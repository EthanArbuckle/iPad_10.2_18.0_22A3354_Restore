void DNS64AnswerCurrentQuestion(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  unint64_t v11;
  char *v12;
  unint64_t v13;
  __int128 v15;
  int v16;
  unsigned int v17;
  void *v18;
  _OWORD v19[2];
  uint64_t v20;
  _OWORD *v21;
  __int128 v22;
  _OWORD v23[17];

  memset(v23, 0, 268);
  v18 = 0;
  v4 = *(_QWORD *)(a1 + 208);
  v5 = *(_QWORD *)(v4 + 80);
  if (v5)
  {
    v17 = 0;
    v15 = 0uLL;
    if (_DNS64GetPrefixes(a1, v5, &v18, (int *)&v17))
    {
      v12 = (char *)v18;
      if (!v18)
        return;
      goto LABEL_14;
    }
    v9 = *(_OWORD *)(a2 + 16);
    v8 = *(_OWORD *)(a2 + 32);
    v19[0] = *(_OWORD *)a2;
    v19[1] = v9;
    v10 = *(_OWORD *)(a2 + 48);
    v20 = v8;
    v22 = v10;
    WORD2(v19[0]) = 28;
    WORD6(v19[0]) = 16;
    LOWORD(v23[0]) = 16;
    v21 = v23;
    v16 = *(_DWORD *)(*(_QWORD *)(a2 + 40) + 4);
    v11 = v17;
    v12 = (char *)v18;
    if (v17)
    {
      v13 = 0;
      do
      {
        while (!nw_nat64_synthesize_v6(&v12[16 * v13], &v16, &v15))
        {
          if (++v13 >= v11)
            goto LABEL_13;
        }
        *(_OWORD *)((char *)v23 + 4) = v15;
        (*(void (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(v4 + 152))(a1, v4, v19, a3);
        ++v13;
      }
      while (*(_QWORD *)(a1 + 208) == v4 && v13 < v11);
    }
LABEL_13:
    if (v12)
LABEL_14:
      free(v12);
  }
}

uint64_t _dns_obj_domain_name_compare(uint64_t a1, uint64_t a2, int a3)
{
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  int v8;

  if (a1 == a2)
    return 0;
  v6 = *(unsigned __int8 **)(a1 + 16);
  v7 = *(unsigned __int8 **)(a2 + 16);
  if (*(_QWORD *)(a1 + 24) == *(_QWORD *)(a2 + 24))
  {
    if (!*(_BYTE *)(a1 + 36))
    {
      *(_DWORD *)(a1 + 32) = domain_name_labels_compute_hash(*(_BYTE **)(a1 + 16));
      *(_BYTE *)(a1 + 36) = 1;
    }
    if (*(_BYTE *)(a2 + 36))
    {
      v8 = *(_DWORD *)(a2 + 32);
    }
    else
    {
      v8 = domain_name_labels_compute_hash(v7);
      *(_DWORD *)(a2 + 32) = v8;
      *(_BYTE *)(a2 + 36) = 1;
    }
    if (*(_DWORD *)(a1 + 32) == v8)
      return domain_name_labels_canonical_compare(v6, v7, a3);
  }
  if ((a3 & 1) == 0)
    return domain_name_labels_canonical_compare(v6, v7, a3);
  else
    return 2;
}

void _dns_obj_domain_name_finalize(uint64_t a1)
{
  void *v2;
  _QWORD *v3;

  if (*(_BYTE *)(a1 + 37))
  {
    v2 = *(void **)(a1 + 16);
    if (v2)
    {
      free(v2);
      *(_QWORD *)(a1 + 16) = 0;
    }
  }
  v3 = *(_QWORD **)(a1 + 40);
  if (v3)
  {
    ref_count_obj_release(v3);
    *(_QWORD *)(a1 + 40) = 0;
  }
}

unsigned __int8 *dns_obj_domain_name_create_with_labels(_BYTE *a1, int *a2)
{
  unsigned __int8 *v2;
  unsigned __int8 *v5;
  int v6;
  _UNKNOWN **v7;
  void (*v8)(unsigned __int8 *);
  int v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  int v12;
  unsigned __int8 *v13;
  int v15;

  v5 = (unsigned __int8 *)malloc_type_calloc(1uLL, 0x30uLL, 0xF1748037uLL);
  if (v5)
  {
    v2 = v5;
    v7 = &_dns_obj_domain_name_kind;
    *((_QWORD *)v5 + 1) = &_dns_obj_domain_name_kind;
    do
    {
      v8 = (void (*)(unsigned __int8 *))v7[2];
      if (v8)
        v8(v2);
      v7 = (_UNKNOWN **)*v7;
    }
    while (v7);
    ++*(_DWORD *)v2;
    v15 = 0;
    v5 = domain_name_labels_create(a1, &v15);
    v6 = v15;
    if (!v15)
    {
      v9 = *v5;
      v10 = v5;
      if (*v5)
      {
        v10 = v5;
        do
        {
          v11 = &v10[v9];
          v12 = v11[1];
          v10 = v11 + 1;
          v9 = v12;
        }
        while (v12);
      }
      *((_QWORD *)v2 + 2) = v5;
      *((_QWORD *)v2 + 3) = v10 - v5 + 1;
      *((_DWORD *)v2 + 8) = 0;
      *((_WORD *)v2 + 18) = 256;
      *((_QWORD *)v2 + 5) = 0;
LABEL_11:
      v6 = 0;
      v13 = v2;
      v2 = 0;
      if (!a2)
        goto LABEL_13;
      goto LABEL_12;
    }
  }
  else
  {
    __break(1u);
  }
  if (v5)
  {
    free(v5);
    v6 = v15;
    if (!v15)
      goto LABEL_11;
  }
  v13 = 0;
  if (a2)
LABEL_12:
    *a2 = v6;
LABEL_13:
  if (v2)
    ref_count_obj_release(v2);
  return v13;
}

unsigned __int8 *dns_obj_domain_name_create_concatenation(_BYTE *a1, _BYTE *a2, _DWORD *a3)
{
  unsigned __int8 *result;
  int v5;
  _OWORD __dst[16];

  v5 = 0;
  memset(__dst, 0, sizeof(__dst));
  domain_name_labels_concatenate(a1, a2, (char *)__dst, &v5);
  if (v5)
  {
    result = 0;
    if (!a3)
      return result;
  }
  else
  {
    result = dns_obj_domain_name_create_with_labels(__dst, &v5);
    if (!a3)
      return result;
  }
  *a3 = v5;
  return result;
}

unsigned __int8 *dns_obj_domain_name_create_with_cstring(char *a1, _DWORD *a2)
{
  int v3;
  char *v4;
  char *v5;
  char *v6;
  char *v7;
  unsigned __int8 *v8;
  int v9;
  int v10;
  int v11;
  char *v12;
  unsigned __int8 *result;
  int v14;
  int v15;
  _OWORD v16[15];
  __int128 v17;

  v17 = 0u;
  memset(v16, 0, sizeof(v16));
  v3 = *a1;
  if (!*a1)
    goto LABEL_23;
  if (v3 == 46)
  {
    if (a1[1])
    {
      v3 = 46;
      goto LABEL_5;
    }
LABEL_23:
    v15 = 0;
    result = dns_obj_domain_name_create_with_labels(v16, &v15);
    if (a2)
LABEL_24:
      *a2 = v15;
    return result;
  }
LABEL_5:
  v4 = (char *)v16;
  while (2)
  {
    if (v4 + 64 >= (char *)&v17 + 15)
      v5 = (char *)&v17 + 15;
    else
      v5 = v4 + 64;
    v6 = v4 + 1;
    v7 = v4 + 1;
    v8 = (unsigned __int8 *)a1;
    do
    {
      a1 = (char *)(v8 + 1);
      if (v3 == 92)
      {
        v3 = *a1;
        if (!*a1)
        {
          v14 = -6750;
          goto LABEL_28;
        }
        a1 = (char *)(v8 + 2);
        if (v3 - 48 <= 9)
        {
          v9 = *a1;
          if ((v9 - 48) <= 9)
          {
            v10 = v8[3];
            if ((v10 - 48) <= 9)
            {
              v11 = 100 * v3 + 10 * (char)v9 + (char)v10;
              v12 = (char *)(v8 + 4);
              if (v11 < 5584)
              {
                a1 = v12;
                LOBYTE(v3) = v11 + 48;
              }
            }
          }
        }
      }
      else if (v3 == 46)
      {
        break;
      }
      if (v7 >= v5)
      {
        v14 = -6751;
        goto LABEL_28;
      }
      *v7++ = v3;
      v3 = *a1;
      v8 = (unsigned __int8 *)a1;
    }
    while (*a1);
    if (v7 != v6)
    {
      *v4 = (_BYTE)v7 - (_BYTE)v6;
      *v7 = 0;
      v3 = *a1;
      v4 = v7;
      if (*a1)
        continue;
      goto LABEL_23;
    }
    break;
  }
  v14 = -6742;
LABEL_28:
  result = 0;
  v15 = v14;
  if (a2)
    goto LABEL_24;
  return result;
}

void *_mdns_cache_metadata_copy_description(_QWORD *a1, int a2)
{
  _QWORD *v4;
  void *v5;
  void *v6;

  v4 = (_QWORD *)mdns_string_builder_create();
  if (!v4)
    return 0;
  v5 = v4;
  if (a2 && mdns_string_builder_append_formatted(v4, "<%s: %p>: ", *(const char **)(a1[2] + 8), a1))
    v6 = 0;
  else
    v6 = mdns_string_builder_copy_string((uint64_t)v5);
  os_release(v5);
  return v6;
}

void _mdns_cache_metadata_finalize(uint64_t a1)
{
  void *v2;
  void *v3;

  v2 = *(void **)(a1 + 24);
  if (v2)
  {
    os_release(v2);
    *(_QWORD *)(a1 + 24) = 0;
  }
  v3 = *(void **)(a1 + 32);
  if (v3)
  {
    os_release(v3);
    *(_QWORD *)(a1 + 32) = 0;
  }
}

uint64_t mdns_cache_metadata_create()
{
  uint64_t v0;
  uint64_t v1;
  _UNKNOWN **v2;
  void (*v3)(uint64_t);

  v0 = _os_object_alloc(OS_mdns_cache_metadata, 56);
  v1 = v0;
  if (v0)
  {
    v2 = &_mdns_cache_metadata_kind;
    *(_QWORD *)(v0 + 16) = &_mdns_cache_metadata_kind;
    do
    {
      v3 = (void (*)(uint64_t))v2[2];
      if (v3)
        v3(v1);
      v2 = (_UNKNOWN **)*v2;
    }
    while (v2);
    *(_QWORD *)(v1 + 40) = 0;
  }
  return v1;
}

void mdns_cache_metadata_set_extended_dns_error(uint64_t a1, void *object)
{
  void *v4;

  if (object)
    os_retain(object);
  v4 = *(void **)(a1 + 32);
  if (v4)
    os_release(v4);
  *(_QWORD *)(a1 + 32) = object;
}

NSObject *_mdns_dispatch_create_monotonic_timer(unsigned int a1, uint64_t a2, unsigned int a3, NSObject *a4)
{
  NSObject *v7;
  int v8;
  uint64_t v9;
  dispatch_time_t v10;

  v7 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, a4);
  if (v7)
  {
    if (a3 >= 0x64)
      v8 = 100;
    else
      v8 = a3;
    v9 = (10000 * v8) * (unint64_t)a1;
    v10 = dispatch_time(0x8000000000000000, 1000000 * a1);
    dispatch_source_set_timer(v7, v10, a2, v9);
  }
  return v7;
}

char *_mdns_multicast_delay_histogram_copy_description(uint64_t a1)
{
  unsigned int v2;
  uint64_t i;
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char *v9[2];

  v2 = 0;
  v9[0] = 0;
  for (i = 28; i != 62; i += 2)
    v2 += *(unsigned __int16 *)(a1 + i);
  if (v2)
  {
    v8 = *(unsigned __int16 *)(a1 + 28);
    v7 = *(unsigned __int16 *)(a1 + 32) + *(unsigned __int16 *)(a1 + 30) + *(unsigned __int16 *)(a1 + 34);
    v6 = *(unsigned __int16 *)(a1 + 38) + *(unsigned __int16 *)(a1 + 36) + *(unsigned __int16 *)(a1 + 40);
    v4 = vaddlvq_u16(*(uint16x8_t *)(a1 + 42));
    _mdns_multicast_delay_histogram_calculate_percentile_rank(a1, 50);
    _mdns_multicast_delay_histogram_calculate_percentile_rank(a1, 75);
    _mdns_multicast_delay_histogram_calculate_percentile_rank(a1, 90);
    _mdns_multicast_delay_histogram_calculate_percentile_rank(a1, 95);
    _mdns_multicast_delay_histogram_calculate_percentile_rank(a1, 99);
    asprintf(v9, "delay distribution: [0] %u(%u%%) [1] %u(%u%%) [4] %u(%u%%) [7] %u(%u%%) [15] %u(%u%%) [20] %u(%u%%) [INF], cache hit rate: %u%%(hit: %u, miss:%u), percentile rank: P50(%us), P75(%us), P90(%us), P95(%us), P99(%us)", v8, 100 * (int)v8 / v2, v7, 100 * (int)v7 / v2, v6, 100 * (int)v6 / v2, v4);
  }
  else
  {
    asprintf(v9, "<< No Data Available >>");
  }
  return v9[0];
}

uint64_t _mdns_multicast_delay_histogram_calculate_percentile_rank(uint64_t a1, int a2)
{
  int v2;
  uint64_t i;
  unint64_t v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v8;

  v2 = 0;
  for (i = 28; i != 62; i += 2)
    v2 += *(unsigned __int16 *)(a1 + i);
  if (!v2)
    return 0;
  v4 = 0;
  v5 = 0;
  v6 = (v2 * a2 + 99) / 0x64u;
  while (1)
  {
    v5 += *(unsigned __int16 *)(a1 + 28 + 2 * v4);
    if (v5 >= v6)
      break;
    if (++v4 == 17)
      return 0;
  }
  if (v4 == 15)
    v8 = 18;
  else
    v8 = 0;
  if (v4 <= 0xE)
    return (v4 + 1);
  else
    return v8;
}

uint64_t mdns_multicast_delay_histogram_create()
{
  uint64_t v0;
  uint64_t v1;
  _UNKNOWN **v2;
  void (*v3)(uint64_t);

  v0 = _os_object_alloc(OS_mdns_multicast_delay_histogram, 64);
  v1 = v0;
  if (v0)
  {
    v2 = &_mdns_multicast_delay_histogram_kind;
    *(_QWORD *)(v0 + 16) = &_mdns_multicast_delay_histogram_kind;
    do
    {
      v3 = (void (*)(uint64_t))v2[2];
      if (v3)
        v3(v1);
      v2 = (_UNKNOWN **)*v2;
    }
    while (v2);
  }
  return v1;
}

const char *mdns_signed_result_get_data(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  const char *result;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t buf[4];
  uint64_t v9;

  v7 = 0;
  v3 = *(_QWORD *)(a1 + 16);
  result = (const char *)(*(uint64_t (**)(void))(v3 + 48))();
  if (!result)
  {
    if (_mdns_signed_result_log_s_once != -1)
      dispatch_once(&_mdns_signed_result_log_s_once, &__block_literal_global_651);
    v5 = _mdns_signed_result_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_signed_result_log_s_log, OS_LOG_TYPE_FAULT))
    {
      v6 = *(_QWORD *)(v3 + 8);
      *(_DWORD *)buf = 136446210;
      v9 = v6;
      _os_log_fault_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "mdns_signed_result_get_data() failed for %{public}s", buf, 0xCu);
    }
    v7 = 0;
    result = "";
  }
  if (a2)
    *a2 = v7;
  return result;
}

void ___mdns_signed_result_log_block_invoke(id a1)
{
  _mdns_signed_result_log_s_log = (uint64_t)os_log_create("com.apple.mdns", "signed_result");
}

uint64_t _mdns_signed_browse_result_create_ex(const unsigned __int8 *a1, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned __int16 a5, int *a6)
{
  int v12;
  size_t v13;
  size_t v14;
  unint64_t v15;
  unsigned __int8 *v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  uint64_t v21;
  int v22;
  int v24;
  char __s[1009];

  bzero(__s, 0x3F1uLL);
  v12 = DomainNameToString(a2, 0, (unsigned __int8 *)__s, 0);
  if (v12)
  {
    v22 = v12;
    v21 = 0;
  }
  else
  {
    v13 = strlen(__s);
    if (v13 >> 16)
    {
      v21 = 0;
      v22 = -6743;
    }
    else
    {
      v14 = v13;
      v15 = v13 + 58;
      v16 = (unsigned __int8 *)malloc_type_calloc(1uLL, v13 + 58, 0xF1748037uLL);
      if (!v16)
        __break(1u);
      v17 = (uint64_t)v16;
      v18 = (uint64_t)(v16 + 32);
      uuid_copy(v16 + 32, a1);
      v19 = _mdns_signed_result_compute_metadata_hash(v18, a3, a4, a5);
      *(_DWORD *)(v17 + 48) = 5;
      *(_DWORD *)(v17 + 52) = v19;
      *(_WORD *)(v17 + 56) = v14;
      memcpy((void *)(v17 + 58), __s, v14);
      v20 = _mdns_necp_sign_result(v17, v15);
      if (v20 || (v20 = _mdns_necp_validate_result(v17, v15), (v24 = v20) != 0))
      {
        v22 = v20;
        v21 = 0;
      }
      else
      {
        v21 = _mdns_signed_browse_result_create_no_copy(a2, v17, v15, &v24);
        v22 = v24;
        if (!v24)
          goto LABEL_7;
      }
      free((void *)v17);
    }
  }
LABEL_7:
  if (a6)
    *a6 = v22;
  return v21;
}

uint64_t _mdns_signed_result_compute_metadata_hash(uint64_t a1, unsigned int a2, unsigned __int8 *a3, unsigned int a4)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  int v10;
  unsigned int v12;

  v4 = 0;
  v5 = -2128831035;
  do
    v5 = 16777619 * (v5 ^ *(unsigned __int8 *)(a1 + v4++));
  while (v4 != 16);
  v6 = 0;
  v12 = bswap32(a2);
  v7 = v5;
  do
    v7 = 16777619 * (v7 ^ *((unsigned __int8 *)&v12 + v6++));
  while (v6 != 4);
  v8 = 16777619 * ((16777619 * (v5 ^ (a4 >> 8))) ^ a4);
  if (a4)
  {
    v9 = a4;
    do
    {
      v10 = *a3++;
      v8 = 16777619 * (v8 ^ v10);
      --v9;
    }
    while (v9);
  }
  return v8 & 0xFFFFFF ^ HIBYTE(v8) | ((v7 ^ (v7 >> 8)) << 24);
}

uint64_t _mdns_necp_sign_result(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t shared_fd;
  uint64_t result;
  NSObject *v6;
  _BOOL4 v7;
  unsigned int v8;
  uint8_t buf[4];
  uint64_t v10;

  v2 = a2 - 32;
  if (a2 < 0x20)
    return 4294960546;
  v8 = 0;
  shared_fd = _mdns_necp_get_shared_fd((int *)&v8);
  result = v8;
  if (!v8)
  {
    result = necp_client_action(shared_fd, 20, a1 + 32, v2, a1, 32);
    v8 = result;
    if ((_DWORD)result)
    {
      if (*__error())
      {
        v8 = *__error();
        if (!v8)
          return 0;
      }
      else
      {
        v8 = -6700;
      }
      if (_mdns_signed_result_log_s_once != -1)
        dispatch_once(&_mdns_signed_result_log_s_once, &__block_literal_global_651);
      v6 = _mdns_signed_result_log_s_log;
      v7 = os_log_type_enabled((os_log_t)_mdns_signed_result_log_s_log, OS_LOG_TYPE_ERROR);
      result = v8;
      if (v7)
      {
        *(_DWORD *)buf = 134217984;
        v10 = (int)v8;
        _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Failed to sign data: %{mdns:err}ld", buf, 0xCu);
        return v8;
      }
    }
  }
  return result;
}

uint64_t _mdns_necp_validate_result(uint64_t a1, uint64_t a2)
{
  uint64_t shared_fd;
  uint64_t result;
  NSObject *v6;
  _BOOL4 v7;
  unsigned int v8;
  uint8_t buf[4];
  uint64_t v10;

  v8 = 0;
  shared_fd = _mdns_necp_get_shared_fd((int *)&v8);
  result = v8;
  if (!v8)
  {
    result = necp_client_action(shared_fd, 23, a1, a2, 0, 0);
    v8 = result;
    if ((_DWORD)result)
    {
      if (*__error())
      {
        v8 = *__error();
        if (!v8)
          return 0;
      }
      else
      {
        v8 = -6700;
      }
      if (_mdns_signed_result_log_s_once != -1)
        dispatch_once(&_mdns_signed_result_log_s_once, &__block_literal_global_651);
      v6 = _mdns_signed_result_log_s_log;
      v7 = os_log_type_enabled((os_log_t)_mdns_signed_result_log_s_log, OS_LOG_TYPE_ERROR);
      result = v8;
      if (v7)
      {
        *(_DWORD *)buf = 134217984;
        v10 = (int)v8;
        _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Failed to validate data: %{mdns:err}ld", buf, 0xCu);
        return v8;
      }
    }
  }
  return result;
}

uint64_t _mdns_signed_browse_result_create_no_copy(_BYTE *a1, uint64_t a2, uint64_t a3, int *a4)
{
  uint64_t v8;
  uint64_t v9;
  _UNKNOWN **v10;
  void (*v11)(uint64_t);
  int v12;
  uint64_t i;
  int v14;

  v8 = _os_object_alloc(OS_mdns_signed_browse_result, 56);
  v9 = v8;
  if (!v8)
  {
    v14 = -6728;
    if (!a4)
      return v9;
    goto LABEL_9;
  }
  v10 = &_mdns_signed_browse_result_kind;
  *(_QWORD *)(v8 + 16) = &_mdns_signed_browse_result_kind;
  do
  {
    v11 = (void (*)(uint64_t))v10[2];
    if (v11)
      v11(v9);
    v10 = (_UNKNOWN **)*v10;
  }
  while (v10);
  DomainNameDupEx(a1, (_QWORD *)(v9 + 24), 0);
  v12 = -2128831035;
  for (i = 32; i != 48; ++i)
    v12 = 16777619 * (v12 ^ *(unsigned __int8 *)(a2 + i));
  v14 = 0;
  *(_DWORD *)(v9 + 48) = v12;
  *(_QWORD *)(v9 + 32) = a2;
  *(_QWORD *)(v9 + 40) = a3;
  if (a4)
LABEL_9:
    *a4 = v14;
  return v9;
}

void *_mdns_signed_browse_result_copy_description(_QWORD *a1, int a2, int a3)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  void *v9;
  char out[40];

  v6 = (_QWORD *)mdns_string_builder_create();
  if (!v6)
    return 0;
  v7 = v6;
  if (a2 && mdns_string_builder_append_formatted(v6, "<%s: %p>: ", *(const char **)(a1[2] + 8), a1))
  {
LABEL_6:
    v9 = 0;
    goto LABEL_7;
  }
  v8 = a1[4];
  memset(out, 0, 37);
  uuid_unparse((const unsigned __int8 *)(v8 + 32), out);
  v9 = 0;
  if (!mdns_string_builder_append_formatted(v7, "client ID: %s, service instance: ", out))
  {
    if (!_mdns_string_builder_append_domain_name_string(v7, v8 + 58, *(unsigned __int16 *)(v8 + 56), a3))
    {
      v9 = mdns_string_builder_copy_string((uint64_t)v7);
      goto LABEL_7;
    }
    goto LABEL_6;
  }
LABEL_7:
  os_release(v7);
  return v9;
}

void _mdns_signed_browse_result_finalize(_QWORD *a1)
{
  void *v2;
  void *v3;

  v2 = (void *)a1[3];
  if (v2)
  {
    free(v2);
    a1[3] = 0;
  }
  v3 = (void *)a1[4];
  if (v3)
  {
    free(v3);
    a1[4] = 0;
  }
  a1[5] = 0;
}

uint64_t _mdns_signed_browse_result_get_data(uint64_t a1, _QWORD *a2)
{
  if (a2)
    *a2 = *(_QWORD *)(a1 + 40);
  return *(_QWORD *)(a1 + 32);
}

uint64_t _mdns_signed_browse_result_get_uuid(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32) + 32;
}

uint64_t _mdns_string_builder_append_domain_name_string(_QWORD *a1, uint64_t a2, unint64_t a3, int a4)
{
  char v8[1009];
  _BYTE v9[72];

  if (a3 > 0x3F0)
    return mdns_string_builder_append_formatted(a1, "«TOO LONG: %zu chars»");
  if (!a4)
    return mdns_string_builder_append_formatted(a1, "%.*s");
  memset(v9, 0, 64);
  bzero(v8, 0x3F1uLL);
  __memcpy_chk(v8, a2, a3, 1009);
  v8[a3] = 0;
  DNSMessagePrintObfuscatedString((uint64_t)v9, v8);
  return mdns_string_builder_append_formatted(a1, "%s");
}

uint64_t _mdns_necp_get_shared_fd(int *a1)
{
  int v2;
  NSObject *v4;
  int v5;
  uint64_t v6;

  os_unfair_lock_lock((os_unfair_lock_t)&_mdns_necp_get_shared_fd_s_lock);
  if ((_mdns_necp_get_shared_fd_s_fd & 0x80000000) == 0
    || (_mdns_necp_get_shared_fd_s_fd = necp_open(0), (_mdns_necp_get_shared_fd_s_fd & 0x80000000) == 0))
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&_mdns_necp_get_shared_fd_s_lock);
    v2 = 0;
    goto LABEL_4;
  }
  if (*__error())
  {
    v2 = *__error();
    os_unfair_lock_unlock((os_unfair_lock_t)&_mdns_necp_get_shared_fd_s_lock);
    if (!v2)
      goto LABEL_4;
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&_mdns_necp_get_shared_fd_s_lock);
    v2 = -6700;
  }
  if (_mdns_signed_result_log_s_once != -1)
    dispatch_once(&_mdns_signed_result_log_s_once, &__block_literal_global_651);
  v4 = _mdns_signed_result_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_signed_result_log_s_log, OS_LOG_TYPE_ERROR))
  {
    v5 = 134217984;
    v6 = v2;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Failed to create NECP file descriptor: %{mdns:err}ld", (uint8_t *)&v5, 0xCu);
  }
LABEL_4:
  if (a1)
    *a1 = v2;
  return _mdns_necp_get_shared_fd_s_fd;
}

BOOL mdns_signed_browse_result_contains(uint64_t a1, unsigned __int8 *a2, unsigned int a3)
{
  uint64_t v3;
  unsigned int v4;
  int v5;
  unsigned int v7;

  if (!a3)
    return DomainNameEqual(*(unsigned __int8 **)(a1 + 24), a2) != 0;
  v3 = 0;
  v4 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 52);
  v5 = *(_DWORD *)(a1 + 48);
  v7 = bswap32(a3);
  do
    LOWORD(v5) = 403 * (v5 ^ *((unsigned __int8 *)&v7 + v3++));
  while (v3 != 4);
  return HIBYTE(v4) == (v5 ^ BYTE1(v5))
      && DomainNameEqual(*(unsigned __int8 **)(a1 + 24), a2) != 0;
}

uint64_t _mdns_signed_resolve_result_create_no_copy(_BYTE *a1, uint64_t a2, uint64_t a3, int *a4)
{
  uint64_t v8;
  uint64_t v9;
  _UNKNOWN **v10;
  void (*v11)(uint64_t);
  int v12;
  uint64_t i;
  int v14;

  v8 = _os_object_alloc(OS_mdns_signed_resolve_result, 56);
  v9 = v8;
  if (!v8)
  {
    v14 = -6728;
    if (!a4)
      return v9;
    goto LABEL_9;
  }
  v10 = &_mdns_signed_resolve_result_kind;
  *(_QWORD *)(v8 + 16) = &_mdns_signed_resolve_result_kind;
  do
  {
    v11 = (void (*)(uint64_t))v10[2];
    if (v11)
      v11(v9);
    v10 = (_UNKNOWN **)*v10;
  }
  while (v10);
  DomainNameDupEx(a1, (_QWORD *)(v9 + 24), 0);
  v12 = -2128831035;
  for (i = 32; i != 48; ++i)
    v12 = 16777619 * (v12 ^ *(unsigned __int8 *)(a2 + i));
  v14 = 0;
  *(_DWORD *)(v9 + 48) = v12;
  *(_QWORD *)(v9 + 32) = a2;
  *(_QWORD *)(v9 + 40) = a3;
  if (a4)
LABEL_9:
    *a4 = v14;
  return v9;
}

void *_mdns_signed_resolve_result_copy_description(_QWORD *a1, int a2, int a3)
{
  _QWORD *v6;
  _QWORD *v7;
  void *v8;
  uint64_t v9;
  uint64_t v11;
  char v12;
  char v13;
  _QWORD v14[2];
  unsigned __int16 v15;
  int v16;
  __int16 v17;
  const char *v18;
  uint64_t v19;
  __int16 v20;
  char out[40];

  v6 = (_QWORD *)mdns_string_builder_create();
  if (!v6)
    return 0;
  v7 = v6;
  if (!a2 || !mdns_string_builder_append_formatted(v6, "<%s: %p>: ", *(const char **)(a1[2] + 8), a1))
  {
    v9 = a1[4];
    memset(out, 0, 37);
    uuid_unparse((const unsigned __int8 *)(v9 + 32), out);
    v8 = 0;
    if (mdns_string_builder_append_formatted(v7, "client ID: %s", out))
      goto LABEL_6;
    v11 = 0;
    v14[0] = "service instance";
    v14[1] = v9 + 62;
    v15 = *(_WORD *)(v9 + 56);
    v16 = 0;
    v17 = 0;
    v18 = "hostname";
    v19 = v9 + 62 + v15;
    v20 = *(_WORD *)(v9 + 60);
    v12 = 1;
    while (1)
    {
      v13 = v12;
      if (mdns_string_builder_append_formatted(v7, ", %s: ", (const char *)v14[3 * v11])
        || _mdns_string_builder_append_domain_name_string(v7, v14[3 * v11 + 1], LOWORD(v14[3 * v11 + 2]), a3))
      {
        break;
      }
      v12 = 0;
      v11 = 1;
      if ((v13 & 1) == 0)
      {
        if (mdns_string_builder_append_formatted(v7, ", port: %u", bswap32(*(unsigned __int16 *)(v9 + 58)) >> 16))break;
        v8 = mdns_string_builder_copy_string((uint64_t)v7);
        goto LABEL_6;
      }
    }
  }
  v8 = 0;
LABEL_6:
  os_release(v7);
  return v8;
}

void _mdns_signed_resolve_result_finalize(_QWORD *a1)
{
  void *v2;
  void *v3;

  v2 = (void *)a1[3];
  if (v2)
  {
    free(v2);
    a1[3] = 0;
  }
  v3 = (void *)a1[4];
  if (v3)
  {
    free(v3);
    a1[4] = 0;
  }
  a1[5] = 0;
}

uint64_t _mdns_signed_resolve_result_get_data(uint64_t a1, _QWORD *a2)
{
  if (a2)
    *a2 = *(_QWORD *)(a1 + 40);
  return *(_QWORD *)(a1 + 32);
}

uint64_t _mdns_signed_resolve_result_get_uuid(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32) + 32;
}

uint64_t mdns_signed_resolve_result_create_from_data(uint64_t a1, size_t a2, int *a3)
{
  size_t v4;
  size_t v6;
  BOOL v7;
  unint64_t v8;
  unint64_t v9;
  int v11;
  void *v12;
  uint64_t result;
  int v14;
  int v15;
  _OWORD v16[16];
  char v17[1009];

  v4 = a2 - 62;
  if (a2 < 0x3E)
  {
    result = 0;
    v14 = -6743;
  }
  else if (*(_DWORD *)(a1 + 48) == 6)
  {
    v6 = *(unsigned __int16 *)(a1 + 56);
    v7 = v4 >= v6;
    v8 = v4 - v6;
    if (v7 && (v9 = *(unsigned __int16 *)(a1 + 60), v8 >= v9))
    {
      if (v9 > 0x3F0)
      {
        result = 0;
        v14 = -6744;
      }
      else
      {
        bzero(v17, 0x3F1uLL);
        __memcpy_chk(v17, a1 + v6 + 62, v9, 1009);
        v17[v9] = 0;
        memset(v16, 0, sizeof(v16));
        v11 = DomainNameFromString(v16, v17);
        if (!v11)
        {
          v11 = _mdns_necp_validate_result(a1, a2);
          if (!v11)
          {
            v15 = 0;
            v12 = malloc_type_malloc(a2, 0xA172743EuLL);
            if (v12)
            {
              v9 = (unint64_t)v12;
              memcpy(v12, (const void *)a1, a2);
              result = _mdns_signed_resolve_result_create_no_copy(v16, v9, a2, &v15);
              if (result)
              {
LABEL_11:
                v14 = v15;
                goto LABEL_12;
              }
            }
            else
            {
              __break(1u);
            }
            free((void *)v9);
            result = 0;
            goto LABEL_11;
          }
        }
        v14 = v11;
        result = 0;
      }
    }
    else
    {
      result = 0;
      v14 = -6750;
    }
  }
  else
  {
    result = 0;
    v14 = -6756;
  }
LABEL_12:
  if (a3)
    *a3 = v14;
  return result;
}

BOOL mdns_signed_resolve_result_contains(uint64_t a1, char *a2, unsigned int a3)
{
  uint64_t v4;
  unsigned int v5;
  int v6;
  unsigned int v8;
  _OWORD v9[16];

  v4 = 0;
  v5 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 52);
  v6 = *(_DWORD *)(a1 + 48);
  v8 = bswap32(a3);
  do
    LOWORD(v6) = 403 * (v6 ^ *((unsigned __int8 *)&v8 + v4++));
  while (v4 != 4);
  if (HIBYTE(v5) != (v6 ^ BYTE1(v6)))
    return 0;
  memset(v9, 0, sizeof(v9));
  return !DomainNameFromString(v9, a2)
      && DomainNameEqual(*(unsigned __int8 **)(a1 + 24), (unsigned __int8 *)v9) != 0;
}

unsigned __int8 *mdns_signed_hostname_result_create_ipv4(uint64_t a1, _DWORD *a2, int *a3)
{
  __int128 v4;
  uint64_t v5;
  int v6;

  v5 = 0;
  *((_QWORD *)&v4 + 1) = 0;
  v6 = 0;
  LOWORD(v4) = 528;
  WORD1(v4) = *(_WORD *)(*(_QWORD *)(a1 + 32) + 58);
  DWORD1(v4) = *a2;
  return _mdns_signed_hostname_result_create(a1, &v4, a3);
}

unsigned __int8 *_mdns_signed_hostname_result_create(uint64_t a1, __int128 *a2, int *a3)
{
  uint64_t v6;
  uint64_t v7;
  _UNKNOWN **v8;
  void (*v9)(uint64_t);
  uint64_t v10;
  size_t v11;
  unsigned __int8 *result;
  unsigned __int8 *v13;
  __int128 v14;
  size_t v15;
  int v16;
  void *v17;

  v6 = _os_object_alloc(OS_mdns_signed_hostname_result, 40);
  v7 = v6;
  if (v6)
  {
    v8 = &_mdns_signed_hostname_result_kind;
    *(_QWORD *)(v6 + 16) = &_mdns_signed_hostname_result_kind;
    do
    {
      v9 = (void (*)(uint64_t))v8[2];
      if (v9)
        v9(v7);
      v8 = (_UNKNOWN **)*v8;
    }
    while (v8);
    v10 = *(_QWORD *)(a1 + 32);
    v11 = *(unsigned __int16 *)(v10 + 60) + 88;
    *(_QWORD *)(v7 + 32) = v11;
    result = (unsigned __int8 *)malloc_type_calloc(1uLL, v11, 0xF1748037uLL);
    if (!result)
    {
      __break(1u);
      return result;
    }
    v13 = result;
    *(_QWORD *)(v7 + 24) = result;
    uuid_copy(result + 32, (const unsigned __int8 *)(v10 + 32));
    *((_QWORD *)v13 + 6) = 4;
    v14 = *a2;
    *(_OWORD *)(v13 + 68) = *(__int128 *)((char *)a2 + 12);
    *(_OWORD *)(v13 + 56) = v14;
    v15 = *(unsigned __int16 *)(v10 + 60);
    *((_DWORD *)v13 + 21) = v15;
    memcpy(v13 + 88, (const void *)(v10 + *(unsigned __int16 *)(v10 + 56) + 62), v15);
    v16 = _mdns_necp_sign_result(*(_QWORD *)(v7 + 24), *(_QWORD *)(v7 + 32));
    if (v16 || (v16 = _mdns_necp_validate_result(*(_QWORD *)(v7 + 24), *(_QWORD *)(v7 + 32))) != 0)
    {
      v17 = (void *)v7;
      v7 = 0;
    }
    else
    {
      v17 = 0;
    }
  }
  else
  {
    v17 = 0;
    v16 = -6728;
  }
  if (a3)
    *a3 = v16;
  if (v17)
    os_release(v17);
  return (unsigned __int8 *)v7;
}

void *_mdns_signed_hostname_result_copy_description(_QWORD *a1, int a2, int a3)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  void *v9;
  _OWORD v11[2];
  char out[40];

  v6 = (_QWORD *)mdns_string_builder_create();
  if (!v6)
    return 0;
  v7 = v6;
  if (a2 && mdns_string_builder_append_formatted(v6, "<%s: %p>: ", *(const char **)(a1[2] + 8), a1))
  {
LABEL_8:
    v9 = 0;
    goto LABEL_9;
  }
  v8 = a1[3];
  memset(out, 0, 37);
  uuid_unparse((const unsigned __int8 *)(v8 + 32), out);
  v9 = 0;
  if (!mdns_string_builder_append_formatted(v7, "client ID: %s, hostname: ", out))
  {
    if (!_mdns_string_builder_append_domain_name_string(v7, v8 + 88, *(unsigned int *)(v8 + 84), a3)
      && !mdns_string_builder_append_formatted(v7, ", address: "))
    {
      v11[0] = *(_OWORD *)(v8 + 56);
      *(_OWORD *)((char *)v11 + 12) = *(_OWORD *)(v8 + 68);
      if (!mdns_string_builder_append_sockaddr_description(v7, (uint64_t)v11, a3))
      {
        v9 = mdns_string_builder_copy_string((uint64_t)v7);
        goto LABEL_9;
      }
    }
    goto LABEL_8;
  }
LABEL_9:
  os_release(v7);
  return v9;
}

void _mdns_signed_hostname_result_finalize(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 24);
  if (v2)
  {
    free(v2);
    *(_QWORD *)(a1 + 24) = 0;
  }
  *(_QWORD *)(a1 + 32) = 0;
}

uint64_t _mdns_signed_hostname_result_get_data(uint64_t a1, _QWORD *a2)
{
  if (a2)
    *a2 = *(_QWORD *)(a1 + 32);
  return *(_QWORD *)(a1 + 24);
}

uint64_t _mdns_signed_hostname_result_get_uuid(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24) + 32;
}

unsigned __int8 *mdns_signed_hostname_result_create_ipv6(uint64_t a1, _OWORD *a2, int a3, int *a4)
{
  _DWORD v5[7];

  memset(&v5[1], 0, 24);
  LOWORD(v5[0]) = 7708;
  HIWORD(v5[0]) = *(_WORD *)(*(_QWORD *)(a1 + 32) + 58);
  *(_OWORD *)&v5[2] = *a2;
  if (LOBYTE(v5[2]) == 254 && (BYTE1(v5[2]) & 0xC0) == 0x80)
    v5[6] = a3;
  return _mdns_signed_hostname_result_create(a1, (__int128 *)v5, a4);
}

uint64_t _dnssec_obj_rrset_compare()
{
  return 2;
}

_QWORD *_dnssec_obj_rrset_finalize(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *result;
  _QWORD *v4;

  v2 = *(_QWORD **)(a1 + 16);
  if (v2)
  {
    ref_count_obj_release(v2);
    *(_QWORD *)(a1 + 16) = 0;
  }
  result = *(_QWORD **)(a1 + 24);
  if (result)
  {
    do
    {
      v4 = (_QWORD *)result[1];
      free(result);
      result = v4;
    }
    while (v4);
  }
  return result;
}

_QWORD *dnssec_obj_rrset_create(_DWORD *a1, int a2, _DWORD *a3)
{
  _QWORD *result;
  _QWORD *v7;
  _UNKNOWN **v8;
  void (*v9)(_QWORD *);

  result = malloc_type_calloc(1uLL, 0x40uLL, 0xF1748037uLL);
  if (result)
  {
    v7 = result;
    v8 = &_dnssec_obj_rrset_kind;
    result[1] = &_dnssec_obj_rrset_kind;
    do
    {
      v9 = (void (*)(_QWORD *))v8[2];
      if (v9)
        v9(v7);
      v8 = (_UNKNOWN **)*v8;
    }
    while (v8);
    ++*(_DWORD *)v7;
    v7[2] = a1;
    ++*a1;
    v7[4] = 0;
    v7[5] = 0;
    *((_DWORD *)v7 + 12) = -6718;
    *((_BYTE *)v7 + 60) = 0;
    *((_DWORD *)v7 + 14) = a2;
    ++*(_DWORD *)v7;
    if (a3)
      *a3 = 0;
    ref_count_obj_release(v7);
    return v7;
  }
  else
  {
    __break(1u);
  }
  return result;
}

uint64_t dnssec_obj_rrset_get_rr_type(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;
  NSObject *v3;
  int v5;
  const char *v6;
  __int16 v7;
  const char *v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  uint64_t v14;

  if (*(_QWORD *)(a1 + 32))
  {
    v1 = **(_QWORD **)(a1 + 24);
    result = *(unsigned __int16 *)(v1 + 4);
    if ((_DWORD)result == 46)
      return __rev16(*(unsigned __int16 *)(*(_QWORD *)(v1 + 40) + 4));
    return result;
  }
  v3 = mDNSLogCategory_DNSSEC;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
  {
    result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
    if (!(_DWORD)result)
      return result;
LABEL_13:
    v5 = 136447234;
    v6 = "rrset->rr_count > 0";
    v7 = 2082;
    v8 = "";
    v9 = 2082;
    v10 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
    v11 = 1024;
    v12 = 123;
    v13 = 2048;
    v14 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", (uint8_t *)&v5, 0x30u);
    return 0;
  }
  v3 = mDNSLogCategory_DNSSEC_redacted;
  result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
  if ((_DWORD)result)
    goto LABEL_13;
  return result;
}

uint64_t dnssec_obj_rrset_get_rr_class(uint64_t a1)
{
  uint64_t result;
  NSObject *v2;
  int v4;
  const char *v5;
  __int16 v6;
  const char *v7;
  __int16 v8;
  const char *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  uint64_t v13;

  if (*(_QWORD *)(a1 + 32))
    return *(unsigned __int16 *)(**(_QWORD **)(a1 + 24) + 6);
  v2 = mDNSLogCategory_DNSSEC;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
  {
    result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
    if ((_DWORD)result)
    {
LABEL_12:
      v4 = 136447234;
      v5 = "me->rr_count > 0";
      v6 = 2082;
      v7 = "";
      v8 = 2082;
      v9 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
      v10 = 1024;
      v11 = 138;
      v12 = 2048;
      v13 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", (uint8_t *)&v4, 0x30u);
      return 0;
    }
  }
  else
  {
    v2 = mDNSLogCategory_DNSSEC_redacted;
    result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
    if ((_DWORD)result)
      goto LABEL_12;
  }
  return result;
}

uint64_t dnssec_obj_rrset_get_time_received(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t result;
  NSObject *v4;
  int v8;
  const char *v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  uint64_t v17;

  if (!*(_QWORD *)(a1 + 32))
  {
    v4 = mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
      if (!(_DWORD)result)
        return result;
    }
    else
    {
      v4 = mDNSLogCategory_DNSSEC_redacted;
      result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
      if (!(_DWORD)result)
        return result;
    }
    v8 = 136447234;
    v9 = "me->rr_count > 0";
    v10 = 2082;
    v11 = "";
    v12 = 2082;
    v13 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
    v14 = 1024;
    v15 = 147;
    v16 = 2048;
    v17 = 0;
LABEL_33:
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", (uint8_t *)&v8, 0x30u);
    return 0;
  }
  v1 = *(_QWORD *)(**(_QWORD **)(a1 + 24) + 56);
  if (!v1)
  {
    v4 = mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
      if (!(_DWORD)result)
        return result;
    }
    else
    {
      v4 = mDNSLogCategory_DNSSEC_redacted;
      result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
      if (!(_DWORD)result)
        return result;
    }
    v8 = 136447234;
    v9 = "rr->dnssec != NULL";
    v10 = 2082;
    v11 = "";
    v12 = 2082;
    v13 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
    v14 = 1024;
    v15 = 149;
    v16 = 2048;
    v17 = 0;
    goto LABEL_33;
  }
  v2 = *(_QWORD *)(v1 + 16);
  if (v2)
    return *(unsigned int *)(v2 + 80);
  v4 = mDNSLogCategory_DNSSEC;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
  {
    result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
    if ((_DWORD)result)
    {
LABEL_32:
      v8 = 136447234;
      v9 = "cr != NULL";
      v10 = 2082;
      v11 = "";
      v12 = 2082;
      v13 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
      v14 = 1024;
      v15 = 152;
      v16 = 2048;
      v17 = 0;
      goto LABEL_33;
    }
  }
  else
  {
    v4 = mDNSLogCategory_DNSSEC_redacted;
    result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
    if ((_DWORD)result)
      goto LABEL_32;
  }
  return result;
}

uint64_t dnssec_obj_rrset_get_rr_expire_time(uint64_t a1)
{
  NSObject *v2;
  int v5;
  const char *v6;
  __int16 v7;
  const char *v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  uint64_t v14;

  if (*(_QWORD *)(a1 + 32))
    return resource_record_get_expiration_time(*(_QWORD *)(**(_QWORD **)(a1 + 24) + 56));
  v2 = mDNSLogCategory_DNSSEC;
  if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_DNSSEC != mDNSLogCategory_State)
  {
    v2 = mDNSLogCategory_DNSSEC_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT))
      return 0;
    goto LABEL_11;
  }
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
  {
LABEL_11:
    v5 = 136447234;
    v6 = "me->rr_count > 0";
    v7 = 2082;
    v8 = "";
    v9 = 2082;
    v10 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
    v11 = 1024;
    v12 = 185;
    v13 = 2048;
    v14 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", (uint8_t *)&v5, 0x30u);
  }
  return 0;
}

unsigned __int8 *dnssec_obj_rrset_copy_signer_name(uint64_t a1, int *a2)
{
  int v3;
  unsigned __int8 *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 *result;
  uint64_t v13;
  BOOL v14;
  int v15;

  v3 = -6727;
  if (!*(_QWORD *)(a1 + 32) || (v15 = -6727, (v4 = *(unsigned __int8 **)(a1 + 24)) == 0))
  {
    result = 0;
    goto LABEL_27;
  }
  while (1)
  {
    v5 = *(_QWORD *)v4;
    if (**(unsigned __int8 **)v4 != 240)
    {
      if (*(_WORD *)(v5 + 4) == 46)
      {
        result = dnssec_obj_domain_name_create_with_labels((unsigned __int8 *)(*(_QWORD *)(v5 + 40) + 22), 1, &v15);
        v3 = v15;
        if (v15)
          goto LABEL_27;
      }
      else
      {
        result = 0;
      }
      goto LABEL_20;
    }
    v6 = *(_QWORD *)(v5 + 56);
    if (!v6)
    {
      result = 0;
      v3 = -6700;
      goto LABEL_27;
    }
    if (*(_DWORD *)(v6 + 32) || *(_BYTE *)(v6 + 40) || (v7 = *(_QWORD *)(v6 + 48)) == 0)
    {
      result = 0;
      v3 = -6709;
      goto LABEL_27;
    }
    v8 = *(unsigned __int8 *)(v7 + 72);
    if (!*(_BYTE *)(v7 + 72))
    {
LABEL_30:
      result = 0;
      v3 = -6727;
      goto LABEL_27;
    }
    v9 = 0;
    v10 = v7 + 104;
    while (1)
    {
      if (*(_BYTE *)(v10 + v9))
      {
        v11 = **(_QWORD **)(v10 + 8 * v9 - 24);
        if (v11)
          break;
      }
      if (v8 == ++v9)
        goto LABEL_30;
    }
    v13 = *(_QWORD *)(v11 + 80);
    v15 = 0;
    result = dnssec_obj_domain_name_create_with_labels(*(unsigned __int8 **)(v13 + 16), 1, &v15);
    if (v15)
      break;
    v3 = 0;
LABEL_20:
    v4 = (unsigned __int8 *)*((_QWORD *)v4 + 1);
    if (v4)
      v14 = result == 0;
    else
      v14 = 0;
    if (!v14)
      goto LABEL_27;
  }
  v3 = v15;
LABEL_27:
  if (a2)
    *a2 = v3;
  return result;
}

BOOL dnssec_obj_rrset_is_dnskey(uint64_t a1)
{
  unsigned __int8 **v1;
  unsigned __int8 *v2;
  _BOOL8 result;
  int v4;
  NSObject *v6;
  int v8;
  const char *v9;
  __int16 v10;
  const char *v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  uint64_t v17;

  if (!*(_QWORD *)(a1 + 32) || (v1 = *(unsigned __int8 ***)(a1 + 24)) == 0)
  {
    v6 = mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
      if (!result)
        return result;
    }
    else
    {
      v6 = mDNSLogCategory_DNSSEC_redacted;
      result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
      if (!result)
        return result;
    }
    v8 = 136447234;
    v9 = "rrset->rr_count > 0 && rrset->rrs != NULL";
    v10 = 2082;
    v11 = "";
    v12 = 2082;
    v13 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
    v14 = 1024;
    v15 = 284;
    v16 = 2048;
    v17 = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", (uint8_t *)&v8, 0x30u);
    return 0;
  }
  v2 = *v1;
  if (*v2 == 240)
    return 0;
  v4 = *((unsigned __int16 *)v2 + 2);
  if (v4 == 46)
    return __rev16(*(unsigned __int16 *)(*((_QWORD *)v2 + 5) + 4)) == 48;
  else
    return v4 == 48;
}

uint64_t dnssec_obj_rrset_get_denial_of_existence(uint64_t a1, int *a2)
{
  unsigned __int8 *v2;
  uint64_t v3;
  uint64_t result;
  int v5;

  if (*(_QWORD *)(a1 + 32) != 1)
    goto LABEL_14;
  v2 = **(unsigned __int8 ***)(a1 + 24);
  if (*v2 != 240)
  {
    result = 0;
    v5 = -6727;
    goto LABEL_10;
  }
  v3 = *((_QWORD *)v2 + 7);
  if (!v3)
  {
LABEL_14:
    result = 0;
    v5 = -6709;
    goto LABEL_10;
  }
  if (*(_DWORD *)(v3 + 32) || *(_BYTE *)(v3 + 40))
    result = 0;
  else
    result = *(_QWORD *)(v3 + 48);
  if (result)
    v5 = 0;
  else
    v5 = -6727;
LABEL_10:
  if (a2)
    *a2 = v5;
  return result;
}

uint64_t dnssec_obj_rrset_needs_to_update_cache(uint64_t a1, int a2)
{
  unsigned __int8 *v3;
  uint64_t v4;
  int v5;
  uint64_t cache_record;
  unsigned int v7;
  uint64_t result;
  uint64_t v9;
  unsigned int v10;
  NSObject *v11;
  int v14;
  const char *v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  uint64_t v23;

  if (!*(_QWORD *)(a1 + 32))
  {
    v11 = mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
      if (!(_DWORD)result)
        return result;
    }
    else
    {
      v11 = mDNSLogCategory_DNSSEC_redacted;
      result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
      if (!(_DWORD)result)
        return result;
    }
    v14 = 136447234;
    v15 = "me->rr_count > 0";
    v16 = 2082;
    v17 = "";
    v18 = 2082;
    v19 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
    v20 = 1024;
    v21 = 455;
    v22 = 2048;
    v23 = 0;
LABEL_41:
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", (uint8_t *)&v14, 0x30u);
    return 0;
  }
  v3 = **(unsigned __int8 ***)(a1 + 24);
  if (*v3 != 240)
    goto LABEL_6;
  v4 = *((_QWORD *)v3 + 7);
  if (!v4)
  {
    v11 = mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
      if (!(_DWORD)result)
        return result;
    }
    else
    {
      v11 = mDNSLogCategory_DNSSEC_redacted;
      result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
      if (!(_DWORD)result)
        return result;
    }
    v14 = 136447234;
    v15 = "me->rrs->rr->dnssec != NULL";
    v16 = 2082;
    v17 = "";
    v18 = 2082;
    v19 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
    v20 = 1024;
    v21 = 457;
    v22 = 2048;
    v23 = 0;
    goto LABEL_41;
  }
  if (!*(_DWORD *)(v4 + 32) && !*(_BYTE *)(v4 + 40))
  {
    v9 = *(_QWORD *)(v4 + 48);
    if (v9)
    {
      v10 = *(_DWORD *)(v9 + 16);
      if (v10 < 6 && ((0x27u >> v10) & 1) != 0)
        return 0;
    }
  }
LABEL_6:
  if (!*(_BYTE *)(a1 + 60))
    return 1;
  v5 = *(_DWORD *)(a1 + 52);
  cache_record = resource_record_get_cache_record(*((_QWORD *)v3 + 7));
  if (!cache_record)
  {
    v11 = mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
      if (!(_DWORD)result)
        return result;
    }
    else
    {
      v11 = mDNSLogCategory_DNSSEC_redacted;
      result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
      if (!(_DWORD)result)
        return result;
    }
    v14 = 136447234;
    v15 = "cr != NULL";
    v16 = 2082;
    v17 = "";
    v18 = 2082;
    v19 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
    v20 = 1024;
    v21 = 488;
    v22 = 2048;
    v23 = 0;
    goto LABEL_41;
  }
  v7 = *(_DWORD *)(cache_record + 80) + 1000 * a2;
  if (v7 <= 1)
    v7 = 1;
  return (int)(v7 - v5) > 999;
}

_QWORD *dnssec_obj_rrset_copy_rrs(_QWORD *result, size_t *a2, _DWORD *a3)
{
  uint64_t *v3;
  _QWORD *v6;
  size_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;

  v3 = (uint64_t *)result[3];
  if (!v3)
    goto LABEL_17;
  v6 = result;
  v7 = 0;
  do
  {
    v8 = *v3;
    v3 = (uint64_t *)v3[1];
    if (*(_WORD *)(v8 + 4) != 46)
      ++v7;
  }
  while (v3);
  if (v7 && !(v7 >> 61) && (result = malloc_type_calloc(v7, 8uLL, 0xF1748037uLL)) != 0)
  {
    v9 = (_QWORD *)v6[3];
    if (v9)
    {
      v10 = 0;
      do
      {
        if (*(_WORD *)(*v9 + 4) != 46)
          result[v10++] = *v9;
        v9 = (_QWORD *)v9[1];
      }
      while (v9);
    }
    *a2 = v7;
    if (a3)
      *a3 = 0;
  }
  else
  {
LABEL_17:
    __break(1u);
  }
  return result;
}

uint64_t dnssec_obj_rrset_copy_dses_with_supported_algorithm(uint64_t a1, size_t *a2, int *a3)
{
  uint64_t *v5;
  size_t v7;
  uint64_t result;
  _QWORD *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  _QWORD **v17;
  int v18;

  v18 = 0;
  v5 = *(uint64_t **)(a1 + 24);
  if (!v5)
    goto LABEL_18;
  v7 = 0;
  do
  {
    result = *v5;
    if (*(_WORD *)(*v5 + 4) == 43)
    {
      result = resource_record_as_ds_refers_to_supported_key_algorithm(result);
      v7 += result;
    }
    v5 = (uint64_t *)v5[1];
  }
  while (v5);
  if (!v7)
  {
LABEL_18:
    v15 = *(_DWORD *)(a1 + 40);
    v9 = 0;
    v13 = 0;
    if (v15 == 4 || v15 == 2)
      v14 = -6727;
    else
      v14 = -6745;
    v18 = v14;
LABEL_25:
    if (!a3)
      goto LABEL_27;
    goto LABEL_26;
  }
  if (!(v7 >> 61))
  {
    result = (uint64_t)malloc_type_calloc(v7, 8uLL, 0xF1748037uLL);
    if (result)
    {
      v9 = (_QWORD *)result;
      v10 = *(uint64_t **)(a1 + 24);
      if (v10)
      {
        v11 = 0;
        while (1)
        {
          v12 = *v10;
          if (*(_WORD *)(*v10 + 4) == 43)
            goto LABEL_14;
          if ((resource_record_as_ds_refers_to_supported_key_algorithm(v12) & 1) == 0)
            break;
LABEL_16:
          v10 = (uint64_t *)v10[1];
          if (!v10)
            goto LABEL_38;
        }
        v12 = *v10;
LABEL_14:
        v13 = v11 + 1;
        v9[v11] = dnssec_obj_rr_ds_create(*(unsigned __int8 **)(v12 + 32), *(_WORD *)(v12 + 6), (const void *)(*(_QWORD *)(v12 + 40) + 4), *(unsigned __int16 *)(v12 + 12), 0, &v18);
        v14 = v18;
        if (v18)
          goto LABEL_25;
        ++v11;
        goto LABEL_16;
      }
      v11 = 0;
LABEL_38:
      v14 = 0;
      *a2 = v7;
      v18 = 0;
      v13 = v11;
      if (!a3)
      {
LABEL_27:
        if (v14)
        {
          if (v13)
          {
            v17 = (_QWORD **)v9;
            do
            {
              if (*v17)
              {
                ref_count_obj_release(*v17);
                *v17 = 0;
              }
              ++v17;
              --v13;
            }
            while (v13);
            goto LABEL_35;
          }
          if (v9)
          {
LABEL_35:
            free(v9);
            return 0;
          }
        }
        return (uint64_t)v9;
      }
LABEL_26:
      *a3 = v14;
      goto LABEL_27;
    }
  }
  __break(1u);
  return result;
}

_QWORD *dnssec_obj_rrset_copy_dnskeys(_QWORD *result, size_t *a2, int *a3)
{
  uint64_t *v3;
  _QWORD *v6;
  size_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  _QWORD **v14;
  int v15;

  v3 = (uint64_t *)result[3];
  if (!v3)
    goto LABEL_28;
  v6 = result;
  v7 = 0;
  do
  {
    v8 = *v3;
    v3 = (uint64_t *)v3[1];
    if (*(_WORD *)(v8 + 4) == 48)
      ++v7;
  }
  while (v3);
  if (v7 && !(v7 >> 61) && (result = malloc_type_calloc(v7, 8uLL, 0xF1748037uLL)) != 0)
  {
    v9 = result;
    v15 = 0;
    v10 = (_QWORD *)v6[3];
    if (v10)
    {
      v11 = 0;
      do
      {
        if (*(_WORD *)(*v10 + 4) == 48)
        {
          v12 = v11 + 1;
          v9[v11] = dnssec_obj_rr_dnskey_create(*(unsigned __int8 **)(*v10 + 32), *(_WORD *)(*v10 + 6), (_BYTE *)(*(_QWORD *)(*v10 + 40) + 4), *(unsigned __int16 *)(*v10 + 12), &v15);
          v13 = v15;
          if (v15)
            goto LABEL_18;
          ++v11;
        }
        v10 = (_QWORD *)v10[1];
      }
      while (v10);
    }
    else
    {
      v11 = 0;
    }
    v13 = 0;
    *a2 = v7;
    v15 = 0;
    v12 = v11;
LABEL_18:
    if (a3)
      *a3 = v13;
    if (v13)
    {
      if (v12)
      {
        v14 = (_QWORD **)v9;
        do
        {
          if (*v14)
          {
            ref_count_obj_release(*v14);
            *v14 = 0;
          }
          ++v14;
          --v12;
        }
        while (v12);
      }
      free(v9);
      return 0;
    }
    return v9;
  }
  else
  {
LABEL_28:
    __break(1u);
  }
  return result;
}

uint64_t dnssec_obj_rrset_add_rr(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2;
  int v5;
  unint64_t v6;
  uint64_t result;
  unsigned __int8 **v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  NSObject *v13;
  int v14;
  int v15;
  unsigned int validation_result;
  int v17;
  int v18;

  v2 = *((_QWORD *)a2 + 7);
  if (!v2)
    return 4294960591;
  v5 = *(_DWORD *)(a1 + 40);
  if (v5 == 2)
  {
    if (!*(_QWORD *)(a1 + 32))
      return 4294960591;
  }
  else if (v5 == 1)
  {
    if (!*(_QWORD *)(a1 + 32))
      return 4294960587;
  }
  else if (!v5 && *(_QWORD *)(a1 + 32))
  {
    return 4294960587;
  }
  if (*a2 == 240)
  {
    v6 = *(_QWORD *)(a1 + 32);
    if (v6)
    {
      if (v6 == 1)
      {
        if (**(unsigned __int8 ***)(a1 + 24) == a2)
          return 4294960566;
        else
          return 4294960587;
      }
      return 4294960587;
    }
LABEL_20:
    if (domain_name_labels_canonical_compare(*(unsigned __int8 **)(*(_QWORD *)(a1 + 16) + 16), *((unsigned __int8 **)a2 + 4), 1))return 4294960548;
    v9 = malloc_type_calloc(1uLL, 0x10uLL, 0xF1748037uLL);
    if (!v9)
    {
      __break(1u);
      return 4294960587;
    }
    *v9 = a2;
    v9[1] = *(_QWORD *)(a1 + 24);
    *(_DWORD *)(a1 + 40) = 1;
    v10 = *(_QWORD *)(a1 + 32) + 1;
    *(_QWORD *)(a1 + 24) = v9;
    *(_QWORD *)(a1 + 32) = v10;
    if (*a2 == 240 || v10 == v6)
      *(_DWORD *)(a1 + 40) = 2;
    v11 = *((_QWORD *)a2 + 7);
    if (v11)
    {
      v12 = *(_DWORD *)(v11 + 32);
      if (v12 == 1)
      {
        validation_result = dnssec_obj_resource_record_member_get_validation_result(v11);
        result = 0;
        *(_QWORD *)(a1 + 44) = validation_result;
        return result;
      }
      if (!v12)
      {
        result = 0;
        *(_QWORD *)(a1 + 44) = 0xFFFFE5C200000000;
        return result;
      }
    }
    v13 = mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
      {
        v15 = *(_DWORD *)(v11 + 32);
        v17 = 67109120;
        v18 = v15;
        goto LABEL_35;
      }
    }
    else
    {
      v13 = mDNSLogCategory_DNSSEC_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT))
      {
        v14 = *(_DWORD *)(v11 + 32);
        v17 = 67109120;
        v18 = v14;
LABEL_35:
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_FAULT, "DNSSEC aware RR is neither to-be-validated or validated - aware type: %u.", (uint8_t *)&v17, 8u);
      }
    }
    return 4294960540;
  }
  v6 = *(_QWORD *)(v2 + 24);
  v8 = *(unsigned __int8 ***)(a1 + 24);
  if (!v8)
  {
LABEL_19:
    if (*(_QWORD *)(a1 + 32) < v6)
      goto LABEL_20;
    return 4294960591;
  }
  while (*v8 != a2)
  {
    v8 = (unsigned __int8 **)v8[1];
    if (!v8)
      goto LABEL_19;
  }
  return 4294960566;
}

uint64_t dnssec_obj_rrset_remove_rr(uint64_t a1, unsigned __int8 *a2)
{
  unsigned __int8 **v3;
  _QWORD *v4;
  NSObject *v5;
  uint8_t *v7;
  int v9;
  unsigned __int8 **v10;
  uint64_t v11;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  __int16 v16;
  __int16 v17;

  if (!*((_QWORD *)a2 + 7))
    return 4294960591;
  v4 = (_QWORD *)(a1 + 24);
  v3 = *(unsigned __int8 ***)(a1 + 24);
  if (!v3)
    goto LABEL_3;
  v9 = *a2;
  if (*v3 != a2)
  {
    while (1)
    {
      v10 = v3;
      v3 = (unsigned __int8 **)v3[1];
      if (!v3)
        break;
      if (*v3 == a2)
      {
        v4 = v10 + 1;
        goto LABEL_14;
      }
    }
LABEL_3:
    v5 = mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
        return 4294960569;
      v17 = 0;
      v7 = (uint8_t *)&v17;
    }
    else
    {
      v5 = mDNSLogCategory_DNSSEC_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT))
        return 4294960569;
      v16 = 0;
      v7 = (uint8_t *)&v16;
    }
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "Record to be removed is not found.", v7, 2u);
    return 4294960569;
  }
LABEL_14:
  v11 = *(_QWORD *)(a1 + 32);
  if (v9 == 240)
  {
    if (v11 != 1)
      return 4294960587;
  }
  else if (!v11)
  {
    return 4294960587;
  }
  if (!*(_DWORD *)(a1 + 40))
    return 4294960587;
  *v4 = v3[1];
  free(v3);
  *(_DWORD *)(a1 + 40) = 3;
  v14 = *(_QWORD *)(a1 + 32) - 1;
  *(_QWORD *)(a1 + 32) = v14;
  v15 = *((_QWORD *)a2 + 7);
  if (v9 == 240)
  {
    *(_DWORD *)(a1 + 40) = 4;
    if (!v15)
      return 0;
  }
  else if (*(_BYTE *)(v15 + 36) && v14 == *(_QWORD *)(v15 + 24))
  {
    *(_DWORD *)(a1 + 40) = 4;
  }
  if (*(_DWORD *)(v15 + 32))
    return 0;
  result = 0;
  *(_QWORD *)(a1 + 44) = 0xFFFFE5C200000000;
  return result;
}

uint64_t dnssec_obj_rrset_matches_dnskey_key_tag(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v5;
  uint64_t denial_of_existence;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unsigned int v12;
  int v13;
  unsigned int v15;
  unint64_t v16;
  uint64_t v17;
  NSObject *v18;
  int v26;
  uint8_t buf[4];
  const char *v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  int v34;
  __int16 v35;
  uint64_t v36;

  if (!*(_QWORD *)(a1 + 32))
  {
    v18 = mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
        return 0;
    }
    else
    {
      v18 = mDNSLogCategory_DNSSEC_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT))
        return 0;
    }
    *(_DWORD *)buf = 136447234;
    v28 = "me->rr_count > 0";
    v29 = 2082;
    v30 = "";
    v31 = 2082;
    v32 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
    v33 = 1024;
    v34 = 847;
    v35 = 2048;
    v36 = 0;
    goto LABEL_64;
  }
  v5 = *(_QWORD *)(a1 + 24);
  if (**(unsigned __int8 **)v5 == 240)
  {
    v26 = 0;
    denial_of_existence = dnssec_obj_rrset_get_denial_of_existence(a1, &v26);
    v7 = v26;
    if (v26)
    {
      v18 = mDNSLogCategory_DNSSEC;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
          return 0;
      }
      else
      {
        v18 = mDNSLogCategory_DNSSEC_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT))
          return 0;
      }
      *(_DWORD *)buf = 136447234;
      v28 = "err == 0";
      v29 = 2082;
      v30 = "";
      v31 = 2082;
      v32 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rrset.c";
      v33 = 1024;
      v34 = 867;
      v35 = 2048;
      v36 = v7;
      goto LABEL_64;
    }
    if (!*(_BYTE *)(denial_of_existence + 72))
    {
      v18 = mDNSLogCategory_DNSSEC;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
          return 0;
      }
      else
      {
        v18 = mDNSLogCategory_DNSSEC_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT))
          return 0;
      }
      *(_DWORD *)buf = 136447234;
      v28 = "me->nsec_count > 0";
      v29 = 2082;
      v30 = "";
      v31 = 2082;
      v32 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_denial_of_existence.c";
      v33 = 1024;
      v34 = 227;
      v35 = 2048;
      v36 = 0;
      goto LABEL_64;
    }
    v8 = 0;
    while (1)
    {
      v9 = *(unsigned __int8 *)(denial_of_existence + v8 + 104);
      if (!*(_BYTE *)(denial_of_existence + v8 + 104))
        break;
      v10 = 0;
      do
      {
        while (!a3)
        {
          if (++v10 >= v9)
            return 0;
        }
        v11 = 0;
        v12 = __rev16(*(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(denial_of_existence + 8 * v8 + 80)
                                                                  + 8 * v10)
                                                      + 24)
                                          + 16));
        do
        {
          v13 = *(unsigned __int16 *)(*(_QWORD *)(a2 + 8 * v11) + 80);
          v5 = v13 == v12;
          ++v11;
        }
        while (v11 < a3 && v13 != v12);
        ++v10;
      }
      while (v10 < v9 && v13 != v12);
      ++v8;
      if (v13 != v12 || v8 == *(unsigned __int8 *)(denial_of_existence + 72))
        return v5;
    }
    v18 = mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_DNSSEC != mDNSLogCategory_State)
    {
      v18 = mDNSLogCategory_DNSSEC_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT))
        return 0;
      goto LABEL_37;
    }
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
    {
LABEL_37:
      *(_DWORD *)buf = 136447234;
      v28 = "me->nsec_rrsig_count[i] > 0";
      v29 = 2082;
      v30 = "";
      v31 = 2082;
      v32 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_denial_of_existence.c";
      v33 = 1024;
      v34 = 230;
      v35 = 2048;
      v36 = 0;
LABEL_64:
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", buf, 0x30u);
    }
    return 0;
  }
  while (*(_WORD *)(*(_QWORD *)v5 + 4) != 46 || !a3)
  {
LABEL_28:
    v5 = *(_QWORD *)(v5 + 8);
    if (!v5)
      return v5;
  }
  v15 = __rev16(*(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)v5 + 40) + 20));
  v16 = a3;
  v17 = a2;
  while (*(unsigned __int16 *)(*(_QWORD *)v17 + 80) != v15)
  {
    v17 += 8;
    if (!--v16)
      goto LABEL_28;
  }
  return 1;
}

uint64_t dnssec_obj_rrset_validate_with_dnskeys(uint64_t *a1, _DWORD **a2, size_t a3, unsigned __int8 *a4)
{
  unsigned __int8 *v4;
  uint64_t v5;
  uint64_t *v6;
  int v7;
  BOOL v8;
  uint64_t v9;
  unsigned __int8 *v12;
  uint64_t v13;
  size_t v14;
  _DWORD **v15;
  size_t v16;
  _DWORD **v17;
  int v18;
  int v19;
  size_t v20;
  size_t v21;
  _QWORD *v22;
  _DWORD **v23;
  _DWORD **v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  unsigned int v28;
  _QWORD *v29;
  _QWORD *v30;
  _UNKNOWN **v31;
  void (*v32)(_QWORD *);
  _QWORD *v33;
  _QWORD **v34;
  _QWORD **v35;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  uint64_t v41;
  size_t v42;
  unsigned int v43;
  int v44;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  _DWORD **v49;
  size_t v50;
  int v51;
  _QWORD *v52;
  int v53;
  uint64_t *v54;
  unsigned __int8 *v56;
  _DWORD **v57;
  _DWORD **v58;
  const void *v59;
  __int16 v60;
  int v61;
  int v62[3];
  int v63;

  v4 = a4;
  v5 = *((unsigned int *)a1 + 11);
  if ((_DWORD)v5)
  {
    v14 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v19 = -6719;
LABEL_16:
    v61 = v19;
    if (!a4)
      goto LABEL_54;
LABEL_53:
    *(_DWORD *)v4 = v61;
    goto LABEL_54;
  }
  v6 = a1;
  v7 = *((_DWORD *)a1 + 10);
  v8 = v7 == 2 || v7 == 4;
  if (!v8 || (v9 = a1[4]) == 0)
  {
    v14 = 0;
    v5 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v19 = -6745;
    goto LABEL_16;
  }
  v12 = (unsigned __int8 *)a1[3];
  if (**(unsigned __int8 **)v12 != 240)
  {
    v20 = 0;
    v21 = 0;
    do
    {
      v22 = *(_QWORD **)v12;
      v12 = (unsigned __int8 *)*((_QWORD *)v12 + 1);
      if (*((_WORD *)v22 + 2) == 46)
        ++v20;
      else
        ++v21;
    }
    while (v12);
    if (v20 + v21 == v9)
    {
      if (!v21
        || v21 >> 61
        || (v23 = (_DWORD **)malloc_type_calloc(v21, 8uLL, 0xF1748037uLL)) == 0
        || !v20
        || v20 >> 61
        || (v17 = v23, (v24 = (_DWORD **)malloc_type_calloc(v20, 8uLL, 0xF1748037uLL)) == 0))
      {
LABEL_99:
        __break(1u);
LABEL_100:
        v5 = 3;
        v53 = -6750;
        goto LABEL_98;
      }
      v15 = v24;
      v54 = v6;
      v56 = v4;
      v61 = -6736;
      v6 = (uint64_t *)v6[3];
      if (!v6)
      {
        v14 = 0;
        v16 = 0;
LABEL_47:
        v33 = dnssec_obj_rr_validator_create(v17, v16, v15, v14, a2, a3, 0, 0, 0, 0, &v61);
        v5 = dnssec_obj_rr_validator_validate_rrset((uint64_t)v33, &v61);
        ref_count_obj_release(v33);
        v6 = v54;
        v4 = v56;
        goto LABEL_48;
      }
      v16 = 0;
      v14 = 0;
      v57 = v24;
      v58 = v17;
      while (1)
      {
        v25 = *v6;
        v26 = *(unsigned __int16 *)(*v6 + 4);
        v4 = *(unsigned __int8 **)(*v6 + 32);
        if (v26 == 46)
        {
          v15[v14++] = (_DWORD *)dnssec_obj_rr_rrsig_create(*(unsigned __int8 **)(*v6 + 32), (const void *)(*(_QWORD *)(v25 + 40) + 4), *(unsigned __int16 *)(v25 + 12), 0, &v61);
        }
        else
        {
          v60 = *(_WORD *)(v25 + 6);
          v27 = *(_QWORD *)(v25 + 40);
          v28 = *(unsigned __int16 *)(v25 + 12);
          v62[0] = 0;
          v29 = malloc_type_calloc(1uLL, 0x50uLL, 0xF1748037uLL);
          if (!v29)
            goto LABEL_99;
          v30 = v29;
          v59 = (const void *)(v27 + 4);
          v31 = &_dnssec_obj_rr_kind;
          v29[1] = &_dnssec_obj_rr_kind;
          do
          {
            v32 = (void (*)(_QWORD *))v31[2];
            if (v32)
              v32(v30);
            v31 = (_UNKNOWN **)*v31;
          }
          while (v31);
          ++*(_DWORD *)v30;
          dnssec_obj_rr_init_fields((uint64_t)v30, v4, v26, v60, v59, v28, 0, 0, v62);
          if (v62[0])
          {
            v61 = v62[0];
            ref_count_obj_release(v30);
            v30 = 0;
          }
          else
          {
            v61 = 0;
          }
          v17 = v58;
          v58[v16++] = v30;
          v15 = v57;
        }
        if (v61)
          break;
        v6 = (uint64_t *)v6[1];
        if (!v6)
          goto LABEL_47;
      }
      v5 = 0;
      v4 = v56;
LABEL_52:
      if (!v4)
        goto LABEL_54;
      goto LABEL_53;
    }
    goto LABEL_12;
  }
  v13 = *(_QWORD *)(*(_QWORD *)v12 + 56);
  if (!v13)
  {
    v14 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v18 = -6736;
LABEL_13:
    v61 = v18;
    v5 = 3;
    if (!a4)
      goto LABEL_54;
    goto LABEL_53;
  }
  if (*(_DWORD *)(v13 + 32) || *(_BYTE *)(v13 + 40) || (v37 = *(_QWORD *)(v13 + 48)) == 0)
  {
LABEL_12:
    v14 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v18 = -6709;
    goto LABEL_13;
  }
  if (!*(_DWORD *)(v37 + 16))
  {
    v5 = 3;
    v53 = -6720;
    goto LABEL_98;
  }
  if (!*(_BYTE *)(v37 + 72))
  {
    v5 = 3;
    v53 = -6736;
    goto LABEL_98;
  }
  v38 = 0;
  do
  {
    v39 = *(unsigned __int8 *)(v37 + v38 + 104);
    if (!*(_BYTE *)(v37 + v38 + 104))
      goto LABEL_97;
    v40 = 0;
    do
    {
      while (1)
      {
        v41 = *(_QWORD *)(*(_QWORD *)(v37 + 8 * v38 + 80) + 8 * v40);
        if (!v41)
          goto LABEL_100;
        if (a3)
          break;
        if (++v40 >= v39)
          goto LABEL_97;
      }
      v42 = 0;
      v43 = __rev16(*(unsigned __int16 *)(*(_QWORD *)(v41 + 24) + 16));
      do
        v44 = *((unsigned __int16 *)a2[v42++] + 40);
      while (v42 < a3 && v43 != v44);
      ++v40;
    }
    while (v40 < v39 && v43 != v44);
    if (v43 != v44)
    {
LABEL_97:
      v5 = 0;
      v53 = -6745;
      goto LABEL_98;
    }
    ++v38;
  }
  while (v38 != *(unsigned __int8 *)(v37 + 72));
  v5 = 0;
  v46 = 0;
  v63 = -6736;
  v47 = v37 + 104;
  while (1)
  {
    v48 = v47 + 8 * v46;
    v49 = *(_DWORD ***)(v48 - 24);
    v50 = *(unsigned __int8 *)(v47 + v46);
    v51 = *(_DWORD *)(v37 + 44);
    if (v51 == 2)
      goto LABEL_94;
    if (v51 != 1)
      break;
    v48 = v47 + 8 * v46;
LABEL_94:
    *(_QWORD *)v62 = *(_QWORD *)(v48 - 56);
    v52 = dnssec_obj_rr_validator_create((_DWORD **)v62, 1uLL, v49, v50, a2, a3, 0, 0, 0, 0, &v63);
    v5 = dnssec_obj_rr_validator_validate_rrset((uint64_t)v52, &v63);
    ref_count_obj_release(v52);
    if ((_DWORD)v5 == 1 && ++v46 < (unint64_t)*(unsigned __int8 *)(v37 + 72))
      continue;
    v53 = v63;
    goto LABEL_103;
  }
  v53 = -6736;
LABEL_103:
  v6 = a1;
LABEL_98:
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v61 = v53;
LABEL_48:
  *((_DWORD *)v6 + 11) = v5;
  if (!(_DWORD)v5)
    goto LABEL_52;
  *((_DWORD *)v6 + 12) = v61;
  if (v4)
    goto LABEL_53;
LABEL_54:
  if (v14)
  {
    v34 = (_QWORD **)v15;
    do
    {
      if (*v34)
      {
        ref_count_obj_release(*v34);
        *v34 = 0;
      }
      ++v34;
      --v14;
    }
    while (v14);
  }
  if (v16)
  {
    v35 = (_QWORD **)v17;
    do
    {
      if (*v35)
      {
        ref_count_obj_release(*v35);
        *v35 = 0;
      }
      ++v35;
      --v16;
    }
    while (v16);
  }
  if (v15)
    free(v15);
  if (v17)
    free(v17);
  return v5;
}

uint64_t dnssec_obj_rrset_validate_with_dses_or_trust_anchors(uint64_t a1, _DWORD **a2, size_t a3, _DWORD **a4, size_t a5, _DWORD *a6)
{
  uint64_t v7;
  int v9;
  BOOL v10;
  uint64_t v15;
  unsigned __int8 *v16;
  _QWORD *v17;
  size_t v18;
  size_t v19;
  int v20;
  _DWORD **v21;
  _DWORD **v22;
  _DWORD **v23;
  _DWORD **v24;
  _QWORD *v25;
  size_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  int v30;
  int v31;
  _QWORD *v32;
  _QWORD *v33;
  _QWORD **v34;
  _QWORD **v35;
  _DWORD **v37;
  _DWORD **v38;
  _DWORD *v39;
  int v40;

  v40 = 0;
  v7 = *(unsigned int *)(a1 + 44);
  if ((_DWORD)v7)
  {
    v27 = 0;
    v24 = 0;
    v26 = 0;
    v22 = 0;
    v16 = 0;
    v30 = -6719;
    goto LABEL_37;
  }
  v9 = *(_DWORD *)(a1 + 40);
  v10 = v9 == 2 || v9 == 4;
  if (!v10 || !*(_QWORD *)(a1 + 32))
    goto LABEL_36;
  if (***(unsigned __int8 ***)(a1 + 24) == 240)
  {
    v27 = 0;
    v24 = 0;
    v26 = 0;
    v22 = 0;
    v16 = 0;
    v31 = -6736;
    goto LABEL_42;
  }
  if (!dnssec_obj_rrset_is_dnskey(a1))
  {
    v27 = 0;
    v24 = 0;
    v26 = 0;
    v22 = 0;
    v16 = 0;
    v31 = -6705;
    goto LABEL_42;
  }
  if (!(a5 | a3))
  {
LABEL_36:
    v7 = 0;
    v27 = 0;
    v24 = 0;
    v26 = 0;
    v22 = 0;
    v16 = 0;
    v30 = -6745;
    goto LABEL_37;
  }
  v15 = *(_QWORD *)(a1 + 16);
  v16 = dnssec_obj_rrset_copy_signer_name(a1, &v40);
  if (v40)
  {
    v7 = 0;
    v27 = 0;
    v24 = 0;
    v26 = 0;
    v22 = 0;
    v30 = -6728;
LABEL_37:
    v40 = v30;
    if (!a6)
      goto LABEL_50;
    goto LABEL_49;
  }
  if (ref_count_obj_compare(v15, (uint64_t)v16, 1))
  {
    v27 = 0;
    v24 = 0;
    v26 = 0;
    v22 = 0;
    v31 = -90005;
LABEL_42:
    v40 = v31;
    v7 = 3;
    if (!a6)
      goto LABEL_50;
    goto LABEL_49;
  }
  v17 = *(_QWORD **)(a1 + 24);
  if (!v17)
  {
    if (*(_QWORD *)(a1 + 32))
    {
LABEL_41:
      v27 = 0;
      v24 = 0;
      v26 = 0;
      v22 = 0;
      v31 = -6709;
      goto LABEL_42;
    }
LABEL_40:
    __break(1u);
    goto LABEL_41;
  }
  v18 = 0;
  v19 = 0;
  do
  {
    v20 = *(unsigned __int16 *)(*v17 + 4);
    if (v20 == 46)
    {
      ++v18;
    }
    else
    {
      if (v20 != 48)
        goto LABEL_41;
      ++v19;
    }
    v17 = (_QWORD *)v17[1];
  }
  while (v17);
  if (v18 + v19 != *(_QWORD *)(a1 + 32))
    goto LABEL_41;
  if (!v19)
    goto LABEL_40;
  if (v19 >> 61)
    goto LABEL_40;
  v21 = (_DWORD **)malloc_type_calloc(v19, 8uLL, 0xF1748037uLL);
  if (!v21)
    goto LABEL_40;
  if (!v18)
    goto LABEL_40;
  if (v18 >> 61)
    goto LABEL_40;
  v22 = v21;
  v23 = (_DWORD **)malloc_type_calloc(v18, 8uLL, 0xF1748037uLL);
  if (!v23)
    goto LABEL_40;
  v24 = v23;
  v37 = a4;
  v38 = a2;
  v39 = a6;
  v40 = -6736;
  v25 = *(_QWORD **)(a1 + 24);
  if (v25)
  {
    v26 = 0;
    v27 = 0;
    while (1)
    {
      v28 = *v25;
      v29 = *(unsigned __int16 *)(*v25 + 4);
      if (v29 == 46)
      {
        v24[v27++] = (_DWORD *)dnssec_obj_rr_rrsig_create(*(unsigned __int8 **)(v28 + 32), (const void *)(*(_QWORD *)(v28 + 40) + 4), *(unsigned __int16 *)(v28 + 12), 0, &v40);
      }
      else
      {
        if (v29 != 48)
        {
          v7 = 0;
          v40 = -6736;
LABEL_69:
          a6 = v39;
          if (!v39)
            goto LABEL_50;
LABEL_49:
          *a6 = v40;
          goto LABEL_50;
        }
        v22[v26++] = (_DWORD *)dnssec_obj_rr_dnskey_create(*(unsigned __int8 **)(v28 + 32), *(_WORD *)(v28 + 6), (_BYTE *)(*(_QWORD *)(v28 + 40) + 4), *(unsigned __int16 *)(v28 + 12), &v40);
      }
      if (v40)
        goto LABEL_67;
      v25 = (_QWORD *)v25[1];
      if (!v25)
        goto LABEL_45;
    }
  }
  v27 = 0;
  v26 = 0;
LABEL_45:
  v32 = dnssec_obj_rr_validator_create(v22, v26, v24, v18, v22, v26, v38, a3, v37, a5, &v40);
  if (v40)
  {
LABEL_67:
    v7 = 0;
    goto LABEL_69;
  }
  v33 = v32;
  v7 = dnssec_obj_rr_validator_validate_rrset((uint64_t)v32, &v40);
  ref_count_obj_release(v33);
  *(_DWORD *)(a1 + 44) = v7;
  a6 = v39;
  if ((_DWORD)v7)
    *(_DWORD *)(a1 + 48) = v40;
  if (v39)
    goto LABEL_49;
LABEL_50:
  if (v16)
    ref_count_obj_release(v16);
  if (v27)
  {
    v34 = (_QWORD **)v24;
    do
    {
      if (*v34)
      {
        ref_count_obj_release(*v34);
        *v34 = 0;
      }
      ++v34;
      --v27;
    }
    while (v27);
  }
  if (v26)
  {
    v35 = (_QWORD **)v22;
    do
    {
      if (*v35)
      {
        ref_count_obj_release(*v35);
        *v35 = 0;
      }
      ++v35;
      --v26;
    }
    while (v26);
  }
  if (v24)
    free(v24);
  if (v22)
    free(v22);
  return v7;
}

void *_mdns_dns_service_manager_copy_description(_QWORD *a1, int a2, char a3)
{
  _QWORD *v6;
  _QWORD *v7;
  int appended;
  int v9;
  int v10;
  void *v11;
  _QWORD v13[7];
  char v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  int v22;
  _QWORD v23[5];
  _QWORD v24[5];

  v19 = 0;
  v20 = &v19;
  v21 = 0x2000000000;
  v22 = 0;
  v15 = 0;
  v16 = &v15;
  v17 = 0x2000000000;
  v18 = 0;
  v6 = (_QWORD *)mdns_string_builder_create();
  if (v6)
  {
    v7 = v6;
    if (a2)
    {
      appended = mdns_string_builder_append_formatted(v6, "<%s: %p>: ", *(const char **)(a1[2] + 8), a1);
      *((_DWORD *)v20 + 6) = appended;
      if (appended)
        goto LABEL_7;
    }
    v9 = mdns_string_builder_append_formatted(v7, "{");
    *((_DWORD *)v20 + 6) = v9;
    if (v9)
      goto LABEL_7;
    v16[3] = (uint64_t)"\n\t";
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 0x40000000;
    v13[2] = ___mdns_dns_service_manager_copy_description_block_invoke;
    v13[3] = &unk_10013AB28;
    v13[4] = &v19;
    v13[5] = &v15;
    v13[6] = v7;
    v14 = a3;
    v23[0] = _NSConcreteStackBlock;
    v23[1] = 0x40000000;
    v23[2] = ___mdns_dns_service_manager_enumerate_all_services_block_invoke;
    v23[3] = &unk_10013B258;
    v23[4] = v13;
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 0x40000000;
    v24[2] = ___mdns_dns_service_manager_enumerate_all_service_arrays_block_invoke;
    v24[3] = &unk_10013B230;
    v24[4] = v23;
    _mdns_dns_service_manager_enumerate_all_service_array_pointers((uint64_t)a1, (uint64_t)v24);
    if (*((_DWORD *)v20 + 6)
      || (v10 = mdns_string_builder_append_formatted(v7, "\n}"), (*((_DWORD *)v20 + 6) = v10) != 0))
    {
LABEL_7:
      v11 = 0;
    }
    else
    {
      v11 = mdns_string_builder_copy_string((uint64_t)v7);
    }
    os_release(v7);
  }
  else
  {
    v11 = 0;
  }
  _Block_object_dispose(&v15, 8);
  _Block_object_dispose(&v19, 8);
  return v11;
}

void _mdns_dns_service_manager_finalize(_QWORD *a1)
{
  const void *v2;
  NSObject *v3;
  const void *v4;

  _mdns_dns_service_manager_enumerate_all_service_array_pointers((uint64_t)a1, (uint64_t)&__block_literal_global_103);
  v2 = (const void *)a1[10];
  if (v2)
  {
    CFRelease(v2);
    a1[10] = 0;
  }
  v3 = a1[11];
  if (v3)
  {
    dispatch_release(v3);
    a1[11] = 0;
  }
  v4 = (const void *)a1[13];
  if (v4)
  {
    _Block_release(v4);
    a1[13] = 0;
  }
}

uint64_t _mdns_dns_service_manager_enumerate_all_service_array_pointers(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v4;
  unint64_t v5;
  char v6;
  _QWORD v7[7];

  v7[0] = a1 + 24;
  v7[1] = a1 + 32;
  v7[2] = a1 + 40;
  v7[3] = a1 + 48;
  v7[4] = a1 + 56;
  v7[5] = a1 + 64;
  v7[6] = a1 + 72;
  result = (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
  if ((_DWORD)result)
  {
    v4 = 1;
    v5 = 6;
    while (v4 != 7)
    {
      v6 = (*(uint64_t (**)(uint64_t, _QWORD))(a2 + 16))(a2, v7[v4++]);
      if ((v6 & 1) == 0)
      {
        v5 = v4 - 2;
        return v5 > 5;
      }
    }
    return v5 > 5;
  }
  return result;
}

BOOL ___mdns_dns_service_manager_finalize_block_invoke(id a1, __CFArray **a2)
{
  if (*a2)
  {
    CFRelease(*a2);
    *a2 = 0;
  }
  return 1;
}

BOOL ___mdns_dns_service_manager_copy_description_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = mdns_string_builder_append_description_with_prefix(*(_QWORD **)(a1 + 48), *(const char **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8)+ 24), a2, *(_BYTE *)(a1 + 56));
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = ",\n\t";
  return *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) == 0;
}

BOOL ___mdns_dns_service_manager_enumerate_all_services_block_invoke(uint64_t a1, const __CFArray *a2)
{
  uint64_t v2;
  _QWORD v4[5];

  v2 = *(_QWORD *)(a1 + 32);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___mdns_dns_service_enumerate_array_including_variants_and_discovered_alts_block_invoke;
  v4[3] = &unk_10013B280;
  v4[4] = v2;
  return mdns_cfarray_enumerate(a2, (uint64_t)v4);
}

uint64_t ___mdns_dns_service_manager_enumerate_all_service_arrays_block_invoke(uint64_t a1, _QWORD *a2)
{
  if (*a2)
    return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  else
    return 1;
}

uint64_t ___mdns_dns_service_enumerate_array_including_variants_and_discovered_alts_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  const __CFArray *v5;
  const __CFArray *v6;

  result = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  if ((_DWORD)result)
  {
    v5 = *(const __CFArray **)(a2 + 128);
    if (!v5 || (result = mdns_cfarray_enumerate(v5, *(_QWORD *)(a1 + 32)), (_DWORD)result))
    {
      v6 = *(const __CFArray **)(a2 + 144);
      return !v6 || mdns_cfarray_enumerate(v6, *(_QWORD *)(a1 + 32));
    }
  }
  return result;
}

void *_mdns_dns_service_copy_description(uint64_t a1, int a2, int a3)
{
  _QWORD *v6;
  _QWORD *v7;
  int v8;
  int appended;
  int v10;
  int v11;
  void *v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  const char *v19;
  int v20;
  int v21;
  const __CFArray *v23;
  int v24;
  int v25;
  uint64_t v26;
  _QWORD *v27;
  const char *v28;
  int v29;
  int v30;
  int v31;
  uint64_t v32;
  uint64_t *v33;
  int v34;
  uint64_t v35;
  int v36;
  int v37;
  int v38;
  int v39;
  uint64_t v40;
  uint64_t *v41;
  int v42;
  int v43;
  int v44;
  int v45;
  char *provider_name_cstr;
  const char *v47;
  int v48;
  int v49;
  uint64_t v50;
  const char *v51;
  int v52;
  int v53;
  int v54;
  int v55;
  uint64_t v56;
  int v57;
  int v58;
  uint64_t v59;
  _QWORD v60[7];
  char v61;
  uint64_t v62;
  uint64_t *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t *v67;
  uint64_t v68;
  int v69;
  char out[48];
  __int128 v71;
  unsigned __int8 uu[8];
  uint64_t v73;

  v66 = 0;
  v67 = &v66;
  v68 = 0x2000000000;
  v69 = 0;
  v62 = 0;
  v63 = &v62;
  v64 = 0x2000000000;
  v65 = 0;
  v6 = (_QWORD *)mdns_string_builder_create();
  if (v6)
  {
    v7 = v6;
    if (!a2
      || (v8 = mdns_string_builder_append_formatted(v6, "<%s: %p>: ", *(const char **)(*(_QWORD *)(a1 + 16) + 8), (const void *)a1), (*((_DWORD *)v67 + 6) = v8) == 0))
    {
      appended = mdns_string_builder_append_formatted(v7, "id: %llu", *(_QWORD *)(a1 + 24));
      *((_DWORD *)v67 + 6) = appended;
      if (!appended)
      {
        v10 = mdns_string_builder_append_formatted(v7, ", type: ");
        *((_DWORD *)v67 + 6) = v10;
        if (!v10)
        {
          v11 = *(unsigned __int8 *)(a1 + 281) > 5uLL
              ? mdns_string_builder_append_formatted(v7, "«INVALID %u»")
              : mdns_string_builder_append_formatted(v7, "%s");
          *((_DWORD *)v67 + 6) = v11;
          if (!v11)
          {
            v13 = mdns_string_builder_append_formatted(v7, ", source: ");
            *((_DWORD *)v67 + 6) = v13;
            if (!v13)
            {
              v14 = (*(char *)(a1 + 282) - 1) > 4
                  ? mdns_string_builder_append_formatted(v7, "«INVALID %u»")
                  : mdns_string_builder_append_formatted(v7, "%s");
              *((_DWORD *)v67 + 6) = v14;
              if (!v14)
              {
                v15 = mdns_string_builder_append_formatted(v7, ", scope: ");
                *((_DWORD *)v67 + 6) = v15;
                if (!v15)
                {
                  switch(*(_BYTE *)(a1 + 280))
                  {
                    case 1:
                      v16 = mdns_string_builder_append_formatted(v7, "none", v59);
                      goto LABEL_27;
                    case 2:
                      v16 = mdns_string_builder_append_formatted(v7, "interface", v59);
                      goto LABEL_27;
                    case 3:
                      v16 = mdns_string_builder_append_formatted(v7, "service (%u)");
                      goto LABEL_27;
                    case 4:
                      v17 = mdns_string_builder_append_formatted(v7, "uuid");
                      *((_DWORD *)v67 + 6) = v17;
                      if (v17)
                        goto LABEL_32;
                      if ((a3 & 1) != 0)
                        goto LABEL_28;
                      *(_QWORD *)uu = 0;
                      v73 = 0;
                      nw_resolver_config_get_identifier(*(_QWORD *)(a1 + 96), uu);
                      memset(out, 0, 37);
                      uuid_unparse(uu, out);
                      v18 = mdns_string_builder_append_formatted(v7, " (%s)", out);
                      v12 = 0;
                      *((_DWORD *)v67 + 6) = v18;
                      if (!v18)
                        goto LABEL_28;
                      goto LABEL_33;
                    case 5:
                      v16 = mdns_string_builder_append_formatted(v7, "none+interface");
                      goto LABEL_27;
                    default:
                      v16 = mdns_string_builder_append_formatted(v7, "«INVALID %d»");
LABEL_27:
                      *((_DWORD *)v67 + 6) = v16;
                      if (v16)
                        goto LABEL_32;
LABEL_28:
                      v19 = *(const char **)(a1 + 104);
                      if (!v19)
                        v19 = "";
                      v20 = mdns_string_builder_append_formatted(v7, ", interface: %s/%u", v19, *(_DWORD *)(a1 + 256));
                      *((_DWORD *)v67 + 6) = v20;
                      if (v20)
                        goto LABEL_32;
                      v21 = mdns_string_builder_append_formatted(v7, ", servers: {");
                      *((_DWORD *)v67 + 6) = v21;
                      if (v21)
                        goto LABEL_32;
                      v63[3] = 0;
                      v23 = *(const __CFArray **)(a1 + 80);
                      if (v23)
                      {
                        v60[0] = _NSConcreteStackBlock;
                        v60[1] = 0x40000000;
                        v60[2] = ___mdns_dns_service_copy_description_block_invoke;
                        v60[3] = &unk_10013AEF0;
                        v60[4] = &v66;
                        v60[5] = &v62;
                        v60[6] = v7;
                        v61 = a3;
                        mdns_cfarray_enumerate(v23, (uint64_t)v60);
                        if (*((_DWORD *)v67 + 6))
                          goto LABEL_32;
                      }
                      v24 = mdns_string_builder_append_formatted(v7, "}");
                      *((_DWORD *)v67 + 6) = v24;
                      if (v24)
                        goto LABEL_32;
                      v25 = mdns_string_builder_append_formatted(v7, ", domains: {");
                      *((_DWORD *)v67 + 6) = v25;
                      if (v25)
                        goto LABEL_32;
                      v63[3] = 0;
                      v26 = *(_QWORD *)(a1 + 136);
                      if (!v26)
                        v26 = a1;
                      v27 = *(_QWORD **)(v26 + 88);
                      if (!v27)
                        goto LABEL_45;
                      v28 = 0;
                      break;
                  }
                  while (1)
                  {
                    v29 = mdns_string_builder_append_description_with_prefix(v7, v28, v27[1], a3);
                    *((_DWORD *)v67 + 6) = v29;
                    if (v29)
                      break;
                    v63[3] = (uint64_t)", ";
                    v27 = (_QWORD *)*v27;
                    v28 = ", ";
                    if (!v27)
                    {
LABEL_45:
                      v30 = mdns_string_builder_append_formatted(v7, "}");
                      *((_DWORD *)v67 + 6) = v30;
                      if (!v30)
                      {
                        v31 = mdns_string_builder_append_formatted(v7, ", attributes: {");
                        *((_DWORD *)v67 + 6) = v31;
                        if (!v31)
                        {
                          v32 = 0;
                          v33 = v63;
                          v63[3] = (uint64_t)"";
                          do
                          {
                            if (((uint64_t)(&off_10013AF10)[v32 + 1] & *(_WORD *)(a1 + 276)) != 0)
                            {
                              v34 = mdns_string_builder_append_formatted(v7, "%s%s", (const char *)v33[3], (&off_10013AF10)[v32]);
                              *((_DWORD *)v67 + 6) = v34;
                              if (v34)
                                goto LABEL_32;
                              v33 = v63;
                              v63[3] = (uint64_t)", ";
                            }
                            v32 += 2;
                          }
                          while (v32 != 14);
                          v35 = *(_QWORD *)(a1 + 96);
                          if (v35 && nw_resolver_config_get_allow_failover(v35))
                          {
                            v36 = mdns_string_builder_append_formatted(v7, "%sallows-failover", (const char *)v63[3]);
                            *((_DWORD *)v67 + 6) = v36;
                            if (v36)
                              break;
                            v63[3] = (uint64_t)", ";
                          }
                          if (!*(_QWORD *)(a1 + 240)
                            || !*(_QWORD *)(a1 + 248)
                            || (v37 = mdns_string_builder_append_formatted(v7, "%sreports-push-connection-error", (const char *)v63[3]), (*((_DWORD *)v67 + 6) = v37) == 0))
                          {
                            v38 = mdns_string_builder_append_formatted(v7, "}");
                            *((_DWORD *)v67 + 6) = v38;
                            if (!v38)
                            {
                              v39 = mdns_string_builder_append_formatted(v7, ", interface properties: {");
                              *((_DWORD *)v67 + 6) = v39;
                              if (!v39)
                              {
                                v40 = 0;
                                v41 = v63;
                                v63[3] = (uint64_t)"";
                                do
                                {
                                  if (((uint64_t)(&off_10013AF80)[v40 + 1] & *(_WORD *)(a1 + 276)) != 0)
                                  {
                                    v42 = mdns_string_builder_append_formatted(v7, "%s%s", (const char *)v41[3], (&off_10013AF80)[v40]);
                                    *((_DWORD *)v67 + 6) = v42;
                                    if (v42)
                                      goto LABEL_32;
                                    v41 = v63;
                                    v63[3] = (uint64_t)", ";
                                  }
                                  v40 += 2;
                                }
                                while (v40 != 16);
                                v43 = mdns_string_builder_append_formatted(v7, "}");
                                *((_DWORD *)v67 + 6) = v43;
                                if (!v43)
                                {
                                  if (!*(_QWORD *)(a1 + 96))
                                    goto LABEL_100;
                                  v44 = mdns_string_builder_append_formatted(v7, ", resolver config: {");
                                  *((_DWORD *)v67 + 6) = v44;
                                  if (!v44)
                                  {
                                    v45 = mdns_string_builder_append_formatted(v7, "provider name: ");
                                    *((_DWORD *)v67 + 6) = v45;
                                    if (!v45)
                                    {
                                      provider_name_cstr = _mdns_dns_service_get_provider_name_cstr(a1);
                                      if (!provider_name_cstr)
                                        goto LABEL_102;
                                      v47 = provider_name_cstr;
                                      v71 = 0u;
                                      memset(out, 0, sizeof(out));
                                      if (a3)
                                      {
                                        if ((int)DNSMessagePrintObfuscatedString((uint64_t)out, provider_name_cstr) < 0)
                                          v47 = "«REDACTED»";
                                        else
                                          v47 = out;
                                      }
                                      v48 = mdns_string_builder_append_formatted(v7, "%s", v47);
                                      *((_DWORD *)v67 + 6) = v48;
                                      if (!v48)
                                      {
LABEL_102:
                                        v49 = mdns_string_builder_append_formatted(v7, ", provider path: ");
                                        *((_DWORD *)v67 + 6) = v49;
                                        if (!v49)
                                        {
                                          v50 = *(_QWORD *)(a1 + 136);
                                          if (!v50 || !*(_QWORD *)(v50 + 96))
                                            v50 = a1;
                                          v51 = *(const char **)(v50 + 168);
                                          if (!v51)
                                            goto LABEL_101;
                                          v71 = 0u;
                                          memset(out, 0, sizeof(out));
                                          if (a3)
                                          {
                                            if ((int)DNSMessagePrintObfuscatedString((uint64_t)out, v51) < 0)
                                              v51 = "«REDACTED»";
                                            else
                                              v51 = out;
                                          }
                                          v52 = mdns_string_builder_append_formatted(v7, "%s", v51);
                                          *((_DWORD *)v67 + 6) = v52;
                                          if (!v52)
                                          {
LABEL_101:
                                            v53 = mdns_string_builder_append_formatted(v7, "}");
                                            *((_DWORD *)v67 + 6) = v53;
                                            if (!v53)
                                            {
LABEL_100:
                                              if (!*(_QWORD *)(a1 + 176)
                                                || (v54 = mdns_string_builder_append_formatted(v7, ", connection hostname: %s", *(const char **)(a1 + 176)), (*((_DWORD *)v67 + 6) = v54) == 0))
                                              {
                                                if (!*(_WORD *)(a1 + 278)
                                                  || (v55 = mdns_string_builder_append_formatted(v7, ", port: %d", *(unsigned __int16 *)(a1 + 278)), (*((_DWORD *)v67 + 6) = v55) == 0))
                                                {
                                                  v56 = *(_QWORD *)(a1 + 216);
                                                  if (!v56
                                                    || (v57 = mdns_string_builder_append_formatted(v7, ", SRV name: %s", *(const char **)(v56 + 40)), (*((_DWORD *)v67 + 6) = v57) == 0))
                                                  {
                                                    v58 = *(_QWORD *)(a1 + 136)
                                                        ? mdns_string_builder_append_formatted(v7, ", parent: %llu")
                                                        : mdns_string_builder_append_formatted(v7, ", use count: %d");
                                                    *((_DWORD *)v67 + 6) = v58;
                                                    if (!v58)
                                                    {
                                                      v12 = mdns_string_builder_copy_string((uint64_t)v7);
                                                      goto LABEL_33;
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
LABEL_32:
    v12 = 0;
LABEL_33:
    os_release(v7);
  }
  else
  {
    v12 = 0;
  }
  _Block_object_dispose(&v62, 8);
  _Block_object_dispose(&v66, 8);
  return v12;
}

uint64_t _mdns_dns_service_equal(uint64_t a1, uint64_t a2)
{
  return _mdns_dns_service_equal_ex(a1, a2, 0);
}

void _mdns_dns_service_finalize(_QWORD *a1)
{
  void (*v2)(void);
  const void *v3;
  _QWORD *v4;
  void *v5;
  void *v6;
  void *v7;
  const void *v8;
  void *v9;
  const void *v10;
  const void *v11;
  void *v12;
  void *v13;
  void *v14;
  const void *v15;
  void *v16;
  void *v17;
  const void *v18;

  if (a1[14])
  {
    v2 = (void (*)(void))a1[15];
    if (v2)
      v2();
    a1[14] = 0;
  }
  v3 = (const void *)a1[10];
  if (v3)
  {
    CFRelease(v3);
    a1[10] = 0;
  }
  while (1)
  {
    v4 = (_QWORD *)a1[11];
    if (!v4)
      break;
    a1[11] = *v4;
    _domain_item_free(v4);
  }
  v5 = (void *)a1[6];
  if (v5)
  {
    nw_release(v5);
    a1[6] = 0;
  }
  v6 = (void *)a1[12];
  if (v6)
  {
    nw_release(v6);
    a1[12] = 0;
  }
  v7 = (void *)a1[13];
  if (v7)
  {
    free(v7);
    a1[13] = 0;
  }
  v8 = (const void *)a1[16];
  if (v8)
  {
    CFRelease(v8);
    a1[16] = 0;
  }
  v9 = (void *)a1[17];
  if (v9)
  {
    os_release(v9);
    a1[17] = 0;
  }
  v10 = (const void *)a1[18];
  if (v10)
  {
    CFRelease(v10);
    a1[18] = 0;
  }
  v11 = (const void *)a1[19];
  if (v11)
  {
    CFRelease(v11);
    a1[19] = 0;
  }
  v12 = (void *)a1[20];
  if (v12)
  {
    xpc_release(v12);
    a1[20] = 0;
  }
  v13 = (void *)a1[21];
  if (v13)
  {
    free(v13);
    a1[21] = 0;
  }
  v14 = (void *)a1[22];
  if (v14)
  {
    free(v14);
    a1[22] = 0;
  }
  v15 = (const void *)a1[24];
  if (v15)
  {
    CFRelease(v15);
    a1[24] = 0;
  }
  v16 = (void *)a1[26];
  if (v16)
  {
    nw_release(v16);
    a1[26] = 0;
  }
  v17 = (void *)a1[27];
  if (v17)
  {
    os_release(v17);
    a1[27] = 0;
  }
  v18 = (const void *)a1[29];
  if (v18)
  {
    CFRelease(v18);
    a1[29] = 0;
  }
}

void _domain_item_free(_QWORD *a1)
{
  void *v2;

  v2 = (void *)a1[1];
  if (v2)
    os_release(v2);
  free(a1);
}

uint64_t _mdns_dns_service_equal_ex(uint64_t a1, uint64_t a2, char a3)
{
  int v5;
  const void *v7;
  const void *v8;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  int v13;

  if (a1 == a2)
    return 1;
  v5 = *(unsigned __int8 *)(a1 + 280);
  if (v5 != *(unsigned __int8 *)(a2 + 280)
    || *(_DWORD *)(a1 + 256) != *(_DWORD *)(a2 + 256)
    || v5 == 3 && *(_DWORD *)(a1 + 260) != *(_DWORD *)(a2 + 260))
  {
    return 0;
  }
  v7 = *(const void **)(a1 + 80);
  v8 = *(const void **)(a2 + 80);
  if (v7 == v8 || (result = 0, v7) && v8 && (result = CFEqual(*(CFTypeRef *)(a1 + 80), v8), (_DWORD)result))
  {
    if ((a3 & 1) != 0)
      return 1;
    v10 = a1 + 88;
    v11 = a2 + 88;
    while (1)
    {
      v11 = *(_QWORD *)v11;
      v10 = *(_QWORD *)v10;
      if (!v10 || v11 == 0)
        break;
      v13 = _domain_item_compare(v10, v11, 0);
      result = 0;
      if (v13)
        return result;
    }
    return !(v10 | v11);
  }
  return result;
}

uint64_t _domain_item_compare(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  int v6;
  _BYTE *v12;
  _BYTE *v13;
  int v14;
  _BYTE *v15;
  _BYTE *v16;
  int v17;
  int v18;
  unsigned __int8 *v19;
  unsigned int v20;
  unsigned int v21;
  unsigned __int8 *v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t v25;
  int v26;

  v3 = *(_QWORD *)(a1 + 8);
  v4 = *(_DWORD *)(v3 + 48);
  v5 = *(_QWORD *)(a2 + 8);
  v6 = v4 - *(_DWORD *)(v5 + 48);
  if (v6)
  {
    if (v6 < 1)
      return 1;
    else
      return 0xFFFFFFFFLL;
  }
  else
  {
    if (v3 != v5 && v4 >= 1)
    {
      v12 = *(_BYTE **)(v3 + 24);
      v13 = *(_BYTE **)(v5 + 24);
      while (1)
      {
        v14 = v4 - 1;
        if (v4 < 1)
          return (a3 & 1) == 0 && *(_DWORD *)(a1 + 16) < *(_DWORD *)(a2 + 16);
        v15 = v12;
        v16 = v13;
        if (v4 != 1)
        {
          v17 = 1;
          v15 = v12;
          do
          {
            if (!*v15)
              break;
            v15 += *v15 + 1;
            ++v17;
          }
          while (v4 != v17);
          v18 = 1;
          v16 = v13;
          do
          {
            if (!*v16)
              break;
            v16 += *v16 + 1;
            ++v18;
          }
          while (v4 != v18);
        }
        v21 = *v15;
        v19 = v15 + 1;
        v20 = v21;
        v24 = *v16;
        v22 = v16 + 1;
        v23 = v24;
        if (v20 >= v24)
          v25 = v23;
        else
          v25 = v20;
        v26 = mdns_memcmp_us_ascii_case_insensitive(v19, v22, v25, v4);
        if (v26)
          return (char)v26;
        if (v20 < v23)
          break;
        v4 = v14;
        if (v20 > v23)
        {
          LOBYTE(v26) = 1;
          return (char)v26;
        }
      }
      LOBYTE(v26) = -1;
      return (char)v26;
    }
    return (a3 & 1) == 0 && *(_DWORD *)(a1 + 16) < *(_DWORD *)(a2 + 16);
  }
}

BOOL ___mdns_dns_service_copy_description_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = mdns_string_builder_append_description_with_prefix(*(_QWORD **)(a1 + 48), *(const char **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8)+ 24), a2, *(_BYTE *)(a1 + 56));
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = ", ";
  return *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) == 0;
}

char *_mdns_dns_service_get_provider_name_cstr(uint64_t a1)
{
  uint64_t v1;
  char *result;

  v1 = *(_QWORD *)(a1 + 136);
  if (!v1 || !*(_QWORD *)(v1 + 96))
    v1 = a1;
  result = *(char **)(v1 + 160);
  if (result)
    return (char *)xpc_string_get_string_ptr(result);
  return result;
}

BOOL __mdns_dns_service_manager_create_block_invoke(id a1, __CFArray **a2)
{
  __CFArray *Mutable;

  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
  *a2 = Mutable;
  return Mutable != 0;
}

void ___mdns_os_variant_has_internal_diagnostics_block_invoke(id a1)
{
  _mdns_os_variant_has_internal_diagnostics_s_result = os_variant_has_internal_diagnostics("com.apple.mdns");
}

void __mdns_dns_service_manager_activate_block_invoke(uint64_t a1)
{
  uint64_t v1;
  dispatch_source_t v2;
  NSObject *v3;
  NSObject *v4;
  _QWORD v5[5];
  _QWORD handler[5];

  v1 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v1 + 131) && !*(_QWORD *)(v1 + 96))
  {
    v2 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_data_or, 0, 0, *(dispatch_queue_t *)(v1 + 88));
    *(_QWORD *)(v1 + 96) = v2;
    if (v2)
    {
      os_retain((void *)v1);
      v3 = *(NSObject **)(v1 + 96);
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 0x40000000;
      handler[2] = ___mdns_dns_service_manager_activate_internal_block_invoke;
      handler[3] = &__block_descriptor_tmp_5;
      handler[4] = v1;
      dispatch_source_set_event_handler(v3, handler);
      v4 = *(NSObject **)(v1 + 96);
      v5[0] = _NSConcreteStackBlock;
      v5[1] = 0x40000000;
      v5[2] = ___mdns_dns_service_manager_activate_internal_block_invoke_2;
      v5[3] = &__block_descriptor_tmp_6;
      v5[4] = v1;
      dispatch_source_set_cancel_handler(v4, v5);
      dispatch_activate(*(dispatch_object_t *)(v1 + 96));
    }
    else
    {
      _mdns_dns_service_manager_terminate(v1, -6729);
    }
  }
}

uint64_t ___mdns_dns_service_manager_activate_internal_block_invoke(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 104);
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(result + 16))(result, 3, 0);
  return result;
}

void ___mdns_dns_service_manager_activate_internal_block_invoke_2(uint64_t a1)
{
  os_release(*(void **)(a1 + 32));
}

void _mdns_dns_service_manager_terminate(uint64_t a1, int a2)
{
  NSObject *v4;
  CFIndex Count;
  CFIndex v6;
  CFIndex i;
  void *ValueAtIndex;
  void *v9;
  NSObject *v10;
  _QWORD v11[5];
  int v12;
  _QWORD v13[5];
  _QWORD v14[5];

  if (!*(_BYTE *)(a1 + 130))
  {
    *(_BYTE *)(a1 + 131) = 1;
    v4 = *(NSObject **)(a1 + 96);
    if (v4)
    {
      dispatch_source_cancel(*(dispatch_source_t *)(a1 + 96));
      dispatch_release(v4);
      *(_QWORD *)(a1 + 96) = 0;
    }
    Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 80));
    if (Count >= 1)
    {
      v6 = Count;
      for (i = 0; i != v6; ++i)
      {
        ValueAtIndex = (void *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 80), i);
        mdns_interface_monitor_invalidate(ValueAtIndex);
      }
    }
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 80));
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 0x40000000;
    v13[2] = ___mdns_dns_service_manager_terminate_block_invoke;
    v13[3] = &__block_descriptor_tmp_110;
    v13[4] = a1;
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 0x40000000;
    v14[2] = ___mdns_dns_service_manager_enumerate_all_service_arrays_block_invoke;
    v14[3] = &unk_10013B230;
    v14[4] = v13;
    _mdns_dns_service_manager_enumerate_all_service_array_pointers(a1, (uint64_t)v14);
    v9 = *(void **)(a1 + 112);
    if (v9)
    {
      mdns_system_remove_network_policy(v9);
      *(_QWORD *)(a1 + 112) = 0;
    }
    os_retain((void *)a1);
    v10 = *(NSObject **)(a1 + 88);
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000;
    v11[2] = ___mdns_dns_service_manager_terminate_block_invoke_2;
    v11[3] = &__block_descriptor_tmp_111;
    v11[4] = a1;
    v12 = a2;
    dispatch_async(v10, v11);
  }
}

uint64_t ___mdns_dns_service_manager_terminate_block_invoke(uint64_t a1, const __CFArray *a2)
{
  uint64_t v3;
  _QWORD v5[5];

  v3 = *(_QWORD *)(a1 + 32);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___mdns_dns_service_manager_terminate_services_block_invoke;
  v5[3] = &__block_descriptor_tmp_112;
  v5[4] = v3;
  mdns_cfarray_enumerate(a2, (uint64_t)v5);
  CFArrayRemoveAllValues(a2);
  return 1;
}

void ___mdns_dns_service_manager_terminate_block_invoke_2(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *(_QWORD **)(a1 + 32);
  v3 = v2[13];
  if (v3)
  {
    if (*(_DWORD *)(a1 + 40))
      v4 = 1;
    else
      v4 = 2;
    (*(void (**)(_QWORD, uint64_t))(v3 + 16))(v2[13], v4);
    v2 = *(_QWORD **)(a1 + 32);
  }
  os_release(v2);
}

uint64_t ___mdns_dns_service_manager_terminate_services_block_invoke(uint64_t a1, uint64_t a2)
{
  _mdns_dns_service_manager_terminate_service(*(_QWORD *)(a1 + 32), a2);
  return 1;
}

void _mdns_dns_service_manager_terminate_service(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  const __CFArray *v5;
  const void *v6;
  const __CFArray *v7;
  const void *v8;
  const __CFArray *v9;
  const void *v10;
  _QWORD v11[5];

  _mdns_dns_service_clear_use_count(a2);
  _mdns_dns_service_make_defunct(a2);
  v4 = *(_QWORD *)(a2 + 96);
  if (v4 && *(_BYTE *)(a2 + 284))
  {
    *(_BYTE *)(a2 + 284) = 0;
    _mdns_dns_service_manager_cancel_resolver_config_updates(a1, v4);
  }
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  v11[2] = ___mdns_dns_service_manager_terminate_service_block_invoke;
  v11[3] = &__block_descriptor_tmp_122;
  v11[4] = a1;
  v5 = *(const __CFArray **)(a2 + 128);
  if (v5)
  {
    mdns_cfarray_enumerate(v5, (uint64_t)v11);
    v6 = *(const void **)(a2 + 128);
    if (v6)
    {
      CFRelease(v6);
      *(_QWORD *)(a2 + 128) = 0;
    }
  }
  v7 = *(const __CFArray **)(a2 + 144);
  if (v7)
  {
    mdns_cfarray_enumerate(v7, (uint64_t)v11);
    v8 = *(const void **)(a2 + 144);
    if (v8)
    {
      CFRelease(v8);
      *(_QWORD *)(a2 + 144) = 0;
    }
  }
  v9 = *(const __CFArray **)(a2 + 152);
  if (v9)
  {
    mdns_cfarray_enumerate(v9, (uint64_t)v11);
    v10 = *(const void **)(a2 + 152);
    if (v10)
    {
      CFRelease(v10);
      *(_QWORD *)(a2 + 152) = 0;
    }
  }
}

void _mdns_dns_service_clear_use_count(uint64_t a1)
{
  NSObject *v2;

  v2 = *(NSObject **)(a1 + 224);
  if (v2)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 224));
    dispatch_release(v2);
    *(_QWORD *)(a1 + 224) = 0;
  }
  *(_DWORD *)(a1 + 264) = 0;
}

void _mdns_dns_service_make_defunct(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  void *v4;
  void *v5;
  _BYTE *v6;
  NSObject *v7;
  const void *v8;

  *(_WORD *)(a1 + 276) |= 1u;
  v2 = *(NSObject **)(a1 + 200);
  if (v2)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 200));
    dispatch_release(v2);
    *(_QWORD *)(a1 + 200) = 0;
  }
  _mdns_dns_service_forget_all_ddr_queriers(a1);
  v3 = *(_QWORD *)(a1 + 208);
  if (v3)
  {
    nw_array_apply(v3, &__block_literal_global_128);
    v4 = *(void **)(a1 + 208);
    if (v4)
    {
      nw_release(v4);
      *(_QWORD *)(a1 + 208) = 0;
    }
  }
  v5 = *(void **)(a1 + 64);
  if (v5)
  {
    mdns_resolver_invalidate(v5);
    os_release(*(void **)(a1 + 64));
    *(_QWORD *)(a1 + 64) = 0;
  }
  v6 = *(_BYTE **)(a1 + 72);
  if (v6)
  {
    mdns_push_server_invalidate(v6);
    os_release(*(void **)(a1 + 72));
    *(_QWORD *)(a1 + 72) = 0;
  }
  v7 = *(NSObject **)(a1 + 240);
  if (v7)
  {
    dispatch_release(v7);
    *(_QWORD *)(a1 + 240) = 0;
  }
  v8 = *(const void **)(a1 + 248);
  if (v8)
  {
    _Block_release(v8);
    *(_QWORD *)(a1 + 248) = 0;
  }
}

uint64_t _mdns_dns_service_manager_cancel_resolver_config_updates(uint64_t a1, uint64_t a2)
{
  _QWORD v5[6];

  if (_mdns_dns_service_queue_s_once != -1)
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___mdns_dns_service_manager_cancel_resolver_config_updates_block_invoke;
  v5[3] = &__block_descriptor_tmp_77;
  v5[4] = a1;
  v5[5] = a2;
  return nw_resolver_config_cancel_updates(a2, _mdns_dns_service_queue_s_queue, v5);
}

uint64_t ___mdns_dns_service_manager_terminate_service_block_invoke(uint64_t a1)
{
  _mdns_dns_service_manager_terminate_service(*(_QWORD *)(a1 + 32));
  return 1;
}

void ___mdns_dns_service_manager_cancel_resolver_config_updates_block_invoke(uint64_t a1)
{
  os_release(*(void **)(a1 + 32));
  nw_release(*(void **)(a1 + 40));
}

void _mdns_dns_service_forget_all_ddr_queriers(uint64_t a1)
{
  uint64_t v2;
  const __CFArray *v3;

  v2 = *(_QWORD *)(a1 + 184);
  if (v2)
  {
    mdns_client_invalidate(v2);
    os_release(*(void **)(a1 + 184));
    *(_QWORD *)(a1 + 184) = 0;
  }
  v3 = *(const __CFArray **)(a1 + 192);
  if (v3)
  {
    mdns_cfarray_enumerate(v3, (uint64_t)&__block_literal_global_125);
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 192));
  }
}

BOOL ___mdns_dns_service_forget_all_ddr_connections_block_invoke(id a1, unint64_t a2, const nw_object *a3)
{
  nw_connection_cancel((nw_connection_t)a3);
  return 1;
}

BOOL ___mdns_dns_service_forget_all_ddr_queriers_block_invoke(id a1, const mdns_querier_s *a2)
{
  mdns_client_invalidate((uint64_t)a2);
  return 1;
}

void ___mdns_dns_service_queue_block_invoke(id a1)
{
  _mdns_dns_service_queue_s_queue = (uint64_t)dispatch_queue_create("com.apple.mdns.dns-service-queue", 0);
}

void __mdns_dns_service_manager_register_native_service_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  __CFArray *v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  BOOL v8;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  __int16 v15;
  __int16 v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  NSObject *v20;
  _QWORD v21[6];
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  int v25;
  __int128 buf;
  BOOL (*v27)(uint64_t, void *);
  void *v28;
  uint64_t *v29;
  uint64_t v30;

  v2 = a1[6];
  if (*(_BYTE *)(v2 + 131))
  {
    *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = 0;
    *(_DWORD *)(*(_QWORD *)(a1[5] + 8) + 24) = -6752;
    return;
  }
  v3 = *(__CFArray **)(v2 + 24);
  v4 = a1[7];
  v5 = *(_QWORD *)(a1[5] + 8);
  v22 = 0;
  v23 = &v22;
  v24 = 0x2000000000;
  v25 = 0;
  v6 = *(_DWORD *)(v4 + 48);
  v7 = *(unsigned __int8 *)(v4 + 52);
  if (*(_BYTE *)(v4 + 52))
    v8 = v6 == 0;
  else
    v8 = 0;
  if (v8 || v7 > 2)
  {
    v10 = 0;
    v11 = -6705;
LABEL_25:
    *((_DWORD *)v23 + 6) = v11;
    goto LABEL_26;
  }
  v12 = _mdns_dns_service_create(1, 1, (0x50201u >> (8 * v7)) & 7, &v25);
  v10 = v12;
  if (v12)
  {
    *(_QWORD *)&buf = _NSConcreteStackBlock;
    *((_QWORD *)&buf + 1) = 0x40000000;
    v27 = ___mdns_dns_service_create_native_source_service_from_definition_block_invoke;
    v28 = &unk_10013A6E0;
    v29 = &v22;
    v30 = v12;
    mdns_cfarray_enumerate(*(const __CFArray **)(v4 + 24), (uint64_t)&buf);
    v13 = *((_DWORD *)v23 + 6);
    if (v13)
      goto LABEL_40;
    v21[0] = _NSConcreteStackBlock;
    v21[1] = 0x40000000;
    v21[2] = ___mdns_dns_service_create_native_source_service_from_definition_block_invoke_2;
    v21[3] = &unk_10013A708;
    v21[4] = &v22;
    v21[5] = v10;
    mdns_cfset_enumerate(*(const __CFSet **)(v4 + 32), (uint64_t)v21);
    v13 = *((_DWORD *)v23 + 6);
    if (v13)
    {
LABEL_40:
      os_release((void *)v10);
      _Block_object_dispose(&v22, 8);
      v18 = 0;
      *(_DWORD *)(v5 + 24) = v13;
      goto LABEL_35;
    }
    *(_DWORD *)(v10 + 256) = v6;
    if (v6)
      *(_QWORD *)(v10 + 104) = mdns_system_interface_index_to_name(v6);
    *(_WORD *)(v10 + 276) = 6;
    v14 = *(unsigned __int8 *)(v4 + 53);
    if (*(_BYTE *)(v4 + 53))
      v15 = 8198;
    else
      v15 = 6;
    *(_WORD *)(v10 + 276) = v15;
    if (*(_BYTE *)(v4 + 54))
    {
      v11 = 0;
      if (v14)
        v16 = 24582;
      else
        v16 = 16390;
      *(_WORD *)(v10 + 276) = v16;
    }
    else
    {
      v11 = 0;
    }
    goto LABEL_25;
  }
  v11 = *((_DWORD *)v23 + 6);
LABEL_26:
  _Block_object_dispose(&v22, 8);
  if (!v11)
  {
    _mdns_dns_service_increment_use_count(v10);
    CFArrayAppendValue(v3, (const void *)v10);
    _mdns_dns_service_manager_update_interface_properties_for_service((CFArrayRef *)v2, v10);
    if (_mdns_dns_service_log_s_once != -1)
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
    v19 = _mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138412290;
      *(_QWORD *)((char *)&buf + 4) = v10;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Registered native service -- %@", (uint8_t *)&buf, 0xCu);
    }
    v17 = *(_QWORD *)(v10 + 24);
    *(_DWORD *)(v5 + 24) = 0;
    goto LABEL_34;
  }
  v17 = 0;
  v18 = 0;
  *(_DWORD *)(v5 + 24) = v11;
  if (v10)
  {
LABEL_34:
    os_release((void *)v10);
    v18 = v17;
  }
LABEL_35:
  *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = v18;
  if (*(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24))
  {
    v20 = *(NSObject **)(a1[6] + 96);
    if (v20)
      dispatch_source_merge_data(v20, 1uLL);
  }
}

uint64_t _mdns_dns_service_create(char a1, char a2, char a3, int *a4)
{
  uint64_t v8;
  uint64_t v9;
  _UNKNOWN **v10;
  void (*v11)(uint64_t);
  unint64_t v12;
  int v13;

  v8 = _os_object_alloc(OS_mdns_dns_service, 288);
  v9 = v8;
  if (!v8)
  {
    v13 = -6728;
    if (!a4)
      return v9;
    goto LABEL_8;
  }
  v10 = &_mdns_dns_service_kind;
  *(_QWORD *)(v8 + 16) = &_mdns_dns_service_kind;
  do
  {
    v11 = (void (*)(uint64_t))v10[2];
    if (v11)
      v11(v9);
    v10 = (_UNKNOWN **)*v10;
  }
  while (v10);
  do
    v12 = __ldxr(&_mdns_get_next_dns_service_id_s_next_id);
  while (__stxr(v12 + 1, &_mdns_get_next_dns_service_id_s_next_id));
  v13 = 0;
  *(_QWORD *)(v9 + 24) = v12;
  *(_BYTE *)(v9 + 281) = a1;
  *(_BYTE *)(v9 + 282) = a2;
  *(_BYTE *)(v9 + 280) = a3;
  if (a4)
LABEL_8:
    *a4 = v13;
  return v9;
}

BOOL ___mdns_dns_service_create_native_source_service_from_definition_block_invoke(uint64_t a1, void *a2)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = _mdns_dns_service_append_address(*(_QWORD *)(a1 + 40), a2);
  return *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) == 0;
}

BOOL ___mdns_dns_service_create_native_source_service_from_definition_block_invoke_2(uint64_t a1, void *a2)
{
  _mdns_dns_service_add_domain(*(_QWORD *)(a1 + 40), a2, 0);
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  return *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) == 0;
}

uint64_t _mdns_dns_service_increment_use_count(uint64_t a1)
{
  int v2;
  NSObject *v3;
  uint64_t result;

  v2 = *(_DWORD *)(a1 + 264);
  v3 = *(NSObject **)(a1 + 224);
  if (v2 == 1)
  {
    if (!v3)
    {
      v2 = 1;
      goto LABEL_7;
    }
    *(_DWORD *)(a1 + 264) = 0;
    goto LABEL_5;
  }
  if (v3)
  {
LABEL_5:
    dispatch_source_cancel(v3);
    dispatch_release(v3);
    *(_QWORD *)(a1 + 224) = 0;
    v2 = *(_DWORD *)(a1 + 264);
  }
LABEL_7:
  result = (v2 + 1);
  *(_DWORD *)(a1 + 264) = result;
  return result;
}

void _mdns_dns_service_manager_update_interface_properties_for_service(CFArrayRef *a1, uint64_t a2)
{
  unsigned int v4;
  CFIndex Count;
  CFIndex v6;
  CFIndex v7;
  _DWORD *ValueAtIndex;
  uint64_t v9;
  uint64_t v10;
  __int16 v11;
  int v12;
  __int16 v13;
  NSObject *v14;
  const char *v15;
  int v16;
  _QWORD v17[6];
  _BYTE buf[24];
  void *v19;
  CFArrayRef *v20;
  uint64_t v21;

  v4 = *(_DWORD *)(a2 + 256);
  Count = CFArrayGetCount(a1[10]);
  if (Count >= 1)
  {
    v6 = Count;
    v7 = 0;
    while (1)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(a1[10], v7);
      if (ValueAtIndex[34] == v4)
        break;
      if (v6 == ++v7)
        goto LABEL_5;
    }
    v10 = (uint64_t)ValueAtIndex;
    goto LABEL_14;
  }
LABEL_5:
  v9 = mdns_interface_monitor_create(v4);
  if (v9)
  {
    v10 = v9;
    if (_mdns_dns_service_queue_s_once != -1)
      dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
    mdns_interface_monitor_set_queue(v10, (dispatch_object_t)_mdns_dns_service_queue_s_queue);
    os_retain(a1);
    *(_QWORD *)buf = _NSConcreteStackBlock;
    *(_QWORD *)&buf[8] = 0x40000000;
    *(_QWORD *)&buf[16] = ___mdns_dns_service_manager_get_interface_monitor_block_invoke;
    v19 = &__block_descriptor_tmp_55;
    v20 = a1;
    v21 = v10;
    mdns_interface_monitor_set_update_handler(v10, buf);
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 0x40000000;
    v17[2] = ___mdns_dns_service_manager_get_interface_monitor_block_invoke_2;
    v17[3] = &__block_descriptor_tmp_57;
    v17[4] = v10;
    v17[5] = a1;
    mdns_interface_monitor_set_event_handler(v10, v17);
    if (!*(_BYTE *)(v10 + 154))
    {
      if (*(_QWORD *)(v10 + 32))
        _mdns_interface_monitor_activate_async((void *)v10);
      *(_BYTE *)(v10 + 154) = 1;
    }
    CFArrayAppendValue(a1[10], (const void *)v10);
LABEL_14:
    v11 = *(_WORD *)(a2 + 276) & 0xF80F;
    *(_WORD *)(a2 + 276) = v11;
    v12 = *(_DWORD *)(v10 + 144);
    v13 = v11 & 0xFF0F | (16 * (v12 & 0xF));
    if ((v12 & 0xF) != 0)
      *(_WORD *)(a2 + 276) = v13;
    if (*(_BYTE *)(a2 + 282) == 2 && *(_DWORD *)(a2 + 256) && (v12 & 0x10) != 0)
    {
      v13 |= 0x100u;
      *(_WORD *)(a2 + 276) = v13;
    }
    if ((v12 & 0x60) != 0)
      *(_WORD *)(a2 + 276) = (16 * v12) & 0x600 | v13;
    return;
  }
  if (_mdns_dns_service_log_s_once != -1)
    dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
  v14 = _mdns_dns_service_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
  {
    v15 = *(const char **)(a2 + 104);
    if (!v15)
      v15 = "";
    v16 = *(_DWORD *)(a2 + 256);
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = v15;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v16;
    _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Failed to get interface monitor for interface %{public}s/%u", buf, 0x12u);
  }
}

void ___mdns_dns_service_log_block_invoke(id a1)
{
  _mdns_dns_service_log_s_log = (uint64_t)os_log_create("com.apple.mdns", "dns_service");
}

void ___mdns_dns_service_manager_get_interface_monitor_block_invoke(uint64_t a1, char a2)
{
  _DWORD *v3;
  uint64_t v4;
  int v5;
  NSObject *v6;
  const __CFArray *v7;
  const __CFArray *v8;
  const __CFArray *v9;
  NSObject *v10;
  _QWORD v11[4];
  int v12;
  uint8_t buf[8];
  uint64_t v14;
  uint64_t (*v15)(uint64_t, uint64_t);
  void *v16;
  _QWORD *v17;
  CFRange v18;

  if (a2)
  {
    v4 = *(_QWORD *)(a1 + 32);
    v3 = *(_DWORD **)(a1 + 40);
    v18.length = CFArrayGetCount(*(CFArrayRef *)(v4 + 80));
    v18.location = 0;
    if (CFArrayContainsValue(*(CFArrayRef *)(v4 + 80), v18, v3))
    {
      if (a2 < 0)
      {
        v5 = v3[34];
        if (_mdns_dns_service_log_s_once != -1)
          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
        v6 = _mdns_dns_service_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = v5;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "Network change event for interface index %u", buf, 8u);
        }
        v11[0] = _NSConcreteStackBlock;
        v11[1] = 0x40000000;
        v11[2] = ___mdns_dns_service_manager_handle_network_change_event_block_invoke;
        v11[3] = &__block_descriptor_tmp_58;
        v12 = v5;
        v7 = *(const __CFArray **)(v4 + 40);
        *(_QWORD *)buf = _NSConcreteStackBlock;
        v14 = 0x40000000;
        v15 = ___mdns_dns_service_manager_enumerate_service_array_including_variants_block_invoke;
        v16 = &unk_10013A7B0;
        v17 = v11;
        mdns_cfarray_enumerate(v7, (uint64_t)buf);
        v8 = *(const __CFArray **)(v4 + 56);
        *(_QWORD *)buf = _NSConcreteStackBlock;
        v14 = 0x40000000;
        v15 = ___mdns_dns_service_manager_enumerate_service_array_including_variants_block_invoke;
        v16 = &unk_10013A7B0;
        v17 = v11;
        mdns_cfarray_enumerate(v8, (uint64_t)buf);
        v9 = *(const __CFArray **)(v4 + 48);
        *(_QWORD *)buf = _NSConcreteStackBlock;
        v14 = 0x40000000;
        v15 = ___mdns_dns_service_manager_handle_network_change_event_block_invoke_2;
        v16 = &__block_descriptor_tmp_59;
        LODWORD(v17) = v5;
        mdns_cfarray_enumerate(v9, (uint64_t)buf);
      }
      v10 = *(NSObject **)(v4 + 96);
      if (v10)
        dispatch_source_merge_data(v10, 1uLL);
    }
  }
}

void ___mdns_dns_service_manager_get_interface_monitor_block_invoke_2(uint64_t a1, int a2)
{
  CFIndex FirstIndexOfValue;
  CFRange v4;

  if (a2 == 1)
  {
    v4.length = CFArrayGetCount(*(CFArrayRef *)(*(_QWORD *)(a1 + 40) + 80));
    v4.location = 0;
    FirstIndexOfValue = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(*(_QWORD *)(a1 + 40) + 80), v4, *(const void **)(a1 + 32));
    if ((FirstIndexOfValue & 0x8000000000000000) == 0)
      CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(*(_QWORD *)(a1 + 40) + 80), FirstIndexOfValue);
    mdns_interface_monitor_invalidate(*(void **)(a1 + 32));
  }
  else if (a2 == 2)
  {
    os_release(*(void **)(a1 + 32));
    os_release(*(void **)(a1 + 40));
  }
}

uint64_t ___mdns_dns_service_manager_handle_network_change_event_block_invoke(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 256) == *(_DWORD *)(a1 + 32))
    *(_BYTE *)(a2 + 286) = 1;
  return 1;
}

uint64_t ___mdns_dns_service_manager_enumerate_service_array_including_variants_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  const __CFArray *v5;

  result = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  if ((_DWORD)result)
  {
    v5 = *(const __CFArray **)(a2 + 128);
    return !v5 || mdns_cfarray_enumerate(v5, *(_QWORD *)(a1 + 32));
  }
  return result;
}

uint64_t ___mdns_dns_service_manager_handle_network_change_event_block_invoke_2(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 256) == *(_DWORD *)(a1 + 32))
    *(_DWORD *)(a2 + 264) = 0;
  return 1;
}

void _mdns_dns_service_add_domain(uint64_t a1, void *a2, unsigned int a3)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  int v10;

  v6 = malloc_type_calloc(1uLL, 0x18uLL, 0xF1748037uLL);
  if (v6)
  {
    v7 = (uint64_t)v6;
    v6[1] = a2;
    os_retain(a2);
    *(_DWORD *)(v7 + 16) = a3;
    v8 = a1 + 88;
    do
    {
      v9 = (_QWORD *)v8;
      v8 = *(_QWORD *)v8;
      if (!v8)
        goto LABEL_6;
      v10 = _domain_item_compare(v7, v8, 1);
    }
    while (v10 > 0);
    if (v10)
    {
LABEL_6:
      *(_QWORD *)v7 = v8;
      *v9 = v7;
      return;
    }
    if (*(_DWORD *)(v8 + 16) > a3)
      *(_DWORD *)(v8 + 16) = a3;
    _domain_item_free((_QWORD *)v7);
  }
  else
  {
    __break(1u);
  }
}

uint64_t _mdns_dns_service_append_address(uint64_t a1, void *value)
{
  __CFArray *Mutable;

  Mutable = *(__CFArray **)(a1 + 80);
  if (!Mutable)
  {
    Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
    *(_QWORD *)(a1 + 80) = Mutable;
    if (!Mutable)
      return 4294960567;
  }
  CFArrayAppendValue(Mutable, value);
  return 0;
}

void mdns_dns_service_manager_deregister_native_service(uint64_t a1, uint64_t a2)
{
  _QWORD v4[6];

  if (a2)
  {
    if (_mdns_dns_service_queue_s_once != -1)
      dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 0x40000000;
    v4[2] = __mdns_dns_service_manager_deregister_native_service_block_invoke;
    v4[3] = &__block_descriptor_tmp_8_809;
    v4[4] = a1;
    v4[5] = a2;
    dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, v4);
  }
}

void __mdns_dns_service_manager_deregister_native_service_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t service_by_id;

  v1 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v1 + 131))
  {
    service_by_id = _mdns_dns_service_manager_get_service_by_id(*(const __CFArray **)(v1 + 24), *(_QWORD *)(a1 + 40));
    if (service_by_id)
      _mdns_dns_service_manager_deregister_service(v1, service_by_id);
  }
}

uint64_t _mdns_dns_service_manager_get_service_by_id(const __CFArray *a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD v4[6];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___mdns_dns_service_manager_get_service_by_id_block_invoke;
  v4[3] = &unk_10013AC00;
  v4[4] = &v5;
  v4[5] = a2;
  mdns_cfarray_enumerate(a1, (uint64_t)v4);
  v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

void _mdns_dns_service_manager_deregister_service(uint64_t a1, uint64_t a2)
{
  int v2;
  unsigned int v5;
  NSObject *monotonic_timer;
  int v7;
  NSObject *v8;
  uint64_t v9;
  int v10;
  NSObject *v11;
  uint64_t v12;
  NSObject *v13;
  _QWORD v14[6];
  uint8_t buf[4];
  uint64_t v16;
  __int16 v17;
  int v18;

  v2 = *(_DWORD *)(a2 + 264) - 1;
  *(_DWORD *)(a2 + 264) = v2;
  if (!v2)
  {
    v5 = *(_DWORD *)(a2 + 272);
    if (!v5)
      goto LABEL_13;
    if (_mdns_dns_service_queue_s_once != -1)
      dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
    monotonic_timer = _mdns_dispatch_create_monotonic_timer(v5, 0xFFFFFFFFFFFFFFFFLL, 5u, _mdns_dns_service_queue_s_queue);
    *(_QWORD *)(a2 + 224) = monotonic_timer;
    v7 = *(_DWORD *)(a2 + 264);
    if (monotonic_timer)
    {
      *(_DWORD *)(a2 + 264) = v7 + 1;
      v14[0] = _NSConcreteStackBlock;
      v14[1] = 0x40000000;
      v14[2] = ___mdns_dns_service_decrement_use_count_block_invoke;
      v14[3] = &__block_descriptor_tmp_72;
      v14[4] = a2;
      v14[5] = a1;
      dispatch_source_set_event_handler(monotonic_timer, v14);
      if (_mdns_dns_service_log_s_once != -1)
        dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
      v8 = _mdns_dns_service_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
      {
        v9 = *(_QWORD *)(a2 + 24);
        v10 = *(_DWORD *)(a2 + 272);
        *(_DWORD *)buf = 134218240;
        v16 = v9;
        v17 = 1024;
        v18 = v10;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "Keeping orphaned DNS service %llu for up to %u milliseconds", buf, 0x12u);
      }
      dispatch_activate(*(dispatch_object_t *)(a2 + 224));
      v7 = *(_DWORD *)(a2 + 264);
    }
    if (!v7)
    {
LABEL_13:
      if (_mdns_dns_service_log_s_once != -1)
        dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
      v11 = _mdns_dns_service_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
      {
        v12 = *(_QWORD *)(a2 + 24);
        *(_DWORD *)buf = 134217984;
        v16 = v12;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "Deregistered DNS service -- service id: %llu", buf, 0xCu);
      }
      v13 = *(NSObject **)(a1 + 96);
      if (v13)
        dispatch_source_merge_data(v13, 1uLL);
    }
  }
}

void ___mdns_dns_service_decrement_use_count_block_invoke(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  NSObject *v5;
  int v6;
  uint64_t v7;

  v2 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(v2 + 224))
  {
    _mdns_dns_service_clear_use_count(v2);
    if (_mdns_dns_service_log_s_once != -1)
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
    v3 = _mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
    {
      v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 24);
      v6 = 134217984;
      v7 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "Deregistered orphaned DNS service due to timeout -- service id: %llu", (uint8_t *)&v6, 0xCu);
    }
    v5 = *(NSObject **)(*(_QWORD *)(a1 + 40) + 96);
    if (v5)
      dispatch_source_merge_data(v5, 1uLL);
  }
}

BOOL ___mdns_dns_service_manager_get_service_by_id_block_invoke(uint64_t a1, uint64_t a2)
{
  if (*(_QWORD *)(a2 + 24) == *(_QWORD *)(a1 + 40))
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = a2;
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) == 0;
}

void mdns_dns_service_manager_deregister_discovered_push_service(uint64_t a1, uint64_t a2)
{
  _QWORD v4[6];

  if (a2)
  {
    if (_mdns_dns_service_queue_s_once != -1)
      dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 0x40000000;
    v4[2] = __mdns_dns_service_manager_deregister_discovered_push_service_block_invoke;
    v4[3] = &__block_descriptor_tmp_9;
    v4[4] = a1;
    v4[5] = a2;
    dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, v4);
  }
}

void __mdns_dns_service_manager_deregister_discovered_push_service_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t service_by_id;

  v1 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v1 + 131))
  {
    service_by_id = _mdns_dns_service_manager_get_service_by_id(*(const __CFArray **)(v1 + 64), *(_QWORD *)(a1 + 40));
    if (service_by_id)
      _mdns_dns_service_manager_deregister_service(v1, service_by_id);
  }
}

void __mdns_dns_service_manager_register_custom_push_service_block_invoke(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;

  v2 = *(_QWORD *)(a1 + 56);
  if (*(_BYTE *)(v2 + 131))
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = -6752;
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = _mdns_dns_service_manager_register_push_service_internal_from_definition((CFArrayRef *)v2, *(__CFArray **)(v2 + 72), *(_QWORD *)(a1 + 64), *(_DWORD *)(a1 + 80), *(NSObject **)(a1 + 72), *(const void **)(a1 + 32), (int *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8)+ 24));
    if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24))
    {
      v3 = *(NSObject **)(*(_QWORD *)(a1 + 56) + 96);
      if (v3)
        dispatch_source_merge_data(v3, 1uLL);
    }
  }
}

uint64_t _mdns_dns_service_manager_register_push_service_internal_from_definition(CFArrayRef *a1, __CFArray *a2, uint64_t a3, int a4, NSObject *a5, const void *a6, int *a7)
{
  unsigned int v13;
  unsigned int v14;
  BOOL v15;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v22;
  int v23;
  __int16 v24;
  __int16 v25;
  uint64_t v26;
  NSObject *v28;
  uint64_t v29;
  void *v30;
  const __CFArray *v31;
  CFArrayRef Copy;
  _QWORD v33[6];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  int v37;
  __int128 buf;
  BOOL (*v39)(uint64_t, void *);
  void *v40;
  uint64_t *v41;
  uint64_t v42;

  v34 = 0;
  v35 = &v34;
  v36 = 0x2000000000;
  v37 = 0;
  v13 = *(_DWORD *)(a3 + 72);
  v14 = *(unsigned __int8 *)(a3 + 78);
  if (*(_BYTE *)(a3 + 78))
    v15 = v13 == 0;
  else
    v15 = 0;
  if (v15 || v14 > 2)
  {
    v17 = 0;
    v18 = 0;
    v19 = -6705;
    goto LABEL_10;
  }
  v22 = _mdns_dns_service_create(5, 1, (0x50201u >> (8 * v14)) & 7, &v37);
  v18 = v22;
  v19 = *((_DWORD *)v35 + 6);
  if (!v19)
  {
    *(_DWORD *)(v22 + 256) = v13;
    if (v13)
      *(_QWORD *)(v22 + 104) = mdns_system_interface_index_to_name(v13);
    *(_WORD *)(v18 + 276) = 6;
    v23 = *(unsigned __int8 *)(a3 + 79);
    if (*(_BYTE *)(a3 + 79))
      v24 = 8198;
    else
      v24 = 6;
    *(_WORD *)(v18 + 276) = v24;
    if (*(_BYTE *)(a3 + 80))
    {
      if (v23)
        v25 = 24582;
      else
        v25 = 16390;
      *(_WORD *)(v18 + 276) = v25;
    }
    *(_QWORD *)&buf = _NSConcreteStackBlock;
    *((_QWORD *)&buf + 1) = 0x40000000;
    v39 = ___mdns_dns_service_create_push_service_from_definition_block_invoke;
    v40 = &unk_10013AE78;
    v41 = &v34;
    v42 = v18;
    mdns_cfset_enumerate(*(const __CFSet **)(a3 + 48), (uint64_t)&buf);
    v19 = *((_DWORD *)v35 + 6);
    if (v19)
      goto LABEL_26;
    v29 = *(_QWORD *)(a3 + 24);
    if (v29)
    {
      os_retain(*(void **)(a3 + 24));
      v30 = *(void **)(v18 + 216);
      if (v30)
        os_release(v30);
      *(_QWORD *)(v18 + 216) = v29;
    }
    else
    {
      if (CFArrayGetCount(*(CFArrayRef *)(a3 + 40)) < 1 || !CFArrayGetValueAtIndex(*(CFArrayRef *)(a3 + 40), 0))
      {
        v19 = -6705;
        goto LABEL_56;
      }
      v33[0] = _NSConcreteStackBlock;
      v33[1] = 0x40000000;
      v33[2] = ___mdns_dns_service_create_push_service_from_definition_block_invoke_2;
      v33[3] = &unk_10013AEA0;
      v33[4] = &v34;
      v33[5] = v18;
      mdns_cfarray_enumerate(*(const __CFArray **)(a3 + 40), (uint64_t)v33);
      v19 = *((_DWORD *)v35 + 6);
      if (v19)
      {
LABEL_26:
        v20 = 0;
        goto LABEL_27;
      }
    }
    v31 = *(const __CFArray **)(a3 + 56);
    if (!v31 || (Copy = CFArrayCreateCopy(kCFAllocatorDefault, v31), (*(_QWORD *)(v18 + 232) = Copy) != 0))
    {
      v19 = 0;
      v17 = 0;
      goto LABEL_10;
    }
    v19 = -6729;
LABEL_56:
    v17 = v18;
    v18 = 0;
LABEL_10:
    v20 = v18;
    *((_DWORD *)v35 + 6) = v19;
    v18 = v17;
    if (!v17)
      goto LABEL_28;
LABEL_27:
    os_release((void *)v18);
    goto LABEL_28;
  }
  v20 = 0;
  if (v22)
    goto LABEL_27;
LABEL_28:
  _Block_object_dispose(&v34, 8);
  if (v19)
  {
    v26 = 0;
    if (!a7)
      goto LABEL_31;
    goto LABEL_30;
  }
  *(_DWORD *)(v20 + 272) = a4;
  if (a5 && a6)
  {
    *(_QWORD *)(v20 + 240) = a5;
    dispatch_retain(a5);
    *(_QWORD *)(v20 + 248) = _Block_copy(a6);
  }
  _mdns_dns_service_increment_use_count(v20);
  CFArrayAppendValue(a2, (const void *)v20);
  _mdns_dns_service_manager_update_interface_properties_for_service(a1, v20);
  if (_mdns_dns_service_log_s_once != -1)
    dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
  v28 = _mdns_dns_service_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 138412290;
    *(_QWORD *)((char *)&buf + 4) = v20;
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Registered push service -- %@", (uint8_t *)&buf, 0xCu);
  }
  v26 = *(_QWORD *)(v20 + 24);
  if (a7)
LABEL_30:
    *a7 = v19;
LABEL_31:
  if (v20)
    os_release((void *)v20);
  return v26;
}

BOOL ___mdns_dns_service_create_push_service_from_definition_block_invoke(uint64_t a1, void *a2)
{
  _mdns_dns_service_add_domain(*(_QWORD *)(a1 + 40), a2, 0);
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  return *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) == 0;
}

BOOL ___mdns_dns_service_create_push_service_from_definition_block_invoke_2(uint64_t a1, void *a2)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = _mdns_dns_service_append_address(*(_QWORD *)(a1 + 40), a2);
  return *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) == 0;
}

void mdns_dns_service_manager_deregister_custom_push_service(uint64_t a1, uint64_t a2)
{
  _QWORD v4[6];

  if (a2)
  {
    if (_mdns_dns_service_queue_s_once != -1)
      dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 0x40000000;
    v4[2] = __mdns_dns_service_manager_deregister_custom_push_service_block_invoke;
    v4[3] = &__block_descriptor_tmp_11_814;
    v4[4] = a1;
    v4[5] = a2;
    dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, v4);
  }
}

void __mdns_dns_service_manager_deregister_custom_push_service_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t service_by_id;

  v1 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v1 + 131))
  {
    service_by_id = _mdns_dns_service_manager_get_service_by_id(*(const __CFArray **)(v1 + 72), *(_QWORD *)(a1 + 40));
    if (service_by_id)
      _mdns_dns_service_manager_deregister_service(v1, service_by_id);
  }
}

void __mdns_dns_service_manager_apply_dns_config_block_invoke(uint64_t a1)
{
  uint64_t v1;
  unsigned int *v2;
  CFIndex Count;
  const __CFAllocator *v4;
  CFIndex v5;
  NSObject *v6;
  __CFArray *Mutable;
  __CFArray *MutableCopy;
  unint64_t i;
  const void *ValueAtIndex;
  const void *v11;
  const __CFArray *v12;
  const __CFArray *v13;
  int appended;
  CFIndex v15;
  CFIndex v16;
  uint64_t v17;
  const __CFArray **v18;
  CFIndex FirstIndexOfValue;
  CFIndex v20;
  __int16 v21;
  const __CFArray *v22;
  const void *v23;
  int v24;
  _QWORD v25[4];
  __int16 v26;
  uint8_t buf[8];
  uint64_t v28;
  uint64_t (*v29)(uint64_t, uint64_t);
  void *v30;
  uint64_t v31;
  CFRange v32;
  CFRange v33;

  v1 = *(_QWORD *)(a1 + 32);
  if (*(_BYTE *)(v1 + 131))
    return;
  v2 = *(unsigned int **)(a1 + 40);
  Count = CFArrayGetCount(*(CFArrayRef *)(v1 + 48));
  if (Count > 3)
  {
    v5 = Count;
    if (_mdns_dns_service_log_s_once != -1)
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
    v6 = _mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Purging %u discovered services down to 4", buf, 8u);
    }
    v4 = kCFAllocatorDefault;
    Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
    MutableCopy = CFArrayCreateMutableCopy(kCFAllocatorDefault, 0, *(CFArrayRef *)(v1 + 48));
    v32.location = 0;
    v32.length = v5;
    CFArraySortValues(MutableCopy, v32, (CFComparatorFunction)_mdns_dns_service_compare_time, 0);
    for (i = 0; i != v5; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(MutableCopy, i);
      if (i < 4)
        CFArrayAppendValue(Mutable, ValueAtIndex);
      else
        _mdns_dns_service_manager_terminate_service(v1, (uint64_t)ValueAtIndex);
    }
    if (MutableCopy)
      CFRelease(MutableCopy);
    v11 = *(const void **)(v1 + 48);
    if (v11)
      CFRelease(v11);
    *(_QWORD *)(v1 + 48) = Mutable;
  }
  else
  {
    v4 = kCFAllocatorDefault;
  }
  v12 = CFArrayCreateMutable(v4, 0, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
  if (!v12)
  {
    v24 = -6729;
    goto LABEL_36;
  }
  v13 = v12;
  appended = _mdns_append_dns_service_from_config_by_scope(v12, v2, 1);
  if (appended
    || (appended = _mdns_append_dns_service_from_config_by_scope(v13, v2, 2)) != 0
    || (appended = _mdns_append_dns_service_from_config_by_scope(v13, v2, 3)) != 0)
  {
    v24 = appended;
    CFRelease(v13);
LABEL_36:
    _mdns_dns_service_manager_terminate(v1, v24);
    return;
  }
  v15 = CFArrayGetCount(v13);
  v16 = CFArrayGetCount(*(CFArrayRef *)(v1 + 32));
  if (v16 - 1 >= 0)
  {
    v17 = v16;
    do
    {
      v18 = (const __CFArray **)CFArrayGetValueAtIndex(*(CFArrayRef *)(v1 + 32), --v17);
      v33.location = 0;
      v33.length = v15;
      FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v13, v33, v18);
      if (FirstIndexOfValue < 0)
      {
        _mdns_dns_service_manager_terminate_service(v1, (uint64_t)v18);
      }
      else
      {
        v20 = FirstIndexOfValue;
        v21 = *((_WORD *)CFArrayGetValueAtIndex(v13, FirstIndexOfValue) + 138) & 0xE;
        *((_WORD *)v18 + 138) = *((_WORD *)v18 + 138) & 0xFFF1 | v21;
        v25[0] = _NSConcreteStackBlock;
        v25[1] = 0x40000000;
        v25[2] = ___mdns_dns_service_manager_apply_dns_config_internal_block_invoke;
        v25[3] = &__block_descriptor_tmp_65_817;
        v26 = v21;
        v22 = v18[18];
        if (v22)
          mdns_cfarray_enumerate(v22, (uint64_t)v25);
        CFArraySetValueAtIndex(v13, v20, v18);
      }
    }
    while (v17 > 0);
  }
  v23 = *(const void **)(v1 + 32);
  if (v23)
    CFRelease(v23);
  *(_QWORD *)(v1 + 32) = v13;
  *(_QWORD *)buf = _NSConcreteStackBlock;
  v28 = 0x40000000;
  v29 = ___mdns_dns_service_manager_apply_dns_config_internal_block_invoke_2;
  v30 = &__block_descriptor_tmp_66;
  v31 = v1;
  mdns_cfarray_enumerate(v13, (uint64_t)buf);
  _mdns_dns_service_manager_remove_unneeded_interface_monitors(v1);
}

uint64_t _mdns_dns_service_compare_time(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  BOOL v4;
  _BOOL8 v5;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_QWORD *)(a2 + 32);
  v4 = v2 > v3;
  v5 = v2 < v3;
  if (v4)
    return -1;
  else
    return v5;
}

uint64_t _mdns_append_dns_service_from_config_by_scope(const __CFArray *a1, unsigned int *a2, int a3)
{
  char v3;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t result;
  int v13;
  uint64_t v14;
  unsigned int v15;
  __int16 v16;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  void *v21;
  int *v22;
  uint8_t *v23;
  int v24;
  NSObject *v25;
  _BOOL4 v26;
  int v27;
  int v28;
  uint64_t v29;
  int v30;
  char *v31;
  CFIndex Count;
  CFIndex v33;
  CFIndex v34;
  const void *ValueAtIndex;
  int v36;
  unsigned int v37;
  char *v38;
  uint64_t v39;
  uint64_t v41;
  unsigned int appended;
  uint8_t v43[16];
  uint64_t v44;
  int v45;
  uint8_t buf[32];
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;

  v3 = a3;
  switch(a3)
  {
    case 3:
      v5 = (uint64_t *)(a2 + 9);
      a2 += 8;
      break;
    case 2:
      v5 = (uint64_t *)(a2 + 4);
      a2 += 3;
      break;
    case 1:
      v5 = (uint64_t *)(a2 + 1);
      break;
    default:
      return 0;
  }
  v6 = *a2;
  if ((int)v6 < 1)
    return 0;
  v7 = 0;
  v8 = *v5;
  appended = 0;
  v41 = v8;
  v39 = v6;
  while (1)
  {
    v9 = *(_QWORD *)(v8 + 8 * v7);
    if (*(_WORD *)(v9 + 20) == 5353 || !*(_DWORD *)(v9 + 8))
      goto LABEL_64;
    if (*(_QWORD *)v9)
    {
      v59 = 0u;
      v60 = 0u;
      v57 = 0u;
      v58 = 0u;
      v55 = 0u;
      v56 = 0u;
      v53 = 0u;
      v54 = 0u;
      v51 = 0u;
      v52 = 0u;
      v49 = 0u;
      v50 = 0u;
      v47 = 0u;
      v48 = 0u;
      memset(buf, 0, sizeof(buf));
      if (DomainNameFromString(buf, *(char **)v9))
      {
        if (_mdns_dns_service_log_s_once != -1)
          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
        v10 = _mdns_dns_service_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
        {
          v38 = *(char **)v9;
          *(_DWORD *)v43 = 136315138;
          *(_QWORD *)&v43[4] = v38;
          _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Encountered invalid dns_config_t resolver domain name: %s", v43, 0xCu);
        }
        v8 = v41;
        goto LABEL_64;
      }
    }
    v11 = _mdns_dns_service_create(1, 2, v3, (int *)&appended);
    result = appended;
    if (appended)
      goto LABEL_68;
    v13 = *(_DWORD *)(v9 + 8);
    if (v13 >= 1)
      break;
LABEL_40:
    *(_DWORD *)(v11 + 256) = *(_DWORD *)(v9 + 64);
    v3 = a3;
    if (a3 == 3)
      v30 = *(_DWORD *)(v9 + 76);
    else
      v30 = 0;
    v6 = v39;
    v8 = v41;
    *(_DWORD *)(v11 + 260) = v30;
    *(_WORD *)(v11 + 276) = 0;
    if (*(_QWORD *)v9)
      v31 = *(char **)v9;
    else
      v31 = ".";
    Count = CFArrayGetCount(a1);
    if (Count < 1)
    {
LABEL_51:
      v36 = *(_DWORD *)(v9 + 68);
      if ((v36 & 2) != 0)
        *(_WORD *)(v11 + 276) |= 2u;
      if ((v36 & 4) != 0)
        *(_WORD *)(v11 + 276) |= 4u;
      if ((*(_BYTE *)(v9 + 74) & 4) != 0)
        *(_WORD *)(v11 + 276) |= 8u;
      v37 = *(_DWORD *)(v11 + 256);
      if (v37)
        *(_QWORD *)(v11 + 104) = mdns_system_interface_index_to_name(v37);
      appended = _mdns_dns_service_add_domain_by_string(v11, v31, *(_DWORD *)(v9 + 60));
      if (appended)
        goto LABEL_69;
      CFArrayAppendValue(a1, (const void *)v11);
    }
    else
    {
      v33 = Count;
      v34 = 0;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(a1, v34);
        if (_mdns_dns_service_equal_ex((uint64_t)ValueAtIndex, v11, 1))
          break;
        if (v33 == ++v34)
        {
          v3 = a3;
          v6 = v39;
          v8 = v41;
          if (!v11)
            goto LABEL_64;
          goto LABEL_51;
        }
      }
      result = _mdns_dns_service_add_domain_by_string((uint64_t)ValueAtIndex, v31, *(_DWORD *)(v9 + 60));
      appended = result;
      if ((_DWORD)result)
        goto LABEL_68;
      v3 = a3;
      v6 = v39;
      v8 = v41;
      if (!v11)
        goto LABEL_64;
    }
    os_release((void *)v11);
LABEL_64:
    if (++v7 == v6)
      return 0;
  }
  v14 = 0;
  v15 = *(unsigned __int16 *)(v9 + 20);
  if (!*(_WORD *)(v9 + 20))
    v15 = 53;
  v16 = __rev16(v15);
  while (1)
  {
    v17 = *(_QWORD *)(*(_QWORD *)(v9 + 12) + 8 * v14);
    v18 = *(unsigned __int8 *)(v17 + 1);
    if (v18 == 30)
      break;
    if (v18 == 2)
    {
      v19 = *(_DWORD *)(v17 + 4);
      v20 = _mdns_address_new();
      if (!v20)
        goto LABEL_67;
      v21 = (void *)v20;
      *(_WORD *)(v20 + 24) = 528;
      *(_WORD *)(v20 + 26) = v16;
      *(_DWORD *)(v20 + 28) = v19;
      goto LABEL_37;
    }
LABEL_39:
    if (++v14 >= v13)
      goto LABEL_40;
  }
  v22 = (int *)(v17 + 24);
  v23 = (uint8_t *)(v17 + 8);
  memset(v43, 0, sizeof(v43));
  v45 = 0;
  v44 = 0;
  if (*(unsigned __int8 *)(v17 + 8) == 254 && (*(_BYTE *)(v17 + 9) & 0xC0) == 0x80)
  {
    v24 = *(_DWORD *)(v9 + 64);
    if (v24)
    {
      if (*v22 != v24)
      {
        *(_OWORD *)v43 = *(_OWORD *)v17;
        v44 = *(_QWORD *)(v17 + 16);
        v45 = v24;
        if (_mdns_dns_service_log_s_once != -1)
          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
        v25 = _mdns_dns_service_log_s_log;
        v26 = os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT);
        v23 = &v43[8];
        v22 = &v45;
        if (v26)
        {
          v27 = *(_DWORD *)(v17 + 24);
          *(_DWORD *)buf = 68158466;
          *(_DWORD *)&buf[4] = 28;
          *(_WORD *)&buf[8] = 2096;
          *(_QWORD *)&buf[10] = v17;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v27;
          *(_WORD *)&buf[24] = 1024;
          *(_DWORD *)&buf[26] = v24;
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Corrected scope ID of link-local server address %{network:sockaddr}.*P from %u to %u", buf, 0x1Eu);
          v23 = &v43[8];
          v22 = &v45;
        }
      }
    }
  }
  v28 = *v22;
  v29 = _mdns_address_new();
  if (v29)
  {
    v21 = (void *)v29;
    *(_WORD *)(v29 + 24) = 7708;
    *(_WORD *)(v29 + 26) = v16;
    *(_OWORD *)(v29 + 32) = *(_OWORD *)v23;
    *(_DWORD *)(v29 + 48) = v28;
LABEL_37:
    appended = _mdns_dns_service_append_address(v11, v21);
    os_release(v21);
    result = appended;
    if (appended)
      goto LABEL_68;
    v13 = *(_DWORD *)(v9 + 8);
    goto LABEL_39;
  }
LABEL_67:
  result = 4294960568;
  appended = -6728;
LABEL_68:
  if (v11)
  {
LABEL_69:
    os_release((void *)v11);
    return appended;
  }
  return result;
}

uint64_t ___mdns_dns_service_manager_apply_dns_config_internal_block_invoke(uint64_t a1, uint64_t a2)
{
  __int16 v2;

  v2 = *(_WORD *)(a2 + 276) & 0xFFF1;
  *(_WORD *)(a2 + 276) = v2;
  *(_WORD *)(a2 + 276) = *(_WORD *)(a1 + 32) | v2;
  return 1;
}

uint64_t ___mdns_dns_service_manager_apply_dns_config_internal_block_invoke_2(uint64_t a1, uint64_t a2)
{
  if (!*(_DWORD *)(a2 + 264))
  {
    _mdns_dns_service_increment_use_count(a2);
    _mdns_dns_service_manager_update_interface_properties_for_service(*(CFArrayRef **)(a1 + 32), a2);
  }
  return 1;
}

void _mdns_dns_service_manager_remove_unneeded_interface_monitors(uint64_t a1)
{
  CFIndex Count;
  CFIndex v3;
  _DWORD *ValueAtIndex;
  int v5;
  _QWORD v6[4];
  int v7;
  _QWORD v8[5];
  _QWORD v9[5];

  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 80));
  if (Count - 1 >= 0)
  {
    v3 = Count;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 80), --v3);
      v5 = ValueAtIndex[34];
      v6[0] = _NSConcreteStackBlock;
      v6[1] = 0x40000000;
      v6[2] = ___mdns_dns_service_manager_uses_interface_block_invoke;
      v6[3] = &__block_descriptor_tmp_118;
      v7 = v5;
      v8[0] = _NSConcreteStackBlock;
      v8[1] = 0x40000000;
      v8[2] = ___mdns_dns_service_manager_enumerate_all_services_block_invoke;
      v8[3] = &unk_10013B258;
      v8[4] = v6;
      v9[0] = _NSConcreteStackBlock;
      v9[1] = 0x40000000;
      v9[2] = ___mdns_dns_service_manager_enumerate_all_service_arrays_block_invoke;
      v9[3] = &unk_10013B230;
      v9[4] = v8;
      if (_mdns_dns_service_manager_enumerate_all_service_array_pointers(a1, (uint64_t)v9))
      {
        mdns_interface_monitor_invalidate(ValueAtIndex);
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 80), v3);
      }
    }
    while (v3 > 0);
  }
}

BOOL ___mdns_dns_service_manager_uses_interface_block_invoke(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a2 + 256) != *(_DWORD *)(a1 + 32);
}

uint64_t _mdns_dns_service_add_domain_by_string(uint64_t a1, char *a2, unsigned int a3)
{
  _QWORD *v5;
  void *v6;
  unsigned int v8;

  v8 = 0;
  v5 = mdns_domain_name_create(a2, &v8);
  if (v5)
  {
    v6 = v5;
    _mdns_dns_service_add_domain(a1, v5, a3);
    v8 = 0;
    os_release(v6);
  }
  return v8;
}

void __mdns_dns_service_manager_register_path_resolver_block_invoke(uint64_t a1)
{
  uint64_t v1;
  const unsigned __int8 *v2;
  uint64_t service_by_uuid;
  void *v4;
  char *v5;
  char *v6;
  __CFArray *v7;
  NSObject *v8;
  NSObject *v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  int v13;
  uint8_t buf[4];
  _BYTE v15[14];
  __int16 v16;
  void *v17;
  __int16 v18;
  uint64_t v19;
  _BYTE v20[32];
  uint64_t v21;
  void *v22;

  v1 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v1 + 131))
  {
    v2 = *(const unsigned __int8 **)(a1 + 40);
    service_by_uuid = _mdns_dns_service_manager_get_service_by_uuid(*(const __CFArray **)(v1 + 40), v2);
    if (service_by_uuid)
    {
      v10 = service_by_uuid;
      if (_mdns_dns_service_log_s_once != -1)
        dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
      v11 = _mdns_dns_service_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEBUG))
      {
        v12 = *(_QWORD *)(v10 + 24);
        *(_DWORD *)v20 = 134218498;
        *(_QWORD *)&v20[4] = v12;
        *(_WORD *)&v20[12] = 1040;
        *(_DWORD *)&v20[14] = 16;
        *(_WORD *)&v20[18] = 2096;
        *(_QWORD *)&v20[20] = v2;
        _os_log_debug_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "Already registered service -- service id: %llu, uuid: %{uuid_t}.16P", v20, 0x1Cu);
      }
    }
    else
    {
      v4 = (void *)nw_resolver_config_create();
      nw_resolver_config_set_identifier(v4, v2);
      os_retain((void *)v1);
      nw_retain(v4);
      if (_mdns_dns_service_queue_s_once != -1)
        dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
      *(_QWORD *)v20 = _NSConcreteStackBlock;
      *(_QWORD *)&v20[8] = 0x40000000;
      *(_QWORD *)&v20[16] = ___mdns_dns_service_manager_register_path_resolver_internal_block_invoke;
      *(_QWORD *)&v20[24] = &__block_descriptor_tmp_69;
      v21 = v1;
      v22 = v4;
      nw_resolver_config_watch_updates(v4, _mdns_dns_service_queue_s_queue, v20);
      v13 = 0;
      v5 = _mdns_dns_service_create_from_resolver_config(v4, 3, 4, &v13);
      if (v5)
      {
        v6 = v5;
        v5[284] = 1;
        v7 = *(__CFArray **)(v1 + 40);
        _mdns_dns_service_increment_use_count((uint64_t)v5);
        CFArrayAppendValue(v7, v6);
        _mdns_dns_service_manager_update_interface_properties_for_service((CFArrayRef *)v1, (uint64_t)v6);
        if (_mdns_dns_service_log_s_once != -1)
          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
        v8 = _mdns_dns_service_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412290;
          *(_QWORD *)v15 = v6;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Registered service -- %@", buf, 0xCu);
        }
        os_release(v6);
      }
      else
      {
        _mdns_dns_service_manager_cancel_resolver_config_updates(v1, (uint64_t)v4);
        if (_mdns_dns_service_log_s_once != -1)
          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
        v9 = _mdns_dns_service_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 68158466;
          *(_DWORD *)v15 = 16;
          *(_WORD *)&v15[4] = 2096;
          *(_QWORD *)&v15[6] = v2;
          v16 = 2112;
          v17 = v4;
          v18 = 2048;
          v19 = v13;
          _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Failed to register service -- uuid: %{uuid_t}.16P, config: %@, error: %{mdns:err}ld", buf, 0x26u);
        }
      }
      nw_release(v4);
    }
  }
}

uint64_t _mdns_dns_service_manager_get_service_by_uuid(const __CFArray *a1, const unsigned __int8 *a2)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v9[5];
  __int128 v10;
  int v11;
  uuid_t dst;
  int v13;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  v13 = 3;
  memset(dst, 0, sizeof(dst));
  uuid_copy(dst, a2);
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = ___mdns_dns_service_manager_get_service_by_uuid_block_invoke;
  v9[3] = &unk_10013A878;
  v10 = *(_OWORD *)dst;
  v11 = v13;
  v9[4] = &v5;
  mdns_cfarray_enumerate(a1, (uint64_t)v9);
  v3 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v3;
}

void ___mdns_dns_service_manager_register_path_resolver_internal_block_invoke(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t path_service_by_config;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t provider_name;
  uint64_t provider_path;
  uint64_t odoh_config;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  void (*v15)(void);
  NSObject *v16;
  const __CFArray *v17;
  uint64_t v18;
  const char *string_ptr;
  const char *v20;
  const char *v21;
  const char *v22;
  NSObject *v23;
  uint64_t v24;
  __int128 buf;
  uint64_t (*v26)(uint64_t, uint64_t);
  void *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_QWORD *)(a1 + 40);
  if (a2)
  {
    path_service_by_config = _mdns_dns_service_manager_get_path_service_by_config(*(const __CFArray **)(v2 + 40), v3);
    if (path_service_by_config)
    {
      v5 = path_service_by_config;
      _mdns_dns_service_manager_deregister_service(v2, path_service_by_config);
      if (_mdns_dns_service_log_s_once != -1)
        dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
      v6 = _mdns_dns_service_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 138412290;
        *(_QWORD *)((char *)&buf + 4) = v5;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Deregistered service -- %@", (uint8_t *)&buf, 0xCu);
      }
    }
    return;
  }
  if (v3)
  {
    if (nw_resolver_config_get_protocol(*(_QWORD *)(a1 + 40)) == 3)
    {
      v7 = _mdns_dns_service_manager_get_path_service_by_config(*(const __CFArray **)(v2 + 40), v3);
      if (v7)
      {
        v8 = v7;
        provider_name = nw_resolver_config_get_provider_name(*(_QWORD *)(v7 + 96));
        provider_path = nw_resolver_config_get_provider_path(*(_QWORD *)(v8 + 96));
        v24 = 0;
        odoh_config = nw_resolver_config_get_odoh_config(*(_QWORD *)(v8 + 96), &v24);
        v12 = nw_resolver_config_copy_proxy_config(*(_QWORD *)(v8 + 96));
        v13 = (void *)v12;
        if (v12)
          nw_proxy_config_set_prohibit_direct(v12, 1);
        v14 = *(_QWORD *)(v8 + 64);
        if (v14)
        {
          v15 = *(void (**)(void))(*(_QWORD *)(v14 + 16) + 96);
          if (v15)
            v15();
          if (_mdns_dns_service_log_s_once != -1)
            dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
          v16 = _mdns_dns_service_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 138412290;
            *(_QWORD *)((char *)&buf + 4) = v8;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Updated ODoH config -- %@", (uint8_t *)&buf, 0xCu);
          }
        }
        *(_QWORD *)&buf = _NSConcreteStackBlock;
        *((_QWORD *)&buf + 1) = 0x40000000;
        v26 = ___mdns_dns_service_manager_handle_resolver_config_update_block_invoke;
        v27 = &__block_descriptor_tmp_73;
        v28 = provider_name;
        v29 = provider_path;
        v30 = odoh_config;
        v31 = v24;
        v32 = v13;
        v17 = *(const __CFArray **)(v8 + 128);
        if (v17)
          mdns_cfarray_enumerate(v17, (uint64_t)&buf);
        if (v13)
          nw_release(v13);
        v18 = *(_QWORD *)(v8 + 96);
        if (v18)
        {
          if (!*(_QWORD *)(v8 + 136))
          {
            if (*(_QWORD *)(v8 + 160))
            {
              string_ptr = xpc_string_get_string_ptr(*(xpc_object_t *)(v8 + 160));
              v20 = (const char *)nw_resolver_config_get_provider_name(*(_QWORD *)(v8 + 96));
              if (string_ptr)
              {
                if (v20 && !strcmp(string_ptr, v20))
                {
LABEL_33:
                  v21 = *(const char **)(v8 + 168);
                  v22 = (const char *)nw_resolver_config_get_provider_path(*(_QWORD *)(v8 + 96));
                  if (v21)
                  {
                    if (v22 && !strcmp(v21, v22))
                      return;
                  }
                  else if (!v22)
                  {
                    return;
                  }
                }
              }
              else if (!v20)
              {
                goto LABEL_33;
              }
            }
            else if (!nw_resolver_config_get_provider_name(v18))
            {
              goto LABEL_33;
            }
            v23 = *(NSObject **)(v2 + 96);
            if (v23)
              dispatch_source_merge_data(v23, 1uLL);
          }
        }
      }
    }
  }
}

char *_mdns_dns_service_create_from_resolver_config(void *a1, char a2, char a3, int *a4)
{
  unsigned int protocol;
  char v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  const char *interface_name;
  const char *v14;
  char *result;
  _QWORD v16[5];
  _QWORD v17[6];
  uint64_t v18;
  int *v19;
  uint64_t v20;
  int v21;

  v18 = 0;
  v19 = (int *)&v18;
  v20 = 0x2000000000;
  v21 = 0;
  protocol = nw_resolver_config_get_protocol();
  if (protocol < 4)
    v9 = protocol + 1;
  else
    v9 = 0;
  v10 = _mdns_dns_service_create(v9, a2, a3, v19 + 6);
  v11 = v10;
  v12 = v19[6];
  if (!v12)
  {
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 0x40000000;
    v17[2] = ___mdns_dns_service_create_from_resolver_config_block_invoke;
    v17[3] = &unk_10013A908;
    v17[4] = &v18;
    v17[5] = v10;
    nw_resolver_config_enumerate_name_servers(a1, v17);
    v12 = v19[6];
    if (!v12)
    {
      v16[0] = _NSConcreteStackBlock;
      v16[1] = 0x40000000;
      v16[2] = ___mdns_dns_service_create_from_resolver_config_block_invoke_2;
      v16[3] = &__block_descriptor_tmp_76;
      v16[4] = v11;
      nw_resolver_config_enumerate_match_domains(a1, v16);
      *(_QWORD *)(v11 + 96) = a1;
      nw_retain(a1);
      interface_name = (const char *)nw_resolver_config_get_interface_name(a1);
      if (interface_name)
      {
        v14 = interface_name;
        result = strdup(interface_name);
        if (!result)
        {
          __break(1u);
          return result;
        }
        *(_QWORD *)(v11 + 104) = result;
        *(_DWORD *)(v11 + 256) = if_nametoindex(v14);
      }
      *(_WORD *)(v11 + 276) = 6;
      _mdns_dns_service_update_nw_config_data(v11);
      v12 = 0;
      v19[6] = 0;
    }
  }
  if (a4)
    *a4 = v12;
  _Block_object_dispose(&v18, 8);
  return (char *)v11;
}

BOOL ___mdns_dns_service_create_from_resolver_config_block_invoke(uint64_t a1, char *a2)
{
  void *v3;
  void *v4;
  _BOOL8 result;

  v3 = (void *)mdns_address_create_from_ip_address_string(a2);
  result = 1;
  if (v3)
  {
    v4 = v3;
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = _mdns_dns_service_append_address(*(_QWORD *)(a1 + 40), v3);
    os_release(v4);
    if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
      return 0;
  }
  return result;
}

uint64_t ___mdns_dns_service_create_from_resolver_config_block_invoke_2(uint64_t a1, char *a2)
{
  _mdns_dns_service_add_domain_by_string(*(_QWORD *)(a1 + 32), a2, 0);
  return 1;
}

const char *_mdns_dns_service_update_nw_config_data(uint64_t a1)
{
  const char *result;
  const char *provider_name;
  void *v4;
  const char *string_ptr;
  void *v6;
  xpc_object_t v7;
  const char *v8;
  void *v9;
  void *v10;

  result = *(const char **)(a1 + 96);
  if (result && !*(_QWORD *)(a1 + 136))
  {
    provider_name = (const char *)nw_resolver_config_get_provider_name();
    v4 = *(void **)(a1 + 160);
    if (v4)
    {
      string_ptr = xpc_string_get_string_ptr(v4);
      if (string_ptr)
      {
        if (!provider_name)
        {
          v10 = *(void **)(a1 + 160);
          if (!v10)
            goto LABEL_15;
          xpc_release(v10);
          v7 = 0;
LABEL_14:
          *(_QWORD *)(a1 + 160) = v7;
          goto LABEL_15;
        }
        if (!strcmp(string_ptr, provider_name))
          goto LABEL_15;
      }
      else if (!provider_name)
      {
        goto LABEL_15;
      }
      v6 = *(void **)(a1 + 160);
      if (v6)
      {
        xpc_release(v6);
        *(_QWORD *)(a1 + 160) = 0;
      }
    }
    else if (!provider_name)
    {
LABEL_15:
      result = (const char *)nw_resolver_config_get_provider_path(*(_QWORD *)(a1 + 96));
      v8 = result;
      v9 = *(void **)(a1 + 168);
      if (v9)
      {
        if (!result)
          goto LABEL_22;
        result = (const char *)strcmp(*(const char **)(a1 + 168), result);
        if (!(_DWORD)result)
          return result;
        free(v9);
        *(_QWORD *)(a1 + 168) = 0;
      }
      else if (!result)
      {
        return result;
      }
      result = strdup(v8);
      if (result)
      {
LABEL_23:
        *(_QWORD *)(a1 + 168) = result;
        return result;
      }
      __break(1u);
LABEL_22:
      free(v9);
      result = 0;
      goto LABEL_23;
    }
    v7 = xpc_string_create(provider_name);
    goto LABEL_14;
  }
  return result;
}

uint64_t _mdns_dns_service_manager_get_path_service_by_config(const __CFArray *a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD v4[6];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___mdns_dns_service_manager_get_path_service_by_config_block_invoke;
  v4[3] = &unk_10013A8A0;
  v4[4] = &v5;
  v4[5] = a2;
  mdns_cfarray_enumerate(a1, (uint64_t)v4);
  v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t ___mdns_dns_service_manager_handle_resolver_config_update_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void (*v3)(void);

  v2 = *(_QWORD *)(a2 + 64);
  if (v2)
  {
    v3 = *(void (**)(void))(*(_QWORD *)(v2 + 16) + 96);
    if (v3)
      v3();
  }
  return 1;
}

BOOL ___mdns_dns_service_manager_get_path_service_by_config_block_invoke(uint64_t a1, uint64_t a2)
{
  if (*(_QWORD *)(a2 + 96) == *(_QWORD *)(a1 + 40))
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = a2;
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) == 0;
}

BOOL ___mdns_dns_service_manager_get_service_by_uuid_block_invoke(uint64_t a1, uint64_t a2)
{
  if (_mdns_dns_service_scope_id_match(a2, a1 + 40))
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = a2;
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) == 0;
}

uint64_t _mdns_dns_service_scope_id_match(uint64_t a1, uint64_t a2)
{
  int v3;
  int v4;
  uint64_t v5;
  unsigned __int8 uu1[8];
  uint64_t v8;

  switch(*(_BYTE *)(a1 + 280))
  {
    case 1:
      return !*(_BYTE *)(a2 + 16);
    case 2:
      v3 = *(unsigned __int8 *)(a2 + 16);
      goto LABEL_12;
    case 3:
      if (*(_BYTE *)(a2 + 16) != 2)
        return 0;
      v4 = *(_DWORD *)(a1 + 260);
      return v4 == *(_DWORD *)a2;
    case 4:
      if (*(_BYTE *)(a2 + 16) == 3)
      {
        v5 = *(_QWORD *)(a1 + 96);
        if (v5)
        {
          *(_QWORD *)uu1 = 0;
          v8 = 0;
          nw_resolver_config_get_identifier(v5, uu1);
          if (!uuid_compare(uu1, (const unsigned __int8 *)a2))
            return 1;
        }
      }
      return 0;
    case 5:
      v3 = *(unsigned __int8 *)(a2 + 16);
      if (!*(_BYTE *)(a2 + 16))
        return 1;
      if (v3 != 1)
        return 0;
LABEL_12:
      v4 = *(_DWORD *)(a1 + 256);
      return v4 == *(_DWORD *)a2;
    default:
      return 0;
  }
}

uint64_t mdns_dns_service_manager_register_custom_service(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD block[7];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2000000000;
  v10 = 0;
  if (_mdns_dns_service_queue_s_once != -1)
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = __mdns_dns_service_manager_register_custom_service_block_invoke;
  block[3] = &unk_10013A218;
  block[4] = &v7;
  block[5] = a1;
  block[6] = a2;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, block);
  v4 = v8[3];
  _Block_object_dispose(&v7, 8);
  return v4;
}

void __mdns_dns_service_manager_register_custom_service_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  void *v5;
  uint64_t service_by_uuid;
  _QWORD *v7;
  int v8;
  NSObject *v9;
  uint64_t v10;
  char *v11;
  __CFArray *v12;
  NSObject *v13;
  uint64_t v14;
  NSObject *v15;
  char *v16;
  NSObject *v17;
  const char *v18;
  int v19;
  uint8_t buf[4];
  _BYTE v21[14];
  __int16 v22;
  void *v23;
  __int16 v24;
  uint64_t v25;
  _QWORD v26[2];

  v2 = a1[5];
  if (*(_BYTE *)(v2 + 131))
    goto LABEL_21;
  v3 = (void *)a1[6];
  v4 = nw_resolver_config_create_with_dictionary(v3);
  if (!v4)
  {
    v16 = xpc_copy_description(v3);
    if (_mdns_dns_service_log_s_once != -1)
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
    v17 = _mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
    {
      v18 = "<NO DESC.>";
      if (v16)
        v18 = v16;
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)v21 = v18;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Failed to create nw_resolver_config for dictionary: %s", buf, 0xCu);
      if (!v16)
        goto LABEL_21;
    }
    else if (!v16)
    {
      goto LABEL_21;
    }
    free(v16);
    goto LABEL_21;
  }
  v5 = (void *)v4;
  v26[0] = 0;
  v26[1] = 0;
  nw_resolver_config_get_identifier(v4, v26);
  service_by_uuid = _mdns_dns_service_manager_get_service_by_uuid(*(const __CFArray **)(v2 + 56), (const unsigned __int8 *)v26);
  if (!service_by_uuid)
  {
    v19 = 0;
    v11 = _mdns_dns_service_create_from_resolver_config(v5, 5, 4, &v19);
    if (v11)
    {
      v7 = v11;
      v12 = *(__CFArray **)(v2 + 56);
      _mdns_dns_service_increment_use_count((uint64_t)v11);
      CFArrayAppendValue(v12, v7);
      _mdns_dns_service_manager_update_interface_properties_for_service((CFArrayRef *)v2, (uint64_t)v7);
      if (_mdns_dns_service_log_s_once != -1)
        dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
      v13 = _mdns_dns_service_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        *(_QWORD *)v21 = v7;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Registered custom service -- %@", buf, 0xCu);
      }
      os_release(v7);
      goto LABEL_14;
    }
    if (_mdns_dns_service_log_s_once != -1)
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
    v15 = _mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 68158466;
      *(_DWORD *)v21 = 16;
      *(_WORD *)&v21[4] = 2096;
      *(_QWORD *)&v21[6] = v26;
      v22 = 2112;
      v23 = v5;
      v24 = 2048;
      v25 = v19;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Failed to register custom service -- uuid: %{uuid_t}.16P, config: %@, error: %{mdns:err}ld", buf, 0x26u);
    }
    nw_release(v5);
LABEL_21:
    v14 = 0;
    goto LABEL_15;
  }
  v7 = (_QWORD *)service_by_uuid;
  v8 = _mdns_dns_service_increment_use_count(service_by_uuid);
  if (_mdns_dns_service_log_s_once != -1)
    dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
  v9 = _mdns_dns_service_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
  {
    v10 = v7[3];
    *(_DWORD *)buf = 134218240;
    *(_QWORD *)v21 = v10;
    *(_WORD *)&v21[8] = 1024;
    *(_DWORD *)&v21[10] = v8;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "Registered existing custom service -- service id: %llu, use count: %d", buf, 0x12u);
  }
LABEL_14:
  nw_release(v5);
  v14 = v7[3];
LABEL_15:
  *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = v14;
}

void __mdns_dns_service_manager_deregister_custom_service_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t service_by_id;

  v1 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v1 + 131))
  {
    service_by_id = _mdns_dns_service_manager_get_service_by_id(*(const __CFArray **)(v1 + 56), *(_QWORD *)(a1 + 40));
    if (service_by_id)
      _mdns_dns_service_manager_deregister_service(v1, service_by_id);
  }
}

void __mdns_dns_service_manager_register_doh_uri_block_invoke(_QWORD *a1)
{
  char *v1;
  uint64_t v2;
  const char *v3;
  char *v4;
  char *v5;
  nw_endpoint_t url;
  NSObject *v7;
  const char *url_scheme;
  const char *hostname;
  uint64_t url_path;
  const char *v11;
  CFIndex Count;
  CFIndex v13;
  CFIndex v14;
  uint64_t ValueAtIndex;
  uint64_t v16;
  const char *provider_name;
  const char *provider_path;
  NSObject *v19;
  void *v20;
  const char *v21;
  uint64_t v22;
  __CFArray *v23;
  NSObject *v24;
  char *v25;
  int v26;
  _BYTE buf[22];

  v2 = a1[4];
  if (!*(_BYTE *)(v2 + 131))
  {
    v3 = (const char *)a1[5];
    if (v3 && (v25 = (char *)a1[6], (v4 = strdup(v3)) != 0))
    {
      v1 = v4;
      v5 = strchr(v4, 123);
      if (v5)
        *v5 = 0;
      url = nw_endpoint_create_url(v1);
      if (url)
      {
        v7 = url;
        url_scheme = (const char *)nw_endpoint_get_url_scheme();
        if (url_scheme && !strcasecmp("https", url_scheme))
        {
          hostname = nw_endpoint_get_hostname(v7);
          url_path = nw_endpoint_get_url_path(v7);
          if (hostname
            && (v11 = (const char *)url_path) != 0
            && (Count = CFArrayGetCount(*(CFArrayRef *)(v2 + 48)), Count >= 1))
          {
            v13 = Count;
            v14 = 0;
            while (1)
            {
              ValueAtIndex = (uint64_t)CFArrayGetValueAtIndex(*(CFArrayRef *)(v2 + 48), v14);
              v16 = *(_QWORD *)(ValueAtIndex + 96);
              if (v16)
              {
                if (nw_resolver_config_get_protocol(v16) == 2)
                {
                  provider_name = (const char *)nw_resolver_config_get_provider_name(*(_QWORD *)(ValueAtIndex + 96));
                  provider_path = (const char *)nw_resolver_config_get_provider_path(*(_QWORD *)(ValueAtIndex + 96));
                  if (!strcasecmp(hostname, provider_name) && !strcasecmp(v11, provider_path))
                    break;
                }
              }
              if (v13 == ++v14)
                goto LABEL_18;
            }
          }
          else
          {
LABEL_18:
            if (_mdns_dns_service_log_s_once != -1)
              dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
            v19 = _mdns_dns_service_log_s_log;
            if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315138;
              *(_QWORD *)&buf[4] = v1;
              _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Registering discovered DoH resolver at %s", buf, 0xCu);
            }
            v20 = (void *)nw_resolver_config_create();
            nw_resolver_config_set_class(v20, 3);
            nw_resolver_config_set_protocol(v20, 2);
            v21 = nw_endpoint_get_hostname(v7);
            nw_resolver_config_set_provider_name(v20, v21);
            v22 = nw_endpoint_get_url_path(v7);
            nw_resolver_config_set_provider_path(v20, v22);
            *(_QWORD *)buf = 0;
            *(_QWORD *)&buf[8] = 0;
            uuid_generate(buf);
            nw_resolver_config_set_identifier(v20, buf);
            v26 = 0;
            ValueAtIndex = _mdns_dns_service_create(3, 4, 4, &v26);
            if (v26)
            {
              if (v20)
                nw_release(v20);
              if (!ValueAtIndex)
                goto LABEL_31;
            }
            else
            {
              *(_QWORD *)(ValueAtIndex + 48) = nw_retain(v7);
              *(_BYTE *)(ValueAtIndex + 56) = 1;
              *(_QWORD *)(ValueAtIndex + 96) = v20;
              *(_WORD *)(ValueAtIndex + 276) = 6;
              _mdns_dns_service_update_nw_config_data(ValueAtIndex);
            }
            v23 = *(__CFArray **)(v2 + 48);
            _mdns_dns_service_increment_use_count(ValueAtIndex);
            CFArrayAppendValue(v23, (const void *)ValueAtIndex);
            _mdns_dns_service_manager_update_interface_properties_for_service((CFArrayRef *)v2, ValueAtIndex);
            os_release((void *)ValueAtIndex);
            _mdns_dns_service_manager_fetch_doh_pvd((_QWORD *)ValueAtIndex);
          }
          if (v25)
          {
            if (_mdns_dns_service_log_s_once != -1)
              dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
            v24 = _mdns_dns_service_log_s_log;
            if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315394;
              *(_QWORD *)&buf[4] = v25;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = v1;
              _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Adding domain %s to DoH resolver at %s", buf, 0x16u);
            }
            _mdns_dns_service_add_domain_by_string(ValueAtIndex, v25, 0);
          }
        }
LABEL_31:
        free(v1);
        nw_release(v7);
        return;
      }
    }
    else
    {
      __break(1u);
    }
    free(v1);
  }
}

void _mdns_dns_service_manager_fetch_doh_pvd(_QWORD *a1)
{
  NSObject *v2;
  void *v3;
  const char *hostname;
  uint64_t url_path;
  void *pvd_query;
  void *v7;
  _QWORD v8[7];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;

  v9 = 0;
  v10 = &v9;
  v11 = 0x2000000000;
  v12 = 0;
  os_retain(a1);
  v2 = a1[6];
  nw_retain(v2);
  if (_mdns_dns_service_queue_s_once != -1)
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
  v3 = (void *)_mdns_dns_service_queue_s_queue;
  hostname = nw_endpoint_get_hostname(v2);
  url_path = nw_endpoint_get_url_path(v2);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = ___mdns_dns_service_manager_fetch_doh_pvd_block_invoke;
  v8[3] = &unk_10013A990;
  v8[5] = v2;
  v8[6] = a1;
  v8[4] = &v9;
  pvd_query = http_task_create_pvd_query(v3, (uint64_t)hostname, url_path, v8);
  v10[3] = (uint64_t)pvd_query;
  v7 = objc_autoreleasePoolPush();
  objc_msgSend(pvd_query, "resume");
  objc_autoreleasePoolPop(v7);
  _Block_object_dispose(&v9, 8);
}

void ___mdns_dns_service_manager_fetch_doh_pvd_block_invoke(uint64_t a1, xpc_object_t xdict)
{
  const char *string;
  char *v5;
  size_t v6;
  char *v7;
  const char *url;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  NSObject *v13;
  uint32_t v14;
  uint64_t v15;
  uint64_t uint64;
  NSObject *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  xpc_object_t value;
  xpc_object_t v22;
  void *v23;
  uint64_t v24;
  NSObject *v25;
  uint64_t v26;
  _QWORD applier[4];
  __int128 v28;
  xpc_object_t v29;
  uint8_t buf[4];
  uint64_t v31;
  __int16 v32;
  uint64_t v33;

  if (xdict)
  {
    string = xpc_dictionary_get_string(xdict, "dohTemplate");
    if (string)
    {
      v5 = (char *)string;
      v6 = strlen(string);
      v7 = strchr(v5, 123);
      if (v7)
        v6 = v7 - v5;
      url = nw_endpoint_get_url(*(nw_endpoint_t *)(a1 + 40));
      if (url && (v9 = url, strlen(url) == v6) && !strncasecmp(v5, v9, v6))
      {
        uint64 = xpc_dictionary_get_uint64(xdict, "secondsRemaining");
        if (uint64 || (uint64 = xpc_dictionary_get_uint64(xdict, "seconds-remaining")) != 0)
        {
          if (_mdns_dns_service_log_s_once != -1)
            dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
          v17 = _mdns_dns_service_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
          {
            v18 = *(_QWORD *)(a1 + 40);
            *(_DWORD *)buf = 138412546;
            v31 = v18;
            v32 = 2048;
            v33 = uint64;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_INFO, "DoH resolver for %@ will expire in %llu seconds", buf, 0x16u);
          }
          if (_mdns_get_future_continuous_time_onceToken != -1)
            dispatch_once(&_mdns_get_future_continuous_time_onceToken, &__block_literal_global_91);
          v19 = 1000000000
              * uint64
              * *(unsigned int *)algn_10014DD54
              / _mdns_get_future_continuous_time_time_base;
          v20 = mach_continuous_time() + v19;
        }
        else
        {
          if (_mdns_dns_service_log_s_once != -1)
            dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
          v25 = _mdns_dns_service_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
          {
            v26 = *(_QWORD *)(a1 + 40);
            *(_DWORD *)buf = 138412290;
            v31 = v26;
            _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_INFO, "DoH resolver for %@ does not specify an expiration", buf, 0xCu);
          }
          v20 = 0;
        }
        *(_QWORD *)(*(_QWORD *)(a1 + 48) + 40) = v20;
        value = xpc_dictionary_get_value(xdict, "dnsZones");
        v22 = xpc_dictionary_get_value(xdict, "trustedNames");
        if (v22)
        {
          v23 = v22;
          if (xpc_get_type(v22) == (xpc_type_t)&_xpc_type_array)
          {
            applier[0] = _NSConcreteStackBlock;
            applier[1] = 0x40000000;
            applier[2] = ___mdns_dns_service_manager_fetch_doh_pvd_block_invoke_85;
            applier[3] = &__block_descriptor_tmp_87;
            v28 = *(_OWORD *)(a1 + 40);
            v29 = value;
            xpc_array_apply(v23, applier);
          }
        }
      }
      else
      {
        if (_mdns_dns_service_log_s_once != -1)
          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
        v10 = _mdns_dns_service_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
        {
          v11 = *(_QWORD *)(a1 + 40);
          *(_DWORD *)buf = 138412546;
          v31 = v11;
          v32 = 2080;
          v33 = (uint64_t)v5;
          v12 = "DoH resolver for %@ does not match DoH template %s";
          v13 = v10;
          v14 = 22;
LABEL_29:
          _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, v12, buf, v14);
        }
      }
    }
    else
    {
      if (_mdns_dns_service_log_s_once != -1)
        dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
      v15 = _mdns_dns_service_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
      {
        v24 = *(_QWORD *)(a1 + 40);
        *(_DWORD *)buf = 138412290;
        v31 = v24;
        v12 = "DoH resolver for %@ missing DoH template";
        v13 = v15;
        v14 = 12;
        goto LABEL_29;
      }
    }
  }
  http_task_cancel(*(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
  os_release(*(void **)(a1 + 48));
  nw_release(*(void **)(a1 + 40));
}

uint64_t ___mdns_dns_service_manager_fetch_doh_pvd_block_invoke_85(_QWORD *a1, int a2, xpc_object_t object)
{
  const char *string_ptr;
  NSObject *v7;
  uint64_t v8;
  void *v9;
  void *v10;
  void *v11;
  xpc_object_t v12;
  nw_endpoint_t host;
  void *pvd_query;
  void *v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD applier[7];
  char *v21;
  _BYTE buf[24];
  void *v23;
  uint64_t *v24;
  nw_endpoint_t v25;
  void *v26;
  xpc_object_t v27;
  void *v28;

  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_string)
  {
    string_ptr = xpc_string_get_string_ptr(object);
    if (_mdns_dns_service_log_s_once != -1)
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
    v7 = _mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      v8 = a1[4];
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = string_ptr;
      *(_WORD *)&buf[12] = 2112;
      *(_QWORD *)&buf[14] = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Query trusted name %s for DoH resolver for %@", buf, 0x16u);
    }
    v9 = (void *)a1[6];
    if (v9)
    {
      if (string_ptr)
      {
        v10 = (void *)a1[4];
        if (v10)
        {
          v11 = (void *)a1[5];
          if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_array)
          {
            v21 = 0;
            asprintf(&v21, ".%s", string_ptr);
            v12 = xpc_array_create(0, 0);
            applier[0] = _NSConcreteStackBlock;
            applier[1] = 0x40000000;
            applier[2] = ___mdns_dns_service_manager_fetch_trusted_name_pvd_block_invoke;
            applier[3] = &__block_descriptor_tmp_93;
            applier[4] = string_ptr;
            applier[5] = v12;
            applier[6] = v21;
            xpc_array_apply(v9, applier);
            if (v21)
            {
              free(v21);
              v21 = 0;
            }
            if (xpc_array_get_count(v12))
            {
              v16 = 0;
              v17 = &v16;
              v18 = 0x2000000000;
              v19 = 0;
              nw_retain(v10);
              os_retain(v11);
              host = nw_endpoint_create_host(string_ptr, "443");
              if (_mdns_dns_service_queue_s_once != -1)
                dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
              *(_QWORD *)buf = _NSConcreteStackBlock;
              *(_QWORD *)&buf[8] = 0x40000000;
              *(_QWORD *)&buf[16] = ___mdns_dns_service_manager_fetch_trusted_name_pvd_block_invoke_2;
              v23 = &unk_10013AA38;
              v26 = v10;
              v27 = v12;
              v28 = v11;
              v24 = &v16;
              v25 = host;
              pvd_query = http_task_create_pvd_query((void *)_mdns_dns_service_queue_s_queue, (uint64_t)string_ptr, (uint64_t)"", buf);
              v17[3] = (uint64_t)pvd_query;
              v15 = objc_autoreleasePoolPush();
              objc_msgSend(pvd_query, "resume");
              objc_autoreleasePoolPop(v15);
              _Block_object_dispose(&v16, 8);
            }
            else if (v12)
            {
              xpc_release(v12);
            }
          }
        }
      }
    }
  }
  return 1;
}

uint64_t ___mdns_dns_service_manager_fetch_trusted_name_pvd_block_invoke(uint64_t a1, int a2, xpc_object_t object)
{
  const char *string_ptr;
  size_t v6;
  size_t v7;

  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_string)
  {
    string_ptr = xpc_string_get_string_ptr(object);
    if (!strcasecmp(*(const char **)(a1 + 32), string_ptr)
      || (v6 = strlen(*(const char **)(a1 + 48)), v7 = strlen(string_ptr), v7 >= v6)
      && !strcasecmp(*(const char **)(a1 + 48), &string_ptr[v7 - v6]))
    {
      xpc_array_append_value(*(xpc_object_t *)(a1 + 40), object);
    }
  }
  return 1;
}

void ___mdns_dns_service_manager_fetch_trusted_name_pvd_block_invoke_2(uint64_t a1, xpc_object_t xdict)
{
  const char *string;
  const char *v4;
  const char *url;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  NSObject *v10;
  uint32_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  NSObject *v17;
  uint64_t v18;
  const char *v19;
  void *v20;
  uint64_t v21;
  void *v22;
  _QWORD v23[6];
  uint8_t buf[4];
  uint64_t v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  uint64_t v29;

  if (xdict)
  {
    string = xpc_dictionary_get_string(xdict, "dohTemplate");
    if (string)
    {
      v4 = string;
      url = nw_endpoint_get_url(*(nw_endpoint_t *)(a1 + 48));
      if (url && !strcasecmp(v4, url))
      {
        if (_mdns_dns_service_log_s_once != -1)
          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
        v17 = _mdns_dns_service_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
        {
          v19 = *(const char **)(a1 + 40);
          v18 = *(_QWORD *)(a1 + 48);
          *(_DWORD *)buf = 138412546;
          v25 = v18;
          v26 = 2112;
          v27 = v19;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "DoH resolver at %@ is trusted for %@", buf, 0x16u);
        }
        v23[0] = _NSConcreteStackBlock;
        v23[1] = 0x40000000;
        v23[2] = ___mdns_dns_service_manager_fetch_trusted_name_pvd_block_invoke_95;
        v23[3] = &__block_descriptor_tmp_96;
        v20 = *(void **)(a1 + 56);
        v21 = *(_QWORD *)(a1 + 64);
        v23[4] = *(_QWORD *)(a1 + 48);
        v23[5] = v21;
        xpc_array_apply(v20, v23);
      }
      else
      {
        if (_mdns_dns_service_log_s_once != -1)
          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
        v6 = _mdns_dns_service_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
        {
          v8 = *(_QWORD *)(a1 + 40);
          v7 = *(_QWORD *)(a1 + 48);
          *(_DWORD *)buf = 138412802;
          v25 = v7;
          v26 = 2080;
          v27 = v4;
          v28 = 2112;
          v29 = v8;
          v9 = "DoH resolver for %@ does not match trusted DoH template %s for %@";
          v10 = v6;
          v11 = 32;
LABEL_17:
          _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, v9, buf, v11);
        }
      }
    }
    else
    {
      if (_mdns_dns_service_log_s_once != -1)
        dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
      v15 = _mdns_dns_service_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
      {
        v16 = *(_QWORD *)(a1 + 40);
        *(_DWORD *)buf = 138412290;
        v25 = v16;
        v9 = "Trusted name %@ missing DoH template";
        v10 = v15;
        v11 = 12;
        goto LABEL_17;
      }
    }
  }
  else
  {
    if (_mdns_dns_service_log_s_once != -1)
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
    v12 = _mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
    {
      v13 = *(_QWORD *)(a1 + 40);
      v14 = *(const char **)(a1 + 48);
      *(_DWORD *)buf = 138412546;
      v25 = v13;
      v26 = 2112;
      v27 = v14;
      v9 = "No PvD file found at %@ for DoH server %@";
      v10 = v12;
      v11 = 22;
      goto LABEL_17;
    }
  }
  http_task_cancel(*(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
  nw_release(*(void **)(a1 + 40));
  nw_release(*(void **)(a1 + 48));
  v22 = *(void **)(a1 + 56);
  if (v22)
    xpc_release(v22);
  os_release(*(void **)(a1 + 64));
}

uint64_t ___mdns_dns_service_manager_fetch_trusted_name_pvd_block_invoke_95(uint64_t a1, int a2, xpc_object_t xstring)
{
  char *string_ptr;
  NSObject *v5;
  uint64_t v6;
  int v8;
  char *v9;
  __int16 v10;
  uint64_t v11;

  string_ptr = (char *)xpc_string_get_string_ptr(xstring);
  if (_mdns_dns_service_log_s_once != -1)
    dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
  v5 = _mdns_dns_service_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
  {
    v6 = *(_QWORD *)(a1 + 32);
    v8 = 136315394;
    v9 = string_ptr;
    v10 = 2112;
    v11 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Adding domain %s to discovered DoH resolver for %@", (uint8_t *)&v8, 0x16u);
  }
  _mdns_dns_service_add_domain_by_string(*(_QWORD *)(a1 + 40), string_ptr, 0);
  return 1;
}

void ___mdns_get_future_continuous_time_block_invoke(id a1)
{
  mach_timebase_info((mach_timebase_info_t)&_mdns_get_future_continuous_time_time_base);
}

uint64_t mdns_dns_service_manager_register_discovered_push_service(uint64_t a1, uint64_t a2, int a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v10;
  _QWORD block[9];
  int v13;
  int v14;
  char v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  int v23;

  v20 = 0;
  v21 = &v20;
  v22 = 0x2000000000;
  v23 = 0;
  v16 = 0;
  v17 = &v16;
  v18 = 0x2000000000;
  v19 = 0;
  if (_mdns_dns_service_queue_s_once != -1)
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = __mdns_dns_service_manager_register_discovered_push_service_block_invoke;
  block[3] = &unk_10013A280;
  block[4] = &v16;
  block[5] = &v20;
  block[6] = a1;
  block[7] = a2;
  v15 = 2;
  v13 = a3;
  v14 = 30000;
  block[8] = a4;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, block);
  if (a5)
    *a5 = *((_DWORD *)v21 + 6);
  v10 = v17[3];
  _Block_object_dispose(&v16, 8);
  _Block_object_dispose(&v20, 8);
  return v10;
}

void __mdns_dns_service_manager_register_discovered_push_service_block_invoke(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  char v4;
  int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t discovered_push_service;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  int v12;
  _BOOL4 v13;
  _QWORD *v14;
  uint64_t v15;
  NSObject *v16;
  _BYTE *v17;
  int v18;
  uint8_t buf[4];
  uint64_t v20;

  v2 = *(_QWORD *)(a1 + 48);
  if (*(_BYTE *)(v2 + 131))
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = -6752;
    return;
  }
  v3 = *(void **)(a1 + 56);
  v4 = *(_BYTE *)(a1 + 80);
  v6 = *(_DWORD *)(a1 + 72);
  v5 = *(_DWORD *)(a1 + 76);
  v7 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  v18 = 0;
  discovered_push_service = _mdns_dns_service_manager_get_discovered_push_service(*(const __CFArray **)(v2 + 64), (uint64_t)v3, v6);
  v9 = discovered_push_service;
  if (discovered_push_service)
  {
    _mdns_dns_service_increment_use_count(discovered_push_service);
    v10 = *(_QWORD *)(v9 + 24);
    if (_mdns_dns_service_log_s_once != -1)
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
    v11 = _mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      v20 = v10;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Re-registered discovered push service -- id: %llu", buf, 0xCu);
    }
    v12 = 0;
    goto LABEL_9;
  }
  v14 = mdns_dns_push_service_definition_create();
  if (!v14)
  {
    v10 = 0;
    v12 = -6729;
LABEL_9:
    v13 = v9 != 0;
    *(_DWORD *)(v7 + 24) = v12;
    goto LABEL_12;
  }
  v15 = (uint64_t)v14;
  mdns_dns_push_service_definition_set_srv_name((uint64_t)v14, v3);
  mdns_dns_push_service_definition_set_interface_index(v15, v6, v4);
  *(_WORD *)(v15 + 79) = 1;
  v10 = _mdns_dns_service_manager_register_push_service_internal_from_definition((CFArrayRef *)v2, *(__CFArray **)(v2 + 64), v15, v5, 0, 0, &v18);
  *(_DWORD *)(v7 + 24) = v18;
  os_release((void *)v15);
  v13 = 0;
LABEL_12:
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v10;
  if (!v13)
  {
    if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    {
      v16 = *(NSObject **)(*(_QWORD *)(a1 + 48) + 96);
      if (v16)
        dispatch_source_merge_data(v16, 1uLL);
    }
  }
  v17 = *(_BYTE **)(a1 + 64);
  if (v17)
    *v17 = v13;
}

uint64_t _mdns_dns_service_manager_get_discovered_push_service(const __CFArray *a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD v9[6];
  int v10;
  uint64_t v11;
  int v12;
  BOOL v13;
  __int16 v14;
  char v15;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = ___mdns_dns_service_manager_get_discovered_push_service_block_invoke;
  v9[3] = &unk_10013AEC8;
  v10 = a3;
  v11 = 0;
  v12 = 0;
  v13 = a3 != 0;
  v14 = 0;
  v15 = 0;
  v9[4] = &v5;
  v9[5] = a2;
  mdns_cfarray_enumerate(a1, (uint64_t)v9);
  v3 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v3;
}

BOOL ___mdns_dns_service_manager_get_discovered_push_service_block_invoke(uint64_t a1, uint64_t a2)
{
  if (_mdns_dns_service_scope_id_match(a2, a1 + 48)
    && _mdns_domain_name_equal(*(_QWORD *)(a2 + 216), *(_QWORD *)(a1 + 40)))
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = a2;
  }
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) == 0;
}

void __mdns_dns_service_manager_terminate_discovered_push_service_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  int v3;
  CFIndex Count;
  CFIndex v5;
  CFIndex v6;
  _QWORD *ValueAtIndex;
  NSObject *v8;

  v2 = a1[5];
  if (*(_BYTE *)(v2 + 131))
  {
    v3 = -6752;
  }
  else
  {
    Count = CFArrayGetCount(*(CFArrayRef *)(v2 + 64));
    if (Count < 1)
    {
LABEL_7:
      v3 = -6727;
    }
    else
    {
      v5 = Count;
      v6 = 0;
      while (1)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1[5] + 64), v6);
        if (ValueAtIndex[3] == a1[6])
          break;
        if (v5 == ++v6)
          goto LABEL_7;
      }
      _mdns_dns_service_manager_terminate_service(a1[5], (uint64_t)ValueAtIndex);
      CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1[5] + 64), v6);
      v8 = *(NSObject **)(a1[5] + 96);
      if (v8)
        dispatch_source_merge_data(v8, 1uLL);
      v3 = 0;
    }
  }
  *(_DWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = v3;
}

void __mdns_dns_service_manager_invalidate_block_invoke(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 130))
  {
    _mdns_dns_service_manager_terminate(v2, 0);
    *(_BYTE *)(*(_QWORD *)(a1 + 32) + 130) = 1;
  }
}

uint64_t __mdns_dns_service_manager_get_unscoped_custom_push_service_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  const __CFArray *v3;
  uint64_t v4;
  uint64_t service;
  uint64_t result;
  _QWORD v7[2];
  int v8;

  v2 = a1[5];
  if (*(_BYTE *)(v2 + 131))
  {
    result = 0;
  }
  else
  {
    v3 = *(const __CFArray **)(v2 + 72);
    v4 = a1[6];
    v7[0] = 0;
    v7[1] = 0;
    v8 = 0;
    service = _mdns_dns_service_manager_get_service(v3, v4, (uint64_t)v7, 0, 0);
    result = _mdns_dns_service_manager_prepare_service(a1[5], service);
  }
  *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = result;
  return result;
}

uint64_t _mdns_dns_service_manager_get_service(const __CFArray *a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5)
{
  uint64_t *v6;
  uint64_t v7;
  uint64_t preferred_encrypted_alt;
  uint64_t v9;
  _QWORD v11[10];
  _QWORD v12[3];
  int v13;
  _QWORD v14[3];
  int v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;

  v16 = 0;
  v17 = &v16;
  v18 = 0x2000000000;
  v19 = 0;
  v14[0] = 0;
  v14[1] = v14;
  v14[2] = 0x2000000000;
  v15 = -1;
  v12[0] = 0;
  v12[1] = v12;
  v12[2] = 0x2000000000;
  v13 = 0;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  v11[2] = ___mdns_dns_service_manager_get_service_block_invoke;
  v11[3] = &unk_10013ABB0;
  v11[8] = a3;
  v11[9] = a2;
  v11[4] = a5;
  v11[5] = v14;
  v11[6] = v12;
  v11[7] = &v16;
  mdns_cfarray_enumerate(a1, (uint64_t)v11);
  v6 = v17;
  if ((a4 & 1) != 0)
  {
    v7 = v17[3];
    if (v7)
    {
      preferred_encrypted_alt = _mdns_dns_service_get_preferred_encrypted_alt(v7, (a4 & 2) != 0);
      v6 = v17;
      if (preferred_encrypted_alt)
        v17[3] = preferred_encrypted_alt;
    }
  }
  v9 = v6[3];
  _Block_object_dispose(v12, 8);
  _Block_object_dispose(v14, 8);
  _Block_object_dispose(&v16, 8);
  return v9;
}

uint64_t _mdns_dns_service_manager_prepare_service(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  _QWORD *v4;
  const __CFArray *v5;
  CFIndex v6;
  CFIndex v7;
  CFIndex i;
  const void *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  const __CFArray *v13;
  const __CFArray *v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _UNKNOWN **v19;
  void (*v20)(uint64_t);
  uint64_t v21;
  _UNKNOWN **v22;
  void (*v23)(uint64_t);
  int v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  const void *v28;
  uint64_t v29;
  void *v30;
  NSObject *v31;
  const void *v32;
  uint64_t v33;
  _UNKNOWN **v34;
  void (*v35)(uint64_t);
  CFMutableArrayRef Mutable;
  uint64_t v37;
  uint64_t v38;
  uint64_t provider_name;
  uint64_t provider_path;
  void (*v41)(uint64_t, uint64_t);
  void (*v42)(uint64_t, uint64_t);
  uint64_t identity_reference;
  unsigned int (*v44)(uint64_t, uint64_t, uint64_t);
  NSObject *v45;
  uint64_t odoh_config;
  uint64_t v47;
  void *v48;
  NSObject *v49;
  void (*v50)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void *);
  void (*v51)(uint64_t);
  void (*v52)(uint64_t);
  _BOOL4 v53;
  int v54;
  int v55;
  int v56;
  int v57;
  const __CFArray *v58;
  CFIndex Count;
  CFIndex v60;
  uint64_t v61;
  char *ValueAtIndex;
  char *v63;
  _OWORD *v64;
  int v65;
  nw_endpoint_t address;
  nw_endpoint_t v67;
  int v68;
  NSObject *v69;
  uint64_t v70;
  uint64_t v71;
  NSObject *v72;
  NSObject *v73;
  void *v74;
  dispatch_source_t v75;
  unsigned int v76;
  unsigned int v77;
  NSObject *v78;
  dispatch_time_t v79;
  NSObject *v80;
  NSObject *v81;
  uint64_t v83;
  const char *v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  const char *v88;
  NSObject *v89;
  uint32_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  __int128 aBlock;
  void *v97;
  void *v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  _BYTE buf[32];
  uint64_t v103;
  uint64_t v104;

  v2 = a2;
  if (!a2)
    return v2;
  v3 = *(unsigned __int8 *)(a2 + 281);
  if (v3 != 5)
  {
    if (*(_QWORD *)(a2 + 64))
      return v2;
    if ((v3 - 3) < 2)
    {
      v16 = *(unsigned int *)(a2 + 256);
      v21 = _os_object_alloc(OS_mdns_resolver, 232);
      if (!v21)
        goto LABEL_177;
      v18 = v21;
      v22 = &_mdns_https_resolver_kind;
      *(_QWORD *)(v21 + 16) = &_mdns_https_resolver_kind;
      do
      {
        v23 = (void (*)(uint64_t))v22[2];
        if (v23)
          v23(v18);
        v22 = (_UNKNOWN **)*v22;
      }
      while (v22);
    }
    else
    {
      if (v3 == 1)
      {
        v16 = *(unsigned int *)(a2 + 256);
        v33 = _os_object_alloc(OS_mdns_resolver, 160);
        if (!v33)
          goto LABEL_177;
        v18 = v33;
        v34 = &_mdns_normal_resolver_kind;
        *(_QWORD *)(v33 + 16) = &_mdns_normal_resolver_kind;
        do
        {
          v35 = (void (*)(uint64_t))v34[2];
          if (v35)
            v35(v18);
          v34 = (_UNKNOWN **)*v34;
        }
        while (v34);
        v24 = 0;
        goto LABEL_53;
      }
      if (v3 != 2)
      {
LABEL_168:
        if (_mdns_dns_service_log_s_once != -1)
          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
        v81 = _mdns_dns_service_log_s_log;
        if (!os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
          return 0;
        v83 = *(_QWORD *)(v2 + 24);
        LODWORD(aBlock) = 134217984;
        *(_QWORD *)((char *)&aBlock + 4) = v83;
        v84 = "Failed to prepare resolver -- service id: %llu";
        goto LABEL_175;
      }
      v16 = *(unsigned int *)(a2 + 256);
      v17 = _os_object_alloc(OS_mdns_resolver, 184);
      if (!v17)
        goto LABEL_177;
      v18 = v17;
      v19 = &_mdns_tls_resolver_kind;
      *(_QWORD *)(v17 + 16) = &_mdns_tls_resolver_kind;
      do
      {
        v20 = (void (*)(uint64_t))v19[2];
        if (v20)
          v20(v18);
        v19 = (_UNKNOWN **)*v19;
      }
      while (v19);
    }
    v24 = 1;
LABEL_53:
    Mutable = CFArrayCreateMutable(0, 0, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
    *(_QWORD *)(v18 + 56) = Mutable;
    if (Mutable)
    {
      if (!(_DWORD)v16 || (v37 = nw_interface_create_with_index(v16), (*(_QWORD *)(v18 + 48) = v37) != 0))
      {
        v38 = *(_QWORD *)(v2 + 96);
        if (v38)
        {
          provider_name = nw_resolver_config_get_provider_name(v38);
          provider_path = nw_resolver_config_get_provider_path(*(_QWORD *)(v2 + 96));
          if (!*(_BYTE *)(v18 + 137))
          {
            v41 = *(void (**)(uint64_t, uint64_t))(*(_QWORD *)(v18 + 16) + 56);
            if (!v41 || (v41(v18, provider_name), !*(_BYTE *)(v18 + 137)))
            {
              v42 = *(void (**)(uint64_t, uint64_t))(*(_QWORD *)(v18 + 16) + 80);
              if (v42)
                v42(v18, provider_path);
            }
          }
          v95 = 0;
          identity_reference = nw_resolver_config_get_identity_reference(*(_QWORD *)(v2 + 96), &v95);
          if (identity_reference)
          {
            if (*(_BYTE *)(v18 + 137)
              || (v44 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v18 + 16) + 88)) != 0
              && v44(v18, identity_reference, v95))
            {
              if (_mdns_dns_service_log_s_once != -1)
                dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
              v45 = _mdns_dns_service_log_s_log;
              if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
              {
                v85 = *(_QWORD *)(v2 + 24);
                *(_DWORD *)buf = 134217984;
                *(_QWORD *)&buf[4] = v85;
                _os_log_error_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, "Failed to set identity reference for service -- service id: %llu", buf, 0xCu);
              }
            }
          }
          if (nw_resolver_config_get_protocol(*(_QWORD *)(v2 + 96)) == 3)
          {
            v94 = 0;
            odoh_config = nw_resolver_config_get_odoh_config(*(_QWORD *)(v2 + 96), &v94);
            v47 = nw_resolver_config_copy_proxy_config(*(_QWORD *)(v2 + 96));
            v48 = (void *)v47;
            if (v47)
              nw_proxy_config_set_prohibit_direct(v47, 1);
            if (_mdns_dns_service_log_s_once != -1)
              dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
            v49 = _mdns_dns_service_log_s_log;
            if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 138412290;
              *(_QWORD *)&buf[4] = v48;
              _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "Resolver proxy config: %@", buf, 0xCu);
            }
            v50 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void *))(*(_QWORD *)(v18 + 16)
                                                                                             + 96);
            if (v50)
              v50(v18, provider_name, provider_path, odoh_config, v94, v48);
            if (v48)
              nw_release(v48);
            if (*(_BYTE *)(a1 + 129))
            {
              if (*(_BYTE *)(v2 + 282) != 4)
              {
                *(_WORD *)(v2 + 276) |= 0x1000u;
                if (!*(_BYTE *)(v18 + 137))
                  *(_BYTE *)(v18 + 140) = 1;
              }
            }
          }
        }
        if (*(_QWORD *)(v2 + 176))
        {
          if (!*(_BYTE *)(v18 + 137))
          {
            v51 = *(void (**)(uint64_t))(*(_QWORD *)(v18 + 16) + 64);
            if (v51)
              v51(v18);
          }
        }
        if (*(_WORD *)(v2 + 278))
        {
          if (!*(_BYTE *)(v18 + 137))
          {
            v52 = *(void (**)(uint64_t))(*(_QWORD *)(v18 + 16) + 72);
            if (v52)
              v52(v18);
          }
        }
        if (!*(_BYTE *)(v2 + 56) || *(_BYTE *)(v18 + 137))
        {
          v53 = *(unsigned __int8 *)(v18 + 137) != 0;
          if (*(_BYTE *)(v18 + 137))
            goto LABEL_108;
        }
        else
        {
          v53 = 0;
          *(_BYTE *)(v18 + 133) = 1;
        }
        if ((*(_WORD *)(v2 + 276) & 8) != 0)
          v54 = 2000;
        else
          v54 = 1000;
        *(_DWORD *)(v18 + 124) = v54;
        *(_BYTE *)(v18 + 132) = *(_BYTE *)(a1 + 128);
        if (((v24 | v53) & 1) == 0)
        {
          *(_BYTE *)(v18 + 138) = 1;
          v55 = *(_DWORD *)(a1 + 120);
          if (v55 >= 0x64)
            v56 = 100;
          else
            v56 = *(_DWORD *)(a1 + 120);
          if (v55 <= 0)
            v57 = 0;
          else
            v57 = v56;
          *(_DWORD *)(v18 + 128) = v57;
        }
LABEL_108:
        v58 = *(const __CFArray **)(v2 + 80);
        if (v58)
        {
          v93 = a1;
          Count = CFArrayGetCount(v58);
          if (Count >= 1)
          {
            v60 = 0;
            v61 = 0;
            while (1)
            {
              ValueAtIndex = (char *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v2 + 80), v60);
              v63 = ValueAtIndex;
              if (*(_BYTE *)(v18 + 137))
                break;
              *(_DWORD *)&buf[24] = 0;
              *(_QWORD *)&buf[16] = 0;
              v64 = ValueAtIndex + 24;
              v65 = ValueAtIndex[25];
              if (v65 == 30)
              {
                *(_OWORD *)buf = *v64;
                *(_OWORD *)&buf[12] = *(_OWORD *)(ValueAtIndex + 36);
              }
              else
              {
                if (v65 != 2)
                {
                  v68 = -6756;
LABEL_124:
                  if (_mdns_dns_service_log_s_once != -1)
                    dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
                  v69 = _mdns_dns_service_log_s_log;
                  if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
                  {
                    v70 = *(_QWORD *)(v2 + 24);
                    *(_DWORD *)buf = 134218498;
                    *(_QWORD *)&buf[4] = v70;
                    *(_WORD *)&buf[12] = 2112;
                    *(_QWORD *)&buf[14] = v63;
                    *(_WORD *)&buf[22] = 2048;
                    *(_QWORD *)&buf[24] = v68;
                    _os_log_error_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_ERROR, "Failed to add address to resolver -- service id: %llu, address: %@, error: %{mdns:err}ld", buf, 0x20u);
                  }
                  goto LABEL_128;
                }
                *(_OWORD *)buf = *v64;
              }
              if (!*(_WORD *)&buf[2])
                *(_WORD *)&buf[2] = bswap32(*(unsigned __int16 *)(*(_QWORD *)(v18 + 16) + 156)) >> 16;
              address = nw_endpoint_create_address((const sockaddr *)buf);
              if (!address)
              {
                v68 = -6700;
                goto LABEL_124;
              }
              v67 = address;
              if (*(_QWORD *)(v18 + 48))
                nw_endpoint_set_interface(address);
              v68 = _mdns_resolver_add_server_by_endpoint(v18, v67);
              nw_release(v67);
              if (v68)
                goto LABEL_124;
              ++v61;
LABEL_128:
              if (Count == ++v60)
                goto LABEL_133;
            }
            v68 = -6719;
            goto LABEL_124;
          }
          v61 = 0;
LABEL_133:
          a1 = v93;
          if (Count)
          {
            if (v61 < 1)
            {
              os_release((void *)v18);
              goto LABEL_167;
            }
          }
        }
        if (_mdns_dns_service_queue_s_once != -1)
          dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
        if (!*(_BYTE *)(v18 + 137))
        {
          v71 = _mdns_dns_service_queue_s_queue;
          dispatch_retain((dispatch_object_t)_mdns_dns_service_queue_s_queue);
          v72 = *(NSObject **)(v18 + 72);
          if (v72)
            dispatch_release(v72);
          *(_QWORD *)(v18 + 72) = v71;
        }
        os_retain((void *)a1);
        os_retain((void *)v18);
        v73 = os_retain((void *)v2);
        *(_QWORD *)&aBlock = _NSConcreteStackBlock;
        *((_QWORD *)&aBlock + 1) = 0x40000000;
        v97 = ___mdns_dns_service_manager_prepare_resolver_block_invoke;
        v98 = &__block_descriptor_tmp_193;
        v99 = a1;
        v100 = v2;
        v101 = v18;
        if (!*(_BYTE *)(v18 + 137))
        {
          v74 = _Block_copy(&aBlock);
          v73 = *(NSObject **)(v18 + 80);
          if (v73)
            _Block_release(v73);
          *(_QWORD *)(v18 + 80) = v74;
        }
        *(_QWORD *)(v2 + 64) = v18;
        if (*(_BYTE *)(v2 + 283))
        {
          *(_BYTE *)(v2 + 283) = 0;
          v73 = *(NSObject **)(a1 + 96);
          if (v73)
          {
            dispatch_source_merge_data(v73, 1uLL);
            v18 = *(_QWORD *)(v2 + 64);
          }
        }
        if (!*(_BYTE *)(v18 + 137))
        {
          *(_BYTE *)(v18 + 137) = 1;
          os_retain((void *)v18);
          if (_mdns_resolver_queue_s_once != -1)
            dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
          *(_QWORD *)buf = _NSConcreteStackBlock;
          *(_QWORD *)&buf[8] = 0x40000000;
          *(_QWORD *)&buf[16] = __mdns_resolver_activate_block_invoke;
          *(_QWORD *)&buf[24] = &__block_descriptor_tmp_4666;
          v103 = v18;
          dispatch_async((dispatch_queue_t)_mdns_resolver_queue_s_queue, buf);
        }
        if (*(unsigned __int8 *)(v2 + 281) - 2 >= 4
          && nw_settings_get_ddr_enabled(v73)
          && !*(_QWORD *)(v2 + 200))
        {
          if (_mdns_dns_service_queue_s_once != -1)
            dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
          v75 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, (dispatch_queue_t)_mdns_dns_service_queue_s_queue);
          *(_QWORD *)(v2 + 200) = v75;
          if (v75)
          {
            if (_mdns_os_variant_has_internal_diagnostics_s_once != -1)
              dispatch_once(&_mdns_os_variant_has_internal_diagnostics_s_once, &__block_literal_global_240);
            if (_mdns_os_variant_has_internal_diagnostics_s_result && (v76 = *(_DWORD *)(a1 + 124)) != 0)
            {
              if (v76 <= 0xA)
                v77 = 10;
              else
                v77 = *(_DWORD *)(a1 + 124);
            }
            else
            {
              v77 = 1800;
            }
            v78 = *(NSObject **)(v2 + 200);
            v79 = dispatch_time(0x8000000000000000, 1000000000 * v77);
            dispatch_source_set_timer(v78, v79, 1000000000 * v77, 50000000 * v77);
            v80 = *(NSObject **)(v2 + 200);
            *(_QWORD *)buf = _NSConcreteStackBlock;
            *(_QWORD *)&buf[8] = 0x40000000;
            *(_QWORD *)&buf[16] = ___mdns_dns_service_manager_schedule_ddr_probe_block_invoke;
            *(_QWORD *)&buf[24] = &__block_descriptor_tmp_202;
            v103 = a1;
            v104 = v2;
            dispatch_source_set_event_handler(v80, buf);
            dispatch_activate(*(dispatch_object_t *)(v2 + 200));
            _mdns_dns_service_forget_all_ddr_queriers(v2);
            _mdns_dns_service_manager_start_ddr_querier_ex((void *)a1, v2, 0);
            goto LABEL_167;
          }
          if (_mdns_dns_service_log_s_once != -1)
            dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
          v92 = _mdns_dns_service_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            v88 = "Failed to create DDR timer";
            v89 = v92;
            v90 = 2;
            goto LABEL_181;
          }
        }
        goto LABEL_167;
      }
    }
    os_release((void *)v18);
LABEL_177:
    if (_mdns_dns_service_log_s_once != -1)
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
    v86 = _mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
    {
      v87 = *(_QWORD *)(v2 + 24);
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = v87;
      v88 = "Failed to create resolver for service -- service id: %llu";
      v89 = v86;
      v90 = 12;
LABEL_181:
      _os_log_error_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_ERROR, v88, buf, v90);
    }
LABEL_167:
    if (*(_QWORD *)(v2 + 64))
      return v2;
    goto LABEL_168;
  }
  if (*(_QWORD *)(a2 + 72))
    return v2;
  v4 = mdns_push_server_create();
  *(_QWORD *)(v2 + 72) = v4;
  if (!v4)
    goto LABEL_182;
  v5 = *(const __CFArray **)(v2 + 232);
  if (v5)
  {
    v6 = CFArrayGetCount(v5);
    if (v6 >= 1)
    {
      v7 = v6;
      for (i = 0; i != v7; ++i)
      {
        v9 = CFArrayGetValueAtIndex(*(CFArrayRef *)(v2 + 232), i);
        v10 = *(_QWORD *)(v2 + 72);
        if (!*(_BYTE *)(v10 + 103))
          CFArrayAppendValue(*(CFMutableArrayRef *)(v10 + 72), v9);
      }
    }
  }
  v11 = *(_QWORD *)(v2 + 72);
  if (!*(_BYTE *)(v11 + 103))
  {
    v12 = *(_DWORD *)(v2 + 256);
    if (*(_DWORD *)(v11 + 96) != v12)
    {
      *(_DWORD *)(v11 + 96) = v12;
      if (*(_QWORD *)(v11 + 56))
      {
        free(*(void **)(v11 + 56));
        *(_QWORD *)(v11 + 56) = 0;
        v12 = *(_DWORD *)(v11 + 96);
      }
    }
    if (v12 && !*(_QWORD *)(v11 + 56))
      *(_QWORD *)(v11 + 56) = mdns_system_interface_index_to_name(v12);
  }
  v13 = *(const __CFArray **)(v2 + 80);
  if (v13 && CFArrayGetCount(v13) >= 1)
  {
    v14 = *(const __CFArray **)(v2 + 80);
    *(_QWORD *)&aBlock = _NSConcreteStackBlock;
    *((_QWORD *)&aBlock + 1) = 0x40000000;
    v97 = ___mdns_dns_service_manager_prepare_push_service_block_invoke;
    v98 = &__block_descriptor_tmp_232;
    v99 = v2;
    mdns_cfarray_enumerate(v14, (uint64_t)&aBlock);
    goto LABEL_39;
  }
  v25 = *(void **)(v2 + 216);
  v26 = *(_QWORD *)(v2 + 72);
  if (!v25)
  {
    if (v26)
      return v2;
LABEL_182:
    if (_mdns_dns_service_log_s_once != -1)
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
    v81 = _mdns_dns_service_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
      return 0;
    v91 = *(_QWORD *)(v2 + 24);
    LODWORD(aBlock) = 134217984;
    *(_QWORD *)((char *)&aBlock + 4) = v91;
    v84 = "Failed to prepare push server -- service id: %llu";
LABEL_175:
    _os_log_error_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_ERROR, v84, (uint8_t *)&aBlock, 0xCu);
    return 0;
  }
  mdns_push_server_set_srv_name(v26, v25);
LABEL_39:
  v27 = *(_QWORD *)(v2 + 240);
  if (v27)
  {
    v28 = *(const void **)(v2 + 248);
    if (v28)
    {
      v29 = *(_QWORD *)(v2 + 72);
      dispatch_retain(*(dispatch_object_t *)(v2 + 240));
      v30 = _Block_copy(v28);
      v31 = *(NSObject **)(v29 + 80);
      if (v31)
        dispatch_release(v31);
      *(_QWORD *)(v29 + 80) = v27;
      v32 = *(const void **)(v29 + 88);
      if (v32)
        _Block_release(v32);
      *(_QWORD *)(v29 + 88) = v30;
    }
  }
  *(_BYTE *)(*(_QWORD *)(v2 + 72) + 103) = 1;
  return v2;
}

void ___mdns_dns_service_manager_prepare_resolver_block_invoke(_QWORD *a1, int a2, xpc_object_t xdict)
{
  uint64_t v3;
  _QWORD *v4;
  char *v5;
  _BOOL4 v8;
  NSObject *v9;
  const char *v10;
  const char *v11;
  NSObject *v12;
  const char *v13;
  int int64;
  NSObject *v15;
  const char *v16;
  const char *v17;
  char *v18;
  NSObject *v19;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  NSObject *v23;
  const char *v24;
  NSObject *v25;
  const char *v26;
  NSObject *v27;
  const char *v28;
  const char *v29;
  const char *v30;
  int v31;
  const char *v32;
  __int16 v33;
  const char *v34;
  __int16 v35;
  char *v36;

  v4 = (_QWORD *)a1[4];
  v3 = a1[5];
  v5 = (char *)a1[6];
  switch(a2)
  {
    case 1:
      if (_mdns_dns_service_log_s_once != -1)
        dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
      v12 = _mdns_dns_service_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
      {
        v13 = *(const char **)(v3 + 24);
        v31 = 134218242;
        v32 = v13;
        v33 = 2112;
        v34 = v5;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "Resolver has been invalidated -- service id: %llu, resolver: %@", (uint8_t *)&v31, 0x16u);
      }
      os_release(v5);
      os_release((void *)v3);
      os_release(v4);
      break;
    case 3:
      if (!xdict || *(char **)(v3 + 64) != v5)
        return;
      int64 = xpc_dictionary_get_int64(xdict, "error_code");
      if (*(_BYTE *)(v3 + 282) == 4)
      {
        if (int64 == -6736)
        {
          if (_mdns_dns_service_log_s_once != -1)
            dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
          v15 = _mdns_dns_service_log_s_log;
          if (!os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
            return;
          v24 = *(const char **)(v3 + 24);
          v31 = 134217984;
          v32 = v24;
          v17 = "Received unexpected error for discovered service id: %llu";
        }
        else
        {
          if (int64 != -6776)
            return;
          if (_mdns_dns_service_log_s_once != -1)
            dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
          v15 = _mdns_dns_service_log_s_log;
          if (!os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
            return;
          v16 = *(const char **)(v3 + 24);
          v31 = 134217984;
          v32 = v16;
          v17 = "Received authentication error for discovered service id: %llu";
        }
        _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, v17, (uint8_t *)&v31, 0xCu);
        return;
      }
      if (!*(_QWORD *)(v3 + 96))
        return;
      if (int64)
      {
        if (int64 == -6736)
        {
          if (_mdns_dns_service_log_s_once != -1)
            dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
          v27 = _mdns_dns_service_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
          {
            v30 = *(const char **)(v3 + 24);
            v31 = 134217984;
            v32 = v30;
            _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "Reporting EBADMSG error for service id: %llu", (uint8_t *)&v31, 0xCu);
          }
          v21 = *(_QWORD *)(v3 + 96);
          v22 = 94;
        }
        else
        {
          if (int64 != -6776)
            return;
          if (_mdns_dns_service_log_s_once != -1)
            dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
          v20 = _mdns_dns_service_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
          {
            v29 = *(const char **)(v3 + 24);
            v31 = 134217984;
            v32 = v29;
            _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Reporting EAUTH error for service id: %llu", (uint8_t *)&v31, 0xCu);
          }
          v21 = *(_QWORD *)(v3 + 96);
          v22 = 80;
        }
      }
      else
      {
        if (_mdns_dns_service_log_s_once != -1)
          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
        v25 = _mdns_dns_service_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
        {
          v26 = *(const char **)(v3 + 24);
          v31 = 134217984;
          v32 = v26;
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_INFO, "Reporting success for service id: %llu", (uint8_t *)&v31, 0xCu);
        }
        v21 = *(_QWORD *)(v3 + 96);
        v22 = 0;
      }
      nw_resolver_config_report_error(v21, v22);
      break;
    case 2:
      if (xdict && *(char **)(v3 + 64) == v5)
      {
        v8 = xpc_dictionary_get_BOOL(xdict, "cannot_connect");
        if (_mdns_dns_service_log_s_once != -1)
          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
        v9 = _mdns_dns_service_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEFAULT))
        {
          v10 = "";
          v11 = *(const char **)(v3 + 24);
          v31 = 136446722;
          if (v8)
            v10 = "not";
          v32 = v10;
          v33 = 2048;
          v34 = v11;
          v35 = 2112;
          v36 = v5;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Resolver can%{public}s connect -- service id: %llu, resolver: %@", (uint8_t *)&v31, 0x20u);
        }
        if (v8)
        {
          if (*(_BYTE *)(v3 + 283))
            return;
          *(_BYTE *)(v3 + 283) = 1;
        }
        else
        {
          if (!*(_BYTE *)(v3 + 283))
            return;
          *(_BYTE *)(v3 + 283) = 0;
        }
        v19 = v4[12];
        if (v19)
          dispatch_source_merge_data(v19, 1uLL);
      }
      break;
    default:
      if (_mdns_dns_service_log_s_once != -1)
        dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
      if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEBUG))
      {
        if (xdict)
        {
          v18 = xpc_copy_description(xdict);
          if (_mdns_dns_service_log_s_once != -1)
            dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
        }
        else
        {
          v18 = 0;
        }
        v23 = _mdns_dns_service_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_DEBUG))
        {
          v28 = "<invalid event value>";
          v31 = 138412802;
          v32 = (const char *)v3;
          if (!a2)
            v28 = "null";
          v33 = 2080;
          v34 = v28;
          v35 = 2082;
          v36 = v18;
          _os_log_debug_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEBUG, "DNS service (%@) got unhandled event: %s info: %{public}s", (uint8_t *)&v31, 0x20u);
          if (!v18)
            return;
        }
        else if (!v18)
        {
          return;
        }
        free(v18);
      }
      break;
  }
}

void ___mdns_dns_service_manager_schedule_ddr_probe_block_invoke(uint64_t a1)
{
  void *v1;
  uint64_t v2;

  v1 = *(void **)(a1 + 32);
  v2 = *(_QWORD *)(a1 + 40);
  _mdns_dns_service_forget_all_ddr_queriers(v2);
  _mdns_dns_service_manager_start_ddr_querier_ex(v1, v2, 0);
}

void _mdns_dns_service_manager_start_ddr_querier_ex(void *a1, uint64_t a2, char *a3)
{
  void *v4;
  CFMutableArrayRef Mutable;
  uint64_t querier;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  NSObject *v18;
  const char *v19;
  _QWORD aBlock[8];
  uint8_t buf[4];
  const char *v22;

  v4 = *(void **)(a2 + 64);
  if (v4)
  {
    if (a3 && !*(_QWORD *)(a2 + 192))
    {
      Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
      *(_QWORD *)(a2 + 192) = Mutable;
      if (!Mutable)
        return;
      v4 = *(void **)(a2 + 64);
    }
    querier = mdns_resolver_create_querier(v4);
    if (querier)
    {
      v15 = querier;
      ++*(_DWORD *)(a2 + 268);
      mdns_querier_set_log_label(querier, "S%llu.DDR%u", v9, v10, v11, v12, v13, v14, *(_QWORD *)(a2 + 24));
      if (_mdns_dns_service_queue_s_once != -1)
        dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
      mdns_client_set_queue(v15, (dispatch_object_t)_mdns_dns_service_queue_s_queue);
      if (a3)
        v16 = a3;
      else
        v16 = "\x04_dns\bresolver\x04arpa";
      mdns_querier_set_query(v15, v16, 64);
      if (!*(_BYTE *)(v15 + 49))
        *(_DWORD *)(v15 + 236) = -1;
      if (a3)
      {
        CFArrayAppendValue(*(CFMutableArrayRef *)(a2 + 192), (const void *)v15);
      }
      else
      {
        v17 = *(_QWORD *)(a2 + 184);
        if (v17)
        {
          mdns_client_invalidate(v17);
          os_release(*(void **)(a2 + 184));
        }
        *(_QWORD *)(a2 + 184) = v15;
        os_retain((void *)v15);
      }
      os_retain(a1);
      os_retain((void *)a2);
      aBlock[0] = _NSConcreteStackBlock;
      aBlock[1] = 0x40000000;
      aBlock[2] = ___mdns_dns_service_manager_start_ddr_querier_ex_block_invoke;
      aBlock[3] = &__block_descriptor_tmp_206;
      aBlock[4] = a2;
      aBlock[5] = v15;
      aBlock[6] = a1;
      aBlock[7] = a3;
      mdns_querier_set_result_handler(v15, aBlock);
      mdns_querier_set_time_limit_ms((void *)v15, 15000);
      mdns_client_activate(v15);
    }
    else
    {
      if (_mdns_dns_service_log_s_once != -1)
        dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
      v18 = _mdns_dns_service_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
      {
        v19 = "alias ";
        if (!a3)
          v19 = "";
        *(_DWORD *)buf = 136446210;
        v22 = v19;
        _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Failed to create DDR %{public}squerier", buf, 0xCu);
      }
    }
  }
}

uint64_t ___mdns_dns_service_manager_prepare_push_service_block_invoke(uint64_t a1, const void *a2)
{
  uint64_t v2;

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 72);
  if (!*(_BYTE *)(v2 + 103))
    CFArrayAppendValue(*(CFMutableArrayRef *)(v2 + 64), a2);
  return 1;
}

void ___mdns_dns_service_manager_start_ddr_querier_ex_block_invoke(uint64_t a1)
{
  const void *v2;
  uint64_t v3;
  const __CFArray *v4;
  CFIndex FirstIndexOfValue;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  CFArrayRef *v11;
  unsigned __int16 *v12;
  const void *v13;
  unsigned int v14;
  int v15;
  unsigned __int16 *v16;
  unint64_t v17;
  int v18;
  unsigned __int16 *v19;
  _BYTE *v20;
  BOOL v21;
  unsigned __int16 *v22;
  unsigned __int16 *v23;
  unsigned __int16 *v24;
  BOOL v25;
  _BYTE *v26;
  uint64_t v27;
  _BYTE *v28;
  unsigned __int8 *v29;
  unint64_t v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int v33;
  char *v34;
  int v35;
  int is_empty;
  char *v37;
  const char *p_block;
  int v39;
  size_t v40;
  char *v41;
  char *v42;
  void *v43;
  int v44;
  NSObject *v45;
  const __CFArray *v46;
  const void *v47;
  uint64_t v48;
  void *v49;
  uint64_t v50;
  char *discovered_alt;
  char *v52;
  NSObject *v53;
  const char *v54;
  NSObject *v55;
  const char *v56;
  unsigned int v57;
  uint64_t v58;
  char *v59;
  NSObject *v60;
  NSObject *v61;
  unsigned int v62;
  unsigned int v63;
  NSObject *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  NSObject *v68;
  NSObject *v69;
  uint64_t v70;
  void *obj;
  char *v72;
  unsigned int v73;
  nw_endpoint_t endpoint;
  NSObject *endpointa;
  int v76;
  nw_parameters_t parameters;
  NSObject *parametersa;
  void *v79;
  char *__s;
  unsigned __int8 *v81;
  NSObject *group;
  NSObject *v83;
  _QWORD v84[5];
  uint64_t v85;
  uint64_t *v86;
  uint64_t v87;
  char v88;
  unint64_t v89;
  unsigned __int16 *v90;
  char *v91;
  char *v92;
  int v93[2];
  int AnswerSection;
  _QWORD aBlock[7];
  __int16 v96;
  _QWORD v97[5];
  void *v98;
  _QWORD v99[4];
  _QWORD v100[3];
  char v101;
  _QWORD v102[3];
  char v103;
  uint64_t v104;
  uint64_t *v105;
  uint64_t v106;
  nw_connection_t v107;
  _QWORD v108[3];
  char v109;
  _QWORD v110[4];
  _QWORD v111[4];
  void **block;
  uint64_t v113;
  void *v114;
  void *v115;
  _BYTE *v116;
  CFArrayRef *v117;
  NSObject *v118;
  uint8_t v119[4];
  uint64_t v120;
  _BYTE buf[24];
  __int128 v122;
  _QWORD *p_isa;
  _QWORD *v124;
  _QWORD *v125;
  _QWORD *v126;
  _QWORD *v127;
  _QWORD *v128;
  _QWORD *v129;
  uint64_t v130;
  NSObject *v131;
  char v132;
  char v133[8];
  uint64_t v134;
  char v135;
  uuid_t out;
  uint64_t v137;
  void *v138;
  _QWORD *v139;
  _QWORD *v140;
  _QWORD *v141;
  nw_parameters_t v142;
  char v143;
  CFRange v144;

  v3 = *(_QWORD *)(a1 + 32);
  v2 = *(const void **)(a1 + 40);
  if (*(const void **)(v3 + 184) == v2)
  {
    if (v2)
    {
      os_release(*(void **)(a1 + 40));
      *(_QWORD *)(v3 + 184) = 0;
    }
  }
  else
  {
    v4 = *(const __CFArray **)(v3 + 192);
    if (!v4)
      goto LABEL_173;
    v144.length = CFArrayGetCount(v4);
    v144.location = 0;
    FirstIndexOfValue = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(v3 + 192), v144, v2);
    if (FirstIndexOfValue < 0)
      goto LABEL_173;
    CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v3 + 192), FirstIndexOfValue);
  }
  v6 = *(_QWORD *)(a1 + 40);
  if (*(_BYTE *)(v6 + 248) == 1)
  {
    v7 = *(_QWORD *)(v6 + 136);
    if (v7)
    {
      v8 = *(_QWORD *)(v7 + 32);
      v9 = *(unsigned int *)(v7 + 40);
    }
    else
    {
      v8 = 0;
      v9 = 0;
    }
    if (*(_QWORD *)(a1 + 56))
      v81 = *(unsigned __int8 **)(*(_QWORD *)(*(_QWORD *)(v6 + 88) + 56) + 24);
    else
      v81 = 0;
    v10 = *(_QWORD *)(a1 + 32);
    v11 = *(CFArrayRef **)(a1 + 48);
    AnswerSection = 0;
    *(_QWORD *)v93 = 0;
    v12 = (unsigned __int16 *)DNSMessageCollapse(v8, v9, v93, (char **)&AnswerSection);
    if (!AnswerSection)
    {
      v13 = *(const void **)(v10 + 152);
      if (v13)
      {
        CFRelease(v13);
        *(_QWORD *)(v10 + 152) = 0;
      }
      *(_BYTE *)(v10 + 287) = 0;
      if (*(_QWORD *)v93 >= 0xCuLL)
      {
        v14 = __rev16(v12[3]);
        if (v14)
        {
          v92 = 0;
          AnswerSection = DNSMessageGetAnswerSection((unint64_t)v12, *(unint64_t *)v93, &v92);
          if (!AnswerSection)
          {
            group = dispatch_group_create();
            v15 = 0;
            v91 = v92;
            while (1)
            {
              v89 = 0;
              v90 = 0;
              AnswerSection = _DNSMessageExtractRecordEx((unint64_t)v12, *(uint64_t *)v93, v91, 0, 0, 0, 0, &v90, &v89, 0, 0, 0, 0, &v91);
              if (AnswerSection)
                goto LABEL_171;
              v16 = v90;
              if (v90)
              {
                v17 = v89;
                if (v89 >= 2)
                {
                  if (*v90)
                  {
                    *(_QWORD *)buf = 0;
                    *(_QWORD *)&buf[8] = buf;
                    *(_QWORD *)&buf[16] = 0x2000000000;
                    LOBYTE(v122) = 0;
                    block = _NSConcreteStackBlock;
                    v113 = 0x40000000;
                    v114 = __dnssd_svcb_is_valid_block_invoke;
                    v115 = &unk_10013E810;
                    v116 = buf;
                    _dnssd_svcb_extract_values(v90, v89, 0, (uint64_t)&block);
                    v18 = *(unsigned __int8 *)(*(_QWORD *)&buf[8] + 24);
                    _Block_object_dispose(buf, 8);
                    if (!v18)
                    {
                      v17 = v89;
                      v16 = v90;
                      if (v89 >= 2)
                      {
LABEL_29:
                        if (!*v16)
                        {
                          if (!v81)
                          {
                            v19 = v16 + 1;
                            if (v16 != (unsigned __int16 *)-2 && (unsigned __int16 *)((char *)v16 + v17) > v19)
                            {
                              v20 = v16 + 1;
                              while (*v20)
                              {
                                v20 += *v20 + 1;
                                if (v20)
                                  v21 = v20 >= (_BYTE *)v16 + v17;
                                else
                                  v21 = 1;
                                if (v21)
                                  goto LABEL_33;
                              }
                              if ((unsigned __int16)((_WORD)v20 - (_WORD)v19 + 1) <= 0x100uLL)
                                _mdns_dns_service_manager_start_ddr_querier_ex(v11, v10);
                            }
                          }
                          goto LABEL_33;
                        }
                      }
                      v85 = 0;
                      v86 = &v85;
                      v87 = 0x2000000000;
                      v88 = 0;
                      v84[0] = _NSConcreteStackBlock;
                      v84[1] = 0x40000000;
                      v84[2] = ___mdns_dns_service_manager_process_ddr_response_block_invoke;
                      v84[3] = &unk_10013B068;
                      v84[4] = &v85;
                      block = _NSConcreteStackBlock;
                      v113 = 0x40000000;
                      v114 = __dnssd_svcb_access_alpn_values_block_invoke;
                      v115 = &unk_10013E8D8;
                      v116 = v84;
                      _dnssd_svcb_extract_values(v16, v17, 1, (uint64_t)&block);
                      if (!*((_BYTE *)v86 + 24))
                        goto LABEL_32;
                      if (v89 < 2)
                        goto LABEL_32;
                      v22 = v90;
                      v23 = v90 + 1;
                      if (v90 == (unsigned __int16 *)-2 || (unsigned __int16 *)((char *)v90 + v89) <= v23)
                        goto LABEL_32;
                      v24 = v90 + 1;
                      while (*(_BYTE *)v24)
                      {
                        v24 = (unsigned __int16 *)((char *)v24 + *(unsigned __int8 *)v24 + 1);
                        if (v24)
                          v25 = v24 >= (unsigned __int16 *)((char *)v90 + v89);
                        else
                          v25 = 1;
                        if (v25)
                          goto LABEL_32;
                      }
                      if ((unsigned __int16)((_WORD)v24 - (_WORD)v23 + 1) > 0x100uLL)
                        goto LABEL_32;
                      v26 = malloc_type_calloc(1uLL, 0x3F1uLL, 0xF1748037uLL);
                      if (!v26)
                        __break(1u);
                      LODWORD(v27) = *((unsigned __int8 *)v22 + 2);
                      v28 = v26;
                      if (*((_BYTE *)v22 + 2)
                        || (*v26 = 46, v28 = v26 + 1, LODWORD(v27) = *(unsigned __int8 *)v23, *(_BYTE *)v23))
                      {
                        while (v27 <= 0x3F)
                        {
                          v29 = (unsigned __int8 *)v23 + 1;
                          v30 = (unint64_t)v23 + v27 + 1;
                          if (v30 >= (unint64_t)(v22 + 129))
                            break;
                          if ((unint64_t)v29 < v30)
                          {
                            v27 = v27;
                            do
                            {
                              v32 = *v29++;
                              v31 = v32;
                              if (v32 == 92 || v31 == 46)
                              {
                                *v28++ = 92;
                              }
                              else if (v31 <= 0x20)
                              {
                                *(_WORD *)v28 = 12380;
                                v33 = (205 * v31) >> 11;
                                v28[2] = v33 | 0x30;
                                v28 += 3;
                                LOBYTE(v31) = (v31 - 10 * v33) | 0x30;
                              }
                              *v28++ = v31;
                              --v27;
                            }
                            while (v27);
                          }
                          *v28 = 0;
                          v34 = (char *)v23 + *(unsigned __int8 *)v23;
                          *v28++ = 46;
                          v35 = v34[1];
                          v23 = (unsigned __int16 *)(v34 + 1);
                          LODWORD(v27) = v35;
                          if (!v35)
                            goto LABEL_72;
                        }
LABEL_157:
                        free(v26);
LABEL_32:
                        _Block_object_dispose(&v85, 8);
                        goto LABEL_33;
                      }
LABEL_72:
                      *v28 = 0;
                      if (v28 == (_BYTE *)-1)
                        goto LABEL_157;
                      __s = v26;
                      bzero(&block, 0x3F1uLL);
                      is_empty = dnssd_svcb_service_name_is_empty((uint64_t)v90, v89);
                      v37 = __s;
                      p_block = __s;
                      if (is_empty)
                      {
                        if (!v81)
                          goto LABEL_156;
                        p_block = (const char *)&block;
                        v39 = DomainNameToString(v81, 0, (unsigned __int8 *)&block, 0);
                        v37 = __s;
                        if (v39)
                          goto LABEL_156;
                      }
                      v40 = strlen(p_block);
                      if (v40 && p_block[v40 - 1] == 46)
                        p_block[v40 - 1] = 0;
                      parameters = (nw_parameters_t)p_block;
                      *(_QWORD *)out = 0;
                      *(_QWORD *)&out[8] = out;
                      v137 = 0x2000000000;
                      LOWORD(v138) = 0;
                      *(_QWORD *)buf = _NSConcreteStackBlock;
                      *(_QWORD *)&buf[8] = 0x40000000;
                      *(_QWORD *)&buf[16] = __dnssd_svcb_get_port_block_invoke;
                      *(_QWORD *)&v122 = &unk_10013E838;
                      *((_QWORD *)&v122 + 1) = out;
                      _dnssd_svcb_extract_values(v90, v89, 3, (uint64_t)buf);
                      v73 = *(unsigned __int16 *)(*(_QWORD *)&out[8] + 24);
                      _Block_object_dispose(out, 8);
                      *(_QWORD *)out = 0;
                      *(_QWORD *)&out[8] = out;
                      v137 = 0x2000000000;
                      v138 = 0;
                      *(_QWORD *)buf = _NSConcreteStackBlock;
                      *(_QWORD *)&buf[8] = 0x40000000;
                      *(_QWORD *)&buf[16] = __dnssd_svcb_copy_doh_path_block_invoke;
                      *(_QWORD *)&v122 = &unk_10013E888;
                      *((_QWORD *)&v122 + 1) = out;
                      _dnssd_svcb_extract_values(v90, v89, 7, (uint64_t)buf);
                      v41 = *(char **)(*(_QWORD *)&out[8] + 24);
                      _Block_object_dispose(out, 8);
                      if (v41)
                      {
                        v42 = strchr(v41, 123);
                        if (v42)
                          *v42 = 0;
                      }
                      v83 = 0;
                      *(_QWORD *)out = 0;
                      *(_QWORD *)&out[8] = out;
                      v137 = 0x2000000000;
                      v138 = 0;
                      *(_QWORD *)buf = _NSConcreteStackBlock;
                      *(_QWORD *)&buf[8] = 0x40000000;
                      *(_QWORD *)&buf[16] = __dnssd_svcb_copy_odoh_config_block_invoke;
                      *(_QWORD *)&v122 = &unk_10013E8B0;
                      *((_QWORD *)&v122 + 1) = out;
                      p_isa = &v83;
                      _dnssd_svcb_extract_values(v90, v89, 32769, (uint64_t)buf);
                      v43 = *(void **)(*(_QWORD *)&out[8] + 24);
                      _Block_object_dispose(out, 8);
                      v44 = *((unsigned __int8 *)v86 + 24);
                      v45 = v83;
                      if (v44 == 3 && v43 && v83)
                      {
                        v44 = 4;
                        *((_BYTE *)v86 + 24) = 4;
                      }
                      endpoint = v45;
                      v79 = v43;
                      *(_QWORD *)out = 0;
                      *(_QWORD *)&out[8] = out;
                      v137 = 0x2000000000;
                      v138 = 0;
                      *(_QWORD *)buf = _NSConcreteStackBlock;
                      *(_QWORD *)&buf[8] = 0x40000000;
                      *(_QWORD *)&buf[16] = ___mdns_dns_service_get_discovered_alt_block_invoke;
                      *(_QWORD *)&v122 = &unk_10013B0D0;
                      v76 = v44;
                      LOBYTE(v124) = v44;
                      p_isa = &parameters->isa;
                      *((_QWORD *)&v122 + 1) = out;
                      v46 = *(const __CFArray **)(v10 + 144);
                      if (v46)
                      {
                        mdns_cfarray_enumerate(v46, (uint64_t)buf);
                        v47 = *(const void **)(*(_QWORD *)&out[8] + 24);
                        _Block_object_dispose(out, 8);
                        if (v47)
                        {
                          _mdns_dns_service_manager_add_pending_alt(v11, v10, v47);
                          if (!v41)
                            goto LABEL_153;
LABEL_152:
                          free(v41);
                          goto LABEL_153;
                        }
                      }
                      else
                      {
                        _Block_object_dispose(out, 8);
                      }
                      if ((v76 - 2) > 2)
                        goto LABEL_110;
                      v72 = v41;
                      v48 = nw_resolver_config_create();
                      v49 = (void *)v48;
                      if (v79 != 0 && endpoint != 0)
                        v50 = 4;
                      else
                        v50 = 2;
                      nw_resolver_config_set_class(v48, v50);
                      nw_resolver_config_set_protocol(v49, (v76 - 2) + 1);
                      nw_resolver_config_set_provider_name(v49, parameters);
                      if (v72)
                        nw_resolver_config_set_provider_path(v49, v72);
                      obj = v49;
                      if (v79 != 0 && endpoint != 0)
                        nw_resolver_config_set_odoh_config(v49, v79, endpoint);
                      memset(buf, 0, 17);
                      if (*(_QWORD *)(v10 + 104) || (v62 = *(_DWORD *)(v10 + 256)) != 0 && if_indextoname(v62, buf))
                        nw_resolver_config_set_interface_name(v49);
                      memset(out, 0, sizeof(out));
                      uuid_generate(out);
                      nw_resolver_config_set_identifier(v49, out);
                      v41 = v72;
                      if (obj)
                      {
                        if (nw_resolver_config_get_class(obj) == 4)
                        {
                          *(_DWORD *)out = 0;
                          discovered_alt = _mdns_dns_service_create_discovered_alt(v10, obj, v73, 0, 0, out);
                          if (discovered_alt)
                          {
                            v52 = discovered_alt;
                            *(_DWORD *)out = _mdns_dns_service_manager_add_pending_alt(v11, v10, discovered_alt);
                            nw_release(obj);
                            os_release(v52);
                          }
                          else
                          {
                            if (_mdns_dns_service_log_s_once != -1)
                              dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
                            v68 = _mdns_dns_service_log_s_log;
                            if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
                            {
                              *(_DWORD *)buf = 134217984;
                              *(_QWORD *)&buf[4] = *(int *)out;
                              _os_log_error_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_ERROR, "Failed to create discovered oblivious DNS service -- error: %{mdns:err}ld", buf, 0xCu);
                            }
                            nw_release(obj);
                          }
                          v41 = v72;
                          if (v72)
                            goto LABEL_152;
LABEL_153:
                          if (v79)
                            free(v79);
                          v37 = __s;
LABEL_156:
                          v26 = v37;
                          goto LABEL_157;
                        }
                        if (_mdns_dns_service_log_s_once != -1)
                          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
                        v55 = _mdns_dns_service_log_s_log;
                        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
                        {
                          *(_DWORD *)buf = 67109891;
                          v56 = "";
                          if (v72)
                            v56 = v72;
                          *(_DWORD *)&buf[4] = v76;
                          *(_WORD *)&buf[8] = 2081;
                          *(_QWORD *)&buf[10] = parameters;
                          *(_WORD *)&buf[18] = 1024;
                          *(_DWORD *)&buf[20] = v73;
                          LOWORD(v122) = 2081;
                          *(_QWORD *)((char *)&v122 + 2) = v56;
                          _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_INFO, "Verifying discovered service -- type: %{mdns:dns_service_type}d, provider name: %{private}s, port: %d, path: %{private}s", buf, 0x22u);
                        }
                        aBlock[0] = _NSConcreteStackBlock;
                        aBlock[1] = 0x40000000;
                        aBlock[2] = ___mdns_dns_service_manager_register_discovered_service_block_invoke;
                        aBlock[3] = &__block_descriptor_tmp_212;
                        aBlock[4] = v10;
                        aBlock[5] = obj;
                        v96 = v73;
                        aBlock[6] = v11;
                        v111[0] = 0;
                        v111[1] = v111;
                        v111[2] = 0x2000000000;
                        v111[3] = 0;
                        v110[0] = 0;
                        v110[1] = v110;
                        v110[2] = 0x2000000000;
                        v110[3] = 0;
                        if (v76 == 2)
                          v57 = 853;
                        else
                          v57 = 443;
                        if (v73)
                          v58 = v73;
                        else
                          v58 = v57;
                        v108[0] = 0;
                        v108[1] = v108;
                        v108[2] = 0x2000000000;
                        v109 = 0;
                        endpointa = nw_endpoint_create_host_with_numeric_port(parameters, v58);
                        *(_QWORD *)out = _NSConcreteStackBlock;
                        *(_QWORD *)&out[8] = 0x40000000;
                        v137 = (uint64_t)___mdns_dns_service_manager_probe_discovered_service_block_invoke;
                        v138 = &unk_10013B148;
                        v143 = v76;
                        v139 = v108;
                        v140 = v111;
                        v141 = v110;
                        v142 = parameters;
                        parametersa = nw_parameters_create_secure_tcp(out, _nw_parameters_configure_protocol_default_configuration);
                        *(_QWORD *)v133 = 0;
                        v134 = 0;
                        v135 = 0;
                        v59 = *(char **)(v10 + 104);
                        if (v59 || (v63 = *(_DWORD *)(v10 + 256)) != 0 && (v59 = if_indextoname(v63, v133)) != 0)
                        {
                          if (_mdns_dns_service_log_s_once != -1)
                            dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
                          v60 = _mdns_dns_service_log_s_log;
                          if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
                          {
                            *(_DWORD *)buf = 136446210;
                            *(_QWORD *)&buf[4] = v59;
                            _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_INFO, "Scoping discovered service to %{public}s", buf, 0xCu);
                          }
                          v61 = nw_interface_create_with_name(v59);
                          nw_parameters_require_interface(parametersa, v61);
                          if (v61)
                            nw_release(v61);
                        }
                        v104 = 0;
                        v105 = &v104;
                        v106 = 0x2000000000;
                        v107 = 0;
                        v107 = nw_connection_create(endpointa, parametersa);
                        if (endpointa)
                          nw_release(endpointa);
                        if (parametersa)
                          nw_release(parametersa);
                        v64 = v105[3];
                        if (_mdns_dns_service_queue_s_once != -1)
                          dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
                        nw_connection_set_queue(v64, (dispatch_queue_t)_mdns_dns_service_queue_s_queue);
                        os_retain((void *)v10);
                        dispatch_group_enter(group);
                        v102[0] = 0;
                        v102[1] = v102;
                        v102[2] = 0x2000000000;
                        v103 = 0;
                        v100[0] = 0;
                        v100[1] = v100;
                        v100[2] = 0x2000000000;
                        v101 = 0;
                        v99[0] = 0;
                        v99[1] = v99;
                        v99[2] = 0x2000000000;
                        v99[3] = 0;
                        v97[0] = 0;
                        v97[1] = v97;
                        v97[2] = 0x3002000000;
                        v97[3] = __Block_byref_object_copy__874;
                        v97[4] = __Block_byref_object_dispose__875;
                        v98 = 0;
                        v98 = _Block_copy(aBlock);
                        v65 = v105[3];
                        *(_QWORD *)buf = _NSConcreteStackBlock;
                        *(_QWORD *)&buf[8] = 0x40000000;
                        *(_QWORD *)&buf[16] = ___mdns_dns_service_manager_probe_discovered_service_block_invoke_220;
                        *(_QWORD *)&v122 = &unk_10013B198;
                        *((_QWORD *)&v122 + 1) = &v104;
                        p_isa = v102;
                        v132 = v76;
                        v124 = v111;
                        v125 = v110;
                        v126 = v100;
                        v127 = v99;
                        v130 = v10;
                        v131 = group;
                        v128 = v97;
                        v129 = v108;
                        nw_connection_set_event_handler(v65, buf);
                        nw_connection_start((nw_connection_t)v105[3]);
                        v66 = v105[3];
                        v67 = *(_QWORD *)(v10 + 208);
                        if (v67 || (v67 = nw_array_create(), (*(_QWORD *)(v10 + 208) = v67) != 0))
                        {
                          nw_array_append(v67, v66);
                        }
                        else
                        {
                          if (_mdns_dns_service_log_s_once != -1)
                            dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
                          v69 = _mdns_dns_service_log_s_log;
                          if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
                          {
                            v70 = *(_QWORD *)(v10 + 24);
                            *(_DWORD *)v119 = 134217984;
                            v120 = v70;
                            _os_log_error_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_ERROR, "Cancelling service's DDR verification connection because of lack of resources -- service id: %llu", v119, 0xCu);
                          }
                          nw_connection_cancel((nw_connection_t)v105[3]);
                        }
                        v41 = v72;
                        _Block_object_dispose(v97, 8);
                        _Block_object_dispose(v99, 8);
                        _Block_object_dispose(v100, 8);
                        _Block_object_dispose(v102, 8);
                        _Block_object_dispose(&v104, 8);
                        _Block_object_dispose(v108, 8);
                        _Block_object_dispose(v110, 8);
                        _Block_object_dispose(v111, 8);
                      }
                      else
                      {
LABEL_110:
                        if (_mdns_dns_service_log_s_once != -1)
                          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
                        v53 = _mdns_dns_service_log_s_log;
                        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
                        {
                          *(_DWORD *)buf = 67109891;
                          v54 = "";
                          if (v41)
                            v54 = v41;
                          *(_DWORD *)&buf[4] = v76;
                          *(_WORD *)&buf[8] = 2081;
                          *(_QWORD *)&buf[10] = parameters;
                          *(_WORD *)&buf[18] = 1024;
                          *(_DWORD *)&buf[20] = v73;
                          LOWORD(v122) = 2081;
                          *(_QWORD *)((char *)&v122 + 2) = v54;
                          _os_log_error_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_ERROR, "Failed to create discovered DNS config -- type: %{mdns:dns_service_type}d, provider name: %{private}s, port: %d, path: %{private}s", buf, 0x22u);
                          if (v41)
                            goto LABEL_152;
                          goto LABEL_153;
                        }
                      }
                      if (!v41)
                        goto LABEL_153;
                      goto LABEL_152;
                    }
                  }
                  else if ((dnssd_svcb_service_name_is_empty((uint64_t)v90, v89) & 1) == 0)
                  {
                    goto LABEL_29;
                  }
                }
              }
LABEL_33:
              if (++v15 == v14)
              {
                os_retain(v11);
                os_retain((void *)v10);
                if (_mdns_dns_service_queue_s_once != -1)
                  dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
                block = _NSConcreteStackBlock;
                v113 = 0x40000000;
                v114 = ___mdns_dns_service_manager_process_ddr_response_block_invoke_2;
                v115 = &__block_descriptor_tmp_210;
                v116 = (_BYTE *)v10;
                v117 = v11;
                v118 = group;
                dispatch_group_notify(group, (dispatch_queue_t)_mdns_dns_service_queue_s_queue, &block);
                goto LABEL_171;
              }
            }
          }
        }
        goto LABEL_172;
      }
    }
LABEL_171:
    if (v12)
LABEL_172:
      free(v12);
  }
LABEL_173:
  os_release(*(void **)(a1 + 48));
  os_release(*(void **)(a1 + 32));
  os_release(*(void **)(a1 + 40));
}

uint64_t ___mdns_dns_service_manager_process_ddr_response_block_invoke(uint64_t a1, char *__s1)
{
  char v4;

  if (!strcmp(__s1, "dot"))
  {
    v4 = 2;
    goto LABEL_5;
  }
  if (!strcmp(__s1, "h2"))
  {
    v4 = 3;
LABEL_5:
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v4;
  }
  return 1;
}

BOOL ___mdns_dns_service_get_discovered_alt_block_invoke(uint64_t a1, uint64_t a2)
{
  const char *provider_name;

  if (*(_QWORD *)(a2 + 96))
  {
    if (*(unsigned __int8 *)(a2 + 281) == *(unsigned __int8 *)(a1 + 48))
    {
      provider_name = (const char *)nw_resolver_config_get_provider_name();
      if (!strcasecmp(provider_name, *(const char **)(a1 + 40)))
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = a2;
    }
  }
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) == 0;
}

uint64_t _mdns_dns_service_manager_add_pending_alt(CFArrayRef *a1, uint64_t a2, const void *a3)
{
  const __CFArray *Mutable;
  uint64_t result;
  __CFArray *v8;
  _QWORD v9[5];

  Mutable = *(const __CFArray **)(a2 + 152);
  if (!Mutable)
  {
    Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
    *(_QWORD *)(a2 + 152) = Mutable;
    if (!Mutable)
      return 4294960567;
  }
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = ___mdns_dns_service_array_contains_service_block_invoke;
  v9[3] = &__block_descriptor_tmp_135;
  v9[4] = a3;
  result = mdns_cfarray_enumerate(Mutable, (uint64_t)v9);
  if ((_DWORD)result)
  {
    v8 = *(__CFArray **)(a2 + 152);
    _mdns_dns_service_increment_use_count((uint64_t)a3);
    CFArrayAppendValue(v8, a3);
    _mdns_dns_service_manager_update_interface_properties_for_service(a1, (uint64_t)a3);
    return 0;
  }
  return result;
}

char *_mdns_dns_service_create_discovered_alt(uint64_t a1, void *a2, unsigned int a3, int a4, uint64_t a5, _DWORD *a6)
{
  char *result;
  char *v13;
  char *v14;
  uint64_t v15;
  const void *v16;
  const __CFArray *v17;
  CFIndex Count;
  CFIndex v19;
  CFIndex v20;
  __int16 v21;
  _DWORD *ValueAtIndex;
  _DWORD *v23;
  int v24;
  int v25;
  uint64_t v26;
  void *v27;
  int v28;
  uint64_t v29;
  int v30;

  result = (char *)nw_resolver_config_get_provider_name(a2);
  if (a5)
  {
    if (!result || (result = strdup(result)) == 0)
    {
      __break(1u);
      return result;
    }
    v13 = result;
    nw_resolver_config_set_provider_name(a2, a5);
  }
  else
  {
    v13 = 0;
  }
  v30 = 0;
  v14 = _mdns_dns_service_create_from_resolver_config(a2, 4, *(_BYTE *)(a1 + 280), &v30);
  v15 = (uint64_t)v14;
  if (!v30)
  {
    *((_QWORD *)v14 + 17) = a1;
    os_retain((void *)a1);
    *(_WORD *)(v15 + 276) = *(_WORD *)(a1 + 276) & 0xE;
    *(_WORD *)(v15 + 278) = a3;
    if (v13)
      *(_QWORD *)(v15 + 176) = v13;
    if (a4)
    {
      v16 = *(const void **)(v15 + 80);
      if (v16)
      {
        CFRelease(v16);
        *(_QWORD *)(v15 + 80) = 0;
      }
      v17 = *(const __CFArray **)(a1 + 80);
      if (v17)
      {
        Count = CFArrayGetCount(v17);
        if (Count >= 1)
        {
          v19 = Count;
          v20 = 0;
          v21 = __rev16(a3);
          while (1)
          {
            ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 80), v20);
            v23 = ValueAtIndex;
            v24 = *((unsigned __int8 *)ValueAtIndex + 25);
            if (v24 == 30)
              break;
            if (v24 == 2)
            {
              v25 = ValueAtIndex[7];
              v26 = _mdns_address_new();
              if (!v26)
                goto LABEL_24;
              v27 = (void *)v26;
              *(_WORD *)(v26 + 24) = 528;
              *(_WORD *)(v26 + 26) = v21;
              *(_DWORD *)(v26 + 28) = v25;
LABEL_21:
              _mdns_dns_service_append_address(v15, v27);
              os_release(v27);
            }
LABEL_22:
            if (v19 == ++v20)
              goto LABEL_25;
          }
          v28 = ValueAtIndex[12];
          v29 = _mdns_address_new();
          if (!v29)
          {
LABEL_24:
            _mdns_dns_service_append_address(v15, 0);
            goto LABEL_22;
          }
          v27 = (void *)v29;
          *(_WORD *)(v29 + 24) = 7708;
          *(_WORD *)(v29 + 26) = v21;
          *(_OWORD *)(v29 + 32) = *((_OWORD *)v23 + 2);
          *(_DWORD *)(v29 + 48) = v28;
          goto LABEL_21;
        }
      }
    }
LABEL_25:
    v13 = 0;
  }
  if (a6)
    *a6 = v30;
  if (v13)
    free(v13);
  return (char *)v15;
}

void ___mdns_dns_service_manager_register_discovered_service_block_invoke(uint64_t a1, int a2, int a3, void *a4)
{
  uint64_t v6;
  char *v7;
  char *v8;
  NSObject *v9;
  uint64_t v10;
  char *v11;
  const char *v12;
  NSObject *v13;
  uint32_t v14;
  uint64_t v15;
  NSObject *v16;
  int v17;
  uint8_t buf[4];
  char *v19;

  v6 = *(_QWORD *)(a1 + 32);
  if ((*(_WORD *)(v6 + 276) & 1) != 0)
  {
    if (_mdns_dns_service_log_s_once != -1)
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
    v10 = _mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
    {
      v11 = *(char **)(*(_QWORD *)(a1 + 32) + 24);
      *(_DWORD *)buf = 134217984;
      v19 = v11;
      v12 = "Service became defunct before discovered child service could be validated -- service id: %llu";
      v13 = v10;
      v14 = 12;
LABEL_19:
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_INFO, v12, buf, v14);
    }
LABEL_20:
    nw_release(*(void **)(a1 + 40));
    if (!a4)
      return;
    goto LABEL_21;
  }
  if (!a2)
  {
    if (_mdns_dns_service_log_s_once != -1)
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
    v15 = _mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      v12 = "Failed to validate discovered service, ignoring";
      v13 = v15;
      v14 = 2;
      goto LABEL_19;
    }
    goto LABEL_20;
  }
  v17 = 0;
  v7 = _mdns_dns_service_create_discovered_alt(v6, *(void **)(a1 + 40), *(unsigned __int16 *)(a1 + 56), a3, (uint64_t)a4, &v17);
  if (!v7)
  {
    if (_mdns_dns_service_log_s_once != -1)
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
    v16 = _mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      v19 = (char *)v17;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Failed to create discovered DNS service -- error: %{mdns:err}ld", buf, 0xCu);
    }
    goto LABEL_20;
  }
  v8 = v7;
  v17 = _mdns_dns_service_manager_add_pending_alt(*(CFArrayRef **)(a1 + 48), *(_QWORD *)(a1 + 32), v7);
  if (!v17)
  {
    if (_mdns_dns_service_log_s_once != -1)
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
    v9 = _mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 138412290;
      v19 = v8;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "Registered discovered service -- %@", buf, 0xCu);
    }
  }
  nw_release(*(void **)(a1 + 40));
  os_release(v8);
  if (a4)
LABEL_21:
    free(a4);
}

void ___mdns_dns_service_manager_probe_discovered_service_block_invoke(uint64_t a1, nw_protocol_options_t options)
{
  NSObject *v3;
  NSObject *v4;
  int v5;
  const char *v6;
  __int128 v7;
  _QWORD v8[4];
  __int128 v9;
  __int128 v10;

  v3 = nw_tls_copy_sec_protocol_options(options);
  if (!v3)
    return;
  v4 = v3;
  sec_protocol_options_set_tls_server_name(v3, *(const char **)(a1 + 56));
  sec_protocol_options_set_peer_authentication_required(v4, 1);
  v5 = *(unsigned __int8 *)(a1 + 64);
  if (v5 == 2)
  {
    v6 = "dot";
LABEL_6:
    sec_protocol_options_add_tls_application_protocol(v4, v6);
    goto LABEL_7;
  }
  if ((v5 - 3) <= 1)
  {
    v6 = "h2";
    goto LABEL_6;
  }
LABEL_7:
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = ___mdns_dns_service_manager_probe_discovered_service_block_invoke_2;
  v8[3] = &unk_10013B120;
  v7 = *(_OWORD *)(a1 + 48);
  v9 = *(_OWORD *)(a1 + 32);
  v10 = v7;
  if (_mdns_dns_service_queue_s_once != -1)
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
  sec_protocol_options_set_verify_block(v4, v8, (dispatch_queue_t)_mdns_dns_service_queue_s_queue);
  sec_release(v4);
}

void __Block_byref_object_copy__874(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 135);
}

void __Block_byref_object_dispose__875(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 135);
}

void ___mdns_dns_service_manager_probe_discovered_service_block_invoke_220(uint64_t a1, int a2)
{
  uint64_t v4;
  const void *v5;
  void *v6;
  const void *v7;
  const void *v8;
  NSObject *v9;
  __int128 v10;
  NSObject *v11;
  _QWORD v12[4];
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  char v17;

  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 96) + 208);
  if (v4 && nw_array_contains_object(v4, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24)))
  {
    switch(a2)
    {
      case 1:
      case 4:
        _mdns_dns_service_forget_ddr_connection(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 208), *(NSObject **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
        break;
      case 3:
        v9 = *(NSObject **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
        if (_mdns_dns_service_queue_s_once != -1)
        {
          v11 = *(NSObject **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
          dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
          v9 = v11;
        }
        v12[0] = _NSConcreteStackBlock;
        v12[1] = 0x40000000;
        v12[2] = ___mdns_dns_service_manager_probe_discovered_service_block_invoke_2_221;
        v12[3] = &unk_10013B170;
        v16 = *(_QWORD *)(a1 + 96);
        v17 = *(_BYTE *)(a1 + 112);
        v10 = *(_OWORD *)(a1 + 48);
        v13 = *(_OWORD *)(a1 + 32);
        v14 = v10;
        v15 = *(_OWORD *)(a1 + 64);
        nw_connection_access_establishment_report(v9, (dispatch_queue_t)_mdns_dns_service_queue_s_queue, v12);
        break;
      case 5:
        goto LABEL_6;
      default:
        return;
    }
  }
  else if (a2 == 5)
  {
LABEL_6:
    (*(void (**)(void))(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8) + 40) + 16))();
    v5 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8) + 40);
    if (v5)
    {
      _Block_release(v5);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8) + 40) = 0;
    }
    dispatch_group_leave(*(dispatch_group_t *)(a1 + 104));
    v6 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    if (v6)
    {
      nw_release(v6);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
    }
    os_release(*(void **)(a1 + 96));
    v7 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
    if (v7)
    {
      CFRelease(v7);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = 0;
    }
    v8 = *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24);
    if (v8)
    {
      CFRelease(v8);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) = 0;
    }
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 88) + 8) + 24) = 1;
  }
}

void ___mdns_dns_service_manager_process_ddr_response_block_invoke_2(uint64_t a1)
{
  uint64_t v2;
  CFIndex Count;
  NSObject *v4;

  v2 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(v2 + 152))
  {
    Count = CFArrayGetCount(*(CFArrayRef *)(v2 + 152));
    v2 = *(_QWORD *)(a1 + 32);
    if (Count >= 1)
    {
      *(_BYTE *)(v2 + 287) = 1;
      if (*(_QWORD *)(*(_QWORD *)(a1 + 40) + 96))
      {
        dispatch_source_merge_data(*(dispatch_source_t *)(*(_QWORD *)(a1 + 40) + 96), 1uLL);
        v2 = *(_QWORD *)(a1 + 32);
      }
    }
  }
  os_release((void *)v2);
  os_release(*(void **)(a1 + 40));
  v4 = *(NSObject **)(a1 + 48);
  if (v4)
    dispatch_release(v4);
}

void ___mdns_dns_service_manager_probe_discovered_service_block_invoke_2_221(CFIndex a1, NSObject *a2)
{
  uint64_t MaximumSizeForEncoding;
  CFIndex v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  int v8;
  const __CFArray *v9;
  void *v10;
  const __CFArray *v11;
  const char *string_ptr;
  BOOL v13;
  CFStringRef v14;
  int v15;
  _BOOL4 v16;
  const __CFArray *v17;
  _QWORD *ValueAtIndex;
  _QWORD *v19;
  CFIndex v20;
  CFIndex v21;
  uint64_t v22;
  const __CFString *v23;
  const char *CStringPtr;
  char *v25;
  CFIndex Length;
  UInt8 *v27;
  NSObject *host;
  NSObject *v29;
  const sockaddr *address;
  int sa_family;
  char *v34;
  char v35;
  uint64_t v36;
  CFIndex v37;
  unsigned int v38;
  _BOOL4 v39;
  char **v40;
  CFIndex Count;
  uint64_t v42;
  uint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  char v46;
  uint8_t v47[4];
  uint64_t v48;
  __int128 buf;
  BOOL (*v50)(uint64_t, uint64_t);
  void *v51;
  uint64_t *v52;
  CFIndex v53;
  uint64_t v54;
  char **v55;
  BOOL v56;
  char v57;
  CFRange v58;
  CFRange v59;

  v3 = a1;
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 208);
  if (v4 && nw_array_contains_object(v4, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8) + 24)))
  {
    v42 = *(_QWORD *)(v3 + 80);
    v6 = *(_QWORD *)(v42 + 136);
    if (!v6 || !*(_QWORD *)(v6 + 96))
      v6 = *(_QWORD *)(v3 + 80);
    v7 = *(_QWORD *)(*(_QWORD *)(v3 + 64) + 8);
    v40 = (char **)(*(_QWORD *)(*(_QWORD *)(v3 + 72) + 8) + 24);
    v8 = *(unsigned __int8 *)(v3 + 88);
    v9 = *(const __CFArray **)(*(_QWORD *)(*(_QWORD *)(v3 + 48) + 8) + 24);
    v10 = *(void **)(v6 + 160);
    if (!v10
      || ((v11 = *(const __CFArray **)(*(_QWORD *)(*(_QWORD *)(v3 + 56) + 8) + 24),
           string_ptr = xpc_string_get_string_ptr(v10),
           v11)
        ? (v13 = string_ptr == 0)
        : (v13 = 1),
          v13))
    {
      v16 = 0;
    }
    else
    {
      v14 = CFStringCreateWithCString(kCFAllocatorDefault, string_ptr, 0x8000100u);
      v58.length = CFArrayGetCount(v11);
      v58.location = 0;
      v15 = CFArrayContainsValue(v11, v58, v14);
      v16 = v15 != 0;
      if (v15)
      {
        if (_mdns_dns_service_log_s_once != -1)
          dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
        MaximumSizeForEncoding = _mdns_dns_service_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
        {
          LODWORD(buf) = 138543362;
          *(_QWORD *)((char *)&buf + 4) = v14;
          _os_log_impl((void *)&_mh_execute_header, (os_log_t)MaximumSizeForEncoding, OS_LOG_TYPE_INFO, "Discovered service verified, name \"%{public}@\" in certificate", (uint8_t *)&buf, 0xCu);
        }
      }
      if (v14)
        CFRelease(v14);
    }
    v17 = *(const __CFArray **)(v42 + 80);
    if (v17)
    {
      Count = CFArrayGetCount(v17);
      if (Count >= 1)
      {
        v39 = v16;
        v36 = v7;
        v37 = v3;
        v3 = 0;
        v38 = v8 - 3;
        while (1)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v42 + 80), v3);
          if (v9)
          {
            v19 = ValueAtIndex;
            v20 = CFArrayGetCount(v9);
            if (v20 >= 1)
              break;
          }
          MaximumSizeForEncoding = 0;
LABEL_64:
          if (++v3 >= Count || (MaximumSizeForEncoding & 1) != 0)
          {
            v3 = v37;
            v7 = v36;
            v16 = v39;
            goto LABEL_69;
          }
        }
        v21 = v20;
        v22 = 1;
        while (1)
        {
          v23 = (const __CFString *)CFArrayGetValueAtIndex(v9, v22 - 1);
          CStringPtr = CFStringGetCStringPtr(v23, 0x8000100u);
          if (CStringPtr)
            break;
          Length = CFStringGetLength(v23);
          MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
          if (MaximumSizeForEncoding == -1
            || (v27 = (UInt8 *)malloc_type_malloc(MaximumSizeForEncoding + 1, 0xA172743EuLL)) == 0)
          {
LABEL_81:
            __break(1u);
            goto LABEL_82;
          }
          v25 = (char *)v27;
          *(_QWORD *)&buf = 0;
          v59.location = 0;
          v59.length = Length;
          if (CFStringGetBytes(v23, v59, 0x8000100u, 0, 0, v27, MaximumSizeForEncoding, (CFIndex *)&buf) == Length)
          {
            v25[buf] = 0;
            goto LABEL_33;
          }
          free(v25);
          MaximumSizeForEncoding = 0;
LABEL_57:
          if (v22++ >= v21)
            goto LABEL_64;
        }
        v25 = strdup(CStringPtr);
        if (!v25)
          goto LABEL_81;
LABEL_33:
        host = nw_endpoint_create_host(v25, "0");
        if (!host)
        {
          MaximumSizeForEncoding = 0;
          goto LABEL_56;
        }
        v29 = host;
        if (nw_endpoint_get_type(host) == nw_endpoint_type_address)
        {
          address = nw_endpoint_get_address(v29);
          sa_family = address->sa_family;
          if (sa_family == *((unsigned __int8 *)v19 + 25) && address->sa_len == *((unsigned __int8 *)v19 + 24))
          {
            if (sa_family == 30)
            {
              if (*(_QWORD *)&address->sa_data[6] == v19[4] && *(_QWORD *)&address[1].sa_len == v19[5])
                goto LABEL_40;
            }
            else if (sa_family == 2 && *(_DWORD *)&address->sa_data[2] == *((_DWORD *)v19 + 7))
            {
LABEL_40:
              if (_mdns_dns_service_log_s_once != -1)
                dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
              MaximumSizeForEncoding = _mdns_dns_service_log_s_log;
              if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
              {
                LODWORD(buf) = 138543362;
                *(_QWORD *)((char *)&buf + 4) = v29;
                _os_log_impl((void *)&_mh_execute_header, (os_log_t)MaximumSizeForEncoding, OS_LOG_TYPE_INFO, "Discovered service verified, address %{public}@ in certificate", (uint8_t *)&buf, 0xCu);
              }
              if (!v39 && !*v40)
              {
                if (v38 <= 1 && sa_family == 30)
                {
                  asprintf(v40, "[%s]", v25);
                }
                else
                {
                  v34 = strdup(v25);
                  if (!v34)
                    goto LABEL_81;
                  *v40 = v34;
                }
              }
              MaximumSizeForEncoding = 1;
              goto LABEL_55;
            }
          }
        }
        MaximumSizeForEncoding = 0;
LABEL_55:
        nw_release(v29);
LABEL_56:
        free(v25);
        if ((MaximumSizeForEncoding & 1) != 0)
          goto LABEL_64;
        goto LABEL_57;
      }
    }
    else
    {
      Count = 0;
    }
    LODWORD(MaximumSizeForEncoding) = 0;
LABEL_69:
    v43 = 0;
    v44 = &v43;
    v45 = 0x2000000000;
    v46 = 0;
    if (a2)
    {
      *(_QWORD *)&buf = _NSConcreteStackBlock;
      *((_QWORD *)&buf + 1) = 0x40000000;
      v50 = ___mdns_dns_server_validate_discovered_service_connection_block_invoke;
      v51 = &unk_10013B1E8;
      v52 = &v43;
      v56 = v16;
      v57 = MaximumSizeForEncoding;
      v53 = Count;
      v54 = v42;
      v55 = v40;
      nw_establishment_report_enumerate_resolution_reports(a2, &buf);
    }
    if (((v16 | MaximumSizeForEncoding) & 1) != 0)
    {
      v35 = 1;
    }
    else if (*((_BYTE *)v44 + 24))
    {
      v35 = 1;
      *(_BYTE *)(v7 + 24) = 1;
    }
    else
    {
      if (_mdns_dns_service_log_s_once != -1)
        dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
      MaximumSizeForEncoding = _mdns_dns_service_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
      {
LABEL_82:
        *(_DWORD *)v47 = 138412290;
        v48 = v42;
        _os_log_error_impl((void *)&_mh_execute_header, (os_log_t)MaximumSizeForEncoding, OS_LOG_TYPE_ERROR, "Discovered service could not be verified for %@", v47, 0xCu);
      }
      v35 = 0;
    }
    _Block_object_dispose(&v43, 8);
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v3 + 40) + 8) + 24) = v35;
    _mdns_dns_service_forget_ddr_connection(*(_QWORD *)(*(_QWORD *)(v3 + 80) + 208), *(NSObject **)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8) + 24));
  }
}

void _mdns_dns_service_forget_ddr_connection(uint64_t a1, NSObject *a2)
{
  if (a1)
  {
    if (nw_array_remove_object())
      nw_connection_cancel(a2);
  }
}

BOOL ___mdns_dns_server_validate_discovered_service_connection_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD v5[6];
  __int128 v6;
  __int16 v7;

  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = ___mdns_dns_server_validate_discovered_service_connection_block_invoke_2;
  v5[3] = &unk_10013B1C0;
  v3 = *(_QWORD *)(a1 + 40);
  v5[4] = *(_QWORD *)(a1 + 32);
  v5[5] = v3;
  v7 = *(_WORD *)(a1 + 64);
  v6 = *(_OWORD *)(a1 + 48);
  nw_resolution_report_enumerate_endpoints(a2, v5);
  return *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) == 0;
}

BOOL ___mdns_dns_server_validate_discovered_service_connection_block_invoke_2(uint64_t a1, nw_endpoint_t endpoint)
{
  const sockaddr *address;
  int v5;
  const sockaddr *v6;
  CFIndex v7;
  _DWORD *ValueAtIndex;
  int sa_family;
  unsigned int v11;
  NSObject *v12;
  _QWORD *v13;
  const char *hostname;
  char *v15;
  uint8_t buf[4];
  nw_endpoint_t v18;

  if (nw_endpoint_get_type(endpoint) == nw_endpoint_type_address)
  {
    address = nw_endpoint_get_address(endpoint);
    v5 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    {
      if (*(uint64_t *)(a1 + 40) < 1)
      {
        v5 = 0;
      }
      else
      {
        v6 = address;
        v7 = 0;
        do
        {
          ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(*(_QWORD *)(a1 + 48) + 80), v7);
          sa_family = v6->sa_family;
          if (sa_family == *((unsigned __int8 *)ValueAtIndex + 25)
            && sa_family == 2
            && v6->sa_len == *((unsigned __int8 *)ValueAtIndex + 24))
          {
            v11 = *(_DWORD *)&v6->sa_data[2];
            if (v11 == ValueAtIndex[7]
              && (vmaxv_u16((uint16x4_t)vmovn_s32(vceqq_s32((int32x4_t)vandq_s8((int8x16_t)vdupq_n_s32(bswap32(v11)), (int8x16_t)xmmword_100100910), (int32x4_t)xmmword_100100920))) & 1) != 0)
            {
              *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
              if (_mdns_dns_service_log_s_once != -1)
                dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
              v12 = _mdns_dns_service_log_s_log;
              if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
              {
                *(_DWORD *)buf = 138543362;
                v18 = endpoint;
                _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "Discovered service verified, private address %{public}@ used", buf, 0xCu);
              }
            }
          }
          if (!*(_BYTE *)(a1 + 64) && !*(_BYTE *)(a1 + 65))
          {
            if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
            {
              v13 = *(_QWORD **)(a1 + 56);
              if (v13)
              {
                if (!*v13)
                {
                  hostname = nw_endpoint_get_hostname(endpoint);
                  if (hostname)
                  {
                    v15 = strdup(hostname);
                    if (!v15)
                      __break(1u);
                    **(_QWORD **)(a1 + 56) = v15;
                  }
                }
              }
            }
          }
          v5 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
          if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
            break;
          ++v7;
        }
        while (v7 < *(_QWORD *)(a1 + 40));
      }
    }
  }
  else
  {
    v5 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  return v5 == 0;
}

void ___mdns_dns_service_manager_probe_discovered_service_block_invoke_3(_QWORD *a1, SecTrustRef trust, int a3, uint64_t a4)
{
  const __CFArray *v5;
  const __CFArray *v6;
  const void *ValueAtIndex;
  const void *v8;
  const void *v9;
  NSObject *v11;
  const void *v12;
  int v13;
  uint64_t v14;

  if (!*(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24))
  {
    if (a3)
    {
      v5 = SecTrustCopyCertificateChain(trust);
      if (v5)
      {
        v6 = v5;
        if (CFArrayGetCount(v5) >= 1)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v6, 0);
          v8 = *(const void **)(*(_QWORD *)(a1[6] + 8) + 24);
          if (v8)
          {
            CFRelease(v8);
            *(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 24) = 0;
          }
          v9 = *(const void **)(*(_QWORD *)(a1[7] + 8) + 24);
          if (v9)
          {
            CFRelease(v9);
            *(_QWORD *)(*(_QWORD *)(a1[7] + 8) + 24) = 0;
          }
          *(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 24) = SecCertificateCopyIPAddresses(ValueAtIndex);
          *(_QWORD *)(*(_QWORD *)(a1[7] + 8) + 24) = SecCertificateCopyDNSNames(ValueAtIndex);
        }
        CFRelease(v6);
      }
    }
    else
    {
      if (_mdns_dns_service_log_s_once != -1)
        dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
      v11 = _mdns_dns_service_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_ERROR))
      {
        v13 = 138412290;
        v14 = a4;
        _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Aynchronous trust evaluation failed: %@", (uint8_t *)&v13, 0xCu);
      }
    }
  }
  (*(void (**)(void))(a1[4] + 16))();
  v12 = (const void *)a1[4];
  if (v12)
    _Block_release(v12);
}

BOOL ___mdns_dns_service_array_contains_service_block_invoke(uint64_t a1, uint64_t a2)
{
  return *(_QWORD *)(a1 + 32) != a2;
}

uint64_t ___mdns_dns_service_manager_get_service_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  int v6;
  unsigned int v7;
  unsigned int v9;

  v4 = *(_QWORD *)(a1 + 32);
  if (!v4 || ((*(uint64_t (**)(uint64_t, uint64_t))(v4 + 16))(v4, a2) & 1) == 0)
  {
    if (_mdns_dns_service_scope_id_match(a2, *(_QWORD *)(a1 + 64)))
    {
      v9 = 0;
      v5 = _mdns_dns_service_handles_domain_name(a2, *(_BYTE **)(a1 + 72), &v9);
      if ((v5 & 0x80000000) == 0)
      {
        v6 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
        if (v5 > v6)
        {
          v7 = v9;
LABEL_7:
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) = a2;
          *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = v5;
          *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = v7;
          return 1;
        }
        if (v5 == v6)
        {
          v7 = v9;
          if (v9 < *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24))
            goto LABEL_7;
        }
      }
    }
  }
  return 1;
}

uint64_t _mdns_dns_service_get_preferred_encrypted_alt(uint64_t a1, char a2)
{
  const __CFArray *v3;
  uint64_t v4;
  _QWORD v6[6];
  char v7;
  _QWORD v8[3];
  char v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;

  v10 = 0;
  v11 = &v10;
  v12 = 0x2000000000;
  v13 = 0;
  v8[0] = 0;
  v8[1] = v8;
  v8[2] = 0x2000000000;
  v9 = 0;
  v3 = *(const __CFArray **)(a1 + 144);
  if (v3 && *(unsigned __int8 *)(a1 + 281) - 2 >= 4)
  {
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 0x40000000;
    v6[2] = ___mdns_dns_service_get_preferred_encrypted_alt_block_invoke;
    v6[3] = &unk_10013ABD8;
    v7 = a2;
    v6[4] = v8;
    v6[5] = &v10;
    mdns_cfarray_enumerate(v3, (uint64_t)v6);
    v4 = v11[3];
  }
  else
  {
    v4 = 0;
  }
  _Block_object_dispose(v8, 8);
  _Block_object_dispose(&v10, 8);
  return v4;
}

BOOL ___mdns_dns_service_get_preferred_encrypted_alt_block_invoke(uint64_t a1, uint64_t a2)
{
  int v4;
  int v5;
  int v6;
  BOOL v7;

  if ((*(_WORD *)(a2 + 276) & 0x801) != 0)
    return 1;
  v4 = *(_QWORD *)(a2 + 96) && nw_resolver_config_get_class() == 4;
  if (*(unsigned __int8 *)(a1 + 48) != v4)
    return 1;
  v5 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if ((v5 - 3) >= 2)
  {
    v6 = *(unsigned __int8 *)(a2 + 281);
    if ((v6 - 3) < 2 || v6 == 2 && (v7 = v5 == 2, v5 = 2, !v7))
    {
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = a2;
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v6;
      v5 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    }
  }
  return (v5 - 5) < 0xFFFFFFFE;
}

uint64_t _mdns_dns_service_handles_domain_name(uint64_t a1, _BYTE *a2, _DWORD *a3)
{
  uint64_t *v5;
  unsigned int v6;
  int v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  int v12;
  unsigned __int8 *v13;

  v5 = (uint64_t *)(a1 + 88);
  while (1)
  {
    v5 = (uint64_t *)*v5;
    if (!v5)
      return 0xFFFFFFFFLL;
    v6 = *a2;
    if (*a2)
    {
      v7 = 0;
      v8 = a2;
      while (v6 <= 0x3F)
      {
        v8 += v6 + 1;
        if (v8 - a2 > 255)
          break;
        ++v7;
        v6 = *v8;
        if (!*v8)
          goto LABEL_10;
      }
      v7 = -1;
    }
    else
    {
      v7 = 0;
    }
LABEL_10:
    v9 = v5[1];
    v10 = *(unsigned int *)(v9 + 48);
    v11 = __OFSUB__(v7, (_DWORD)v10);
    v12 = v7 - v10;
    if (v12 < 0 == v11)
    {
      if (!(_DWORD)v10)
        break;
      v13 = a2;
      if (v12 >= 1)
      {
        v13 = a2;
        do
        {
          if (!*v13)
            break;
          v13 += *v13 + 1;
          --v12;
        }
        while (v12);
      }
      if (DomainNameEqual(v13, *(unsigned __int8 **)(v9 + 24)))
        break;
    }
  }
  if (a3)
    *a3 = *((_DWORD *)v5 + 4);
  return v10;
}

uint64_t __mdns_dns_service_manager_get_interface_scoped_custom_push_service_block_invoke(uint64_t a1)
{
  uint64_t v2;
  const __CFArray *v3;
  uint64_t v4;
  int v5;
  uint64_t service;
  uint64_t result;
  int v8;
  uint64_t v9;
  uint64_t v10;

  v2 = *(_QWORD *)(a1 + 40);
  if (*(_BYTE *)(v2 + 131))
  {
    result = 0;
  }
  else
  {
    v3 = *(const __CFArray **)(v2 + 72);
    v4 = *(_QWORD *)(a1 + 48);
    v5 = *(_DWORD *)(a1 + 56);
    v9 = 0;
    v10 = 0x100000000;
    v8 = v5;
    service = _mdns_dns_service_manager_get_service(v3, v4, (uint64_t)&v8, 0, 0);
    result = _mdns_dns_service_manager_prepare_service(*(_QWORD *)(a1 + 40), service);
  }
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t mdns_dns_service_manager_get_unscoped_native_service(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD block[7];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2000000000;
  v10 = 0;
  if (_mdns_dns_service_queue_s_once != -1)
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = __mdns_dns_service_manager_get_unscoped_native_service_block_invoke;
  block[3] = &unk_10013A340;
  block[4] = &v7;
  block[5] = a1;
  block[6] = a2;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, block);
  v4 = v8[3];
  _Block_object_dispose(&v7, 8);
  return v4;
}

uint64_t __mdns_dns_service_manager_get_unscoped_native_service_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  const __CFArray *v3;
  uint64_t v4;
  uint64_t service;
  uint64_t result;
  _QWORD v7[2];
  int v8;

  v2 = a1[5];
  if (*(_BYTE *)(v2 + 131))
  {
    result = 0;
  }
  else
  {
    v3 = *(const __CFArray **)(v2 + 24);
    v4 = a1[6];
    v7[0] = 0;
    v7[1] = 0;
    v8 = 0;
    service = _mdns_dns_service_manager_get_service(v3, v4, (uint64_t)v7, 0, 0);
    result = _mdns_dns_service_manager_prepare_service(a1[5], service);
  }
  *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = result;
  return result;
}

uint64_t __mdns_dns_service_manager_get_interface_scoped_native_service_block_invoke(uint64_t a1)
{
  uint64_t v2;
  const __CFArray *v3;
  uint64_t v4;
  int v5;
  uint64_t service;
  uint64_t result;
  int v8;
  uint64_t v9;
  uint64_t v10;

  v2 = *(_QWORD *)(a1 + 40);
  if (*(_BYTE *)(v2 + 131))
  {
    result = 0;
  }
  else
  {
    v3 = *(const __CFArray **)(v2 + 24);
    v4 = *(_QWORD *)(a1 + 48);
    v5 = *(_DWORD *)(a1 + 56);
    v9 = 0;
    v10 = 0x100000000;
    v8 = v5;
    service = _mdns_dns_service_manager_get_service(v3, v4, (uint64_t)&v8, 0, 0);
    result = _mdns_dns_service_manager_prepare_service(*(_QWORD *)(a1 + 40), service);
  }
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t mdns_dns_service_manager_get_unscoped_system_service_with_options(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6;
  _QWORD v8[7];
  int v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;

  v10 = 0;
  v11 = &v10;
  v12 = 0x2000000000;
  v13 = 0;
  if (_mdns_dns_service_queue_s_once != -1)
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = __mdns_dns_service_manager_get_unscoped_system_service_with_options_block_invoke;
  v8[3] = &unk_10013A390;
  v8[4] = &v10;
  v8[5] = a1;
  v8[6] = a2;
  v9 = a3;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, v8);
  v6 = v11[3];
  _Block_object_dispose(&v10, 8);
  return v6;
}

uint64_t __mdns_dns_service_manager_get_unscoped_system_service_with_options_block_invoke(uint64_t a1)
{
  uint64_t v2;
  const __CFArray *v3;
  uint64_t v4;
  int v5;
  uint64_t service;
  uint64_t result;
  _QWORD v8[2];
  int v9;

  v2 = *(_QWORD *)(a1 + 40);
  if (*(_BYTE *)(v2 + 131))
  {
    result = 0;
  }
  else
  {
    v3 = *(const __CFArray **)(v2 + 32);
    v4 = *(_QWORD *)(a1 + 48);
    v5 = *(_DWORD *)(a1 + 56);
    v8[0] = 0;
    v8[1] = 0;
    v9 = 0;
    service = _mdns_dns_service_manager_get_service(v3, v4, (uint64_t)v8, v5, 0);
    result = _mdns_dns_service_manager_prepare_service(*(_QWORD *)(a1 + 40), service);
  }
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t mdns_dns_service_manager_get_interface_scoped_system_service_with_options(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t v8;
  _QWORD v10[7];
  int v11;
  int v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;

  v13 = 0;
  v14 = &v13;
  v15 = 0x2000000000;
  v16 = 0;
  if (_mdns_dns_service_queue_s_once != -1)
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = __mdns_dns_service_manager_get_interface_scoped_system_service_with_options_block_invoke;
  v10[3] = &unk_10013A3B8;
  v10[4] = &v13;
  v10[5] = a1;
  v10[6] = a2;
  v11 = a3;
  v12 = a4;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, v10);
  v8 = v14[3];
  _Block_object_dispose(&v13, 8);
  return v8;
}

uint64_t __mdns_dns_service_manager_get_interface_scoped_system_service_with_options_block_invoke(uint64_t a1)
{
  uint64_t v2;
  const __CFArray *v3;
  uint64_t v4;
  int v5;
  int v6;
  uint64_t service;
  uint64_t result;
  int v9;
  uint64_t v10;
  uint64_t v11;

  v2 = *(_QWORD *)(a1 + 40);
  if (*(_BYTE *)(v2 + 131))
  {
    result = 0;
  }
  else
  {
    v3 = *(const __CFArray **)(v2 + 32);
    v4 = *(_QWORD *)(a1 + 48);
    v6 = *(_DWORD *)(a1 + 56);
    v5 = *(_DWORD *)(a1 + 60);
    v10 = 0;
    v11 = 0x100000000;
    v9 = v6;
    service = _mdns_dns_service_manager_get_service(v3, v4, (uint64_t)&v9, v5, 0);
    result = _mdns_dns_service_manager_prepare_service(*(_QWORD *)(a1 + 40), service);
  }
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t mdns_dns_service_manager_get_service_scoped_system_service(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6;
  _QWORD v8[7];
  int v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;

  v10 = 0;
  v11 = &v10;
  v12 = 0x2000000000;
  v13 = 0;
  if (_mdns_dns_service_queue_s_once != -1)
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = __mdns_dns_service_manager_get_service_scoped_system_service_block_invoke;
  v8[3] = &unk_10013A3E0;
  v8[4] = &v10;
  v8[5] = a1;
  v8[6] = a2;
  v9 = a3;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, v8);
  v6 = v11[3];
  _Block_object_dispose(&v10, 8);
  return v6;
}

uint64_t __mdns_dns_service_manager_get_service_scoped_system_service_block_invoke(uint64_t a1)
{
  uint64_t v2;
  const __CFArray *v3;
  uint64_t v4;
  int v5;
  uint64_t service;
  uint64_t result;
  int v8;
  uint64_t v9;
  uint64_t v10;

  v2 = *(_QWORD *)(a1 + 40);
  if (*(_BYTE *)(v2 + 131))
  {
    result = 0;
  }
  else
  {
    v3 = *(const __CFArray **)(v2 + 32);
    v4 = *(_QWORD *)(a1 + 48);
    v5 = *(_DWORD *)(a1 + 56);
    v9 = 0;
    v10 = 0x200000000;
    v8 = v5;
    service = _mdns_dns_service_manager_get_service(v3, v4, (uint64_t)&v8, 0, 0);
    result = _mdns_dns_service_manager_prepare_service(*(_QWORD *)(a1 + 40), service);
  }
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t mdns_dns_service_manager_get_custom_service(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD block[7];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2000000000;
  v10 = 0;
  if (_mdns_dns_service_queue_s_once != -1)
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = __mdns_dns_service_manager_get_custom_service_block_invoke;
  block[3] = &unk_10013A408;
  block[4] = &v7;
  block[5] = a1;
  block[6] = a2;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, block);
  v4 = v8[3];
  _Block_object_dispose(&v7, 8);
  return v4;
}

uint64_t __mdns_dns_service_manager_get_custom_service_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t service_by_id;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 40);
  if (*(_BYTE *)(v2 + 131))
  {
    result = 0;
  }
  else
  {
    service_by_id = _mdns_dns_service_manager_get_service_by_id(*(const __CFArray **)(v2 + 56), *(_QWORD *)(a1 + 48));
    if (service_by_id)
      service_by_id = (uint64_t)_mdns_dns_service_manager_get_usable_service_instance(*(CFArrayRef **)(a1 + 40), service_by_id, 0);
    result = _mdns_dns_service_manager_prepare_service(*(_QWORD *)(a1 + 40), service_by_id);
  }
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

__CFArray *_mdns_dns_service_manager_get_usable_service_instance(CFArrayRef *a1, uint64_t a2, int a3)
{
  int v5;
  BOOL v6;
  char v7;
  __CFArray *Mutable;
  int v9;
  const __CFArray *v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  void *v14;
  unsigned int v15;
  _QWORD v17[5];
  int v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;

  v5 = *(_DWORD *)(a2 + 256);
  if (a3)
    v6 = v5 == a3;
  else
    v6 = 1;
  v7 = !v6;
  if (v5 && (v7 & 1) != 0)
    return 0;
  if ((v7 & 1) == 0 && (*(_WORD *)(a2 + 276) & 1) == 0)
    return (__CFArray *)a2;
  if (v5)
    v9 = *(_DWORD *)(a2 + 256);
  else
    v9 = a3;
  v19 = 0;
  v20 = &v19;
  v21 = 0x2000000000;
  v22 = 0;
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 0x40000000;
  v17[2] = ___mdns_dns_service_get_variant_for_interface_block_invoke;
  v17[3] = &unk_10013ACD0;
  v18 = v9;
  v17[4] = &v19;
  v10 = *(const __CFArray **)(a2 + 128);
  if (v10)
  {
    mdns_cfarray_enumerate(v10, (uint64_t)v17);
    Mutable = (__CFArray *)v20[3];
    _Block_object_dispose(&v19, 8);
    if (Mutable)
      return Mutable;
  }
  else
  {
    _Block_object_dispose(&v19, 8);
  }
  LODWORD(v17[0]) = 0;
  v11 = _mdns_dns_service_create(*(_BYTE *)(a2 + 281), *(_BYTE *)(a2 + 282), *(_BYTE *)(a2 + 280), (int *)v17);
  v12 = v11;
  if (!LODWORD(v17[0]))
  {
    *(_QWORD *)(v11 + 136) = a2;
    os_retain((void *)a2);
    *(_DWORD *)(v12 + 256) = v9;
    *(_WORD *)(v12 + 276) = *(_WORD *)(a2 + 276) & 6;
    v13 = *(const void **)(a2 + 80);
    *(_QWORD *)(v12 + 80) = v13;
    if (v13)
      CFRetain(v13);
    v14 = *(void **)(a2 + 96);
    *(_QWORD *)(v12 + 96) = v14;
    if (v14)
      nw_retain(v14);
    v15 = *(_DWORD *)(v12 + 256);
    if (v15)
      *(_QWORD *)(v12 + 104) = mdns_system_interface_index_to_name(v15);
    goto LABEL_26;
  }
  if (!v11)
    return 0;
LABEL_26:
  Mutable = *(__CFArray **)(a2 + 128);
  if (Mutable
    || (Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, (const CFArrayCallBacks *)&mdns_cfarray_callbacks),
        (*(_QWORD *)(a2 + 128) = Mutable) != 0))
  {
    _mdns_dns_service_increment_use_count(v12);
    CFArrayAppendValue(Mutable, (const void *)v12);
    _mdns_dns_service_manager_update_interface_properties_for_service(a1, v12);
    Mutable = (__CFArray *)v12;
  }
  os_release((void *)v12);
  return Mutable;
}

BOOL ___mdns_dns_service_get_variant_for_interface_block_invoke(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 256) == *(_DWORD *)(a1 + 40))
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = a2;
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) == 0;
}

uint64_t __mdns_dns_service_manager_get_interface_scoped_mdns_alternative_service_block_invoke(uint64_t a1)
{
  uint64_t v2;
  const __CFArray *v3;
  uint64_t v4;
  int v5;
  uint64_t service;
  uint64_t result;
  int v8;
  uint64_t v9;
  uint64_t v10;

  v2 = *(_QWORD *)(a1 + 40);
  if (*(_BYTE *)(v2 + 131))
  {
    result = 0;
  }
  else
  {
    v3 = *(const __CFArray **)(v2 + 72);
    v4 = *(_QWORD *)(a1 + 48);
    v5 = *(_DWORD *)(a1 + 56);
    v9 = 0;
    v10 = 0x100000000;
    v8 = v5;
    service = _mdns_dns_service_manager_get_service(v3, v4, (uint64_t)&v8, 0, (uint64_t)&__block_literal_global_30);
    result = _mdns_dns_service_manager_prepare_service(*(_QWORD *)(a1 + 40), service);
  }
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

BOOL __mdns_dns_service_manager_get_interface_scoped_mdns_alternative_service_block_invoke_2(id a1, const mdns_dns_service_s *a2)
{
  return (a2->var32 & 0x4000) == 0;
}

uint64_t __mdns_dns_service_manager_get_unscoped_mdns_alternative_service_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  const __CFArray *v3;
  uint64_t v4;
  uint64_t service;
  uint64_t result;
  _QWORD v7[2];
  int v8;

  v2 = a1[5];
  if (*(_BYTE *)(v2 + 131))
  {
    result = 0;
  }
  else
  {
    v3 = *(const __CFArray **)(v2 + 72);
    v4 = a1[6];
    v7[0] = 0;
    v7[1] = 0;
    v8 = 0;
    service = _mdns_dns_service_manager_get_service(v3, v4, (uint64_t)v7, 0, (uint64_t)&__block_literal_global_33);
    result = _mdns_dns_service_manager_prepare_service(a1[5], service);
  }
  *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = result;
  return result;
}

BOOL __mdns_dns_service_manager_get_unscoped_mdns_alternative_service_block_invoke_2(id a1, const mdns_dns_service_s *a2)
{
  return (a2->var32 & 0x4000) == 0;
}

uint64_t mdns_dns_service_manager_get_uuid_scoped_service(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6;
  _QWORD v8[7];
  int v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;

  v10 = 0;
  v11 = &v10;
  v12 = 0x2000000000;
  v13 = 0;
  if (_mdns_dns_service_queue_s_once != -1)
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = __mdns_dns_service_manager_get_uuid_scoped_service_block_invoke;
  v8[3] = &unk_10013A500;
  v8[4] = &v10;
  v8[5] = a1;
  v8[6] = a2;
  v9 = a3;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, v8);
  v6 = v11[3];
  _Block_object_dispose(&v10, 8);
  return v6;
}

uint64_t __mdns_dns_service_manager_get_uuid_scoped_service_block_invoke(uint64_t a1)
{
  uint64_t v2;
  const unsigned __int8 *v3;
  uint64_t service_by_uuid;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 40);
  if (*(_BYTE *)(v2 + 131))
  {
    result = 0;
  }
  else
  {
    v3 = *(const unsigned __int8 **)(a1 + 48);
    service_by_uuid = _mdns_dns_service_manager_get_service_by_uuid(*(const __CFArray **)(v2 + 48), v3);
    if (service_by_uuid
      || (service_by_uuid = _mdns_dns_service_manager_get_service_by_uuid(*(const __CFArray **)(v2 + 40), v3)) != 0)
    {
      service_by_uuid = (uint64_t)_mdns_dns_service_manager_get_usable_service_instance(*(CFArrayRef **)(a1 + 40), service_by_uuid, *(_DWORD *)(a1 + 56));
    }
    result = _mdns_dns_service_manager_prepare_service(*(_QWORD *)(a1 + 40), service_by_uuid);
  }
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t mdns_dns_service_manager_get_discovered_service(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD block[7];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2000000000;
  v10 = 0;
  if (_mdns_dns_service_queue_s_once != -1)
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = __mdns_dns_service_manager_get_discovered_service_block_invoke;
  block[3] = &unk_10013A528;
  block[4] = &v7;
  block[5] = a1;
  block[6] = a2;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, block);
  v4 = v8[3];
  _Block_object_dispose(&v7, 8);
  return v4;
}

uint64_t __mdns_dns_service_manager_get_discovered_service_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  const __CFArray *v4;
  uint64_t v5;
  uint64_t v6;
  __CFArray *usable_service_instance;
  uint64_t result;
  _QWORD v9[7];
  _QWORD v10[3];
  int v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;

  v2 = *(_QWORD *)(a1 + 40);
  if (*(_BYTE *)(v2 + 131))
  {
    result = 0;
  }
  else
  {
    v3 = *(_QWORD *)(a1 + 48);
    v12 = 0;
    v13 = &v12;
    v14 = 0x2000000000;
    v15 = 0;
    v10[0] = 0;
    v10[1] = v10;
    v10[2] = 0x2000000000;
    v11 = -1;
    v4 = *(const __CFArray **)(v2 + 48);
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 0x40000000;
    v9[2] = ___mdns_dns_service_manager_get_discovered_service_block_invoke;
    v9[3] = &unk_10013AA60;
    v9[5] = &v12;
    v9[6] = v3;
    v9[4] = v10;
    mdns_cfarray_enumerate(v4, (uint64_t)v9);
    if (v13[3])
    {
      v5 = mach_continuous_approximate_time();
      v6 = v13[3];
      *(_QWORD *)(v6 + 32) = v5;
    }
    else
    {
      v6 = 0;
    }
    _Block_object_dispose(v10, 8);
    _Block_object_dispose(&v12, 8);
    if (v6)
      usable_service_instance = _mdns_dns_service_manager_get_usable_service_instance(*(CFArrayRef **)(a1 + 40), v6, 0);
    else
      usable_service_instance = 0;
    result = _mdns_dns_service_manager_prepare_service(*(_QWORD *)(a1 + 40), (uint64_t)usable_service_instance);
  }
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t ___mdns_dns_service_manager_get_discovered_service_block_invoke(uint64_t a1, _QWORD *a2)
{
  int v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  _QWORD *v8;
  int v10;
  uint64_t v11;

  v4 = _mdns_dns_service_handles_domain_name((uint64_t)a2, *(_BYTE **)(a1 + 48), 0);
  if (a2[12] && v4 > *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = a2;
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v4;
  }
  v5 = a2[5];
  if (v5 && v5 < mach_continuous_time())
  {
    if (_mdns_dns_service_log_s_once != -1)
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
    v6 = _mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
    {
      v7 = a2[6];
      v10 = 138412290;
      v11 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "DoH resolver for %@ has passed expiration", (uint8_t *)&v10, 0xCu);
    }
    a2[5] = 0;
    while (1)
    {
      v8 = (_QWORD *)a2[11];
      if (!v8)
        break;
      a2[11] = *v8;
      _domain_item_free(v8);
    }
    _mdns_dns_service_manager_fetch_doh_pvd(a2);
  }
  return 1;
}

uint64_t mdns_dns_service_manager_get_discovered_oblivious_service(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t proxy_agent;
  uint64_t v8;
  uint64_t v9;
  _QWORD v11[8];
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;

  v4 = *(_QWORD *)(a2 + 96);
  if (!v4)
    return 0;
  if (nw_resolver_config_get_class(v4) != 4)
    return 0;
  proxy_agent = nw_resolver_config_get_proxy_agent(*(_QWORD *)(a2 + 96));
  if (!proxy_agent)
    return 0;
  v8 = proxy_agent;
  v12 = 0;
  v13 = &v12;
  v14 = 0x2000000000;
  v15 = 0;
  if (_mdns_dns_service_queue_s_once != -1)
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  v11[2] = __mdns_dns_service_manager_get_discovered_oblivious_service_block_invoke;
  v11[3] = &unk_10013A550;
  v11[4] = &v12;
  v11[5] = a1;
  v11[6] = a3;
  v11[7] = v8;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, v11);
  v9 = v13[3];
  _Block_object_dispose(&v12, 8);
  return v9;
}

uint64_t __mdns_dns_service_manager_get_discovered_oblivious_service_block_invoke(uint64_t a1)
{
  uint64_t v2;
  const __CFArray *v3;
  uint64_t v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  _QWORD v8[2];
  int v9;

  v2 = *(_QWORD *)(a1 + 40);
  if (*(_BYTE *)(v2 + 131))
    goto LABEL_8;
  v3 = *(const __CFArray **)(v2 + 32);
  v4 = *(_QWORD *)(a1 + 48);
  v8[0] = 0;
  v8[1] = 0;
  v9 = 0;
  result = _mdns_dns_service_manager_get_service(v3, v4, (uint64_t)v8, 3, 0);
  if (!result)
    goto LABEL_7;
  v6 = result;
  result = *(_QWORD *)(result + 96);
  if (!result)
    goto LABEL_7;
  if (nw_resolver_config_get_class(result) != 4)
  {
LABEL_8:
    result = 0;
    goto LABEL_7;
  }
  result = (uint64_t)_mdns_dns_service_manager_get_usable_service_instance(*(CFArrayRef **)(a1 + 40), v6, 0);
  if (result)
  {
    v7 = result;
    nw_resolver_config_set_proxy_agent(*(_QWORD *)(result + 96), *(_QWORD *)(a1 + 56));
    result = _mdns_dns_service_manager_prepare_service(*(_QWORD *)(a1 + 40), v7);
  }
LABEL_7:
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t __mdns_dns_service_manager_get_discovered_push_service_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t discovered_push_service;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 40);
  if (*(_BYTE *)(v2 + 131))
  {
    result = 0;
  }
  else
  {
    discovered_push_service = _mdns_dns_service_manager_get_discovered_push_service(*(const __CFArray **)(v2 + 64), *(_QWORD *)(a1 + 48), *(_DWORD *)(a1 + 56));
    result = _mdns_dns_service_manager_prepare_service(*(_QWORD *)(a1 + 40), discovered_push_service);
  }
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

void __mdns_dns_service_manager_apply_pending_updates_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  void *v10;
  id v11;
  id v12;
  void *v13;
  id v14;
  void **v15;
  void *v16;
  void *v17;
  id v18;
  void **v19;
  uint64_t v20;
  void *v21;
  void *v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  char v27;
  void **v28;
  uint64_t v29;
  void *v30;
  void *v31;
  Block_layout *v32;
  void **v33;
  uint64_t v34;
  uint64_t (*v35)(uint64_t, _QWORD *);
  void *v36;
  void ***v37;

  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 131))
  {
    v28 = _NSConcreteStackBlock;
    v29 = 0x40000000;
    v30 = ___mdns_dns_service_manager_remove_unused_services_block_invoke;
    v31 = &__block_descriptor_tmp_99;
    v32 = (Block_layout *)v2;
    v33 = _NSConcreteStackBlock;
    v34 = 0x40000000;
    v35 = ___mdns_dns_service_manager_enumerate_all_service_arrays_block_invoke;
    v36 = &unk_10013B230;
    v37 = &v28;
    _mdns_dns_service_manager_enumerate_all_service_array_pointers(v2, (uint64_t)&v33);
    v3 = *(_QWORD *)(a1 + 32);
    v33 = _NSConcreteStackBlock;
    v34 = 0x40000000;
    v35 = ___mdns_dns_service_manager_enumerate_all_service_arrays_block_invoke;
    v36 = &unk_10013B230;
    v37 = (void ***)&__block_literal_global_130;
    _mdns_dns_service_manager_enumerate_all_service_array_pointers(v3, (uint64_t)&v33);
    v4 = *(_QWORD *)(a1 + 32);
    v19 = _NSConcreteStackBlock;
    v20 = 0x40000000;
    v21 = ___mdns_dns_service_manager_handle_pending_alts_block_invoke;
    v22 = &__block_descriptor_tmp_134;
    v23 = (uint64_t *)v4;
    v28 = _NSConcreteStackBlock;
    v29 = 0x40000000;
    v30 = ___mdns_dns_service_manager_enumerate_all_services_block_invoke;
    v31 = &unk_10013B258;
    v32 = (Block_layout *)&v19;
    v33 = _NSConcreteStackBlock;
    v34 = 0x40000000;
    v35 = ___mdns_dns_service_manager_enumerate_all_service_arrays_block_invoke;
    v36 = &unk_10013B230;
    v37 = &v28;
    _mdns_dns_service_manager_enumerate_all_service_array_pointers(v4, (uint64_t)&v33);
    v5 = *(_QWORD *)(a1 + 32);
    v28 = _NSConcreteStackBlock;
    v29 = 0x40000000;
    v30 = ___mdns_dns_service_manager_enumerate_all_services_block_invoke;
    v31 = &unk_10013B258;
    v32 = &__block_literal_global_101;
    v33 = _NSConcreteStackBlock;
    v34 = 0x40000000;
    v35 = ___mdns_dns_service_manager_enumerate_all_service_arrays_block_invoke;
    v36 = &unk_10013B230;
    v37 = &v28;
    _mdns_dns_service_manager_enumerate_all_service_array_pointers(v5, (uint64_t)&v33);
    v6 = *(_QWORD *)(a1 + 32);
    v28 = _NSConcreteStackBlock;
    v29 = 0x40000000;
    v30 = ___mdns_dns_service_manager_enumerate_all_services_block_invoke;
    v31 = &unk_10013B258;
    v32 = &__block_literal_global_120_918;
    v33 = _NSConcreteStackBlock;
    v34 = 0x40000000;
    v35 = ___mdns_dns_service_manager_enumerate_all_service_arrays_block_invoke;
    v36 = &unk_10013B230;
    v37 = &v28;
    _mdns_dns_service_manager_enumerate_all_service_array_pointers(v6, (uint64_t)&v33);
    _mdns_dns_service_manager_remove_unneeded_interface_monitors(*(_QWORD *)(a1 + 32));
    v7 = *(_QWORD *)(a1 + 32);
    v19 = _NSConcreteStackBlock;
    v20 = 0x40000000;
    v21 = ___mdns_dns_service_manager_update_interface_properties_block_invoke;
    v22 = &__block_descriptor_tmp_117;
    v23 = (uint64_t *)v7;
    v28 = _NSConcreteStackBlock;
    v29 = 0x40000000;
    v30 = ___mdns_dns_service_manager_enumerate_all_services_block_invoke;
    v31 = &unk_10013B258;
    v32 = (Block_layout *)&v19;
    v33 = _NSConcreteStackBlock;
    v34 = 0x40000000;
    v35 = ___mdns_dns_service_manager_enumerate_all_service_arrays_block_invoke;
    v36 = &unk_10013B230;
    v37 = &v28;
    _mdns_dns_service_manager_enumerate_all_service_array_pointers(v7, (uint64_t)&v33);
    v8 = *(_QWORD *)(a1 + 32);
    v24 = 0;
    v25 = &v24;
    v26 = 0x2000000000;
    v27 = 0;
    v19 = _NSConcreteStackBlock;
    v20 = 0x40000000;
    v21 = ___mdns_dns_service_manager_update_policies_block_invoke;
    v22 = &unk_10013AC28;
    v23 = &v24;
    v28 = _NSConcreteStackBlock;
    v29 = 0x40000000;
    v30 = ___mdns_dns_service_manager_enumerate_all_services_block_invoke;
    v31 = &unk_10013B258;
    v32 = (Block_layout *)&v19;
    v33 = _NSConcreteStackBlock;
    v34 = 0x40000000;
    v35 = ___mdns_dns_service_manager_enumerate_all_service_arrays_block_invoke;
    v36 = &unk_10013B230;
    v37 = &v28;
    _mdns_dns_service_manager_enumerate_all_service_array_pointers(v8, (uint64_t)&v33);
    v9 = *(void **)(v8 + 112);
    if (*((_BYTE *)v25 + 24))
    {
      if (!v9)
      {
        v10 = objc_autoreleasePoolPush();
        if (objc_opt_class(NEPolicySession))
        {
          v11 = objc_msgSend(objc_alloc((Class)NEPolicySession), "initFromPrivilegedProcess");
          objc_msgSend(v11, "setPriority:", 500);
          v12 = objc_msgSend(objc_alloc((Class)NSUUID), "initWithUUIDBytes:", &ne_privacy_proxy_netagent_id);
          v13 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyResult removeNetworkAgentUUID:](NEPolicyResult, "removeNetworkAgentUUID:", v12));
          v14 = objc_alloc((Class)NEPolicy);
          v15 = (void **)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition allInterfaces](NEPolicyCondition, "allInterfaces"));
          v33 = v15;
          v16 = (void *)objc_claimAutoreleasedReturnValue(+[NEPolicyCondition flowRemoteAddressEmpty](NEPolicyCondition, "flowRemoteAddressEmpty"));
          v34 = (uint64_t)v16;
          v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v33, 2));
          v18 = objc_msgSend(v14, "initWithOrder:result:conditions:", 0, v13, v17);
          objc_msgSend(v11, "addPolicy:", v18);

          objc_msgSend(v11, "apply");
        }
        else
        {
          v11 = 0;
        }
        objc_autoreleasePoolPop(v10);
        goto LABEL_9;
      }
    }
    else if (v9)
    {
      mdns_system_remove_network_policy(v9);
      v11 = 0;
LABEL_9:
      *(_QWORD *)(v8 + 112) = v11;
    }
    _Block_object_dispose(&v24, 8);
  }
}

uint64_t ___mdns_dns_service_manager_remove_unused_services_block_invoke(uint64_t a1, CFArrayRef theArray)
{
  CFIndex Count;
  CFIndex v5;
  _DWORD *ValueAtIndex;

  Count = CFArrayGetCount(theArray);
  if (Count - 1 >= 0)
  {
    v5 = Count;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(theArray, --v5);
      if (!ValueAtIndex[66])
      {
        _mdns_dns_service_manager_terminate_service(*(_QWORD *)(a1 + 32), (uint64_t)ValueAtIndex);
        CFArrayRemoveValueAtIndex(theArray, v5);
      }
    }
    while (v5 > 0);
  }
  return 1;
}

uint64_t ___mdns_dns_service_manager_handle_pending_alts_block_invoke(uint64_t a1, uint64_t a2)
{
  const __CFArray *v4;
  uint64_t v5;
  const __CFArray *v6;
  const void *v7;
  _QWORD v9[6];

  if (*(_BYTE *)(a2 + 287))
  {
    *(_BYTE *)(a2 + 287) = 0;
    v4 = *(const __CFArray **)(a2 + 152);
    if (v4)
    {
      if (CFArrayGetCount(v4) >= 1)
      {
        v9[0] = _NSConcreteStackBlock;
        v9[1] = 0x40000000;
        v9[2] = ___mdns_dns_service_manager_handle_pending_alts_block_invoke_2;
        v9[3] = &__block_descriptor_tmp_133;
        v5 = *(_QWORD *)(a1 + 32);
        v9[4] = a2;
        v9[5] = v5;
        v6 = *(const __CFArray **)(a2 + 144);
        if (v6)
        {
          mdns_cfarray_enumerate(v6, (uint64_t)v9);
          v7 = *(const void **)(a2 + 144);
          if (v7)
            CFRelease(v7);
        }
        *(_QWORD *)(a2 + 144) = *(_QWORD *)(a2 + 152);
        *(_QWORD *)(a2 + 152) = 0;
      }
    }
  }
  return 1;
}

uint64_t ___mdns_dns_service_manager_update_interface_properties_block_invoke(uint64_t a1, uint64_t a2)
{
  _mdns_dns_service_manager_update_interface_properties_for_service(*(CFArrayRef **)(a1 + 32), a2);
  return 1;
}

BOOL ___mdns_dns_service_manager_update_policies_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t preferred_encrypted_alt;

  preferred_encrypted_alt = _mdns_dns_service_get_preferred_encrypted_alt(a2, 1);
  if (preferred_encrypted_alt)
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  return preferred_encrypted_alt == 0;
}

BOOL ___mdns_dns_service_manager_update_nw_config_data_block_invoke(id a1, const mdns_dns_service_s *a2)
{
  _mdns_dns_service_update_nw_config_data((uint64_t)a2);
  return 1;
}

BOOL ___mdns_dns_service_manager_update_service_usability_block_invoke(id a1, const mdns_dns_service_s *a2)
{
  unsigned __int16 var32;
  unsigned __int16 v3;

  var32 = a2->var32;
  if (a2->var37)
  {
    if ((a2->var32 & 0x800) == 0)
    {
      v3 = var32 | 0x800;
LABEL_6:
      a2->var32 = v3;
    }
  }
  else if ((a2->var32 & 0x800) != 0)
  {
    v3 = var32 & 0xF7FF;
    goto LABEL_6;
  }
  return 1;
}

uint64_t ___mdns_dns_service_manager_handle_pending_alts_block_invoke_2(uint64_t a1, uint64_t a2)
{
  const __CFArray *v4;
  NSObject *v5;
  uint64_t v6;
  __int128 v8;
  BOOL (*v9)(uint64_t, uint64_t);
  void *v10;
  uint64_t v11;

  v4 = *(const __CFArray **)(*(_QWORD *)(a1 + 32) + 152);
  *(_QWORD *)&v8 = _NSConcreteStackBlock;
  *((_QWORD *)&v8 + 1) = 0x40000000;
  v9 = ___mdns_dns_service_array_contains_service_block_invoke;
  v10 = &__block_descriptor_tmp_135;
  v11 = a2;
  if (mdns_cfarray_enumerate(v4, (uint64_t)&v8))
  {
    _mdns_dns_service_manager_terminate_service(*(_QWORD *)(a1 + 40), a2);
    if (_mdns_dns_service_log_s_once != -1)
      dispatch_once(&_mdns_dns_service_log_s_once, &__block_literal_global_62);
    v5 = _mdns_dns_service_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dns_service_log_s_log, OS_LOG_TYPE_INFO))
    {
      v6 = *(_QWORD *)(a2 + 24);
      LODWORD(v8) = 134217984;
      *(_QWORD *)((char *)&v8 + 4) = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "Deregistered discovered service -- id: %llu", (uint8_t *)&v8, 0xCu);
    }
  }
  return 1;
}

BOOL ___mdns_dns_service_manager_handle_network_changes_block_invoke(id a1, const __CFArray *a2)
{
  mdns_cfarray_enumerate(a2, (uint64_t)&__block_literal_global_132);
  return 1;
}

BOOL ___mdns_dns_service_manager_handle_network_changes_block_invoke_2(id a1, const mdns_dns_service_s *a2)
{
  __CFArray *var11;
  CFIndex Count;
  CFIndex v5;
  _BYTE *ValueAtIndex;

  if (a2->var40)
  {
    a2->var40 = 0;
    _mdns_dns_service_make_defunct((uint64_t)a2);
  }
  var11 = a2->var11;
  if (var11)
  {
    Count = CFArrayGetCount(var11);
    if (Count - 1 >= 0)
    {
      v5 = Count;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(a2->var11, --v5);
        if (ValueAtIndex[286])
        {
          ValueAtIndex[286] = 0;
          _mdns_dns_service_make_defunct((uint64_t)ValueAtIndex);
          CFArrayRemoveValueAtIndex(a2->var11, v5);
        }
      }
      while (v5 > 0);
    }
  }
  return 1;
}

uint64_t __mdns_dns_service_manager_apply_pending_connection_problem_updates_block_invoke(uint64_t a1)
{
  uint64_t result;
  _QWORD v2[5];
  _QWORD v3[5];

  result = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(result + 131))
  {
    v2[0] = _NSConcreteStackBlock;
    v2[2] = ___mdns_dns_service_manager_enumerate_all_services_block_invoke;
    v2[3] = &unk_10013B258;
    v2[1] = 0x40000000;
    v2[4] = &__block_literal_global_101;
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 0x40000000;
    v3[2] = ___mdns_dns_service_manager_enumerate_all_service_arrays_block_invoke;
    v3[3] = &unk_10013B230;
    v3[4] = v2;
    return _mdns_dns_service_manager_enumerate_all_service_array_pointers(result, (uint64_t)v3);
  }
  return result;
}

void mdns_dns_service_manager_enumerate(uint64_t a1, uint64_t a2)
{
  _QWORD block[7];
  _QWORD v5[3];
  char v6;

  v5[0] = 0;
  v5[1] = v5;
  v5[2] = 0x2000000000;
  v6 = 0;
  if (_mdns_dns_service_queue_s_once != -1)
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = __mdns_dns_service_manager_enumerate_block_invoke;
  block[3] = &unk_10013A5E0;
  block[5] = v5;
  block[6] = a1;
  block[4] = a2;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, block);
  _Block_object_dispose(v5, 8);
}

uint64_t __mdns_dns_service_manager_enumerate_block_invoke(_QWORD *a1)
{
  uint64_t result;
  uint64_t v3;
  _QWORD v4[5];
  _QWORD v5[5];

  result = a1[6];
  if (*(_BYTE *)(result + 131))
  {
    *(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24) = 1;
  }
  else
  {
    v3 = a1[4];
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 0x40000000;
    v4[2] = ___mdns_dns_service_manager_enumerate_all_services_block_invoke;
    v4[3] = &unk_10013B258;
    v4[4] = v3;
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 0x40000000;
    v5[2] = ___mdns_dns_service_manager_enumerate_all_service_arrays_block_invoke;
    v5[3] = &unk_10013B230;
    v5[4] = v4;
    result = _mdns_dns_service_manager_enumerate_all_service_array_pointers(result, (uint64_t)v5);
    *(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24) = result;
  }
  return result;
}

uint64_t __mdns_dns_service_manager_get_count_block_invoke(uint64_t a1)
{
  uint64_t result;
  _QWORD v3[5];
  _QWORD v4[5];

  result = *(_QWORD *)(a1 + 40);
  if (!*(_BYTE *)(result + 131))
  {
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 0x40000000;
    v3[2] = __mdns_dns_service_manager_get_count_block_invoke_2;
    v3[3] = &unk_10013A630;
    v3[4] = *(_QWORD *)(a1 + 32);
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 0x40000000;
    v4[2] = ___mdns_dns_service_manager_enumerate_all_service_arrays_block_invoke;
    v4[3] = &unk_10013B230;
    v4[4] = v3;
    return _mdns_dns_service_manager_enumerate_all_service_array_pointers(result, (uint64_t)v4);
  }
  return result;
}

uint64_t __mdns_dns_service_manager_get_count_block_invoke_2(uint64_t a1, const __CFArray *a2)
{
  _QWORD v3[5];

  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = __mdns_dns_service_manager_get_count_block_invoke_3;
  v3[3] = &unk_10013A608;
  v3[4] = *(_QWORD *)(a1 + 32);
  mdns_cfarray_enumerate(a2, (uint64_t)v3);
  return 1;
}

uint64_t __mdns_dns_service_manager_get_count_block_invoke_3(uint64_t a1, uint64_t a2)
{
  const __CFArray *v4;
  CFIndex Count;
  const __CFArray *v6;
  CFIndex v7;

  ++*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  v4 = *(const __CFArray **)(a2 + 128);
  if (v4)
  {
    Count = CFArrayGetCount(v4);
    if (Count >= 1)
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += Count;
  }
  v6 = *(const __CFArray **)(a2 + 144);
  if (v6)
  {
    v7 = CFArrayGetCount(v6);
    if (v7 >= 1)
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += v7;
  }
  return 1;
}

BOOL __mdns_dns_service_manager_handle_sleep_block_invoke(id a1, const mdns_dns_service_s *a2)
{
  mdns_resolver_s *var3;

  if (a2->var35 - 2 <= 2)
  {
    var3 = a2->var3;
    if (var3)
    {
      mdns_resolver_invalidate(var3);
      os_release(a2->var3);
      a2->var3 = 0;
      a2->var39 = 1;
    }
  }
  return 1;
}

uint64_t __mdns_dns_service_manager_handle_wake_block_invoke(uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a2 + 285))
  {
    _mdns_dns_service_manager_prepare_service(*(_QWORD *)(a1 + 32), a2);
    *(_BYTE *)(a2 + 285) = 0;
  }
  return 1;
}

void __dnssd_server_init_block_invoke(id a1)
{
  NSObject *monotonic_timer;
  NSObject *v2;
  uint8_t v3[16];

  if (_dx_server_queue_once != -1)
    dispatch_once(&_dx_server_queue_once, &__block_literal_global_20);
  dnssd_server_init_s_listener = (uint64_t)xpc_connection_create_mach_service("com.apple.dnssd.service", (dispatch_queue_t)_dx_server_queue_queue, 1uLL);
  xpc_connection_set_event_handler((xpc_connection_t)dnssd_server_init_s_listener, &__block_literal_global_4);
  xpc_connection_activate((xpc_connection_t)dnssd_server_init_s_listener);
  if (_dx_server_queue_once != -1)
    dispatch_once(&_dx_server_queue_once, &__block_literal_global_20);
  monotonic_timer = _mdns_dispatch_create_monotonic_timer(0x1B7740u, 0x1A3185C5000uLL, 5u, _dx_server_queue_queue);
  dnssd_server_init_s_powerlog_progress_timer = (uint64_t)monotonic_timer;
  if (monotonic_timer)
  {
    dispatch_source_set_event_handler(monotonic_timer, &__block_literal_global_6);
    dispatch_activate((dispatch_object_t)dnssd_server_init_s_powerlog_progress_timer);
  }
  else
  {
    if (_mdns_server_log_s_once != -1)
      dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
    v2 = _mdns_server_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)v3 = 0;
      _os_log_fault_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_FAULT, "Failed to create periodic powerlog report timer", v3, 2u);
    }
  }
}

void ___mdns_server_log_block_invoke(id a1)
{
  _mdns_server_log_s_log = (uint64_t)os_log_create("com.apple.mdns", "dnssd_server");
}

void __dnssd_server_init_block_invoke_3(id a1)
{
  NSObject *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __CFDictionary *Mutable;
  NSObject *v11;
  __uint64_t monotonic_time_ns;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  __uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  __uint64_t v24;
  BOOL v25;
  uint64_t v26;
  uint64_t v27;
  __uint64_t v28;
  uint64_t v29;
  CFStringRef v30;
  CFStringRef v31;
  __CFDictionary *v32;
  __CFDictionary *v33;
  NSObject *v34;
  __CFDictionary *v35;
  NSObject *v36;
  NSObject *v37;
  int v38;
  int v39;
  NSObject *v40;
  CFIndex Count;
  uint8_t buf[4];
  CFStringRef v43;
  __int16 v44;
  __CFDictionary *v45;

  if (_mdns_server_log_s_once != -1)
    dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
  v1 = _mdns_server_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)buf = 0;
    _os_log_debug_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEBUG, "periodic powerlog report timer fired", buf, 2u);
  }
  v2 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v2, v3, v4, v5, v6, v7, v8, v9);
  Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    if (_mdns_powerlog_log_s_once != -1)
      dispatch_once(&_mdns_powerlog_log_s_once, &__block_literal_global_1390);
    v11 = _mdns_powerlog_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_powerlog_log_s_log, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_fault_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, "Failed to create top-level client summary dictionary", buf, 2u);
    }
  }
  monotonic_time_ns = _mdns_powerlog_get_monotonic_time_ns();
  v20 = (char *)g_client_info_list;
  if (g_client_info_list)
  {
    v21 = monotonic_time_ns;
    v22 = &g_client_info_list;
    do
    {
      if (*((_DWORD *)v20 + 6))
      {
        v23 = *((_QWORD *)v20 + 1);
        v24 = v21 - *(_QWORD *)v20;
        v25 = __CFADD__(v23, v24);
        v26 = v23 + v24;
        if (v25)
          v26 = -1;
        *((_QWORD *)v20 + 1) = v26;
      }
      *(_QWORD *)v20 = v21;
      if (*((_DWORD *)v20 + 14))
      {
        v27 = *((_QWORD *)v20 + 5);
        v28 = v21 - *((_QWORD *)v20 + 4);
        v25 = __CFADD__(v27, v28);
        v29 = v27 + v28;
        if (v25)
          v29 = -1;
        *((_QWORD *)v20 + 5) = v29;
      }
      *((_QWORD *)v20 + 4) = v21;
      if (Mutable)
      {
        v30 = CFStringCreateWithCString(0, v20 + 72, 0x8000100u);
        if (v30)
        {
          v31 = v30;
          v32 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          if (v32)
          {
            v33 = v32;
            _mdns_powerlog_set_client_stats(v32, (uint64_t)v20, CFSTR("durationInfra"), CFSTR("startCountInfra"), CFSTR("stopCountInfra"), CFSTR("carryoverCountInfra"));
            _mdns_powerlog_set_client_stats(v33, (uint64_t)(v20 + 32), CFSTR("durationAWDL"), CFSTR("startCountAWDL"), CFSTR("stopCountAWDL"), CFSTR("carryoverCountAWDL"));
            CFDictionarySetValue(Mutable, v31, v33);
            if (_mdns_powerlog_log_s_once != -1)
              dispatch_once(&_mdns_powerlog_log_s_once, &__block_literal_global_1390);
            v34 = _mdns_powerlog_log_s_log;
            if (os_log_type_enabled((os_log_t)_mdns_powerlog_log_s_log, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 138412546;
              v43 = v31;
              v44 = 2112;
              v45 = v33;
              _os_log_debug_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEBUG, "Will submit client dictionary -- client name: %@, dictionary: %@", buf, 0x16u);
            }
            CFRelease(v31);
            v35 = v33;
          }
          else
          {
            if (_mdns_powerlog_log_s_once != -1)
              dispatch_once(&_mdns_powerlog_log_s_once, &__block_literal_global_1390);
            v37 = _mdns_powerlog_log_s_log;
            if (os_log_type_enabled((os_log_t)_mdns_powerlog_log_s_log, OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_fault_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_FAULT, "Failed to create powerlog client dictionary", buf, 2u);
            }
            v35 = (__CFDictionary *)v31;
          }
          CFRelease(v35);
        }
        else
        {
          if (_mdns_powerlog_log_s_once != -1)
            dispatch_once(&_mdns_powerlog_log_s_once, &__block_literal_global_1390);
          v36 = _mdns_powerlog_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_powerlog_log_s_log, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 136446210;
            v43 = (CFStringRef)(v20 + 72);
            _os_log_fault_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_FAULT, "Failed to create powerlog client name string: '%{public}s'", buf, 0xCu);
          }
        }
      }
      v38 = *((_DWORD *)v20 + 6);
      v39 = *((_DWORD *)v20 + 14);
      if (v38 | v39)
      {
        *((_QWORD *)v20 + 1) = 0;
        *((_QWORD *)v20 + 2) = 0;
        *((_DWORD *)v20 + 7) = v38;
        *((_QWORD *)v20 + 5) = 0;
        *((_QWORD *)v20 + 6) = 0;
        v22 = (uint64_t *)(v20 + 64);
        *((_DWORD *)v20 + 15) = v39;
      }
      else
      {
        *v22 = *((_QWORD *)v20 + 8);
        free(v20);
      }
      v20 = (char *)*v22;
    }
    while (*v22);
  }
  if (Mutable)
  {
    if (_mdns_powerlog_log_s_once != -1)
      dispatch_once(&_mdns_powerlog_log_s_once, &__block_literal_global_1390);
    v40 = _mdns_powerlog_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_powerlog_log_s_log, OS_LOG_TYPE_DEBUG))
    {
      Count = CFDictionaryGetCount(Mutable);
      *(_DWORD *)buf = 134218242;
      v43 = (CFStringRef)Count;
      v44 = 2112;
      v45 = Mutable;
      _os_log_debug_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEBUG, "Submitting client summary dictionary with %lld entries: %@", buf, 0x16u);
    }
    if (&_PLLogRegisteredEvent)
      PLLogRegisteredEvent(98, CFSTR("clientSummary"), Mutable, 0);
    CFRelease(Mutable);
  }
  KQueueUnlock((uint64_t)"dnssd_server: submitting client summary to powerlog", v13, v14, v15, v16, v17, v18, v19);
}

void __dnssd_server_init_block_invoke_2(id a1, void *a2)
{
  uint64_t v2;
  _DWORD *v4;
  uint64_t v5;
  unsigned int *v6;
  unsigned int v7;
  _xpc_connection_s *v8;
  _xpc_connection_s *v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned int v13;
  pid_t pid;
  NSObject *v15;
  _QWORD v16[2];
  _OWORD handler[2];
  uint64_t v18;

  if (xpc_get_type(a2) != (xpc_type_t)&_xpc_type_connection)
    return;
  v4 = malloc_type_calloc(1uLL, 0x68uLL, 0xF1748037uLL);
  if (v4)
  {
    v2 = (uint64_t)v4;
    *(_QWORD *)v4 = &_dx_session_kind;
    v4[2] = 1;
    _dx_recursive_init((uint64_t)v4, &_dx_session_kind);
    *(_QWORD *)(v2 + 32) = a2;
    xpc_retain(a2);
    memset(handler, 0, sizeof(handler));
    xpc_connection_get_audit_token(*(_QWORD *)(v2 + 32), handler);
    v5 = mdns_audit_token_create(handler);
    *(_QWORD *)(v2 + 64) = v5;
    if (v5)
    {
      v6 = (unsigned int *)(v2 + 8);
      *(_DWORD *)(v2 + 76) = xpc_connection_get_pid(*(xpc_connection_t *)(v2 + 32));
      *(_DWORD *)(v2 + 72) = xpc_connection_get_euid(*(xpc_connection_t *)(v2 + 32));
      mdns_system_pid_to_name(*(_DWORD *)(v2 + 76), v2 + 84);
      do
        v7 = __ldaxr(v6);
      while (__stlxr(v7 + 1, v6));
      v8 = *(_xpc_connection_s **)(v2 + 32);
      if (_dx_server_queue_once != -1)
        dispatch_once(&_dx_server_queue_once, &__block_literal_global_20);
      xpc_connection_set_target_queue(v8, (dispatch_queue_t)_dx_server_queue_queue);
      v9 = *(_xpc_connection_s **)(v2 + 32);
      *(_QWORD *)&handler[0] = _NSConcreteStackBlock;
      *((_QWORD *)&handler[0] + 1) = 0x40000000;
      *(_QWORD *)&handler[1] = ___dx_session_activate_block_invoke;
      *((_QWORD *)&handler[1] + 1) = &__block_descriptor_tmp_27_956;
      v18 = v2;
      xpc_connection_set_event_handler(v9, handler);
      xpc_connection_activate(*(xpc_connection_t *)(v2 + 32));
      _dx_session_reset_idle_timer(v2);
      v10 = &g_session_list;
      do
      {
        v11 = v10;
        v12 = *v10;
        v10 = (uint64_t *)(*v10 + 16);
      }
      while (v12);
      *(_QWORD *)(v2 + 16) = 0;
      *v11 = v2;
      do
        v13 = __ldaxr(v6);
      while (__stlxr(v13 + 1, v6));
      _dx_release((char *)v2);
      return;
    }
  }
  else
  {
    __break(1u);
  }
  _dx_release((char *)v2);
  pid = xpc_connection_get_pid((xpc_connection_t)a2);
  v16[0] = 0;
  v16[1] = 0;
  mdns_system_pid_to_name(pid, (uint64_t)v16);
  if (_mdns_server_log_s_once != -1)
    dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
  v15 = _mdns_server_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_FAULT))
  {
    LODWORD(handler[0]) = 67109378;
    DWORD1(handler[0]) = pid;
    WORD4(handler[0]) = 2082;
    *(_QWORD *)((char *)handler + 10) = v16;
    _os_log_fault_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_FAULT, "Failed to create session for connection -- client pid: %d (%{public}s)", (uint8_t *)handler, 0x12u);
  }
  xpc_connection_cancel((xpc_connection_t)a2);
}

uint64_t _dx_recursive_init(uint64_t result, _QWORD *a2)
{
  uint64_t v3;
  uint64_t (*v4)(uint64_t);

  v3 = result;
  if (*a2)
    result = _dx_recursive_init(result);
  v4 = (uint64_t (*)(uint64_t))a2[1];
  if (v4)
    return v4(v3);
  return result;
}

void ___dx_session_activate_block_invoke(uint64_t a1, xpc_object_t object)
{
  uint64_t v4;
  void *v5;
  uint64_t v6;
  int v7;
  const char *string;
  const char *v9;
  xpc_object_t value;
  void *uint64_limited;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  void (*v16)(uint64_t);
  uint64_t *v17;
  uint64_t *v18;
  uint64_t v19;
  BOOL v20;
  xpc_object_t v21;
  void *v22;
  int32x2_t v23;
  xpc_object_t dictionary;
  void *v25;
  int32x2_t *v26;
  int32x2_t *v27;
  unsigned int *v28;
  unsigned int *v29;
  unsigned int v30;
  const char *v31;
  char *v32;
  xpc_object_t v33;
  xpc_object_t v34;
  xpc_object_t v35;
  int v36;
  int32x2_t v37;
  __int128 *data;
  uint64_t v39;
  int32x2_t *v40;
  __int128 v41;
  pid_t int64_limited;
  unsigned __int8 *v43;
  int v44;
  int32x2_t v45;
  BOOL v46;
  pid_t v47;
  const char *v48;
  const char *v49;
  int32x2_t v50;
  __int16 v51;
  const uint8_t *uuid;
  uint64_t v53;
  unsigned __int8 *v54;
  xpc_object_t v55;
  xpc_object_t v56;
  void *v57;
  const uint8_t *v58;
  const uint8_t *v59;
  _OWORD *v60;
  const char *v61;
  _BOOL4 v62;
  __int8 v63;
  int v64;
  __int8 v65;
  unsigned __int8 v66;
  unsigned __int8 v68;
  uint64_t v69;
  const void *v70;
  uint64_t v71;
  _QWORD *v72;
  uint64_t v73;
  NSObject *v74;
  NSObject *v75;
  int32x2_t v76;
  int v77;
  uint64_t v78;
  __int32 v79;
  __int32 v80;
  __int32 v81;
  __int32 v82;
  int32x2_t v83;
  int v84;
  uint64_t v85;
  const char *v86;
  uint64_t v87;
  __int32 v88;
  __int32 v89;
  __int32 v90;
  __int32 v91;
  int32x2_t v92;
  int v93;
  uint64_t v94;
  __int32 v95;
  __int32 v96;
  __int32 v97;
  __int32 v98;
  int32x2_t v99;
  int v100;
  uint64_t v101;
  NSObject *v102;
  uint32_t v103;
  uint64_t v104;
  __int32 v105;
  __int32 v106;
  __int32 v107;
  __int32 v108;
  int32x2_t v109;
  int v110;
  uint64_t v111;
  __int32 v112;
  __int32 v113;
  __int32 v114;
  __int32 v115;
  int32x2_t v116;
  int v117;
  uint64_t v118;
  __int32 v119;
  __int32 v120;
  __int32 v121;
  __int32 v122;
  int32x2_t v123;
  int v124;
  uint64_t v125;
  uint64_t v126;
  unsigned __int8 *v127;
  __int128 v128;
  char *v129;
  int started;
  int32x2_t **v131;
  int32x2_t **v132;
  int32x2_t *v133;
  unsigned int v134;
  __int32 v135;
  int32x2_t v136;
  __int32 v137;
  __int32 v138;
  NSObject *v139;
  xpc_object_t reply;
  void *v141;
  uint64_t v142;
  __int32 v143;
  const char *v144;
  NSObject *v145;
  uint32_t v146;
  uint64_t v147;
  __int32 v148;
  uint64_t v149;
  unsigned __int8 *src;
  BOOL v151;
  size_t v152;
  BOOL v153;
  __int128 v154;
  __int128 v155;
  _BYTE length[36];
  __int16 v157;
  int32x2_t v158;
  __int16 v159;
  int v160;
  __int16 v161;
  uint64_t v162;
  __int16 v163;
  uint64_t v164;
  __int16 v165;
  _QWORD v166[3];
  _QWORD v167[2];

  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    v6 = *(_QWORD *)(a1 + 32);
    if (!*(_QWORD *)(v6 + 32))
      return;
    v7 = -65540;
    string = xpc_dictionary_get_string(object, "command");
    if (!string)
      goto LABEL_163;
    v9 = string;
    if (strcmp(string, "getaddrinfo"))
    {
      if (!strcmp(v9, "stop"))
      {
        length[0] = 0;
        value = xpc_dictionary_get_value(object, "id");
        uint64_limited = _mdns_xpc_object_get_uint64_limited(value, 0xFFFFFFFFFFFFFFFFLL, length);
        if (length[0])
        {
          v12 = (_QWORD *)(v6 + 24);
          v13 = *(_QWORD *)(v6 + 24);
          v7 = -65541;
          if (v13)
          {
            if (*(void **)(v13 + 40) == uint64_limited)
            {
LABEL_15:
              *v12 = *(_QWORD *)(v13 + 16);
              *(_QWORD *)(v13 + 16) = 0;
              v15 = (_QWORD *)v13;
              while (1)
              {
                v15 = (_QWORD *)*v15;
                if (!v15)
                  break;
                v16 = (void (*)(uint64_t))v15[2];
                if (v16)
                {
                  v16(v13);
                  break;
                }
              }
              _dx_release((char *)v13);
              v7 = 0;
            }
            else
            {
              while (1)
              {
                v14 = v13;
                v13 = *(_QWORD *)(v13 + 16);
                if (!v13)
                  break;
                if (*(void **)(v13 + 40) == uint64_limited)
                {
                  v12 = (_QWORD *)(v14 + 16);
                  goto LABEL_15;
                }
              }
            }
          }
        }
      }
      goto LABEL_163;
    }
    v151 = 0;
    v21 = xpc_dictionary_get_value(object, "id");
    v22 = _mdns_xpc_object_get_uint64_limited(v21, 0xFFFFFFFFFFFFFFFFLL, &v151);
    if (!v151)
      goto LABEL_154;
    v23 = (int32x2_t)v22;
    dictionary = xpc_dictionary_get_dictionary(object, "params");
    if (!dictionary)
      goto LABEL_154;
    v25 = dictionary;
    v26 = (int32x2_t *)malloc_type_calloc(1uLL, 0x100uLL, 0xF1748037uLL);
    if (v26)
    {
      v27 = v26;
      *v26 = (int32x2_t)&_dx_gai_request_kind;
      v28 = (unsigned int *)&v26[1];
      v26[1].i32[0] = 1;
      _dx_recursive_init((uint64_t)v26, &_dx_gai_request_kind);
      v27[5] = v23;
      v27[3] = (int32x2_t)v6;
      v29 = (unsigned int *)(v6 + 8);
      do
        v30 = __ldaxr(v29);
      while (__stlxr(v30 + 1, v29));
      v31 = xpc_dictionary_get_string(v25, "hostname");
      if (!v31)
        goto LABEL_152;
      v32 = strdup(v31);
      if (v32)
      {
        v27[13] = (int32x2_t)v32;
        v153 = 0;
        v33 = xpc_dictionary_get_value(v25, "flags");
        v27[27].i32[0] = _mdns_xpc_object_get_uint64_limited(v33, 0xFFFFFFFFuLL, &v153);
        if (v153)
        {
          v34 = xpc_dictionary_get_value(v25, "interface_index");
          v27[27].i32[1] = _mdns_xpc_object_get_uint64_limited(v34, 0xFFFFFFFFuLL, &v153);
          if (v153)
          {
            v35 = xpc_dictionary_get_value(v25, "protocols");
            v27[28].i32[0] = _mdns_xpc_object_get_uint64_limited(v35, 0xFFFFFFFFuLL, &v153);
            v36 = -65540;
            if (!v153)
              goto LABEL_161;
            v37 = v27[3];
            v154 = 0u;
            v155 = 0u;
            *(_QWORD *)length = 0;
            data = (__int128 *)xpc_dictionary_get_data(v25, "delegate_id", (size_t *)length);
            if (data && *(_QWORD *)length == 32)
            {
              v154 = *data;
              v155 = data[1];
              v39 = mdns_audit_token_create(&v154);
              v27[21] = (int32x2_t)v39;
              v40 = v27 + 21;
              if (!v39)
                goto LABEL_159;
            }
            else
            {
              v40 = v27 + 21;
              v39 = (uint64_t)v27[21];
              if (!v39)
              {
                uuid = xpc_dictionary_get_uuid(v25, "delegate_id");
                if (uuid)
                {
                  v43 = (unsigned __int8 *)uuid;
                  v46 = 0;
                  int64_limited = 0;
                  v44 = 1;
                  goto LABEL_55;
                }
                int64_limited = _mdns_xpc_dictionary_get_int64_limited(v25, "delegate_id", 0x8000000000000000, 0x7FFFFFFFFFFFFFFFLL, 0);
LABEL_45:
                v43 = 0;
                v44 = 0;
                v45 = *v40;
                v46 = int64_limited != 0;
                if (!*(_QWORD *)&v45 && !int64_limited)
                {
                  uuid_clear((unsigned __int8 *)&v27[29] + 2);
                  src = 0;
                  goto LABEL_48;
                }
LABEL_55:
                v53 = *(_QWORD *)(*(_QWORD *)&v37 + 32);
                v36 = -65555;
                if (!v53)
                  goto LABEL_161;
                src = v43;
                if (!mdns_xpc_connection_is_entitled(v53, (uint64_t)"com.apple.private.network.socket-delegate"))
                  goto LABEL_161;
                v54 = (unsigned __int8 *)&v27[29] + 2;
                if (v44)
                {
                  uuid_copy(v54, src);
                  v47 = 0;
                  goto LABEL_49;
                }
                uuid_clear(v54);
                v47 = int64_limited;
                if (v46)
                  goto LABEL_49;
LABEL_48:
                v47 = *(_DWORD *)(*(_QWORD *)&v37 + 76);
LABEL_49:
                v27[28].i32[1] = v47;
                v48 = xpc_dictionary_get_string(v25, "service_scheme");
                if (v48)
                {
                  v49 = v48;
                  if (!strcasecmp(v48, "_443._https"))
                  {
                    v50 = v27[13];
                    v51 = 65;
                  }
                  else
                  {
                    asprintf((char **)&v27[25], "%s.%s", v49, *(_QWORD *)&v27[13]);
                    v50 = v27[25];
                    if (!*(_QWORD *)&v50)
                    {
LABEL_159:
                      v36 = -65539;
                      goto LABEL_161;
                    }
                    v51 = 64;
                  }
                  v27[17] = v50;
                  v27[29].i16[0] = v51;
                }
                v55 = xpc_dictionary_get_value(v25, "fallback_config");
                v27[22] = (int32x2_t)v55;
                if (v55)
                  xpc_retain(v55);
                v56 = xpc_dictionary_get_value(v25, "resolver_uuids");
                if (!v56 || (v57 = v56, !xpc_array_get_count(v56)) || (v58 = xpc_array_get_uuid(v57, 0)) == 0)
                {
LABEL_68:
                  if (xpc_dictionary_get_BOOL(v25, "need_encryption"))
                    v27[31].i8[3] |= 2u;
                  v61 = xpc_dictionary_get_string(v25, "account_id");
                  if (v61 && !strcmp(v61, "com.apple.WebKit.InAppBrowser"))
                    v27[31].i8[3] |= 4u;
                  v62 = xpc_dictionary_get_BOOL(v25, "use_failover");
                  v63 = v27[31].i8[3];
                  if (v62)
                  {
                    v63 |= 8u;
                    v27[31].i8[3] = v63;
                  }
                  if ((v63 & 8) != 0)
                  {
                    v64 = v27[28].i32[0] & 3;
                    v65 = v27[31].i8[2];
                    if (v64 == 2 || (v65 |= 1u, v27[31].i8[2] = v65, v64 != 1))
                      v27[31].i8[2] = v65 | 2;
                  }
                  length[0] = 0;
                  v66 = _mdns_xpc_dictionary_get_int64_limited(v25, "log_privacy_level", -128, 127, length);
                  if (v66 >= 2u || length[0] == 0)
                    v68 = 0;
                  else
                    v68 = v66;
                  v27[31].i8[4] = v68;
                  if (xpc_dictionary_get_BOOL(v25, "prohibit_encrypted_dns"))
                  {
                    v69 = *(_QWORD *)(*(_QWORD *)&v37 + 32);
                    v36 = -65555;
                    if (!v69
                      || !mdns_xpc_connection_is_entitled(v69, (uint64_t)"com.apple.private.dnssd.prohibit-encrypted-dns"))
                    {
                      goto LABEL_161;
                    }
                    v27[31].i8[3] |= 0x10u;
                  }
                  v152 = 0;
                  v70 = xpc_dictionary_get_data(v25, "validation_data", &v152);
                  if (!v70)
                    goto LABEL_98;
                  LODWORD(v167[0]) = 0;
                  v71 = mdns_signed_resolve_result_create_from_data((uint64_t)v70, v152, (int *)v167);
                  v72 = (_QWORD *)v71;
                  if (v71)
                  {
                    if (!mdns_signed_resolve_result_contains(v71, *(char **)&v27[13], v27[27].u32[1]))
                    {
                      if (_mdns_server_log_s_once != -1)
                        dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
                      v75 = _mdns_server_log_s_log;
                      if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_ERROR))
                      {
                        v135 = v27[6].i32[0];
                        v136 = v27[13];
                        v137 = v27[27].i32[1];
                        *(_DWORD *)length = 67109891;
                        *(_DWORD *)&length[4] = v135;
                        *(_WORD *)&length[8] = 2160;
                        *(_QWORD *)&length[10] = 1752392040;
                        *(_WORD *)&length[18] = 2081;
                        *(int32x2_t *)&length[20] = v136;
                        *(_WORD *)&length[28] = 1024;
                        *(_DWORD *)&length[30] = v137;
                        _os_log_error_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_ERROR, "[R%u] Signed resolve result does not cover request -- hostname: %{private,mask.hash}s, ifindex: %u", length, 0x22u);
                      }
LABEL_103:
                      v76 = v27[3];
                      v77 = v27[31].u8[4];
                      if (src)
                      {
                        if (v77 == 1)
                        {
                          if (_mdns_server_log_s_once != -1)
                            dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
                          v78 = _mdns_server_log_s_log;
                          if (!os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT))
                            goto LABEL_139;
                          v79 = v27[6].i32[0];
                          v80 = v27[27].i32[0];
                          v81 = v27[27].i32[1];
                          v82 = v27[28].i32[0];
                          v83 = v27[13];
                          v84 = v27[31].u8[3];
                          v85 = *(int *)(*(_QWORD *)&v76 + 76);
                          *(_DWORD *)length = 67111683;
                          *(_DWORD *)&length[4] = v79;
                          *(_WORD *)&length[8] = 1024;
                          *(_DWORD *)&length[10] = v80;
                          *(_WORD *)&length[14] = 1024;
                          *(_DWORD *)&length[16] = v81;
                          *(_WORD *)&length[20] = 1024;
                          *(_DWORD *)&length[22] = v82;
                          *(_WORD *)&length[26] = 2160;
                          *(_QWORD *)&length[28] = 1752392040;
                          v157 = 2085;
                          v158 = v83;
                          v159 = 1024;
                          v160 = v84;
                          v161 = 2048;
                          v162 = v85;
                          v163 = 2082;
                          v164 = *(_QWORD *)&v76 + 84;
                          v165 = 1042;
                          LODWORD(v166[0]) = 16;
                          WORD2(v166[0]) = 2098;
                          *(_QWORD *)((char *)v166 + 6) = src;
                          v86 = "[R%u] getaddrinfo start -- flags: 0x%X, ifindex: %d, protocols: %u, hostname: %{sensitiv"
                                "e,mask.hash}s, options: %{mdns:gaiopts}X, client pid: %lld (%{public}s), delegator uuid:"
                                " %{public,uuid_t}.16P";
                        }
                        else
                        {
                          if (_mdns_server_log_s_once != -1)
                            dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
                          v78 = _mdns_server_log_s_log;
                          if (!os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT))
                            goto LABEL_139;
                          v95 = v27[6].i32[0];
                          v96 = v27[27].i32[0];
                          v97 = v27[27].i32[1];
                          v98 = v27[28].i32[0];
                          v99 = v27[13];
                          v100 = v27[31].u8[3];
                          v101 = *(int *)(*(_QWORD *)&v76 + 76);
                          *(_DWORD *)length = 67111683;
                          *(_DWORD *)&length[4] = v95;
                          *(_WORD *)&length[8] = 1024;
                          *(_DWORD *)&length[10] = v96;
                          *(_WORD *)&length[14] = 1024;
                          *(_DWORD *)&length[16] = v97;
                          *(_WORD *)&length[20] = 1024;
                          *(_DWORD *)&length[22] = v98;
                          *(_WORD *)&length[26] = 2160;
                          *(_QWORD *)&length[28] = 1752392040;
                          v157 = 2081;
                          v158 = v99;
                          v159 = 1024;
                          v160 = v100;
                          v161 = 2048;
                          v162 = v101;
                          v163 = 2082;
                          v164 = *(_QWORD *)&v76 + 84;
                          v165 = 1042;
                          LODWORD(v166[0]) = 16;
                          WORD2(v166[0]) = 2098;
                          *(_QWORD *)((char *)v166 + 6) = src;
                          v86 = "[R%u] getaddrinfo start -- flags: 0x%X, ifindex: %d, protocols: %u, hostname: %{private,"
                                "mask.hash}s, options: %{mdns:gaiopts}X, client pid: %lld (%{public}s), delegator uuid: %"
                                "{public,uuid_t}.16P";
                        }
                        v102 = v78;
                        v103 = 88;
                      }
                      else if (int64_limited)
                      {
                        v167[0] = 0;
                        v167[1] = 0;
                        mdns_system_pid_to_name(int64_limited, (uint64_t)v167);
                        if (v77 == 1)
                        {
                          if (_mdns_server_log_s_once != -1)
                            dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
                          v87 = _mdns_server_log_s_log;
                          if (!os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT))
                            goto LABEL_139;
                          v88 = v27[6].i32[0];
                          v89 = v27[27].i32[0];
                          v90 = v27[27].i32[1];
                          v91 = v27[28].i32[0];
                          v92 = v27[13];
                          v93 = v27[31].u8[3];
                          v94 = *(int *)(*(_QWORD *)&v76 + 76);
                          *(_DWORD *)length = 67111683;
                          *(_DWORD *)&length[4] = v88;
                          *(_WORD *)&length[8] = 1024;
                          *(_DWORD *)&length[10] = v89;
                          *(_WORD *)&length[14] = 1024;
                          *(_DWORD *)&length[16] = v90;
                          *(_WORD *)&length[20] = 1024;
                          *(_DWORD *)&length[22] = v91;
                          *(_WORD *)&length[26] = 2160;
                          *(_QWORD *)&length[28] = 1752392040;
                          v157 = 2085;
                          v158 = v92;
                          v159 = 1024;
                          v160 = v93;
                          v161 = 2048;
                          v162 = v94;
                          v163 = 2082;
                          v164 = *(_QWORD *)&v76 + 84;
                          v165 = 2048;
                          v166[0] = int64_limited;
                          LOWORD(v166[1]) = 2082;
                          *(_QWORD *)((char *)&v166[1] + 2) = v167;
                          v86 = "[R%u] getaddrinfo start -- flags: 0x%X, ifindex: %d, protocols: %u, hostname: %{sensitiv"
                                "e,mask.hash}s, options: %{mdns:gaiopts}X, client pid: %lld (%{public}s), delegator pid: "
                                "%lld (%{public}s)";
                        }
                        else
                        {
                          if (_mdns_server_log_s_once != -1)
                            dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
                          v87 = _mdns_server_log_s_log;
                          if (!os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT))
                            goto LABEL_139;
                          v112 = v27[6].i32[0];
                          v113 = v27[27].i32[0];
                          v114 = v27[27].i32[1];
                          v115 = v27[28].i32[0];
                          v116 = v27[13];
                          v117 = v27[31].u8[3];
                          v118 = *(int *)(*(_QWORD *)&v76 + 76);
                          *(_DWORD *)length = 67111683;
                          *(_DWORD *)&length[4] = v112;
                          *(_WORD *)&length[8] = 1024;
                          *(_DWORD *)&length[10] = v113;
                          *(_WORD *)&length[14] = 1024;
                          *(_DWORD *)&length[16] = v114;
                          *(_WORD *)&length[20] = 1024;
                          *(_DWORD *)&length[22] = v115;
                          *(_WORD *)&length[26] = 2160;
                          *(_QWORD *)&length[28] = 1752392040;
                          v157 = 2081;
                          v158 = v116;
                          v159 = 1024;
                          v160 = v117;
                          v161 = 2048;
                          v162 = v118;
                          v163 = 2082;
                          v164 = *(_QWORD *)&v76 + 84;
                          v165 = 2048;
                          v166[0] = int64_limited;
                          LOWORD(v166[1]) = 2082;
                          *(_QWORD *)((char *)&v166[1] + 2) = v167;
                          v86 = "[R%u] getaddrinfo start -- flags: 0x%X, ifindex: %d, protocols: %u, hostname: %{private,"
                                "mask.hash}s, options: %{mdns:gaiopts}X, client pid: %lld (%{public}s), delegator pid: %lld (%{public}s)";
                        }
                        v102 = v87;
                        v103 = 92;
                      }
                      else
                      {
                        if (v77 == 1)
                        {
                          if (_mdns_server_log_s_once != -1)
                            dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
                          v104 = _mdns_server_log_s_log;
                          if (!os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT))
                            goto LABEL_139;
                          v105 = v27[6].i32[0];
                          v106 = v27[27].i32[0];
                          v107 = v27[27].i32[1];
                          v108 = v27[28].i32[0];
                          v109 = v27[13];
                          v110 = v27[31].u8[3];
                          v111 = *(int *)(*(_QWORD *)&v76 + 76);
                          *(_DWORD *)length = 67111171;
                          *(_DWORD *)&length[4] = v105;
                          *(_WORD *)&length[8] = 1024;
                          *(_DWORD *)&length[10] = v106;
                          *(_WORD *)&length[14] = 1024;
                          *(_DWORD *)&length[16] = v107;
                          *(_WORD *)&length[20] = 1024;
                          *(_DWORD *)&length[22] = v108;
                          *(_WORD *)&length[26] = 2160;
                          *(_QWORD *)&length[28] = 1752392040;
                          v157 = 2085;
                          v158 = v109;
                          v159 = 1024;
                          v160 = v110;
                          v161 = 2048;
                          v162 = v111;
                          v163 = 2082;
                          v164 = *(_QWORD *)&v76 + 84;
                          v86 = "[R%u] getaddrinfo start -- flags: 0x%X, ifindex: %d, protocols: %u, hostname: %{sensitiv"
                                "e,mask.hash}s, options: %{mdns:gaiopts}X, client pid: %lld (%{public}s)";
                        }
                        else
                        {
                          if (_mdns_server_log_s_once != -1)
                            dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
                          v104 = _mdns_server_log_s_log;
                          if (!os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT))
                            goto LABEL_139;
                          v119 = v27[6].i32[0];
                          v120 = v27[27].i32[0];
                          v121 = v27[27].i32[1];
                          v122 = v27[28].i32[0];
                          v123 = v27[13];
                          v124 = v27[31].u8[3];
                          v125 = *(int *)(*(_QWORD *)&v76 + 76);
                          *(_DWORD *)length = 67111171;
                          *(_DWORD *)&length[4] = v119;
                          *(_WORD *)&length[8] = 1024;
                          *(_DWORD *)&length[10] = v120;
                          *(_WORD *)&length[14] = 1024;
                          *(_DWORD *)&length[16] = v121;
                          *(_WORD *)&length[20] = 1024;
                          *(_DWORD *)&length[22] = v122;
                          *(_WORD *)&length[26] = 2160;
                          *(_QWORD *)&length[28] = 1752392040;
                          v157 = 2081;
                          v158 = v123;
                          v159 = 1024;
                          v160 = v124;
                          v161 = 2048;
                          v162 = v125;
                          v163 = 2082;
                          v164 = *(_QWORD *)&v76 + 84;
                          v86 = "[R%u] getaddrinfo start -- flags: 0x%X, ifindex: %d, protocols: %u, hostname: %{private,"
                                "mask.hash}s, options: %{mdns:gaiopts}X, client pid: %lld (%{public}s)";
                        }
                        v102 = v104;
                        v103 = 72;
                      }
                      _os_log_impl((void *)&_mh_execute_header, v102, OS_LOG_TYPE_DEFAULT, v86, length, v103);
LABEL_139:
                      v36 = 0;
                      goto LABEL_140;
                    }
                    v73 = (*(uint64_t (**)(_QWORD *))(v72[2] + 56))(v72);
                    if ((mdns_system_is_signed_result_uuid_valid(v73) & 1) != 0)
                    {
                      if (_mdns_server_log_s_once != -1)
                        dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
                      v74 = _mdns_server_log_s_log;
                      if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEBUG))
                      {
                        v138 = v27[6].i32[0];
                        *(_DWORD *)length = 67109120;
                        *(_DWORD *)&length[4] = v138;
                        _os_log_debug_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEBUG, "[R%u] Allowing signed result", length, 8u);
                      }
                      v27[24] = (int32x2_t)v72;
LABEL_98:
                      v72 = 0;
                      goto LABEL_103;
                    }
                    if (_mdns_server_log_s_once != -1)
                      dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
                    v147 = _mdns_server_log_s_log;
                    v36 = -65570;
                    if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_ERROR))
                    {
                      v148 = v27[6].i32[0];
                      *(_DWORD *)length = 67109120;
                      *(_DWORD *)&length[4] = v148;
                      v144 = "[R%u] Signed result UUID revoked.";
                      v145 = v147;
                      v146 = 8;
                      goto LABEL_175;
                    }
                  }
                  else
                  {
                    if (_mdns_server_log_s_once != -1)
                      dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
                    v142 = _mdns_server_log_s_log;
                    v36 = -65549;
                    if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_ERROR))
                    {
                      v143 = v27[6].i32[0];
                      *(_DWORD *)length = 67109376;
                      *(_DWORD *)&length[4] = v143;
                      *(_WORD *)&length[8] = 2048;
                      *(_QWORD *)&length[10] = SLODWORD(v167[0]);
                      v144 = "[R%u] Failed to create signed resolve result from data: %{mdns:err}ld";
                      v145 = v142;
                      v146 = 18;
LABEL_175:
                      _os_log_error_impl((void *)&_mh_execute_header, v145, OS_LOG_TYPE_ERROR, v144, length, v146);
                    }
                  }
LABEL_140:
                  if (v72)
                    os_release(v72);
                  if (!v36)
                  {
                    if (!*(_QWORD *)&v27[24]
                      && _os_feature_enabled_impl("mDNSResponder", "bonjour_privacy"))
                    {
                      v126 = *(_QWORD *)(*(_QWORD *)&v27[3] + 64);
                      LODWORD(v167[0]) = 0;
                      v127 = (unsigned __int8 *)v27[13];
                      v128 = *(_OWORD *)(v126 + 40);
                      v154 = *(_OWORD *)(v126 + 24);
                      v155 = v128;
                      v129 = (char *)&loc_100082F6C
                           + *((int *)qword_100083478
                             + mdns_trust_checks_check(&v154, 2, v127, 0, 0, 0, (int *)v167));
                      __asm { BR              X10 }
                    }
                    started = _dx_gai_request_start_client_requests(v27, 1);
                    if (!started)
                    {
                      v131 = (int32x2_t **)(v6 + 24);
                      do
                      {
                        v132 = v131;
                        v133 = *v131;
                        v131 = (int32x2_t **)&(*v131)[2];
                      }
                      while (v133);
                      v27[2] = 0;
                      *v132 = v27;
                      do
                        v134 = __ldaxr(v28);
                      while (__stlxr(v134 + 1, v28));
                      v36 = 0;
                      goto LABEL_162;
                    }
                    v36 = started;
                  }
LABEL_161:
                  _dx_gai_request_log_error((uint64_t)v27, v36);
LABEL_162:
                  _dx_release((char *)v27);
                  v7 = v36;
LABEL_163:
                  _dx_session_reset_idle_timer(v6);
                  reply = xpc_dictionary_create_reply(object);
                  if (reply)
                  {
                    v141 = reply;
                    xpc_dictionary_set_int64(reply, "error", v7);
                    _dx_session_send_message(v6, v141);
                    xpc_release(v141);
                  }
                  else
                  {
                    _dx_session_terminate(v6, 4);
                  }
                  return;
                }
                v59 = v58;
                v60 = malloc_type_malloc(0x10uLL, 0xA172743EuLL);
                if (v60)
                {
                  *v60 = *(_OWORD *)v59;
                  v27[18] = (int32x2_t)v60;
                  goto LABEL_68;
                }
                goto LABEL_153;
              }
            }
            v41 = *(_OWORD *)(v39 + 40);
            *(_OWORD *)length = *(_OWORD *)(v39 + 24);
            *(_OWORD *)&length[16] = v41;
            int64_limited = audit_token_to_pid((audit_token_t *)length);
            goto LABEL_45;
          }
        }
LABEL_152:
        v36 = -65540;
        goto LABEL_161;
      }
    }
LABEL_153:
    __break(1u);
LABEL_154:
    if (_mdns_server_log_s_once != -1)
      dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
    v139 = _mdns_server_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_ERROR))
    {
      v149 = *(int *)(v6 + 76);
      *(_DWORD *)length = 134218498;
      *(_QWORD *)&length[4] = -65540;
      *(_WORD *)&length[12] = 2048;
      *(_QWORD *)&length[14] = v149;
      *(_WORD *)&length[22] = 2082;
      *(_QWORD *)&length[24] = v6 + 84;
      _os_log_error_impl((void *)&_mh_execute_header, v139, OS_LOG_TYPE_ERROR, "XPC session error -- error: %{mdns:err}ld, client pid: %lld (%{public}s)", length, 0x20u);
    }
    v7 = -65540;
    goto LABEL_163;
  }
  v4 = *(_QWORD *)(a1 + 32);
  if (object == &_xpc_error_connection_invalid)
  {
    v17 = &g_session_list;
    do
    {
      v18 = v17;
      v19 = *v17;
      v17 = (uint64_t *)(*v17 + 16);
      if (v19)
        v20 = v19 == v4;
      else
        v20 = 1;
    }
    while (!v20);
    if (v19)
    {
      *v18 = *(_QWORD *)(v4 + 16);
      *(_QWORD *)(v4 + 16) = 0;
      _dx_release((char *)v4);
      v4 = *(_QWORD *)(a1 + 32);
    }
    _dx_session_invalidate(v4);
    _dx_release(*(char **)(a1 + 32));
  }
  else
  {
    v5 = *(void **)(v4 + 32);
    if (v5)
    {
      xpc_connection_cancel(*(xpc_connection_t *)(v4 + 32));
      xpc_release(v5);
      *(_QWORD *)(*(_QWORD *)(a1 + 32) + 32) = 0;
    }
  }
}

void _dx_session_reset_idle_timer(uint64_t a1)
{
  NSObject *v2;
  unsigned int v3;
  NSObject *oneshot_timer;
  _QWORD handler[5];

  if (*(_QWORD *)(a1 + 48))
  {
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "!me->keepalive_reply_timer", "", "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssd_server.c", 1188, 0);
  }
  else
  {
    v2 = *(NSObject **)(a1 + 40);
    if (v2)
    {
      dispatch_source_cancel(*(dispatch_source_t *)(a1 + 40));
      dispatch_release(v2);
      *(_QWORD *)(a1 + 40) = 0;
    }
    if (*(_QWORD *)(a1 + 24))
      v3 = 60000;
    else
      v3 = 300000;
    oneshot_timer = _dx_create_oneshot_timer(v3);
    *(_QWORD *)(a1 + 40) = oneshot_timer;
    if (oneshot_timer)
    {
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 0x40000000;
      handler[2] = ___dx_session_reset_idle_timer_block_invoke;
      handler[3] = &__block_descriptor_tmp_56;
      handler[4] = a1;
      dispatch_source_set_event_handler(oneshot_timer, handler);
      dispatch_activate(*(dispatch_object_t *)(a1 + 40));
    }
    else
    {
      fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "me->idle_timer", "", "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssd_server.c", 1198, 0);
    }
  }
}

void _dx_release(char *a1)
{
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;
  _QWORD *v5;
  void (*v6)(char *);

  v2 = (unsigned int *)(a1 + 8);
  do
  {
    v3 = __ldaxr(v2);
    v4 = v3 - 1;
  }
  while (__stlxr(v4, v2));
  if (!v4)
  {
    v5 = *(_QWORD **)a1;
    if (*(_QWORD *)a1)
    {
      do
      {
        v6 = (void (*)(char *))v5[3];
        if (v6)
          v6(a1);
        v5 = (_QWORD *)*v5;
      }
      while (v5);
    }
    free(a1);
  }
}

NSObject *_dx_create_oneshot_timer(unsigned int a1)
{
  NSObject *v2;
  dispatch_time_t v3;

  if (_dx_server_queue_once != -1)
    dispatch_once(&_dx_server_queue_once, &__block_literal_global_20);
  v2 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, (dispatch_queue_t)_dx_server_queue_queue);
  if (v2)
  {
    v3 = dispatch_time(0, 1000000 * a1);
    dispatch_source_set_timer(v2, v3, 0xFFFFFFFFFFFFFFFFLL, 50000 * a1);
  }
  return v2;
}

void ___dx_session_reset_idle_timer_block_invoke(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  xpc_object_t empty;
  NSObject *oneshot_timer;
  unsigned int *v6;
  unsigned int v7;
  _xpc_connection_s *v8;
  void *v9;
  NSObject *v10;
  _QWORD v11[5];
  _QWORD handler[5];

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(NSObject **)(v1 + 40);
  if (v2)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(v1 + 40));
    dispatch_release(v2);
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 40) = 0;
    v1 = *(_QWORD *)(a1 + 32);
  }
  if (!*(_QWORD *)(v1 + 24))
  {
    _dx_session_terminate(v1, 1);
    return;
  }
  if (!*(_QWORD *)(v1 + 32) || *(_QWORD *)(v1 + 48))
  {
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "me->connection && !me->keepalive_reply_timer", "", "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssd_server.c", 1150, 0);
    return;
  }
  if (!_dx_session_send_keepalive_message_s_keepalive_msg)
  {
    empty = xpc_dictionary_create_empty();
    _dx_session_send_keepalive_message_s_keepalive_msg = (uint64_t)empty;
    if (!empty)
    {
      fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "s_keepalive_msg", "", "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssd_server.c", 1155, 0);
      return;
    }
    xpc_dictionary_set_string(empty, "command", "keepalive");
  }
  oneshot_timer = _dx_create_oneshot_timer(0x1388u);
  *(_QWORD *)(v1 + 48) = oneshot_timer;
  if (oneshot_timer)
  {
    v6 = (unsigned int *)(v1 + 8);
    do
      v7 = __ldaxr(v6);
    while (__stlxr(v7 + 1, v6));
    v8 = *(_xpc_connection_s **)(v1 + 32);
    v9 = (void *)_dx_session_send_keepalive_message_s_keepalive_msg;
    if (_dx_server_queue_once != -1)
      dispatch_once(&_dx_server_queue_once, &__block_literal_global_20);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 0x40000000;
    handler[2] = ___dx_session_send_keepalive_message_block_invoke;
    handler[3] = &__block_descriptor_tmp_61_967;
    handler[4] = v1;
    xpc_connection_send_message_with_reply(v8, v9, (dispatch_queue_t)_dx_server_queue_queue, handler);
    v10 = *(NSObject **)(v1 + 48);
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000;
    v11[2] = ___dx_session_send_keepalive_message_block_invoke_2;
    v11[3] = &__block_descriptor_tmp_62;
    v11[4] = v1;
    dispatch_source_set_event_handler(v10, v11);
    dispatch_activate(*(dispatch_object_t *)(v1 + 48));
  }
  else
  {
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "me->keepalive_reply_timer", "", "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssd_server.c", 1160, 0);
  }
}

void ___dx_session_send_keepalive_message_block_invoke(uint64_t a1, xpc_object_t object)
{
  uint64_t v3;
  xpc_type_t type;
  NSObject *v5;

  v3 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(v3 + 32))
  {
    type = xpc_get_type(object);
    v3 = *(_QWORD *)(a1 + 32);
    if (type == (xpc_type_t)&_xpc_type_dictionary)
    {
      v5 = *(NSObject **)(v3 + 48);
      if (v5)
      {
        dispatch_source_cancel(*(dispatch_source_t *)(v3 + 48));
        dispatch_release(v5);
        *(_QWORD *)(*(_QWORD *)(a1 + 32) + 48) = 0;
        v3 = *(_QWORD *)(a1 + 32);
      }
      _dx_session_reset_idle_timer(v3);
      v3 = *(_QWORD *)(a1 + 32);
    }
  }
  _dx_release((char *)v3);
}

void ___dx_session_send_keepalive_message_block_invoke_2(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(NSObject **)(v2 + 48);
  if (v3)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(v2 + 48));
    dispatch_release(v3);
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 48) = 0;
    v2 = *(_QWORD *)(a1 + 32);
  }
  _dx_session_terminate(v2, 3);
}

void _dx_session_terminate(uint64_t a1, int a2)
{
  NSObject *v4;
  int v5;
  uint64_t v6;
  void *v7;
  _DWORD v8[2];
  __int16 v9;
  int v10;
  __int16 v11;
  uint64_t v12;
  __int16 v13;
  uint64_t v14;

  if (!*(_BYTE *)(a1 + 100))
  {
    if (_mdns_server_log_s_once != -1)
      dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
    v4 = _mdns_server_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, (os_log_type_t)(a2 == 1)))
    {
      v5 = *(_DWORD *)(a1 + 80);
      v6 = *(int *)(a1 + 76);
      v8[0] = 67109890;
      v8[1] = a2;
      v9 = 1024;
      v10 = v5;
      v11 = 2048;
      v12 = v6;
      v13 = 2082;
      v14 = a1 + 84;
      _os_log_impl((void *)&_mh_execute_header, v4, (os_log_type_t)(a2 == 1), "Session terminated -- reason: %{mdns:termination_reason}d, pending send count: %u, client pid: %lld (%{public}s)", (uint8_t *)v8, 0x22u);
    }
    v7 = *(void **)(a1 + 32);
    if (v7)
    {
      xpc_connection_cancel(*(xpc_connection_t *)(a1 + 32));
      xpc_release(v7);
      *(_QWORD *)(a1 + 32) = 0;
    }
    *(_BYTE *)(a1 + 100) = 1;
  }
}

void ___dx_gai_request_trust_check_block_invoke(uint64_t a1, int a2, int a3)
{
  int32x2_t *v4;
  uint32_t started;
  int v6;

  v4 = *(int32x2_t **)(a1 + 32);
  if (!a2 && *(_QWORD *)&v4[23])
  {
    if (a3 == 1)
    {
      started = _dx_gai_request_start_client_requests(v4, 1);
      v4 = *(int32x2_t **)(a1 + 32);
      if (!started)
        goto LABEL_9;
    }
    else
    {
      started = -65570;
    }
    v6 = _dx_request_set_error((os_unfair_lock_s *)v4, started);
    v4 = *(int32x2_t **)(a1 + 32);
    if (v6)
    {
      _dx_gai_request_log_error((uint64_t)v4, started);
      _dx_request_send_pending_error(*(_QWORD *)(a1 + 32));
      v4 = *(int32x2_t **)(a1 + 32);
    }
  }
LABEL_9:
  if (v4[23])
  {
    os_release(*(void **)&v4[23]);
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 184) = 0;
    v4 = *(int32x2_t **)(a1 + 32);
  }
  _dx_release((char *)v4);
}

uint64_t _dx_gai_request_start_client_requests(int32x2_t *a1, int a2)
{
  int32x2_t v4;
  int32x2_t v5;
  int32x4_t v6;
  __int128 v7;
  char *v8;
  __int8 v9;
  __int8 v10;
  int32x2_t v11;
  int v12;
  BOOL v13;
  __int8 v14;
  char *v15;
  __int128 *v16;
  __int8 v17;
  int32x2_t v18;
  uint64_t v19;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  _QWORD v27[2];
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  _QWORD v33[8];
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  int v37;
  _QWORD v38[5];

  v4 = a1[3];
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v5 = a1[13];
  v6 = *(int32x4_t *)a1[27].i8;
  *(_QWORD *)&v7 = vrev64q_s32(v6).u64[0];
  *((int32x2_t *)&v7 + 1) = a1[28];
  v27[0] = 0;
  v28 = v7;
  v27[1] = v5;
  LODWORD(v27[0]) = a1[6].i32[0];
  v8 = (char *)&a1[29] + 2;
  *(_QWORD *)&v29 = (char *)a1 + 234;
  DWORD2(v29) = *(_DWORD *)(*(_QWORD *)&v4 + 72);
  v9 = a1[31].i8[3];
  LOBYTE(v31) = (v9 & 2) != 0;
  v10 = a1[31].i8[2];
  BYTE2(v31) = (v10 & 8) != 0;
  BYTE3(v31) = (v9 & 0x10) != 0;
  v11 = a1[21];
  *((_QWORD *)&v31 + 1) = *(_QWORD *)(*(_QWORD *)&v4 + 64);
  *(int32x2_t *)&v32 = v11;
  BYTE8(v32) = (v9 & 4) != 0;
  BYTE9(v32) = a1[31].i8[4];
  v12 = v6.i8[8] & 3;
  v13 = v12 == 3 || (v6.i8[8] & 3) == 0;
  if (v12 != 3 && (v6.i8[8] & 3) != 0)
    v14 = v10 & 0xEF;
  else
    v14 = v10 | 0x10;
  a1[31].i8[2] = v14;
  v15 = (char *)a1[26];
  if (v15)
  {
    _dx_release(v15);
    a1[26] = 0;
  }
  BYTE10(v32) = v13;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v16 = (__int128 *)a1[17];
  if (v16)
  {
    v21 = 0uLL;
    v22 = 0uLL;
    v25 = 0uLL;
    v26 = 0uLL;
    v23 = 0uLL;
    v24 = 0uLL;
    LODWORD(v21) = a1[6].i32[0];
    *((_QWORD *)&v21 + 1) = v16;
    *(int32x2_t *)&v22 = vrev64_s32(a1[27]);
    WORD4(v22) = a1[29].i16[0];
    WORD5(v22) = 1;
    HIDWORD(v22) = a1[28].i32[1];
    *(_QWORD *)&v23 = v8;
    DWORD2(v23) = *(_DWORD *)(*(_QWORD *)&v4 + 72);
    v17 = a1[31].i8[3];
    LOBYTE(v25) = (v17 & 2) != 0;
    BYTE2(v25) = (a1[31].i8[2] & 8) != 0;
    BYTE3(v25) = (v17 & 0x10) != 0;
    v18 = a1[21];
    *((_QWORD *)&v25 + 1) = *(_QWORD *)(*(_QWORD *)&v4 + 64);
    *(int32x2_t *)&v26 = v18;
    BYTE8(v26) = (v17 & 4) != 0;
    v16 = &v21;
    BYTE10(v26) = a1[31].i8[4];
  }
  v34 = 0;
  v35 = &v34;
  v36 = 0x2000000000;
  v37 = 0;
  v33[0] = _NSConcreteStackBlock;
  v33[1] = 0x40000000;
  v33[2] = ___dx_gai_request_start_client_requests_internal_block_invoke;
  v33[3] = &unk_10013B600;
  v33[6] = v27;
  v33[7] = v16;
  v33[4] = &v34;
  v33[5] = a1;
  _dx_kqueue_locked((uint64_t)"dx_gai_request: starting client requests", a2, (uint64_t)v33);
  if (*((_DWORD *)v35 + 6))
  {
    v38[0] = _NSConcreteStackBlock;
    v38[1] = 0x40000000;
    v38[2] = ___dx_gai_request_stop_client_requests_block_invoke;
    v38[3] = &__block_descriptor_tmp_31_995;
    v38[4] = a1;
    _dx_kqueue_locked((uint64_t)"dx_gai_request: stopping client requests", a2, (uint64_t)v38);
    v19 = *((unsigned int *)v35 + 6);
  }
  else
  {
    v19 = 0;
  }
  _Block_object_dispose(&v34, 8);
  return v19;
}

void _dx_gai_request_log_error(uint64_t a1, int a2)
{
  uint64_t v4;
  NSObject *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  _DWORD v9[2];
  __int16 v10;
  uint64_t v11;
  __int16 v12;
  uint64_t v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  uint64_t v19;

  v4 = *(_QWORD *)(a1 + 24);
  if (_mdns_server_log_s_once != -1)
    dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
  v5 = _mdns_server_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_ERROR))
  {
    v6 = *(_DWORD *)(a1 + 48);
    v7 = *(_QWORD *)(a1 + 104);
    v8 = *(int *)(v4 + 76);
    v9[0] = 67110403;
    v9[1] = v6;
    v10 = 2160;
    v11 = 1752392040;
    v12 = 2081;
    v13 = v7;
    v14 = 2048;
    v15 = a2;
    v16 = 2048;
    v17 = v8;
    v18 = 2082;
    v19 = v4 + 84;
    _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "[R%u] getaddrinfo error -- hostname: %{private,mask.hash}s, error: %{mdns:err}ld, client pid: %lld (%{public}s)", (uint8_t *)v9, 0x3Au);
  }
}

void _dx_session_send_message(uint64_t a1, void *a2)
{
  _xpc_connection_s *v3;
  int v4;
  NSObject *v5;
  int v6;
  uint64_t v7;
  unsigned int *v8;
  unsigned int v9;
  _xpc_connection_s *v10;
  _QWORD barrier[5];
  uint8_t buf[4];
  uint64_t v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  int v17;

  v3 = *(_xpc_connection_s **)(a1 + 32);
  if (v3)
  {
    xpc_connection_send_message(v3, a2);
    v4 = *(_DWORD *)(a1 + 80);
    *(_DWORD *)(a1 + 80) = v4 + 1;
    if (v4)
    {
      if (v4 == 1)
        *(_BYTE *)(a1 + 101) = 1;
      if (_mdns_server_log_s_once != -1)
        dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
      v5 = _mdns_server_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEBUG))
      {
        v6 = *(_DWORD *)(a1 + 80);
        v7 = *(int *)(a1 + 76);
        *(_DWORD *)buf = 134218498;
        v13 = v7;
        v14 = 2082;
        v15 = a1 + 84;
        v16 = 1024;
        v17 = v6;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "XPC session to client with pid %lld (%{public}s) pending send count increased to %d", buf, 0x1Cu);
      }
    }
    else
    {
      *(_QWORD *)(a1 + 56) = mach_absolute_time();
    }
    v8 = (unsigned int *)(a1 + 8);
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 + 1, v8));
    v10 = *(_xpc_connection_s **)(a1 + 32);
    barrier[0] = _NSConcreteStackBlock;
    barrier[1] = 0x40000000;
    barrier[2] = ___dx_session_send_message_block_invoke;
    barrier[3] = &__block_descriptor_tmp_53;
    barrier[4] = a1;
    xpc_connection_send_barrier(v10, barrier);
  }
  else
  {
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "me->connection", "", "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssd_server.c", 1089, 0);
  }
}

void _dx_session_invalidate(uint64_t a1)
{
  void *v2;
  NSObject *v3;
  NSObject *v4;
  _QWORD *v5;
  void (*v6)(_QWORD *);
  _QWORD *v7;

  v2 = *(void **)(a1 + 32);
  if (v2)
  {
    xpc_connection_cancel(*(xpc_connection_t *)(a1 + 32));
    xpc_release(v2);
    *(_QWORD *)(a1 + 32) = 0;
  }
  v3 = *(NSObject **)(a1 + 40);
  if (v3)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 40));
    dispatch_release(v3);
    *(_QWORD *)(a1 + 40) = 0;
  }
  v4 = *(NSObject **)(a1 + 48);
  if (v4)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 48));
    dispatch_release(v4);
    *(_QWORD *)(a1 + 48) = 0;
  }
  while (1)
  {
    v7 = *(_QWORD **)(a1 + 24);
    if (!v7)
      break;
    *(_QWORD *)(a1 + 24) = v7[2];
    v5 = v7;
    while (1)
    {
      v5 = (_QWORD *)*v5;
      if (!v5)
        break;
      v6 = (void (*)(_QWORD *))v5[2];
      if (v6)
      {
        v6(v7);
        break;
      }
    }
    _dx_release((char *)v7);
  }
}

void ___dx_session_send_message_block_invoke(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  __int16 v9;
  uint64_t v10;
  __int16 v11;
  int v12;

  v2 = *(_QWORD *)(a1 + 32);
  --*(_DWORD *)(v2 + 80);
  if (*(_BYTE *)(v2 + 101))
  {
    if (_mdns_server_log_s_once != -1)
      dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
    v3 = _mdns_server_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEBUG))
    {
      v5 = *(_DWORD *)(v2 + 80);
      v6 = *(int *)(v2 + 76);
      v7 = 134218498;
      v8 = v6;
      v9 = 2082;
      v10 = v2 + 84;
      v11 = 1024;
      v12 = v5;
      _os_log_debug_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "XPC session to client with pid %lld (%{public}s) pending send count decreased to %d", (uint8_t *)&v7, 0x1Cu);
    }
  }
  v4 = *(_QWORD *)(a1 + 32);
  if (!*(_DWORD *)(v4 + 80))
    *(_BYTE *)(v4 + 101) = 0;
  _dx_release((char *)v4);
}

void ___dx_gai_request_start_client_requests_internal_block_invoke(_QWORD *a1)
{
  _QWORD *v2;
  const unsigned __int8 *v3;
  int is_null;
  uint64_t v5;
  uint64_t DNSServiceManager;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  int RecordClientRequestStart;
  int *v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  int AddrInfoClientRequestStart;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  int v38;
  BOOL v39;
  __uint64_t monotonic_time_ns;

  v2 = (_QWORD *)a1[5];
  v3 = (const unsigned __int8 *)v2[18];
  if (v3)
  {
    is_null = uuid_is_null(v3);
    v2 = (_QWORD *)a1[5];
    if (!is_null)
    {
      Querier_RegisterPathResolver(v2[18]);
      v2 = (_QWORD *)a1[5];
    }
  }
  if (!v2[8])
  {
    v5 = v2[22];
    if (v5)
    {
      DNSServiceManager = Querier_GetDNSServiceManager();
      if (DNSServiceManager)
        DNSServiceManager = mdns_dns_service_manager_register_custom_service(DNSServiceManager, v5);
      v2 = (_QWORD *)a1[5];
      v2[8] = DNSServiceManager;
    }
  }
  v7 = a1[6];
  if (v7)
  {
    *(_QWORD *)(v7 + 48) = v2[18];
    v2 = (_QWORD *)a1[5];
    *(_QWORD *)(a1[6] + 56) = v2[8];
  }
  v8 = a1[7];
  if (v8)
  {
    *(_QWORD *)(v8 + 48) = v2[18];
    v9 = a1[5];
    v10 = a1[7];
    *(_QWORD *)(v10 + 56) = *(_QWORD *)(v9 + 64);
    if (!*(_QWORD *)(v9 + 88))
    {
      v11 = *(_QWORD *)(a1[4] + 8);
      v12 = malloc_type_calloc(1uLL, 0x320uLL, 0xF1748037uLL);
      if (!v12)
      {
LABEL_44:
        __break(1u);
LABEL_45:
        fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "err == 0", "", "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssd_server.c", 1780, v17);
        return;
      }
      v18 = v12;
      RecordClientRequestStart = QueryRecordClientRequestStart((uint64_t)v12, v10, (uint64_t)_dx_gai_request_query_result_handler, v9, v13, v14, v15, v16);
      if (RecordClientRequestStart)
      {
        free(v18);
        v18 = 0;
      }
      *(_DWORD *)(v11 + 24) = RecordClientRequestStart;
      *(_QWORD *)(a1[5] + 88) = v18;
      v17 = *(int *)(*(_QWORD *)(a1[4] + 8) + 24);
      if ((_DWORD)v17)
        goto LABEL_45;
    }
  }
  v20 = (int *)a1[6];
  if (!v20)
    return;
  v21 = a1[5];
  if (*(_QWORD *)(v21 + 80))
    return;
  v22 = *(_QWORD *)(a1[4] + 8);
  v23 = malloc_type_calloc(1uLL, 0x20uLL, 0xF1748037uLL);
  if (!v23)
    goto LABEL_44;
  v28 = v23;
  AddrInfoClientRequestStart = GetAddrInfoClientRequestStart((uint64_t)v23, v20, (uint64_t)_dx_gai_request_gai_result_handler, v21, v24, v25, v26, v27);
  if (AddrInfoClientRequestStart)
  {
    free(v28);
    v28 = 0;
  }
  *(_DWORD *)(v22 + 24) = AddrInfoClientRequestStart;
  *(_QWORD *)(a1[5] + 80) = v28;
  if (*(_DWORD *)(*(_QWORD *)(a1[4] + 8) + 24))
  {
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "err == 0", "", "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssd_server.c", 1785, *(int *)(*(_QWORD *)(a1[4] + 8) + 24));
  }
  else
  {
    v30 = a1[5];
    v31 = *(_QWORD *)(v30 + 80);
    if (v31 && *(_DWORD *)(v30 + 220) != -1)
    {
      v32 = *(_QWORD *)(v31 + 16);
      if (v32)
      {
        v33 = (char *)(v32 + 376);
      }
      else
      {
        v34 = *(_QWORD *)(v31 + 24);
        v33 = v34 ? (char *)(v34 + 376) : "";
      }
      if (IsLocalDomain(v33))
      {
        v35 = a1[5];
        v36 = (char *)(*(_QWORD *)(v35 + 24) + 84);
        v37 = *(unsigned int *)(v35 + 220);
        if ((_DWORD)v37)
        {
          if (AWDLInterfaceID && AWDLInterfaceID == v37)
          {
            v38 = 1;
          }
          else
          {
            if (WiFiAwareInterfaceID)
              v39 = WiFiAwareInterfaceID == v37;
            else
              v39 = 0;
            v38 = v39;
          }
        }
        else
        {
          v38 = (*(unsigned __int8 *)(v35 + 218) >> 4) & 1;
        }
        monotonic_time_ns = _mdns_powerlog_get_monotonic_time_ns();
        _mdns_powerlog_bonjour_event(4, v38, v36, monotonic_time_ns);
        *(_QWORD *)(a1[5] + 72) = monotonic_time_ns;
      }
    }
  }
}

void _dx_kqueue_locked(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  if (a2)
  {
    v5 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
    *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v5, v6, v7, v8, v9, v10, v11, v12);
    (*(void (**)(uint64_t))(a3 + 16))(a3);
    KQueueUnlock(a1, v13, v14, v15, v16, v17, v18, v19);
  }
  else
  {
    (*(void (**)(uint64_t))(a3 + 16))(a3);
  }
}

void ___dx_gai_request_stop_client_requests_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  BOOL v16;
  int v17;
  uint64_t v18;
  void *v19;
  int v20;

  v9 = *(_QWORD *)(a1 + 32);
  v10 = *(_QWORD *)(v9 + 80);
  if (v10)
  {
    GetAddrInfoClientRequestStop(v10, a2, a3, a4, a5, a6, a7, a8);
    v11 = *(void **)(v9 + 80);
    if (v11)
    {
      free(v11);
      *(_QWORD *)(v9 + 80) = 0;
    }
  }
  v12 = *(_QWORD *)(a1 + 32);
  v13 = *(_QWORD *)(v12 + 72);
  if (v13)
  {
    v14 = *(unsigned int *)(v12 + 220);
    if ((_DWORD)v14)
    {
      if (AWDLInterfaceID)
        v15 = AWDLInterfaceID == v14;
      else
        v15 = 0;
      if (v15)
      {
        v17 = 1;
      }
      else
      {
        if (WiFiAwareInterfaceID)
          v16 = WiFiAwareInterfaceID == v14;
        else
          v16 = 0;
        v17 = v16;
      }
    }
    else
    {
      v17 = (*(unsigned __int8 *)(v12 + 218) >> 4) & 1;
    }
    _mdns_powerlog_bonjour_event(6, v17, (char *)(*(_QWORD *)(v12 + 24) + 84), v13);
    v12 = *(_QWORD *)(a1 + 32);
    *(_QWORD *)(v12 + 72) = 0;
  }
  v18 = *(_QWORD *)(v12 + 88);
  if (v18)
  {
    QueryRecordClientRequestStop(v18, a2, a3, v13, a5, a6, a7, a8, v20);
    v19 = *(void **)(v12 + 88);
    if (v19)
    {
      free(v19);
      *(_QWORD *)(v12 + 88) = 0;
    }
  }
}

void _dx_gai_request_query_result_handler(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, uint32_t a6, os_unfair_lock_s *a7)
{
  _WORD *v13;
  unint64_t v14;
  void *v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t DNSServiceManager;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void **block;
  uint64_t p_block;
  uint64_t v29;
  void *v30;
  uint64_t v31;
  void *v32;
  _QWORD *v33;
  _QWORD v34[127];

  if (a6 && a6 != -65554)
  {
    _dx_request_set_error(a7, a6);
  }
  else if (*(unsigned __int16 *)(a3 + 4) - 66 >= 0xFFFFFFFE)
  {
    if (a6)
    {
      v13 = 0;
      LODWORD(v14) = 0;
    }
    else
    {
      v13 = (_WORD *)(*(_QWORD *)(a3 + 40) + 4);
      v14 = *(unsigned __int16 *)(a3 + 12);
      block = 0;
      p_block = (uint64_t)&block;
      v29 = 0x2000000000;
      v30 = 0;
      v34[0] = _NSConcreteStackBlock;
      v34[1] = 0x40000000;
      v34[2] = __dnssd_svcb_copy_doh_uri_block_invoke;
      v34[3] = &unk_10013E860;
      v34[4] = &block;
      _dnssd_svcb_extract_values(v13, v14, 0x8000, (uint64_t)v34);
      v15 = *(void **)(p_block + 24);
      _Block_object_dispose(&block, 8);
      if (v15)
      {
        bzero(v34, 0x3F1uLL);
        v16 = *(_QWORD *)(a3 + 56);
        if (v16 && dnssec_obj_resource_record_member_get_validation_result(v16) == 1)
        {
          v17 = v34;
          if (!ConvertDomainNameToCString_withescape(*(unsigned __int8 **)(a3 + 32), (unsigned __int8 *)v34))
            v17 = 0;
        }
        else
        {
          v17 = 0;
        }
        DNSServiceManager = Querier_GetDNSServiceManager();
        if (DNSServiceManager)
        {
          if (_mdns_dns_service_queue_s_once != -1)
          {
            v26 = DNSServiceManager;
            dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
            DNSServiceManager = v26;
          }
          block = _NSConcreteStackBlock;
          p_block = 0x40000000;
          v29 = (uint64_t)__mdns_dns_service_manager_register_doh_uri_block_invoke;
          v30 = &__block_descriptor_tmp_16;
          v31 = DNSServiceManager;
          v32 = v15;
          v33 = v17;
          dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, &block);
        }
        free(v15);
      }
    }
    if ((_dx_gai_request_check_for_failover_restart((uint64_t)a7, a3, a4 != 0, (_DWORD)v14 != 0) & 1) != 0)
      _dx_gai_request_restart_client_requests_in_failover_mode((uint64_t)a7, v19, v20, v21, v22, v23, v24, v25);
    else
      _dx_gai_request_enqueue_result((uint64_t)a7, a5, a3, a4 != 0, v13, v14, a6, a2);
  }
}

void _dx_gai_request_gai_result_handler(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, uint32_t a6, uint64_t a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  xpc_object_t *v18;
  _BYTE *v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  char v24;
  _DWORD *v25;
  unsigned int v26;
  unsigned __int8 *v27;
  char *v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD v37[7];
  unsigned __int8 v38[1009];

  if (a6 && a6 != -65554)
  {
    _dx_request_set_error((os_unfair_lock_s *)a7, a6);
    return;
  }
  if ((*(_BYTE *)(a7 + 250) & 3) != 0 && (*(_BYTE *)(a7 + 250) & 4) == 0)
  {
    v14 = *(_QWORD *)(a3 + 48);
    if (v14)
    {
      v15 = *(_QWORD *)(v14 + 24);
      if (v15)
      {
        v16 = *(_QWORD *)(v15 + 96);
        if (v16)
        {
          if (nw_resolver_config_get_allow_failover(v16))
            *(_BYTE *)(a7 + 250) |= 4u;
        }
      }
    }
  }
  if (!*(_BYTE *)(a2 + 353))
  {
    v17 = *(unsigned __int16 *)(a2 + 342);
    if (v17 == 28)
    {
      v18 = (xpc_object_t *)(a7 + 160);
      v19 = (_BYTE *)(a7 + 254);
    }
    else
    {
      if (v17 != 1)
        goto LABEL_22;
      v18 = (xpc_object_t *)(a7 + 152);
      v19 = (_BYTE *)(a7 + 253);
    }
    if (*v18)
    {
      xpc_release(*v18);
      *v18 = 0;
    }
    *v18 = xpc_array_create_empty();
    *v19 = 1;
  }
LABEL_22:
  v20 = *(unsigned __int16 *)(a3 + 4);
  if (v20 == 5)
  {
    if (a6)
      return;
    v21 = *(unsigned __int16 *)(a2 + 342);
    if (v21 == 28)
    {
      v22 = a7 + 160;
      v23 = a7 + 254;
    }
    else
    {
      if (v21 != 1)
        goto LABEL_39;
      v22 = a7 + 152;
      v23 = a7 + 253;
    }
    v27 = (unsigned __int8 *)(*(_QWORD *)(a3 + 40) + 4);
    bzero(v38, 0x3F1uLL);
    if (!ConvertDomainNameToCString_withescape(v27, v38))
      v38[0] = 0;
    v37[0] = _NSConcreteStackBlock;
    v37[1] = 0x40000000;
    v37[2] = ___dx_gai_request_append_cname_block_invoke;
    v37[3] = &__block_descriptor_tmp_51;
    v37[4] = v38;
    v37[5] = v22;
    v37[6] = v23;
    os_unfair_lock_lock((os_unfair_lock_t)(a7 + 56));
    ___dx_gai_request_append_cname_block_invoke((uint64_t)v37);
    os_unfair_lock_unlock((os_unfair_lock_t)(a7 + 56));
    if (v21 == 1 && !a4 && (*(_BYTE *)(a7 + 250) & 0x10) != 0)
    {
      v28 = *(char **)(a7 + 208);
      if (v28)
      {
        _dx_release(v28);
        *(_QWORD *)(a7 + 208) = 0;
      }
    }
LABEL_39:
    v29 = *(unsigned __int16 *)(a3 + 4);
    if (v29 != 1)
    {
      if (v29 != 28)
        return;
LABEL_44:
      v26 = 16;
      goto LABEL_45;
    }
LABEL_43:
    v26 = 4;
LABEL_45:
    v25 = (_DWORD *)(*(_QWORD *)(a3 + 40) + 4);
    v24 = 1;
LABEL_46:
    if ((_dx_gai_request_check_for_failover_restart(a7, a3, a4 != 0, v24) & 1) != 0)
      _dx_gai_request_restart_client_requests_in_failover_mode(a7, v30, v31, v32, v33, v34, v35, v36);
    else
      _dx_gai_request_enqueue_result(a7, a5, a3, a4 != 0, v25, v26, a6, a2);
    return;
  }
  if (v20 == 1 || v20 == 28)
  {
    if (a6)
    {
      v24 = 0;
      v25 = 0;
      v26 = 0;
      goto LABEL_46;
    }
    if (v20 != 1)
      goto LABEL_44;
    goto LABEL_43;
  }
}

void ___dx_gai_request_append_cname_block_invoke(uint64_t a1)
{
  const char *v1;
  xpc_object_t v3;

  v1 = *(const char **)(a1 + 32);
  if (v1)
  {
    v3 = **(xpc_object_t **)(a1 + 40);
    if (!v3)
    {
      v3 = xpc_array_create(0, 0);
      **(_QWORD **)(a1 + 40) = v3;
      if (!v3)
        return;
      v1 = *(const char **)(a1 + 32);
    }
    xpc_array_set_string(v3, 0xFFFFFFFFFFFFFFFFLL, v1);
    **(_BYTE **)(a1 + 48) = 1;
  }
}

uint64_t _dx_gai_request_check_for_failover_restart(uint64_t a1, uint64_t a2, char a3, char a4)
{
  os_unfair_lock_s *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD v9[8];
  char v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  char v18;

  v15 = 0;
  v16 = &v15;
  v17 = 0x2000000000;
  v18 = 0;
  v11 = 0;
  v12 = &v11;
  v13 = 0x2000000000;
  v14 = 0;
  if ((*(_BYTE *)(a1 + 250) & 3) != 0 && (a3 & 1) == 0)
  {
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 0x40000000;
    v9[2] = ___dx_gai_request_check_for_failover_restart_block_invoke;
    v9[3] = &unk_10013B628;
    v10 = a4;
    v9[6] = a2;
    v9[7] = a1;
    v9[4] = &v15;
    v9[5] = &v11;
    v4 = (os_unfair_lock_s *)(a1 + 56);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 56));
    ___dx_gai_request_check_for_failover_restart_block_invoke((uint64_t)v9);
    os_unfair_lock_unlock(v4);
    v5 = v12[3];
    if (v5)
    {
      v12[3] = 0;
      do
      {
        v6 = *(_QWORD *)(v5 + 16);
        _dx_release((char *)v5);
        v5 = v6;
      }
      while (v6);
    }
  }
  v7 = *((unsigned __int8 *)v16 + 24);
  _Block_object_dispose(&v11, 8);
  _Block_object_dispose(&v15, 8);
  return v7;
}

void _dx_gai_request_enqueue_result(uint64_t a1, int a2, uint64_t a3, unsigned int a4, _DWORD *a5, unsigned int a6, int a7, uint64_t a8)
{
  uint64_t v8;
  unsigned int *v9;
  unsigned int v12;
  _DWORD *v17;
  _BYTE *v18;
  uint64_t v19;
  int v20;
  _QWORD *v21;
  void *v22;
  int v23;
  uint64_t v24;
  int v25;
  int v26;
  void *v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  xpc_object_t v34;
  int v35;
  uint64_t v36;
  unsigned __int8 *v37;
  NSObject *v38;
  int v39;
  void *v40;
  void *v41;
  char v42;
  unsigned int v43;
  char *v44;
  uint64_t v45;
  _QWORD *v46;
  char *v47;
  int v48;
  int v49;
  __int16 v51;
  char *string;
  uint8_t buf[8];
  __int16 v54;
  int v55;
  __int16 v56;
  uint64_t v57;

  v12 = a6;
  if (a6 || (a4 & 1) == 0)
  {
    v17 = malloc_type_calloc(1uLL, 0x68uLL, 0xF1748037uLL);
    if (!v17)
    {
      __break(1u);
      goto LABEL_99;
    }
    v8 = (uint64_t)v17;
    *(_QWORD *)v17 = &_dx_gai_result_kind;
    v9 = v17 + 2;
    v17[2] = 1;
    _dx_recursive_init((uint64_t)v17, &_dx_gai_result_kind);
    v18 = *(_BYTE **)(a3 + 32);
    v19 = *(_QWORD *)(a1 + 112);
    if (v19)
    {
      v20 = SameDomainNameBytes(*(_BYTE **)(v19 + 24), *(_BYTE **)(a3 + 32));
      v21 = *(_QWORD **)(a1 + 112);
      if (v20)
      {
LABEL_9:
        if (!v21)
          goto LABEL_97;
        v22 = mdns_resource_record_create(v21, *(_WORD *)(a3 + 4), *(_WORD *)(a3 + 6), 0, a5, v12);
        *(_QWORD *)(v8 + 24) = v22;
        if (!v22)
          goto LABEL_97;
        if (a2)
        {
          if (*(_BYTE *)(a8 + 357))
            v23 = 2;
          else
            v23 = 1073741826;
          v24 = *(_QWORD *)(a3 + 48);
          if (!v12)
          {
            if (v24 && *(_QWORD *)(v24 + 24))
            {
              if (a2 == 4)
              {
                v25 = 3;
              }
              else
              {
                if (*(_BYTE *)(a3 + 1) == 3)
                  v26 = 2;
                else
                  v26 = 5;
                if (*(_BYTE *)(a3 + 1))
                  v25 = v26;
                else
                  v25 = 1;
              }
            }
            else if (*(_QWORD *)(a3 + 24))
            {
              v25 = 1;
            }
            else
            {
              v25 = 4;
            }
            *(_DWORD *)(v8 + 84) = v25;
          }
          v12 = a4;
          if (v24)
          {
            v27 = *(void **)(v24 + 32);
            *(_QWORD *)(v8 + 72) = v27;
            if (v27)
              os_retain(v27);
          }
          else
          {
            *(_QWORD *)(v8 + 72) = 0;
          }
        }
        else
        {
          v23 = 0;
          v12 = a4;
        }
        v28 = v23 | 0x80000000;
        if (!v12)
          v28 = v23;
        *(_DWORD *)(v8 + 80) = v28;
        *(_DWORD *)(v8 + 88) = a7;
        v29 = *(_QWORD *)(a3 + 24);
        v30 = v29 + 5;
        if ((unint64_t)(v29 + 5) < 6 && ((0x2Du >> v30) & 1) != 0)
          LODWORD(v29) = dword_100100820[v30];
        *(_DWORD *)(v8 + 92) = v29;
        v31 = *(_QWORD *)(a3 + 48);
        if (v31)
        {
          *(_DWORD *)(v8 + 96) = *(_DWORD *)(v31 + 48);
          *(_WORD *)(v8 + 100) = bswap32(*(unsigned __int16 *)(a8 + 340)) >> 16;
          v32 = *(_QWORD *)(v31 + 24);
          if (v32)
          {
            v33 = *(_QWORD *)(v32 + 136);
            if (!v33 || !*(_QWORD *)(v33 + 96))
              v33 = v32;
            v34 = *(xpc_object_t *)(v33 + 160);
            if (v34)
              v34 = xpc_retain(v34);
            *(_QWORD *)(v8 + 32) = v34;
          }
LABEL_47:
          *(_BYTE *)(v8 + 102) = *(_BYTE *)(v8 + 102) & 0xFD | (2 * (*(_BYTE *)(a1 + 252) == 1));
          v35 = *(unsigned __int16 *)(*(_QWORD *)(v8 + 24) + 52);
          if (a2)
          {
            if (!a7)
            {
              v36 = *(_QWORD *)(a1 + 192);
              if (v36)
              {
                if (v35 == 28 || v35 == 1)
                {
                  LODWORD(string) = 0;
                  v37 = v35 == 1
                      ? mdns_signed_hostname_result_create_ipv4(v36, a5, (int *)&string)
                      : mdns_signed_hostname_result_create_ipv6(v36, a5, *(_DWORD *)(v8 + 92), (int *)&string);
                  *(_QWORD *)(v8 + 64) = v37;
                  if (!v37)
                  {
                    if (_mdns_server_log_s_once != -1)
                      dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
                    v38 = _mdns_server_log_s_log;
                    if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_ERROR))
                    {
                      v48 = *(_DWORD *)(a1 + 48);
                      if (v35 == 1)
                        v49 = 4;
                      else
                        v49 = 6;
                      *(_DWORD *)buf = 67109632;
                      *(_DWORD *)&buf[4] = v48;
                      v54 = 1024;
                      v55 = v49;
                      v56 = 2048;
                      v57 = (int)string;
                      _os_log_error_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "[R%u] Failed to create IPv%d signed hostname result: %{mdns:err}ld", buf, 0x18u);
                    }
                  }
                }
              }
            }
          }
          if (&_NEHelperTrackerGetAppInfo)
          {
            v39 = 1;
            if (!a2)
              goto LABEL_74;
          }
          else
          {
            v39 = _os_feature_enabled_impl("symptomsd", "networking_transparency");
            if (!a2)
              goto LABEL_74;
          }
          if (!v39
            || (string = 0,
                *(_QWORD *)buf = 0,
                v51 = 0,
                resolved_cache_get_tracker_state(a8, buf, &string, (BOOL *)&v51 + 1, &v51) != 2)
            || !*(_QWORD *)buf)
          {
LABEL_74:
            v42 = *(_BYTE *)(a1 + 250);
            if ((v42 & 0x10) == 0 || (v12 & 1) != 0)
              goto LABEL_90;
            if (v35 == 28)
            {
              v46 = (_QWORD *)(a1 + 208);
              v45 = *(_QWORD *)(a1 + 208);
              if (!v45)
                goto LABEL_88;
              _dx_gai_request_append_result((os_unfair_lock_s *)a1, v45);
              v47 = *(char **)(a1 + 208);
              if (!v47)
                goto LABEL_88;
            }
            else
            {
              if (v35 != 1)
              {
LABEL_90:
                _dx_gai_request_append_result((os_unfair_lock_s *)a1, v8);
LABEL_91:
                _dx_release((char *)v8);
                return;
              }
              if (*(_DWORD *)(v8 + 84) == 3)
              {
                do
                  v43 = __ldaxr(v9);
                while (__stlxr(v43 + 1, v9));
                v44 = *(char **)(a1 + 208);
                if (v44)
                  _dx_release(v44);
                *(_QWORD *)(a1 + 208) = v8;
                goto LABEL_91;
              }
              v46 = (_QWORD *)(a1 + 208);
              v47 = *(char **)(a1 + 208);
              if (!v47)
              {
LABEL_89:
                *(_BYTE *)(a1 + 250) = v42 & 0xEF;
                goto LABEL_90;
              }
            }
            _dx_release(v47);
            *v46 = 0;
LABEL_88:
            v42 = *(_BYTE *)(a1 + 250);
            goto LABEL_89;
          }
          mdns_xpc_string_recreate((xpc_object_t *)(a1 + 120), *(char **)buf);
          v40 = *(void **)(a1 + 120);
          if (v40)
          {
            *(_QWORD *)(v8 + 48) = v40;
            xpc_retain(v40);
            if (!string)
            {
LABEL_70:
              if (HIBYTE(v51))
                *(_BYTE *)(v8 + 102) |= 1u;
              if ((_BYTE)v51)
                *(_BYTE *)(v8 + 102) |= 4u;
              goto LABEL_74;
            }
            mdns_xpc_string_recreate((xpc_object_t *)(a1 + 128), string);
            v41 = *(void **)(a1 + 128);
            if (v41)
            {
              *(_QWORD *)(v8 + 56) = v41;
              xpc_retain(v41);
              goto LABEL_70;
            }
          }
LABEL_97:
          _dx_release((char *)v8);
          _dx_request_set_error((os_unfair_lock_s *)a1, 0xFFFEFFFD);
          return;
        }
LABEL_99:
        *(_DWORD *)(v8 + 96) = 0;
        *(_WORD *)(v8 + 100) = bswap32(*(unsigned __int16 *)(a8 + 340)) >> 16;
        goto LABEL_47;
      }
      if (v21)
      {
        os_release(v21);
        *(_QWORD *)(a1 + 112) = 0;
      }
    }
    v21 = mdns_domain_name_create_with_labels(v18, 0);
    *(_QWORD *)(a1 + 112) = v21;
    goto LABEL_9;
  }
}

uint64_t _dx_request_set_error(os_unfair_lock_s *a1, uint32_t a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  char v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2000000000;
  v10 = 0;
  v4 = a1 + 14;
  os_unfair_lock_lock(a1 + 14);
  if (!a1[13]._os_unfair_lock_opaque)
  {
    a1[13]._os_unfair_lock_opaque = a2;
    *((_BYTE *)v8 + 24) = 1;
  }
  os_unfair_lock_unlock(v4);
  v5 = *((unsigned __int8 *)v8 + 24);
  _Block_object_dispose(&v7, 8);
  return v5;
}

uint64_t _dx_gai_request_restart_client_requests_in_failover_mode(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  NSObject *v9;
  int v10;
  _QWORD v11[5];

  if ((*(_BYTE *)(result + 250) & 8) == 0)
  {
    v8 = result;
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000;
    v11[2] = ___dx_gai_request_stop_client_requests_block_invoke;
    v11[3] = &__block_descriptor_tmp_31_995;
    v11[4] = result;
    ___dx_gai_request_stop_client_requests_block_invoke((uint64_t)v11, a2, a3, a4, a5, a6, a7, a8);
    if (_mdns_server_log_s_once != -1)
      dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
    v9 = _mdns_server_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      v10 = *(_DWORD *)(v8 + 48);
      LODWORD(v11[0]) = 67109120;
      HIDWORD(v11[0]) = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "[R%u] getaddrinfo failover restart", (uint8_t *)v11, 8u);
    }
    *(_BYTE *)(v8 + 250) |= 8u;
    return _dx_gai_request_start_client_requests(v8, 0);
  }
  return result;
}

void _dx_gai_request_append_result(os_unfair_lock_s *a1, uint64_t a2)
{
  int v4;
  uint64_t v5;
  xpc_object_t *v6;
  _BYTE *v7;
  xpc_object_t v8;
  os_unfair_lock_s *v9;
  os_unfair_lock_s *v10;
  uint64_t v11;
  unsigned int *v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;

  v4 = *(unsigned __int16 *)(*(_QWORD *)(a2 + 24) + 52);
  v14 = 0;
  v15 = &v14;
  v16 = 0x2000000000;
  v17 = 0;
  if (v4 == 28)
  {
    v6 = (xpc_object_t *)&a1[40];
    v7 = (char *)&a1[63]._os_unfair_lock_opaque + 2;
  }
  else
  {
    v5 = 0;
    if (v4 != 1)
      goto LABEL_10;
    v6 = (xpc_object_t *)&a1[38];
    v7 = (char *)&a1[63]._os_unfair_lock_opaque + 1;
  }
  os_unfair_lock_lock(a1 + 14);
  if (*v7)
  {
    if (*v6)
    {
      v8 = xpc_copy(*v6);
      v15[3] = (uint64_t)v8;
    }
    *v7 = 0;
  }
  os_unfair_lock_unlock(a1 + 14);
  v5 = v15[3];
LABEL_10:
  _Block_object_dispose(&v14, 8);
  *(_QWORD *)(a2 + 40) = v5;
  os_unfair_lock_lock(a1 + 14);
  v9 = a1 + 24;
  do
  {
    v10 = v9;
    v11 = *(_QWORD *)&v9->_os_unfair_lock_opaque;
    v9 = (os_unfair_lock_s *)(*(_QWORD *)&v9->_os_unfair_lock_opaque + 16);
  }
  while (v11);
  *(_QWORD *)&v10->_os_unfair_lock_opaque = a2;
  v12 = (unsigned int *)(a2 + 8);
  do
    v13 = __ldaxr(v12);
  while (__stlxr(v13 + 1, v12));
  os_unfair_lock_unlock(a1 + 14);
}

void _dx_gai_result_finalize(_QWORD *a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;

  v2 = (void *)a1[3];
  if (v2)
  {
    os_release(v2);
    a1[3] = 0;
  }
  v3 = (void *)a1[4];
  if (v3)
  {
    xpc_release(v3);
    a1[4] = 0;
  }
  v4 = (void *)a1[5];
  if (v4)
  {
    xpc_release(v4);
    a1[5] = 0;
  }
  v5 = (void *)a1[6];
  if (v5)
  {
    xpc_release(v5);
    a1[6] = 0;
  }
  v6 = (void *)a1[7];
  if (v6)
  {
    xpc_release(v6);
    a1[7] = 0;
  }
  v7 = (void *)a1[8];
  if (v7)
  {
    os_release(v7);
    a1[8] = 0;
  }
  v8 = (void *)a1[9];
  if (v8)
  {
    os_release(v8);
    a1[9] = 0;
  }
}

uint64_t ___dx_gai_request_check_for_failover_restart_block_invoke(uint64_t result)
{
  int v1;
  BOOL v2;
  uint64_t v3;
  char v4;

  v1 = *(unsigned __int16 *)(*(_QWORD *)(result + 48) + 4);
  if (*(_BYTE *)(result + 64))
  {
    if (v1 == 1 || (v1 != 65 ? (v2 = v1 == 28) : (v2 = 1), v2))
      *(_BYTE *)(*(_QWORD *)(result + 56) + 250) &= 0xFCu;
    return result;
  }
  if (v1 == 1)
  {
    v3 = *(_QWORD *)(result + 56);
    v4 = *(_BYTE *)(v3 + 250) & 0xFE;
    goto LABEL_13;
  }
  if (v1 == 28)
  {
    v3 = *(_QWORD *)(result + 56);
    v4 = *(_BYTE *)(v3 + 250) & 0xFD;
LABEL_13:
    *(_BYTE *)(v3 + 250) = v4;
    goto LABEL_15;
  }
  v3 = *(_QWORD *)(result + 56);
  v4 = *(_BYTE *)(v3 + 250);
LABEL_15:
  if ((v4 & 7) == 4)
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = 1;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 40) + 8) + 24) = *(_QWORD *)(v3 + 96);
    *(_QWORD *)(*(_QWORD *)(result + 56) + 96) = 0;
  }
  return result;
}

uint64_t _dx_request_send_pending_error(uint64_t a1)
{
  os_unfair_lock_s *v2;
  int64_t v3;
  uint64_t result;
  void *v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  int v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = 0;
  v2 = (os_unfair_lock_s *)(a1 + 56);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 56));
  *((_DWORD *)v7 + 6) = *(_DWORD *)(a1 + 52);
  os_unfair_lock_unlock(v2);
  v3 = *((int *)v7 + 6);
  _Block_object_dispose(&v6, 8);
  if (!(_DWORD)v3 || *(_BYTE *)(a1 + 60))
    return 1;
  result = (uint64_t)xpc_dictionary_create(0, 0, 0);
  if (result)
  {
    v5 = (void *)result;
    xpc_dictionary_set_uint64((xpc_object_t)result, "id", *(_QWORD *)(a1 + 40));
    xpc_dictionary_set_int64(v5, "error", v3);
    _dx_session_send_message(*(_QWORD *)(a1 + 24), v5);
    xpc_release(v5);
    result = 1;
    *(_BYTE *)(a1 + 60) = 1;
  }
  return result;
}

void _dx_gai_request_invalidate(uint64_t a1)
{
  uint64_t v2;
  int v3;
  NSObject *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  void *v42;
  void *v43;
  void *v44;
  void *v45;
  void **v46;
  uint64_t v47;
  _BYTE v48[24];
  uint64_t v49;

  v2 = *(_QWORD *)(a1 + 24);
  v3 = *(unsigned __int8 *)(a1 + 252);
  if (*(_BYTE *)(v2 + 100))
  {
    if (v3 == 1)
    {
      if (_mdns_server_log_s_once != -1)
        dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
      v4 = _mdns_server_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT))
      {
        v5 = *(_DWORD *)(a1 + 48);
        v6 = *(_QWORD *)(a1 + 104);
        v7 = *(int *)(v2 + 76);
        LODWORD(v46) = 67110147;
        HIDWORD(v46) = v5;
        strcpy((char *)&v47, "p\bhash");
        HIBYTE(v47) = 0;
        *(_WORD *)v48 = 0;
        *(_WORD *)&v48[2] = 2085;
        *(_QWORD *)&v48[4] = v6;
        *(_WORD *)&v48[12] = 2048;
        *(_QWORD *)&v48[14] = v7;
        *(_WORD *)&v48[22] = 2082;
        v49 = v2 + 84;
        v8 = "[R%u] getaddrinfo stop (forced) -- hostname: %{sensitive,mask.hash}s, client pid: %lld (%{public}s)";
LABEL_20:
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&v46, 0x30u);
      }
    }
    else
    {
      if (_mdns_server_log_s_once != -1)
        dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
      v4 = _mdns_server_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT))
      {
        v12 = *(_DWORD *)(a1 + 48);
        v13 = *(_QWORD *)(a1 + 104);
        v14 = *(int *)(v2 + 76);
        LODWORD(v46) = 67110147;
        HIDWORD(v46) = v12;
        strcpy((char *)&v47, "p\bhash");
        HIBYTE(v47) = 0;
        *(_WORD *)v48 = 0;
        *(_WORD *)&v48[2] = 2081;
        *(_QWORD *)&v48[4] = v13;
        *(_WORD *)&v48[12] = 2048;
        *(_QWORD *)&v48[14] = v14;
        *(_WORD *)&v48[22] = 2082;
        v49 = v2 + 84;
        v8 = "[R%u] getaddrinfo stop (forced) -- hostname: %{private,mask.hash}s, client pid: %lld (%{public}s)";
        goto LABEL_20;
      }
    }
  }
  else if (v3 == 1)
  {
    if (_mdns_server_log_s_once != -1)
      dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
    v4 = _mdns_server_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      v9 = *(_DWORD *)(a1 + 48);
      v10 = *(_QWORD *)(a1 + 104);
      v11 = *(int *)(v2 + 76);
      LODWORD(v46) = 67110147;
      HIDWORD(v46) = v9;
      strcpy((char *)&v47, "p\bhash");
      HIBYTE(v47) = 0;
      *(_WORD *)v48 = 0;
      *(_WORD *)&v48[2] = 2085;
      *(_QWORD *)&v48[4] = v10;
      *(_WORD *)&v48[12] = 2048;
      *(_QWORD *)&v48[14] = v11;
      *(_WORD *)&v48[22] = 2082;
      v49 = v2 + 84;
      v8 = "[R%u] getaddrinfo stop -- hostname: %{sensitive,mask.hash}s, client pid: %lld (%{public}s)";
      goto LABEL_20;
    }
  }
  else
  {
    if (_mdns_server_log_s_once != -1)
      dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
    v4 = _mdns_server_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      v15 = *(_DWORD *)(a1 + 48);
      v16 = *(_QWORD *)(a1 + 104);
      v17 = *(int *)(v2 + 76);
      LODWORD(v46) = 67110147;
      HIDWORD(v46) = v15;
      strcpy((char *)&v47, "p\bhash");
      HIBYTE(v47) = 0;
      *(_WORD *)v48 = 0;
      *(_WORD *)&v48[2] = 2081;
      *(_QWORD *)&v48[4] = v16;
      *(_WORD *)&v48[12] = 2048;
      *(_QWORD *)&v48[14] = v17;
      *(_WORD *)&v48[22] = 2082;
      v49 = v2 + 84;
      v8 = "[R%u] getaddrinfo stop -- hostname: %{private,mask.hash}s, client pid: %lld (%{public}s)";
      goto LABEL_20;
    }
  }
  v46 = _NSConcreteStackBlock;
  v47 = 0x40000000;
  *(_QWORD *)v48 = ___dx_gai_request_stop_client_requests_block_invoke;
  *(_QWORD *)&v48[8] = &__block_descriptor_tmp_31_995;
  *(_QWORD *)&v48[16] = a1;
  v18 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v18, v19, v20, v21, v22, v23, v24, v25);
  ___dx_gai_request_stop_client_requests_block_invoke((uint64_t)&v46, v26, v27, v28, v29, v30, v31, v32);
  KQueueUnlock((uint64_t)"dx_gai_request: stopping client requests", v33, v34, v35, v36, v37, v38, v39);
  v40 = *(_QWORD *)(a1 + 64);
  if (v40)
  {
    Querier_DeregisterCustomDNSService(v40);
    *(_QWORD *)(a1 + 64) = 0;
  }
  v41 = *(_QWORD *)(a1 + 184);
  if (v41)
  {
    mdns_trust_invalidate(v41);
    os_release(*(void **)(a1 + 184));
    *(_QWORD *)(a1 + 184) = 0;
  }
  v42 = *(void **)(a1 + 192);
  if (v42)
  {
    os_release(v42);
    *(_QWORD *)(a1 + 192) = 0;
  }
  v43 = *(void **)(a1 + 112);
  if (v43)
  {
    os_release(v43);
    *(_QWORD *)(a1 + 112) = 0;
  }
  v44 = *(void **)(a1 + 120);
  if (v44)
  {
    xpc_release(v44);
    *(_QWORD *)(a1 + 120) = 0;
  }
  v45 = *(void **)(a1 + 128);
  if (v45)
  {
    xpc_release(v45);
    *(_QWORD *)(a1 + 128) = 0;
  }
}

void _dx_gai_request_finalize(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  char *v11;

  v2 = a1[12];
  if (v2)
  {
    a1[12] = 0;
    do
    {
      v3 = *(_QWORD *)(v2 + 16);
      _dx_release((char *)v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = (void *)a1[13];
  if (v4)
  {
    free(v4);
    a1[13] = 0;
  }
  v5 = (void *)a1[25];
  if (v5)
  {
    free(v5);
    a1[25] = 0;
  }
  v6 = (void *)a1[19];
  if (v6)
  {
    xpc_release(v6);
    a1[19] = 0;
  }
  v7 = (void *)a1[20];
  if (v7)
  {
    xpc_release(v7);
    a1[20] = 0;
  }
  v8 = (void *)a1[21];
  if (v8)
  {
    os_release(v8);
    a1[21] = 0;
  }
  v9 = (void *)a1[22];
  if (v9)
  {
    xpc_release(v9);
    a1[22] = 0;
  }
  v10 = (void *)a1[18];
  if (v10)
  {
    free(v10);
    a1[18] = 0;
  }
  v11 = (char *)a1[26];
  if (v11)
  {
    _dx_release(v11);
    a1[26] = 0;
  }
}

xpc_object_t _dx_gai_request_take_results(os_unfair_lock_s *a1)
{
  os_unfair_lock_s *v1;
  os_unfair_lock_s *v2;
  uint64_t *v3;
  uint64_t v4;
  xpc_object_t v5;
  xpc_object_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  size_t v10;
  BOOL v11;
  const char *v12;
  int64_t v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  uint64_t v18;
  const char *data;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  xpc_object_t empty;
  void *v24;
  uint32_t os_unfair_lock_opaque;
  unsigned int v26;
  unsigned int v27;
  uint64_t v28;
  _QWORD *v29;
  int v30;
  char v31;
  BOOL v32;
  _BOOL4 v33;
  uint64_t v34;
  void *v35;
  NSObject *v36;
  int v37;
  int v38;
  int v39;
  _QWORD *v40;
  uint64_t (*v41)(_QWORD *, _QWORD, uint64_t);
  uint64_t v42;
  void *v43;
  NSObject *v44;
  int v45;
  int v46;
  int v47;
  void *v48;
  _QWORD *v49;
  uint64_t (*v50)(_QWORD *, _QWORD, uint64_t);
  uint64_t v51;
  _QWORD *v52;
  uint64_t (*v53)(uint64_t, _QWORD, uint64_t);
  void *v54;
  NSObject *v55;
  int v56;
  int v57;
  NSObject *v58;
  int v59;
  int v60;
  char v61;
  uint64_t v62;
  uint64_t v63;
  os_unfair_lock_s *v65;
  uint32_t v66;
  int v67;
  void *v68;
  xpc_object_t xarray;
  _QWORD v70[6];
  uint64_t v71;
  uint64_t *v72;
  uint64_t v73;
  uint64_t v74;
  uint8_t buf[8];
  __int16 v76;
  int v77;
  __int16 v78;
  unsigned int v79;
  __int16 v80;
  int v81;
  __int16 v82;
  void *v83;
  __int16 v84;
  int v85;
  __int16 v86;
  void *v87;
  __int16 v88;
  unsigned int v89;

  v1 = a1;
  v71 = 0;
  v72 = &v71;
  v73 = 0x2000000000;
  v74 = 0;
  v70[0] = _NSConcreteStackBlock;
  v70[1] = 0x40000000;
  v70[2] = ___dx_gai_request_take_results_block_invoke;
  v70[3] = &unk_10013B5B8;
  v2 = a1 + 14;
  v70[4] = &v71;
  v70[5] = a1;
  os_unfair_lock_lock(a1 + 14);
  ___dx_gai_request_take_results_block_invoke((uint64_t)v70);
  os_unfair_lock_unlock(v2);
  v3 = v72;
  if (!v72[3])
  {
    xarray = 0;
    LODWORD(v4) = 0;
    goto LABEL_83;
  }
  LODWORD(v4) = -65539;
  v5 = xpc_array_create(0, 0);
  v3 = v72;
  xarray = v5;
  if (v5)
  {
    v4 = v72[3];
    if (v4)
    {
      v65 = v1;
      while (1)
      {
        v6 = xpc_dictionary_create(0, 0, 0);
        if (!v6)
        {
          fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "result", "", "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssd_server.c", 2548, 0);
          v61 = 0;
          v3 = v72;
          LODWORD(v4) = -65539;
          goto LABEL_84;
        }
        v7 = v6;
        xpc_dictionary_set_int64(v6, "error", *(int *)(v4 + 88));
        xpc_dictionary_set_uint64(v7, "flags", *(unsigned int *)(v4 + 80));
        xpc_dictionary_set_uint64(v7, "interface_index", *(unsigned int *)(v4 + 92));
        xpc_dictionary_set_string(v7, "rname", *(const char **)(*(_QWORD *)(*(_QWORD *)(v4 + 24) + 24) + 40));
        xpc_dictionary_set_uint64(v7, "rtype", *(unsigned __int16 *)(*(_QWORD *)(v4 + 24) + 52));
        xpc_dictionary_set_uint64(v7, "rprotocol", *(unsigned __int16 *)(v4 + 96));
        xpc_dictionary_set_uint64(v7, "rclass", *(unsigned __int16 *)(*(_QWORD *)(v4 + 24) + 54));
        v8 = *(_QWORD *)(v4 + 24);
        v9 = *(_QWORD *)(v8 + 32);
        v10 = *(unsigned __int16 *)(v8 + 56);
        if (v9)
          v11 = 1;
        else
          v11 = (_DWORD)v10 == 0;
        if (v11)
        {
          if (v9)
            v12 = *(const char **)(v8 + 32);
          else
            v12 = "";
          xpc_dictionary_set_data(v7, "rdata", v12, v10);
        }
        v13 = *(int *)(v4 + 84);
        if ((_DWORD)v13)
          xpc_dictionary_set_int64(v7, "negative_reason", v13);
        v14 = *(void **)(v4 + 32);
        if (v14)
          xpc_dictionary_set_value(v7, "provider_name", v14);
        v15 = *(void **)(v4 + 40);
        if (v15)
          xpc_dictionary_set_value(v7, "cname_update", v15);
        v16 = *(void **)(v4 + 48);
        if (v16)
        {
          xpc_dictionary_set_value(v7, "tracker_hostname", v16);
          v17 = *(void **)(v4 + 56);
          if (v17)
            xpc_dictionary_set_value(v7, "tracker_owner", v17);
          xpc_dictionary_set_BOOL(v7, "tracker_approved", *(_BYTE *)(v4 + 102) & 1);
          xpc_dictionary_set_BOOL(v7, "tracker_can_block_request", (*(_BYTE *)(v4 + 102) & 4) != 0);
        }
        v18 = *(_QWORD *)(v4 + 64);
        if (v18)
        {
          *(_QWORD *)buf = 0;
          data = mdns_signed_result_get_data(v18, buf);
          if (data)
            xpc_dictionary_set_data(v7, "validation_data", data, *(size_t *)buf);
        }
        v20 = *(_QWORD *)(v4 + 72);
        if (v20)
        {
          v21 = *(unsigned __int16 *)(v20 + 32);
          v22 = *(void **)(v20 + 24);
          empty = xpc_dictionary_create_empty();
          if (empty)
          {
            v24 = empty;
            xpc_dictionary_set_uint64(empty, "code", v21);
            if (v22 && xpc_string_get_length(v22))
              xpc_dictionary_set_value(v24, "text", v22);
            xpc_dictionary_set_value(v7, "extended_dns_error", v24);
            xpc_release(v24);
          }
          else
          {
            xpc_dictionary_set_value(v7, "extended_dns_error", 0);
          }
        }
        os_unfair_lock_opaque = v1[12]._os_unfair_lock_opaque;
        v26 = *(_DWORD *)(v4 + 80);
        v27 = v26 & 2;
        v28 = *(_QWORD *)(v4 + 24);
        if (!v28)
        {
          v29 = 0;
          v30 = 0;
          v31 = *(_BYTE *)(v4 + 102);
LABEL_40:
          if ((v31 & 2) != 0)
          {
            v40 = v29 + 2;
            while (1)
            {
              v40 = (_QWORD *)*v40;
              if (!v40)
                break;
              v41 = (uint64_t (*)(_QWORD *, _QWORD, uint64_t))v40[3];
              if (v41)
              {
                v42 = v41(v29, 0, 1);
                if (!v42)
                  break;
                v43 = (void *)v42;
                if (_mdns_server_log_s_once != -1)
                  dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
                v44 = _mdns_server_log_s_log;
                if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT))
                {
                  v45 = *(unsigned __int16 *)(v4 + 100);
                  v46 = *(_DWORD *)(v4 + 92);
                  v47 = *(_DWORD *)(v4 + 84);
                  *(_DWORD *)buf = 67110658;
                  *(_DWORD *)&buf[4] = os_unfair_lock_opaque;
                  v76 = 1024;
                  v77 = v45;
                  v78 = 1024;
                  v79 = v27 >> 1;
                  v80 = 1024;
                  v81 = v46;
                  v82 = 2082;
                  v83 = v43;
                  v84 = 1024;
                  v85 = v30;
                  v86 = 1024;
                  LODWORD(v87) = v47;
                  _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "[R%u->Q%u] getaddrinfo result -- event: %{mdns:addrmv}d, ifindex: %d, name: %{public}s, type: %{mdns:rrtype}d, rdata: <none>, reason: %{mdns:nreason}d", buf, 0x30u);
                }
                v48 = v43;
                goto LABEL_79;
              }
            }
          }
          if (_mdns_server_log_s_once != -1)
            dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
          v36 = _mdns_server_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT))
          {
            v37 = *(unsigned __int16 *)(v4 + 100);
            v38 = *(_DWORD *)(v4 + 92);
            v39 = *(_DWORD *)(v4 + 84);
            *(_DWORD *)buf = 67110658;
            *(_DWORD *)&buf[4] = os_unfair_lock_opaque;
            v76 = 1024;
            v77 = v37;
            v78 = 1024;
            v79 = v27 >> 1;
            v80 = 1024;
            v81 = v38;
            v82 = 2112;
            v83 = v29;
            v84 = 1024;
            v85 = v30;
            v86 = 1024;
            LODWORD(v87) = v39;
            _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "[R%u->Q%u] getaddrinfo result -- event: %{mdns:addrmv}d, ifindex: %d, name: %@, type: %{mdns:rrtype}d, rdata: <none>, reason: %{mdns:nreason}d", buf, 0x30u);
          }
          goto LABEL_80;
        }
        v29 = *(_QWORD **)(v28 + 24);
        v30 = *(unsigned __int16 *)(v28 + 52);
        v31 = *(_BYTE *)(v4 + 102);
        if (!*(_WORD *)(v28 + 56))
          goto LABEL_40;
        v66 = v1[12]._os_unfair_lock_opaque;
        v67 = *(unsigned __int16 *)(v28 + 52);
        if ((*(_BYTE *)(v4 + 102) & 2) != 0)
        {
          v49 = v29 + 2;
          while (1)
          {
            v49 = (_QWORD *)*v49;
            if (!v49)
              break;
            v50 = (uint64_t (*)(_QWORD *, _QWORD, uint64_t))v49[3];
            if (v50)
            {
              v51 = v50(v29, 0, 1);
              v28 = *(_QWORD *)(v4 + 24);
              goto LABEL_59;
            }
          }
          v51 = 0;
LABEL_59:
          v52 = (_QWORD *)(v28 + 16);
          do
          {
            v52 = (_QWORD *)*v52;
            if (!v52)
            {
              v32 = 0;
              v34 = 0;
              v35 = (void *)v51;
              v33 = v51 != 0;
              goto LABEL_70;
            }
            v53 = (uint64_t (*)(uint64_t, _QWORD, uint64_t))v52[3];
          }
          while (!v53);
          v34 = v53(v28, 0, 1);
          v54 = (void *)v51;
          v33 = v51 != 0;
          v32 = v34 != 0;
          v35 = v54;
          if (v54 && v34)
          {
            v68 = (void *)v34;
            if (_mdns_server_log_s_once != -1)
              dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
            v55 = _mdns_server_log_s_log;
            if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT))
            {
              v56 = *(unsigned __int16 *)(v4 + 100);
              v57 = *(_DWORD *)(v4 + 92);
              *(_DWORD *)buf = 67110914;
              *(_DWORD *)&buf[4] = v66;
              v76 = 1024;
              v77 = v56;
              v78 = 1024;
              v79 = v27 >> 1;
              v80 = 1024;
              v81 = v57;
              v82 = 2082;
              v83 = v35;
              v84 = 1024;
              v85 = v67;
              v86 = 2082;
              v87 = v68;
              v88 = 1024;
              v89 = v26 >> 31;
              _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "[R%u->Q%u] getaddrinfo result -- event: %{mdns:addrmv}d, ifindex: %d, name: %{public}s, type: %{mdns:rrtype}d, rdata: %{public}s, expired: %{mdns:yesno}d", buf, 0x3Au);
            }
            free(v35);
LABEL_78:
            v48 = v68;
LABEL_79:
            free(v48);
            goto LABEL_80;
          }
        }
        else
        {
          v32 = 0;
          v33 = 0;
          v34 = 0;
          v35 = 0;
        }
LABEL_70:
        v68 = (void *)v34;
        if (_mdns_server_log_s_once != -1)
          dispatch_once(&_mdns_server_log_s_once, &__block_literal_global_16);
        v58 = _mdns_server_log_s_log;
        if (!os_log_type_enabled((os_log_t)_mdns_server_log_s_log, OS_LOG_TYPE_DEFAULT))
          break;
        v59 = *(unsigned __int16 *)(v4 + 100);
        v60 = *(_DWORD *)(v4 + 92);
        *(_DWORD *)buf = 67110914;
        *(_DWORD *)&buf[4] = v66;
        v76 = 1024;
        v77 = v59;
        v78 = 1024;
        v79 = v27 >> 1;
        v80 = 1024;
        v81 = v60;
        v82 = 2112;
        v83 = v29;
        v84 = 1024;
        v85 = v67;
        v86 = 2112;
        v87 = (void *)v28;
        v88 = 1024;
        v89 = v26 >> 31;
        _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "[R%u->Q%u] getaddrinfo result -- event: %{mdns:addrmv}d, ifindex: %d, name: %@, type: %{mdns:rrtype}d, rdata: %@, expired: %{mdns:yesno}d", buf, 0x3Au);
        v1 = v65;
        if (v33)
          goto LABEL_76;
LABEL_77:
        if (v32)
          goto LABEL_78;
LABEL_80:
        v72[3] = *(_QWORD *)(v4 + 16);
        _dx_release((char *)v4);
        xpc_array_append_value(xarray, v7);
        xpc_release(v7);
        v3 = v72;
        v4 = v72[3];
        if (!v4)
          goto LABEL_83;
      }
      v1 = v65;
      if (!v33)
        goto LABEL_77;
LABEL_76:
      free(v35);
      goto LABEL_77;
    }
LABEL_83:
    v61 = 1;
    goto LABEL_84;
  }
  xarray = 0;
  v61 = 0;
LABEL_84:
  v62 = v3[3];
  if (v62)
  {
    v3[3] = 0;
    do
    {
      v63 = *(_QWORD *)(v62 + 16);
      _dx_release((char *)v62);
      v62 = v63;
    }
    while (v63);
  }
  if ((v61 & 1) == 0)
    _dx_request_set_error(v1, v4);
  _Block_object_dispose(&v71, 8);
  return xarray;
}

uint64_t ___dx_gai_request_take_results_block_invoke(uint64_t result)
{
  uint64_t v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v1 = *(_QWORD *)(result + 40);
  if ((*(_BYTE *)(v1 + 250) & 3) != 0)
  {
    v7 = 0;
    v4 = *(_QWORD *)(v1 + 96);
    v2 = (uint64_t *)(v1 + 96);
    v3 = v4;
    if (v4)
    {
      v5 = &v7;
      do
      {
        if ((*(_DWORD *)(v3 + 80) & 0x80000000) != 0)
        {
          *v2 = *(_QWORD *)(v3 + 16);
          *(_QWORD *)(v3 + 16) = 0;
          *v5 = v3;
          v5 = (uint64_t *)(v3 + 16);
        }
        else
        {
          v2 = (uint64_t *)(v3 + 16);
        }
        v3 = *v2;
      }
      while (*v2);
      v6 = v7;
    }
    else
    {
      v6 = 0;
    }
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = v6;
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = *(_QWORD *)(v1 + 96);
    *(_QWORD *)(*(_QWORD *)(result + 40) + 96) = 0;
  }
  return result;
}

uint64_t _dx_request_init(uint64_t result)
{
  unsigned int v1;

  do
    v1 = __ldaxr(&dnssd_server_get_new_request_id_s_next_id);
  while (__stlxr(v1 + 1, &dnssd_server_get_new_request_id_s_next_id));
  *(_DWORD *)(result + 48) = v1;
  *(_DWORD *)(result + 56) = 0;
  return result;
}

void _dx_request_finalize(uint64_t a1)
{
  char *v2;
  void *v3;

  v2 = *(char **)(a1 + 24);
  if (v2)
  {
    _dx_release(v2);
    *(_QWORD *)(a1 + 24) = 0;
  }
  v3 = *(void **)(a1 + 32);
  if (v3)
  {
    xpc_release(v3);
    *(_QWORD *)(a1 + 32) = 0;
  }
}

void _dx_session_finalize(uint64_t a1)
{
  void *v2;
  void *v3;

  v2 = *(void **)(a1 + 32);
  if (v2)
  {
    xpc_release(v2);
    *(_QWORD *)(a1 + 32) = 0;
  }
  v3 = *(void **)(a1 + 64);
  if (v3)
  {
    os_release(v3);
    *(_QWORD *)(a1 + 64) = 0;
  }
}

void ___dx_server_queue_block_invoke(id a1)
{
  NSObject *v1;

  v1 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
  _dx_server_queue_queue = (uint64_t)dispatch_queue_create("com.apple.dnssd.server", v1);
}

void __dnssd_server_idle_block_invoke(id a1)
{
  if (_dx_server_queue_once != -1)
    dispatch_once(&_dx_server_queue_once, &__block_literal_global_20);
  dnssd_server_idle_s_source = (uint64_t)dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_data_or, 0, 0, (dispatch_queue_t)_dx_server_queue_queue);
  dispatch_source_set_event_handler((dispatch_source_t)dnssd_server_idle_s_source, &__block_literal_global_14);
  dispatch_activate((dispatch_object_t)dnssd_server_idle_s_source);
}

void __dnssd_server_idle_block_invoke_2(id a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  _QWORD *v7;
  uint64_t (*v8)(_QWORD *);
  uint64_t v9;
  void *v10;
  xpc_object_t v11;
  void *v12;

  if (g_session_list)
  {
    v1 = mach_absolute_time();
    v2 = g_session_list;
    if (g_session_list)
    {
      v3 = v1;
      do
      {
        if (*(_QWORD *)(v2 + 32))
        {
          if (!*(_DWORD *)(v2 + 80))
            goto LABEL_10;
          v4 = *(_QWORD *)(v2 + 56);
          if (mdns_mach_ticks_per_second_s_once != -1)
            dispatch_once(&mdns_mach_ticks_per_second_s_once, &__block_literal_global_3428);
          if ((v3 - v4) / mdns_mach_ticks_per_second_s_ticks_per_second < 5)
          {
LABEL_10:
            v7 = *(_QWORD **)(v2 + 24);
            if (!v7)
              goto LABEL_20;
            while (1)
            {
              v8 = *(uint64_t (**)(_QWORD *))(*v7 + 32);
              if (v8)
              {
                v9 = v8(v7);
                if (v9)
                {
                  v10 = (void *)v9;
                  v11 = xpc_dictionary_create(0, 0, 0);
                  if (!v11)
                  {
                    _dx_session_terminate(v2, 5);
                    xpc_release(v10);
                    goto LABEL_20;
                  }
                  v12 = v11;
                  xpc_dictionary_set_uint64(v11, "id", v7[5]);
                  xpc_dictionary_set_int64(v12, "error", 0);
                  xpc_dictionary_set_value(v12, "results", v10);
                  xpc_release(v10);
                  _dx_session_send_message(v2, v12);
                  xpc_release(v12);
                }
              }
              if ((_dx_request_send_pending_error((uint64_t)v7) & 1) == 0)
              {
                v5 = v2;
                v6 = 5;
                goto LABEL_19;
              }
              v7 = (_QWORD *)v7[2];
              if (!v7)
                goto LABEL_20;
            }
          }
          v5 = v2;
          v6 = 2;
LABEL_19:
          _dx_session_terminate(v5, v6);
        }
        else
        {
          fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "me->connection", "", "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssd_server.c", 1050, 0);
        }
LABEL_20:
        v2 = *(_QWORD *)(v2 + 16);
      }
      while (v2);
    }
  }
}

uint64_t *GetAuthInfoForName_direct(uint64_t a1, _BYTE *a2)
{
  _BYTE *v2;
  uint64_t *v3;
  uint64_t *v4;
  _BYTE *v5;
  int v6;

  if (*a2)
  {
    v2 = a2;
    v3 = (uint64_t *)(a1 + 12760);
    do
    {
      v4 = v3;
      while (1)
      {
        v4 = (uint64_t *)*v4;
        if (!v4)
          break;
        if (SameDomainNameBytes((_BYTE *)v4 + 12, v2))
          return v4;
      }
      v5 = &v2[*v2];
      v6 = v5[1];
      v2 = v5 + 1;
    }
    while (v6);
  }
  return 0;
}

void RecreateNATMappings(uint64_t a1, int a2)
{
  int v3;
  uint64_t *i;
  _DWORD *v5;

  if ((*(_DWORD *)(a1 + 64) + a2) <= 1)
    v3 = 1;
  else
    v3 = *(_DWORD *)(a1 + 64) + a2;
  for (i = *(uint64_t **)(a1 + 14720); i; i = (uint64_t *)*i)
  {
    i[1] = 0xFA00000000;
    *((_DWORD *)i + 4) = v3;
    *((_DWORD *)i + 6) = 0;
    if (!*((_BYTE *)i + 172))
      *((_DWORD *)i + 5) = 0;
    v5 = (_DWORD *)i[7];
    if (v5)
    {
      mDNSPlatformTCPCloseConnection(v5);
      i[7] = 0;
    }
  }
  *(_DWORD *)(a1 + 14748) = arc4random();
  *(_DWORD *)(a1 + 14752) = arc4random();
  *(_DWORD *)(a1 + 14756) = arc4random();
  *(_DWORD *)(a1 + 14736) = 0;
  *(_DWORD *)(a1 + 14740) = v3;
  LNT_ClearState(a1);
  *(_DWORD *)(a1 + 104) = *(_DWORD *)(a1 + 64);
}

void natTraversalHandleAddressReply(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 v9;
  int v10;
  int v11;
  uint64_t *i;
  int v13;
  int v14;
  _DWORD *v15;
  int v16;

  v16 = a3;
  if (a2)
  {
    v9 = a2;
    if ((unsigned __int16)natTraversalHandleAddressReply_last_err != a2)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Error getting external address %d", a4, a5, a6, a7, a8, a2);
    v16 = 0;
    goto LABEL_5;
  }
  if (mDNS_LoggingEnabled == 1)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Received external IP address %.4a from NAT", a4, a5, a6, a7, a8, (int)&v16);
    LOBYTE(a3) = v16;
  }
  if (a3 != 10)
  {
    if (a3 == 172)
    {
      if ((BYTE1(v16) & 0xF0) != 0x10)
        goto LABEL_14;
    }
    else if (a3 != 192 || BYTE1(v16) != 168)
    {
      goto LABEL_14;
    }
  }
  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Double NAT (external NAT gateway address %.4a is also a private RFC 1918 address)", a4, a5, a6, a7, a8, (int)&v16);
LABEL_14:
  if (v16)
  {
    v9 = 0;
    v10 = 900000;
    *(_DWORD *)(a1 + 14744) = v16;
    goto LABEL_17;
  }
  v9 = 3;
LABEL_5:
  *(_DWORD *)(a1 + 14744) = 0;
  if (natTraversalHandleAddressReply_last_err)
  {
    v10 = *(_DWORD *)(a1 + 14736);
    goto LABEL_18;
  }
  v10 = 250;
LABEL_17:
  *(_DWORD *)(a1 + 14736) = v10;
LABEL_18:
  v11 = v10 + *(_DWORD *)(a1 + 64);
  *(_DWORD *)(a1 + 14740) = v11;
  if (*(_DWORD *)(a1 + 104) - v11 >= 1)
    *(_DWORD *)(a1 + 104) = v11;
  natTraversalHandleAddressReply_last_err = v9;
  for (i = *(uint64_t **)(a1 + 14720); i; i = (uint64_t *)*i)
  {
    if (*((_DWORD *)i + 39) != v16)
    {
      v13 = *((_DWORD *)i + 6);
      if (*((_BYTE *)i + 172))
      {
        if ((v13 - 1) < 2)
          goto LABEL_26;
      }
      else if (v13 != 3)
      {
LABEL_26:
        *((_DWORD *)i + 39) = v16;
        i[1] = 0xFA00000000;
        v14 = *(_DWORD *)(a1 + 64);
        *((_DWORD *)i + 4) = v14;
        v15 = (_DWORD *)i[7];
        if (v15)
        {
          mDNSPlatformTCPCloseConnection(v15);
          i[7] = 0;
          v14 = *(_DWORD *)(a1 + 64);
        }
        *(_DWORD *)(a1 + 104) = v14;
      }
    }
  }
}

void natTraversalHandlePortMapReplyWithAddress(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 v8;
  int v9;
  int v12;
  int v13;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;

  v8 = a6;
  v9 = a4;
  v22 = a5;
  v12 = *(unsigned __int8 *)(a2 + 172);
  *(_DWORD *)(a2 + 20) = a4;
  if (!(_DWORD)a4 && (_DWORD)a7 && (_WORD)a6)
  {
    v13 = a8;
    if (a7 >= 0xF423F)
      v15 = 999999;
    else
      v15 = a7;
    if ((*(_DWORD *)(a1 + 64) + 1000 * v15) <= 1)
      v16 = 1;
    else
      v16 = *(_DWORD *)(a1 + 64) + 1000 * v15;
    v17 = *(_DWORD *)(a2 + 156);
    *(_DWORD *)(a2 + 8) = v16;
    if (v17 == (_DWORD)a5)
    {
      if (*(unsigned __int16 *)(a2 + 176) == (unsigned __int16)a6 || (mDNS_LoggingEnabled & 1) == 0)
        goto LABEL_23;
    }
    else if (mDNS_LoggingEnabled != 1)
    {
LABEL_23:
      *(_QWORD *)(a2 + 144) = a3;
      *(_DWORD *)(a2 + 156) = a5;
      if (v12)
        *(_WORD *)(a2 + 176) = v8;
      *(_DWORD *)(a2 + 24) = v13;
      v20 = (*(_DWORD *)(a2 + 8) - *(_DWORD *)(a1 + 64)) / 2;
      if (v20 <= 2000)
        v20 = 2000;
      *(_DWORD *)(a2 + 12) = v20;
      v21 = *(_DWORD *)(a1 + 64);
      *(_DWORD *)(a2 + 16) = v21 + v20;
      *(_DWORD *)(a1 + 104) = v21;
      return;
    }
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "natTraversalHandlePortMapReplyWithAddress: %p %s Response %s Port %5d External %.4a:%d changed to %.4a:%d lease %d", a4, a5, a6, a7, a8, a2);
    LODWORD(a5) = v22;
    v12 = *(unsigned __int8 *)(a2 + 172);
    goto LABEL_23;
  }
  if (mDNS_LoggingEnabled == 1)
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "natTraversalHandlePortMapReplyWithAddress: %p Response %s Port %5d External %.4a:%d lease %d error %d", a4, a5, a6, a7, a8, a2);
  v18 = *(_DWORD *)(a1 + 64) + 900000;
  *(_DWORD *)(a2 + 12) = 900000;
  *(_DWORD *)(a2 + 16) = v18;
  if (v9 == 2)
  {
    v19 = -65565;
  }
  else
  {
    if ((v9 - 1) > 4)
      return;
    v19 = -65564;
  }
  *(_DWORD *)(a2 + 20) = v19;
}

void mDNS_StopNATOperation_internal(uint64_t a1, uint64_t a2)
{
  uint64_t **v4;
  _QWORD *v5;
  _QWORD *v6;
  BOOL v7;
  NSObject *v8;
  NSObject *v10;
  int v13;
  unsigned int v14;
  unsigned int v15;
  int v16;
  uint64_t *v17;
  int v18;
  int v19;
  int v20;
  int v21;
  BOOL v22;
  NSObject *v23;
  _BOOL4 v25;
  unsigned int v26;
  int v27;
  unsigned int v28;
  int v29;
  const char *v30;
  NSObject *v31;
  _DWORD *v33;
  void *v34;
  void *v35;
  _OWORD *v36;
  _QWORD *v37;
  _QWORD *v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  _QWORD *v44;
  _QWORD *v45;
  unsigned int v46;
  unsigned int v47;
  _QWORD *v48;
  BOOL v49;
  NSObject *v50;
  uint8_t v53[16];
  _BYTE buf[24];
  const char *v55;
  const char *v56;
  uint64_t *v57;
  __int128 v58;
  const char *v59;
  uint64_t v60;
  __int16 v61;

  v4 = (uint64_t **)(a1 + 14720);
  v5 = (_QWORD *)(a1 + 14720);
  do
  {
    v6 = v5;
    v5 = (_QWORD *)*v5;
    if (v5)
      v7 = v5 == (_QWORD *)a2;
    else
      v7 = 1;
  }
  while (!v7);
  if (!v5)
  {
    v10 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
        return;
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = a2;
    }
    else
    {
      v10 = mDNSLogCategory_NAT_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
        return;
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = a2;
    }
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "mDNS_StopNATOperation_internal: NATTraversalInfo %p not found in list", buf, 0xCu);
    return;
  }
  *v6 = *v5;
  v8 = mDNSLogCategory_NAT;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
      goto LABEL_24;
    goto LABEL_23;
  }
  v8 = mDNSLogCategory_NAT_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
  {
LABEL_23:
    v13 = *(unsigned __int8 *)(a2 + 172);
    v14 = bswap32(*(unsigned __int16 *)(a2 + 174)) >> 16;
    v15 = bswap32(*(unsigned __int16 *)(a2 + 176)) >> 16;
    v16 = *(_DWORD *)(a2 + 180);
    *(_DWORD *)buf = 134219008;
    *(_QWORD *)&buf[4] = a2;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v13;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v14;
    LOWORD(v55) = 1024;
    *(_DWORD *)((char *)&v55 + 2) = v15;
    HIWORD(v55) = 1024;
    LODWORD(v56) = v16;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "mDNS_StopNATOperation_internal %p %d %d %d %d", buf, 0x24u);
  }
LABEL_24:
  if (*(_QWORD *)(a1 + 14728) == a2)
    *(_QWORD *)(a1 + 14728) = *(_QWORD *)a2;
  v17 = *v4;
  if (v17)
  {
    v18 = 1;
    while (1)
    {
      v19 = *(unsigned __int8 *)(a2 + 172);
      v20 = *((unsigned __int8 *)v17 + 172);
      if (*(_BYTE *)(a2 + 172))
      {
        if (v19 != v20
          || (v21 = *(unsigned __int8 *)(a2 + 172), *(unsigned __int16 *)(a2 + 174) != *((unsigned __int16 *)v17 + 87)))
        {
          v22 = v19 == 2 && v20 == 0;
          if (!v22 || *(_WORD *)(a2 + 174) != 2304)
            goto LABEL_51;
          v21 = 0;
        }
      }
      else
      {
        v21 = *((unsigned __int8 *)v17 + 172);
        if (*((_BYTE *)v17 + 172))
        {
          if (v20 != 2 || *((_WORD *)v17 + 87) != 2304)
            goto LABEL_51;
          v21 = 2;
        }
      }
      v23 = mDNSLogCategory_NAT;
      if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_NAT != mDNSLogCategory_State)
        break;
      v18 = 0;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
        goto LABEL_50;
LABEL_51:
      v17 = (uint64_t *)*v17;
      if (!v17)
        goto LABEL_54;
    }
    v23 = mDNSLogCategory_NAT_redacted;
    v25 = os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT);
    v18 = 0;
    if (!v25)
      goto LABEL_51;
LABEL_50:
    v26 = bswap32(*(unsigned __int16 *)(a2 + 174)) >> 16;
    v27 = *(_DWORD *)(a2 + 180);
    v28 = bswap32(*((unsigned __int16 *)v17 + 87));
    v29 = *((_DWORD *)v17 + 45);
    *(_DWORD *)buf = 134219776;
    *(_QWORD *)&buf[4] = a2;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v19;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v26;
    LOWORD(v55) = 1024;
    *(_DWORD *)((char *)&v55 + 2) = v27;
    HIWORD(v55) = 2048;
    v56 = (const char *)v17;
    LOWORD(v57) = 1024;
    *(_DWORD *)((char *)&v57 + 2) = v21;
    HIWORD(v57) = 1024;
    LODWORD(v58) = HIWORD(v28);
    WORD2(v58) = 1024;
    *(_DWORD *)((char *)&v58 + 6) = v29;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Warning: Removed port mapping request %p Prot %d Int %d TTL %d duplicates existing port mapping request %p Prot %d Int %d TTL %d", buf, 0x3Au);
    v18 = 0;
    goto LABEL_51;
  }
  v18 = 1;
LABEL_54:
  if (!*(_WORD *)(a1 + 15036) || !*(_QWORD *)(a1 + 15056) || !*(_QWORD *)(a1 + 15072))
    goto LABEL_98;
  v61 = 0;
  v60 = 0;
  mDNS_snprintf(&v60);
  *(_QWORD *)buf = "NewRemoteHost";
  *(_QWORD *)&buf[8] = "string";
  *(_QWORD *)&buf[16] = "";
  v55 = "NewExternalPort";
  v56 = "ui2";
  v57 = &v60;
  *(_QWORD *)&v58 = "NewProtocol";
  *((_QWORD *)&v58 + 1) = "string";
  v30 = "TCP";
  if (*(_BYTE *)(a2 + 172) == 1)
    v30 = "UDP";
  v59 = v30;
  *(_QWORD *)(a2 + 48) = a2;
  if (*(_QWORD *)(a2 + 56))
  {
    v31 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
        goto LABEL_70;
      *(_WORD *)v53 = 0;
    }
    else
    {
      v31 = mDNSLogCategory_NAT_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_70;
      *(_WORD *)v53 = 0;
    }
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "LNT_UnmapPort: closing previous open connection", v53, 2u);
LABEL_70:
    v33 = *(_DWORD **)(a2 + 56);
    if (v33)
    {
      mDNSPlatformTCPCloseConnection(v33);
      *(_QWORD *)(a2 + 56) = 0;
    }
  }
  v34 = *(void **)(a2 + 96);
  if (v34)
  {
    free(v34);
    *(_QWORD *)(a2 + 96) = 0;
  }
  v35 = *(void **)(a2 + 112);
  if (v35)
  {
    free(v35);
    *(_QWORD *)(a2 + 112) = 0;
  }
  v36 = malloc_type_malloc(0x70uLL, 0xA172743EuLL);
  if (!v36)
    __break(1u);
  v37 = v36;
  v38 = (_QWORD *)(a1 + 15008);
  v39 = *(_OWORD *)(a2 + 32);
  v40 = *(_OWORD *)(a2 + 64);
  v36[1] = *(_OWORD *)(a2 + 48);
  v36[2] = v40;
  *v36 = v39;
  v41 = *(_OWORD *)(a2 + 80);
  v42 = *(_OWORD *)(a2 + 96);
  v43 = *(_OWORD *)(a2 + 128);
  v36[5] = *(_OWORD *)(a2 + 112);
  v36[6] = v43;
  v36[3] = v41;
  v36[4] = v42;
  v44 = (_QWORD *)(a1 + 15008);
  do
  {
    v45 = v44;
    v44 = (_QWORD *)*v44;
  }
  while (v44);
  *v45 = v36;
  v46 = SendSOAPMsgControlAction(a1, (uint64_t)v36, (uint64_t)"DeletePortMapping", 3, (uint64_t)buf, 4);
  if (!v46)
    goto LABEL_98;
  v47 = v46;
  do
  {
    v48 = v38;
    v38 = (_QWORD *)*v38;
    if (v38)
      v49 = v38 == v37;
    else
      v49 = 1;
  }
  while (!v49);
  if (v38)
  {
    *v48 = *v38;
    free(v37);
  }
  v50 = mDNSLogCategory_NAT;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
      goto LABEL_98;
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v47;
    goto LABEL_97;
  }
  v50 = mDNSLogCategory_NAT_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v47;
LABEL_97:
    _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "Legacy NAT Traversal - unmap request failed with error %d", buf, 8u);
  }
LABEL_98:
  if (*(_DWORD *)(a2 + 8))
  {
    if (v18)
    {
      *(_DWORD *)(a2 + 180) = 0;
      *(_DWORD *)(a2 + 12) = 0;
      *(_BYTE *)(a2 + 28) = 0;
      *(_WORD *)(a2 + 176) = 0;
      *(_DWORD *)(a2 + 156) = 0;
      uDNS_SendNATMsg(a1, a2, *(_DWORD *)(a2 + 24) != 1, 1);
    }
  }
}

uint64_t mDNS_StartNATOperation(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t started;

  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNS_StartNATOperation", 1003);
  started = mDNS_StartNATOperation_internal((uint64_t)mDNSStorage, a1, v2, v3, v4, v5, v6, v7);
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_StartNATOperation", 1005);
  return started;
}

void FoundStaticHostname(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v11;
  _BYTE *v12;
  uint64_t *v13;
  _BYTE *v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  int v18;
  unsigned __int16 v19;
  int v20;
  BOOL v21;
  unsigned int v22;
  unsigned int v23;

  v8 = a4;
  v11 = *(_QWORD *)(a3 + 40);
  v12 = (_BYTE *)(a1 + 14168);
  v13 = *(uint64_t **)(a1 + 14680);
  if (*(_WORD *)(a3 + 12))
  {
    if (mDNS_LoggingEnabled)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "FoundStaticHostname: question %##s -> answer %##s (%s)", a4, a5, a6, a7, a8, a2 + 376);
  }
  else if (mDNS_LoggingEnabled)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "FoundStaticHostname: question %##s -> answer NULL (%s)", a4, a5, a6, a7, a8, a2 + 376);
  }
  if (!v8)
  {
    if (!SameDomainNameBytes((_BYTE *)(v11 + 4), v12))
      return;
    mDNS_Lock_((unsigned int *)a1, (uint64_t)"FoundStaticHostname", 2587);
    *v12 = 0;
    v16 = *(_DWORD *)(a1 + 64);
    if (v16 <= 1)
      v16 = 1;
    *(_DWORD *)(a1 + 12684) = v16;
    v17 = a1;
    v18 = 2590;
    goto LABEL_33;
  }
  if (!*(_WORD *)(a3 + 12) || SameDomainNameBytes((_BYTE *)(v11 + 4), v12))
    return;
  v14 = (_BYTE *)(v11 + 4);
  if (v11 == -260)
  {
LABEL_11:
    while (v14)
    {
      v15 = *v14;
      if (v15 > 0x3F)
        break;
      if (!*v14)
      {
        v19 = (_WORD)v14 - (v11 + 4) + 1;
        if (v19 > 0x100u)
          break;
        memcpy(v12, (const void *)(v11 + 4), v19);
        goto LABEL_23;
      }
      v14 += v15 + 1;
      if (v11 != -260)
        goto LABEL_10;
    }
  }
  else
  {
LABEL_10:
    if ((unint64_t)v14 < v11 + 260)
      goto LABEL_11;
  }
  *v12 = 0;
LABEL_23:
  if (!v13)
  {
LABEL_30:
    mDNS_Lock_((unsigned int *)a1, (uint64_t)"FoundStaticHostname", 2581);
    v22 = *(_DWORD *)(a1 + 64);
    if (v22 <= 1)
      v22 = 1;
    *(_DWORD *)(a1 + 12684) = v22;
    v17 = a1;
    v18 = 2583;
LABEL_33:
    mDNS_Unlock_(v17, (uint64_t)"FoundStaticHostname", v18);
    return;
  }
  while (1)
  {
    v20 = *((_DWORD *)v13 + 202);
    v21 = v20 == 1 || v20 == 6;
    if (v21 || *((_DWORD *)v13 + 496) == 1)
      break;
    v13 = (uint64_t *)*v13;
    if (!v13)
      goto LABEL_30;
  }
  v23 = *(_DWORD *)(a1 + 64) + 5000;
  if (v23 <= 1)
    v23 = 1;
  *(_DWORD *)(a1 + 12684) = v23;
}

void UpdateOneSRVRecord(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t ServiceTarget;
  char *v6;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v11;
  _BOOL4 v12;
  int v13;
  int v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  BOOL v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  _QWORD *v33;
  _QWORD *v34;
  BOOL v35;
  NSObject *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;

  v4 = *(_QWORD *)(a2 + 48);
  ServiceTarget = GetServiceTarget(a1, a2);
  if (ServiceTarget)
    v6 = (char *)ServiceTarget;
  else
    v6 = "";
  v7 = *v6 && *(_DWORD *)(a2 + 344) == 8 || SameDomainNameBytes((_BYTE *)(v4 + 10), v6) == 0;
  v8 = *(_QWORD *)(a2 + 48);
  v9 = *(unsigned __int16 *)(v8 + 8);
  if (*(_BYTE *)(a2 + 120) != 2 || v9 == 0)
    goto LABEL_13;
  v13 = *(unsigned __int8 *)(a1 + 12720);
  if (v13 == 10)
    goto LABEL_41;
  if (v13 == 172)
  {
    if ((*(_BYTE *)(a1 + 12721) & 0xF0) == 0x10)
      goto LABEL_41;
LABEL_13:
    LODWORD(v11) = 0;
    goto LABEL_14;
  }
  if (v13 != 192 || *(unsigned __int8 *)(a1 + 12721) != 168)
    goto LABEL_13;
LABEL_41:
  v11 = *(_QWORD *)(a2 + 376);
  if (!v11)
    goto LABEL_14;
  if (*(_DWORD *)(v11 + 788) == 4)
  {
    v27 = *(unsigned __int8 *)(v11 + 792);
    switch(v27)
    {
      case 10:
        v29 = 1;
        goto LABEL_71;
      case 192:
        v28 = *(unsigned __int8 *)(v11 + 793) == 168;
LABEL_68:
        v29 = v28;
        goto LABEL_71;
      case 172:
        v28 = (*(_BYTE *)(v11 + 793) & 0xF0) == 16;
        goto LABEL_68;
    }
  }
  v29 = 0;
LABEL_71:
  LODWORD(v11) = v29 ^ 1;
LABEL_14:
  if (*(_QWORD *)(a2 + 584))
  {
    v12 = *(unsigned __int16 *)(a2 + 568) != v9;
  }
  else
  {
    if ((v11 & 1) != 0)
    {
      v14 = 1;
      goto LABEL_25;
    }
    v12 = 0;
  }
  v14 = v12 & ~(_DWORD)v11;
LABEL_25:
  if (mDNS_LoggingEnabled == 1)
  {
    v15 = mDNSLogCategory_Default;
    GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(v8 + 4), (_BYTE *)(a1 + 47032));
    LogMsgWithLevel(v15, OS_LOG_TYPE_DEFAULT, "UpdateOneSRVRecord: Resource Record %s TargetChanged %d, NewTarget %##s", v16, v17, v18, v19, v20, a1 + 47032);
  }
  mDNS_VerifyLockState("Check Lock", 1, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"UpdateOneSRVRecord", 2307);
  if ((v7 | v14) == 1)
  {
    if (*(_BYTE *)(a2 + 8) == 1)
    {
      if (mDNS_LoggingEnabled)
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "UpdateOneSRVRecord: Deregistering record, Ignoring TargetChanged %d, NATChanged %d for %##s, state %d", v22, v23, v24, v25, v26, v7);
    }
    else
    {
      if (mDNS_LoggingEnabled)
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "UpdateOneSRVRecord: TargetChanged %d, NATChanged %d for %##s, state %d, newtarget %##s", v22, v23, v24, v25, v26, v7);
      switch(*(_DWORD *)(a2 + 344))
      {
        case 1:
        case 2:
        case 3:
        case 5:
          *(_BYTE *)(a2 + 592) = 1;
          *(_DWORD *)(a2 + 280) = 1000;
          *(_DWORD *)(a2 + 284) = *(_DWORD *)(a1 + 64) - 1000;
          if (!*v6)
          {
            if (mDNS_LoggingEnabled)
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "UpdateOneSRVRecord: SRV record changed for service %##s de-registering", v22, v23, v24, v25, v26, *(_QWORD *)(a2 + 40));
            *(_DWORD *)(a2 + 344) = 3;
            v30 = a1;
            v31 = a2;
            v32 = 0;
            goto LABEL_76;
          }
          if (mDNS_LoggingEnabled)
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "UpdateOneSRVRecord: SRV record changed for service %##s, registering with new target %##s", v22, v23, v24, v25, v26, *(_QWORD *)(a2 + 40));
          *(_DWORD *)(a2 + 344) = 1;
          break;
        case 6:
        case 7:
          return;
        case 8:
          goto LABEL_53;
        case 9:
          if (v14)
          {
LABEL_53:
            if (*v6)
            {
              if (mDNS_LoggingEnabled)
                LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "RegisterAllServiceRecords: Service Record %##s", v22, v23, v24, v25, v26, *(_QWORD *)(a2 + 40));
              *(_BYTE *)(a2 + 592) = 0;
              v33 = (_QWORD *)(a1 + 12616);
              do
              {
                v34 = v33;
                v33 = (_QWORD *)*v33;
                if (v33)
                  v35 = v33 == (_QWORD *)a2;
                else
                  v35 = 1;
              }
              while (!v35);
              if (v33)
              {
                *v34 = *(_QWORD *)a2;
                *(_QWORD *)a2 = 0;
                if (*(_QWORD *)(a2 + 584))
                {
                  mDNS_StopNATOperation_internal(a1, a2 + 392);
                  *(_QWORD *)(a2 + 584) = 0;
                  if (*(_WORD *)(a2 + 12) == 33)
                    *(_WORD *)(*(_QWORD *)(a2 + 48) + 8) = *(_WORD *)(a2 + 566);
                }
              }
              else
              {
                LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "UnlinkResourceRecord:ERROR!! - no such active record %##s", v22, v23, v24, v25, v26, *(_QWORD *)(a2 + 40));
              }
              mDNS_Register_internal(a1, a2, v21, v22, v23, v24, v25, v26);
              v30 = a1;
              v31 = a2;
              v32 = 1;
LABEL_76:
              UpdateAllServiceRecords(v30, v31, v32);
            }
            else if (mDNS_LoggingEnabled)
            {
              v36 = mDNSLogCategory_Default;
              GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(a1 + 47032));
              LogMsgWithLevel(v36, OS_LOG_TYPE_DEFAULT, "UpdateOneSRVRecord: No target yet for Resource Record %s", v37, v38, v39, v40, v41, a1 + 47032);
            }
          }
          break;
        default:
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "UpdateOneSRVRecord: Unknown state %d for %##s", v22, v23, v24, v25, v26, *(_DWORD *)(a2 + 344));
          break;
      }
    }
  }
}

void UpdateAllServiceRecords(uint64_t a1, uint64_t a2, int a3)
{
  unsigned __int8 *v5;
  char *v7;
  NSObject *v8;
  _BYTE *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t *v23;
  uint64_t v24;
  NSObject *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned __int8 *v31;
  int v32;
  uint64_t v33;
  NSObject *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  NSObject *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  NSObject *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;

  v5 = (unsigned __int8 *)(a2 + 8);
  if (*(_WORD *)(a2 + 12) != 33)
  {
    v7 = "UpdateAllServiceRecords:ERROR!! ResourceRecord not a service record %s";
    goto LABEL_6;
  }
  if (a3 && *(_DWORD *)(a2 + 344) == 8)
  {
    v7 = "UpdateAllServiceRecords:ERROR!! SRV record %s in noTarget state during registration";
LABEL_6:
    v8 = mDNSLogCategory_Default;
    v9 = (_BYTE *)(a1 + 47032);
    GetRRDisplayString_rdb(v5, (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), v9);
    LogMsgWithLevel(v8, OS_LOG_TYPE_DEFAULT, v7, v10, v11, v12, v13, v14, (int)v9);
    return;
  }
  if (mDNS_LoggingEnabled == 1)
  {
    v15 = mDNSLogCategory_Default;
    GetRRDisplayString_rdb(v5, (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(a1 + 47032));
    LogMsgWithLevel(v15, OS_LOG_TYPE_DEFAULT, "UpdateAllServiceRecords: ResourceRecord %s", v16, v17, v18, v19, v20, a1 + 47032);
  }
  v21 = *(_QWORD *)(a1 + 12616);
  if (v21)
  {
    while (*(_QWORD *)(v21 + 32) || *(_BYTE *)(v21 + 122) || IsLocalDomain(*(_BYTE **)(v21 + 40)))
    {
LABEL_23:
      v21 = *(_QWORD *)v21;
      if (!v21)
        return;
    }
    v22 = *(unsigned __int16 *)(v21 + 12);
    if (v22 == 16)
    {
      v23 = (uint64_t *)(v21 + 88);
    }
    else
    {
      if (v22 != 12)
      {
        v24 = 0;
LABEL_22:
        if (v24 == a2)
        {
          v31 = (unsigned __int8 *)(v21 + 8);
          if (a3)
          {
            *(_BYTE *)(v21 + 592) = 0;
            v32 = *(_DWORD *)(v21 + 344);
            if (v32 == 2 || v32 == 1 && (v33 = *(_QWORD *)(v21 + 376)) != 0 && *(_DWORD *)(v33 + 792))
            {
              if (mDNS_LoggingEnabled == 1)
              {
                v34 = mDNSLogCategory_Default;
                GetRRDisplayString_rdb(v31, (unsigned __int16 *)(*(_QWORD *)(v21 + 48) + 4), (_BYTE *)(a1 + 47032));
                LogMsgWithLevel(v34, OS_LOG_TYPE_DEFAULT, "UpdateAllServiceRecords: not registering %s, state %d", v35, v36, v37, v38, v39, a1 + 47032);
              }
            }
            else
            {
              if (mDNS_LoggingEnabled == 1)
              {
                v46 = mDNSLogCategory_Default;
                GetRRDisplayString_rdb(v31, (unsigned __int16 *)(*(_QWORD *)(v21 + 48) + 4), (_BYTE *)(a1 + 47032));
                LogMsgWithLevel(v46, OS_LOG_TYPE_DEFAULT, "UpdateAllServiceRecords: registering %s, state %d", v47, v48, v49, v50, v51, a1 + 47032);
              }
              ActivateUnicastRegistration(a1, v21);
            }
          }
          else
          {
            if (mDNS_LoggingEnabled == 1)
            {
              v40 = mDNSLogCategory_Default;
              GetRRDisplayString_rdb(v31, (unsigned __int16 *)(*(_QWORD *)(v21 + 48) + 4), (_BYTE *)(a1 + 47032));
              LogMsgWithLevel(v40, OS_LOG_TYPE_DEFAULT, "UpdateAllServiceRecords: deregistering %s", v41, v42, v43, v44, v45, a1 + 47032);
            }
            *(_BYTE *)(v21 + 592) = 1;
            *(_DWORD *)(v21 + 280) = 1000;
            *(_DWORD *)(v21 + 284) = *(_DWORD *)(a1 + 64) - 1000;
            *(_DWORD *)(v21 + 344) = 3;
          }
        }
        goto LABEL_23;
      }
      v23 = (uint64_t *)(v21 + 72);
    }
    v24 = *v23;
    if (*v23 && *(_WORD *)(v24 + 12) != 33)
    {
      v25 = mDNSLogCategory_Default;
      GetRRDisplayString_rdb((unsigned __int8 *)(v24 + 8), (unsigned __int16 *)(*(_QWORD *)(v24 + 48) + 4), (_BYTE *)(a1 + 47032));
      LogMsgWithLevel(v25, OS_LOG_TYPE_DEFAULT, "UpdateAllServiceRecords: ERROR!! Resource record %s wrong, expecting SRV type", v26, v27, v28, v29, v30, a1 + 47032);
    }
    goto LABEL_22;
  }
}

void hostnameGetPublicAddressCallback(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v9;
  int v10;
  _DWORD *v11;

  v9 = *(_QWORD *)(a2 + 192);
  if (!v9)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "RegisterHostnameRecord: registration cancelled", a4, a5, a6, a7, a8, a9);
    return;
  }
  if (!*(_DWORD *)(a2 + 168))
  {
    v11 = (_DWORD *)(a2 + 152);
    v10 = *(_DWORD *)(a2 + 152);
    if (v10 && v10 != 10)
    {
      if (v10 == 172)
      {
        if ((BYTE1(v10) & 0xF0) == 0x10)
          return;
      }
      else if (v10 == 192 && BYTE1(v10) == 168)
      {
        return;
      }
      if (*(_BYTE *)(v9 + 472))
      {
        if (*(_DWORD *)(*(_QWORD *)(v9 + 512) + 4) != v10)
        {
          if (mDNS_LoggingEnabled == 1)
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Updating hostname %p %##s IPv4 from %.4a to %.4a (NAT gateway's external address)", a4, a5, a6, a7, a8, a2);
          mDNS_Deregister(a1, v9 + 464);
        }
      }
      else
      {
        if (mDNS_LoggingEnabled == 1)
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Advertising hostname %##s IPv4 %.4a (NAT gateway's external address)", a4, a5, a6, a7, a8, *(_QWORD *)(v9 + 504));
        *(_BYTE *)(v9 + 472) = 32;
        *(_DWORD *)(*(_QWORD *)(v9 + 512) + 4) = *v11;
        mDNS_Register(a1, v9 + 464);
      }
    }
  }
}

void mDNS_RemoveDynDNSHostName(_BYTE *a1)
{
  NSObject *v2;
  _BYTE *v4;
  unsigned __int16 v5;
  uint64_t v6;
  _BYTE *v8;
  unsigned __int16 v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  void **v13;
  int v14;
  _DWORD *v15;
  int v16;
  _BOOL4 v17;
  NSObject *v18;
  _BYTE *v20;
  int v21;
  uint64_t v22;
  _BYTE *v24;
  uint64_t v25;
  NSObject *v26;
  _BYTE *v27;
  int v28;
  uint64_t v29;
  int v30;
  _BYTE *v31;
  uint64_t v32;
  uint64_t v33;
  NSObject *v34;
  _BYTE *v35;
  int v36;
  uint64_t v37;
  _BYTE *v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  __int16 v42;
  int v43;
  __int16 v44;
  _BYTE *v45;

  v2 = mDNSLogCategory_uDNS;
  if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_uDNS != mDNSLogCategory_State)
  {
    v2 = mDNSLogCategory_uDNS_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT))
      goto LABEL_37;
    if (a1)
    {
      v8 = a1;
      if (a1 == (_BYTE *)-256)
        goto LABEL_23;
LABEL_20:
      v9 = 257;
      if (v8 < a1 + 256 && v8)
      {
        while (1)
        {
          v10 = *v8;
          if (v10 > 0x3F)
          {
LABEL_31:
            v9 = 257;
            goto LABEL_35;
          }
          if (!*v8)
            break;
          v8 += v10 + 1;
          if (a1 != (_BYTE *)-256)
            goto LABEL_20;
LABEL_23:
          if (!v8)
            goto LABEL_31;
        }
        v9 = (_WORD)v8 - (_WORD)a1 + 1;
      }
LABEL_35:
      v11 = v9;
    }
    else
    {
      v11 = 0;
    }
    goto LABEL_36;
  }
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT))
  {
    if (a1)
    {
      v4 = a1;
      if (a1 == (_BYTE *)-256)
        goto LABEL_12;
LABEL_9:
      v5 = 257;
      if (v4 < a1 + 256 && v4)
      {
        while (1)
        {
          v6 = *v4;
          if (v6 > 0x3F)
          {
LABEL_30:
            v5 = 257;
            goto LABEL_33;
          }
          if (!*v4)
            break;
          v4 += v6 + 1;
          if (a1 != (_BYTE *)-256)
            goto LABEL_9;
LABEL_12:
          if (!v4)
            goto LABEL_30;
        }
        v5 = (_WORD)v4 - (_WORD)a1 + 1;
      }
LABEL_33:
      v11 = v5;
    }
    else
    {
      v11 = 0;
    }
LABEL_36:
    v40 = 141558531;
    v41 = 1752392040;
    v42 = 1040;
    v43 = v11;
    v44 = 2101;
    v45 = a1;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "mDNS_RemoveDynDNSHostName %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", (uint8_t *)&v40, 0x1Cu);
  }
LABEL_37:
  v12 = xmmword_10015C720;
  if (!(_QWORD)xmmword_10015C720)
    goto LABEL_47;
  v13 = (void **)&xmmword_10015C720;
  while (1)
  {
    v14 = SameDomainNameBytes(a1, (_BYTE *)(v12 + 208));
    v15 = *v13;
    if (v14)
      break;
    v12 = *(_QWORD *)v15;
    v13 = (void **)*v13;
    if (!*(_QWORD *)v15)
      goto LABEL_47;
  }
  if (!v15)
  {
LABEL_47:
    v18 = mDNSLogCategory_uDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_uDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT))
        goto LABEL_101;
      if (a1)
      {
        v20 = a1;
        if (a1 == (_BYTE *)-256)
          goto LABEL_58;
LABEL_55:
        v21 = 257;
        if (v20 < a1 + 256 && v20)
        {
          while (1)
          {
            v22 = *v20;
            if (v22 > 0x3F)
            {
LABEL_95:
              v21 = 257;
              goto LABEL_100;
            }
            if (!*v20)
              break;
            v20 += v22 + 1;
            if (a1 != (_BYTE *)-256)
              goto LABEL_55;
LABEL_58:
            if (!v20)
              goto LABEL_95;
          }
          v21 = (unsigned __int16)((_WORD)v20 - (_WORD)a1 + 1);
        }
      }
      else
      {
        v21 = 0;
      }
    }
    else
    {
      v18 = mDNSLogCategory_uDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_101;
      if (a1)
      {
        v24 = a1;
        if (a1 == (_BYTE *)-256)
          goto LABEL_69;
LABEL_66:
        v21 = 257;
        if (v24 < a1 + 256 && v24)
        {
          while (1)
          {
            v25 = *v24;
            if (v25 > 0x3F)
            {
LABEL_96:
              v21 = 257;
              goto LABEL_100;
            }
            if (!*v24)
              break;
            v24 += v25 + 1;
            if (a1 != (_BYTE *)-256)
              goto LABEL_66;
LABEL_69:
            if (!v24)
              goto LABEL_96;
          }
          v21 = (unsigned __int16)((_WORD)v24 - (_WORD)a1 + 1);
        }
      }
      else
      {
        v21 = 0;
      }
    }
LABEL_100:
    v40 = 141558531;
    v41 = 1752392040;
    v42 = 1040;
    v43 = v21;
    v44 = 2101;
    v45 = a1;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "mDNS_RemoveDynDNSHostName: no such domainname %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", (uint8_t *)&v40, 0x1Cu);
    goto LABEL_101;
  }
  v16 = *((unsigned __int8 *)v15 + 472);
  if (*((_BYTE *)v15 + 472))
    v16 = v15[202] != 4;
  if (*((_BYTE *)v15 + 1648))
    v17 = v15[496] != 4;
  else
    v17 = 0;
  *v13 = *(void **)v15;
  if ((v16 | v17) == 1)
  {
    if (!v16)
      goto LABEL_124;
    v26 = mDNSLogCategory_uDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_uDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT))
      {
        if (a1)
        {
          v31 = a1;
          if (a1 == (_BYTE *)-256)
            goto LABEL_110;
LABEL_107:
          v28 = 257;
          if (v31 < a1 + 256 && v31)
          {
            while (1)
            {
              v32 = *v31;
              if (v32 > 0x3F)
              {
LABEL_118:
                v28 = 257;
                goto LABEL_122;
              }
              if (!*v31)
                break;
              v31 += v32 + 1;
              if (a1 != (_BYTE *)-256)
                goto LABEL_107;
LABEL_110:
              if (!v31)
                goto LABEL_118;
            }
            v28 = (unsigned __int16)((_WORD)v31 - (_WORD)a1 + 1);
          }
        }
        else
        {
          v28 = 0;
        }
        goto LABEL_122;
      }
    }
    else
    {
      v26 = mDNSLogCategory_uDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT))
      {
        if (a1)
        {
          v27 = a1;
          if (a1 == (_BYTE *)-256)
            goto LABEL_87;
LABEL_84:
          v28 = 257;
          if (v27 < a1 + 256 && v27)
          {
            while (1)
            {
              v29 = *v27;
              if (v29 > 0x3F)
              {
LABEL_117:
                v28 = 257;
                goto LABEL_122;
              }
              if (!*v27)
                break;
              v27 += v29 + 1;
              if (a1 != (_BYTE *)-256)
                goto LABEL_84;
LABEL_87:
              if (!v27)
                goto LABEL_117;
            }
            v28 = (unsigned __int16)((_WORD)v27 - (_WORD)a1 + 1);
          }
        }
        else
        {
          v28 = 0;
        }
LABEL_122:
        v40 = 141558531;
        v41 = 1752392040;
        v42 = 1040;
        v43 = v28;
        v44 = 2101;
        v45 = a1;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "mDNS_RemoveDynDNSHostName removing v4 %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", (uint8_t *)&v40, 0x1Cu);
      }
    }
    mDNS_Deregister_internal((uint64_t)mDNSStorage, (uint64_t)(v15 + 116), 0);
LABEL_124:
    if (!v17)
      goto LABEL_101;
    v33 = (uint64_t)(v15 + 410);
    v34 = mDNSLogCategory_uDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_uDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT))
      {
        if (a1)
        {
          v38 = a1;
          if (a1 == (_BYTE *)-256)
            goto LABEL_144;
LABEL_141:
          v36 = 257;
          if (v38 < a1 + 256 && v38)
          {
            while (1)
            {
              v39 = *v38;
              if (v39 > 0x3F)
              {
LABEL_152:
                v36 = 257;
                goto LABEL_156;
              }
              if (!*v38)
                break;
              v38 += v39 + 1;
              if (a1 != (_BYTE *)-256)
                goto LABEL_141;
LABEL_144:
              if (!v38)
                goto LABEL_152;
            }
            v36 = (unsigned __int16)((_WORD)v38 - (_WORD)a1 + 1);
          }
        }
        else
        {
          v36 = 0;
        }
        goto LABEL_156;
      }
    }
    else
    {
      v34 = mDNSLogCategory_uDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT))
      {
        if (a1)
        {
          v35 = a1;
          if (a1 == (_BYTE *)-256)
            goto LABEL_133;
LABEL_130:
          v36 = 257;
          if (v35 < a1 + 256 && v35)
          {
            while (1)
            {
              v37 = *v35;
              if (v37 > 0x3F)
              {
LABEL_151:
                v36 = 257;
                goto LABEL_156;
              }
              if (!*v35)
                break;
              v35 += v37 + 1;
              if (a1 != (_BYTE *)-256)
                goto LABEL_130;
LABEL_133:
              if (!v35)
                goto LABEL_151;
            }
            v36 = (unsigned __int16)((_WORD)v35 - (_WORD)a1 + 1);
          }
        }
        else
        {
          v36 = 0;
        }
LABEL_156:
        v40 = 141558531;
        v41 = 1752392040;
        v42 = 1040;
        v43 = v36;
        v44 = 2101;
        v45 = a1;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "mDNS_RemoveDynDNSHostName removing v6 %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", (uint8_t *)&v40, 0x1Cu);
      }
    }
    mDNS_Deregister_internal((uint64_t)mDNSStorage, v33, 0);
    goto LABEL_101;
  }
  if (*((_QWORD *)v15 + 25))
  {
    mDNS_StopNATOperation_internal((uint64_t)mDNSStorage, (uint64_t)(v15 + 2));
    *((_QWORD *)v15 + 25) = 0;
  }
  free(v15);
LABEL_101:
  mDNS_VerifyLockState("Check Lock", 1, dword_100158DF8, dword_100158DFC, (uint64_t)"mDNS_RemoveDynDNSHostName", 2699);
  v30 = dword_100158E08;
  if (dword_100158E08 <= 1)
    v30 = 1;
  dword_10015BF54 = v30;
}

uint64_t ParseTSIGError(uint64_t a1, unint64_t a2, unint64_t a3, int a4)
{
  unsigned __int8 *v8;
  unsigned __int8 *Additionals;
  unsigned __int8 *v10;
  unsigned int i;
  unsigned __int8 *LargeResourceRecord;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v22;
  unint64_t v23;
  _BYTE *v24;
  uint64_t v25;
  unsigned __int16 v26;
  uint64_t v27;
  unsigned __int16 *v28;
  unint64_t v29;
  unint64_t v30;
  unsigned __int16 *v31;
  unint64_t v32;
  unsigned int v34;

  v8 = (unsigned __int8 *)(a1 + 37920);
  Additionals = LocateAdditionals(a2, a3);
  if (Additionals && *(_WORD *)(a2 + 10))
  {
    v10 = Additionals;
    for (i = 0; i < *(unsigned __int16 *)(a2 + 10); ++i)
    {
      LargeResourceRecord = GetLargeResourceRecord(a1, a2, v10, a3, 0, 128, a1 + 37912);
      if (!LargeResourceRecord)
        break;
      v10 = LargeResourceRecord;
      if (*v8 != 240 && *((_WORD *)v8 + 2) == 250)
      {
        v22 = *((_QWORD *)v8 + 5) + 4;
        v23 = v22 + *((unsigned __int16 *)v8 + 6);
        v24 = (_BYTE *)v22;
        if (!v23)
          goto LABEL_18;
LABEL_15:
        v19 = 0;
        if ((unint64_t)v24 >= v23 || !v24)
          goto LABEL_11;
        while (1)
        {
          v25 = *v24;
          if (v25 > 0x3F)
            goto LABEL_10;
          if (!*v24)
          {
            v26 = (_WORD)v24 - v22 + 1;
            if (v26 > 0x100u)
              goto LABEL_10;
            v27 = v22 + v26;
            if (v27 + 6 > v23)
              goto LABEL_10;
            v28 = (unsigned __int16 *)(v27 + 8);
            if (v27 + 8 > v23)
              goto LABEL_10;
            v29 = v27 + 10;
            if (v29 > v23)
              goto LABEL_10;
            v30 = v29 + (bswap32(*v28) >> 16);
            if (v30 > v23)
              goto LABEL_10;
            v31 = (unsigned __int16 *)(v30 + 2);
            v32 = v30 + 4;
            if ((unint64_t)v31 > v23 || v32 > v23)
              goto LABEL_10;
            v34 = bswap32(*v31);
            v19 = HIWORD(v34);
            if (HIWORD(v34) > 0x10u)
            {
              if ((_DWORD)v19 == 17)
              {
                v19 = 4294901735;
                LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%##s: bad key", v13, v14, v15, v16, v17, a4);
                goto LABEL_11;
              }
              if ((_DWORD)v19 == 18)
              {
                LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%##s: bad time", v13, v14, v15, v16, v17, a4);
                v19 = 4294901737;
                goto LABEL_11;
              }
            }
            else
            {
              if (!(_DWORD)v19)
                goto LABEL_11;
              if ((_DWORD)v19 == 16)
              {
                LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%##s: bad signature", v13, v14, v15, v16, v17, a4);
                v19 = 4294901736;
                goto LABEL_11;
              }
            }
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%##s: unknown tsig error %d", v13, v14, v15, v16, v17, a4);
            v19 = 4294901759;
            goto LABEL_11;
          }
          v24 += v25 + 1;
          if (v23)
            goto LABEL_15;
LABEL_18:
          if (!v24)
            goto LABEL_10;
        }
      }
      *(_WORD *)v8 = 0;
      *((_WORD *)v8 + 51) = 0;
      v18 = (_QWORD *)*((_QWORD *)v8 + 7);
      if (v18)
      {
        ref_count_obj_release(v18);
        *((_QWORD *)v8 + 7) = 0;
      }
    }
  }
LABEL_10:
  v19 = 0;
LABEL_11:
  *(_WORD *)v8 = 0;
  *((_WORD *)v8 + 51) = 0;
  v20 = (_QWORD *)*((_QWORD *)v8 + 7);
  if (v20)
  {
    ref_count_obj_release(v20);
    *((_QWORD *)v8 + 7) = 0;
  }
  return v19;
}

const char *LLQStateToString(int a1)
{
  const char *result;
  NSObject *v3;
  int v6;
  int v7;

  if (a1 <= 9)
  {
    if (!a1)
      return "LLQ_Invalid";
    if (a1 == 1)
      return "LLQ_Init";
LABEL_9:
    v3 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))
        return "<INVALID LLQ_State>";
      v6 = 67109120;
      v7 = a1;
    }
    else
    {
      v3 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
        return "<INVALID LLQ_State>";
      v6 = 67109120;
      v7 = a1;
    }
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, "Invalid LLQ_State - state: %u", (uint8_t *)&v6, 8u);
    return "<INVALID LLQ_State>";
  }
  switch(a1)
  {
    case 10:
      result = "LLQ_DNSPush_ServerDiscovery";
      break;
    case 11:
      result = "LLQ_DNSPush_Connecting";
      break;
    case 12:
      result = "LLQ_DNSPush_Established";
      break;
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
      goto LABEL_9;
    case 20:
      result = "LLQ_InitialRequest";
      break;
    case 21:
      result = "LLQ_SecondaryRequest";
      break;
    case 22:
      result = "LLQ_Established";
      break;
    default:
      if (a1 != 30)
        goto LABEL_9;
      result = "LLQ_Poll";
      break;
  }
  return result;
}

void uDNS_DeregisterRecord(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  int v7;
  unsigned int v8;
  NSObject *v10;
  uint64_t v11;
  _BYTE *v12;
  uint64_t v13;
  _BYTE *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char v18;
  NSObject *v19;
  int v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  char v24;
  NSObject *v25;
  unsigned __int8 *v26;
  char v27;
  NSObject *v28;
  NSObject *v29;
  uint64_t *AuthInfoForName_internal;
  int v33;
  int v34;
  NSObject *log;
  uint8_t buf[4];
  _BYTE v37[20];
  _BYTE v38[10];
  __int16 v39;
  const char *v40;

  v4 = mDNSLogCategory_uDNS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_uDNS == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT))
      goto LABEL_10;
  }
  else
  {
    v4 = mDNSLogCategory_uDNS_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT))
      goto LABEL_10;
  }
  GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(a1 + 47032));
  v7 = *(_DWORD *)(a2 + 344);
  *(_DWORD *)buf = 141558531;
  *(_QWORD *)v37 = 1752392040;
  *(_WORD *)&v37[8] = 2085;
  *(_QWORD *)&v37[10] = a1 + 47032;
  *(_WORD *)&v37[18] = 1024;
  *(_DWORD *)v38 = v7;
  _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "uDNS_DeregisterRecord: Resource Record %{sensitive, mask.hash}s, state %d", buf, 0x1Cu);
LABEL_10:
  v8 = *(_DWORD *)(a2 + 344);
  if (v8 <= 9 && ((1 << v8) & 0x351) != 0)
  {
    v10 = mDNSLogCategory_uDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_uDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT))
        goto LABEL_49;
      v11 = *(_QWORD *)(a2 + 40);
      if (v11)
      {
        v14 = *(_BYTE **)(a2 + 40);
        if (v11 == -256)
        {
LABEL_29:
          while (v14)
          {
            v15 = *v14;
            if (v15 > 0x3F)
              break;
            if (!*v14)
            {
              v20 = (unsigned __int16)((_WORD)v14 - v11 + 1);
              goto LABEL_48;
            }
            v14 += v15 + 1;
            if (v11 != -256)
              goto LABEL_28;
          }
        }
        else
        {
LABEL_28:
          if ((unint64_t)v14 < v11 + 256)
            goto LABEL_29;
        }
        v20 = 257;
      }
      else
      {
        v20 = 0;
      }
    }
    else
    {
      v10 = mDNSLogCategory_uDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_49;
      v11 = *(_QWORD *)(a2 + 40);
      if (v11)
      {
        v12 = *(_BYTE **)(a2 + 40);
        if (v11 == -256)
        {
LABEL_20:
          while (v12)
          {
            v13 = *v12;
            if (v13 > 0x3F)
              break;
            if (!*v12)
            {
              v20 = (unsigned __int16)((_WORD)v12 - v11 + 1);
              goto LABEL_48;
            }
            v12 += v13 + 1;
            if (v11 != -256)
              goto LABEL_19;
          }
        }
        else
        {
LABEL_19:
          if ((unint64_t)v12 < v11 + 256)
            goto LABEL_20;
        }
        v20 = 257;
      }
      else
      {
        v20 = 0;
      }
    }
LABEL_48:
    v21 = DNSTypeName(*(unsigned __int16 *)(a2 + 12));
    *(_DWORD *)buf = 67110147;
    *(_DWORD *)v37 = v8;
    *(_WORD *)&v37[4] = 2160;
    *(_QWORD *)&v37[6] = 1752392040;
    *(_WORD *)&v37[14] = 1040;
    *(_DWORD *)&v37[16] = v20;
    *(_WORD *)v38 = 2101;
    *(_QWORD *)&v38[2] = v11;
    v39 = 2082;
    v40 = v21;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "uDNS_DeregisterRecord: State %d for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P type %{public}s", buf, 0x2Cu);
LABEL_49:
    if (*(_BYTE *)(a2 + 8) == 1)
      CompleteDeregistration(a1, a2);
    return;
  }
  v16 = *(_QWORD *)(a2 + 632);
  if (v16 && *(_QWORD *)(a2 + 320))
  {
    v17 = *(_QWORD *)(a2 + 48);
    v18 = gSensitiveLoggingEnabled;
    v19 = mDNSLogCategory_uDNS;
    if (mDNSLogCategory_uDNS == mDNSLogCategory_State)
      v18 = 0;
    if (v16 != v17)
    {
      if ((v18 & 1) != 0)
      {
        v19 = mDNSLogCategory_uDNS_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT))
          goto LABEL_55;
      }
      else if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT))
      {
LABEL_55:
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(v17 + 4), (_BYTE *)(a1 + 47032));
        *(_DWORD *)buf = 141558275;
        *(_QWORD *)v37 = 1752392040;
        *(_WORD *)&v37[8] = 2085;
        *(_QWORD *)&v37[10] = a1 + 47032;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "uDNS_DeregisterRecord: Freeing InFlightRData for %{sensitive, mask.hash}s", buf, 0x16u);
      }
      (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD))(a2 + 320))(a1, a2, *(_QWORD *)(a2 + 632), *(unsigned __int16 *)(a2 + 618));
      *(_QWORD *)(a2 + 632) = 0;
      goto LABEL_59;
    }
    if ((v18 & 1) == 0)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT))
        goto LABEL_59;
LABEL_58:
      GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(v16 + 4), (_BYTE *)(a1 + 47032));
      *(_DWORD *)buf = 141558275;
      *(_QWORD *)v37 = 1752392040;
      *(_WORD *)&v37[8] = 2085;
      *(_QWORD *)&v37[10] = a1 + 47032;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "uDNS_DeregisterRecord: InFlightRData same as rdata for %{sensitive, mask.hash}s", buf, 0x16u);
      goto LABEL_59;
    }
    v19 = mDNSLogCategory_uDNS_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT))
      goto LABEL_58;
  }
LABEL_59:
  v22 = *(_QWORD *)(a2 + 640);
  if (!v22 || !*(_QWORD *)(a2 + 320))
    goto LABEL_75;
  v23 = *(_QWORD *)(a2 + 48);
  v24 = gSensitiveLoggingEnabled;
  v25 = mDNSLogCategory_uDNS;
  if (mDNSLogCategory_uDNS == mDNSLogCategory_State)
    v24 = 0;
  if (v22 != v23)
  {
    if ((v24 & 1) != 0)
    {
      v25 = mDNSLogCategory_uDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_71;
    }
    else if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT))
    {
LABEL_71:
      GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(v23 + 4), (_BYTE *)(a1 + 47032));
      *(_DWORD *)buf = 141558275;
      *(_QWORD *)v37 = 1752392040;
      *(_WORD *)&v37[8] = 2085;
      *(_QWORD *)&v37[10] = a1 + 47032;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "uDNS_DeregisterRecord: Freeing QueuedRData for %{sensitive, mask.hash}s", buf, 0x16u);
    }
    (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD))(a2 + 320))(a1, a2, *(_QWORD *)(a2 + 640), *(unsigned __int16 *)(a2 + 620));
    *(_QWORD *)(a2 + 640) = 0;
    goto LABEL_75;
  }
  if ((v24 & 1) == 0)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT))
      goto LABEL_75;
LABEL_74:
    GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(v22 + 4), (_BYTE *)(a1 + 47032));
    *(_DWORD *)buf = 141558275;
    *(_QWORD *)v37 = 1752392040;
    *(_WORD *)&v37[8] = 2085;
    *(_QWORD *)&v37[10] = a1 + 47032;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "uDNS_DeregisterRecord: ERROR!! QueuedRData same as rdata for %{sensitive, mask.hash}s", buf, 0x16u);
    goto LABEL_75;
  }
  v25 = mDNSLogCategory_uDNS_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT))
    goto LABEL_74;
LABEL_75:
  if (!*(_WORD *)(a2 + 358))
    goto LABEL_110;
  v26 = *(unsigned __int8 **)(a1 + 12616);
  if (!v26)
    goto LABEL_101;
  v27 = 1;
  do
  {
    while (!*(_QWORD *)(a2 + 32)
         && !*(_BYTE *)(a2 + 122)
         && !IsLocalDomain(*(_BYTE **)(a2 + 40))
         && *((unsigned __int16 *)v26 + 179) == *(unsigned __int16 *)(a2 + 358)
         && *((_QWORD *)v26 + 48))
    {
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_uDNS == mDNSLogCategory_State)
      {
        log = mDNSLogCategory_uDNS;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT))
          goto LABEL_91;
      }
      else
      {
        log = mDNSLogCategory_uDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT))
          goto LABEL_91;
      }
      GetRRDisplayString_rdb(v26 + 8, (unsigned __int16 *)(*((_QWORD *)v26 + 6) + 4), (_BYTE *)(a1 + 47032));
      *(_DWORD *)buf = 141558275;
      *(_QWORD *)v37 = 1752392040;
      *(_WORD *)&v37[8] = 2085;
      *(_QWORD *)&v37[10] = a1 + 47032;
      _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, "uDNS_DeregisterRecord: Found Anchor RR %{sensitive, mask.hash}s terminated", buf, 0x16u);
LABEL_91:
      if ((v27 & 1) == 0)
      {
        v28 = mDNSLogCategory_uDNS;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_uDNS == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT))
          {
LABEL_97:
            GetRRDisplayString_rdb(v26 + 8, (unsigned __int16 *)(*((_QWORD *)v26 + 6) + 4), (_BYTE *)(a1 + 47032));
            *(_DWORD *)buf = 141558275;
            *(_QWORD *)v37 = 1752392040;
            *(_WORD *)&v37[8] = 2085;
            *(_QWORD *)&v37[10] = a1 + 47032;
            _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "uDNS_DeregisterRecord: ERROR: Another anchorRR %{sensitive, mask.hash}s found", buf, 0x16u);
          }
        }
        else
        {
          v28 = mDNSLogCategory_uDNS_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT))
            goto LABEL_97;
        }
      }
      DisposeTCPConn(*((_QWORD *)v26 + 48));
      v27 = 0;
      *((_QWORD *)v26 + 48) = 0;
      v26 = *(unsigned __int8 **)v26;
      if (!v26)
        goto LABEL_110;
    }
    v26 = *(unsigned __int8 **)v26;
  }
  while (v26);
  if ((v27 & 1) != 0)
  {
LABEL_101:
    v29 = mDNSLogCategory_uDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_uDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT))
        goto LABEL_109;
    }
    else
    {
      v29 = mDNSLogCategory_uDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT))
      {
LABEL_109:
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(a1 + 47032));
        *(_DWORD *)buf = 141558275;
        *(_QWORD *)v37 = 1752392040;
        *(_WORD *)&v37[8] = 2085;
        *(_QWORD *)&v37[10] = a1 + 47032;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "uDNSDeregisterRecord: Cannot find the anchor Resource Record for %{sensitive, mask.hash}s, not an error", buf, 0x16u);
      }
    }
  }
LABEL_110:
  *(_DWORD *)(a2 + 344) = 3;
  *(_DWORD *)(a2 + 280) = 1000;
  *(_DWORD *)(a2 + 284) = *(_DWORD *)(a1 + 64) - 1000;
  AuthInfoForName_internal = GetAuthInfoForName_internal(a1, *(_BYTE **)(a2 + 40));
  if (IsRecordMergeable(a1, a2, *(_DWORD *)(a1 + 64) + 1000))
  {
    if (AuthInfoForName_internal && *((_DWORD *)AuthInfoForName_internal + 2))
      v33 = *(_DWORD *)(a2 + 284) + 2000;
    else
      v33 = *(_DWORD *)(a2 + 284) + 1000;
    *(_DWORD *)(a2 + 284) = v33;
  }
  else
  {
    v33 = *(_DWORD *)(a2 + 284);
  }
  v34 = *(_DWORD *)(a2 + 280) + v33;
  if (*(_DWORD *)(a1 + 12680) - v34 >= 0)
    *(_DWORD *)(a1 + 12680) = v34;
}

void StartRecordNatMap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _BYTE *v10;
  uint64_t v11;
  _BYTE *v12;
  uint64_t v13;
  _BYTE *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char v21;
  uint64_t v22;

  if (*(_WORD *)(a2 + 12) == 33)
  {
    v10 = *(_BYTE **)(a2 + 40);
    if (*v10)
      v11 = *v10 + 1;
    else
      v11 = 0;
    v12 = &v10[v11];
    if (*v12)
      v13 = *v12 + 1;
    else
      v13 = 0;
    v14 = &v12[v13];
    if (SameDomainLabelPointer(&v12[v13], "\x04_tcp"))
    {
      v21 = 2;
    }
    else
    {
      if (!SameDomainLabelPointer(v14, "\x04_udp"))
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "StartRecordNatMap: could not determine transport protocol of service %##s", v16, v17, v18, v19, v20, *(_QWORD *)(a2 + 40));
        return;
      }
      v21 = 1;
    }
    if (*(_QWORD *)(a2 + 584))
      mDNS_StopNATOperation_internal(a1, a2 + 392);
    *(_BYTE *)(a2 + 564) = v21;
    v22 = *(_QWORD *)(a2 + 48);
    *(_WORD *)(a2 + 566) = *(_WORD *)(v22 + 8);
    *(_WORD *)(a2 + 568) = *(_WORD *)(v22 + 8);
    *(_DWORD *)(a2 + 572) = 0;
    *(_QWORD *)(a2 + 576) = CompleteRecordNatMap;
    *(_QWORD *)(a2 + 584) = a2;
    mDNS_StartNATOperation_internal(a1, a2 + 392, v15, v16, v17, v18, v19, v20);
  }
  else if (mDNS_LoggingEnabled == 1)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "StartRecordNatMap: Resource Record %##s type %d, not supported", a4, a5, a6, a7, a8, *(_QWORD *)(a2 + 40));
  }
}

BOOL IsRecordMergeable(uint64_t a1, uint64_t a2, int a3)
{
  _BOOL8 result;
  _BYTE *v7;
  uint64_t *AuthInfoForName_internal;
  int v9;
  unsigned int v10;
  uint64_t v11;

  if (*(_QWORD *)(a2 + 32))
    return 0;
  if (*(_BYTE *)(a2 + 122))
    return 0;
  if (IsLocalDomain(*(_BYTE **)(a2 + 40)))
    return 0;
  if (*(_DWORD *)(a2 + 284) - a3 + *(_DWORD *)(a2 + 280) > 0)
    return 0;
  v7 = *(_BYTE **)(a2 + 368);
  if (!v7)
    return 0;
  AuthInfoForName_internal = GetAuthInfoForName_internal(a1, v7);
  if (AuthInfoForName_internal)
  {
    v9 = *((_DWORD *)AuthInfoForName_internal + 2);
    if (v9)
    {
      if (*(_DWORD *)(a1 + 64) - v9 >= 0)
        return 0;
    }
  }
  result = 0;
  v10 = *(_DWORD *)(a2 + 344);
  if (v10 <= 7 && ((1 << v10) & 0xAE) != 0)
  {
    v11 = *(_QWORD *)(a2 + 376);
    if (v11 && *(_DWORD *)(v11 + 792) && *(_BYTE *)(a2 + 348))
      return *(_DWORD *)(a2 + 596) != 1;
    return 0;
  }
  return result;
}

void CompleteRecordNatMap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v9;
  NSObject *v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  NSObject *v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  NSObject *v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _BYTE *ServiceTarget;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  _BYTE *v47;
  _BYTE *v48;
  unsigned int v49;
  NSObject *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  _BYTE *v61;
  uint64_t v62;
  unsigned __int16 v63;
  int v64;

  v9 = *(_QWORD *)(a2 + 192);
  if (!v9)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "CompleteRecordNatMap called with unknown AuthRecord object", a4, a5, a6, a7, a8, a9);
    return;
  }
  if (!*(_DWORD *)(a2 + 180))
  {
    v19 = mDNSLogCategory_Default;
    v20 = a1 + 47032;
    GetRRDisplayString_rdb((unsigned __int8 *)(v9 + 8), (unsigned __int16 *)(*(_QWORD *)(v9 + 48) + 4), (_BYTE *)(a1 + 47032));
    LogMsgWithLevel(v19, OS_LOG_TYPE_DEFAULT, "CompleteRecordNatMap No NATLease for %s", v21, v22, v23, v24, v25, v20);
    return;
  }
  if (*(_WORD *)(v9 + 12) != 33)
  {
    v26 = mDNSLogCategory_Default;
    v27 = a1 + 47032;
    GetRRDisplayString_rdb((unsigned __int8 *)(v9 + 8), (unsigned __int16 *)(*(_QWORD *)(v9 + 48) + 4), (_BYTE *)(a1 + 47032));
    LogMsgWithLevel(v26, OS_LOG_TYPE_DEFAULT, "CompleteRecordNatMap: Not a service record %s", v28, v29, v30, v31, v32, v27);
    return;
  }
  if (*(_BYTE *)(v9 + 8) == 1)
  {
    if (mDNS_LoggingEnabled == 1)
    {
      v12 = mDNSLogCategory_Default;
      v13 = a1 + 47032;
      GetRRDisplayString_rdb((unsigned __int8 *)(v9 + 8), (unsigned __int16 *)(*(_QWORD *)(v9 + 48) + 4), (_BYTE *)(a1 + 47032));
      LogMsgWithLevel(v12, OS_LOG_TYPE_DEFAULT, "CompleteRecordNatMap called for %s, Service deregistering", v14, v15, v16, v17, v18, v13);
    }
    return;
  }
  if (*(_DWORD *)(v9 + 344) == 3)
  {
    if (mDNS_LoggingEnabled == 1)
    {
      v33 = mDNSLogCategory_Default;
      v34 = a1 + 47032;
      GetRRDisplayString_rdb((unsigned __int8 *)(v9 + 8), (unsigned __int16 *)(*(_QWORD *)(v9 + 48) + 4), (_BYTE *)(a1 + 47032));
      LogMsgWithLevel(v33, OS_LOG_TYPE_DEFAULT, "CompleteRecordNatMap called for %s, record in DeregPending", v35, v36, v37, v38, v39, v34);
    }
    return;
  }
  v40 = *(_QWORD *)(v9 + 376);
  if (!v40 || !*(_DWORD *)(v40 + 792))
  {
    if (mDNS_LoggingEnabled == 1)
    {
      v50 = mDNSLogCategory_Default;
      GetRRDisplayString_rdb((unsigned __int8 *)(v9 + 8), (unsigned __int16 *)(*(_QWORD *)(v9 + 48) + 4), (_BYTE *)(a1 + 47032));
      LogMsgWithLevel(v50, OS_LOG_TYPE_DEFAULT, "CompleteRecordNatMap called for %s but no zone information!", v51, v52, v53, v54, v55, a1 + 47032);
    }
    if (*(_QWORD *)(v9 + 584))
    {
      mDNS_StopNATOperation_internal(a1, v9 + 392);
      *(_QWORD *)(v9 + 584) = 0;
    }
    *(_DWORD *)(v9 + 344) = 1;
    *(_DWORD *)(v9 + 280) = 1000;
    *(_DWORD *)(v9 + 284) = *(_DWORD *)(a1 + 64) - 1000;
    return;
  }
  mDNS_Lock_((unsigned int *)a1, (uint64_t)"CompleteRecordNatMap", 2122);
  ServiceTarget = (_BYTE *)GetServiceTarget(a1, v9);
  v47 = ServiceTarget;
  v48 = 0;
  v49 = *(unsigned __int16 *)(v9 + 12);
  if (v49 > 0x20)
  {
    switch(v49)
    {
      case '!':
        v48 = (_BYTE *)(*(_QWORD *)(v9 + 48) + 10);
        break;
      case '$':
LABEL_28:
        v48 = (_BYTE *)(*(_QWORD *)(v9 + 48) + 6);
        break;
      case '\'':
LABEL_31:
        v48 = (_BYTE *)(*(_QWORD *)(v9 + 48) + 4);
        break;
    }
  }
  else
  {
    switch(*(_WORD *)(v9 + 12))
    {
      case 0xC:
        goto LABEL_31;
      case 0xD:
      case 0xE:
      case 0x10:
      case 0x11:
      case 0x13:
      case 0x14:
        break;
      case 0xF:
      case 0x12:
      case 0x15:
        goto LABEL_28;
      default:
        if (v49 == 2 || v49 == 5)
          goto LABEL_31;
        break;
    }
  }
  if (!ServiceTarget || !*ServiceTarget)
  {
    if (mDNS_LoggingEnabled == 1)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "CompleteRecordNatMap - no target for %##s, ExternalPort %d", v42, v43, v44, v45, v46, *(_QWORD *)(v9 + 40));
    goto LABEL_49;
  }
  if (!*(_WORD *)(a2 + 160))
  {
    if (mDNS_LoggingEnabled)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "CompleteRecordNatMap - Target %##s for ResourceRecord %##s, ExternalPort %d", v42, v43, v44, v45, v46, (int)ServiceTarget);
LABEL_49:
    if (v48)
      *v48 = 0;
    *(_DWORD *)(v9 + 344) = 8;
    *(_DWORD *)(v9 + 20) = 0;
    mDNS_Unlock_(a1, (uint64_t)"CompleteRecordNatMap", 2136);
    UpdateAllServiceRecords(a1, v9, 0);
    return;
  }
  if (mDNS_LoggingEnabled)
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "CompleteRecordNatMap - Target %##s for ResourceRecord %##s, ExternalPort %d", v42, v43, v44, v45, v46, (int)ServiceTarget);
  if (v48 && !SameDomainNameBytes(v48, v47))
  {
    v61 = v47;
    if (v47 == (_BYTE *)-256)
    {
LABEL_42:
      while (v61)
      {
        v62 = *v61;
        if (v62 > 0x3F)
          break;
        if (!*v61)
        {
          v63 = (_WORD)v61 - (_WORD)v47 + 1;
          if (v63 > 0x100u)
            break;
          memcpy(v48, v47, v63);
          goto LABEL_57;
        }
        v61 += v62 + 1;
        if (v47 != (_BYTE *)-256)
          goto LABEL_41;
      }
    }
    else
    {
LABEL_41:
      if (v61 < v47 + 256)
        goto LABEL_42;
    }
    *v48 = 0;
LABEL_57:
    SetNewRData(v9 + 8, 0, 0, v56, v57, v58, v59, v60);
  }
  *(_BYTE *)(v9 + 592) = 0;
  *(_DWORD *)(v9 + 344) = 1;
  *(_DWORD *)(v9 + 280) = 1000;
  v64 = *(_DWORD *)(a1 + 64);
  *(_DWORD *)(v9 + 284) = v64 - 1000;
  if (IsRecordMergeable(a1, v9, v64 + 1000))
    *(_DWORD *)(v9 + 284) += 1000;
  mDNS_Unlock_(a1, (uint64_t)"CompleteRecordNatMap", 2174);
  UpdateAllServiceRecords(a1, v9, 1);
}

uint64_t uDNS_UpdateRecord(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void (*v9)(uint64_t *, uint64_t);
  uint64_t result;
  void (*v11)(uint64_t *, uint64_t, _QWORD, _QWORD);
  int v12;

  if (mDNS_LoggingEnabled == 1)
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_UpdateRecord: Resource Record %##s, state %d", a4, a5, a6, a7, a8, *(_QWORD *)(a1 + 40));
  switch(*(_DWORD *)(a1 + 344))
  {
    case 0:
    case 9:
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: uDNS_UpdateRecord called for record %##s with bad state regState_NATError", a4, a5, a6, a7, a8, *(_QWORD *)(a1 + 40));
      return 4294901759;
    case 1:
    case 5:
    case 7:
      if (*(_QWORD *)(a1 + 640))
      {
        v9 = *(void (**)(uint64_t *, uint64_t))(a1 + 320);
        if (v9)
          v9(mDNSStorage, a1);
      }
      result = 0;
      *(_QWORD *)(a1 + 640) = *(_QWORD *)(a1 + 304);
      *(_WORD *)(a1 + 620) = *(_WORD *)(a1 + 312);
      goto LABEL_12;
    case 2:
      *(_QWORD *)(a1 + 624) = *(_QWORD *)(a1 + 48);
      *(_WORD *)(a1 + 616) = *(_WORD *)(a1 + 20);
      *(_QWORD *)(a1 + 632) = *(_QWORD *)(a1 + 304);
      *(_WORD *)(a1 + 618) = *(_WORD *)(a1 + 312);
      *(_QWORD *)(a1 + 304) = 0;
      *(_DWORD *)(a1 + 344) = 7;
      *(_DWORD *)(a1 + 280) = 1000;
      v12 = dword_100158E08;
      *(_DWORD *)(a1 + 284) = dword_100158E08 - 1000;
      result = 0;
      if (dword_10015BF50 - v12 >= 0)
        dword_10015BF50 = v12;
      return result;
    case 3:
    case 4:
      goto LABEL_14;
    case 6:
    case 8:
      v11 = *(void (**)(uint64_t *, uint64_t, _QWORD, _QWORD))(a1 + 320);
      if (v11)
        v11(mDNSStorage, a1, *(_QWORD *)(a1 + 48), *(unsigned __int16 *)(a1 + 20));
      SetNewRData(a1 + 8, *(_QWORD *)(a1 + 304), *(unsigned __int16 *)(a1 + 312), a4, a5, a6, a7, a8);
      result = 0;
LABEL_12:
      *(_QWORD *)(a1 + 304) = 0;
      return result;
    default:
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_UpdateRecord: Unknown state %d for %##s", a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 344));
LABEL_14:
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_UpdateRecord: Requested update of record %##s type %d, in erroneous state %d", a4, a5, a6, a7, a8, *(_QWORD *)(a1 + 40));
      return 4294901747;
  }
}

uint64_t AreRecordsMergeable(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;

  result = IsRecordMergeable(a1, a3, a4);
  if ((_DWORD)result)
  {
    result = SameDomainNameBytes(*(_BYTE **)(a2 + 368), *(_BYTE **)(a3 + 368));
    if ((_DWORD)result)
    {
      v7 = *(_QWORD *)(a2 + 376);
      v8 = *(_QWORD *)(a3 + 376);
      return *(_DWORD *)(v7 + 792) == *(_DWORD *)(v8 + 792)
          && *(unsigned __int16 *)(v7 + 786) == *(unsigned __int16 *)(v8 + 786);
    }
  }
  return result;
}

void SendGroupRRMessage(uint64_t a1, uint64_t a2, unint64_t a3, _DWORD *a4)
{
  unsigned __int16 *v7;
  unint64_t updated;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *TCPConn;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t i;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  NSObject *v29;
  _BYTE *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  _BYTE *v37;
  _BYTE *v38;
  int v39;
  int v40;

  v7 = (unsigned __int16 *)(a1 + 28960);
  updated = putUpdateLeaseWithLimit(a1 + 28960, a3, a1 + 30412);
  if (updated)
  {
    v14 = updated;
    if (*(_BYTE *)(a2 + 356))
    {
      v15 = *(_QWORD *)(a2 + 384);
      if (v15)
      {
        DisposeTCPConn(v15);
        *(_QWORD *)(a2 + 384) = 0;
      }
      v16 = *(_QWORD *)(a2 + 376);
      if (v16)
      {
        TCPConn = MakeTCPConn(a1, v7, v14, 1, (int *)(v16 + 788), *(unsigned __int16 *)(v16 + 786), (_BYTE *)(v16 + 530), 0, a2);
        *(_QWORD *)(a2 + 384) = TCPConn;
        if (TCPConn)
        {
          if (mDNS_LoggingEnabled)
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SendGroupRRMessage: Sent a group update ID: %d start %p, end %p, limit %p", v18, v19, v20, v21, v22, bswap32(*v7) >> 16);
          return;
        }
        if (!mDNS_LoggingEnabled)
          return;
        v29 = mDNSLogCategory_Default;
        v38 = (_BYTE *)(a1 + 47032);
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), v38);
        v40 = (int)v38;
        v36 = "SendGroupRRMessage: Cannot establish TCP connection for %s";
      }
      else
      {
        v29 = mDNSLogCategory_Default;
        v37 = (_BYTE *)(a1 + 47032);
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), v37);
        v40 = (int)v37;
        v36 = "SendGroupRRMessage:ERROR!! nta is NULL for %s";
      }
LABEL_18:
      LogMsgWithLevel(v29, OS_LOG_TYPE_DEFAULT, v36, v31, v32, v33, v34, v35, v40);
      return;
    }
    if (mDNSSendDNSMessage(a1, (unint64_t)v7, updated, 0, 0, 0, (int *)(*(_QWORD *)(a2 + 376) + 788), *(_WORD *)(*(_QWORD *)(a2 + 376) + 786), a4, 0))
    {
      if (!mDNS_LoggingEnabled)
        return;
      v29 = mDNSLogCategory_Default;
      v30 = (_BYTE *)(a1 + 47032);
      GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), v30);
      v40 = (int)v30;
      v36 = "SendGroupRRMessage: Cannot send UDP message for %s";
      goto LABEL_18;
    }
    if (mDNS_LoggingEnabled)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SendGroupRRMessage: Sent a group UDP update ID: %d start %p, end %p, limit %p", v24, v25, v26, v27, v28, bswap32(*v7) >> 16);
  }
  else
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SendGroupRRMessage: ERROR: Could not put lease option, failing the group registration", v9, v10, v11, v12, v13, v39);
    for (i = *(_QWORD *)(a1 + 12616); i; i = *(_QWORD *)i)
    {
      *(_DWORD *)(i + 596) = 1;
      *(_QWORD *)(i + 224) = 0;
      ActivateUnicastRegistration(a1, i);
    }
  }
}

unint64_t BuildUpdateMessage(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v10;
  int v12;
  int v13;
  __int16 v14;
  unint64_t result;
  __int16 v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  _WORD *v29;
  int v30;
  __int16 v31;
  _BYTE *v32;
  NSObject *v33;
  _BYTE *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;

  v10 = a2;
  v12 = *(_DWORD *)(a3 + 344);
  v13 = 5;
  switch(v12)
  {
    case 2:
      goto LABEL_5;
    case 3:
      *(_DWORD *)(a3 + 352) = 0;
      v14 = *(_WORD *)(a3 + 14);
      *(_WORD *)(a3 + 14) = 254;
      result = PutResourceRecordTTLWithLimit(a1 + 28960, a2, (_WORD *)(a1 + 28968), a3 + 8, 0, a4, a7, a8);
      *(_WORD *)(a3 + 14) = v14;
      if (!result)
        goto LABEL_25;
      return result;
    case 5:
    case 7:
      goto LABEL_6;
    default:
      v13 = 1;
LABEL_5:
      *(_DWORD *)(a3 + 344) = v13;
      v12 = v13;
LABEL_6:
      if (*(_BYTE *)(a3 + 8) != 4)
        *(_BYTE *)(a3 + 192) = 1;
      if (*(_WORD *)(a3 + 12) == 33 && *(_BYTE *)(a3 + 120) == 2 && *(_WORD *)(a3 + 552))
      {
        *(_WORD *)(*(_QWORD *)(a3 + 48) + 8) = *(_WORD *)(a3 + 552);
        v12 = *(_DWORD *)(a3 + 344);
      }
      if (v12 == 7)
      {
        SetNewRData(a3 + 8, *(_QWORD *)(a3 + 624), *(unsigned __int16 *)(a3 + 616), a4, a5, a6, a7, a8);
        v16 = *(_WORD *)(a3 + 14);
        *(_WORD *)(a3 + 14) = 254;
        v19 = PutResourceRecordTTLWithLimit(a1 + 28960, v10, (_WORD *)(a1 + 28968), a3 + 8, 0, a4, v17, v18);
        *(_WORD *)(a3 + 14) = v16;
        if (!v19)
          goto LABEL_25;
        v25 = v19;
        SetNewRData(a3 + 8, *(_QWORD *)(a3 + 632), *(unsigned __int16 *)(a3 + 618), v20, v21, v22, v23, v24);
        v26 = *(unsigned int *)(a3 + 16);
        v27 = a1 + 28960;
        v28 = v25;
        v29 = (_WORD *)(a1 + 28968);
      }
      else
      {
        v30 = *(unsigned __int8 *)(a3 + 8);
        if (v30 == 32 || v30 == 16)
        {
          v31 = *(_WORD *)(a3 + 12);
          v32 = putDomainNameAsLabels(a1 + 28960, a2, a4, *(unsigned __int8 **)(a3 + 40), a5, a6, a7, a8);
          if (!v32)
            goto LABEL_25;
          v10 = (unint64_t)(v32 + 10);
          if ((unint64_t)(v32 + 10) >= a4)
            goto LABEL_25;
          *v32 = HIBYTE(v31);
          v32[1] = v31;
          *((_WORD *)v32 + 1) = -256;
          *((_DWORD *)v32 + 1) = 0;
          *((_WORD *)v32 + 4) = 0;
          ++*(_WORD *)(a1 + 28968);
          if (v32 == (_BYTE *)-10)
            goto LABEL_25;
        }
        else if (!a2 && v30 != 8)
        {
          goto LABEL_25;
        }
        v27 = a1 + 28960;
        v29 = (_WORD *)(a1 + 28968);
        v26 = *(unsigned int *)(a3 + 16);
        v28 = v10;
      }
      result = PutResourceRecordTTLWithLimit(v27, v28, v29, a3 + 8, v26, a4, a7, a8);
      if (result)
        return result;
LABEL_25:
      v33 = mDNSLogCategory_Default;
      v34 = (_BYTE *)(a1 + 47032);
      GetRRDisplayString_rdb((unsigned __int8 *)(a3 + 8), (unsigned __int16 *)(*(_QWORD *)(a3 + 48) + 4), v34);
      LogMsgWithLevel(v33, OS_LOG_TYPE_DEFAULT, "BuildUpdateMessage: Error formatting message for %s", v35, v36, v37, v38, v39, (int)v34);
      return 0;
  }
}

void uDNS_SetupWABQueries()
{
  uint64_t i;
  uint64_t j;
  NSObject *v2;
  unsigned int v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t *v6;
  int v7;
  NSObject *v8;
  int v9;
  uint64_t v10;
  _BYTE *k;
  uint64_t v12;
  unsigned __int16 v13;
  int v14;
  int v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  int v24;
  NSObject *v25;
  int v26;
  NSObject *v27;
  int v28;
  NSObject *v29;
  _QWORD *v30;
  NSObject *v31;
  uint64_t v32;
  _BYTE *v33;
  unsigned __int16 v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  _BYTE *v40;
  uint64_t v41;
  unsigned __int16 v42;
  int v43;
  int v44;
  NSObject *v45;
  int v46;
  NSObject *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  NSObject *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  int Domains;
  uint64_t v64;
  NSObject *v65;
  os_log_type_t v66;
  const char *v67;
  uint32_t v68;
  int v69;
  NSObject *v70;
  int v71;
  int v72;
  int v73;
  uint64_t v74;
  NSObject *v75;
  os_log_type_t v76;
  const char *v77;
  uint32_t v78;
  uint64_t v79;
  int v80;
  uint64_t v81;
  NSObject *v82;
  os_log_type_t v83;
  const char *v84;
  uint32_t v85;
  int v86;
  NSObject *v87;
  int v88;
  int v89;
  int v90;
  unsigned int v91;
  uint8_t buf[4];
  _BYTE v93[10];
  __int128 v94;
  _BYTE v95[10];
  _BYTE v96[6];
  uint64_t v97;

  for (i = SearchList; i; i = *(_QWORD *)i)
    *(_DWORD *)(i + 264) |= 1u;
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"uDNS_SetupWABQueries", 5489);
  if (!mDNSPlatformSetDNSConfig(0, 1, 0, 0, 0, 0))
  {
    for (j = SearchList; j; j = *(_QWORD *)j)
      *(_DWORD *)(j + 264) &= ~1u;
    v2 = mDNSLogCategory_State;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "uDNS_SetupWABQueries: No config change", buf, 2u);
    }
  }
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"uDNS_SetupWABQueries", 5499);
  v3 = DWORD2(xmmword_10015C720) != 0;
  if (HIDWORD(xmmword_10015C720))
    v3 |= 2u;
  if (dword_10015C730)
    v4 = v3 | 4;
  else
    v4 = v3;
  v5 = SearchList;
  if (SearchList)
  {
    v6 = &SearchList;
    v91 = v4;
    do
    {
      v7 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(v5 + 8));
      v8 = mDNSLogCategory_State;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
      {
        v9 = *(_DWORD *)(v5 + 264);
        v10 = *(_QWORD *)(v5 + 272);
        for (k = (_BYTE *)(v5 + 8); ; k += v12 + 1)
        {
          if ((unint64_t)k >= v5 + 264 || !k || (v12 = *k, v12 > 0x3F))
          {
            v13 = 257;
            goto LABEL_24;
          }
          if (!*k)
            break;
        }
        v13 = (_WORD)k - (v5 + 8) + 1;
LABEL_24:
        *(_DWORD *)buf = 67110402;
        *(_DWORD *)v93 = v4;
        *(_WORD *)&v93[4] = 1024;
        *(_DWORD *)&v93[6] = v9;
        LOWORD(v94) = 2048;
        *(_QWORD *)((char *)&v94 + 2) = v10;
        WORD5(v94) = 1040;
        HIDWORD(v94) = v13;
        *(_WORD *)v95 = 2098;
        *(_QWORD *)&v95[2] = v5 + 8;
        *(_WORD *)v96 = 1024;
        *(_DWORD *)&v96[2] = v7;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "uDNS_SetupWABQueries -- action: 0x%x, flags: 0x%x, ifid: %p, domain: %{public, mdnsresponder:domain_name}.*P (%x)", buf, 0x2Eu);
      }
      v14 = *(_DWORD *)(v5 + 264);
      if ((v14 & 1) != 0)
      {
        v23 = *(_QWORD **)(v5 + 3768);
        *(_QWORD *)(v5 + 3768) = 0;
        *v6 = *(_QWORD *)v5;
        if ((v14 & 2) != 0
          && !SameDomainNameBytes((_BYTE *)(v5 + 8), "\x05local")
          && !*(_QWORD *)(v5 + 272))
        {
          v24 = v7;
          v25 = mDNSLogCategory_State;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 67109120;
            *(_DWORD *)v93 = v24;
            _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "uDNS_SetupWABQueries: DELETE Browse for domain -- name hash: %x", buf, 8u);
          }
          mDNS_StopQuery((unsigned int *)mDNSStorage, v5 + 280);
          mDNS_StopQuery((unsigned int *)mDNSStorage, v5 + 976);
          v7 = v24;
        }
        if ((*(_BYTE *)(v5 + 264) & 4) != 0
          && !SameDomainNameBytes((_BYTE *)(v5 + 8), "\x05local")
          && !*(_QWORD *)(v5 + 272))
        {
          v26 = v7;
          v27 = mDNSLogCategory_State;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 67109120;
            *(_DWORD *)v93 = v26;
            _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "uDNS_SetupWABQueries: DELETE Legacy Browse for domain -- name hash: %x", buf, 8u);
          }
          mDNS_StopQuery((unsigned int *)mDNSStorage, v5 + 1672);
          v7 = v26;
        }
        if ((*(_BYTE *)(v5 + 264) & 8) != 0
          && !SameDomainNameBytes((_BYTE *)(v5 + 8), "\x05local")
          && !*(_QWORD *)(v5 + 272))
        {
          v28 = v7;
          v29 = mDNSLogCategory_State;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 67109120;
            *(_DWORD *)v93 = v28;
            _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "uDNS_SetupWABQueries: DELETE Registration for domain -- name hash: %x", buf, 8u);
          }
          mDNS_StopQuery((unsigned int *)mDNSStorage, v5 + 2368);
          mDNS_StopQuery((unsigned int *)mDNSStorage, v5 + 3064);
        }
        free((void *)v5);
        if (!v23)
        {
LABEL_81:
          v5 = (uint64_t)v6;
          v4 = v91;
          goto LABEL_146;
        }
        while (2)
        {
          v30 = v23;
          v23 = (_QWORD *)*v23;
          v31 = mDNSLogCategory_State;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
          {
            v32 = v30[6];
            if (v32)
            {
              v33 = (_BYTE *)v30[6];
              if (v32 == -256)
                goto LABEL_58;
LABEL_55:
              v34 = 257;
              if ((unint64_t)v33 < v32 + 256 && v33)
              {
                while (1)
                {
                  v35 = *v33;
                  if (v35 > 0x3F)
                  {
LABEL_64:
                    v34 = 257;
                    goto LABEL_66;
                  }
                  if (!*v33)
                    break;
                  v33 += v35 + 1;
                  if (v32 != -256)
                    goto LABEL_55;
LABEL_58:
                  if (!v33)
                    goto LABEL_64;
                }
                v34 = (_WORD)v33 - v32 + 1;
              }
LABEL_66:
              v36 = v34;
            }
            else
            {
              v36 = 0;
            }
            v37 = v30[7];
            v38 = v37 + 4;
            v39 = v37 + 260;
            v40 = (_BYTE *)(v37 + 4);
            if (v39)
            {
LABEL_68:
              if ((unint64_t)v40 < v39)
                goto LABEL_69;
            }
            else
            {
LABEL_69:
              while (v40)
              {
                v41 = *v40;
                if (v41 > 0x3F)
                  break;
                if (!*v40)
                {
                  v42 = (_WORD)v40 - v38 + 1;
                  goto LABEL_76;
                }
                v40 += v41 + 1;
                if (v39)
                  goto LABEL_68;
              }
            }
            v42 = 257;
LABEL_76:
            *(_DWORD *)buf = 141559299;
            *(_QWORD *)v93 = 1752392040;
            *(_WORD *)&v93[8] = 1040;
            LODWORD(v94) = v36;
            WORD2(v94) = 2101;
            *(_QWORD *)((char *)&v94 + 6) = v32;
            HIWORD(v94) = 2160;
            *(_QWORD *)v95 = 1752392040;
            *(_WORD *)&v95[8] = 1040;
            *(_DWORD *)v96 = v42;
            *(_WORD *)&v96[4] = 2101;
            v97 = v38;
            _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "uDNS_SetupWABQueries: DELETE Deregistering PTR -- record: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P PTR %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", buf, 0x36u);
          }
          v43 = mDNS_Deregister((unsigned int *)mDNSStorage, (uint64_t)(v30 + 1));
          if (v43)
          {
            v44 = v43;
            v45 = mDNSLogCategory_State;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 67109120;
              *(_DWORD *)v93 = v44;
              _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, "uDNS_SetupWABQueries: mDNS_Deregister returned error -- error: %d", buf, 8u);
            }
          }
          if (!v23)
            goto LABEL_81;
          continue;
        }
      }
      if ((v4 & 1) != 0 || (v14 & 2) == 0)
      {
        if ((v4 & 2) == 0 && (v14 & 4) != 0)
        {
LABEL_88:
          if (!SameDomainNameBytes((_BYTE *)(v5 + 8), "\x05local") && !*(_QWORD *)(v5 + 272))
          {
            v46 = v7;
            v47 = mDNSLogCategory_State;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 67109120;
              *(_DWORD *)v93 = v46;
              _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "uDNS_SetupWABQueries: Deleting Legacy Browse for domain -- name hash: %x", buf, 8u);
            }
            *(_DWORD *)(v5 + 264) &= ~4u;
            uDNS_DeleteWABQueries(v5, 2, v48, v49, v50, v51, v52, v53, v89);
            v7 = v46;
          }
          goto LABEL_93;
        }
        if (v4 > 3 || (v14 & 8) == 0)
          goto LABEL_100;
      }
      else if (!SameDomainNameBytes((_BYTE *)(v5 + 8), "\x05local") && !*(_QWORD *)(v5 + 272))
      {
        v15 = v7;
        v16 = mDNSLogCategory_State;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)v93 = v15;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "uDNS_SetupWABQueries: Deleting Browse for domain -- name hash: %x", buf, 8u);
        }
        *(_DWORD *)(v5 + 264) &= ~2u;
        uDNS_DeleteWABQueries(v5, 1, v17, v18, v19, v20, v21, v22, v89);
        v7 = v15;
      }
      if ((v4 & 2) == 0 && (*(_BYTE *)(v5 + 264) & 4) != 0)
        goto LABEL_88;
LABEL_93:
      if (v4 <= 3
        && (*(_BYTE *)(v5 + 264) & 8) != 0
        && !SameDomainNameBytes((_BYTE *)(v5 + 8), "\x05local")
        && !*(_QWORD *)(v5 + 272))
      {
        v54 = v7;
        v55 = mDNSLogCategory_State;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)v93 = v54;
          _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "uDNS_SetupWABQueries: Deleting Registration for domain -- name hash: %x", buf, 8u);
        }
        *(_DWORD *)(v5 + 264) &= ~8u;
        uDNS_DeleteWABQueries(v5, 4, v56, v57, v58, v59, v60, v61, v89);
        v7 = v54;
      }
LABEL_100:
      v62 = v7;
      if ((v4 & 1) == 0
        || (*(_BYTE *)(v5 + 264) & 2) != 0
        || SameDomainNameBytes((_BYTE *)(v5 + 8), "\x05local")
        || *(_QWORD *)(v5 + 272))
      {
        goto LABEL_114;
      }
      Domains = mDNS_GetDomains(v5 + 280, 0, (char *)(v5 + 8), 0, (uint64_t)FoundDomain, v5);
      v64 = mDNSLogCategory_State;
      if (Domains)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_ERROR))
          goto LABEL_110;
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)v93 = v62;
        *(_WORD *)&v93[4] = 1024;
        *(_DWORD *)&v93[6] = Domains;
        v65 = v64;
        v66 = OS_LOG_TYPE_ERROR;
        v67 = "uDNS_SetupWABQueries: GetDomains(mDNS_DomainTypeBrowse) returned error -- name hash: %x, error: %d";
        v68 = 14;
      }
      else
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
          goto LABEL_110;
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)v93 = v62;
        v65 = v64;
        v66 = OS_LOG_TYPE_DEFAULT;
        v67 = "uDNS_SetupWABQueries: Starting Browse for domain -- name hash: %x";
        v68 = 8;
      }
      _os_log_impl((void *)&_mh_execute_header, v65, v66, v67, buf, v68);
LABEL_110:
      v90 = Domains;
      v69 = mDNS_GetDomains(v5 + 976, 1, (char *)(v5 + 8), *(_QWORD *)(v5 + 272), (uint64_t)FoundDomain, v5);
      v70 = mDNSLogCategory_State;
      if (v69)
      {
        v71 = v69;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)v93 = v62;
          *(_WORD *)&v93[4] = 1024;
          *(_DWORD *)&v93[6] = v71;
          _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_ERROR, "uDNS_SetupWABQueries: GetDomains(mDNS_DomainTypeBrowseDefault) returned error -- name hash: %x, error: %d", buf, 0xEu);
        }
        if (v90)
        {
LABEL_114:
          if ((v4 & 2) == 0)
            goto LABEL_128;
          goto LABEL_115;
        }
      }
      else if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)v93 = v62;
        _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "uDNS_SetupWABQueries: Starting Default Browse for domain -- name hash: %x", buf, 8u);
      }
      *(_DWORD *)(v5 + 264) |= 2u;
      if ((v4 & 2) == 0)
        goto LABEL_128;
LABEL_115:
      if ((*(_BYTE *)(v5 + 264) & 4) == 0
        && !SameDomainNameBytes((_BYTE *)(v5 + 8), "\x05local")
        && !*(_QWORD *)(v5 + 272))
      {
        v72 = mDNS_GetDomains(v5 + 1672, 2, (char *)(v5 + 8), 0, (uint64_t)FoundDomain, v5);
        if (v72)
        {
          v73 = v72;
          v74 = mDNSLogCategory_State;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 67109376;
            *(_DWORD *)v93 = v62;
            *(_WORD *)&v93[4] = 1024;
            *(_DWORD *)&v93[6] = v73;
            v75 = v74;
            v76 = OS_LOG_TYPE_ERROR;
            v77 = "uDNS_SetupWABQueries: GetDomains(mDNS_DomainTypeBrowseAutomatic) returned error -- name hash: %x, error: %d";
            v78 = 14;
LABEL_127:
            _os_log_impl((void *)&_mh_execute_header, v75, v76, v77, buf, v78);
          }
        }
        else
        {
          *(_DWORD *)(v5 + 264) |= 4u;
          v79 = mDNSLogCategory_State;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 67109120;
            *(_DWORD *)v93 = v62;
            v75 = v79;
            v76 = OS_LOG_TYPE_DEFAULT;
            v77 = "uDNS_SetupWABQueries: Starting Legacy Browse for domain -- name hash: %x";
            v78 = 8;
            goto LABEL_127;
          }
        }
      }
LABEL_128:
      if (v4 < 4
        || (*(_BYTE *)(v5 + 264) & 8) != 0
        || SameDomainNameBytes((_BYTE *)(v5 + 8), "\x05local")
        || *(_QWORD *)(v5 + 272))
      {
        goto LABEL_146;
      }
      v80 = mDNS_GetDomains(v5 + 2368, 3, (char *)(v5 + 8), 0, (uint64_t)FoundDomain, v5);
      v81 = mDNSLogCategory_State;
      if (v80)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)v93 = v62;
          *(_WORD *)&v93[4] = 1024;
          *(_DWORD *)&v93[6] = v80;
          v82 = v81;
          v83 = OS_LOG_TYPE_ERROR;
          v84 = "uDNS_SetupWABQueries: GetDomains(mDNS_DomainTypeRegistration) returned error -- name hash: %x, error: %d";
          v85 = 14;
LABEL_137:
          _os_log_impl((void *)&_mh_execute_header, v82, v83, v84, buf, v85);
        }
      }
      else if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)v93 = v62;
        v82 = v81;
        v83 = OS_LOG_TYPE_DEFAULT;
        v84 = "uDNS_SetupWABQueries: Starting Registration for domain -- name hash: %x";
        v85 = 8;
        goto LABEL_137;
      }
      v86 = mDNS_GetDomains(v5 + 3064, 4, (char *)(v5 + 8), *(_QWORD *)(v5 + 272), (uint64_t)FoundDomain, v5);
      v87 = mDNSLogCategory_State;
      if (v86)
      {
        v88 = v86;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)v93 = v62;
          *(_WORD *)&v93[4] = 1024;
          *(_DWORD *)&v93[6] = v88;
          _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_ERROR, "uDNS_SetupWABQueries: GetDomains(mDNS_DomainTypeRegistrationDefault) returned error -- name hash: %x, error: %d", buf, 0xEu);
        }
        if (v80)
          goto LABEL_146;
      }
      else if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)v93 = v62;
        _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_DEFAULT, "uDNS_SetupWABQueries: Starting Default Registration for domain -- name hash: %x", buf, 8u);
      }
      *(_DWORD *)(v5 + 264) |= 8u;
LABEL_146:
      v6 = (uint64_t *)v5;
      v5 = *(_QWORD *)v5;
    }
    while (v5);
  }
}

void uDNS_DeleteWABQueries(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  char v10;
  uint64_t v11;
  char *v12;
  char **v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned __int8 *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD *i;
  int v35;
  _OWORD v36[16];
  _OWORD v37[16];

  switch(a2)
  {
    case 4:
      mDNS_StopQuery((unsigned int *)mDNSStorage, a1 + 2368);
      v10 = 0;
      v11 = a1 + 3064;
      v12 = "dr._dns-sd._udp.";
      v13 = off_10013BE58;
      break;
    case 2:
      v12 = 0;
      v11 = a1 + 1672;
      v10 = 1;
      v13 = off_10013BE50;
      break;
    case 1:
      mDNS_StopQuery((unsigned int *)mDNSStorage, a1 + 280);
      v10 = 0;
      v11 = a1 + 976;
      v12 = "db._dns-sd._udp.";
      v13 = mDNS_DomainTypeNames;
      break;
    default:
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_DeleteWABQueries: ERROR!! returning from default", a4, a5, a6, a7, a8, a9);
      return;
  }
  mDNS_StopQuery((unsigned int *)mDNSStorage, v11);
  memset(v37, 0, sizeof(v37));
  memset(v36, 0, sizeof(v36));
  v20 = (unsigned __int8 *)*v13;
  if (v20)
  {
    AppendDNSNameString(v37, v20, v14, v15, v16, v17, v18, v19);
    AppendDNSNameString(v37, "local", v21, v22, v23, v24, v25, v26);
  }
  v27 = (_QWORD *)(a1 + 3768);
  if ((v10 & 1) == 0)
  {
    LOBYTE(v36[0]) = 0;
    AppendDNSNameString(v36, (unsigned __int8 *)v12, v14, v15, v16, v17, v18, v19);
    AppendDNSNameString(v36, "local", v28, v29, v30, v31, v32, v33);
  }
  for (i = (_QWORD *)*v27; *v27; i = (_QWORD *)*v27)
  {
    if (v20 && SameDomainNameBytes((_BYTE *)i + 660, v37)
      || (v10 & 1) == 0 && SameDomainNameBytes((_BYTE *)i + 660, v36))
    {
      if (mDNS_LoggingEnabled == 1)
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_DeleteWABQueries: Deregistering PTR %##s -> %##s", v15, v16, v17, v18, v19, i[6]);
      *v27 = *i;
      v35 = mDNS_Deregister((unsigned int *)mDNSStorage, (uint64_t)(i + 1));
      if (v35)
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_DeleteWABQueries:: ERROR!! mDNS_Deregister returned %d", v15, v16, v17, v18, v19, v35);
    }
    else
    {
      if (mDNS_LoggingEnabled == 1)
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_DeleteWABQueries: Skipping PTR %##s -> %##s", v15, v16, v17, v18, v19, i[6]);
      v27 = (_QWORD *)*v27;
    }
  }
}

void FoundDomain(uint64_t a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v10;
  int v11;
  uint64_t v13;
  char **v14;
  unsigned __int8 *v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  const void *v38;
  unint64_t v39;
  _BYTE *v40;
  uint64_t v41;
  unsigned __int8 *v42;
  unsigned __int8 *v43;
  int v44;
  unsigned __int8 *v45;
  NSObject *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unsigned __int16 v58;
  NSObject *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  int v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;

  if (*((_WORD *)a3 + 2) == 12 && *a3 != 240)
  {
    v10 = *((_QWORD *)a3 + 3);
    if (v10 != -2)
    {
      v11 = a4;
      v13 = *(_QWORD *)(a2 + 176);
      if (v13 + 280 == a2)
      {
        v14 = mDNS_DomainTypeNames;
      }
      else if (v13 + 976 == a2)
      {
        v14 = off_10013BE48;
      }
      else if (v13 + 1672 == a2)
      {
        v14 = off_10013BE50;
      }
      else if (v13 + 2368 == a2)
      {
        v14 = off_10013BE58;
      }
      else
      {
        if (v13 + 3064 != a2)
        {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "FoundDomain - unknown question", a4, a5, a6, a7, a8, a9);
          return;
        }
        v14 = &off_10013BE60;
      }
      v15 = (unsigned __int8 *)*v14;
      if (mDNS_LoggingEnabled == 1)
      {
        v16 = mDNSLogCategory_Default;
        GetRRDisplayString_rdb(a3, (unsigned __int16 *)(*((_QWORD *)a3 + 5) + 4), (_BYTE *)(a1 + 47032));
        LogMsgWithLevel(v16, OS_LOG_TYPE_DEFAULT, "FoundDomain: %p %s %s Q %##s A %s", v17, v18, v19, v20, v21, v10);
      }
      if (v11)
      {
        v22 = malloc_type_calloc(1uLL, 0x4A0uLL, 0xF1748037uLL);
        if (v22)
        {
          v23 = v22;
          v24 = (uint64_t)(v22 + 1);
          mDNS_SetupResourceRecord((uint64_t)(v22 + 1), 0, -2, 12, 0x1C20u, 8, 4, (uint64_t)FreeARElemCallback, (uint64_t)v22);
          *((_BYTE *)v23 + 660) = 0;
          AppendDNSNameString((_BYTE *)v23 + 660, v15, v25, v26, v27, v28, v29, v30);
          AppendDNSNameString((_BYTE *)v23 + 660, "local", v31, v32, v33, v34, v35, v36);
          v37 = *((_QWORD *)a3 + 5);
          v38 = (const void *)(v37 + 4);
          v39 = v37 + 260;
          v40 = (_BYTE *)(v37 + 4);
          if (v39)
          {
LABEL_20:
            if ((unint64_t)v40 < v39)
              goto LABEL_21;
          }
          else
          {
LABEL_21:
            while (v40)
            {
              v41 = *v40;
              if (v41 > 0x3F)
                break;
              if (!*v40)
              {
                v58 = (_WORD)v40 - (_WORD)v38 + 1;
                if (v58 > 0x100u)
                  break;
                memcpy((void *)(v23[7] + 4), v38, v58);
                goto LABEL_39;
              }
              v40 += v41 + 1;
              if (v39)
                goto LABEL_20;
            }
          }
          *(_BYTE *)(v23[7] + 4) = 0;
LABEL_39:
          if (mDNS_LoggingEnabled == 1)
          {
            v59 = mDNSLogCategory_Default;
            GetRRDisplayString_rdb((unsigned __int8 *)v23 + 16, (unsigned __int16 *)(v23[7] + 4), (_BYTE *)(a1 + 47032));
            LogMsgWithLevel(v59, OS_LOG_TYPE_DEFAULT, "FoundDomain: Registering %s", v60, v61, v62, v63, v64, a1 + 47032);
          }
          v65 = mDNS_Register((unsigned int *)a1, v24);
          if (v65)
          {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: FoundDomain - mDNS_Register returned %d", v66, v67, v68, v69, v70, v65);
            free(v23);
          }
          else
          {
            *v23 = *(_QWORD *)(v13 + 3768);
            *(_QWORD *)(v13 + 3768) = v23;
          }
        }
        else
        {
          __break(1u);
        }
      }
      else
      {
        v42 = *(unsigned __int8 **)(v13 + 3768);
        if (v42)
        {
          v43 = (unsigned __int8 *)(v13 + 3768);
          do
          {
            v44 = SameDomainNameBytes((_BYTE *)(*((_QWORD *)v42 + 7) + 4), (_BYTE *)(*((_QWORD *)a3 + 5) + 4));
            v45 = *(unsigned __int8 **)v43;
            if (v44)
            {
              *(_QWORD *)v43 = *(_QWORD *)v45;
              if (mDNS_LoggingEnabled == 1)
              {
                v46 = mDNSLogCategory_Default;
                GetRRDisplayString_rdb(v45 + 16, (unsigned __int16 *)(*((_QWORD *)v45 + 7) + 4), (_BYTE *)(a1 + 47032));
                LogMsgWithLevel(v46, OS_LOG_TYPE_DEFAULT, "FoundDomain: Deregistering %s", v47, v48, v49, v50, v51, a1 + 47032);
              }
              v52 = mDNS_Deregister((unsigned int *)a1, (uint64_t)(v45 + 8));
              if (v52)
                LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: FoundDomain - mDNS_Deregister returned %d", v53, v54, v55, v56, v57, v52);
            }
            else
            {
              v43 = *(unsigned __int8 **)v43;
            }
            v42 = *(unsigned __int8 **)v43;
          }
          while (*(_QWORD *)v43);
        }
      }
    }
  }
}

void FreeARElemCallback(uint64_t a1, uint64_t a2, int a3)
{
  void *v3;

  if (a3 == -65792)
  {
    v3 = *(void **)(a2 + 112);
    if (v3)
      free(v3);
  }
}

void uDNS_StartWABQueries(char a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  int v10;
  int v11;

  if ((a1 & 1) != 0)
  {
    v9 = ++DWORD2(xmmword_10015C720);
    if (mDNS_LoggingEnabled == 1)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_StartWABQueries: Browse query count %d", a4, a5, a6, a7, a8, v9);
  }
  if ((a1 & 2) != 0)
  {
    v10 = ++HIDWORD(xmmword_10015C720);
    if (mDNS_LoggingEnabled == 1)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_StartWABQueries: Legacy Browse query count %d", a4, a5, a6, a7, a8, v10);
  }
  if ((a1 & 4) != 0)
  {
    v11 = ++dword_10015C730;
    if (mDNS_LoggingEnabled == 1)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_StartWABQueries: Reg query count %d", a4, a5, a6, a7, a8, v11);
  }
  uDNS_SetupWABQueries();
}

void uDNS_StopWABQueries(char a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  int v10;
  int v11;

  if ((a1 & 1) != 0)
  {
    v9 = --DWORD2(xmmword_10015C720);
    if (mDNS_LoggingEnabled == 1)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_StopWABQueries: Browse query count %d", a4, a5, a6, a7, a8, v9);
  }
  if ((a1 & 2) != 0)
  {
    v10 = --HIDWORD(xmmword_10015C720);
    if (mDNS_LoggingEnabled == 1)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_StopWABQueries: Legacy Browse query count %d", a4, a5, a6, a7, a8, v10);
  }
  if ((a1 & 4) != 0)
  {
    v11 = --dword_10015C730;
    if (mDNS_LoggingEnabled == 1)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "uDNS_StopWABQueries: Reg query count %d", a4, a5, a6, a7, a8, v11);
  }
  uDNS_SetupWABQueries();
}

uint64_t FlushAddressCacheRecords(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v8;
  uint64_t v9;
  _BYTE *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v21;
  uint8_t buf[4];
  uint64_t v23;
  __int16 v24;
  _BYTE *v25;

  v8 = (unsigned int *)result;
  v9 = 0;
  v10 = (_BYTE *)(result + 47032);
  do
  {
    v21 = v9;
    v11 = *(_QWORD **)&v8[2 * v9 + 68];
    if (v11)
    {
      while (1)
      {
        v12 = v11[2];
        if (v12)
          break;
LABEL_18:
        v11 = (_QWORD *)*v11;
        if (!v11)
          goto LABEL_19;
      }
      while (1)
      {
        if (*(_QWORD *)(v12 + 32))
          goto LABEL_17;
        if (!RRTypeAnswersQuestionType(v12 + 8, 1u, 3, a4, a5, a6, a7, a8))
        {
          result = RRTypeAnswersQuestionType(v12 + 8, 0x1Cu, 3, v13, v14, v15, v16, v17);
          if (!(_DWORD)result)
            goto LABEL_17;
        }
        v18 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_Default != mDNSLogCategory_State)
          break;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          goto LABEL_15;
LABEL_16:
        result = mDNS_PurgeCacheResourceRecord(v8, v12);
LABEL_17:
        v12 = *(_QWORD *)v12;
        if (!v12)
          goto LABEL_18;
      }
      v18 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_16;
LABEL_15:
      GetRRDisplayString_rdb((unsigned __int8 *)(v12 + 8), (unsigned __int16 *)(*(_QWORD *)(v12 + 48) + 4), v10);
      *(_DWORD *)buf = 141558275;
      v23 = 1752392040;
      v24 = 2085;
      v25 = v10;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "FlushAddressCacheRecords: Purging Resourcerecord - record description: %{sensitive, mask.hash}s.", buf, 0x16u);
      goto LABEL_16;
    }
LABEL_19:
    v9 = v21 + 1;
  }
  while (v21 != 498);
  return result;
}

void _mdns_powerlog_awdl_event(uint64_t a1, unsigned __int8 *a2, int a3, unsigned int a4)
{
  __CFDictionary *Mutable;
  int v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  unsigned __int8 *v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  int v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  char *v19;
  size_t v20;
  CFStringRef v21;
  CFStringRef v22;
  const char *v23;
  CFStringRef v24;
  CFStringRef v25;
  CFNumberRef v26;
  CFNumberRef v27;
  CFStringRef v28;
  CFStringRef v29;
  NSObject *v30;
  char __s[1024];
  _OWORD v32[16];

  if (a4)
    goto LABEL_5;
  if (_mdns_powerlog_log_s_once != -1)
    dispatch_once(&_mdns_powerlog_log_s_once, &__block_literal_global_1390);
  if (os_log_type_enabled((os_log_t)_mdns_powerlog_log_s_log, OS_LOG_TYPE_DEBUG))
  {
LABEL_5:
    Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (!Mutable)
      goto LABEL_38;
    if (a2)
    {
      v9 = *a2;
      if (*a2)
      {
        v10 = 0;
        v11 = 0;
        do
        {
          v12 = v11;
          v13 = v10;
          v11 = a2;
          v14 = &a2[v9];
          v15 = v14[1];
          a2 = v14 + 1;
          v9 = v15;
          v10 = v12;
        }
        while (v15);
        bzero(__s, 0x3F1uLL);
        memset(v32, 0, sizeof(v32));
        if (v13)
        {
          if (v12)
          {
            if (v13[1] == 95 && _mdns_label_is_protocol_label((const char *)v12))
            {
              if (DomainNameEqual(v11, "\x05local"))
              {
                v16 = *v13;
                __memcpy_chk(v32, v13, v16 + 1, 256);
                v17 = *v12;
                if ((v16 ^ 0xFFuLL) > v17)
                {
                  v18 = v17 + 1;
                  v19 = (char *)v32 + v16 + 1;
                  memcpy(v19, v12, v17 + 1);
                  if ((char *)v32 - &v19[v18] + 256 >= 1)
                  {
                    v19[v18] = 0;
                    v12 = (unsigned __int8 *)v32;
                    goto LABEL_21;
                  }
                }
              }
            }
          }
        }
        else if (v12 && v12[1] == 95 && _mdns_label_is_protocol_label((const char *)v11))
        {
LABEL_21:
          if (!DomainNameToString(v12, 0, (unsigned __int8 *)__s, 0))
          {
            v20 = strlen(__s);
            if (v20 && __s[v20 - 1] == 46)
              __s[v20 - 1] = 0;
            v21 = CFStringCreateWithCString(0, __s, 0x8000100u);
            if (v21)
            {
              v22 = v21;
              CFDictionarySetValue(Mutable, CFSTR("service"), v21);
              CFRelease(v22);
            }
          }
        }
      }
    }
    memset(__s, 0, 32);
    v23 = DNSRecordTypeValueToString(a3);
    if (!v23)
    {
      v23 = __s;
      snprintf(__s, 0x20uLL, "TYPE%d", a3);
    }
    v24 = CFStringCreateWithCString(0, v23, 0x8000100u);
    if (v24)
    {
      v25 = v24;
      CFDictionarySetValue(Mutable, CFSTR("recordType"), v24);
      CFRelease(v25);
    }
    if ((a4 & 0x80000000) == 0)
    {
      *(_QWORD *)__s = a4;
      v26 = CFNumberCreate(0, kCFNumberLongLongType, __s);
      if (v26)
      {
        v27 = v26;
        CFDictionarySetValue(Mutable, CFSTR("clientPID"), v26);
        CFRelease(v27);
      }
      *(_QWORD *)__s = 0;
      *(_QWORD *)&__s[8] = 0;
      if (a4)
      {
        if (mdns_system_pid_to_name(a4, (uint64_t)__s))
        {
          v28 = CFStringCreateWithCString(0, __s, 0x8000100u);
          if (v28)
          {
            v29 = v28;
            CFDictionarySetValue(Mutable, CFSTR("clientName"), v28);
            CFRelease(v29);
          }
        }
      }
    }
LABEL_38:
    if (_mdns_powerlog_log_s_once != -1)
      dispatch_once(&_mdns_powerlog_log_s_once, &__block_literal_global_1390);
    v30 = _mdns_powerlog_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_powerlog_log_s_log, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)__s = 138412802;
      *(_QWORD *)&__s[4] = a1;
      *(_WORD *)&__s[12] = 1024;
      *(_DWORD *)&__s[14] = a4 == 0;
      *(_WORD *)&__s[18] = 2112;
      *(_QWORD *)&__s[20] = Mutable;
      _os_log_debug_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEBUG, "PowerLog event -- name: %@, exclude: %{mdns:yesno}d, dictionary: %@", (uint8_t *)__s, 0x1Cu);
      if (a4)
      {
LABEL_42:
        if (&_PLLogRegisteredEvent)
          PLLogRegisteredEvent(98, a1, Mutable, 0);
      }
    }
    else if (a4)
    {
      goto LABEL_42;
    }
    if (Mutable)
      CFRelease(Mutable);
  }
}

BOOL _mdns_label_is_protocol_label(const char *a1)
{
  BOOL v2;
  _BOOL8 result;

  if (a1 == "\x04_tcp")
    return 1;
  if (*a1 != 4)
    return a1 == "\x04_udp";
  if (mdns_memcmp_us_ascii_case_insensitive((unsigned __int8 *)a1 + 1, (unsigned __int8 *)"_tcp", 4, 4))
    v2 = a1 == "\x04_udp";
  else
    v2 = 1;
  result = v2;
  if (!v2)
    return mdns_memcmp_us_ascii_case_insensitive((unsigned __int8 *)a1 + 1, (unsigned __int8 *)"_udp", 4, (char)"\x04_udp") == 0;
  return result;
}

void ___mdns_powerlog_log_block_invoke(id a1)
{
  _mdns_powerlog_log_s_log = (uint64_t)os_log_create("com.apple.mdns", "powerlog");
}

__uint64_t _mdns_powerlog_get_monotonic_time_ns()
{
  __uint64_t result;
  int v1;
  NSObject *v2;
  _DWORD v3[2];

  result = clock_gettime_nsec_np(_CLOCK_MONOTONIC_RAW);
  if (!result)
  {
    if (*__error())
    {
      v1 = *__error();
      if (!v1)
        return 0;
    }
    else
    {
      v1 = -6700;
    }
    if (_mdns_powerlog_log_s_once != -1)
      dispatch_once(&_mdns_powerlog_log_s_once, &__block_literal_global_1390);
    v2 = _mdns_powerlog_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_powerlog_log_s_log, OS_LOG_TYPE_FAULT))
    {
      v3[0] = 67109120;
      v3[1] = v1;
      _os_log_fault_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_FAULT, "clock_gettime_nsec_np() returned 0: %{mdns:err}d", (uint8_t *)v3, 8u);
    }
    return 1;
  }
  return result;
}

uint64_t _mdns_powerlog_bonjour_event(uint64_t result, int a2, char *a3, uint64_t a4)
{
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  BOOL v25;
  uint64_t v26;

  if (result <= 0x12)
  {
    if (((1 << result) & 0x12493) != 0)
    {
      v7 = &g_client_info_list;
      v8 = g_client_info_list;
      if (g_client_info_list)
      {
        while (1)
        {
          v9 = v8;
          result = strcasecmp((const char *)(v8 + 72), a3);
          if (!(_DWORD)result)
            break;
          v8 = *(_QWORD *)(v9 + 64);
          if (!v8)
          {
            v7 = (uint64_t *)(v9 + 64);
            goto LABEL_7;
          }
        }
      }
      else
      {
LABEL_7:
        result = (uint64_t)malloc_type_calloc(1uLL, 0x58uLL, 0xF1748037uLL);
        if (!result || !a3)
        {
          __break(1u);
          return result;
        }
        v9 = result;
        v10 = 0;
        v11 = result + 72;
        v12 = 16;
        while (1)
        {
          v13 = a3[v10];
          *(_BYTE *)(v11 + v10) = v13;
          if (!v13)
            break;
          --v12;
          ++v10;
          if (v12 <= 1)
          {
            *(_BYTE *)(v11 + v10) = 0;
            break;
          }
        }
        *v7 = result;
      }
      v14 = v9 + 32;
      if (!a2)
        v14 = v9;
      v15 = *(_DWORD *)(v14 + 16);
      if (v15 != -1)
        *(_DWORD *)(v14 + 16) = v15 + 1;
      v16 = *(_DWORD *)(v14 + 24);
      *(_DWORD *)(v14 + 24) = v16 + 1;
      if (!v16)
        *(_QWORD *)v14 = a4;
    }
    else if (((1 << result) & 0x49248) != 0)
    {
      result = _mdns_powerlog_get_monotonic_time_ns();
      v17 = g_client_info_list;
      if (g_client_info_list)
      {
        v18 = result;
        while (1)
        {
          result = strcasecmp((const char *)(v17 + 72), a3);
          if (!(_DWORD)result)
            break;
          v17 = *(_QWORD *)(v17 + 64);
          if (!v17)
            return result;
        }
        v19 = v17 + 32;
        if (!a2)
          v19 = v17;
        v20 = *(_DWORD *)(v19 + 20);
        if (v20 != -1)
          *(_DWORD *)(v19 + 20) = v20 + 1;
        v21 = *(_DWORD *)(v19 + 24);
        if (v21)
        {
          v22 = v21 - 1;
          *(_DWORD *)(v19 + 24) = v22;
          if (!v22)
          {
            v23 = *(_QWORD *)(v19 + 8);
            v24 = v18 - *(_QWORD *)v19;
            v25 = __CFADD__(v23, v24);
            v26 = v23 + v24;
            if (v25)
              v26 = -1;
            *(_QWORD *)(v19 + 8) = v26;
          }
        }
      }
    }
  }
  return result;
}

void _mdns_powerlog_set_client_stats(__CFDictionary *a1, uint64_t a2, const void *a3, const void *a4, const void *a5, const void *a6)
{
  unint64_t v12;
  unint64_t v13;

  v12 = *(_QWORD *)(a2 + 8);
  if (v12 % 0x3B9ACA00)
    v13 = v12 / 0x3B9ACA00 + 1;
  else
    v13 = v12 / 0x3B9ACA00;
  _mdns_powerlog_event_dictionary_set_int64(a1, a3, v13);
  _mdns_powerlog_event_dictionary_set_int64(a1, a4, *(unsigned int *)(a2 + 16));
  _mdns_powerlog_event_dictionary_set_int64(a1, a5, *(unsigned int *)(a2 + 20));
  _mdns_powerlog_event_dictionary_set_int64(a1, a6, *(unsigned int *)(a2 + 28));
}

void _mdns_powerlog_event_dictionary_set_int64(__CFDictionary *a1, const void *a2, uint64_t a3)
{
  CFNumberRef v5;
  CFNumberRef v6;
  uint64_t valuePtr;

  valuePtr = a3;
  v5 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
  if (v5)
  {
    v6 = v5;
    CFDictionarySetValue(a1, a2, v5);
    CFRelease(v6);
  }
}

char *_mdns_interface_monitor_copy_description(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  NSObject *name;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  int v18;
  char *result;
  char *p_s1;
  char __s1;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  _BYTE v28[31];
  uint64_t v29;

  memset(v28, 0, sizeof(v28));
  v27 = 0u;
  v26 = 0u;
  v25 = 0u;
  v24 = 0u;
  v23 = 0u;
  v22 = 0u;
  p_s1 = &__s1;
  __s1 = 0;
  if (!a2
    || (mdns_snprintf_add(&p_s1, (uint64_t)&v29, "<%s: %p>: ", a4, a5, a6, a7, a8, *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8)) & 0x80000000) == 0)
  {
    if (*(_DWORD *)(a1 + 136))
    {
      name = *(NSObject **)(a1 + 80);
    }
    else
    {
      name = *(NSObject **)(a1 + 128);
      if (name)
        name = nw_interface_get_name(name);
    }
    v10 = "";
    if (name)
      LOBYTE(v10) = (_BYTE)name;
    if ((mdns_snprintf_add(&p_s1, (uint64_t)&v29, "interface %s/%u: ", a4, a5, a6, a7, a8, (char)v10) & 0x80000000) == 0)
    {
      v16 = 0;
      v17 = "";
      while (1)
      {
        if (((uint64_t)(&off_10013B838)[v16 + 1] & *(_DWORD *)(a1 + 144)) != 0)
        {
          v18 = mdns_snprintf_add(&p_s1, (uint64_t)&v29, "%s%s", v11, v12, v13, v14, v15, (char)v17);
          v17 = ", ";
          if (v18 < 0)
            break;
        }
        v16 += 2;
        if (v16 == 14)
        {
          result = strdup(&__s1);
          if (!result)
            __break(1u);
          return result;
        }
      }
    }
  }
  return 0;
}

void _mdns_interface_monitor_finalize(_QWORD *a1)
{
  NSObject *v2;
  void *v3;
  const void *v4;
  const void *v5;
  void *v6;
  void *v7;
  void *v8;

  v2 = a1[4];
  if (v2)
  {
    dispatch_release(v2);
    a1[4] = 0;
  }
  v3 = (void *)a1[5];
  if (v3)
  {
    nw_release(v3);
    a1[5] = 0;
  }
  v4 = (const void *)a1[8];
  if (v4)
  {
    _Block_release(v4);
    a1[8] = 0;
  }
  v5 = (const void *)a1[9];
  if (v5)
  {
    _Block_release(v5);
    a1[9] = 0;
  }
  v6 = (void *)a1[10];
  if (v6)
  {
    free(v6);
    a1[10] = 0;
  }
  v7 = (void *)a1[15];
  if (v7)
  {
    nw_release(v7);
    a1[15] = 0;
  }
  v8 = (void *)a1[16];
  if (v8)
  {
    nw_release(v8);
    a1[16] = 0;
  }
  _mdns_interface_monitor_forget_signatures((uint64_t)a1);
}

void _mdns_interface_monitor_forget_signatures(uint64_t a1)
{
  void *v2;
  void *v3;

  v2 = *(void **)(a1 + 88);
  if (v2)
  {
    free(v2);
    *(_QWORD *)(a1 + 88) = 0;
  }
  *(_QWORD *)(a1 + 96) = 0;
  v3 = *(void **)(a1 + 104);
  if (v3)
  {
    free(v3);
    *(_QWORD *)(a1 + 104) = 0;
  }
  *(_QWORD *)(a1 + 112) = 0;
  *(_WORD *)(a1 + 152) = 0;
}

uint64_t mdns_interface_monitor_create(unsigned int a1)
{
  uint64_t v2;
  uint64_t v3;
  _UNKNOWN **v4;
  void (*v5)(uint64_t);
  char *v6;
  uint64_t v7;
  NSObject *v8;
  NSObject *v9;
  NSObject *v10;
  uint64_t evaluator_for_endpoint;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  NSObject *v15;
  void *v16;
  NSObject *v18;
  NSObject *v19;
  NSObject *v20;
  const char *v21;
  int v22;
  _QWORD v23[5];
  uint8_t buf[4];
  int v25;

  v2 = _os_object_alloc(OS_mdns_interface_monitor, 160);
  v3 = v2;
  if (!v2)
    return v3;
  v4 = &_mdns_interface_monitor_kind;
  *(_QWORD *)(v2 + 16) = &_mdns_interface_monitor_kind;
  do
  {
    v5 = (void (*)(uint64_t))v4[2];
    if (v5)
      v5(v3);
    v4 = (_UNKNOWN **)*v4;
  }
  while (v4);
  *(_DWORD *)(v3 + 148) = 0;
  *(_DWORD *)(v3 + 136) = a1;
  if (a1)
  {
    v6 = mdns_system_interface_index_to_name(a1);
    *(_QWORD *)(v3 + 80) = v6;
    if (v6)
    {
      v7 = nw_interface_create_with_index(*(unsigned int *)(v3 + 136));
      if (v7)
      {
        v8 = v7;
        v9 = nw_parameters_create();
        if (v9)
        {
          v10 = v9;
          nw_parameters_require_interface(v9, v8);
          evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint(0, v10);
          *(_QWORD *)(v3 + 40) = evaluator_for_endpoint;
          if (evaluator_for_endpoint)
          {
            v12 = nw_path_evaluator_copy_path(evaluator_for_endpoint);
            if (v12)
            {
              v13 = v12;
LABEL_13:
              *(_DWORD *)(v3 + 140) = _mdns_get_interface_flags_from_nw_path(v13, 0);
              goto LABEL_21;
            }
            if (_mdns_ifmon_log_s_once != -1)
              dispatch_once(&_mdns_ifmon_log_s_once, &__block_literal_global_1466);
            v20 = _mdns_ifmon_log_s_log;
            if (!os_log_type_enabled((os_log_t)_mdns_ifmon_log_s_log, OS_LOG_TYPE_ERROR))
            {
LABEL_46:
              os_release((void *)v3);
              v3 = 0;
              v13 = 0;
              if (!v8)
                goto LABEL_23;
              goto LABEL_22;
            }
            *(_WORD *)buf = 0;
            v21 = "Failed to copy path from path evaluator";
          }
          else
          {
            if (_mdns_ifmon_log_s_once != -1)
              dispatch_once(&_mdns_ifmon_log_s_once, &__block_literal_global_1466);
            v20 = _mdns_ifmon_log_s_log;
            if (!os_log_type_enabled((os_log_t)_mdns_ifmon_log_s_log, OS_LOG_TYPE_ERROR))
              goto LABEL_46;
            *(_WORD *)buf = 0;
            v21 = "Failed to create path evaluator";
          }
          _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, v21, buf, 2u);
          goto LABEL_46;
        }
        if (_mdns_ifmon_log_s_once != -1)
          dispatch_once(&_mdns_ifmon_log_s_once, &__block_literal_global_1466);
        v19 = _mdns_ifmon_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_ifmon_log_s_log, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Failed to create params", buf, 2u);
        }
        v10 = 0;
        goto LABEL_46;
      }
      if (_mdns_ifmon_log_s_once != -1)
        dispatch_once(&_mdns_ifmon_log_s_once, &__block_literal_global_1466);
      v18 = _mdns_ifmon_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_ifmon_log_s_log, OS_LOG_TYPE_ERROR))
      {
        v22 = *(_DWORD *)(v3 + 136);
        *(_DWORD *)buf = 67109120;
        v25 = v22;
        _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Failed to create interface for index %u", buf, 8u);
      }
    }
    v10 = 0;
    v8 = 0;
    goto LABEL_46;
  }
  v14 = nw_path_create_evaluator_for_endpoint(0, 0);
  v8 = v14;
  if (v14)
  {
    v13 = nw_path_evaluator_copy_path(v14);
    nw_release(v8);
    if (v13)
    {
      v15 = nw_path_copy_interface(v13);
      v8 = v15;
      if (v15)
      {
        *(_QWORD *)(v3 + 120) = v15;
        nw_retain(v15);
        v16 = *(void **)(v3 + 120);
        *(_QWORD *)(v3 + 128) = v16;
        nw_retain(v16);
        nw_release(v8);
        v10 = 0;
        v8 = 0;
      }
      else
      {
        v10 = 0;
      }
      goto LABEL_13;
    }
    v8 = 0;
  }
  else
  {
    v13 = 0;
  }
  v10 = 0;
LABEL_21:
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 0x40000000;
  v23[2] = __mdns_interface_monitor_create_block_invoke;
  v23[3] = &__block_descriptor_tmp_1471;
  v23[4] = v3;
  os_unfair_lock_lock(&_mdns_nwi_locked_s_lock);
  __mdns_interface_monitor_create_block_invoke((uint64_t)v23);
  os_unfair_lock_unlock(&_mdns_nwi_locked_s_lock);
  *(_DWORD *)(v3 + 144) = *(_DWORD *)(v3 + 140);
  if (v8)
LABEL_22:
    nw_release(v8);
LABEL_23:
  if (v10)
    nw_release(v10);
  if (v13)
    nw_release(v13);
  return v3;
}

uint64_t _mdns_get_interface_flags_from_nw_path(NSObject *a1, int a2)
{
  unsigned int v3;

  v3 = a2 & 0xFFFFFFF0 | nw_path_has_ipv4(a1);
  if (nw_path_has_ipv6(a1))
    v3 |= 2u;
  if (nw_path_is_expensive(a1))
    v3 |= 4u;
  if (nw_path_is_constrained(a1))
    return v3 | 8;
  else
    return v3;
}

uint64_t __mdns_interface_monitor_create_block_invoke(uint64_t a1)
{
  uint64_t v2;
  const char *name;
  NSObject *v4;
  BOOL v5;
  uint64_t ifstate;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 32);
  if (*(_DWORD *)(v2 + 136))
  {
    name = *(const char **)(v2 + 80);
  }
  else
  {
    v4 = *(NSObject **)(v2 + 120);
    if (!v4)
    {
LABEL_10:
      ifstate = 0;
      goto LABEL_11;
    }
    name = nw_interface_get_name(v4);
  }
  if (name)
    v5 = g_nwi_state == 0;
  else
    v5 = 1;
  if (v5)
    goto LABEL_10;
  ifstate = nwi_state_get_ifstate(g_nwi_state, name);
LABEL_11:
  _mdns_interface_monitor_update_signatures_from_nwi_state(*(_QWORD *)(a1 + 32), ifstate);
  result = _mdns_get_interface_flags_from_nwi_state(ifstate, *(_DWORD *)(*(_QWORD *)(a1 + 32) + 140));
  *(_DWORD *)(*(_QWORD *)(a1 + 32) + 140) = result;
  return result;
}

uint64_t _mdns_interface_monitor_update_signatures_from_nwi_state(uint64_t a1, uint64_t a2)
{
  void *signature;
  int v5;
  int updated;
  void *v7;
  int v8;
  _BYTE *v9;
  unsigned int v10;
  uint64_t v11;
  NSObject *v12;
  const char *v14;
  int v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  int v29;
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  int v33;

  v20 = 0;
  if (a2)
  {
    signature = (void *)nwi_ifstate_get_signature(a2, 2, &v20);
    v5 = v20;
  }
  else
  {
    v5 = 0;
    signature = 0;
  }
  updated = _mdns_interface_monitor_update_signature((const void **)(a1 + 88), (_QWORD *)(a1 + 96), (char *)(a1 + 152), signature, v5 & ~(v5 >> 31));
  v20 = 0;
  if (a2)
  {
    v7 = (void *)nwi_ifstate_get_signature(a2, 30, &v20);
    v8 = v20;
  }
  else
  {
    v8 = 0;
    v7 = 0;
  }
  v9 = (_BYTE *)(a1 + 153);
  v10 = _mdns_interface_monitor_update_signature((const void **)(a1 + 104), (_QWORD *)(a1 + 112), (char *)(a1 + 153), v7, v8 & ~(v8 >> 31));
  if ((updated & v10 & 1) != 0)
  {
    v11 = 1;
  }
  else if ((updated & 1) != 0)
  {
    v11 = (v10 & 1) == 0 && *v9 == 0;
  }
  else if (*(_BYTE *)(a1 + 152))
  {
    v11 = 0;
  }
  else
  {
    v11 = v10;
  }
  if (_mdns_ifmon_log_s_once != -1)
    dispatch_once(&_mdns_ifmon_log_s_once, &__block_literal_global_1466);
  v12 = _mdns_ifmon_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_ifmon_log_s_log, OS_LOG_TYPE_DEBUG))
  {
    v14 = *(const char **)(a1 + 80);
    if (!v14)
      v14 = "";
    v15 = *(unsigned __int8 *)(a1 + 152);
    if (*(_BYTE *)(a1 + 152))
      v15 = *(_DWORD *)(a1 + 96);
    v16 = *(_DWORD *)(a1 + 136);
    v17 = *(_QWORD *)(a1 + 88);
    v18 = *v9;
    if (*v9)
      v18 = *(_DWORD *)(a1 + 112);
    v19 = *(_QWORD *)(a1 + 104);
    v20 = 136447746;
    v21 = v14;
    v22 = 1024;
    v23 = v16;
    v24 = 1040;
    v25 = v15;
    v26 = 2096;
    v27 = v17;
    v28 = 1040;
    v29 = v18;
    v30 = 2096;
    v31 = v19;
    v32 = 1024;
    v33 = v11;
    _os_log_debug_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "Signature update -- interface: %{public}s/%u, IPv4: %{mdns:base64}.*P, IPv6: %{mdns:base64}.*P, network changed: %{mdns:yesno}d", (uint8_t *)&v20, 0x38u);
  }
  return v11;
}

uint64_t _mdns_get_interface_flags_from_nwi_state(uint64_t a1, int a2)
{
  uint64_t v2;

  v2 = a2 & 0xFFFFFFCF;
  if (a1)
  {
    LODWORD(v2) = (nwi_ifstate_get_flags() >> 2) & 0x10 | v2;
    if (nwi_ifstate_get_vpn_server(a1))
      return v2 | 0x20;
    else
      return v2;
  }
  return v2;
}

uint64_t _mdns_interface_monitor_update_signature(const void **a1, _QWORD *a2, char *a3, void *__s2, size_t __n)
{
  void *v10;
  uint64_t result;
  uint64_t v12;
  char v13;

  if (!__n)
  {
    v13 = 0;
    if (*a3)
      goto LABEL_10;
    return 0;
  }
  v10 = (void *)*a1;
  if (*a2 == __n && !memcmp(*a1, __s2, __n))
  {
    if (!*a3)
      goto LABEL_8;
    return 0;
  }
  if (v10)
  {
    free(v10);
    *a1 = 0;
  }
  *a2 = 0;
  result = (uint64_t)malloc_type_malloc(__n, 0xA172743EuLL);
  if (result)
  {
    v12 = result;
    memcpy((void *)result, __s2, __n);
    *a1 = (const void *)v12;
    *a2 = __n;
LABEL_8:
    v13 = 1;
LABEL_10:
    *a3 = v13;
    return 1;
  }
  __break(1u);
  return result;
}

void ___mdns_ifmon_log_block_invoke(id a1)
{
  _mdns_ifmon_log_s_log = (uint64_t)os_log_create("com.apple.mdns", "interface_monitor");
}

void _mdns_interface_monitor_activate_async(void *a1)
{
  _QWORD block[5];

  os_retain(a1);
  if (_mdns_internal_queue_s_once != -1)
    dispatch_once(&_mdns_internal_queue_s_once, &__block_literal_global_7);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = ___mdns_interface_monitor_activate_async_block_invoke;
  block[3] = &__block_descriptor_tmp_21_1479;
  block[4] = a1;
  dispatch_async((dispatch_queue_t)_mdns_internal_queue_s_queue, block);
}

void ___mdns_interface_monitor_activate_async_block_invoke(uint64_t a1)
{
  uint64_t v2;
  SCDynamicStoreRef v3;
  int v4;
  CFStringRef NetworkInterface;
  int v6;
  const __CFArray *v7;
  const __CFArray *v8;
  int v9;
  int v10;
  int v11;
  NSObject *v12;
  int v13;
  uint64_t v14;
  int v15;
  NSObject *v16;
  const char *v17;
  int v18;
  dispatch_source_t v19;
  NSObject *v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  nw_path_monitor_t v24;
  NSObject *v25;
  NSObject *v26;
  NSObject *v27;
  uint64_t *v28;
  uint64_t *v29;
  uint64_t v30;
  void *v31;
  const char *notify_key;
  uint32_t v33;
  uint32_t v34;
  NSObject *v35;
  const char *v36;
  NSObject *v37;
  uint32_t v38;
  uint64_t v39;
  NSObject *v40;
  _QWORD cancel_handler[5];
  _QWORD update_handler[5];
  _QWORD v43[5];
  _QWORD v44[5];
  void *values[5];
  __int128 buf;
  void (*v47)(uint64_t);
  void *v48;
  uint64_t v49;
  uint8_t v50[4];
  uint32_t v51;

  v2 = *(_QWORD *)(a1 + 32);
  if (*(_BYTE *)(v2 + 155) || *(_BYTE *)(v2 + 156))
    goto LABEL_68;
  *(_BYTE *)(v2 + 155) = 1;
  if (!_mdns_start_interface_availability_monitoring_s_store)
  {
    v3 = SCDynamicStoreCreate(0, CFSTR("com.apple.mdns.interface-monitor"), (SCDynamicStoreCallBack)_mdns_store_changed, 0);
    if (v3)
      goto LABEL_7;
    if (SCError())
    {
      v4 = SCError();
      if (!v4)
      {
LABEL_7:
        NetworkInterface = SCDynamicStoreKeyCreateNetworkInterface(0, kSCDynamicStoreDomainState);
        if (NetworkInterface)
          goto LABEL_10;
        if (SCError())
        {
          v6 = SCError();
          if (!v6)
          {
LABEL_10:
            values[0] = (void *)NetworkInterface;
            v7 = CFArrayCreate(0, (const void **)values, 1, &kCFTypeArrayCallBacks);
            if (v7)
            {
              v8 = v7;
              if (!SCDynamicStoreSetNotificationKeys(v3, v7, 0))
              {
                if (SCError())
                {
                  v9 = SCError();
                  if (!v9)
                    goto LABEL_14;
                  v15 = v9;
                }
                else
                {
                  v15 = -6700;
                }
                if (_mdns_ifmon_log_s_once != -1)
                  dispatch_once(&_mdns_ifmon_log_s_once, &__block_literal_global_1466);
                v16 = _mdns_ifmon_log_s_log;
                if (!os_log_type_enabled((os_log_t)_mdns_ifmon_log_s_log, OS_LOG_TYPE_ERROR))
                {
LABEL_40:
                  if (!v3)
                    goto LABEL_42;
LABEL_41:
                  CFRelease(v3);
                  goto LABEL_42;
                }
                LODWORD(buf) = 134217984;
                *(_QWORD *)((char *)&buf + 4) = v15;
                v17 = "Failed to set notification keys for interface availability monitoring: %{mdns:err}ld";
LABEL_72:
                _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, v17, (uint8_t *)&buf, 0xCu);
                if (!v3)
                  goto LABEL_42;
                goto LABEL_41;
              }
LABEL_14:
              if (_mdns_internal_queue_s_once != -1)
                dispatch_once(&_mdns_internal_queue_s_once, &__block_literal_global_7);
              if (SCDynamicStoreSetDispatchQueue(v3, (dispatch_queue_t)_mdns_internal_queue_s_queue))
                goto LABEL_19;
              if (SCError())
              {
                v10 = SCError();
                if (!v10)
                {
LABEL_19:
                  _mdns_start_interface_availability_monitoring_s_store = (uint64_t)v3;
LABEL_42:
                  if (NetworkInterface)
                    CFRelease(NetworkInterface);
                  if (v8)
                    CFRelease(v8);
                  goto LABEL_46;
                }
                v18 = v10;
              }
              else
              {
                v18 = -6700;
              }
              if (_mdns_ifmon_log_s_once != -1)
                dispatch_once(&_mdns_ifmon_log_s_once, &__block_literal_global_1466);
              v16 = _mdns_ifmon_log_s_log;
              if (!os_log_type_enabled((os_log_t)_mdns_ifmon_log_s_log, OS_LOG_TYPE_ERROR))
                goto LABEL_40;
              LODWORD(buf) = 134217984;
              *(_QWORD *)((char *)&buf + 4) = v18;
              v17 = "Failed to set dispatch queue for interface availability monitoring: %{mdns:err}ld";
              goto LABEL_72;
            }
            if (_mdns_ifmon_log_s_once != -1)
              dispatch_once(&_mdns_ifmon_log_s_once, &__block_literal_global_1466);
            v39 = _mdns_ifmon_log_s_log;
            if (os_log_type_enabled((os_log_t)_mdns_ifmon_log_s_log, OS_LOG_TYPE_ERROR))
            {
              LOWORD(buf) = 0;
              v36 = "Failed to create notification keys array for interface availability monitoring";
              v37 = v39;
              v38 = 2;
              goto LABEL_70;
            }
            goto LABEL_29;
          }
          v13 = v6;
        }
        else
        {
          v13 = -6700;
        }
        if (_mdns_ifmon_log_s_once != -1)
          dispatch_once(&_mdns_ifmon_log_s_once, &__block_literal_global_1466);
        v14 = _mdns_ifmon_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_ifmon_log_s_log, OS_LOG_TYPE_ERROR))
        {
          LODWORD(buf) = 134217984;
          *(_QWORD *)((char *)&buf + 4) = v13;
          v36 = "Failed to create interfaces state key for interface availability monitoring: %{mdns:err}ld";
          v37 = v14;
          v38 = 12;
LABEL_70:
          _os_log_error_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, v36, (uint8_t *)&buf, v38);
        }
LABEL_29:
        v8 = 0;
        if (!v3)
          goto LABEL_42;
        goto LABEL_41;
      }
      v11 = v4;
    }
    else
    {
      v11 = -6700;
    }
    if (_mdns_ifmon_log_s_once != -1)
      dispatch_once(&_mdns_ifmon_log_s_once, &__block_literal_global_1466);
    v12 = _mdns_ifmon_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_ifmon_log_s_log, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 134217984;
      *(_QWORD *)((char *)&buf + 4) = v11;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Failed to create store for interface availability monitoring: %{mdns:err}ld", (uint8_t *)&buf, 0xCu);
    }
  }
LABEL_46:
  v19 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_data_or, 0, 0, *(dispatch_queue_t *)(v2 + 32));
  *(_QWORD *)(v2 + 56) = v19;
  if (!v19)
  {
LABEL_82:
    _mdns_interface_monitor_terminate((_QWORD *)v2, -6729);
    goto LABEL_68;
  }
  os_retain((void *)v2);
  v20 = *(NSObject **)(v2 + 56);
  *(_QWORD *)&buf = _NSConcreteStackBlock;
  *((_QWORD *)&buf + 1) = 0x40000000;
  v47 = ___mdns_interface_monitor_activate_internal_block_invoke;
  v48 = &__block_descriptor_tmp_22_1486;
  v49 = v2;
  dispatch_source_set_event_handler(v20, &buf);
  v21 = *(NSObject **)(v2 + 56);
  values[0] = _NSConcreteStackBlock;
  values[1] = (void *)0x40000000;
  values[2] = ___mdns_interface_monitor_activate_internal_block_invoke_2;
  values[3] = &__block_descriptor_tmp_23_1487;
  values[4] = (void *)v2;
  dispatch_source_set_cancel_handler(v21, values);
  dispatch_activate(*(dispatch_object_t *)(v2 + 56));
  if (*(_QWORD *)(v2 + 40))
  {
    os_retain((void *)v2);
    v22 = *(_QWORD *)(v2 + 40);
    if (_mdns_internal_queue_s_once != -1)
      dispatch_once(&_mdns_internal_queue_s_once, &__block_literal_global_7);
    v44[0] = _NSConcreteStackBlock;
    v44[1] = 0x40000000;
    v44[2] = ___mdns_interface_monitor_activate_internal_block_invoke_3;
    v44[3] = &__block_descriptor_tmp_25_1488;
    v44[4] = v2;
    nw_path_evaluator_set_update_handler(v22, _mdns_internal_queue_s_queue, v44);
    v23 = *(_QWORD *)(v2 + 40);
    v43[0] = _NSConcreteStackBlock;
    v43[1] = 0x40000000;
    v43[2] = ___mdns_interface_monitor_activate_internal_block_invoke_4;
    v43[3] = &__block_descriptor_tmp_26_1489;
    v43[4] = v2;
    nw_path_evaluator_set_cancel_handler(v23, v43);
    nw_path_evaluator_start(*(_QWORD *)(v2 + 40));
    *(_BYTE *)(v2 + 157) = 1;
  }
  if (*(_DWORD *)(v2 + 136))
    goto LABEL_56;
  v24 = nw_path_monitor_create();
  *(_QWORD *)(v2 + 48) = v24;
  if (!v24)
  {
    if (_mdns_ifmon_log_s_once != -1)
      dispatch_once(&_mdns_ifmon_log_s_once, &__block_literal_global_1466);
    v40 = _mdns_ifmon_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_ifmon_log_s_log, OS_LOG_TYPE_ERROR))
    {
      LOWORD(update_handler[0]) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "Failed to create path monitor", (uint8_t *)update_handler, 2u);
    }
    goto LABEL_82;
  }
  v25 = v24;
  if (_mdns_internal_queue_s_once != -1)
    dispatch_once(&_mdns_internal_queue_s_once, &__block_literal_global_7);
  nw_path_monitor_set_queue(v25, (dispatch_queue_t)_mdns_internal_queue_s_queue);
  os_retain((void *)v2);
  v26 = *(NSObject **)(v2 + 48);
  update_handler[0] = _NSConcreteStackBlock;
  update_handler[1] = 0x40000000;
  update_handler[2] = ___mdns_interface_monitor_activate_internal_block_invoke_27;
  update_handler[3] = &__block_descriptor_tmp_28_1491;
  update_handler[4] = v2;
  nw_path_monitor_set_update_handler(v26, update_handler);
  v27 = *(NSObject **)(v2 + 48);
  cancel_handler[0] = _NSConcreteStackBlock;
  cancel_handler[1] = 0x40000000;
  cancel_handler[2] = ___mdns_interface_monitor_activate_internal_block_invoke_2_29;
  cancel_handler[3] = &__block_descriptor_tmp_30;
  cancel_handler[4] = v2;
  nw_path_monitor_set_cancel_handler(v27, cancel_handler);
  nw_path_monitor_start(*(nw_path_monitor_t *)(v2 + 48));
  *(_BYTE *)(v2 + 157) = 1;
LABEL_56:
  v28 = &g_monitor_list;
  do
  {
    v29 = v28;
    v30 = *v28;
    v28 = (uint64_t *)(*v28 + 24);
  }
  while (v30);
  v31 = os_retain((void *)v2);
  *v29 = v2;
  if (_mdns_start_nwi_state_monitoring_s_nwi_notify_token == -1)
  {
    notify_key = (const char *)nwi_state_get_notify_key(v31);
    if (_mdns_internal_queue_s_once != -1)
      dispatch_once(&_mdns_internal_queue_s_once, &__block_literal_global_7);
    v33 = notify_register_dispatch(notify_key, &_mdns_start_nwi_state_monitoring_s_nwi_notify_token, (dispatch_queue_t)_mdns_internal_queue_s_queue, &__block_literal_global_37);
    if (_mdns_start_nwi_state_monitoring_s_nwi_notify_token == -1)
    {
      v34 = v33;
      if (_mdns_nwi_log_s_once != -1)
        dispatch_once(&_mdns_nwi_log_s_once, &__block_literal_global_40);
      v35 = _mdns_nwi_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_nwi_log_s_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v50 = 67109120;
        v51 = v34;
        _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "Failed to register for NWI state notifications (status %u)", v50, 8u);
      }
    }
    else
    {
      _mdns_nwi_state_update();
    }
  }
  _mdns_interface_monitor_check_nwi_state_for_updates(v2);
LABEL_68:
  os_release(*(void **)(a1 + 32));
}

void _mdns_store_changed()
{
  int v0;
  uint64_t i;
  int v2;
  unsigned int v3;
  ifaddrs *v4;
  sockaddr *ifa_addr;
  int v6;
  int v7;
  NSObject *v8;
  ifaddrs *v9;
  uint8_t buf[4];
  uint64_t v11;

  v9 = 0;
  if (getifaddrs(&v9))
  {
    if (*__error())
    {
      v0 = *__error();
      if (!v0)
        goto LABEL_4;
    }
    else
    {
      v0 = -6700;
    }
    if (_mdns_ifmon_log_s_once != -1)
      dispatch_once(&_mdns_ifmon_log_s_once, &__block_literal_global_1466);
    v8 = _mdns_ifmon_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_ifmon_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      v11 = v0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "getifaddrs() failed: %{mdns:err}ld", buf, 0xCu);
    }
    goto LABEL_21;
  }
LABEL_4:
  for (i = g_monitor_list; i; i = *(_QWORD *)(i + 24))
  {
    v2 = *(_DWORD *)(i + 136);
    if (v2)
    {
      v3 = *(_DWORD *)(i + 140);
      v4 = v9;
      if (v9)
      {
        while (1)
        {
          ifa_addr = v4->ifa_addr;
          if (ifa_addr)
          {
            if (ifa_addr->sa_family == 18 && v2 == *(unsigned __int16 *)ifa_addr->sa_data)
              break;
          }
          v4 = v4->ifa_next;
          if (!v4)
            goto LABEL_11;
        }
        v7 = v3 & 0xFFFFFFBF;
        v6 = (v3 >> 6) & 1;
      }
      else
      {
LABEL_11:
        v6 = (*(_DWORD *)(i + 140) & 0x40) == 0;
        v7 = v3 | 0x40;
      }
      _mdns_interface_monitor_trigger_update(i, v7, v6);
    }
  }
LABEL_21:
  if (v9)
    freeifaddrs(v9);
}

void ___mdns_interface_monitor_activate_internal_block_invoke(uint64_t a1)
{
  uint64_t v2;
  unsigned int v3;
  int v4;
  int v5;
  void *v6;
  _QWORD *v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v11[8];
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  char v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  int v23;

  v2 = *(_QWORD *)(a1 + 32);
  v20 = 0;
  v21 = &v20;
  v22 = 0x2000000000;
  v23 = 0;
  v16 = 0;
  v17 = &v16;
  v18 = 0x2000000000;
  v19 = 0;
  v12 = 0;
  v13 = &v12;
  v14 = 0x2000000000;
  v15 = 0;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  v11[2] = ___mdns_interface_monitor_update_block_invoke;
  v11[3] = &unk_10013B990;
  v11[4] = &v20;
  v11[5] = &v16;
  v11[6] = &v12;
  v11[7] = v2;
  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 148));
  ___mdns_interface_monitor_update_block_invoke(v11);
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 148));
  v3 = *(_DWORD *)(v2 + 144);
  v4 = *((_DWORD *)v21 + 6);
  *(_DWORD *)(v2 + 144) = v4;
  v5 = *((unsigned __int8 *)v17 + 24);
  if (*(_DWORD *)(v2 + 136))
  {
    v6 = (void *)v13[3];
    if (!v6)
      goto LABEL_8;
    nw_release(v6);
    v7 = v13 + 3;
  }
  else
  {
    v8 = *(void **)(v2 + 128);
    if (v8)
    {
      nw_release(v8);
      *(_QWORD *)(v2 + 128) = 0;
    }
    v7 = v13 + 3;
    *(_QWORD *)(v2 + 128) = v13[3];
  }
  *v7 = 0;
LABEL_8:
  if (v5)
    v9 = v4 ^ v3 | 0x80;
  else
    v9 = v4 ^ v3;
  _Block_object_dispose(&v12, 8);
  _Block_object_dispose(&v16, 8);
  _Block_object_dispose(&v20, 8);
  if ((_DWORD)v9)
  {
    v10 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 64);
    if (v10)
      (*(void (**)(uint64_t, uint64_t))(v10 + 16))(v10, v9);
  }
}

void ___mdns_interface_monitor_activate_internal_block_invoke_2(uint64_t a1)
{
  os_release(*(void **)(a1 + 32));
}

void ___mdns_interface_monitor_activate_internal_block_invoke_3(uint64_t a1, NSObject *a2)
{
  _mdns_interface_monitor_trigger_update_with_path(*(_QWORD *)(a1 + 32), a2);
}

void ___mdns_interface_monitor_activate_internal_block_invoke_4(uint64_t a1)
{
  os_release(*(void **)(a1 + 32));
}

void ___mdns_interface_monitor_activate_internal_block_invoke_27(uint64_t a1, NSObject *a2)
{
  _mdns_interface_monitor_trigger_update_with_path(*(_QWORD *)(a1 + 32), a2);
}

void ___mdns_interface_monitor_activate_internal_block_invoke_2_29(uint64_t a1)
{
  os_release(*(void **)(a1 + 32));
}

void _mdns_nwi_state_update()
{
  uint64_t v0;
  NSObject *v1;
  uint64_t i;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;

  v0 = nwi_state_copy();
  if (!v0)
  {
    if (_mdns_nwi_log_s_once != -1)
      dispatch_once(&_mdns_nwi_log_s_once, &__block_literal_global_40);
    v1 = _mdns_nwi_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_nwi_log_s_log, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v3) = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "Failed to copy NWI state", (uint8_t *)&v3, 2u);
    }
  }
  v3 = 0;
  v4 = &v3;
  v5 = 0x2000000000;
  v6 = 0;
  os_unfair_lock_lock(&_mdns_nwi_locked_s_lock);
  v4[3] = g_nwi_state;
  g_nwi_state = v0;
  os_unfair_lock_unlock(&_mdns_nwi_locked_s_lock);
  if (v4[3])
    nwi_state_release();
  for (i = g_monitor_list; i; i = *(_QWORD *)(i + 24))
    _mdns_interface_monitor_check_nwi_state_for_updates(i);
  _Block_object_dispose(&v3, 8);
}

void _mdns_interface_monitor_check_nwi_state_for_updates(uint64_t a1)
{
  const char *name;
  NSObject *v3;
  BOOL v4;
  uint64_t ifstate;
  int interface_flags_from_nwi_state;
  int updated;

  if (*(_DWORD *)(a1 + 136))
  {
    name = *(const char **)(a1 + 80);
  }
  else
  {
    v3 = *(NSObject **)(a1 + 120);
    if (!v3)
    {
LABEL_10:
      ifstate = 0;
      goto LABEL_11;
    }
    name = nw_interface_get_name(v3);
  }
  if (name)
    v4 = g_nwi_state == 0;
  else
    v4 = 1;
  if (v4)
    goto LABEL_10;
  ifstate = nwi_state_get_ifstate(g_nwi_state, name);
LABEL_11:
  interface_flags_from_nwi_state = _mdns_get_interface_flags_from_nwi_state(ifstate, *(_DWORD *)(a1 + 140));
  updated = _mdns_interface_monitor_update_signatures_from_nwi_state(a1, ifstate);
  _mdns_interface_monitor_trigger_update(a1, interface_flags_from_nwi_state, updated);
}

void _mdns_interface_monitor_terminate(_QWORD *object, int a2)
{
  NSObject *v4;
  void *v5;
  NSObject *v6;
  void *v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t *v10;
  NSObject *v11;
  _QWORD v12[5];
  int v13;

  v4 = object[7];
  if (v4)
  {
    dispatch_source_cancel((dispatch_source_t)object[7]);
    dispatch_release(v4);
    object[7] = 0;
  }
  v5 = (void *)object[5];
  if (v5)
  {
    if (!*((_BYTE *)object + 157) || (nw_path_evaluator_cancel(), (v5 = (void *)object[5]) != 0))
    {
      nw_release(v5);
      object[5] = 0;
    }
  }
  v6 = object[6];
  if (v6)
  {
    nw_path_monitor_cancel(v6);
    v7 = (void *)object[6];
    if (v7)
    {
      nw_release(v7);
      object[6] = 0;
    }
  }
  v8 = (_QWORD *)g_monitor_list;
  if (g_monitor_list)
  {
    if ((_QWORD *)g_monitor_list == object)
    {
      v10 = &g_monitor_list;
LABEL_16:
      *v10 = object[3];
      object[3] = 0;
      os_release(object);
    }
    else
    {
      while (1)
      {
        v9 = v8;
        v8 = (_QWORD *)v8[3];
        if (!v8)
          break;
        if (v8 == object)
        {
          v10 = v9 + 3;
          goto LABEL_16;
        }
      }
    }
  }
  os_retain(object);
  v11 = object[4];
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000;
  v12[2] = ___mdns_interface_monitor_terminate_block_invoke;
  v12[3] = &__block_descriptor_tmp_42_1493;
  v13 = a2;
  v12[4] = object;
  dispatch_async(v11, v12);
}

void ___mdns_interface_monitor_terminate_block_invoke(uint64_t a1)
{
  uint64_t v2;
  const void **v3;
  void (**v4)(const void *, uint64_t, _QWORD);
  uint64_t v5;

  v2 = *(unsigned int *)(a1 + 40);
  v3 = *(const void ***)(a1 + 32);
  v4 = (void (**)(const void *, uint64_t, _QWORD))v3[9];
  if (v4)
  {
    if ((_DWORD)v2)
      v5 = 1;
    else
      v5 = 2;
    v4[2](v3[9], v5, v2);
    v3 = *(const void ***)(a1 + 32);
  }
  if (!(_DWORD)v2 && v3[9])
  {
    _Block_release(v3[9]);
    v3 = *(const void ***)(a1 + 32);
    v3[9] = 0;
  }
  os_release(v3);
}

void _mdns_interface_monitor_trigger_update(uint64_t a1, int a2, int a3)
{
  os_unfair_lock_s *v7;
  NSObject *v8;

  if (*(_DWORD *)(a1 + 140) != a2 || a3 != 0)
  {
    v7 = (os_unfair_lock_s *)(a1 + 148);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 148));
    *(_DWORD *)(a1 + 140) = a2;
    if (a3)
      *(_BYTE *)(a1 + 158) = 1;
    os_unfair_lock_unlock(v7);
    v8 = *(NSObject **)(a1 + 56);
    if (v8)
      dispatch_source_merge_data(v8, 1uLL);
  }
}

void ___mdns_nwi_log_block_invoke(id a1)
{
  _mdns_nwi_log_s_log = (uint64_t)os_log_create("com.apple.mdns", "NWI");
}

void _mdns_interface_monitor_trigger_update_with_path(uint64_t a1, NSObject *a2)
{
  _DWORD *v4;
  int interface_flags_from_nw_path;
  char v6;
  uint64_t v7;
  uint64_t v8;
  uint32_t index;
  NSObject *v10;
  const char *name;
  BOOL v12;
  uint64_t ifstate;
  NSObject *v14;
  void *v15;
  _QWORD v16[6];
  int v17;
  char v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;

  v19 = 0;
  v20 = &v19;
  v21 = 0x2000000000;
  v22 = 0;
  if (*(_DWORD *)(a1 + 136))
    goto LABEL_2;
  v7 = nw_path_copy_interface(a2);
  v20[3] = v7;
  v8 = *(_QWORD *)(a1 + 120);
  if (!v7)
  {
    v4 = (_DWORD *)(a1 + 140);
    interface_flags_from_nw_path = _mdns_get_interface_flags_from_nw_path(a2, *(_DWORD *)(a1 + 140));
    if (!v8)
      goto LABEL_3;
LABEL_10:
    _mdns_interface_monitor_forget_signatures(a1);
    v10 = v20[3];
    if (!v10 || ((name = nw_interface_get_name(v10)) != 0 ? (v12 = g_nwi_state == 0) : (v12 = 1), v12))
      ifstate = 0;
    else
      ifstate = nwi_state_get_ifstate(g_nwi_state, name);
    _mdns_interface_monitor_update_signatures_from_nwi_state(a1, ifstate);
    interface_flags_from_nw_path = _mdns_get_interface_flags_from_nwi_state(ifstate, interface_flags_from_nw_path);
    v6 = 1;
    goto LABEL_18;
  }
  if (!v8
    || (index = nw_interface_get_index(*(nw_interface_t *)(a1 + 120)),
        index != nw_interface_get_index((nw_interface_t)v20[3])))
  {
    interface_flags_from_nw_path = _mdns_get_interface_flags_from_nw_path(a2, *(_DWORD *)(a1 + 140));
    goto LABEL_10;
  }
LABEL_2:
  v4 = (_DWORD *)(a1 + 140);
  interface_flags_from_nw_path = _mdns_get_interface_flags_from_nw_path(a2, *(_DWORD *)(a1 + 140));
LABEL_3:
  if (*v4 == interface_flags_from_nw_path)
    goto LABEL_20;
  v6 = 0;
LABEL_18:
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 0x40000000;
  v16[2] = ___mdns_interface_monitor_trigger_update_with_path_block_invoke;
  v16[3] = &unk_10013B9B8;
  v17 = interface_flags_from_nw_path;
  v18 = v6;
  v16[4] = &v19;
  v16[5] = a1;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 148));
  ___mdns_interface_monitor_trigger_update_with_path_block_invoke((uint64_t)v16);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 148));
  v14 = *(NSObject **)(a1 + 56);
  if (v14)
    dispatch_source_merge_data(v14, 1uLL);
LABEL_20:
  v15 = (void *)v20[3];
  if (v15)
  {
    nw_release(v15);
    v20[3] = 0;
  }
  _Block_object_dispose(&v19, 8);
}

void ___mdns_interface_monitor_trigger_update_with_path_block_invoke(uint64_t a1)
{
  uint64_t v1;
  void *v3;

  v1 = *(_QWORD *)(a1 + 40);
  *(_DWORD *)(v1 + 140) = *(_DWORD *)(a1 + 48);
  if (*(_BYTE *)(a1 + 52))
  {
    *(_BYTE *)(v1 + 158) = 1;
    v3 = *(void **)(v1 + 120);
    if (v3)
    {
      nw_release(v3);
      *(_QWORD *)(*(_QWORD *)(a1 + 40) + 120) = 0;
      v1 = *(_QWORD *)(a1 + 40);
    }
    *(_QWORD *)(v1 + 120) = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  }
}

void *___mdns_interface_monitor_update_block_invoke(_QWORD *a1)
{
  uint64_t v1;
  void *result;

  *(_DWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = *(_DWORD *)(a1[7] + 140);
  v1 = a1[7];
  *(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24) = *(_BYTE *)(v1 + 158);
  *(_BYTE *)(v1 + 158) = 0;
  *(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 24) = *(_QWORD *)(v1 + 120);
  result = *(void **)(*(_QWORD *)(a1[6] + 8) + 24);
  if (result)
    return nw_retain(result);
  return result;
}

void ___mdns_internal_queue_block_invoke(id a1)
{
  _mdns_internal_queue_s_queue = (uint64_t)dispatch_queue_create("com.apple.mdns.interface-monitor", 0);
}

void mdns_interface_monitor_invalidate(void *a1)
{
  _QWORD block[5];

  os_retain(a1);
  if (_mdns_internal_queue_s_once != -1)
    dispatch_once(&_mdns_internal_queue_s_once, &__block_literal_global_7);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = __mdns_interface_monitor_invalidate_block_invoke;
  block[3] = &__block_descriptor_tmp_2;
  block[4] = a1;
  dispatch_async((dispatch_queue_t)_mdns_internal_queue_s_queue, block);
}

void __mdns_interface_monitor_invalidate_block_invoke(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 156))
  {
    _mdns_interface_monitor_terminate((_QWORD *)v2, 0);
    v2 = *(_QWORD *)(a1 + 32);
    *(_BYTE *)(v2 + 156) = 1;
  }
  os_release((void *)v2);
}

void mdns_interface_monitor_set_queue(uint64_t a1, dispatch_object_t object)
{
  NSObject *v4;

  if (*(_BYTE *)(a1 + 154))
  {
    if (!*(_QWORD *)(a1 + 32))
    {
      *(_QWORD *)(a1 + 32) = object;
      dispatch_retain(object);
      _mdns_interface_monitor_activate_async((void *)a1);
    }
  }
  else
  {
    dispatch_retain(object);
    v4 = *(NSObject **)(a1 + 32);
    if (v4)
      dispatch_release(v4);
    *(_QWORD *)(a1 + 32) = object;
  }
}

void mdns_interface_monitor_set_event_handler(uint64_t a1, void *aBlock)
{
  void *v3;
  const void *v4;

  if (aBlock)
    v3 = _Block_copy(aBlock);
  else
    v3 = 0;
  v4 = *(const void **)(a1 + 72);
  if (v4)
    _Block_release(v4);
  *(_QWORD *)(a1 + 72) = v3;
}

void mdns_interface_monitor_set_update_handler(uint64_t a1, void *aBlock)
{
  void *v3;
  const void *v4;

  if (aBlock)
    v3 = _Block_copy(aBlock);
  else
    v3 = 0;
  v4 = *(const void **)(a1 + 64);
  if (v4)
    _Block_release(v4);
  *(_QWORD *)(a1 + 64) = v3;
}

const char *DNSTypeName(int a1)
{
  const char *v1;

  if (a1 <= 32)
  {
    v1 = "Addr";
    switch(a1)
    {
      case 1:
        return v1;
      case 2:
        v1 = "NS";
        break;
      case 3:
      case 4:
      case 7:
      case 8:
      case 9:
      case 11:
      case 14:
      case 15:
        goto LABEL_33;
      case 5:
        v1 = "CNAME";
        break;
      case 6:
        v1 = "SOA";
        break;
      case 10:
        v1 = "NULL";
        break;
      case 12:
        v1 = "PTR";
        break;
      case 13:
        v1 = "HINFO";
        break;
      case 16:
        v1 = "TXT";
        break;
      default:
        if (a1 != 28)
          goto LABEL_33;
        v1 = "AAAA";
        break;
    }
  }
  else
  {
    if (a1 > 63)
    {
      if (a1 <= 249)
      {
        if (a1 == 64)
          return "SVCB";
        if (a1 == 65)
          return "HTTPS";
      }
      else
      {
        switch(a1)
        {
          case 250:
            return "TSIG";
          case 255:
            return "ANY";
          case 65323:
            return "TSR";
        }
      }
LABEL_33:
      v1 = (const char *)&DNSTypeName_buffer;
      mDNS_snprintf(&DNSTypeName_buffer);
      return v1;
    }
    switch(a1)
    {
      case '!':
        v1 = "SRV";
        break;
      case ')':
        v1 = "OPT";
        break;
      case '+':
        v1 = "DS";
        break;
      case '.':
        v1 = "RRSIG";
        break;
      case '/':
        v1 = "NSEC";
        break;
      case '0':
        v1 = "DNSKEY";
        break;
      case '2':
        v1 = "NSEC3";
        break;
      case '3':
        v1 = "NSEC3PARAM";
        break;
      default:
        goto LABEL_33;
    }
  }
  return v1;
}

_BYTE *GetRRDisplayString_rdb(unsigned __int8 *a1, unsigned __int16 *a2, _BYTE *a3)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  _QWORD *v15;
  _QWORD *v16;
  char *v17;
  unsigned __int16 *v18;
  int v19;
  int v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _BYTE *v25;
  _BYTE *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _BYTE *v35;
  _BYTE *v37;
  int v38;
  int v39;
  char v40;
  uint64_t v41;
  char *v42;
  unsigned int v43;
  char *v44;
  unsigned int v45;
  int v46;
  unsigned __int16 *v47;
  char *v48;
  char *v49;
  unsigned int v50;
  int v51;
  uint64_t v52;
  int v53;
  int v54;
  unsigned int v55;
  uint64_t v56;
  unsigned __int16 *v57;
  unsigned __int16 v58;
  uint64_t v59;
  uint64_t v60;
  char v61;
  unsigned __int8 *v62;
  int v63;
  int v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  unsigned __int8 *v70;
  unsigned int v71;
  uint64_t v72;
  unsigned int v73;
  unsigned __int8 *v74;
  __int16 v75;
  int v76;
  unsigned __int16 *v77;
  _BYTE *v78;
  int v79;
  _BYTE *v80;
  int v81;
  int v82;
  int v83;

  DNSTypeName(*((unsigned __int16 *)a1 + 2));
  v80 = a3;
  v6 = mDNS_snprintf(a3);
  if (*a1 == 240)
    return v80;
  v12 = v6;
  v13 = *((unsigned __int16 *)a1 + 6);
  v14 = *((unsigned __int16 *)a1 + 2);
  if (!*((_WORD *)a1 + 6))
  {
    if (v14 != 41)
    {
      v35 = &v80[v6];
      goto LABEL_32;
    }
LABEL_9:
    v18 = (unsigned __int16 *)((char *)a2 + v13);
    v19 = mDNS_snprintf(&v80[v6]);
    if (v18 <= a2)
      return v80;
    v20 = v19 + v12;
    while (1)
    {
      v21 = *a2;
      if (v21 <= 3)
      {
        if (v21 != 1)
        {
          if (v21 == 2)
            v26 = &v80[v20];
          else
LABEL_25:
            v26 = &v80[v20];
LABEL_26:
          v20 += mDNS_snprintf(v26);
          goto LABEL_27;
        }
        v31 = mDNS_snprintf(&v80[v20]) + v20;
        v32 = mDNS_snprintf(&v80[v31]) + v31;
        v33 = mDNS_snprintf(&v80[v32]) + v32;
        v34 = mDNS_snprintf(&v80[v33]) + v33;
        v24 = mDNS_snprintf(&v80[v34]) + v34;
        v25 = &v80[v24];
      }
      else
      {
        switch(v21)
        {
          case 4u:
            v27 = mDNS_snprintf(&v80[v20]) + v20;
            v28 = mDNS_snprintf(&v80[v27]) + v27;
            v29 = mDNS_snprintf(&v80[v28]) + v28;
            v20 = v29 + mDNS_snprintf(&v80[v29]);
            if (a2[1] < 0xEu)
              goto LABEL_27;
            v20 += mDNS_snprintf(&v80[v20]);
            if (a2[1] < 0xFu)
              goto LABEL_27;
            v26 = &v80[v20];
            goto LABEL_26;
          case 0xFDE9u:
            v30 = mDNS_snprintf(&v80[v20]) + v20;
            v24 = mDNS_snprintf(&v80[v30]) + v30;
            v25 = &v80[v24];
            break;
          case 0xFDEAu:
            v22 = mDNS_snprintf(&v80[v20]) + v20;
            v23 = mDNS_snprintf(&v80[v22]) + v22;
            v24 = mDNS_snprintf(&v80[v23]) + v23;
            v25 = &v80[v24];
            break;
          default:
            goto LABEL_25;
        }
      }
      v20 = mDNS_snprintf(v25) + v24;
LABEL_27:
      a2 += 12;
      if (a2 >= v18)
        return v80;
    }
  }
  if (*((unsigned __int16 *)a1 + 2) <= 0x20u)
  {
    switch(*((_WORD *)a1 + 2))
    {
      case 1:
        v35 = &v80[v6];
        break;
      case 2:
      case 5:
      case 0xC:
        v35 = &v80[v6];
        break;
      case 3:
      case 4:
      case 7:
      case 8:
      case 9:
      case 0xA:
      case 0xB:
      case 0xE:
      case 0xF:
        goto LABEL_116;
      case 6:
        v35 = &v80[v6];
        break;
      case 0xD:
      case 0x10:
        if ((511 - v6) < 5)
          return v80;
        v37 = &v80[v6];
        v38 = (_DWORD)a2 + v13;
        if ((unsigned __int16 *)((char *)a2 + v13) <= a2)
        {
          v39 = 0;
          goto LABEL_151;
        }
        v39 = 0;
        v40 = 1;
        v77 = (unsigned __int16 *)((char *)a2 + v13);
        v78 = &v80[v6];
        while (2)
        {
          v43 = *(unsigned __int8 *)a2;
          v42 = (char *)a2 + 1;
          v41 = v43;
          if (v38 - (int)v42 < v43)
            goto LABEL_151;
          v44 = &v37[v39];
          v45 = 506 - (v12 + v39);
          if ((v40 & 1) != 0)
          {
            v46 = 0;
LABEL_45:
            v47 = (unsigned __int16 *)&v42[v41];
            if (v42 >= &v42[v41])
            {
LABEL_94:
              v40 = 0;
              v39 += v46;
              a2 = v47;
              v38 = (int)v77;
              v37 = v78;
              if (v47 >= v77)
                goto LABEL_151;
              continue;
            }
            while (1)
            {
              v48 = &v42[(_DWORD)v47 - (_DWORD)v42];
              if (v48 > v42)
                break;
LABEL_81:
              v49 = 0;
LABEL_82:
              if (v49)
                v53 = (_DWORD)v49 - (_DWORD)v42;
              else
                v53 = (_DWORD)v47 - (_DWORD)v42;
              if (v53)
              {
                v54 = mDNS_snprintf(&v44[v46]);
                v46 += v54;
                if (v54 != v53)
                  goto LABEL_150;
              }
              if (v49)
              {
                v55 = v45 - v46;
                if ((*v49 & 0xDF) == 0x5C)
                {
                  if (v55 <= 2)
                    goto LABEL_150;
                }
                else if (v55 < 5)
                {
                  goto LABEL_150;
                }
                v46 += mDNS_snprintf(&v44[v46]);
                v48 = v49 + 1;
              }
              v42 = v48;
              if (v48 >= (char *)v47)
                goto LABEL_94;
            }
            v49 = v42;
            while (1)
            {
              v50 = (_DWORD)v47 - (_DWORD)v49;
              if ((_DWORD)v47 == (_DWORD)v49)
                goto LABEL_82;
              v51 = *v49;
              if (v51 < 0)
              {
                if (v50 < 2)
                  goto LABEL_82;
                if ((v51 + 32) >= 0xE2u && v49[1] < -64)
                {
                  v52 = 2;
                  goto LABEL_53;
                }
                if (v50 < 3 || v49[2] > -65)
                  goto LABEL_82;
                if (v51 == -32)
                {
                  if ((v49[1] & 0xE0) == 0xA0)
                    goto LABEL_67;
                }
                else if ((v51 + 31) < 0xC || (v51 & 0xFFFFFFFE) == 0xFFFFFFEE)
                {
                  if (v49[1] <= -65)
                    goto LABEL_67;
                }
                else if (v51 == -19 && v49[1] < -96)
                {
LABEL_67:
                  v52 = 3;
                  goto LABEL_53;
                }
                if (v50 < 4 || v49[3] > -65)
                  goto LABEL_82;
                if (v51 == -16)
                {
                  if ((v49[1] + 64) < 0xD0u)
                    goto LABEL_82;
                }
                else if ((v51 + 12) >= 0xFDu)
                {
                  if (v49[1] > -65)
                    goto LABEL_82;
                }
                else if (v51 != -12 || v49[1] > -113)
                {
                  goto LABEL_82;
                }
                v52 = 4;
              }
              else
              {
                if ((v51 & 0xFFFFFFDF) == 0x5C || (v51 - 32) > 0x5Eu)
                  goto LABEL_82;
                v52 = 1;
              }
LABEL_53:
              v49 += v52;
              if (v49 >= v48)
                goto LABEL_81;
            }
          }
          break;
        }
        if (v45 >= 2)
        {
          v46 = mDNS_snprintf(v44);
          goto LABEL_45;
        }
        v46 = 0;
LABEL_150:
        v39 += v46;
        v37 = v78;
LABEL_151:
        v35 = &v37[v39];
        break;
      default:
        if (v14 == 28)
        {
          v35 = &v80[v6];
          break;
        }
LABEL_116:
        mDNS_snprintf(&v80[v6]);
        v61 = *v80;
        if (*v80)
        {
          v62 = v80 + 1;
          do
          {
            if (v61 <= 31)
              *(v62 - 1) = 46;
            v63 = *v62++;
            v61 = v63;
          }
          while (v63);
        }
        return v80;
    }
LABEL_32:
    mDNS_snprintf(v35);
    return v80;
  }
  switch(*((_WORD *)a1 + 2))
  {
    case ')':
      goto LABEL_9;
    case '*':
    case ',':
    case '-':
      goto LABEL_116;
    case '+':
      v83 = 0;
      v15 = dnssec_obj_rr_ds_create(*((unsigned __int8 **)a1 + 4), *((_WORD *)a1 + 3), (const void *)(*((_QWORD *)a1 + 5) + 4), v13, 0, &v83);
      v16 = v15;
      if (v83)
        goto LABEL_109;
      v17 = dnssec_obj_rr_copy_rdata_rfc_description((uint64_t)v15, &v83);
      if (!v83)
        goto LABEL_128;
      goto LABEL_110;
    case '.':
      v82 = 0;
      v56 = dnssec_obj_rr_rrsig_create(*((unsigned __int8 **)a1 + 4), (const void *)(*((_QWORD *)a1 + 5) + 4), v13, 0, &v82);
      v16 = (_QWORD *)v56;
      if (v82)
        goto LABEL_109;
      v17 = dnssec_obj_rr_copy_rdata_rfc_description(v56, &v82);
      if (!v82)
        goto LABEL_128;
      goto LABEL_110;
    case '/':
      v57 = a2;
      if (a2 != (unsigned __int16 *)-256)
        goto LABEL_100;
      break;
    case '0':
      v81 = 0;
      v60 = dnssec_obj_rr_dnskey_create(*((unsigned __int8 **)a1 + 4), *((_WORD *)a1 + 3), (_BYTE *)(*((_QWORD *)a1 + 5) + 4), v13, &v81);
      v16 = (_QWORD *)v60;
      if (v81)
      {
LABEL_109:
        v17 = 0;
      }
      else
      {
        v17 = dnssec_obj_rr_copy_rdata_rfc_description(v60, &v81);
        if (!v81)
LABEL_128:
          mDNS_snprintf(&v80[v12]);
      }
LABEL_110:
      if (v16)
        ref_count_obj_release(v16);
      if (v17)
        free(v17);
      return v80;
    default:
      if (v14 == 33)
      {
        v35 = &v80[v6];
      }
      else
      {
        if (v14 != 65323)
          goto LABEL_116;
        v35 = &v80[v6];
      }
      goto LABEL_32;
  }
LABEL_103:
  if (v57)
  {
    while (1)
    {
      v59 = *(unsigned __int8 *)v57;
      if (v59 > 0x3F)
        break;
      if (!*(_BYTE *)v57)
      {
        v58 = (_WORD)v57 - (_WORD)a2 + 1;
        goto LABEL_130;
      }
      v57 = (unsigned __int16 *)((char *)v57 + v59 + 1);
      if (a2 == (unsigned __int16 *)-256)
        goto LABEL_103;
LABEL_100:
      v58 = 257;
      if (v57 >= a2 + 128 || !v57)
        goto LABEL_130;
    }
  }
  v58 = 257;
LABEL_130:
  v64 = v13 - v58;
  if (RRAssertsExistence((uint64_t)a1, 0x2Fu, v7, v13, v8, v9, v10, v11))
    v12 += mDNS_snprintf(&v80[v12]);
  if (v64 >= 1)
  {
    v70 = (unsigned __int8 *)a2 + v58;
    while (1)
    {
      v71 = v64 - 2;
      if (v64 <= 2)
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "PrintTypeBitmap: malformed bitmap, bitmaplen %d short", v65, v66, v67, v68, v69, v64);
        return v80;
      }
      v72 = v70[1];
      if (v71 < v72 || (v72 - 33) <= 0xFFFFFFDF)
        break;
      v79 = v71 - v72;
      v73 = 0;
      v74 = v70 + 2;
      v75 = *v70 << 8;
      if ((8 * v72) <= 1)
        v76 = 1;
      else
        v76 = 8 * v72;
      do
      {
        if (((v74[(unint64_t)v73 >> 3] << (v73 & 7)) & 0x80) != 0)
        {
          DNSTypeName((unsigned __int16)(v75 + v73));
          v12 += mDNS_snprintf(&v80[v12]);
        }
        ++v73;
      }
      while (v76 != v73);
      v70 = &v74[v72];
      v64 = v79;
      if (v79 <= 0)
        return v80;
    }
    if (mDNS_LoggingEnabled == 1)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "PrintTypeBitmap: malformed nsec, bitmaplen %d wlen %d", v65, v66, v67, v68, v69, v64 - 2);
  }
  return v80;
}

uint64_t RRAssertsExistence(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  _BYTE *v11;
  unsigned __int16 v12;
  uint64_t v13;
  int v14;
  unsigned __int8 *v15;
  unsigned int v16;
  uint64_t v17;
  unsigned __int8 *v18;
  uint64_t v19;

  if (*(_WORD *)(a1 + 4) != 47)
    return 0;
  v8 = *(_QWORD *)(a1 + 40);
  v9 = v8 + 4;
  v10 = v8 + 260;
  v11 = (_BYTE *)(v8 + 4);
  if (!v10)
    goto LABEL_6;
LABEL_3:
  v12 = 257;
  if ((unint64_t)v11 < v10 && v11)
  {
    while (1)
    {
      v13 = *v11;
      if (v13 > 0x3F)
      {
LABEL_11:
        v12 = 257;
        goto LABEL_13;
      }
      if (!*v11)
        break;
      v11 += v13 + 1;
      if (v10)
        goto LABEL_3;
LABEL_6:
      if (!v11)
        goto LABEL_11;
    }
    v12 = (_WORD)v11 - v9 + 1;
  }
LABEL_13:
  v14 = *(unsigned __int16 *)(a1 + 12) - v12;
  if (v14 < 1)
    return 0;
  v15 = (unsigned __int8 *)(v9 + v12);
  while (1)
  {
    v16 = v14 - 2;
    if (v14 <= 2)
    {
      if (mDNS_LoggingEnabled == 1)
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "BitmapTypeCheck: malformed nsec, bitmaplen %d short", a4, a5, a6, a7, a8, v14);
      return 0;
    }
    v17 = v15[1];
    v14 = v16 - v17;
    if (v16 < v17 || (v17 - 33) <= 0xFFFFFFDF)
    {
      if (mDNS_LoggingEnabled == 1)
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "BitmapTypeCheck: malformed nsec, bitmaplen %d wlen %d, win %d", a4, a5, a6, a7, a8, v16);
      return 0;
    }
    v18 = v15 + 2;
    if (a2 >> 8 == *v15)
      break;
    v15 = &v18[v17];
    if (v14 <= 0)
      return 0;
  }
  v19 = a2 >> 3;
  if (v19 >= v17)
    return 0;
  return v18[v19] & (0x80u >> (a2 & 7));
}

uint64_t mDNS_DomainNameFNV1aHash(unsigned __int8 *a1)
{
  uint64_t result;
  unsigned __int8 *v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;

  result = 2166136261;
  v3 = a1;
  if (a1 == (unsigned __int8 *)-256)
    goto LABEL_5;
LABEL_2:
  v4 = 257;
  if (v3 >= a1 + 256 || !v3)
    goto LABEL_12;
  while (1)
  {
    v5 = *v3;
    if (v5 > 0x3F)
    {
LABEL_10:
      v4 = 257;
      goto LABEL_12;
    }
    if (!*v3)
      break;
    v3 += v5 + 1;
    if (a1 != (unsigned __int8 *)-256)
      goto LABEL_2;
LABEL_5:
    if (!v3)
      goto LABEL_10;
  }
  v4 = (unsigned __int16)((_WORD)v3 - (_WORD)a1 + 1);
  if ((_WORD)v3 - (_WORD)a1 != 0xFFFF)
  {
LABEL_12:
    v6 = v4;
    do
    {
      v8 = *a1++;
      v7 = v8;
      v9 = v8 + 32;
      if ((v8 - 65) < 0x1A)
        v7 = v9;
      result = 16777619 * (v7 ^ result);
      --v6;
    }
    while (v6);
  }
  return result;
}

uint64_t SameDomainNameBytes(_BYTE *a1, _BYTE *a2)
{
  _BYTE *v3;
  unint64_t v4;
  uint64_t result;

  v3 = a1;
  v4 = (unint64_t)(a1 + 256);
  while (*v3 || *a2)
  {
    if ((unint64_t)&v3[*v3 + 1] >= v4)
      return 0;
    result = SameDomainLabelPointer(v3, a2);
    if (!(_DWORD)result)
      return result;
    v3 += *v3 + 1;
    a2 += *a2 + 1;
  }
  return 1;
}

uint64_t IsSubdomain(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v2;
  int v3;
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  int v6;
  int v7;
  int v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  int v11;
  BOOL v12;
  int v13;
  int v15;

  v2 = *a1;
  if (*a1)
  {
    v3 = 0;
    v4 = a1;
    do
    {
      ++v3;
      v5 = &v4[v2];
      v6 = v5[1];
      v4 = v5 + 1;
      v2 = v6;
    }
    while (v6);
  }
  else
  {
    v3 = 0;
  }
  v7 = *a2;
  if (*a2)
  {
    v8 = 0;
    v9 = a2;
    do
    {
      ++v8;
      v10 = &v9[v7];
      v11 = v10[1];
      v9 = v10 + 1;
      v7 = v11;
    }
    while (v11);
  }
  else
  {
    v8 = 0;
  }
  v12 = __OFSUB__(v3, v8);
  v13 = v3 - v8;
  if (v13 < 0 != v12)
    return 0;
  if (v13 >= 1)
  {
    v15 = v13 + 1;
    do
    {
      if (!*a1)
        break;
      a1 += *a1 + 1;
      --v15;
    }
    while (v15 > 1);
  }
  return SameDomainNameBytes(a1, a2);
}

uint64_t TruncateUTF8ToLength(uint64_t a1, uint64_t a2, unsigned int a3)
{
  unsigned int v3;
  uint64_t v4;
  char v5;
  int v6;
  unsigned __int8 *v7;
  int v8;
  int v9;
  BOOL v10;
  _BOOL4 v11;
  int v12;
  uint64_t v13;

  if (a2 <= a3)
    return a2;
  v3 = a3;
  v4 = a3 + 1;
  if (v4 < a2)
  {
    v5 = *(_BYTE *)(a1 + v4);
    if (!a3)
      goto LABEL_16;
LABEL_6:
    v6 = *(unsigned __int8 *)(a1 + a3);
    v7 = (unsigned __int8 *)(a1 + a3 - 1);
    while (1)
    {
      v8 = v5 & 0xF0;
      v5 = v6;
      v9 = v6 & 0xC0;
      v10 = v6 == 237 && v8 == 176;
      v11 = v10;
      if (v9 != 128 && !v11)
        goto LABEL_17;
      v12 = *v7--;
      v6 = v12;
      --v3;
      if (!--a3)
        goto LABEL_16;
    }
  }
  v5 = -80;
  if (a3)
    goto LABEL_6;
LABEL_16:
  v3 = 0;
LABEL_17:
  v13 = v3;
  do
  {
    a2 = v13;
    if (!v13)
      break;
    --v13;
  }
  while (*(unsigned __int8 *)(a1 - 1 + a2) < 0x21u);
  return a2;
}

uint64_t IncrementLabelSuffix(unsigned __int8 *a1, int a2)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  int v7;
  unsigned int v8;
  int v9;
  char v10;
  unsigned int v11;
  unsigned __int16 v12;
  int v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t result;
  uint64_t v18;
  char v19;
  unsigned __int8 v20;
  BOOL v21;
  unsigned __int8 v22;
  int v23;
  int v24;
  unsigned int v25;
  int v26;
  char v27;
  uint32_t v28;

  v4 = *a1;
  if (!a2)
  {
    if (v4 >= 2)
    {
      v7 = a1[v4];
      v9 = 2;
      if ((v7 - 48) <= 9)
      {
        if ((((_WORD)v4 - 1) & 0xFFFE) != 0)
          v11 = 2;
        else
          v11 = (unsigned __int16)(v4 - 1);
        v12 = v4 - 1;
        while (v12 > 2u)
        {
          v13 = a1[v12--];
          if ((v13 - 48) >= 0xA)
            goto LABEL_39;
        }
        v13 = a1[v11];
LABEL_39:
        if (v13 != 45)
          goto LABEL_61;
        goto LABEL_40;
      }
      v10 = 1;
    }
    else
    {
      v10 = 1;
      v9 = 2;
    }
    v8 = 2;
    goto LABEL_27;
  }
  if (v4 >= 4 && a1[v4] == 41 && a1[(unsigned __int16)(v4 - 1)] - 48 <= 9)
  {
    v5 = v4 - 2;
    v6 = (unsigned __int16)(v4 - 2);
    if ((v4 - 2) >= 3)
    {
      do
      {
        if (a1[v6] - 48 >= 0xA)
          break;
        v6 = (unsigned __int16)--v5;
      }
      while ((unsigned __int16)v5 >= 3u);
    }
    if (a1[v6] != 40 || a1[v6 - 1] != 32)
      goto LABEL_61;
    v7 = 41;
LABEL_40:
    if (a2 && v7 == 41)
    {
      LOBYTE(v4) = v4 - 1;
      *a1 = v4;
    }
    v23 = v4;
    v24 = a1[v4];
    if ((v24 - 48) > 9)
    {
      v25 = 0;
      if (a2)
        goto LABEL_47;
    }
    else
    {
      v25 = 0;
      v26 = 1;
      do
      {
        v25 += (v24 - 48) * v26;
        v26 *= 10;
        LOBYTE(v4) = v4 - 1;
        *a1 = v4;
        v23 = v4;
        v24 = a1[v4];
      }
      while ((v24 - 48) < 0xA);
      if (a2)
      {
LABEL_47:
        if (v4 >= 2u && v24 == 40 && a1[v23 - 1] == 32)
        {
          v27 = -2;
LABEL_55:
          *a1 = v4 + v27;
          goto LABEL_56;
        }
        goto LABEL_56;
      }
    }
    if ((_BYTE)v4 && v24 == 45)
    {
      v27 = -1;
      goto LABEL_55;
    }
LABEL_56:
    if (v25)
    {
      if (v25 >= 0xA)
      {
        do
          v28 = arc4random() & 0x7F;
        while (v28 > 0x63);
        v8 = v25 + v28 + 1;
      }
      else
      {
        v8 = v25 + 1;
      }
      goto LABEL_62;
    }
LABEL_61:
    v8 = 2;
LABEL_62:
    if (a2)
      v9 = 4;
    else
      v9 = 2;
    if (!a2)
    {
      v10 = 1;
      goto LABEL_27;
    }
    LODWORD(v4) = *a1;
    goto LABEL_12;
  }
  v8 = 2;
  v9 = 4;
LABEL_12:
  while (a1[v4] == 32)
  {
    LODWORD(v4) = v4 - 1;
    *a1 = v4;
  }
  v10 = 0;
LABEL_27:
  v14 = v9 - 1;
  v15 = 1;
  do
  {
    v16 = v15;
    ++v14;
    if (v15 > 0x19999998)
      break;
    v15 *= 10;
  }
  while (v15 <= v8);
  result = TruncateUTF8ToLength((uint64_t)(a1 + 1), *a1, 63 - v14);
  *a1 = result + 1;
  v18 = (result + 1);
  if ((v10 & 1) != 0)
  {
    v19 = 45;
  }
  else
  {
    a1[v18] = 32;
    LOBYTE(v18) = *a1 + 1;
    *a1 = v18;
    v18 = v18;
    v19 = 40;
  }
  a1[v18] = v19;
  if (v16)
  {
    do
    {
      v20 = *a1 + 1;
      *a1 = v20;
      a1[v20] = v8 / v16 + 48;
      v8 %= v16;
      v21 = v16 > 9;
      v16 /= 0xAu;
    }
    while (v21);
  }
  if ((v10 & 1) == 0)
  {
    v22 = *a1 + 1;
    *a1 = v22;
    a1[v22] = 41;
  }
  return result;
}

uint64_t mDNS_SetupQuestion(uint64_t a1, uint64_t a2, _BYTE *__src, int a4, uint64_t a5)
{
  _BYTE *v8;
  uint64_t v9;
  unsigned __int16 v10;
  uint64_t result;

  *(_QWORD *)(a1 + 136) = a2;
  *(_DWORD *)(a1 + 324) = 0;
  v8 = __src;
  if (__src == (_BYTE *)-256)
  {
LABEL_3:
    while (v8)
    {
      v9 = *v8;
      if (v9 > 0x3F)
        break;
      if (!*v8)
      {
        v10 = (_WORD)v8 - (_WORD)__src + 1;
        if (v10 > 0x100u)
          break;
        memcpy((void *)(a1 + 376), __src, v10);
        goto LABEL_11;
      }
      v8 += v9 + 1;
      if (__src != (_BYTE *)-256)
        goto LABEL_2;
    }
  }
  else
  {
LABEL_2:
    if (v8 < __src + 256)
      goto LABEL_3;
  }
  *(_BYTE *)(a1 + 376) = 0;
LABEL_11:
  *(_WORD *)(a1 + 342) = a4;
  *(_WORD *)(a1 + 344) = 1;
  *(_BYTE *)(a1 + 632) = 0;
  *(_BYTE *)(a1 + 633) = a4 != 12;
  *(_BYTE *)(a1 + 641) = 0;
  *(_WORD *)(a1 + 639) = 0;
  *(_BYTE *)(a1 + 652) = 0;
  *(_DWORD *)(a1 + 634) = 0;
  result = getpid();
  *(_QWORD *)(a1 + 244) = result;
  *(_BYTE *)(a1 + 654) = 0;
  *(_DWORD *)(a1 + 280) = -1;
  *(_QWORD *)(a1 + 152) = ProxyClientCallback;
  *(_QWORD *)(a1 + 176) = a5;
  return result;
}

BOOL RRTypeAnswersQuestionType(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  uint64_t v11;
  int v12;
  _BOOL8 result;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v10 = a3 & 3;
  if (v10 == 1)
  {
    v11 = *(_QWORD *)(a1 + 56);
    if (!v11)
      return 0;
    v12 = 0;
  }
  else
  {
    if (v10 == 3)
    {
      v11 = *(_QWORD *)(a1 + 56);
      if (!v11)
        return 0;
      if (!*(_DWORD *)(v11 + 32))
        goto LABEL_15;
    }
    else
    {
      v11 = *(_QWORD *)(a1 + 56);
      if (v10 != 2 || !v11)
      {
        result = 0;
        if (v10 == 2 || v11)
          return result;
        goto LABEL_15;
      }
    }
    v12 = 1;
  }
  if (*(_DWORD *)(v11 + 32) != v12)
    return 0;
LABEL_15:
  v14 = *(unsigned __int16 *)(a1 + 4);
  if (v14 == 41)
    return 0;
  if (v14 == 5)
    return 1;
  result = 1;
  if (a2 != 255 && v14 != a2)
  {
    if (v14 == 47)
    {
      v15 = RRAssertsExistence(a1, 0x2Fu, a3, a4, a5, a6, a7, a8);
      v14 = *(unsigned __int16 *)(a1 + 4);
      if (!v15 && v14 == 47)
      {
        if (!RRAssertsExistence(a1, a2, v16, v17, v18, v19, v20, v21))
          return 1;
        v14 = *(unsigned __int16 *)(a1 + 4);
      }
    }
    if (v14 == 46)
    {
      if (resource_record_as_rrsig_get_covered_type(a1) == a2)
        return 1;
      return resource_record_as_rrsig_get_covered_type(a1) == 5;
    }
    return 0;
  }
  return result;
}

BOOL RecordAnswersQuestion(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _BOOL8 result;

  result = SameNameRecordAnswersQuestion((unsigned __int8 *)a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
    return *(_DWORD *)(a1 + 16) == *(_DWORD *)(a3 + 200)
        && SameDomainNameBytes(*(_BYTE **)(a1 + 32), (_BYTE *)(a3 + 376)) != 0;
  return result;
}

BOOL LocalOnlyRecordAnswersQuestion(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  _BOOL8 result;
  int v16;

  v9 = *(_DWORD *)(a1 + 172);
  if (v9 <= 3)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "LocalOnlyRecordAnswersQuestion: ERROR!! called with regular AuthRecordAny %##s", a4, a5, a6, a7, a8, *(_QWORD *)(a1 + 40));
    return 0;
  }
  v11 = *(_QWORD *)(a1 + 32);
  if (v11)
  {
    v12 = *(_QWORD *)(a2 + 136);
    if (v12 != -2)
    {
      if (v12)
      {
        if (v11 != v12)
          return 0;
      }
      else
      {
        v13 = v11 + 5;
        if (v13 > 3 || v13 == 1)
          return 0;
      }
    }
    if (v9 != 4 && *(_WORD *)(a2 + 340))
      return 0;
  }
  if (*(_QWORD *)(a2 + 144))
    return 0;
  result = RRTypeAnswersQuestionType(a1 + 8, *(unsigned __int16 *)(a2 + 342), 0, a4, a5, a6, a7, a8);
  if (result)
  {
    v16 = *(unsigned __int16 *)(a2 + 344);
    if ((*(unsigned __int16 *)(a1 + 14) == v16 || v16 == 255) && *(_DWORD *)(a1 + 24) == *(_DWORD *)(a2 + 200))
      return SameDomainNameBytes(*(_BYTE **)(a1 + 40), (_BYTE *)(a2 + 376)) != 0;
    return 0;
  }
  return result;
}

uint64_t ResourceRecordGetRDataBytesPointer(uint64_t a1, char *a2, int a3, _WORD *a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v11;
  char *v15;
  __int16 v16;
  BOOL v17;
  int v18;
  uint64_t result;

  v11 = *(unsigned __int16 *)(a1 + 4);
  if ((v11 > 0x2F || ((1 << v11) & 0x821204268040) == 0) && v11 != 65323)
  {
    v18 = 0;
    result = *(_QWORD *)(a1 + 40) + 4;
    v16 = *(_WORD *)(a1 + 12);
    if (!a4)
      goto LABEL_19;
LABEL_18:
    *a4 = v16;
    goto LABEL_19;
  }
  v15 = putRData(0, a2, (unint64_t)&a2[a3], a1, (unint64_t)a5, a6, a7, a8);
  v16 = (_WORD)v15 - (_WORD)a2;
  v17 = v15 > a2;
  if (v15 > a2)
    v18 = 0;
  else
    v18 = -65540;
  if (v15 > a2)
    result = (uint64_t)a2;
  else
    result = 0;
  if (!v17)
    v16 = 0;
  if (a4)
    goto LABEL_18;
LABEL_19:
  if (a5)
    *a5 = v18;
  return result;
}

unint64_t putUpdateLeaseWithLimit(unint64_t a1, unint64_t a2, unint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  int v15;
  char v16[4];
  __int16 v17;
  __int16 v18;
  int v19;
  int v20;
  _BYTE *v21;
  _WORD *v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  char v30;
  char v31;
  _BYTE *v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  _BYTE v45[25];
  __int16 v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  _BYTE v50[256];
  _WORD v51[4];
  int v52;

  bzero(&v15, 0x498uLL);
  v16[0] = 32;
  v17 = 41;
  v51[0] = 264;
  v21 = v50;
  v22 = v51;
  v30 = 0;
  v31 = 0;
  v23 = 0u;
  v24 = 0u;
  v25 = 0u;
  v26 = 0u;
  v27 = 0u;
  v28 = 0u;
  v29 = 0;
  v32 = v50;
  v46 = 0;
  v47 = 0;
  v49 = 0;
  v48 = 0;
  v50[0] = 0;
  v44 = 0u;
  memset(v45, 0, sizeof(v45));
  v42 = 0u;
  v43 = 0u;
  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v33 = 0u;
  v18 = 1440;
  v19 = 4500;
  v20 = 1572888;
  v51[2] = 2;
  v52 = 7200;
  v13 = PutResourceRecordTTLWithLimit(a1, a2, (_WORD *)(a1 + 10), (uint64_t)v16, 0, a3, v6, v7);
  if (!v13)
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: putUpdateLeaseWithLimit - PutResourceRecordTTLWithLimit", v8, v9, v10, v11, v12, v15);
  return v13;
}

_BYTE *skipDomainName(unint64_t a1, _BYTE *a2, unint64_t a3)
{
  _BYTE *result;
  unsigned int v5;
  unsigned __int16 v6;
  _BYTE *v7;

  result = 0;
  if ((unint64_t)a2 >= a1 && (unint64_t)a2 < a3)
  {
    result = a2 + 1;
    v5 = *a2;
    if (*a2)
    {
      v6 = 0;
      while (!(v5 >> 6))
      {
        a2 += v5 + 1;
        if ((unint64_t)a2 >= a3 || v5 + v6 + 1 > 0xFF)
          return 0;
        v6 += v5 + 1;
        v5 = *a2;
        if (!*a2)
          return a2 + 1;
      }
      v7 = a2 + 2;
      if ((unint64_t)(a2 + 2) > a3)
        v7 = 0;
      if ((v5 >> 6) - 1 >= 2)
        return v7;
      else
        return 0;
    }
  }
  return result;
}

BOOL SetRData(unint64_t a1, unsigned __int8 *__src, unint64_t a3, uint64_t a4, uint64_t __n, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  unint64_t v10;
  unsigned __int8 *v11;
  unint64_t v12;
  unsigned __int16 *v13;
  _OWORD *v14;
  int v15;
  unsigned __int8 *v16;
  _BYTE *v17;
  unsigned __int8 *v18;
  uint64_t v19;
  _BYTE *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned __int8 *v28;
  unsigned __int8 *DomainName;
  unsigned int *v30;
  uint64_t v31;
  size_t v32;
  char *v33;
  uint8_t *v34;
  char *v35;
  unsigned __int8 *v36;
  uint64_t v37;
  unsigned __int8 *v38;
  unsigned __int8 *v39;
  unsigned __int8 *v40;
  char *v41;
  uint8_t *v42;
  unsigned __int8 *v43;
  uint64_t v44;
  unsigned int v46;
  uint64_t v47;
  char *v48;
  unsigned __int8 *v49;
  unsigned __int8 *v50;
  int v51;
  uint64_t v52;
  unint64_t v53;
  unsigned int v55;
  unint64_t v56;
  int v57;
  int v59;
  __int16 v60;
  int v61;
  unsigned int v62;
  NSObject *v64;
  char *v65;
  unsigned __int8 *v66;
  unsigned __int16 *v67;
  uint64_t v68;
  unsigned __int16 *v69;
  uint64_t v70;
  uint64_t v71;
  const char *v73;
  uint8_t *v74;
  uint64_t v75;
  uint64_t v76;
  unsigned __int16 *v78;
  uint64_t v79;
  unsigned __int16 *v80;
  uint64_t v81;
  uint8_t *v82;
  uint64_t v83;
  uint64_t v84;
  NSObject *v87;
  uint32_t v88;
  uint64_t v89;
  _BYTE *v90;
  uint64_t v91;
  _BYTE *v92;
  uint64_t v93;
  uint8_t *v94;
  uint64_t v95;
  unsigned int v97;
  unsigned int v98;
  uint8_t *v99;
  uint64_t v100;
  uint64_t v102;
  uint8_t *v103;
  uint64_t v104;
  uint64_t v105;
  unsigned int v107;
  unint64_t v108;
  uint8_t *v109;
  uint64_t v110;
  unsigned int v112;
  unsigned __int8 *v113;
  uint64_t v114;
  _BYTE *v115;
  uint64_t v116;
  __int16 v117;
  unsigned __int16 v118;
  uint8_t *v119;
  uint64_t v120;
  uint64_t v122;
  _BYTE *i;
  uint64_t v125;
  unsigned int v126;
  __int16 v127;
  uint8_t *v128;
  uint64_t v129;
  int v131;
  uint8_t buf[16];
  __int128 v133;
  __int128 v134;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  __int128 v138;
  __int128 v139;
  __int128 v140;
  __int128 v141;
  __int128 v142;
  __int128 v143;
  __int128 v144;
  __int128 v145;
  __int128 v146;
  __int128 v147;
  uint8_t v148[16];

  v8 = __n;
  v10 = a3;
  v11 = __src;
  v12 = a1;
  v13 = *(unsigned __int16 **)(a4 + 40);
  v14 = v13 + 2;
  v15 = *(unsigned __int16 *)(a4 + 4);
  switch(*(_WORD *)(a4 + 4))
  {
    case 1:
      if ((_DWORD)__n != 4)
        return 0;
      *((_BYTE *)v13 + 4) = *__src;
      *((_BYTE *)v13 + 5) = __src[1];
      *((_BYTE *)v13 + 6) = __src[2];
      *((_BYTE *)v13 + 7) = __src[3];
      return 1;
    case 2:
    case 3:
    case 4:
    case 5:
    case 7:
    case 8:
    case 9:
    case 0xC:
    case 0x17:
    case 0x27:
      if (a1)
        goto LABEL_3;
      if (!AssignDomainNameWithLimit((_BYTE *)v13 + 4, __src, a3))
        return 0;
      v19 = 257;
      v20 = v13 + 2;
      if (v13 != (unsigned __int16 *)-260)
        goto LABEL_17;
      while (2)
      {
        if (!v20)
          goto LABEL_303;
        v22 = *v20;
        if (v22 > 0x3F)
          goto LABEL_303;
        if (*v20)
        {
          v20 += v22 + 1;
          if (v13 != (unsigned __int16 *)-260)
          {
LABEL_17:
            if (v20 >= (_BYTE *)v13 + 260)
              goto LABEL_303;
          }
          continue;
        }
        goto LABEL_301;
      }
    case 6:
      if (!a1)
      {
        if (!AssignDomainNameWithLimit((_BYTE *)v13 + 4, __src, a3))
          return 0;
        v78 = v13 + 130;
        v79 = 257;
        v80 = v13 + 2;
        if (v13 == (unsigned __int16 *)-260)
        {
          while (1)
          {
LABEL_151:
            if (!v80)
              goto LABEL_260;
            v81 = *(unsigned __int8 *)v80;
            if (v81 > 0x3F)
              goto LABEL_260;
            if (!*(_BYTE *)v80)
              break;
            v80 = (unsigned __int16 *)((char *)v80 + v81 + 1);
            if (v13 != (unsigned __int16 *)-260)
              goto LABEL_150;
          }
          v79 = (unsigned __int16)((_WORD)v80 - (_WORD)v14 + 1);
        }
        else
        {
LABEL_150:
          if (v80 < v78)
            goto LABEL_151;
        }
LABEL_260:
        v113 = &v11[v79];
        if (!v113 || !AssignDomainNameWithLimit((_BYTE *)v13 + 260, v113, v10))
          return 0;
        v114 = 257;
        v115 = v13 + 130;
        if (v13 == (unsigned __int16 *)-516)
        {
          while (1)
          {
LABEL_264:
            if (!v115)
              goto LABEL_311;
            v116 = *v115;
            if (v116 > 0x3F)
              goto LABEL_311;
            if (!*v115)
              break;
            v115 += v116 + 1;
            if (v13 != (unsigned __int16 *)-516)
              goto LABEL_263;
          }
          v114 = (unsigned __int16)((_WORD)v115 - (_WORD)v78 + 1);
        }
        else
        {
LABEL_263:
          if (v115 < (_BYTE *)v13 + 516)
            goto LABEL_264;
        }
LABEL_311:
        v30 = (unsigned int *)&v113[v114];
        if (!&v113[v114])
          return 0;
        goto LABEL_37;
      }
      DomainName = getDomainName(a1, __src, a3, (_BYTE *)v13 + 4);
      if (!DomainName)
        return 0;
      v30 = (unsigned int *)getDomainName(v12, DomainName, v10, (_BYTE *)v13 + 260);
      if (!v30)
        return 0;
LABEL_37:
      if (v30 + 5 != (unsigned int *)v10)
        return 0;
      *((_DWORD *)v13 + 129) = bswap32(*v30);
      *((_DWORD *)v13 + 130) = bswap32(v30[1]);
      *((_DWORD *)v13 + 131) = bswap32(v30[2]);
      *((_DWORD *)v13 + 132) = bswap32(v30[3]);
      *((_DWORD *)v13 + 133) = bswap32(v30[4]);
      return 1;
    case 0xA:
    case 0xB:
    case 0x10:
    case 0x13:
    case 0x14:
    case 0x16:
    case 0x18:
    case 0x19:
    case 0x1B:
    case 0x1D:
    case 0x1E:
    case 0x1F:
    case 0x20:
    case 0x22:
    case 0x25:
    case 0x26:
    case 0x28:
    case 0x2A:
    case 0x2B:
    case 0x2C:
    case 0x2D:
    case 0x2E:
    case 0x30:
    case 0x31:
    case 0x32:
    case 0x33:
    case 0x34:
    case 0x35:
    case 0x36:
    case 0x37:
    case 0x38:
    case 0x39:
    case 0x3A:
    case 0x3B:
    case 0x3C:
    case 0x3D:
    case 0x3E:
    case 0x3F:
    case 0x40:
    case 0x41:
      goto LABEL_43;
    case 0xD:
      if (a3 > (unint64_t)__src && (_DWORD)__n == (_DWORD)a3 - (_DWORD)__src)
      {
        v31 = *__src + 1;
        if (v31 >= __n)
        {
          v102 = mDNSLogCategory_Default;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
              return 0;
            *(_WORD *)buf = 0;
            v73 = "SetRData: Malformed HINFO RDATA - CPU character string goes out of boundary";
          }
          else
          {
            v102 = mDNSLogCategory_Default_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
              return 0;
            *(_WORD *)buf = 0;
            v73 = "SetRData: Malformed HINFO RDATA - CPU character string goes out of boundary";
          }
        }
        else
        {
          if (__src[v31] + 1 == (_DWORD)a3 - ((_DWORD)__src + (_DWORD)v31))
            goto LABEL_43;
          v102 = mDNSLogCategory_Default;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
              return 0;
            *(_WORD *)buf = 0;
            v73 = "SetRData: Malformed HINFO RDATA - OS character string does not end at the RDATA ending";
          }
          else
          {
            v102 = mDNSLogCategory_Default_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
              return 0;
            *(_WORD *)buf = 0;
            v73 = "SetRData: Malformed HINFO RDATA - OS character string does not end at the RDATA ending";
          }
        }
        v87 = v102;
        v88 = 2;
      }
      else
      {
        v71 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
            return 0;
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = v8;
          v73 = "SetRData: Malformed HINFO RDATA - invalid RDATA length: %u";
        }
        else
        {
          v71 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
            return 0;
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = v8;
          v73 = "SetRData: Malformed HINFO RDATA - invalid RDATA length: %u";
        }
        v87 = v71;
        v88 = 8;
      }
      _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_DEBUG, v73, buf, v88);
      return 0;
    case 0xE:
    case 0x11:
      if (a1)
      {
        v28 = getDomainName(a1, __src, a3, (_BYTE *)v13 + 4);
        if (!v28)
          return 0;
        v16 = v28;
        v17 = v13 + 130;
        goto LABEL_50;
      }
      if (!AssignDomainNameWithLimit((_BYTE *)v13 + 4, __src, a3))
        return 0;
      v67 = v13 + 130;
      v68 = 257;
      v69 = v13 + 2;
      if (v13 != (unsigned __int16 *)-260)
        goto LABEL_125;
      while (2)
      {
        if (v69)
        {
          v70 = *(unsigned __int8 *)v69;
          if (v70 <= 0x3F)
          {
            if (*(_BYTE *)v69)
            {
              v69 = (unsigned __int16 *)((char *)v69 + v70 + 1);
              if (v13 != (unsigned __int16 *)-260)
              {
LABEL_125:
                if (v69 >= v67)
                  break;
              }
              continue;
            }
            v68 = (unsigned __int16)((_WORD)v69 - (_WORD)v14 + 1);
          }
        }
        break;
      }
      v11 += v68;
      if (v11 && AssignDomainNameWithLimit((_BYTE *)v13 + 260, v11, v10))
      {
        v19 = 257;
        v92 = v13 + 130;
        if (v13 == (unsigned __int16 *)-516)
          goto LABEL_189;
        while (1)
        {
          if (v92 >= (_BYTE *)v13 + 516)
            goto LABEL_303;
          do
          {
LABEL_189:
            if (!v92)
              goto LABEL_303;
            v93 = *v92;
            if (v93 > 0x3F)
              goto LABEL_303;
            if (!*v92)
            {
              v117 = (_WORD)v92 - (_WORD)v67;
              goto LABEL_302;
            }
            v92 += v93 + 1;
          }
          while (v13 == (unsigned __int16 *)-516);
        }
      }
      return 0;
    case 0xF:
    case 0x12:
    case 0x15:
    case 0x24:
      if (__n < 3)
        return 0;
      v11 = __src + 2;
      v13[2] = bswap32(*(unsigned __int16 *)__src) >> 16;
      v14 = v13 + 3;
      if (a1)
        goto LABEL_3;
      if (!AssignDomainNameWithLimit((_BYTE *)v13 + 6, __src + 2, a3))
        return 0;
      v19 = 257;
      v20 = v13 + 3;
      if (v13 != (unsigned __int16 *)-262)
        goto LABEL_9;
      while (2)
      {
        if (!v20)
          goto LABEL_303;
        v21 = *v20;
        if (v21 > 0x3F)
          goto LABEL_303;
        if (*v20)
        {
          v20 += v21 + 1;
          if (v13 != (unsigned __int16 *)-262)
          {
LABEL_9:
            if (v20 >= (_BYTE *)v13 + 262)
              goto LABEL_303;
          }
          continue;
        }
        goto LABEL_301;
      }
    case 0x1A:
      if (__n < 4)
        return 0;
      v35 = (char *)(__src + 2);
      v13[2] = bswap32(*(unsigned __int16 *)__src) >> 16;
      if (a1)
      {
        v36 = getDomainName(a1, __src + 2, a3, (_BYTE *)v13 + 6);
        if (!v36)
          return 0;
        v16 = v36;
        v17 = v13 + 131;
LABEL_50:
        a1 = v12;
        a3 = v10;
LABEL_4:
        v18 = getDomainName(a1, v16, a3, v17);
        return v18 == (unsigned __int8 *)v10;
      }
      if (!AssignDomainNameWithLimit((_BYTE *)v13 + 6, __src + 2, a3))
        return 0;
      v14 = v13 + 131;
      v89 = 257;
      v90 = v13 + 3;
      if (v13 != (unsigned __int16 *)-262)
        goto LABEL_174;
      while (2)
      {
        if (v90)
        {
          v91 = *v90;
          if (v91 <= 0x3F)
          {
            if (*v90)
            {
              v90 += v91 + 1;
              if (v13 != (unsigned __int16 *)-262)
              {
LABEL_174:
                if (v90 >= (_BYTE *)v14)
                  break;
              }
              continue;
            }
            v89 = (unsigned __int16)((_WORD)v90 - ((_WORD)v13 + 6) + 1);
          }
        }
        break;
      }
      v11 = (unsigned __int8 *)&v35[v89];
      if (v11 && AssignDomainNameWithLimit((_BYTE *)v13 + 262, v11, v10))
      {
        v19 = 257;
        v20 = v13 + 131;
        if (v13 == (unsigned __int16 *)-518)
          goto LABEL_296;
        while (1)
        {
          if (v20 >= (_BYTE *)v13 + 518)
            goto LABEL_303;
          do
          {
LABEL_296:
            if (!v20)
              goto LABEL_303;
            v122 = *v20;
            if (v122 > 0x3F)
              goto LABEL_303;
            if (!*v20)
              goto LABEL_301;
            v20 += v122 + 1;
          }
          while (v13 == (unsigned __int16 *)-518);
        }
      }
      return 0;
    case 0x1C:
      if ((_DWORD)__n != 16)
        return 0;
      *v14 = *(_OWORD *)__src;
      return 1;
    case 0x21:
      if (__n < 7)
        return 0;
      v13[2] = bswap32(*(unsigned __int16 *)__src) >> 16;
      v13[3] = bswap32(*((unsigned __int16 *)__src + 1)) >> 16;
      *((_BYTE *)v13 + 8) = __src[4];
      *((_BYTE *)v13 + 9) = __src[5];
      v11 = __src + 6;
      v14 = v13 + 5;
      if (a1)
      {
LABEL_3:
        v16 = v11;
        v17 = v14;
        goto LABEL_4;
      }
      if (!AssignDomainNameWithLimit((_BYTE *)v13 + 10, __src + 6, a3))
        return 0;
      v19 = 257;
      v20 = v13 + 5;
      if (v13 != (unsigned __int16 *)-266)
        goto LABEL_57;
      while (2)
      {
        if (v20)
        {
          v37 = *v20;
          if (v37 <= 0x3F)
          {
            if (*v20)
            {
              v20 += v37 + 1;
              if (v13 != (unsigned __int16 *)-266)
              {
LABEL_57:
                if (v20 >= (_BYTE *)v13 + 266)
                  break;
              }
              continue;
            }
LABEL_301:
            v117 = (_WORD)v20 - (_WORD)v14;
LABEL_302:
            v19 = (unsigned __int16)(v117 + 1);
          }
        }
        break;
      }
LABEL_303:
      v18 = &v11[v19];
      return v18 == (unsigned __int8 *)v10;
    case 0x23:
      v146 = 0u;
      v147 = 0u;
      v144 = 0u;
      v145 = 0u;
      v142 = 0u;
      v143 = 0u;
      v140 = 0u;
      v141 = 0u;
      v138 = 0u;
      v139 = 0u;
      v136 = 0u;
      v137 = 0u;
      v134 = 0u;
      v135 = 0u;
      *(_OWORD *)buf = 0u;
      v133 = 0u;
      if (__n < 8)
        return 0;
      v38 = &__src[__src[4] + 5];
      if ((unint64_t)v38 >= a3)
      {
        if (mDNS_LoggingEnabled != 1)
          return 0;
        v64 = mDNSLogCategory_Default;
        v65 = "SetRData: Malformed NAPTR flags";
        goto LABEL_330;
      }
      v39 = &v38[*v38 + 1];
      if ((unint64_t)v39 >= a3)
      {
        if (mDNS_LoggingEnabled != 1)
          return 0;
        v64 = mDNSLogCategory_Default;
        v65 = "SetRData: Malformed NAPTR service";
        goto LABEL_330;
      }
      v40 = &v39[*v39];
      v41 = (char *)(v40 + 1);
      if ((unint64_t)(v40 + 1) >= a3)
      {
        if (mDNS_LoggingEnabled != 1)
          return 0;
        v64 = mDNSLogCategory_Default;
        v65 = "SetRData: Malformed NAPTR regexp";
        goto LABEL_330;
      }
      if (!a1)
      {
        for (i = v40 + 1; ; i += v125 + 1)
        {
          if ((unint64_t)i >= a3)
            return 0;
          if (!i)
            return 0;
          v125 = *i;
          if (v125 > 0x3F)
            return 0;
          if (!*i)
            break;
        }
        v127 = (_WORD)i - (_WORD)v41;
        if ((v127 & 0xFF00) != 0)
          return 0;
        v128 = buf;
        memcpy(buf, v41, (unsigned __int16)(v127 + 1));
        do
        {
          v129 = *v128;
          if (v129 > 0x3F)
            break;
          if (!*v128)
          {
            v46 = (_DWORD)v128 - buf + 1;
            goto LABEL_343;
          }
          v128 += v129 + 1;
        }
        while (v128 < v148 && v128 != 0);
        LOWORD(v46) = 257;
LABEL_343:
        v43 = (unsigned __int8 *)&v41[(unsigned __int16)v46];
        goto LABEL_324;
      }
      v42 = buf;
      v43 = getDomainName(a1, v40 + 1, a3, buf);
      while (1)
      {
        v44 = *v42;
        if (v44 > 0x3F)
        {
LABEL_76:
          LOWORD(v46) = 257;
          goto LABEL_324;
        }
        if (!*v42)
          break;
        v42 += v44 + 1;
        if (v42 >= v148 || v42 == 0)
          goto LABEL_76;
      }
      v46 = (_DWORD)v42 - buf + 1;
LABEL_324:
      if (v43 == (unsigned __int8 *)v10)
      {
        *(_WORD *)(a4 + 12) = v46 + (_WORD)v41 - (_WORD)v11;
        if ((unsigned __int16)(v46 + (_WORD)v41 - (_WORD)v11) <= 0x2000u)
        {
          memcpy(v14, v11, ((_DWORD)v41 - (_DWORD)v11));
          v33 = (char *)v14 + (int)v41 - (int)v11;
          v32 = (unsigned __int16)v46;
          v34 = buf;
          goto LABEL_45;
        }
        if (mDNS_LoggingEnabled != 1)
          return 0;
        v64 = mDNSLogCategory_Default;
        v131 = v8;
        v65 = "SetRData: Malformed NAPTR rdlength %d, rr->rdlength %d, bmaplen %d, name %##s";
      }
      else
      {
        if (mDNS_LoggingEnabled != 1)
          return 0;
        v64 = mDNSLogCategory_Default;
        v65 = "SetRData: Malformed NAPTR RDATA name";
      }
      goto LABEL_330;
    case 0x29:
      v47 = *v13;
      *(_WORD *)(a4 + 12) = 0;
      if ((unint64_t)__src >= a3 || v47 < 0x18)
        goto LABEL_118;
      v48 = (char *)v14 + v47;
      while (1)
      {
        v49 = v11 + 4;
        if ((unint64_t)(v11 + 4) > v10)
        {
          if (mDNS_LoggingEnabled != 1)
            return 0;
          v64 = mDNSLogCategory_Default;
          v65 = "SetRData: OPT RDATA ptr + 4 > end";
          goto LABEL_330;
        }
        v50 = v11;
        v51 = __rev16(*(unsigned __int16 *)v11);
        *(_WORD *)v14 = v51;
        v52 = v11[3];
        v53 = v52 | ((unint64_t)v11[2] << 8);
        *((_WORD *)v14 + 1) = v53;
        v11 = &v49[v53];
        if ((unint64_t)&v49[v53] > v10)
        {
          if (mDNS_LoggingEnabled != 1)
            return 0;
          v64 = mDNSLogCategory_Default;
          v65 = "SetRData: ptr + opt->optlen > end";
          goto LABEL_330;
        }
        if (v51 <= 3)
        {
          if (v51 != 1)
          {
            if (v51 != 2 || (_DWORD)v53 != 4)
              goto LABEL_112;
            v55 = bswap32(*((_DWORD *)v50 + 1));
            if (v55 >= 0x1CAC08)
              v55 = 1879048;
            *((_DWORD *)v14 + 1) = v55;
            goto LABEL_111;
          }
          if ((_DWORD)v53 == 18)
          {
            *((_WORD *)v14 + 2) = bswap32(*((unsigned __int16 *)v50 + 2)) >> 16;
            *((_WORD *)v14 + 3) = bswap32(*((unsigned __int16 *)v50 + 3)) >> 16;
            *((_WORD *)v14 + 4) = bswap32(*((unsigned __int16 *)v50 + 4)) >> 16;
            *(_QWORD *)((char *)v14 + 12) = *(_QWORD *)(v50 + 10);
            v62 = bswap32(*(_DWORD *)(v50 + 18));
            if (v62 >= 0x1CAC08)
              v62 = 1879048;
            *((_DWORD *)v14 + 5) = v62;
            goto LABEL_111;
          }
        }
        else
        {
          if (v51 == 4)
          {
            HIDWORD(v56) = v52;
            LODWORD(v56) = ((_DWORD)v53 << 16) - 0x80000;
            v57 = (1 << (v56 >> 17)) & 0x69;
            if ((unsigned __int16)(v56 >> 17) > 6u || v57 == 0)
              goto LABEL_112;
            *((_BYTE *)v14 + 4) = v50[4];
            *((_BYTE *)v14 + 5) = v50[5];
            v59 = *(_DWORD *)(v50 + 6);
            *((_WORD *)v14 + 5) = *((_WORD *)v50 + 5);
            *(_DWORD *)((char *)v14 + 6) = v59;
            v60 = *((_WORD *)v50 + 5);
            *((_DWORD *)v14 + 3) = *(_DWORD *)(v50 + 6);
            *((_WORD *)v14 + 8) = v60;
            *(_DWORD *)((char *)v14 + 18) = 0;
            *((_WORD *)v14 + 11) = 0;
            if (v53 >= 0xE)
            {
              v61 = *((_DWORD *)v50 + 3);
              *((_WORD *)v14 + 8) = *((_WORD *)v50 + 8);
              *((_DWORD *)v14 + 3) = v61;
              if ((_DWORD)v53 != 14)
                memcpy((char *)v14 + 18, v50 + 18, (v53 - 14));
            }
            goto LABEL_111;
          }
          if (v51 == 65001)
          {
            if ((_DWORD)v53 == 5)
            {
              *((_BYTE *)v14 + 4) = v50[4];
              *((_DWORD *)v14 + 2) = bswap32(*(_DWORD *)(v50 + 5));
            }
            else
            {
              *((_BYTE *)v14 + 4) = -1;
              *((_DWORD *)v14 + 2) = -1;
            }
            goto LABEL_111;
          }
          if (v51 == 65002 && (_DWORD)v53 == 10)
          {
            *((_DWORD *)v14 + 1) = bswap32(*((_DWORD *)v50 + 1));
            *((_DWORD *)v14 + 2) = bswap32(*((_DWORD *)v50 + 2));
            *((_WORD *)v14 + 6) = bswap32(*((unsigned __int16 *)v50 + 6)) >> 16;
LABEL_111:
            v14 = (_OWORD *)((char *)v14 + 24);
          }
        }
LABEL_112:
        if ((unint64_t)v11 >= v10 || v48 - (char *)v14 <= 23)
        {
          v13 = *(unsigned __int16 **)(a4 + 40);
LABEL_118:
          *(_WORD *)(a4 + 12) = (_WORD)v14 - (_WORD)v13 - 4;
          if (v11 == (unsigned __int8 *)v10)
            return 1;
          if (mDNS_LoggingEnabled != 1)
            return 0;
          v64 = mDNSLogCategory_Default;
          v65 = "SetRData: Malformed OptRdata";
LABEL_330:
          LogMsgWithLevel(v64, OS_LOG_TYPE_DEFAULT, v65, a4, __n, a6, a7, a8, v131);
          return 0;
        }
      }
    case 0x2F:
      v146 = 0u;
      v147 = 0u;
      v144 = 0u;
      v145 = 0u;
      v142 = 0u;
      v143 = 0u;
      v140 = 0u;
      v141 = 0u;
      v138 = 0u;
      v139 = 0u;
      v136 = 0u;
      v137 = 0u;
      v134 = 0u;
      v135 = 0u;
      *(_OWORD *)buf = 0u;
      v133 = 0u;
      if (a1)
      {
        v66 = getDomainName(a1, __src, a3, buf);
        goto LABEL_233;
      }
      v82 = buf;
      if (!AssignDomainNameWithLimit(buf, __src, a3))
        return 0;
      v83 = 257;
      while (2)
      {
        v84 = *v82;
        if (v84 <= 0x3F)
        {
          if (*v82)
          {
            v82 += v84 + 1;
            if (v82 >= v148 || v82 == 0)
              break;
            continue;
          }
          v83 = (unsigned __int16)((_WORD)v82 - (unsigned __int16)buf + 1);
        }
        break;
      }
      v66 = &v11[v83];
LABEL_233:
      if (!v66)
      {
        if (mDNS_LoggingEnabled == 1)
        {
          v64 = mDNSLogCategory_Default;
          v65 = "SetRData: Malformed NSEC nextname";
          goto LABEL_330;
        }
        return 0;
      }
      v103 = buf;
      v104 = 257;
      do
      {
        v105 = *v103;
        if (v105 > 0x3F)
          break;
        if (!*v103)
        {
          v104 = (unsigned __int16)((_WORD)v103 - (unsigned __int16)buf + 1);
          break;
        }
        v103 += v105 + 1;
      }
      while (v103 < v148 && v103 != 0);
      v107 = (_DWORD)v11 - (_DWORD)v66 + v8;
      v108 = SanityCheckBitMap((unint64_t)v66, v10, v107, a4, __n, a6, a7, a8);
      if (!v108)
        return 0;
      if (v108 == v10)
      {
        v109 = buf;
        while (1)
        {
          v110 = *v109;
          if (v110 > 0x3F)
          {
LABEL_258:
            LOWORD(v112) = 257;
            goto LABEL_279;
          }
          if (!*v109)
            break;
          v109 += v110 + 1;
          if (v109 >= v148 || v109 == 0)
            goto LABEL_258;
        }
        v112 = (_DWORD)v109 - buf + 1;
LABEL_279:
        v118 = v112 + v107;
        *(_WORD *)(a4 + 12) = v118;
        if (v118 > 0x2000u)
        {
          if (mDNS_LoggingEnabled == 1)
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SetRData: Malformed NSEC rdlength %d, rr->rdlength %d, bmaplen %d, name %##s", a4, __n, a6, a7, a8, v8);
          return 0;
        }
        v119 = buf;
        do
        {
          v120 = *v119;
          if (v120 > 0x3F)
            break;
          if (!*v119)
          {
            v126 = (_DWORD)v119 - buf + 1;
            if ((unsigned __int16)v126 <= 0x100u)
            {
              memcpy(v14, buf, (unsigned __int16)v126);
              goto LABEL_322;
            }
            break;
          }
          v119 += v120 + 1;
        }
        while (v119 < v148 && v119 != 0);
        *(_BYTE *)v14 = 0;
LABEL_322:
        v33 = (char *)v14 + v104;
        v32 = v107;
        v34 = v66;
LABEL_45:
        memcpy(v33, v34, v32);
        return 1;
      }
      else
      {
        if (mDNS_LoggingEnabled == 1)
        {
          v64 = mDNSLogCategory_Default;
          v65 = "SetRData: Malformed NSEC length not right";
          goto LABEL_330;
        }
        return 0;
      }
    default:
      if ((v15 - 249) >= 2)
      {
        if (v15 == 65323)
        {
          *(_DWORD *)v14 = bswap32(*(_DWORD *)__src);
          return 1;
        }
LABEL_43:
        *(_WORD *)(a4 + 12) = __n;
        v32 = __n;
        v33 = (char *)(v13 + 2);
      }
      else
      {
        v146 = 0u;
        v147 = 0u;
        v144 = 0u;
        v145 = 0u;
        v142 = 0u;
        v143 = 0u;
        v140 = 0u;
        v141 = 0u;
        v138 = 0u;
        v139 = 0u;
        v136 = 0u;
        v137 = 0u;
        v134 = 0u;
        v135 = 0u;
        *(_OWORD *)buf = 0u;
        v133 = 0u;
        if (a1)
        {
          v11 = getDomainName(a1, __src, a3, buf);
          if (!v11)
            goto LABEL_206;
        }
        else
        {
          v74 = buf;
          if (!AssignDomainNameWithLimit(buf, __src, a3))
            return 0;
          v75 = 257;
          while (1)
          {
            v76 = *v74;
            if (v76 > 0x3F)
              goto LABEL_195;
            if (!*v74)
              break;
            v74 += v76 + 1;
            if (v74 >= v148 || v74 == 0)
              goto LABEL_195;
          }
          v75 = (unsigned __int16)((_WORD)v74 - (unsigned __int16)buf + 1);
LABEL_195:
          v11 += v75;
          if (!v11)
          {
LABEL_206:
            if (mDNS_LoggingEnabled == 1)
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SetRData: Malformed name for TSIG/TKEY type %d", v23, v24, v25, v26, v27, *(unsigned __int16 *)(a4 + 4));
            return 0;
          }
        }
        if ((unint64_t)v11 >= v10)
          goto LABEL_206;
        v94 = buf;
        do
        {
          v95 = *v94;
          if (v95 > 0x3F)
            break;
          if (!*v94)
          {
            v97 = (_DWORD)v94 - buf + 1;
            goto LABEL_209;
          }
          v94 += v95 + 1;
        }
        while (v94 < v148 && v94 != 0);
        LOWORD(v97) = 257;
LABEL_209:
        v98 = v10 - (_DWORD)v11;
        *(_WORD *)(a4 + 12) = v97 + v98;
        if ((unsigned __int16)(v97 + v98) > 0x2000u)
        {
          if (mDNS_LoggingEnabled == 1)
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SetRData: Malformed TSIG/TKEY rdlength %d, rr->rdlength %d, bmaplen %d, name %##s", v23, v24, v25, v26, v27, v8);
          return 0;
        }
        v99 = buf;
        while (1)
        {
          v100 = *v99;
          if (v100 > 0x3F)
            goto LABEL_223;
          if (!*v99)
            break;
          v99 += v100 + 1;
          if (v99 >= v148 || v99 == 0)
            goto LABEL_223;
        }
        if ((unsigned __int16)((_WORD)v99 - (unsigned __int16)buf + 1) > 0x100u)
LABEL_223:
          *(_BYTE *)v14 = 0;
        else
          memcpy(v13 + 2, buf, (unsigned __int16)((_WORD)v99 - (unsigned __int16)buf + 1));
        v33 = (char *)v14 + (unsigned __int16)v97;
        v32 = v98;
      }
      v34 = v11;
      goto LABEL_45;
  }
}

uint64_t AssignDomainNameWithLimit(_BYTE *a1, _BYTE *a2, unint64_t a3)
{
  _BYTE *v3;
  uint64_t v4;
  __int16 v5;
  uint64_t v6;

  v3 = a2;
  if (a3)
  {
LABEL_2:
    if ((unint64_t)v3 < a3)
      goto LABEL_3;
  }
  else
  {
LABEL_3:
    while (v3)
    {
      v4 = *v3;
      if (v4 > 0x3F)
        break;
      if (!*v3)
      {
        v5 = (_WORD)v3 - (_WORD)a2;
        if ((v5 & 0xFF00) != 0)
          break;
        memcpy(a1, a2, (unsigned __int16)(v5 + 1));
        return 1;
      }
      v3 += v4 + 1;
      if (a3)
        goto LABEL_2;
    }
  }
  v6 = 0;
  *a1 = 0;
  return v6;
}

unint64_t SanityCheckBitMap(unint64_t result, unint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v9;

  if (result < a2)
  {
    while (1)
    {
      v8 = a3 - 2;
      if (a3 <= 2)
        break;
      v9 = *(unsigned __int8 *)(result + 1);
      a3 = v8 - v9;
      if (v8 < v9 || (v9 - 33) <= 0xFFFFFFDF)
      {
        if (mDNS_LoggingEnabled == 1)
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SanityCheckBitMap: invalid window length %d", a4, a5, a6, a7, a8, v9);
        return 0;
      }
      result += v9 + 2;
      if (result >= a2)
        return result;
    }
    if (mDNS_LoggingEnabled == 1)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SanityCheckBitMap: invalid length %d", a4, a5, a6, a7, a8, a3);
    return 0;
  }
  return result;
}

char **mDNS_snprintf_add(char **result, int a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  char *v9;
  int v10;
  char **v11;

  v9 = *result;
  v10 = a2 - *result;
  if (v10)
  {
    v11 = result;
    result = (char **)mDNS_vsnprintf(v9, v10, a3, &a9);
    *v11 = &v9[result];
  }
  return result;
}

void DumpPacket(int a1, int a2, uint64_t a3, __int128 *a4, unsigned int a5, __int128 *a6, unsigned int a7, unsigned __int8 *a8, unint64_t a9, uint64_t a10)
{
  __int128 *v16;
  __int128 *v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  NSObject *v21;
  __int128 *v23;
  __int128 *v24;
  unsigned int v25;
  char v26;
  uint64_t v27;
  const char *v28;
  unsigned __int8 *v30;
  __int128 v31;
  unsigned int v32;
  unsigned __int8 *DomainName;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unsigned __int8 *v39;
  unsigned int v40;
  unsigned int v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint8_t *v48;
  int v49;
  int v50;
  int v51;
  int v52;
  uint8_t *v53;
  unsigned __int8 *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  BOOL v60;
  int64_t v61;
  unsigned __int8 *v62;
  unsigned int v63;
  unsigned int v64;
  int v65;
  const char *v66;
  int v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  unsigned __int8 *v88;
  unsigned __int8 *v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  unsigned int v96;
  int v97;
  const char *v98;
  unsigned int v99;
  int v100;
  const char *v101;
  uint8_t *v102;
  NSObject *v103;
  os_log_type_t v104;
  uint32_t v105;
  unsigned int v106;
  const char *v107;
  int v108;
  uint64_t v109;
  const char *v110;
  unsigned int v111;
  const char *v112;
  int v113;
  const char *v114;
  int v115;
  int v116;
  const char *v117;
  const char *v118;
  const char *v119;
  const char *v120;
  const char *v121;
  int v122;
  int v123;
  int v124;
  int v126;
  unsigned int v128;
  __int128 v129;
  int v130;
  char *v131;
  char *v132;
  _OWORD v133[2];
  uint8_t v134[4];
  unsigned int v135;
  __int16 v136;
  const char *v137;
  __int16 v138;
  const char *v139;
  __int16 v140;
  unint64_t v141;
  __int16 v142;
  int v143;
  __int16 v144;
  int v145;
  __int16 v146;
  const char *v147;
  __int16 v148;
  int v149;
  __int16 v150;
  const char *v151;
  __int16 v152;
  const char *v153;
  __int16 v154;
  const char *v155;
  __int16 v156;
  const char *v157;
  __int16 v158;
  const char *v159;
  __int16 v160;
  const char *v161;
  __int16 v162;
  uint64_t v163;
  __int16 v164;
  _OWORD *v165;
  __int16 v166;
  int v167;
  __int16 v168;
  int v169;
  __int16 v170;
  int v171;
  __int16 v172;
  uint64_t v173;
  __int16 v174;
  _OWORD *v175;
  _OWORD v176[32];
  _OWORD v177[32];
  uint8_t buf[48];
  __int128 v179;
  __int128 v180;
  __int128 v181;
  __int128 v182;
  __int128 v183;
  __int128 v184;
  __int128 v185;
  __int128 v186;
  __int128 v187;
  __int128 v188;
  __int128 v189;
  __int128 v190;
  __int128 v191;
  _OWORD v192[16];

  v129 = xmmword_1000FFE88;
  v130 = 0;
  memset(v133, 0, sizeof(v133));
  if (a1)
    v122 = a1;
  mDNS_snprintf(v133);
  v16 = &xmmword_10015BF38;
  while (1)
  {
    v16 = *(__int128 **)v16;
    if (!v16)
      break;
    v17 = v16;
    if (*((_QWORD *)v16 + 444) == a10)
      goto LABEL_8;
  }
  v17 = 0;
LABEL_8:
  v18 = (uint64_t)v17 + 3606;
  if (v16)
    v19 = v18;
  else
    v19 = 0;
  v20 = *(unsigned __int16 *)a8;
  if (*(_WORD *)a8)
  {
    v21 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_38:
        v30 = a8 + 12;
        v31 = 0uLL;
        memset(v192, 0, sizeof(v192));
        v191 = 0u;
        v190 = 0u;
        v189 = 0u;
        v188 = 0u;
        v187 = 0u;
        v186 = 0u;
        v185 = 0u;
        v184 = 0u;
        v183 = 0u;
        v182 = 0u;
        v181 = 0u;
        v180 = 0u;
        v179 = 0u;
        memset(buf, 0, sizeof(buf));
        memset(v177, 0, sizeof(v177));
        v132 = (char *)v177;
        if (*((_WORD *)a8 + 2))
        {
          v32 = 0;
          do
          {
            DomainName = getDomainName((unint64_t)a8, v30, a9, buf);
            if (!DomainName)
              return;
            v39 = DomainName;
            if ((uint64_t)(a9 - (_QWORD)DomainName) < 4)
              return;
            v40 = bswap32(*(unsigned __int16 *)DomainName) >> 16;
            v41 = *((unsigned __int16 *)DomainName + 1);
            if (v40 != 1)
              DNSTypeName(v40);
            v42 = __rev16(v41);
            mDNS_snprintf_add(&v132, (int)buf, " %##s %s", v34, v35, v36, v37, v38, (int)buf);
            if (v42 != 1)
              mDNS_snprintf_add(&v132, (int)buf, "/%u", v43, v44, v45, v46, v47, v42);
            v30 = v39 + 4;
            mDNS_snprintf_add(&v132, (int)buf, "?", v43, v44, v45, v46, v47, v123);
            ++v32;
          }
          while (v32 < *((unsigned __int16 *)a8 + 2));
          v48 = buf;
          v31 = 0uLL;
        }
        else
        {
          v48 = 0;
        }
        v176[30] = v31;
        v176[31] = v31;
        v176[28] = v31;
        v176[29] = v31;
        v176[26] = v31;
        v176[27] = v31;
        v176[24] = v31;
        v176[25] = v31;
        v176[22] = v31;
        v176[23] = v31;
        v176[20] = v31;
        v176[21] = v31;
        v176[18] = v31;
        v176[19] = v31;
        v176[16] = v31;
        v176[17] = v31;
        v176[14] = v31;
        v176[15] = v31;
        v176[12] = v31;
        v176[13] = v31;
        v176[10] = v31;
        v176[11] = v31;
        v176[8] = v31;
        v176[9] = v31;
        v176[6] = v31;
        v176[7] = v31;
        v176[4] = v31;
        v176[5] = v31;
        v176[2] = v31;
        v176[3] = v31;
        v176[0] = v31;
        v176[1] = v31;
        v131 = (char *)v176;
        v49 = *((unsigned __int16 *)a8 + 3);
        v50 = *((unsigned __int16 *)a8 + 4);
        v51 = *((unsigned __int16 *)a8 + 5);
        if (v50 + v49 + v51)
        {
          v52 = 0;
          v126 = v50 + v51 + v49;
          do
          {
            v53 = &buf[256 * (unint64_t)(v48 == buf)];
            v54 = getDomainName((unint64_t)a8, v30, a9, v53);
            if (v54)
              v60 = (uint64_t)(a9 - (_QWORD)v54) < 10;
            else
              v60 = 1;
            if (v60)
              return;
            v61 = __rev16(*((unsigned __int16 *)v54 + 4));
            v62 = v54 + 10;
            if ((uint64_t)(a9 - (_QWORD)(v54 + 10)) < v61)
              return;
            v63 = *(unsigned __int16 *)v54;
            v64 = *((unsigned __int16 *)v54 + 1);
            v128 = *((_DWORD *)v54 + 1);
            if (v52)
              mDNS_snprintf_add(&v131, (int)v177, ",", v55, v56, v57, v58, v59, v122);
            if (!v48 || !SameDomainNameBytes(v53, v48))
              mDNS_snprintf_add(&v131, (int)v177, " %##s", v55, v56, v57, v58, v59, (int)v53);
            v65 = __rev16(v63);
            v66 = "A";
            if (v65 != 1)
              LODWORD(v66) = DNSTypeName(v65);
            v67 = __rev16(v64);
            mDNS_snprintf_add(&v131, (int)v177, " %s", v55, v56, v57, v58, v59, (int)v66);
            if (v67 != 1)
              mDNS_snprintf_add(&v131, (int)v177, "/%u", v68, v69, v70, v71, v72, v67);
            mDNS_snprintf_add(&v131, (int)v177, " ", v68, v69, v70, v71, v72, v124);
            if (v65 > 5)
            {
              if (v65 == 6)
              {
                v88 = getDomainName((unint64_t)a8, v62, a9, buf);
                if (!v88)
                  return;
                v89 = getDomainName((unint64_t)a8, v88, a9, v192);
                if (!v89 || (uint64_t)(a9 - (_QWORD)v89) < 20)
                  return;
                mDNS_snprintf_add(&v131, (int)v177, "%##s %##s %lu %lu %lu %lu %lu", v90, v91, v92, v93, v94, (int)buf);
                v53 = 0;
              }
              else
              {
                if (v65 != 28 || (_DWORD)v61 != 16)
                  goto LABEL_76;
                mDNS_snprintf_add(&v131, (int)v177, "%.16a", v73, v74, v75, v76, v77, (int)v62);
              }
            }
            else
            {
              if (v65 != 1)
              {
                if (v65 == 5)
                {
                  if (!getDomainName((unint64_t)a8, v62, a9, v53))
                    return;
                  mDNS_snprintf_add(&v131, (int)v177, "%##s", v78, v79, v80, v81, v82, (int)v53);
                  goto LABEL_77;
                }
LABEL_76:
                mDNS_snprintf_add(&v131, (int)v177, "RDATA[%u]: %.*H", v73, v74, v75, v76, v77, v61);
                goto LABEL_77;
              }
              if ((_DWORD)v61 != 4)
                goto LABEL_76;
              mDNS_snprintf_add(&v131, (int)v177, "%.4a", v73, v74, v75, v76, v77, (int)v62);
            }
LABEL_77:
            mDNS_snprintf_add(&v131, (int)v177, " (%lu)", v83, v84, v85, v86, v87, bswap32(v128));
            v30 = &v62[v61];
            ++v52;
            v48 = v53;
          }
          while (v126 != v52);
        }
        v95 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
            return;
          v99 = bswap32(*(unsigned __int16 *)a8);
          v100 = a8[2];
          if ((v100 & 0x78u) >= 0x30)
          {
            v101 = "?? ";
            if ((v100 & 0x78) == 0x30)
              v101 = "DSO ";
          }
          else
          {
            v101 = *(const char **)((char *)&off_10013BA58 + (v100 & 0x78));
          }
          v111 = HIWORD(v99);
          if ((v100 & 0x80u) != 0)
            v112 = "Response";
          else
            v112 = "Query";
          v108 = a8[3];
          v109 = v108 & 0xF;
          if ((v108 & 0xFu) >= 0xB)
          {
            v110 = "??";
            if ((v108 & 0xF) == 0xB)
              v110 = "DSOTypeNI";
          }
          else
          {
            v110 = off_10013BA88[v109];
          }
          v113 = *((unsigned __int16 *)a8 + 3);
          v114 = " AA";
          v115 = *((unsigned __int16 *)a8 + 4);
          v116 = *((unsigned __int16 *)a8 + 5);
          if ((v100 & 4) == 0)
            v114 = "";
          *(_DWORD *)v134 = 67114243;
          v135 = v111;
          if ((v100 & 2) != 0)
            v117 = " TC";
          else
            v117 = "";
          v136 = 2082;
          v137 = v101;
          if ((v100 & 1) != 0)
            v118 = " RD";
          else
            v118 = "";
          v138 = 2082;
          v139 = v112;
          v140 = 2048;
          if ((v108 & 0x80u) != 0)
            v119 = " RA";
          else
            v119 = "";
          v141 = a9 - (_QWORD)a8;
          v120 = " AD";
          v142 = 1024;
          if ((v108 & 0x20) == 0)
            v120 = "";
          v143 = v100;
          v121 = " CD";
          v144 = 1024;
          if ((v108 & 0x10) == 0)
            v121 = "";
        }
        else
        {
          v95 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
            return;
          v96 = bswap32(*(unsigned __int16 *)a8);
          v97 = a8[2];
          if ((v97 & 0x78u) >= 0x30)
          {
            v98 = "?? ";
            if ((v97 & 0x78) == 0x30)
              v98 = "DSO ";
          }
          else
          {
            v98 = *(const char **)((char *)&off_10013BA58 + (v97 & 0x78));
          }
          v106 = HIWORD(v96);
          if ((v97 & 0x80u) != 0)
            v107 = "Response";
          else
            v107 = "Query";
          v108 = a8[3];
          v109 = v108 & 0xF;
          if ((v108 & 0xFu) >= 0xB)
          {
            v110 = "??";
            if ((v108 & 0xF) == 0xB)
              v110 = "DSOTypeNI";
          }
          else
          {
            v110 = off_10013BA88[v109];
          }
          v113 = *((unsigned __int16 *)a8 + 3);
          v114 = " AA";
          v115 = *((unsigned __int16 *)a8 + 4);
          v116 = *((unsigned __int16 *)a8 + 5);
          if ((v97 & 4) == 0)
            v114 = "";
          *(_DWORD *)v134 = 67114243;
          v135 = v106;
          if ((v97 & 2) != 0)
            v117 = " TC";
          else
            v117 = "";
          v136 = 2082;
          v137 = v98;
          if ((v97 & 1) != 0)
            v118 = " RD";
          else
            v118 = "";
          v138 = 2082;
          v139 = v107;
          v140 = 2048;
          if ((v108 & 0x80u) != 0)
            v119 = " RA";
          else
            v119 = "";
          v141 = a9 - (_QWORD)a8;
          v120 = " AD";
          v142 = 1024;
          if ((v108 & 0x20) == 0)
            v120 = "";
          v143 = v97;
          v121 = " CD";
          v144 = 1024;
          if ((v108 & 0x10) == 0)
            v121 = "";
        }
        v145 = v108;
        v146 = 2082;
        v147 = v110;
        v148 = 1024;
        v149 = v109;
        v150 = 2082;
        v151 = v114;
        v152 = 2082;
        v153 = v117;
        v154 = 2082;
        v155 = v118;
        v156 = 2082;
        v157 = v119;
        v158 = 2082;
        v159 = v120;
        v160 = 2082;
        v161 = v121;
        v162 = 2160;
        v163 = 1752392040;
        v164 = 2085;
        v165 = v177;
        v166 = 1024;
        v167 = v113;
        v168 = 1024;
        v169 = v115;
        v170 = 1024;
        v171 = v116;
        v172 = 2160;
        v173 = 1752392040;
        v174 = 2085;
        v175 = v176;
        v28 = "[Q%u] DNS %{public}s%{public}s (%lu) (flags %02X%02X) RCODE: %{public}s (%d)%{public}s%{public}s%{public}s"
              "%{public}s%{public}s%{public}s:%{sensitive, mask.hash}s %u/%u/%u %{sensitive, mask.hash}s";
        v102 = v134;
        v103 = v95;
        v104 = OS_LOG_TYPE_DEFAULT;
        v105 = 184;
        goto LABEL_149;
      }
      *(_DWORD *)buf = 67112451;
      v23 = &v129;
      *(_DWORD *)&buf[4] = __rev16(v20);
      if (a4)
        v24 = a4;
      else
        v24 = &v129;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = v133;
      v25 = bswap32(a5) >> 16;
      *(_WORD *)&buf[18] = 2082;
      if (a6)
        v23 = a6;
    }
    else
    {
      v21 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_38;
      *(_DWORD *)buf = 67112451;
      v23 = &v129;
      *(_DWORD *)&buf[4] = __rev16(v20);
      if (a4)
        v24 = a4;
      else
        v24 = &v129;
      *(_WORD *)&buf[8] = 2082;
      *(_QWORD *)&buf[10] = v133;
      v25 = bswap32(a5) >> 16;
      *(_WORD *)&buf[18] = 2082;
      if (a6)
        v23 = a6;
    }
    *(_QWORD *)&buf[20] = a3;
    *(_WORD *)&buf[28] = 2048;
    *(_QWORD *)&buf[30] = a9 - (_QWORD)a8;
    *(_WORD *)&buf[38] = 2160;
    *(_QWORD *)&buf[40] = 1752392040;
    LOWORD(v179) = 1045;
    *(_DWORD *)((char *)&v179 + 2) = 20;
    WORD3(v179) = 2101;
    *((_QWORD *)&v179 + 1) = v24;
    LOWORD(v180) = 1024;
    *(_DWORD *)((char *)&v180 + 2) = v25;
    WORD3(v180) = 2160;
    *((_QWORD *)&v180 + 1) = 1752392040;
    LOWORD(v181) = 1045;
    *(_DWORD *)((char *)&v181 + 2) = 20;
    WORD3(v181) = 2101;
    *((_QWORD *)&v181 + 1) = v23;
    LOWORD(v182) = 1024;
    *(_DWORD *)((char *)&v182 + 2) = bswap32(a7) >> 16;
    WORD3(v182) = 2082;
    *((_QWORD *)&v182 + 1) = v19;
    LOWORD(v183) = 2048;
    *(_QWORD *)((char *)&v183 + 2) = a10;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "[Q%u] %{public}s %{public}s DNS Message %lu bytes from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P:%d to %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P:%d via %{public}s (%p)", buf, 0x7Au);
    goto LABEL_38;
  }
  DumpMDNSPacket(a2, a8, a9, a4, a5, a6, a7, a10, v19);
  if (!a1)
    return;
  v26 = gSensitiveLoggingEnabled;
  v27 = mDNSLogCategory_mDNS;
  if (mDNSLogCategory_mDNS == mDNSLogCategory_State)
    v26 = 0;
  if (a2)
  {
    if ((v26 & 1) != 0)
    {
      v27 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
        return;
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = a1;
      v28 = "Sending mDNS message failed - mStatus: %d";
    }
    else
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
        return;
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = a1;
      v28 = "Sending mDNS message failed - mStatus: %d";
    }
  }
  else if ((v26 & 1) != 0)
  {
    v27 = mDNSLogCategory_mDNS_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = a1;
    v28 = "Receiving mDNS message failed - mStatus: %d";
  }
  else
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = a1;
    v28 = "Receiving mDNS message failed - mStatus: %d";
  }
  v102 = buf;
  v103 = v27;
  v104 = OS_LOG_TYPE_ERROR;
  v105 = 8;
LABEL_149:
  _os_log_impl((void *)&_mh_execute_header, v103, v104, v28, v102, v105);
}

void DumpMDNSPacket(int a1, unsigned __int8 *a2, unint64_t a3, _DWORD *a4, __int16 a5, _DWORD *a6, unsigned __int16 a7, unsigned int a8, uint64_t a9)
{
  unsigned __int8 *v15;
  uint64_t v16;
  _BOOL4 IsDNSMulticast;
  _BOOL4 v18;
  int v19;
  unsigned __int8 *v20;
  uint64_t v21;
  int v22;
  unsigned __int8 *v23;
  uint64_t v24;
  int v25;
  int v26;
  int v27;
  uint64_t v28;
  _DWORD *v29;
  int v30;
  uint64_t v31;
  int v32;
  int v33;
  uint64_t v34;
  _DWORD *v35;
  uint64_t i;
  uint64_t v37;
  uint64_t v38;
  uint64_t j;
  unsigned int v40;
  uint64_t v41;
  int *v42;
  int *v43;
  int v44;
  uint64_t v45;
  int v46;
  unsigned int v47;
  uint64_t v48;
  int *v49;
  int *v50;
  int v51;
  uint64_t v52;
  char v53;
  int v54;
  int v55;
  int v56;
  int v57;
  BOOL v58;
  unsigned int v59;
  int v60;
  unint64_t v61;
  uint64_t v62;
  BOOL v63;
  unsigned int v64;
  _OWORD *v65;
  _BYTE *v66;
  unsigned int v67;
  int v68;
  unsigned int v69;
  unsigned __int8 *v70;
  unsigned int v71;
  unsigned __int8 *v72;
  unsigned int v73;
  unsigned __int8 *v74;
  unsigned int v75;
  unsigned int v76;
  uint64_t v77;
  _OWORD *v78;
  char v79;
  uint64_t v80;
  const char *v81;
  uint64_t v82;
  NSObject *v83;
  uint32_t v84;
  BOOL v85;
  uint64_t v86;
  int v87;
  unsigned int v88;
  char v89;
  char v90;
  _DWORD *v91;
  unsigned int v92;
  int v93;
  _BOOL4 v94;
  int v97;
  unsigned __int16 v98;
  uint8_t buf[4];
  int v100;
  __int16 v101;
  int v102;
  __int16 v103;
  _BYTE v104[14];
  __int16 v105;
  _BYTE v106[24];
  __int16 v107;
  _BYTE v108[14];
  __int16 v109;
  _OWORD *v110;
  __int16 v111;
  uint64_t v112;
  __int16 v113;
  int v114;
  __int16 v115;
  _OWORD *v116;
  _OWORD v117[4];

  v15 = a2 + 12;
  v16 = (a3 - (_DWORD)a2);
  v97 = a2[2];
  if (a6)
  {
    IsDNSMulticast = mDNSAddrIsDNSMulticast(a6);
    v18 = a7 == 59668;
    if (IsDNSMulticast)
      v18 = 0;
    v94 = v18;
  }
  else
  {
    v94 = 0;
  }
  v19 = -2128831035;
  if ((_DWORD)v16)
  {
    v20 = a2;
    v21 = v16;
    do
    {
      v22 = *v20++;
      v19 = 16777619 * (v19 ^ v22);
      --v21;
    }
    while (v21);
    v23 = a2;
    v24 = v16;
    do
    {
      v25 = *v23++;
      LODWORD(v21) = v25 + 65599 * v21;
      --v24;
    }
    while (v24);
  }
  else
  {
    LODWORD(v21) = 0;
  }
  v26 = v21;
  v27 = v19;
  if (a4)
  {
    v28 = 0;
    v29 = a4 + 1;
    v30 = v19;
    do
      v30 = 16777619 * (v30 ^ *((unsigned __int8 *)v29 + v28++));
    while (v28 != 4);
    v31 = 0;
    v32 = v30 ^ a5;
    v33 = v21;
    do
      v33 = *((unsigned __int8 *)v29 + v31++) + 65599 * v33;
    while (v31 != 4);
    v26 = HIBYTE(a5) + 65599 * (a5 + 65599 * v33);
    v27 = 16777619 * ((16777619 * v32) ^ HIBYTE(a5));
  }
  v93 = v16;
  if (a6)
  {
    v34 = 0;
    v35 = a6 + 1;
    do
      v27 = 16777619 * (v27 ^ *((unsigned __int8 *)v35 + v34++));
    while (v34 != 4);
    for (i = 0; i != 4; ++i)
      v26 = *((unsigned __int8 *)v35 + i) + 65599 * v26;
    v26 = HIBYTE(a7) + 65599 * (a7 + 65599 * v26);
    v27 = 16777619 * ((16777619 * (v27 ^ a7)) ^ HIBYTE(a7));
  }
  v37 = 0;
  v38 = a9;
  *(_DWORD *)buf = bswap32(a8);
  do
    v27 = 16777619 * (v27 ^ buf[v37++]);
  while (v37 != 4);
  for (j = 0; j != 4; ++j)
    v26 = buf[j] + 65599 * v26;
  v40 = DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextMsgHashUninitializedSlot;
  if (DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextMsgHashUninitializedSlot >= 0x14)
    v41 = 20;
  else
    v41 = DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextMsgHashUninitializedSlot;
  if ((_DWORD)v41)
  {
    v42 = DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_previousMsg2ndHashes;
    v43 = DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_previousMsgHashes;
    while (1)
    {
      v44 = *v43++;
      if (v44 == v19 && *v42 == (_DWORD)v21)
        break;
      ++v42;
      if (!--v41)
        goto LABEL_37;
    }
    v46 = 0;
  }
  else
  {
LABEL_37:
    v45 = DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextMsgHashSlot;
    DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_previousMsgHashes[DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextMsgHashSlot] = v19;
    DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_previousMsg2ndHashes[v45] = v21;
    DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextMsgHashSlot = ((int)v45 + 1) % 0x14u;
    if (v40 <= 0x13)
      DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextMsgHashUninitializedSlot = v40 + 1;
    v46 = 1;
  }
  v47 = DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextCompleteHashUninitializedSlot;
  if (DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextCompleteHashUninitializedSlot >= 0x14)
    v48 = 20;
  else
    v48 = DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextCompleteHashUninitializedSlot;
  if ((_DWORD)v48)
  {
    v49 = DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_previousComplete2ndHashes;
    v50 = DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_previousCompleteHashes;
    while (1)
    {
      v51 = *v50++;
      if (v51 == v27 && *v49 == v26)
        break;
      ++v49;
      if (!--v48)
        goto LABEL_49;
    }
    v53 = 0;
  }
  else
  {
LABEL_49:
    v52 = DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextCompleteHashSlot;
    DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_previousCompleteHashes[DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextCompleteHashSlot] = v27;
    DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_previousComplete2ndHashes[v52] = v26;
    DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextCompleteHashSlot = ((int)v52 + 1) % 0x14u;
    if (v47 <= 0x13)
      DumpMDNSPacket_CalculateAndCheckIfMsgAppearsBefore_nextCompleteHashUninitializedSlot = v47 + 1;
    v53 = 1;
  }
  v56 = *((unsigned __int16 *)a2 + 2);
  v57 = *((unsigned __int16 *)a2 + 3);
  if (!a4)
  {
    if (!a6)
    {
      v58 = 1;
      goto LABEL_60;
    }
LABEL_58:
    v58 = *a6 != 6;
    goto LABEL_60;
  }
  v58 = *a4 != 6;
  if (a6 && *a4 != 6)
    goto LABEL_58;
LABEL_60:
  v59 = a2[3];
  v54 = *a2;
  v55 = a2[1];
  v60 = (v54 << 24) | (v55 << 16) | (v97 << 8);
  v61 = ((unint64_t)*((unsigned __int16 *)a2 + 2) << 48) & 0xFF00000000000000 | ((unint64_t)*((_WORD *)a2 + 2) << 48) | ((unint64_t)HIBYTE(*((_WORD *)a2 + 3)) << 40) | ((unint64_t)*((_WORD *)a2 + 3) << 32) | ((unint64_t)HIBYTE(*((unsigned __int16 *)a2 + 4)) << 24) | ((unint64_t)*((_WORD *)a2 + 4) << 16);
  v62 = *((unsigned __int16 *)a2 + 5);
  memset(v117, 0, 60);
  v91 = a6;
  if (!v46)
  {
    v68 = 0;
    goto LABEL_102;
  }
  v92 = a8;
  v89 = v53;
  v90 = v46;
  v87 = (v54 << 24) | (v55 << 16) | (v97 << 8);
  v88 = v59;
  v86 = v62;
  if (v56)
  {
    v63 = v58;
    v64 = 0;
    v65 = v117;
    while (1)
    {
      *(_DWORD *)buf = 0;
      v98 = 0;
      if (!DumpMDNSPacket_GetNameHashTypeClass((unint64_t)a2, v15, a3, (int *)buf, &v98))
        break;
      *(_DWORD *)v65 = bswap32(*(unsigned int *)buf);
      *((_WORD *)v65 + 2) = bswap32(v98) >> 16;
      v66 = skipDomainName((unint64_t)a2, v15, a3);
      v15 = v66 + 4;
      if (v66 == (_BYTE *)-4 || !v66 || (unint64_t)v15 > a3)
        break;
      v65 = (_OWORD *)((char *)v65 + 6);
      v67 = v64 + 1;
      if (v64 <= 8)
      {
        ++v64;
        if (v67 < *((unsigned __int16 *)a2 + 2))
          continue;
      }
      v57 = *((unsigned __int16 *)a2 + 3);
      v58 = v63;
      a8 = v92;
      goto LABEL_73;
    }
    v58 = v63;
    a8 = v92;
    goto LABEL_101;
  }
  v67 = 0;
  v65 = v117;
LABEL_73:
  v85 = v58;
  if (v67 <= 9 && v57)
  {
    v69 = 1;
    while (1)
    {
      v64 = v67 + v69 - 1;
      *(_DWORD *)buf = 0;
      v98 = 0;
      if (!DumpMDNSPacket_GetNameHashTypeClass((unint64_t)a2, v15, a3, (int *)buf, &v98))
        break;
      *(_DWORD *)v65 = bswap32(*(unsigned int *)buf);
      *((_WORD *)v65 + 2) = bswap32(v98) >> 16;
      v70 = skipResourceRecord((unint64_t)a2, v15, a3);
      if (!v70)
      {
LABEL_97:
        v76 = v67 + v69;
LABEL_98:
        v64 = v76 - 1;
        break;
      }
      v15 = v70;
      v65 = (_OWORD *)((char *)v65 + 6);
      v71 = v69 + 1;
      if (v69 < *((unsigned __int16 *)a2 + 3))
      {
        ++v69;
        if (v64 < 9)
          continue;
      }
      v67 = v67 + v71 - 1;
      a8 = v92;
      v58 = v85;
      goto LABEL_81;
    }
  }
  else
  {
LABEL_81:
    if (*((_WORD *)a2 + 4) && v67 <= 9)
    {
      v69 = 1;
      while (1)
      {
        v64 = v67 + v69 - 1;
        *(_DWORD *)buf = 0;
        v98 = 0;
        if (!DumpMDNSPacket_GetNameHashTypeClass((unint64_t)a2, v15, a3, (int *)buf, &v98))
          break;
        *(_DWORD *)v65 = bswap32(*(unsigned int *)buf);
        *((_WORD *)v65 + 2) = bswap32(v98) >> 16;
        v72 = skipResourceRecord((unint64_t)a2, v15, a3);
        if (!v72)
          goto LABEL_97;
        v15 = v72;
        v65 = (_OWORD *)((char *)v65 + 6);
        v73 = v69 + 1;
        if (v69 < *((unsigned __int16 *)a2 + 4))
        {
          ++v69;
          if (v64 < 9)
            continue;
        }
        v67 = v67 + v73 - 1;
        a8 = v92;
        v58 = v85;
        goto LABEL_89;
      }
    }
    else
    {
LABEL_89:
      if (!*((_WORD *)a2 + 5) || v67 > 9)
      {
        v64 = v67;
        goto LABEL_101;
      }
      v69 = 1;
      while (1)
      {
        v64 = v67 + v69 - 1;
        *(_DWORD *)buf = 0;
        v98 = 0;
        if (!DumpMDNSPacket_GetNameHashTypeClass((unint64_t)a2, v15, a3, (int *)buf, &v98))
          break;
        *(_DWORD *)v65 = bswap32(*(unsigned int *)buf);
        *((_WORD *)v65 + 2) = bswap32(v98) >> 16;
        v74 = skipResourceRecord((unint64_t)a2, v15, a3);
        if (!v74)
          goto LABEL_97;
        v75 = v69 + 1;
        if (v69 < *((unsigned __int16 *)a2 + 5))
        {
          v15 = v74;
          v65 = (_OWORD *)((char *)v65 + 6);
          ++v69;
          if (v64 < 9)
            continue;
        }
        v76 = v67 + v75;
        goto LABEL_98;
      }
    }
  }
  a8 = v92;
  v58 = v85;
LABEL_101:
  v68 = 6 * v64;
  v38 = a9;
  v53 = v89;
  LOBYTE(v46) = v90;
  v60 = v87;
  v59 = v88;
  v62 = v86;
LABEL_102:
  v77 = v60 | v59;
  v78 = (_OWORD *)(v61 | v62);
  v79 = gSensitiveLoggingEnabled;
  v80 = mDNSLogCategory_mDNS;
  if (mDNSLogCategory_mDNS == mDNSLogCategory_State)
    v79 = 0;
  if (!v94)
  {
    if (v58)
    {
      if (!a1)
      {
        if ((v97 & 0x80) != 0)
        {
          if ((v53 & 1) != 0)
          {
            if ((v46 & 1) != 0)
            {
              if ((v79 & 1) != 0)
              {
                v80 = mDNSLogCategory_mDNS_redacted;
                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                  return;
              }
              else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
              {
                return;
              }
              *(_DWORD *)buf = 67112195;
              v100 = v19;
              v101 = 1024;
              v102 = v27;
              v103 = 1024;
              *(_DWORD *)v104 = v93;
              *(_WORD *)&v104[4] = 2160;
              *(_QWORD *)&v104[6] = 1752392040;
              v105 = 1045;
              *(_DWORD *)v106 = 20;
              *(_WORD *)&v106[4] = 2101;
              *(_QWORD *)&v106[6] = a4;
              *(_WORD *)&v106[14] = 2082;
              *(_QWORD *)&v106[16] = v38;
              v107 = 1024;
              *(_DWORD *)v108 = a8;
              *(_WORD *)&v108[4] = 2048;
              *(_QWORD *)&v108[6] = v77;
              v109 = 2048;
              v110 = v78;
              v111 = 2160;
              v112 = 1752392040;
              v113 = 1040;
              v114 = v68;
              v115 = 2101;
              v116 = v117;
              v81 = "[Q(%x, %x)] Received %u-byte IPv4 mDNS response from %{sensitive, mask.hash, mdnsresponder:ip_addr}."
                    "20P over multicast via %{public}s/%u -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX %{"
                    "sensitive, mask.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
              goto LABEL_388;
            }
            if ((v79 & 1) != 0)
            {
              v80 = mDNSLogCategory_mDNS_redacted;
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                return;
            }
            else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            {
              return;
            }
            *(_DWORD *)buf = 67110659;
            v100 = v19;
            v101 = 1024;
            v102 = v27;
            v103 = 2160;
            *(_QWORD *)v104 = 1752392040;
            *(_WORD *)&v104[8] = 1045;
            *(_DWORD *)&v104[10] = 20;
            v105 = 2101;
            *(_QWORD *)v106 = a4;
            *(_WORD *)&v106[8] = 2082;
            *(_QWORD *)&v106[10] = v38;
            *(_WORD *)&v106[18] = 1024;
            *(_DWORD *)&v106[20] = a8;
            v81 = "[Q(%x, %x)] Received a previous IPv4 mDNS response from %{sensitive, mask.hash, mdnsresponder:ip_addr}"
                  ".20P over multicast via %{public}s/%u";
            goto LABEL_397;
          }
          if ((v79 & 1) != 0)
          {
            v82 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
              return;
            *(_DWORD *)buf = 67109376;
            v100 = v19;
            v101 = 1024;
            v102 = v27;
            v81 = "[Q(%x, %x)] Received a previous IPv4 mDNS response over multicast";
            goto LABEL_267;
          }
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            return;
          *(_DWORD *)buf = 67109376;
          v100 = v19;
          v101 = 1024;
          v102 = v27;
          v81 = "[Q(%x, %x)] Received a previous IPv4 mDNS response over multicast";
        }
        else
        {
          if ((v53 & 1) != 0)
          {
            if ((v46 & 1) != 0)
            {
              if ((v79 & 1) != 0)
              {
                v80 = mDNSLogCategory_mDNS_redacted;
                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                  return;
              }
              else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
              {
                return;
              }
              *(_DWORD *)buf = 67112195;
              v100 = v19;
              v101 = 1024;
              v102 = v27;
              v103 = 1024;
              *(_DWORD *)v104 = v93;
              *(_WORD *)&v104[4] = 2160;
              *(_QWORD *)&v104[6] = 1752392040;
              v105 = 1045;
              *(_DWORD *)v106 = 20;
              *(_WORD *)&v106[4] = 2101;
              *(_QWORD *)&v106[6] = a4;
              *(_WORD *)&v106[14] = 2082;
              *(_QWORD *)&v106[16] = v38;
              v107 = 1024;
              *(_DWORD *)v108 = a8;
              *(_WORD *)&v108[4] = 2048;
              *(_QWORD *)&v108[6] = v77;
              v109 = 2048;
              v110 = v78;
              v111 = 2160;
              v112 = 1752392040;
              v113 = 1040;
              v114 = v68;
              v115 = 2101;
              v116 = v117;
              v81 = "[A(%x, %x)] Received %u-byte IPv4 mDNS query from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P"
                    " over multicast via %{public}s/%u -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX %{sen"
                    "sitive, mask.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
              goto LABEL_388;
            }
            if ((v79 & 1) != 0)
            {
              v80 = mDNSLogCategory_mDNS_redacted;
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                return;
            }
            else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            {
              return;
            }
            *(_DWORD *)buf = 67110659;
            v100 = v19;
            v101 = 1024;
            v102 = v27;
            v103 = 2160;
            *(_QWORD *)v104 = 1752392040;
            *(_WORD *)&v104[8] = 1045;
            *(_DWORD *)&v104[10] = 20;
            v105 = 2101;
            *(_QWORD *)v106 = a4;
            *(_WORD *)&v106[8] = 2082;
            *(_QWORD *)&v106[10] = v38;
            *(_WORD *)&v106[18] = 1024;
            *(_DWORD *)&v106[20] = a8;
            v81 = "[A(%x, %x)] Received a previous IPv4 mDNS query from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20"
                  "P over multicast via %{public}s/%u";
            goto LABEL_397;
          }
          if ((v79 & 1) != 0)
          {
            v82 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
              return;
            *(_DWORD *)buf = 67109376;
            v100 = v19;
            v101 = 1024;
            v102 = v27;
            v81 = "[A(%x, %x)] Received a previous IPv4 mDNS query over multicast";
            goto LABEL_267;
          }
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            return;
          *(_DWORD *)buf = 67109376;
          v100 = v19;
          v101 = 1024;
          v102 = v27;
          v81 = "[A(%x, %x)] Received a previous IPv4 mDNS query over multicast";
        }
        goto LABEL_344;
      }
      if ((v97 & 0x80) != 0)
      {
        if ((v53 & 1) == 0)
        {
          if ((v79 & 1) != 0)
          {
            v82 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
              return;
            *(_DWORD *)buf = 67109376;
            v100 = v19;
            v101 = 1024;
            v102 = v27;
            v81 = "[A(%x, %x)] Sent a previous IPv4 mDNS response over multicast";
            goto LABEL_267;
          }
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            return;
          *(_DWORD *)buf = 67109376;
          v100 = v19;
          v101 = 1024;
          v102 = v27;
          v81 = "[A(%x, %x)] Sent a previous IPv4 mDNS response over multicast";
          goto LABEL_344;
        }
        if ((v46 & 1) != 0)
        {
          if ((v79 & 1) != 0)
          {
            v80 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
              return;
          }
          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            return;
          }
          *(_DWORD *)buf = 67111427;
          v100 = v19;
          v101 = 1024;
          v102 = v27;
          v103 = 1024;
          *(_DWORD *)v104 = v93;
          *(_WORD *)&v104[4] = 2082;
          *(_QWORD *)&v104[6] = v38;
          v105 = 1024;
          *(_DWORD *)v106 = a8;
          *(_WORD *)&v106[4] = 2048;
          *(_QWORD *)&v106[6] = v77;
          *(_WORD *)&v106[14] = 2048;
          *(_QWORD *)&v106[16] = v78;
          v107 = 2160;
          *(_QWORD *)v108 = 1752392040;
          *(_WORD *)&v108[8] = 1040;
          *(_DWORD *)&v108[10] = v68;
          v109 = 2101;
          v110 = v117;
          v81 = "[A(%x, %x)] Sent %u-byte IPv4 mDNS response over multicast via %{public}s/%u -- %{mdns:dns.idflags}08lX,"
                " counts: %{mdns:dns.counts}016llX %{sensitive, mask.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
          goto LABEL_362;
        }
        if ((v79 & 1) != 0)
        {
          v80 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
            return;
        }
        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        {
          return;
        }
        *(_DWORD *)buf = 67109890;
        v100 = v19;
        v101 = 1024;
        v102 = v27;
        v103 = 2082;
        *(_QWORD *)v104 = v38;
        *(_WORD *)&v104[8] = 1024;
        *(_DWORD *)&v104[10] = a8;
        v81 = "[A(%x, %x)] Sent a previous IPv4 mDNS response over multicast via %{public}s/%u";
      }
      else
      {
        if ((v53 & 1) == 0)
        {
          if ((v79 & 1) != 0)
          {
            v82 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
              return;
            *(_DWORD *)buf = 67109376;
            v100 = v19;
            v101 = 1024;
            v102 = v27;
            v81 = "[Q(%x, %x)] Sent a previous IPv4 mDNS query over multicast";
            goto LABEL_267;
          }
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            return;
          *(_DWORD *)buf = 67109376;
          v100 = v19;
          v101 = 1024;
          v102 = v27;
          v81 = "[Q(%x, %x)] Sent a previous IPv4 mDNS query over multicast";
LABEL_344:
          v83 = v80;
          goto LABEL_345;
        }
        if ((v46 & 1) != 0)
        {
          if ((v79 & 1) != 0)
          {
            v80 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
              return;
          }
          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            return;
          }
          *(_DWORD *)buf = 67111427;
          v100 = v19;
          v101 = 1024;
          v102 = v27;
          v103 = 1024;
          *(_DWORD *)v104 = v93;
          *(_WORD *)&v104[4] = 2082;
          *(_QWORD *)&v104[6] = v38;
          v105 = 1024;
          *(_DWORD *)v106 = a8;
          *(_WORD *)&v106[4] = 2048;
          *(_QWORD *)&v106[6] = v77;
          *(_WORD *)&v106[14] = 2048;
          *(_QWORD *)&v106[16] = v78;
          v107 = 2160;
          *(_QWORD *)v108 = 1752392040;
          *(_WORD *)&v108[8] = 1040;
          *(_DWORD *)&v108[10] = v68;
          v109 = 2101;
          v110 = v117;
          v81 = "[Q(%x, %x)] Sent %u-byte IPv4 mDNS query over multicast via %{public}s/%u -- %{mdns:dns.idflags}08lX, co"
                "unts: %{mdns:dns.counts}016llX %{sensitive, mask.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
LABEL_362:
          v83 = v80;
          v84 = 82;
          goto LABEL_398;
        }
        if ((v79 & 1) != 0)
        {
          v80 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
            return;
        }
        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        {
          return;
        }
        *(_DWORD *)buf = 67109890;
        v100 = v19;
        v101 = 1024;
        v102 = v27;
        v103 = 2082;
        *(_QWORD *)v104 = v38;
        *(_WORD *)&v104[8] = 1024;
        *(_DWORD *)&v104[10] = a8;
        v81 = "[Q(%x, %x)] Sent a previous IPv4 mDNS query over multicast via %{public}s/%u";
      }
    }
    else
    {
      if (!a1)
      {
        if ((v97 & 0x80) != 0)
        {
          if ((v53 & 1) != 0)
          {
            if ((v46 & 1) != 0)
            {
              if ((v79 & 1) != 0)
              {
                v80 = mDNSLogCategory_mDNS_redacted;
                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                  return;
              }
              else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
              {
                return;
              }
              *(_DWORD *)buf = 67112195;
              v100 = v19;
              v101 = 1024;
              v102 = v27;
              v103 = 1024;
              *(_DWORD *)v104 = v93;
              *(_WORD *)&v104[4] = 2160;
              *(_QWORD *)&v104[6] = 1752392040;
              v105 = 1045;
              *(_DWORD *)v106 = 20;
              *(_WORD *)&v106[4] = 2101;
              *(_QWORD *)&v106[6] = a4;
              *(_WORD *)&v106[14] = 2082;
              *(_QWORD *)&v106[16] = v38;
              v107 = 1024;
              *(_DWORD *)v108 = a8;
              *(_WORD *)&v108[4] = 2048;
              *(_QWORD *)&v108[6] = v77;
              v109 = 2048;
              v110 = v78;
              v111 = 2160;
              v112 = 1752392040;
              v113 = 1040;
              v114 = v68;
              v115 = 2101;
              v116 = v117;
              v81 = "[Q(%x, %x)] Received %u-byte IPv6 mDNS response from %{sensitive, mask.hash, mdnsresponder:ip_addr}."
                    "20P over multicast via %{public}s/%u -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX %{"
                    "sensitive, mask.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
              goto LABEL_388;
            }
            if ((v79 & 1) != 0)
            {
              v80 = mDNSLogCategory_mDNS_redacted;
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                return;
            }
            else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            {
              return;
            }
            *(_DWORD *)buf = 67110659;
            v100 = v19;
            v101 = 1024;
            v102 = v27;
            v103 = 2160;
            *(_QWORD *)v104 = 1752392040;
            *(_WORD *)&v104[8] = 1045;
            *(_DWORD *)&v104[10] = 20;
            v105 = 2101;
            *(_QWORD *)v106 = a4;
            *(_WORD *)&v106[8] = 2082;
            *(_QWORD *)&v106[10] = v38;
            *(_WORD *)&v106[18] = 1024;
            *(_DWORD *)&v106[20] = a8;
            v81 = "[Q(%x, %x)] Received a previous IPv6 mDNS response from %{sensitive, mask.hash, mdnsresponder:ip_addr}"
                  ".20P over multicast via %{public}s/%u";
            goto LABEL_397;
          }
          if ((v79 & 1) != 0)
          {
            v82 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
              return;
            *(_DWORD *)buf = 67109376;
            v100 = v19;
            v101 = 1024;
            v102 = v27;
            v81 = "[Q(%x, %x)] Received a previous IPv6 mDNS response over multicast";
            goto LABEL_267;
          }
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            return;
          *(_DWORD *)buf = 67109376;
          v100 = v19;
          v101 = 1024;
          v102 = v27;
          v81 = "[Q(%x, %x)] Received a previous IPv6 mDNS response over multicast";
        }
        else
        {
          if ((v53 & 1) != 0)
          {
            if ((v46 & 1) != 0)
            {
              if ((v79 & 1) != 0)
              {
                v80 = mDNSLogCategory_mDNS_redacted;
                if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                  return;
              }
              else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
              {
                return;
              }
              *(_DWORD *)buf = 67112195;
              v100 = v19;
              v101 = 1024;
              v102 = v27;
              v103 = 1024;
              *(_DWORD *)v104 = v93;
              *(_WORD *)&v104[4] = 2160;
              *(_QWORD *)&v104[6] = 1752392040;
              v105 = 1045;
              *(_DWORD *)v106 = 20;
              *(_WORD *)&v106[4] = 2101;
              *(_QWORD *)&v106[6] = a4;
              *(_WORD *)&v106[14] = 2082;
              *(_QWORD *)&v106[16] = v38;
              v107 = 1024;
              *(_DWORD *)v108 = a8;
              *(_WORD *)&v108[4] = 2048;
              *(_QWORD *)&v108[6] = v77;
              v109 = 2048;
              v110 = v78;
              v111 = 2160;
              v112 = 1752392040;
              v113 = 1040;
              v114 = v68;
              v115 = 2101;
              v116 = v117;
              v81 = "[A(%x, %x)] Received %u-byte IPv6 mDNS query from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P"
                    " over multicast via %{public}s/%u -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX %{sen"
                    "sitive, mask.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
              goto LABEL_388;
            }
            if ((v79 & 1) != 0)
            {
              v80 = mDNSLogCategory_mDNS_redacted;
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                return;
            }
            else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            {
              return;
            }
            *(_DWORD *)buf = 67110659;
            v100 = v19;
            v101 = 1024;
            v102 = v27;
            v103 = 2160;
            *(_QWORD *)v104 = 1752392040;
            *(_WORD *)&v104[8] = 1045;
            *(_DWORD *)&v104[10] = 20;
            v105 = 2101;
            *(_QWORD *)v106 = a4;
            *(_WORD *)&v106[8] = 2082;
            *(_QWORD *)&v106[10] = v38;
            *(_WORD *)&v106[18] = 1024;
            *(_DWORD *)&v106[20] = a8;
            v81 = "[A(%x, %x)] Received a previous IPv6 mDNS query from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20"
                  "P over multicast via %{public}s/%u";
            goto LABEL_397;
          }
          if ((v79 & 1) != 0)
          {
            v82 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
              return;
            *(_DWORD *)buf = 67109376;
            v100 = v19;
            v101 = 1024;
            v102 = v27;
            v81 = "[A(%x, %x)] Received a previous IPv6 mDNS query over multicast";
            goto LABEL_267;
          }
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            return;
          *(_DWORD *)buf = 67109376;
          v100 = v19;
          v101 = 1024;
          v102 = v27;
          v81 = "[A(%x, %x)] Received a previous IPv6 mDNS query over multicast";
        }
        goto LABEL_344;
      }
      if ((v97 & 0x80) != 0)
      {
        if ((v53 & 1) == 0)
        {
          if ((v79 & 1) != 0)
          {
            v82 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
              return;
            *(_DWORD *)buf = 67109376;
            v100 = v19;
            v101 = 1024;
            v102 = v27;
            v81 = "[A(%x, %x)] Sent a previous IPv6 mDNS response over multicast";
            goto LABEL_267;
          }
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            return;
          *(_DWORD *)buf = 67109376;
          v100 = v19;
          v101 = 1024;
          v102 = v27;
          v81 = "[A(%x, %x)] Sent a previous IPv6 mDNS response over multicast";
          goto LABEL_344;
        }
        if ((v46 & 1) != 0)
        {
          if ((v79 & 1) != 0)
          {
            v80 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
              return;
          }
          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            return;
          }
          *(_DWORD *)buf = 67111427;
          v100 = v19;
          v101 = 1024;
          v102 = v27;
          v103 = 1024;
          *(_DWORD *)v104 = v93;
          *(_WORD *)&v104[4] = 2082;
          *(_QWORD *)&v104[6] = v38;
          v105 = 1024;
          *(_DWORD *)v106 = a8;
          *(_WORD *)&v106[4] = 2048;
          *(_QWORD *)&v106[6] = v77;
          *(_WORD *)&v106[14] = 2048;
          *(_QWORD *)&v106[16] = v78;
          v107 = 2160;
          *(_QWORD *)v108 = 1752392040;
          *(_WORD *)&v108[8] = 1040;
          *(_DWORD *)&v108[10] = v68;
          v109 = 2101;
          v110 = v117;
          v81 = "[A(%x, %x)] Sent %u-byte IPv6 mDNS response over multicast via %{public}s/%u -- %{mdns:dns.idflags}08lX,"
                " counts: %{mdns:dns.counts}016llX %{sensitive, mask.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
          goto LABEL_362;
        }
        if ((v79 & 1) != 0)
        {
          v80 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
            return;
        }
        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        {
          return;
        }
        *(_DWORD *)buf = 67109890;
        v100 = v19;
        v101 = 1024;
        v102 = v27;
        v103 = 2082;
        *(_QWORD *)v104 = v38;
        *(_WORD *)&v104[8] = 1024;
        *(_DWORD *)&v104[10] = a8;
        v81 = "[A(%x, %x)] Sent a previous IPv6 mDNS response over multicast via %{public}s/%u";
      }
      else
      {
        if ((v53 & 1) == 0)
        {
          if ((v79 & 1) != 0)
          {
            v82 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
              return;
            *(_DWORD *)buf = 67109376;
            v100 = v19;
            v101 = 1024;
            v102 = v27;
            v81 = "[Q(%x, %x)] Sent a previous IPv6 mDNS query over multicast";
            goto LABEL_267;
          }
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            return;
          *(_DWORD *)buf = 67109376;
          v100 = v19;
          v101 = 1024;
          v102 = v27;
          v81 = "[Q(%x, %x)] Sent a previous IPv6 mDNS query over multicast";
          goto LABEL_344;
        }
        if ((v46 & 1) != 0)
        {
          if ((v79 & 1) != 0)
          {
            v80 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
              return;
          }
          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            return;
          }
          *(_DWORD *)buf = 67111427;
          v100 = v19;
          v101 = 1024;
          v102 = v27;
          v103 = 1024;
          *(_DWORD *)v104 = v93;
          *(_WORD *)&v104[4] = 2082;
          *(_QWORD *)&v104[6] = v38;
          v105 = 1024;
          *(_DWORD *)v106 = a8;
          *(_WORD *)&v106[4] = 2048;
          *(_QWORD *)&v106[6] = v77;
          *(_WORD *)&v106[14] = 2048;
          *(_QWORD *)&v106[16] = v78;
          v107 = 2160;
          *(_QWORD *)v108 = 1752392040;
          *(_WORD *)&v108[8] = 1040;
          *(_DWORD *)&v108[10] = v68;
          v109 = 2101;
          v110 = v117;
          v81 = "[Q(%x, %x)] Sent %u-byte IPv6 mDNS query over multicast via %{public}s/%u -- %{mdns:dns.idflags}08lX, co"
                "unts: %{mdns:dns.counts}016llX %{sensitive, mask.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
          goto LABEL_362;
        }
        if ((v79 & 1) != 0)
        {
          v80 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
            return;
        }
        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        {
          return;
        }
        *(_DWORD *)buf = 67109890;
        v100 = v19;
        v101 = 1024;
        v102 = v27;
        v103 = 2082;
        *(_QWORD *)v104 = v38;
        *(_WORD *)&v104[8] = 1024;
        *(_DWORD *)&v104[10] = a8;
        v81 = "[Q(%x, %x)] Sent a previous IPv6 mDNS query over multicast via %{public}s/%u";
      }
    }
    v83 = v80;
    v84 = 30;
    goto LABEL_398;
  }
  if (!v58)
  {
    if (a1)
    {
      if ((v97 & 0x80) != 0)
      {
        if ((v53 & 1) != 0)
        {
          if ((v46 & 1) != 0)
          {
            if ((v79 & 1) != 0)
            {
              v80 = mDNSLogCategory_mDNS_redacted;
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                return;
            }
            else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            {
              return;
            }
            *(_DWORD *)buf = 67112195;
            v100 = v19;
            v101 = 1024;
            v102 = v27;
            v103 = 1024;
            *(_DWORD *)v104 = v93;
            *(_WORD *)&v104[4] = 2160;
            *(_QWORD *)&v104[6] = 1752392040;
            v105 = 1045;
            *(_DWORD *)v106 = 20;
            *(_WORD *)&v106[4] = 2101;
            *(_QWORD *)&v106[6] = v91;
            *(_WORD *)&v106[14] = 2082;
            *(_QWORD *)&v106[16] = v38;
            v107 = 1024;
            *(_DWORD *)v108 = a8;
            *(_WORD *)&v108[4] = 2048;
            *(_QWORD *)&v108[6] = v77;
            v109 = 2048;
            v110 = v78;
            v111 = 2160;
            v112 = 1752392040;
            v113 = 1040;
            v114 = v68;
            v115 = 2101;
            v116 = v117;
            v81 = "[A(%x, %x)] Sent %u-byte IPv6 mDNS response to %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P over"
                  " unicast via %{public}s/%u -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX %{sensitive, m"
                  "ask.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
            goto LABEL_388;
          }
          if ((v79 & 1) != 0)
          {
            v80 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
              return;
          }
          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            return;
          }
          *(_DWORD *)buf = 67110659;
          v100 = v19;
          v101 = 1024;
          v102 = v27;
          v103 = 2160;
          *(_QWORD *)v104 = 1752392040;
          *(_WORD *)&v104[8] = 1045;
          *(_DWORD *)&v104[10] = 20;
          v105 = 2101;
          *(_QWORD *)v106 = v91;
          *(_WORD *)&v106[8] = 2082;
          *(_QWORD *)&v106[10] = v38;
          *(_WORD *)&v106[18] = 1024;
          *(_DWORD *)&v106[20] = a8;
          v81 = "[A(%x, %x)] Sent a previous IPv6 mDNS response to %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P ove"
                "r unicast via %{public}s/%u";
          goto LABEL_397;
        }
        if ((v79 & 1) != 0)
        {
          v82 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
            return;
          *(_DWORD *)buf = 67109376;
          v100 = v19;
          v101 = 1024;
          v102 = v27;
          v81 = "[A(%x, %x)] Sent a previous IPv6 mDNS response over unicast";
          goto LABEL_267;
        }
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          return;
        *(_DWORD *)buf = 67109376;
        v100 = v19;
        v101 = 1024;
        v102 = v27;
        v81 = "[A(%x, %x)] Sent a previous IPv6 mDNS response over unicast";
      }
      else
      {
        if ((v53 & 1) != 0)
        {
          if ((v46 & 1) != 0)
          {
            if ((v79 & 1) != 0)
            {
              v80 = mDNSLogCategory_mDNS_redacted;
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
                return;
            }
            else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
            {
              return;
            }
            *(_DWORD *)buf = 67112195;
            v100 = v19;
            v101 = 1024;
            v102 = v27;
            v103 = 1024;
            *(_DWORD *)v104 = v93;
            *(_WORD *)&v104[4] = 2160;
            *(_QWORD *)&v104[6] = 1752392040;
            v105 = 1045;
            *(_DWORD *)v106 = 20;
            *(_WORD *)&v106[4] = 2101;
            *(_QWORD *)&v106[6] = v91;
            *(_WORD *)&v106[14] = 2082;
            *(_QWORD *)&v106[16] = v38;
            v107 = 1024;
            *(_DWORD *)v108 = a8;
            *(_WORD *)&v108[4] = 2048;
            *(_QWORD *)&v108[6] = v77;
            v109 = 2048;
            v110 = v78;
            v111 = 2160;
            v112 = 1752392040;
            v113 = 1040;
            v114 = v68;
            v115 = 2101;
            v116 = v117;
            v81 = "[Q(%x, %x)] Sent %u-byte IPv6 mDNS query to %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P over un"
                  "icast via %{public}s/%u -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX %{sensitive, mask"
                  ".hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
            goto LABEL_388;
          }
          if ((v79 & 1) != 0)
          {
            v80 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
              return;
          }
          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            return;
          }
          *(_DWORD *)buf = 67110659;
          v100 = v19;
          v101 = 1024;
          v102 = v27;
          v103 = 2160;
          *(_QWORD *)v104 = 1752392040;
          *(_WORD *)&v104[8] = 1045;
          *(_DWORD *)&v104[10] = 20;
          v105 = 2101;
          *(_QWORD *)v106 = v91;
          *(_WORD *)&v106[8] = 2082;
          *(_QWORD *)&v106[10] = v38;
          *(_WORD *)&v106[18] = 1024;
          *(_DWORD *)&v106[20] = a8;
          v81 = "[Q(%x, %x)] Sent a previous IPv6 mDNS query to %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P over u"
                "nicast via %{public}s/%u";
LABEL_397:
          v83 = v80;
          v84 = 56;
          goto LABEL_398;
        }
        if ((v79 & 1) != 0)
        {
          v82 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
            return;
          *(_DWORD *)buf = 67109376;
          v100 = v19;
          v101 = 1024;
          v102 = v27;
          v81 = "[Q(%x, %x)] Sent a previous IPv6 mDNS query over unicast";
          goto LABEL_267;
        }
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          return;
        *(_DWORD *)buf = 67109376;
        v100 = v19;
        v101 = 1024;
        v102 = v27;
        v81 = "[Q(%x, %x)] Sent a previous IPv6 mDNS query over unicast";
      }
    }
    else if ((v97 & 0x80) != 0)
    {
      if ((v53 & 1) != 0)
      {
        if ((v46 & 1) != 0)
        {
          if ((v79 & 1) != 0)
          {
            v80 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
              return;
          }
          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            return;
          }
          *(_DWORD *)buf = 67112195;
          v100 = v19;
          v101 = 1024;
          v102 = v27;
          v103 = 1024;
          *(_DWORD *)v104 = v93;
          *(_WORD *)&v104[4] = 2160;
          *(_QWORD *)&v104[6] = 1752392040;
          v105 = 1045;
          *(_DWORD *)v106 = 20;
          *(_WORD *)&v106[4] = 2101;
          *(_QWORD *)&v106[6] = a4;
          *(_WORD *)&v106[14] = 2082;
          *(_QWORD *)&v106[16] = v38;
          v107 = 1024;
          *(_DWORD *)v108 = a8;
          *(_WORD *)&v108[4] = 2048;
          *(_QWORD *)&v108[6] = v77;
          v109 = 2048;
          v110 = v78;
          v111 = 2160;
          v112 = 1752392040;
          v113 = 1040;
          v114 = v68;
          v115 = 2101;
          v116 = v117;
          v81 = "[Q(%x, %x)] Received %u-byte IPv6 mDNS response from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P "
                "over unicast via %{public}s/%u -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX %{sensitive,"
                " mask.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
          goto LABEL_388;
        }
        if ((v79 & 1) != 0)
        {
          v80 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
            return;
        }
        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        {
          return;
        }
        *(_DWORD *)buf = 67110659;
        v100 = v19;
        v101 = 1024;
        v102 = v27;
        v103 = 2160;
        *(_QWORD *)v104 = 1752392040;
        *(_WORD *)&v104[8] = 1045;
        *(_DWORD *)&v104[10] = 20;
        v105 = 2101;
        *(_QWORD *)v106 = a4;
        *(_WORD *)&v106[8] = 2082;
        *(_QWORD *)&v106[10] = v38;
        *(_WORD *)&v106[18] = 1024;
        *(_DWORD *)&v106[20] = a8;
        v81 = "[Q(%x, %x)] Received a previous IPv6 mDNS response from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P"
              " over unicast via %{public}s/%u";
        goto LABEL_397;
      }
      if ((v79 & 1) != 0)
      {
        v82 = mDNSLogCategory_mDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
          return;
        *(_DWORD *)buf = 67109376;
        v100 = v19;
        v101 = 1024;
        v102 = v27;
        v81 = "[Q(%x, %x)] Received a previous IPv6 mDNS response over unicast";
        goto LABEL_267;
      }
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        return;
      *(_DWORD *)buf = 67109376;
      v100 = v19;
      v101 = 1024;
      v102 = v27;
      v81 = "[Q(%x, %x)] Received a previous IPv6 mDNS response over unicast";
    }
    else
    {
      if ((v53 & 1) != 0)
      {
        if ((v46 & 1) != 0)
        {
          if ((v79 & 1) != 0)
          {
            v80 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
              return;
          }
          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            return;
          }
          *(_DWORD *)buf = 67112195;
          v100 = v19;
          v101 = 1024;
          v102 = v27;
          v103 = 1024;
          *(_DWORD *)v104 = v93;
          *(_WORD *)&v104[4] = 2160;
          *(_QWORD *)&v104[6] = 1752392040;
          v105 = 1045;
          *(_DWORD *)v106 = 20;
          *(_WORD *)&v106[4] = 2101;
          *(_QWORD *)&v106[6] = a4;
          *(_WORD *)&v106[14] = 2082;
          *(_QWORD *)&v106[16] = v38;
          v107 = 1024;
          *(_DWORD *)v108 = a8;
          *(_WORD *)&v108[4] = 2048;
          *(_QWORD *)&v108[6] = v77;
          v109 = 2048;
          v110 = v78;
          v111 = 2160;
          v112 = 1752392040;
          v113 = 1040;
          v114 = v68;
          v115 = 2101;
          v116 = v117;
          v81 = "[A(%x, %x)] Received %u-byte IPv6 mDNS query from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P ove"
                "r unicast via %{public}s/%u -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX %{sensitive, ma"
                "sk.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
          goto LABEL_388;
        }
        if ((v79 & 1) != 0)
        {
          v80 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
            return;
        }
        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        {
          return;
        }
        *(_DWORD *)buf = 67110659;
        v100 = v19;
        v101 = 1024;
        v102 = v27;
        v103 = 2160;
        *(_QWORD *)v104 = 1752392040;
        *(_WORD *)&v104[8] = 1045;
        *(_DWORD *)&v104[10] = 20;
        v105 = 2101;
        *(_QWORD *)v106 = a4;
        *(_WORD *)&v106[8] = 2082;
        *(_QWORD *)&v106[10] = v38;
        *(_WORD *)&v106[18] = 1024;
        *(_DWORD *)&v106[20] = a8;
        v81 = "[A(%x, %x)] Received a previous IPv6 mDNS query from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P ov"
              "er unicast via %{public}s/%u";
        goto LABEL_397;
      }
      if ((v79 & 1) != 0)
      {
        v82 = mDNSLogCategory_mDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
          return;
        *(_DWORD *)buf = 67109376;
        v100 = v19;
        v101 = 1024;
        v102 = v27;
        v81 = "[A(%x, %x)] Received a previous IPv6 mDNS query over unicast";
        goto LABEL_267;
      }
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        return;
      *(_DWORD *)buf = 67109376;
      v100 = v19;
      v101 = 1024;
      v102 = v27;
      v81 = "[A(%x, %x)] Received a previous IPv6 mDNS query over unicast";
    }
    goto LABEL_344;
  }
  if (!a1)
  {
    if ((v97 & 0x80) != 0)
    {
      if ((v53 & 1) != 0)
      {
        if ((v46 & 1) != 0)
        {
          if ((v79 & 1) != 0)
          {
            v80 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
              return;
          }
          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            return;
          }
          *(_DWORD *)buf = 67112195;
          v100 = v19;
          v101 = 1024;
          v102 = v27;
          v103 = 1024;
          *(_DWORD *)v104 = v93;
          *(_WORD *)&v104[4] = 2160;
          *(_QWORD *)&v104[6] = 1752392040;
          v105 = 1045;
          *(_DWORD *)v106 = 20;
          *(_WORD *)&v106[4] = 2101;
          *(_QWORD *)&v106[6] = a4;
          *(_WORD *)&v106[14] = 2082;
          *(_QWORD *)&v106[16] = v38;
          v107 = 1024;
          *(_DWORD *)v108 = a8;
          *(_WORD *)&v108[4] = 2048;
          *(_QWORD *)&v108[6] = v77;
          v109 = 2048;
          v110 = v78;
          v111 = 2160;
          v112 = 1752392040;
          v113 = 1040;
          v114 = v68;
          v115 = 2101;
          v116 = v117;
          v81 = "[Q(%x, %x)] Received %u-byte IPv4 mDNS response from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P "
                "over unicast via %{public}s/%u -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX %{sensitive,"
                " mask.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
          goto LABEL_388;
        }
        if ((v79 & 1) != 0)
        {
          v80 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
            return;
        }
        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        {
          return;
        }
        *(_DWORD *)buf = 67110659;
        v100 = v19;
        v101 = 1024;
        v102 = v27;
        v103 = 2160;
        *(_QWORD *)v104 = 1752392040;
        *(_WORD *)&v104[8] = 1045;
        *(_DWORD *)&v104[10] = 20;
        v105 = 2101;
        *(_QWORD *)v106 = a4;
        *(_WORD *)&v106[8] = 2082;
        *(_QWORD *)&v106[10] = v38;
        *(_WORD *)&v106[18] = 1024;
        *(_DWORD *)&v106[20] = a8;
        v81 = "[Q(%x, %x)] Received a previous IPv4 mDNS response from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P"
              " over unicast via %{public}s/%u";
        goto LABEL_397;
      }
      if ((v79 & 1) != 0)
      {
        v82 = mDNSLogCategory_mDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
          return;
        *(_DWORD *)buf = 67109376;
        v100 = v19;
        v101 = 1024;
        v102 = v27;
        v81 = "[Q(%x, %x)] Received a previous IPv4 mDNS response over unicast";
        goto LABEL_267;
      }
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        return;
      *(_DWORD *)buf = 67109376;
      v100 = v19;
      v101 = 1024;
      v102 = v27;
      v81 = "[Q(%x, %x)] Received a previous IPv4 mDNS response over unicast";
    }
    else
    {
      if ((v53 & 1) != 0)
      {
        if ((v46 & 1) != 0)
        {
          if ((v79 & 1) != 0)
          {
            v80 = mDNSLogCategory_mDNS_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
              return;
          }
          else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          {
            return;
          }
          *(_DWORD *)buf = 67112195;
          v100 = v19;
          v101 = 1024;
          v102 = v27;
          v103 = 1024;
          *(_DWORD *)v104 = v93;
          *(_WORD *)&v104[4] = 2160;
          *(_QWORD *)&v104[6] = 1752392040;
          v105 = 1045;
          *(_DWORD *)v106 = 20;
          *(_WORD *)&v106[4] = 2101;
          *(_QWORD *)&v106[6] = a4;
          *(_WORD *)&v106[14] = 2082;
          *(_QWORD *)&v106[16] = v38;
          v107 = 1024;
          *(_DWORD *)v108 = a8;
          *(_WORD *)&v108[4] = 2048;
          *(_QWORD *)&v108[6] = v77;
          v109 = 2048;
          v110 = v78;
          v111 = 2160;
          v112 = 1752392040;
          v113 = 1040;
          v114 = v68;
          v115 = 2101;
          v116 = v117;
          v81 = "[A(%x, %x)] Received %u-byte IPv4 mDNS query from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P ove"
                "r unicast via %{public}s/%u -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX %{sensitive, ma"
                "sk.hash, mdnsresponder:mdns_name_hash_type_bytes}.*P";
          goto LABEL_388;
        }
        if ((v79 & 1) != 0)
        {
          v80 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
            return;
        }
        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        {
          return;
        }
        *(_DWORD *)buf = 67110659;
        v100 = v19;
        v101 = 1024;
        v102 = v27;
        v103 = 2160;
        *(_QWORD *)v104 = 1752392040;
        *(_WORD *)&v104[8] = 1045;
        *(_DWORD *)&v104[10] = 20;
        v105 = 2101;
        *(_QWORD *)v106 = a4;
        *(_WORD *)&v106[8] = 2082;
        *(_QWORD *)&v106[10] = v38;
        *(_WORD *)&v106[18] = 1024;
        *(_DWORD *)&v106[20] = a8;
        v81 = "[A(%x, %x)] Received a previous IPv4 mDNS query from %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P ov"
              "er unicast via %{public}s/%u";
        goto LABEL_397;
      }
      if ((v79 & 1) != 0)
      {
        v82 = mDNSLogCategory_mDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
          return;
        *(_DWORD *)buf = 67109376;
        v100 = v19;
        v101 = 1024;
        v102 = v27;
        v81 = "[A(%x, %x)] Received a previous IPv4 mDNS query over unicast";
        goto LABEL_267;
      }
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        return;
      *(_DWORD *)buf = 67109376;
      v100 = v19;
      v101 = 1024;
      v102 = v27;
      v81 = "[A(%x, %x)] Received a previous IPv4 mDNS query over unicast";
    }
    goto LABEL_344;
  }
  if ((v97 & 0x80) != 0)
  {
    if ((v53 & 1) != 0)
    {
      if ((v46 & 1) != 0)
      {
        if ((v79 & 1) != 0)
        {
          v80 = mDNSLogCategory_mDNS_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
            return;
        }
        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        {
          return;
        }
        *(_DWORD *)buf = 67112195;
        v100 = v19;
        v101 = 1024;
        v102 = v27;
        v103 = 1024;
        *(_DWORD *)v104 = v93;
        *(_WORD *)&v104[4] = 2160;
        *(_QWORD *)&v104[6] = 1752392040;
        v105 = 1045;
        *(_DWORD *)v106 = 20;
        *(_WORD *)&v106[4] = 2101;
        *(_QWORD *)&v106[6] = v91;
        *(_WORD *)&v106[14] = 2082;
        *(_QWORD *)&v106[16] = v38;
        v107 = 1024;
        *(_DWORD *)v108 = a8;
        *(_WORD *)&v108[4] = 2048;
        *(_QWORD *)&v108[6] = v77;
        v109 = 2048;
        v110 = v78;
        v111 = 2160;
        v112 = 1752392040;
        v113 = 1040;
        v114 = v68;
        v115 = 2101;
        v116 = v117;
        v81 = "[A(%x, %x)] Sent %u-byte IPv4 mDNS response to %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P over uni"
              "cast via %{public}s/%u -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX %{sensitive, mask.hash"
              ", mdnsresponder:mdns_name_hash_type_bytes}.*P";
        goto LABEL_388;
      }
      if ((v79 & 1) != 0)
      {
        v80 = mDNSLogCategory_mDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
          return;
      }
      else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
        return;
      }
      *(_DWORD *)buf = 67110659;
      v100 = v19;
      v101 = 1024;
      v102 = v27;
      v103 = 2160;
      *(_QWORD *)v104 = 1752392040;
      *(_WORD *)&v104[8] = 1045;
      *(_DWORD *)&v104[10] = 20;
      v105 = 2101;
      *(_QWORD *)v106 = v91;
      *(_WORD *)&v106[8] = 2082;
      *(_QWORD *)&v106[10] = v38;
      *(_WORD *)&v106[18] = 1024;
      *(_DWORD *)&v106[20] = a8;
      v81 = "[A(%x, %x)] Sent a previous IPv4 mDNS response to %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P over un"
            "icast via %{public}s/%u";
      goto LABEL_397;
    }
    if ((v79 & 1) != 0)
    {
      v82 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
        return;
      *(_DWORD *)buf = 67109376;
      v100 = v19;
      v101 = 1024;
      v102 = v27;
      v81 = "[A(%x, %x)] Sent a previous IPv4 mDNS response over unicast";
      goto LABEL_267;
    }
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      return;
    *(_DWORD *)buf = 67109376;
    v100 = v19;
    v101 = 1024;
    v102 = v27;
    v81 = "[A(%x, %x)] Sent a previous IPv4 mDNS response over unicast";
    goto LABEL_344;
  }
  if ((v53 & 1) != 0)
  {
    if ((v46 & 1) != 0)
    {
      if ((v79 & 1) != 0)
      {
        v80 = mDNSLogCategory_mDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
          return;
      }
      else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
        return;
      }
      *(_DWORD *)buf = 67112195;
      v100 = v19;
      v101 = 1024;
      v102 = v27;
      v103 = 1024;
      *(_DWORD *)v104 = v93;
      *(_WORD *)&v104[4] = 2160;
      *(_QWORD *)&v104[6] = 1752392040;
      v105 = 1045;
      *(_DWORD *)v106 = 20;
      *(_WORD *)&v106[4] = 2101;
      *(_QWORD *)&v106[6] = v91;
      *(_WORD *)&v106[14] = 2082;
      *(_QWORD *)&v106[16] = v38;
      v107 = 1024;
      *(_DWORD *)v108 = a8;
      *(_WORD *)&v108[4] = 2048;
      *(_QWORD *)&v108[6] = v77;
      v109 = 2048;
      v110 = v78;
      v111 = 2160;
      v112 = 1752392040;
      v113 = 1040;
      v114 = v68;
      v115 = 2101;
      v116 = v117;
      v81 = "[Q(%x, %x)] Sent %u-byte IPv4 mDNS query to %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P over unicast "
            "via %{public}s/%u -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX %{sensitive, mask.hash, mdnsr"
            "esponder:mdns_name_hash_type_bytes}.*P";
LABEL_388:
      v83 = v80;
      v84 = 108;
      goto LABEL_398;
    }
    if ((v79 & 1) != 0)
    {
      v80 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
        return;
    }
    else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
    {
      return;
    }
    *(_DWORD *)buf = 67110659;
    v100 = v19;
    v101 = 1024;
    v102 = v27;
    v103 = 2160;
    *(_QWORD *)v104 = 1752392040;
    *(_WORD *)&v104[8] = 1045;
    *(_DWORD *)&v104[10] = 20;
    v105 = 2101;
    *(_QWORD *)v106 = v91;
    *(_WORD *)&v106[8] = 2082;
    *(_QWORD *)&v106[10] = v38;
    *(_WORD *)&v106[18] = 1024;
    *(_DWORD *)&v106[20] = a8;
    v81 = "[Q(%x, %x)] Sent a previous IPv4 mDNS query to %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P over unicast"
          " via %{public}s/%u";
    goto LABEL_397;
  }
  if ((v79 & 1) == 0)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      return;
    *(_DWORD *)buf = 67109376;
    v100 = v19;
    v101 = 1024;
    v102 = v27;
    v81 = "[Q(%x, %x)] Sent a previous IPv4 mDNS query over unicast";
    goto LABEL_344;
  }
  v82 = mDNSLogCategory_mDNS_redacted;
  if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
    return;
  *(_DWORD *)buf = 67109376;
  v100 = v19;
  v101 = 1024;
  v102 = v27;
  v81 = "[Q(%x, %x)] Sent a previous IPv4 mDNS query over unicast";
LABEL_267:
  v83 = v82;
LABEL_345:
  v84 = 14;
LABEL_398:
  _os_log_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_DEFAULT, v81, buf, v84);
}

uint64_t DumpMDNSPacket_GetNameHashTypeClass(unint64_t a1, unsigned __int8 *a2, unint64_t a3, int *a4, _WORD *a5)
{
  int v8;
  uint64_t *v9;
  unsigned __int8 *DomainName;
  uint64_t v11;
  uint64_t v13;
  unsigned __int8 *v14;
  int v15;
  uint64_t v16;
  unsigned int v17;
  _OWORD v19[16];
  uint64_t v20;

  v8 = -2128831035;
  memset(v19, 0, sizeof(v19));
  v9 = (uint64_t *)v19;
  DomainName = getDomainName(a1, a2, a3, v19);
  while (1)
  {
    v11 = *(unsigned __int8 *)v9;
    if (v11 > 0x3F)
    {
LABEL_9:
      LODWORD(v13) = 257;
      goto LABEL_11;
    }
    if (!*(_BYTE *)v9)
      break;
    v9 = (uint64_t *)((char *)v9 + v11 + 1);
    if (v9 >= &v20 || v9 == 0)
      goto LABEL_9;
  }
  LODWORD(v13) = (unsigned __int16)((_WORD)v9 - (unsigned __int16)v19 + 1);
  if ((_WORD)v9 - (unsigned __int16)v19 == 0xFFFF)
    goto LABEL_13;
LABEL_11:
  v13 = v13;
  v14 = (unsigned __int8 *)v19;
  do
  {
    v15 = *v14++;
    v8 = 16777619 * (v8 ^ v15);
    --v13;
  }
  while (v13);
LABEL_13:
  v16 = 0;
  if (DomainName && (unint64_t)(DomainName + 4) <= a3)
  {
    v17 = *(unsigned __int16 *)DomainName;
    if (a4)
      *a4 = v8;
    if (a5)
      *a5 = bswap32(v17) >> 16;
    return 1;
  }
  return v16;
}

BOOL DNSQuestionNeedsSensitiveLogging(uint64_t a1)
{
  if (is_apple_internal_build_s_once != -1)
    dispatch_once(&is_apple_internal_build_s_once, &__block_literal_global_2_6036);
  return is_apple_internal_build_is_internal && *(_BYTE *)(a1 + 689) == 1;
}

BOOL DNSQuestionIsEligibleForMDNSAlternativeService(uint64_t a1)
{
  uint64_t v3;
  int v4;
  BOOL v5;

  if (is_airplay_demo_mode_enabled_once != -1)
    dispatch_once(&is_airplay_demo_mode_enabled_once, &__block_literal_global_6035);
  if (is_airplay_demo_mode_enabled_is_demo_mode_enabled || *(_WORD *)(a1 + 340))
    return 0;
  v3 = *(_QWORD *)(a1 + 136);
  if (v3)
  {
    if (AWDLInterfaceID && AWDLInterfaceID == v3)
    {
      v4 = 1;
    }
    else
    {
      if (WiFiAwareInterfaceID)
        v5 = WiFiAwareInterfaceID == v3;
      else
        v5 = 0;
      v4 = v5;
    }
  }
  else
  {
    v4 = (*(_DWORD *)(a1 + 324) >> 20) & 1;
  }
  return v4 == 0;
}

void mDNS_VerifyLockState(char *a1, int a2, unsigned int a3, unsigned int a4, uint64_t a5, int a6)
{
  uint64_t v10;
  const char *v12;
  int v14;
  char v16;
  uint64_t v17;
  uint64_t v19;
  NSObject *v21;
  uint32_t v22;
  int v23;
  char *v24;
  __int16 v25;
  _BYTE v26[14];
  __int16 v27;
  _BYTE v28[10];
  _BYTE v29[6];
  unsigned int v30;
  __int16 v31;
  unsigned int v32;

  if (!a2)
  {
    if (a3 != a4)
    {
      v16 = gSensitiveLoggingEnabled;
      v17 = mDNSLogCategory_Default;
      if (mDNSLogCategory_Default == mDNSLogCategory_State)
        v16 = 0;
      if (a3 <= a4)
      {
        if ((v16 & 1) != 0)
        {
          v17 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
            return;
        }
        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))
        {
          return;
        }
        v23 = 136447746;
        v24 = a1;
        v25 = 2082;
        *(_QWORD *)v26 = a5;
        *(_WORD *)&v26[8] = 1024;
        *(_DWORD *)&v26[10] = a6;
        v27 = 2082;
        *(_QWORD *)v28 = mDNS_VerifyLockState_lastLockOperator;
        *(_WORD *)&v28[8] = 1024;
        *(_DWORD *)v29 = mDNS_VerifyLockState_lineNumberlastLockOperator;
        *(_WORD *)&v29[4] = 1024;
        v30 = a3;
        v31 = 1024;
        v32 = a4;
        v12 = "Lock failure: %{public}s, last lock dropper dropped the lock before grabbing it - caller: %{public}s at li"
              "ne %u, last lock dropper: %{public}s at line %u, mDNS_busy (%u) != mDNS_reentrancy (%u).";
      }
      else
      {
        if ((v16 & 1) != 0)
        {
          v17 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
            return;
        }
        else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))
        {
          return;
        }
        v23 = 136447746;
        v24 = a1;
        v25 = 2082;
        *(_QWORD *)v26 = a5;
        *(_WORD *)&v26[8] = 1024;
        *(_DWORD *)&v26[10] = a6;
        v27 = 2082;
        *(_QWORD *)v28 = mDNS_VerifyLockState_lastLockOperator;
        *(_WORD *)&v28[8] = 1024;
        *(_DWORD *)v29 = mDNS_VerifyLockState_lineNumberlastLockOperator;
        *(_WORD *)&v29[4] = 1024;
        v30 = a3;
        v31 = 1024;
        v32 = a4;
        v12 = "Lock failure: %{public}s, last lock holder still holds the lock - caller: %{public}s at line %u, last succ"
              "essful lock holder: %{public}s at line %u, mDNS_busy (%u) != mDNS_reentrancy (%u).";
      }
      v21 = v17;
      v22 = 56;
      goto LABEL_51;
    }
    v14 = *a1;
    if (v14 <= 75)
    {
      if (v14 == 67)
        return;
      if (v14 == 68)
        goto LABEL_15;
    }
    else
    {
      if (v14 == 85 || v14 == 82)
      {
        os_unfair_lock_lock(&mDNS_VerifyLockState_logLock);
        mDNS_VerifyLockState_lastLockOperator = 0;
        mDNS_VerifyLockState_lineNumberlastLockOperator = 0;
        goto LABEL_45;
      }
      if (v14 == 76)
      {
LABEL_15:
        os_unfair_lock_lock(&mDNS_VerifyLockState_logLock);
        mDNS_VerifyLockState_lastLockOperator = a5;
        mDNS_VerifyLockState_lineNumberlastLockOperator = a6;
LABEL_45:
        os_unfair_lock_unlock(&mDNS_VerifyLockState_logLock);
        return;
      }
    }
    v19 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))
        return;
      v23 = 136446210;
      v24 = a1;
      v12 = "Invalid lock operation - %{public}s";
    }
    else
    {
      v19 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
        return;
      v23 = 136446210;
      v24 = a1;
      v12 = "Invalid lock operation - %{public}s";
    }
    v21 = v19;
    v22 = 12;
    goto LABEL_51;
  }
  if (a4 + 1 >= a3)
  {
    if (a4 + 1 <= a3)
      return;
    v10 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))
        return;
    }
    else
    {
      v10 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
        return;
    }
    v23 = 136447490;
    v24 = (char *)a5;
    v25 = 1024;
    *(_DWORD *)v26 = a6;
    *(_WORD *)&v26[4] = 2082;
    *(_QWORD *)&v26[6] = mDNS_VerifyLockState_lastLockOperator;
    v27 = 1024;
    *(_DWORD *)v28 = mDNS_VerifyLockState_lineNumberlastLockOperator;
    *(_WORD *)&v28[4] = 1024;
    *(_DWORD *)&v28[6] = a3;
    *(_WORD *)v29 = 1024;
    *(_DWORD *)&v29[2] = a4;
    v12 = "Lock failure: Check Lock, last lock dropper dropped the lock before grabbing it - caller: %{public}s at line %"
          "u, last lock dropper: %{public}s at line %u, mDNS_busy (%u) != mDNS_reentrancy (%u).";
    goto LABEL_43;
  }
  v10 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))
      return;
    goto LABEL_9;
  }
  v10 = mDNSLogCategory_Default_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
  {
LABEL_9:
    v23 = 136447490;
    v24 = (char *)a5;
    v25 = 1024;
    *(_DWORD *)v26 = a6;
    *(_WORD *)&v26[4] = 2082;
    *(_QWORD *)&v26[6] = mDNS_VerifyLockState_lastLockOperator;
    v27 = 1024;
    *(_DWORD *)v28 = mDNS_VerifyLockState_lineNumberlastLockOperator;
    *(_WORD *)&v28[4] = 1024;
    *(_DWORD *)&v28[6] = a3;
    *(_WORD *)v29 = 1024;
    *(_DWORD *)&v29[2] = a4;
    v12 = "Lock failure: Check Lock, lock was grabbed by multiple callers - caller: %{public}s at line %u, last successfu"
          "l lock holder: %{public}s at line %u, mDNS_busy (%u) != mDNS_reentrancy (%u).";
LABEL_43:
    v21 = v10;
    v22 = 46;
LABEL_51:
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_FAULT, v12, (uint8_t *)&v23, v22);
  }
}

uint64_t GetReverseIPv6Addr(_BYTE *a1, _OWORD *a2)
{
  unsigned int v3;
  _BYTE *v4;
  int v5;
  char v6;
  uint64_t v7;
  char v8;
  uint64_t result;
  __int128 v10;

  v3 = 0;
  v10 = 0uLL;
  do
  {
    if (*a1 != 1)
      return 0;
    v4 = a1;
    v5 = a1[1];
    if ((v5 - 48) >= 0xA)
    {
      if ((v5 - 97) >= 6)
      {
        if ((v5 - 65) > 5)
          return 0;
        v6 = -55;
      }
      else
      {
        v6 = -87;
      }
    }
    else
    {
      v6 = -48;
    }
    v7 = 15 - (v3 >> 1);
    v8 = v6 + v5;
    if ((v3 & 1) != 0)
      v8 = *((_BYTE *)&v10 + v7) | (16 * v8);
    *((_BYTE *)&v10 + v7) = v8;
    ++v3;
    a1 += 2;
  }
  while (v3 != 32);
  result = SameDomainNameBytes(v4 + 2, "\x03ip6\x04arpa");
  if ((_DWORD)result)
  {
    if (a2)
      *a2 = v10;
    return 1;
  }
  return result;
}

id _mdns_ne_dns_proxy_state_watch_log()
{
  if (_mdns_ne_dns_proxy_state_watch_log_s_once != -1)
    dispatch_once(&_mdns_ne_dns_proxy_state_watch_log_s_once, &__block_literal_global_10);
  return (id)_mdns_ne_dns_proxy_state_watch_log_s_log;
}

id _mdns_ne_dns_proxy_state_watch_queue()
{
  if (_mdns_ne_dns_proxy_state_watch_queue_s_once != -1)
    dispatch_once(&_mdns_ne_dns_proxy_state_watch_queue_s_once, &__block_literal_global_5);
  return (id)_mdns_ne_dns_proxy_state_watch_queue_s_queue;
}

void _mdns_ne_dns_proxy_state_watch_fetch_manager_status(void *a1)
{
  id v1;
  id v2;
  id v3;
  id v4;
  NSObject *v5;
  _BOOL4 v6;
  _QWORD v7[5];
  uint8_t buf[4];
  id v9;

  v1 = a1;
  v2 = objc_msgSend((id)g_managers, "indexOfObjectIdenticalTo:", v1);
  v3 = objc_msgSend((id)g_managers, "count");
  v4 = _mdns_ne_dns_proxy_state_watch_log();
  v5 = objc_claimAutoreleasedReturnValue(v4);
  v6 = os_log_type_enabled(v5, OS_LOG_TYPE_INFO);
  if (v2 >= v3)
  {
    if (v6)
    {
      *(_DWORD *)buf = 134217984;
      v9 = v1;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "Not fetching status for stale manager -- address: %p", buf, 0xCu);
    }

  }
  else
  {
    if (v6)
    {
      *(_DWORD *)buf = 134217984;
      v9 = v1;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "Fetching status for manager -- address: %p", buf, 0xCu);
    }

    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    v7[2] = ___mdns_ne_dns_proxy_state_watch_fetch_manager_status_block_invoke;
    v7[3] = &unk_10013BC60;
    v7[4] = v1;
    objc_msgSend(v1, "fetchStatusWithCompletionHandler:", v7);
  }

}

void ___mdns_ne_dns_proxy_state_watch_fetch_manager_status_block_invoke(uint64_t a1, unint64_t a2)
{
  id v4;
  NSObject *v5;
  uint64_t v6;
  const char *v7;
  id v8;
  NSObject *v9;
  _QWORD v10[6];
  uint8_t buf[4];
  uint64_t v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  unint64_t v16;

  v4 = _mdns_ne_dns_proxy_state_watch_log();
  v5 = objc_claimAutoreleasedReturnValue(v4);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v6 = *(_QWORD *)(a1 + 32);
    if (a2 > 4)
      v7 = "«UNKNOWN STATUS»";
    else
      v7 = off_10013BC98[a2];
    *(_DWORD *)buf = 134218498;
    v12 = v6;
    v13 = 2082;
    v14 = v7;
    v15 = 2048;
    v16 = a2;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Fetched status for manager -- address: %p, status: %{public}s (%lld)", buf, 0x20u);
  }

  v8 = _mdns_ne_dns_proxy_state_watch_queue();
  v9 = objc_claimAutoreleasedReturnValue(v8);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = ___mdns_ne_dns_proxy_state_watch_fetch_manager_status_block_invoke_23;
  v10[3] = &unk_10013BC38;
  v10[4] = *(_QWORD *)(a1 + 32);
  v10[5] = a2;
  dispatch_async(v9, v10);

}

void ___mdns_ne_dns_proxy_state_watch_fetch_manager_status_block_invoke_23(uint64_t a1)
{
  uint64_t v1;
  id v2;
  id v3;
  uint64_t v4;
  void *v5;
  id v6;
  NSObject *v7;
  int v8;
  id v9;

  v1 = *(_QWORD *)(a1 + 40);
  v2 = *(id *)(a1 + 32);
  v3 = objc_msgSend((id)g_managers, "indexOfObjectIdenticalTo:", v2);
  if (v3 >= objc_msgSend((id)g_managers, "count"))
  {
    v6 = _mdns_ne_dns_proxy_state_watch_log();
    v7 = objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v8 = 134217984;
      v9 = v2;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Not handling status update for stale manager -- address: %p", (uint8_t *)&v8, 0xCu);
    }

  }
  else
  {
    if (v1 == 3)
      v4 = 2;
    else
      v4 = 1;
    v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v4));
    objc_msgSend((id)g_states, "setObject:atIndexedSubscript:", v5, v3);

    _mdns_ne_dns_proxy_state_watch_check_for_collective_state_change();
  }

}

void _mdns_ne_dns_proxy_state_watch_check_for_collective_state_change()
{
  uint64_t v0;
  id v1;
  id v2;
  id v3;
  char v4;
  uint64_t v5;
  void *i;
  unsigned int v7;
  int v8;
  char *v9;
  char *v10;
  id v11;
  NSObject *v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint8_t buf[4];
  char *v18;
  __int16 v19;
  char *v20;

  v0 = g_current_state;
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  v16 = 0u;
  v1 = (id)g_states;
  v2 = objc_msgSend(v1, "countByEnumeratingWithState:objects:count:", &v13, buf, 16);
  if (v2)
  {
    v3 = v2;
    v4 = 0;
    v5 = *(_QWORD *)v14;
    do
    {
      for (i = 0; i != v3; i = (char *)i + 1)
      {
        if (*(_QWORD *)v14 != v5)
          objc_enumerationMutation(v1);
        v7 = objc_msgSend(*(id *)(*((_QWORD *)&v13 + 1) + 8 * (_QWORD)i), "unsignedIntValue", (_QWORD)v13);
        if (v7)
        {
          if (v7 == 2)
          {

            v8 = 2;
            goto LABEL_15;
          }
        }
        else
        {
          v4 = 1;
        }
      }
      v3 = objc_msgSend(v1, "countByEnumeratingWithState:objects:count:", &v13, buf, 16);
    }
    while (v3);
  }
  else
  {
    v4 = 0;
  }

  v8 = (v4 & 1) == 0;
LABEL_15:
  if (v8 != (_DWORD)v0)
  {
    g_current_state = v8;
    v9 = off_10013BC80[v0];
    v10 = off_10013BC80[v8];
    v11 = _mdns_ne_dns_proxy_state_watch_log();
    v12 = objc_claimAutoreleasedReturnValue(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446466;
      v18 = v9;
      v19 = 2082;
      v20 = v10;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "State change: %{public}s -> %{public}s", buf, 0x16u);
    }

    if ((g_current_state - 1) <= 1)
    {
      if (g_user_updater)
        dispatch_source_merge_data((dispatch_source_t)g_user_updater, g_current_state);
    }
  }
}

void ___mdns_ne_dns_proxy_state_watch_queue_block_invoke(id a1)
{
  dispatch_queue_t v1;
  void *v2;

  v1 = dispatch_queue_create("com.apple.mdns.ne-dns-proxy-state-watch", 0);
  v2 = (void *)_mdns_ne_dns_proxy_state_watch_queue_s_queue;
  _mdns_ne_dns_proxy_state_watch_queue_s_queue = (uint64_t)v1;

}

void ___mdns_ne_dns_proxy_state_watch_log_block_invoke(id a1)
{
  os_log_t v1;
  void *v2;

  v1 = os_log_create("com.apple.mdns", "ne_dns_proxy_state_watch");
  v2 = (void *)_mdns_ne_dns_proxy_state_watch_log_s_log;
  _mdns_ne_dns_proxy_state_watch_log_s_log = (uint64_t)v1;

}

id _mdns_ne_dns_proxy_state_watch_load_managers()
{
  id v0;
  NSObject *v1;
  uint8_t v3[16];

  v0 = _mdns_ne_dns_proxy_state_watch_log();
  v1 = objc_claimAutoreleasedReturnValue(v0);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_INFO, "Loading new manager array", v3, 2u);
  }

  return +[NEDNSProxyManager loadAllFromPreferencesWithCompletionHandler:](NEDNSProxyManager, "loadAllFromPreferencesWithCompletionHandler:", &__block_literal_global_14_2165);
}

void ___mdns_ne_dns_proxy_state_watch_load_managers_block_invoke(id a1, NSArray *a2)
{
  NSArray *v2;
  id v3;
  NSObject *v4;
  _QWORD block[5];

  v2 = a2;
  v3 = _mdns_ne_dns_proxy_state_watch_queue();
  v4 = objc_claimAutoreleasedReturnValue(v3);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = ___mdns_ne_dns_proxy_state_watch_load_managers_block_invoke_2;
  block[3] = &unk_10013D018;
  block[4] = v2;
  dispatch_async(v4, block);

}

void ___mdns_ne_dns_proxy_state_watch_load_managers_block_invoke_2(uint64_t a1)
{
  id v1;
  id v2;
  void *v3;
  id v4;
  void *v5;
  id v6;
  id v7;
  id v8;
  uint64_t v9;
  void *i;
  uint64_t v11;
  id v12;
  id v13;
  NSObject *v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 buf;
  void (*v20)(uint64_t, void *, uint64_t);
  void *v21;
  id v22;
  _BYTE v23[128];

  v1 = *(id *)(a1 + 32);
  v2 = objc_alloc_init((Class)NSMutableArray);
  v3 = (void *)g_managers;
  g_managers = (uint64_t)v2;

  v4 = objc_alloc_init((Class)NSMutableArray);
  v5 = (void *)g_states;
  g_states = (uint64_t)v4;

  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v6 = v1;
  v7 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v15, v23, 16);
  if (v7)
  {
    v8 = v7;
    v9 = *(_QWORD *)v16;
    do
    {
      for (i = 0; i != v8; i = (char *)i + 1)
      {
        if (*(_QWORD *)v16 != v9)
          objc_enumerationMutation(v6);
        v11 = *(_QWORD *)(*((_QWORD *)&v15 + 1) + 8 * (_QWORD)i);
        if (objc_msgSend((id)g_managers, "indexOfObjectIdenticalTo:", v11, (_QWORD)v15) == (id)0x7FFFFFFFFFFFFFFFLL)
        {
          objc_msgSend((id)g_managers, "addObject:", v11);
          objc_msgSend((id)g_states, "addObject:", &off_100140E68);
        }
      }
      v8 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v15, v23, 16);
    }
    while (v8);
  }

  _mdns_ne_dns_proxy_state_watch_check_for_collective_state_change();
  v12 = objc_msgSend((id)g_managers, "count");
  v13 = _mdns_ne_dns_proxy_state_watch_log();
  v14 = objc_claimAutoreleasedReturnValue(v13);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 134217984;
    *(_QWORD *)((char *)&buf + 4) = v12;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Updated DNS proxy managers -- count: %llu", (uint8_t *)&buf, 0xCu);
  }

  *(_QWORD *)&buf = _NSConcreteStackBlock;
  *((_QWORD *)&buf + 1) = 3221225472;
  v20 = ___mdns_ne_dns_proxy_state_watch_handle_new_managers_block_invoke;
  v21 = &__block_descriptor_40_e34_v32__0__NEDNSProxyManager_8Q16_B24l;
  v22 = v12;
  objc_msgSend((id)g_managers, "enumerateObjectsUsingBlock:", &buf);

}

void ___mdns_ne_dns_proxy_state_watch_handle_new_managers_block_invoke(uint64_t a1, void *a2, uint64_t a3)
{
  id v5;
  id v6;
  NSObject *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  uint64_t v12;
  __int16 v13;
  id v14;
  __int16 v15;
  id v16;

  v5 = a2;
  v6 = _mdns_ne_dns_proxy_state_watch_log();
  v7 = objc_claimAutoreleasedReturnValue(v6);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    v8 = *(_QWORD *)(a1 + 32);
    v9 = 134218754;
    v10 = a3 + 1;
    v11 = 2048;
    v12 = v8;
    v13 = 2048;
    v14 = v5;
    v15 = 2112;
    v16 = v5;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "DNS proxy manager (%llu/%llu) -- address: %p, description: %@", (uint8_t *)&v9, 0x2Au);
  }

  objc_msgSend(v5, "setDelegate:", g_watcher);
  _mdns_ne_dns_proxy_state_watch_fetch_manager_status(v5);

}

void __mdns_ne_dns_proxy_state_watch_start_block_invoke(uint64_t a1)
{
  void *v1;
  NSObject *v2;
  id v3;
  NSObject *v4;
  void *v5;
  NSObject *v6;
  _QWORD handler[7];
  _QWORD v8[3];
  int v9;

  v1 = *(void **)(a1 + 40);
  v2 = *(id *)(a1 + 32);
  v3 = v1;
  if (_mdns_ne_dns_proxy_state_watch_init_s_once != -1)
    dispatch_once(&_mdns_ne_dns_proxy_state_watch_init_s_once, &__block_literal_global_7_2175);
  if (g_user_updater)
  {
    v4 = (id)g_user_updater;
    dispatch_source_cancel(v4);
    v5 = (void *)g_user_updater;
    g_user_updater = 0;

  }
  v8[0] = 0;
  v8[1] = v8;
  v8[2] = 0x2020000000;
  v9 = 0;
  v6 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_data_replace, 0, 0, v2);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472;
  handler[2] = ___mdns_ne_dns_proxy_state_watch_start_block_invoke;
  handler[3] = &unk_10013BB70;
  handler[5] = v3;
  handler[6] = v8;
  handler[4] = v6;
  dispatch_source_set_event_handler(v6, handler);
  dispatch_activate(v6);
  objc_storeStrong((id *)&g_user_updater, v6);
  if ((g_current_state - 1) <= 1 && g_user_updater)
    dispatch_source_merge_data((dispatch_source_t)g_user_updater, g_current_state);

  _Block_object_dispose(v8, 8);
}

uintptr_t ___mdns_ne_dns_proxy_state_watch_start_block_invoke(uint64_t a1)
{
  uintptr_t result;
  int v3;
  id v4;
  NSObject *v5;
  _DWORD v6[2];

  result = dispatch_source_get_data(*(dispatch_source_t *)(a1 + 32));
  v3 = result;
  if ((result - 1) <= 1 && *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) != (_DWORD)result)
  {
    v4 = _mdns_ne_dns_proxy_state_watch_log();
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      v6[0] = 67109120;
      v6[1] = v3 == 2;
      _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Calling user's update handler -- running: %{BOOL}d", (uint8_t *)v6, 8u);
    }

    result = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = v3;
  }
  return result;
}

void ___mdns_ne_dns_proxy_state_watch_init_block_invoke(id a1)
{
  MDNSNEDNSProxyWatcher *v1;
  void *v2;
  void *v3;

  v1 = objc_alloc_init(MDNSNEDNSProxyWatcher);
  v2 = (void *)g_watcher;
  g_watcher = (uint64_t)v1;

  v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSNotificationCenter defaultCenter](NSNotificationCenter, "defaultCenter"));
  objc_msgSend(v3, "addObserver:selector:name:object:", g_watcher, "configurationChanged:", NEDNSProxyConfigurationDidChangeNotification, 0);

  _mdns_ne_dns_proxy_state_watch_load_managers();
}

uint64_t _dnssec_obj_dns_question_member_compare()
{
  return 2;
}

void _dnssec_obj_dns_question_member_finalize(uint64_t a1)
{
  _QWORD *v2;

  v2 = *(_QWORD **)(a1 + 16);
  if (v2)
  {
    ref_count_obj_release(v2);
    *(_QWORD *)(a1 + 16) = 0;
  }
}

uint64_t resolver_discovery_get_next_scheduled_event()
{
  _QWORD *v0;
  unsigned int v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t v8;
  int v9;
  unsigned int v12;

  if (!g_discover_resolvers)
    return 0;
  v0 = *(_QWORD **)g_discover_resolvers;
  if (!*(_QWORD *)g_discover_resolvers)
    return 0;
  v1 = 0;
  v2 = *(_QWORD **)g_discover_resolvers;
  do
  {
    v3 = v2[1];
    if (v3)
    {
      v4 = *(_QWORD *)(v3 + 272);
      if (v4)
      {
        v5 = *(_QWORD *)(v4 + 696);
        if (v5)
        {
          v6 = *(_DWORD *)(v5 + 1664);
          if (v6)
          {
            if ((int)(v6 - v1) < 0 || v1 == 0)
              v1 = v6;
          }
        }
      }
    }
    v2 = (_QWORD *)*v2;
  }
  while (v2);
  do
  {
    v8 = v0[1];
    if (!*(_DWORD *)(v8 + 264))
    {
      v9 = *(_DWORD *)(v8 + 256);
      if (v9)
      {
        if ((int)v2 - v9 > 0 || (_DWORD)v2 == 0)
          LODWORD(v2) = v9;
      }
    }
    v0 = (_QWORD *)*v0;
  }
  while (v0);
  if ((int)((_DWORD)v2 - v1) < 0 || v1 == 0)
    v12 = v2;
  else
    v12 = v1;
  if ((_DWORD)v2)
    return v12;
  else
    return v1;
}

uint64_t dns_push_handle_question_start(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  _BYTE *v3;
  unsigned __int8 *v4;
  uint64_t v5;
  _QWORD *v8;
  _UNKNOWN **v9;
  void (*v10)(_QWORD *);
  int v11;
  _QWORD *v12;
  unsigned __int8 *v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  void (*v17)(_QWORD *);
  _QWORD *v18;
  _QWORD *v19;
  _WORD *v20;
  _BYTE *i;
  uint64_t v22;
  int v24;
  NSObject *v25;
  unsigned int v26;
  unsigned int v27;
  uint8_t buf[4];
  unsigned int v29;
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  int v33;
  __int16 v34;
  uint64_t v35;
  __int16 v36;
  int v37;

  if (*(_BYTE *)(a2 + 655))
  {
    v5 = 4294960591;
    goto LABEL_42;
  }
  v8 = malloc_type_calloc(1uLL, 0x18uLL, 0xF1748037uLL);
  if (!v8)
    goto LABEL_45;
  v2 = v8;
  v9 = &_dns_push_obj_dns_question_member_kind;
  v8[1] = &_dns_push_obj_dns_question_member_kind;
  do
  {
    v10 = (void (*)(_QWORD *))v9[2];
    if (v10)
      v10(v2);
    v9 = (_UNKNOWN **)*v9;
  }
  while (v9);
  v11 = (*(_DWORD *)v2)++;
  v2[2] = 0;
  v12 = *(_QWORD **)(a2 + 184);
  if (v12 != v2)
  {
    *(_DWORD *)v2 = v11 + 2;
    if (v12)
      ref_count_obj_release(v12);
    *(_QWORD *)(a2 + 184) = v2;
  }
  *(_BYTE *)(a2 + 632) = 0;
  v27 = 0;
  v3 = (_BYTE *)(a2 + 376);
  v13 = dns_obj_domain_name_create_with_labels((_BYTE *)(a2 + 376), (int *)&v27);
  v4 = v13;
  v5 = v27;
  if (v27)
    goto LABEL_46;
  v5 = *((_QWORD *)v13 + 2);
  v14 = *(unsigned __int8 *)v5 + 2;
  if (v14 == *((_QWORD *)v13 + 3))
  {
    v24 = *(unsigned __int16 *)(a2 + 342);
    v25 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
      {
LABEL_53:
        v26 = bswap32(*(unsigned __int16 *)(a2 + 340));
        *(_DWORD *)buf = 67110147;
        v29 = HIWORD(v26);
        v30 = 2160;
        v31 = 1752392040;
        v32 = 1040;
        v33 = v14;
        v34 = 2101;
        v35 = v5;
        v36 = 1024;
        v37 = v24;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "[Q%u] Unable to start DNS push server discovery for the single-label name (TLD) -- qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %{mdns:rrtype}d", buf, 0x28u);
      }
    }
    else
    {
      v25 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
        goto LABEL_53;
    }
    v16 = 0;
    v5 = 4294960591;
    v27 = -6705;
LABEL_20:
    ref_count_obj_release(v4);
    goto LABEL_21;
  }
  v15 = malloc_type_calloc(1uLL, 0x48uLL, 0xF1748037uLL);
  if (!v15)
    goto LABEL_45;
  v16 = v15;
  v5 = (uint64_t)&_dns_push_obj_context_kind;
  v15[1] = &_dns_push_obj_context_kind;
  do
  {
    v17 = *(void (**)(_QWORD *))(v5 + 16);
    if (v17)
      v17(v16);
    v5 = *(_QWORD *)v5;
  }
  while (v5);
  ++*(_DWORD *)v16;
  v16[5] = a2;
  v27 = 0;
  if (v4)
    goto LABEL_20;
LABEL_21:
  while (!(_DWORD)v5)
  {
    v18 = (_QWORD *)v2[2];
    if (v18 != v16)
    {
      if (v16)
        ++*(_DWORD *)v16;
      if (v18)
        ref_count_obj_release(v18);
      v2[2] = v16;
    }
    v19 = malloc_type_calloc(1uLL, 0x2B8uLL, 0xF1748037uLL);
    if (v19)
    {
      v20 = v19;
      v19[17] = *(_QWORD *)(a2 + 136);
      for (i = v3; (unint64_t)i < a2 + 632; i += v22 + 1)
      {
        if (!i)
          break;
        v22 = *i;
        if (v22 > 0x3F)
          break;
        if (!*i)
        {
          if ((unsigned __int16)((_WORD)i - (_WORD)v3 + 1) <= 0x100u)
          {
            memcpy(v19 + 47, v3, (unsigned __int16)((_WORD)i - (_WORD)v3 + 1));
            goto LABEL_38;
          }
          break;
        }
      }
      *((_BYTE *)v19 + 376) = 0;
LABEL_38:
      v20[171] = 6;
      v20[172] = *(_WORD *)(a2 + 344);
      *((_DWORD *)v20 + 61) = getpid();
      *((_QWORD *)v20 + 19) = _dns_push_discovery_soa_result_reply;
      *((_QWORD *)v20 + 22) = v16;
      *((_BYTE *)v20 + 635) = 1;
      *((_BYTE *)v20 + 632) = 0;
      if (!mDNS_StartQuery_internal(a1, v20))
      {
        v16[6] = v20;
        ref_count_obj_release(v2);
        ref_count_obj_release(v16);
        return 0;
      }
      free(v20);
      v5 = 4294960567;
      break;
    }
LABEL_45:
    __break(1u);
LABEL_46:
    v16 = 0;
    if (v4)
      goto LABEL_20;
  }
  ref_count_obj_release(v2);
  if (v16)
    ref_count_obj_release(v16);
LABEL_42:
  dns_push_handle_question_stop(a1, a2);
  return v5;
}

void _dns_push_discovery_soa_result_reply(uint64_t a1, uint64_t a2, unsigned __int8 *a3, int a4)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  unsigned __int8 *v12;
  int v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  char *v20;
  char *v21;
  uint64_t v22;
  size_t v23;
  unsigned __int8 *v24;
  unsigned __int8 *v25;
  unsigned __int16 v26;
  uint64_t v27;
  unsigned int v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t *v32;
  uint64_t v33;
  unsigned __int8 *concatenation;
  _QWORD *v35;
  int v36;
  unsigned __int16 *v37;
  _QWORD v38[5];
  _QWORD aBlock[5];

  v37 = (unsigned __int16 *)a2;
  if (a4 != 1)
    return;
  v5 = (uint64_t)a3;
  v8 = *(_QWORD *)(a2 + 176);
  v36 = 0;
  if (*a3 != 240)
  {
    if (*((_WORD *)a3 + 2) != 6)
      goto LABEL_60;
    v11 = dns_obj_domain_name_create_with_labels(*((_BYTE **)a3 + 4), &v36);
    v12 = v11;
    v13 = v36;
    if (v36)
    {
LABEL_57:
      if (!v12)
        goto LABEL_59;
      goto LABEL_58;
    }
    if (!v11)
      goto LABEL_3;
    ++*(_DWORD *)v11;
    v14 = *(_QWORD **)(v8 + 16);
    if (v14)
      ref_count_obj_release(v14);
    *(_QWORD *)(v8 + 16) = v12;
    _dns_push_discovery_stop((unsigned int *)a1, &v37, v8, 1);
    mDNS_Lock_((unsigned int *)a1, (uint64_t)"_dns_push_discovery_soa_result_reply", 256);
    v15 = *(_QWORD *)(v5 + 24);
    v16 = v15 + 5;
    if ((unint64_t)(v15 + 5) < 6 && ((0x2Du >> v16) & 1) != 0)
      v15 = dword_100100838[v16];
    mDNS_Unlock_(a1, (uint64_t)"_dns_push_discovery_soa_result_reply", 258);
    *(_DWORD *)(v8 + 64) = v15;
    v17 = *(_QWORD *)(v5 + 24);
    v18 = malloc_type_calloc(1uLL, 0x2B8uLL, 0xF1748037uLL);
    if (!v18)
      goto LABEL_73;
    v5 = (uint64_t)v18;
    v19 = *(_QWORD *)(v8 + 24);
    if (v19)
    {
LABEL_17:
      v21 = *(char **)(v19 + 16);
      v20 = v21;
      if (v21 == (char *)-256)
      {
LABEL_19:
        while (v21)
        {
          v22 = *v21;
          if (v22 > 0x3F)
            break;
          if (!*v21)
          {
            v26 = (_WORD)v21 - (_WORD)v20 + 1;
            if (v26 > 0x100u)
              break;
            memcpy((void *)(v5 + 376), v20, v26);
            goto LABEL_36;
          }
          v21 += v22 + 1;
          if (v20 != (char *)-256)
            goto LABEL_18;
        }
      }
      else
      {
LABEL_18:
        if (v21 < v20 + 256)
          goto LABEL_19;
      }
      *(_BYTE *)(v5 + 376) = 0;
LABEL_36:
      v27 = *(_QWORD *)(v8 + 40);
      if (!v27)
        goto LABEL_55;
      *(_WORD *)(v5 + 342) = 33;
      *(_WORD *)(v5 + 344) = *(_WORD *)(v27 + 344);
      *(_QWORD *)(v5 + 136) = v17;
      *(_DWORD *)(v5 + 244) = getpid();
      *(_QWORD *)(v5 + 152) = _dns_push_discovery_srv_result_reply;
      *(_QWORD *)(v5 + 176) = v8;
      *(_BYTE *)(v5 + 635) = 1;
      *(_BYTE *)(v5 + 632) = 0;
      v28 = *(_DWORD *)(v8 + 64);
      v4 = (uint64_t *)g_interface_monitors;
      if (g_interface_monitors)
      {
        while (1)
        {
          v15 = *v4;
          if (*(_DWORD *)(*v4 + 136) == v28)
            break;
          v4 = (uint64_t *)v4[2];
          if (!v4)
            goto LABEL_40;
        }
        os_retain((void *)*v4);
        ++v4[1];
        goto LABEL_52;
      }
LABEL_40:
      v29 = (uint64_t *)malloc_type_calloc(1uLL, 0x18uLL, 0xF1748037uLL);
      if (v29)
      {
        v4 = v29;
        v30 = mdns_interface_monitor_create(v28);
        if (!v30)
        {
          free(v4);
          goto LABEL_55;
        }
        v15 = v30;
        if (_dns_push_discovery_interface_monitor_queue_s_once == -1)
          goto LABEL_43;
        goto LABEL_74;
      }
LABEL_73:
      __break(1u);
LABEL_74:
      dispatch_once(&_dns_push_discovery_interface_monitor_queue_s_once, &__block_literal_global_2234);
LABEL_43:
      mdns_interface_monitor_set_queue(v15, (dispatch_object_t)_dns_push_discovery_interface_monitor_queue_s_queue);
      os_retain((void *)v15);
      aBlock[0] = _NSConcreteStackBlock;
      aBlock[1] = 0x40000000;
      aBlock[2] = ___dns_push_discovery_start_mdns_interface_monitor_block_invoke;
      aBlock[3] = &__block_descriptor_tmp_2235;
      aBlock[4] = v15;
      mdns_interface_monitor_set_event_handler(v15, aBlock);
      v38[0] = _NSConcreteStackBlock;
      v38[1] = 0x40000000;
      v38[2] = ___dns_push_discovery_start_mdns_interface_monitor_block_invoke_2;
      v38[3] = &__block_descriptor_tmp_3_2236;
      v38[4] = v15;
      mdns_interface_monitor_set_update_handler(v15, v38);
      if (!*(_BYTE *)(v15 + 154))
      {
        if (*(_QWORD *)(v15 + 32))
          _mdns_interface_monitor_activate_async((void *)v15);
        *(_BYTE *)(v15 + 154) = 1;
      }
      *v4 = v15;
      os_retain((void *)v15);
      v31 = &g_interface_monitors;
      do
      {
        v32 = v31;
        v33 = *v31;
        v31 = (uint64_t *)(*v31 + 16);
      }
      while (v33);
      *v32 = (uint64_t)v4;
      ++v4[1];
      if (v15)
      {
LABEL_52:
        dns_push_obj_context_set_interface_monitor(v8, (void *)v15);
        if (!mDNS_StartQuery((unsigned int *)a1, v5))
        {
          os_release((void *)v15);
          *(_QWORD *)(v8 + 48) = v5;
          if (!v12)
          {
LABEL_59:
            if (!v13)
              return;
            goto LABEL_60;
          }
LABEL_58:
          ref_count_obj_release(v12);
          goto LABEL_59;
        }
        free((void *)v5);
        os_release((void *)v15);
        goto LABEL_56;
      }
LABEL_55:
      free((void *)v5);
LABEL_56:
      v36 = -6729;
      goto LABEL_57;
    }
    if (!*(_QWORD *)(v8 + 16))
      goto LABEL_55;
    LODWORD(aBlock[0]) = 0;
    v24 = dns_obj_domain_name_create_with_cstring("_dns-push-tls._tcp", aBlock);
    v15 = (uint64_t)v24;
    if (LODWORD(aBlock[0]))
    {
      v25 = v24;
      if (!v24)
        goto LABEL_31;
    }
    else
    {
      concatenation = dns_obj_domain_name_create_concatenation(*((_BYTE **)v24 + 2), *(_BYTE **)(*(_QWORD *)(v8 + 16) + 16), aBlock);
      v25 = concatenation;
      if (!LODWORD(aBlock[0]))
      {
        if (concatenation)
          ++*(_DWORD *)concatenation;
        v35 = *(_QWORD **)(v8 + 24);
        if (v35)
          ref_count_obj_release(v35);
        *(_QWORD *)(v8 + 24) = v25;
      }
      ref_count_obj_release((_QWORD *)v15);
      if (!v25)
      {
LABEL_31:
        v19 = *(_QWORD *)(v8 + 24);
        if (!v19)
          goto LABEL_55;
        goto LABEL_17;
      }
    }
    ref_count_obj_release(v25);
    goto LABEL_31;
  }
LABEL_3:
  if (!*(_BYTE *)(a2 + 376))
  {
LABEL_60:
    _dns_push_discovery_stop((unsigned int *)a1, &v37, v8, 1);
    return;
  }
  v9 = dns_obj_domain_name_create_with_labels((_BYTE *)(*(unsigned __int8 *)(a2 + 376) + a2 + 376 + 1), &v36);
  v10 = v9;
  if (v36)
  {
    if (v9)
      ref_count_obj_release(v9);
    goto LABEL_60;
  }
  *(_QWORD *)(a1 + 232) = a2;
  mDNS_StopQuery((unsigned int *)a1, a2);
  *(_QWORD *)(a1 + 232) = 0;
  v23 = *((_QWORD *)v10 + 3);
  if (v23 >= 0x100)
  {
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "labels_length < sizeof(question->qname.c)", "", "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dns_push/dns_push_discovery.c", 385, 0);
  }
  else
  {
    memcpy((void *)(a2 + 376), *((const void **)v10 + 2), v23);
    *(_DWORD *)(a2 + 200) = DomainNameHashValue(a2 + 376);
    mDNS_StartQuery((unsigned int *)a1, a2);
  }
  ref_count_obj_release(v10);
}

void dns_push_handle_question_stop(unsigned int *a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v5;
  uint64_t DNSServiceManager;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  _QWORD *v12;
  unsigned __int16 *v13;

  v2 = *(_QWORD *)(a2 + 184);
  if (v2)
  {
    v3 = *(_QWORD **)(v2 + 16);
    if (v3)
    {
      v13 = (unsigned __int16 *)v3[6];
      if (v13)
      {
        _dns_push_discovery_stop(a1, &v13, (uint64_t)v3, 0);
        v3[6] = 0;
      }
      v5 = v3[4];
      if (v5)
      {
        DNSServiceManager = Querier_GetDNSServiceManager();
        if (DNSServiceManager)
        {
          mdns_dns_service_manager_deregister_discovered_push_service(DNSServiceManager, v5);
          v3[4] = 0;
        }
      }
      v7 = (void *)v3[7];
      if (v7)
      {
        v8 = g_interface_monitors;
        if (!g_interface_monitors)
          goto LABEL_20;
        if (*(void **)g_interface_monitors == v7)
        {
          v10 = &g_interface_monitors;
LABEL_15:
          v11 = *(_QWORD *)(v8 + 8) - 1;
          *(_QWORD *)(v8 + 8) = v11;
          if (!v11)
          {
            *v10 = *(_QWORD *)(v8 + 16);
            if (*(_QWORD *)v8)
            {
              mdns_interface_monitor_invalidate(*(void **)v8);
              os_release(*(void **)v8);
            }
            free((void *)v8);
            v7 = (void *)v3[7];
          }
        }
        else
        {
          while (1)
          {
            v9 = v8;
            v8 = *(_QWORD *)(v8 + 16);
            if (!v8)
              break;
            if (*(void **)v8 == v7)
            {
              v10 = (uint64_t *)(v9 + 16);
              goto LABEL_15;
            }
          }
        }
        if (v7)
LABEL_20:
          os_release(v7);
        v3[7] = 0;
      }
      v12 = *(_QWORD **)(a2 + 184);
      if (v12)
      {
        ref_count_obj_release(v12);
        *(_QWORD *)(a2 + 184) = 0;
      }
      *(_BYTE *)(a2 + 632) = 1;
    }
  }
}

void _dns_push_discovery_stop(unsigned int *a1, unsigned __int16 **a2, uint64_t a3, int a4)
{
  unsigned __int16 *v8;
  NSObject *v9;
  unsigned int v12;
  _DWORD v13[2];

  v8 = *a2;
  if (*a2 != *(unsigned __int16 **)(a3 + 48))
  {
    v9 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))
        goto LABEL_11;
      goto LABEL_10;
    }
    v9 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
    {
LABEL_10:
      v12 = bswap32(v8[170]) >> 16;
      v13[0] = 67109120;
      v13[1] = v12;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "[Q%u] Question being stopped is not the currently active discovery question", (uint8_t *)v13, 8u);
    }
  }
LABEL_11:
  if (a4)
  {
    mDNS_StopQuery(a1, (uint64_t)v8);
    if (!v8)
      goto LABEL_16;
    goto LABEL_15;
  }
  mDNS_StopQuery_internal(a1, v8);
  if (v8)
LABEL_15:
    free(v8);
LABEL_16:
  *a2 = 0;
  *(_QWORD *)(a3 + 48) = 0;
}

void _dns_push_discovery_srv_result_reply(unsigned int *a1, uint64_t a2, unsigned __int8 *a3, int a4)
{
  uint64_t v6;
  unsigned int v7;
  NSObject *v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t DNSServiceManager;
  uint64_t v17;
  unsigned __int8 *v18;
  unsigned __int8 *concatenation;
  unsigned __int8 *v20;
  int v21;
  uint64_t v23;
  unsigned int v24;
  unsigned int v25;
  NSObject *v26;
  uint64_t v27;
  int v28;
  _QWORD *v29;
  uint64_t v30;
  int v31;
  NSObject *v32;
  uint64_t v33;
  uint64_t v34;
  char v35;
  uint64_t v36;
  const char *v37;
  NSObject *v38;
  uint32_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int v43;
  unsigned int v44;
  NSObject *v45;
  unsigned __int16 *v46;
  int v47;
  unsigned __int8 v48;
  uint8_t buf[4];
  unsigned int v50;
  __int16 v51;
  _BYTE v52[14];
  __int16 v53;
  uint64_t v54;
  __int16 v55;
  int v56;
  __int16 v57;
  uint64_t v58;

  v46 = (unsigned __int16 *)a2;
  if (a4 != 1)
    return;
  v6 = *(_QWORD *)(a2 + 176);
  v7 = bswap32(*(unsigned __int16 *)(*(_QWORD *)(v6 + 40) + 340)) >> 16;
  if (*a3 == 240)
  {
    v8 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
        v10 = *(_QWORD *)(a2 + 80);
        if (v10)
          v10 = *(_QWORD *)(v10 + 24);
        goto LABEL_24;
      }
    }
    else
    {
      v8 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        v10 = *(_QWORD *)(a2 + 80);
        if (v10)
          v10 = *(_QWORD *)(v10 + 24);
LABEL_24:
        *(_DWORD *)buf = 67109376;
        v50 = v7;
        v51 = 2048;
        *(_QWORD *)v52 = v10;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "[Q%u] Current network does not support DNS push, falling back to DNS polling -- service ID: %llu", buf, 0x12u);
      }
    }
    v23 = *(_QWORD *)(v6 + 40);
    v24 = *(_DWORD *)(v23 + 252);
    v25 = bswap32(*(unsigned __int16 *)(v23 + 340)) >> 16;
    v26 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_30:
        *(_DWORD *)buf = 67109376;
        v50 = v24;
        v51 = 1024;
        *(_DWORD *)v52 = v25;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "[R%u->Q%u] Starting long-lived DNS polling -- polling interval: 15 min", buf, 0xEu);
      }
    }
    else
    {
      v26 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_30;
    }
    *(_BYTE *)(v6 + 68) = 1;
LABEL_32:
    Querier_ProcessDNSServiceChangesAsync();
    return;
  }
  v11 = *(_QWORD *)(v6 + 16);
  if (!v11)
    return;
  mDNS_Lock_(a1, (uint64_t)"_dns_push_discovery_srv_result_reply", 311);
  v13 = *((_QWORD *)a3 + 3);
  v14 = v13 + 5;
  if ((unint64_t)(v13 + 5) < 6 && ((0x2Du >> v14) & 1) != 0)
    LODWORD(v13) = dword_100100850[v14];
  mDNS_Unlock_((uint64_t)a1, (uint64_t)"_dns_push_discovery_srv_result_reply", 313);
  *(_DWORD *)buf = 0;
  v48 = 0;
  DNSServiceManager = Querier_GetDNSServiceManager(v15);
  if (!DNSServiceManager)
  {
    v21 = -6729;
    goto LABEL_48;
  }
  v17 = DNSServiceManager;
  v18 = (unsigned __int8 *)_dns_push_discovery_register_push_service_dns_push_service_type;
  if (!_dns_push_discovery_register_push_service_dns_push_service_type)
  {
    v18 = dns_obj_domain_name_create_with_cstring("_dns-push-tls._tcp", buf);
    _dns_push_discovery_register_push_service_dns_push_service_type = (uint64_t)v18;
    v21 = *(_DWORD *)buf;
    if (*(_DWORD *)buf)
      goto LABEL_36;
  }
  concatenation = dns_obj_domain_name_create_concatenation(*((_BYTE **)v18 + 2), *(_BYTE **)(v11 + 16), buf);
  v20 = concatenation;
  v21 = *(_DWORD *)buf;
  if (*(_DWORD *)buf)
  {
    if (concatenation)
      ref_count_obj_release(concatenation);
LABEL_36:
    v27 = 0;
    v28 = 0;
    goto LABEL_46;
  }
  v29 = mdns_domain_name_create_with_labels(*((_BYTE **)concatenation + 2), 0);
  if (v29)
  {
    v47 = 0;
    v30 = mdns_dns_service_manager_register_discovered_push_service(v17, (uint64_t)v29, v13, (uint64_t)&v48, &v47);
    v27 = v30;
    if (v30)
    {
      *(_QWORD *)(v6 + 32) = v30;
      if (v48)
        Querier_ProcessDNSServiceChangesAsync();
      goto LABEL_44;
    }
    v31 = v47;
  }
  else
  {
    v27 = 0;
    v31 = -6729;
  }
  *(_DWORD *)buf = v31;
LABEL_44:
  v28 = v48;
  v21 = *(_DWORD *)buf;
  ref_count_obj_release(v20);
  if (v29)
    os_release(v29);
LABEL_46:
  if (v27 || !v21)
  {
    v35 = gSensitiveLoggingEnabled;
    v36 = mDNSLogCategory_Default;
    if (mDNSLogCategory_Default == mDNSLogCategory_State)
      v35 = 0;
    if (v28)
    {
      if ((v35 & 1) != 0)
      {
        v36 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          goto LABEL_64;
      }
      else if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_64:
        *(_DWORD *)buf = 67109632;
        v50 = v7;
        v51 = 2048;
        *(_QWORD *)v52 = v27;
        *(_WORD *)&v52[8] = 1024;
        *(_DWORD *)&v52[10] = 1;
        v37 = "[Q%u] DNS push discovery finished -- service id: %llu, re registered: %{mdns:yesno}d";
        v38 = v36;
        v39 = 24;
LABEL_67:
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, v37, buf, v39);
      }
LABEL_68:
      _dns_push_discovery_stop(a1, &v46, v6, 1);
      v42 = *(_QWORD *)(v6 + 40);
      v43 = *(_DWORD *)(v42 + 252);
      v44 = bswap32(*(unsigned __int16 *)(v42 + 340)) >> 16;
      v45 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        {
LABEL_73:
          *(_DWORD *)buf = 67109376;
          v50 = v43;
          v51 = 1024;
          *(_DWORD *)v52 = v44;
          _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "[R%u->Q%u] Stopping long-lived DNS polling", buf, 0xEu);
        }
      }
      else
      {
        v45 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          goto LABEL_73;
      }
      *(_BYTE *)(v6 + 68) = 0;
      goto LABEL_32;
    }
    if ((v35 & 1) != 0)
    {
      v36 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_68;
    }
    else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
      goto LABEL_68;
    }
    v41 = *(_QWORD *)(v11 + 16);
    v40 = *(_QWORD *)(v11 + 24);
    *(_DWORD *)buf = 67110146;
    v50 = v7;
    v51 = 1040;
    *(_DWORD *)v52 = v40;
    *(_WORD *)&v52[4] = 2098;
    *(_QWORD *)&v52[6] = v41;
    v53 = 2048;
    v54 = v27;
    v55 = 1024;
    v56 = 0;
    v37 = "[Q%u] DNS push discovery finished, using service with SRV name _dns-push-tls._tcp.%{public, mdnsresponder:doma"
          "in_name}.*P -- service id: %llu, re registered: %{mdns:yesno}d";
    v38 = v36;
    v39 = 40;
    goto LABEL_67;
  }
LABEL_48:
  v32 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))
    {
LABEL_53:
      v34 = *(_QWORD *)(v11 + 16);
      v33 = *(_QWORD *)(v11 + 24);
      *(_DWORD *)buf = 67110402;
      v50 = v7;
      v51 = 2048;
      *(_QWORD *)v52 = 0;
      *(_WORD *)&v52[8] = 1040;
      *(_DWORD *)&v52[10] = v33;
      v53 = 2098;
      v54 = v34;
      v55 = 1024;
      v56 = v13;
      v57 = 2048;
      v58 = v21;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_FAULT, "[Q%u] Failed to register push service -- id: %lluauthoritative zone: %{public, mdnsresponder:domain_name}.*P, interface index: %u, error: %{mdns:err}ld", buf, 0x32u);
    }
  }
  else
  {
    v32 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
      goto LABEL_53;
  }
}

void ___dns_push_discovery_start_mdns_interface_monitor_block_invoke(uint64_t a1, int a2)
{
  if (a2 == 1)
  {
    _dns_push_discovery_process_interface_changes(*(_QWORD *)(a1 + 32));
  }
  else if (a2 == 2)
  {
    os_release(*(void **)(a1 + 32));
  }
}

void ___dns_push_discovery_start_mdns_interface_monitor_block_invoke_2(uint64_t a1, char a2)
{
  if (a2 < 0)
    _dns_push_discovery_process_interface_changes(*(_QWORD *)(a1 + 32));
}

void _dns_push_discovery_process_interface_changes(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t DNSServiceManager;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v21;
  uint64_t v22;
  NSObject *v23;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  _QWORD v34[3];
  int v35;
  void **block;
  __int128 v37;
  void *v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;

  v33 = *(_DWORD *)(a1 + 136);
  v2 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage + 616));
  *(_DWORD *)(mDNSStorage + 680) = mDNSPlatformRawTime(v2, v3, v4, v5, v6, v7, v8, v9);
  mDNS_Lock_((unsigned int *)&mDNSStorage, (uint64_t)"_dns_push_discovery_process_interface_changes", 487);
  DNSServiceManager = Querier_GetDNSServiceManager(v10);
  v12 = *(_QWORD *)((char *)&xmmword_100158E84 + 4);
  if (!*(_QWORD *)((char *)&xmmword_100158E84 + 4))
    goto LABEL_20;
  v13 = DNSServiceManager;
  v14 = 0;
  v15 = *(_QWORD *)((char *)&xmmword_100158E84 + 4);
  do
  {
    ++v14;
    v15 = *(_QWORD *)(v15 + 8);
  }
  while (v15);
  qword_100158EB0 = *(_QWORD *)((char *)&xmmword_100158E84 + 4);
  if (v14)
  {
    v16 = 0;
    do
    {
      if (!v12)
        break;
      v17 = *(_QWORD *)(v12 + 184);
      if (!v17)
        goto LABEL_17;
      v18 = *(_QWORD *)(v17 + 16);
      if (!v18)
        goto LABEL_17;
      v19 = *(_QWORD *)(v18 + 56);
      if (!v19 || v19 != a1)
        goto LABEL_17;
      v21 = *(_QWORD *)(v18 + 32);
      v34[0] = 0;
      v34[1] = v34;
      v34[2] = 0x2000000000;
      v35 = 0;
      if (_mdns_dns_service_queue_s_once != -1)
        dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
      ++v16;
      block = _NSConcreteStackBlock;
      *(_QWORD *)&v37 = 0x40000000;
      *((_QWORD *)&v37 + 1) = __mdns_dns_service_manager_terminate_discovered_push_service_block_invoke;
      v38 = &unk_10013A2A8;
      v39 = v34;
      v40 = v13;
      v41 = v21;
      dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, &block);
      _Block_object_dispose(v34, 8);
      dns_push_handle_question_stop(&mDNSStorage, v12);
      dns_push_handle_question_start(&mDNSStorage, v12);
      v22 = qword_100158EB0;
      if (qword_100158EB0 == v12)
      {
LABEL_17:
        v22 = *(_QWORD *)(v12 + 8);
        qword_100158EB0 = v22;
      }
      v12 = v22;
      --v14;
    }
    while (v14);
  }
  else
  {
LABEL_20:
    v16 = 0;
  }
  qword_100158EB0 = 0;
  v23 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
LABEL_29:
      LODWORD(block) = 67109376;
      HIDWORD(block) = v33;
      LOWORD(v37) = 2048;
      *(_QWORD *)((char *)&v37 + 2) = v16;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Network changes, restarting all push questions that are related to the changed interface -- if_index: %u, restarted count: %zu", (uint8_t *)&block, 0x12u);
    }
  }
  else
  {
    v23 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      goto LABEL_29;
  }
  mDNS_Unlock_((uint64_t)&mDNSStorage, (uint64_t)"_dns_push_discovery_process_interface_changes", 529);
  KQueueUnlock((uint64_t)"DNS push interface monitor", v26, v27, v28, v29, v30, v31, v32);
}

void ___dns_push_discovery_interface_monitor_queue_block_invoke(id a1)
{
  _dns_push_discovery_interface_monitor_queue_s_queue = (uint64_t)dispatch_queue_create("com.apple.dns-push.interface-monitor", 0);
}

uint64_t LogToFD(int a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  char __b[1024];

  bzero(__b, 0x400uLL);
  mDNS_vsnprintf(__b, 1024, a2, &a9);
  return dprintf(a1, "%s\n", __b);
}

void mdns_free_context_finalizer(void *a1)
{
  if (a1)
    free(a1);
}

uint64_t _dnssec_obj_rr_nsec_compare(uint64_t a1, uint64_t a2, char a3)
{
  if ((a3 & 1) != 0)
    return 3;
  else
    return domain_name_label_canonical_compare(*(unsigned __int8 **)(*(_QWORD *)(a1 + 16) + 16), *(unsigned __int8 **)(*(_QWORD *)(a2 + 16) + 16), 0);
}

void _dnssec_obj_rr_nsec_finalize(uint64_t a1)
{
  _QWORD *v2;

  v2 = *(_QWORD **)(a1 + 80);
  if (v2)
  {
    ref_count_obj_release(v2);
    *(_QWORD *)(a1 + 80) = 0;
  }
}

uint64_t dnssec_obj_rr_nsec_covers_dns_type(_BYTE *a1, __int16 a2, unsigned int a3)
{
  int v3;
  _BYTE *v4;
  _BYTE *v5;
  int v6;

  v3 = *a1;
  v4 = a1;
  if (*a1)
  {
    v4 = a1;
    do
    {
      v5 = &v4[v3];
      v6 = v5[1];
      v4 = v5 + 1;
      v3 = v6;
    }
    while (v6);
  }
  return rdata_parser_type_bit_maps_cover_dns_type(v4 + 1, (unsigned __int16)(~((_WORD)v4 - (_WORD)a1) + a2), a3);
}

BOOL dnssec_obj_rr_nsec_asserts_name_exists_data_does_not_exist(uint64_t a1, uint64_t a2, int a3, unsigned int a4)
{
  _BYTE *v6;
  __int16 v7;

  if (*(unsigned __int16 *)(a1 + 34) != a3)
    return 0;
  v6 = *(_BYTE **)(a1 + 24);
  v7 = *(_WORD *)(a1 + 36);
  return (dnssec_obj_rr_nsec_covers_dns_type(v6, v7, a4) & 1) == 0
      && (dnssec_obj_rr_nsec_covers_dns_type(v6, v7, 5u) & 1) == 0
      && ref_count_obj_compare(*(_QWORD *)(a1 + 16), a2, 1) == 0;
}

uint64_t dnssec_obj_rr_nsec_asserts_name_does_not_exist(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4;
  int v5;
  int v6;

  if (*(unsigned __int16 *)(a1 + 34) != a3)
    return 0;
  v4 = *(_QWORD *)(a1 + 80);
  v5 = *(unsigned __int8 *)(a1 + 88);
  v6 = ref_count_obj_compare(*(_QWORD *)(a1 + 16), a2, 0);
  if (v5)
  {
    if (v6 == -1)
      return 1;
    return ref_count_obj_compare(a2, v4, 0) == -1;
  }
  if (v6 != -1)
    return 0;
  return ref_count_obj_compare(a2, v4, 0) == -1;
}

uint64_t _discovery_proxy_start_handler(unsigned int a1, const __CFArray *a2, const __CFArray *a3, const __CFArray *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  CFIndex Count;
  CFIndex v26;
  CFIndex i;
  const void *ValueAtIndex;
  CFIndex v29;
  CFIndex v30;
  CFIndex j;
  const void *v32;
  CFIndex v33;
  CFIndex v34;
  CFIndex k;
  const void *v36;
  uint64_t v37;
  uint64_t v38;
  NSObject *v39;
  uint64_t v41;
  _BOOL4 v42;
  int v44;
  uint64_t v45;

  v8 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v8, v9, v10, v11, v12, v13, v14, v15);
  _discovery_proxy_stop_internal();
  v16 = mdns_dns_push_service_definition_create();
  if (v16)
  {
    v24 = (uint64_t)v16;
    if (a1)
    {
      mdns_dns_push_service_definition_set_interface_index((uint64_t)v16, a1, 2);
      *(_WORD *)(v24 + 79) = 257;
      Count = CFArrayGetCount(a2);
      if (Count >= 1)
      {
        v26 = Count;
        for (i = 0; i != v26; ++i)
        {
          ValueAtIndex = CFArrayGetValueAtIndex(a2, i);
          CFArrayAppendValue(*(CFMutableArrayRef *)(v24 + 40), ValueAtIndex);
        }
      }
      v29 = CFArrayGetCount(a3);
      if (v29 >= 1)
      {
        v30 = v29;
        for (j = 0; j != v30; ++j)
        {
          v32 = CFArrayGetValueAtIndex(a3, j);
          CFSetAddValue(*(CFMutableSetRef *)(v24 + 48), v32);
        }
      }
      v33 = CFArrayGetCount(a4);
      if (v33 >= 1)
      {
        v34 = v33;
        for (k = 0; k != v34; ++k)
        {
          v36 = CFArrayGetValueAtIndex(a4, k);
          CFArrayAppendValue(*(CFMutableArrayRef *)(v24 + 56), v36);
        }
      }
      v37 = Querier_RegisterCustomPushDNSServiceWithConnectionErrorHandler(v24, 0, 0);
      g_discovery_proxy_service_id = v37;
      if (v37)
      {
        v38 = v37;
        v39 = mDNSLogCategory_uDNS;
        if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_uDNS != mDNSLogCategory_State)
        {
          v39 = mDNSLogCategory_uDNS_redacted;
          v42 = os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT);
          v41 = 0;
          if (!v42)
            goto LABEL_26;
          v44 = 134217984;
          v45 = v38;
          goto LABEL_25;
        }
        v41 = 0;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT))
        {
          v44 = 134217984;
          v45 = v38;
LABEL_25:
          _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "Discovery proxy service registered -- id: %llu", (uint8_t *)&v44, 0xCu);
          v41 = 0;
        }
      }
      else
      {
        v41 = 4294960582;
      }
LABEL_26:
      os_release((void *)v24);
      goto LABEL_27;
    }
    os_release(v16);
    v41 = 4294960591;
  }
  else
  {
    v41 = 4294960567;
  }
LABEL_27:
  KQueueUnlock((uint64_t)"discovery_proxy_start_handler", v17, v18, v19, v20, v21, v22, v23);
  return v41;
}

uint64_t _discovery_proxy_stop_handler()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v0 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v0, v1, v2, v3, v4, v5, v6, v7);
  _discovery_proxy_stop_internal();
  KQueueUnlock((uint64_t)"discovery_proxy_stop_handler", v8, v9, v10, v11, v12, v13, v14);
  return 0;
}

void _discovery_proxy_stop_internal()
{
  uint64_t v0;
  uint64_t DNSServiceManager;
  NSObject *v2;
  int v5;
  uint64_t v6;

  v0 = g_discovery_proxy_service_id;
  if (g_discovery_proxy_service_id)
  {
    DNSServiceManager = Querier_GetDNSServiceManager();
    if (DNSServiceManager)
      mdns_dns_service_manager_deregister_custom_push_service(DNSServiceManager, v0);
    v2 = mDNSLogCategory_uDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_uDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS, OS_LOG_TYPE_DEFAULT))
      {
LABEL_14:
        g_discovery_proxy_service_id = 0;
        return;
      }
      v5 = 134217984;
      v6 = g_discovery_proxy_service_id;
    }
    else
    {
      v2 = mDNSLogCategory_uDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_uDNS_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_14;
      v5 = 134217984;
      v6 = g_discovery_proxy_service_id;
    }
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Discovery proxy service deregistered -- id: %llu", (uint8_t *)&v5, 0xCu);
    goto LABEL_14;
  }
}

void ___mdns_managed_defaults_log_block_invoke(id a1)
{
  _mdns_managed_defaults_log_s_log = (uint64_t)os_log_create("com.apple.mdns", "managed_defaults");
}

uint64_t _dnssec_obj_trust_anchor_manager_compare()
{
  return 2;
}

void _dnssec_obj_trust_anchor_manager_finalize(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;

  v1 = *(_QWORD **)(a1 + 16);
  while (v1)
  {
    v2 = v1;
    v1 = (_QWORD *)*v1;
    do
    {
      v4 = (_QWORD *)v2[1];
      v3 = (_QWORD *)v2[2];
      if (v3)
        ref_count_obj_release(v3);
      free(v2);
      v2 = v4;
    }
    while (v4);
  }
}

uint64_t dnssec_obj_trust_anchor_manager_add_anchor(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;

  result = (uint64_t)malloc_type_calloc(1uLL, 0x18uLL, 0xF1748037uLL);
  if (result)
  {
    v5 = (_QWORD *)result;
    v6 = *(_QWORD *)(*(_QWORD *)(a2 + 16) + 16);
    v7 = (_QWORD *)(a1 + 16);
    v8 = v7;
    while (1)
    {
      v9 = v8;
      v8 = (_QWORD *)*v8;
      if (!v8)
        break;
      if (!ref_count_obj_compare(*(_QWORD *)(*(_QWORD *)(v8[2] + 16) + 16), v6, 1))
      {
        v10 = v8;
        while (ref_count_obj_compare(v10[2], a2, 1))
        {
          v10 = (_QWORD *)v10[1];
          if (!v10)
          {
            *v9 = v5;
            *v5 = *v8;
            *v8 = 0;
            v5[1] = v8;
            goto LABEL_12;
          }
        }
        free(v5);
        return 4294960566;
      }
    }
    do
    {
      v11 = v7;
      v7 = (_QWORD *)*v7;
    }
    while (v7 && ref_count_obj_compare(*(_QWORD *)(*(_QWORD *)(v7[2] + 16) + 16), v6, 0) != 1);
    *v11 = v5;
    *v5 = v7;
LABEL_12:
    result = 0;
    v5[2] = a2;
    ++*(_DWORD *)a2;
  }
  else
  {
    __break(1u);
  }
  return result;
}

void LogMcastStateInfo(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t i;
  uint64_t v14;
  uint64_t v15;
  uint64_t j;
  NSObject *v18;
  char *v19;
  int v20;
  int v21;

  if ((_DWORD)a3)
  {
    i_mcount = 0;
    if ((_DWORD)a2)
      mcount = 0;
    if (mDNS_McastLoggingEnabled)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "--- START MCAST STATE LOG ---", a4, a5, a6, a7, a8, v21);
    v10 = all_requests;
    if (all_requests)
    {
      do
      {
        v11 = *(_QWORD *)(v10 + 24);
        if (v11)
        {
          for (i = all_requests; i && i != v10; i = *(_QWORD *)(i + 16))
          {
            if (i == v11)
              goto LABEL_18;
          }
          if (mDNS_McastLoggingEnabled)
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: Orphan operation; parent not found in request list",
              a4,
              a5,
              a6,
              a7,
              a8,
              *(_DWORD *)(v10 + 176));
        }
        LogMcastClientInfo((_QWORD *)v10, a2, a3, a4, a5, a6, a7, a8, v21);
LABEL_18:
        v10 = *(_QWORD *)(v10 + 16);
      }
      while (v10);
      if (mcount || (mcount = i_mcount) != 0)
      {
LABEL_43:
        v20 = mDNS_McastLoggingEnabled;
        if (a1)
        {
          if (mDNS_McastLoggingEnabled)
          {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "--- MCOUNT[%d]: CMPKTNUM[%d] - IMPKTNUM[%d] = [%d]PKTS ---", a4, a5, a6, a7, a8, mcount);
            v20 = mDNS_McastLoggingEnabled;
          }
        }
        if (v20)
        {
          v18 = mDNSLogCategory_Default;
          v19 = "--- END MCAST STATE LOG ---";
LABEL_48:
          LogMsgWithLevel(v18, OS_LOG_TYPE_DEFAULT, v19, a4, a5, a6, a7, a8, a9);
          return;
        }
        return;
      }
    }
    else
    {
      mcount = 0;
      if (!mDNS_McastLoggingEnabled)
      {
        LogMcastStateInfo_i_mpktnum = dword_100158E50;
        goto LABEL_43;
      }
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "<None>", a4, a5, a6, a7, a8, v21);
      if (mcount)
        goto LABEL_43;
    }
    LogMcastStateInfo_i_mpktnum = dword_100158E50;
    if (mDNS_McastLoggingEnabled)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "--- MCOUNT[%d]: IMPKTNUM[%d] ---", a4, a5, a6, a7, a8, 0);
    goto LABEL_43;
  }
  v14 = all_requests;
  if (!all_requests)
  {
    if (!mDNS_McastLoggingEnabled)
      return;
    v18 = mDNSLogCategory_Default;
    v19 = "<None>";
    goto LABEL_48;
  }
  do
  {
    v15 = *(_QWORD *)(v14 + 24);
    if (v15)
    {
      for (j = all_requests; j && j != v14; j = *(_QWORD *)(j + 16))
      {
        if (j == v15)
          goto LABEL_32;
      }
    }
    GetMcastClients(v14);
LABEL_32:
    v14 = *(_QWORD *)(v14 + 16);
  }
  while (v14);
  if (mDNS_McastLoggingEnabled)
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "--- MCAST RECORDS COUNT[%d] MCAST QUESTIONS COUNT[%d] ---", a4, a5, a6, a7, a8, n_mrecords);
  n_mquests = 0;
  n_mrecords = 0;
}

uint64_t GetMcastClients(uint64_t result)
{
  uint64_t v1;
  void (*v2)(uint64_t);
  uint64_t i;
  uint64_t v4;
  uint64_t j;
  uint64_t *k;
  uint64_t *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;

  v1 = result;
  v2 = *(void (**)(uint64_t))(result + 104);
  if (v2 == connection_termination)
  {
    for (i = *(_QWORD *)(result + 168); i; i = *(_QWORD *)(i + 8))
    {
      v4 = *(_QWORD *)(i + 56);
      if (!*(_QWORD *)(v4 + 32) && !*(_BYTE *)(v4 + 122))
      {
        result = IsLocalDomain(*(_BYTE **)(v4 + 40));
        if (!(_DWORD)result)
          continue;
      }
      ++n_mrecords;
    }
    for (j = *(_QWORD *)(v1 + 16); j; j = *(_QWORD *)(j + 16))
    {
      if (*(_QWORD *)(j + 24) == v1)
        result = GetMcastClients(j);
    }
  }
  else if ((char *)v2 == (char *)regservice_termination_callback)
  {
    for (k = *(uint64_t **)(*(_QWORD *)(result + 120) + 1624); k; k = (uint64_t *)*k)
    {
      if (!k[341] && !*((_BYTE *)k + 2818))
      {
        result = IsLocalDomain((_BYTE *)k[342]);
        if (!(_DWORD)result)
          continue;
      }
      ++n_mrecords;
    }
  }
  else if ((char *)v2 == (char *)browse_termination_callback)
  {
    v7 = *(uint64_t **)(*(_QWORD *)(result + 144) + 272);
    if (v7)
    {
      v8 = n_mquests;
      do
      {
        if (!*((_WORD *)v7 + 302))
          n_mquests = ++v8;
        v7 = (uint64_t *)*v7;
      }
      while (v7);
    }
  }
  else if (v2 == resolve_termination_callback)
  {
    v9 = *(_QWORD *)(result + 128);
    if (!*(_WORD *)(v9 + 1036) && *(int *)(v9 + 908) > 0)
      goto LABEL_38;
  }
  else
  {
    if (v2 != queryrecord_termination_callback)
    {
      if (v2 != addrinfo_termination_callback)
        return result;
      result = GetAddrInfoClientRequestIsMulticast(*(_QWORD *)(result + 160));
      if (!(_DWORD)result)
        return result;
LABEL_38:
      ++n_mquests;
      return result;
    }
    v10 = *(_QWORD *)(result + 136);
    if (!*(_WORD *)(v10 + 340) && *(int *)(v10 + 212) >= 1)
      goto LABEL_38;
  }
  return result;
}

void LogMcastClientInfo(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  void (*v9)(uint64_t);
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t i;
  uint64_t *v29;
  uint64_t v30;
  uint64_t *v32;
  int v33;
  BOOL v34;
  NSObject *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  NSObject *v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  NSObject *v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;

  v9 = (void (*)(uint64_t))a1[13];
  if (v9)
  {
    if (v9 != connection_termination)
    {
      if ((char *)v9 != (char *)regservice_termination_callback)
      {
        if ((char *)v9 == (char *)browse_termination_callback)
        {
          v32 = *(uint64_t **)(a1[18] + 272);
          if (v32)
          {
            v33 = mDNS_McastLoggingEnabled;
            do
            {
              if (*((_WORD *)v32 + 302))
                v34 = 1;
              else
                v34 = v33 == 0;
              if (!v34)
              {
                v35 = mDNSLogCategory_Default;
                DNSTypeName(*((unsigned __int16 *)v32 + 303));
                ++i_mcount;
                LogMsgWithLevel(v35, OS_LOG_TYPE_DEFAULT, "Q: DNSServiceBrowse  %##s %s PID[%d](%s)", v36, v37, v38, v39, v40, (_DWORD)v32 + 640);
                v33 = mDNS_McastLoggingEnabled;
              }
              v32 = (uint64_t *)*v32;
            }
            while (v32);
          }
        }
        else if (v9 == resolve_termination_callback)
        {
          v41 = a1[16];
          if (!*(_WORD *)(v41 + 1036) && *(int *)(v41 + 908) >= 1 && mDNS_McastLoggingEnabled != 0)
          {
            v43 = mDNSLogCategory_Default;
            v44 = v41 + 1072;
            DNSTypeName(*(unsigned __int16 *)(v41 + 1038));
            ++i_mcount;
            LogMsgWithLevel(v43, OS_LOG_TYPE_DEFAULT, "Q: DNSServiceResolve  %##s %s PID[%d](%s)", v45, v46, v47, v48, v49, v44);
          }
        }
        else if (v9 == queryrecord_termination_callback)
        {
          v50 = a1[17];
          if (!*(_WORD *)(v50 + 340) && *(int *)(v50 + 212) >= 1 && mDNS_McastLoggingEnabled != 0)
          {
            v52 = mDNSLogCategory_Default;
            v53 = v50 + 376;
            DNSTypeName(*(unsigned __int16 *)(v50 + 342));
            ++i_mcount;
            LogMsgWithLevel(v52, OS_LOG_TYPE_DEFAULT, "Q: DNSServiceQueryRecord  %##s %s PID[%d](%s)", v54, v55, v56, v57, v58, v53);
          }
        }
        else if (v9 == addrinfo_termination_callback)
        {
          v11 = a1[20];
          if (GetAddrInfoClientRequestIsMulticast(v11))
          {
            if (mDNS_McastLoggingEnabled)
            {
              v17 = "v4";
              if ((*(_DWORD *)(v11 + 8) & 1) == 0)
                v17 = "  ";
              ++i_mcount;
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Q: DNSServiceGetAddrInfo  %s%s %##s PID[%d](%s)", v12, v13, v14, v15, v16, (int)v17);
            }
          }
        }
        return;
      }
      v29 = *(uint64_t **)(a1[15] + 1624);
      if (!v29)
        return;
      while (v29[341] || *((_BYTE *)v29 + 2818))
      {
        if (mDNS_McastLoggingEnabled)
          goto LABEL_36;
LABEL_37:
        v29 = (uint64_t *)*v29;
        if (!v29)
          return;
      }
      if (!IsLocalDomain((_BYTE *)v29[342]) || mDNS_McastLoggingEnabled == 0)
        goto LABEL_37;
LABEL_36:
      v30 = v29[342];
      ++i_mcount;
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "R: DNSServiceRegister:  %##s %u/%u PID[%d](%s)", a4, a5, a6, a7, a8, v30);
      goto LABEL_37;
    }
    v18 = a1[21];
    if (v18)
    {
      while (1)
      {
        v19 = *(_QWORD *)(v18 + 56);
        if (!*(_QWORD *)(v19 + 32) && !*(_BYTE *)(v19 + 122))
          break;
        if (mDNS_McastLoggingEnabled)
          goto LABEL_19;
LABEL_20:
        v18 = *(_QWORD *)(v18 + 8);
        if (!v18)
          goto LABEL_27;
      }
      if (!IsLocalDomain(*(_BYTE **)(v19 + 40)) || mDNS_McastLoggingEnabled == 0)
        goto LABEL_20;
      v19 = *(_QWORD *)(v18 + 56);
LABEL_19:
      v20 = mDNSLogCategory_Default;
      v21 = *(_QWORD *)(v19 + 40);
      DNSTypeName(*(unsigned __int16 *)(v19 + 12));
      ++i_mcount;
      LogMsgWithLevel(v20, OS_LOG_TYPE_DEFAULT, "R: ->  DNSServiceRegisterRecord:  %##s %s PID[%d](%s)", v22, v23, v24, v25, v26, v21);
      goto LABEL_20;
    }
LABEL_27:
    for (i = a1[2]; i; i = *(_QWORD *)(i + 16))
    {
      if (*(_QWORD **)(i + 24) == a1)
        LogMcastClientInfo(i);
    }
  }
  else if (mDNS_McastLoggingEnabled)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "No operation yet on this socket", a4, a5, a6, a7, a8, a9);
  }
}

void regservice_termination_callback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v10;
  _QWORD *v11;
  _BYTE *v12;
  _QWORD *v13;
  NSObject *v14;
  unsigned __int8 *v16;
  unsigned __int8 *v17;
  unsigned __int16 v18;
  uint64_t v19;
  uint64_t v20;
  unsigned __int8 *v22;
  unsigned __int8 *v23;
  unsigned __int16 v24;
  uint64_t v25;
  int v26;
  int v27;
  int v28;
  unsigned __int8 *v29;
  unsigned int v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  unsigned __int8 *v34;
  int v35;
  unsigned int v36;
  int v37;
  int v38;
  NSObject *v39;
  int v40;
  unsigned __int8 *v41;
  unsigned int v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  unsigned __int8 *v46;
  int v47;
  unsigned int v48;
  int v49;
  int v50;
  int ShouldLogFullRequestInfo;
  unsigned __int8 *v52;
  unsigned __int8 *v53;
  uint64_t v54;
  char v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  unsigned __int8 *v65;
  unsigned __int16 v66;
  uint64_t v67;
  int v68;
  unsigned __int8 *v69;
  uint64_t v70;
  unsigned __int8 *v71;
  unsigned __int16 v72;
  uint64_t v73;
  unsigned __int8 *v74;
  unsigned __int16 v75;
  uint64_t v76;
  uint64_t v77;
  int v78;
  int v79;
  NSObject *v80;
  const char *v81;
  int v82;
  int v83;
  uint32_t v84;
  unsigned __int8 *v85;
  unsigned __int16 v86;
  uint64_t v87;
  int v88;
  int v89;
  int v90;
  unsigned int v91;
  int v92;
  unsigned __int8 *v93;
  int v94;
  int v95;
  int v96;
  unsigned int v97;
  int v98;
  unsigned __int8 *v99;
  int v100;
  int v101;
  int v102;
  int v103;
  unsigned int v104;
  int v105;
  int v106;
  int v107;
  int v108;
  int v109;
  int v110;
  unsigned int v111;
  int v112;
  int v113;
  int v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  int v129;
  BOOL v130;
  void *v131;
  int v132;
  int v133;
  int v134;
  int v135;
  int v136;
  int v137;
  int v138;
  NSObject *v139;
  int v140;
  int v141;
  int v142;
  int v143;
  int v144;
  uint64_t v145;
  char *v146;
  _BYTE __tp[20];
  int v148;
  __int16 v149;
  unsigned __int8 *v150;
  __int16 v151;
  int v152;
  __int16 v153;
  unsigned int v154;
  __int16 v155;
  int v156;
  __int16 v157;
  _BYTE v158[10];
  _BYTE v159[10];
  __int16 v160;
  int v161;
  __int16 v162;
  int v163;

  if (a1)
  {
    v10 = *(_QWORD *)(a1 + 120);
    v11 = *(_QWORD **)(v10 + 1624);
    if (v11)
    {
      v146 = (char *)(a1 + 248);
      v12 = &unk_100164000;
      v13 = &unk_100150000;
      v132 = 67109376;
      v145 = *(_QWORD *)(a1 + 120);
      while (1)
      {
        *(_QWORD *)(v10 + 1624) = *v11;
        v14 = v13[197];
        if (v12[2416] != 1 || v14 == mDNSLogCategory_State)
          break;
        v20 = mDNSLogCategory_mDNS_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
        {
          v22 = (unsigned __int8 *)v11[342];
          if (v22)
          {
            v23 = (unsigned __int8 *)v11[342];
            if (v22 == (unsigned __int8 *)-256)
              goto LABEL_26;
LABEL_23:
            v24 = 257;
            if (v23 < v22 + 256 && v23)
            {
              while (1)
              {
                v25 = *v23;
                if (v25 > 0x3F)
                {
LABEL_34:
                  v24 = 257;
                  goto LABEL_52;
                }
                if (!*v23)
                  break;
                v23 += v25 + 1;
                if (v22 != (unsigned __int8 *)-256)
                  goto LABEL_23;
LABEL_26:
                if (!v23)
                  goto LABEL_34;
              }
              v24 = (_WORD)v23 - (_WORD)v22 + 1;
            }
LABEL_52:
            v27 = v24;
          }
          else
          {
            v27 = 0;
          }
          v40 = *(_DWORD *)(a1 + 192);
          v41 = (unsigned __int8 *)v11[342];
          if (v22 == (unsigned __int8 *)-256)
            goto LABEL_57;
LABEL_54:
          v42 = 257;
          if (v41 < v22 + 256 && v41)
          {
            do
            {
              v43 = *v41;
              if (v43 > 0x3F)
                break;
              if (!*v41)
              {
                v44 = -2128831035;
                v42 = (unsigned __int16)((_WORD)v41 - (_WORD)v22 + 1);
                if ((_WORD)v41 - (_WORD)v22 != 0xFFFF)
                  goto LABEL_64;
LABEL_66:
                v48 = bswap32(*(unsigned __int16 *)(v11[343] + 8)) >> 16;
                v49 = *(_DWORD *)(a1 + 180);
                *(_QWORD *)__tp = 0;
                *(_QWORD *)&__tp[8] = 0;
                clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
                v50 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 196);
                *(_DWORD *)__tp = 67111171;
                *(_DWORD *)&__tp[4] = v40;
                *(_WORD *)&__tp[8] = 2160;
                *(_QWORD *)&__tp[10] = 1752392040;
                *(_WORD *)&__tp[18] = 1040;
                v148 = v27;
                v149 = 2101;
                v150 = v22;
                v151 = 1024;
                v152 = v44;
                v153 = 1024;
                v154 = v48;
                v155 = 1024;
                v156 = v49;
                v12 = &unk_100164000;
                v157 = 2082;
                v10 = v145;
                *(_QWORD *)v158 = v146;
                *(_WORD *)&v158[8] = 1024;
                *(_DWORD *)v159 = v50;
                v39 = v20;
LABEL_67:
                _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "[R%d] DNSServiceRegister(%{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), %u) STOP PID[%d](%{public}s) -- duration: %{mdns:time_duration}u", __tp, 0x44u);
                v13 = &unk_100150000;
                goto LABEL_68;
              }
              v41 += v43 + 1;
              if (v22 != (unsigned __int8 *)-256)
                goto LABEL_54;
LABEL_57:
              ;
            }
            while (v41);
            v42 = 257;
          }
LABEL_64:
          v45 = v42;
          v46 = (unsigned __int8 *)v11[342];
          v44 = -2128831035;
          do
          {
            v47 = *v46++;
            v44 = 16777619 * (v44 ^ v47);
            --v45;
          }
          while (v45);
          goto LABEL_66;
        }
LABEL_68:
        ShouldLogFullRequestInfo = requestShouldLogFullRequestInfo(a1);
        v52 = (unsigned __int8 *)v11[342];
        v53 = v52 + 1;
        v54 = (uint64_t)&v52[*v52 + 1];
        if (!*v52)
          v54 = v11[342];
        v55 = v12[2416];
        v56 = v13[197];
        if (v56 == mDNSLogCategory_State)
          v55 = 0;
        if (ShouldLogFullRequestInfo)
        {
          if (v54)
          {
            if ((v55 & 1) != 0)
            {
              v57 = mDNSLogCategory_mDNS_redacted;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
              {
                v141 = *(_DWORD *)(a1 + 192);
                v65 = v52;
                if (v52 == (unsigned __int8 *)-256)
                  goto LABEL_80;
LABEL_77:
                v66 = 257;
                if (v65 < v52 + 256 && v65)
                {
                  while (1)
                  {
                    v67 = *v65;
                    if (v67 > 0x3F)
                    {
LABEL_133:
                      v66 = 257;
                      goto LABEL_136;
                    }
                    if (!*v65)
                      break;
                    v65 += v67 + 1;
                    if (v52 != (unsigned __int8 *)-256)
                      goto LABEL_77;
LABEL_80:
                    if (!v65)
                      goto LABEL_133;
                  }
                  v66 = (_WORD)v65 - (_WORD)v52 + 1;
                }
LABEL_136:
                v137 = v66;
                v90 = mDNS_DomainNameFNV1aHash(v52);
                v91 = bswap32(*(unsigned __int16 *)(v11[343] + 8)) >> 16;
                v92 = *(_DWORD *)(a1 + 240);
                v133 = *(_DWORD *)(a1 + 244);
                v135 = *(_DWORD *)(a1 + 180);
                if (*v52)
                  v93 = &v53[*v52];
                else
                  v93 = v52;
                v94 = mDNS_DomainNameFNV1aHash(v93);
                *(_QWORD *)__tp = 0;
                *(_QWORD *)&__tp[8] = 0;
                clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
                v95 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 196);
                *(_DWORD *)__tp = 67111939;
                *(_DWORD *)&__tp[4] = v141;
                *(_WORD *)&__tp[8] = 2160;
                *(_QWORD *)&__tp[10] = 1752392040;
                *(_WORD *)&__tp[18] = 1040;
                v148 = v137;
                v149 = 2101;
                v150 = v52;
                v151 = 1024;
                v152 = v90;
                v13 = (_QWORD *)&unk_100150000;
                v153 = 1024;
                v154 = v91;
                v12 = (_BYTE *)&unk_100164000;
                v155 = 1024;
                v156 = v92;
                v157 = 1024;
                *(_DWORD *)v158 = v133;
                *(_WORD *)&v158[4] = 1024;
                *(_DWORD *)&v158[6] = v135;
                *(_WORD *)v159 = 2082;
                v10 = v145;
                *(_QWORD *)&v159[2] = v146;
                v160 = 1024;
                v161 = v94;
                v162 = 1024;
                v163 = v95;
                v80 = v57;
                v81 = "[R%u] DNSServiceRegister STOP -- SRV name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P ("
                      "%x), port: %u, flags: 0x%X, interface index: %d, client pid: %d (%{public}s), name hash: %x, durat"
                      "ion: %{mdns:time_duration}u";
LABEL_145:
                v84 = 86;
                goto LABEL_153;
              }
            }
            else if (os_log_type_enabled((os_log_t)v13[197], OS_LOG_TYPE_DEFAULT))
            {
              v143 = *(_DWORD *)(a1 + 192);
              v74 = v52;
              if (v52 == (unsigned __int8 *)-256)
                goto LABEL_107;
LABEL_104:
              v75 = 257;
              if (v74 < v52 + 256 && v74)
              {
                while (1)
                {
                  v76 = *v74;
                  if (v76 > 0x3F)
                  {
LABEL_134:
                    v75 = 257;
                    goto LABEL_141;
                  }
                  if (!*v74)
                    break;
                  v74 += v76 + 1;
                  if (v52 != (unsigned __int8 *)-256)
                    goto LABEL_104;
LABEL_107:
                  if (!v74)
                    goto LABEL_134;
                }
                v75 = (_WORD)v74 - (_WORD)v52 + 1;
              }
LABEL_141:
              v138 = v75;
              v96 = mDNS_DomainNameFNV1aHash(v52);
              v97 = bswap32(*(unsigned __int16 *)(v11[343] + 8)) >> 16;
              v98 = *(_DWORD *)(a1 + 240);
              v134 = *(_DWORD *)(a1 + 244);
              v136 = *(_DWORD *)(a1 + 180);
              if (*v52)
                v99 = &v53[*v52];
              else
                v99 = v52;
              v100 = mDNS_DomainNameFNV1aHash(v99);
              *(_QWORD *)__tp = 0;
              *(_QWORD *)&__tp[8] = 0;
              clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
              v101 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 196);
              *(_DWORD *)__tp = 67111939;
              *(_DWORD *)&__tp[4] = v143;
              *(_WORD *)&__tp[8] = 2160;
              *(_QWORD *)&__tp[10] = 1752392040;
              *(_WORD *)&__tp[18] = 1040;
              v148 = v138;
              v149 = 2101;
              v150 = v52;
              v151 = 1024;
              v152 = v96;
              v153 = 1024;
              v154 = v97;
              v12 = (_BYTE *)&unk_100164000;
              v155 = 1024;
              v156 = v98;
              v157 = 1024;
              *(_DWORD *)v158 = v134;
              *(_WORD *)&v158[4] = 1024;
              *(_DWORD *)&v158[6] = v136;
              *(_WORD *)v159 = 2082;
              v10 = v145;
              *(_QWORD *)&v159[2] = v146;
              v160 = 1024;
              v161 = v100;
              v13 = (_QWORD *)&unk_100150000;
              v162 = 1024;
              v163 = v101;
              v80 = v56;
              v81 = "[R%u] DNSServiceRegister STOP -- SRV name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x"
                    "), port: %u, flags: 0x%X, interface index: %d, client pid: %d (%{public}s), name hash: %x, duration:"
                    " %{mdns:time_duration}u";
              goto LABEL_145;
            }
          }
          else if ((v55 & 1) != 0)
          {
            v70 = mDNSLogCategory_mDNS_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
            {
              v142 = *(_DWORD *)(a1 + 192);
              v71 = v52;
              if (v52 == (unsigned __int8 *)-256)
                goto LABEL_97;
LABEL_94:
              v72 = 257;
              if (v71 < v52 + 256 && v71)
              {
                while (1)
                {
                  v73 = *v71;
                  if (v73 > 0x3F)
                  {
LABEL_146:
                    v72 = 257;
                    goto LABEL_149;
                  }
                  if (!*v71)
                    break;
                  v71 += v73 + 1;
                  if (v52 != (unsigned __int8 *)-256)
                    goto LABEL_94;
LABEL_97:
                  if (!v71)
                    goto LABEL_146;
                }
                v72 = (_WORD)v71 - (_WORD)v52 + 1;
              }
LABEL_149:
              v102 = v72;
              v103 = mDNS_DomainNameFNV1aHash(v52);
              v104 = bswap32(*(unsigned __int16 *)(v11[343] + 8)) >> 16;
              v139 = v70;
              v106 = *(_DWORD *)(a1 + 240);
              v105 = *(_DWORD *)(a1 + 244);
              v107 = *(_DWORD *)(a1 + 180);
              *(_QWORD *)__tp = 0;
              *(_QWORD *)&__tp[8] = 0;
              clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
              v108 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 196);
              *(_DWORD *)__tp = 67111683;
              *(_DWORD *)&__tp[4] = v142;
              *(_WORD *)&__tp[8] = 2160;
              *(_QWORD *)&__tp[10] = 1752392040;
              *(_WORD *)&__tp[18] = 1040;
              v148 = v102;
              v149 = 2101;
              v150 = v52;
              v151 = 1024;
              v152 = v103;
              v13 = (_QWORD *)&unk_100150000;
              v153 = 1024;
              v154 = v104;
              v155 = 1024;
              v156 = v106;
              v12 = (_BYTE *)&unk_100164000;
              v157 = 1024;
              *(_DWORD *)v158 = v105;
              *(_WORD *)&v158[4] = 1024;
              *(_DWORD *)&v158[6] = v107;
              *(_WORD *)v159 = 2082;
              v10 = v145;
              *(_QWORD *)&v159[2] = v146;
              v160 = 1024;
              v161 = v108;
              v80 = v139;
              v81 = "[R%u] DNSServiceRegister STOP -- SRV name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x"
                    "), port: %u, flags: 0x%X, interface index: %d, client pid: %d (%{public}s), , duration: %{mdns:time_duration}u";
LABEL_152:
              v84 = 80;
              goto LABEL_153;
            }
          }
          else if (os_log_type_enabled((os_log_t)v13[197], OS_LOG_TYPE_DEFAULT))
          {
            v144 = *(_DWORD *)(a1 + 192);
            v85 = v52;
            if (v52 == (unsigned __int8 *)-256)
              goto LABEL_125;
LABEL_122:
            v86 = 257;
            if (v85 < v52 + 256 && v85)
            {
              while (1)
              {
                v87 = *v85;
                if (v87 > 0x3F)
                {
LABEL_147:
                  v86 = 257;
                  goto LABEL_151;
                }
                if (!*v85)
                  break;
                v85 += v87 + 1;
                if (v52 != (unsigned __int8 *)-256)
                  goto LABEL_122;
LABEL_125:
                if (!v85)
                  goto LABEL_147;
              }
              v86 = (_WORD)v85 - (_WORD)v52 + 1;
            }
LABEL_151:
            v109 = v86;
            v110 = mDNS_DomainNameFNV1aHash(v52);
            v111 = bswap32(*(unsigned __int16 *)(v11[343] + 8)) >> 16;
            v113 = *(_DWORD *)(a1 + 240);
            v112 = *(_DWORD *)(a1 + 244);
            v140 = *(_DWORD *)(a1 + 180);
            *(_QWORD *)__tp = 0;
            *(_QWORD *)&__tp[8] = 0;
            clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
            v114 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 196);
            *(_DWORD *)__tp = 67111683;
            *(_DWORD *)&__tp[4] = v144;
            *(_WORD *)&__tp[8] = 2160;
            *(_QWORD *)&__tp[10] = 1752392040;
            *(_WORD *)&__tp[18] = 1040;
            v148 = v109;
            v149 = 2101;
            v150 = v52;
            v151 = 1024;
            v152 = v110;
            v13 = (_QWORD *)&unk_100150000;
            v153 = 1024;
            v154 = v111;
            v155 = 1024;
            v156 = v113;
            v12 = (_BYTE *)&unk_100164000;
            v157 = 1024;
            *(_DWORD *)v158 = v112;
            *(_WORD *)&v158[4] = 1024;
            *(_DWORD *)&v158[6] = v140;
            *(_WORD *)v159 = 2082;
            v10 = v145;
            *(_QWORD *)&v159[2] = v146;
            v160 = 1024;
            v161 = v114;
            v80 = v56;
            v81 = "[R%u] DNSServiceRegister STOP -- SRV name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x),"
                  " port: %u, flags: 0x%X, interface index: %d, client pid: %d (%{public}s), , duration: %{mdns:time_duration}u";
            goto LABEL_152;
          }
        }
        else if (v54)
        {
          if ((v55 & 1) != 0)
          {
            v56 = mDNSLogCategory_mDNS_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
            {
              v68 = *(_DWORD *)(a1 + 192);
              if (*v52)
                v69 = &v53[*v52];
              else
                v69 = v52;
LABEL_119:
              v82 = mDNS_DomainNameFNV1aHash(v69);
              *(_QWORD *)__tp = 0;
              *(_QWORD *)&__tp[8] = 0;
              clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
              v83 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 196);
              *(_DWORD *)__tp = 67109632;
              *(_DWORD *)&__tp[4] = v68;
              *(_WORD *)&__tp[8] = 1024;
              *(_DWORD *)&__tp[10] = v82;
              v13 = (_QWORD *)&unk_100150000;
              *(_WORD *)&__tp[14] = 1024;
              *(_DWORD *)&__tp[16] = v83;
              v80 = v56;
              v81 = "[R%u] DNSServiceRegister STOP -- name hash: %x, duration: %{mdns:time_duration}u";
              v84 = 20;
              goto LABEL_153;
            }
          }
          else if (os_log_type_enabled((os_log_t)v13[197], OS_LOG_TYPE_DEFAULT))
          {
            v68 = *(_DWORD *)(a1 + 192);
            if (*v52)
              v69 = &v53[*v52];
            else
              v69 = v52;
            goto LABEL_119;
          }
        }
        else if ((v55 & 1) != 0)
        {
          v77 = mDNSLogCategory_mDNS_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
          {
            v78 = *(_DWORD *)(a1 + 192);
            *(_QWORD *)__tp = 0;
            *(_QWORD *)&__tp[8] = 0;
            clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
            v79 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 196);
            *(_DWORD *)__tp = v132;
            *(_DWORD *)&__tp[4] = v78;
            *(_WORD *)&__tp[8] = 1024;
            *(_DWORD *)&__tp[10] = v79;
            v80 = v77;
            v81 = "[R%u] DNSServiceRegister STOP -- , duration: %{mdns:time_duration}u";
            goto LABEL_132;
          }
        }
        else if (os_log_type_enabled((os_log_t)v13[197], OS_LOG_TYPE_DEFAULT))
        {
          v88 = *(_DWORD *)(a1 + 192);
          *(_QWORD *)__tp = 0;
          *(_QWORD *)&__tp[8] = 0;
          clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
          v89 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 196);
          *(_DWORD *)__tp = v132;
          *(_DWORD *)&__tp[4] = v88;
          *(_WORD *)&__tp[8] = 1024;
          *(_DWORD *)&__tp[10] = v89;
          v80 = v56;
          v81 = "[R%u] DNSServiceRegister STOP -- , duration: %{mdns:time_duration}u";
LABEL_132:
          v84 = 14;
LABEL_153:
          _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, v81, __tp, v84);
        }
        external_stop_advertising_helper((uint64_t)v11, v58, v59, v60, v61, v62, v63, v64);
        v11[1] = 0;
        if (mDNS_McastLoggingEnabled)
          LogMcastService((uint64_t)(v11 + 337), a1, 0, v115, v116, v117, v118, v119, v132);
        if (mDNS_DeregisterService_drt((unsigned int *)mDNSStorage, (uint64_t)(v11 + 36), 0, v115, v116, v117, v118, v119))unlink_and_free_service_instance(v11, v120, v121, v122, v123, v124, v125, v126);
        v127 = *(_QWORD *)(a1 + 8);
        if (v127)
        {
          v128 = *(unsigned int *)(a1 + 244);
          if ((_DWORD)v128)
          {
            if (AWDLInterfaceID && AWDLInterfaceID == v128)
            {
              v129 = 1;
            }
            else
            {
              if (WiFiAwareInterfaceID)
                v130 = WiFiAwareInterfaceID == v128;
              else
                v130 = 0;
              v129 = v130;
            }
          }
          else
          {
            v129 = (*(_DWORD *)(a1 + 240) >> 20) & 1;
          }
          _mdns_powerlog_bonjour_event(18, v129, v146, v127);
          *(_QWORD *)(a1 + 8) = 0;
        }
        v11 = *(_QWORD **)(v10 + 1624);
        if (!v11)
          goto LABEL_172;
      }
      if (!os_log_type_enabled((os_log_t)v13[197], OS_LOG_TYPE_DEFAULT))
        goto LABEL_68;
      v16 = (unsigned __int8 *)v11[342];
      if (v16)
      {
        v17 = (unsigned __int8 *)v11[342];
        if (v16 == (unsigned __int8 *)-256)
          goto LABEL_15;
LABEL_12:
        v18 = 257;
        if (v17 < v16 + 256 && v17)
        {
          while (1)
          {
            v19 = *v17;
            if (v19 > 0x3F)
            {
LABEL_33:
              v18 = 257;
              goto LABEL_36;
            }
            if (!*v17)
              break;
            v17 += v19 + 1;
            if (v16 != (unsigned __int8 *)-256)
              goto LABEL_12;
LABEL_15:
            if (!v17)
              goto LABEL_33;
          }
          v18 = (_WORD)v17 - (_WORD)v16 + 1;
        }
LABEL_36:
        v26 = v18;
      }
      else
      {
        v26 = 0;
      }
      v28 = *(_DWORD *)(a1 + 192);
      v29 = (unsigned __int8 *)v11[342];
      if (v16 == (unsigned __int8 *)-256)
        goto LABEL_41;
LABEL_38:
      v30 = 257;
      if (v29 < v16 + 256 && v29)
      {
        do
        {
          v31 = *v29;
          if (v31 > 0x3F)
            break;
          if (!*v29)
          {
            v32 = -2128831035;
            v30 = (unsigned __int16)((_WORD)v29 - (_WORD)v16 + 1);
            if ((_WORD)v29 - (_WORD)v16 != 0xFFFF)
              goto LABEL_48;
LABEL_50:
            v36 = bswap32(*(unsigned __int16 *)(v11[343] + 8)) >> 16;
            v37 = *(_DWORD *)(a1 + 180);
            *(_QWORD *)__tp = 0;
            *(_QWORD *)&__tp[8] = 0;
            clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
            v38 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 196);
            *(_DWORD *)__tp = 67111171;
            *(_DWORD *)&__tp[4] = v28;
            *(_WORD *)&__tp[8] = 2160;
            *(_QWORD *)&__tp[10] = 1752392040;
            *(_WORD *)&__tp[18] = 1040;
            v148 = v26;
            v149 = 2101;
            v150 = v16;
            v151 = 1024;
            v152 = v32;
            v153 = 1024;
            v154 = v36;
            v12 = (_BYTE *)&unk_100164000;
            v155 = 1024;
            v156 = v37;
            v157 = 2082;
            v10 = v145;
            *(_QWORD *)v158 = v146;
            *(_WORD *)&v158[8] = 1024;
            *(_DWORD *)v159 = v38;
            v39 = v14;
            goto LABEL_67;
          }
          v29 += v31 + 1;
          if (v16 != (unsigned __int8 *)-256)
            goto LABEL_38;
LABEL_41:
          ;
        }
        while (v29);
        v30 = 257;
      }
LABEL_48:
      v33 = v30;
      v34 = (unsigned __int8 *)v11[342];
      v32 = -2128831035;
      do
      {
        v35 = *v34++;
        v32 = 16777619 * (v32 ^ v35);
        --v33;
      }
      while (v33);
      goto LABEL_50;
    }
LABEL_172:
    v131 = *(void **)(v10 + 16);
    if (v131)
    {
      free(v131);
      *(_QWORD *)(v10 + 16) = 0;
    }
    if (*(_BYTE *)(v10 + 1612))
    {
      *(_BYTE *)(v10 + 1612) = 0;
      UpdateDeviceInfoRecord(mDNSStorage);
    }
  }
  else
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "regservice_termination_callback context is NULL", a4, a5, a6, a7, a8, a9);
  }
}

void browse_termination_callback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  _BYTE *v10;
  void *v11;
  NSObject **v12;
  int ShouldLogFullRequestInfo;
  char v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  const char *v28;
  NSObject *v29;
  uint32_t v30;
  int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  unsigned int *v36;
  _DWORD *v37;
  int v38;
  __int16 v39;
  char v40;
  NSObject *v41;
  uint64_t v42;
  int v43;
  _BYTE *v44;
  uint64_t v45;
  int v46;
  _BYTE *v47;
  uint64_t v48;
  int v49;
  int v50;
  int v51;
  unsigned __int16 v52;
  unsigned __int16 v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  NSObject *v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  int v69;
  BOOL v70;
  uint64_t v71;
  unsigned __int8 *v72;
  timespec __tp[3];
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;

  v9 = *(_QWORD *)(a1 + 144);
  v10 = &unk_100164000;
  v11 = &unk_100150000;
  v12 = (NSObject **)&unk_100164000;
  if (!*(_BYTE *)(v9 + 8))
    goto LABEL_24;
  ShouldLogFullRequestInfo = requestShouldLogFullRequestInfo(a1);
  v14 = gSensitiveLoggingEnabled;
  v15 = mDNSLogCategory_mDNS;
  if (mDNSLogCategory_mDNS == mDNSLogCategory_State)
    v14 = 0;
  if (!ShouldLogFullRequestInfo)
  {
    if ((v14 & 1) != 0)
    {
      v15 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_16;
    }
    else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
    {
      goto LABEL_16;
    }
    v31 = *(_DWORD *)(a1 + 192);
    __tp[0].tv_sec = 0;
    __tp[0].tv_nsec = 0;
    clock_gettime(_CLOCK_MONOTONIC_RAW, __tp);
    v32 = LODWORD(__tp[0].tv_sec) - *(_DWORD *)(a1 + 196);
    LODWORD(__tp[0].tv_sec) = 67109376;
    HIDWORD(__tp[0].tv_sec) = v31;
    LOWORD(__tp[0].tv_nsec) = 1024;
    *(_DWORD *)((char *)&__tp[0].tv_nsec + 2) = v32;
    v28 = "[R%u] DNSServiceBrowse Cancel domain enumeration for WAB and mDNS -- , duration: %{mdns:time_duration}u";
    v29 = v15;
    v30 = 14;
    goto LABEL_15;
  }
  if ((v14 & 1) != 0)
  {
    v15 = mDNSLogCategory_mDNS_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
      goto LABEL_12;
  }
  else if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
  {
LABEL_12:
    v23 = *(_DWORD *)(a1 + 192);
    v24 = *(_DWORD *)(a1 + 240);
    v25 = *(_DWORD *)(a1 + 244);
    v26 = *(_DWORD *)(a1 + 180);
    __tp[0].tv_sec = 0;
    __tp[0].tv_nsec = 0;
    clock_gettime(_CLOCK_MONOTONIC_RAW, __tp);
    v27 = LODWORD(__tp[0].tv_sec) - *(_DWORD *)(a1 + 196);
    LODWORD(__tp[0].tv_sec) = 67110402;
    HIDWORD(__tp[0].tv_sec) = v23;
    LOWORD(__tp[0].tv_nsec) = 1024;
    *(_DWORD *)((char *)&__tp[0].tv_nsec + 2) = v24;
    v11 = &unk_100150000;
    HIWORD(__tp[0].tv_nsec) = 1024;
    LODWORD(__tp[1].tv_sec) = v25;
    WORD2(__tp[1].tv_sec) = 1024;
    *(_DWORD *)((char *)&__tp[1].tv_sec + 6) = v26;
    WORD1(__tp[1].tv_nsec) = 2082;
    *(uint64_t *)((char *)&__tp[1].tv_nsec + 4) = a1 + 248;
    v12 = (NSObject **)&unk_100164000;
    WORD2(__tp[2].tv_sec) = 1024;
    *(_DWORD *)((char *)&__tp[2].tv_sec + 6) = v27;
    v28 = "[R%u] DNSServiceBrowse Cancel domain enumeration for WAB and mDNS -- , flags: 0x%X, interface index: %d, clien"
          "t pid: %d (%{public}s), , duration: %{mdns:time_duration}u";
    v29 = v15;
    v30 = 42;
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, v28, (uint8_t *)__tp, v30);
  }
LABEL_16:
  uDNS_StopWABQueries(2, v16, v17, v18, v19, v20, v21, v22);
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNS_StopDomainEnumeration", 16137);
  v33 = qword_10015C518;
  if (qword_10015C518)
  {
    while (!SameDomainNameBytes((_BYTE *)v33, "\x05local"))
    {
      v33 = *(_QWORD *)(v33 + 296);
      if (!v33)
        goto LABEL_23;
    }
    v34 = *(_QWORD *)(v33 + 272);
    if (v34)
    {
      v35 = *(_DWORD *)(v34 + 708);
      if (v35)
      {
        *(_DWORD *)(v34 + 708) = v35 - 1;
        mDNS_SetUpDomainEnumeration((unsigned int *)mDNSStorage, v33, 2);
      }
    }
  }
LABEL_23:
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_StopDomainEnumeration", 16166);
LABEL_24:
  v36 = *(unsigned int **)(v9 + 272);
  if (v36)
  {
    v72 = (unsigned __int8 *)(v9 + 10);
    v37 = (_DWORD *)&unk_100150000;
    v71 = v9;
    do
    {
      if (callExternalHelpers(*((_QWORD *)v36 + 50), (_BYTE *)v36 + 8, v36[147], a4, a5, a6, a7, a8))
      {
        v85 = 0u;
        v86 = 0u;
        v83 = 0u;
        v84 = 0u;
        v81 = 0u;
        v82 = 0u;
        v79 = 0u;
        v80 = 0u;
        v77 = 0u;
        v78 = 0u;
        v75 = 0u;
        v76 = 0u;
        v74 = 0u;
        memset(__tp, 0, sizeof(__tp));
        ConstructServiceName(__tp, 0, v72, (_BYTE *)v36 + 8);
        external_stop_browsing_for_service(*((_QWORD *)v36 + 50), (unsigned __int8 *)__tp, 12, v36[147], *(_DWORD *)(a1 + 180));
      }
      v38 = requestShouldLogFullRequestInfo(a1);
      v39 = (_WORD)v36 + 640;
      v40 = v10[2416];
      v41 = *((_QWORD *)v11 + 197);
      if (v41 == v12[296])
        v40 = 0;
      if (v38)
      {
        if ((v40 & 1) != 0)
        {
          v42 = mDNSLogCategory_mDNS_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
          {
            v43 = *(_DWORD *)(a1 + 192);
            v44 = v36 + 160;
            if (v36 == (unsigned int *)-896)
            {
LABEL_35:
              while (v44)
              {
                v45 = *v44;
                if (v45 > 0x3F)
                  break;
                if (!*v44)
                {
                  v52 = (_WORD)v44 - v39 + 1;
                  goto LABEL_56;
                }
                v44 += v45 + 1;
                if (v36 != (unsigned int *)-896)
                  goto LABEL_34;
              }
            }
            else
            {
LABEL_34:
              if (v44 < (_BYTE *)v36 + 896)
                goto LABEL_35;
            }
            v52 = 257;
LABEL_56:
            v54 = v52;
            v55 = *(_DWORD *)(a1 + 240);
            v56 = *(_DWORD *)(a1 + 244);
            v57 = *(_DWORD *)(a1 + 180);
            v58 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)v36 + 640);
            __tp[0].tv_sec = 0;
            __tp[0].tv_nsec = 0;
            clock_gettime(_CLOCK_MONOTONIC_RAW, __tp);
            v59 = LODWORD(__tp[0].tv_sec) - *(_DWORD *)(a1 + 196);
            LODWORD(__tp[0].tv_sec) = 67111427;
            HIDWORD(__tp[0].tv_sec) = v43;
            LOWORD(__tp[0].tv_nsec) = 2160;
            *(uint64_t *)((char *)&__tp[0].tv_nsec + 2) = 1752392040;
            WORD1(__tp[1].tv_sec) = 1040;
            HIDWORD(__tp[1].tv_sec) = v54;
            LOWORD(__tp[1].tv_nsec) = 2101;
            *(uint64_t *)((char *)&__tp[1].tv_nsec + 2) = (uint64_t)(v36 + 160);
            WORD1(__tp[2].tv_sec) = 1024;
            HIDWORD(__tp[2].tv_sec) = v55;
            LOWORD(__tp[2].tv_nsec) = 1024;
            *(_DWORD *)((char *)&__tp[2].tv_nsec + 2) = v56;
            HIWORD(__tp[2].tv_nsec) = 1024;
            LODWORD(v74) = v57;
            WORD2(v74) = 2082;
            *(_QWORD *)((char *)&v74 + 6) = a1 + 248;
            HIWORD(v74) = 1024;
            LODWORD(v75) = v58;
            WORD2(v75) = 1024;
            *(_DWORD *)((char *)&v75 + 6) = v59;
            v60 = v42;
LABEL_59:
            _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "[R%u] DNSServiceBrowse STOP -- service name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, flags: 0x%X, interface index: %d, client pid: %d (%{public}s), name hash: %x, duration: %{mdns:time_duration}u", (uint8_t *)__tp, 0x4Au);
            v9 = v71;
            v10 = (_BYTE *)&unk_100164000;
            v11 = &unk_100150000;
            v12 = (NSObject **)&unk_100164000;
            v37 = &unk_100150000;
          }
        }
        else if (os_log_type_enabled(*((os_log_t *)v11 + 197), OS_LOG_TYPE_DEFAULT))
        {
          v46 = *(_DWORD *)(a1 + 192);
          v47 = v36 + 160;
          if (v36 == (unsigned int *)-896)
          {
LABEL_46:
            while (v47)
            {
              v48 = *v47;
              if (v48 > 0x3F)
                break;
              if (!*v47)
              {
                v53 = (_WORD)v47 - v39 + 1;
                goto LABEL_58;
              }
              v47 += v48 + 1;
              if (v36 != (unsigned int *)-896)
                goto LABEL_45;
            }
          }
          else
          {
LABEL_45:
            if (v47 < (_BYTE *)v36 + 896)
              goto LABEL_46;
          }
          v53 = 257;
LABEL_58:
          v61 = v53;
          v62 = *(_DWORD *)(a1 + 240);
          v63 = *(_DWORD *)(a1 + 244);
          v64 = *(_DWORD *)(a1 + 180);
          v65 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)v36 + 640);
          __tp[0].tv_sec = 0;
          __tp[0].tv_nsec = 0;
          clock_gettime(_CLOCK_MONOTONIC_RAW, __tp);
          v66 = LODWORD(__tp[0].tv_sec) - *(_DWORD *)(a1 + 196);
          LODWORD(__tp[0].tv_sec) = 67111427;
          HIDWORD(__tp[0].tv_sec) = v46;
          LOWORD(__tp[0].tv_nsec) = 2160;
          *(uint64_t *)((char *)&__tp[0].tv_nsec + 2) = 1752392040;
          WORD1(__tp[1].tv_sec) = 1040;
          HIDWORD(__tp[1].tv_sec) = v61;
          LOWORD(__tp[1].tv_nsec) = 2101;
          *(uint64_t *)((char *)&__tp[1].tv_nsec + 2) = (uint64_t)(v36 + 160);
          WORD1(__tp[2].tv_sec) = 1024;
          HIDWORD(__tp[2].tv_sec) = v62;
          LOWORD(__tp[2].tv_nsec) = 1024;
          *(_DWORD *)((char *)&__tp[2].tv_nsec + 2) = v63;
          HIWORD(__tp[2].tv_nsec) = 1024;
          LODWORD(v74) = v64;
          WORD2(v74) = 2082;
          *(_QWORD *)((char *)&v74 + 6) = a1 + 248;
          HIWORD(v74) = 1024;
          LODWORD(v75) = v65;
          WORD2(v75) = 1024;
          *(_DWORD *)((char *)&v75 + 6) = v66;
          v60 = v41;
          goto LABEL_59;
        }
      }
      else if ((v40 & 1) != 0)
      {
        v41 = mDNSLogCategory_mDNS_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
          goto LABEL_52;
      }
      else if (os_log_type_enabled(*((os_log_t *)v11 + 197), OS_LOG_TYPE_DEFAULT))
      {
LABEL_52:
        v49 = *(_DWORD *)(a1 + 192);
        v50 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)v36 + 640);
        __tp[0].tv_sec = 0;
        __tp[0].tv_nsec = 0;
        clock_gettime(_CLOCK_MONOTONIC_RAW, __tp);
        v51 = LODWORD(__tp[0].tv_sec) - *(_DWORD *)(a1 + 196);
        LODWORD(__tp[0].tv_sec) = 67109632;
        HIDWORD(__tp[0].tv_sec) = v49;
        LOWORD(__tp[0].tv_nsec) = 1024;
        *(_DWORD *)((char *)&__tp[0].tv_nsec + 2) = v50;
        v37 = (_DWORD *)&unk_100150000;
        HIWORD(__tp[0].tv_nsec) = 1024;
        LODWORD(__tp[1].tv_sec) = v51;
        _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "[R%u] DNSServiceBrowse STOP -- name hash: %x, duration: %{mdns:time_duration}u", (uint8_t *)__tp, 0x14u);
      }
      *(_QWORD *)(v9 + 272) = *(_QWORD *)v36;
      mDNS_StopQuery((unsigned int *)mDNSStorage, (uint64_t)(v36 + 66));
      if (v37[389])
        LogMcastQuestion((uint64_t)(v36 + 66), a1, 0);
      free(v36);
      v36 = *(unsigned int **)(v9 + 272);
    }
    while (v36);
  }
  v67 = *(_QWORD *)(a1 + 8);
  if (v67)
  {
    v68 = *(unsigned int *)(a1 + 244);
    if ((_DWORD)v68)
    {
      if (AWDLInterfaceID && AWDLInterfaceID == v68)
      {
        v69 = 1;
      }
      else
      {
        if (WiFiAwareInterfaceID)
          v70 = WiFiAwareInterfaceID == v68;
        else
          v70 = 0;
        v69 = v70;
      }
    }
    else
    {
      v69 = (*(unsigned __int8 *)(a1 + 242) >> 4) & 1;
    }
    _mdns_powerlog_bonjour_event(3, v69, (char *)(a1 + 248), v67);
    *(_QWORD *)(a1 + 8) = 0;
  }
}

void resolve_termination_callback(uint64_t a1)
{
  uint64_t v2;
  int ShouldLogFullRequestInfo;
  __int16 v4;
  char v5;
  NSObject *v6;
  int v7;
  _BYTE *v8;
  uint64_t v9;
  int v10;
  _BYTE *v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  unsigned __int16 v16;
  unsigned __int16 v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  uint64_t v30;
  unsigned __int8 *v31;
  int v32;
  unsigned int v33;
  _BYTE *v34;
  NSObject *v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  _BYTE *v40;
  uint64_t v41;
  _BYTE *v42;
  uint64_t v43;
  int v44;
  _BYTE *v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  _BYTE *v51;
  _BYTE *v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  char v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  BOOL v60;
  uint8_t buf[4];
  uint64_t v62;
  __int16 v63;
  int v64;
  __int16 v65;
  uint64_t v66;
  _BYTE __tp[48];
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;

  v2 = *(_QWORD *)(a1 + 128);
  ShouldLogFullRequestInfo = requestShouldLogFullRequestInfo(a1);
  v4 = v2 + 376;
  v5 = gSensitiveLoggingEnabled;
  v6 = mDNSLogCategory_mDNS;
  if (mDNSLogCategory_mDNS == mDNSLogCategory_State)
    v5 = 0;
  if (ShouldLogFullRequestInfo)
  {
    if ((v5 & 1) != 0)
    {
      v6 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_33;
      v7 = *(_DWORD *)(a1 + 192);
      v8 = (_BYTE *)(v2 + 376);
      if (v2 == -632)
      {
LABEL_8:
        while (v8)
        {
          v9 = *v8;
          if (v9 > 0x3F)
            break;
          if (!*v8)
          {
            v16 = (_WORD)v8 - v4 + 1;
            goto LABEL_29;
          }
          v8 += v9 + 1;
          if (v2 != -632)
            goto LABEL_7;
        }
      }
      else
      {
LABEL_7:
        if ((unint64_t)v8 < v2 + 632)
          goto LABEL_8;
      }
      v16 = 257;
LABEL_29:
      v18 = v16;
      v19 = *(_DWORD *)(a1 + 240);
      v20 = *(_DWORD *)(a1 + 244);
      v21 = *(_DWORD *)(a1 + 180);
      v22 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(v2 + 376));
      *(_QWORD *)__tp = 0;
      *(_QWORD *)&__tp[8] = 0;
      clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
      v23 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 196);
      *(_DWORD *)__tp = 67111427;
      *(_DWORD *)&__tp[4] = v7;
      *(_WORD *)&__tp[8] = 2160;
      *(_QWORD *)&__tp[10] = 1752392040;
      *(_WORD *)&__tp[18] = 1040;
      *(_DWORD *)&__tp[20] = v18;
      *(_WORD *)&__tp[24] = 2101;
      *(_QWORD *)&__tp[26] = v2 + 376;
      *(_WORD *)&__tp[34] = 1024;
      *(_DWORD *)&__tp[36] = v19;
      *(_WORD *)&__tp[40] = 1024;
      *(_DWORD *)&__tp[42] = v20;
      *(_WORD *)&__tp[46] = 1024;
      LODWORD(v68) = v21;
      WORD2(v68) = 2082;
      *(_QWORD *)((char *)&v68 + 6) = a1 + 248;
      HIWORD(v68) = 1024;
      LODWORD(v69) = v22;
      WORD2(v69) = 1024;
      *(_DWORD *)((char *)&v69 + 6) = v23;
    }
    else
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        goto LABEL_33;
      v10 = *(_DWORD *)(a1 + 192);
      v11 = (_BYTE *)(v2 + 376);
      if (v2 == -632)
      {
LABEL_19:
        while (v11)
        {
          v12 = *v11;
          if (v12 > 0x3F)
            break;
          if (!*v11)
          {
            v17 = (_WORD)v11 - v4 + 1;
            goto LABEL_31;
          }
          v11 += v12 + 1;
          if (v2 != -632)
            goto LABEL_18;
        }
      }
      else
      {
LABEL_18:
        if ((unint64_t)v11 < v2 + 632)
          goto LABEL_19;
      }
      v17 = 257;
LABEL_31:
      v24 = v17;
      v26 = *(_DWORD *)(a1 + 240);
      v25 = *(_DWORD *)(a1 + 244);
      v27 = *(_DWORD *)(a1 + 180);
      v28 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(v2 + 376));
      *(_QWORD *)__tp = 0;
      *(_QWORD *)&__tp[8] = 0;
      clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
      v29 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 196);
      *(_DWORD *)__tp = 67111427;
      *(_DWORD *)&__tp[4] = v10;
      *(_WORD *)&__tp[8] = 2160;
      *(_QWORD *)&__tp[10] = 1752392040;
      *(_WORD *)&__tp[18] = 1040;
      *(_DWORD *)&__tp[20] = v24;
      *(_WORD *)&__tp[24] = 2101;
      *(_QWORD *)&__tp[26] = v2 + 376;
      *(_WORD *)&__tp[34] = 1024;
      *(_DWORD *)&__tp[36] = v26;
      *(_WORD *)&__tp[40] = 1024;
      *(_DWORD *)&__tp[42] = v25;
      *(_WORD *)&__tp[46] = 1024;
      LODWORD(v68) = v27;
      WORD2(v68) = 2082;
      *(_QWORD *)((char *)&v68 + 6) = a1 + 248;
      HIWORD(v68) = 1024;
      LODWORD(v69) = v28;
      WORD2(v69) = 1024;
      *(_DWORD *)((char *)&v69 + 6) = v29;
    }
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "[R%u] DNSServiceResolve STOP -- SRV name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, flags: 0x%X, interface index: %d, client pid: %d (%{public}s), name hash: %x, duration: %{mdns:time_duration}u", __tp, 0x4Au);
  }
  else
  {
    if ((v5 & 1) != 0)
    {
      v6 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_33;
    }
    else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
    {
      goto LABEL_33;
    }
    v13 = *(_DWORD *)(a1 + 192);
    v14 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(v2 + 376));
    *(_QWORD *)__tp = 0;
    *(_QWORD *)&__tp[8] = 0;
    clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
    v15 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 196);
    *(_DWORD *)__tp = 67109632;
    *(_DWORD *)&__tp[4] = v13;
    *(_WORD *)&__tp[8] = 1024;
    *(_DWORD *)&__tp[10] = v14;
    *(_WORD *)&__tp[14] = 1024;
    *(_DWORD *)&__tp[16] = v15;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "[R%u] DNSServiceResolve STOP -- name hash: %x, duration: %{mdns:time_duration}u", __tp, 0x14u);
  }
LABEL_33:
  mDNS_StopQuery((unsigned int *)mDNSStorage, v2);
  mDNS_StopQuery((unsigned int *)mDNSStorage, v2 + 696);
  if (mDNS_McastLoggingEnabled)
    LogMcastQuestion(v2 + 696, a1, 0);
  if (*(_BYTE *)(v2 + 1416))
  {
    v30 = *(_QWORD *)(v2 + 832);
    v31 = (unsigned __int8 *)(v2 + 1072);
    v32 = *(_DWORD *)(a1 + 240);
    v33 = *(_DWORD *)(a1 + 180);
    v79 = 0u;
    v80 = 0u;
    v77 = 0u;
    v78 = 0u;
    v75 = 0u;
    v76 = 0u;
    v73 = 0u;
    v74 = 0u;
    v71 = 0u;
    v72 = 0u;
    v69 = 0u;
    v70 = 0u;
    *(_OWORD *)&__tp[32] = 0u;
    v68 = 0u;
    if (*(_BYTE *)(v2 + 1072))
      v34 = (_BYTE *)(v2 + 1072 + *(unsigned __int8 *)(v2 + 1072) + 1);
    else
      v34 = (_BYTE *)(v2 + 1072);
    memset(__tp, 0, 32);
    DomainnameToLower(v34, (uint64_t)__tp);
    v35 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        goto LABEL_62;
      v42 = (_BYTE *)(v2 + 1072);
      if (v2 == -1328)
      {
LABEL_52:
        while (v42)
        {
          v43 = *v42;
          if (v43 > 0x3F)
            break;
          if (!*v42)
          {
            v44 = (unsigned __int16)((_WORD)v42 - (_WORD)v31 + 1);
            goto LABEL_61;
          }
          v42 += v43 + 1;
          if (v2 != -1328)
            goto LABEL_51;
        }
      }
      else
      {
LABEL_51:
        if ((unint64_t)v42 < v2 + 1328)
          goto LABEL_52;
      }
      v44 = 257;
    }
    else
    {
      v35 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_62;
      v40 = (_BYTE *)(v2 + 1072);
      if (v2 == -1328)
      {
LABEL_44:
        while (v40)
        {
          v41 = *v40;
          if (v41 > 0x3F)
            break;
          if (!*v40)
          {
            v44 = (unsigned __int16)((_WORD)v40 - (_WORD)v31 + 1);
            goto LABEL_61;
          }
          v40 += v41 + 1;
          if (v2 != -1328)
            goto LABEL_43;
        }
      }
      else
      {
LABEL_43:
        if ((unint64_t)v40 < v2 + 1328)
          goto LABEL_44;
      }
      v44 = 257;
    }
LABEL_61:
    *(_DWORD *)buf = 141558531;
    v62 = 1752392040;
    v63 = 1040;
    v64 = v44;
    v65 = 2101;
    v66 = v2 + 1072;
    _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "external_stop_resolving_service - fqdn: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", buf, 0x1Cu);
LABEL_62:
    v45 = putDomainNameAsLabels((unint64_t)&compression_base_msg, (unint64_t)&unk_1001499E7, (unint64_t)&compression_base_msg + &unk_1000022F8, __tp, v36, v37, v38, v39);
    if (v45)
    {
      *(_WORD *)v45 = 3072;
      v45[2] = 1;
      v50 = (unint64_t)(v45 + 3);
    }
    else
    {
      v50 = 0;
    }
    *(_DWORD *)buf = 0;
    v51 = putDomainNameAsLabels((unint64_t)&compression_base_msg, v50, (unint64_t)&compression_base_msg + &unk_1000022F8, v31, v46, v47, v48, v49);
    v52 = &v51[-v50];
    PrintHelper((uint64_t)"external_stop_resolving_service", (uint64_t)&unk_1001499E7, (unsigned __int16)(v50 - (unsigned __int16)&unk_1001499E7), v50, (unsigned __int16)((_WORD)v51 - v50));
    v53 = xD2DMapToTransportType(v30, v32, buf);
    if ((_DWORD)v53 == 4)
    {
      v54 = 0;
      v55 = *(_DWORD *)buf;
      do
      {
        if (v55 != (_DWORD)v54)
        {
          if (&_D2DStopResolvingPairOnTransport)
          {
            D2DStopResolvingPairOnTransport(&unk_1001499E7, v50 - (_QWORD)&unk_1001499E7, v50, v52, v54);
            if ((v54 & 0x7FFFFFFE) == 2)
              _mdns_powerlog_awdl_event((uint64_t)CFSTR("stopAWDLResolve"), __tp, 12, v33);
          }
        }
        v54 = (v54 + 1);
      }
      while ((_DWORD)v54 != 4);
    }
    else if (&_D2DStopResolvingPairOnTransport)
    {
      v56 = v53;
      D2DStopResolvingPairOnTransport(&unk_1001499E7, v50 - (_QWORD)&unk_1001499E7, v50, v52, v53);
      if ((v56 & 6) == 2)
        _mdns_powerlog_awdl_event((uint64_t)CFSTR("stopAWDLResolve"), __tp, 12, v33);
    }
  }
  v57 = *(_QWORD *)(a1 + 8);
  if (v57)
  {
    v58 = *(unsigned int *)(a1 + 244);
    if ((_DWORD)v58)
    {
      if (AWDLInterfaceID && AWDLInterfaceID == v58)
      {
        v59 = 1;
      }
      else
      {
        if (WiFiAwareInterfaceID)
          v60 = WiFiAwareInterfaceID == v58;
        else
          v60 = 0;
        v59 = v60;
      }
    }
    else
    {
      v59 = (*(unsigned __int8 *)(a1 + 242) >> 4) & 1;
    }
    _mdns_powerlog_bonjour_event(15, v59, (char *)(a1 + 248), v57);
    *(_QWORD *)(a1 + 8) = 0;
  }
}

void addrinfo_termination_callback(uint64_t a1)
{
  uint64_t v2;
  int ShouldLogFullRequestInfo;
  char v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  int v15;
  uint64_t v16;
  unsigned __int8 *v17;
  uint64_t v18;
  const char *v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  int v23;
  uint64_t v24;
  unsigned __int8 *v25;
  int v26;
  int v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  const char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  int v36;
  const char *v37;
  NSObject *v38;
  uint32_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  BOOL v47;
  int v48;
  _BYTE __tp[20];
  int v50;
  __int16 v51;
  unsigned __int8 *v52;
  __int16 v53;
  int v54;
  __int16 v55;
  int v56;
  __int16 v57;
  int v58;
  __int16 v59;
  uint64_t v60;
  __int16 v61;
  int v62;
  __int16 v63;
  int v64;

  v2 = *(_QWORD *)(a1 + 160);
  ShouldLogFullRequestInfo = requestShouldLogFullRequestInfo(a1);
  v4 = gSensitiveLoggingEnabled;
  v5 = mDNSLogCategory_Default;
  if (mDNSLogCategory_Default == mDNSLogCategory_State)
    v4 = 0;
  if (ShouldLogFullRequestInfo)
  {
    if ((v4 & 1) != 0)
    {
      v5 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_67;
      v13 = *(_QWORD *)(v2 + 16);
      if (v13)
      {
        v14 = (const char *)(v13 + 376);
      }
      else
      {
        v21 = *(_QWORD *)(v2 + 24);
        if (v21)
          v14 = (const char *)(v21 + 376);
        else
          v14 = "";
      }
      v48 = *(_DWORD *)(a1 + 192);
      v22 = v14;
      v23 = 257;
      if (v14 == (const char *)-256)
        goto LABEL_25;
LABEL_22:
      if (v22 < v14 + 256 && v22)
      {
        while (1)
        {
          v24 = *(unsigned __int8 *)v22;
          if (v24 > 0x3F)
          {
LABEL_30:
            v23 = 257;
            goto LABEL_31;
          }
          if (!*v22)
            break;
          v22 += v24 + 1;
          if (v14 != (const char *)-256)
            goto LABEL_22;
LABEL_25:
          if (!v22)
            goto LABEL_30;
        }
        v23 = (unsigned __int16)((_WORD)v22 - (_WORD)v14 + 1);
        if (v13)
          goto LABEL_32;
      }
      else
      {
LABEL_31:
        if (v13)
        {
LABEL_32:
          v25 = (unsigned __int8 *)(v13 + 376);
          v26 = *(_DWORD *)(a1 + 240);
          v27 = *(_DWORD *)(a1 + 244);
          v28 = a1 + 248;
          v29 = *(_DWORD *)(a1 + 180);
LABEL_58:
          v35 = mDNS_DomainNameFNV1aHash(v25);
          *(_QWORD *)__tp = 0;
          *(_QWORD *)&__tp[8] = 0;
          clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
          v36 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 196);
          *(_DWORD *)__tp = 67111427;
          *(_DWORD *)&__tp[4] = v48;
          *(_WORD *)&__tp[8] = 2160;
          *(_QWORD *)&__tp[10] = 1752392040;
          *(_WORD *)&__tp[18] = 1040;
          v50 = v23;
          v51 = 2101;
          v52 = v25;
          v53 = 1024;
          v54 = v26;
          v55 = 1024;
          v56 = v27;
          v57 = 1024;
          v58 = v29;
          v59 = 2082;
          v60 = v28;
          v61 = 1024;
          v62 = v35;
          v63 = 1024;
          v64 = v36;
          v37 = "[R%u] DNSServiceGetAddrInfo STOP -- hostname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, fla"
                "gs: 0x%X, interface index: %d, client pid: %d (%{public}s), name hash: %x, duration: %{mdns:time_duration}u";
          v38 = v5;
          v39 = 74;
          goto LABEL_66;
        }
      }
      v33 = *(_QWORD *)(v2 + 24);
      if (v33)
        v25 = (unsigned __int8 *)(v33 + 376);
      else
        v25 = "";
      v26 = *(_DWORD *)(a1 + 240);
      v27 = *(_DWORD *)(a1 + 244);
      v29 = *(_DWORD *)(a1 + 180);
      v28 = a1 + 248;
      goto LABEL_58;
    }
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      goto LABEL_67;
    v18 = *(_QWORD *)(v2 + 16);
    if (v18)
    {
      v19 = (const char *)(v18 + 376);
    }
    else
    {
      v30 = *(_QWORD *)(v2 + 24);
      if (v30)
        v19 = (const char *)(v30 + 376);
      else
        v19 = "";
    }
    v48 = *(_DWORD *)(a1 + 192);
    v31 = v19;
    v23 = 257;
    if (v19 == (const char *)-256)
      goto LABEL_40;
LABEL_37:
    if (v31 < v19 + 256 && v31)
    {
      while (1)
      {
        v32 = *(unsigned __int8 *)v31;
        if (v32 > 0x3F)
        {
LABEL_45:
          v23 = 257;
          goto LABEL_46;
        }
        if (!*v31)
          break;
        v31 += v32 + 1;
        if (v19 != (const char *)-256)
          goto LABEL_37;
LABEL_40:
        if (!v31)
          goto LABEL_45;
      }
      v23 = (unsigned __int16)((_WORD)v31 - (_WORD)v19 + 1);
      if (v18)
        goto LABEL_47;
    }
    else
    {
LABEL_46:
      if (v18)
      {
LABEL_47:
        v25 = (unsigned __int8 *)(v18 + 376);
        v26 = *(_DWORD *)(a1 + 240);
        v27 = *(_DWORD *)(a1 + 244);
        v28 = a1 + 248;
        v29 = *(_DWORD *)(a1 + 180);
        goto LABEL_58;
      }
    }
    v34 = *(_QWORD *)(v2 + 24);
    if (v34)
      v25 = (unsigned __int8 *)(v34 + 376);
    else
      v25 = "";
    v26 = *(_DWORD *)(a1 + 240);
    v27 = *(_DWORD *)(a1 + 244);
    v29 = *(_DWORD *)(a1 + 180);
    v28 = a1 + 248;
    goto LABEL_58;
  }
  if ((v4 & 1) != 0)
  {
    v5 = mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      goto LABEL_67;
    v15 = *(_DWORD *)(a1 + 192);
    v16 = *(_QWORD *)(v2 + 16);
    if (v16)
    {
      v17 = (unsigned __int8 *)(v16 + 376);
    }
    else
    {
      v40 = *(_QWORD *)(v2 + 24);
      if (v40)
        v17 = (unsigned __int8 *)(v40 + 376);
      else
        v17 = "";
    }
  }
  else
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      goto LABEL_67;
    v15 = *(_DWORD *)(a1 + 192);
    v20 = *(_QWORD *)(v2 + 16);
    if (v20)
    {
      v17 = (unsigned __int8 *)(v20 + 376);
    }
    else
    {
      v41 = *(_QWORD *)(v2 + 24);
      if (v41)
        v17 = (unsigned __int8 *)(v41 + 376);
      else
        v17 = "";
    }
  }
  v42 = mDNS_DomainNameFNV1aHash(v17);
  *(_QWORD *)__tp = 0;
  *(_QWORD *)&__tp[8] = 0;
  clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
  v43 = *(_DWORD *)__tp - *(_DWORD *)(a1 + 196);
  *(_DWORD *)__tp = 67109632;
  *(_DWORD *)&__tp[4] = v15;
  *(_WORD *)&__tp[8] = 1024;
  *(_DWORD *)&__tp[10] = v42;
  *(_WORD *)&__tp[14] = 1024;
  *(_DWORD *)&__tp[16] = v43;
  v37 = "[R%u] DNSServiceGetAddrInfo STOP -- name hash: %x, duration: %{mdns:time_duration}u";
  v38 = v5;
  v39 = 20;
LABEL_66:
  _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, v37, __tp, v39);
LABEL_67:
  GetAddrInfoClientRequestStop(v2, v6, v7, v8, v9, v10, v11, v12);
  v44 = *(_QWORD *)(a1 + 8);
  if (v44)
  {
    v45 = *(unsigned int *)(a1 + 244);
    if ((_DWORD)v45)
    {
      if (AWDLInterfaceID && AWDLInterfaceID == v45)
      {
        v46 = 1;
      }
      else
      {
        if (WiFiAwareInterfaceID)
          v47 = WiFiAwareInterfaceID == v45;
        else
          v47 = 0;
        v46 = v47;
      }
    }
    else
    {
      v46 = (*(unsigned __int8 *)(a1 + 242) >> 4) & 1;
    }
    _mdns_powerlog_bonjour_event(6, v46, (char *)(a1 + 248), v44);
    *(_QWORD *)(a1 + 8) = 0;
  }
}

uint64_t requestShouldLogFullRequestInfo(uint64_t a1)
{
  int v2;
  int tv_sec;
  timespec v5;

  v2 = *(_DWORD *)(a1 + 196);
  v5.tv_sec = 0;
  v5.tv_nsec = 0;
  clock_gettime(_CLOCK_MONOTONIC_RAW, &v5);
  tv_sec = v5.tv_sec;
  if (v2)
  {
    if (LODWORD(v5.tv_sec) - v2 < 300)
      return 0;
  }
  else
  {
    v5.tv_sec = 0;
    v5.tv_nsec = 0;
    clock_gettime(_CLOCK_MONOTONIC_RAW, &v5);
    *(_DWORD *)(a1 + 196) = v5.tv_sec;
  }
  *(_DWORD *)(a1 + 200) = tv_sec;
  return 1;
}

uint64_t LogMcastQuestion(uint64_t result, uint64_t a2, int a3)
{
  int v3;
  _BOOL8 v4;
  uint64_t v5;
  NSObject *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __int128 *v14;

  if (!*(_WORD *)(result + 340))
  {
    if (a3 == 1)
      v3 = 1;
    else
      v3 = -1;
    if (mcount)
      v4 = 0;
    else
      v4 = a3 == 1;
    mcount += v3;
    if (mDNS_McastLoggingEnabled)
    {
      v5 = result;
      v6 = mDNSLogCategory_Default;
      if (a3)
        v7 = "+Question";
      else
        v7 = "-Question";
      DNSTypeName(*(unsigned __int16 *)(result + 342));
      v13 = *(_QWORD *)(v5 + 136);
      if ((unint64_t)(v13 + 5) >= 6 || ((0x2Du >> (v13 + 5)) & 1) == 0)
      {
        v14 = &xmmword_10015BF38;
        do
          v14 = *(__int128 **)v14;
        while (v14 && *((_QWORD *)v14 + 444) != v13);
      }
      LogMsgWithLevel(v6, OS_LOG_TYPE_DEFAULT, "%s: %##s  (%s) (%s)  Client(%d)[%s]", v8, v9, v10, v11, v12, (int)v7);
    }
    return LogMcastStateInfo(v4, 0, 0);
  }
  return result;
}

void external_stop_advertising_helper(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  unint64_t v12;
  uint64_t v13;
  _QWORD *i;
  int v15;

  if (*(_BYTE *)(a1 + 27))
  {
    v9 = *(_QWORD *)(a1 + 16);
    if (mDNS_LoggingEnabled == 1)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "external_stop_advertising_helper: calling external_stop_advertising_service", a4, a5, a6, a7, a8, v15);
    v10 = *(_QWORD *)(a1 + 8);
    if (v10)
    {
      v11 = *(_DWORD *)(v10 + 180);
      if (*(_DWORD *)(*(_QWORD *)(v10 + 120) + 1616))
      {
        v12 = 0;
        v13 = v9 + 8;
        do
        {
          internal_stop_advertising_service(v13, *(_DWORD *)(v10 + 240), v11);
          ++v12;
          v10 = *(_QWORD *)(a1 + 8);
          v13 += 1176;
        }
        while (v12 < *(unsigned int *)(*(_QWORD *)(v10 + 120) + 1616));
      }
      internal_stop_advertising_service(a1 + 1528, *(_DWORD *)(v10 + 240), v11);
      internal_stop_advertising_service(a1 + 2704, *(_DWORD *)(*(_QWORD *)(a1 + 8) + 240), v11);
      internal_stop_advertising_service(a1 + 3880, *(_DWORD *)(*(_QWORD *)(a1 + 8) + 240), v11);
      for (i = *(_QWORD **)(a1 + 312); i; i = (_QWORD *)*i)
        internal_stop_advertising_service((uint64_t)(i + 3), *(_DWORD *)(*(_QWORD *)(a1 + 8) + 240), v11);
    }
    *(_BYTE *)(a1 + 27) = 0;
  }
}

void LogMcastService(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  int v11;
  _BOOL4 v12;
  NSObject *v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __int128 *v21;

  if (*(_QWORD *)(a1 + 32) || *(_BYTE *)(a1 + 122) || IsLocalDomain(*(_BYTE **)(a1 + 40)))
  {
    if (a3 == 1)
      v11 = 1;
    else
      v11 = -1;
    if (mcount)
      v12 = 0;
    else
      v12 = a3 == 1;
    mcount += v11;
    if (mDNS_McastLoggingEnabled)
    {
      v13 = mDNSLogCategory_Default;
      if (a3)
        v14 = "+Service";
      else
        v14 = "-Service";
      DNSTypeName(*(unsigned __int16 *)(a1 + 12));
      v20 = *(_QWORD *)(a1 + 32);
      if ((unint64_t)(v20 + 5) >= 6 || ((0x2Du >> (v20 + 5)) & 1) == 0)
      {
        v21 = &xmmword_10015BF38;
        do
          v21 = *(__int128 **)v21;
        while (v21 && *((_QWORD *)v21 + 444) != v20);
      }
      LogMsgWithLevel(v13, OS_LOG_TYPE_DEFAULT, "%s: %##s  (%s)  (%s)  Client(%d)[%s]", v15, v16, v17, v18, v19, (int)v14);
    }
    LogMcastStateInfo(v12, 0, 0, a4, a5, a6, a7, a8, a9);
  }
}

void unlink_and_free_service_instance(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;
  char *v19;
  void *v21;

  v9 = (_QWORD *)a1[39];
  external_stop_advertising_helper((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
  v15 = a1[1];
  if (v15)
  {
    v16 = (_QWORD *)(*(_QWORD *)(v15 + 120) + 1624);
    while (1)
    {
      v17 = v16;
      v16 = (_QWORD *)*v16;
      if (!v16)
        break;
      if (v16 == a1)
      {
        *v17 = *a1;
        break;
      }
    }
  }
  while (v9)
  {
    v18 = (uint64_t)(v9 + 2);
    v9[16] = v9;
    v9 = (_QWORD *)*v9;
    FreeExtraRR((uint64_t)mDNSStorage, v18, -65792, v10, v11, v12, v13, v14);
  }
  v19 = (char *)a1[490];
  if (v19 != (char *)a1 + 4780 && v19 != 0)
  {
    free(v19);
    a1[490] = 0;
  }
  v21 = (void *)a1[2];
  if (v21)
    free(v21);
  free(a1);
}

void FreeExtraRR(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v9;
  NSObject *v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;

  if (a3 == -65792)
  {
    v9 = *(void **)(a2 + 112);
    if (mDNS_LoggingEnabled == 1)
    {
      v10 = mDNSLogCategory_Default;
      v11 = a1 + 47032;
      GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), (_BYTE *)(a1 + 47032));
      LogMsgWithLevel(v10, OS_LOG_TYPE_DEFAULT, "     FreeExtraRR %s", v12, v13, v14, v15, v16, v11);
    }
    v17 = *(void **)(a2 + 48);
    if (v17 != (void *)(a2 + 908) && v17 != 0)
    {
      free(v17);
      *(_QWORD *)(a2 + 48) = 0;
    }
    if (v9)
      free(v9);
  }
  else
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Error: FreeExtraRR invoked with unexpected error %d", a4, a5, a6, a7, a8, a3);
  }
}

void request_state_forget(_QWORD **a1)
{
  _QWORD *v1;
  void *v3;
  void *v4;
  _QWORD *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  const __CFArray *v13;
  const void *v14;
  void *v15;

  v1 = *a1;
  if (*a1)
  {
    v3 = (void *)v1[14];
    if (v3)
    {
      free(v3);
      v1[14] = 0;
    }
    v4 = (void *)v1[15];
    if (v4)
    {
      free(v4);
      v1[15] = 0;
    }
    v5 = (_QWORD *)v1[16];
    if (v5)
    {
      v6 = (void *)v5[174];
      if (v6)
      {
        free(v6);
        v5[174] = 0;
      }
      v7 = (void *)v5[175];
      if (v7)
        free(v7);
      free(v5);
      v1[16] = 0;
    }
    v8 = (void *)v1[17];
    if (v8)
    {
      free(v8);
      v1[17] = 0;
    }
    v9 = (void *)v1[18];
    if (v9)
    {
      free(v9);
      v1[18] = 0;
    }
    v10 = (void *)v1[19];
    if (v10)
    {
      free(v10);
      v1[19] = 0;
    }
    v11 = (void *)v1[20];
    if (v11)
    {
      free(v11);
      v1[20] = 0;
    }
    v12 = (void *)v1[4];
    if (v12)
    {
      os_release(v12);
      v1[4] = 0;
    }
    v13 = (const __CFArray *)v1[6];
    if (v13)
    {
      mdns_cfarray_enumerate(v13, (uint64_t)&__block_literal_global_386);
      v14 = (const void *)v1[6];
      if (v14)
      {
        CFRelease(v14);
        v1[6] = 0;
      }
    }
    v15 = (void *)v1[7];
    if (v15)
      os_release(v15);
    free(v1);
    *a1 = 0;
  }
}

BOOL __request_state_forget_block_invoke(id a1, mdns_trust_s *a2)
{
  mdns_trust_invalidate((uint64_t)a2);
  return 1;
}

uint64_t CountExistingRegistrations(_BYTE *a1, unsigned __int16 a2)
{
  uint64_t *v2;
  uint64_t v4;
  int v5;

  v2 = (uint64_t *)xmmword_10015BF10;
  if (!(_QWORD)xmmword_10015BF10)
    return 0;
  v4 = 0;
  v5 = a2;
  do
  {
    if (*((_WORD *)v2 + 6) == 33 && *(unsigned __int16 *)(v2[6] + 8) == v5)
      v4 = v4 + SameDomainNameBytes((_BYTE *)v2[5], a1);
    v2 = (uint64_t *)*v2;
  }
  while (v2);
  return v4;
}

uint64_t DeregisterLocalOnlyDomainEnumPTR_Internal(unsigned int *a1, _BYTE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  unsigned __int8 *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  char v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  _BYTE v37[31];

  v8 = a4;
  memset(v37, 0, sizeof(v37));
  v36 = 0u;
  v35 = 0u;
  v34 = 0u;
  v33 = 0u;
  v32 = 0u;
  v31 = 0u;
  v30 = 0u;
  v29 = 0u;
  v28 = 0u;
  v27 = 0u;
  v26 = 0u;
  v25 = 0u;
  v24 = 0u;
  v23 = 0u;
  v11 = (unsigned __int8 *)mDNS_DomainTypeNames[(int)a3];
  v22 = 0;
  AppendDNSNameString(&v22, v11, a3, a4, a5, a6, a7, a8);
  result = (uint64_t)AppendDNSNameString(&v22, "local", v12, v13, v14, v15, v16, v17);
  v19 = LocalDomainEnumRecords;
  if (LocalDomainEnumRecords)
  {
    v20 = &LocalDomainEnumRecords;
    while (1)
    {
      result = SameDomainNameBytes((_BYTE *)(*(_QWORD *)(v19 + 56) + 4), a2);
      if ((_DWORD)result)
      {
        result = SameDomainNameBytes(*(_BYTE **)(*v20 + 48), &v22);
        if ((_DWORD)result)
          break;
      }
      v20 = (uint64_t *)*v20;
      v19 = *v20;
      if (!*v20)
        return result;
    }
    v21 = *v20 + 8;
    *v20 = *(_QWORD *)*v20;
    if (v8)
      return mDNS_Deregister_internal((uint64_t)a1, v21, 0);
    else
      return mDNS_Deregister(a1, v21);
  }
  return result;
}

void SendServiceRemovalNotification(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;

  v7 = 0;
  v1 = *(_QWORD *)(a1 + 8);
  if (GenerateNTDResponse(*(char **)(a1 + 2448), *(_QWORD *)(a1 + 2440), *(_QWORD *)(v1 + 8), (char **)&v7, (char *)0x41, 0, 0))
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: SendServiceRemovalNotification: %##s is not valid DNS-SD SRV name", v2, v3, v4, v5, v6, *(_DWORD *)(*(_QWORD *)(v1 + 8) + 176));
  }
  else
  {
    append_reply(*(_QWORD *)(v1 + 8), v7);
    *(_BYTE *)(v1 + 25) = 0;
  }
}

uint64_t get_service_attr_tsr_params(uint64_t a1, int *a2, _DWORD *a3)
{
  unsigned __int8 *v3;
  uint64_t result;
  uint64_t v8;
  int tlv_uint32;
  int v10;
  int v11;
  NSObject *v12;
  int v13;
  int v14;
  uint8_t buf[4];
  int v16;
  __int16 v17;
  int v18;

  v3 = *(unsigned __int8 **)(a1 + 80);
  if (!v3)
    return 0;
  result = 0;
  if (a3)
  {
    if (a2)
    {
      if ((*(_DWORD *)(a1 + 216) & 2) != 0)
      {
        v14 = 0;
        v8 = *(_QWORD *)(a1 + 88);
        tlv_uint32 = get_tlv_uint32(v3, v8, 5, &v14);
        result = 0;
        *a2 = tlv_uint32;
        if (!v14)
        {
          v10 = get_tlv_uint32(v3, v8, 11, &v14);
          *a3 = v10;
          if (v14)
            return 0;
          v11 = v10;
          v12 = mDNSLogCategory_Default;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
            {
LABEL_14:
              v13 = *a2;
              *(_DWORD *)buf = 67109376;
              v16 = v13;
              v17 = 1024;
              v18 = v11;
              _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "get_service_attr_tsr_params timestamp %u hostkeyHash %u", buf, 0xEu);
            }
          }
          else
          {
            v12 = mDNSLogCategory_Default_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
              goto LABEL_14;
          }
          return 1;
        }
      }
    }
  }
  return result;
}

uint64_t conflictWithCacheRecordsOrFlush(unsigned int a1, _BYTE *a2, int a3, int a4)
{
  uint64_t result;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v13;
  uint8_t buf[4];
  int v15;
  _BYTE v16[10];
  __int16 v17;
  __int16 *v18;

  result = (uint64_t)CacheGroupForName((uint64_t)mDNSStorage, a1, a2);
  if (result)
  {
    v7 = result;
    v8 = mDNSGetTSRForCacheGroup(result);
    if (v8)
    {
      v15 = a4;
      *(_DWORD *)v16 = 0;
      *(_DWORD *)buf = a3;
      if (CheckTSRForResourceRecord((int *)buf, (uint64_t)(v8 + 1)) == 2)
        return 1;
    }
    v9 = *(_QWORD *)(v7 + 16);
    if (v9)
    {
      while (1)
      {
        mDNS_PurgeCacheResourceRecord((unsigned int *)mDNSStorage, v9);
        v10 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_mDNS != mDNSLogCategory_State)
          break;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG))
          goto LABEL_14;
LABEL_15:
        v9 = *(_QWORD *)v9;
        if (!v9)
          return 0;
      }
      v10 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG))
        goto LABEL_15;
LABEL_14:
      v13 = *(_QWORD *)(v9 + 32);
      GetRRDisplayString_rdb((unsigned __int8 *)(v9 + 8), (unsigned __int16 *)(*(_QWORD *)(v9 + 48) + 4), word_100164580);
      *(_DWORD *)buf = 67109635;
      v15 = v13;
      strcpy(v16, "p\bhash");
      v16[7] = 0;
      *(_WORD *)&v16[8] = 0;
      v17 = 2085;
      v18 = word_100164580;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "conflictWithCacheRecordsOrFlush - new TSR, flushing interface %d %{sensitive, mask.hash}s", buf, 0x1Cu);
      goto LABEL_15;
    }
    return 0;
  }
  return result;
}

uint64_t updateTSRRecord(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t v8;
  NSObject *v9;
  uint64_t v11;
  _BYTE *v12;
  uint64_t v13;
  _BYTE *v15;
  uint64_t v16;
  int v17;
  int v18;
  int v20;
  uint64_t v21;
  __int16 v22;
  int v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  int v27;
  __int16 v28;
  int v29;

  v8 = *(_QWORD *)(a2 + 48);
  v9 = mDNSLogCategory_mDNS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      goto LABEL_31;
    v11 = *(_QWORD *)(a2 + 40);
    if (v11)
    {
      v12 = *(_BYTE **)(a2 + 40);
      if (v11 == -256)
      {
LABEL_10:
        while (v12)
        {
          v13 = *v12;
          if (v13 > 0x3F)
            break;
          if (!*v12)
          {
            v17 = (unsigned __int16)((_WORD)v12 - v11 + 1);
            goto LABEL_30;
          }
          v12 += v13 + 1;
          if (v11 != -256)
            goto LABEL_9;
        }
      }
      else
      {
LABEL_9:
        if ((unint64_t)v12 < v11 + 256)
          goto LABEL_10;
      }
      v17 = 257;
    }
    else
    {
      v17 = 0;
    }
  }
  else
  {
    v9 = mDNSLogCategory_mDNS_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
      goto LABEL_31;
    v11 = *(_QWORD *)(a2 + 40);
    if (v11)
    {
      v15 = *(_BYTE **)(a2 + 40);
      if (v11 == -256)
      {
LABEL_19:
        while (v15)
        {
          v16 = *v15;
          if (v16 > 0x3F)
            break;
          if (!*v15)
          {
            v17 = (unsigned __int16)((_WORD)v15 - v11 + 1);
            goto LABEL_30;
          }
          v15 += v16 + 1;
          if (v11 != -256)
            goto LABEL_18;
        }
      }
      else
      {
LABEL_18:
        if ((unint64_t)v15 < v11 + 256)
          goto LABEL_19;
      }
      v17 = 257;
    }
    else
    {
      v17 = 0;
    }
  }
LABEL_30:
  v18 = *(_DWORD *)(v8 + 4);
  v20 = 141559043;
  v21 = 1752392040;
  v22 = 1040;
  v23 = v17;
  v24 = 2101;
  v25 = v11;
  v26 = 1024;
  v27 = a3;
  v28 = 1024;
  v29 = v18;
  _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "TSR timestamp - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, new: %d  old: %d", (uint8_t *)&v20, 0x28u);
LABEL_31:
  if (a3 - *(_DWORD *)(v8 + 8) < 1)
    return 0;
  v20 = 167832317;
  LOBYTE(v21) = HIBYTE(a3);
  BYTE1(v21) = BYTE2(a3);
  BYTE2(v21) = BYTE1(a3);
  BYTE3(v21) = a3;
  BYTE4(v21) = HIBYTE(a4);
  BYTE5(v21) = BYTE2(a4);
  BYTE6(v21) = BYTE1(a4);
  HIBYTE(v21) = a4;
  v22 = 0;
  return update_record(a2, 14, (unsigned __int8 *)&v20, 4500, 0, *(_DWORD *)(a1 + 192));
}

uint64_t add_record_to_service(uint64_t a1, uint64_t a2, int a3, uint64_t a4, unsigned __int8 *a5, unsigned int a6)
{
  uint64_t v12;
  _WORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  size_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  size_t v32;
  NSObject *v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  _BYTE *v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  _BYTE *v46;
  uint64_t v47;
  int v49[2];
  __int16 v50;
  uint64_t v51;
  __int16 v52;
  int v53;
  __int16 v54;
  uint64_t v55;
  __int16 v56;
  const char *v57;

  if (a4 <= 0x214)
    v12 = 532;
  else
    v12 = a4;
  v13 = malloc_type_calloc(1uLL, v12 + 928, 0xF1748037uLL);
  if (!v13)
    __break(1u);
  v17 = (uint64_t)v13;
  v18 = (uint64_t)(v13 + 12);
  v13[14] = a3;
  v19 = (uint64_t)(v13 + 462);
  *((_QWORD *)v13 + 8) = v13 + 462;
  v13[462] = v12;
  v13[18] = a4;
  v20 = *(uint64_t **)(a1 + 120);
  if (!SetRData(0, a5, (unint64_t)&a5[a4], (uint64_t)(v13 + 12), a4, v14, v15, v16))
  {
    v33 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
      {
        v34 = *(_DWORD *)(a1 + 192);
        v45 = v20[203];
        if (v45)
        {
          v36 = *(_QWORD *)(v45 + 2736);
          if (v36)
          {
            v46 = *(_BYTE **)(v45 + 2736);
            v38 = 257;
            if (v36 == -256)
              goto LABEL_37;
LABEL_34:
            if ((unint64_t)v46 < v36 + 256 && v46)
            {
              while (1)
              {
                v47 = *v46;
                if (v47 > 0x3F)
                {
LABEL_47:
                  v38 = 257;
                  goto LABEL_51;
                }
                if (!*v46)
                  break;
                v46 += v47 + 1;
                if (v36 != -256)
                  goto LABEL_34;
LABEL_37:
                if (!v46)
                  goto LABEL_47;
              }
              v38 = (unsigned __int16)((_WORD)v46 - v36 + 1);
            }
          }
          else
          {
            v38 = 0;
          }
        }
        else
        {
          v38 = 0;
          v36 = 0;
        }
        goto LABEL_51;
      }
    }
    else
    {
      v33 = mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
      {
        v34 = *(_DWORD *)(a1 + 192);
        v35 = v20[203];
        if (v35)
        {
          v36 = *(_QWORD *)(v35 + 2736);
          if (v36)
          {
            v37 = *(_BYTE **)(v35 + 2736);
            v38 = 257;
            if (v36 == -256)
              goto LABEL_17;
LABEL_14:
            if ((unint64_t)v37 < v36 + 256 && v37)
            {
              while (1)
              {
                v39 = *v37;
                if (v39 > 0x3F)
                {
LABEL_46:
                  v38 = 257;
                  goto LABEL_51;
                }
                if (!*v37)
                  break;
                v37 += v39 + 1;
                if (v36 != -256)
                  goto LABEL_14;
LABEL_17:
                if (!v37)
                  goto LABEL_46;
              }
              v38 = (unsigned __int16)((_WORD)v37 - v36 + 1);
            }
          }
          else
          {
            v38 = 0;
          }
        }
        else
        {
          v38 = 0;
          v36 = 0;
        }
LABEL_51:
        v49[0] = 67110147;
        v49[1] = v34;
        v50 = 2160;
        v51 = 1752392040;
        v52 = 1040;
        v53 = v38;
        v54 = 2101;
        v55 = v36;
        v56 = 2082;
        v57 = DNSTypeName(a3);
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "[R%u] read_rr_from_ipc_msg: SetRData failed for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)", (uint8_t *)v49, 0x2Cu);
      }
    }
    free((void *)v17);
    return 4294901756;
  }
  SetNewRData(v18, 0, 0, v21, v22, v23, v24, v25);
  *(_QWORD *)(v17 + 48) = *v20;
  v26 = mDNS_AddRecordToService((uint64_t)mDNSStorage, a2 + 288, v17, v19, a6, *(_DWORD *)(a1 + 240));
  if ((_DWORD)v26)
  {
    v32 = v26;
    free((void *)v17);
  }
  else
  {
    if (mDNS_McastLoggingEnabled)
      LogMcastService(a2 + 1520, a1, 1, v27, v28, v29, v30, v31, v49[0]);
    *(_DWORD *)(v17 + 8) = *(_DWORD *)(a1 + 232);
    if (*(_BYTE *)(a2 + 27)
      && callExternalHelpers(*v20, (_BYTE *)(a2 + 28), *(unsigned int *)(a1 + 240), v27, v28, v29, v30, v31))
    {
      if (mDNS_LoggingEnabled == 1)
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "add_record_to_service: calling external_start_advertising_service", v40, v41, v42, v43, v44, v49[0]);
      internal_start_advertising_service(v18, *(_DWORD *)(a1 + 240), *(_DWORD *)(a1 + 180));
    }
    return 0;
  }
  return v32;
}

uint64_t update_record(uint64_t a1, uint64_t a2, unsigned __int8 *a3, int a4, uint64_t a5, int a6)
{
  uint64_t v12;
  unsigned __int16 *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned __int16 *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int RDLength;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  void (*v33)(uint64_t *, uint64_t);
  unsigned int v34;
  uint64_t v35;
  uint64_t updated;
  NSObject *v37;
  uint64_t v38;
  _BYTE *v39;
  uint64_t v40;
  NSObject *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  NSObject *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  _BYTE *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unsigned int v60;
  int v61;
  unsigned int v62;
  unsigned int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  unsigned int v69;
  int v70;
  const char *v71;
  _OWORD v73[2];
  __int128 v74;
  __int128 v75;
  uint8_t buf[4];
  int v77;
  __int16 v78;
  uint64_t v79;
  __int16 v80;
  int v81;
  __int16 v82;
  uint64_t v83;
  __int16 v84;
  const char *v85;

  if (a2 <= 0x214)
    v12 = 532;
  else
    v12 = a2;
  v13 = (unsigned __int16 *)malloc_type_calloc(1uLL, v12 + 4, 0xF1748037uLL);
  if (!v13)
    __break(1u);
  v17 = v13;
  v74 = 0u;
  v75 = 0u;
  memset(v73, 0, sizeof(v73));
  v18 = *(_QWORD *)(a1 + 40);
  DWORD1(v73[0]) = *(_DWORD *)(a1 + 12);
  *(_QWORD *)&v74 = v18;
  *((_QWORD *)&v74 + 1) = v13;
  *v13 = v12;
  WORD6(v73[0]) = a2;
  if (!SetRData(0, a3, (unint64_t)&a3[a2], (uint64_t)v73, a2, v14, v15, v16))
  {
    updated = 4294901756;
    v37 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
        goto LABEL_85;
      v38 = v74;
      if ((_QWORD)v74)
      {
        v53 = (_BYTE *)v74;
        if ((_QWORD)v74 == -256)
        {
LABEL_41:
          while (v53)
          {
            v54 = *v53;
            if (v54 > 0x3F)
              break;
            if (!*v53)
            {
              v65 = (unsigned __int16)((_WORD)v53 - v74 + 1);
              goto LABEL_84;
            }
            v53 += v54 + 1;
            if ((_QWORD)v74 != -256)
              goto LABEL_40;
          }
        }
        else
        {
LABEL_40:
          if ((unint64_t)v53 < (uint64_t)v74 + 256)
            goto LABEL_41;
        }
        v65 = 257;
      }
      else
      {
        v65 = 0;
      }
    }
    else
    {
      v37 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
      {
LABEL_85:
        free(v17);
        return updated;
      }
      v38 = v74;
      if ((_QWORD)v74)
      {
        v39 = (_BYTE *)v74;
        if ((_QWORD)v74 == -256)
        {
LABEL_30:
          while (v39)
          {
            v40 = *v39;
            if (v40 > 0x3F)
              break;
            if (!*v39)
            {
              v65 = (unsigned __int16)((_WORD)v39 - v74 + 1);
              goto LABEL_84;
            }
            v39 += v40 + 1;
            if ((_QWORD)v74 != -256)
              goto LABEL_29;
          }
        }
        else
        {
LABEL_29:
          if ((unint64_t)v39 < (uint64_t)v74 + 256)
            goto LABEL_30;
        }
        v65 = 257;
      }
      else
      {
        v65 = 0;
      }
    }
LABEL_84:
    v71 = DNSTypeName(WORD2(v73[0]));
    *(_DWORD *)buf = 67110147;
    v77 = a6;
    v78 = 2160;
    v79 = 1752392040;
    v80 = 1040;
    v81 = v65;
    v82 = 2101;
    v83 = v38;
    v84 = 2082;
    v85 = v71;
    _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, "[R%u] update_record: SetRData failed for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%{public}s)", buf, 0x2Cu);
    goto LABEL_85;
  }
  RDLength = GetRDLength((uint64_t)v73, 0, v19, v20, v21, v22, v23, v24);
  v26 = RDLength;
  if (*(_WORD *)(a1 + 12) == 16 && !RDLength)
  {
    *((_BYTE *)v17 + 4) = 0;
    v26 = 1;
  }
  if (a5)
    *(_QWORD *)(a1 + 608) = a5;
  if (!ValidateRData(*(unsigned __int16 *)(a1 + 12), v26, v17))
  {
    v41 = mDNSLogCategory_Default;
    GetRRDisplayString_rdb((unsigned __int8 *)(a1 + 8), v17 + 2, word_100164580);
    LogMsgWithLevel(v41, OS_LOG_TYPE_DEFAULT, "Attempt to update record with invalid rdata: %s", v42, v43, v44, v45, v46, (int)word_100164580);
    updated = 4294901747;
LABEL_36:
    v47 = mDNSLogCategory_Default;
    GetRRDisplayString_rdb((unsigned __int8 *)(a1 + 8), (unsigned __int16 *)(*(_QWORD *)(a1 + 48) + 4), word_100164580);
    LogMsgWithLevel(v47, OS_LOG_TYPE_DEFAULT, "update_record: Error %d for %s", v48, v49, v50, v51, v52, updated);
    goto LABEL_85;
  }
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNS_Update", 16304);
  if (!a4)
    a4 = *(_DWORD *)(a1 + 16);
  v32 = *(_QWORD *)(a1 + 304);
  if (v32)
  {
    *(_QWORD *)(a1 + 304) = 0;
    v33 = *(void (**)(uint64_t *, uint64_t))(a1 + 320);
    if (v33)
      v33(mDNSStorage, a1);
  }
  *(_QWORD *)(a1 + 304) = v17;
  *(_WORD *)(a1 + 312) = v26;
  *(_QWORD *)(a1 + 320) = update_callback;
  v34 = *(_DWORD *)(a1 + 172) & 0xFFFFFFFE;
  if (v34 == 4)
    goto LABEL_23;
  if (!*(_QWORD *)(a1 + 32) && !*(_BYTE *)(a1 + 122))
  {
    if (IsLocalDomain(*(_BYTE **)(a1 + 40)))
    {
      v34 = *(_DWORD *)(a1 + 172) & 0xFFFFFFFE;
      goto LABEL_22;
    }
    updated = uDNS_UpdateRecord(a1, v35, v32, v27, v28, v29, v30, v31);
    if (!(_DWORD)updated)
    {
      mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_Update", 16328);
      return updated;
    }
    *(_QWORD *)(a1 + 304) = 0;
    *(_WORD *)(a1 + 312) = 0;
    mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_Update", 16328);
    goto LABEL_36;
  }
LABEL_22:
  if (v34 != 4
    && (*(_DWORD *)(a1 + 16) != a4
     || *(unsigned __int16 *)(a1 + 20) != v26
     || memcmp((const void *)(*(_QWORD *)(a1 + 48) + 4), v17 + 2, v26)))
  {
    *(_BYTE *)(a1 + 191) = 4;
    InitializeLastAPTime(mDNSStorage, a1);
    v60 = *(_DWORD *)(a1 + 332);
    if (v60)
    {
      v61 = dword_100158E08;
      while ((int)(v61 - v60) >= 0)
      {
        v62 = *(_DWORD *)(a1 + 328) + 1;
        *(_DWORD *)(a1 + 328) = v62;
        v60 += 6000;
        if (v60 <= 1)
          v60 = 1;
        if (v62 <= 9)
          v63 = v60;
        else
          v63 = 0;
        *(_DWORD *)(a1 + 332) = v63;
        if (v62 >= 0xA)
          goto LABEL_58;
      }
      v64 = 0;
    }
    else
    {
LABEL_58:
      v64 = 1;
    }
    v66 = *(_DWORD *)(a1 + 336);
    if (!v66)
    {
      v67 = *(_DWORD *)(a1 + 328);
      if (v67)
        *(_DWORD *)(a1 + 328) = v67 - 1;
    }
    if (v64)
    {
      v68 = dword_100158E08 + 6000;
      if ((dword_100158E08 + 6000) <= 1)
        v68 = 1;
      *(_DWORD *)(a1 + 332) = v68;
    }
    v69 = *(_DWORD *)(a1 + 328);
    if (v69 + 1 < *(unsigned __int8 *)(a1 + 191))
      *(_BYTE *)(a1 + 191) = v69 + 1;
    if (v69 <= 5)
    {
      if (!v66)
      {
        if (dword_100158E08 + 1000 * (6 - v69) <= 1)
          v66 = 1;
        else
          v66 = dword_100158E08 + 1000 * (6 - v69);
        *(_DWORD *)(a1 + 336) = v66;
      }
      v70 = *(_DWORD *)(a1 + 280);
      *(_DWORD *)(a1 + 280) = 4 * v70;
      *(_DWORD *)(a1 + 284) = v66 - 4 * v70;
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Excessive update rate for %##s; delaying announcement by %ld second%s",
        v55,
        v56,
        v57,
        v58,
        v59,
        *(_QWORD *)(a1 + 40));
    }
    *(_DWORD *)(a1 + 16) = a4;
    goto LABEL_81;
  }
LABEL_23:
  CompleteRDataUpdate((uint64_t)mDNSStorage, a1, v32, v27, v28, v29, v30, v31);
LABEL_81:
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_Update", 16356);
  return 0;
}

void update_callback(int a1, uint64_t a2, char *a3, uint64_t __n, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _BYTE *v10;
  __int128 v12;
  __int128 v13;
  int v14;
  int v15;
  NSObject *v16;
  uint8_t v17[16];
  _OWORD v18[2];
  __int128 v19;
  __int128 v20;

  v10 = *(_BYTE **)(a2 + 608);
  if (!v10 || !*v10)
    goto LABEL_16;
  v12 = *(_OWORD *)(a2 + 24);
  v18[0] = *(_OWORD *)(a2 + 8);
  v18[1] = v12;
  v13 = *(_OWORD *)(a2 + 56);
  v19 = *(_OWORD *)(a2 + 40);
  v20 = v13;
  v14 = *(_DWORD *)(a2 + 172);
  v15 = (v14 & 0xFFFFFFFD) == 1 ? 0x20000 : (v14 == 2) << 20;
  if (WORD6(v18[0]) == (_DWORD)__n && !memcmp((const void *)(*((_QWORD *)&v19 + 1) + 4), a3 + 4, __n))
    goto LABEL_16;
  SetNewRData((uint64_t)v18, (uint64_t)a3, __n, __n, a5, a6, a7, a8);
  internal_stop_advertising_service((uint64_t)v18, v15, 0);
  v16 = mDNSLogCategory_D2D;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_D2D == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v17 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    v16 = mDNSLogCategory_D2D_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_D2D_redacted, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v17 = 0;
LABEL_14:
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "update_callback: calling external_start_advertising_service", v17, 2u);
    }
  }
  internal_start_advertising_service(a2 + 8, v15, 0);
LABEL_16:
  if ((char *)(a2 + 908) != a3)
  {
    if (a3)
      free(a3);
  }
}

void FreeARElemCallback_2558(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t *v5;
  uint64_t *v6;
  BOOL v7;
  NSObject *v8;
  _BYTE *v11;
  void *v12;
  int v13;
  uint64_t v14;
  __int16 v15;
  _BYTE *v16;

  if (a3 == -65792)
  {
    v5 = &LocalDomainEnumRecords;
    do
    {
      v6 = v5;
      v5 = (uint64_t *)*v5;
      if (v5)
        v7 = v5 + 1 == (uint64_t *)a2;
      else
        v7 = 1;
    }
    while (!v7);
    if (!v5)
      goto LABEL_18;
    *v6 = *v5;
    v8 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        goto LABEL_18;
    }
    else
    {
      v8 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_18;
    }
    v11 = (_BYTE *)(a1 + 47032);
    GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), v11);
    v13 = 141558275;
    v14 = 1752392040;
    v15 = 2085;
    v16 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "FreeARElemCallback: Have to cut %{sensitive, mask.hash}s", (uint8_t *)&v13, 0x16u);
LABEL_18:
    v12 = *(void **)(a2 + 112);
    if (v12)
      free(v12);
  }
}

uint64_t ___get_unicast_discovery_dns_services_block_invoke(uint64_t a1, int a2, __int128 *a3, unsigned int a4)
{
  CFMutableArrayRef *v8;
  CFMutableArrayRef *v9;
  unsigned int v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  __int128 v15;

  if (a3)
  {
    v8 = (CFMutableArrayRef *)mdns_dns_service_definition_create();
    if (v8)
    {
      v9 = v8;
      if (a2 == 30)
      {
        v15 = *a3;
        v13 = _mdns_address_new();
        if (!v13)
        {
LABEL_10:
          os_release(v9);
          return 1;
        }
        v12 = (void *)v13;
        *(_DWORD *)(v13 + 24) = -384557540;
        *(_OWORD *)(v13 + 32) = v15;
        *(_DWORD *)(v13 + 48) = a4;
      }
      else
      {
        if (a2 != 2)
          goto LABEL_10;
        v10 = *(_DWORD *)a3;
        v11 = _mdns_address_new();
        if (!v11)
          goto LABEL_10;
        v12 = (void *)v11;
        *(_DWORD *)(v11 + 24) = -384564720;
        *(_DWORD *)(v11 + 28) = bswap32(v10);
      }
      CFArrayAppendValue(v9[3], v12);
      os_release(v12);
      mdns_dns_service_definition_set_interface_index((uint64_t)v9, a4, 1);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), v9);
      goto LABEL_10;
    }
  }
  return 1;
}

uint64_t __add_domain_to_browser_block_invoke(_QWORD *a1, uint64_t a2)
{
  int v4;
  unsigned __int8 *ValueAtIndex;
  unsigned __int8 *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  _BYTE *v15;
  _BYTE *v16;
  uint64_t v17;
  unsigned __int16 v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;
  int v23;
  uint64_t v24;
  int v25;
  NSObject *v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  unint64_t v30;
  _BYTE *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  _BYTE *v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  _BYTE *v40;
  uint64_t v41;
  int v42;
  _BYTE *v43;
  uint64_t v44;
  uint8_t buf[8];
  _BYTE v47[6];
  __int16 v48;
  uint64_t v49;
  __int16 v50;
  int v51;
  __int16 v52;
  uint64_t v53;
  __int16 v54;
  uint64_t v55;
  __int16 v56;
  int v57;
  __int16 v58;
  uint64_t v59;

  v4 = *(_DWORD *)(a2 + 48);
  if (CFArrayGetCount(*(CFArrayRef *)(a2 + 24)) >= 1)
  {
    ValueAtIndex = (unsigned __int8 *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 24), 0);
    if (ValueAtIndex)
    {
      v6 = ValueAtIndex;
      v7 = malloc_type_calloc(1uLL, 0x3C0uLL, 0xF1748037uLL);
      if (!v7)
        __break(1u);
      v14 = v7;
      v15 = (_BYTE *)a1[5];
      v16 = v15;
      if (v15 == (_BYTE *)-256)
      {
LABEL_6:
        while (v16)
        {
          v17 = *v16;
          if (v17 > 0x3F)
            break;
          if (!*v16)
          {
            v18 = (_WORD)v16 - (_WORD)v15 + 1;
            if (v18 > 0x100u)
              break;
            memcpy(v7 + 1, v15, v18);
            goto LABEL_14;
          }
          v16 += v17 + 1;
          if (v15 != (_BYTE *)-256)
            goto LABEL_5;
        }
      }
      else
      {
LABEL_5:
        if (v16 < v15 + 256)
          goto LABEL_6;
      }
      *((_BYTE *)v7 + 8) = 0;
LABEL_14:
      v19 = a1[6];
      *((_DWORD *)v14 + 128) = *(_DWORD *)(v19 + 188);
      if (*(_BYTE *)(v19 + 280))
      {
        v20 = 0;
        *(_OWORD *)(v14 + 115) = *(_OWORD *)(v19 + 264);
      }
      else
      {
        v20 = *(_DWORD *)(v19 + 180);
      }
      *((_DWORD *)v14 + 127) = v20;
      *((_DWORD *)v14 + 129) = *(_DWORD *)(a1[6] + 192);
      v21 = v6[25];
      if (v21 == 30)
      {
        v23 = *((_DWORD *)v6 + 8);
        *(_QWORD *)buf = *(_QWORD *)(v6 + 36);
        *(_DWORD *)v47 = *((_DWORD *)v6 + 11);
        v22 = 6;
      }
      else if (v21 == 2)
      {
        *(_DWORD *)v47 = 0;
        *(_QWORD *)buf = 0;
        v22 = 4;
        v23 = *((_DWORD *)v6 + 7);
      }
      else
      {
        v23 = 0;
        v22 = 0;
        *(_DWORD *)v47 = 0;
        *(_QWORD *)buf = 0;
      }
      *((_DWORD *)v14 + 142) = v22;
      *((_DWORD *)v14 + 143) = v23;
      v14[72] = *(_QWORD *)buf;
      *((_DWORD *)v14 + 146) = *(_DWORD *)v47;
      v24 = mDNSPlatformInterfaceIDfromInterfaceIndex(v4, (uint64_t)v15, v8, v9, v10, v11, v12, v13);
      *(_DWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = mDNS_StartBrowse((uint64_t)(v14 + 33), (unsigned __int8 *)(a1[7] + 10), (_BYTE *)a1[5], v24, *(_DWORD *)(a1[6] + 240), 0, (*(_DWORD *)(a1[6] + 240) & 0x80000) != 0, 0, a1[6]);
      v25 = *(_DWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
      if (v25)
      {
        v26 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
          {
            v34 = a1[7];
            v28 = *(_DWORD *)(a1[6] + 192);
            v29 = v34 + 10;
            v35 = v34 + 266;
            v36 = (_BYTE *)(v34 + 10);
            if (v35)
            {
LABEL_37:
              if ((unint64_t)v36 < v35)
                goto LABEL_38;
            }
            else
            {
LABEL_38:
              while (v36)
              {
                v37 = *v36;
                if (v37 > 0x3F)
                  break;
                if (!*v36)
                {
                  v38 = (unsigned __int16)((_WORD)v36 - v29 + 1);
                  goto LABEL_57;
                }
                v36 += v37 + 1;
                if (v35)
                  goto LABEL_37;
              }
            }
            v38 = 257;
LABEL_57:
            v39 = a1[5];
            if (v39)
            {
              v43 = (_BYTE *)a1[5];
              if (v39 == -256)
              {
LABEL_60:
                while (v43)
                {
                  v44 = *v43;
                  if (v44 > 0x3F)
                    break;
                  if (!*v43)
                  {
                    v42 = (unsigned __int16)((_WORD)v43 - v39 + 1);
                    goto LABEL_69;
                  }
                  v43 += v44 + 1;
                  if (v39 != -256)
                    goto LABEL_59;
                }
              }
              else
              {
LABEL_59:
                if ((unint64_t)v43 < v39 + 256)
                  goto LABEL_60;
              }
              v42 = 257;
            }
            else
            {
              v42 = 0;
            }
            goto LABEL_69;
          }
        }
        else
        {
          v26 = mDNSLogCategory_mDNS_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
          {
            v27 = a1[7];
            v28 = *(_DWORD *)(a1[6] + 192);
            v29 = v27 + 10;
            v30 = v27 + 266;
            v31 = (_BYTE *)(v27 + 10);
            if (v30)
            {
LABEL_27:
              if ((unint64_t)v31 < v30)
                goto LABEL_28;
            }
            else
            {
LABEL_28:
              while (v31)
              {
                v32 = *v31;
                if (v32 > 0x3F)
                  break;
                if (!*v31)
                {
                  v38 = (unsigned __int16)((_WORD)v31 - v29 + 1);
                  goto LABEL_46;
                }
                v31 += v32 + 1;
                if (v30)
                  goto LABEL_27;
              }
            }
            v38 = 257;
LABEL_46:
            v39 = a1[5];
            if (v39)
            {
              v40 = (_BYTE *)a1[5];
              if (v39 == -256)
              {
LABEL_49:
                while (v40)
                {
                  v41 = *v40;
                  if (v41 > 0x3F)
                    break;
                  if (!*v40)
                  {
                    v42 = (unsigned __int16)((_WORD)v40 - v39 + 1);
                    goto LABEL_69;
                  }
                  v40 += v41 + 1;
                  if (v39 != -256)
                    goto LABEL_48;
                }
              }
              else
              {
LABEL_48:
                if ((unint64_t)v40 < v39 + 256)
                  goto LABEL_49;
              }
              v42 = 257;
            }
            else
            {
              v42 = 0;
            }
LABEL_69:
            *(_DWORD *)buf = 67110915;
            *(_DWORD *)&buf[4] = v28;
            *(_WORD *)v47 = 1024;
            *(_DWORD *)&v47[2] = v25;
            v48 = 2160;
            v49 = 1752392040;
            v50 = 1040;
            v51 = v38;
            v52 = 2101;
            v53 = v29;
            v54 = 2160;
            v55 = 1752392040;
            v56 = 1040;
            v57 = v42;
            v58 = 2101;
            v59 = v39;
            _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "[R%u] mDNS_StartBrowse returned error (UNICAST_DISCOVERY) -- error: %d, type: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, domain: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", buf, 0x42u);
          }
        }
        free(v14);
        return 1;
      }
      v33 = a1[7];
      *v14 = *(_QWORD *)(v33 + 272);
      *(_QWORD *)(v33 + 272) = v14;
      if (mDNS_McastLoggingEnabled)
        LogMcastQuestion((uint64_t)(v14 + 33), a1[6], 1);
    }
  }
  return 1;
}

void *GenerateBrowseReply(unsigned __int8 *a1, uint64_t a2, uint64_t a3, char **a4, unsigned int a5, unsigned int a6)
{
  uint64_t v12;
  char *v13;
  _BYTE *v14;
  uint64_t v15;
  char v16;
  size_t v17;
  size_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *reply;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  char *v31;
  _DWORD *v32;
  char *v33;
  size_t v34;
  void *result;
  char __src[1009];
  _OWORD __s[4];

  memset(__s, 0, sizeof(__s));
  bzero(__src, 0x3F1uLL);
  *a4 = 0;
  if (a1)
  {
    v13 = (char *)(a1 + 1);
    v12 = *a1;
    if (v12 <= 0x3F)
    {
      if (v13 >= &v13[v12])
      {
        v14 = __s;
      }
      else
      {
        v14 = __s;
        v15 = *a1;
        do
        {
          v16 = *v13++;
          *v14++ = v16;
          --v15;
        }
        while (v15);
      }
      *v14 = 0;
    }
    mDNS_snprintf(__src);
  }
  else
  {
    LOBYTE(__s[0]) = 0;
  }
  v17 = strlen((const char *)__s);
  v18 = strlen(__src);
  reply = create_reply((char *)0x42, v17 + v18 + 16, a3, v19, v20, v21, v22, v23);
  *a4 = reply;
  *((_DWORD *)reply + 11) = bswap32(a5);
  v30 = mDNSPlatformInterfaceIndexfromInterfaceID((uint64_t **)mDNSStorage, a2, 0, v25, v26, v27, v28, v29);
  v31 = *a4;
  *((_DWORD *)v31 + 12) = bswap32(v30);
  *((_DWORD *)v31 + 13) = bswap32(a6);
  v32 = v31 + 56;
  memcpy(v31 + 56, __s, v17 + 1);
  v33 = (char *)v32 + v17 + 1;
  v34 = strlen(__src) + 1;
  result = memcpy(v33, __src, v34);
  *(_WORD *)&v33[v34] = 46;
  return result;
}

void append_reply(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;

  if (*(_BYTE *)(a1 + 284))
  {
    if (a2)
      free(a2);
  }
  else
  {
    v2 = *(_QWORD *)(a1 + 24);
    if (!v2)
      v2 = a1;
    v3 = (_QWORD *)(v2 + 96);
    do
    {
      v4 = v3;
      v3 = (_QWORD *)*v3;
    }
    while (v3);
    *v4 = a2;
    *a2 = 0;
  }
}

void FoundNonLocalOnlyAutomaticBrowseDomain(uint64_t a1, uint64_t a2, unsigned __int8 *a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  BOOL v10;
  uint64_t v14;
  __int16 v15;
  _BYTE *v16;
  uint64_t v17;
  uint64_t v18;
  _BYTE *v19;
  _BYTE *v20;
  _BYTE *v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  unsigned __int16 v27;
  const char *v28;
  uint64_t v29;
  int v30;
  _QWORD *v31;
  _QWORD *v32;
  char *v33;
  NSObject *v34;
  const char *v36;
  _BYTE *v37;
  uint64_t v38;
  _BYTE *v40;
  uint64_t v41;
  int v42;
  int v43;
  const char *v44;
  __int16 v45;
  char *v46;
  __int16 v47;
  uint64_t v48;
  __int16 v49;
  int v50;
  __int16 v51;
  uint64_t v52;

  v8 = *((_QWORD *)a3 + 3) + 5;
  v10 = v8 <= 3 && v8 != 1 || a4 > 1;
  if (!v10 && *a3 != 240)
  {
    v14 = *((_QWORD *)a3 + 5);
    v15 = v14 + 4;
    v16 = (_BYTE *)(v14 + 4);
    if (a4)
    {
      RegisterLocalOnlyDomainEnumPTR((unsigned int *)a1, v16, 2);
      mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNS_AddDomainDiscoveredForDomainEnumeration", 16174);
      v17 = *(_QWORD *)(a1 + 14160);
      if (v17)
      {
        while (!SameDomainNameBytes((_BYTE *)v17, "\x05local"))
        {
          v17 = *(_QWORD *)(v17 + 296);
          if (!v17)
            goto LABEL_38;
        }
        if (*(_QWORD *)(v17 + 272))
        {
          v19 = malloc_type_calloc(1uLL, 0x108uLL, 0xF1748037uLL);
          if (!v19)
            __break(1u);
          v20 = v19;
          v21 = (_BYTE *)(v14 + 4);
          if (v14 == -260)
          {
LABEL_24:
            while (v21)
            {
              v22 = *v21;
              if (v22 > 0x3F)
                break;
              if (!*v21)
              {
                v27 = (_WORD)v21 - v15 + 1;
                if (v27 > 0x100u)
                  break;
                memcpy(v19, (const void *)(v14 + 4), v27);
                goto LABEL_37;
              }
              v21 += v22 + 1;
              if (v14 != -260)
                goto LABEL_23;
            }
          }
          else
          {
LABEL_23:
            if ((unint64_t)v21 < v14 + 260)
              goto LABEL_24;
          }
          *v19 = 0;
LABEL_37:
          *((_QWORD *)v20 + 32) = **(_QWORD **)(v17 + 272);
          **(_QWORD **)(v17 + 272) = v20;
        }
      }
LABEL_38:
      v28 = "mDNS_AddDomainDiscoveredForDomainEnumeration";
      v29 = a1;
      v30 = 16209;
    }
    else
    {
      DeregisterLocalOnlyDomainEnumPTR_Internal((unsigned int *)a1, v16, 2, 0, a5, a6, a7, a8);
      mDNS_Lock_((unsigned int *)a1, (uint64_t)"mDNS_RemoveDomainDiscoveredForDomainEnumeration", 16217);
      v18 = *(_QWORD *)(a1 + 14160);
      if (v18)
      {
        while (!SameDomainNameBytes((_BYTE *)v18, "\x05local"))
        {
          v18 = *(_QWORD *)(v18 + 296);
          if (!v18)
            goto LABEL_40;
        }
        v23 = *(uint64_t **)(v18 + 272);
        if (v23)
        {
          v24 = *v23;
          if (*v23)
          {
            while (1)
            {
              v25 = SameDomainNameBytes((_BYTE *)v24, (_BYTE *)(v14 + 4));
              v26 = *(_QWORD *)(v24 + 256);
              if (v25)
                break;
              v23 = (uint64_t *)(v24 + 256);
              v24 = *(_QWORD *)(v24 + 256);
              if (!v26)
                goto LABEL_40;
            }
            *v23 = v26;
            free((void *)v24);
          }
        }
      }
LABEL_40:
      v28 = "mDNS_RemoveDomainDiscoveredForDomainEnumeration";
      v29 = a1;
      v30 = 16254;
    }
    mDNS_Unlock_(v29, (uint64_t)v28, v30);
    v31 = (_QWORD *)(a1 + 12656);
    while (1)
    {
      v31 = (_QWORD *)*v31;
      if (!v31)
        break;
      v32 = v31;
      if (v31[444] == *((_QWORD *)a3 + 3))
        goto LABEL_46;
    }
    v32 = 0;
LABEL_46:
    if (v31)
      v33 = (char *)v32 + 3606;
    else
      v33 = 0;
    v34 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
        v36 = "removed";
        if (a4 == 1)
          v36 = "added";
        v37 = (_BYTE *)(v14 + 4);
        if (v14 == -260)
        {
LABEL_59:
          while (v37)
          {
            v38 = *v37;
            if (v38 > 0x3F)
              break;
            if (!*v37)
            {
              v42 = (unsigned __int16)((_WORD)v37 - v15 + 1);
              goto LABEL_78;
            }
            v37 += v38 + 1;
            if (v14 != -260)
              goto LABEL_58;
          }
        }
        else
        {
LABEL_58:
          if ((unint64_t)v37 < v14 + 260)
            goto LABEL_59;
        }
        v42 = 257;
        goto LABEL_78;
      }
    }
    else
    {
      v34 = mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
      {
        v36 = "removed";
        if (a4 == 1)
          v36 = "added";
        v40 = (_BYTE *)(v14 + 4);
        if (v14 == -260)
        {
LABEL_69:
          while (v40)
          {
            v41 = *v40;
            if (v41 > 0x3F)
              break;
            if (!*v40)
            {
              v42 = (unsigned __int16)((_WORD)v40 - v15 + 1);
              goto LABEL_78;
            }
            v40 += v41 + 1;
            if (v14 != -260)
              goto LABEL_68;
          }
        }
        else
        {
LABEL_68:
          if ((unint64_t)v40 < v14 + 260)
            goto LABEL_69;
        }
        v42 = 257;
LABEL_78:
        v43 = 136447235;
        v44 = v36;
        v45 = 2082;
        v46 = v33;
        v47 = 2160;
        v48 = 1752392040;
        v49 = 1040;
        v50 = v42;
        v51 = 2101;
        v52 = v14 + 4;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "Automatic browsing domain discovered via network - change: %{public}s, interface name: %{public}s, browsing domain: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", (uint8_t *)&v43, 0x30u);
      }
    }
  }
}

uint64_t uds_socket_setup(int a1)
{
  int v2;
  const char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;

  v10 = 0x100000001;
  if (setsockopt(a1, 0xFFFF, 4227, &v10, 8u) < 0)
    my_perror((int)"WARNING: could not set sockopt - SO_NP_EXTENSIONS");
  v2 = fcntl(a1, 3, 0);
  if (fcntl(a1, 4, v2 | 4u))
  {
    v3 = "ERROR: could not set listen socket to non-blocking mode";
LABEL_9:
    my_perror((int)v3);
    return 0;
  }
  if (listen(a1, 100))
  {
    v3 = "ERROR: could not listen on listen socket";
    goto LABEL_9;
  }
  if (udsSupportAddFDToEventLoop(a1, (uint64_t)connect_callback, 0))
  {
    v3 = "ERROR: could not add listen socket to event loop";
    goto LABEL_9;
  }
  if (mDNS_LoggingEnabled == 1)
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: Listening for incoming Unix Domain Socket client requests", v4, v5, v6, v7, v8, a1);
  dword_10015DB80 = a1;
  return 1;
}

void my_perror(int a1)
{
  NSObject *v2;
  int *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = mDNSLogCategory_Default;
  __error();
  v3 = __error();
  strerror(*v3);
  LogMsgWithLevel(v2, OS_LOG_TYPE_DEFAULT, "%s: %d (%s)", v4, v5, v6, v7, v8, a1);
}

void AutomaticBrowseDomainChange(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v6;
  NSObject *v7;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  _BYTE *v12;
  uint64_t v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  _BYTE *v24;
  uint64_t v25;
  int v26;
  int v27;
  const char *v28;
  const char *v29;
  char *v30;
  int v31;
  uint64_t v32;
  __int16 v33;
  int v34;
  __int16 v35;
  uint64_t v36;
  __int16 v37;
  const char *v38;
  __int16 v39;
  uint64_t v40;
  __int16 v41;
  const char *v42;

  v6 = *(_QWORD *)(a3 + 24);
  v7 = mDNSLogCategory_mDNS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      goto LABEL_36;
    v9 = *(_QWORD *)(a3 + 40);
    v10 = v9 + 4;
    v11 = v9 + 260;
    v12 = (_BYTE *)(v9 + 4);
    if (v11)
    {
LABEL_8:
      if ((unint64_t)v12 < v11)
        goto LABEL_9;
    }
    else
    {
LABEL_9:
      while (v12)
      {
        v13 = *v12;
        if (v13 > 0x3F)
          break;
        if (!*v12)
        {
          v26 = (unsigned __int16)((_WORD)v12 - v10 + 1);
          goto LABEL_25;
        }
        v12 += v13 + 1;
        if (v11)
          goto LABEL_8;
      }
    }
    v26 = 257;
LABEL_25:
    v28 = "removing";
    v31 = 141559299;
    v32 = 1752392040;
    v33 = 1040;
    if (a4 == 1)
      v28 = "adding";
    v34 = v26;
    v35 = 2101;
    v36 = v10;
    v29 = ", ignored.";
    v37 = 2082;
    if (v6)
      v29 = ".";
    goto LABEL_35;
  }
  v7 = mDNSLogCategory_mDNS_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
  {
    v21 = *(_QWORD *)(a3 + 40);
    v22 = v21 + 4;
    v23 = v21 + 260;
    v24 = (_BYTE *)(v21 + 4);
    if (v23)
    {
LABEL_16:
      if ((unint64_t)v24 < v23)
        goto LABEL_17;
    }
    else
    {
LABEL_17:
      while (v24)
      {
        v25 = *v24;
        if (v25 > 0x3F)
          break;
        if (!*v24)
        {
          v27 = (unsigned __int16)((_WORD)v24 - v22 + 1);
          goto LABEL_31;
        }
        v24 += v25 + 1;
        if (v23)
          goto LABEL_16;
      }
    }
    v27 = 257;
LABEL_31:
    v28 = "removing";
    v31 = 141559299;
    v32 = 1752392040;
    v33 = 1040;
    if (a4 == 1)
      v28 = "adding";
    v34 = v27;
    v35 = 2101;
    v36 = v22;
    v29 = ", ignored.";
    v37 = 2082;
    if (v6)
      v29 = ".";
LABEL_35:
    v38 = v28;
    v39 = 2048;
    v40 = v6;
    v41 = 2082;
    v42 = v29;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Automatic browsing domain changes - name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, event: %{public}s, interface ID: %p%{public}s", (uint8_t *)&v31, 0x3Au);
  }
LABEL_36:
  if (v6)
  {
    v30 = (char *)(*(_QWORD *)(a3 + 40) + 4);
    if (a4)
      AddAutoBrowseDomain(0, v30);
    else
      RmvAutoBrowseDomain(0, v30, v15, v16, v17, v18, v19, v20);
  }
}

uint64_t set_peer_pid(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;
  socklen_t v4;
  int v5;

  *(_BYTE *)(a1 + 248) = 0;
  v2 = a1 + 248;
  *(_DWORD *)(a1 + 180) = -1;
  v4 = 4;
  v5 = -1;
  result = *(unsigned int *)(a1 + 176);
  if ((result & 0x80000000) == 0)
  {
    result = getsockopt(result, 0, 3, &v5, &v4);
    if (!(_DWORD)result)
    {
      result = mdns_system_pid_to_name(v5, v2);
      if (result)
        *(_DWORD *)(a1 + 180) = v5;
    }
  }
  return result;
}

uint64_t get_signed_browse_tlvs(uint64_t a1)
{
  unsigned __int16 *signed_data_tlvs;
  unsigned __int16 *v3;
  uint64_t v4;
  unint64_t v5;
  int v6;
  void *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;
  const char *v15;
  NSObject *v17;
  uint32_t v18;
  unint64_t v21;
  int v22;
  _OWORD v23[16];
  uint8_t buf[4];
  unint64_t v25;
  __int16 v26;
  uint64_t v27;

  v21 = 0;
  signed_data_tlvs = _get_signed_data_tlvs(a1, (uint64_t *)&v21);
  if (!*(_BYTE *)(a1 + 282))
    return 0;
  v3 = signed_data_tlvs;
  if (!signed_data_tlvs)
  {
    v10 = 4294901747;
    v13 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
        return v10;
      *(_WORD *)buf = 0;
      v15 = "get_signed_browse_tlvs data invalid";
    }
    else
    {
      v13 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
        return v10;
      *(_WORD *)buf = 0;
      v15 = "get_signed_browse_tlvs data invalid";
    }
    v17 = v13;
    v18 = 2;
    goto LABEL_33;
  }
  v4 = v21;
  if (v21 < 0x3A)
  {
    v9 = -6743;
  }
  else if (*((_DWORD *)signed_data_tlvs + 12) == 5)
  {
    v5 = signed_data_tlvs[28];
    if (v21 - 58 < v5)
    {
      v9 = -6750;
    }
    else if (v5 > 0x3F0)
    {
      v9 = -6744;
    }
    else
    {
      bzero(buf, 0x3F1uLL);
      __memcpy_chk(buf, v3 + 29, v5, 1009);
      buf[v5] = 0;
      memset(v23, 0, sizeof(v23));
      v6 = DomainNameFromString(v23, (char *)buf);
      if (v6 || (v6 = _mdns_necp_validate_result((uint64_t)v3, v4)) != 0)
      {
        v9 = v6;
      }
      else
      {
        v22 = 0;
        v7 = malloc_type_malloc(v4, 0xA172743EuLL);
        if (v7)
        {
          v5 = (unint64_t)v7;
          memcpy(v7, v3, v4);
          v8 = _mdns_signed_browse_result_create_no_copy(v23, v5, v4, &v22);
          if (v8)
          {
            v9 = v22;
            if (!v22)
            {
              v10 = 0;
              *(_QWORD *)(a1 + 56) = v8;
              return v10;
            }
            goto LABEL_12;
          }
        }
        else
        {
          __break(1u);
        }
        free((void *)v5);
        v9 = -6728;
      }
    }
  }
  else
  {
    v9 = -6756;
  }
LABEL_12:
  v10 = 4294901747;
  v11 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
    {
LABEL_29:
      *(_DWORD *)buf = 134218240;
      v25 = v21;
      v26 = 2048;
      v27 = v9;
      v15 = "get_signed_browse_tlvs len %ld data invalid %ld";
      v17 = v11;
      v18 = 22;
LABEL_33:
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, v15, buf, v18);
    }
  }
  else
  {
    v11 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
      goto LABEL_29;
  }
  return v10;
}

uint64_t build_domainname_from_strings(_BYTE *a1, _BYTE *a2, unsigned __int8 *a3, unsigned __int8 *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  uint64_t v11;
  char *v12;
  BOOL v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned __int8 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  _BYTE v36[31];
  char v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  _BYTE v52[31];
  char v53[64];
  uint64_t v54;
  uint64_t vars0;

  memset(&v53[1], 0, 63);
  LOBYTE(v10) = *a2;
  if (*a2)
  {
    v11 = 0;
    do
    {
      v53[v11 + 1] = v10;
      v12 = &v53[v11 + 2];
      v10 = a2[++v11];
      if (v10)
        v13 = v12 >= (char *)&v54;
      else
        v13 = 1;
    }
    while (!v13);
    v53[0] = v53 + v11 + 1 + ~(&vars0 - 104);
    if (v10)
      return 0xFFFFFFFFLL;
  }
  else
  {
    v53[0] = v53 + 1 + ~(&vars0 - 104);
  }
  v51 = 0u;
  memset(v52, 0, sizeof(v52));
  v49 = 0u;
  v50 = 0u;
  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  v38 = 0u;
  v22 = 0u;
  v23 = 0u;
  v24 = 0u;
  v25 = 0u;
  v26 = 0u;
  v27 = 0u;
  v28 = 0u;
  v29 = 0u;
  v30 = 0u;
  v31 = 0u;
  v32 = 0u;
  v33 = 0u;
  v34 = 0u;
  v35 = 0u;
  memset(v36, 0, sizeof(v36));
  v21 = 0;
  if (!AppendDNSNameString(&v21, a3, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8))
    return 0xFFFFFFFFLL;
  v37 = 0;
  if (!AppendDNSNameString(&v37, a4, v14, v15, v16, v17, v18, v19))
    return 0xFFFFFFFFLL;
  if (ConstructServiceName(a1, v53, &v21, &v37))
    return 0;
  else
    return 0xFFFFFFFFLL;
}

void resolve_result_callback(uint64_t **a1, uint64_t a2, size_t a3, int a4)
{
  void *v4;
  timespec *p_tp;
  timespec *v10;
  _BYTE *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int tv_nsec;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  int v24;
  size_t v25;
  _WORD *v26;
  BOOL v27;
  int v28;
  char *v29;
  uint64_t v30;
  const void *v31;
  unsigned int v32;
  uint64_t v33;
  int validation_result;
  int v35;
  size_t v36;
  _WORD *v37;
  BOOL v38;
  int v39;
  char *v40;
  int v41;
  char *v42;
  uint64_t v43;
  void *v44;
  unsigned int v45;
  __int16 *v46;
  int v47;
  char *v48;
  uint64_t v49;
  const void *v50;
  __int16 *v51;
  int v52;
  char *v53;
  uint64_t v54;
  unsigned int v55;
  __int16 *v56;
  int v57;
  char *v58;
  uint64_t v59;
  timespec *v60;
  __int16 *v61;
  NSObject *v62;
  NSObject *v63;
  int v64;
  unsigned int v65;
  _BYTE *v66;
  int v67;
  int v68;
  uint64_t v69;
  int v70;
  char *v71;
  uint64_t v72;
  const void *v73;
  unsigned int v74;
  __int16 *v75;
  int v76;
  char *v77;
  NSObject *v78;
  int v79;
  uint64_t RDataBytesPointer;
  const void *v81;
  NSObject *v82;
  NSObject *v83;
  int v84;
  _BYTE *v85;
  int v86;
  int v87;
  uint64_t v88;
  NSObject *v89;
  int tv_sec;
  unsigned int v91;
  _BYTE *v92;
  int v93;
  int v94;
  uint64_t v95;
  NSObject *v96;
  uint64_t v97;
  const void *v98;
  int v99;
  unsigned int v100;
  int v101;
  const char *v102;
  NSObject *v103;
  _BYTE *v104;
  uint64_t v105;
  NSObject *v106;
  int v107;
  _BYTE *v108;
  int v109;
  int v110;
  uint64_t v111;
  int v112;
  unsigned int v113;
  int v114;
  uint32_t v115;
  _BYTE *v116;
  uint64_t v117;
  NSObject *v118;
  int v119;
  unsigned int v120;
  unsigned int v121;
  size_t v122;
  unsigned int v123;
  NSObject *v124;
  int v125;
  unsigned int v126;
  _BYTE *v127;
  uint64_t v128;
  int v129;
  unsigned int v130;
  _BYTE *v131;
  uint64_t v132;
  int v133;
  int v134;
  _BYTE *v135;
  uint64_t v136;
  NSObject *v137;
  NSObject *v138;
  int v139;
  unsigned int v140;
  unsigned int v141;
  size_t v142;
  unsigned int v143;
  timespec *v144;
  NSObject *v145;
  int v146;
  unsigned int v147;
  _BYTE *v148;
  uint64_t v149;
  int v150;
  unsigned int v151;
  unsigned int v152;
  size_t v153;
  unsigned int v154;
  timespec *v155;
  int v156;
  unsigned int v157;
  _BYTE *v158;
  uint64_t v159;
  int v160;
  int v161;
  _BYTE *v162;
  uint64_t v163;
  NSObject *v164;
  int v165;
  unsigned int v166;
  size_t v167;
  unsigned int v168;
  NSObject *v169;
  int v170;
  _BYTE *v171;
  uint64_t v172;
  _BYTE *v173;
  uint64_t v174;
  unsigned __int16 v175;
  NSObject *v176;
  int v177;
  unsigned int v178;
  size_t v179;
  unsigned int v180;
  NSObject *v181;
  int v182;
  _BYTE *v183;
  uint64_t v184;
  _BYTE *v185;
  uint64_t v186;
  unsigned __int16 v187;
  unsigned __int16 v188;
  unsigned __int16 v189;
  unsigned __int16 v190;
  int v191;
  const void *v192;
  int v193;
  const char *v194;
  NSObject *v195;
  uint32_t v196;
  unsigned __int16 v197;
  unsigned __int16 v198;
  unsigned __int16 v199;
  unsigned __int16 v200;
  unsigned __int16 v201;
  int v202;
  int v203;
  unsigned int v204;
  size_t v205;
  unsigned int v206;
  const void *v207;
  int v208;
  unsigned int v209;
  int v210;
  unsigned int v211;
  size_t v212;
  unsigned int v213;
  size_t v214;
  void *v215;
  const void *v216;
  int v217;
  unsigned int v218;
  void *v219;
  void *v220;
  const void *v221;
  unsigned int v222;
  NSObject *v223;
  void *v224;
  const void *v225;
  unsigned int v226;
  int v227;
  const void *v228;
  int v229;
  unsigned __int16 v230;
  unsigned __int16 v231;
  int v232;
  unsigned int v233;
  size_t v234;
  unsigned int v235;
  timespec *v236;
  const void *v237;
  unsigned int v238;
  int v239;
  int v240;
  unsigned int v241;
  size_t v242;
  unsigned int v243;
  timespec *v244;
  const void *v245;
  int v246;
  int v247;
  int v248;
  unsigned int v249;
  size_t v250;
  unsigned int v251;
  const void *v252;
  const void *v253;
  unsigned int v254;
  int v255;
  int v256;
  unsigned int v257;
  size_t v258;
  unsigned int v259;
  timespec *v260;
  const void *v261;
  int v262;
  unsigned int v263;
  size_t v264;
  const void *v265;
  int v266;
  int v267;
  __darwin_time_t v268;
  int v269;
  void *v270;
  void *v271;
  void *v272;
  void *v273;
  uint64_t v274;
  _BYTE *v275;
  unint64_t v276;
  _BYTE *v277;
  int v278;
  uint64_t v279;
  uint64_t v280;
  size_t v281;
  size_t v282;
  _BYTE *v283;
  uint64_t v284;
  unsigned __int16 v285;
  _BOOL4 v286;
  _BOOL4 v287;
  int v288;
  int v289;
  uint64_t v290;
  uint64_t v291;
  uint64_t v292;
  uint64_t v293;
  uint64_t v294;
  unsigned __int8 *v295;
  unsigned __int8 *v296;
  uint64_t v297;
  uint64_t v298;
  unsigned __int16 v299;
  int v300;
  int v301;
  unsigned __int8 *p_n;
  unsigned int v303;
  size_t v304;
  uint64_t v305;
  uint64_t v306;
  uint64_t v307;
  uint64_t v308;
  uint64_t v309;
  unsigned int v310;
  void *v311;
  uint64_t v312;
  NSObject *v313;
  uint64_t v314;
  const char *v315;
  unsigned int v316;
  uint64_t v317;
  size_t v318;
  size_t v319;
  uint64_t v320;
  uint64_t v321;
  uint64_t v322;
  int v323;
  size_t v324;
  int v325;
  uint64_t v326;
  const char *data;
  unsigned __int16 v328;
  uint64_t v329;
  int v330;
  unsigned int v331;
  NSObject *v332;
  int v333;
  unsigned int v334;
  unint64_t v335;
  char *reply;
  size_t v337;
  char *v338;
  size_t v339;
  char *v340;
  char *v341;
  char *v342;
  char v343;
  uint64_t v344;
  uint64_t v345;
  int v346;
  unsigned int v347;
  const char *v348;
  NSObject *v349;
  uint32_t v350;
  int v351;
  unsigned int v352;
  int v353;
  int v354;
  unsigned int v355;
  unsigned int v356;
  uint64_t **v357;
  uint64_t **v358;
  unsigned __int8 *v359;
  int v360;
  int v361;
  timespec *v362;
  timespec *v363;
  size_t v364;
  int v365;
  uint64_t v366;
  uint64_t v367;
  uint64_t v368;
  unsigned __int16 __n;
  int __n_2;
  char __src;
  char v372;
  char __s[1009];
  timespec __tp;
  _BYTE v375[10];
  char *v376;
  _BYTE v377[68];

  p_tp = &__tp;
  bzero(__s, 0x3F1uLL);
  bzero(&v372, 0x3F0uLL);
  __src = 48;
  v10 = *(timespec **)(a2 + 176);
  v11 = (_BYTE *)(a2 + 376);
  v365 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(a2 + 376));
  v12 = *(unsigned __int16 *)(a2 + 340);
  LODWORD(v366) = mDNSPlatformInterfaceIndexfromInterfaceID(a1, *(_QWORD *)(a3 + 24), 0, v13, v14, v15, v16, v17);
  HIDWORD(v366) = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(a2 + 376));
  tv_nsec = v10[12].tv_nsec;
  __tp.tv_sec = 0;
  __tp.tv_nsec = 0;
  clock_gettime(_CLOCK_MONOTONIC_RAW, &__tp);
  v368 = a2;
  if (!tv_nsec || LODWORD(__tp.tv_sec) - tv_nsec >= 300)
  {
    LODWORD(v10[12].tv_nsec) = __tp.tv_sec;
    v33 = *(_QWORD *)(a3 + 56);
    if (v33)
    {
      validation_result = dnssec_obj_resource_record_member_get_validation_result(v33);
      v35 = *(unsigned __int16 *)(a2 + 340);
      v37 = (_WORD *)(a3 + 12);
      v36 = *(unsigned __int16 *)(a3 + 12);
      v38 = v36 < 0x201;
      if (validation_result)
      {
        if (v35)
        {
          if (v36 >= 0x201)
          {
            v36 = (size_t)malloc_type_malloc(v36, 0xA172743EuLL);
            if (!v36)
              goto LABEL_624;
            v40 = (char *)v36;
            LODWORD(v36) = (unsigned __int16)*v37;
            v4 = v40;
            v39 = v36;
          }
          else
          {
            v4 = 0;
            v39 = 512;
            v40 = (char *)&unk_100164380;
          }
          v79 = a4;
          if (!(_DWORD)v36)
          {
            if (v12)
              v89 = mDNSLogCategory_Default;
            else
              v89 = mDNSLogCategory_mDNS;
            if (gSensitiveLoggingEnabled != 1 || v89 == mDNSLogCategory_State)
            {
              if (!os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
                goto LABEL_479;
              tv_sec = v10[12].tv_sec;
              v91 = bswap32(*(unsigned __int16 *)(v368 + 340)) >> 16;
              v116 = v11;
              v94 = v366;
              v93 = HIDWORD(v366);
              if (v368 == -632)
              {
LABEL_190:
                while (v116)
                {
                  v117 = *v116;
                  if (v117 > 0x3F)
                    break;
                  if (!*v116)
                  {
                    v187 = (_WORD)v116 - (_WORD)v11 + 1;
                    goto LABEL_405;
                  }
                  v116 += v117 + 1;
                  if (v368 != -632)
                    goto LABEL_189;
                }
              }
              else
              {
LABEL_189:
                if ((unint64_t)v116 < v368 + 632)
                  goto LABEL_190;
              }
              v187 = 257;
            }
            else
            {
              if (v12)
                v89 = mDNSLogCategory_Default_redacted;
              else
                v89 = mDNSLogCategory_mDNS;
              if (!os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
                goto LABEL_479;
              tv_sec = v10[12].tv_sec;
              v91 = bswap32(*(unsigned __int16 *)(v368 + 340)) >> 16;
              v92 = v11;
              v94 = v366;
              v93 = HIDWORD(v366);
              if (v368 == -632)
              {
LABEL_136:
                while (v92)
                {
                  v95 = *v92;
                  if (v95 > 0x3F)
                    break;
                  if (!*v92)
                  {
                    v187 = (_WORD)v92 - (_WORD)v11 + 1;
                    goto LABEL_405;
                  }
                  v92 += v95 + 1;
                  if (v368 != -632)
                    goto LABEL_135;
                }
              }
              else
              {
LABEL_135:
                if ((unint64_t)v92 < v368 + 632)
                  goto LABEL_136;
              }
              v187 = 257;
            }
LABEL_405:
            v202 = *(unsigned __int16 *)(a3 + 4);
            LODWORD(__tp.tv_sec) = 67111683;
            HIDWORD(__tp.tv_sec) = tv_sec;
            LOWORD(__tp.tv_nsec) = 1024;
            *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v91;
            HIWORD(__tp.tv_nsec) = 1024;
            *(_DWORD *)v375 = v79;
            *(_WORD *)&v375[4] = 1024;
            *(_DWORD *)&v375[6] = 0;
            LOWORD(v376) = 1024;
            *(_DWORD *)((char *)&v376 + 2) = v94;
            HIWORD(v376) = 2160;
            *(_QWORD *)v377 = 1752392040;
            *(_WORD *)&v377[8] = 1040;
            *(_DWORD *)&v377[10] = v187;
            *(_WORD *)&v377[14] = 2101;
            *(_QWORD *)&v377[16] = v11;
            *(_WORD *)&v377[24] = 1024;
            *(_DWORD *)&v377[26] = v93;
            *(_WORD *)&v377[30] = 1026;
            *(_DWORD *)&v377[32] = validation_result;
            *(_WORD *)&v377[36] = 1024;
            *(_DWORD *)&v377[38] = v202;
            v102 = "[R%u->Q%u] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, "
                   "name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_resul"
                   "t}d, type: %{mdns:rrtype}d, rdata: <none>";
            v103 = v89;
            a4 = v79;
            v115 = 76;
            goto LABEL_450;
          }
          __n_2 = 0;
          __n = 0;
          RDataBytesPointer = ResourceRecordGetRDataBytesPointer(a3, v40, v39, &__n, &__n_2, v19, v20, v21);
          if (!__n_2)
          {
            v81 = (const void *)RDataBytesPointer;
            v367 = (uint64_t)v10;
            if (__n >= 0x1FFuLL)
            {
              v364 = __n + 2;
              v36 = (size_t)malloc_type_malloc(v364, 0xA172743EuLL);
              if (!v36)
                goto LABEL_624;
              p_tp = (timespec *)v36;
            }
            else
            {
              p_tp = 0;
              v364 = 512;
              v36 = (size_t)word_100164580;
            }
            v363 = (timespec *)v36;
            if (v12)
              v145 = mDNSLogCategory_Default;
            else
              v145 = mDNSLogCategory_mDNS;
            if (gSensitiveLoggingEnabled != 1 || v145 == mDNSLogCategory_State)
            {
              if (!os_log_type_enabled(v145, OS_LOG_TYPE_DEFAULT))
                goto LABEL_477;
              v156 = *(_DWORD *)(v367 + 192);
              v157 = bswap32(*(unsigned __int16 *)(v368 + 340)) >> 16;
              v158 = v11;
              v362 = p_tp;
              if (v368 == -632)
              {
LABEL_284:
                while (v158)
                {
                  v159 = *v158;
                  if (v159 > 0x3F)
                    break;
                  if (!*v158)
                  {
                    v198 = (_WORD)v158 - (_WORD)v11 + 1;
                    goto LABEL_441;
                  }
                  v158 += v159 + 1;
                  if (v368 != -632)
                    goto LABEL_283;
                }
              }
              else
              {
LABEL_283:
                if ((unint64_t)v158 < v368 + 632)
                  goto LABEL_284;
              }
              v198 = 257;
LABEL_441:
              v240 = v198;
              v241 = *(unsigned __int16 *)(a3 + 4);
              v242 = __n;
              v243 = __n + 2;
              if (v243 <= v364)
              {
                v244 = v363;
                LOWORD(v363->tv_sec) = __rev16(v241);
                v245 = v81;
                v246 = v156;
                v354 = v198;
                v356 = v157;
                LODWORD(v364) = v243;
                memcpy((char *)&v363->tv_sec + 2, v245, v242);
                v240 = v354;
                v157 = v356;
                v243 = v364;
                v156 = v246;
              }
              else
              {
                v244 = 0;
              }
              LODWORD(__tp.tv_sec) = 67112451;
              HIDWORD(__tp.tv_sec) = v156;
              LOWORD(__tp.tv_nsec) = 1024;
              *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v157;
              HIWORD(__tp.tv_nsec) = 1024;
              *(_DWORD *)v375 = v79;
              *(_WORD *)&v375[4] = 1024;
              *(_DWORD *)&v375[6] = 0;
              LOWORD(v376) = 1024;
              *(_DWORD *)((char *)&v376 + 2) = v366;
              HIWORD(v376) = 2160;
              *(_QWORD *)v377 = 1752392040;
              *(_WORD *)&v377[8] = 1040;
              *(_DWORD *)&v377[10] = v240;
              *(_WORD *)&v377[14] = 2101;
              *(_QWORD *)&v377[16] = v11;
              *(_WORD *)&v377[24] = 1024;
              *(_DWORD *)&v377[26] = HIDWORD(v366);
              *(_WORD *)&v377[30] = 1026;
              *(_DWORD *)&v377[32] = validation_result;
              *(_WORD *)&v377[36] = 1024;
              *(_DWORD *)&v377[38] = v241;
              *(_WORD *)&v377[42] = 2160;
              *(_QWORD *)&v377[44] = 1752392040;
              *(_WORD *)&v377[52] = 1040;
              *(_DWORD *)&v377[54] = v243;
              *(_WORD *)&v377[58] = 2101;
              *(_QWORD *)&v377[60] = v244;
              goto LABEL_445;
            }
            if (v12)
              v145 = mDNSLogCategory_Default_redacted;
            else
              v145 = mDNSLogCategory_mDNS;
            if (os_log_type_enabled(v145, OS_LOG_TYPE_DEFAULT))
            {
              v146 = *(_DWORD *)(v367 + 192);
              v147 = bswap32(*(unsigned __int16 *)(v368 + 340)) >> 16;
              v148 = v11;
              v362 = p_tp;
              if (v368 == -632)
              {
LABEL_273:
                while (v148)
                {
                  v149 = *v148;
                  if (v149 > 0x3F)
                    break;
                  if (!*v148)
                  {
                    v197 = (_WORD)v148 - (_WORD)v11 + 1;
                    goto LABEL_436;
                  }
                  v148 += v149 + 1;
                  if (v368 != -632)
                    goto LABEL_272;
                }
              }
              else
              {
LABEL_272:
                if ((unint64_t)v148 < v368 + 632)
                  goto LABEL_273;
              }
              v197 = 257;
LABEL_436:
              v232 = v197;
              v233 = *(unsigned __int16 *)(a3 + 4);
              v234 = __n;
              v235 = __n + 2;
              if (v235 <= v364)
              {
                v236 = v363;
                LOWORD(v363->tv_sec) = __rev16(v233);
                v237 = v81;
                v353 = v146;
                v355 = v233;
                v364 = (size_t)v145;
                v238 = v147;
                v239 = v197;
                memcpy((char *)&v363->tv_sec + 2, v237, v234);
                v232 = v239;
                v146 = v353;
                v233 = v355;
                v147 = v238;
                v145 = v364;
              }
              else
              {
                v236 = 0;
              }
              LODWORD(__tp.tv_sec) = 67112451;
              HIDWORD(__tp.tv_sec) = v146;
              LOWORD(__tp.tv_nsec) = 1024;
              *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v147;
              HIWORD(__tp.tv_nsec) = 1024;
              *(_DWORD *)v375 = v79;
              *(_WORD *)&v375[4] = 1024;
              *(_DWORD *)&v375[6] = 0;
              LOWORD(v376) = 1024;
              *(_DWORD *)((char *)&v376 + 2) = v366;
              HIWORD(v376) = 2160;
              *(_QWORD *)v377 = 1752392040;
              *(_WORD *)&v377[8] = 1040;
              *(_DWORD *)&v377[10] = v232;
              *(_WORD *)&v377[14] = 2101;
              *(_QWORD *)&v377[16] = v11;
              *(_WORD *)&v377[24] = 1024;
              *(_DWORD *)&v377[26] = HIDWORD(v366);
              *(_WORD *)&v377[30] = 1026;
              *(_DWORD *)&v377[32] = validation_result;
              *(_WORD *)&v377[36] = 1024;
              *(_DWORD *)&v377[38] = v233;
              *(_WORD *)&v377[42] = 2160;
              *(_QWORD *)&v377[44] = 1752392040;
              *(_WORD *)&v377[52] = 1040;
              *(_DWORD *)&v377[54] = v235;
              *(_WORD *)&v377[58] = 2101;
              *(_QWORD *)&v377[60] = v236;
LABEL_445:
              _os_log_impl((void *)&_mh_execute_header, v145, OS_LOG_TYPE_DEFAULT, "[R%u->Q%u] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P", (uint8_t *)&__tp, 0x66u);
LABEL_476:
              p_tp = v362;
            }
LABEL_477:
            v10 = (timespec *)v367;
            if (p_tp)
              free(p_tp);
          }
LABEL_479:
          a4 = v79;
          goto LABEL_480;
        }
        if (v36 >= 0x201)
        {
          v36 = (size_t)malloc_type_malloc(v36, 0xA172743EuLL);
          if (!v36)
            goto LABEL_624;
          v77 = (char *)v36;
          LODWORD(v36) = (unsigned __int16)*v37;
          v4 = v77;
          v76 = v36;
        }
        else
        {
          v4 = 0;
          v76 = 512;
          v77 = (char *)&unk_100164380;
        }
        v79 = a4;
        if ((_DWORD)v36)
        {
          __n_2 = 0;
          __n = 0;
          v97 = ResourceRecordGetRDataBytesPointer(a3, v77, v76, &__n, &__n_2, v19, v20, v21);
          if (!__n_2)
          {
            v98 = (const void *)v97;
            v367 = (uint64_t)v10;
            if (__n >= 0x1FFuLL)
            {
              v364 = __n + 2;
              v36 = (size_t)malloc_type_malloc(v364, 0xA172743EuLL);
              if (!v36)
                goto LABEL_624;
              p_tp = (timespec *)v36;
            }
            else
            {
              p_tp = 0;
              v364 = 512;
              v36 = (size_t)word_100164580;
            }
            v363 = (timespec *)v36;
            if (v12)
              v181 = mDNSLogCategory_Default;
            else
              v181 = mDNSLogCategory_mDNS;
            if (gSensitiveLoggingEnabled != 1 || v181 == mDNSLogCategory_State)
            {
              if (!os_log_type_enabled(v181, OS_LOG_TYPE_DEFAULT))
                goto LABEL_477;
              v182 = *(_DWORD *)(v367 + 192);
              v185 = v11;
              v358 = a1;
              v362 = p_tp;
              if (v368 == -632)
              {
LABEL_381:
                while (v185)
                {
                  v186 = *v185;
                  if (v186 > 0x3F)
                    break;
                  if (!*v185)
                  {
                    v231 = (_WORD)v185 - (_WORD)v11 + 1;
                    goto LABEL_472;
                  }
                  v185 += v186 + 1;
                  if (v368 != -632)
                    goto LABEL_380;
                }
              }
              else
              {
LABEL_380:
                if ((unint64_t)v185 < v368 + 632)
                  goto LABEL_381;
              }
              v231 = 257;
LABEL_472:
              v256 = v231;
              v257 = *(unsigned __int16 *)(a3 + 4);
              v264 = __n;
              v259 = __n + 2;
              if (v259 <= v364)
              {
                v260 = v363;
                LOWORD(v363->tv_sec) = __rev16(v257);
                v265 = v98;
                v266 = v182;
                LODWORD(v364) = v257;
                memcpy((char *)&v363->tv_sec + 2, v265, v264);
                v257 = v364;
                v182 = v266;
              }
              else
              {
                v260 = 0;
              }
            }
            else
            {
              if (v12)
                v181 = mDNSLogCategory_Default_redacted;
              else
                v181 = mDNSLogCategory_mDNS;
              if (!os_log_type_enabled(v181, OS_LOG_TYPE_DEFAULT))
                goto LABEL_477;
              v182 = *(_DWORD *)(v367 + 192);
              v183 = v11;
              v358 = a1;
              v362 = p_tp;
              if (v368 == -632)
              {
LABEL_370:
                while (v183)
                {
                  v184 = *v183;
                  if (v184 > 0x3F)
                    break;
                  if (!*v183)
                  {
                    v230 = (_WORD)v183 - (_WORD)v11 + 1;
                    goto LABEL_468;
                  }
                  v183 += v184 + 1;
                  if (v368 != -632)
                    goto LABEL_369;
                }
              }
              else
              {
LABEL_369:
                if ((unint64_t)v183 < v368 + 632)
                  goto LABEL_370;
              }
              v230 = 257;
LABEL_468:
              v256 = v230;
              v257 = *(unsigned __int16 *)(a3 + 4);
              v258 = __n;
              v259 = __n + 2;
              if (v259 <= v364)
              {
                v260 = v363;
                LOWORD(v363->tv_sec) = __rev16(v257);
                v261 = v98;
                v262 = v182;
                v364 = (size_t)v181;
                v263 = v257;
                memcpy((char *)&v363->tv_sec + 2, v261, v258);
                v257 = v263;
                v181 = v364;
                v182 = v262;
              }
              else
              {
                v260 = 0;
              }
            }
            LODWORD(__tp.tv_sec) = 67112195;
            HIDWORD(__tp.tv_sec) = v182;
            LOWORD(__tp.tv_nsec) = 1024;
            *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v79;
            HIWORD(__tp.tv_nsec) = 1024;
            *(_DWORD *)v375 = 0;
            *(_WORD *)&v375[4] = 1024;
            *(_DWORD *)&v375[6] = v366;
            strcpy((char *)&v376, "p\bhash");
            HIBYTE(v376) = 0;
            *(_WORD *)v377 = 0;
            *(_WORD *)&v377[2] = 1040;
            *(_DWORD *)&v377[4] = v256;
            *(_WORD *)&v377[8] = 2101;
            *(_QWORD *)&v377[10] = v11;
            *(_WORD *)&v377[18] = 1024;
            *(_DWORD *)&v377[20] = HIDWORD(v366);
            *(_WORD *)&v377[24] = 1026;
            *(_DWORD *)&v377[26] = validation_result;
            *(_WORD *)&v377[30] = 1024;
            *(_DWORD *)&v377[32] = v257;
            *(_WORD *)&v377[36] = 2160;
            *(_QWORD *)&v377[38] = 1752392040;
            *(_WORD *)&v377[46] = 1040;
            *(_DWORD *)&v377[48] = v259;
            *(_WORD *)&v377[52] = 2101;
            *(_QWORD *)&v377[54] = v260;
            _os_log_impl((void *)&_mh_execute_header, v181, OS_LOG_TYPE_DEFAULT, "[R%u->mDNSQ] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P", (uint8_t *)&__tp, 0x60u);
            a1 = v358;
            goto LABEL_476;
          }
          goto LABEL_479;
        }
        if (v12)
          v106 = mDNSLogCategory_Default;
        else
          v106 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || v106 == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT))
            goto LABEL_479;
          v107 = v10[12].tv_sec;
          v162 = v11;
          v110 = v366;
          v109 = HIDWORD(v366);
          if (v368 == -632)
          {
LABEL_295:
            while (v162)
            {
              v163 = *v162;
              if (v163 > 0x3F)
                break;
              if (!*v162)
              {
                v199 = (_WORD)v162 - (_WORD)v11 + 1;
                goto LABEL_448;
              }
              v162 += v163 + 1;
              if (v368 != -632)
                goto LABEL_294;
            }
          }
          else
          {
LABEL_294:
            if ((unint64_t)v162 < v368 + 632)
              goto LABEL_295;
          }
          v199 = 257;
        }
        else
        {
          if (v12)
            v106 = mDNSLogCategory_Default_redacted;
          else
            v106 = mDNSLogCategory_mDNS;
          if (!os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT))
            goto LABEL_479;
          v107 = v10[12].tv_sec;
          v108 = v11;
          v110 = v366;
          v109 = HIDWORD(v366);
          if (v368 == -632)
          {
LABEL_180:
            while (v108)
            {
              v111 = *v108;
              if (v111 > 0x3F)
                break;
              if (!*v108)
              {
                v199 = (_WORD)v108 - (_WORD)v11 + 1;
                goto LABEL_448;
              }
              v108 += v111 + 1;
              if (v368 != -632)
                goto LABEL_179;
            }
          }
          else
          {
LABEL_179:
            if ((unint64_t)v108 < v368 + 632)
              goto LABEL_180;
          }
          v199 = 257;
        }
LABEL_448:
        v247 = *(unsigned __int16 *)(a3 + 4);
        LODWORD(__tp.tv_sec) = 67111427;
        HIDWORD(__tp.tv_sec) = v107;
        LOWORD(__tp.tv_nsec) = 1024;
        *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v79;
        HIWORD(__tp.tv_nsec) = 1024;
        *(_DWORD *)v375 = 0;
        *(_WORD *)&v375[4] = 1024;
        *(_DWORD *)&v375[6] = v110;
        strcpy((char *)&v376, "p\bhash");
        HIBYTE(v376) = 0;
        *(_WORD *)v377 = 0;
        *(_WORD *)&v377[2] = 1040;
        *(_DWORD *)&v377[4] = v199;
        *(_WORD *)&v377[8] = 2101;
        *(_QWORD *)&v377[10] = v11;
        *(_WORD *)&v377[18] = 1024;
        *(_DWORD *)&v377[20] = v109;
        *(_WORD *)&v377[24] = 1026;
        *(_DWORD *)&v377[26] = validation_result;
        *(_WORD *)&v377[30] = 1024;
        *(_DWORD *)&v377[32] = v247;
        v102 = "[R%u->mDNSQ] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, na"
               "me: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_result}d, t"
               "ype: %{mdns:rrtype}d, rdata: <none>";
        v103 = v106;
        a4 = v79;
LABEL_449:
        v115 = 70;
        goto LABEL_450;
      }
    }
    else
    {
      v35 = *(unsigned __int16 *)(a2 + 340);
      v37 = (_WORD *)(a3 + 12);
      LODWORD(v36) = *(unsigned __int16 *)(a3 + 12);
      v38 = v36 < 0x201;
    }
    if (v35)
    {
      if (v38)
      {
        v4 = 0;
        v47 = 512;
        v48 = (char *)&unk_100164380;
        if ((_DWORD)v36)
          goto LABEL_27;
      }
      else
      {
        v36 = (size_t)malloc_type_malloc(v36, 0xA172743EuLL);
        if (!v36)
          goto LABEL_624;
        v48 = (char *)v36;
        v4 = (void *)v36;
        v47 = (unsigned __int16)*v37;
        if (*v37)
        {
LABEL_27:
          __n_2 = 0;
          __n = 0;
          v49 = ResourceRecordGetRDataBytesPointer(a3, v48, v47, &__n, &__n_2, v19, v20, v21);
          if (__n_2)
            goto LABEL_480;
          v50 = (const void *)v49;
          v367 = (uint64_t)v10;
          if (__n >= 0x1FFuLL)
          {
            v364 = __n + 2;
            v36 = (size_t)malloc_type_malloc(v364, 0xA172743EuLL);
            if (!v36)
              goto LABEL_624;
            v51 = (__int16 *)v36;
            p_tp = (timespec *)v36;
          }
          else
          {
            p_tp = 0;
            v364 = 512;
            v51 = word_100164580;
          }
          if (v12)
            v124 = mDNSLogCategory_Default;
          else
            v124 = mDNSLogCategory_mDNS;
          if (gSensitiveLoggingEnabled != 1 || v124 == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled(v124, OS_LOG_TYPE_DEFAULT))
            {
LABEL_417:
              v10 = (timespec *)v367;
              if (!p_tp)
                goto LABEL_480;
              v219 = p_tp;
LABEL_466:
              free(v219);
              goto LABEL_480;
            }
            v129 = *(_DWORD *)(v367 + 192);
            v130 = bswap32(*(unsigned __int16 *)(v368 + 340)) >> 16;
            v131 = v11;
            v363 = p_tp;
            if (v368 == -632)
            {
LABEL_232:
              while (v131)
              {
                v132 = *v131;
                if (v132 > 0x3F)
                  break;
                if (!*v131)
                {
                  v189 = (_WORD)v131 - (_WORD)v11 + 1;
                  goto LABEL_412;
                }
                v131 += v132 + 1;
                if (v368 != -632)
                  goto LABEL_231;
              }
            }
            else
            {
LABEL_231:
              if ((unint64_t)v131 < v368 + 632)
                goto LABEL_232;
            }
            v189 = 257;
LABEL_412:
            v210 = v189;
            v211 = *(unsigned __int16 *)(a3 + 4);
            v212 = __n;
            v213 = __n + 2;
            if (v213 <= v364)
            {
              LODWORD(v362) = v189;
              *v51 = __rev16(v211);
              v215 = v51 + 1;
              v216 = v50;
              v217 = v129;
              v364 = (size_t)v51;
              v218 = v213;
              memcpy(v215, v216, v212);
              v210 = (int)v362;
              v213 = v218;
              v214 = v364;
              v129 = v217;
            }
            else
            {
              v214 = 0;
            }
            LODWORD(__tp.tv_sec) = 67112195;
            HIDWORD(__tp.tv_sec) = v129;
            LOWORD(__tp.tv_nsec) = 1024;
            *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v130;
            HIWORD(__tp.tv_nsec) = 1024;
            *(_DWORD *)v375 = a4;
            *(_WORD *)&v375[4] = 1024;
            *(_DWORD *)&v375[6] = 0;
            LOWORD(v376) = 1024;
            *(_DWORD *)((char *)&v376 + 2) = v366;
            HIWORD(v376) = 2160;
            *(_QWORD *)v377 = 1752392040;
            *(_WORD *)&v377[8] = 1040;
            *(_DWORD *)&v377[10] = v210;
            *(_WORD *)&v377[14] = 2101;
            *(_QWORD *)&v377[16] = v11;
            *(_WORD *)&v377[24] = 1024;
            *(_DWORD *)&v377[26] = HIDWORD(v366);
            *(_WORD *)&v377[30] = 1024;
            *(_DWORD *)&v377[32] = v211;
            *(_WORD *)&v377[36] = 2160;
            *(_QWORD *)&v377[38] = 1752392040;
            *(_WORD *)&v377[46] = 1040;
            *(_DWORD *)&v377[48] = v213;
            *(_WORD *)&v377[52] = 2101;
            *(_QWORD *)&v377[54] = v214;
          }
          else
          {
            if (v12)
              v124 = mDNSLogCategory_Default_redacted;
            else
              v124 = mDNSLogCategory_mDNS;
            if (!os_log_type_enabled(v124, OS_LOG_TYPE_DEFAULT))
              goto LABEL_417;
            v125 = *(_DWORD *)(v367 + 192);
            v126 = bswap32(*(unsigned __int16 *)(v368 + 340)) >> 16;
            v127 = v11;
            v363 = p_tp;
            if (v368 == -632)
            {
LABEL_221:
              while (v127)
              {
                v128 = *v127;
                if (v128 > 0x3F)
                  break;
                if (!*v127)
                {
                  v188 = (_WORD)v127 - (_WORD)v11 + 1;
                  goto LABEL_407;
                }
                v127 += v128 + 1;
                if (v368 != -632)
                  goto LABEL_220;
              }
            }
            else
            {
LABEL_220:
              if ((unint64_t)v127 < v368 + 632)
                goto LABEL_221;
            }
            v188 = 257;
LABEL_407:
            v203 = v188;
            v204 = *(unsigned __int16 *)(a3 + 4);
            v205 = __n;
            v206 = __n + 2;
            if (v206 <= v364)
            {
              *v51 = __rev16(v204);
              v207 = v50;
              v208 = v125;
              v364 = (size_t)v124;
              v209 = v126;
              LODWORD(v362) = v206;
              memcpy(v51 + 1, v207, v205);
              v206 = v362;
              v126 = v209;
              v124 = v364;
              v125 = v208;
            }
            else
            {
              v51 = 0;
            }
            LODWORD(__tp.tv_sec) = 67112195;
            HIDWORD(__tp.tv_sec) = v125;
            LOWORD(__tp.tv_nsec) = 1024;
            *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v126;
            HIWORD(__tp.tv_nsec) = 1024;
            *(_DWORD *)v375 = a4;
            *(_WORD *)&v375[4] = 1024;
            *(_DWORD *)&v375[6] = 0;
            LOWORD(v376) = 1024;
            *(_DWORD *)((char *)&v376 + 2) = v366;
            HIWORD(v376) = 2160;
            *(_QWORD *)v377 = 1752392040;
            *(_WORD *)&v377[8] = 1040;
            *(_DWORD *)&v377[10] = v203;
            *(_WORD *)&v377[14] = 2101;
            *(_QWORD *)&v377[16] = v11;
            *(_WORD *)&v377[24] = 1024;
            *(_DWORD *)&v377[26] = HIDWORD(v366);
            *(_WORD *)&v377[30] = 1024;
            *(_DWORD *)&v377[32] = v204;
            *(_WORD *)&v377[36] = 2160;
            *(_QWORD *)&v377[38] = 1752392040;
            *(_WORD *)&v377[46] = 1040;
            *(_DWORD *)&v377[48] = v206;
            *(_WORD *)&v377[52] = 2101;
            *(_QWORD *)&v377[54] = v51;
          }
          _os_log_impl((void *)&_mh_execute_header, v124, OS_LOG_TYPE_DEFAULT, "[R%u->Q%u] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P", (uint8_t *)&__tp, 0x60u);
          p_tp = v363;
          goto LABEL_417;
        }
      }
      if (v12)
        v63 = mDNSLogCategory_Default;
      else
        v63 = mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || v63 == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
          goto LABEL_480;
        v64 = v10[12].tv_sec;
        v65 = bswap32(*(unsigned __int16 *)(v368 + 340)) >> 16;
        v104 = v11;
        v68 = v366;
        v67 = HIDWORD(v366);
        if (v368 == -632)
        {
LABEL_164:
          while (v104)
          {
            v105 = *v104;
            if (v105 > 0x3F)
              break;
            if (!*v104)
            {
              v175 = (_WORD)v104 - (_WORD)v11 + 1;
              goto LABEL_394;
            }
            v104 += v105 + 1;
            if (v368 != -632)
              goto LABEL_163;
          }
        }
        else
        {
LABEL_163:
          if ((unint64_t)v104 < v368 + 632)
            goto LABEL_164;
        }
        v175 = 257;
      }
      else
      {
        if (v12)
          v63 = mDNSLogCategory_Default_redacted;
        else
          v63 = mDNSLogCategory_mDNS;
        if (!os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
          goto LABEL_480;
        v64 = v10[12].tv_sec;
        v65 = bswap32(*(unsigned __int16 *)(v368 + 340)) >> 16;
        v66 = v11;
        v68 = v366;
        v67 = HIDWORD(v366);
        if (v368 == -632)
        {
LABEL_65:
          while (v66)
          {
            v69 = *v66;
            if (v69 > 0x3F)
              break;
            if (!*v66)
            {
              v175 = (_WORD)v66 - (_WORD)v11 + 1;
              goto LABEL_394;
            }
            v66 += v69 + 1;
            if (v368 != -632)
              goto LABEL_64;
          }
        }
        else
        {
LABEL_64:
          if ((unint64_t)v66 < v368 + 632)
            goto LABEL_65;
        }
        v175 = 257;
      }
LABEL_394:
      v191 = *(unsigned __int16 *)(a3 + 4);
      LODWORD(__tp.tv_sec) = 67111427;
      HIDWORD(__tp.tv_sec) = v64;
      LOWORD(__tp.tv_nsec) = 1024;
      *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v65;
      HIWORD(__tp.tv_nsec) = 1024;
      *(_DWORD *)v375 = a4;
      *(_WORD *)&v375[4] = 1024;
      *(_DWORD *)&v375[6] = 0;
      LOWORD(v376) = 1024;
      *(_DWORD *)((char *)&v376 + 2) = v68;
      HIWORD(v376) = 2160;
      *(_QWORD *)v377 = 1752392040;
      *(_WORD *)&v377[8] = 1040;
      *(_DWORD *)&v377[10] = v175;
      *(_WORD *)&v377[14] = 2101;
      *(_QWORD *)&v377[16] = v11;
      *(_WORD *)&v377[24] = 1024;
      *(_DWORD *)&v377[26] = v67;
      *(_WORD *)&v377[30] = 1024;
      *(_DWORD *)&v377[32] = v191;
      v102 = "[R%u->Q%u] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name: "
             "%{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: <none>";
      v103 = v63;
      goto LABEL_449;
    }
    if (v38)
    {
      v4 = 0;
      v57 = 512;
      v58 = (char *)&unk_100164380;
      if ((_DWORD)v36)
        goto LABEL_37;
    }
    else
    {
      v36 = (size_t)malloc_type_malloc(v36, 0xA172743EuLL);
      if (!v36)
        goto LABEL_624;
      v58 = (char *)v36;
      v4 = (void *)v36;
      v57 = (unsigned __int16)*v37;
      if (*v37)
      {
LABEL_37:
        __n_2 = 0;
        __n = 0;
        v59 = ResourceRecordGetRDataBytesPointer(a3, v58, v57, &__n, &__n_2, v19, v20, v21);
        if (__n_2)
          goto LABEL_480;
        p_tp = (timespec *)v59;
        v367 = (uint64_t)v10;
        if (__n >= 0x1FFuLL)
        {
          v364 = __n + 2;
          v36 = (size_t)malloc_type_malloc(v364, 0xA172743EuLL);
          if (!v36)
            goto LABEL_624;
          v61 = (__int16 *)v36;
          v60 = (timespec *)v36;
        }
        else
        {
          v60 = 0;
          v364 = 512;
          v61 = word_100164580;
        }
        if (v12)
          v169 = mDNSLogCategory_Default;
        else
          v169 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || v169 == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v169, OS_LOG_TYPE_DEFAULT))
          {
LABEL_460:
            v10 = (timespec *)v367;
            if (!v60)
              goto LABEL_480;
            v219 = v60;
            goto LABEL_466;
          }
          v170 = *(_DWORD *)(v367 + 192);
          v173 = v11;
          v357 = a1;
          v363 = v60;
          if (v368 == -632)
          {
LABEL_337:
            while (v173)
            {
              v174 = *v173;
              if (v174 > 0x3F)
                break;
              if (!*v173)
              {
                v201 = (_WORD)v173 - (_WORD)v11 + 1;
                goto LABEL_456;
              }
              v173 += v174 + 1;
              if (v368 != -632)
                goto LABEL_336;
            }
          }
          else
          {
LABEL_336:
            if ((unint64_t)v173 < v368 + 632)
              goto LABEL_337;
          }
          v201 = 257;
LABEL_456:
          v248 = v201;
          v249 = *(unsigned __int16 *)(a3 + 4);
          v250 = __n;
          v251 = __n + 2;
          if (v251 > v364)
          {
            v61 = 0;
            goto LABEL_459;
          }
        }
        else
        {
          if (v12)
            v169 = mDNSLogCategory_Default_redacted;
          else
            v169 = mDNSLogCategory_mDNS;
          if (!os_log_type_enabled(v169, OS_LOG_TYPE_DEFAULT))
            goto LABEL_460;
          v170 = *(_DWORD *)(v367 + 192);
          v171 = v11;
          v357 = a1;
          v363 = v60;
          if (v368 == -632)
          {
LABEL_326:
            while (v171)
            {
              v172 = *v171;
              if (v172 > 0x3F)
                break;
              if (!*v171)
              {
                v200 = (_WORD)v171 - (_WORD)v11 + 1;
                goto LABEL_452;
              }
              v171 += v172 + 1;
              if (v368 != -632)
                goto LABEL_325;
            }
          }
          else
          {
LABEL_325:
            if ((unint64_t)v171 < v368 + 632)
              goto LABEL_326;
          }
          v200 = 257;
LABEL_452:
          v248 = v200;
          v249 = *(unsigned __int16 *)(a3 + 4);
          v250 = __n;
          v251 = __n + 2;
          if (v251 > v364)
          {
            v61 = 0;
LABEL_459:
            LODWORD(__tp.tv_sec) = 67111939;
            HIDWORD(__tp.tv_sec) = v170;
            LOWORD(__tp.tv_nsec) = 1024;
            *(_DWORD *)((char *)&__tp.tv_nsec + 2) = a4;
            HIWORD(__tp.tv_nsec) = 1024;
            *(_DWORD *)v375 = 0;
            *(_WORD *)&v375[4] = 1024;
            *(_DWORD *)&v375[6] = v366;
            strcpy((char *)&v376, "p\bhash");
            HIBYTE(v376) = 0;
            *(_WORD *)v377 = 0;
            *(_WORD *)&v377[2] = 1040;
            *(_DWORD *)&v377[4] = v248;
            *(_WORD *)&v377[8] = 2101;
            *(_QWORD *)&v377[10] = v11;
            *(_WORD *)&v377[18] = 1024;
            *(_DWORD *)&v377[20] = HIDWORD(v366);
            *(_WORD *)&v377[24] = 1024;
            *(_DWORD *)&v377[26] = v249;
            *(_WORD *)&v377[30] = 2160;
            *(_QWORD *)&v377[32] = 1752392040;
            *(_WORD *)&v377[40] = 1040;
            *(_DWORD *)&v377[42] = v251;
            *(_WORD *)&v377[46] = 2101;
            *(_QWORD *)&v377[48] = v61;
            _os_log_impl((void *)&_mh_execute_header, v169, OS_LOG_TYPE_DEFAULT, "[R%u->mDNSQ] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P", (uint8_t *)&__tp, 0x5Au);
            a1 = v357;
            v60 = v363;
            goto LABEL_460;
          }
        }
        *v61 = __rev16(v249);
        v252 = p_tp;
        LODWORD(p_tp) = v170;
        memcpy(v61 + 1, v252, v250);
        v170 = (int)p_tp;
        goto LABEL_459;
      }
    }
    if (v12)
      v83 = mDNSLogCategory_Default;
    else
      v83 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || v83 == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT))
        goto LABEL_480;
      v84 = v10[12].tv_sec;
      v135 = v11;
      v87 = v366;
      v86 = HIDWORD(v366);
      if (v368 == -632)
      {
LABEL_242:
        while (v135)
        {
          v136 = *v135;
          if (v136 > 0x3F)
            break;
          if (!*v135)
          {
            v190 = (_WORD)v135 - (_WORD)v11 + 1;
            goto LABEL_427;
          }
          v135 += v136 + 1;
          if (v368 != -632)
            goto LABEL_241;
        }
      }
      else
      {
LABEL_241:
        if ((unint64_t)v135 < v368 + 632)
          goto LABEL_242;
      }
      v190 = 257;
    }
    else
    {
      if (v12)
        v83 = mDNSLogCategory_Default_redacted;
      else
        v83 = mDNSLogCategory_mDNS;
      if (!os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT))
        goto LABEL_480;
      v84 = v10[12].tv_sec;
      v85 = v11;
      v87 = v366;
      v86 = HIDWORD(v366);
      if (v368 == -632)
      {
LABEL_120:
        while (v85)
        {
          v88 = *v85;
          if (v88 > 0x3F)
            break;
          if (!*v85)
          {
            v190 = (_WORD)v85 - (_WORD)v11 + 1;
            goto LABEL_427;
          }
          v85 += v88 + 1;
          if (v368 != -632)
            goto LABEL_119;
        }
      }
      else
      {
LABEL_119:
        if ((unint64_t)v85 < v368 + 632)
          goto LABEL_120;
      }
      v190 = 257;
    }
LABEL_427:
    v227 = *(unsigned __int16 *)(a3 + 4);
    LODWORD(__tp.tv_sec) = 67111171;
    HIDWORD(__tp.tv_sec) = v84;
    LOWORD(__tp.tv_nsec) = 1024;
    *(_DWORD *)((char *)&__tp.tv_nsec + 2) = a4;
    HIWORD(__tp.tv_nsec) = 1024;
    *(_DWORD *)v375 = 0;
    *(_WORD *)&v375[4] = 1024;
    *(_DWORD *)&v375[6] = v87;
    strcpy((char *)&v376, "p\bhash");
    HIBYTE(v376) = 0;
    *(_WORD *)v377 = 0;
    *(_WORD *)&v377[2] = 1040;
    *(_DWORD *)&v377[4] = v190;
    *(_WORD *)&v377[8] = 2101;
    *(_QWORD *)&v377[10] = v11;
    *(_WORD *)&v377[18] = 1024;
    *(_DWORD *)&v377[20] = v86;
    *(_WORD *)&v377[24] = 1024;
    *(_DWORD *)&v377[26] = v227;
    v102 = "[R%u->mDNSQ] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name: "
           "%{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: <none>";
    v103 = v83;
    v115 = 64;
    goto LABEL_450;
  }
  v22 = *(_QWORD *)(a3 + 56);
  if (!v22)
  {
    v24 = *(unsigned __int16 *)(a2 + 340);
    v26 = (_WORD *)(a3 + 12);
    LODWORD(v25) = *(unsigned __int16 *)(a3 + 12);
    v27 = v25 < 0x201;
LABEL_17:
    if (v24)
    {
      if (v27)
      {
        v4 = 0;
        v41 = 512;
        v42 = (char *)&unk_100164380;
        if ((_DWORD)v25)
        {
LABEL_20:
          __n_2 = 0;
          __n = 0;
          v43 = ResourceRecordGetRDataBytesPointer(a3, v42, v41, &__n, &__n_2, v19, v20, v21);
          if (__n_2)
            goto LABEL_480;
          p_tp = (timespec *)v43;
          v361 = a4;
          if (__n >= 0x1FFuLL)
          {
            v45 = __n + 2;
            v36 = (size_t)malloc_type_malloc(__n + 2, 0xA172743EuLL);
            if (!v36)
              goto LABEL_624;
            v46 = (__int16 *)v36;
            v44 = (void *)v36;
          }
          else
          {
            v44 = 0;
            v45 = 512;
            v46 = word_100164580;
          }
          if (v12)
            v118 = mDNSLogCategory_Default;
          else
            v118 = mDNSLogCategory_mDNS;
          if (gSensitiveLoggingEnabled == 1 && v118 != mDNSLogCategory_State)
          {
            if (v12)
              v118 = mDNSLogCategory_Default_redacted;
            else
              v118 = mDNSLogCategory_mDNS;
            if (!os_log_type_enabled(v118, OS_LOG_TYPE_DEFAULT))
              goto LABEL_431;
            v119 = v10[12].tv_sec;
            v120 = bswap32(*(unsigned __int16 *)(v368 + 340)) >> 16;
            v121 = *(unsigned __int16 *)(a3 + 4);
            v122 = __n;
            v123 = __n + 2;
            if (v123 > v45)
            {
              v46 = 0;
LABEL_396:
              LODWORD(__tp.tv_sec) = 67111427;
              HIDWORD(__tp.tv_sec) = v119;
              LOWORD(__tp.tv_nsec) = 1024;
              *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v120;
              HIWORD(__tp.tv_nsec) = 1024;
              *(_DWORD *)v375 = v361;
              *(_WORD *)&v375[4] = 1024;
              *(_DWORD *)&v375[6] = 0;
              LOWORD(v376) = 1024;
              *(_DWORD *)((char *)&v376 + 2) = v366;
              HIWORD(v376) = 1024;
              *(_DWORD *)v377 = HIDWORD(v366);
              *(_WORD *)&v377[4] = 1024;
              *(_DWORD *)&v377[6] = v121;
              *(_WORD *)&v377[10] = 2160;
              *(_QWORD *)&v377[12] = 1752392040;
              *(_WORD *)&v377[20] = 1040;
              *(_DWORD *)&v377[22] = v123;
              *(_WORD *)&v377[26] = 2101;
              *(_QWORD *)&v377[28] = v46;
              v194 = "[R%u->Q%u] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d"
                     ", name hash: %x, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
              v195 = v118;
              v196 = 70;
LABEL_430:
              _os_log_impl((void *)&_mh_execute_header, v195, OS_LOG_TYPE_DEFAULT, v194, (uint8_t *)&__tp, v196);
              goto LABEL_431;
            }
            goto LABEL_395;
          }
          if (os_log_type_enabled(v118, OS_LOG_TYPE_DEFAULT))
          {
            v119 = v10[12].tv_sec;
            v120 = bswap32(*(unsigned __int16 *)(v368 + 340)) >> 16;
            v121 = *(unsigned __int16 *)(a3 + 4);
            v122 = __n;
            v123 = __n + 2;
            if (v123 > v45)
            {
              v46 = 0;
              goto LABEL_396;
            }
LABEL_395:
            *v46 = __rev16(v121);
            v192 = p_tp;
            LODWORD(p_tp) = v121;
            v193 = v119;
            LODWORD(v364) = v120;
            memcpy(v46 + 1, v192, v122);
            v120 = v364;
            v119 = v193;
            v121 = p_tp;
            goto LABEL_396;
          }
LABEL_431:
          a4 = v361;
          if (!v44)
            goto LABEL_480;
          v219 = v44;
          goto LABEL_466;
        }
      }
      else
      {
        v36 = (size_t)malloc_type_malloc(v25, 0xA172743EuLL);
        if (!v36)
          goto LABEL_624;
        v42 = (char *)v36;
        v4 = (void *)v36;
        v41 = (unsigned __int16)*v26;
        if (*v26)
          goto LABEL_20;
      }
      if (v12)
        v62 = mDNSLogCategory_Default;
      else
        v62 = mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || v62 == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
          goto LABEL_480;
      }
      else
      {
        if (v12)
          v62 = mDNSLogCategory_Default_redacted;
        else
          v62 = mDNSLogCategory_mDNS;
        if (!os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
          goto LABEL_480;
      }
      v99 = v10[12].tv_sec;
      v100 = bswap32(*(unsigned __int16 *)(v368 + 340));
      v101 = *(unsigned __int16 *)(a3 + 4);
      LODWORD(__tp.tv_sec) = 67110656;
      HIDWORD(__tp.tv_sec) = v99;
      LOWORD(__tp.tv_nsec) = 1024;
      *(_DWORD *)((char *)&__tp.tv_nsec + 2) = HIWORD(v100);
      HIWORD(__tp.tv_nsec) = 1024;
      *(_DWORD *)v375 = a4;
      *(_WORD *)&v375[4] = 1024;
      *(_DWORD *)&v375[6] = 0;
      LOWORD(v376) = 1024;
      *(_DWORD *)((char *)&v376 + 2) = v366;
      HIWORD(v376) = 1024;
      *(_DWORD *)v377 = HIDWORD(v366);
      *(_WORD *)&v377[4] = 1024;
      *(_DWORD *)&v377[6] = v101;
      v102 = "[R%u->Q%u] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name h"
             "ash: %x, type: %{mdns:rrtype}d, rdata: <none>";
      v103 = v62;
      goto LABEL_291;
    }
    if (v27)
    {
      v4 = 0;
      v52 = 512;
      v53 = (char *)&unk_100164380;
      if ((_DWORD)v25)
        goto LABEL_32;
    }
    else
    {
      v36 = (size_t)malloc_type_malloc(v25, 0xA172743EuLL);
      if (!v36)
        goto LABEL_624;
      v53 = (char *)v36;
      v4 = (void *)v36;
      v52 = (unsigned __int16)*v26;
      if (*v26)
      {
LABEL_32:
        __n_2 = 0;
        __n = 0;
        v54 = ResourceRecordGetRDataBytesPointer(a3, v53, v52, &__n, &__n_2, v19, v20, v21);
        if (__n_2)
          goto LABEL_480;
        p_tp = (timespec *)v54;
        v361 = a4;
        if (__n >= 0x1FFuLL)
        {
          v55 = __n + 2;
          v36 = (size_t)malloc_type_malloc(__n + 2, 0xA172743EuLL);
          if (!v36)
            goto LABEL_624;
          v56 = (__int16 *)v36;
          v44 = (void *)v36;
        }
        else
        {
          v44 = 0;
          v55 = 512;
          v56 = word_100164580;
        }
        if (v12)
          v164 = mDNSLogCategory_Default;
        else
          v164 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || v164 == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v164, OS_LOG_TYPE_DEFAULT))
            goto LABEL_431;
          v165 = v10[12].tv_sec;
          v166 = *(unsigned __int16 *)(a3 + 4);
          v167 = __n;
          v168 = __n + 2;
          if (v168 > v55)
          {
            v56 = 0;
            goto LABEL_429;
          }
        }
        else
        {
          if (v12)
            v164 = mDNSLogCategory_Default_redacted;
          else
            v164 = mDNSLogCategory_mDNS;
          if (!os_log_type_enabled(v164, OS_LOG_TYPE_DEFAULT))
            goto LABEL_431;
          v165 = v10[12].tv_sec;
          v166 = *(unsigned __int16 *)(a3 + 4);
          v167 = __n;
          v168 = __n + 2;
          if (v168 > v55)
          {
            v56 = 0;
LABEL_429:
            LODWORD(__tp.tv_sec) = 67111171;
            HIDWORD(__tp.tv_sec) = v165;
            LOWORD(__tp.tv_nsec) = 1024;
            *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v361;
            HIWORD(__tp.tv_nsec) = 1024;
            *(_DWORD *)v375 = 0;
            *(_WORD *)&v375[4] = 1024;
            *(_DWORD *)&v375[6] = v366;
            LOWORD(v376) = 1024;
            *(_DWORD *)((char *)&v376 + 2) = HIDWORD(v366);
            HIWORD(v376) = 1024;
            *(_DWORD *)v377 = v166;
            *(_WORD *)&v377[4] = 2160;
            *(_QWORD *)&v377[6] = 1752392040;
            *(_WORD *)&v377[14] = 1040;
            *(_DWORD *)&v377[16] = v168;
            *(_WORD *)&v377[20] = 2101;
            *(_QWORD *)&v377[22] = v56;
            v194 = "[R%u->mDNSQ] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d"
                   ", name hash: %x, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
            v195 = v164;
            v196 = 64;
            goto LABEL_430;
          }
        }
        *v56 = __rev16(v166);
        v228 = p_tp;
        LODWORD(p_tp) = v166;
        v229 = v165;
        memcpy(v56 + 1, v228, v167);
        v165 = v229;
        v166 = p_tp;
        goto LABEL_429;
      }
    }
    if (v12)
      v82 = mDNSLogCategory_Default;
    else
      v82 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || v82 == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
        goto LABEL_480;
    }
    else
    {
      if (v12)
        v82 = mDNSLogCategory_Default_redacted;
      else
        v82 = mDNSLogCategory_mDNS;
      if (!os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
        goto LABEL_480;
    }
    v133 = v10[12].tv_sec;
    v134 = *(unsigned __int16 *)(a3 + 4);
    LODWORD(__tp.tv_sec) = 67110400;
    HIDWORD(__tp.tv_sec) = v133;
    LOWORD(__tp.tv_nsec) = 1024;
    *(_DWORD *)((char *)&__tp.tv_nsec + 2) = a4;
    HIWORD(__tp.tv_nsec) = 1024;
    *(_DWORD *)v375 = 0;
    *(_WORD *)&v375[4] = 1024;
    *(_DWORD *)&v375[6] = v366;
    LOWORD(v376) = 1024;
    *(_DWORD *)((char *)&v376 + 2) = HIDWORD(v366);
    HIWORD(v376) = 1024;
    *(_DWORD *)v377 = v134;
    v102 = "[R%u->mDNSQ] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name h"
           "ash: %x, type: %{mdns:rrtype}d, rdata: <none>";
    v103 = v82;
    v115 = 38;
    goto LABEL_450;
  }
  v23 = dnssec_obj_resource_record_member_get_validation_result(v22);
  v24 = *(unsigned __int16 *)(a2 + 340);
  v26 = (_WORD *)(a3 + 12);
  v25 = *(unsigned __int16 *)(a3 + 12);
  v27 = v25 < 0x201;
  if (!v23)
    goto LABEL_17;
  if (!v24)
  {
    if (v25 >= 0x201)
    {
      v36 = (size_t)malloc_type_malloc(v25, 0xA172743EuLL);
      if (!v36)
        goto LABEL_624;
      v71 = (char *)v36;
      v4 = (void *)v36;
      v70 = (unsigned __int16)*v26;
      if (*v26)
      {
LABEL_72:
        __n_2 = 0;
        __n = 0;
        v72 = ResourceRecordGetRDataBytesPointer(a3, v71, v70, &__n, &__n_2, v19, v20, v21);
        if (__n_2)
          goto LABEL_480;
        v73 = (const void *)v72;
        v360 = a4;
        p_tp = v10;
        if (__n >= 0x1FFuLL)
        {
          v74 = __n + 2;
          v36 = (size_t)malloc_type_malloc(__n + 2, 0xA172743EuLL);
          if (!v36)
            goto LABEL_624;
          v75 = (__int16 *)v36;
          v364 = v36;
        }
        else
        {
          v364 = 0;
          v74 = 512;
          v75 = word_100164580;
        }
        if (v12)
          v176 = mDNSLogCategory_Default;
        else
          v176 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || v176 == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v176, OS_LOG_TYPE_DEFAULT))
          {
LABEL_464:
            v10 = p_tp;
LABEL_465:
            a4 = v360;
            v219 = (void *)v364;
            if (!v364)
              goto LABEL_480;
            goto LABEL_466;
          }
          v177 = p_tp[12].tv_sec;
          v178 = *(unsigned __int16 *)(a3 + 4);
          v179 = __n;
          v180 = __n + 2;
          if (v180 > v74)
          {
            v75 = 0;
            goto LABEL_463;
          }
        }
        else
        {
          if (v12)
            v176 = mDNSLogCategory_Default_redacted;
          else
            v176 = mDNSLogCategory_mDNS;
          if (!os_log_type_enabled(v176, OS_LOG_TYPE_DEFAULT))
            goto LABEL_464;
          v177 = p_tp[12].tv_sec;
          v178 = *(unsigned __int16 *)(a3 + 4);
          v179 = __n;
          v180 = __n + 2;
          if (v180 > v74)
          {
            v75 = 0;
LABEL_463:
            LODWORD(__tp.tv_sec) = 67111427;
            HIDWORD(__tp.tv_sec) = v177;
            LOWORD(__tp.tv_nsec) = 1024;
            *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v360;
            HIWORD(__tp.tv_nsec) = 1024;
            *(_DWORD *)v375 = 0;
            *(_WORD *)&v375[4] = 1024;
            *(_DWORD *)&v375[6] = v366;
            LOWORD(v376) = 1024;
            *(_DWORD *)((char *)&v376 + 2) = HIDWORD(v366);
            HIWORD(v376) = 1026;
            *(_DWORD *)v377 = v23;
            *(_WORD *)&v377[4] = 1024;
            *(_DWORD *)&v377[6] = v178;
            *(_WORD *)&v377[10] = 2160;
            *(_QWORD *)&v377[12] = 1752392040;
            *(_WORD *)&v377[20] = 1040;
            *(_DWORD *)&v377[22] = v180;
            *(_WORD *)&v377[26] = 2101;
            *(_QWORD *)&v377[28] = v75;
            _os_log_impl((void *)&_mh_execute_header, v176, OS_LOG_TYPE_DEFAULT, "[R%u->mDNSQ] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P", (uint8_t *)&__tp, 0x46u);
            goto LABEL_464;
          }
        }
        *v75 = __rev16(v178);
        v253 = v73;
        v254 = v178;
        v255 = v177;
        memcpy(v75 + 1, v253, v179);
        v177 = v255;
        v178 = v254;
        goto LABEL_463;
      }
    }
    else
    {
      v4 = 0;
      v70 = 512;
      v71 = (char *)&unk_100164380;
      if (*(_WORD *)(a3 + 12))
        goto LABEL_72;
    }
    if (v12)
      v96 = mDNSLogCategory_Default;
    else
      v96 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || v96 == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT))
        goto LABEL_480;
    }
    else
    {
      if (v12)
        v96 = mDNSLogCategory_Default_redacted;
      else
        v96 = mDNSLogCategory_mDNS;
      if (!os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT))
        goto LABEL_480;
    }
    v160 = v10[12].tv_sec;
    v161 = *(unsigned __int16 *)(a3 + 4);
    LODWORD(__tp.tv_sec) = 67110656;
    HIDWORD(__tp.tv_sec) = v160;
    LOWORD(__tp.tv_nsec) = 1024;
    *(_DWORD *)((char *)&__tp.tv_nsec + 2) = a4;
    HIWORD(__tp.tv_nsec) = 1024;
    *(_DWORD *)v375 = 0;
    *(_WORD *)&v375[4] = 1024;
    *(_DWORD *)&v375[6] = v366;
    LOWORD(v376) = 1024;
    *(_DWORD *)((char *)&v376 + 2) = HIDWORD(v366);
    HIWORD(v376) = 1026;
    *(_DWORD *)v377 = v23;
    *(_WORD *)&v377[4] = 1024;
    *(_DWORD *)&v377[6] = v161;
    v102 = "[R%u->mDNSQ] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name h"
           "ash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: <none>";
    v103 = v96;
LABEL_291:
    v115 = 44;
    goto LABEL_450;
  }
  if (v25 >= 0x201)
  {
    v36 = (size_t)malloc_type_malloc(v25, 0xA172743EuLL);
    if (!v36)
      goto LABEL_624;
    v29 = (char *)v36;
    v4 = (void *)v36;
    v28 = (unsigned __int16)*v26;
    if (*v26)
    {
LABEL_8:
      __n_2 = 0;
      __n = 0;
      v30 = ResourceRecordGetRDataBytesPointer(a3, v29, v28, &__n, &__n_2, v19, v20, v21);
      if (__n_2)
        goto LABEL_480;
      v31 = (const void *)v30;
      v367 = (uint64_t)v10;
      v360 = a4;
      if (__n >= 0x1FFuLL)
      {
        v32 = __n + 2;
        v36 = (size_t)malloc_type_malloc(__n + 2, 0xA172743EuLL);
        if (!v36)
          goto LABEL_624;
        p_tp = (timespec *)v36;
        v364 = v36;
      }
      else
      {
        v364 = 0;
        v32 = 512;
        p_tp = (timespec *)word_100164580;
      }
      if (v12)
        v137 = mDNSLogCategory_Default;
      else
        v137 = mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || v137 == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled(v137, OS_LOG_TYPE_DEFAULT))
        {
LABEL_424:
          v10 = (timespec *)v367;
          goto LABEL_465;
        }
        v150 = *(_DWORD *)(v367 + 192);
        v151 = bswap32(*(unsigned __int16 *)(v368 + 340)) >> 16;
        v152 = *(unsigned __int16 *)(a3 + 4);
        v153 = __n;
        v154 = __n + 2;
        if (v154 <= v32)
        {
          v155 = p_tp;
          LOWORD(p_tp->tv_sec) = __rev16(v152);
          v224 = (char *)&p_tp->tv_sec + 2;
          v225 = v31;
          LODWORD(p_tp) = v150;
          v226 = v151;
          memcpy(v224, v225, v153);
          v151 = v226;
          v150 = (int)p_tp;
        }
        else
        {
          v155 = 0;
        }
        LODWORD(__tp.tv_sec) = 67111683;
        HIDWORD(__tp.tv_sec) = v150;
        LOWORD(__tp.tv_nsec) = 1024;
        *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v151;
        HIWORD(__tp.tv_nsec) = 1024;
        *(_DWORD *)v375 = v360;
        *(_WORD *)&v375[4] = 1024;
        *(_DWORD *)&v375[6] = 0;
        LOWORD(v376) = 1024;
        *(_DWORD *)((char *)&v376 + 2) = v366;
        HIWORD(v376) = 1024;
        *(_DWORD *)v377 = HIDWORD(v366);
        *(_WORD *)&v377[4] = 1026;
        *(_DWORD *)&v377[6] = v23;
        *(_WORD *)&v377[10] = 1024;
        *(_DWORD *)&v377[12] = v152;
        *(_WORD *)&v377[16] = 2160;
        *(_QWORD *)&v377[18] = 1752392040;
        *(_WORD *)&v377[26] = 1040;
        *(_DWORD *)&v377[28] = v154;
        *(_WORD *)&v377[32] = 2101;
        *(_QWORD *)&v377[34] = v155;
        v223 = v137;
      }
      else
      {
        if (v12)
          v138 = mDNSLogCategory_Default_redacted;
        else
          v138 = mDNSLogCategory_mDNS;
        if (!os_log_type_enabled(v138, OS_LOG_TYPE_DEFAULT))
          goto LABEL_424;
        v139 = *(_DWORD *)(v367 + 192);
        v140 = bswap32(*(unsigned __int16 *)(v368 + 340)) >> 16;
        v141 = *(unsigned __int16 *)(a3 + 4);
        v142 = __n;
        v143 = __n + 2;
        if (v143 <= v32)
        {
          v144 = p_tp;
          LOWORD(p_tp->tv_sec) = __rev16(v141);
          v220 = (char *)&p_tp->tv_sec + 2;
          v221 = v31;
          LODWORD(p_tp) = v139;
          v222 = v140;
          memcpy(v220, v221, v142);
          v140 = v222;
          v139 = (int)p_tp;
        }
        else
        {
          v144 = 0;
        }
        LODWORD(__tp.tv_sec) = 67111683;
        HIDWORD(__tp.tv_sec) = v139;
        LOWORD(__tp.tv_nsec) = 1024;
        *(_DWORD *)((char *)&__tp.tv_nsec + 2) = v140;
        HIWORD(__tp.tv_nsec) = 1024;
        *(_DWORD *)v375 = v360;
        *(_WORD *)&v375[4] = 1024;
        *(_DWORD *)&v375[6] = 0;
        LOWORD(v376) = 1024;
        *(_DWORD *)((char *)&v376 + 2) = v366;
        HIWORD(v376) = 1024;
        *(_DWORD *)v377 = HIDWORD(v366);
        *(_WORD *)&v377[4] = 1026;
        *(_DWORD *)&v377[6] = v23;
        *(_WORD *)&v377[10] = 1024;
        *(_DWORD *)&v377[12] = v141;
        *(_WORD *)&v377[16] = 2160;
        *(_QWORD *)&v377[18] = 1752392040;
        *(_WORD *)&v377[26] = 1040;
        *(_DWORD *)&v377[28] = v143;
        *(_WORD *)&v377[32] = 2101;
        *(_QWORD *)&v377[34] = v144;
        v223 = v138;
      }
      _os_log_impl((void *)&_mh_execute_header, v223, OS_LOG_TYPE_DEFAULT, "[R%u->Q%u] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P", (uint8_t *)&__tp, 0x4Cu);
      goto LABEL_424;
    }
  }
  else
  {
    v4 = 0;
    v28 = 512;
    v29 = (char *)&unk_100164380;
    if (*(_WORD *)(a3 + 12))
      goto LABEL_8;
  }
  if (v12)
    v78 = mDNSLogCategory_Default;
  else
    v78 = mDNSLogCategory_mDNS;
  if (gSensitiveLoggingEnabled != 1 || v78 == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
      goto LABEL_480;
    goto LABEL_186;
  }
  if (v12)
    v78 = mDNSLogCategory_Default_redacted;
  else
    v78 = mDNSLogCategory_mDNS;
  if (os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
  {
LABEL_186:
    v112 = v10[12].tv_sec;
    v113 = bswap32(*(unsigned __int16 *)(v368 + 340));
    v114 = *(unsigned __int16 *)(a3 + 4);
    LODWORD(__tp.tv_sec) = 67110912;
    HIDWORD(__tp.tv_sec) = v112;
    LOWORD(__tp.tv_nsec) = 1024;
    *(_DWORD *)((char *)&__tp.tv_nsec + 2) = HIWORD(v113);
    HIWORD(__tp.tv_nsec) = 1024;
    *(_DWORD *)v375 = a4;
    *(_WORD *)&v375[4] = 1024;
    *(_DWORD *)&v375[6] = 0;
    LOWORD(v376) = 1024;
    *(_DWORD *)((char *)&v376 + 2) = v366;
    HIWORD(v376) = 1024;
    *(_DWORD *)v377 = HIDWORD(v366);
    *(_WORD *)&v377[4] = 1026;
    *(_DWORD *)&v377[6] = v23;
    *(_WORD *)&v377[10] = 1024;
    *(_DWORD *)&v377[12] = v114;
    v102 = "[R%u->Q%u] DNSServiceResolve result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name has"
           "h: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: <none>";
    v103 = v78;
    v115 = 50;
LABEL_450:
    _os_log_impl((void *)&_mh_execute_header, v103, OS_LOG_TYPE_DEFAULT, v102, (uint8_t *)&__tp, v115);
  }
LABEL_480:
  if (v4)
    free(v4);
  v267 = *(unsigned __int16 *)(a3 + 4);
  if (v267 != 33 && v267 != 16)
    return;
  v268 = v10[8].tv_sec;
  if (!a4)
  {
    if (v267 == 33)
    {
      v271 = *(void **)(v268 + 1392);
      if (v271)
      {
        free(v271);
        *(_QWORD *)(v268 + 1392) = 0;
      }
      *(_WORD *)(v268 + 1408) = 0;
LABEL_530:
      *(_BYTE *)(v268 + 1417) = 0;
      goto LABEL_531;
    }
    v273 = *(void **)(v268 + 1400);
    if (v273)
    {
      free(v273);
      *(_QWORD *)(v268 + 1400) = 0;
    }
    *(_WORD *)(v268 + 1410) = 0;
LABEL_515:
    *(_BYTE *)(v268 + 1418) = 0;
    goto LABEL_531;
  }
  v269 = *(unsigned __int8 *)a3;
  if (v267 != 33)
  {
    v272 = *(void **)(v268 + 1400);
    if (v272)
    {
      free(v272);
      *(_QWORD *)(v268 + 1400) = 0;
    }
    if (v269 == 240)
    {
      *(_WORD *)(v268 + 1410) = 0;
      *(_BYTE *)(v268 + 1418) = 1;
      goto LABEL_531;
    }
    v280 = *(_QWORD *)(a3 + 40);
    v281 = *(unsigned __int16 *)(a3 + 12);
    if (v281 <= 1)
      v282 = 1;
    else
      v282 = *(unsigned __int16 *)(a3 + 12);
    v36 = (size_t)malloc_type_calloc(1uLL, v282, 0xF1748037uLL);
    if (!v36)
      goto LABEL_624;
    *(_QWORD *)(v268 + 1400) = v36;
    memcpy((void *)v36, (const void *)(v280 + 4), v281);
    *(_WORD *)(v268 + 1410) = v281;
    goto LABEL_515;
  }
  v270 = *(void **)(v268 + 1392);
  if (v270)
  {
    free(v270);
    *(_QWORD *)(v268 + 1392) = 0;
  }
  if (v269 == 240)
  {
    *(_WORD *)(v268 + 1408) = 0;
    *(_BYTE *)(v268 + 1417) = 1;
    goto LABEL_531;
  }
  v274 = *(_QWORD *)(a3 + 40);
  v275 = (_BYTE *)(v274 + 10);
  v276 = v274 + 266;
  v277 = (_BYTE *)(v274 + 10);
  if (!v276)
    goto LABEL_505;
LABEL_502:
  LOWORD(v278) = 257;
  if ((unint64_t)v277 >= v276 || !v277)
    goto LABEL_518;
  while (1)
  {
    v279 = *v277;
    if (v279 > 0x3F)
    {
LABEL_516:
      LOWORD(v278) = 257;
      goto LABEL_518;
    }
    if (!*v277)
      break;
    v277 += v279 + 1;
    if (v276)
      goto LABEL_502;
LABEL_505:
    if (!v277)
      goto LABEL_516;
  }
  v278 = (unsigned __int16)((_WORD)v277 - (_WORD)v275) + 1;
  if ((v278 & 0x10000) == 0)
  {
LABEL_518:
    v36 = (size_t)malloc_type_calloc(1uLL, (unsigned __int16)v278, 0xF1748037uLL);
    if (!v36)
      goto LABEL_624;
    *(_QWORD *)(v268 + 1392) = v36;
    v283 = v275;
    if (v276)
    {
LABEL_520:
      if ((unint64_t)v283 < v276)
        goto LABEL_521;
    }
    else
    {
LABEL_521:
      while (v283)
      {
        v284 = *v283;
        if (v284 > 0x3F)
          break;
        if (!*v283)
        {
          v285 = (_WORD)v283 - (_WORD)v275 + 1;
          if (v285 > 0x100u)
            break;
          memcpy((void *)v36, v275, v285);
          goto LABEL_529;
        }
        v283 += v284 + 1;
        if (v276)
          goto LABEL_520;
      }
    }
    *(_BYTE *)v36 = 0;
LABEL_529:
    *(_WORD *)(v268 + 1408) = *(_WORD *)(*(_QWORD *)(a3 + 40) + 8);
    goto LABEL_530;
  }
LABEL_531:
  if (*(_BYTE *)(v268 + 1417))
    v286 = 1;
  else
    v286 = *(_QWORD *)(v268 + 1392) != 0;
  if (*(_BYTE *)(v268 + 1418))
  {
    v287 = 1;
    if (!v286)
      return;
  }
  else
  {
    v287 = *(_QWORD *)(v268 + 1400) != 0;
    if (!v286)
      return;
  }
  if (v287)
  {
    v288 = -65549;
    LODWORD(v363) = *(unsigned __int8 *)(v268 + 1417);
    if (*(_BYTE *)(v268 + 1417))
      v289 = -65554;
    else
      v289 = 0;
    LODWORD(v362) = v289;
    ConvertDomainNameToCString_withescape(*(unsigned __int8 **)(a3 + 32), (unsigned __int8 *)__s);
    if (*(_BYTE *)(v268 + 1417))
    {
      LODWORD(p_tp) = 0;
      v366 = 0;
      LOBYTE(__n) = 0;
    }
    else
    {
      LODWORD(p_tp) = -2128831035;
      v295 = *(unsigned __int8 **)(v268 + 1392);
      v296 = v295;
      if (v295 == (unsigned __int8 *)-256)
      {
LABEL_546:
        while (v296)
        {
          v297 = *v296;
          if (v297 > 0x3F)
            break;
          if (!*v296)
          {
            v299 = (_WORD)v296 - (_WORD)v295 + 1;
            ConvertDomainNameToCString_withescape(*(unsigned __int8 **)(v268 + 1392), (unsigned __int8 *)&__src);
            LODWORD(v298) = v299;
            if (!v299)
              goto LABEL_555;
            goto LABEL_553;
          }
          v296 += v297 + 1;
          if (v295 != (unsigned __int8 *)-256)
            goto LABEL_545;
        }
      }
      else
      {
LABEL_545:
        if (v296 < v295 + 256)
          goto LABEL_546;
      }
      ConvertDomainNameToCString_withescape(*(unsigned __int8 **)(v268 + 1392), (unsigned __int8 *)&__src);
      LODWORD(v298) = 257;
LABEL_553:
      v298 = v298;
      do
      {
        v300 = *v295++;
        LODWORD(p_tp) = 16777619 * (p_tp ^ v300);
        --v298;
      }
      while (v298);
LABEL_555:
      v301 = *(unsigned __int8 *)(v268 + 1417);
      LOBYTE(__n) = 0;
      if (!v301)
      {
        p_n = *(unsigned __int8 **)(v268 + 1392);
        LODWORD(v366) = *(unsigned __int8 *)(v268 + 1409);
        HIDWORD(v366) = *(unsigned __int8 *)(v268 + 1408);
        goto LABEL_558;
      }
      v366 = 0;
    }
    p_n = (unsigned __int8 *)&__n;
LABEL_558:
    if (*(_BYTE *)(v268 + 1418))
    {
      v303 = 0;
      v364 = (size_t)&__n;
    }
    else
    {
      v364 = *(_QWORD *)(v268 + 1400);
      v303 = *(unsigned __int16 *)(v268 + 1410);
    }
    LODWORD(v4) = mDNSPlatformInterfaceIndexfromInterfaceID(a1, *(_QWORD *)(a3 + 24), 0, v290, v291, v292, v293, v294);
    v304 = strlen(__s);
    a3 = v303;
    a1 = (uint64_t **)(v304 + v303 + strlen(&__src) + 18);
    v367 = (uint64_t)v10;
    if (!BYTE2(v10[17].tv_nsec))
    {
      v311 = 0;
      v315 = 0;
      v310 = 0;
      goto LABEL_571;
    }
    v359 = p_n;
    v310 = 0;
    v311 = 0;
    if (!a4 || (v312 = *(_QWORD *)(v367 + 56)) == 0)
    {
      v315 = 0;
      goto LABEL_571;
    }
    if (*(_UNKNOWN ***)(v312 + 16) != &_mdns_signed_browse_result_kind)
    {
      v313 = mDNSLogCategory_mDNS;
      v314 = v368;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
        {
LABEL_589:
          v330 = *(_DWORD *)(v367 + 192);
          v331 = bswap32(*(unsigned __int16 *)(v368 + 340));
          LODWORD(__tp.tv_sec) = 67109376;
          HIDWORD(__tp.tv_sec) = v330;
          LOWORD(__tp.tv_nsec) = 1024;
          *(_DWORD *)((char *)&__tp.tv_nsec + 2) = HIWORD(v331);
          _os_log_impl((void *)&_mh_execute_header, v313, OS_LOG_TYPE_ERROR, "[R%u->Q%u] resolve_result_callback mdns_signed_resolve_result_downcast failed", (uint8_t *)&__tp, 0xEu);
        }
      }
      else
      {
        v313 = mDNSLogCategory_mDNS_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
          goto LABEL_589;
      }
      v311 = 0;
LABEL_591:
      v316 = v362;
      v332 = mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
        {
LABEL_596:
          v333 = *(_DWORD *)(v367 + 192);
          v334 = bswap32(*(unsigned __int16 *)(v314 + 340));
          LODWORD(__tp.tv_sec) = 67109632;
          HIDWORD(__tp.tv_sec) = v333;
          LOWORD(__tp.tv_nsec) = 1024;
          *(_DWORD *)((char *)&__tp.tv_nsec + 2) = HIWORD(v334);
          HIWORD(__tp.tv_nsec) = 2048;
          *(_QWORD *)v375 = v288;
          _os_log_impl((void *)&_mh_execute_header, v332, OS_LOG_TYPE_ERROR, "[R%u->Q%u] resolve_result_callback signed_resolve failed %ld", (uint8_t *)&__tp, 0x18u);
        }
      }
      else
      {
        v332 = mDNSLogCategory_mDNS_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
          goto LABEL_596;
      }
      v315 = 0;
      v310 = 0;
LABEL_598:
      v335 = (unint64_t)a1;
      reply = create_reply((char *)0x43, (uint64_t)a1, v367, v305, v306, v307, v308, v309);
      *((_DWORD *)reply + 11) = 0;
      *((_DWORD *)reply + 12) = bswap32(v4);
      *((_DWORD *)reply + 13) = bswap32(v316);
      v337 = strlen(__s) + 1;
      memcpy(reply + 56, __s, v337);
      v338 = &reply[v337 + 56];
      v339 = strlen(&__src) + 1;
      memcpy(v338, &__src, v339);
      v340 = &v338[v339];
      *v340 = BYTE4(v366);
      v340[1] = v366;
      v340[2] = BYTE1(a3);
      v341 = &v338[v339 + 4];
      v340[3] = a3;
      memcpy(v341, (const void *)v364, a3);
      if (v315)
      {
        v342 = &v341[a3];
        if (&v341[a3])
        {
          if (v342 <= &v342[v335] && v335 >= (unint64_t)v310 + 4)
          {
            *(_WORD *)v342 = 1792;
            v342[2] = BYTE1(v310);
            v342[3] = v310;
            if (v310)
              memcpy(v342 + 4, v315, v310);
          }
        }
        *((_DWORD *)reply + 6) |= 2u;
      }
      if (v311)
        os_release(v311);
      v343 = gSensitiveLoggingEnabled;
      v344 = mDNSLogCategory_mDNS;
      if (mDNSLogCategory_mDNS == mDNSLogCategory_State)
        v343 = 0;
      if ((_DWORD)v363)
      {
        v345 = v367;
        if ((v343 & 1) != 0)
        {
          v344 = mDNSLogCategory_mDNS_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
            goto LABEL_617;
        }
        else if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
        {
LABEL_617:
          v346 = *(_DWORD *)(v367 + 192);
          v347 = bswap32(*(unsigned __int16 *)(v368 + 340));
          LODWORD(__tp.tv_sec) = 67110147;
          HIDWORD(__tp.tv_sec) = v346;
          LOWORD(__tp.tv_nsec) = 1024;
          *(_DWORD *)((char *)&__tp.tv_nsec + 2) = HIWORD(v347);
          HIWORD(__tp.tv_nsec) = 2160;
          *(_QWORD *)v375 = 1752392040;
          *(_WORD *)&v375[8] = 2085;
          v376 = __s;
          *(_WORD *)v377 = 1024;
          *(_DWORD *)&v377[2] = v365;
          v348 = "[R%d->Q%d] DNSServiceResolve(%{sensitive, mask.hash}s (%x)) NoSuchRecord";
          v349 = v344;
          v350 = 40;
LABEL_620:
          _os_log_impl((void *)&_mh_execute_header, v349, OS_LOG_TYPE_DEFAULT, v348, (uint8_t *)&__tp, v350);
        }
LABEL_621:
        append_reply(v345, reply);
        return;
      }
      v345 = v367;
      if ((v343 & 1) != 0)
      {
        v344 = mDNSLogCategory_mDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
          goto LABEL_621;
      }
      else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
        goto LABEL_621;
      }
      v351 = *(_DWORD *)(v367 + 192);
      v352 = bswap32(*(unsigned __int16 *)(v368 + 340));
      LODWORD(__tp.tv_sec) = 67111171;
      HIDWORD(__tp.tv_sec) = v351;
      LOWORD(__tp.tv_nsec) = 1024;
      *(_DWORD *)((char *)&__tp.tv_nsec + 2) = HIWORD(v352);
      HIWORD(__tp.tv_nsec) = 2160;
      *(_QWORD *)v375 = 1752392040;
      *(_WORD *)&v375[8] = 2085;
      v376 = __s;
      *(_WORD *)v377 = 1024;
      *(_DWORD *)&v377[2] = v365;
      *(_WORD *)&v377[6] = 2160;
      *(_QWORD *)&v377[8] = 1752392040;
      *(_WORD *)&v377[16] = 2085;
      *(_QWORD *)&v377[18] = &__src;
      *(_WORD *)&v377[26] = 1024;
      *(_DWORD *)&v377[28] = (_DWORD)p_tp;
      *(_WORD *)&v377[32] = 1024;
      *(_DWORD *)&v377[34] = __rev16(HIDWORD(v366) | ((_DWORD)v366 << 8));
      v348 = "[R%d->Q%d] DNSServiceResolve(%{sensitive, mask.hash}s (%x)) RESULT   %{sensitive, mask.hash}s (%x):%d";
      v349 = v344;
      v350 = 72;
      goto LABEL_620;
    }
    bzero(&__tp, 0x3F1uLL);
    LODWORD(v36) = DomainNameToString(v359, 0, (unsigned __int8 *)&__tp, 0);
    if ((_DWORD)v36)
      goto LABEL_625;
    v317 = *(_QWORD *)(v312 + 32);
    v318 = strlen((const char *)&__tp);
    if (v318 >> 16)
    {
      v311 = 0;
      v288 = -6743;
      goto LABEL_630;
    }
    v319 = v318;
    v320 = v318 + *(unsigned __int16 *)(v317 + 56) + 62;
    v36 = (size_t)malloc_type_calloc(1uLL, v320, 0xF1748037uLL);
    if (v36)
    {
      v321 = v36;
      v322 = v36 + 32;
      uuid_copy((unsigned __int8 *)(v36 + 32), (const unsigned __int8 *)(v317 + 32));
      v323 = _mdns_signed_result_compute_metadata_hash(v322, v4, (unsigned __int8 *)v364, a3);
      *(_DWORD *)(v321 + 48) = 6;
      *(_DWORD *)(v321 + 52) = v323;
      v324 = *(unsigned __int16 *)(v317 + 56);
      *(_WORD *)(v321 + 56) = v324;
      *(_WORD *)(v321 + 58) = WORD2(v366) | ((_WORD)v366 << 8);
      *(_WORD *)(v321 + 60) = v319;
      memcpy((void *)(v321 + 62), (const void *)(v317 + 58), v324);
      memcpy((void *)(v321 + 62 + v324), &__tp, v319);
      v325 = _mdns_necp_sign_result(v321, v320);
      if (v325)
      {
        v288 = v325;
      }
      else
      {
        v288 = _mdns_necp_validate_result(v321, v320);
        __n_2 = v288;
        if (!v288)
        {
          v326 = _mdns_signed_resolve_result_create_no_copy(v359, v321, v320, &__n_2);
          v311 = (void *)v326;
          v288 = __n_2;
          if (!__n_2)
          {
            v314 = v368;
            if (!v326)
            {
              v288 = 0;
              goto LABEL_591;
            }
            __tp.tv_sec = 0;
            data = mdns_signed_result_get_data(v326, &__tp);
            v328 = __tp.tv_sec;
            if (__tp.tv_sec >= 0x10000uLL)
              v328 = 0;
            v310 = v328;
            if (__tp.tv_sec >= 0x10000uLL)
              v329 = 0;
            else
              v329 = LOWORD(__tp.tv_sec) + 4;
            a1 = (uint64_t **)((char *)a1 + v329);
            if (__tp.tv_sec >= 0x10000uLL)
              v315 = 0;
            else
              v315 = data;
LABEL_571:
            v316 = v362;
            goto LABEL_598;
          }
          goto LABEL_629;
        }
      }
      v311 = 0;
LABEL_629:
      free((void *)v321);
      goto LABEL_630;
    }
LABEL_624:
    __break(1u);
LABEL_625:
    v288 = v36;
    v311 = 0;
LABEL_630:
    v314 = v368;
    goto LABEL_591;
  }
}

uint64_t _handle_resolve_request_with_trust(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v4;
  __int128 v5;
  char *v6;
  NSObject *v7;
  int v10;
  int v11;
  int v13;
  _BYTE buf[32];

  v4 = *(_QWORD *)(a1 + 32);
  if (v4)
  {
    v13 = 0;
    v5 = *(_OWORD *)(v4 + 40);
    *(_OWORD *)buf = *(_OWORD *)(v4 + 24);
    *(_OWORD *)&buf[16] = v5;
    v6 = (char *)&loc_1000A2664
       + *((int *)qword_1000A28E0 + mdns_trust_checks_check(buf, 0, 0, a2, 0, 1, &v13));
    __asm { BR              X10 }
  }
  v7 = mDNSLogCategory_mDNS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
    {
LABEL_11:
      v10 = *(_DWORD *)(a1 + 192);
      v11 = *(_DWORD *)(a1 + 180);
      *(_DWORD *)buf = 67109634;
      *(_DWORD *)&buf[4] = v10;
      *(_WORD *)&buf[8] = 2080;
      *(_QWORD *)&buf[10] = a1 + 248;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v11;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "[R%u] _handle_resolve_request_with_trust: no audit token for pid(%s %d)", buf, 0x18u);
    }
  }
  else
  {
    v7 = mDNSLogCategory_mDNS_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
      goto LABEL_11;
  }
  return _handle_resolve_request_start(a1, (uint64_t)a2);
}

uint64_t _handle_resolve_request_start(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t started;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  BOOL v14;
  __uint64_t monotonic_time_ns;
  unsigned __int8 *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  unsigned int v24;
  _BYTE *v25;
  NSObject *v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _BYTE *v31;
  uint64_t v32;
  _BYTE *v33;
  uint64_t v34;
  int v35;
  _BYTE *v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  _BYTE *v42;
  _BYTE *v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  int v49;
  uint64_t v50;
  __int16 v51;
  int v52;
  __int16 v53;
  uint64_t v54;
  _OWORD v55[16];

  v4 = *(_QWORD *)(a1 + 128);
  started = mDNS_StartQuery((unsigned int *)mDNSStorage, v4 + 696);
  if (!(_DWORD)started)
  {
    v6 = mDNS_StartQuery((unsigned int *)mDNSStorage, v4);
    if ((_DWORD)v6)
    {
      started = v6;
      mDNS_StopQuery((unsigned int *)mDNSStorage, v4 + 696);
      return started;
    }
    *(_QWORD *)(a1 + 104) = resolve_termination_callback;
    if (*(_DWORD *)(a1 + 244) != -1 && IsLocalDomain((_BYTE *)(a2 + 1009)))
    {
      v12 = *(unsigned int *)(a1 + 244);
      if ((_DWORD)v12)
      {
        if (AWDLInterfaceID && AWDLInterfaceID == v12)
        {
          v13 = 1;
        }
        else
        {
          if (WiFiAwareInterfaceID)
            v14 = WiFiAwareInterfaceID == v12;
          else
            v14 = 0;
          v13 = v14;
        }
      }
      else
      {
        v13 = (*(unsigned __int8 *)(a1 + 242) >> 4) & 1;
      }
      monotonic_time_ns = _mdns_powerlog_get_monotonic_time_ns();
      _mdns_powerlog_bonjour_event(13, v13, (char *)(a1 + 248), monotonic_time_ns);
      *(_QWORD *)(a1 + 8) = monotonic_time_ns;
    }
    if (mDNS_McastLoggingEnabled)
      LogMcastQuestion(v4 + 696, a1, 1);
    v16 = (unsigned __int8 *)(a2 + 1009);
    if (!callExternalHelpers(*(_QWORD *)(a2 + 1272), (_BYTE *)(a2 + 1009), *(unsigned int *)(a1 + 240), v7, v8, v9, v10, v11))return 0;
    *(_BYTE *)(v4 + 1416) = 1;
    if (mDNS_LoggingEnabled == 1)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handle_resolve_request: calling external_start_resolving_service()", v17, v18, v19, v20, v21, v49);
    v22 = *(_QWORD *)(a2 + 1272);
    v23 = *(_DWORD *)(a1 + 240);
    v24 = *(_DWORD *)(a1 + 180);
    memset(&v55[2], 0, 224);
    if (*(_BYTE *)(a2 + 1009))
      v25 = (_BYTE *)(a2 + 1009 + *(unsigned __int8 *)(a2 + 1009) + 1);
    else
      v25 = (_BYTE *)(a2 + 1009);
    memset(v55, 0, 32);
    DomainnameToLower(v25, (uint64_t)v55);
    v26 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        goto LABEL_49;
      v33 = (_BYTE *)(a2 + 1009);
      if (a2 == -1265)
      {
LABEL_39:
        while (v33)
        {
          v34 = *v33;
          if (v34 > 0x3F)
            break;
          if (!*v33)
          {
            v35 = (unsigned __int16)((_WORD)v33 - (_WORD)v16 + 1);
            goto LABEL_48;
          }
          v33 += v34 + 1;
          if (a2 != -1265)
            goto LABEL_38;
        }
      }
      else
      {
LABEL_38:
        if ((unint64_t)v33 < a2 + 1265)
          goto LABEL_39;
      }
      v35 = 257;
    }
    else
    {
      v26 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_49;
      v31 = (_BYTE *)(a2 + 1009);
      if (a2 == -1265)
      {
LABEL_31:
        while (v31)
        {
          v32 = *v31;
          if (v32 > 0x3F)
            break;
          if (!*v31)
          {
            v35 = (unsigned __int16)((_WORD)v31 - (_WORD)v16 + 1);
            goto LABEL_48;
          }
          v31 += v32 + 1;
          if (a2 != -1265)
            goto LABEL_30;
        }
      }
      else
      {
LABEL_30:
        if ((unint64_t)v31 < a2 + 1265)
          goto LABEL_31;
      }
      v35 = 257;
    }
LABEL_48:
    v49 = 141558531;
    v50 = 1752392040;
    v51 = 1040;
    v52 = v35;
    v53 = 2101;
    v54 = a2 + 1009;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "external_start_resolving_service - fqdn: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", (uint8_t *)&v49, 0x1Cu);
LABEL_49:
    v36 = putDomainNameAsLabels((unint64_t)compression_base_msg, (unint64_t)byte_1001499E7, (unint64_t)&compression_base_msg[&unk_1000022F8], (unsigned __int8 *)v55, v27, v28, v29, v30);
    if (v36)
    {
      *(_WORD *)v36 = 3072;
      v36[2] = 1;
      v41 = (unint64_t)(v36 + 3);
    }
    else
    {
      v41 = 0;
    }
    v49 = 0;
    v42 = putDomainNameAsLabels((unint64_t)compression_base_msg, v41, (unint64_t)&compression_base_msg[&unk_1000022F8], v16, v37, v38, v39, v40);
    v43 = &v42[-v41];
    PrintHelper((uint64_t)"external_start_resolving_service", (uint64_t)byte_1001499E7, (unsigned __int16)(v41 - (unsigned __int16)byte_1001499E7), v41, (unsigned __int16)((_WORD)v42 - v41));
    v44 = xD2DMapToTransportType(v22, v23, &v49);
    if ((_DWORD)v44 == 4)
    {
      v45 = 0;
      v46 = v49;
      do
      {
        if (v46 != (_DWORD)v45 && &_D2DStartResolvingPairOnTransport)
        {
          if ((v45 & 0x7FFFFFFE) == 2)
            _mdns_powerlog_awdl_event((uint64_t)CFSTR("startAWDLResolve"), (unsigned __int8 *)v55, 12, v24);
          D2DStartResolvingPairOnTransport(byte_1001499E7, v41 - (_QWORD)byte_1001499E7, v41, v43, v45);
        }
        v45 = (v45 + 1);
      }
      while ((_DWORD)v45 != 4);
    }
    else if (&_D2DStartResolvingPairOnTransport)
    {
      v47 = v44;
      if ((v44 & 6) == 2)
        _mdns_powerlog_awdl_event((uint64_t)CFSTR("startAWDLResolve"), (unsigned __int8 *)v55, 12, v24);
      D2DStartResolvingPairOnTransport(byte_1001499E7, v41 - (_QWORD)byte_1001499E7, v41, v43, v47);
    }
    return 0;
  }
  return started;
}

unsigned __int8 *get_tracker_info_tlvs(uint64_t a1)
{
  unsigned __int8 *result;

  result = *(unsigned __int8 **)(a1 + 80);
  if (result)
  {
    if ((*(_BYTE *)(a1 + 216) & 2) != 0)
    {
      result = (unsigned __int8 *)get_tlv_uint32(result, *(_QWORD *)(a1 + 88), 8, 0);
      *(_BYTE *)(a1 + 281) = (_DWORD)result != 0;
    }
  }
  return result;
}

uint64_t _handle_queryrecord_request_with_trust(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int8 *v10;
  uint64_t v11;
  int v12;
  int v13;
  __int128 v14;
  char *v15;
  NSObject *v16;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  int v28[64];
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  char v45[64];
  _OWORD v46[16];
  uint8_t buf[4];
  int v48;
  __int16 v49;
  uint64_t v50;
  __int16 v51;
  int v52;

  if (*(_QWORD *)(a1 + 32))
  {
    bzero(buf, 0x3F1uLL);
    memset(v46, 0, sizeof(v46));
    if (!AppendDNSNameString(v46, (unsigned __int8 *)(a2 + 96), v4, v5, v6, v7, v8, v9))
      goto LABEL_5;
    v43 = 0u;
    v44 = 0u;
    v41 = 0u;
    v42 = 0u;
    v39 = 0u;
    v40 = 0u;
    v37 = 0u;
    v38 = 0u;
    v35 = 0u;
    v36 = 0u;
    v33 = 0u;
    v34 = 0u;
    v31 = 0u;
    v32 = 0u;
    v29 = 0u;
    v30 = 0u;
    if (DeconstructServiceName((char *)v46, v45, (uint64_t)&v29, v28))
    {
      v10 = buf;
      ConvertDomainNameToCString_withescape((unsigned __int8 *)&v29, buf);
    }
    else
    {
LABEL_5:
      v10 = 0;
    }
    v11 = *(_QWORD *)(a1 + 32);
    v28[0] = 0;
    v12 = *(unsigned __int16 *)(a2 + 24);
    v13 = (*(_DWORD *)(a2 + 20) >> 10) & 1;
    v14 = *(_OWORD *)(v11 + 40);
    v29 = *(_OWORD *)(v11 + 24);
    v30 = v14;
    v15 = (char *)&loc_1000A2F44
        + dword_1000A31E4[mdns_trust_checks_check(&v29, 2, (unsigned __int8 *)(a2 + 96), v10, v12, v13, v28)];
    __asm { BR              X10 }
  }
  v16 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
LABEL_15:
      v25 = *(_DWORD *)(a1 + 192);
      v26 = *(_DWORD *)(a1 + 180);
      *(_DWORD *)buf = 67109634;
      v48 = v25;
      v49 = 2080;
      v50 = a1 + 248;
      v51 = 1024;
      v52 = v26;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "[R%u] _handle_queryrecord_request_with_trust: no audit token for pid(%s %d)", buf, 0x18u);
    }
  }
  else
  {
    v16 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      goto LABEL_15;
  }
  return _handle_queryrecord_request_start(a1, a2, v19, v20, v21, v22, v23, v24);
}

uint64_t _handle_queryrecord_request_start(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t RecordClientRequestStart;
  uint64_t v12;
  int v13;
  BOOL v14;
  __uint64_t monotonic_time_ns;

  *(_QWORD *)(a1 + 104) = queryrecord_termination_callback;
  v9 = *(_QWORD *)(a1 + 136);
  RecordClientRequestStart = QueryRecordClientRequestStart(v9, a2, (uint64_t)queryrecord_result_reply, a1, a5, a6, a7, a8);
  if (!(_DWORD)RecordClientRequestStart && *(_DWORD *)(a1 + 244) != -1 && IsLocalDomain((_BYTE *)(v9 + 376)))
  {
    v12 = *(unsigned int *)(a1 + 244);
    if ((_DWORD)v12)
    {
      if (AWDLInterfaceID && AWDLInterfaceID == v12)
      {
        v13 = 1;
      }
      else
      {
        if (WiFiAwareInterfaceID)
          v14 = WiFiAwareInterfaceID == v12;
        else
          v14 = 0;
        v13 = v14;
      }
    }
    else
    {
      v13 = (*(unsigned __int8 *)(a1 + 242) >> 4) & 1;
    }
    monotonic_time_ns = _mdns_powerlog_get_monotonic_time_ns();
    _mdns_powerlog_bonjour_event(7, v13, (char *)(a1 + 248), monotonic_time_ns);
    *(_QWORD *)(a1 + 8) = monotonic_time_ns;
  }
  return RecordClientRequestStart;
}

unsigned __int16 *_get_signed_data_tlvs(uint64_t a1, uint64_t *a2)
{
  unsigned __int16 *v2;
  unsigned __int16 *result;
  uint64_t v6;
  int tlv_uint32;
  uint64_t v8;
  unsigned __int16 *v9;
  uint64_t v10;
  unsigned int v11;

  v2 = *(unsigned __int16 **)(a1 + 80);
  if (!v2 || (*(_BYTE *)(a1 + 216) & 2) == 0)
    return 0;
  v6 = *(_QWORD *)(a1 + 88);
  tlv_uint32 = get_tlv_uint32(*(unsigned __int8 **)(a1 + 80), v6, 6, 0);
  result = 0;
  if (tlv_uint32 == 1)
  {
    *(_BYTE *)(a1 + 282) = 1;
    while (v6 - (uint64_t)v2 >= 4)
    {
      v8 = 0;
      v9 = v2 + 2;
      if (v2 == (unsigned __int16 *)-4)
      {
        result = 0;
        if (!a2)
          return result;
LABEL_15:
        *a2 = v8;
        return result;
      }
      v10 = __rev16(v2[1]);
      result = 0;
      if (v6 - (uint64_t)v9 < v10)
        goto LABEL_14;
      v11 = __rev16(*v2);
      v2 = (unsigned __int16 *)((char *)v9 + v10);
      if (v11 == 7)
      {
        v8 = v10;
        result = v9;
        if (!a2)
          return result;
        goto LABEL_15;
      }
    }
    v8 = 0;
    result = 0;
LABEL_14:
    if (!a2)
      return result;
    goto LABEL_15;
  }
  return result;
}

uint64_t _handle_browse_request_with_trust(uint64_t a1, unsigned __int8 *a2)
{
  char *v4;
  unsigned __int8 *v5;
  uint64_t v6;
  __int128 v7;
  int v8;
  char v9;
  NSObject *v10;
  int v11;
  NSObject *v12;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  int v23;
  int v25;
  uint8_t v26[16];
  __int128 v27;
  _BYTE v28[256];
  _BYTE v29[256];
  _BYTE v30[64];
  uint8_t buf[4];
  int v32;
  __int16 v33;
  uint64_t v34;
  __int16 v35;
  int v36;

  if (*(_QWORD *)(a1 + 32))
  {
    bzero(buf, 0x3F1uLL);
    v4 = (char *)(*(_QWORD *)(a1 + 144) + 10);
    memset(v29, 0, sizeof(v29));
    if (DeconstructServiceName(v4, v30, (uint64_t)v29, v28))
      v5 = v29;
    else
      v5 = (unsigned __int8 *)v4;
    ConvertDomainNameToCString_withescape(v5, buf);
    v6 = *(_QWORD *)(a1 + 32);
    v25 = 0;
    v7 = *(_OWORD *)(v6 + 40);
    *(_OWORD *)v26 = *(_OWORD *)(v6 + 24);
    v27 = v7;
    v8 = mdns_trust_checks_check(v26, 0, 0, buf, 0, 1, &v25);
    v9 = v25;
    if ((v25 & 2) == 0)
      *(_BYTE *)(a1 + 282) = 0;
    if ((v9 & 4) == 0)
LABEL_25:
      __asm { BR              X10 }
    v10 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG))
      {
        v23 = *(_DWORD *)(a1 + 192);
        *(_DWORD *)v26 = 67109120;
        *(_DWORD *)&v26[4] = v23;
        goto LABEL_23;
      }
    }
    else
    {
      v10 = mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG))
      {
        v11 = *(_DWORD *)(a1 + 192);
        *(_DWORD *)v26 = 67109120;
        *(_DWORD *)&v26[4] = v11;
LABEL_23:
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "[R%u] _handle_browse_request_with_trust: has media discovery entitlement", v26, 8u);
      }
    }
    *(_BYTE *)(a1 + 282) = 1;
    goto LABEL_25;
  }
  v12 = mDNSLogCategory_mDNS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
    {
LABEL_20:
      v21 = *(_DWORD *)(a1 + 192);
      v22 = *(_DWORD *)(a1 + 180);
      *(_DWORD *)buf = 67109634;
      v32 = v21;
      v33 = 2080;
      v34 = a1 + 248;
      v35 = 1024;
      v36 = v22;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "[R%u] _handle_browse_request_with_trust: no audit token for pid(%s %d)", buf, 0x18u);
    }
  }
  else
  {
    v12 = mDNSLogCategory_mDNS_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
      goto LABEL_20;
  }
  return _handle_browse_request_start(a1, a2, v15, v16, v17, v18, v19, v20);
}

uint64_t _handle_browse_request_start(uint64_t a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  int v11;
  unsigned int v12;
  BOOL v13;
  uint64_t v14;
  char v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  _BYTE v31[31];

  memset(v31, 0, sizeof(v31));
  v30 = 0u;
  v29 = 0u;
  v28 = 0u;
  v27 = 0u;
  v26 = 0u;
  v25 = 0u;
  v24 = 0u;
  v23 = 0u;
  v22 = 0u;
  v21 = 0u;
  v20 = 0u;
  v19 = 0u;
  v18 = 0u;
  v17 = 0u;
  *(_QWORD *)(a1 + 104) = browse_termination_callback;
  if (*a2)
  {
    v16 = 0;
    if (AppendDNSNameString(&v16, a2, a3, a4, a5, a6, a7, a8))
      return add_domain_to_browser(a1, &v16);
    else
      return 4294901756;
  }
  else
  {
    v10 = AutoBrowseDomains;
    if (AutoBrowseDomains)
    {
      while (1)
      {
        v11 = *(_DWORD *)(v10 + 8);
        if (!v11 || ((v12 = *(_DWORD *)(a1 + 188), v12 >= 0x1F5) ? (v13 = v12 == v11) : (v13 = 1), v13))
        {
          v14 = add_domain_to_browser(a1, (_BYTE *)(v10 + 12));
          if ((_DWORD)v14)
          {
            v9 = v14;
            if (SameDomainNameBytes((_BYTE *)(v10 + 12), "\x05local"))
              break;
          }
        }
        v10 = *(_QWORD *)v10;
        if (!v10)
          return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return v9;
}

uint64_t _handle_regservice_request_with_trust(uint64_t a1, _BYTE *a2)
{
  uint64_t v4;
  unsigned __int8 *v5;
  __int128 v6;
  char *v7;
  NSObject *v8;
  int v11;
  int v12;
  int v14;
  _BYTE buf[32];

  v4 = *(_QWORD *)(a1 + 32);
  if (v4)
  {
    v14 = 0;
    v5 = (unsigned __int8 *)(*(_QWORD *)(a1 + 120) + 90);
    v6 = *(_OWORD *)(v4 + 40);
    *(_OWORD *)buf = *(_OWORD *)(v4 + 24);
    *(_OWORD *)&buf[16] = v6;
    v7 = (char *)&loc_1000A39EC + dword_1000A3C9C[mdns_trust_checks_check(buf, 1, 0, v5, 0, 0, &v14)];
    __asm { BR              X10 }
  }
  v8 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
LABEL_11:
      v11 = *(_DWORD *)(a1 + 192);
      v12 = *(_DWORD *)(a1 + 180);
      *(_DWORD *)buf = 67109634;
      *(_DWORD *)&buf[4] = v11;
      *(_WORD *)&buf[8] = 2080;
      *(_QWORD *)&buf[10] = a1 + 248;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v12;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "[R%u] _handle_regservice_request_with_trust: no audit token for pid(%s %d)", buf, 0x18u);
    }
  }
  else
  {
    v8 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      goto LABEL_11;
  }
  return _handle_regservice_request_start(a1, a2);
}

uint64_t _handle_regservice_request_start(uint64_t a1, _BYTE *a2)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t i;
  int v7;
  unsigned int v8;

  *(_QWORD *)(a1 + 104) = regservice_termination_callback;
  v3 = register_service_instance(a1, a2);
  if (!(_DWORD)v3)
  {
    v5 = *(_QWORD *)(a1 + 120);
    if (*(_BYTE *)(v5 + 1612))
      UpdateDeviceInfoRecord((size_t)mDNSStorage);
    if (*(_BYTE *)(v5 + 1355))
    {
      for (i = AutoRegistrationDomains; i; i = *(_QWORD *)i)
      {
        v7 = *(_DWORD *)(i + 8);
        if (v7)
        {
          v8 = *(_DWORD *)(a1 + 188);
          if (v8 >= 0x1F5 && v8 != v7)
            continue;
        }
        register_service_instance(a1, (_BYTE *)(i + 12));
      }
    }
  }
  return v3;
}

void enum_termination_callback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _BYTE *v8;

  v8 = *(_BYTE **)(a1 + 112);
  if ((*v8 & 0x80) != 0)
  {
    if (mDNS_LoggingEnabled)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: DNSServiceEnumeration Cancel WAB Registration PID[%d](%s)", a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 176));
    uDNS_StopWABQueries(4, a2, a3, a4, a5, a6, a7, a8);
  }
  else
  {
    if (mDNS_LoggingEnabled)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%3d: DNSServiceEnumeration Cancel WAB Browse PID[%d](%s)", a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 176));
    uDNS_StopWABQueries(3, a2, a3, a4, a5, a6, a7, a8);
    mDNS_StopQuery((unsigned int *)mDNSStorage, (uint64_t)(v8 + 1400));
  }
  mDNS_StopQuery((unsigned int *)mDNSStorage, (uint64_t)(v8 + 8));
  mDNS_StopQuery((unsigned int *)mDNSStorage, (uint64_t)(v8 + 704));
}

void port_mapping_create_request_callback(uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v9;
  char *reply;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned __int16 *v18;
  char v19;
  char v20;
  NSObject *v21;
  int v22;
  int v23;
  int v24;
  BOOL v25;
  unsigned int v26;
  int v27;
  int v28;
  unsigned int v29;
  unsigned int v30;
  int v31;
  _DWORD v32[2];
  __int16 v33;
  int v34;
  __int16 v35;
  unsigned int v36;
  __int16 v37;
  unsigned int v38;
  __int16 v39;
  int v40;
  __int16 v41;
  uint64_t v42;
  __int16 v43;
  int v44;
  __int16 v45;
  unsigned __int16 *v46;
  __int16 v47;
  unsigned int v48;
  __int16 v49;
  int v50;

  v9 = *(_QWORD *)(a2 + 192);
  if (!v9)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "port_mapping_create_request_callback called with unknown request_state object", a4, a5, a6, a7, a8, a9);
    return;
  }
  reply = create_reply((char *)0x47, 25, v9, a4, a5, a6, a7, a8);
  *((_DWORD *)reply + 11) = 0;
  *((_DWORD *)reply + 12) = bswap32(mDNSPlatformInterfaceIndexfromInterfaceID(a1, *(_QWORD *)(a2 + 144), 0, v13, v14, v15, v16, v17));
  *((_DWORD *)reply + 13) = bswap32(*(_DWORD *)(a2 + 168));
  v18 = *(unsigned __int16 **)(v9 + 152);
  reply[56] = *((_BYTE *)v18 + 160);
  reply[57] = *((_BYTE *)v18 + 161);
  reply[58] = *((_BYTE *)v18 + 162);
  reply[59] = *((_BYTE *)v18 + 163);
  if (*((_BYTE *)v18 + 180) == 1)
    v19 = 16;
  else
    v19 = 32;
  if (*((_BYTE *)v18 + 180))
    v20 = v19;
  else
    v20 = 0;
  reply[60] = v20;
  reply[61] = *((_BYTE *)v18 + 182);
  reply[62] = *((_BYTE *)v18 + 183);
  reply[63] = *((_BYTE *)v18 + 168);
  reply[64] = *((_BYTE *)v18 + 169);
  *(_DWORD *)(reply + 65) = bswap32(*((_DWORD *)v18 + 43));
  v21 = mDNSLogCategory_NAT;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
    {
      v22 = *(_DWORD *)(v9 + 192);
      v27 = *((unsigned __int8 *)v18 + 180);
      if (v27 == 1)
        v24 = 16;
      else
        v24 = 32;
      v25 = v27 == 0;
      v26 = v18[91];
      if (v25)
        v24 = 0;
      goto LABEL_24;
    }
  }
  else
  {
    v21 = mDNSLogCategory_NAT_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
    {
      v22 = *(_DWORD *)(v9 + 192);
      v23 = *((unsigned __int8 *)v18 + 180);
      if (v23 == 1)
        v24 = 16;
      else
        v24 = 32;
      v25 = v23 == 0;
      v26 = v18[91];
      if (v25)
        v24 = 0;
LABEL_24:
      v28 = *((_DWORD *)v18 + 47);
      v29 = bswap32(*v18) >> 16;
      v30 = bswap32(v18[84]) >> 16;
      v31 = *((_DWORD *)v18 + 43);
      v32[0] = 67111427;
      v32[1] = v22;
      v33 = 1024;
      v34 = v24;
      v35 = 1024;
      v36 = bswap32(v26) >> 16;
      v37 = 1024;
      v38 = v29;
      v39 = 1024;
      v40 = v28;
      v41 = 2160;
      v42 = 1752392040;
      v43 = 1045;
      v44 = 4;
      v45 = 2101;
      v46 = v18 + 80;
      v47 = 1024;
      v48 = v30;
      v49 = 1024;
      v50 = v31;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "[R%d] DNSServiceNATPortMappingCreate(%X, %u, %u, %d) RESULT %{sensitive, mask.hash, network:in_addr}.4P:%u TTL %u", (uint8_t *)v32, 0x46u);
    }
  }
  append_reply(v9, reply);
}

void port_mapping_termination_callback(uint64_t a1)
{
  unsigned __int16 *v2;
  NSObject *v3;
  int v5;
  int v6;
  int v7;
  int v9;
  unsigned int v10;
  unsigned int v11;
  int v12;
  int v13;
  int v14;
  timespec v15;
  unsigned int v16;
  __int16 v17;
  unsigned int v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  int v26;

  v2 = *(unsigned __int16 **)(a1 + 152);
  v3 = mDNSLogCategory_NAT;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
    {
      v5 = *(_DWORD *)(a1 + 192);
      if (*((_BYTE *)v2 + 180) == 1)
        v6 = 16;
      else
        v6 = 32;
      if (*((_BYTE *)v2 + 180))
        v7 = v6;
      else
        v7 = 0;
      goto LABEL_20;
    }
  }
  else
  {
    v3 = mDNSLogCategory_NAT_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
    {
      v5 = *(_DWORD *)(a1 + 192);
      if (*((_BYTE *)v2 + 180) == 1)
        v9 = 16;
      else
        v9 = 32;
      if (*((_BYTE *)v2 + 180))
        v7 = v9;
      else
        v7 = 0;
LABEL_20:
      v10 = bswap32(v2[91]) >> 16;
      v11 = bswap32(*v2) >> 16;
      v12 = *((_DWORD *)v2 + 47);
      v13 = *(_DWORD *)(a1 + 180);
      v15.tv_sec = 0;
      v15.tv_nsec = 0;
      clock_gettime(_CLOCK_MONOTONIC_RAW, &v15);
      v14 = LODWORD(v15.tv_sec) - *(_DWORD *)(a1 + 196);
      LODWORD(v15.tv_sec) = 67110914;
      HIDWORD(v15.tv_sec) = v5;
      LOWORD(v15.tv_nsec) = 1024;
      *(_DWORD *)((char *)&v15.tv_nsec + 2) = v7;
      HIWORD(v15.tv_nsec) = 1024;
      v16 = v10;
      v17 = 1024;
      v18 = v11;
      v19 = 1024;
      v20 = v12;
      v21 = 1024;
      v22 = v13;
      v23 = 2082;
      v24 = a1 + 248;
      v25 = 1024;
      v26 = v14;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "[R%d] DNSServiceNATPortMappingCreate(%X, %u, %u, %d) STOP PID[%d](%{public}s) -- duration: %{mdns:time_duration}u", (uint8_t *)&v15, 0x36u);
    }
  }
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNS_StopNATOperation", 1012);
  mDNS_StopNATOperation_internal((uint64_t)mDNSStorage, (uint64_t)(v2 + 4));
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNS_StopNATOperation", 1014);
}

uint64_t _handle_addrinfo_request_with_trust(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  __int128 v5;
  char *v6;
  NSObject *v7;
  int v10;
  int v11;
  int v13;
  _BYTE buf[32];

  v4 = *(_QWORD *)(a1 + 32);
  if (v4)
  {
    v13 = 0;
    v5 = *(_OWORD *)(v4 + 40);
    *(_OWORD *)buf = *(_OWORD *)(v4 + 24);
    *(_OWORD *)&buf[16] = v5;
    v6 = (char *)&loc_1000A44AC
       + *((int *)qword_1000A4728
         + mdns_trust_checks_check(buf, 2, (unsigned __int8 *)(a2 + 4), 0, 0, 0, &v13));
    __asm { BR              X10 }
  }
  v7 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
LABEL_11:
      v10 = *(_DWORD *)(a1 + 192);
      v11 = *(_DWORD *)(a1 + 180);
      *(_DWORD *)buf = 67109634;
      *(_DWORD *)&buf[4] = v10;
      *(_WORD *)&buf[8] = 2080;
      *(_QWORD *)&buf[10] = a1 + 248;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v11;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "[R%u] _handle_addrinfo_request_with_trust: no audit token for pid(%s %d)", buf, 0x18u);
    }
  }
  else
  {
    v7 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      goto LABEL_11;
  }
  return _handle_addrinfo_request_start(a1, (int *)a2);
}

uint64_t _handle_addrinfo_request_start(uint64_t a1, int *a2)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t AddrInfoClientRequestStart;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  BOOL v19;
  __uint64_t monotonic_time_ns;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;

  *(_QWORD *)(a1 + 104) = addrinfo_termination_callback;
  v21 = 0u;
  v22 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  LODWORD(v21) = *(_DWORD *)(a1 + 192);
  v3 = *a2;
  *((_QWORD *)&v21 + 1) = a2 + 1;
  *(int32x2_t *)&v22 = vrev64_s32(*(int32x2_t *)(a1 + 240));
  DWORD2(v22) = v3;
  v4 = *(unsigned __int8 *)(a1 + 280);
  if (*(_BYTE *)(a1 + 280))
    v5 = 0;
  else
    v5 = *(_DWORD *)(a1 + 180);
  HIDWORD(v22) = v5;
  if (v4)
    v6 = a1 + 264;
  else
    v6 = 0;
  *(_QWORD *)&v23 = v6;
  DWORD2(v23) = *(_DWORD *)(a1 + 188);
  LOBYTE(v25) = *((_BYTE *)a2 + 1013) != 0;
  *((_QWORD *)&v24 + 1) = *(_QWORD *)a1;
  *((_QWORD *)&v25 + 1) = *(_QWORD *)(a1 + 32);
  get_tracker_info_tlvs(a1);
  AddrInfoClientRequestStart = GetAddrInfoClientRequestStart(*(_QWORD *)(a1 + 160), (int *)&v21, (uint64_t)queryrecord_result_reply, a1, v7, v8, v9, v10);
  if (!(_DWORD)AddrInfoClientRequestStart && *(_DWORD *)(a1 + 244) != -1)
  {
    v13 = *(_QWORD *)(a1 + 160);
    v14 = *(_QWORD *)(v13 + 16);
    if (v14)
    {
      v15 = (char *)(v14 + 376);
    }
    else
    {
      v16 = *(_QWORD *)(v13 + 24);
      v15 = v16 ? (char *)(v16 + 376) : "";
    }
    if (IsLocalDomain(v15))
    {
      v17 = *(unsigned int *)(a1 + 244);
      if ((_DWORD)v17)
      {
        if (AWDLInterfaceID && AWDLInterfaceID == v17)
        {
          v18 = 1;
        }
        else
        {
          if (WiFiAwareInterfaceID)
            v19 = WiFiAwareInterfaceID == v17;
          else
            v19 = 0;
          v18 = v19;
        }
      }
      else
      {
        v18 = (*(unsigned __int8 *)(a1 + 242) >> 4) & 1;
      }
      monotonic_time_ns = _mdns_powerlog_get_monotonic_time_ns();
      _mdns_powerlog_bonjour_event(4, v18, (char *)(a1 + 248), monotonic_time_ns);
      *(_QWORD *)(a1 + 8) = monotonic_time_ns;
    }
  }
  return AddrInfoClientRequestStart;
}

uint64_t _handle_regrecord_request_start(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  BOOL v5;
  int v6;
  size_t v8;
  __uint64_t *v9;
  __uint64_t *v10;
  __uint64_t v11;
  int ShouldLogFullRequestInfo;
  unsigned __int8 *v13;
  char v14;
  NSObject *v15;
  int v16;
  unsigned __int8 *v17;
  uint64_t v18;
  int v19;
  unsigned __int8 *v20;
  uint64_t v21;
  int v22;
  const char *v23;
  int v24;
  NSObject *v25;
  uint32_t v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  size_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  NSObject *v49;
  uint64_t v50;
  int v51;
  int v52;
  int v53;
  int v54;
  BOOL v55;
  __uint64_t monotonic_time_ns;
  int v58;
  uint8_t buf[4];
  int v60;
  __int16 v61;
  _BYTE v62[10];
  _BYTE v63[20];
  __int16 v64;
  int v65;
  __int16 v66;
  int v67;
  __int16 v68;
  int v69;
  __int16 v70;
  uint64_t v71;
  __int16 v72;
  int v73;

  if (*(_QWORD *)(a2 + 32) == -2 && !IsLocalDomain(*(_BYTE **)(a2 + 40)) && *(_WORD *)(a2 + 14) == 1)
  {
    v4 = *(unsigned __int16 *)(a2 + 12);
    v5 = v4 > 0x1C;
    v6 = (1 << v4) & 0x10000022;
    if (!v5 && v6 != 0)
    {
      free((void *)a2);
      return 4294901756;
    }
  }
  v9 = (__uint64_t *)malloc_type_calloc(1uLL, 0x40uLL, 0xF1748037uLL);
  if (!v9)
    __break(1u);
  v10 = v9;
  *((_DWORD *)v9 + 4) = *(_DWORD *)(a1 + 232);
  v9[7] = a2;
  *(__uint64_t *)((char *)v9 + 20) = *(_QWORD *)(a1 + 224);
  v9[4] = a1;
  *((_BYTE *)v9 + 40) = 0;
  *(_QWORD *)(a2 + 104) = regrecord_callback;
  *(_QWORD *)(a2 + 112) = v9;
  *(_BYTE *)(a2 + 122) = (*(_DWORD *)(a1 + 240) & 0x400) != 0;
  v11 = *(_QWORD *)(a2 + 32);
  v9[6] = v11;
  if (v11 == -3)
    *(_QWORD *)(a2 + 32) = 0;
  if (!*(_DWORD *)(a2 + 16))
    *(_DWORD *)(a2 + 16) = 4500;
  ShouldLogFullRequestInfo = requestShouldLogFullRequestInfo(a1);
  v13 = *(unsigned __int8 **)(a2 + 40);
  v14 = gSensitiveLoggingEnabled;
  v15 = mDNSLogCategory_mDNS;
  if (mDNSLogCategory_mDNS == mDNSLogCategory_State)
    v14 = 0;
  if (!ShouldLogFullRequestInfo)
  {
    if (v13)
    {
      if ((v14 & 1) != 0)
      {
        v15 = mDNSLogCategory_mDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
          goto LABEL_60;
      }
      else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
        goto LABEL_60;
      }
      v24 = *(_DWORD *)(a1 + 192);
      *(_DWORD *)buf = 67109376;
      v60 = v24;
      v61 = 1024;
      *(_DWORD *)v62 = mDNS_DomainNameFNV1aHash(v13);
      v23 = "[R%u] DNSServiceRegisterRecord START -- name hash: %x";
      v25 = v15;
      v26 = 14;
    }
    else
    {
      if ((v14 & 1) != 0)
      {
        v15 = mDNSLogCategory_mDNS_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
          goto LABEL_60;
        v22 = *(_DWORD *)(a1 + 192);
        *(_DWORD *)buf = 67109120;
        v60 = v22;
        v23 = "[R%u] DNSServiceRegisterRecord START -- ";
      }
      else
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
          goto LABEL_60;
        v32 = *(_DWORD *)(a1 + 192);
        *(_DWORD *)buf = 67109120;
        v60 = v32;
        v23 = "[R%u] DNSServiceRegisterRecord START -- ";
      }
      v25 = v15;
      v26 = 8;
    }
    goto LABEL_52;
  }
  if (!v13)
  {
    if ((v14 & 1) != 0)
    {
      v15 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_60;
    }
    else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
    {
      goto LABEL_60;
    }
    v27 = *(_DWORD *)(a1 + 192);
    v28 = *(unsigned __int16 *)(a2 + 12);
    v29 = *(_DWORD *)(a1 + 240);
    v30 = *(_DWORD *)(a1 + 244);
    v31 = *(_DWORD *)(a1 + 180);
    *(_DWORD *)buf = 67111171;
    v60 = v27;
    v61 = 2160;
    *(_QWORD *)v62 = 1752392040;
    *(_WORD *)&v62[8] = 1040;
    *(_DWORD *)v63 = 257;
    *(_WORD *)&v63[4] = 2101;
    *(_QWORD *)&v63[6] = 0;
    *(_WORD *)&v63[14] = 1024;
    *(_DWORD *)&v63[16] = v28;
    v64 = 1024;
    v65 = v29;
    v66 = 1024;
    v67 = v30;
    v68 = 1024;
    v69 = v31;
    v70 = 2082;
    v71 = a1 + 248;
    v23 = "[R%u] DNSServiceRegisterRecord START -- name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, type: %{m"
          "dns:rrtype}d, flags: 0x%X, interface index: %d, client pid: %d (%{public}s), ";
    v25 = v15;
    v26 = 68;
LABEL_52:
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, v23, buf, v26);
    goto LABEL_60;
  }
  if ((v14 & 1) != 0)
  {
    v15 = mDNSLogCategory_mDNS_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
      goto LABEL_60;
    v16 = *(_DWORD *)(a1 + 192);
    v17 = v13;
    if (v13 == (unsigned __int8 *)-256)
    {
LABEL_22:
      while (v17)
      {
        v18 = *v17;
        if (v18 > 0x3F)
          break;
        if (!*v17)
        {
          v33 = (unsigned __int16)((_WORD)v17 - (_WORD)v13 + 1);
          goto LABEL_56;
        }
        v17 += v18 + 1;
        if (v13 != (unsigned __int8 *)-256)
          goto LABEL_21;
      }
    }
    else
    {
LABEL_21:
      if (v17 < v13 + 256)
        goto LABEL_22;
    }
    v33 = 257;
LABEL_56:
    v35 = *(unsigned __int16 *)(a2 + 12);
    v36 = *(_DWORD *)(a1 + 240);
    v37 = *(_DWORD *)(a1 + 244);
    v38 = *(_DWORD *)(a1 + 180);
    *(_DWORD *)buf = 67111427;
    v60 = v16;
    v61 = 2160;
    *(_QWORD *)v62 = 1752392040;
    *(_WORD *)&v62[8] = 1040;
    *(_DWORD *)v63 = v33;
    *(_WORD *)&v63[4] = 2101;
    *(_QWORD *)&v63[6] = v13;
    *(_WORD *)&v63[14] = 1024;
    *(_DWORD *)&v63[16] = v35;
    v64 = 1024;
    v65 = v36;
    v66 = 1024;
    v67 = v37;
    v68 = 1024;
    v69 = v38;
    v70 = 2082;
    v71 = a1 + 248;
    v72 = 1024;
    v73 = mDNS_DomainNameFNV1aHash(v13);
  }
  else
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      goto LABEL_60;
    v19 = *(_DWORD *)(a1 + 192);
    v20 = v13;
    if (v13 == (unsigned __int8 *)-256)
    {
LABEL_37:
      while (v20)
      {
        v21 = *v20;
        if (v21 > 0x3F)
          break;
        if (!*v20)
        {
          v34 = (unsigned __int16)((_WORD)v20 - (_WORD)v13 + 1);
          goto LABEL_58;
        }
        v20 += v21 + 1;
        if (v13 != (unsigned __int8 *)-256)
          goto LABEL_36;
      }
    }
    else
    {
LABEL_36:
      if (v20 < v13 + 256)
        goto LABEL_37;
    }
    v34 = 257;
LABEL_58:
    v39 = *(unsigned __int16 *)(a2 + 12);
    v40 = *(_DWORD *)(a1 + 240);
    v41 = *(_DWORD *)(a1 + 244);
    v42 = *(_DWORD *)(a1 + 180);
    *(_DWORD *)buf = 67111427;
    v60 = v19;
    v61 = 2160;
    *(_QWORD *)v62 = 1752392040;
    *(_WORD *)&v62[8] = 1040;
    *(_DWORD *)v63 = v34;
    *(_WORD *)&v63[4] = 2101;
    *(_QWORD *)&v63[6] = v13;
    *(_WORD *)&v63[14] = 1024;
    *(_DWORD *)&v63[16] = v39;
    v64 = 1024;
    v65 = v40;
    v66 = 1024;
    v67 = v41;
    v68 = 1024;
    v69 = v42;
    v70 = 2082;
    v71 = a1 + 248;
    v72 = 1024;
    v73 = mDNS_DomainNameFNV1aHash(v13);
  }
  _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "[R%u] DNSServiceRegisterRecord START -- name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, type: %{mdns:rrtype}d, flags: 0x%X, interface index: %d, client pid: %d (%{public}s), name hash: %x", buf, 0x4Au);
LABEL_60:
  v43 = mDNS_Register((unsigned int *)mDNSStorage, a2);
  if ((_DWORD)v43)
  {
    v8 = v43;
    v49 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
LABEL_72:
        v52 = *(_DWORD *)(a1 + 192);
        v53 = *(_DWORD *)(a1 + 240);
        v54 = *(_DWORD *)(a1 + 244);
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), word_100164580);
        *(_DWORD *)buf = 67110403;
        v60 = v52;
        v61 = 1024;
        *(_DWORD *)v62 = v53;
        *(_WORD *)&v62[4] = 1024;
        *(_DWORD *)&v62[6] = v54;
        strcpy(v63, "p\bhash");
        v63[7] = 0;
        *(_WORD *)&v63[8] = 0;
        *(_WORD *)&v63[10] = 2085;
        *(_QWORD *)&v63[12] = word_100164580;
        v64 = 1024;
        v65 = v8;
        _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "[R%d] DNSServiceRegisterRecord(0x%X, %d,%{sensitive, mask.hash}s) ERROR (%d)", buf, 0x2Eu);
      }
    }
    else
    {
      v49 = mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_72;
    }
    free(v10);
    free((void *)a2);
    return v8;
  }
  if (*(_QWORD *)(a2 + 32) != -2 && IsLocalDomain(*(_BYTE **)(a2 + 40)))
  {
    v50 = *(unsigned int *)(a1 + 244);
    if ((_DWORD)v50)
    {
      if (AWDLInterfaceID && AWDLInterfaceID == v50)
      {
        v51 = 1;
      }
      else
      {
        if (WiFiAwareInterfaceID)
          v55 = WiFiAwareInterfaceID == v50;
        else
          v55 = 0;
        v51 = v55;
      }
    }
    else
    {
      v51 = (*(unsigned __int8 *)(a1 + 242) >> 4) & 1;
    }
    monotonic_time_ns = _mdns_powerlog_get_monotonic_time_ns();
    _mdns_powerlog_bonjour_event(10, v51, (char *)(a1 + 248), monotonic_time_ns);
    *v10 = monotonic_time_ns;
  }
  if (mDNS_McastLoggingEnabled)
    LogMcastService(a2, a1, 1, v44, v45, v46, v47, v48, v58);
  v8 = 0;
  v10[1] = *(_QWORD *)(a1 + 168);
  *(_QWORD *)(a1 + 168) = v10;
  return v8;
}

void ___handle_regrecord_request_with_trust_block_invoke_2(uint64_t a1, int a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  NSObject *v23;
  int v24;
  void *v25;
  uint8_t buf[4];
  int v27;
  __int16 v28;
  unsigned int v29;

  if (!a2)
  {
    v5 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
    *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v5, v6, v7, v8, v9, v10, v11, v12);
    v20 = *(_QWORD *)(a1 + 32);
    if (*(_QWORD *)(v20 + 64) && *(_BYTE *)(v20 + 27))
      goto LABEL_17;
    v13 = *(_QWORD *)(v20 + 56);
    if (!v13)
      goto LABEL_17;
    if (a3 == 1)
    {
      *(_QWORD *)(v20 + 56) = 0;
      v21 = _handle_regrecord_request_start(*(_QWORD *)(a1 + 40), v13);
      if (!v21)
        goto LABEL_17;
    }
    else
    {
      v21 = -65570;
    }
    v22 = *(_QWORD *)(a1 + 40);
    v25 = 0;
    if (GenerateNTDResponse(0, 0, v22, (char **)&v25, (char *)0x45, 0, v21))
    {
      v23 = mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
        {
LABEL_16:
          v24 = *(_DWORD *)(v22 + 192);
          *(_DWORD *)buf = 67109376;
          v27 = v24;
          v28 = 1024;
          v29 = v21;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "[R%u] DNSServiceRegisterRecord _return_regrecord_request_error: error(%d)", buf, 0xEu);
        }
      }
      else
      {
        v23 = mDNSLogCategory_mDNS_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
          goto LABEL_16;
      }
    }
    else
    {
      append_reply(v22, v25);
    }
LABEL_17:
    KQueueUnlock((uint64_t)"_handle_regrecord_request_with_trust", v13, v14, v15, v16, v17, v18, v19);
  }
}

uint64_t LocateSubordinateRequest(uint64_t result)
{
  uint64_t v1;

  v1 = all_requests;
  if (all_requests)
  {
    while (*(_QWORD *)(v1 + 24) != result
         || *(_DWORD *)(v1 + 224) != *(_DWORD *)(result + 224)
         || *(_DWORD *)(v1 + 228) != *(_DWORD *)(result + 228))
    {
      v1 = *(_QWORD *)(v1 + 16);
      if (!v1)
        return result;
    }
    return v1;
  }
  return result;
}

uint64_t handle_tsr_update_request(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  uint64_t *v8;
  NSObject *v9;
  uint64_t v11;
  _BYTE *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _BYTE *v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v21;
  _BYTE *v22;
  uint64_t v23;
  _BYTE *v25;
  uint64_t v26;
  int v27;
  int v29;
  _BYTE v30[30];
  __int16 v31;
  uint64_t v32;

  v8 = mDNSGetTSRForAuthRecordNamed((uint64_t *)xmmword_10015BF10, *(_BYTE **)(a2 + 40), *(_DWORD *)(a2 + 24));
  if (a3 > 0x93A80)
  {
    v9 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
        return 4294901756;
      v11 = *(_QWORD *)(a2 + 40);
      if (v11)
      {
        v12 = *(_BYTE **)(a2 + 40);
        if (v11 == -256)
        {
LABEL_11:
          while (v12)
          {
            v13 = *v12;
            if (v13 > 0x3F)
              break;
            if (!*v12)
            {
              v27 = (unsigned __int16)((_WORD)v12 - v11 + 1);
              goto LABEL_56;
            }
            v12 += v13 + 1;
            if (v11 != -256)
              goto LABEL_10;
          }
        }
        else
        {
LABEL_10:
          if ((unint64_t)v12 < v11 + 256)
            goto LABEL_11;
        }
        v27 = 257;
      }
      else
      {
        v27 = 0;
      }
    }
    else
    {
      v9 = mDNSLogCategory_mDNS_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
        return 4294901756;
      v11 = *(_QWORD *)(a2 + 40);
      if (v11)
      {
        v17 = *(_BYTE **)(a2 + 40);
        if (v11 == -256)
        {
LABEL_22:
          while (v17)
          {
            v18 = *v17;
            if (v18 > 0x3F)
              break;
            if (!*v17)
            {
              v27 = (unsigned __int16)((_WORD)v17 - v11 + 1);
              goto LABEL_56;
            }
            v17 += v18 + 1;
            if (v11 != -256)
              goto LABEL_21;
          }
        }
        else
        {
LABEL_21:
          if ((unint64_t)v17 < v11 + 256)
            goto LABEL_22;
        }
        v27 = 257;
      }
      else
      {
        v27 = 0;
      }
    }
LABEL_56:
    *(_DWORD *)v30 = 67110147;
    *(_DWORD *)&v30[4] = a3;
    *(_WORD *)&v30[8] = 1024;
    *(_DWORD *)&v30[10] = 604800;
    *(_WORD *)&v30[14] = 2160;
    *(_QWORD *)&v30[16] = 1752392040;
    *(_WORD *)&v30[24] = 1040;
    *(_DWORD *)&v30[26] = v27;
    v31 = 2101;
    v32 = v11;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "tsrTimestamp[%u] out of range (%u) on TSR for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", v30, 0x28u);
    return 4294901756;
  }
  v14 = (uint64_t)v8;
  *(_QWORD *)v30 = 0;
  *(_QWORD *)&v30[8] = 0;
  clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)v30);
  if (v14)
    return updateTSRRecord(a1, v14, *(_DWORD *)v30 - a3, a4);
  v15 = 4294901755;
  v19 = mDNSLogCategory_mDNS;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_ERROR))
      return v15;
    v21 = *(_QWORD *)(a2 + 40);
    if (v21)
    {
      v22 = *(_BYTE **)(a2 + 40);
      if (v21 == -256)
      {
LABEL_36:
        while (v22)
        {
          v23 = *v22;
          if (v23 > 0x3F)
            break;
          if (!*v22)
          {
            v29 = (unsigned __int16)((_WORD)v22 - v21 + 1);
            goto LABEL_65;
          }
          v22 += v23 + 1;
          if (v21 != -256)
            goto LABEL_35;
        }
      }
      else
      {
LABEL_35:
        if ((unint64_t)v22 < v21 + 256)
          goto LABEL_36;
      }
      v29 = 257;
    }
    else
    {
      v29 = 0;
    }
LABEL_65:
    *(_DWORD *)v30 = 141558531;
    *(_QWORD *)&v30[4] = 1752392040;
    *(_WORD *)&v30[12] = 1040;
    *(_DWORD *)&v30[14] = v29;
    *(_WORD *)&v30[18] = 2101;
    *(_QWORD *)&v30[20] = v21;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "No existing TSR for %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", v30, 0x1Cu);
    return v15;
  }
  v19 = mDNSLogCategory_mDNS_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_ERROR))
  {
    v21 = *(_QWORD *)(a2 + 40);
    if (v21)
    {
      v25 = *(_BYTE **)(a2 + 40);
      if (v21 == -256)
      {
LABEL_45:
        while (v25)
        {
          v26 = *v25;
          if (v26 > 0x3F)
            break;
          if (!*v25)
          {
            v29 = (unsigned __int16)((_WORD)v25 - v21 + 1);
            goto LABEL_65;
          }
          v25 += v26 + 1;
          if (v21 != -256)
            goto LABEL_44;
        }
      }
      else
      {
LABEL_44:
        if ((unint64_t)v25 < v21 + 256)
          goto LABEL_45;
      }
      v29 = 257;
    }
    else
    {
      v29 = 0;
    }
    goto LABEL_65;
  }
  return v15;
}

void ___get_trust_results_dispatch_queue_block_invoke(id a1)
{
  NSObject *v1;

  v1 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_UTILITY, 0);
  _get_trust_results_dispatch_queue_queue = (uint64_t)dispatch_queue_create("com.apple.mDNSResponder.trust_results-queue", v1);
}

void ___handle_regrecord_request_with_trust_block_invoke(id a1, void *a2)
{
  if (a2)
    free(a2);
}

void queryrecord_result_reply(uint64_t **a1, uint64_t a2, uint64_t a3, int a4, int a5, unsigned int a6, uint64_t a7)
{
  char v13;
  int v14;
  int v15;
  NSObject *v16;
  int v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int validation_result;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  _BYTE *v31;
  int v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  BOOL v37;
  int v38;
  uint64_t v39;
  int v40;
  int v41;
  size_t v42;
  _WORD *v43;
  BOOL v44;
  char *v45;
  int v46;
  char *v47;
  uint64_t v48;
  const void *v49;
  __int16 *v50;
  __int16 *v51;
  uint64_t v52;
  int v53;
  int v54;
  size_t v55;
  _WORD *v56;
  BOOL v57;
  int v58;
  char *v59;
  uint64_t v60;
  const void *v61;
  __int16 *v62;
  uint64_t v63;
  int v64;
  int v65;
  uint64_t v66;
  size_t v67;
  _WORD *v68;
  BOOL v69;
  char *v70;
  int v71;
  char *v72;
  uint64_t v73;
  const void *v74;
  __int16 *v75;
  unsigned int v76;
  __int16 *v77;
  uint64_t v78;
  int v79;
  int v80;
  size_t v81;
  _WORD *v82;
  BOOL v83;
  int v84;
  char *v85;
  uint64_t v86;
  const void *v87;
  unsigned int v88;
  __int16 *v89;
  int v90;
  char *v91;
  uint64_t v92;
  const void *v93;
  unsigned int v94;
  __int16 *v95;
  int v96;
  char *v97;
  uint64_t v98;
  const void *v99;
  unsigned int v100;
  __int16 *v101;
  int v102;
  char *v103;
  uint64_t v104;
  const void *v105;
  __int16 *v106;
  unsigned int v107;
  __int16 *v108;
  int v109;
  char *v110;
  uint64_t v111;
  const void *v112;
  unsigned int v113;
  __int16 *v114;
  int v115;
  char *v116;
  uint64_t v117;
  const void *v118;
  unsigned int v119;
  __int16 *v120;
  int v121;
  char *v122;
  uint64_t v123;
  const void *v124;
  unsigned int v125;
  __int16 *v126;
  int v127;
  char *v128;
  uint64_t v129;
  const void *v130;
  int v131;
  unsigned int v132;
  __int16 *v133;
  int v134;
  char *v135;
  uint64_t v136;
  const void *v137;
  int v138;
  unsigned int v139;
  __int16 *v140;
  char *v141;
  int v142;
  NSObject *v143;
  int v144;
  unsigned int v145;
  _BYTE *v146;
  uint64_t v147;
  char *v148;
  int v149;
  int v150;
  unsigned int v151;
  _BYTE *v152;
  uint64_t v153;
  char *v154;
  int v155;
  NSObject *v156;
  int v157;
  unsigned int v158;
  int v159;
  const char *v160;
  char *v161;
  int v162;
  int v163;
  char *v164;
  int v165;
  char *v166;
  int v167;
  char *v168;
  int v169;
  char *v170;
  char *v171;
  int v172;
  NSObject *v173;
  int v174;
  unsigned int v175;
  _BYTE *v176;
  uint64_t v177;
  char *v178;
  int v179;
  int v180;
  unsigned int v181;
  _BYTE *v182;
  uint64_t v183;
  char *v184;
  int v185;
  NSObject *v186;
  int v187;
  unsigned int v188;
  int v189;
  const char *v190;
  char *v191;
  int v192;
  char *v193;
  int v194;
  NSObject *v195;
  int v196;
  _BYTE *v197;
  uint64_t v198;
  char *v199;
  int v200;
  int v201;
  _BYTE *v202;
  uint64_t v203;
  char *v204;
  int v205;
  NSObject *v206;
  int v207;
  int v208;
  char *v209;
  int v210;
  uint64_t v211;
  const void *v212;
  __int16 *v213;
  uint64_t RDataBytesPointer;
  const void *v215;
  __int16 *v216;
  uint64_t v217;
  const void *v218;
  unsigned int v219;
  __int16 *v220;
  uint64_t v221;
  const void *v222;
  unsigned int v223;
  __int16 *v224;
  _BYTE *v225;
  uint64_t v226;
  _BYTE *v227;
  uint64_t v228;
  int v229;
  unsigned int v230;
  int v231;
  NSObject *v232;
  uint32_t v233;
  int v234;
  int v235;
  _BYTE *v236;
  uint64_t v237;
  int v238;
  int v239;
  _BYTE *v240;
  uint64_t v241;
  int v242;
  NSObject *v243;
  int v244;
  int v245;
  int v246;
  _BYTE *v247;
  uint64_t v248;
  _BYTE *v249;
  uint64_t v250;
  int v251;
  unsigned int v252;
  int v253;
  NSObject *v254;
  uint32_t v255;
  __int16 *v256;
  NSObject *v257;
  int v258;
  unsigned int v259;
  _BYTE *v260;
  uint64_t v261;
  __int16 *v262;
  int v263;
  unsigned int v264;
  _BYTE *v265;
  uint64_t v266;
  __int16 *v267;
  NSObject *v268;
  NSObject *v269;
  int v270;
  unsigned int v271;
  unsigned int v272;
  size_t v273;
  unsigned int v274;
  __int16 *v275;
  int v276;
  unsigned int v277;
  unsigned int v278;
  size_t v279;
  unsigned int v280;
  int v281;
  unsigned int v282;
  _BYTE *v283;
  uint64_t v284;
  int v285;
  unsigned int v286;
  _BYTE *v287;
  uint64_t v288;
  int v289;
  unsigned int v290;
  unsigned int v291;
  size_t v292;
  unsigned int v293;
  int v294;
  unsigned int v295;
  unsigned int v296;
  size_t v297;
  unsigned int v298;
  _BYTE *v299;
  uint64_t v300;
  _BYTE *v301;
  uint64_t v302;
  int v303;
  int v304;
  NSObject *v305;
  NSObject *v306;
  int v307;
  unsigned int v308;
  _BYTE *v309;
  uint64_t v310;
  NSObject *v311;
  int v312;
  unsigned int v313;
  _BYTE *v314;
  uint64_t v315;
  NSObject *v316;
  NSObject *v317;
  int v318;
  unsigned int v319;
  unsigned int v320;
  size_t v321;
  unsigned int v322;
  __int16 *v323;
  int v324;
  unsigned int v325;
  unsigned int v326;
  size_t v327;
  unsigned int v328;
  __int16 *v329;
  int v330;
  unsigned int v331;
  _BYTE *v332;
  uint64_t v333;
  int v334;
  unsigned int v335;
  _BYTE *v336;
  uint64_t v337;
  int v338;
  unsigned int v339;
  unsigned int v340;
  size_t v341;
  unsigned int v342;
  __int16 *v343;
  int v344;
  unsigned int v345;
  unsigned int v346;
  size_t v347;
  unsigned int v348;
  __int16 *v349;
  _BYTE *v350;
  uint64_t v351;
  _BYTE *v352;
  uint64_t v353;
  int v354;
  int v355;
  __int16 *v356;
  NSObject *v357;
  int v358;
  _BYTE *v359;
  uint64_t v360;
  __int16 *v361;
  int v362;
  _BYTE *v363;
  uint64_t v364;
  __int16 *v365;
  NSObject *v366;
  int v367;
  unsigned int v368;
  size_t v369;
  unsigned int v370;
  __int16 *v371;
  int v372;
  unsigned int v373;
  size_t v374;
  unsigned int v375;
  _BYTE *v376;
  uint64_t v377;
  _BYTE *v378;
  uint64_t v379;
  unsigned __int16 v380;
  unsigned __int16 v381;
  NSObject *v382;
  int v383;
  _BYTE *v384;
  uint64_t v385;
  int v386;
  _BYTE *v387;
  uint64_t v388;
  NSObject *v389;
  NSObject *v390;
  int v391;
  unsigned int v392;
  size_t v393;
  unsigned int v394;
  __int16 *v395;
  int v396;
  unsigned int v397;
  size_t v398;
  unsigned int v399;
  __int16 *v400;
  int v401;
  _BYTE *v402;
  uint64_t v403;
  int v404;
  _BYTE *v405;
  uint64_t v406;
  int v407;
  unsigned int v408;
  size_t v409;
  unsigned int v410;
  __int16 *v411;
  int v412;
  unsigned int v413;
  size_t v414;
  unsigned int v415;
  __int16 *v416;
  unsigned __int16 v417;
  unsigned __int16 v418;
  unsigned __int16 v419;
  unsigned __int16 v420;
  unsigned __int16 v421;
  unsigned __int16 v422;
  unsigned __int16 v423;
  unsigned __int16 v424;
  int v425;
  const char *v426;
  int v427;
  const void *v428;
  unsigned int v429;
  const char *v430;
  const void *v431;
  unsigned int v432;
  NSObject *v433;
  const void *v434;
  unsigned int v435;
  const void *v436;
  unsigned int v437;
  uint32_t v438;
  unsigned __int16 v439;
  unsigned __int16 v440;
  unsigned __int16 v441;
  unsigned __int16 v442;
  unsigned __int16 v443;
  unsigned __int16 v444;
  unsigned __int16 v445;
  unsigned __int16 v446;
  int v447;
  int v448;
  NSObject *v449;
  uint32_t v450;
  int v451;
  unsigned int v452;
  size_t v453;
  unsigned int v454;
  const void *v455;
  int v456;
  unsigned int v457;
  const char *v458;
  int v459;
  unsigned int v460;
  size_t v461;
  unsigned int v462;
  const void *v463;
  int v464;
  unsigned int v465;
  int v466;
  unsigned int v467;
  size_t v468;
  unsigned int v469;
  const void *v470;
  int v471;
  unsigned int v472;
  int v473;
  unsigned int v474;
  size_t v475;
  unsigned int v476;
  const void *v477;
  int v478;
  unsigned int v479;
  const void *v480;
  int v481;
  const char *v482;
  const void *v483;
  int v484;
  NSObject *v485;
  const void *v486;
  int v487;
  const void *v488;
  int v489;
  uint32_t v490;
  int v491;
  int v492;
  int v493;
  int v494;
  unsigned __int16 v495;
  unsigned __int16 v496;
  unsigned __int16 v497;
  unsigned __int16 v498;
  int v499;
  unsigned int v500;
  size_t v501;
  unsigned int v502;
  __int16 *v503;
  const void *v504;
  int v505;
  const char *v506;
  int v507;
  unsigned int v508;
  size_t v509;
  unsigned int v510;
  __int16 *v511;
  const void *v512;
  int v513;
  NSObject *v514;
  int v515;
  unsigned int v516;
  size_t v517;
  unsigned int v518;
  __int16 *v519;
  const void *v520;
  int v521;
  int v522;
  unsigned int v523;
  size_t v524;
  unsigned int v525;
  __int16 *v526;
  const void *v527;
  int v528;
  uint32_t v529;
  int v530;
  int v531;
  int v532;
  unsigned int v533;
  size_t v534;
  unsigned int v535;
  const void *v536;
  int v537;
  int v538;
  const char *v539;
  int v540;
  unsigned int v541;
  size_t v542;
  unsigned int v543;
  const void *v544;
  int v545;
  int v546;
  const void *v547;
  int v548;
  const void *v549;
  int v550;
  const void *v551;
  int v552;
  const void *v553;
  int v554;
  int v555;
  unsigned int v556;
  size_t v557;
  unsigned int v558;
  __int16 *v559;
  const void *v560;
  int v561;
  unsigned int v562;
  int v563;
  unsigned int v564;
  size_t v565;
  unsigned int v566;
  __int16 *v567;
  const void *v568;
  int v569;
  unsigned int v570;
  int v571;
  unsigned int v572;
  size_t v573;
  unsigned int v574;
  __int16 *v575;
  const void *v576;
  int v577;
  int v578;
  unsigned int v579;
  size_t v580;
  unsigned int v581;
  __int16 *v582;
  const void *v583;
  int v584;
  uint64_t v585;
  uint64_t v586;
  size_t v587;
  uint64_t v588;
  uint64_t v589;
  uint64_t v590;
  uint64_t v591;
  uint64_t v592;
  unint64_t v593;
  unsigned int v594;
  void *v595;
  uint64_t v596;
  unsigned int v597;
  NSObject *v598;
  int v599;
  unsigned int v600;
  const char *v601;
  const char *v602;
  uint64_t ipv4;
  int v604;
  unsigned int v605;
  int v606;
  const char *data;
  unsigned __int16 tv_sec;
  uint64_t v609;
  NSObject *v610;
  int v611;
  unsigned int v612;
  uint64_t v613;
  char *reply;
  char *v615;
  unsigned int v616;
  char *v617;
  char *v618;
  size_t v619;
  unint64_t v620;
  uint64_t v621;
  uint64_t v622;
  uint64_t v623;
  char *v624;
  char *v625;
  uint64_t v626;
  uint64_t v627;
  uint64_t v628;
  uint64_t v629;
  uint64_t v630;
  char *v631;
  unsigned int v632;
  char *v633;
  const void *v634;
  size_t v635;
  NSObject *v636;
  int v637;
  unsigned int v638;
  uint64_t *v639;
  int tracker_state;
  CFIndex Count;
  const __CFData *ValueAtIndex;
  uint64_t v643;
  const void *v644;
  int v645;
  int v646;
  int v647;
  int v648;
  NSObject *v649;
  unsigned int v650;
  unsigned int v651;
  int v652;
  int v653;
  unsigned int v654;
  unsigned int v655;
  __int16 *v656;
  __int16 *v657;
  unsigned int v658;
  unsigned int v659;
  unsigned int v660;
  unsigned int v661;
  char *v662;
  __int16 *v663;
  __int16 *v664;
  __int16 *v665;
  __int16 *v666;
  __int16 *v667;
  __int16 *v668;
  __int16 *v669;
  unsigned int v670;
  unsigned int v671;
  int v672;
  int v673;
  int v674;
  int v675;
  int v676;
  int v677;
  int v678;
  int v679;
  unsigned int v680;
  unsigned int v681;
  __int16 *v682;
  __int16 *v683;
  __int16 *v684;
  __int16 *v685;
  unsigned int v686;
  unsigned int v687;
  unsigned int v688;
  unsigned int v689;
  NSObject *v690;
  NSObject *v691;
  unsigned int v692;
  unsigned int v693;
  int v694;
  int v695;
  int v696;
  int v697;
  int v698;
  int v699;
  int v700;
  int v701;
  int v702;
  int v703;
  int v704;
  int v705;
  int v706;
  int v707;
  unsigned int v708;
  int v709;
  unsigned int v710;
  uint64_t v712;
  uint64_t v713;
  _WORD __n[7];
  timespec buf;
  _BYTE v716[10];
  uint64_t v717;
  _BYTE v718[68];
  char __s[1009];

  if (&_NEHelperTrackerGetAppInfo)
    v13 = 1;
  else
    v13 = _os_feature_enabled_impl("symptomsd", "networking_transparency");
  bzero(__s, 0x3F1uLL);
  if (a5 && (v13 & 1) != 0)
  {
    v14 = *(unsigned __int16 *)(a3 + 4);
    *(_QWORD *)&__n[3] = 0;
    if (v14 == 28 || v14 == 1)
    {
      if (*(_BYTE *)(a7 + 281))
      {
        v15 = 1;
        if (resolved_cache_get_tracker_state(a2, &__n[3], 0, 0, 0) == 2 && !*(_QWORD *)&__n[3])
        {
          v16 = mDNSLogCategory_Default;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
          {
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
            {
LABEL_19:
              v17 = *(_DWORD *)(a7 + 192);
              v18 = bswap32(*(unsigned __int16 *)(a2 + 340)) >> 16;
              LODWORD(buf.tv_sec) = 67109376;
              HIDWORD(buf.tv_sec) = v17;
              LOWORD(buf.tv_nsec) = 1024;
              *(_DWORD *)((char *)&buf.tv_nsec + 2) = v18;
              _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "[R%u->Q%u] queryrecord_result_reply NULL tracker hostname", (uint8_t *)&buf, 0xEu);
            }
          }
          else
          {
            v16 = mDNSLogCategory_Default_redacted;
            if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
              goto LABEL_19;
          }
        }
      }
      else
      {
        v15 = 1;
      }
    }
    else
    {
      v15 = 0;
    }
  }
  else
  {
    v15 = 0;
    *(_QWORD *)&__n[3] = 0;
  }
  ConvertDomainNameToCString_withescape(*(unsigned __int8 **)(a3 + 32), (unsigned __int8 *)__s);
  v709 = v15;
  v710 = a6;
  if (*(_QWORD *)(a2 + 144) && (v24 = *(_QWORD *)(a3 + 56)) != 0)
  {
    validation_result = dnssec_obj_resource_record_member_get_validation_result(v24);
    if (validation_result == 2)
      v26 = 2097184;
    else
      v26 = 0;
    if (validation_result == 1)
      v27 = 2097168;
    else
      v27 = v26;
    v708 = v27;
  }
  else
  {
    v708 = 0;
  }
  v28 = *(unsigned __int16 *)(a2 + 340);
  v29 = *(_DWORD *)(a7 + 220);
  v30 = mDNSPlatformInterfaceIndexfromInterfaceID(a1, *(_QWORD *)(a3 + 24), 0, v19, v20, v21, v22, v23);
  v713 = a2;
  v31 = (_BYTE *)(a2 + 376);
  v32 = mDNS_DomainNameFNV1aHash((unsigned __int8 *)(a2 + 376));
  v33 = *(_DWORD *)(a7 + 200);
  buf.tv_sec = 0;
  buf.tv_nsec = 0;
  clock_gettime(_CLOCK_MONOTONIC_RAW, &buf);
  if (v33)
    v37 = LODWORD(buf.tv_sec) - v33 <= 299;
  else
    v37 = 0;
  v38 = !v37;
  v712 = a7;
  if (v29 != 8)
  {
    if (v38)
    {
      *(_DWORD *)(a7 + 200) = buf.tv_sec;
      v52 = *(_QWORD *)(a3 + 56);
      if (v52)
      {
        v53 = v30;
        v54 = dnssec_obj_resource_record_member_get_validation_result(v52);
        v56 = (_WORD *)(a3 + 12);
        v55 = *(unsigned __int16 *)(a3 + 12);
        v57 = v55 < 0x201;
        if (v54)
        {
          if (!*(_WORD *)(v713 + 340))
          {
            if (v55 >= 0x201)
            {
              v55 = (size_t)malloc_type_malloc(v55, 0xA172743EuLL);
              if (!v55)
                goto LABEL_1111;
              v166 = (char *)v55;
              LODWORD(v55) = (unsigned __int16)*v56;
              v45 = v166;
              v165 = v55;
            }
            else
            {
              v45 = 0;
              v165 = 512;
              v166 = (char *)&unk_100164380;
            }
            if ((_DWORD)v55)
            {
              *(_DWORD *)&__n[1] = 0;
              __n[0] = 0;
              RDataBytesPointer = ResourceRecordGetRDataBytesPointer(a3, v166, v165, __n, (int *)&__n[1], v34, v35, v36);
              if (*(_DWORD *)&__n[1])
                goto LABEL_1002;
              v215 = (const void *)RDataBytesPointer;
              v705 = v32;
              if (__n[0] >= 0x1FFuLL)
              {
                v681 = __n[0] + 2;
                v216 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
                if (!v216)
                  goto LABEL_1111;
                v50 = v216;
              }
              else
              {
                v50 = 0;
                v681 = 512;
                v216 = word_100164580;
              }
              v669 = v216;
              if (v28)
                v382 = mDNSLogCategory_Default;
              else
                v382 = mDNSLogCategory_mDNS;
              if (gSensitiveLoggingEnabled != 1 || v382 == mDNSLogCategory_State)
              {
                if (!os_log_type_enabled(v382, OS_LOG_TYPE_DEFAULT))
                  goto LABEL_1000;
                v404 = *(_DWORD *)(v712 + 192);
                v405 = v31;
                v657 = v50;
                if (v713 == -632)
                {
LABEL_798:
                  while (v405)
                  {
                    v406 = *v405;
                    if (v406 > 0x3F)
                      break;
                    if (!*v405)
                    {
                      v498 = (_WORD)v405 - (_WORD)v31 + 1;
                      goto LABEL_994;
                    }
                    v405 += v406 + 1;
                    if (v713 != -632)
                      goto LABEL_797;
                  }
                }
                else
                {
LABEL_797:
                  if ((unint64_t)v405 < v713 + 632)
                    goto LABEL_798;
                }
                v498 = 257;
LABEL_994:
                v578 = v498;
                v579 = *(unsigned __int16 *)(a3 + 4);
                v580 = __n[0];
                v581 = __n[0] + 2;
                if (v581 <= v681)
                {
                  v582 = v669;
                  *v669 = __rev16(v579);
                  v583 = v215;
                  v584 = v404;
                  v655 = v579;
                  v693 = v581;
                  memcpy(v669 + 1, v583, v580);
                  v581 = v693;
                  v579 = v655;
                  v404 = v584;
                }
                else
                {
                  v582 = 0;
                }
                LODWORD(buf.tv_sec) = 67112195;
                HIDWORD(buf.tv_sec) = v404;
                LOWORD(buf.tv_nsec) = 1024;
                *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
                HIWORD(buf.tv_nsec) = 1024;
                *(_DWORD *)v716 = a4;
                *(_WORD *)&v716[4] = 1024;
                *(_DWORD *)&v716[6] = v53;
                strcpy((char *)&v717, "p\bhash");
                HIBYTE(v717) = 0;
                *(_WORD *)v718 = 0;
                *(_WORD *)&v718[2] = 1040;
                *(_DWORD *)&v718[4] = v578;
                *(_WORD *)&v718[8] = 2101;
                *(_QWORD *)&v718[10] = v31;
                *(_WORD *)&v718[18] = 1024;
                *(_DWORD *)&v718[20] = v705;
                *(_WORD *)&v718[24] = 1026;
                *(_DWORD *)&v718[26] = v54;
                *(_WORD *)&v718[30] = 1024;
                *(_DWORD *)&v718[32] = v579;
                *(_WORD *)&v718[36] = 2160;
                *(_QWORD *)&v718[38] = 1752392040;
                *(_WORD *)&v718[46] = 1040;
                *(_DWORD *)&v718[48] = v581;
                *(_WORD *)&v718[52] = 2101;
                *(_QWORD *)&v718[54] = v582;
                v506 = "[R%u->mDNSQ] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifi"
                       "ndex: %d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdn"
                       "s:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
              }
              else
              {
                if (v28)
                  v382 = mDNSLogCategory_Default_redacted;
                else
                  v382 = mDNSLogCategory_mDNS;
                if (!os_log_type_enabled(v382, OS_LOG_TYPE_DEFAULT))
                  goto LABEL_1000;
                v386 = *(_DWORD *)(v712 + 192);
                v387 = v31;
                v657 = v50;
                if (v713 == -632)
                {
LABEL_756:
                  while (v387)
                  {
                    v388 = *v387;
                    if (v388 > 0x3F)
                      break;
                    if (!*v387)
                    {
                      v496 = (_WORD)v387 - (_WORD)v31 + 1;
                      goto LABEL_984;
                    }
                    v387 += v388 + 1;
                    if (v713 != -632)
                      goto LABEL_755;
                  }
                }
                else
                {
LABEL_755:
                  if ((unint64_t)v387 < v713 + 632)
                    goto LABEL_756;
                }
                v496 = 257;
LABEL_984:
                v563 = v496;
                v564 = *(unsigned __int16 *)(a3 + 4);
                v565 = __n[0];
                v566 = __n[0] + 2;
                if (v566 <= v681)
                {
                  v567 = v669;
                  *v669 = __rev16(v564);
                  v568 = v215;
                  v569 = v386;
                  v691 = v382;
                  v570 = v564;
                  v653 = v496;
                  memcpy(v669 + 1, v568, v565);
                  v563 = v653;
                  v564 = v570;
                  v382 = v691;
                  v386 = v569;
                }
                else
                {
                  v567 = 0;
                }
                LODWORD(buf.tv_sec) = 67112195;
                HIDWORD(buf.tv_sec) = v386;
                LOWORD(buf.tv_nsec) = 1024;
                *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
                HIWORD(buf.tv_nsec) = 1024;
                *(_DWORD *)v716 = a4;
                *(_WORD *)&v716[4] = 1024;
                *(_DWORD *)&v716[6] = v53;
                strcpy((char *)&v717, "p\bhash");
                HIBYTE(v717) = 0;
                *(_WORD *)v718 = 0;
                *(_WORD *)&v718[2] = 1040;
                *(_DWORD *)&v718[4] = v563;
                *(_WORD *)&v718[8] = 2101;
                *(_QWORD *)&v718[10] = v31;
                *(_WORD *)&v718[18] = 1024;
                *(_DWORD *)&v718[20] = v705;
                *(_WORD *)&v718[24] = 1026;
                *(_DWORD *)&v718[26] = v54;
                *(_WORD *)&v718[30] = 1024;
                *(_DWORD *)&v718[32] = v564;
                *(_WORD *)&v718[36] = 2160;
                *(_QWORD *)&v718[38] = 1752392040;
                *(_WORD *)&v718[46] = 1040;
                *(_DWORD *)&v718[48] = v566;
                *(_WORD *)&v718[52] = 2101;
                *(_QWORD *)&v718[54] = v567;
                v506 = "[R%u->mDNSQ] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifi"
                       "ndex: %d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdn"
                       "s:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
              }
              goto LABEL_998;
            }
            v238 = v32;
            if (v28)
              v143 = mDNSLogCategory_Default;
            else
              v143 = mDNSLogCategory_mDNS;
            if (gSensitiveLoggingEnabled != 1 || v143 == mDNSLogCategory_State)
            {
              if (!os_log_type_enabled(v143, OS_LOG_TYPE_DEFAULT))
                goto LABEL_1003;
              v239 = *(_DWORD *)(a7 + 192);
              v352 = v31;
              if (v713 == -632)
              {
LABEL_626:
                while (v352)
                {
                  v353 = *v352;
                  if (v353 > 0x3F)
                    break;
                  if (!*v352)
                  {
                    v444 = (_WORD)v352 - (_WORD)v31 + 1;
                    goto LABEL_940;
                  }
                  v352 += v353 + 1;
                  if (v713 != -632)
                    goto LABEL_625;
                }
              }
              else
              {
LABEL_625:
                if ((unint64_t)v352 < v713 + 632)
                  goto LABEL_626;
              }
              v444 = 257;
            }
            else
            {
              if (v28)
                v143 = mDNSLogCategory_Default_redacted;
              else
                v143 = mDNSLogCategory_mDNS;
              if (!os_log_type_enabled(v143, OS_LOG_TYPE_DEFAULT))
                goto LABEL_1003;
              v239 = *(_DWORD *)(a7 + 192);
              v240 = v31;
              if (v713 == -632)
              {
LABEL_379:
                while (v240)
                {
                  v241 = *v240;
                  if (v241 > 0x3F)
                    break;
                  if (!*v240)
                  {
                    v444 = (_WORD)v240 - (_WORD)v31 + 1;
                    goto LABEL_940;
                  }
                  v240 += v241 + 1;
                  if (v713 != -632)
                    goto LABEL_378;
                }
              }
              else
              {
LABEL_378:
                if ((unint64_t)v240 < v713 + 632)
                  goto LABEL_379;
              }
              v444 = 257;
            }
LABEL_940:
            v531 = *(unsigned __int16 *)(a3 + 4);
            LODWORD(buf.tv_sec) = 67111427;
            HIDWORD(buf.tv_sec) = v239;
            LOWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
            HIWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)v716 = a4;
            *(_WORD *)&v716[4] = 1024;
            *(_DWORD *)&v716[6] = v53;
            strcpy((char *)&v717, "p\bhash");
            HIBYTE(v717) = 0;
            *(_WORD *)v718 = 0;
            *(_WORD *)&v718[2] = 1040;
            *(_DWORD *)&v718[4] = v444;
            *(_WORD *)&v718[8] = 2101;
            *(_QWORD *)&v718[10] = v31;
            *(_WORD *)&v718[18] = 1024;
            *(_DWORD *)&v718[20] = v238;
            *(_WORD *)&v718[24] = 1026;
            *(_DWORD *)&v718[26] = v54;
            *(_WORD *)&v718[30] = 1024;
            *(_DWORD *)&v718[32] = v531;
            v426 = "[R%u->mDNSQ] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex"
                   ": %d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec"
                   "_result}d, type: %{mdns:rrtype}d, rdata: <none>";
LABEL_941:
            v449 = v143;
            v450 = 70;
            goto LABEL_942;
          }
          if (v55 >= 0x201)
          {
            v178 = (char *)malloc_type_malloc(v55, 0xA172743EuLL);
            if (!v178)
              goto LABEL_1111;
            v59 = v178;
            v45 = v178;
            v58 = (unsigned __int16)*v56;
            if (*v56)
            {
LABEL_52:
              *(_DWORD *)&__n[1] = 0;
              __n[0] = 0;
              v60 = ResourceRecordGetRDataBytesPointer(a3, v59, v58, __n, (int *)&__n[1], v34, v35, v36);
              if (!*(_DWORD *)&__n[1])
              {
                v61 = (const void *)v60;
                v695 = v32;
                if (__n[0] >= 0x1FFuLL)
                {
                  v671 = __n[0] + 2;
                  v62 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
                  if (!v62)
                    goto LABEL_1111;
                  v50 = v62;
                }
                else
                {
                  v50 = 0;
                  v671 = 512;
                  v62 = word_100164580;
                }
                v665 = v62;
                if (v28)
                  v305 = mDNSLogCategory_Default;
                else
                  v305 = mDNSLogCategory_mDNS;
                if (gSensitiveLoggingEnabled == 1 && v305 != mDNSLogCategory_State)
                {
                  if (v28)
                    v311 = mDNSLogCategory_Default_redacted;
                  else
                    v311 = mDNSLogCategory_mDNS;
                  if (os_log_type_enabled(v311, OS_LOG_TYPE_DEFAULT))
                  {
                    v312 = *(_DWORD *)(v712 + 192);
                    v313 = bswap32(*(unsigned __int16 *)(v713 + 340)) >> 16;
                    v314 = v31;
                    v649 = v311;
                    v657 = v50;
                    if (v713 == -632)
                    {
LABEL_562:
                      while (v314)
                      {
                        v315 = *v314;
                        if (v315 > 0x3F)
                          break;
                        if (!*v314)
                        {
                          v440 = (_WORD)v314 - (_WORD)v31 + 1;
                          goto LABEL_918;
                        }
                        v314 += v315 + 1;
                        if (v713 != -632)
                          goto LABEL_561;
                      }
                    }
                    else
                    {
LABEL_561:
                      if ((unint64_t)v314 < v713 + 632)
                        goto LABEL_562;
                    }
                    v440 = 257;
LABEL_918:
                    v507 = v440;
                    v508 = *(unsigned __int16 *)(a3 + 4);
                    v509 = __n[0];
                    v510 = __n[0] + 2;
                    if (v510 <= v671)
                    {
                      v511 = v665;
                      *v665 = __rev16(v508);
                      v512 = v61;
                      v513 = v312;
                      v687 = v508;
                      v646 = v440;
                      memcpy(v665 + 1, v512, v509);
                      v507 = v646;
                      v508 = v687;
                      v312 = v513;
                    }
                    else
                    {
                      v511 = 0;
                    }
                    LODWORD(buf.tv_sec) = 67112451;
                    HIDWORD(buf.tv_sec) = v312;
                    LOWORD(buf.tv_nsec) = 1024;
                    *(_DWORD *)((char *)&buf.tv_nsec + 2) = v313;
                    HIWORD(buf.tv_nsec) = 1024;
                    *(_DWORD *)v716 = a5;
                    *(_WORD *)&v716[4] = 1024;
                    *(_DWORD *)&v716[6] = a4;
                    LOWORD(v717) = 1024;
                    *(_DWORD *)((char *)&v717 + 2) = v53;
                    HIWORD(v717) = 2160;
                    *(_QWORD *)v718 = 1752392040;
                    *(_WORD *)&v718[8] = 1040;
                    *(_DWORD *)&v718[10] = v507;
                    *(_WORD *)&v718[14] = 2101;
                    *(_QWORD *)&v718[16] = v31;
                    *(_WORD *)&v718[24] = 1024;
                    *(_DWORD *)&v718[26] = v695;
                    *(_WORD *)&v718[30] = 1026;
                    *(_DWORD *)&v718[32] = v54;
                    *(_WORD *)&v718[36] = 1024;
                    *(_DWORD *)&v718[38] = v508;
                    *(_WORD *)&v718[42] = 2160;
                    *(_QWORD *)&v718[44] = 1752392040;
                    *(_WORD *)&v718[52] = 1040;
                    *(_DWORD *)&v718[54] = v510;
                    *(_WORD *)&v718[58] = 2101;
                    *(_QWORD *)&v718[60] = v511;
                    v506 = "[R%u->Q%u] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, i"
                           "findex: %d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{publi"
                           "c, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
                    goto LABEL_922;
                  }
LABEL_1000:
                  if (v50)
                    free(v50);
                  goto LABEL_1002;
                }
                if (!os_log_type_enabled(v305, OS_LOG_TYPE_DEFAULT))
                  goto LABEL_1000;
                v334 = *(_DWORD *)(v712 + 192);
                v335 = bswap32(*(unsigned __int16 *)(v713 + 340)) >> 16;
                v336 = v31;
                v657 = v50;
                if (v713 == -632)
                {
LABEL_604:
                  while (v336)
                  {
                    v337 = *v336;
                    if (v337 > 0x3F)
                      break;
                    if (!*v336)
                    {
                      v442 = (_WORD)v336 - (_WORD)v31 + 1;
                      goto LABEL_929;
                    }
                    v336 += v337 + 1;
                    if (v713 != -632)
                      goto LABEL_603;
                  }
                }
                else
                {
LABEL_603:
                  if ((unint64_t)v336 < v713 + 632)
                    goto LABEL_604;
                }
                v442 = 257;
LABEL_929:
                v522 = v442;
                v523 = *(unsigned __int16 *)(a3 + 4);
                v524 = __n[0];
                v525 = __n[0] + 2;
                if (v525 <= v671)
                {
                  v526 = v665;
                  *v665 = __rev16(v523);
                  v527 = v61;
                  v528 = v334;
                  v648 = v442;
                  v651 = v335;
                  v689 = v525;
                  memcpy(v665 + 1, v527, v524);
                  v522 = v648;
                  v335 = v651;
                  v525 = v689;
                  v334 = v528;
                }
                else
                {
                  v526 = 0;
                }
                LODWORD(buf.tv_sec) = 67112451;
                HIDWORD(buf.tv_sec) = v334;
                LOWORD(buf.tv_nsec) = 1024;
                *(_DWORD *)((char *)&buf.tv_nsec + 2) = v335;
                HIWORD(buf.tv_nsec) = 1024;
                *(_DWORD *)v716 = a5;
                *(_WORD *)&v716[4] = 1024;
                *(_DWORD *)&v716[6] = a4;
                LOWORD(v717) = 1024;
                *(_DWORD *)((char *)&v717 + 2) = v53;
                HIWORD(v717) = 2160;
                *(_QWORD *)v718 = 1752392040;
                *(_WORD *)&v718[8] = 1040;
                *(_DWORD *)&v718[10] = v522;
                *(_WORD *)&v718[14] = 2101;
                *(_QWORD *)&v718[16] = v31;
                *(_WORD *)&v718[24] = 1024;
                *(_DWORD *)&v718[26] = v695;
                *(_WORD *)&v718[30] = 1026;
                *(_DWORD *)&v718[32] = v54;
                *(_WORD *)&v718[36] = 1024;
                *(_DWORD *)&v718[38] = v523;
                *(_WORD *)&v718[42] = 2160;
                *(_QWORD *)&v718[44] = 1752392040;
                *(_WORD *)&v718[52] = 1040;
                *(_DWORD *)&v718[54] = v525;
                *(_WORD *)&v718[58] = 2101;
                *(_QWORD *)&v718[60] = v526;
                v506 = "[R%u->Q%u] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifind"
                       "ex: %d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:"
                       "dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
LABEL_933:
                v514 = v305;
                goto LABEL_934;
              }
              goto LABEL_1002;
            }
          }
          else
          {
            v45 = 0;
            v58 = 512;
            v59 = (char *)&unk_100164380;
            if (*(_WORD *)(a3 + 12))
              goto LABEL_52;
          }
          v179 = v32;
          if (v28)
            v173 = mDNSLogCategory_Default;
          else
            v173 = mDNSLogCategory_mDNS;
          if (gSensitiveLoggingEnabled != 1 || v173 == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled(v173, OS_LOG_TYPE_DEFAULT))
              goto LABEL_1003;
            v180 = *(_DWORD *)(a7 + 192);
            v181 = bswap32(*(unsigned __int16 *)(v713 + 340)) >> 16;
            v249 = v31;
            if (v713 == -632)
            {
LABEL_415:
              while (v249)
              {
                v250 = *v249;
                if (v250 > 0x3F)
                  break;
                if (!*v249)
                {
                  v418 = (_WORD)v249 - (_WORD)v31 + 1;
                  goto LABEL_855;
                }
                v249 += v250 + 1;
                if (v713 != -632)
                  goto LABEL_414;
              }
            }
            else
            {
LABEL_414:
              if ((unint64_t)v249 < v713 + 632)
                goto LABEL_415;
            }
            v418 = 257;
          }
          else
          {
            if (v28)
              v173 = mDNSLogCategory_Default_redacted;
            else
              v173 = mDNSLogCategory_mDNS;
            if (!os_log_type_enabled(v173, OS_LOG_TYPE_DEFAULT))
              goto LABEL_1003;
            v180 = *(_DWORD *)(a7 + 192);
            v181 = bswap32(*(unsigned __int16 *)(v713 + 340)) >> 16;
            v182 = v31;
            if (v713 == -632)
            {
LABEL_218:
              while (v182)
              {
                v183 = *v182;
                if (v183 > 0x3F)
                  break;
                if (!*v182)
                {
                  v418 = (_WORD)v182 - (_WORD)v31 + 1;
                  goto LABEL_855;
                }
                v182 += v183 + 1;
                if (v713 != -632)
                  goto LABEL_217;
              }
            }
            else
            {
LABEL_217:
              if ((unint64_t)v182 < v713 + 632)
                goto LABEL_218;
            }
            v418 = 257;
          }
LABEL_855:
          v448 = *(unsigned __int16 *)(a3 + 4);
          LODWORD(buf.tv_sec) = 67111683;
          HIDWORD(buf.tv_sec) = v180;
          LOWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)((char *)&buf.tv_nsec + 2) = v181;
          HIWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)v716 = a5;
          *(_WORD *)&v716[4] = 1024;
          *(_DWORD *)&v716[6] = a4;
          LOWORD(v717) = 1024;
          *(_DWORD *)((char *)&v717 + 2) = v53;
          HIWORD(v717) = 2160;
          *(_QWORD *)v718 = 1752392040;
          *(_WORD *)&v718[8] = 1040;
          *(_DWORD *)&v718[10] = v418;
          *(_WORD *)&v718[14] = 2101;
          *(_QWORD *)&v718[16] = v31;
          *(_WORD *)&v718[24] = 1024;
          *(_DWORD *)&v718[26] = v179;
          *(_WORD *)&v718[30] = 1026;
          *(_DWORD *)&v718[32] = v54;
          *(_WORD *)&v718[36] = 1024;
          *(_DWORD *)&v718[38] = v448;
          v426 = "[R%u->Q%u] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d"
                 ", name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_resul"
                 "t}d, type: %{mdns:rrtype}d, rdata: <none>";
          goto LABEL_856;
        }
        v30 = v53;
        if (!*(_WORD *)(v713 + 340))
        {
LABEL_102:
          if (v57)
          {
            v45 = 0;
            v121 = 512;
            v122 = (char *)&unk_100164380;
            if ((_DWORD)v55)
              goto LABEL_104;
          }
          else
          {
            v199 = (char *)malloc_type_malloc(v55, 0xA172743EuLL);
            if (!v199)
              goto LABEL_1111;
            v122 = v199;
            v45 = v199;
            v121 = (unsigned __int16)*v56;
            if (*v56)
            {
LABEL_104:
              *(_DWORD *)&__n[1] = 0;
              __n[0] = 0;
              v123 = ResourceRecordGetRDataBytesPointer(a3, v122, v121, __n, (int *)&__n[1], v34, v35, v36);
              if (*(_DWORD *)&__n[1])
                goto LABEL_1002;
              v124 = (const void *)v123;
              v677 = v30;
              v703 = v32;
              if (__n[0] >= 0x1FFuLL)
              {
                v125 = __n[0] + 2;
                v361 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
                if (!v361)
                  goto LABEL_1111;
                v126 = v361;
                v50 = v361;
              }
              else
              {
                v50 = 0;
                v125 = 512;
                v126 = word_100164580;
              }
              if (v28)
                v357 = mDNSLogCategory_Default;
              else
                v357 = mDNSLogCategory_mDNS;
              if (gSensitiveLoggingEnabled != 1 || v357 == mDNSLogCategory_State)
              {
                if (!os_log_type_enabled(v357, OS_LOG_TYPE_DEFAULT))
                  goto LABEL_1000;
                v362 = *(_DWORD *)(v712 + 192);
                v378 = v31;
                v667 = v50;
                if (v713 == -632)
                {
LABEL_710:
                  while (v378)
                  {
                    v379 = *v378;
                    if (v379 > 0x3F)
                      break;
                    if (!*v378)
                    {
                      v446 = (_WORD)v378 - (_WORD)v31 + 1;
                      goto LABEL_957;
                    }
                    v378 += v379 + 1;
                    if (v713 != -632)
                      goto LABEL_709;
                  }
                }
                else
                {
LABEL_709:
                  if ((unint64_t)v378 < v713 + 632)
                    goto LABEL_710;
                }
                v446 = 257;
LABEL_957:
                v540 = v446;
                v541 = *(unsigned __int16 *)(a3 + 4);
                v542 = __n[0];
                v543 = __n[0] + 2;
                if (v543 > v125)
                {
                  v126 = 0;
                  goto LABEL_960;
                }
              }
              else
              {
                if (v28)
                  v357 = mDNSLogCategory_Default_redacted;
                else
                  v357 = mDNSLogCategory_mDNS;
                if (!os_log_type_enabled(v357, OS_LOG_TYPE_DEFAULT))
                  goto LABEL_1000;
                v362 = *(_DWORD *)(v712 + 192);
                v363 = v31;
                v667 = v50;
                if (v713 == -632)
                {
LABEL_668:
                  while (v363)
                  {
                    v364 = *v363;
                    if (v364 > 0x3F)
                      break;
                    if (!*v363)
                    {
                      v446 = (_WORD)v363 - (_WORD)v31 + 1;
                      goto LABEL_949;
                    }
                    v363 += v364 + 1;
                    if (v713 != -632)
                      goto LABEL_667;
                  }
                }
                else
                {
LABEL_667:
                  if ((unint64_t)v363 < v713 + 632)
                    goto LABEL_668;
                }
                v446 = 257;
LABEL_949:
                v540 = v446;
                v541 = *(unsigned __int16 *)(a3 + 4);
                v542 = __n[0];
                v543 = __n[0] + 2;
                if (v543 > v125)
                {
                  v126 = 0;
LABEL_960:
                  LODWORD(buf.tv_sec) = 67111939;
                  HIDWORD(buf.tv_sec) = v362;
                  LOWORD(buf.tv_nsec) = 1024;
                  *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
                  HIWORD(buf.tv_nsec) = 1024;
                  *(_DWORD *)v716 = a4;
                  *(_WORD *)&v716[4] = 1024;
                  *(_DWORD *)&v716[6] = v677;
                  strcpy((char *)&v717, "p\bhash");
                  HIBYTE(v717) = 0;
                  *(_WORD *)v718 = 0;
                  *(_WORD *)&v718[2] = 1040;
                  *(_DWORD *)&v718[4] = v540;
                  *(_WORD *)&v718[8] = 2101;
                  *(_QWORD *)&v718[10] = v31;
                  *(_WORD *)&v718[18] = 1024;
                  *(_DWORD *)&v718[20] = v703;
                  *(_WORD *)&v718[24] = 1024;
                  *(_DWORD *)&v718[26] = v541;
                  *(_WORD *)&v718[30] = 2160;
                  *(_QWORD *)&v718[32] = 1752392040;
                  *(_WORD *)&v718[40] = 1040;
                  *(_DWORD *)&v718[42] = v543;
                  *(_WORD *)&v718[46] = 2101;
                  *(_QWORD *)&v718[48] = v126;
                  v539 = "[R%u->mDNSQ] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, i"
                         "findex: %d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrty"
                         "pe}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
                  goto LABEL_961;
                }
              }
              *v126 = __rev16(v541);
              v544 = v124;
              v545 = v362;
              v546 = v446;
              memcpy(v126 + 1, v544, v542);
              v540 = v546;
              v362 = v545;
              goto LABEL_960;
            }
          }
          v200 = v32;
          if (v28)
            v195 = mDNSLogCategory_Default;
          else
            v195 = mDNSLogCategory_mDNS;
          if (gSensitiveLoggingEnabled != 1 || v195 == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled(v195, OS_LOG_TYPE_DEFAULT))
              goto LABEL_1003;
            v201 = *(_DWORD *)(a7 + 192);
            v301 = v31;
            if (v713 == -632)
            {
LABEL_520:
              while (v301)
              {
                v302 = *v301;
                if (v302 > 0x3F)
                  break;
                if (!*v301)
                {
                  v424 = (_WORD)v301 - (_WORD)v31 + 1;
                  goto LABEL_895;
                }
                v301 += v302 + 1;
                if (v713 != -632)
                  goto LABEL_519;
              }
            }
            else
            {
LABEL_519:
              if ((unint64_t)v301 < v713 + 632)
                goto LABEL_520;
            }
            v424 = 257;
          }
          else
          {
            if (v28)
              v195 = mDNSLogCategory_Default_redacted;
            else
              v195 = mDNSLogCategory_mDNS;
            if (!os_log_type_enabled(v195, OS_LOG_TYPE_DEFAULT))
              goto LABEL_1003;
            v201 = *(_DWORD *)(a7 + 192);
            v202 = v31;
            if (v713 == -632)
            {
LABEL_278:
              while (v202)
              {
                v203 = *v202;
                if (v203 > 0x3F)
                  break;
                if (!*v202)
                {
                  v424 = (_WORD)v202 - (_WORD)v31 + 1;
                  goto LABEL_895;
                }
                v202 += v203 + 1;
                if (v713 != -632)
                  goto LABEL_277;
              }
            }
            else
            {
LABEL_277:
              if ((unint64_t)v202 < v713 + 632)
                goto LABEL_278;
            }
            v424 = 257;
          }
LABEL_895:
          v492 = *(unsigned __int16 *)(a3 + 4);
          LODWORD(buf.tv_sec) = 67111171;
          HIDWORD(buf.tv_sec) = v201;
          LOWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
          HIWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)v716 = a4;
          *(_WORD *)&v716[4] = 1024;
          *(_DWORD *)&v716[6] = v30;
          strcpy((char *)&v717, "p\bhash");
          HIBYTE(v717) = 0;
          *(_WORD *)v718 = 0;
          *(_WORD *)&v718[2] = 1040;
          *(_DWORD *)&v718[4] = v424;
          *(_WORD *)&v718[8] = 2101;
          *(_QWORD *)&v718[10] = v31;
          *(_WORD *)&v718[18] = 1024;
          *(_DWORD *)&v718[20] = v200;
          *(_WORD *)&v718[24] = 1024;
          *(_DWORD *)&v718[26] = v492;
          v426 = "[R%u->mDNSQ] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: "
                 "%d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: <none>";
          goto LABEL_896;
        }
      }
      else
      {
        v56 = (_WORD *)(a3 + 12);
        LODWORD(v55) = *(unsigned __int16 *)(a3 + 12);
        v57 = v55 < 0x201;
        if (!*(_WORD *)(v713 + 340))
          goto LABEL_102;
      }
      if (v57)
      {
        v45 = 0;
        v96 = 512;
        v97 = (char *)&unk_100164380;
        if ((_DWORD)v55)
          goto LABEL_80;
      }
      else
      {
        v148 = (char *)malloc_type_malloc(v55, 0xA172743EuLL);
        if (!v148)
          goto LABEL_1111;
        v97 = v148;
        v45 = v148;
        v96 = (unsigned __int16)*v56;
        if (*v56)
        {
LABEL_80:
          *(_DWORD *)&__n[1] = 0;
          __n[0] = 0;
          v98 = ResourceRecordGetRDataBytesPointer(a3, v97, v96, __n, (int *)&__n[1], v34, v35, v36);
          if (*(_DWORD *)&__n[1])
            goto LABEL_1002;
          v99 = (const void *)v98;
          v662 = v45;
          v673 = v30;
          v699 = v32;
          if (__n[0] >= 0x1FFuLL)
          {
            v100 = __n[0] + 2;
            v262 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
            if (!v262)
              goto LABEL_1111;
            v101 = v262;
            v50 = v262;
          }
          else
          {
            v50 = 0;
            v100 = 512;
            v101 = word_100164580;
          }
          if (v28)
            v257 = mDNSLogCategory_Default;
          else
            v257 = mDNSLogCategory_mDNS;
          if (gSensitiveLoggingEnabled == 1 && v257 != mDNSLogCategory_State)
          {
            if (v28)
              v257 = mDNSLogCategory_Default_redacted;
            else
              v257 = mDNSLogCategory_mDNS;
            if (!os_log_type_enabled(v257, OS_LOG_TYPE_DEFAULT))
              goto LABEL_878;
            v263 = *(_DWORD *)(v712 + 192);
            v264 = bswap32(*(unsigned __int16 *)(v713 + 340)) >> 16;
            v265 = v31;
            v656 = v50;
            if (v713 == -632)
            {
LABEL_456:
              while (v265)
              {
                v266 = *v265;
                if (v266 > 0x3F)
                  break;
                if (!*v265)
                {
                  v420 = (_WORD)v265 - (_WORD)v31 + 1;
                  goto LABEL_863;
                }
                v265 += v266 + 1;
                if (v713 != -632)
                  goto LABEL_455;
              }
            }
            else
            {
LABEL_455:
              if ((unint64_t)v265 < v713 + 632)
                goto LABEL_456;
            }
            v420 = 257;
LABEL_863:
            v459 = v420;
            v460 = *(unsigned __int16 *)(a3 + 4);
            v461 = __n[0];
            v462 = __n[0] + 2;
            if (v462 <= v100)
            {
              *v101 = __rev16(v460);
              v463 = v99;
              v464 = v263;
              v465 = v264;
              memcpy(v101 + 1, v463, v461);
              v264 = v465;
              v263 = v464;
            }
            else
            {
              v101 = 0;
            }
            LODWORD(buf.tv_sec) = 67112195;
            HIDWORD(buf.tv_sec) = v263;
            LOWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)((char *)&buf.tv_nsec + 2) = v264;
            HIWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)v716 = a5;
            *(_WORD *)&v716[4] = 1024;
            *(_DWORD *)&v716[6] = a4;
            LOWORD(v717) = 1024;
            *(_DWORD *)((char *)&v717 + 2) = v673;
            HIWORD(v717) = 2160;
            *(_QWORD *)v718 = 1752392040;
            *(_WORD *)&v718[8] = 1040;
            *(_DWORD *)&v718[10] = v459;
            *(_WORD *)&v718[14] = 2101;
            *(_QWORD *)&v718[16] = v31;
            *(_WORD *)&v718[24] = 1024;
            *(_DWORD *)&v718[26] = v699;
            *(_WORD *)&v718[30] = 1024;
            *(_DWORD *)&v718[32] = v460;
            *(_WORD *)&v718[36] = 2160;
            *(_QWORD *)&v718[38] = 1752392040;
            *(_WORD *)&v718[46] = 1040;
            *(_DWORD *)&v718[48] = v462;
            *(_WORD *)&v718[52] = 2101;
            *(_QWORD *)&v718[54] = v101;
            v458 = "[R%u->Q%u] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: "
                   "%d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: %"
                   "{sensitive, mask.hash, mdns:rdata}.*P";
            goto LABEL_877;
          }
          if (os_log_type_enabled(v257, OS_LOG_TYPE_DEFAULT))
          {
            v285 = *(_DWORD *)(v712 + 192);
            v286 = bswap32(*(unsigned __int16 *)(v713 + 340)) >> 16;
            v287 = v31;
            v656 = v50;
            if (v713 == -632)
            {
LABEL_498:
              while (v287)
              {
                v288 = *v287;
                if (v288 > 0x3F)
                  break;
                if (!*v287)
                {
                  v422 = (_WORD)v287 - (_WORD)v31 + 1;
                  goto LABEL_873;
                }
                v287 += v288 + 1;
                if (v713 != -632)
                  goto LABEL_497;
              }
            }
            else
            {
LABEL_497:
              if ((unint64_t)v287 < v713 + 632)
                goto LABEL_498;
            }
            v422 = 257;
LABEL_873:
            v473 = v422;
            v474 = *(unsigned __int16 *)(a3 + 4);
            v475 = __n[0];
            v476 = __n[0] + 2;
            if (v476 <= v100)
            {
              *v101 = __rev16(v474);
              v477 = v99;
              v478 = v285;
              v479 = v286;
              memcpy(v101 + 1, v477, v475);
              v286 = v479;
              v285 = v478;
            }
            else
            {
              v101 = 0;
            }
            LODWORD(buf.tv_sec) = 67112195;
            HIDWORD(buf.tv_sec) = v285;
            LOWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)((char *)&buf.tv_nsec + 2) = v286;
            HIWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)v716 = a5;
            *(_WORD *)&v716[4] = 1024;
            *(_DWORD *)&v716[6] = a4;
            LOWORD(v717) = 1024;
            *(_DWORD *)((char *)&v717 + 2) = v673;
            HIWORD(v717) = 2160;
            *(_QWORD *)v718 = 1752392040;
            *(_WORD *)&v718[8] = 1040;
            *(_DWORD *)&v718[10] = v473;
            *(_WORD *)&v718[14] = 2101;
            *(_QWORD *)&v718[16] = v31;
            *(_WORD *)&v718[24] = 1024;
            *(_DWORD *)&v718[26] = v699;
            *(_WORD *)&v718[30] = 1024;
            *(_DWORD *)&v718[32] = v474;
            *(_WORD *)&v718[36] = 2160;
            *(_QWORD *)&v718[38] = 1752392040;
            *(_WORD *)&v718[46] = 1040;
            *(_DWORD *)&v718[48] = v476;
            *(_WORD *)&v718[52] = 2101;
            *(_QWORD *)&v718[54] = v101;
            v458 = "[R%u->Q%u] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: "
                   "%d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: %"
                   "{sensitive, mask.hash, mdns:rdata}.*P";
            goto LABEL_877;
          }
LABEL_878:
          v45 = v662;
          goto LABEL_1000;
        }
      }
      v149 = v32;
      if (v28)
        v143 = mDNSLogCategory_Default;
      else
        v143 = mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || v143 == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled(v143, OS_LOG_TYPE_DEFAULT))
          goto LABEL_1003;
        v150 = *(_DWORD *)(a7 + 192);
        v151 = bswap32(*(unsigned __int16 *)(v713 + 340)) >> 16;
        v227 = v31;
        if (v713 == -632)
        {
LABEL_342:
          while (v227)
          {
            v228 = *v227;
            if (v228 > 0x3F)
              break;
            if (!*v227)
            {
              v381 = (_WORD)v227 - (_WORD)v31 + 1;
              goto LABEL_824;
            }
            v227 += v228 + 1;
            if (v713 != -632)
              goto LABEL_341;
          }
        }
        else
        {
LABEL_341:
          if ((unint64_t)v227 < v713 + 632)
            goto LABEL_342;
        }
        v381 = 257;
      }
      else
      {
        if (v28)
          v143 = mDNSLogCategory_Default_redacted;
        else
          v143 = mDNSLogCategory_mDNS;
        if (!os_log_type_enabled(v143, OS_LOG_TYPE_DEFAULT))
          goto LABEL_1003;
        v150 = *(_DWORD *)(a7 + 192);
        v151 = bswap32(*(unsigned __int16 *)(v713 + 340)) >> 16;
        v152 = v31;
        if (v713 == -632)
        {
LABEL_150:
          while (v152)
          {
            v153 = *v152;
            if (v153 > 0x3F)
              break;
            if (!*v152)
            {
              v381 = (_WORD)v152 - (_WORD)v31 + 1;
              goto LABEL_824;
            }
            v152 += v153 + 1;
            if (v713 != -632)
              goto LABEL_149;
          }
        }
        else
        {
LABEL_149:
          if ((unint64_t)v152 < v713 + 632)
            goto LABEL_150;
        }
        v381 = 257;
      }
LABEL_824:
      v427 = *(unsigned __int16 *)(a3 + 4);
      LODWORD(buf.tv_sec) = 67111427;
      HIDWORD(buf.tv_sec) = v150;
      LOWORD(buf.tv_nsec) = 1024;
      *(_DWORD *)((char *)&buf.tv_nsec + 2) = v151;
      HIWORD(buf.tv_nsec) = 1024;
      *(_DWORD *)v716 = a5;
      *(_WORD *)&v716[4] = 1024;
      *(_DWORD *)&v716[6] = a4;
      LOWORD(v717) = 1024;
      *(_DWORD *)((char *)&v717 + 2) = v30;
      HIWORD(v717) = 2160;
      *(_QWORD *)v718 = 1752392040;
      *(_WORD *)&v718[8] = 1040;
      *(_DWORD *)&v718[10] = v381;
      *(_WORD *)&v718[14] = 2101;
      *(_QWORD *)&v718[16] = v31;
      *(_WORD *)&v718[24] = 1024;
      *(_DWORD *)&v718[26] = v149;
      *(_WORD *)&v718[30] = 1024;
      *(_DWORD *)&v718[32] = v427;
      v426 = "[R%u->Q%u] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, na"
             "me: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: <none>";
      goto LABEL_941;
    }
    v78 = *(_QWORD *)(a3 + 56);
    if (v78)
    {
      v79 = v30;
      v80 = dnssec_obj_resource_record_member_get_validation_result(v78);
      v66 = v713;
      v82 = (_WORD *)(a3 + 12);
      v81 = *(unsigned __int16 *)(a3 + 12);
      v83 = v81 < 0x201;
      if (v80)
      {
        if (!*(_WORD *)(v713 + 340))
        {
          if (v81 >= 0x201)
          {
            v81 = (size_t)malloc_type_malloc(v81, 0xA172743EuLL);
            if (!v81)
              goto LABEL_1111;
            v170 = (char *)v81;
            LODWORD(v81) = (unsigned __int16)*v82;
            v70 = v170;
            v169 = v81;
          }
          else
          {
            v70 = 0;
            v169 = 512;
            v170 = (char *)&unk_100164380;
          }
          if ((_DWORD)v81)
          {
            *(_DWORD *)&__n[1] = 0;
            __n[0] = 0;
            v221 = ResourceRecordGetRDataBytesPointer(a3, v170, v169, __n, (int *)&__n[1], v34, v35, v36);
            if (*(_DWORD *)&__n[1])
              goto LABEL_976;
            v222 = (const void *)v221;
            v707 = v32;
            if (__n[0] >= 0x1FFuLL)
            {
              v223 = __n[0] + 2;
              v224 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
              if (!v224)
                goto LABEL_1111;
              v75 = v224;
            }
            else
            {
              v75 = 0;
              v223 = 512;
              v224 = word_100164580;
            }
            v685 = v224;
            if (v28)
              v389 = mDNSLogCategory_Default;
            else
              v389 = mDNSLogCategory_mDNS;
            if (gSensitiveLoggingEnabled == 1 && v389 != mDNSLogCategory_State)
            {
              if (v28)
                v390 = mDNSLogCategory_Default_redacted;
              else
                v390 = mDNSLogCategory_mDNS;
              if (!os_log_type_enabled(v390, OS_LOG_TYPE_DEFAULT))
                goto LABEL_974;
              v666 = v75;
              v396 = *(_DWORD *)(v712 + 192);
              v397 = *(unsigned __int16 *)(a3 + 4);
              v398 = __n[0];
              v399 = __n[0] + 2;
              if (v399 <= v223)
              {
                v400 = v685;
                *v685 = __rev16(v397);
                v549 = v222;
                v550 = v396;
                memcpy(v685 + 1, v549, v398);
                v396 = v550;
              }
              else
              {
                v400 = 0;
              }
              LODWORD(buf.tv_sec) = 67111427;
              HIDWORD(buf.tv_sec) = v396;
              LOWORD(buf.tv_nsec) = 1024;
              *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
              HIWORD(buf.tv_nsec) = 1024;
              *(_DWORD *)v716 = a4;
              *(_WORD *)&v716[4] = 1024;
              *(_DWORD *)&v716[6] = v79;
              LOWORD(v717) = 1024;
              *(_DWORD *)((char *)&v717 + 2) = v707;
              HIWORD(v717) = 1026;
              *(_DWORD *)v718 = v80;
              *(_WORD *)&v718[4] = 1024;
              *(_DWORD *)&v718[6] = v397;
              *(_WORD *)&v718[10] = 2160;
              *(_QWORD *)&v718[12] = 1752392040;
              *(_WORD *)&v718[20] = 1040;
              *(_DWORD *)&v718[22] = v399;
              *(_WORD *)&v718[26] = 2101;
              *(_QWORD *)&v718[28] = v400;
              v482 = "[R%u->mDNSQ] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifind"
                     "ex: %d, name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sens"
                     "itive, mask.hash, mdns:rdata}.*P";
              goto LABEL_966;
            }
            if (!os_log_type_enabled(v389, OS_LOG_TYPE_DEFAULT))
              goto LABEL_974;
            v666 = v75;
            v412 = *(_DWORD *)(v712 + 192);
            v413 = *(unsigned __int16 *)(a3 + 4);
            v414 = __n[0];
            v415 = __n[0] + 2;
            if (v415 <= v223)
            {
              v416 = v685;
              *v685 = __rev16(v413);
              v553 = v222;
              v554 = v412;
              memcpy(v685 + 1, v553, v414);
              v412 = v554;
            }
            else
            {
              v416 = 0;
            }
            LODWORD(buf.tv_sec) = 67111427;
            HIDWORD(buf.tv_sec) = v412;
            LOWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
            HIWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)v716 = a4;
            *(_WORD *)&v716[4] = 1024;
            *(_DWORD *)&v716[6] = v79;
            LOWORD(v717) = 1024;
            *(_DWORD *)((char *)&v717 + 2) = v707;
            HIWORD(v717) = 1026;
            *(_DWORD *)v718 = v80;
            *(_WORD *)&v718[4] = 1024;
            *(_DWORD *)&v718[6] = v413;
            *(_WORD *)&v718[10] = 2160;
            *(_QWORD *)&v718[12] = 1752392040;
            *(_WORD *)&v718[20] = 1040;
            *(_DWORD *)&v718[22] = v415;
            *(_WORD *)&v718[26] = 2101;
            *(_QWORD *)&v718[28] = v416;
            v482 = "[R%u->mDNSQ] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex"
                   ": %d, name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitiv"
                   "e, mask.hash, mdns:rdata}.*P";
LABEL_971:
            v485 = v389;
            goto LABEL_972;
          }
          v246 = v32;
          if (v28)
            v243 = mDNSLogCategory_Default;
          else
            v243 = mDNSLogCategory_mDNS;
          if (gSensitiveLoggingEnabled != 1 || v243 == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled(v243, OS_LOG_TYPE_DEFAULT))
              goto LABEL_977;
          }
          else
          {
            if (v28)
              v243 = mDNSLogCategory_Default_redacted;
            else
              v243 = mDNSLogCategory_mDNS;
            if (!os_log_type_enabled(v243, OS_LOG_TYPE_DEFAULT))
              goto LABEL_977;
          }
          v354 = *(_DWORD *)(a7 + 192);
          v355 = *(unsigned __int16 *)(a3 + 4);
          LODWORD(buf.tv_sec) = 67110656;
          HIDWORD(buf.tv_sec) = v354;
          LOWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
          HIWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)v716 = a4;
          *(_WORD *)&v716[4] = 1024;
          *(_DWORD *)&v716[6] = v79;
          LOWORD(v717) = 1024;
          *(_DWORD *)((char *)&v717 + 2) = v246;
          HIWORD(v717) = 1026;
          *(_DWORD *)v718 = v80;
          *(_WORD *)&v718[4] = 1024;
          *(_DWORD *)&v718[6] = v355;
          v190 = "[R%u->mDNSQ] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: "
                 "%d, name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: <none>";
LABEL_635:
          v254 = v243;
          v255 = 44;
          goto LABEL_636;
        }
        if (v81 >= 0x201)
        {
          v191 = (char *)malloc_type_malloc(v81, 0xA172743EuLL);
          if (!v191)
            goto LABEL_1111;
          v85 = v191;
          v70 = v191;
          v84 = (unsigned __int16)*v82;
          if (*v82)
          {
LABEL_68:
            *(_DWORD *)&__n[1] = 0;
            __n[0] = 0;
            v86 = ResourceRecordGetRDataBytesPointer(a3, v85, v84, __n, (int *)&__n[1], v34, v35, v36);
            if (!*(_DWORD *)&__n[1])
            {
              v87 = (const void *)v86;
              v697 = v32;
              if (__n[0] >= 0x1FFuLL)
              {
                v88 = __n[0] + 2;
                v89 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
                if (!v89)
                  goto LABEL_1111;
                v75 = v89;
              }
              else
              {
                v75 = 0;
                v88 = 512;
                v89 = word_100164580;
              }
              v683 = v89;
              if (v28)
                v316 = mDNSLogCategory_Default;
              else
                v316 = mDNSLogCategory_mDNS;
              if (gSensitiveLoggingEnabled == 1 && v316 != mDNSLogCategory_State)
              {
                if (v28)
                  v317 = mDNSLogCategory_Default_redacted;
                else
                  v317 = mDNSLogCategory_mDNS;
                if (os_log_type_enabled(v317, OS_LOG_TYPE_DEFAULT))
                {
                  v666 = v75;
                  v324 = *(_DWORD *)(v712 + 192);
                  v325 = bswap32(*(unsigned __int16 *)(v713 + 340)) >> 16;
                  v326 = *(unsigned __int16 *)(a3 + 4);
                  v327 = __n[0];
                  v328 = __n[0] + 2;
                  if (v328 <= v88)
                  {
                    v329 = v683;
                    *v683 = __rev16(v326);
                    v483 = v87;
                    v484 = v324;
                    v659 = v326;
                    memcpy(v683 + 1, v483, v327);
                    v326 = v659;
                    v324 = v484;
                  }
                  else
                  {
                    v329 = 0;
                  }
                  LODWORD(buf.tv_sec) = 67111683;
                  HIDWORD(buf.tv_sec) = v324;
                  LOWORD(buf.tv_nsec) = 1024;
                  *(_DWORD *)((char *)&buf.tv_nsec + 2) = v325;
                  HIWORD(buf.tv_nsec) = 1024;
                  *(_DWORD *)v716 = a5;
                  *(_WORD *)&v716[4] = 1024;
                  *(_DWORD *)&v716[6] = a4;
                  LOWORD(v717) = 1024;
                  *(_DWORD *)((char *)&v717 + 2) = v79;
                  HIWORD(v717) = 1024;
                  *(_DWORD *)v718 = v697;
                  *(_WORD *)&v718[4] = 1026;
                  *(_DWORD *)&v718[6] = v80;
                  *(_WORD *)&v718[10] = 1024;
                  *(_DWORD *)&v718[12] = v326;
                  *(_WORD *)&v718[16] = 2160;
                  *(_QWORD *)&v718[18] = 1752392040;
                  *(_WORD *)&v718[26] = 1040;
                  *(_DWORD *)&v718[28] = v328;
                  *(_WORD *)&v718[32] = 2101;
                  *(_QWORD *)&v718[34] = v329;
                  v482 = "[R%u->Q%u] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifi"
                         "ndex: %d, name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: "
                         "%{sensitive, mask.hash, mdns:rdata}.*P";
                  goto LABEL_883;
                }
LABEL_974:
                a7 = v712;
                if (v75)
                  free(v75);
                goto LABEL_976;
              }
              if (!os_log_type_enabled(v316, OS_LOG_TYPE_DEFAULT))
                goto LABEL_974;
              v666 = v75;
              v344 = *(_DWORD *)(v712 + 192);
              v345 = bswap32(*(unsigned __int16 *)(v713 + 340)) >> 16;
              v346 = *(unsigned __int16 *)(a3 + 4);
              v347 = __n[0];
              v348 = __n[0] + 2;
              if (v348 <= v88)
              {
                v349 = v683;
                *v683 = __rev16(v346);
                v488 = v87;
                v489 = v344;
                v661 = v346;
                memcpy(v683 + 1, v488, v347);
                v346 = v661;
                v344 = v489;
              }
              else
              {
                v349 = 0;
              }
              LODWORD(buf.tv_sec) = 67111683;
              HIDWORD(buf.tv_sec) = v344;
              LOWORD(buf.tv_nsec) = 1024;
              *(_DWORD *)((char *)&buf.tv_nsec + 2) = v345;
              HIWORD(buf.tv_nsec) = 1024;
              *(_DWORD *)v716 = a5;
              *(_WORD *)&v716[4] = 1024;
              *(_DWORD *)&v716[6] = a4;
              LOWORD(v717) = 1024;
              *(_DWORD *)((char *)&v717 + 2) = v79;
              HIWORD(v717) = 1024;
              *(_DWORD *)v718 = v697;
              *(_WORD *)&v718[4] = 1026;
              *(_DWORD *)&v718[6] = v80;
              *(_WORD *)&v718[10] = 1024;
              *(_DWORD *)&v718[12] = v346;
              *(_WORD *)&v718[16] = 2160;
              *(_QWORD *)&v718[18] = 1752392040;
              *(_WORD *)&v718[26] = 1040;
              *(_DWORD *)&v718[28] = v348;
              *(_WORD *)&v718[32] = 2101;
              *(_QWORD *)&v718[34] = v349;
              v482 = "[R%u->Q%u] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex"
                     ": %d, name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensit"
                     "ive, mask.hash, mdns:rdata}.*P";
LABEL_888:
              v485 = v316;
              goto LABEL_889;
            }
LABEL_976:
            v66 = v713;
            goto LABEL_977;
          }
        }
        else
        {
          v70 = 0;
          v84 = 512;
          v85 = (char *)&unk_100164380;
          if (*(_WORD *)(a3 + 12))
            goto LABEL_68;
        }
        v192 = v32;
        if (v28)
          v186 = mDNSLogCategory_Default;
        else
          v186 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || v186 == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v186, OS_LOG_TYPE_DEFAULT))
            goto LABEL_977;
        }
        else
        {
          if (v28)
            v186 = mDNSLogCategory_Default_redacted;
          else
            v186 = mDNSLogCategory_mDNS;
          if (!os_log_type_enabled(v186, OS_LOG_TYPE_DEFAULT))
            goto LABEL_977;
        }
        v251 = *(_DWORD *)(a7 + 192);
        v252 = bswap32(*(unsigned __int16 *)(v713 + 340));
        v253 = *(unsigned __int16 *)(a3 + 4);
        LODWORD(buf.tv_sec) = 67110912;
        HIDWORD(buf.tv_sec) = v251;
        LOWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)((char *)&buf.tv_nsec + 2) = HIWORD(v252);
        HIWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)v716 = a5;
        *(_WORD *)&v716[4] = 1024;
        *(_DWORD *)&v716[6] = a4;
        LOWORD(v717) = 1024;
        *(_DWORD *)((char *)&v717 + 2) = v79;
        HIWORD(v717) = 1024;
        *(_DWORD *)v718 = v192;
        *(_WORD *)&v718[4] = 1026;
        *(_DWORD *)&v718[6] = v80;
        *(_WORD *)&v718[10] = 1024;
        *(_DWORD *)&v718[12] = v253;
        v190 = "[R%u->Q%u] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, "
               "name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: <none>";
        goto LABEL_424;
      }
      v30 = v79;
      if (!*(_WORD *)(v713 + 340))
      {
LABEL_114:
        if (v83)
        {
          v45 = 0;
          v134 = 512;
          v135 = (char *)&unk_100164380;
          if ((_DWORD)v81)
            goto LABEL_116;
        }
        else
        {
          v209 = (char *)malloc_type_malloc(v81, 0xA172743EuLL);
          if (!v209)
            goto LABEL_1111;
          v135 = v209;
          v45 = v209;
          v134 = (unsigned __int16)*v82;
          if (*v82)
          {
LABEL_116:
            *(_DWORD *)&__n[1] = 0;
            __n[0] = 0;
            v136 = ResourceRecordGetRDataBytesPointer(a3, v135, v134, __n, (int *)&__n[1], v34, v35, v36);
            if (*(_DWORD *)&__n[1])
              goto LABEL_907;
            v137 = (const void *)v136;
            v679 = v30;
            v138 = v32;
            if (__n[0] >= 0x1FFuLL)
            {
              v139 = __n[0] + 2;
              v371 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
              if (!v371)
                goto LABEL_1111;
              v140 = v371;
              v106 = v371;
            }
            else
            {
              v106 = 0;
              v139 = 512;
              v140 = word_100164580;
            }
            if (v28)
              v366 = mDNSLogCategory_Default;
            else
              v366 = mDNSLogCategory_mDNS;
            if (gSensitiveLoggingEnabled != 1 || v366 == mDNSLogCategory_State)
            {
              if (!os_log_type_enabled(v366, OS_LOG_TYPE_DEFAULT))
                goto LABEL_905;
              v663 = v106;
              v372 = *(_DWORD *)(v712 + 192);
              v373 = *(unsigned __int16 *)(a3 + 4);
              v374 = __n[0];
              v375 = __n[0] + 2;
              if (v375 > v139)
              {
                v140 = 0;
                goto LABEL_902;
              }
            }
            else
            {
              if (v28)
                v366 = mDNSLogCategory_Default_redacted;
              else
                v366 = mDNSLogCategory_mDNS;
              if (!os_log_type_enabled(v366, OS_LOG_TYPE_DEFAULT))
                goto LABEL_905;
              v663 = v106;
              v372 = *(_DWORD *)(v712 + 192);
              v373 = *(unsigned __int16 *)(a3 + 4);
              v374 = __n[0];
              v375 = __n[0] + 2;
              if (v375 > v139)
              {
                v140 = 0;
LABEL_902:
                LODWORD(buf.tv_sec) = 67111171;
                HIDWORD(buf.tv_sec) = v372;
                LOWORD(buf.tv_nsec) = 1024;
                *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
                HIWORD(buf.tv_nsec) = 1024;
                *(_DWORD *)v716 = a4;
                *(_WORD *)&v716[4] = 1024;
                *(_DWORD *)&v716[6] = v679;
                LOWORD(v717) = 1024;
                *(_DWORD *)((char *)&v717 + 2) = v138;
                HIWORD(v717) = 1024;
                *(_DWORD *)v718 = v373;
                *(_WORD *)&v718[4] = 2160;
                *(_QWORD *)&v718[6] = 1752392040;
                *(_WORD *)&v718[14] = 1040;
                *(_DWORD *)&v718[16] = v375;
                *(_WORD *)&v718[20] = 2101;
                *(_QWORD *)&v718[22] = v140;
                v430 = "[R%u->mDNSQ] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifi"
                       "ndex: %d, name hash: %x, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
                goto LABEL_903;
              }
            }
            *v140 = __rev16(v373);
            v494 = v372;
            memcpy(v140 + 1, v137, v374);
            v372 = v494;
            goto LABEL_902;
          }
        }
        v210 = v32;
        if (v28)
          v206 = mDNSLogCategory_Default;
        else
          v206 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || v206 == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v206, OS_LOG_TYPE_DEFAULT))
            goto LABEL_1004;
        }
        else
        {
          if (v28)
            v206 = mDNSLogCategory_Default_redacted;
          else
            v206 = mDNSLogCategory_mDNS;
          if (!os_log_type_enabled(v206, OS_LOG_TYPE_DEFAULT))
            goto LABEL_1004;
        }
        v303 = *(_DWORD *)(a7 + 192);
        v304 = *(unsigned __int16 *)(a3 + 4);
        LODWORD(buf.tv_sec) = 67110400;
        HIDWORD(buf.tv_sec) = v303;
        LOWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
        HIWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)v716 = a4;
        *(_WORD *)&v716[4] = 1024;
        *(_DWORD *)&v716[6] = v30;
        LOWORD(v717) = 1024;
        *(_DWORD *)((char *)&v717 + 2) = v210;
        HIWORD(v717) = 1024;
        *(_DWORD *)v718 = v304;
        v160 = "[R%u->mDNSQ] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d"
               ", name hash: %x, type: %{mdns:rrtype}d, rdata: <none>";
        goto LABEL_529;
      }
    }
    else
    {
      v66 = v713;
      v82 = (_WORD *)(a3 + 12);
      LODWORD(v81) = *(unsigned __int16 *)(a3 + 12);
      v83 = v81 < 0x201;
      if (!*(_WORD *)(v713 + 340))
        goto LABEL_114;
    }
    if (v83)
    {
      v45 = 0;
      v109 = 512;
      v110 = (char *)&unk_100164380;
      if ((_DWORD)v81)
      {
LABEL_92:
        *(_DWORD *)&__n[1] = 0;
        __n[0] = 0;
        v111 = ResourceRecordGetRDataBytesPointer(a3, v110, v109, __n, (int *)&__n[1], v34, v35, v36);
        if (*(_DWORD *)&__n[1])
          goto LABEL_907;
        v112 = (const void *)v111;
        v675 = v30;
        v701 = v32;
        if (__n[0] >= 0x1FFuLL)
        {
          v113 = __n[0] + 2;
          v275 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
          if (!v275)
            goto LABEL_1111;
          v114 = v275;
          v106 = v275;
        }
        else
        {
          v106 = 0;
          v113 = 512;
          v114 = word_100164580;
        }
        if (v28)
          v268 = mDNSLogCategory_Default;
        else
          v268 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled == 1 && v268 != mDNSLogCategory_State)
        {
          if (v28)
            v269 = mDNSLogCategory_Default_redacted;
          else
            v269 = mDNSLogCategory_mDNS;
          if (!os_log_type_enabled(v269, OS_LOG_TYPE_DEFAULT))
            goto LABEL_905;
          v663 = v106;
          v276 = *(_DWORD *)(v712 + 192);
          v277 = bswap32(*(unsigned __int16 *)(v713 + 340)) >> 16;
          v278 = *(unsigned __int16 *)(a3 + 4);
          v279 = __n[0];
          v280 = __n[0] + 2;
          if (v280 <= v113)
          {
            *v114 = __rev16(v278);
            v431 = v112;
            v432 = v277;
            memcpy(v114 + 1, v431, v279);
            v277 = v432;
          }
          else
          {
            v114 = 0;
          }
          LODWORD(buf.tv_sec) = 67111427;
          HIDWORD(buf.tv_sec) = v276;
          LOWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)((char *)&buf.tv_nsec + 2) = v277;
          HIWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)v716 = a5;
          *(_WORD *)&v716[4] = 1024;
          *(_DWORD *)&v716[6] = a4;
          LOWORD(v717) = 1024;
          *(_DWORD *)((char *)&v717 + 2) = v675;
          HIWORD(v717) = 1024;
          *(_DWORD *)v718 = v701;
          *(_WORD *)&v718[4] = 1024;
          *(_DWORD *)&v718[6] = v278;
          *(_WORD *)&v718[10] = 2160;
          *(_QWORD *)&v718[12] = 1752392040;
          *(_WORD *)&v718[20] = 1040;
          *(_DWORD *)&v718[22] = v280;
          *(_WORD *)&v718[26] = 2101;
          *(_QWORD *)&v718[28] = v114;
          v430 = "[R%u->Q%u] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d"
                 ", name hash: %x, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
          goto LABEL_831;
        }
        if (!os_log_type_enabled(v268, OS_LOG_TYPE_DEFAULT))
          goto LABEL_905;
        v663 = v106;
        v294 = *(_DWORD *)(v712 + 192);
        v295 = bswap32(*(unsigned __int16 *)(v713 + 340)) >> 16;
        v296 = *(unsigned __int16 *)(a3 + 4);
        v297 = __n[0];
        v298 = __n[0] + 2;
        if (v298 <= v113)
        {
          *v114 = __rev16(v296);
          v436 = v112;
          v437 = v295;
          memcpy(v114 + 1, v436, v297);
          v295 = v437;
        }
        else
        {
          v114 = 0;
        }
        LODWORD(buf.tv_sec) = 67111427;
        HIDWORD(buf.tv_sec) = v294;
        LOWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)((char *)&buf.tv_nsec + 2) = v295;
        HIWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)v716 = a5;
        *(_WORD *)&v716[4] = 1024;
        *(_DWORD *)&v716[6] = a4;
        LOWORD(v717) = 1024;
        *(_DWORD *)((char *)&v717 + 2) = v675;
        HIWORD(v717) = 1024;
        *(_DWORD *)v718 = v701;
        *(_WORD *)&v718[4] = 1024;
        *(_DWORD *)&v718[6] = v296;
        *(_WORD *)&v718[10] = 2160;
        *(_QWORD *)&v718[12] = 1752392040;
        *(_WORD *)&v718[20] = 1040;
        *(_DWORD *)&v718[22] = v298;
        *(_WORD *)&v718[26] = 2101;
        *(_QWORD *)&v718[28] = v114;
        v430 = "[R%u->Q%u] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, "
               "name hash: %x, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
LABEL_836:
        v433 = v268;
        goto LABEL_837;
      }
    }
    else
    {
      v161 = (char *)malloc_type_malloc(v81, 0xA172743EuLL);
      if (!v161)
        goto LABEL_1111;
      v110 = v161;
      v45 = v161;
      v109 = (unsigned __int16)*v82;
      if (*v82)
        goto LABEL_92;
    }
    v162 = v32;
    if (v28)
      v156 = mDNSLogCategory_Default;
    else
      v156 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || v156 == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled(v156, OS_LOG_TYPE_DEFAULT))
        goto LABEL_1004;
    }
    else
    {
      if (v28)
        v156 = mDNSLogCategory_Default_redacted;
      else
        v156 = mDNSLogCategory_mDNS;
      if (!os_log_type_enabled(v156, OS_LOG_TYPE_DEFAULT))
        goto LABEL_1004;
    }
    v229 = *(_DWORD *)(a7 + 192);
    v230 = bswap32(*(unsigned __int16 *)(v66 + 340));
    v231 = *(unsigned __int16 *)(a3 + 4);
    LODWORD(buf.tv_sec) = 67110656;
    HIDWORD(buf.tv_sec) = v229;
    LOWORD(buf.tv_nsec) = 1024;
    *(_DWORD *)((char *)&buf.tv_nsec + 2) = HIWORD(v230);
    HIWORD(buf.tv_nsec) = 1024;
    *(_DWORD *)v716 = a5;
    *(_WORD *)&v716[4] = 1024;
    *(_DWORD *)&v716[6] = a4;
    LOWORD(v717) = 1024;
    *(_DWORD *)((char *)&v717 + 2) = v30;
    HIWORD(v717) = 1024;
    *(_DWORD *)v718 = v162;
    *(_WORD *)&v718[4] = 1024;
    *(_DWORD *)&v718[6] = v231;
    v160 = "[R%u->Q%u] DNSServiceGetAddrInfo result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name"
           " hash: %x, type: %{mdns:rrtype}d, rdata: <none>";
    goto LABEL_351;
  }
  if (v38)
  {
    *(_DWORD *)(a7 + 200) = buf.tv_sec;
    v39 = *(_QWORD *)(a3 + 56);
    if (v39)
    {
      v40 = v30;
      v41 = dnssec_obj_resource_record_member_get_validation_result(v39);
      v43 = (_WORD *)(a3 + 12);
      v42 = *(unsigned __int16 *)(a3 + 12);
      v44 = v42 < 0x201;
      if (v41)
      {
        if (*(_WORD *)(v713 + 340))
        {
          if (v42 >= 0x201)
          {
            v171 = (char *)malloc_type_malloc(v42, 0xA172743EuLL);
            if (!v171)
              goto LABEL_1111;
            v47 = v171;
            v45 = v171;
            v46 = (unsigned __int16)*v43;
            if (*v43)
            {
LABEL_43:
              *(_DWORD *)&__n[1] = 0;
              __n[0] = 0;
              v48 = ResourceRecordGetRDataBytesPointer(a3, v47, v46, __n, (int *)&__n[1], v34, v35, v36);
              if (!*(_DWORD *)&__n[1])
              {
                v49 = (const void *)v48;
                v694 = v32;
                if (__n[0] < 0x1FFuLL)
                {
                  v50 = 0;
                  v670 = 512;
                  v51 = word_100164580;
LABEL_533:
                  v664 = v51;
                  if (v28)
                    v305 = mDNSLogCategory_Default;
                  else
                    v305 = mDNSLogCategory_mDNS;
                  if (gSensitiveLoggingEnabled == 1 && v305 != mDNSLogCategory_State)
                  {
                    if (v28)
                      v306 = mDNSLogCategory_Default_redacted;
                    else
                      v306 = mDNSLogCategory_mDNS;
                    if (os_log_type_enabled(v306, OS_LOG_TYPE_DEFAULT))
                    {
                      v307 = *(_DWORD *)(v712 + 192);
                      v308 = bswap32(*(unsigned __int16 *)(v713 + 340)) >> 16;
                      v309 = v31;
                      v649 = v306;
                      v657 = v50;
                      if (v713 == -632)
                      {
LABEL_544:
                        while (v309)
                        {
                          v310 = *v309;
                          if (v310 > 0x3F)
                            break;
                          if (!*v309)
                          {
                            v439 = (_WORD)v309 - (_WORD)v31 + 1;
                            goto LABEL_913;
                          }
                          v309 += v310 + 1;
                          if (v713 != -632)
                            goto LABEL_543;
                        }
                      }
                      else
                      {
LABEL_543:
                        if ((unint64_t)v309 < v713 + 632)
                          goto LABEL_544;
                      }
                      v439 = 257;
LABEL_913:
                      v499 = v439;
                      v500 = *(unsigned __int16 *)(a3 + 4);
                      v501 = __n[0];
                      v502 = __n[0] + 2;
                      if (v502 <= v670)
                      {
                        v503 = v664;
                        *v664 = __rev16(v500);
                        v504 = v49;
                        v505 = v307;
                        v686 = v500;
                        v645 = v439;
                        memcpy(v664 + 1, v504, v501);
                        v499 = v645;
                        v500 = v686;
                        v307 = v505;
                      }
                      else
                      {
                        v503 = 0;
                      }
                      LODWORD(buf.tv_sec) = 67112451;
                      HIDWORD(buf.tv_sec) = v307;
                      LOWORD(buf.tv_nsec) = 1024;
                      *(_DWORD *)((char *)&buf.tv_nsec + 2) = v308;
                      HIWORD(buf.tv_nsec) = 1024;
                      *(_DWORD *)v716 = a5;
                      *(_WORD *)&v716[4] = 1024;
                      *(_DWORD *)&v716[6] = a4;
                      LOWORD(v717) = 1024;
                      *(_DWORD *)((char *)&v717 + 2) = v40;
                      HIWORD(v717) = 2160;
                      *(_QWORD *)v718 = 1752392040;
                      *(_WORD *)&v718[8] = 1040;
                      *(_DWORD *)&v718[10] = v499;
                      *(_WORD *)&v718[14] = 2101;
                      *(_QWORD *)&v718[16] = v31;
                      *(_WORD *)&v718[24] = 1024;
                      *(_DWORD *)&v718[26] = v694;
                      *(_WORD *)&v718[30] = 1026;
                      *(_DWORD *)&v718[32] = v41;
                      *(_WORD *)&v718[36] = 1024;
                      *(_DWORD *)&v718[38] = v500;
                      *(_WORD *)&v718[42] = 2160;
                      *(_QWORD *)&v718[44] = 1752392040;
                      *(_WORD *)&v718[52] = 1040;
                      *(_DWORD *)&v718[54] = v502;
                      *(_WORD *)&v718[58] = 2101;
                      *(_QWORD *)&v718[60] = v503;
                      v506 = "[R%u->Q%u] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d,"
                             " ifindex: %d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{p"
                             "ublic, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
LABEL_922:
                      v514 = v649;
LABEL_934:
                      v529 = 102;
LABEL_999:
                      _os_log_impl((void *)&_mh_execute_header, v514, OS_LOG_TYPE_DEFAULT, v506, (uint8_t *)&buf, v529);
                      v50 = v657;
                      goto LABEL_1000;
                    }
                    goto LABEL_1000;
                  }
                  if (!os_log_type_enabled(v305, OS_LOG_TYPE_DEFAULT))
                    goto LABEL_1000;
                  v330 = *(_DWORD *)(v712 + 192);
                  v331 = bswap32(*(unsigned __int16 *)(v713 + 340)) >> 16;
                  v332 = v31;
                  v657 = v50;
                  if (v713 == -632)
                  {
LABEL_596:
                    while (v332)
                    {
                      v333 = *v332;
                      if (v333 > 0x3F)
                        break;
                      if (!*v332)
                      {
                        v441 = (_WORD)v332 - (_WORD)v31 + 1;
                        goto LABEL_924;
                      }
                      v332 += v333 + 1;
                      if (v713 != -632)
                        goto LABEL_595;
                    }
                  }
                  else
                  {
LABEL_595:
                    if ((unint64_t)v332 < v713 + 632)
                      goto LABEL_596;
                  }
                  v441 = 257;
LABEL_924:
                  v515 = v441;
                  v516 = *(unsigned __int16 *)(a3 + 4);
                  v517 = __n[0];
                  v518 = __n[0] + 2;
                  if (v518 <= v670)
                  {
                    v519 = v664;
                    *v664 = __rev16(v516);
                    v520 = v49;
                    v521 = v330;
                    v647 = v441;
                    v650 = v331;
                    v688 = v518;
                    memcpy(v664 + 1, v520, v517);
                    v515 = v647;
                    v331 = v650;
                    v518 = v688;
                    v330 = v521;
                  }
                  else
                  {
                    v519 = 0;
                  }
                  LODWORD(buf.tv_sec) = 67112451;
                  HIDWORD(buf.tv_sec) = v330;
                  LOWORD(buf.tv_nsec) = 1024;
                  *(_DWORD *)((char *)&buf.tv_nsec + 2) = v331;
                  HIWORD(buf.tv_nsec) = 1024;
                  *(_DWORD *)v716 = a5;
                  *(_WORD *)&v716[4] = 1024;
                  *(_DWORD *)&v716[6] = a4;
                  LOWORD(v717) = 1024;
                  *(_DWORD *)((char *)&v717 + 2) = v40;
                  HIWORD(v717) = 2160;
                  *(_QWORD *)v718 = 1752392040;
                  *(_WORD *)&v718[8] = 1040;
                  *(_DWORD *)&v718[10] = v515;
                  *(_WORD *)&v718[14] = 2101;
                  *(_QWORD *)&v718[16] = v31;
                  *(_WORD *)&v718[24] = 1024;
                  *(_DWORD *)&v718[26] = v694;
                  *(_WORD *)&v718[30] = 1026;
                  *(_DWORD *)&v718[32] = v41;
                  *(_WORD *)&v718[36] = 1024;
                  *(_DWORD *)&v718[38] = v516;
                  *(_WORD *)&v718[42] = 2160;
                  *(_QWORD *)&v718[44] = 1752392040;
                  *(_WORD *)&v718[52] = 1040;
                  *(_DWORD *)&v718[54] = v518;
                  *(_WORD *)&v718[58] = 2101;
                  *(_QWORD *)&v718[60] = v519;
                  v506 = "[R%u->Q%u] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifi"
                         "ndex: %d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, m"
                         "dns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
                  goto LABEL_933;
                }
                v670 = __n[0] + 2;
                v51 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
                if (v51)
                {
                  v50 = v51;
                  goto LABEL_533;
                }
LABEL_1111:
                __break(1u);
              }
LABEL_1002:
              a7 = v712;
              goto LABEL_1003;
            }
          }
          else
          {
            v45 = 0;
            v46 = 512;
            v47 = (char *)&unk_100164380;
            if (*(_WORD *)(a3 + 12))
              goto LABEL_43;
          }
          v172 = v32;
          if (v28)
            v173 = mDNSLogCategory_Default;
          else
            v173 = mDNSLogCategory_mDNS;
          if (gSensitiveLoggingEnabled == 1 && v173 != mDNSLogCategory_State)
          {
            if (v28)
              v173 = mDNSLogCategory_Default_redacted;
            else
              v173 = mDNSLogCategory_mDNS;
            if (!os_log_type_enabled(v173, OS_LOG_TYPE_DEFAULT))
              goto LABEL_1003;
            v174 = *(_DWORD *)(a7 + 192);
            v175 = bswap32(*(unsigned __int16 *)(v713 + 340)) >> 16;
            v176 = v31;
            if (v713 == -632)
            {
LABEL_200:
              while (v176)
              {
                v177 = *v176;
                if (v177 > 0x3F)
                  break;
                if (!*v176)
                {
                  v417 = (_WORD)v176 - (_WORD)v31 + 1;
                  goto LABEL_851;
                }
                v176 += v177 + 1;
                if (v713 != -632)
                  goto LABEL_199;
              }
            }
            else
            {
LABEL_199:
              if ((unint64_t)v176 < v713 + 632)
                goto LABEL_200;
            }
            v417 = 257;
            goto LABEL_851;
          }
          if (os_log_type_enabled(v173, OS_LOG_TYPE_DEFAULT))
          {
            v174 = *(_DWORD *)(a7 + 192);
            v175 = bswap32(*(unsigned __int16 *)(v713 + 340)) >> 16;
            v247 = v31;
            if (v713 == -632)
            {
LABEL_407:
              while (v247)
              {
                v248 = *v247;
                if (v248 > 0x3F)
                  break;
                if (!*v247)
                {
                  v417 = (_WORD)v247 - (_WORD)v31 + 1;
                  goto LABEL_851;
                }
                v247 += v248 + 1;
                if (v713 != -632)
                  goto LABEL_406;
              }
            }
            else
            {
LABEL_406:
              if ((unint64_t)v247 < v713 + 632)
                goto LABEL_407;
            }
            v417 = 257;
LABEL_851:
            v447 = *(unsigned __int16 *)(a3 + 4);
            LODWORD(buf.tv_sec) = 67111683;
            HIDWORD(buf.tv_sec) = v174;
            LOWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)((char *)&buf.tv_nsec + 2) = v175;
            HIWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)v716 = a5;
            *(_WORD *)&v716[4] = 1024;
            *(_DWORD *)&v716[6] = a4;
            LOWORD(v717) = 1024;
            *(_DWORD *)((char *)&v717 + 2) = v40;
            HIWORD(v717) = 2160;
            *(_QWORD *)v718 = 1752392040;
            *(_WORD *)&v718[8] = 1040;
            *(_DWORD *)&v718[10] = v417;
            *(_WORD *)&v718[14] = 2101;
            *(_QWORD *)&v718[16] = v31;
            *(_WORD *)&v718[24] = 1024;
            *(_DWORD *)&v718[26] = v172;
            *(_WORD *)&v718[30] = 1026;
            *(_DWORD *)&v718[32] = v41;
            *(_WORD *)&v718[36] = 1024;
            *(_DWORD *)&v718[38] = v447;
            v426 = "[R%u->Q%u] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: "
                   "%d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_r"
                   "esult}d, type: %{mdns:rrtype}d, rdata: <none>";
LABEL_856:
            v449 = v173;
            v450 = 76;
LABEL_942:
            _os_log_impl((void *)&_mh_execute_header, v449, OS_LOG_TYPE_DEFAULT, v426, (uint8_t *)&buf, v450);
          }
LABEL_1003:
          v66 = v713;
          goto LABEL_1004;
        }
        if (v42 >= 0x201)
        {
          v42 = (size_t)malloc_type_malloc(v42, 0xA172743EuLL);
          if (!v42)
            goto LABEL_1111;
          v164 = (char *)v42;
          LODWORD(v42) = (unsigned __int16)*v43;
          v45 = v164;
          v163 = v42;
        }
        else
        {
          v45 = 0;
          v163 = 512;
          v164 = (char *)&unk_100164380;
        }
        if ((_DWORD)v42)
        {
          *(_DWORD *)&__n[1] = 0;
          __n[0] = 0;
          v211 = ResourceRecordGetRDataBytesPointer(a3, v164, v163, __n, (int *)&__n[1], v34, v35, v36);
          if (*(_DWORD *)&__n[1])
            goto LABEL_1002;
          v212 = (const void *)v211;
          v704 = v32;
          if (__n[0] >= 0x1FFuLL)
          {
            v680 = __n[0] + 2;
            v213 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
            if (!v213)
              goto LABEL_1111;
            v50 = v213;
          }
          else
          {
            v50 = 0;
            v680 = 512;
            v213 = word_100164580;
          }
          v668 = v213;
          if (v28)
            v382 = mDNSLogCategory_Default;
          else
            v382 = mDNSLogCategory_mDNS;
          if (gSensitiveLoggingEnabled != 1 || v382 == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled(v382, OS_LOG_TYPE_DEFAULT))
              goto LABEL_1000;
            v401 = *(_DWORD *)(v712 + 192);
            v402 = v31;
            v657 = v50;
            if (v713 == -632)
            {
LABEL_790:
              while (v402)
              {
                v403 = *v402;
                if (v403 > 0x3F)
                  break;
                if (!*v402)
                {
                  v497 = (_WORD)v402 - (_WORD)v31 + 1;
                  goto LABEL_989;
                }
                v402 += v403 + 1;
                if (v713 != -632)
                  goto LABEL_789;
              }
            }
            else
            {
LABEL_789:
              if ((unint64_t)v402 < v713 + 632)
                goto LABEL_790;
            }
            v497 = 257;
LABEL_989:
            v571 = v497;
            v572 = *(unsigned __int16 *)(a3 + 4);
            v573 = __n[0];
            v574 = __n[0] + 2;
            if (v574 <= v680)
            {
              v575 = v668;
              *v668 = __rev16(v572);
              v576 = v212;
              v577 = v401;
              v654 = v572;
              v692 = v574;
              memcpy(v668 + 1, v576, v573);
              v574 = v692;
              v572 = v654;
              v401 = v577;
            }
            else
            {
              v575 = 0;
            }
            LODWORD(buf.tv_sec) = 67112195;
            HIDWORD(buf.tv_sec) = v401;
            LOWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
            HIWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)v716 = a4;
            *(_WORD *)&v716[4] = 1024;
            *(_DWORD *)&v716[6] = v40;
            strcpy((char *)&v717, "p\bhash");
            HIBYTE(v717) = 0;
            *(_WORD *)v718 = 0;
            *(_WORD *)&v718[2] = 1040;
            *(_DWORD *)&v718[4] = v571;
            *(_WORD *)&v718[8] = 2101;
            *(_QWORD *)&v718[10] = v31;
            *(_WORD *)&v718[18] = 1024;
            *(_DWORD *)&v718[20] = v704;
            *(_WORD *)&v718[24] = 1026;
            *(_DWORD *)&v718[26] = v41;
            *(_WORD *)&v718[30] = 1024;
            *(_DWORD *)&v718[32] = v572;
            *(_WORD *)&v718[36] = 2160;
            *(_QWORD *)&v718[38] = 1752392040;
            *(_WORD *)&v718[46] = 1040;
            *(_DWORD *)&v718[48] = v574;
            *(_WORD *)&v718[52] = 2101;
            *(_QWORD *)&v718[54] = v575;
            v506 = "[R%u->mDNSQ] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex"
                   ": %d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec"
                   "_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
          }
          else
          {
            if (v28)
              v382 = mDNSLogCategory_Default_redacted;
            else
              v382 = mDNSLogCategory_mDNS;
            if (!os_log_type_enabled(v382, OS_LOG_TYPE_DEFAULT))
              goto LABEL_1000;
            v383 = *(_DWORD *)(v712 + 192);
            v384 = v31;
            v657 = v50;
            if (v713 == -632)
            {
LABEL_738:
              while (v384)
              {
                v385 = *v384;
                if (v385 > 0x3F)
                  break;
                if (!*v384)
                {
                  v495 = (_WORD)v384 - (_WORD)v31 + 1;
                  goto LABEL_979;
                }
                v384 += v385 + 1;
                if (v713 != -632)
                  goto LABEL_737;
              }
            }
            else
            {
LABEL_737:
              if ((unint64_t)v384 < v713 + 632)
                goto LABEL_738;
            }
            v495 = 257;
LABEL_979:
            v555 = v495;
            v556 = *(unsigned __int16 *)(a3 + 4);
            v557 = __n[0];
            v558 = __n[0] + 2;
            if (v558 <= v680)
            {
              v559 = v668;
              *v668 = __rev16(v556);
              v560 = v212;
              v561 = v383;
              v690 = v382;
              v562 = v556;
              v652 = v495;
              memcpy(v668 + 1, v560, v557);
              v555 = v652;
              v556 = v562;
              v382 = v690;
              v383 = v561;
            }
            else
            {
              v559 = 0;
            }
            LODWORD(buf.tv_sec) = 67112195;
            HIDWORD(buf.tv_sec) = v383;
            LOWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
            HIWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)v716 = a4;
            *(_WORD *)&v716[4] = 1024;
            *(_DWORD *)&v716[6] = v40;
            strcpy((char *)&v717, "p\bhash");
            HIBYTE(v717) = 0;
            *(_WORD *)v718 = 0;
            *(_WORD *)&v718[2] = 1040;
            *(_DWORD *)&v718[4] = v555;
            *(_WORD *)&v718[8] = 2101;
            *(_QWORD *)&v718[10] = v31;
            *(_WORD *)&v718[18] = 1024;
            *(_DWORD *)&v718[20] = v704;
            *(_WORD *)&v718[24] = 1026;
            *(_DWORD *)&v718[26] = v41;
            *(_WORD *)&v718[30] = 1024;
            *(_DWORD *)&v718[32] = v556;
            *(_WORD *)&v718[36] = 2160;
            *(_QWORD *)&v718[38] = 1752392040;
            *(_WORD *)&v718[46] = 1040;
            *(_DWORD *)&v718[48] = v558;
            *(_WORD *)&v718[52] = 2101;
            *(_QWORD *)&v718[54] = v559;
            v506 = "[R%u->mDNSQ] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex"
                   ": %d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec"
                   "_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
          }
LABEL_998:
          v514 = v382;
          v529 = 96;
          goto LABEL_999;
        }
        v234 = v32;
        if (v28)
          v143 = mDNSLogCategory_Default;
        else
          v143 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || v143 == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v143, OS_LOG_TYPE_DEFAULT))
            goto LABEL_1003;
          v235 = *(_DWORD *)(a7 + 192);
          v350 = v31;
          if (v713 == -632)
          {
LABEL_618:
            while (v350)
            {
              v351 = *v350;
              if (v351 > 0x3F)
                break;
              if (!*v350)
              {
                v443 = (_WORD)v350 - (_WORD)v31 + 1;
                goto LABEL_936;
              }
              v350 += v351 + 1;
              if (v713 != -632)
                goto LABEL_617;
            }
          }
          else
          {
LABEL_617:
            if ((unint64_t)v350 < v713 + 632)
              goto LABEL_618;
          }
          v443 = 257;
        }
        else
        {
          if (v28)
            v143 = mDNSLogCategory_Default_redacted;
          else
            v143 = mDNSLogCategory_mDNS;
          if (!os_log_type_enabled(v143, OS_LOG_TYPE_DEFAULT))
            goto LABEL_1003;
          v235 = *(_DWORD *)(a7 + 192);
          v236 = v31;
          if (v713 == -632)
          {
LABEL_363:
            while (v236)
            {
              v237 = *v236;
              if (v237 > 0x3F)
                break;
              if (!*v236)
              {
                v443 = (_WORD)v236 - (_WORD)v31 + 1;
                goto LABEL_936;
              }
              v236 += v237 + 1;
              if (v713 != -632)
                goto LABEL_362;
            }
          }
          else
          {
LABEL_362:
            if ((unint64_t)v236 < v713 + 632)
              goto LABEL_363;
          }
          v443 = 257;
        }
LABEL_936:
        v530 = *(unsigned __int16 *)(a3 + 4);
        LODWORD(buf.tv_sec) = 67111427;
        HIDWORD(buf.tv_sec) = v235;
        LOWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
        HIWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)v716 = a4;
        *(_WORD *)&v716[4] = 1024;
        *(_DWORD *)&v716[6] = v40;
        strcpy((char *)&v717, "p\bhash");
        HIBYTE(v717) = 0;
        *(_WORD *)v718 = 0;
        *(_WORD *)&v718[2] = 1040;
        *(_DWORD *)&v718[4] = v443;
        *(_WORD *)&v718[8] = 2101;
        *(_QWORD *)&v718[10] = v31;
        *(_WORD *)&v718[18] = 1024;
        *(_DWORD *)&v718[20] = v234;
        *(_WORD *)&v718[24] = 1026;
        *(_DWORD *)&v718[26] = v41;
        *(_WORD *)&v718[30] = 1024;
        *(_DWORD *)&v718[32] = v530;
        v426 = "[R%u->mDNSQ] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d"
               ", name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), dnssec: %{public, mdns:dnssec_result}"
               "d, type: %{mdns:rrtype}d, rdata: <none>";
        goto LABEL_941;
      }
      v30 = v40;
      if (!*(_WORD *)(v713 + 340))
        goto LABEL_96;
    }
    else
    {
      v43 = (_WORD *)(a3 + 12);
      LODWORD(v42) = *(unsigned __int16 *)(a3 + 12);
      v44 = v42 < 0x201;
      if (!*(_WORD *)(v713 + 340))
      {
LABEL_96:
        if (v44)
        {
          v45 = 0;
          v115 = 512;
          v116 = (char *)&unk_100164380;
          if ((_DWORD)v42)
            goto LABEL_98;
        }
        else
        {
          v193 = (char *)malloc_type_malloc(v42, 0xA172743EuLL);
          if (!v193)
            goto LABEL_1111;
          v116 = v193;
          v45 = v193;
          v115 = (unsigned __int16)*v43;
          if (*v43)
          {
LABEL_98:
            *(_DWORD *)&__n[1] = 0;
            __n[0] = 0;
            v117 = ResourceRecordGetRDataBytesPointer(a3, v116, v115, __n, (int *)&__n[1], v34, v35, v36);
            if (*(_DWORD *)&__n[1])
              goto LABEL_1002;
            v118 = (const void *)v117;
            v676 = v30;
            v702 = v32;
            if (__n[0] >= 0x1FFuLL)
            {
              v119 = __n[0] + 2;
              v356 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
              if (!v356)
                goto LABEL_1111;
              v120 = v356;
              v50 = v356;
            }
            else
            {
              v50 = 0;
              v119 = 512;
              v120 = word_100164580;
            }
            if (v28)
              v357 = mDNSLogCategory_Default;
            else
              v357 = mDNSLogCategory_mDNS;
            if (gSensitiveLoggingEnabled != 1 || v357 == mDNSLogCategory_State)
            {
              if (!os_log_type_enabled(v357, OS_LOG_TYPE_DEFAULT))
                goto LABEL_1000;
              v358 = *(_DWORD *)(v712 + 192);
              v376 = v31;
              v667 = v50;
              if (v713 == -632)
              {
LABEL_702:
                while (v376)
                {
                  v377 = *v376;
                  if (v377 > 0x3F)
                    break;
                  if (!*v376)
                  {
                    v445 = (_WORD)v376 - (_WORD)v31 + 1;
                    goto LABEL_953;
                  }
                  v376 += v377 + 1;
                  if (v713 != -632)
                    goto LABEL_701;
                }
              }
              else
              {
LABEL_701:
                if ((unint64_t)v376 < v713 + 632)
                  goto LABEL_702;
              }
              v445 = 257;
LABEL_953:
              v532 = v445;
              v533 = *(unsigned __int16 *)(a3 + 4);
              v534 = __n[0];
              v535 = __n[0] + 2;
              if (v535 > v119)
              {
                v120 = 0;
                goto LABEL_947;
              }
            }
            else
            {
              if (v28)
                v357 = mDNSLogCategory_Default_redacted;
              else
                v357 = mDNSLogCategory_mDNS;
              if (!os_log_type_enabled(v357, OS_LOG_TYPE_DEFAULT))
                goto LABEL_1000;
              v358 = *(_DWORD *)(v712 + 192);
              v359 = v31;
              v667 = v50;
              if (v713 == -632)
              {
LABEL_650:
                while (v359)
                {
                  v360 = *v359;
                  if (v360 > 0x3F)
                    break;
                  if (!*v359)
                  {
                    v445 = (_WORD)v359 - (_WORD)v31 + 1;
                    goto LABEL_944;
                  }
                  v359 += v360 + 1;
                  if (v713 != -632)
                    goto LABEL_649;
                }
              }
              else
              {
LABEL_649:
                if ((unint64_t)v359 < v713 + 632)
                  goto LABEL_650;
              }
              v445 = 257;
LABEL_944:
              v532 = v445;
              v533 = *(unsigned __int16 *)(a3 + 4);
              v534 = __n[0];
              v535 = __n[0] + 2;
              if (v535 > v119)
              {
                v120 = 0;
LABEL_947:
                LODWORD(buf.tv_sec) = 67111939;
                HIDWORD(buf.tv_sec) = v358;
                LOWORD(buf.tv_nsec) = 1024;
                *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
                HIWORD(buf.tv_nsec) = 1024;
                *(_DWORD *)v716 = a4;
                *(_WORD *)&v716[4] = 1024;
                *(_DWORD *)&v716[6] = v676;
                strcpy((char *)&v717, "p\bhash");
                HIBYTE(v717) = 0;
                *(_WORD *)v718 = 0;
                *(_WORD *)&v718[2] = 1040;
                *(_DWORD *)&v718[4] = v532;
                *(_WORD *)&v718[8] = 2101;
                *(_QWORD *)&v718[10] = v31;
                *(_WORD *)&v718[18] = 1024;
                *(_DWORD *)&v718[20] = v702;
                *(_WORD *)&v718[24] = 1024;
                *(_DWORD *)&v718[26] = v533;
                *(_WORD *)&v718[30] = 2160;
                *(_QWORD *)&v718[32] = 1752392040;
                *(_WORD *)&v718[40] = 1040;
                *(_DWORD *)&v718[42] = v535;
                *(_WORD *)&v718[46] = 2101;
                *(_QWORD *)&v718[48] = v120;
                v539 = "[R%u->mDNSQ] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifi"
                       "ndex: %d, name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d"
                       ", rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
LABEL_961:
                _os_log_impl((void *)&_mh_execute_header, v357, OS_LOG_TYPE_DEFAULT, v539, (uint8_t *)&buf, 0x5Au);
                v50 = v667;
                goto LABEL_1000;
              }
            }
            *v120 = __rev16(v533);
            v536 = v118;
            v537 = v358;
            v538 = v445;
            memcpy(v120 + 1, v536, v534);
            v532 = v538;
            v358 = v537;
            goto LABEL_947;
          }
        }
        v194 = v32;
        if (v28)
          v195 = mDNSLogCategory_Default;
        else
          v195 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || v195 == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v195, OS_LOG_TYPE_DEFAULT))
            goto LABEL_1003;
          v196 = *(_DWORD *)(a7 + 192);
          v299 = v31;
          if (v713 == -632)
          {
LABEL_512:
            while (v299)
            {
              v300 = *v299;
              if (v300 > 0x3F)
                break;
              if (!*v299)
              {
                v423 = (_WORD)v299 - (_WORD)v31 + 1;
                goto LABEL_891;
              }
              v299 += v300 + 1;
              if (v713 != -632)
                goto LABEL_511;
            }
          }
          else
          {
LABEL_511:
            if ((unint64_t)v299 < v713 + 632)
              goto LABEL_512;
          }
          v423 = 257;
        }
        else
        {
          if (v28)
            v195 = mDNSLogCategory_Default_redacted;
          else
            v195 = mDNSLogCategory_mDNS;
          if (!os_log_type_enabled(v195, OS_LOG_TYPE_DEFAULT))
            goto LABEL_1003;
          v196 = *(_DWORD *)(a7 + 192);
          v197 = v31;
          if (v713 == -632)
          {
LABEL_260:
            while (v197)
            {
              v198 = *v197;
              if (v198 > 0x3F)
                break;
              if (!*v197)
              {
                v423 = (_WORD)v197 - (_WORD)v31 + 1;
                goto LABEL_891;
              }
              v197 += v198 + 1;
              if (v713 != -632)
                goto LABEL_259;
            }
          }
          else
          {
LABEL_259:
            if ((unint64_t)v197 < v713 + 632)
              goto LABEL_260;
          }
          v423 = 257;
        }
LABEL_891:
        v491 = *(unsigned __int16 *)(a3 + 4);
        LODWORD(buf.tv_sec) = 67111171;
        HIDWORD(buf.tv_sec) = v196;
        LOWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
        HIWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)v716 = a4;
        *(_WORD *)&v716[4] = 1024;
        *(_DWORD *)&v716[6] = v30;
        strcpy((char *)&v717, "p\bhash");
        HIBYTE(v717) = 0;
        *(_WORD *)v718 = 0;
        *(_WORD *)&v718[2] = 1040;
        *(_DWORD *)&v718[4] = v423;
        *(_WORD *)&v718[8] = 2101;
        *(_QWORD *)&v718[10] = v31;
        *(_WORD *)&v718[18] = 1024;
        *(_DWORD *)&v718[20] = v194;
        *(_WORD *)&v718[24] = 1024;
        *(_DWORD *)&v718[26] = v491;
        v426 = "[R%u->mDNSQ] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d"
               ", name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: <none>";
LABEL_896:
        v449 = v195;
        v450 = 64;
        goto LABEL_942;
      }
    }
    if (v44)
    {
      v45 = 0;
      v90 = 512;
      v91 = (char *)&unk_100164380;
      if ((_DWORD)v42)
        goto LABEL_74;
    }
    else
    {
      v141 = (char *)malloc_type_malloc(v42, 0xA172743EuLL);
      if (!v141)
        goto LABEL_1111;
      v91 = v141;
      v45 = v141;
      v90 = (unsigned __int16)*v43;
      if (*v43)
      {
LABEL_74:
        *(_DWORD *)&__n[1] = 0;
        __n[0] = 0;
        v92 = ResourceRecordGetRDataBytesPointer(a3, v91, v90, __n, (int *)&__n[1], v34, v35, v36);
        if (*(_DWORD *)&__n[1])
          goto LABEL_1002;
        v93 = (const void *)v92;
        v662 = v45;
        v672 = v30;
        v698 = v32;
        if (__n[0] >= 0x1FFuLL)
        {
          v94 = __n[0] + 2;
          v256 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
          if (!v256)
            goto LABEL_1111;
          v95 = v256;
          v50 = v256;
        }
        else
        {
          v50 = 0;
          v94 = 512;
          v95 = word_100164580;
        }
        if (v28)
          v257 = mDNSLogCategory_Default;
        else
          v257 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled == 1 && v257 != mDNSLogCategory_State)
        {
          if (v28)
            v257 = mDNSLogCategory_Default_redacted;
          else
            v257 = mDNSLogCategory_mDNS;
          if (!os_log_type_enabled(v257, OS_LOG_TYPE_DEFAULT))
            goto LABEL_878;
          v258 = *(_DWORD *)(v712 + 192);
          v259 = bswap32(*(unsigned __int16 *)(v713 + 340)) >> 16;
          v260 = v31;
          v656 = v50;
          if (v713 == -632)
          {
LABEL_438:
            while (v260)
            {
              v261 = *v260;
              if (v261 > 0x3F)
                break;
              if (!*v260)
              {
                v419 = (_WORD)v260 - (_WORD)v31 + 1;
                goto LABEL_858;
              }
              v260 += v261 + 1;
              if (v713 != -632)
                goto LABEL_437;
            }
          }
          else
          {
LABEL_437:
            if ((unint64_t)v260 < v713 + 632)
              goto LABEL_438;
          }
          v419 = 257;
LABEL_858:
          v451 = v419;
          v452 = *(unsigned __int16 *)(a3 + 4);
          v453 = __n[0];
          v454 = __n[0] + 2;
          if (v454 <= v94)
          {
            *v95 = __rev16(v452);
            v455 = v93;
            v456 = v258;
            v457 = v259;
            memcpy(v95 + 1, v455, v453);
            v259 = v457;
            v258 = v456;
          }
          else
          {
            v95 = 0;
          }
          LODWORD(buf.tv_sec) = 67112195;
          HIDWORD(buf.tv_sec) = v258;
          LOWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)((char *)&buf.tv_nsec + 2) = v259;
          HIWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)v716 = a5;
          *(_WORD *)&v716[4] = 1024;
          *(_DWORD *)&v716[6] = a4;
          LOWORD(v717) = 1024;
          *(_DWORD *)((char *)&v717 + 2) = v672;
          HIWORD(v717) = 2160;
          *(_QWORD *)v718 = 1752392040;
          *(_WORD *)&v718[8] = 1040;
          *(_DWORD *)&v718[10] = v451;
          *(_WORD *)&v718[14] = 2101;
          *(_QWORD *)&v718[16] = v31;
          *(_WORD *)&v718[24] = 1024;
          *(_DWORD *)&v718[26] = v698;
          *(_WORD *)&v718[30] = 1024;
          *(_DWORD *)&v718[32] = v452;
          *(_WORD *)&v718[36] = 2160;
          *(_QWORD *)&v718[38] = 1752392040;
          *(_WORD *)&v718[46] = 1040;
          *(_DWORD *)&v718[48] = v454;
          *(_WORD *)&v718[52] = 2101;
          *(_QWORD *)&v718[54] = v95;
          v458 = "[R%u->Q%u] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d"
                 ", name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: %{sen"
                 "sitive, mask.hash, mdns:rdata}.*P";
          goto LABEL_877;
        }
        if (os_log_type_enabled(v257, OS_LOG_TYPE_DEFAULT))
        {
          v281 = *(_DWORD *)(v712 + 192);
          v282 = bswap32(*(unsigned __int16 *)(v713 + 340)) >> 16;
          v283 = v31;
          v656 = v50;
          if (v713 == -632)
          {
LABEL_490:
            while (v283)
            {
              v284 = *v283;
              if (v284 > 0x3F)
                break;
              if (!*v283)
              {
                v421 = (_WORD)v283 - (_WORD)v31 + 1;
                goto LABEL_868;
              }
              v283 += v284 + 1;
              if (v713 != -632)
                goto LABEL_489;
            }
          }
          else
          {
LABEL_489:
            if ((unint64_t)v283 < v713 + 632)
              goto LABEL_490;
          }
          v421 = 257;
LABEL_868:
          v466 = v421;
          v467 = *(unsigned __int16 *)(a3 + 4);
          v468 = __n[0];
          v469 = __n[0] + 2;
          if (v469 <= v94)
          {
            *v95 = __rev16(v467);
            v470 = v93;
            v471 = v281;
            v472 = v282;
            memcpy(v95 + 1, v470, v468);
            v282 = v472;
            v281 = v471;
          }
          else
          {
            v95 = 0;
          }
          LODWORD(buf.tv_sec) = 67112195;
          HIDWORD(buf.tv_sec) = v281;
          LOWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)((char *)&buf.tv_nsec + 2) = v282;
          HIWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)v716 = a5;
          *(_WORD *)&v716[4] = 1024;
          *(_DWORD *)&v716[6] = a4;
          LOWORD(v717) = 1024;
          *(_DWORD *)((char *)&v717 + 2) = v672;
          HIWORD(v717) = 2160;
          *(_QWORD *)v718 = 1752392040;
          *(_WORD *)&v718[8] = 1040;
          *(_DWORD *)&v718[10] = v466;
          *(_WORD *)&v718[14] = 2101;
          *(_QWORD *)&v718[16] = v31;
          *(_WORD *)&v718[24] = 1024;
          *(_DWORD *)&v718[26] = v698;
          *(_WORD *)&v718[30] = 1024;
          *(_DWORD *)&v718[32] = v467;
          *(_WORD *)&v718[36] = 2160;
          *(_QWORD *)&v718[38] = 1752392040;
          *(_WORD *)&v718[46] = 1040;
          *(_DWORD *)&v718[48] = v469;
          *(_WORD *)&v718[52] = 2101;
          *(_QWORD *)&v718[54] = v95;
          v458 = "[R%u->Q%u] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d"
                 ", name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: %{sen"
                 "sitive, mask.hash, mdns:rdata}.*P";
LABEL_877:
          _os_log_impl((void *)&_mh_execute_header, v257, OS_LOG_TYPE_DEFAULT, v458, (uint8_t *)&buf, 0x60u);
          v50 = v656;
          goto LABEL_878;
        }
        goto LABEL_878;
      }
    }
    v142 = v32;
    if (v28)
      v143 = mDNSLogCategory_Default;
    else
      v143 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || v143 == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled(v143, OS_LOG_TYPE_DEFAULT))
        goto LABEL_1003;
      v144 = *(_DWORD *)(a7 + 192);
      v145 = bswap32(*(unsigned __int16 *)(v713 + 340)) >> 16;
      v225 = v31;
      if (v713 == -632)
      {
LABEL_334:
        while (v225)
        {
          v226 = *v225;
          if (v226 > 0x3F)
            break;
          if (!*v225)
          {
            v380 = (_WORD)v225 - (_WORD)v31 + 1;
            goto LABEL_822;
          }
          v225 += v226 + 1;
          if (v713 != -632)
            goto LABEL_333;
        }
      }
      else
      {
LABEL_333:
        if ((unint64_t)v225 < v713 + 632)
          goto LABEL_334;
      }
      v380 = 257;
    }
    else
    {
      if (v28)
        v143 = mDNSLogCategory_Default_redacted;
      else
        v143 = mDNSLogCategory_mDNS;
      if (!os_log_type_enabled(v143, OS_LOG_TYPE_DEFAULT))
        goto LABEL_1003;
      v144 = *(_DWORD *)(a7 + 192);
      v145 = bswap32(*(unsigned __int16 *)(v713 + 340)) >> 16;
      v146 = v31;
      if (v713 == -632)
      {
LABEL_132:
        while (v146)
        {
          v147 = *v146;
          if (v147 > 0x3F)
            break;
          if (!*v146)
          {
            v380 = (_WORD)v146 - (_WORD)v31 + 1;
            goto LABEL_822;
          }
          v146 += v147 + 1;
          if (v713 != -632)
            goto LABEL_131;
        }
      }
      else
      {
LABEL_131:
        if ((unint64_t)v146 < v713 + 632)
          goto LABEL_132;
      }
      v380 = 257;
    }
LABEL_822:
    v425 = *(unsigned __int16 *)(a3 + 4);
    LODWORD(buf.tv_sec) = 67111427;
    HIDWORD(buf.tv_sec) = v144;
    LOWORD(buf.tv_nsec) = 1024;
    *(_DWORD *)((char *)&buf.tv_nsec + 2) = v145;
    HIWORD(buf.tv_nsec) = 1024;
    *(_DWORD *)v716 = a5;
    *(_WORD *)&v716[4] = 1024;
    *(_DWORD *)&v716[6] = a4;
    LOWORD(v717) = 1024;
    *(_DWORD *)((char *)&v717 + 2) = v30;
    HIWORD(v717) = 2160;
    *(_QWORD *)v718 = 1752392040;
    *(_WORD *)&v718[8] = 1040;
    *(_DWORD *)&v718[10] = v380;
    *(_WORD *)&v718[14] = 2101;
    *(_QWORD *)&v718[16] = v31;
    *(_WORD *)&v718[24] = 1024;
    *(_DWORD *)&v718[26] = v142;
    *(_WORD *)&v718[30] = 1024;
    *(_DWORD *)&v718[32] = v425;
    v426 = "[R%u->Q%u] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name"
           ": %{sensitive, mask.hash, mdnsresponder:domain_name}.*P (%x), type: %{mdns:rrtype}d, rdata: <none>";
    goto LABEL_941;
  }
  v63 = *(_QWORD *)(a3 + 56);
  if (v63)
  {
    v64 = v30;
    v65 = dnssec_obj_resource_record_member_get_validation_result(v63);
    v66 = v713;
    v68 = (_WORD *)(a3 + 12);
    v67 = *(unsigned __int16 *)(a3 + 12);
    v69 = v67 < 0x201;
    if (v65)
    {
      if (*(_WORD *)(v713 + 340))
      {
        if (v67 >= 0x201)
        {
          v184 = (char *)malloc_type_malloc(v67, 0xA172743EuLL);
          if (!v184)
            goto LABEL_1111;
          v72 = v184;
          v70 = v184;
          v71 = (unsigned __int16)*v68;
          if (*v68)
          {
LABEL_60:
            *(_DWORD *)&__n[1] = 0;
            __n[0] = 0;
            v73 = ResourceRecordGetRDataBytesPointer(a3, v72, v71, __n, (int *)&__n[1], v34, v35, v36);
            if (!*(_DWORD *)&__n[1])
            {
              v74 = (const void *)v73;
              v696 = v32;
              if (__n[0] >= 0x1FFuLL)
              {
                v76 = __n[0] + 2;
                v77 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
                if (!v77)
                  goto LABEL_1111;
                v75 = v77;
              }
              else
              {
                v75 = 0;
                v76 = 512;
                v77 = word_100164580;
              }
              v682 = v77;
              if (v28)
                v316 = mDNSLogCategory_Default;
              else
                v316 = mDNSLogCategory_mDNS;
              if (gSensitiveLoggingEnabled == 1 && v316 != mDNSLogCategory_State)
              {
                if (v28)
                  v317 = mDNSLogCategory_Default_redacted;
                else
                  v317 = mDNSLogCategory_mDNS;
                if (os_log_type_enabled(v317, OS_LOG_TYPE_DEFAULT))
                {
                  v666 = v75;
                  v318 = *(_DWORD *)(v712 + 192);
                  v319 = bswap32(*(unsigned __int16 *)(v713 + 340)) >> 16;
                  v320 = *(unsigned __int16 *)(a3 + 4);
                  v321 = __n[0];
                  v322 = __n[0] + 2;
                  if (v322 <= v76)
                  {
                    v323 = v682;
                    *v682 = __rev16(v320);
                    v480 = v74;
                    v481 = v318;
                    v658 = v320;
                    memcpy(v682 + 1, v480, v321);
                    v320 = v658;
                    v318 = v481;
                  }
                  else
                  {
                    v323 = 0;
                  }
                  LODWORD(buf.tv_sec) = 67111683;
                  HIDWORD(buf.tv_sec) = v318;
                  LOWORD(buf.tv_nsec) = 1024;
                  *(_DWORD *)((char *)&buf.tv_nsec + 2) = v319;
                  HIWORD(buf.tv_nsec) = 1024;
                  *(_DWORD *)v716 = a5;
                  *(_WORD *)&v716[4] = 1024;
                  *(_DWORD *)&v716[6] = a4;
                  LOWORD(v717) = 1024;
                  *(_DWORD *)((char *)&v717 + 2) = v64;
                  HIWORD(v717) = 1024;
                  *(_DWORD *)v718 = v696;
                  *(_WORD *)&v718[4] = 1026;
                  *(_DWORD *)&v718[6] = v65;
                  *(_WORD *)&v718[10] = 1024;
                  *(_DWORD *)&v718[12] = v320;
                  *(_WORD *)&v718[16] = 2160;
                  *(_QWORD *)&v718[18] = 1752392040;
                  *(_WORD *)&v718[26] = 1040;
                  *(_DWORD *)&v718[28] = v322;
                  *(_WORD *)&v718[32] = 2101;
                  *(_QWORD *)&v718[34] = v323;
                  v482 = "[R%u->Q%u] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifi"
                         "ndex: %d, name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: "
                         "%{sensitive, mask.hash, mdns:rdata}.*P";
LABEL_883:
                  v485 = v317;
LABEL_889:
                  v490 = 76;
LABEL_973:
                  _os_log_impl((void *)&_mh_execute_header, v485, OS_LOG_TYPE_DEFAULT, v482, (uint8_t *)&buf, v490);
                  v75 = v666;
                  goto LABEL_974;
                }
                goto LABEL_974;
              }
              if (!os_log_type_enabled(v316, OS_LOG_TYPE_DEFAULT))
                goto LABEL_974;
              v666 = v75;
              v338 = *(_DWORD *)(v712 + 192);
              v339 = bswap32(*(unsigned __int16 *)(v713 + 340)) >> 16;
              v340 = *(unsigned __int16 *)(a3 + 4);
              v341 = __n[0];
              v342 = __n[0] + 2;
              if (v342 <= v76)
              {
                v343 = v682;
                *v682 = __rev16(v340);
                v486 = v74;
                v487 = v338;
                v660 = v340;
                memcpy(v682 + 1, v486, v341);
                v340 = v660;
                v338 = v487;
              }
              else
              {
                v343 = 0;
              }
              LODWORD(buf.tv_sec) = 67111683;
              HIDWORD(buf.tv_sec) = v338;
              LOWORD(buf.tv_nsec) = 1024;
              *(_DWORD *)((char *)&buf.tv_nsec + 2) = v339;
              HIWORD(buf.tv_nsec) = 1024;
              *(_DWORD *)v716 = a5;
              *(_WORD *)&v716[4] = 1024;
              *(_DWORD *)&v716[6] = a4;
              LOWORD(v717) = 1024;
              *(_DWORD *)((char *)&v717 + 2) = v64;
              HIWORD(v717) = 1024;
              *(_DWORD *)v718 = v696;
              *(_WORD *)&v718[4] = 1026;
              *(_DWORD *)&v718[6] = v65;
              *(_WORD *)&v718[10] = 1024;
              *(_DWORD *)&v718[12] = v340;
              *(_WORD *)&v718[16] = 2160;
              *(_QWORD *)&v718[18] = 1752392040;
              *(_WORD *)&v718[26] = 1040;
              *(_DWORD *)&v718[28] = v342;
              *(_WORD *)&v718[32] = 2101;
              *(_QWORD *)&v718[34] = v343;
              v482 = "[R%u->Q%u] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex"
                     ": %d, name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensit"
                     "ive, mask.hash, mdns:rdata}.*P";
              goto LABEL_888;
            }
            goto LABEL_976;
          }
        }
        else
        {
          v70 = 0;
          v71 = 512;
          v72 = (char *)&unk_100164380;
          if (*(_WORD *)(a3 + 12))
            goto LABEL_60;
        }
        v185 = v32;
        if (v28)
          v186 = mDNSLogCategory_Default;
        else
          v186 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled == 1 && v186 != mDNSLogCategory_State)
        {
          if (v28)
            v186 = mDNSLogCategory_Default_redacted;
          else
            v186 = mDNSLogCategory_mDNS;
          if (!os_log_type_enabled(v186, OS_LOG_TYPE_DEFAULT))
            goto LABEL_977;
          goto LABEL_234;
        }
        if (os_log_type_enabled(v186, OS_LOG_TYPE_DEFAULT))
        {
LABEL_234:
          v187 = *(_DWORD *)(a7 + 192);
          v188 = bswap32(*(unsigned __int16 *)(v713 + 340));
          v189 = *(unsigned __int16 *)(a3 + 4);
          LODWORD(buf.tv_sec) = 67110912;
          HIDWORD(buf.tv_sec) = v187;
          LOWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)((char *)&buf.tv_nsec + 2) = HIWORD(v188);
          HIWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)v716 = a5;
          *(_WORD *)&v716[4] = 1024;
          *(_DWORD *)&v716[6] = a4;
          LOWORD(v717) = 1024;
          *(_DWORD *)((char *)&v717 + 2) = v64;
          HIWORD(v717) = 1024;
          *(_DWORD *)v718 = v185;
          *(_WORD *)&v718[4] = 1026;
          *(_DWORD *)&v718[6] = v65;
          *(_WORD *)&v718[10] = 1024;
          *(_DWORD *)&v718[12] = v189;
          v190 = "[R%u->Q%u] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d"
                 ", name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: <none>";
LABEL_424:
          v254 = v186;
          v255 = 50;
LABEL_636:
          _os_log_impl((void *)&_mh_execute_header, v254, OS_LOG_TYPE_DEFAULT, v190, (uint8_t *)&buf, v255);
        }
LABEL_977:
        v45 = v70;
        goto LABEL_1004;
      }
      if (v67 >= 0x201)
      {
        v67 = (size_t)malloc_type_malloc(v67, 0xA172743EuLL);
        if (!v67)
          goto LABEL_1111;
        v168 = (char *)v67;
        LODWORD(v67) = (unsigned __int16)*v68;
        v70 = v168;
        v167 = v67;
      }
      else
      {
        v70 = 0;
        v167 = 512;
        v168 = (char *)&unk_100164380;
      }
      if ((_DWORD)v67)
      {
        *(_DWORD *)&__n[1] = 0;
        __n[0] = 0;
        v217 = ResourceRecordGetRDataBytesPointer(a3, v168, v167, __n, (int *)&__n[1], v34, v35, v36);
        if (*(_DWORD *)&__n[1])
          goto LABEL_976;
        v218 = (const void *)v217;
        v706 = v32;
        if (__n[0] >= 0x1FFuLL)
        {
          v219 = __n[0] + 2;
          v220 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
          if (!v220)
            goto LABEL_1111;
          v75 = v220;
        }
        else
        {
          v75 = 0;
          v219 = 512;
          v220 = word_100164580;
        }
        v684 = v220;
        if (v28)
          v389 = mDNSLogCategory_Default;
        else
          v389 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled == 1 && v389 != mDNSLogCategory_State)
        {
          if (v28)
            v390 = mDNSLogCategory_Default_redacted;
          else
            v390 = mDNSLogCategory_mDNS;
          if (!os_log_type_enabled(v390, OS_LOG_TYPE_DEFAULT))
            goto LABEL_974;
          v666 = v75;
          v391 = *(_DWORD *)(v712 + 192);
          v392 = *(unsigned __int16 *)(a3 + 4);
          v393 = __n[0];
          v394 = __n[0] + 2;
          if (v394 <= v219)
          {
            v395 = v684;
            *v684 = __rev16(v392);
            v547 = v218;
            v548 = v391;
            memcpy(v684 + 1, v547, v393);
            v391 = v548;
          }
          else
          {
            v395 = 0;
          }
          LODWORD(buf.tv_sec) = 67111427;
          HIDWORD(buf.tv_sec) = v391;
          LOWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
          HIWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)v716 = a4;
          *(_WORD *)&v716[4] = 1024;
          *(_DWORD *)&v716[6] = v64;
          LOWORD(v717) = 1024;
          *(_DWORD *)((char *)&v717 + 2) = v706;
          HIWORD(v717) = 1026;
          *(_DWORD *)v718 = v65;
          *(_WORD *)&v718[4] = 1024;
          *(_DWORD *)&v718[6] = v392;
          *(_WORD *)&v718[10] = 2160;
          *(_QWORD *)&v718[12] = 1752392040;
          *(_WORD *)&v718[20] = 1040;
          *(_DWORD *)&v718[22] = v394;
          *(_WORD *)&v718[26] = 2101;
          *(_QWORD *)&v718[28] = v395;
          v482 = "[R%u->mDNSQ] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: "
                 "%d, name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, m"
                 "ask.hash, mdns:rdata}.*P";
LABEL_966:
          v485 = v390;
LABEL_972:
          v490 = 70;
          goto LABEL_973;
        }
        if (!os_log_type_enabled(v389, OS_LOG_TYPE_DEFAULT))
          goto LABEL_974;
        v666 = v75;
        v407 = *(_DWORD *)(v712 + 192);
        v408 = *(unsigned __int16 *)(a3 + 4);
        v409 = __n[0];
        v410 = __n[0] + 2;
        if (v410 <= v219)
        {
          v411 = v684;
          *v684 = __rev16(v408);
          v551 = v218;
          v552 = v407;
          memcpy(v684 + 1, v551, v409);
          v407 = v552;
        }
        else
        {
          v411 = 0;
        }
        LODWORD(buf.tv_sec) = 67111427;
        HIDWORD(buf.tv_sec) = v407;
        LOWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
        HIWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)v716 = a4;
        *(_WORD *)&v716[4] = 1024;
        *(_DWORD *)&v716[6] = v64;
        LOWORD(v717) = 1024;
        *(_DWORD *)((char *)&v717 + 2) = v706;
        HIWORD(v717) = 1026;
        *(_DWORD *)v718 = v65;
        *(_WORD *)&v718[4] = 1024;
        *(_DWORD *)&v718[6] = v408;
        *(_WORD *)&v718[10] = 2160;
        *(_QWORD *)&v718[12] = 1752392040;
        *(_WORD *)&v718[20] = 1040;
        *(_DWORD *)&v718[22] = v410;
        *(_WORD *)&v718[26] = 2101;
        *(_QWORD *)&v718[28] = v411;
        v482 = "[R%u->mDNSQ] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d"
               ", name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: %{sensitive, mask."
               "hash, mdns:rdata}.*P";
        goto LABEL_971;
      }
      v242 = v32;
      if (v28)
        v243 = mDNSLogCategory_Default;
      else
        v243 = mDNSLogCategory_mDNS;
      if (gSensitiveLoggingEnabled != 1 || v243 == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled(v243, OS_LOG_TYPE_DEFAULT))
          goto LABEL_977;
      }
      else
      {
        if (v28)
          v243 = mDNSLogCategory_Default_redacted;
        else
          v243 = mDNSLogCategory_mDNS;
        if (!os_log_type_enabled(v243, OS_LOG_TYPE_DEFAULT))
          goto LABEL_977;
      }
      v244 = *(_DWORD *)(a7 + 192);
      v245 = *(unsigned __int16 *)(a3 + 4);
      LODWORD(buf.tv_sec) = 67110656;
      HIDWORD(buf.tv_sec) = v244;
      LOWORD(buf.tv_nsec) = 1024;
      *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
      HIWORD(buf.tv_nsec) = 1024;
      *(_DWORD *)v716 = a4;
      *(_WORD *)&v716[4] = 1024;
      *(_DWORD *)&v716[6] = v64;
      LOWORD(v717) = 1024;
      *(_DWORD *)((char *)&v717 + 2) = v242;
      HIWORD(v717) = 1026;
      *(_DWORD *)v718 = v65;
      *(_WORD *)&v718[4] = 1024;
      *(_DWORD *)&v718[6] = v245;
      v190 = "[R%u->mDNSQ] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, "
             "name hash: %x, dnssec: %{public, mdns:dnssec_result}d, type: %{mdns:rrtype}d, rdata: <none>";
      goto LABEL_635;
    }
    v30 = v64;
    if (!*(_WORD *)(v713 + 340))
      goto LABEL_108;
    goto LABEL_84;
  }
  v66 = v713;
  v68 = (_WORD *)(a3 + 12);
  LODWORD(v67) = *(unsigned __int16 *)(a3 + 12);
  v69 = v67 < 0x201;
  if (*(_WORD *)(v713 + 340))
  {
LABEL_84:
    if (v69)
    {
      v45 = 0;
      v102 = 512;
      v103 = (char *)&unk_100164380;
      if ((_DWORD)v67)
      {
LABEL_86:
        *(_DWORD *)&__n[1] = 0;
        __n[0] = 0;
        v104 = ResourceRecordGetRDataBytesPointer(a3, v103, v102, __n, (int *)&__n[1], v34, v35, v36);
        if (*(_DWORD *)&__n[1])
          goto LABEL_907;
        v105 = (const void *)v104;
        v674 = v30;
        v700 = v32;
        if (__n[0] >= 0x1FFuLL)
        {
          v107 = __n[0] + 2;
          v267 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
          if (!v267)
            goto LABEL_1111;
          v108 = v267;
          v106 = v267;
        }
        else
        {
          v106 = 0;
          v107 = 512;
          v108 = word_100164580;
        }
        if (v28)
          v268 = mDNSLogCategory_Default;
        else
          v268 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled == 1 && v268 != mDNSLogCategory_State)
        {
          if (v28)
            v269 = mDNSLogCategory_Default_redacted;
          else
            v269 = mDNSLogCategory_mDNS;
          if (!os_log_type_enabled(v269, OS_LOG_TYPE_DEFAULT))
            goto LABEL_905;
          v663 = v106;
          v270 = *(_DWORD *)(v712 + 192);
          v271 = bswap32(*(unsigned __int16 *)(v713 + 340)) >> 16;
          v272 = *(unsigned __int16 *)(a3 + 4);
          v273 = __n[0];
          v274 = __n[0] + 2;
          if (v274 <= v107)
          {
            *v108 = __rev16(v272);
            v428 = v105;
            v429 = v271;
            memcpy(v108 + 1, v428, v273);
            v271 = v429;
          }
          else
          {
            v108 = 0;
          }
          LODWORD(buf.tv_sec) = 67111427;
          HIDWORD(buf.tv_sec) = v270;
          LOWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)((char *)&buf.tv_nsec + 2) = v271;
          HIWORD(buf.tv_nsec) = 1024;
          *(_DWORD *)v716 = a5;
          *(_WORD *)&v716[4] = 1024;
          *(_DWORD *)&v716[6] = a4;
          LOWORD(v717) = 1024;
          *(_DWORD *)((char *)&v717 + 2) = v674;
          HIWORD(v717) = 1024;
          *(_DWORD *)v718 = v700;
          *(_WORD *)&v718[4] = 1024;
          *(_DWORD *)&v718[6] = v272;
          *(_WORD *)&v718[10] = 2160;
          *(_QWORD *)&v718[12] = 1752392040;
          *(_WORD *)&v718[20] = 1040;
          *(_DWORD *)&v718[22] = v274;
          *(_WORD *)&v718[26] = 2101;
          *(_QWORD *)&v718[28] = v108;
          v430 = "[R%u->Q%u] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d"
                 ", name hash: %x, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
LABEL_831:
          v433 = v269;
LABEL_837:
          v438 = 70;
LABEL_904:
          _os_log_impl((void *)&_mh_execute_header, v433, OS_LOG_TYPE_DEFAULT, v430, (uint8_t *)&buf, v438);
          v106 = v663;
          goto LABEL_905;
        }
        if (!os_log_type_enabled(v268, OS_LOG_TYPE_DEFAULT))
          goto LABEL_905;
        v663 = v106;
        v289 = *(_DWORD *)(v712 + 192);
        v290 = bswap32(*(unsigned __int16 *)(v713 + 340)) >> 16;
        v291 = *(unsigned __int16 *)(a3 + 4);
        v292 = __n[0];
        v293 = __n[0] + 2;
        if (v293 <= v107)
        {
          *v108 = __rev16(v291);
          v434 = v105;
          v435 = v290;
          memcpy(v108 + 1, v434, v292);
          v290 = v435;
        }
        else
        {
          v108 = 0;
        }
        LODWORD(buf.tv_sec) = 67111427;
        HIDWORD(buf.tv_sec) = v289;
        LOWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)((char *)&buf.tv_nsec + 2) = v290;
        HIWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)v716 = a5;
        *(_WORD *)&v716[4] = 1024;
        *(_DWORD *)&v716[6] = a4;
        LOWORD(v717) = 1024;
        *(_DWORD *)((char *)&v717 + 2) = v674;
        HIWORD(v717) = 1024;
        *(_DWORD *)v718 = v700;
        *(_WORD *)&v718[4] = 1024;
        *(_DWORD *)&v718[6] = v291;
        *(_WORD *)&v718[10] = 2160;
        *(_QWORD *)&v718[12] = 1752392040;
        *(_WORD *)&v718[20] = 1040;
        *(_DWORD *)&v718[22] = v293;
        *(_WORD *)&v718[26] = 2101;
        *(_QWORD *)&v718[28] = v108;
        v430 = "[R%u->Q%u] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, "
               "name hash: %x, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
        goto LABEL_836;
      }
    }
    else
    {
      v154 = (char *)malloc_type_malloc(v67, 0xA172743EuLL);
      if (!v154)
        goto LABEL_1111;
      v103 = v154;
      v45 = v154;
      v102 = (unsigned __int16)*v68;
      if (*v68)
        goto LABEL_86;
    }
    v155 = v32;
    if (v28)
      v156 = mDNSLogCategory_Default;
    else
      v156 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || v156 == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled(v156, OS_LOG_TYPE_DEFAULT))
        goto LABEL_1004;
    }
    else
    {
      if (v28)
        v156 = mDNSLogCategory_Default_redacted;
      else
        v156 = mDNSLogCategory_mDNS;
      if (!os_log_type_enabled(v156, OS_LOG_TYPE_DEFAULT))
        goto LABEL_1004;
    }
    v157 = *(_DWORD *)(a7 + 192);
    v158 = bswap32(*(unsigned __int16 *)(v66 + 340));
    v159 = *(unsigned __int16 *)(a3 + 4);
    LODWORD(buf.tv_sec) = 67110656;
    HIDWORD(buf.tv_sec) = v157;
    LOWORD(buf.tv_nsec) = 1024;
    *(_DWORD *)((char *)&buf.tv_nsec + 2) = HIWORD(v158);
    HIWORD(buf.tv_nsec) = 1024;
    *(_DWORD *)v716 = a5;
    *(_WORD *)&v716[4] = 1024;
    *(_DWORD *)&v716[6] = a4;
    LOWORD(v717) = 1024;
    *(_DWORD *)((char *)&v717 + 2) = v30;
    HIWORD(v717) = 1024;
    *(_DWORD *)v718 = v155;
    *(_WORD *)&v718[4] = 1024;
    *(_DWORD *)&v718[6] = v159;
    v160 = "[R%u->Q%u] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, name"
           " hash: %x, type: %{mdns:rrtype}d, rdata: <none>";
LABEL_351:
    v232 = v156;
    v233 = 44;
LABEL_530:
    _os_log_impl((void *)&_mh_execute_header, v232, OS_LOG_TYPE_DEFAULT, v160, (uint8_t *)&buf, v233);
    goto LABEL_1004;
  }
LABEL_108:
  if (v69)
  {
    v45 = 0;
    v127 = 512;
    v128 = (char *)&unk_100164380;
    if ((_DWORD)v67)
      goto LABEL_110;
  }
  else
  {
    v204 = (char *)malloc_type_malloc(v67, 0xA172743EuLL);
    if (!v204)
      goto LABEL_1111;
    v128 = v204;
    v45 = v204;
    v127 = (unsigned __int16)*v68;
    if (*v68)
    {
LABEL_110:
      *(_DWORD *)&__n[1] = 0;
      __n[0] = 0;
      v129 = ResourceRecordGetRDataBytesPointer(a3, v128, v127, __n, (int *)&__n[1], v34, v35, v36);
      if (!*(_DWORD *)&__n[1])
      {
        v130 = (const void *)v129;
        v678 = v30;
        v131 = v32;
        if (__n[0] >= 0x1FFuLL)
        {
          v132 = __n[0] + 2;
          v365 = (__int16 *)malloc_type_malloc(__n[0] + 2, 0xA172743EuLL);
          if (!v365)
            goto LABEL_1111;
          v133 = v365;
          v106 = v365;
        }
        else
        {
          v106 = 0;
          v132 = 512;
          v133 = word_100164580;
        }
        if (v28)
          v366 = mDNSLogCategory_Default;
        else
          v366 = mDNSLogCategory_mDNS;
        if (gSensitiveLoggingEnabled != 1 || v366 == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled(v366, OS_LOG_TYPE_DEFAULT))
            goto LABEL_905;
          v663 = v106;
          v367 = *(_DWORD *)(v712 + 192);
          v368 = *(unsigned __int16 *)(a3 + 4);
          v369 = __n[0];
          v370 = __n[0] + 2;
          if (v370 > v132)
          {
            v133 = 0;
            goto LABEL_898;
          }
LABEL_897:
          *v133 = __rev16(v368);
          v493 = v367;
          memcpy(v133 + 1, v130, v369);
          v367 = v493;
          goto LABEL_898;
        }
        if (v28)
          v366 = mDNSLogCategory_Default_redacted;
        else
          v366 = mDNSLogCategory_mDNS;
        if (os_log_type_enabled(v366, OS_LOG_TYPE_DEFAULT))
        {
          v663 = v106;
          v367 = *(_DWORD *)(v712 + 192);
          v368 = *(unsigned __int16 *)(a3 + 4);
          v369 = __n[0];
          v370 = __n[0] + 2;
          if (v370 > v132)
          {
            v133 = 0;
LABEL_898:
            LODWORD(buf.tv_sec) = 67111171;
            HIDWORD(buf.tv_sec) = v367;
            LOWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
            HIWORD(buf.tv_nsec) = 1024;
            *(_DWORD *)v716 = a4;
            *(_WORD *)&v716[4] = 1024;
            *(_DWORD *)&v716[6] = v678;
            LOWORD(v717) = 1024;
            *(_DWORD *)((char *)&v717 + 2) = v131;
            HIWORD(v717) = 1024;
            *(_DWORD *)v718 = v368;
            *(_WORD *)&v718[4] = 2160;
            *(_QWORD *)&v718[6] = 1752392040;
            *(_WORD *)&v718[14] = 1040;
            *(_DWORD *)&v718[16] = v370;
            *(_WORD *)&v718[20] = 2101;
            *(_QWORD *)&v718[22] = v133;
            v430 = "[R%u->mDNSQ] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex"
                   ": %d, name hash: %x, type: %{mdns:rrtype}d, rdata: %{sensitive, mask.hash, mdns:rdata}.*P";
LABEL_903:
            v433 = v366;
            v438 = 64;
            goto LABEL_904;
          }
          goto LABEL_897;
        }
LABEL_905:
        v66 = v713;
        if (v106)
          free(v106);
      }
LABEL_907:
      a7 = v712;
      goto LABEL_1004;
    }
  }
  v205 = v32;
  if (v28)
    v206 = mDNSLogCategory_Default;
  else
    v206 = mDNSLogCategory_mDNS;
  if (gSensitiveLoggingEnabled != 1 || v206 == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled(v206, OS_LOG_TYPE_DEFAULT))
      goto LABEL_1004;
    goto LABEL_294;
  }
  if (v28)
    v206 = mDNSLogCategory_Default_redacted;
  else
    v206 = mDNSLogCategory_mDNS;
  if (os_log_type_enabled(v206, OS_LOG_TYPE_DEFAULT))
  {
LABEL_294:
    v207 = *(_DWORD *)(a7 + 192);
    v208 = *(unsigned __int16 *)(a3 + 4);
    LODWORD(buf.tv_sec) = 67110400;
    HIDWORD(buf.tv_sec) = v207;
    LOWORD(buf.tv_nsec) = 1024;
    *(_DWORD *)((char *)&buf.tv_nsec + 2) = a5;
    HIWORD(buf.tv_nsec) = 1024;
    *(_DWORD *)v716 = a4;
    *(_WORD *)&v716[4] = 1024;
    *(_DWORD *)&v716[6] = v30;
    LOWORD(v717) = 1024;
    *(_DWORD *)((char *)&v717 + 2) = v205;
    HIWORD(v717) = 1024;
    *(_DWORD *)v718 = v208;
    v160 = "[R%u->mDNSQ] DNSServiceQueryRecord result -- event: %{mdns:addrmv}d, expired: %{mdns:yesno}d, ifindex: %d, na"
           "me hash: %x, type: %{mdns:rrtype}d, rdata: <none>";
LABEL_529:
    v232 = v206;
    v233 = 38;
    goto LABEL_530;
  }
LABEL_1004:
  if (v45)
    free(v45);
  v585 = *(_QWORD *)(a3 + 24);
  v586 = v585 + 5;
  if ((unint64_t)(v585 + 5) < 6 && ((0x2Du >> v586) & 1) != 0)
    LODWORD(v585) = dword_100100868[v586];
  v587 = strlen(__s);
  v592 = *(unsigned __int16 *)(a3 + 12);
  v593 = v587 + v592 + 23;
  if (!*(_BYTE *)(a7 + 282))
  {
    v595 = 0;
    goto LABEL_1056;
  }
  v594 = 0;
  v595 = 0;
  if (!a5
    || (v596 = *(_QWORD *)(a7 + 56)) == 0
    || (v594 = 0, v595 = 0, v597 = *(unsigned __int16 *)(a3 + 4), v597 > 0x1C)
    || ((1 << v597) & 0x10010002) == 0)
  {
    v602 = 0;
    goto LABEL_1057;
  }
  *(_DWORD *)&__n[1] = 0;
  if (v597 != 28)
  {
    if (v597 == 16)
    {
      if (*(_UNKNOWN ***)(v596 + 16) != &_mdns_signed_browse_result_kind)
      {
        v598 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
            goto LABEL_1049;
        }
        else
        {
          v598 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
            goto LABEL_1049;
        }
        v604 = *(_DWORD *)(a7 + 192);
        v605 = bswap32(*(unsigned __int16 *)(v66 + 340)) >> 16;
        LODWORD(buf.tv_sec) = 67109376;
        HIDWORD(buf.tv_sec) = v604;
        LOWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)((char *)&buf.tv_nsec + 2) = v605;
        v601 = "[R%u->Q%u] queryrecord_result_reply mdns_signed_browse_result_downcast failed";
        goto LABEL_1036;
      }
      ipv4 = _mdns_signed_browse_result_create_ex((const unsigned __int8 *)(*(_QWORD *)(v596 + 32) + 32), *(unsigned __int8 **)(v596 + 24), v585, (unsigned __int8 *)(*(_QWORD *)(a3 + 40) + 4), v592, (int *)&__n[1]);
      goto LABEL_1038;
    }
    if (v597 != 1)
      goto LABEL_1049;
  }
  if (*(_UNKNOWN ***)(v596 + 16) != &_mdns_signed_resolve_result_kind)
  {
    v598 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
        goto LABEL_1021;
    }
    else
    {
      v598 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
      {
LABEL_1021:
        v599 = *(_DWORD *)(a7 + 192);
        v600 = bswap32(*(unsigned __int16 *)(v66 + 340)) >> 16;
        LODWORD(buf.tv_sec) = 67109376;
        HIDWORD(buf.tv_sec) = v599;
        LOWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)((char *)&buf.tv_nsec + 2) = v600;
        v601 = "[R%u->Q%u] queryrecord_result_reply mdns_signed_resolve_result_downcast failed";
LABEL_1036:
        _os_log_impl((void *)&_mh_execute_header, v598, OS_LOG_TYPE_ERROR, v601, (uint8_t *)&buf, 0xEu);
      }
    }
LABEL_1049:
    v595 = 0;
    v606 = *(_DWORD *)&__n[1];
    goto LABEL_1050;
  }
  if (v597 == 1)
    ipv4 = (uint64_t)mdns_signed_hostname_result_create_ipv4(v596, (_DWORD *)(*(_QWORD *)(a3 + 40) + 4), (int *)&__n[1]);
  else
    ipv4 = (uint64_t)mdns_signed_hostname_result_create_ipv6(v596, (_OWORD *)(*(_QWORD *)(a3 + 40) + 4), v585, (int *)&__n[1]);
LABEL_1038:
  v595 = (void *)ipv4;
  if (!ipv4)
    goto LABEL_1049;
  v606 = *(_DWORD *)&__n[1];
  if (*(_DWORD *)&__n[1])
  {
LABEL_1050:
    v610 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
      {
LABEL_1055:
        v611 = *(_DWORD *)(a7 + 192);
        v612 = bswap32(*(unsigned __int16 *)(v66 + 340)) >> 16;
        LODWORD(buf.tv_sec) = 67109632;
        HIDWORD(buf.tv_sec) = v611;
        LOWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)((char *)&buf.tv_nsec + 2) = v612;
        HIWORD(buf.tv_nsec) = 2048;
        *(_QWORD *)v716 = v606;
        _os_log_impl((void *)&_mh_execute_header, v610, OS_LOG_TYPE_ERROR, "[R%u->Q%u] queryrecord_result_reply signed_result failed %ld", (uint8_t *)&buf, 0x18u);
      }
    }
    else
    {
      v610 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
        goto LABEL_1055;
    }
LABEL_1056:
    v602 = 0;
    v594 = 0;
    goto LABEL_1057;
  }
  buf.tv_sec = 0;
  data = mdns_signed_result_get_data(ipv4, &buf);
  tv_sec = buf.tv_sec;
  if (buf.tv_sec >= 0x10000uLL)
    v602 = 0;
  else
    v602 = data;
  if (buf.tv_sec >= 0x10000uLL)
    tv_sec = 0;
  v594 = tv_sec;
  if (buf.tv_sec >= 0x10000uLL)
    v609 = 0;
  else
    v609 = LOWORD(buf.tv_sec) + 4;
  v593 += v609;
LABEL_1057:
  if (*(_QWORD *)&__n[3])
    v593 += strlen(*(const char **)&__n[3]) + 5;
  if (*(_DWORD *)(v712 + 220) == 8)
    v613 = 68;
  else
    v613 = 72;
  reply = create_reply((char *)v613, v593, v712, v588, v592, v589, v590, v591);
  v615 = reply;
  v616 = v708 | 2;
  if (!a5)
    v616 = v708;
  if (a4)
    v616 |= 0x80000000;
  if (!*(_BYTE *)(v66 + 357))
    v616 |= 0x40000000u;
  *((_DWORD *)reply + 11) = bswap32(v616);
  v617 = reply + 44;
  *((_DWORD *)reply + 12) = bswap32(v585);
  *((_DWORD *)reply + 13) = bswap32(v710);
  v618 = reply + 56;
  v619 = strlen(__s) + 1;
  memcpy(v618, __s, v619);
  v624 = &v618[v619];
  *(_WORD *)v624 = bswap32(*(unsigned __int16 *)(a3 + 4)) >> 16;
  *((_WORD *)v624 + 1) = bswap32(*(unsigned __int16 *)(a3 + 6)) >> 16;
  v625 = &v618[v619 + 6];
  *((_WORD *)v624 + 2) = bswap32(*(unsigned __int16 *)(a3 + 12)) >> 16;
  if (*(_WORD *)(a3 + 12) && !putRData(0, v625, (unint64_t)&v617[v593], a3, v620, v621, v622, v623))
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "queryrecord_result_reply putRData failed %d", v626, v627, v628, v629, v630, (_DWORD)v617 + v593 - (_DWORD)v625);
  v631 = &v625[*(unsigned __int16 *)(a3 + 12)];
  if (a5)
    v632 = *(_DWORD *)(a3 + 8);
  else
    v632 = 0;
  *(_DWORD *)v631 = bswap32(v632);
  v633 = v631 + 4;
  if (v602)
  {
    if (v631 != (char *)-4 && v633 <= &v633[v593] && v593 >= (unint64_t)v594 + 4)
    {
      *((_WORD *)v631 + 2) = 1792;
      v631[6] = BYTE1(v594);
      v633 = v631 + 8;
      v631[7] = v594;
      if (v594)
      {
        memcpy(v631 + 8, v602, v594);
        v633 += v594;
      }
    }
    *((_DWORD *)v615 + 6) |= 2u;
  }
  if (v595)
    os_release(v595);
  v634 = *(const void **)&__n[3];
  if (*(_QWORD *)&__n[3])
  {
    v635 = strlen(*(const char **)&__n[3]) + 1;
    if (!(v635 >> 16))
    {
      if (v633)
      {
        if (v633 <= &v633[v593] && v593 >= (unint64_t)(unsigned __int16)v635 + 4)
        {
          *(_WORD *)v633 = 2304;
          v633[2] = BYTE1(v635);
          v633[3] = v635;
          if ((_WORD)v635)
            memcpy(v633 + 4, v634, (unsigned __int16)v635);
        }
      }
    }
    *((_DWORD *)v615 + 6) |= 2u;
    v636 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
      {
LABEL_1095:
        v637 = *(_DWORD *)(v712 + 192);
        v638 = bswap32(*(unsigned __int16 *)(v713 + 340)) >> 16;
        LODWORD(buf.tv_sec) = 67109891;
        HIDWORD(buf.tv_sec) = v637;
        LOWORD(buf.tv_nsec) = 1024;
        *(_DWORD *)((char *)&buf.tv_nsec + 2) = v638;
        HIWORD(buf.tv_nsec) = 2160;
        *(_QWORD *)v716 = 1752392040;
        *(_WORD *)&v716[8] = 2085;
        v717 = *(_QWORD *)&__n[3];
        _os_log_impl((void *)&_mh_execute_header, v636, OS_LOG_TYPE_DEBUG, "[R%u->Q%u] queryrecord_result_reply add tracker %{sensitive, mask.hash}s", (uint8_t *)&buf, 0x22u);
      }
    }
    else
    {
      v636 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
        goto LABEL_1095;
    }
  }
  if (v709 && &_NEHelperTrackerGetAppInfo)
  {
    v639 = &s_head_0;
    while (1)
    {
      v639 = (uint64_t *)*v639;
      if (!v639)
        break;
      if (v639[1] == v713)
      {
        tracker_state = _cache_item_get_tracker_state((uint64_t)v639);
        Count = CFArrayGetCount((CFArrayRef)v639[6]);
        if (Count < 1)
          break;
        ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex((CFArrayRef)v639[6], Count - 1);
        if (CFDataGetLength(ValueAtIndex) == 4)
          v643 = 2;
        else
          v643 = 30;
        buf.tv_sec = (__darwin_time_t)CFDataGetBytePtr(ValueAtIndex);
        if (tracker_state == 1)
        {
          if (!CFArrayGetCount((CFArrayRef)v639[5]))
            break;
          v644 = CFArrayGetValueAtIndex((CFArrayRef)v639[5], 0);
        }
        else
        {
          v644 = 0;
        }
        NEHelperTrackerAddIPForAllFlowsRedactLogs(*((unsigned int *)v639 + 8), v643, &buf, 1, v639[2], v639[3], v644, gSensitiveLoggingEnabled);
        break;
      }
    }
  }
  append_reply(v712, v615);
}

void ___handle_addrinfo_request_with_trust_block_invoke_2(uint64_t a1, int a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  if (!a2)
  {
    v5 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
    *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v5, v6, v7, v8, v9, v10, v11, v12);
    v20 = *(_QWORD *)(a1 + 32);
    if (*(_QWORD *)(v20 + 64) && *(_BYTE *)(v20 + 27))
      goto LABEL_10;
    v13 = *(int **)(v20 + 56);
    if (!v13)
      goto LABEL_10;
    if (a3 == 1)
    {
      v13 = (int *)_handle_addrinfo_request_start(*(_QWORD *)(a1 + 40), v13);
      if (!(_DWORD)v13)
        goto LABEL_10;
    }
    else
    {
      LODWORD(v13) = -65570;
    }
    _return_queryrecord_request_error(*(_QWORD *)(a1 + 40), v13);
LABEL_10:
    KQueueUnlock((uint64_t)"_handle_addrinfo_request_with_trust", (uint64_t)v13, v14, v15, v16, v17, v18, v19);
  }
}

void _return_queryrecord_request_error(uint64_t a1, unsigned int a2)
{
  NSObject *v4;
  int v6;
  const char *v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *reply;
  _DWORD v16[2];
  __int16 v17;
  const char *v18;
  __int16 v19;
  unsigned int v20;

  v4 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      goto LABEL_15;
    v6 = *(_DWORD *)(a1 + 192);
    if (*(_DWORD *)(a1 + 220) == 8)
      v7 = "QueryRecord";
    else
      v7 = "GetAddrInfo";
  }
  else
  {
    v4 = mDNSLogCategory_Default_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      goto LABEL_15;
    v6 = *(_DWORD *)(a1 + 192);
    if (*(_DWORD *)(a1 + 220) == 8)
      v7 = "QueryRecord";
    else
      v7 = "GetAddrInfo";
  }
  v16[0] = 67109634;
  v16[1] = v6;
  v17 = 2082;
  v18 = v7;
  v19 = 1024;
  v20 = a2;
  _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "[R%u] DNSService%{public}s _return_queryrecord_request_error: error(%d)", (uint8_t *)v16, 0x18u);
LABEL_15:
  if (*(_DWORD *)(a1 + 220) == 8)
    v14 = 68;
  else
    v14 = 72;
  reply = create_reply((char *)v14, 23, a1, v9, v10, v11, v12, v13);
  *((_DWORD *)reply + 11) = 0;
  *((_DWORD *)reply + 12) = 0;
  *((_DWORD *)reply + 13) = bswap32(a2);
  *((_QWORD *)reply + 7) = 0;
  *(_DWORD *)(reply + 63) = 0;
  append_reply(a1, reply);
}

void ___handle_addrinfo_request_with_trust_block_invoke(id a1, void *a2)
{
  if (a2)
    free(a2);
}

void ___handle_regservice_request_with_trust_block_invoke_2(uint64_t a1, int a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  NSObject *v25;
  int v26;
  void *v27;
  uint8_t buf[4];
  int v29;
  __int16 v30;
  unsigned int v31;

  if (!a2)
  {
    v5 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
    *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v5, v6, v7, v8, v9, v10, v11, v12);
    v20 = *(_QWORD *)(a1 + 32);
    if (*(_QWORD *)(v20 + 64) && *(_BYTE *)(v20 + 27))
      goto LABEL_19;
    v13 = *(_BYTE **)(v20 + 56);
    if (!v13)
      goto LABEL_19;
    if (a3 == 1)
    {
      v21 = _handle_regservice_request_start(*(_QWORD *)(a1 + 40), v13);
      if (!v21)
        goto LABEL_19;
    }
    else
    {
      v21 = -65570;
    }
    v22 = *(_QWORD *)(a1 + 40);
    v23 = *(_QWORD *)(v22 + 120);
    v24 = *(void **)(v23 + 16);
    if (v24)
    {
      free(v24);
      *(_QWORD *)(v23 + 16) = 0;
    }
    v27 = 0;
    if (GenerateNTDResponse(0, 0, v22, (char **)&v27, (char *)0x41, 0, v21))
    {
      v25 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        {
LABEL_18:
          v26 = *(_DWORD *)(v22 + 192);
          *(_DWORD *)buf = 67109376;
          v29 = v26;
          v30 = 1024;
          v31 = v21;
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "[R%u] DNSServiceRegister _return_regservice_request_error: error(%d)", buf, 0xEu);
        }
      }
      else
      {
        v25 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          goto LABEL_18;
      }
    }
    else
    {
      append_reply(v22, v27);
    }
LABEL_19:
    KQueueUnlock((uint64_t)"_register_service_instance_with_trust", (uint64_t)v13, v14, v15, v16, v17, v18, v19);
  }
}

void ___handle_regservice_request_with_trust_block_invoke(id a1, void *a2)
{
  if (a2)
    free(a2);
}

void ___handle_browse_request_with_trust_block_invoke_2(uint64_t a1, int a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int8 *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  NSObject *v23;
  int v24;
  void *v25;
  uint8_t buf[4];
  int v27;
  __int16 v28;
  unsigned int v29;

  if (!a2)
  {
    v5 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
    *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v5, v6, v7, v8, v9, v10, v11, v12);
    v20 = *(_QWORD *)(a1 + 32);
    if (*(_QWORD *)(v20 + 64) && *(_BYTE *)(v20 + 27))
      goto LABEL_16;
    v13 = *(unsigned __int8 **)(v20 + 56);
    if (!v13)
      goto LABEL_16;
    if (a3 == 1)
    {
      v21 = _handle_browse_request_start(*(_QWORD *)(a1 + 40), v13, v14, v15, v16, v17, v18, v19);
      if (!v21)
        goto LABEL_16;
    }
    else
    {
      v21 = -65570;
    }
    v22 = *(_QWORD *)(a1 + 40);
    v25 = 0;
    GenerateBrowseReply(0, 0, v22, (char **)&v25, 0, v21);
    v23 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
LABEL_14:
        v24 = *(_DWORD *)(v22 + 192);
        *(_DWORD *)buf = 67109376;
        v27 = v24;
        v28 = 1024;
        v29 = v21;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "[R%d] DNSServiceBrowse _return_browse_request_error: error (%d)", buf, 0xEu);
      }
    }
    else
    {
      v23 = mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_14;
    }
    append_reply(v22, v25);
LABEL_16:
    KQueueUnlock((uint64_t)"_handle_browse_request_with_trust", (uint64_t)v13, v14, v15, v16, v17, v18, v19);
  }
}

void ___handle_browse_request_with_trust_block_invoke(id a1, void *a2)
{
  if (a2)
    free(a2);
}

void ___handle_queryrecord_request_with_trust_block_invoke_2(uint64_t a1, int a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  if (!a2)
  {
    v5 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
    *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v5, v6, v7, v8, v9, v10, v11, v12);
    v20 = *(_QWORD *)(a1 + 32);
    if (*(_QWORD *)(v20 + 64) && *(_BYTE *)(v20 + 27))
      goto LABEL_10;
    v13 = *(_QWORD *)(v20 + 56);
    if (!v13)
      goto LABEL_10;
    if (a3 == 1)
    {
      v13 = _handle_queryrecord_request_start(*(_QWORD *)(a1 + 40), v13, v14, v15, v16, v17, v18, v19);
      if (!(_DWORD)v13)
        goto LABEL_10;
    }
    else
    {
      LODWORD(v13) = -65570;
    }
    _return_queryrecord_request_error(*(_QWORD *)(a1 + 40), v13);
LABEL_10:
    KQueueUnlock((uint64_t)"_handle_queryrecord_request_with_trust", v13, v14, v15, v16, v17, v18, v19);
  }
}

void ___handle_queryrecord_request_with_trust_block_invoke(id a1, void *a2)
{
  if (a2)
    free(a2);
}

void ___handle_resolve_request_with_trust_block_invoke_2(uint64_t a1, int a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  NSObject *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  char *reply;
  _DWORD v31[2];
  __int16 v32;
  unsigned int v33;

  if (!a2)
  {
    v5 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
    *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v5, v6, v7, v8, v9, v10, v11, v12);
    v20 = *(_QWORD *)(a1 + 32);
    if (*(_QWORD *)(v20 + 64) && *(_BYTE *)(v20 + 27))
      goto LABEL_16;
    v13 = *(_QWORD *)(v20 + 56);
    if (!v13)
      goto LABEL_16;
    if (a3 == 1)
    {
      v21 = _handle_resolve_request_start(*(_QWORD *)(a1 + 40), v13);
      if (!v21)
        goto LABEL_16;
    }
    else
    {
      v21 = -65570;
    }
    v22 = *(_QWORD *)(a1 + 40);
    v23 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEFAULT))
      {
LABEL_14:
        v29 = *(_DWORD *)(v22 + 192);
        v31[0] = 67109376;
        v31[1] = v29;
        v32 = 1024;
        v33 = v21;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "[R%u] DNSServiceResolve _return_resolve_request_error: error(%d)", (uint8_t *)v31, 0xEu);
      }
    }
    else
    {
      v23 = mDNSLogCategory_mDNS_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_14;
    }
    reply = create_reply((char *)0x43, 18, v22, v24, v25, v26, v27, v28);
    *((_DWORD *)reply + 11) = 0;
    *((_DWORD *)reply + 12) = 0;
    *(_QWORD *)(reply + 52) = bswap32(v21);
    *((_WORD *)reply + 30) = 0;
    append_reply(v22, reply);
LABEL_16:
    KQueueUnlock((uint64_t)"_handle_resolve_request_with_trust", v13, v14, v15, v16, v17, v18, v19);
  }
}

void ___handle_resolve_request_with_trust_block_invoke(id a1, void *a2)
{
  if (a2)
    free(a2);
}

void PrintOneCacheRecordToFD(int a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, _DWORD *a6)
{
  uint64_t v7;
  size_t i;
  char *v9;
  char *v10;
  int v11;
  unsigned int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned __int8 *v21;

  v21 = (unsigned __int8 *)(a2 + 8);
  v7 = *(_QWORD *)(a2 + 64);
  for (i = 64; ; i = v13 + 1)
  {
    v9 = (char *)malloc_type_calloc(1uLL, i, 0xF1748037uLL);
    if (!v9)
    {
      __break(1u);
      return;
    }
    v10 = v9;
    if (!v7)
    {
LABEL_13:
      *v10 = 0;
      goto LABEL_15;
    }
    v11 = *(_DWORD *)(v7 + 32);
    if (v11 == 1)
    {
      v12 = snprintf(v9, i, "  validated, %s%s");
      goto LABEL_10;
    }
    if (v11)
      break;
    if (*(_BYTE *)(v7 + 40))
      v12 = snprintf(v9, i, "to validate, positive, %-4zu%s");
    else
      v12 = snprintf(v9, i, "to validate, negative, 1   %s");
LABEL_10:
    if ((v12 & 0x80000000) != 0)
      goto LABEL_13;
    if (i > v12)
      goto LABEL_15;
    v13 = v12;
    free(v10);
  }
  free(v9);
  v10 = 0;
LABEL_15:
  v14 = *(unsigned __int8 *)(a2 + 129);
  DNSTypeName(*(unsigned __int16 *)(a2 + 12));
  if (v14 != 1)
    GetRRDisplayString_rdb(v21, (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), word_100164580);
  LogToFD(a1, "%3d %s%8d %-7s%s %-6s   %-40s%s", v15, v16, v17, v18, v19, v20, a3);
  ++*a6;
  if (v10)
    free(v10);
}

uint64_t LogAuthRecordsToFD(uint64_t result, int a2, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v10;
  int v12;
  __int128 *v13;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  _OWORD v31[2];

  v8 = result;
  memset(v31, 0, 20);
  if (!a3)
    return LogToFD(v8, "<None>", a3, (uint64_t)a4, a5, a6, a7, a8, v30);
  v10 = a3;
  v12 = 1;
  do
  {
    v13 = &xmmword_10015BF38;
    do
      v13 = *(__int128 **)v13;
    while (v13 && *((_QWORD *)v13 + 444) != *(_QWORD *)(v10 + 32));
    if ((a4 != 0) != (*(_DWORD *)(v10 + 126) == 0))
    {
      if (v12)
        LogToFD(v8, "Time Registered                  Int    Next  Expire if     State", a3, (uint64_t)a4, a5, a6, a7, a8, v30);
      if (a4)
        ++*a4;
      if (*(_QWORD *)&v31[0] != *(_QWORD *)(v10 + 124)
        || *((_QWORD *)&v31[0] + 1) != *(_QWORD *)(v10 + 132)
        || LODWORD(v31[1]) != (unint64_t)*(unsigned int *)(v10 + 140))
      {
        v31[0] = *(_OWORD *)(v10 + 124);
        LODWORD(v31[1]) = *(_DWORD *)(v10 + 140);
        if (*(_DWORD *)((char *)v31 + 14))
        {
          LogToFD(v8, "Proxying for H-MAC %.6a I-MAC %.6a Password %.6a seq %d", a3, (uint64_t)a4, a5, a6, a7, a8, (int)v31 + 2);
        }
        else if (WORD1(v31[0]) == WORD4(v31[0]) && WORD2(v31[0]) == WORD5(v31[0]) && WORD3(v31[0]) == WORD6(v31[0]))
        {
          LogToFD(v8, "Proxying for %.6a seq %d", a3, (uint64_t)a4, a5, a6, a7, a8, (int)v31 + 2);
        }
        else
        {
          LogToFD(v8, "Proxying for H-MAC %.6a I-MAC %.6a seq %d", a3, (uint64_t)a4, a5, a6, a7, a8, (int)v31 + 2);
        }
      }
      if (!*(_QWORD *)(v10 + 32) && !*(_BYTE *)(v10 + 122) && !IsLocalDomain(*(_BYTE **)(v10 + 40)))
        goto LABEL_31;
      v16 = *(_DWORD *)(v10 + 172);
      if (v16 == 5)
      {
        v23 = *(_QWORD *)(v10 + 32);
        GetRRDisplayString_rdb((unsigned __int8 *)(v10 + 8), (unsigned __int16 *)(*(_QWORD *)(v10 + 48) + 4), word_100164580);
        if (v23 == -5)
          result = LogToFD(v8, "                             BLE %s", v24, v25, v26, v27, v28, v29, (int)word_100164580);
        else
          result = LogToFD(v8, "                             PP %s", v24, v25, v26, v27, v28, v29, (int)word_100164580);
        goto LABEL_35;
      }
      if (v16 == 4)
      {
        GetRRDisplayString_rdb((unsigned __int8 *)(v10 + 8), (unsigned __int16 *)(*(_QWORD *)(v10 + 48) + 4), word_100164580);
        result = LogToFD(v8, "                             LO %s", v17, v18, v19, v20, v21, v22, (int)word_100164580);
      }
      else
      {
LABEL_31:
        result = LogOneAuthRecordToFD(v8, v10, a2);
      }
LABEL_35:
      v12 = 0;
    }
    v10 = *(_QWORD *)v10;
  }
  while (v10);
  if (v12)
    return LogToFD(v8, "<None>", a3, (uint64_t)a4, a5, a6, a7, a8, v30);
  return result;
}

const char *RecordTypeName(int a1)
{
  const char *result;

  result = "Unregistered ";
  switch(a1)
  {
    case 0:
      return result;
    case 1:
      result = "Deregistering";
      break;
    case 2:
      result = "Unique       ";
      break;
    case 3:
    case 5:
    case 6:
    case 7:
      goto LABEL_6;
    case 4:
      result = "Advisory     ";
      break;
    case 8:
      result = "Shared       ";
      break;
    default:
      if (a1 == 16)
      {
        result = "Verified     ";
      }
      else if (a1 == 32)
      {
        result = "KnownUnique  ";
      }
      else
      {
LABEL_6:
        result = "Unknown";
      }
      break;
  }
  return result;
}

uint64_t LogClientInfoToFD(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void (*v11)(uint64_t);
  uint64_t v12;
  int v13;
  uint64_t v14;
  _QWORD *k;
  const char *v16;
  uint64_t v17;
  _QWORD *m;
  const char *v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t i;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t j;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD v38[2];
  __int16 v39;
  _QWORD v40[2];

  *(_QWORD *)((char *)v40 + 6) = 0;
  v40[0] = 0;
  v38[0] = 0;
  v38[1] = 0;
  v39 = 0;
  mDNS_snprintf(v40);
  result = mDNS_snprintf(v38);
  v11 = *(void (**)(uint64_t))(a2 + 104);
  if (!v11)
    return LogToFD(a1, "%s No operation yet on this socket", v5, v6, v7, v8, v9, v10, (int)v38);
  if (v11 == connection_termination)
  {
    v12 = *(_QWORD *)(a2 + 168);
    if (v12)
    {
      v13 = 0;
      do
      {
        ++v13;
        v12 = *(_QWORD *)(v12 + 8);
      }
      while (v12);
    }
    v20 = *(_QWORD *)(a2 + 16);
    if (v20)
    {
      v21 = 0;
      do
      {
        v22 = v20 + 16;
        v20 = *(_QWORD *)(v20 + 16);
        if (*(_QWORD *)(v22 + 8) == a2)
          ++v21;
      }
      while (v20);
    }
    result = LogToFD(a1, "%s DNSServiceCreateConnection: %d registered record%s, %d kDNSServiceFlagsShareConnection operation%s PID[%d](%s)", v5, v6, v7, v8, v9, v10, (int)v38);
    for (i = *(_QWORD *)(a2 + 168); i; i = *(_QWORD *)(i + 8))
    {
      v24 = *(_DWORD *)(a2 + 240);
      GetRRDisplayString_rdb((unsigned __int8 *)(*(_QWORD *)(i + 56) + 8), (unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(i + 56) + 48) + 4), word_100164580);
      result = LogToFD(a1, " ->  DNSServiceRegisterRecord   0x%08X %2d %3d %s PID[%d](%s)", v25, v26, v27, v28, v29, v30, v24);
    }
    for (j = *(_QWORD *)(a2 + 16); j; j = *(_QWORD *)(j + 16))
    {
      if (*(_QWORD *)(j + 24) == a2)
        result = LogClientInfoToFD(a1, j);
    }
  }
  else if ((char *)v11 == (char *)regservice_termination_callback)
  {
    v14 = *(_QWORD *)(a2 + 120);
    for (k = *(_QWORD **)(v14 + 1624); k; k = (_QWORD *)*k)
    {
      if (k == *(_QWORD **)(v14 + 1624))
        v16 = (const char *)v38;
      else
        v16 = "";
      result = LogToFD(a1, "%-9s DNSServiceRegister         0x%08X %2d %##s %u/%u PID[%d](%s)", v5, v6, v7, v8, v9, v10, (int)v16);
    }
  }
  else if ((char *)v11 == (char *)browse_termination_callback)
  {
    v17 = *(_QWORD *)(a2 + 144);
    for (m = *(_QWORD **)(v17 + 272); m; m = (_QWORD *)*m)
    {
      if (m == *(_QWORD **)(v17 + 272))
        v19 = (const char *)v38;
      else
        v19 = "";
      result = LogToFD(a1, "%-9s DNSServiceBrowse           0x%08X %2d %##s PID[%d](%s)", v5, v6, v7, v8, v9, v10, (int)v19);
    }
  }
  else if (v11 == resolve_termination_callback)
  {
    return LogToFD(a1, "%s DNSServiceResolve          0x%08X %2d %##s PID[%d](%s)", v5, v6, v7, v8, v9, v10, (int)v38);
  }
  else if (v11 == queryrecord_termination_callback)
  {
    DNSTypeName(*(unsigned __int16 *)(*(_QWORD *)(a2 + 136) + 342));
    return LogToFD(a1, "%s DNSServiceQueryRecord      0x%08X %2d %##s (%s) PID[%d](%s)", v32, v33, v34, v35, v36, v37, (int)v38);
  }
  else if ((char *)v11 == (char *)enum_termination_callback)
  {
    return LogToFD(a1, "%s DNSServiceEnumerateDomains 0x%08X %2d %##s PID[%d](%s)", v5, v6, v7, v8, v9, v10, (int)v38);
  }
  else if (v11 == port_mapping_termination_callback)
  {
    return LogToFD(a1, "%s DNSServiceNATPortMapping   0x%08X %2d %s%s Int %5d Req %5d Ext %.4a:%5d Req TTL %5d Granted TTL %5d PID[%d](%s)", v5, v6, v7, v8, v9, v10, (int)v38);
  }
  else if (v11 == addrinfo_termination_callback)
  {
    return LogToFD(a1, "%s DNSServiceGetAddrInfo      0x%08X %2d %s%s %##s PID[%d](%s)", v5, v6, v7, v8, v9, v10, (int)v38);
  }
  else
  {
    return LogToFD(a1, "%s Unrecognized operation %p", v5, v6, v7, v8, v9, v10, (int)v38);
  }
  return result;
}

uint64_t LogOneAuthRecordToFD(int a1, uint64_t a2, int a3)
{
  int v6;
  unsigned int v7;
  int v8;
  unint64_t v9;
  int v10;
  uint64_t v11;
  BOOL v12;
  int v13;
  _BOOL8 v14;
  int v15;
  unsigned __int8 *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  unint64_t v25;
  uint64_t v26;
  timeval v27;
  _OWORD v28[2];

  memset(v28, 0, sizeof(v28));
  v6 = *(_DWORD *)(a2 + 648);
  v25 = 0;
  v26 = 0;
  v27.tv_sec = 0;
  *(_QWORD *)&v27.tv_usec = 0;
  gettimeofday(&v27, 0);
  v7 = v6 - a3;
  if (v6 - a3 < 1)
  {
    v11 = 274877907000000 * ((a3 - v6) % 1000);
    LODWORD(v11) = (v11 >> 38) + ((unint64_t)v11 >> 63);
    v13 = v27.tv_usec - v11;
    v12 = v27.tv_usec < (int)v11;
    v14 = v27.tv_usec < (int)v11;
    if (v12)
      v15 = 1000000;
    else
      v15 = 0;
    v9 = v27.tv_sec - (a3 - v6) / 1000 - v14;
    v10 = v13 + v15;
  }
  else
  {
    v8 = v27.tv_usec + (int)(1000000 * (v7 % 0x3E8)) / 1000;
    v9 = v27.tv_sec + v7 / 0x3E8uLL + v8 / 1000000;
    v10 = v8 % 1000000;
  }
  v25 = v9;
  LODWORD(v26) = v10;
  getLocalTimestampFromTimeval((uint64_t)&v25, (char *)v28);
  v16 = (unsigned __int8 *)(a2 + 8);
  if (*(_QWORD *)(a2 + 32) || *(_BYTE *)(a2 + 122) || IsLocalDomain(*(_BYTE **)(a2 + 40)))
  {
    GetRRDisplayString_rdb(v16, (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), word_100164580);
    v23 = "%s %7d %7d %7d %-7s 0x%02X %s %s";
  }
  else
  {
    GetRRDisplayString_rdb(v16, (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), word_100164580);
    v23 = "%s %7d %7d %7d %-7s %4d %s %s";
  }
  return LogToFD(a1, v23, v17, v18, v19, v20, v21, v22, (int)v28);
}

void LogClientInfo(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void (*v7)(uint64_t);
  uint64_t v8;
  int v9;
  uint64_t v10;
  _QWORD *k;
  const char *v12;
  uint64_t v13;
  _QWORD *m;
  const char *v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t i;
  NSObject *v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t j;
  NSObject *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD v34[2];
  __int16 v35;
  _QWORD v36[2];

  *(_QWORD *)((char *)v36 + 6) = 0;
  v36[0] = 0;
  v34[0] = 0;
  v34[1] = 0;
  v35 = 0;
  mDNS_snprintf(v36);
  mDNS_snprintf(v34);
  v7 = *(void (**)(uint64_t))(a1 + 104);
  if (v7)
  {
    if (v7 == connection_termination)
    {
      v8 = *(_QWORD *)(a1 + 168);
      if (v8)
      {
        v9 = 0;
        do
        {
          ++v9;
          v8 = *(_QWORD *)(v8 + 8);
        }
        while (v8);
      }
      v16 = *(_QWORD *)(a1 + 16);
      if (v16)
      {
        v17 = 0;
        do
        {
          v18 = v16 + 16;
          v16 = *(_QWORD *)(v16 + 16);
          if (*(_QWORD *)(v18 + 8) == a1)
            ++v17;
        }
        while (v16);
      }
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%s DNSServiceCreateConnection: %d registered record%s, %d kDNSServiceFlagsShareConnection operation%s PID[%d](%s)", v2, v3, v4, v5, v6, (int)v34);
      for (i = *(_QWORD *)(a1 + 168); i; i = *(_QWORD *)(i + 8))
      {
        v20 = mDNSLogCategory_Default;
        v21 = *(_DWORD *)(a1 + 240);
        GetRRDisplayString_rdb((unsigned __int8 *)(*(_QWORD *)(i + 56) + 8), (unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)(i + 56) + 48) + 4), word_100164580);
        LogMsgWithLevel(v20, OS_LOG_TYPE_DEFAULT, " ->  DNSServiceRegisterRecord   0x%08X %2d %3d %s PID[%d](%s)", v22, v23, v24, v25, v26, v21);
      }
      for (j = *(_QWORD *)(a1 + 16); j; j = *(_QWORD *)(j + 16))
      {
        if (*(_QWORD *)(j + 24) == a1)
          LogClientInfo(j);
      }
    }
    else if ((char *)v7 == (char *)regservice_termination_callback)
    {
      v10 = *(_QWORD *)(a1 + 120);
      for (k = *(_QWORD **)(v10 + 1624); k; k = (_QWORD *)*k)
      {
        if (k == *(_QWORD **)(v10 + 1624))
          v12 = (const char *)v34;
        else
          v12 = "";
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%-9s DNSServiceRegister         0x%08X %2d %##s %u/%u PID[%d](%s)", v2, v3, v4, v5, v6, (int)v12);
      }
    }
    else if ((char *)v7 == (char *)browse_termination_callback)
    {
      v13 = *(_QWORD *)(a1 + 144);
      for (m = *(_QWORD **)(v13 + 272); m; m = (_QWORD *)*m)
      {
        if (m == *(_QWORD **)(v13 + 272))
          v15 = (const char *)v34;
        else
          v15 = "";
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%-9s DNSServiceBrowse           0x%08X %2d %##s PID[%d](%s)", v2, v3, v4, v5, v6, (int)v15);
      }
    }
    else if (v7 == resolve_termination_callback)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%s DNSServiceResolve          0x%08X %2d %##s PID[%d](%s)", v2, v3, v4, v5, v6, (int)v34);
    }
    else if (v7 == queryrecord_termination_callback)
    {
      v28 = mDNSLogCategory_Default;
      DNSTypeName(*(unsigned __int16 *)(*(_QWORD *)(a1 + 136) + 342));
      LogMsgWithLevel(v28, OS_LOG_TYPE_DEFAULT, "%s DNSServiceQueryRecord      0x%08X %2d %##s (%s) PID[%d](%s)", v29, v30, v31, v32, v33, (int)v34);
    }
    else if ((char *)v7 == (char *)enum_termination_callback)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%s DNSServiceEnumerateDomains 0x%08X %2d %##s PID[%d](%s)", v2, v3, v4, v5, v6, (int)v34);
    }
    else if (v7 == port_mapping_termination_callback)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%s DNSServiceNATPortMapping   0x%08X %2d %s%s Int %5d Req %5d Ext %.4a:%5d Req TTL %5d Granted TTL %5d PID[%d](%s)", v2, v3, v4, v5, v6, (int)v34);
    }
    else if (v7 == addrinfo_termination_callback)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%s DNSServiceGetAddrInfo      0x%08X %2d %s%s %##s PID[%d](%s)", v2, v3, v4, v5, v6, (int)v34);
    }
    else
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%s Unrecognized operation %p", v2, v3, v4, v5, v6, (int)v34);
    }
  }
  else
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%s No operation yet on this socket", v2, v3, v4, v5, v6, (int)v34);
  }
}

uint64_t _Querier_DNSServiceRegistrationStartHandler(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _UNKNOWN **v21;
  uint64_t v22;
  uint64_t v23;

  v6 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v6, v7, v8, v9, v10, v11, v12, v13);
  if (!a1)
    goto LABEL_4;
  v21 = *(_UNKNOWN ***)(a1 + 16);
  if (v21 == &_mdns_dns_service_definition_kind)
  {
    v23 = Querier_RegisterNativeDNSService(a1);
LABEL_7:
    v22 = v23;
    goto LABEL_8;
  }
  if (v21 == &_mdns_dns_push_service_definition_kind)
  {
    v23 = Querier_RegisterCustomPushDNSServiceWithConnectionErrorHandler(a1, a2, a3);
    goto LABEL_7;
  }
LABEL_4:
  v22 = 0;
LABEL_8:
  KQueueUnlock((uint64_t)"DNS service registration start handler", v14, v15, v16, v17, v18, v19, v20);
  return v22;
}

void _Querier_DNSServiceRegistrationStopHandler(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t DNSServiceManager;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v2 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v2, v3, v4, v5, v6, v7, v8, v9);
  DNSServiceManager = Querier_GetDNSServiceManager();
  if (DNSServiceManager)
    mdns_dns_service_manager_deregister_native_service(DNSServiceManager, a1);
  v11 = Querier_GetDNSServiceManager();
  if (v11)
    mdns_dns_service_manager_deregister_custom_push_service(v11, a1);
  KQueueUnlock((uint64_t)"DNS service registration stop handler", v12, v13, v14, v15, v16, v17, v18);
}

uint64_t Querier_GetDNSServiceManager()
{
  uint64_t v0;
  NSObject *v1;
  uint64_t v2;
  _UNKNOWN **v3;
  void (*v4)(uint64_t);
  CFMutableArrayRef Mutable;
  const __CFNumber *v6;
  const __CFNumber *v7;
  CFTypeID v8;
  char v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  void *v13;
  const void *v14;
  _QWORD v16[5];
  _QWORD valuePtr[5];

  if (_Querier_EnsureNEDNSProxyStateWatchHasStarted_sOnce != -1)
    dispatch_once(&_Querier_EnsureNEDNSProxyStateWatchHasStarted_sOnce, &__block_literal_global_32);
  v0 = Querier_GetDNSServiceManager_sDNSServiceManager;
  if (!Querier_GetDNSServiceManager_sDNSServiceManager)
  {
    if (_Querier_InternalQueue_sOnce != -1)
      dispatch_once(&_Querier_InternalQueue_sOnce, &__block_literal_global_38);
    v1 = _Querier_InternalQueue_sQueue;
    v2 = _os_object_alloc(OS_mdns_dns_service_manager, 136);
    v0 = v2;
    if (v2)
    {
      v3 = &_mdns_dns_service_manager_kind;
      *(_QWORD *)(v2 + 16) = &_mdns_dns_service_manager_kind;
      do
      {
        v4 = (void (*)(uint64_t))v3[2];
        if (v4)
          v4(v0);
        v3 = (_UNKNOWN **)*v3;
      }
      while (v3);
      if (_mdns_dns_service_manager_enumerate_all_service_array_pointers(v0, (uint64_t)&__block_literal_global_794)&& (Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, (const CFArrayCallBacks *)&mdns_cfarray_callbacks), (*(_QWORD *)(v0 + 80) = Mutable) != 0))
      {
        *(_QWORD *)(v0 + 88) = v1;
        dispatch_retain(v1);
        if (!*(_BYTE *)(v0 + 132))
        {
          *(_WORD *)(v0 + 128) = 257;
          *(_DWORD *)(v0 + 120) = PQWorkaroundThreshold;
        }
        if (os_variant_has_internal_diagnostics("com.apple.mDNSResponder"))
        {
          v6 = (const __CFNumber *)CFPreferencesCopyAppValue(CFSTR("DDRRetryIntervalSecs"), CFSTR("com.apple.mDNSResponder"));
          if (v6)
          {
            v7 = v6;
            v8 = CFGetTypeID(v6);
            if (v8 == CFNumberGetTypeID())
            {
              if (CFNumberIsFloatType(v7)
                || (valuePtr[0] = 0, !CFNumberGetValue(v7, kCFNumberLongLongType, valuePtr)))
              {
                v10 = 0;
                v9 = 1;
              }
              else
              {
                v9 = 0;
                v10 = valuePtr[0];
              }
              CFRelease(v7);
              v11 = 0xFFFFFFFFLL;
              if (v10 < 0xFFFFFFFFLL)
                v11 = v10;
              if ((v9 & 1) == 0)
              {
                v12 = v11 & ~(v11 >> 63);
                if (v12)
                {
                  if (!*(_BYTE *)(v0 + 132))
                  {
                    if (_mdns_os_variant_has_internal_diagnostics_s_once != -1)
                      dispatch_once(&_mdns_os_variant_has_internal_diagnostics_s_once, &__block_literal_global_240);
                    if (_mdns_os_variant_has_internal_diagnostics_s_result)
                      *(_DWORD *)(v0 + 124) = v12;
                  }
                }
              }
            }
            else
            {
              CFRelease(v7);
            }
          }
        }
        v16[0] = _NSConcreteStackBlock;
        v16[1] = 0x40000000;
        v16[2] = __Querier_GetDNSServiceManager_block_invoke;
        v16[3] = &__block_descriptor_tmp_3134;
        v16[4] = v0;
        if (!*(_BYTE *)(v0 + 132))
        {
          v13 = _Block_copy(v16);
          v14 = *(const void **)(v0 + 104);
          if (v14)
            _Block_release(v14);
          *(_QWORD *)(v0 + 104) = v13;
        }
        Querier_GetDNSServiceManager_sDNSServiceManager = v0;
        os_retain((void *)v0);
        v0 = Querier_GetDNSServiceManager_sDNSServiceManager;
        if (!*(_BYTE *)(Querier_GetDNSServiceManager_sDNSServiceManager + 132))
        {
          *(_BYTE *)(Querier_GetDNSServiceManager_sDNSServiceManager + 132) = 1;
          if (_mdns_dns_service_queue_s_once != -1)
            dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
          valuePtr[0] = _NSConcreteStackBlock;
          valuePtr[1] = 0x40000000;
          valuePtr[2] = __mdns_dns_service_manager_activate_block_invoke;
          valuePtr[3] = &__block_descriptor_tmp_4;
          valuePtr[4] = v0;
          dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, valuePtr);
          return Querier_GetDNSServiceManager_sDNSServiceManager;
        }
      }
      else
      {
        os_release((void *)v0);
        return 0;
      }
    }
  }
  return v0;
}

uint64_t Querier_ProcessDNSServiceChanges(uint64_t result)
{
  int v1;
  uint64_t v2;
  unsigned int v3;
  uint64_t v4;
  unsigned int v5;
  int v6;
  _BOOL4 v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  int v11;
  __int16 v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;

  v1 = result;
  v2 = *(_QWORD *)((char *)&xmmword_100158E84 + 4);
  if (*(_QWORD *)((char *)&xmmword_100158E84 + 4))
  {
    v3 = 0;
    v4 = *(_QWORD *)((char *)&xmmword_100158E84 + 4);
    do
    {
      ++v3;
      v4 = *(_QWORD *)(v4 + 8);
    }
    while (v4);
    qword_100158EB0 = *(_QWORD *)((char *)&xmmword_100158E84 + 4);
    if (v3)
    {
      v5 = 1;
      while (1)
      {
        v6 = *(unsigned __int16 *)(v2 + 340);
        if (*(_WORD *)(v2 + 340))
        {
          if (!v1 || *(_QWORD *)(v2 + 184))
            goto LABEL_13;
        }
        else
        {
          result = DNSQuestionIsEligibleForMDNSAlternativeService(v2);
          if ((_DWORD)result)
          {
            result = Querier_IsMDNSAlternativeServiceAvailableForQuestion(v2);
            if ((_DWORD)result)
            {
              *(_WORD *)(v2 + 340) = mDNS_NewMessageID((uint64_t)mDNSStorage);
LABEL_13:
              v7 = _Querier_ExcludeEncryptedDNSServices(v2);
              result = _Querier_GetDNSService(v2, v7);
              v8 = result;
              v9 = *(_QWORD *)(v2 + 80);
              if (v9 == result)
              {
                if (result && *(_BYTE *)(result + 280) == 4)
                {
                  mDNSPlatformGetDNSRoutePolicy(v2);
                  result = _Querier_GetDNSService(v2, v7);
                  v8 = result;
                  v10 = 0;
                  v9 = *(_QWORD *)(v2 + 80);
                  goto LABEL_16;
                }
                v10 = 0;
              }
              else
              {
                v10 = !*(_QWORD *)(v2 + 136)
                   && (!result
                    || *(_BYTE *)(result + 280) == 1
                    && *(unsigned __int8 *)(result + 281) - 2 >= 4
                    && (*(_WORD *)(result + 276) & 0x200) == 0);
LABEL_16:
                if (v9 != v8)
                {
                  v11 = *(unsigned __int8 *)(v2 + 354);
                  goto LABEL_24;
                }
                v8 = v9;
              }
              result = DetermineUnicastQuerySuppression(v2, v8);
              v11 = *(unsigned __int8 *)(v2 + 354);
              if (((_DWORD)result == 0) == (*(_BYTE *)(v2 + 354) != 0))
              {
LABEL_24:
                if (!v11)
                {
                  v12 = *(_WORD *)(v2 + 340);
                  if (!v6)
                    *(_WORD *)(v2 + 340) = 0;
                  result = CacheRecordRmvEventsForQuestion(v2);
                  if (qword_100158EB0 == v2)
                  {
                    result = LocalRecordRmvEventsForQuestion(v2);
                    if (!v6)
LABEL_29:
                      *(_WORD *)(v2 + 340) = v12;
                  }
                  else if (!v6)
                  {
                    goto LABEL_29;
                  }
                }
                if (qword_100158EB0 == v2)
                {
                  mDNS_StopQuery_internal(mDNSStorage, v2);
                  *(_BYTE *)(v2 + 642) = v10;
                  *(_QWORD *)(v2 + 8) = 0;
                  result = mDNS_StartQuery_internal((uint64_t)mDNSStorage, v2);
                }
              }
              v13 = qword_100158EB0;
              if (qword_100158EB0 != v2)
                goto LABEL_34;
            }
          }
        }
        v13 = *(_QWORD *)(v2 + 8);
        qword_100158EB0 = v13;
LABEL_34:
        if (v5 < v3)
        {
          ++v5;
          v2 = v13;
          if (v13)
            continue;
        }
        break;
      }
    }
  }
  qword_100158EB0 = 0;
  if (!v1)
  {
    v14 = 0;
    while (1)
    {
      v15 = (_QWORD *)mDNSStorage[v14 + 34];
      if (v15)
        break;
LABEL_56:
      if (++v14 == 499)
        return result;
    }
    while (1)
    {
      v16 = (_QWORD *)v15[2];
      if (v16)
        break;
LABEL_55:
      v15 = (_QWORD *)*v15;
      if (!v15)
        goto LABEL_56;
    }
    while (1)
    {
      if (!v16[4])
      {
        result = v16[7];
        if (result)
        {
          v17 = *(_QWORD *)(result + 24);
          if (v17 && (*(_WORD *)(v17 + 276) & 1) == 0)
            goto LABEL_54;
          os_release((void *)result);
          v16[7] = 0;
        }
        result = mDNS_PurgeCacheResourceRecord((unsigned int *)mDNSStorage, (uint64_t)v16);
      }
LABEL_54:
      v16 = (_QWORD *)*v16;
      if (!v16)
        goto LABEL_55;
    }
  }
  return result;
}

void _Querier_LogDNSServices(uint64_t a1)
{
  int v2;
  NSObject *v3;
  _QWORD v4[5];
  int v5;
  _QWORD v6[3];
  int v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD block[7];

  v6[0] = 0;
  v6[1] = v6;
  v6[2] = 0x2000000000;
  v7 = 0;
  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = 0;
  if (_mdns_dns_service_queue_s_once != -1)
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = __mdns_dns_service_manager_get_count_block_invoke;
  block[3] = &unk_10013A658;
  block[4] = &v8;
  block[5] = a1;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, block);
  v2 = *((_DWORD *)v9 + 6);
  _Block_object_dispose(&v8, 8);
  v3 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(block[0]) = 67109120;
      HIDWORD(block[0]) = v2;
      goto LABEL_9;
    }
  }
  else
  {
    v3 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(block[0]) = 67109120;
      HIDWORD(block[0]) = v2;
LABEL_9:
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Updated DNS services (%u)", (uint8_t *)block, 8u);
    }
  }
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___Querier_LogDNSServices_block_invoke;
  v4[3] = &unk_10013C398;
  v4[4] = v6;
  v5 = v2;
  mdns_dns_service_manager_enumerate(a1, (uint64_t)v4);
  _Block_object_dispose(v6, 8);
}

uint64_t Querier_IsMDNSAlternativeServiceAvailableForQuestion(uint64_t a1)
{
  uint64_t result;

  result = Querier_GetDNSServiceManager(a1);
  if (result)
    return _Querier_GetMDNSAlternativeService(result, a1) != 0;
  return result;
}

BOOL _Querier_ExcludeEncryptedDNSServices(uint64_t a1)
{
  return Querier_QuestionBelongsToSelf(a1) || *(_BYTE *)(a1 + 650) || IsLocalDomain((_BYTE *)(a1 + 376));
}

uint64_t _Querier_GetDNSService(uint64_t a1, int a2)
{
  uint64_t DNSServiceManager;
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t CustomPushService;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t interface_scoped_system_service_with_options;
  int v16;
  uint64_t uuid_scoped_service;
  uint64_t v18;
  uint64_t v19;
  int v20;
  _BOOL4 v21;
  int v22;
  NSObject *v23;
  int v24;
  unsigned int v25;
  uint64_t (*v26)(uint64_t);
  uint64_t discovered_service;
  uint64_t v28;
  uint64_t discovered_oblivious_service;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  void **block;
  uint64_t v37;
  uint64_t (*v38)(uint64_t);
  void *v39;
  uint64_t *v40;
  uint64_t v41;
  uint64_t v42;
  int v43;

  DNSServiceManager = Querier_GetDNSServiceManager(a1);
  if (!DNSServiceManager)
    return 0;
  v5 = DNSServiceManager;
  if (*(_BYTE *)(a1 + 651))
    return mdns_dns_service_manager_get_uuid_scoped_service(DNSServiceManager, a1 + 360, *(_DWORD *)(a1 + 136));
  if (*(_WORD *)(a1 + 340)
    && !*(_BYTE *)(a1 + 638)
    && !*(_BYTE *)(a1 + 652)
    && ((unint64_t)(*(_QWORD *)(a1 + 136) + 5) <= 3 && *(_QWORD *)(a1 + 136) != -4
     || *(_BYTE *)(a1 + 634)
     || IsLocalDomain((_BYTE *)(a1 + 376)))
    && !Querier_QuestionBelongsToSelf(a1))
  {
    return _Querier_GetMDNSAlternativeService(v5, a1);
  }
  v7 = *(_QWORD *)(a1 + 184);
  if (v7)
  {
    v8 = *(_QWORD *)(v7 + 16);
    if (!v8)
      return 0;
    if (!*(_BYTE *)(v8 + 68))
    {
      v11 = *(_QWORD *)(v7 + 16);
      if (v11)
      {
        if (*(_QWORD *)(v11 + 32))
        {
          v12 = *(_QWORD *)(v11 + 16);
          if (v12)
            return _Querier_GetDiscoveredPushDNSService(v5, *(_BYTE **)(v12 + 16), *(_DWORD *)(a1 + 136));
        }
      }
      return 0;
    }
  }
  CustomPushService = _Querier_GetCustomPushService(v5, a1);
  if (CustomPushService)
    return CustomPushService;
  v10 = *(_QWORD *)(a1 + 136);
  if (v10)
  {
    v32 = 0;
    v33 = &v32;
    v34 = 0x2000000000;
    v35 = 0;
    if (_mdns_dns_service_queue_s_once != -1)
      dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
    block = _NSConcreteStackBlock;
    v37 = 0x40000000;
    v38 = __mdns_dns_service_manager_get_interface_scoped_native_service_block_invoke;
    v39 = &unk_10013A368;
    v40 = &v32;
    v41 = v5;
    v42 = a1 + 376;
    v43 = v10;
    dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, &block);
    CustomPushService = v33[3];
    _Block_object_dispose(&v32, 8);
    if (CustomPushService)
      return CustomPushService;
  }
  else
  {
    CustomPushService = mdns_dns_service_manager_get_unscoped_native_service(v5, a1 + 376);
    if (CustomPushService)
      return CustomPushService;
  }
  v13 = *(_QWORD *)(a1 + 136);
  v14 = v13;
  if (a2)
    goto LABEL_27;
  if (uuid_is_null((const unsigned __int8 *)(a1 + 360)))
  {
    v14 = *(_QWORD *)(a1 + 136);
LABEL_27:
    if (v14)
    {
      interface_scoped_system_service_with_options = mdns_dns_service_manager_get_interface_scoped_system_service_with_options(v5, a1 + 376, v13, (a2 | gNEDNSProxyIsRunning) == 0);
LABEL_45:
      CustomPushService = interface_scoped_system_service_with_options;
      goto LABEL_46;
    }
    v16 = *(_DWORD *)(a1 + 280);
    if ((v16 & 0x80000000) == 0)
    {
      interface_scoped_system_service_with_options = mdns_dns_service_manager_get_service_scoped_system_service(v5, a1 + 376, v16);
      goto LABEL_45;
    }
    v20 = a2 | gNEDNSProxyIsRunning;
    v21 = v20 == 0;
    if (v20 || (CustomPushService = mdns_dns_service_manager_get_discovered_service(v5, a1 + 376)) == 0)
    {
      interface_scoped_system_service_with_options = mdns_dns_service_manager_get_unscoped_system_service_with_options(v5, a1 + 376, v21);
      goto LABEL_45;
    }
    goto LABEL_46;
  }
  uuid_scoped_service = mdns_dns_service_manager_get_uuid_scoped_service(v5, a1 + 360, v13);
  if (!uuid_scoped_service)
    return 0;
  v18 = uuid_scoped_service;
  v19 = *(_QWORD *)(uuid_scoped_service + 96);
  if (!v19 || nw_resolver_config_get_class(v19) != 4 || *(_QWORD *)(a1 + 136))
    goto LABEL_39;
  discovered_service = mdns_dns_service_manager_get_discovered_service(v5, a1 + 376);
  if (discovered_service)
  {
    CustomPushService = discovered_service;
    v28 = *(_QWORD *)(discovered_service + 96);
    if (v28)
    {
      if (nw_resolver_config_get_class(v28) == 3)
        goto LABEL_46;
    }
  }
  discovered_oblivious_service = mdns_dns_service_manager_get_discovered_oblivious_service(v5, v18, a1 + 376);
  if (!discovered_oblivious_service)
  {
LABEL_39:
    CustomPushService = v18;
    goto LABEL_46;
  }
  v30 = discovered_oblivious_service;
  v31 = *(_QWORD *)(discovered_oblivious_service + 96);
  CustomPushService = v18;
  if (v31)
  {
    if (nw_resolver_config_get_class(v31) == 4)
      CustomPushService = v30;
    else
      CustomPushService = v18;
  }
LABEL_46:
  if (a2 || !CustomPushService)
    goto LABEL_62;
  v22 = *(unsigned __int16 *)(CustomPushService + 276);
  if ((v22 & 0x200) != 0)
    goto LABEL_64;
  if (!*(_BYTE *)(a1 + 647) || *(unsigned __int8 *)(CustomPushService + 281) - 2 <= 3)
  {
    if ((v22 & 0x800) == 0)
    {
LABEL_64:
      if ((~v22 & 0x1800) == 0)
      {
        if (*(_BYTE *)(a1 + 649))
          return 0;
      }
      return CustomPushService;
    }
    goto LABEL_60;
  }
  v23 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
LABEL_58:
      v24 = *(_DWORD *)(a1 + 252);
      v25 = bswap32(*(unsigned __int16 *)(a1 + 340)) >> 16;
      v26 = *(uint64_t (**)(uint64_t))(CustomPushService + 24);
      LODWORD(block) = 67109632;
      HIDWORD(block) = v24;
      LOWORD(v37) = 1024;
      *(_DWORD *)((char *)&v37 + 2) = v25;
      HIWORD(v37) = 2048;
      v38 = v26;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "[R%u->Q%u] DNS service %llu lacks required encryption", (uint8_t *)&block, 0x18u);
    }
  }
  else
  {
    v23 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      goto LABEL_58;
  }
  CustomPushService = 0;
LABEL_60:
  if (*(_QWORD *)a1)
    CustomPushService = mdns_dns_service_manager_get_custom_service(v5, *(_QWORD *)a1);
LABEL_62:
  if (CustomPushService)
  {
    v22 = *(unsigned __int16 *)(CustomPushService + 276);
    goto LABEL_64;
  }
  return CustomPushService;
}

BOOL Querier_QuestionBelongsToSelf(uint64_t a1)
{
  int v2;
  const unsigned __int8 *v4;
  int v5;
  const unsigned __int8 *v6;

  if (*(_BYTE *)(a1 + 652))
    return 0;
  v2 = *(_DWORD *)(a1 + 244);
  if (v2)
  {
    if (_Querier_GetMyPID_sOnce != -1)
    {
      v5 = *(_DWORD *)(a1 + 244);
      dispatch_once(&_Querier_GetMyPID_sOnce, &__block_literal_global_45);
      v2 = v5;
    }
    return v2 == _Querier_GetMyPID_sPID;
  }
  else
  {
    v4 = (const unsigned __int8 *)(a1 + 656);
    if (_Querier_GetMyUUID_sOnce != -1)
    {
      v6 = v4;
      dispatch_once(&_Querier_GetMyUUID_sOnce, &__block_literal_global_47_3150);
      v4 = v6;
    }
    return uuid_compare(v4, _Querier_GetMyUUID_sUUID) == 0;
  }
}

uint64_t _Querier_GetMDNSAlternativeService(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  void **v9;
  uint64_t v10;
  void *v11;
  void *v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;

  v3 = *(_QWORD *)(a2 + 136);
  if (v3)
  {
    v4 = a2 + 376;
    v17 = 0;
    v18 = &v17;
    v19 = 0x2000000000;
    v20 = 0;
    if (_mdns_dns_service_queue_s_once != -1)
      dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
    v5 = _mdns_dns_service_queue_s_queue;
    v9 = _NSConcreteStackBlock;
    v10 = 0x40000000;
    v11 = __mdns_dns_service_manager_get_interface_scoped_mdns_alternative_service_block_invoke;
    v12 = &unk_10013A470;
    v13 = &v17;
    v14 = a1;
    v15 = v4;
    v16 = v3;
  }
  else
  {
    v6 = a2 + 376;
    v17 = 0;
    v18 = &v17;
    v19 = 0x2000000000;
    v20 = 0;
    if (_mdns_dns_service_queue_s_once != -1)
      dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
    v5 = _mdns_dns_service_queue_s_queue;
    v9 = _NSConcreteStackBlock;
    v10 = 0x40000000;
    v11 = __mdns_dns_service_manager_get_unscoped_mdns_alternative_service_block_invoke;
    v12 = &unk_10013A4D8;
    v13 = &v17;
    v14 = a1;
    v15 = v6;
  }
  dispatch_sync(v5, &v9);
  v7 = v18[3];
  _Block_object_dispose(&v17, 8);
  return v7;
}

uint64_t _Querier_GetDiscoveredPushDNSService(uint64_t a1, _BYTE *a2, int a3)
{
  _QWORD *v5;
  void *v6;
  uint64_t v7;
  _QWORD v9[7];
  int v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  _OWORD v15[16];

  v15[0] = xmmword_1000FFEC0;
  v15[1] = unk_1000FFED0;
  memset(&v15[2], 0, 224);
  AppendDomainName(v15, a2);
  v5 = mdns_domain_name_create_with_labels(v15, 0);
  if (!v5)
    return 0;
  v6 = v5;
  v11 = 0;
  v12 = &v11;
  v13 = 0x2000000000;
  v14 = 0;
  if (_mdns_dns_service_queue_s_once != -1)
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = __mdns_dns_service_manager_get_discovered_push_service_block_invoke;
  v9[3] = &unk_10013A578;
  v9[4] = &v11;
  v9[5] = a1;
  v9[6] = v6;
  v10 = a3;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, v9);
  v7 = v12[3];
  _Block_object_dispose(&v11, 8);
  os_release(v6);
  return v7;
}

uint64_t _Querier_GetCustomPushService(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  void **v9;
  uint64_t v10;
  void *v11;
  void *v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;

  v3 = *(_QWORD *)(a2 + 136);
  if (v3)
  {
    v4 = a2 + 376;
    v17 = 0;
    v18 = &v17;
    v19 = 0x2000000000;
    v20 = 0;
    if (_mdns_dns_service_queue_s_once != -1)
      dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
    v5 = _mdns_dns_service_queue_s_queue;
    v9 = _NSConcreteStackBlock;
    v10 = 0x40000000;
    v11 = __mdns_dns_service_manager_get_interface_scoped_custom_push_service_block_invoke;
    v12 = &unk_10013A318;
    v13 = &v17;
    v14 = a1;
    v15 = v4;
    v16 = v3;
  }
  else
  {
    v6 = a2 + 376;
    v17 = 0;
    v18 = &v17;
    v19 = 0x2000000000;
    v20 = 0;
    if (_mdns_dns_service_queue_s_once != -1)
      dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
    v5 = _mdns_dns_service_queue_s_queue;
    v9 = _NSConcreteStackBlock;
    v10 = 0x40000000;
    v11 = __mdns_dns_service_manager_get_unscoped_custom_push_service_block_invoke;
    v12 = &unk_10013A2F0;
    v13 = &v17;
    v14 = a1;
    v15 = v6;
  }
  dispatch_sync(v5, &v9);
  v7 = v18[3];
  _Block_object_dispose(&v17, 8);
  return v7;
}

uint64_t Querier_RegisterNativeDNSService(uint64_t a1)
{
  uint64_t DNSServiceManager;
  uint64_t v3;
  int v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  int v15;
  _QWORD block[9];

  DNSServiceManager = Querier_GetDNSServiceManager();
  if (!DNSServiceManager)
    return 0;
  v3 = DNSServiceManager;
  v12 = 0;
  v13 = &v12;
  v14 = 0x2000000000;
  v15 = 0;
  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = 0;
  if (_mdns_dns_service_queue_s_once != -1)
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = __mdns_dns_service_manager_register_native_service_block_invoke;
  block[3] = &unk_10013A128;
  block[4] = &v8;
  block[5] = &v12;
  block[6] = v3;
  block[7] = a1;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, block);
  v4 = *((_DWORD *)v13 + 6);
  v5 = v9[3];
  _Block_object_dispose(&v8, 8);
  _Block_object_dispose(&v12, 8);
  if (v4)
  {
    v6 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))
      {
        LODWORD(block[0]) = 67109120;
        HIDWORD(block[0]) = v4;
        goto LABEL_12;
      }
    }
    else
    {
      v6 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
      {
        LODWORD(block[0]) = 67109120;
        HIDWORD(block[0]) = v4;
LABEL_12:
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "Failed to register native DNS service - error: %d.", (uint8_t *)block, 8u);
      }
    }
  }
  return v5;
}

uint64_t Querier_RegisterCustomPushDNSServiceWithConnectionErrorHandler(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t DNSServiceManager;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  int v19;
  __int128 block;
  void (*v21)(uint64_t);
  void *v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;

  DNSServiceManager = Querier_GetDNSServiceManager();
  if (!DNSServiceManager)
    return 0;
  v7 = DNSServiceManager;
  v16 = 0;
  v17 = &v16;
  v18 = 0x2000000000;
  v19 = 0;
  v12 = 0;
  v13 = &v12;
  v14 = 0x2000000000;
  v15 = 0;
  if (_mdns_dns_service_queue_s_once != -1)
    dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
  *(_QWORD *)&block = _NSConcreteStackBlock;
  *((_QWORD *)&block + 1) = 0x40000000;
  v21 = __mdns_dns_service_manager_register_custom_push_service_block_invoke;
  v22 = &unk_10013A190;
  v25 = &v16;
  v26 = v7;
  v29 = 0;
  v27 = a1;
  v28 = a2;
  v23 = a3;
  v24 = &v12;
  dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, &block);
  v8 = *((int *)v17 + 6);
  v9 = v13[3];
  _Block_object_dispose(&v12, 8);
  _Block_object_dispose(&v16, 8);
  if ((_DWORD)v8)
  {
    v10 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))
      {
        LODWORD(block) = 134217984;
        *(_QWORD *)((char *)&block + 4) = v8;
        goto LABEL_12;
      }
    }
    else
    {
      v10 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
      {
        LODWORD(block) = 134217984;
        *(_QWORD *)((char *)&block + 4) = v8;
LABEL_12:
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_FAULT, "Failed to register custom push service - error: %{mdns:err}ld", (uint8_t *)&block, 0xCu);
      }
    }
  }
  return v9;
}

uint64_t _Querier_VPNDNSServiceExistsForQName(uint64_t a1)
{
  uint64_t result;
  uint64_t unscoped_system_service_with_options;

  result = Querier_GetDNSServiceManager(a1);
  if (result)
  {
    unscoped_system_service_with_options = mdns_dns_service_manager_get_unscoped_system_service_with_options(result, a1, 0);
    return unscoped_system_service_with_options && (*(_WORD *)(unscoped_system_service_with_options + 276) & 0x200) != 0;
  }
  return result;
}

void Querier_RegisterPathResolver(uint64_t a1)
{
  uint64_t DNSServiceManager;
  uint64_t v3;
  _QWORD v4[6];

  DNSServiceManager = Querier_GetDNSServiceManager(a1);
  if (DNSServiceManager)
  {
    v3 = DNSServiceManager;
    if (_mdns_dns_service_queue_s_once != -1)
      dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 0x40000000;
    v4[2] = __mdns_dns_service_manager_register_path_resolver_block_invoke;
    v4[3] = &__block_descriptor_tmp_13_821;
    v4[4] = v3;
    v4[5] = a1;
    dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, v4);
  }
}

uint64_t Querier_RegisterCustomDNSServiceWithPListData(const UInt8 *a1, CFIndex a2)
{
  uint64_t DNSServiceManager;
  uint64_t v5;
  const __CFData *v6;
  const __CFData *v7;
  CFPropertyListRef v8;
  CFTypeID v9;
  void *v10;
  uint64_t v11;

  DNSServiceManager = Querier_GetDNSServiceManager();
  if (DNSServiceManager)
  {
    v5 = DNSServiceManager;
    v6 = CFDataCreate(0, a1, a2);
    if (v6)
    {
      v7 = v6;
      v8 = CFPropertyListCreateWithData(0, v6, 0, 0, 0);
      CFRelease(v7);
      if (v8)
      {
        v9 = CFGetTypeID(v8);
        if (v9 == CFDictionaryGetTypeID())
        {
          v10 = (void *)_CFXPCCreateXPCObjectFromCFObject(v8);
          CFRelease(v8);
          if (v10)
          {
            v11 = mdns_dns_service_manager_register_custom_service(v5, (uint64_t)v10);
            xpc_release(v10);
            return v11;
          }
        }
        else
        {
          CFRelease(v8);
        }
      }
    }
  }
  return 0;
}

void Querier_DeregisterCustomDNSService(uint64_t a1)
{
  uint64_t DNSServiceManager;
  uint64_t v3;
  _QWORD v4[6];

  DNSServiceManager = Querier_GetDNSServiceManager();
  if (DNSServiceManager)
  {
    v3 = DNSServiceManager;
    if (_mdns_dns_service_queue_s_once != -1)
      dispatch_once(&_mdns_dns_service_queue_s_once, &__block_literal_global_237);
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 0x40000000;
    v4[2] = __mdns_dns_service_manager_deregister_custom_service_block_invoke;
    v4[3] = &__block_descriptor_tmp_15;
    v4[4] = v3;
    v4[5] = a1;
    dispatch_sync((dispatch_queue_t)_mdns_dns_service_queue_s_queue, v4);
  }
}

void Querier_HandleUnicastQuestion(uint64_t a1)
{
  uint64_t v2;
  void **v3;
  _QWORD *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  _BOOL4 v8;
  const __CFSet *Mutable;
  void *v10;
  NSObject *v11;
  unsigned int v12;
  int v13;
  _UNKNOWN ***v14;
  uint64_t v15;
  void *v16;
  _QWORD *subscriber;
  uint64_t v18;
  NSObject *v19;
  int v20;
  void *v21;
  uint64_t querier;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  uint64_t v30;
  __int128 v31;
  pid_t v32;
  unsigned int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _QWORD v41[5];
  _QWORD aBlock[5];
  _QWORD v43[6];
  BOOL v44;
  uint8_t buf[4];
  unsigned int v46;
  __int16 v47;
  int v48;
  audit_token_t atoken;

  v3 = (void **)(a1 + 96);
  v2 = *(_QWORD *)(a1 + 96);
  if (v2)
  {
    if (*(_UNKNOWN ***)(v2 + 16) == &_mdns_querier_kind)
    {
      v4 = 0;
      v5 = 0;
      v6 = 0;
      *(_BYTE *)(a1 + 648) = !mdns_querier_match(*(_QWORD *)(v2 + 88), (unsigned __int8 *)(a1 + 376), *(unsigned __int16 *)(a1 + 342), *(unsigned __int16 *)(a1 + 344));
      goto LABEL_49;
    }
LABEL_48:
    v4 = 0;
    v5 = 0;
    v6 = 0;
    goto LABEL_49;
  }
  if (!*(_QWORD *)(a1 + 80))
    goto LABEL_48;
  v7 = *(_QWORD *)(a1 + 144);
  if (v7)
    v8 = *(unsigned __int8 *)(v7 + 24) != 0;
  else
    v8 = 0;
  Mutable = (const __CFSet *)_Querier_GetOrphanedQuerierSet_sOrphanedQuerierSet;
  if (_Querier_GetOrphanedQuerierSet_sOrphanedQuerierSet
    || (Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0, (const CFSetCallBacks *)&gMDNSObjectSetCallbacks),
        (_Querier_GetOrphanedQuerierSet_sOrphanedQuerierSet = (uint64_t)Mutable) != 0))
  {
    *(_QWORD *)atoken.val = 0;
    *(_QWORD *)&atoken.val[2] = &atoken;
    *(_QWORD *)&atoken.val[4] = 0x2000000000;
    *(_QWORD *)&atoken.val[6] = 0;
    v43[0] = _NSConcreteStackBlock;
    v43[1] = 0x40000000;
    v43[2] = __Querier_HandleUnicastQuestion_block_invoke;
    v43[3] = &unk_10013C1B0;
    v44 = v8;
    v43[4] = &atoken;
    v43[5] = a1;
    mdns_cfset_enumerate(Mutable, (uint64_t)v43);
    v10 = *(void **)(*(_QWORD *)&atoken.val[2] + 24);
    if (v10)
    {
      mdns_client_replace(v3, v10);
      CFSetRemoveValue(Mutable, *(const void **)(*(_QWORD *)&atoken.val[2] + 24));
      mdns_querier_set_time_limit_ms(*(void **)(*(_QWORD *)&atoken.val[2] + 24), 0);
      v11 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        {
LABEL_16:
          v12 = bswap32(*(unsigned __int16 *)(a1 + 340));
          v13 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)&atoken.val[2] + 24) + 232);
          *(_DWORD *)buf = 67109376;
          v46 = HIWORD(v12);
          v47 = 1024;
          v48 = v13;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "[Q%u->Q%u] Adopted orphaned querier", buf, 0xEu);
        }
      }
      else
      {
        v11 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          goto LABEL_16;
      }
    }
    _Block_object_dispose(&atoken, 8);
  }
  v14 = (_UNKNOWN ***)*v3;
  if (*v3)
  {
    v6 = 0;
    v5 = 0;
    v4 = 0;
    *(_BYTE *)(a1 + 648) = 0;
    goto LABEL_20;
  }
  v15 = *(_QWORD *)(a1 + 80);
  if (*(_BYTE *)(v15 + 281) == 5)
  {
    v16 = *(void **)(v15 + 72);
    if (!v16)
      goto LABEL_48;
    subscriber = mdns_push_server_create_subscriber(v16);
    if (!subscriber)
      goto LABEL_48;
    v18 = (uint64_t)subscriber;
    v19 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
LABEL_72:
        v33 = bswap32(*(unsigned __int16 *)(a1 + 340));
        v34 = *(_QWORD *)(v18 + 120);
        atoken.val[0] = 67109376;
        atoken.val[1] = HIWORD(v33);
        LOWORD(atoken.val[2]) = 2048;
        *(_QWORD *)((char *)&atoken.val[2] + 2) = v34;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "[Q%u->Sub%llu] Created a subscriber for question", (uint8_t *)&atoken, 0x12u);
      }
    }
    else
    {
      v19 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_72;
    }
    v6 = 0;
    v5 = (void *)v18;
    goto LABEL_74;
  }
  v21 = *(void **)(v15 + 64);
  if (!v21)
    goto LABEL_48;
  querier = mdns_resolver_create_querier(v21);
  if (!querier)
    goto LABEL_48;
  v18 = querier;
  if (v8 && !*(_BYTE *)(querier + 49))
  {
    v23 = *(_QWORD *)(querier + 88);
    if ((*(_BYTE *)(v23 + 70) & 0x20) != 0 || (*(_BYTE *)(v23 + 70) |= 4u, !*(_BYTE *)(querier + 49)))
    {
      v24 = *(_QWORD *)(querier + 88);
      if ((*(_BYTE *)(v24 + 70) & 0x20) == 0)
        *(_BYTE *)(v24 + 70) |= 2u;
    }
  }
  v25 = *(void **)(a1 + 128);
  if (v25)
  {
LABEL_44:
    mdns_querier_set_delegator_audit_token(v18, v25);
    goto LABEL_45;
  }
  v29 = *(_DWORD *)(a1 + 244);
  if (v29)
  {
    v30 = *(_QWORD *)(a1 + 120);
    if (v30)
    {
      v31 = *(_OWORD *)(v30 + 40);
      *(_OWORD *)atoken.val = *(_OWORD *)(v30 + 24);
      *(_OWORD *)&atoken.val[4] = v31;
      v32 = audit_token_to_pid(&atoken);
      v29 = *(_DWORD *)(a1 + 244);
    }
    else
    {
      v32 = 0;
    }
    if (v32 != v29)
    {
      if (!*(_BYTE *)(v18 + 49))
      {
        _mdns_querier_clear_delegation(v18);
        *(_DWORD *)(v18 + 184) = 1;
        *(_DWORD *)(v18 + 168) = v29;
      }
      goto LABEL_45;
    }
    v25 = *(void **)(a1 + 120);
    goto LABEL_44;
  }
  mdns_querier_set_delegator_uuid(querier, (const unsigned __int8 *)(a1 + 656));
LABEL_45:
  if (!DNSQuestionNeedsSensitiveLogging(a1) || *(_BYTE *)(v18 + 49))
  {
    v5 = 0;
  }
  else
  {
    v5 = 0;
    *(_BYTE *)(v18 + 255) = 1;
  }
  v6 = v18;
LABEL_74:
  v4 = mdns_domain_name_create_with_labels((_BYTE *)(a1 + 376), 0);
  if (!v4)
    goto LABEL_49;
  if (!*(_BYTE *)(v18 + 49))
    (*(void (**)(uint64_t, _QWORD *, _QWORD, _QWORD))(*(_QWORD *)(v18 + 16) + 56))(v18, v4, *(unsigned __int16 *)(a1 + 342), *(unsigned __int16 *)(a1 + 344));
  os_retain(*(void **)(a1 + 80));
  if (!*(_BYTE *)(v18 + 49))
  {
    *(_QWORD *)(v18 + 32) = *(_QWORD *)(a1 + 80);
    *(_QWORD *)(v18 + 40) = mdns_object_context_finalizer;
  }
  if (_Querier_InternalQueue_sOnce != -1)
    dispatch_once(&_Querier_InternalQueue_sOnce, &__block_literal_global_38);
  mdns_client_set_queue(v18, (dispatch_object_t)_Querier_InternalQueue_sQueue);
  if (v6)
  {
    os_retain((void *)v6);
    aBlock[0] = _NSConcreteStackBlock;
    aBlock[1] = 0x40000000;
    aBlock[2] = __Querier_HandleUnicastQuestion_block_invoke_14;
    aBlock[3] = &__block_descriptor_tmp_16_3212;
    aBlock[4] = v6;
    mdns_querier_set_result_handler(v6, aBlock);
    mdns_querier_set_log_label(v6, "Q%u", v35, v36, v37, v38, v39, v40, bswap32(*(unsigned __int16 *)(a1 + 340)) >> 16);
    if (!*(_BYTE *)(v6 + 49))
      *(_DWORD *)(v6 + 232) = bswap32(*(unsigned __int16 *)(a1 + 340)) >> 16;
  }
  if (v5)
  {
    os_retain(v5);
    v41[0] = _NSConcreteStackBlock;
    v41[1] = 0x40000000;
    v41[2] = __Querier_HandleUnicastQuestion_block_invoke_2;
    v41[3] = &__block_descriptor_tmp_20_3214;
    v41[4] = v5;
    mdns_subscriber_set_event_handler((uint64_t)v5, v41);
  }
  mdns_client_replace(v3, (void *)v18);
  mdns_client_activate(*(_QWORD *)(a1 + 96));
  v14 = *(_UNKNOWN ****)(a1 + 96);
  *(_BYTE *)(a1 + 648) = 0;
  if (!v14)
    goto LABEL_21;
LABEL_20:
  if (v14[2] != &_mdns_querier_kind || !*((_DWORD *)v14[8][2] + 36))
  {
LABEL_21:
    *(_DWORD *)(a1 + 264) = 0;
    goto LABEL_49;
  }
  if (*(_BYTE *)(a1 + 268))
  {
    *(_DWORD *)(a1 + 268) = 0;
    *(_QWORD *)(a1 + 260) = 0;
  }
  else if (*(_DWORD *)(a1 + 264))
  {
    goto LABEL_49;
  }
  v20 = dword_100158E08;
  if (dword_100158E08 <= 1)
    v20 = 1;
  *(_DWORD *)(a1 + 264) = v20;
LABEL_49:
  v26 = *(_QWORD *)(a1 + 184);
  if (!v26 || (v27 = *(_QWORD *)(v26 + 16)) == 0 || !*(_BYTE *)(v27 + 68))
  {
    v28 = 939524096;
    if (*(_QWORD *)(a1 + 80))
    {
      if (*v3)
        v28 = 939524096;
      else
        v28 = 1000;
    }
    *(_DWORD *)(a1 + 212) = v28;
  }
  *(_DWORD *)(a1 + 208) = dword_100158E08;
  SetNextQueryTime((uint64_t)mDNSStorage, a1);
  if (v6)
    os_release((void *)v6);
  if (v5)
    os_release(v5);
  if (v4)
    os_release(v4);
}

const __CFArray *_Querier_ApplyUpdate(_QWORD *a1)
{
  const __CFArray *result;
  uint64_t v3;
  uint64_t v4;
  _QWORD v5[7];

  result = (const __CFArray *)a1[14];
  if (result)
  {
    v3 = a1[4];
    v4 = *(unsigned int *)(a1[7] + 96);
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 0x40000000;
    v5[2] = ___Querier_ApplyUpdate_block_invoke;
    v5[3] = &__block_descriptor_tmp_43_3219;
    v5[4] = v3;
    v5[5] = v4;
    v5[6] = a1;
    return (const __CFArray *)mdns_cfarray_enumerate(result, (uint64_t)v5);
  }
  return result;
}

void _Querier_HandleSubscriberInvalidation(uint64_t a1)
{
  _BYTE *v2;
  unsigned int v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v10;
  _BYTE *v11;
  unsigned __int16 v12;
  uint64_t v13;
  _BYTE *v15;
  unsigned __int16 v16;
  uint64_t v17;
  int v18;
  int v19;
  int v20;
  uint8_t buf[4];
  uint64_t v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  int v26;
  __int16 v27;
  uint64_t v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;

  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"_Querier_HandleSubscriberInvalidation", 1731);
  v2 = *(_BYTE **)((*(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 16) + 80))(a1) + 24);
  v3 = DomainNameHashValue((unint64_t)v2);
  v4 = CacheGroupForName((uint64_t)mDNSStorage, v3, v2);
  if (v4)
  {
    v5 = v4[2];
    if (v5)
    {
      v6 = *(_QWORD *)(a1 + 120);
      while (1)
      {
        if (!*(_BYTE *)(v5 + 109))
          goto LABEL_45;
        v7 = *(_QWORD *)(v5 + 56);
        if (v7)
          v7 = *(_QWORD *)(v7 + 40);
        if (v7 != v6)
          goto LABEL_45;
        v8 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_Default != mDNSLogCategory_State)
          break;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
        {
          v10 = *(_QWORD *)(v5 + 40);
          if (v10)
          {
            v11 = *(_BYTE **)(v5 + 40);
            if (v10 == -256)
              goto LABEL_19;
LABEL_16:
            v12 = 257;
            if ((unint64_t)v11 < v10 + 256 && v11)
            {
              while (1)
              {
                v13 = *v11;
                if (v13 > 0x3F)
                {
LABEL_37:
                  v12 = 257;
                  goto LABEL_40;
                }
                if (!*v11)
                  break;
                v11 += v13 + 1;
                if (v10 != -256)
                  goto LABEL_16;
LABEL_19:
                if (!v11)
                  goto LABEL_37;
              }
              v12 = (_WORD)v11 - v10 + 1;
            }
LABEL_40:
            v18 = v12;
          }
          else
          {
            v18 = 0;
          }
LABEL_43:
          v19 = *(unsigned __int16 *)(v5 + 12);
          v20 = *(_DWORD *)(v5 + 16);
          *(_DWORD *)buf = 134219267;
          v22 = v6;
          v23 = 2160;
          v24 = 1752392040;
          v25 = 1040;
          v26 = v18;
          v27 = 2101;
          v28 = v10;
          v29 = 1024;
          v30 = v19;
          v31 = 1024;
          v32 = v20;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "[Sub%llu] Removing record from the cache due to subscriber invalidation -- name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, type: %{mdns:rrtype}d, TTL: %us", buf, 0x32u);
        }
LABEL_44:
        *(_QWORD *)(*(_QWORD *)(v5 + 56) + 40) = 0;
        *(_BYTE *)(v5 + 109) = 0;
        mDNS_PurgeCacheResourceRecord((unsigned int *)mDNSStorage, v5);
LABEL_45:
        v5 = *(_QWORD *)v5;
        if (!v5)
          goto LABEL_46;
      }
      v8 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
        goto LABEL_44;
      v10 = *(_QWORD *)(v5 + 40);
      if (v10)
      {
        v15 = *(_BYTE **)(v5 + 40);
        if (v10 == -256)
          goto LABEL_30;
LABEL_27:
        v16 = 257;
        if ((unint64_t)v15 < v10 + 256 && v15)
        {
          while (1)
          {
            v17 = *v15;
            if (v17 > 0x3F)
            {
LABEL_38:
              v16 = 257;
              goto LABEL_42;
            }
            if (!*v15)
              break;
            v15 += v17 + 1;
            if (v10 != -256)
              goto LABEL_27;
LABEL_30:
            if (!v15)
              goto LABEL_38;
          }
          v16 = (_WORD)v15 - v10 + 1;
        }
LABEL_42:
        v18 = v16;
      }
      else
      {
        v18 = 0;
      }
      goto LABEL_43;
    }
  }
LABEL_46:
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"_Querier_HandleSubscriberInvalidation", 1755);
}

void _Querier_RemoveRecord(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  size_t v4;
  _BYTE *v9;
  unsigned int v10;
  uint64_t *v11;
  uint64_t v12;
  int v13;
  int v14;
  const void *v15;
  __int16 v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;

  v4 = *(unsigned __int16 *)(a1 + 56);
  if (v4 <= 0x2000)
  {
    v9 = *(_BYTE **)(*(_QWORD *)(a1 + 24) + 24);
    mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"_Querier_RemoveRecord", 1580);
    v10 = DomainNameHashValue((unint64_t)v9);
    v11 = CacheGroupForName((uint64_t)mDNSStorage, v10, v9);
    if (v11)
    {
      v12 = v11[2];
      if (v12)
      {
        v13 = *(unsigned __int16 *)(a1 + 52);
        v14 = *(unsigned __int16 *)(a1 + 54);
        v15 = *(const void **)(a1 + 32);
        v16 = *(_WORD *)(a2 + 276);
        do
        {
          if (*(_QWORD *)(v12 + 32) == a3)
          {
            if ((v16 & 0x4000) != 0)
              goto LABEL_12;
            v17 = *(_QWORD *)(v12 + 56);
            if (v17)
              v17 = *(_QWORD *)(v17 + 24);
            if (v17 == a2)
            {
LABEL_12:
              if (a4)
              {
                if (v14 == 255
                  || *(unsigned __int16 *)(v12 + 14) == v14
                  && ((v22 = *(unsigned __int16 *)(v12 + 12), v22 == 255) || v22 == v13))
                {
                  mDNS_PurgeCacheResourceRecord((unsigned int *)mDNSStorage, v12);
                }
              }
              else if (*(unsigned __int16 *)(v12 + 12) == v13
                     && *(unsigned __int16 *)(v12 + 14) == v14
                     && *(unsigned __int16 *)(v12 + 20) == (_DWORD)v4)
              {
                __memset_chk(_Querier_RemoveRecord_rdataBuf, 0, v4, 0x2000);
                putRData(0, _Querier_RemoveRecord_rdataBuf, (unint64_t)&_Querier_GetMyPID_sOnce, v12 + 8, v18, v19, v20, v21);
                if (!memcmp(_Querier_RemoveRecord_rdataBuf, v15, v4))
                {
                  mDNS_PurgeCacheResourceRecord((unsigned int *)mDNSStorage, v12);
                  break;
                }
              }
            }
          }
          v12 = *(_QWORD *)v12;
        }
        while (v12);
      }
    }
    mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"_Querier_RemoveRecord", 1645);
  }
}

uint64_t Querier_GetDNSQuestion(uint64_t a1, _BYTE *a2)
{
  uint64_t result;
  char v4;
  uint64_t v5;
  char v6;

  result = *(_QWORD *)((char *)&xmmword_100158E84 + 4);
  if (!*(_QWORD *)((char *)&xmmword_100158E84 + 4))
  {
LABEL_8:
    v6 = 0;
    if (!a2)
      return result;
    goto LABEL_9;
  }
  v4 = 0;
  while (1)
  {
    v5 = *(_QWORD *)(result + 96);
    if (!v5 || *(_UNKNOWN ***)(v5 + 16) != &_mdns_querier_kind)
      v5 = 0;
    v4 |= result == *(_QWORD *)((char *)&xmmword_100158E84 + 12);
    if (v5 == a1)
      break;
    result = *(_QWORD *)(result + 8);
    if (!result)
      goto LABEL_8;
  }
  v6 = v4 & 1;
  if (a2)
LABEL_9:
    *a2 = v6;
  return result;
}

void Querier_ProcessDNSServiceChangesAsync()
{
  _QWORD block[4];
  char v1;

  if (_Querier_InternalQueue_sOnce != -1)
    dispatch_once(&_Querier_InternalQueue_sOnce, &__block_literal_global_38);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = __Querier_ProcessDNSServiceChangesAsync_block_invoke;
  block[3] = &__block_descriptor_tmp_22_3232;
  v1 = 1;
  dispatch_async((dispatch_queue_t)_Querier_InternalQueue_sQueue, block);
}

BOOL Client_SameNameCacheRecordIsAnswer(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v13;

  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a2 + 16) + 88))(a2);
  v5 = *(unsigned __int16 *)(a1 + 14);
  if (v5 != (*(unsigned int (**)(uint64_t))(*(_QWORD *)(a2 + 16) + 96))(a2))
    return 0;
  if (*(_UNKNOWN ***)(a2 + 16) == &_mdns_querier_kind)
  {
    v13 = *(unsigned __int8 *)(*(_QWORD *)(a2 + 88) + 70);
    if ((v13 & 4) != 0)
      v11 = (v13 >> 1) & 1;
    else
      v11 = 0;
  }
  else
  {
    v11 = 0;
  }
  return RRTypeAnswersQuestionType(a1 + 8, v4, v11, v6, v7, v8, v9, v10);
}

void _DPCSubscribe(uint64_t a1, void *a2)
{
  void *Value;
  void *v5;
  uint64_t Subscriber;
  CFMutableSetRef v7;
  const __CFDictionary *v8;
  void *v9;
  CFMutableBagRef Mutable;
  const void *v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD aBlock[5];
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;

  v18 = 0;
  v19 = &v18;
  v20 = 0x2000000000;
  v21 = 0;
  if (gDPCPushServers)
  {
    Value = (void *)CFDictionaryGetValue((CFDictionaryRef)gDPCPushServers, a2);
    if (Value)
    {
      v5 = Value;
      Subscriber = _DPCQuestionGetSubscriber(*(const __CFSet **)(a1 + 192), (uint64_t)a2);
      v19[3] = Subscriber;
      if (!Subscriber)
      {
        if (*(_QWORD *)(a1 + 192)
          || (v7 = CFSetCreateMutable(kCFAllocatorDefault, 0, (const CFSetCallBacks *)&gMDNSObjectSetCallbacks),
              (*(_QWORD *)(a1 + 192) = v7) != 0))
        {
          v8 = (const __CFDictionary *)gDPCSubscriberRegistries;
          if (gDPCSubscriberRegistries
            || (v8 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &gInterfaceIDDictionaryKeyCallbacks, &kCFTypeDictionaryValueCallBacks), (gDPCSubscriberRegistries = (uint64_t)v8) != 0))
          {
            v9 = (void *)CFDictionaryGetValue(v8, a2);
            if (!v9)
            {
              Mutable = CFBagCreateMutable(kCFAllocatorDefault, 0, (const CFBagCallBacks *)&gMDNSObjectBagCallbacks);
              if (!Mutable)
                goto LABEL_4;
              v9 = Mutable;
              CFDictionarySetValue((CFMutableDictionaryRef)gDPCSubscriberRegistries, a2, Mutable);
              CFRelease(v9);
            }
            v11 = (const void *)_DPCGetRegisteredSubscriber(a2, a1 + 376, *(_WORD *)(a1 + 342), *(_WORD *)(a1 + 344));
            v19[3] = (uint64_t)v11;
            if (v11)
            {
              v12 = 0;
            }
            else
            {
              v13 = mdns_domain_name_create_with_labels((_BYTE *)(a1 + 376), 0);
              if (!v13)
                goto LABEL_4;
              v12 = v13;
              v14 = mdns_push_server_create_subscriber(v5);
              v19[3] = (uint64_t)v14;
              if (!v14)
                goto LABEL_15;
              v15 = (uint64_t)v14;
              if (!*((_BYTE *)v14 + 49))
              {
                (*(void (**)(_QWORD *, void *, _QWORD, _QWORD))(v14[2] + 56))(v14, v12, *(unsigned __int16 *)(a1 + 342), *(unsigned __int16 *)(a1 + 344));
                v15 = v19[3];
              }
              if (_Querier_InternalQueue_sOnce != -1)
                dispatch_once(&_Querier_InternalQueue_sOnce, &__block_literal_global_38);
              mdns_client_set_queue(v15, (dispatch_object_t)_Querier_InternalQueue_sQueue);
              os_retain((void *)v19[3]);
              v16 = v19[3];
              aBlock[0] = _NSConcreteStackBlock;
              aBlock[1] = 0x40000000;
              aBlock[2] = ___DPCSubscribe_block_invoke;
              aBlock[3] = &unk_10013C490;
              aBlock[4] = &v18;
              mdns_subscriber_set_event_handler(v16, aBlock);
              mdns_client_activate(v19[3]);
              v11 = (const void *)v19[3];
            }
            CFSetAddValue(*(CFMutableSetRef *)(a1 + 192), v11);
            CFBagAddValue((CFMutableBagRef)v9, (const void *)v19[3]);
            if (v12)
LABEL_15:
              os_release(v12);
          }
        }
      }
    }
  }
LABEL_4:
  _Block_object_dispose(&v18, 8);
}

uint64_t _DPCQuestionGetSubscriber(const __CFSet *a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD v4[6];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;

  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  if (a1)
  {
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 0x40000000;
    v4[2] = ___DPCQuestionGetSubscriber_block_invoke;
    v4[3] = &unk_10013C4B8;
    v4[4] = &v5;
    v4[5] = a2;
    mdns_cfset_enumerate(a1, (uint64_t)v4);
    v2 = v6[3];
  }
  else
  {
    v2 = 0;
  }
  _Block_object_dispose(&v5, 8);
  return v2;
}

uint64_t _DPCGetRegisteredSubscriber(void *key, uint64_t a2, __int16 a3, __int16 a4)
{
  const __CFBag *Value;
  uint64_t v8;
  _QWORD v10[6];
  __int16 v11;
  __int16 v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;

  v13 = 0;
  v14 = &v13;
  v15 = 0x2000000000;
  v16 = 0;
  if (gDPCSubscriberRegistries)
  {
    Value = (const __CFBag *)CFDictionaryGetValue((CFDictionaryRef)gDPCSubscriberRegistries, key);
    if (Value)
    {
      v10[0] = _NSConcreteStackBlock;
      v10[1] = 0x40000000;
      v10[2] = ___DPCGetRegisteredSubscriber_block_invoke;
      v10[3] = &unk_10013C510;
      v11 = a3;
      v12 = a4;
      v10[4] = &v13;
      v10[5] = a2;
      mdns_cfbag_enumerate(Value, (uint64_t)v10);
    }
  }
  v8 = v14[3];
  _Block_object_dispose(&v13, 8);
  return v8;
}

void DPCBrowseHandler(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  void *v6;
  _QWORD *v7;
  void *v8;
  _QWORD *v9;
  _BYTE *v10;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  void *v14;

  if (DPCFeatureEnabled_sOnce != -1)
    dispatch_once(&DPCFeatureEnabled_sOnce, &__block_literal_global_3252);
  if (a4 == 1)
  {
    if (DPCFeatureEnabled_sEnabled)
    {
      v6 = *(void **)(a3 + 24);
      if (!gDPCPushServers || !CFDictionaryGetValue((CFDictionaryRef)gDPCPushServers, *(const void **)(a3 + 24)))
      {
        v7 = mdns_domain_name_create_with_labels(*(_BYTE **)(a3 + 32), 0);
        if (v7)
        {
          v8 = v7;
          _DPCRemovePushServer(v6);
          if (gDPCPushServers
            || (gDPCPushServers = (uint64_t)CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &gInterfaceIDDictionaryKeyCallbacks, (const CFDictionaryValueCallBacks *)&gMDNSObjectDictionaryValueCallbacks)) != 0)
          {
            v9 = mdns_push_server_create();
            if (v9)
            {
              v10 = v9;
              mdns_push_server_set_srv_name((uint64_t)v9, v8);
              v10[103] = 1;
              CFDictionarySetValue((CFMutableDictionaryRef)gDPCPushServers, v6, v10);
              v11 = xmmword_100158E88;
              if ((_QWORD)xmmword_100158E88)
              {
                v12 = *((_QWORD *)&xmmword_100158E88 + 1);
                if ((_QWORD)xmmword_100158E88 != *((_QWORD *)&xmmword_100158E88 + 1))
                {
                  do
                  {
                    if (!*(_WORD *)(v11 + 340) && *(int *)(v11 + 212) >= 1 && !*(_QWORD *)(v11 + 40))
                    {
                      v14 = *(void **)(v11 + 136);
                      if (v14 == v6 || v14 == 0)
                      {
                        _DPCSubscribe(v11, v6);
                        v12 = *((_QWORD *)&xmmword_100158E88 + 1);
                      }
                    }
                    v11 = *(_QWORD *)(v11 + 8);
                    if (v11)
                      v13 = v11 == v12;
                    else
                      v13 = 1;
                  }
                  while (!v13);
                }
              }
              os_release(v10);
            }
          }
          os_release(v8);
        }
      }
    }
  }
}

void _DPCRemovePushServer(void *key)
{
  uint64_t v2;
  BOOL v3;
  const void *Subscriber;
  BOOL v5;
  const __CFBag *Value;
  __CFBag *v7;
  _BYTE *v8;

  v2 = xmmword_100158E88;
  if ((_QWORD)xmmword_100158E88)
    v3 = (_QWORD)xmmword_100158E88 == *((_QWORD *)&xmmword_100158E88 + 1);
  else
    v3 = 1;
  if (!v3)
  {
    do
    {
      Subscriber = (const void *)_DPCQuestionGetSubscriber(*(const __CFSet **)(v2 + 192), (uint64_t)key);
      if (Subscriber)
        CFSetRemoveValue(*(CFMutableSetRef *)(v2 + 192), Subscriber);
      v2 = *(_QWORD *)(v2 + 8);
      if (v2)
        v5 = v2 == *((_QWORD *)&xmmword_100158E88 + 1);
      else
        v5 = 1;
    }
    while (!v5);
  }
  if (gDPCSubscriberRegistries)
  {
    Value = (const __CFBag *)CFDictionaryGetValue((CFDictionaryRef)gDPCSubscriberRegistries, key);
    if (Value)
    {
      v7 = Value;
      mdns_cfbag_enumerate(Value, (uint64_t)&__block_literal_global_54);
      CFBagRemoveAllValues(v7);
      CFDictionaryRemoveValue((CFMutableDictionaryRef)gDPCSubscriberRegistries, key);
    }
  }
  if (gDPCPushServers)
  {
    v8 = CFDictionaryGetValue((CFDictionaryRef)gDPCPushServers, key);
    if (v8)
    {
      mdns_push_server_invalidate(v8);
      CFDictionaryRemoveValue((CFMutableDictionaryRef)gDPCPushServers, key);
    }
  }
}

uint64_t _dns_push_obj_dns_question_member_compare()
{
  return 2;
}

void _dns_push_obj_dns_question_member_finalize(uint64_t a1)
{
  _QWORD *v2;

  v2 = *(_QWORD **)(a1 + 16);
  if (v2)
  {
    ref_count_obj_release(v2);
    *(_QWORD *)(a1 + 16) = 0;
  }
}

_BYTE *domain_name_labels_create(_BYTE *a1, int *a2)
{
  int v4;
  _BYTE *v5;
  _BYTE *v6;
  int v7;
  size_t v8;
  _BYTE *v9;
  _BYTE *v10;
  int v11;
  _BYTE *v12;
  unsigned int v13;
  int v14;
  int v15;

  v4 = *a1;
  v5 = a1;
  if (*a1)
  {
    v5 = a1;
    do
    {
      v6 = &v5[v4];
      v7 = v6[1];
      v5 = v6 + 1;
      v4 = v7;
    }
    while (v7);
  }
  v8 = v5 - a1 + 1;
  if (v8 > 0x100)
  {
LABEL_18:
    v10 = 0;
    v15 = -6751;
    if (!a2)
      return v10;
    goto LABEL_15;
  }
  if (v5 - a1 == -1 || (v9 = malloc_type_malloc(v5 - a1 + 1, 0xA172743EuLL)) == 0)
  {
    __break(1u);
    goto LABEL_18;
  }
  v10 = v9;
  memcpy(v9, a1, v8);
  v11 = *v10;
  if (*v10)
  {
    v12 = v10;
    do
    {
      ++v12;
      v13 = v11 + 1;
      do
      {
        v14 = *v12;
        if ((v14 - 65) <= 0x19)
          *v12 = v14 + 32;
        ++v12;
        --v13;
      }
      while (v13 > 1);
      v11 = *v12;
    }
    while (*v12);
  }
  v15 = 0;
  if (a2)
LABEL_15:
    *a2 = v15;
  return v10;
}

_BYTE *domain_name_labels_get_parent(_BYTE *result, unint64_t a2)
{
  int v2;
  unint64_t v3;
  int v4;
  _BYTE *v5;
  _BYTE *v6;
  int v7;
  BOOL v8;
  unint64_t v9;
  _BYTE *v10;
  int v11;
  BOOL v13;
  NSObject *v14;
  int v17;
  const char *v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  uint64_t v26;

  v2 = *result;
  if (*result)
  {
    v3 = 0;
    v4 = *result;
    v5 = result;
    do
    {
      ++v3;
      v6 = &v5[v4];
      v7 = v6[1];
      v5 = v6 + 1;
      v4 = v7;
    }
    while (v7);
  }
  else
  {
    v3 = 0;
  }
  if (v3 < a2)
  {
    v14 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_FAULT))
        return 0;
    }
    else
    {
      v14 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_FAULT))
        return 0;
    }
    v17 = 136447234;
    v18 = "index <= label_count";
    v19 = 2082;
    v20 = "";
    v21 = 2082;
    v22 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSShared/dns_objects/utilities/domain_name_labels.c";
    v23 = 1024;
    v24 = 107;
    v25 = 2048;
    v26 = 0;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", (uint8_t *)&v17, 0x30u);
    return 0;
  }
  if (*result)
    v8 = a2 == 0;
  else
    v8 = 1;
  if (!v8)
  {
    v9 = a2 - 1;
    do
    {
      v10 = &result[v2];
      v11 = v10[1];
      result = v10 + 1;
      v2 = v11;
      v13 = v9-- != 0;
    }
    while (v2 && v13);
  }
  return result;
}

uint64_t domain_name_label_canonical_compare(unsigned __int8 *a1, unsigned __int8 *a2, int a3)
{
  unsigned int v4;
  unsigned int v5;
  uint64_t result;
  uint64_t v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  BOOL v16;
  BOOL v17;
  unsigned int v18;
  _BOOL4 v19;
  unsigned int v20;

  v4 = *a1;
  v5 = *a2;
  if (a3 && v4 != v5)
    return 2;
  if (v4 >= v5)
    v7 = *a2;
  else
    v7 = *a1;
  if ((_DWORD)v7)
  {
    LODWORD(result) = 0;
    v8 = a1 + 1;
    v9 = a2 + 1;
    while (1)
    {
      v11 = *v8++;
      v10 = v11;
      v12 = v11 + 32;
      if (v11 - 65 < 0x1A)
        v10 = v12;
      v14 = *v9++;
      v13 = v14;
      v15 = v14 + 32;
      if (v14 - 65 < 0x1A)
        v13 = v15;
      v16 = v10 >= v13;
      v17 = v10 == v13;
      v18 = v10 > v13 ? 1 : result;
      result = v16 ? v18 : 0xFFFFFFFFLL;
      if (!v17)
        break;
      if (!--v7)
        goto LABEL_22;
    }
  }
  else
  {
LABEL_22:
    v16 = v4 >= v5;
    v19 = v4 != v5;
    v20 = v4 > v5;
    if (!v16)
      v20 = -1;
    if ((v19 & a3) != 0)
      return 2;
    else
      return v20;
  }
  return result;
}

uint64_t domain_name_labels_canonical_compare(unsigned __int8 *a1, unsigned __int8 *a2, int a3)
{
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  int v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  int v9;
  uint64_t v10;
  unint64_t v11;
  int v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  int v15;
  uint64_t result;
  uint64_t v17;
  unint64_t v18;
  unsigned __int8 *v19;
  unsigned __int8 *v20;
  int v21;
  unsigned int v22;
  int v23;
  unsigned int v24;
  uint64_t v25;
  unsigned __int8 **v26;
  unsigned __int8 **v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  uint64_t v33;
  int v34;
  int v35;
  int v36;
  int v37;
  BOOL v38;
  int v39;
  _QWORD v40[256];
  _QWORD v41[256];

  v4 = a2;
  v5 = a1;
  v6 = *a1;
  v7 = a1;
  if (*a1)
  {
    v7 = a1;
    do
    {
      v8 = &v7[v6];
      v9 = v8[1];
      v7 = v8 + 1;
      v6 = v9;
    }
    while (v9);
  }
  v10 = v7 - a1;
  v11 = v10 + 1;
  v12 = *a2;
  v13 = a2;
  if (*a2)
  {
    v13 = a2;
    do
    {
      v14 = &v13[v12];
      v15 = v14[1];
      v13 = v14 + 1;
      v12 = v15;
    }
    while (v15);
  }
  LODWORD(result) = 3;
  if (v11 > 0x100)
    goto LABEL_42;
  v17 = v13 - a2;
  v18 = v13 - a2 + 1;
  if (v18 > 0x100)
    goto LABEL_42;
  if (v10 != v17 && (a3 & 1) != 0)
    goto LABEL_11;
  v19 = &v5[v11];
  v20 = &a2[v18];
  bzero(v41, 0x800uLL);
  bzero(v40, 0x800uLL);
  if (v19 <= v5)
  {
    v22 = 0;
  }
  else
  {
    v21 = 0;
    do
    {
      v41[v21] = v5;
      v22 = v21 + 1;
      v5 += *v5 + 1;
      ++v21;
    }
    while (v5 < v19);
  }
  if (v20 <= v4)
  {
    v24 = 0;
    if ((a3 & 1) == 0)
      goto LABEL_28;
LABEL_23:
    if (v22 != v24)
    {
LABEL_11:
      LODWORD(result) = 2;
      goto LABEL_42;
    }
    if (v22)
    {
      v25 = v22;
      v26 = (unsigned __int8 **)v40;
      v27 = (unsigned __int8 **)v41;
      while (**v27 == **v26)
      {
        ++v26;
        ++v27;
        if (!--v25)
          goto LABEL_28;
      }
      goto LABEL_11;
    }
    goto LABEL_28;
  }
  v23 = 0;
  do
  {
    v40[v23] = v4;
    v24 = v23 + 1;
    v4 += *v4 + 1;
    ++v23;
  }
  while (v4 < v20);
  if ((a3 & 1) != 0)
    goto LABEL_23;
LABEL_28:
  v28 = 0;
  v29 = v22;
  v30 = v24;
  v31 = &v40[v24 - 1];
  v32 = &v41[v22 - 1];
  while (1)
  {
    v33 = v30 + v28;
    v34 = v29 + v28;
    if (!(v29 + v28) || !v33)
      break;
    LODWORD(result) = domain_name_label_canonical_compare((unsigned __int8 *)v32[v28], (unsigned __int8 *)v31[v28], a3);
    --v28;
    if ((_DWORD)result)
      goto LABEL_42;
  }
  v35 = v34 | v33;
  if ((_DWORD)v33)
    v36 = 3;
  else
    v36 = 1;
  if (v34)
    v37 = v36;
  else
    v37 = -1;
  if (v35)
    LODWORD(result) = v37;
  else
    LODWORD(result) = 0;
LABEL_42:
  if ((_DWORD)result)
    v38 = (_DWORD)result == 3;
  else
    v38 = 1;
  v39 = !v38;
  if ((v39 & a3) != 0)
    return 2;
  else
    return result;
}

uint64_t domain_name_labels_compute_hash(_BYTE *a1)
{
  int v1;
  _BYTE *v2;
  _BYTE *v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  int v10;

  v1 = *a1;
  v2 = a1;
  if (*a1)
  {
    v2 = a1;
    do
    {
      v3 = &v2[v1];
      v4 = v3[1];
      v2 = v3 + 1;
      v1 = v4;
    }
    while (v4);
  }
  v5 = 2166136261;
  v6 = v2 - a1;
  if (v6 != -1)
  {
    v7 = v6 + 1;
    do
    {
      v9 = *a1++;
      v8 = v9;
      v10 = v9 + 32;
      if ((v9 - 65) < 0x1A)
        v8 = v10;
      v5 = 16777619 * (v5 ^ v8);
      --v7;
    }
    while (v7);
  }
  return v5;
}

_BYTE *domain_name_labels_concatenate(_BYTE *__src, _BYTE *a2, char *__dst, int *a4)
{
  int v7;
  _BYTE *v8;
  _BYTE *v9;
  int v10;
  uint64_t v11;
  int v12;
  _BYTE *v13;
  _BYTE *v14;
  int v15;
  size_t v16;
  uint64_t v17;
  int v18;

  v7 = *__src;
  v8 = __src;
  if (*__src)
  {
    v8 = __src;
    do
    {
      v9 = &v8[v7];
      v10 = v9[1];
      v8 = v9 + 1;
      v7 = v10;
    }
    while (v10);
  }
  v11 = v8 - __src;
  v12 = *a2;
  v13 = a2;
  if (*a2)
  {
    v13 = a2;
    do
    {
      v14 = &v13[v12];
      v15 = v14[1];
      v13 = v14 + 1;
      v12 = v15;
    }
    while (v15);
  }
  v16 = v13 - a2 + 1;
  if (v16 + v11 > 0x100)
  {
    v18 = -6751;
    if (!a4)
      return __src;
  }
  else
  {
    v17 = v11 + 1;
    memcpy(__dst, __src, v11 + 1);
    __src = memcpy(&__dst[v17 - 1], a2, v16);
    v18 = 0;
    if (!a4)
      return __src;
  }
  *a4 = v18;
  return __src;
}

uint64_t IsEntitled(uint64_t a1)
{
  void *v1;
  void *v2;
  uint64_t result;
  NSObject *v4;
  uint8_t *v6;
  NSObject *v8;
  _BOOL4 v10;
  uint8_t *v11;
  _BOOL4 v12;
  _BOOL4 v13;
  __int16 v14;
  __int16 v15;
  uint8_t buf[2];
  __int16 v17;

  v1 = (void *)xpc_connection_copy_entitlement_value(a1, "com.apple.mDNSResponder.log_utility");
  if (v1)
  {
    v2 = v1;
    if (xpc_get_type(v1) == (xpc_type_t)&_xpc_type_BOOL && xpc_BOOL_get_value(v2))
    {
      xpc_release(v2);
      return 1;
    }
    xpc_release(v2);
  }
  else
  {
    v4 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
        goto LABEL_16;
      v17 = 0;
      v6 = (uint8_t *)&v17;
    }
    else
    {
      v4 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_16;
      *(_WORD *)buf = 0;
      v6 = buf;
    }
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "IsEntitled: Client Entitlement is NULL", v6, 2u);
  }
LABEL_16:
  v8 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    v10 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v10)
      return result;
    v15 = 0;
    v11 = (uint8_t *)&v15;
    goto LABEL_25;
  }
  v8 = mDNSLogCategory_Default_redacted;
  v12 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT);
  v13 = v12;
  result = 0;
  if (v13)
  {
    v14 = 0;
    v11 = (uint8_t *)&v14;
LABEL_25:
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "IsEntitled: Client is missing Entitlement!", v11, 2u);
    return 0;
  }
  return result;
}

unsigned __int8 *base_x_encode(int a1, unsigned __int8 *a2, unint64_t a3, char *a4)
{
  unsigned __int8 *result;
  unsigned __int8 *v9;
  unsigned __int8 *i;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  int v16;
  char v17;
  int v18;

  result = (unsigned __int8 *)base_x_get_encoded_string_length(a1, a3);
  v9 = result;
  if (!a4)
  {
    result = (unsigned __int8 *)malloc_type_malloc((size_t)(result + 1), 0xA172743EuLL);
    a4 = (char *)result;
    if (!result)
    {
      __break(1u);
      return result;
    }
  }
  v9[(_QWORD)a4] = 0;
  switch(a1)
  {
    case 2:
      v17 = 1;
      return base_32_hex_encode(a2, a3, v17, a4);
    case 1:
      v17 = 0;
      return base_32_hex_encode(a2, a3, v17, a4);
    case 0:
      for (i = &a2[a3]; a2 < i; a4 += 4)
      {
        v18 = 0;
        v11 = i - a2;
        if (i - a2 == 1)
        {
          v15 = 0;
          v13 = *a2 << 16;
          v14 = 1;
        }
        else
        {
          if (v11 == 2)
          {
            v12 = a2[1] << 8;
            v13 = v12 | (*a2 << 16);
            v14 = 2;
            v15 = 3;
          }
          else
          {
            v16 = a2[2];
            v12 = v16 | (a2[1] << 8);
            v13 = v12 | (*a2 << 16);
            if (v11 >= 3)
              v14 = 3;
            else
              v14 = i - a2;
            HIBYTE(v18) = b64_table[v16 & 0x3F];
            v15 = 4;
          }
          BYTE2(v18) = b64_table[(v12 >> 6) & 0x3F];
        }
        BYTE1(v18) = b64_table[(v13 >> 12) & 0x3F];
        LOBYTE(v18) = b64_table[(unint64_t)v13 >> 18];
        if (v15)
        {
          if (v15 > 3)
            goto LABEL_21;
        }
        else
        {
          v15 = 2;
        }
        result = (unsigned __int8 *)memset((char *)&v18 + v15, 61, 4 - v15);
LABEL_21:
        a2 += v14;
        *(_DWORD *)a4 = v18;
      }
      break;
  }
  return result;
}

unint64_t base_x_get_encoded_string_length(int a1, unint64_t a2)
{
  unint64_t result;

  if (a1 != 2)
  {
    if (a1 == 1)
    {
      if (a2 <= 0x1FFFFFFFFFFFFFFELL)
        return (2 * (((a2 + 4) * (unsigned __int128)0xCCCCCCCCCCCCCCCDLL) >> 64)) & 0xFFFFFFFFFFFFFFF8;
    }
    else if (!a1 && a2 <= 0x3FFFFFFFFFFFFFFELL)
    {
      return (2 * (((a2 + 2) * (unsigned __int128)0xAAAAAAAAAAAAAAABLL) >> 64)) & 0xFFFFFFFFFFFFFFFCLL;
    }
    return 0;
  }
  if (a2 > 0x1FFFFFFFFFFFFFFELL)
    return 0;
  result = 8 * (a2 / 5);
  switch(a2 % 5)
  {
    case 0uLL:
      return result;
    case 1uLL:
      result |= 2uLL;
      break;
    case 2uLL:
      result |= 4uLL;
      break;
    case 3uLL:
      result |= 5uLL;
      break;
    case 4uLL:
      result |= 7uLL;
      break;
    default:
      return 0;
  }
  return result;
}

unsigned __int8 *base_32_hex_encode(unsigned __int8 *result, uint64_t a2, char a3, char *__dst)
{
  unsigned __int8 *v4;
  unsigned __int8 *v7;
  unint64_t v8;
  uint64_t v9;
  size_t v10;
  unsigned int v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unsigned __int8 v19;
  unsigned int v20;
  char v21;
  uint64_t v22;

  v4 = &result[a2];
  if (&result[a2] > result)
  {
    v7 = result;
    while (2)
    {
      v22 = 0;
      v8 = v4 - v7;
      v9 = 0;
      switch(v4 - v7)
      {
        case 1:
          v10 = 0;
          v11 = *v7++;
          v12 = (unint64_t)v11 << 32;
          goto LABEL_20;
        case 2:
          v17 = 0;
          v15 = (unint64_t)v7[1] << 24;
          v18 = *v7;
          v7 += 2;
          v12 = v15 | ((unint64_t)v18 << 32);
          goto LABEL_17;
        case 3:
          v19 = v7[2];
          v15 = ((unint64_t)v19 << 16) | ((unint64_t)v7[1] << 24);
          v20 = *v7;
          v7 += 3;
          v12 = v15 | ((unint64_t)v20 << 32);
          BYTE4(v22) = b32_hex_table[2 * (v19 & 0xF)];
          v17 = 5;
          goto LABEL_17;
        case 4:
          goto LABEL_6;
        default:
          v9 = v7[4];
LABEL_6:
          v13 = v7[3];
          v14 = v9 | (v13 << 8);
          v15 = ((unint64_t)v7[1] << 24) | ((unint64_t)v7[2] << 16) | v14;
          v12 = v15 | ((unint64_t)*v7 << 32);
          if (v8 >= 5)
            v16 = 5;
          else
            v16 = v4 - v7;
          v7 += v16;
          if (v8 == 1)
          {
            v10 = 0;
          }
          else
          {
            if (v8 == 4)
            {
              v17 = 7;
            }
            else
            {
              HIBYTE(v22) = b32_hex_table[v9 & 0x1F];
              v17 = 8;
            }
            v21 = b32_hex_table[(v13 >> 2) & 0x1F];
            BYTE6(v22) = b32_hex_table[(v14 >> 5) & 0x1F];
            BYTE5(v22) = v21;
            BYTE4(v22) = b32_hex_table[(v15 >> 15) & 0x1F];
LABEL_17:
            BYTE3(v22) = b32_hex_table[(v15 >> 20) & 0x1F];
            BYTE2(v22) = b32_hex_table[(v15 >> 25) & 0x1F];
            if (v17)
              v10 = v17;
            else
              v10 = 4;
          }
LABEL_20:
          BYTE1(v22) = b32_hex_table[(v12 >> 30) & 0x1F];
          LOBYTE(v22) = b32_hex_table[v12 >> 35];
          if (!v10)
          {
            v10 = 2;
            if ((a3 & 1) != 0)
              goto LABEL_27;
LABEL_25:
            memset((char *)&v22 + v10, 61, 8 - v10);
            goto LABEL_26;
          }
          if ((a3 & 1) != 0)
            goto LABEL_27;
          if (v10 <= 7)
            goto LABEL_25;
LABEL_26:
          v10 = 8;
LABEL_27:
          result = (unsigned __int8 *)memcpy(__dst, &v22, v10);
          __dst += v10;
          if (v7 >= v4)
            return result;
          continue;
      }
    }
  }
  return result;
}

uint64_t get_tlv_uint32(unsigned __int8 *a1, uint64_t a2, int a3, int *a4)
{
  unsigned __int16 *v4;
  uint64_t result;
  int v6;
  unsigned __int8 *v7;
  uint64_t v8;

  do
  {
    if (a2 - (uint64_t)a1 < 4)
      goto LABEL_9;
    v4 = (unsigned __int16 *)a1;
    result = 0;
    v6 = -1;
    v7 = (unsigned __int8 *)(v4 + 2);
    if (v4 == (unsigned __int16 *)-4)
      goto LABEL_10;
    v8 = __rev16(v4[1]);
    if (a2 - (uint64_t)v7 < v8)
      goto LABEL_10;
    a1 = &v7[v8];
  }
  while (a3 != bswap32(*v4) >> 16);
  switch((_DWORD)v8)
  {
    case 4:
      v6 = 0;
      result = bswap32(*((_DWORD *)v4 + 1));
      break;
    case 2:
      v6 = 0;
      result = __rev16(v4[2]);
      break;
    case 1:
      v6 = 0;
      result = *v7;
      break;
    default:
LABEL_9:
      result = 0;
      v6 = -1;
      break;
  }
LABEL_10:
  if (a4)
    *a4 = v6;
  return result;
}

uint64_t _dns_push_obj_context_compare(uint64_t a1, uint64_t a2)
{
  return 2 * (a1 != a2);
}

void _dns_push_obj_context_finalize(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;
  uint64_t DNSServiceManager;

  v2 = (_QWORD *)a1[2];
  if (v2)
  {
    ref_count_obj_release(v2);
    a1[2] = 0;
  }
  v3 = (_QWORD *)a1[3];
  if (v3)
  {
    ref_count_obj_release(v3);
    a1[3] = 0;
  }
  v4 = (void *)a1[7];
  if (v4)
  {
    os_release(v4);
    a1[7] = 0;
  }
  if (a1[4])
  {
    DNSServiceManager = Querier_GetDNSServiceManager();
    if (DNSServiceManager)
      mdns_dns_service_manager_deregister_discovered_push_service(DNSServiceManager, a1[4]);
  }
}

void dns_push_obj_context_set_interface_monitor(uint64_t a1, void *object)
{
  void *v4;

  if (object)
    os_retain(object);
  v4 = *(void **)(a1 + 56);
  if (v4)
    os_release(v4);
  *(_QWORD *)(a1 + 56) = object;
}

void __mdns_mach_ticks_per_second_block_invoke(id a1)
{
  unint64_t v1;
  kern_return_t v2;
  BOOL v3;
  NSObject *v4;
  mach_timebase_info info;
  uint8_t buf[4];
  kern_return_t v7;
  __int16 v8;
  uint32_t numer;
  __int16 v10;
  uint32_t denom;

  v1 = 1000000000;
  info = 0;
  v2 = mach_timebase_info(&info);
  if (v2 || (info.numer ? (v3 = info.denom == 0) : (v3 = 1), v3))
  {
    if (_mdns_ticks_log_s_once != -1)
      dispatch_once(&_mdns_ticks_log_s_once, &__block_literal_global_2);
    v4 = _mdns_ticks_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_ticks_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109632;
      v7 = v2;
      v8 = 1024;
      numer = info.numer;
      v10 = 1024;
      denom = info.denom;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Unexpected results from mach_timebase_info: err %d numer %u denom %u", buf, 0x14u);
    }
  }
  else
  {
    v1 = 1000000000 * (unint64_t)info.denom / info.numer;
  }
  mdns_mach_ticks_per_second_s_ticks_per_second = v1;
}

void ___mdns_ticks_log_block_invoke(id a1)
{
  _mdns_ticks_log_s_log = (uint64_t)os_log_create("com.apple.mdns", "ticks");
}

unint64_t mdns_ticks_to_milliseconds(unint64_t a1)
{
  if (mdns_mach_ticks_per_second_s_once != -1)
    dispatch_once(&mdns_mach_ticks_per_second_s_once, &__block_literal_global_3428);
  return 1000 * (a1 % mdns_mach_ticks_per_second_s_ticks_per_second) / mdns_mach_ticks_per_second_s_ticks_per_second
       + 1000 * (a1 / mdns_mach_ticks_per_second_s_ticks_per_second);
}

uint64_t getLocalTimestampFromTimeval(uint64_t a1, char *a2)
{
  char v5[4];
  __int16 v6;
  tm v7;
  char v8[8];
  uint64_t v9;
  int v10;

  memset(&v7, 0, sizeof(v7));
  *(_QWORD *)v8 = 0;
  v9 = 0;
  v10 = 0;
  v6 = 0;
  *(_DWORD *)v5 = 0;
  localtime_r((const time_t *)a1, &v7);
  strftime(v8, 0x14uLL, "%F %T", &v7);
  strftime(v5, 6uLL, "%z", &v7);
  return snprintf(a2, 0x20uLL, "%s.%03u%s", v8, *(_DWORD *)(a1 + 8) / 1000, v5);
}

void EnumerateLocalRecords(uint64_t a1)
{
  __CFSet *Mutable;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t **v18;
  BOOL v19;
  _QWORD *v20;
  void *v21;
  uint64_t i;
  uint64_t v23;
  unsigned __int8 *v24;
  _QWORD *v25;
  _QWORD *v26;
  int v27;
  uint64_t *v28;
  int v29;
  _DWORD *v30;
  int v31;
  int v32;
  _DWORD *v33;
  uint64_t v34;
  BOOL v35;
  BOOL v36;
  int v38;
  uint64_t v39;
  _QWORD v40[3];
  int v41;

  Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0, (const CFSetCallBacks *)&mdns_domain_name_cf_set_callbacks);
  v3 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v3, v4, v5, v6, v7, v8, v9, v10);
  v18 = (uint64_t **)xmmword_10015BF10;
  if (Mutable)
    v19 = (_QWORD)xmmword_10015BF10 == 0;
  else
    v19 = 1;
  if (!v19)
  {
    do
    {
      if (IsSubdomain((unsigned __int8 *)v18[5], "\x05local")
        && (((_BYTE)v18[1] & 0x32) != 0
         || IsSubdomain((unsigned __int8 *)v18[5], "\f_device-info\x04_tcp\x05local")))
      {
        v20 = mdns_domain_name_create_with_labels(v18[5], 0);
        if (v20)
        {
          v21 = v20;
          CFSetAddValue(Mutable, v20);
          os_release(v21);
        }
      }
      v18 = (uint64_t **)*v18;
    }
    while (v18);
  }
  for (i = 0; i != 499; ++i)
  {
    v23 = mDNSStorage[i + 34];
    if (!v23)
      continue;
    do
    {
      v24 = *(unsigned __int8 **)(v23 + 32);
      if (!v24)
        goto LABEL_71;
      if (!IsSubdomain(v24, "\x05local"))
        goto LABEL_71;
      v25 = mdns_domain_name_create_with_labels(*(_BYTE **)(v23 + 32), 0);
      if (!v25)
        goto LABEL_71;
      v26 = v25;
      if (Mutable && CFSetContainsValue(Mutable, v25))
        goto LABEL_70;
      v27 = IsSubdomain(*(unsigned __int8 **)(v23 + 32), "\f_device-info\x04_tcp\x05local");
      v28 = *(uint64_t **)(v23 + 16);
      if (!v28)
        goto LABEL_70;
      LOBYTE(v29) = 0;
      v30 = 0;
      v31 = 0;
      do
      {
        v32 = *((unsigned __int16 *)v28 + 6);
        if (v32 == 47)
          goto LABEL_56;
        v33 = (_DWORD *)v28 + 33;
        if (v27)
        {
          if (v32 == 16)
          {
            v34 = (uint64_t)(v28 + 1);
            if (*((unsigned __int8 *)v28 + 8) != 240)
              goto LABEL_61;
          }
        }
        if (!v30)
        {
          if (*v33 == 6)
          {
            if (*((unsigned __int8 *)v28 + 136) == 254)
            {
              v35 = (*((_BYTE *)v28 + 137) & 0xC0) == 128;
LABEL_38:
              v29 = v35;
              goto LABEL_54;
            }
          }
          else
          {
            if (*v33 != 4)
              goto LABEL_43;
            if (*((unsigned __int8 *)v28 + 136) == 169)
            {
              v35 = *((unsigned __int8 *)v28 + 137) == 254;
              goto LABEL_38;
            }
          }
          goto LABEL_53;
        }
        if ((_BYTE)v29)
        {
          if (*v33 == 6)
          {
            if (*((unsigned __int8 *)v28 + 136) == 254 && (*((_BYTE *)v28 + 137) & 0xC0) == 0x80)
            {
LABEL_43:
              if ((_BYTE)v29)
                v36 = 1;
              else
                v36 = v30 == 0;
              if (!v36 && v27 == 0)
                LOBYTE(v29) = 0;
              v31 = 1;
              goto LABEL_56;
            }
          }
          else if (*v33 == 4 && *((unsigned __int8 *)v28 + 136) == 169 && *((unsigned __int8 *)v28 + 137) == 254)
          {
            goto LABEL_43;
          }
LABEL_53:
          v29 = 0;
          goto LABEL_54;
        }
        v29 = 0;
        v33 = v30;
LABEL_54:
        if (!(v27 | v29))
        {
          v34 = 0;
LABEL_61:
          memset(v40, 0, sizeof(v40));
          v41 = 0;
          v30 = v33;
          goto LABEL_62;
        }
        v31 = 1;
        v30 = v33;
LABEL_56:
        v28 = (uint64_t *)*v28;
      }
      while (v28);
      if (!v31)
        goto LABEL_70;
      v34 = 0;
      memset(v40, 0, sizeof(v40));
      v41 = 0;
      if (!v30)
        goto LABEL_68;
LABEL_62:
      if (*v30 == 6)
      {
        memset((char *)v40 + 4, 0, 20);
        LODWORD(v40[0]) = 7708;
        v41 = 0;
        *(_OWORD *)&v40[1] = *(_OWORD *)(v30 + 1);
        if (v34)
        {
LABEL_66:
          v39 = *(unsigned __int16 *)(v34 + 12);
          v34 = *(_QWORD *)(v34 + 40) + 4;
          goto LABEL_69;
        }
      }
      else
      {
        if (*v30 == 4)
        {
          v38 = v30[1];
          v40[1] = 0;
          LODWORD(v40[0]) = 528;
          HIDWORD(v40[0]) = v38;
        }
        if (v34)
          goto LABEL_66;
      }
LABEL_68:
      v39 = 0;
LABEL_69:
      (*(void (**)(uint64_t, _QWORD, uint64_t, uint64_t, _QWORD *))(a1 + 16))(a1, v26[5], v34, v39, v40);
LABEL_70:
      os_release(v26);
LABEL_71:
      v23 = *(_QWORD *)v23;
    }
    while (v23);
  }
  KQueueUnlock((uint64_t)"enumerate .local records", v11, v12, v13, v14, v15, v16, v17);
  if (Mutable)
    CFRelease(Mutable);
}

void FlushRecordCache(unsigned __int8 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t i;
  _QWORD *j;
  _BYTE *v18;
  _QWORD *k;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _OWORD v27[16];

  memset(v27, 0, sizeof(v27));
  AppendDNSNameString(v27, a1, a3, a4, a5, a6, a7, a8);
  v8 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v8, v9, v10, v11, v12, v13, v14, v15);
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"FlushRecordCache", 9341);
  for (i = 0; i != 499; ++i)
  {
    for (j = (_QWORD *)mDNSStorage[i + 34]; j; j = (_QWORD *)*j)
    {
      v18 = (_BYTE *)j[4];
      if (v18)
      {
        if (SameDomainNameBytes(v18, v27))
        {
          for (k = (_QWORD *)j[2]; k; k = (_QWORD *)*k)
            mDNS_PurgeCacheResourceRecord((unsigned int *)mDNSStorage, (uint64_t)k);
        }
      }
    }
  }
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"FlushRecordCache", 9352);
  KQueueUnlock((uint64_t)"FlushRecordCache", v20, v21, v22, v23, v24, v25, v26);
}

void NotifyOfElusiveBug(int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v8 = *(_QWORD *)mDNSStorage;
  if (*(_QWORD *)mDNSStorage)
  {
    while (*(_DWORD *)(v8 + 3560) != 4 || *(_BYTE *)(v8 + 3564) != 17)
    {
      v8 = *(_QWORD *)(v8 + 3680);
      if (!v8)
        return;
    }
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "NotifyOfElusiveBug: %s", a4, a5, a6, a7, a8, a1);
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "NotifyOfElusiveBug: %s", v10, v11, v12, v13, v14, a2);
    if (mDNSPlatformRawTime() <= 0x2BF1F)
    {
      v15 = mDNSLogCategory_Default;
      v16 = mDNSPlatformRawTime();
      LogMsgWithLevel(v15, OS_LOG_TYPE_DEFAULT, "Suppressing notification early in boot: %d", v17, v18, v19, v20, v21, v16);
    }
  }
}

void LogFatalError(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _OWORD __b[32];

  memset(__b, 0, sizeof(__b));
  mDNS_vsnprintf((char *)__b, 512, a1, &a9);
  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "!!!! %s !!!!", v9, v10, v11, v12, v13, (int)__b);
}

void __mDNSDynamicStoreSetConfig_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __CFWriteStream *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __CFWriteStream *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const __CFData *v22;
  const UInt8 *BytePtr;
  int v24;
  const char *v25;
  CFIndex Length;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  CFIndex v33;
  int v34;
  const __CFString *Copy;
  NSObject *v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  const char *v45;
  CFMutableStringRef Mutable;
  const __CFData *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  const __CFData *v53;
  CFPropertyListRef v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  const void *v60;
  const __CFData *v61;
  int v62;
  const void *v63;
  void *v64;
  int v65;

  v2 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v2, v3, v4, v5, v6, v7, v8, v9);
  v10 = CFWriteStreamCreateWithAllocatedBuffers(0, 0);
  v16 = v10;
  if (!v10)
  {
    v36 = mDNSLogCategory_Default;
    v37 = "mDNSDynamicStoreSetConfig : CFWriteStreamCreateWithAllocatedBuffers failed (Object creation failed)";
LABEL_8:
    LogMsgWithLevel(v36, OS_LOG_TYPE_DEFAULT, v37, v11, v12, v13, v14, v15, v65);
    v22 = 0;
    goto LABEL_32;
  }
  CFWriteStreamOpen(v10);
  if (!CFPropertyListWrite(*(CFPropertyListRef *)(a1 + 32), v16, kCFPropertyListBinaryFormat_v1_0, 0, 0))
  {
    v36 = mDNSLogCategory_Default;
    v37 = "mDNSDynamicStoreSetConfig : CFPropertyListWriteToStream failed (Could not write property list to stream)";
    goto LABEL_8;
  }
  v22 = (const __CFData *)CFWriteStreamCopyProperty(v16, kCFStreamPropertyDataWritten);
  if (v22)
  {
    CFWriteStreamClose(v16);
    CFRelease(v16);
    BytePtr = CFDataGetBytePtr(v22);
    v24 = *(_DWORD *)(a1 + 48);
    v25 = *(const char **)(a1 + 40);
    Length = CFDataGetLength(v22);
    v32 = v24 - 1;
    v33 = Length;
    v34 = 0;
    Copy = CFSTR("State:/Network/MulticastDNS");
    switch(v32)
    {
      case 0:
        goto LABEL_20;
      case 1:
        v34 = 0;
        Copy = CFSTR("State:/Network/DynamicDNS");
        goto LABEL_20;
      case 2:
        v34 = 0;
        Copy = CFSTR("State:/Network/PrivateDNS");
        goto LABEL_20;
      case 3:
        v34 = 0;
        Copy = CFSTR("State:/Network/BackToMyMac");
        goto LABEL_20;
      case 4:
        if (v25)
          v45 = v25;
        else
          v45 = "";
        Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
        CFStringAppend(Mutable, CFSTR("State:/Network/Interface/"));
        CFStringAppendCString(Mutable, v45, 0x8000100u);
        CFStringAppend(Mutable, CFSTR("/SleepProxyServers"));
        Copy = CFStringCreateCopy(kCFAllocatorDefault, Mutable);
        if (Mutable)
          CFRelease(Mutable);
        v34 = 1;
        goto LABEL_20;
      case 5:
        v34 = 0;
        Copy = CFSTR("State:/Network/mDNSResponder/DebugState");
LABEL_20:
        v47 = CFDataCreateWithBytesNoCopy(0, BytePtr, v33, kCFAllocatorNull);
        if (v47)
        {
          v53 = v47;
          v54 = CFPropertyListCreateWithData(0, v47, 0, 0, 0);
          if (v54)
          {
            v60 = v54;
            CFRelease(v53);
            SCDynamicStoreSetValue(0, Copy, v60);
            v61 = (const __CFData *)v60;
          }
          else
          {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "CFPropertyListCreateWithData of bytes failed", v55, v56, v57, v58, v59, v65);
            v61 = v53;
          }
          CFRelease(v61);
        }
        else
        {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "CFDataCreateWithBytesNoCopy of value failed", v48, v49, v50, v51, v52, v65);
        }
        if (Copy)
          v62 = v34;
        else
          v62 = 0;
        if (v62 == 1)
          CFRelease(Copy);
        break;
      default:
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "unrecognized key %d", v27, v28, v29, v30, v31, (int)CFSTR("State:/Network/MulticastDNS"));
        break;
    }
    v16 = 0;
  }
  else
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSDynamicStoreSetConfig : CFWriteStreamCopyProperty failed (Object creation failed) ", v17, v18, v19, v20, v21, v65);
  }
LABEL_32:
  v63 = *(const void **)(a1 + 32);
  if (v63)
    CFRelease(v63);
  if (v16)
  {
    CFWriteStreamClose(v16);
    CFRelease(v16);
  }
  if (v22)
    CFRelease(v22);
  v64 = *(void **)(a1 + 40);
  if (v64)
    free(v64);
  KQueueUnlock((uint64_t)"mDNSDynamicStoreSetConfig", v38, v39, v40, v41, v42, v43, v44);
}

void SetNetworkChanged(int a1)
{
  int v2;
  int v3;
  int v4;
  BOOL v5;
  uint64_t v6;
  const char *v7;
  NSObject *v8;
  uint32_t v9;
  uint64_t v10;
  int v11;
  int v12;
  __int16 v13;
  int v14;

  mDNS_VerifyLockState("Check Lock", 1, dword_100158DF8, dword_100158DFC, (uint64_t)"SetNetworkChanged", 6309);
  v2 = dword_100158DD0;
  v3 = dword_100158E08;
  v4 = dword_100158E08 + a1;
  if ((dword_100158E08 + a1) <= 1)
    v4 = 1;
  if (dword_100158DD0)
    v5 = dword_100158DD0 - v4 < 1;
  else
    v5 = 0;
  if (v5)
  {
    v10 = mDNSLogCategory_State;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
      return;
    v11 = 67109376;
    v12 = v2 - v3;
    v13 = 1024;
    v14 = a1;
    v7 = "SetNetworkChanged: *NOT* increasing delay from %d to %d";
    v8 = v10;
    v9 = 14;
  }
  else
  {
    dword_100158DD0 = v4;
    v6 = mDNSLogCategory_State;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
      return;
    v11 = 67109120;
    v12 = a1;
    v7 = "SetNetworkChanged: Scheduling in %d ticks";
    v8 = v6;
    v9 = 8;
  }
  _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)&v11, v9);
}

uint64_t CountProxyTargets(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t *v10;
  int v12;
  uint64_t *v13;
  int v14;

  v10 = (uint64_t *)xmmword_10015BF10;
  if ((_QWORD)xmmword_10015BF10)
  {
    v12 = 0;
    do
    {
      if (v10[4] == *(_QWORD *)(a1 + 3552) && *((_DWORD *)v10 + 36) == 4)
      {
        if (a2 && mDNS_LoggingEnabled)
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "CountProxyTargets: fd %d %-7s IP%2d %.4a", a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 3732));
        ++v12;
      }
      v10 = (uint64_t *)*v10;
    }
    while (v10);
    v13 = (uint64_t *)xmmword_10015BF10;
    if ((_QWORD)xmmword_10015BF10)
    {
      v14 = 0;
      do
      {
        if (v13[4] == *(_QWORD *)(a1 + 3552) && *((_DWORD *)v13 + 36) == 6)
        {
          if (a3 && mDNS_LoggingEnabled)
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "CountProxyTargets: fd %d %-7s IP%2d %.16a", a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 3732));
          ++v14;
        }
        v13 = (uint64_t *)*v13;
      }
      while (v13);
      if (a2)
        goto LABEL_20;
      goto LABEL_21;
    }
  }
  else
  {
    v12 = 0;
  }
  v14 = 0;
  if (a2)
LABEL_20:
    *a2 = v12;
LABEL_21:
  if (a3)
    *a3 = v14;
  return (v14 + v12);
}

uint64_t CloseBPF(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __CFRunLoop *Main;
  const void *v10;
  const void *v11;
  uint64_t result;

  if (mDNS_LoggingEnabled == 1)
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%s closing BPF fd %d", a4, a5, a6, a7, a8, a1 + 3606);
  Main = CFRunLoopGetMain();
  CFRunLoopRemoveSource(Main, *(CFRunLoopSourceRef *)(a1 + 3768), kCFRunLoopDefaultMode);
  v10 = *(const void **)(a1 + 3768);
  if (v10)
  {
    CFRelease(v10);
    *(_QWORD *)(a1 + 3768) = 0;
  }
  CFSocketInvalidate(*(CFSocketRef *)(a1 + 3760));
  v11 = *(const void **)(a1 + 3760);
  if (v11)
  {
    CFRelease(v11);
    *(_QWORD *)(a1 + 3760) = 0;
  }
  *(_DWORD *)(a1 + 3732) = -1;
  result = *(unsigned int *)(a1 + 3736);
  if ((result & 0x80000000) == 0)
  {
    result = close(result);
    *(_DWORD *)(a1 + 3736) = -1;
  }
  return result;
}

void __mDNSMacOSXNetworkChanged_block_invoke_2(id a1, int a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v19;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  NSObject *v27;
  uint64_t v28;
  int *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _DWORD *v35;
  NSObject *v36;
  uint64_t v37;
  int *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  NSObject *v49;
  uint64_t v50;
  int *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  NSObject *v57;
  uint64_t v58;
  int *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  int v65;
  NSObject *v66;
  uint64_t v67;
  int *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  int v75;
  __CFSocket *v76;
  __CFRunLoop *Main;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  NSObject *v85;
  int *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  char *v109;
  char *v110;
  char *v111;
  uint64_t v112;
  uint64_t v113;
  int v114;
  CFSocketContext buf;
  _OWORD v116[2];

  if (a2 < 0)
  {
    v19 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
        return;
      LODWORD(buf.version) = 134217984;
      *(CFIndex *)((char *)&buf.version + 4) = a3;
    }
    else
    {
      v19 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
        return;
      LODWORD(buf.version) = 134217984;
      *(CFIndex *)((char *)&buf.version + 4) = a3;
    }
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "BPF request failed: %ld", (uint8_t *)&buf, 0xCu);
    return;
  }
  v3 = *(_QWORD *)&a2;
  v4 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v4, v5, v6, v7, v8, v9, v10, v11);
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNSPlatformReceiveBPF_fd", 3284);
  v17 = *(_QWORD *)mDNSStorage[0];
  if (*(_QWORD *)mDNSStorage[0])
  {
    while (*(_DWORD *)(v17 + 3732) != -2)
    {
      v17 = *(_QWORD *)(v17 + 3680);
      if (!v17)
        goto LABEL_5;
    }
    if (mDNS_LoggingEnabled == 1)
    {
      v99 = v3;
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "%s using   BPF fd %d", v12, v13, v14, v15, v16, v17 + 3606);
    }
    v114 = 0;
    if (ioctl(v3, 0x40044271uLL, &v114, v99) < 0)
    {
      v27 = mDNSLogCategory_Default;
      v28 = *__error();
      v29 = __error();
      v104 = v28;
      v108 = (uint64_t)strerror(*v29);
      v100 = v17 + 3606;
      LogMsgWithLevel(v27, OS_LOG_TYPE_DEFAULT, "mDNSPlatformReceiveBPF_fd: %d %s BIOCVERSION failed %d (%s)", v30, v31, v32, v33, v34, v3);
    }
    else if ((unsigned __int16)v114 != 1 || HIWORD(v114) != 1)
    {
      v112 = (unsigned __int16)v114;
      v113 = HIWORD(v114);
      v104 = 1;
      v108 = 1;
      v100 = v17 + 3606;
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformReceiveBPF_fd: %d %s BIOCVERSION header %d.%d kernel %d.%d", v21, v22, v23, v24, v25, v3);
    }
    v35 = (_DWORD *)(v17 + 3740);
    if (ioctl(v3, 0x40044266uLL, v17 + 3740, v100, v104, v108, v112, v113) < 0)
    {
      v36 = mDNSLogCategory_Default;
      v37 = *__error();
      v38 = __error();
      v105 = v37;
      v109 = strerror(*v38);
      v101 = v17 + 3606;
      LogMsgWithLevel(v36, OS_LOG_TYPE_DEFAULT, "mDNSPlatformReceiveBPF_fd: %d %s BIOCGBLEN failed %d (%s)", v39, v40, v41, v42, v43, v3);
    }
    if (*v35 >= 0x22F9u)
    {
      *v35 = 8952;
      if (ioctl(v3, 0xC0044266uLL, v17 + 3740) < 0)
      {
        v49 = mDNSLogCategory_Default;
        v50 = *__error();
        v51 = __error();
        v105 = v50;
        v109 = strerror(*v51);
        v101 = v17 + 3606;
        LogMsgWithLevel(v49, OS_LOG_TYPE_DEFAULT, "mDNSPlatformReceiveBPF_fd: %d %s BIOCSBLEN failed %d (%s)", v52, v53, v54, v55, v56, v3);
      }
      else if (mDNS_LoggingEnabled == 1)
      {
        v101 = v17 + 3606;
        v105 = *(unsigned int *)(v17 + 3740);
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformReceiveBPF_fd: %d %s BIOCSBLEN %d", v44, v45, v46, v47, v48, v3);
      }
    }
    if (ioctl(v3, 0x80044270uLL, &mDNSPlatformReceiveBPF_fd_opt_one, v101, v105, v109) < 0)
    {
      v57 = mDNSLogCategory_Default;
      v58 = *__error();
      v59 = __error();
      v106 = v58;
      v110 = strerror(*v59);
      v102 = v17 + 3606;
      LogMsgWithLevel(v57, OS_LOG_TYPE_DEFAULT, "mDNSPlatformReceiveBPF_fd: %d %s BIOCIMMEDIATE failed %d (%s)", v60, v61, v62, v63, v64, v3);
    }
    v65 = fcntl(v3, 3, 0, v102, v106, v110);
    if (fcntl(v3, 4, v65 | 4u) < 0)
    {
      v66 = mDNSLogCategory_Default;
      v67 = *__error();
      v68 = __error();
      v107 = v67;
      v111 = strerror(*v68);
      v103 = v17 + 3606;
      LogMsgWithLevel(v66, OS_LOG_TYPE_DEFAULT, "mDNSPlatformReceiveBPF_fd: %d %s O_NONBLOCK failed %d (%s)", v69, v70, v71, v72, v73, v3);
    }
    v74 = 0;
    memset(v116, 0, sizeof(v116));
    while (1)
    {
      v75 = *(unsigned __int8 *)(v17 + 3606 + v74);
      *((_BYTE *)v116 + v74) = v75;
      if (!v75)
        break;
      if (++v74 == 15)
      {
        HIBYTE(v116[0]) = 0;
        break;
      }
    }
    if (ioctl(v3, 0x8020426CuLL, v116, v103, v107, v111) < 0)
    {
      v85 = mDNSLogCategory_Default;
      __error();
      v86 = __error();
      strerror(*v86);
      LogMsgWithLevel(v85, OS_LOG_TYPE_DEFAULT, "mDNSPlatformReceiveBPF_fd: %d %s BIOCSETIF failed %d (%s)", v87, v88, v89, v90, v91, v3);
      *(_DWORD *)(v17 + 3732) = -3;
    }
    else
    {
      buf.version = 0;
      memset(&buf.retain, 0, 24);
      buf.info = (void *)v17;
      *(_DWORD *)(v17 + 3732) = v3;
      v76 = CFSocketCreateWithNative(kCFAllocatorDefault, v3, 1uLL, (CFSocketCallBack)bpf_callback, &buf);
      *(_QWORD *)(v17 + 3760) = v76;
      *(_QWORD *)(v17 + 3768) = CFSocketCreateRunLoopSource(kCFAllocatorDefault, v76, 0);
      Main = CFRunLoopGetMain();
      CFRunLoopAddSource(Main, *(CFRunLoopSourceRef *)(v17 + 3768), kCFRunLoopDefaultMode);
      mDNSPlatformUpdateProxyList(*(_QWORD *)(v17 + 3552), v78, v79, v80, v81, v82, v83, v84);
    }
  }
  else
  {
LABEL_5:
    if (mDNS_LoggingEnabled == 1)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformReceiveBPF_fd: No Interfaces awaiting BPF fd %d; closing",
        v12,
        v13,
        v14,
        v15,
        v16,
        v3);
    close(v3);
  }
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNSPlatformReceiveBPF_fd", 3355);
  KQueueUnlock((uint64_t)"mDNSPlatformReceiveBPF_fd", v92, v93, v94, v95, v96, v97, v98);
}

void bpf_callback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int8x8_t *v19;
  unint64_t v20;
  int v21;
  ssize_t v22;
  unint64_t v23;
  unint64_t v24;
  _OWORD *v25;
  _OWORD *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _WORD *v30;
  uint64_t v31;
  _DWORD *v32;
  uint64_t v33;
  int v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  NSObject *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  char *v78;
  uint64_t v79;
  int *v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  NSObject *v86;
  int *v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  int v100;
  int v101;
  int v102;
  _BYTE *v103;
  NSObject *v104;
  NSObject *v105;
  NSObject *v106;
  unsigned __int16 *v107;
  _BYTE *v108;
  char *v109;
  uint64_t v110;
  NSObject *v111;
  _OWORD *v112;
  _OWORD *v113;
  _QWORD v114[2];
  int v115;
  _QWORD v116[2];
  int v117;
  int v118;
  int v119[3];

  v6 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v6, v7, v8, v9, v10, v11, v12, v13);
  v21 = *(_DWORD *)(a5 + 3732);
  if ((v21 & 0x80000000) == 0)
  {
    v22 = read(v21, (void *)(*(_QWORD *)(a5 + 3688) + 20008), *(unsigned int *)(a5 + 3740));
    if (v22 < 0)
    {
      v80 = __error();
      v86 = mDNSLogCategory_Default;
      if (*v80 == 35)
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "bpf_callback got EAGAIN bailing", v81, v82, v83, v84, v85, v100);
      }
      else
      {
        __error();
        v87 = __error();
        strerror(*v87);
        LogMsgWithLevel(v86, OS_LOG_TYPE_DEFAULT, "Closing %s BPF fd %d due to error %d (%s)", v88, v89, v90, v91, v92, a5 + 3606);
        CloseBPF(a5, v93, v94, v95, v96, v97, v98, v99);
      }
    }
    else
    {
      v23 = *(_QWORD *)(a5 + 3688) + 20008;
      v24 = v23 + v22;
      if (v23 < v23 + v22)
      {
        v25 = (_OWORD *)((char *)v116 + 4);
        v26 = (_OWORD *)((char *)v114 + 4);
        do
        {
          v27 = *(_QWORD *)(a5 + 3688);
          v28 = v23 + *(unsigned __int16 *)(v23 + 16);
          v20 = v28 + *(unsigned int *)(v23 + 8);
          v29 = *(_QWORD *)(a5 + 3552);
          v30 = (_WORD *)(v28 + 14);
          v116[0] = 0;
          v116[1] = 0;
          v117 = 0;
          v114[0] = 0;
          v114[1] = 0;
          v115 = 0;
          if (v28 + 42 <= v20 && *(_WORD *)(v28 + 12) == 1544 && *v30 == 256 && *(_WORD *)(v28 + 16) == 8)
          {
            v31 = v27 + 12656;
            do
            {
              v31 = *(_QWORD *)v31;
              if (!v31)
                goto LABEL_79;
            }
            while (*(_QWORD *)(v31 + 3552) != v29);
            v112 = v26;
            v113 = v25;
            mDNS_Lock_((unsigned int *)v27, (uint64_t)"mDNSCoreReceiveRawARP", 17825);
            if (*(_WORD *)(v28 + 20) == 256)
            {
              v32 = (_DWORD *)(v28 + 38);
              if (*(_DWORD *)(v28 + 28) != *(_DWORD *)(v28 + 38))
              {
                v33 = *(_QWORD *)(v27 + 12616);
                if (v33)
                {
                  v107 = (unsigned __int16 *)(v28 + 22);
                  v103 = (_BYTE *)(v27 + 47032);
                  do
                  {
                    if (*(_QWORD *)(v33 + 32) != v29
                      || *(_BYTE *)(v33 + 8) == 1
                      || *(_DWORD *)(v33 + 144) != 4
                      || *(_DWORD *)(v33 + 148) != *v32)
                    {
                      goto LABEL_39;
                    }
                    v34 = *v107;
                    if (v34 != *(unsigned __int16 *)(v33 + 132)
                      || *(unsigned __int16 *)(v28 + 24) != *(unsigned __int16 *)(v33 + 134)
                      || (v35 = "ARP Req from owner -- re-probing",
                          *(unsigned __int16 *)(v28 + 26) != *(unsigned __int16 *)(v33 + 136)))
                    {
                      v35 = "Ignoring  ARP Request from      ";
                      if (*(_BYTE *)(v33 + 191) != 4)
                      {
                        v35 = "Answering ARP Request from      ";
                        if (v34 == *(unsigned __int16 *)(v31 + 3600)
                          && *(unsigned __int16 *)(v28 + 24) == *(unsigned __int16 *)(v31 + 3602))
                        {
                          if (*(unsigned __int16 *)(v28 + 26) == *(unsigned __int16 *)(v31 + 3604))
                            v35 = "Creating Local ARP Cache entry  ";
                          else
                            v35 = "Answering ARP Request from      ";
                        }
                      }
                    }
                    v109 = (char *)v35;
                    v104 = mDNSLogCategory_Default;
                    GetRRDisplayString_rdb((unsigned __int8 *)(v33 + 8), (unsigned __int16 *)(*(_QWORD *)(v33 + 48) + 4), v103);
                    LogMsgWithLevel(v104, OS_LOG_TYPE_DEFAULT, "Arp %-7s %s %.6a %.4a for %.4a -- H-MAC %.6a I-MAC %.6a %s", v36, v37, v38, v39, v40, v31 + 3606);
                    if (v109 == "ARP Req from owner -- re-probing")
                    {
                      if (*(unsigned __int8 *)(v33 + 189) <= 0x13u)
                      {
                        RestartARPProbing((_DWORD *)v27, v33);
                        goto LABEL_38;
                      }
                      v32 = (_DWORD *)(v28 + 38);
                      if (mDNS_LoggingEnabled == 1)
                      {
                        v47 = mDNSLogCategory_Default;
                        GetRRDisplayString_rdb((unsigned __int8 *)(v33 + 8), (unsigned __int16 *)(*(_QWORD *)(v33 + 48) + 4), v103);
                        LogMsgWithLevel(v47, OS_LOG_TYPE_DEFAULT, "Reached maximum number of restarts for probing - %s", v48, v49, v50, v51, v52, (int)v103);
                        goto LABEL_38;
                      }
                    }
                    else
                    {
                      if (v109 == "Creating Local ARP Cache entry  ")
                      {
                        mDNSPlatformSetLocalAddressCacheEntry((int *)(v33 + 144), (const void *)(v33 + 132), v29, v41, v42, v43, v44, v45, v101);
                        goto LABEL_38;
                      }
                      v32 = (_DWORD *)(v28 + 38);
                      if (v109 == "Answering ARP Request from      ")
                      {
                        v46 = *(_DWORD *)(v28 + 38);
                        v118 = *(_DWORD *)(v28 + 28);
                        v119[0] = v46;
                        SendARP(v27, 2, v33, (uint64_t)v119, (uint64_t)v107, (uint64_t)&v118, (uint64_t)v107);
LABEL_38:
                        v32 = (_DWORD *)(v28 + 38);
                      }
                    }
LABEL_39:
                    v33 = *(_QWORD *)v33;
                  }
                  while (v33);
                }
              }
            }
            if (*(unsigned __int16 *)(v28 + 22) != *(unsigned __int16 *)(v31 + 3600)
              || *(unsigned __int16 *)(v28 + 24) != *(unsigned __int16 *)(v31 + 3602)
              || *(unsigned __int16 *)(v28 + 26) != *(unsigned __int16 *)(v31 + 3604))
            {
              if (*(_DWORD *)(v28 + 28))
              {
                v53 = *(_QWORD *)(v27 + 12616);
                if (v53)
                {
                  v54 = v31 + 3606;
                  v55 = v28 + 38;
                  v108 = (_BYTE *)(v27 + 47032);
                  while (1)
                  {
                    if (*(_QWORD *)(v53 + 32) != v29
                      || *(_BYTE *)(v53 + 8) == 1
                      || *(_DWORD *)(v53 + 144) != 4
                      || *(_DWORD *)(v53 + 148) != *(_DWORD *)(v28 + 28)
                      || *(unsigned __int8 *)(v53 + 189) > 0x13u)
                    {
                      goto LABEL_59;
                    }
                    if (!*(_WORD *)(v53 + 126) && !*(_WORD *)(v53 + 128) && !*(_WORD *)(v53 + 130))
                      break;
                    v110 = v55;
                    RestartARPProbing((_DWORD *)v27, v53);
                    if (*(unsigned __int16 *)(v28 + 22) == *(unsigned __int16 *)(v53 + 132)
                      && *(unsigned __int16 *)(v28 + 24) == *(unsigned __int16 *)(v53 + 134)
                      && *(unsigned __int16 *)(v28 + 26) == *(unsigned __int16 *)(v53 + 136))
                    {
                      v106 = mDNSLogCategory_Default;
                      GetRRDisplayString_rdb((unsigned __int8 *)(v53 + 8), (unsigned __int16 *)(*(_QWORD *)(v53 + 48) + 4), v108);
                      v56 = v110;
                      LogMsgWithLevel(v106, OS_LOG_TYPE_DEFAULT, "%-7s ARP %s from owner %.6a %.4a for %-15.4a -- re-starting probing for %s", v57, v58, v59, v60, v61, v54);
LABEL_62:
                      v55 = v56;
                      goto LABEL_59;
                    }
                    v105 = mDNSLogCategory_Default;
                    GetRRDisplayString_rdb((unsigned __int8 *)(v53 + 8), (unsigned __int16 *)(*(_QWORD *)(v53 + 48) + 4), v108);
                    LogMsgWithLevel(v105, OS_LOG_TYPE_DEFAULT, "%-7s Conflicting ARP from %.6a %.4a for %.4a -- waking H-MAC %.6a I-MAC %.6a %s", v62, v63, v64, v65, v66, v54);
                    ScheduleWakeup(v27, *(_QWORD *)(v53 + 32), (unsigned __int16 *)(v53 + 126), v67, v68, v69, v70, v71, v102);
                    v55 = v110;
LABEL_59:
                    v53 = *(_QWORD *)v53;
                    if (!v53)
                      goto LABEL_93;
                  }
                  v111 = mDNSLogCategory_Default;
                  v56 = v55;
                  GetRRDisplayString_rdb((unsigned __int8 *)(v53 + 8), (unsigned __int16 *)(*(_QWORD *)(v53 + 48) + 4), v108);
                  LogMsgWithLevel(v111, OS_LOG_TYPE_DEFAULT, "%-7s ARP from %.6a %.4a for %.4a -- Invalid H-MAC %.6a I-MAC %.6a %s", v72, v73, v74, v75, v76, v54);
                  goto LABEL_62;
                }
              }
            }
LABEL_93:
            mDNS_Unlock_(v27, (uint64_t)"mDNSCoreReceiveRawARP", 17912);
            v25 = v113;
            v26 = v112;
          }
          else if (v28 + 34 > v20
                 || *(_WORD *)(v28 + 12) != 8
                 || (*(_BYTE *)(v28 + 20) & 0x1F) != 0
                 || *(_BYTE *)(v28 + 21))
          {
            v19 = (int8x8_t *)(v28 + 54);
            if (v28 + 54 <= v20 && *(unsigned __int16 *)(v28 + 12) == 56710)
            {
              LODWORD(v116[0]) = 6;
              *v25 = *(_OWORD *)(v28 + 22);
              LODWORD(v114[0]) = 6;
              *v26 = *(_OWORD *)(v28 + 38);
              v17 = *(unsigned __int8 *)(v28 + 20);
              v77 = 24;
              if ((_DWORD)v17 != 58)
                v77 = 0;
              if ((_DWORD)v17 == 17)
                v77 = 8;
              if ((_DWORD)v17 == 6)
                v77 = 20;
              if ((_DWORD)v17 == 1)
                v77 = 4;
              if ((unint64_t)v19 + v77 <= v20)
                mDNSCoreReceiveRawTransportPacket(v27, (unsigned __int16 *)(v28 + 6), v116, v114, v17, v28, v19, v20, v29, bswap32(*(unsigned __int16 *)(v28 + 18)) >> 16);
            }
          }
          else
          {
            v19 = (int8x8_t *)&v30[2 * (*(_BYTE *)(v28 + 14) & 0xF)];
            v78 = (char *)v30 + (bswap32(*(unsigned __int16 *)(v28 + 16)) >> 16);
            if ((unint64_t)v78 <= v20)
              v20 = (unint64_t)v78;
            LODWORD(v116[0]) = 4;
            HIDWORD(v116[0]) = *(_DWORD *)(v28 + 26);
            LODWORD(v114[0]) = 4;
            HIDWORD(v114[0]) = *(_DWORD *)(v28 + 30);
            v17 = *(unsigned __int8 *)(v28 + 23);
            v79 = 24;
            if ((_DWORD)v17 != 58)
              v79 = 0;
            if ((_DWORD)v17 == 17)
              v79 = 8;
            if ((_DWORD)v17 == 6)
              v79 = 20;
            if ((_DWORD)v17 == 1)
              v79 = 4;
            if (v20 >= (unint64_t)v19 + v79)
              mDNSCoreReceiveRawTransportPacket(v27, (unsigned __int16 *)(v28 + 6), v116, v114, v17, v28, v19, v20, v29, 0);
          }
LABEL_79:
          v23 += (*(_DWORD *)(v23 + 8) + *(unsigned __int16 *)(v23 + 16) + 3) & 0x1FFFFFFFCLL;
        }
        while (v23 < v24);
      }
    }
  }
  KQueueUnlock((uint64_t)"bpf_callback", v14, v15, v16, v17, v18, (uint64_t)v19, v20);
}

void mDNSPlatformUpdateProxyList(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _BYTE *v18;
  uint64_t *v19;
  uint64_t *v20;
  uint64_t *v21;
  uint64_t *v22;
  uint64_t *v23;
  unsigned int v24;
  uint64_t *v25;
  int v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  int v34;
  int v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  int *v39;
  char *v40;
  NSObject *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  int *v51;
  char *v52;
  NSObject *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  int v69;
  int v70;
  int v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  NSObject *v77;
  int v78;
  int *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  int v85;
  uint64_t v86;
  char *v87;
  _OWORD *v88;
  uint64_t v89;
  __int128 v90;
  unsigned int v91;
  uint64_t v92;
  void *v93;
  unsigned int v94;
  unsigned int v95;

  v9 = *(_QWORD *)mDNSStorage[0];
  if (!*(_QWORD *)mDNSStorage[0])
  {
LABEL_5:
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformUpdateProxyList: ERROR InterfaceID %p not found", a4, a5, a6, a7, a8, a1);
    return;
  }
  while (*(_QWORD *)(v9 + 3552) != a1 || (*(_DWORD *)(v9 + 3732) & 0x80000000) != 0)
  {
    v9 = *(_QWORD *)(v9 + 3680);
    if (!v9)
      goto LABEL_5;
  }
  v95 = 0;
  v94 = 0;
  v10 = CountProxyTargets(v9, &v95, &v94, a4, a5, a6, a7, a8);
  v16 = v95;
  v17 = v94;
  if (v10 >= 251)
  {
    v86 = v94;
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformUpdateProxyList: ERROR Too many address proxy records v4 %d v6 %d", v11, v12, v13, v14, v15, v95);
    v16 = v95;
    if ((int)v95 >= 251)
    {
      v16 = 250;
      v95 = 250;
    }
    v17 = (250 - v16);
    v94 = 250 - v16;
  }
  v18 = &unk_100158000;
  if (mDNS_LoggingEnabled == 1)
  {
    v88 = (_OWORD *)v16;
    v89 = v17;
    v86 = v9 + 3606;
    v87 = (char *)(v9 + 3600);
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformUpdateProxyList: fd %d %-7s MAC  %.6a %d v4 %d v6", v11, v12, v13, v14, v15, *(_DWORD *)(v9 + 3732));
    LODWORD(v16) = v95;
    LODWORD(v17) = v94;
  }
  v92 = 0;
  v93 = 0;
  if (v16 | v17)
  {
    v19 = qword_10014BE3C;
    v20 = &qword_10014BE3C[(int)v16];
    v21 = &v20[(int)v17];
    v22 = v21 + 2;
    byte_10014BE17 = ((_DWORD)v21 + 16 - &mDNSPlatformUpdateProxyList_filter - 40) >> 3;
    byte_10014BE27 = v16 + 3;
    v23 = (uint64_t *)xmmword_10015BF10;
    if ((_QWORD)xmmword_10015BF10)
    {
      v19 = qword_10014BE3C;
      do
      {
        if (v23[4] == a1 && *((_DWORD *)v23 + 36) == 4)
        {
          v24 = *((_DWORD *)v23 + 37);
          *(_WORD *)v19 = 21;
          *((_WORD *)v19 + 1) = (((_DWORD)v22 - (_DWORD)v19) >> 3);
          *((_DWORD *)v19++ + 1) = bswap32(v24);
        }
        v23 = (uint64_t *)*v23;
      }
      while (v23);
    }
    *v19 = 6;
    if (v19 != v20)
    {
      v86 = (uint64_t)(v20 + 1);
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformUpdateProxyList: pc %p != chk6 %p", v11, v12, v13, v14, v15, (_DWORD)v19 + 8);
    }
    v25 = v19 + 2;
    v19[1] = 0x3200000020;
    v26 = *(_DWORD *)(v9 + 3736);
    if ((v26 & 0x80000000) == 0)
      close(v26);
    v27 = v21 + 7;
    *(_DWORD *)(v9 + 3736) = socket(30, 2, 0);
    v33 = (uint64_t *)xmmword_10015BF10;
    if ((_QWORD)xmmword_10015BF10)
    {
      v34 = (_DWORD)v21 + 48;
      do
      {
        if (v33[4] == a1 && *((_DWORD *)v33 + 36) == 6)
        {
          *(_WORD *)v25 = 21;
          *((_BYTE *)v25 + 2) = (v34 - (_DWORD)v25) >> 3;
          *((_BYTE *)v25 + 3) = 0;
          *((_DWORD *)v25 + 1) = bswap32(*((_DWORD *)v33 + 40));
          v91 = *(_DWORD *)(v9 + 3720);
          v90 = NDP_prefix;
          *(_WORD *)((char *)&v90 + 13) = *(_WORD *)((char *)v33 + 161);
          HIBYTE(v90) = *((_BYTE *)v33 + 163);
          v35 = setsockopt(*(_DWORD *)(v9 + 3736), 41, 13, &v90, 0x14u);
          if (v35 < 0)
          {
            v36 = v35;
            if (*__error() != 49)
            {
              v37 = mDNSLogCategory_Default;
              v38 = *__error();
              v39 = __error();
              v40 = strerror(*v39);
              v89 = v91;
              v87 = v40;
              v88 = &v90;
              v86 = v38;
              v41 = v37;
              v18 = (_BYTE *)&unk_100158000;
              LogMsgWithLevel(v41, OS_LOG_TYPE_DEFAULT, "mDNSPlatformUpdateProxyList: IPV6_LEAVE_GROUP error %d errno %d (%s) group %.16a on %u", v42, v43, v44, v45, v46, v36);
            }
          }
          v47 = setsockopt(*(_DWORD *)(v9 + 3736), 41, 12, &v90, 0x14u);
          if (v47 < 0)
          {
            v48 = v47;
            if (*__error() != 48)
            {
              v49 = mDNSLogCategory_Default;
              v50 = *__error();
              v51 = __error();
              v52 = strerror(*v51);
              v89 = v91;
              v87 = v52;
              v88 = &v90;
              v86 = v50;
              v53 = v49;
              v18 = &unk_100158000;
              LogMsgWithLevel(v53, OS_LOG_TYPE_DEFAULT, "mDNSPlatformUpdateProxyList: IPV6_JOIN_GROUP error %d errno %d (%s) group %.16a on %u", v54, v55, v56, v57, v58, v48);
            }
          }
          if (v18[3304] == 1)
          {
            v86 = (uint64_t)v33 + 148;
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Joined IPv6 ND multicast group %.16a for %.16a", v28, v29, v30, v31, v32, (int)&v90);
          }
          ++v25;
        }
        v33 = (uint64_t *)*v33;
      }
      while (v33);
    }
    if (v25 == v22)
    {
      *(_OWORD *)v22 = xmmword_1001009B0;
      *((_OWORD *)v22 + 1) = xmmword_1001009C0;
      v22[4] = 22;
    }
    else
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformUpdateProxyList: pc %p != fail %p", v28, v29, v30, v31, v32, (int)v25);
      *v25 = 6;
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformUpdateProxyList: pc %p != ret4 %p", v59, v60, v61, v62, v63, (_DWORD)v25 + 8);
      *(_OWORD *)(v25 + 1) = xmmword_100100990;
      *(_OWORD *)(v25 + 3) = xmmword_1001009A0;
      v86 = (uint64_t)v27;
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformUpdateProxyList: pc %p != ret6 %p", v64, v65, v66, v67, v68, (_DWORD)v25 + 40);
      v27 = v25 + 5;
    }
    *v27 = 0x5E00000006;
    LODWORD(v92) = (unint64_t)((char *)v25 - (char *)&mDNSPlatformUpdateProxyList_filter + 48) >> 3;
    v93 = &mDNSPlatformUpdateProxyList_filter;
    v71 = *(_DWORD *)(v9 + 3732);
    goto LABEL_54;
  }
  if (mDNS_LoggingEnabled == 1)
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformUpdateProxyList: No need for filter", v11, v12, v13, v14, v15, v85);
  if (!dword_100158E08)
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformUpdateProxyList: m->timenow == 0", v11, v12, v13, v14, v15, v85);
  v69 = *(_DWORD *)(v9 + 3736);
  if ((v69 & 0x80000000) == 0)
  {
    close(v69);
    *(_DWORD *)(v9 + 3736) = -1;
  }
  if (!dword_100158DD0)
  {
    v70 = dword_100158E08 + 2000;
    if ((dword_100158E08 + 2000) <= 1)
      v70 = 1;
    dword_100158DD0 = v70;
  }
  v71 = *(_DWORD *)(v9 + 3732);
  if ((v71 & 0x80000000) == 0)
  {
    LODWORD(v92) = 1;
    v93 = &mDNSPlatformUpdateProxyList_nullfilter;
LABEL_54:
    if (ioctl(v71, 0x8010427EuLL, &v92, v86, v87, v88, v89) < 0)
    {
      v77 = mDNSLogCategory_Default;
      v78 = v92;
      __error();
      v79 = __error();
      strerror(*v79);
      LogMsgWithLevel(v77, OS_LOG_TYPE_DEFAULT, "mDNSPlatformUpdateProxyList: BIOCSETFNR(%d) failed %d (%s)", v80, v81, v82, v83, v84, v78);
    }
    else if (v18[3304] == 1)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformUpdateProxyList: BIOCSETFNR(%d) successful", v72, v73, v74, v75, v76, v92);
    }
  }
}

void __mDNSMacOSXNetworkChanged_block_invoke(id a1)
{
  mDNSMacOSXNetworkChanged_queue = (uint64_t)dispatch_queue_create("com.apple.mDNSResponder.bpf-queue", 0);
}

uint64_t CountMaskBits(int *a1)
{
  uint64_t v2;
  uint64_t result;
  _DWORD *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  char v9;

  v2 = 0;
  result = 0;
  v5 = *a1;
  v4 = a1 + 1;
  v6 = 16 * (v5 == 6);
  v7 = 4;
  if (v5 != 4)
    v7 = v6;
  while (v2 != v7)
  {
    v8 = *((char *)v4 + v2);
    if (v8 < 0)
    {
      do
      {
        result = (result + 1);
        v9 = 2 * v8;
        v8 = (char)(2 * v8);
      }
      while (v9 < 0);
    }
    ++v2;
    if (v8)
      return 0xFFFFFFFFLL;
  }
  return result;
}

void mDNSGroupJoinOrLeave(int a1, uint64_t a2, int a3)
{
  int v6;
  int v7;
  NSObject *v8;
  const char *v9;
  NSObject *v10;
  const char *v11;
  uint64_t v12;
  const char *v13;
  int v14;
  const char *v15;
  int v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  const char *v21;
  const char *v22;
  NSObject *v23;
  uint32_t v24;
  char *v25;
  int v26;
  int v27;
  const char *v28;
  __int16 v29;
  _BYTE v30[14];
  __int16 v31;
  _BYTE v32[14];
  __int16 v33;
  uint64_t v34;
  __int16 v35;
  int v36;
  _DWORD v37[9];
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;

  v43 = 0u;
  v42 = 0u;
  v41 = 0u;
  v40 = 0u;
  v39 = 0u;
  v38 = 0u;
  memset(&v37[1], 0, 32);
  v6 = *(_DWORD *)(a2 + 3720);
  v37[0] = v6;
  v7 = *(unsigned __int16 *)(a2 + 3730);
  if (v7 != 30)
  {
    if (v7 != 2)
    {
      v12 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
          return;
        v13 = "join";
        v27 = 136446978;
        if (!a3)
          v13 = "leave";
      }
      else
      {
        v12 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
          return;
        v13 = "join";
        v27 = 136446978;
        if (!a3)
          v13 = "leave";
      }
      v28 = v13;
      v29 = 2082;
      *(_QWORD *)v30 = a2 + 3606;
      *(_WORD *)&v30[8] = 1024;
      *(_DWORD *)&v30[10] = v6;
      v31 = 1024;
      *(_DWORD *)v32 = v7;
      v22 = "Cannot %{public}s mcast group on %{public}s (%u) for unrecognized address family %d";
      v23 = v12;
      v24 = 34;
LABEL_54:
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, v22, (uint8_t *)&v27, v24);
      return;
    }
    LOWORD(v37[1]) = 528;
    v37[2] = -83885856;
    v8 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
      {
        v9 = "Join";
        v27 = 136447234;
        if (!a3)
          v9 = "Leav";
        goto LABEL_24;
      }
    }
    else
    {
      v8 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        v9 = "Join";
        v27 = 136447234;
        if (!a3)
          v9 = "Leav";
LABEL_24:
        v28 = v9;
        v29 = 1042;
        *(_DWORD *)v30 = 4;
        *(_WORD *)&v30[4] = 2098;
        *(_QWORD *)&v30[6] = &v37[2];
        v31 = 2082;
        *(_QWORD *)v32 = a2 + 3606;
        *(_WORD *)&v32[8] = 1024;
        *(_DWORD *)&v32[10] = v6;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}sing mcast group %{public, network:in_addr}.4P on %{public}s (%u)", (uint8_t *)&v27, 0x2Cu);
      }
    }
    v14 = 0;
    v15 = "";
    goto LABEL_31;
  }
  LOWORD(v37[1]) = 7708;
  *(_OWORD *)&v37[3] = xmmword_100100068;
  v10 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
      v11 = "Join";
      v27 = 136447234;
      if (!a3)
        v11 = "Leav";
      goto LABEL_29;
    }
  }
  else
  {
    v10 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
      v11 = "Join";
      v27 = 136447234;
      if (!a3)
        v11 = "Leav";
LABEL_29:
      v28 = v11;
      v29 = 1042;
      *(_DWORD *)v30 = 16;
      *(_WORD *)&v30[4] = 2098;
      *(_QWORD *)&v30[6] = &v37[3];
      v31 = 2082;
      *(_QWORD *)v32 = a2 + 3606;
      *(_WORD *)&v32[8] = 1024;
      *(_DWORD *)&v32[10] = v6;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}sing mcast group %{public, network:in6_addr}.16P on %{public}s (%u)", (uint8_t *)&v27, 0x2Cu);
    }
  }
  v14 = 41;
  v15 = "V6";
LABEL_31:
  if (a3)
    v16 = 80;
  else
    v16 = 81;
  v17 = setsockopt(a1, v14, v16, v37, 0x84u);
  if (v17)
  {
    if ((v18 = v17, v19 = *__error(), a3) && v19 != 48 || !a3 && v19 != 49)
    {
      v20 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
          return;
        if (a3)
          v21 = "JOIN";
        else
          v21 = "LEAVE";
      }
      else
      {
        v20 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
          return;
        if (a3)
          v21 = "JOIN";
        else
          v21 = "LEAVE";
      }
      v25 = strerror(v19);
      v26 = *(_DWORD *)(a2 + 3720);
      v27 = 136447746;
      v28 = v15;
      v29 = 2082;
      *(_QWORD *)v30 = v21;
      *(_WORD *)&v30[8] = 1024;
      *(_DWORD *)&v30[10] = v18;
      v31 = 1024;
      *(_DWORD *)v32 = v19;
      *(_WORD *)&v32[4] = 2080;
      *(_QWORD *)&v32[6] = v25;
      v33 = 2082;
      v34 = a2 + 3606;
      v35 = 1024;
      v36 = v26;
      v22 = "setsockopt - IPPROTO_IP%{public}s/MCAST_%{public}s_GROUP error %d errno %d (%s) on %{public}s (%u)";
      v23 = v20;
      v24 = 60;
      goto LABEL_54;
    }
  }
}

uint64_t getExtendedFlags(uint64_t a1)
{
  int v2;
  int v3;
  uint64_t v4;
  int v5;
  NSObject *v6;
  int *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v14;
  int v15;
  int *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;

  v22 = 0u;
  v23 = 0u;
  v2 = socket(2, 2, 0);
  if (v2 < 0)
  {
    v14 = mDNSLogCategory_Default;
    v15 = *__error();
    v16 = __error();
    strerror(*v16);
    LogMsgWithLevel(v14, OS_LOG_TYPE_DEFAULT, "getExtendedFlags: socket() call failed, errno = %d (%s)", v17, v18, v19, v20, v21, v15);
    return 0;
  }
  else
  {
    BYTE1(v23) = 2;
    if (!a1)
      __break(1u);
    v3 = v2;
    v4 = 0;
    while (1)
    {
      v5 = *(unsigned __int8 *)(a1 + v4);
      *((_BYTE *)&v22 + v4) = v5;
      if (!v5)
        break;
      if (++v4 == 15)
      {
        HIBYTE(v22) = 0;
        break;
      }
    }
    if (ioctl(v2, 0xC020698EuLL, &v22) == -1)
    {
      v6 = mDNSLogCategory_Default;
      __error();
      v7 = __error();
      strerror(*v7);
      LogMsgWithLevel(v6, OS_LOG_TYPE_DEFAULT, "getExtendedFlags: SIOCGIFEFLAGS failed for %s, errno = %d (%s)", v8, v9, v10, v11, v12, a1);
      *(_QWORD *)&v23 = 0;
    }
    close(v3);
    return v23;
  }
}

CFIndex mDNSDomainLabelFromCFString(const __CFString *a1, _BYTE *a2)
{
  CFIndex result;
  CFIndex usedBufLen;
  CFRange v6;

  usedBufLen = 0;
  v6.length = CFStringGetLength(a1);
  v6.location = 0;
  result = CFStringGetBytes(a1, v6, 0x8000100u, 0, 0, a2 + 1, 63, &usedBufLen);
  *a2 = usedBufLen;
  return result;
}

uint64_t CheckInterfaceSupport(uint64_t a1, const char *a2)
{
  const __CFDictionary *v3;
  io_service_t MatchingService;
  io_object_t v5;
  const __CFString *v6;
  int v7;
  uint64_t v8;
  _OWORD v10[8];

  v3 = IOBSDNameMatching(kIOMainPortDefault, 0, (const char *)(a1 + 3606));
  MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v3);
  if (!MatchingService)
    return 0;
  v5 = MatchingService;
  v6 = CFStringCreateWithCString(0, a2, 0x8000100u);
  v7 = RegistryEntrySearchCFPropertyAndIOObject(v5, v6, 0, 0);
  if (v6)
    CFRelease(v6);
  if (v7)
  {
    memset(v10, 0, sizeof(v10));
    IOObjectGetClass(v5, (char *)v10);
    v8 = 0;
  }
  else
  {
    v8 = 1;
  }
  IOObjectRelease(v5);
  return v8;
}

uint64_t RegistryEntrySearchCFPropertyAndIOObject(io_object_t a1, const __CFString *a2, _QWORD *a3, io_registry_entry_t *a4)
{
  io_registry_entry_t v7;
  CFTypeRef CFProperty;
  uint64_t result;
  io_registry_entry_t parent;

  v7 = a1;
  IOObjectRetain(a1);
  while (1)
  {
    CFProperty = IORegistryEntryCreateCFProperty(v7, a2, kCFAllocatorDefault, 0);
    if (CFProperty)
      break;
    parent = 0;
    if (IORegistryEntryGetParentEntry(v7, "IOService", &parent))
      parent = 0;
    IOObjectRelease(v7);
    v7 = parent;
    if (!parent)
      return 3758097088;
  }
  if (a3)
  {
    *a3 = CFProperty;
    if (a4)
    {
LABEL_9:
      result = 0;
      *a4 = v7;
      return result;
    }
  }
  else
  {
    CFRelease(CFProperty);
    if (a4)
      goto LABEL_9;
  }
  IOObjectRelease(v7);
  return 0;
}

void mDNSPlatformSendRawPacket(void *__buf, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  const char *v7;
  uint64_t v8;
  NSObject *v11;
  uint32_t v12;
  int v14;
  uint64_t v15;
  uint64_t v16;
  int v19;
  int v20;
  int *v21;
  char *v22;
  int v23;
  _BYTE v24[10];
  _BYTE v25[10];

  if (!a3)
  {
    v8 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
        return;
      LOWORD(v23) = 0;
      v7 = "mDNSPlatformSendRawPacket: No InterfaceID specified";
    }
    else
    {
      v8 = mDNSLogCategory_NAT_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
        return;
      LOWORD(v23) = 0;
      v7 = "mDNSPlatformSendRawPacket: No InterfaceID specified";
    }
    v11 = v8;
    v12 = 2;
LABEL_26:
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)&v23, v12);
    return;
  }
  v4 = *(_QWORD *)mDNSStorage;
  if (!*(_QWORD *)mDNSStorage)
  {
LABEL_6:
    v5 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
        return;
      v23 = 134217984;
      *(_QWORD *)v24 = a3;
      v7 = "mDNSPlatformSendRawPacket: Invalid interface index %p";
    }
    else
    {
      v5 = mDNSLogCategory_NAT_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
        return;
      v23 = 134217984;
      *(_QWORD *)v24 = a3;
      v7 = "mDNSPlatformSendRawPacket: Invalid interface index %p";
    }
    v11 = v5;
    v12 = 12;
    goto LABEL_26;
  }
  while (!*(_QWORD *)(v4 + 3776) || *(_DWORD *)(v4 + 3720) != (_DWORD)a3)
  {
    v4 = *(_QWORD *)(v4 + 3680);
    if (!v4)
      goto LABEL_6;
  }
  v14 = *(_DWORD *)(v4 + 3732);
  if (v14 < 0)
  {
    v16 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
        return;
    }
    else
    {
      v16 = mDNSLogCategory_NAT_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
        return;
    }
    v23 = 136446466;
    *(_QWORD *)v24 = v4 + 3606;
    *(_WORD *)&v24[8] = 1024;
    *(_DWORD *)v25 = v14;
    v7 = "mDNSPlatformSendRawPacket: %{public}s BPF_fd %d not ready";
    v11 = v16;
    v12 = 18;
    goto LABEL_26;
  }
  if (write(*(_DWORD *)(v4 + 3732), __buf, a2 - (_QWORD)__buf) < 0)
  {
    v15 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
      {
LABEL_44:
        v19 = *(_DWORD *)(v4 + 3732);
        v20 = *__error();
        v21 = __error();
        v22 = strerror(*v21);
        v23 = 67109634;
        *(_DWORD *)v24 = v19;
        *(_WORD *)&v24[4] = 1024;
        *(_DWORD *)&v24[6] = v20;
        *(_WORD *)v25 = 2082;
        *(_QWORD *)&v25[2] = v22;
        v7 = "mDNSPlatformSendRawPacket: BPF write(%d) failed %d (%{public}s)";
        v11 = v15;
        v12 = 24;
        goto LABEL_26;
      }
    }
    else
    {
      v15 = mDNSLogCategory_NAT_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_44;
    }
  }
}

void mDNSPlatformSetLocalAddressCacheEntry(int *a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  unsigned int v9;
  uint64_t v10;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  xpc_object_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;

  if (a3)
  {
    v9 = a3;
    v10 = *(_QWORD *)mDNSStorage[0];
    if (*(_QWORD *)mDNSStorage[0])
    {
      while (!*(_QWORD *)(v10 + 3776) || *(_DWORD *)(v10 + 3720) != (_DWORD)a3)
      {
        v10 = *(_QWORD *)(v10 + 3680);
        if (!v10)
          goto LABEL_6;
      }
      if (mDNS_AddressIsLocalSubnet((uint64_t)mDNSStorage, a3, a1))
      {
        v18 = *a1;
        if (mDNS_LoggingEnabled == 1)
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSSetLocalAddressCacheEntry: Using XPC IPC calling out to Helper: ifindex is [%d] family is [%d]", v13, v14, v15, v16, v17, v9);
        v19 = xpc_dictionary_create(0, 0, 0);
        xpc_dictionary_set_uint64(v19, "HelperMode", 7uLL);
        xpc_dictionary_set_uint64(v19, "slace_ifindex", v9);
        xpc_dictionary_set_uint64(v19, "slace_family", v18);
        xpc_dictionary_set_data(v19, "slace_ip", a1 + 1, 0x10uLL);
        xpc_dictionary_set_data(v19, "slace_eth", a2, 6uLL);
        v25 = SendDict_ToServer(v19);
        if (v19)
          xpc_release(v19);
        if (mDNS_LoggingEnabled == 1)
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSSetLocalAddressCacheEntry: Using XPC IPC returning error_code %d", v20, v21, v22, v23, v24, v25);
        if (v25)
        {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Set local address cache entry for %s %#a %.6a failed: %d", v20, v21, v22, v23, v24, v10 + 3606);
        }
        else if (mDNS_LoggingEnabled == 1)
        {
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Set local address cache entry for %s %#a %.6a", v20, v21, v22, v23, v24, v10 + 3606);
        }
      }
      else if (mDNS_LoggingEnabled == 1)
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Don't need address cache entry for %s %#a %.6a", v13, v14, v15, v16, v17, v10 + 3606);
      }
    }
    else
    {
LABEL_6:
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformSetLocalAddressCacheEntry: Invalid interface index %p", a4, a5, a6, a7, a8, a3);
    }
  }
  else
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformSetLocalAddressCacheEntry: No InterfaceID specified", a4, a5, a6, a7, a8, a9);
  }
}

void mDNSPlatformSendKeepalive(uint64_t a1, uint64_t a2, unsigned __int16 *a3, unsigned __int16 *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const void *v20;
  const void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  xpc_object_t v29;
  int v30;
  char v31;
  __int128 v32;
  char v33[29];
  char v34;
  __int128 v35;
  _BYTE v36[29];

  v8 = a7;
  v9 = a6;
  v10 = a5;
  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformSendKeepalive called\n", (uint64_t)a4, a5, a6, a7, a8, v30);
  v20 = (const void *)(a1 + 4);
  v21 = (const void *)(a2 + 4);
  v22 = *a3;
  v23 = *a4;
  if (mDNS_LoggingEnabled == 1)
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSSendKeepalive: Using XPC IPC calling out to Helper: lport is[%d] rport is[%d] seq is[%d] ack is[%d] win is[%d]", v15, v16, v17, v18, v19, v22);
  memset(v36, 0, sizeof(v36));
  v35 = 0u;
  memset(v33, 0, sizeof(v33));
  v32 = 0u;
  v34 = 0;
  v31 = 0;
  inet_ntop(30, v20, &v34, 0x2Eu);
  inet_ntop(30, v21, &v31, 0x2Eu);
  if (mDNS_LoggingEnabled == 1)
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSSendKeepalive: Using XPC IPC calling out to Helper: sadd is %s, dadd is %s", v24, v25, v26, v27, v28, (int)&v34);
  v29 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_uint64(v29, "HelperMode", 8uLL);
  xpc_dictionary_set_data(v29, "send_keepalive_sadd", v20, 0x10uLL);
  xpc_dictionary_set_data(v29, "send_keepalive_dadd", v21, 0x10uLL);
  xpc_dictionary_set_uint64(v29, "send_keepalive_lport", v22);
  xpc_dictionary_set_uint64(v29, "send_keepalive_rport", v23);
  xpc_dictionary_set_uint64(v29, "send_keepalive_seq", v10);
  xpc_dictionary_set_uint64(v29, "send_keepalive_ack", v9);
  xpc_dictionary_set_uint64(v29, "send_keepalive_win", v8);
  SendDict_ToServer(v29);
  if (v29)
    xpc_release(v29);
}

uint64_t GetRemoteMacinternal(int a1, _DWORD *a2, uint64_t a3)
{
  int v5;
  int v6;
  int v7;
  int v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  int *v11;
  int *v12;
  uint64_t v13;
  NSObject *v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  ssize_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  unsigned __int8 *v28;
  _BYTE *v29;
  int v30;
  int *v31;
  NSObject *v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  NSObject *v39;
  size_t v40;
  _BYTE *v42;
  int v43;
  __int128 __src;
  _OWORD v46[8];
  _WORD __buf[4];
  uint64_t v48;
  int v49;
  int v50;
  _BYTE v51[28];
  int v52;

  v5 = 0;
  v6 = 0;
  __src = 0uLL;
  while (1)
  {
    memset(v46, 0, sizeof(v46));
    bzero(__buf, 0x25CuLL);
    v7 = socket(17, 3, 0);
    if (v7 < 0)
    {
      v12 = __error();
      v13 = *v12;
      v14 = mDNSLogCategory_Default;
      v15 = strerror(*v12);
      LogMsgWithLevel(v14, OS_LOG_TYPE_DEFAULT, "getMACAddress: Can not open the socket - %s", v16, v17, v18, v19, v20, v15);
      goto LABEL_24;
    }
    v8 = v7;
    v48 = 0x300000000;
    __buf[1] = 4357;
    v50 = 6368;
    if (a1 == 2)
    {
      v9 = 0;
      LOWORD(v46[0]) = 528;
      DWORD1(v46[0]) = *a2;
      *(_OWORD *)v51 = v46[0];
      v10 = (unsigned __int8 *)v46;
      v11 = (int *)&v51[16];
    }
    else
    {
      v10 = 0;
      if (a1 == 30)
      {
        LOWORD(v46[0]) = 7708;
        *(_OWORD *)((char *)v46 + 8) = *(_OWORD *)a2;
        *(_OWORD *)v51 = v46[0];
        *(_OWORD *)&v51[12] = *(_OWORD *)((char *)v46 + 12);
        v9 = (unsigned __int8 *)v46;
        v11 = &v52;
      }
      else
      {
        v9 = 0;
        v11 = (int *)v51;
      }
    }
    *(_WORD *)v11 = 4628;
    *(_QWORD *)((char *)v11 + 10) = 0;
    *(_QWORD *)((char *)v11 + 2) = 0;
    *((_WORD *)v11 + 9) = 0;
    __buf[0] = (char *)v11 - (char *)__buf + 20;
    if (write(v7, __buf, __buf[0]) < 0)
    {
      v31 = __error();
      v13 = *v31;
      v32 = mDNSLogCategory_Default;
      v33 = strerror(*v31);
      LogMsgWithLevel(v32, OS_LOG_TYPE_DEFAULT, "getMACAddress: writing to routing socket: %s", v34, v35, v36, v37, v38, v33);
      close(v8);
LABEL_24:
      if ((_DWORD)v13 != -1)
        return v13;
      goto LABEL_36;
    }
    while (1)
    {
      v21 = read(v8, __buf, 0x25CuLL);
      if (v21 < 1)
        break;
      if (v50 == 6368)
      {
        v27 = v49;
        if (v27 == getpid())
          goto LABEL_16;
      }
    }
    if (v21 < 0)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "getMACAddress: Read from routing socket failed", v22, v23, v24, v25, v26, v43);
LABEL_16:
    v28 = v51;
    if (a1 != 2)
    {
      v28 = v10;
      v9 = v51;
      if (a1 != 30)
      {
        v39 = mDNSLogCategory_Default;
        goto LABEL_28;
      }
    }
    v29 = &v51[v51[0]];
    if (v29)
      break;
    v39 = mDNSLogCategory_Default;
LABEL_28:
    LogMsgWithLevel(v39, OS_LOG_TYPE_DEFAULT, "getMACAddress: sdl is NULL for family %d", v22, v23, v24, v25, v26, a1);
LABEL_35:
    close(v8);
LABEL_36:
    if (v5 == 2)
      v40 = 4;
    else
      v40 = 16;
    memcpy(a2, &__src, v40);
    ++v6;
    a1 = v5;
    if (v6 == 5)
      return 0xFFFFFFFFLL;
  }
  v30 = v29[1];
  if (v30 == 30)
  {
    if (v9)
      __src = *(_OWORD *)&v9[*v9 + 8];
    else
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "getMACAddress: sin6 is NULL", v22, v23, v24, v25, v26, v43);
    v5 = 30;
    goto LABEL_35;
  }
  if (v30 == 2)
  {
    if (v28)
      LODWORD(__src) = *(_DWORD *)&v28[*v28 + 4];
    else
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "getMACAddress: sin is NULL", v22, v23, v24, v25, v26, v43);
    v5 = 2;
    goto LABEL_35;
  }
  v42 = &v29[v29[5]];
  *(_DWORD *)a3 = *((_DWORD *)v42 + 2);
  *(_WORD *)(a3 + 4) = *((_WORD *)v42 + 6);
  close(v8);
  return 0;
}

void mDNSPlatformGetRemoteMacAddr(int *a1)
{
  int v2;
  NSObject *v3;
  int v6;
  char *v7;
  char *v8;
  _OWORD *v9;
  unint64_t v10;
  int v11;
  uint64_t v12;
  _BYTE *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __int16 v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  NSObject *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned __int16 v33;
  uint64_t v34;
  _WORD *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unsigned __int16 *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  NSObject *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  NSObject *v54;
  uint64_t v55;
  __int16 v56;
  int v57;
  __int16 v58;
  int v59;
  unsigned __int16 v60;
  _QWORD v61[2];
  int v62;
  __int16 v63;
  unsigned int v64;
  unsigned int v65;
  unsigned int v66;
  int v67;
  int v68;
  __int16 v69;
  uint64_t v70;
  uint64_t v71;
  int v72;
  uint64_t v73;
  uint64_t v74;
  int v75;
  __int128 v76;
  uint8_t buf[16];
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;

  v2 = *a1;
  v3 = mDNSLogCategory_NAT;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
      goto LABEL_11;
    *(_WORD *)buf = 0;
  }
  else
  {
    v3 = mDNSLogCategory_NAT_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
      goto LABEL_11;
    *(_WORD *)buf = 0;
  }
  _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "mDNSPlatformGetRemoteMacAddr calling mDNSGet_RemoteMAC", buf, 2u);
LABEL_11:
  if (v2 == 4)
    v6 = 2;
  else
    v6 = 30;
  v57 = 0;
  v58 = 0;
  v76 = *(_OWORD *)(a1 + 1);
  if (!GetRemoteMacinternal(v6, &v76, (uint64_t)&v57))
  {
    v7 = (char *)malloc_type_calloc(1uLL, 0x28uLL, 0xF1748037uLL);
    if (!v7)
LABEL_56:
      __break(1u);
    v8 = v7;
    v9 = a1 + 1;
    v10 = (unint64_t)(v7 + 20);
    snprintf(v7 + 20, 0x12uLL, "%02x:%02x:%02x:%02x:%02x:%02x", v57, BYTE1(v57), BYTE2(v57), HIBYTE(v57), v58, HIBYTE(v58));
    if (v2 == 4)
      v11 = 4;
    else
      v11 = 6;
    *(_DWORD *)v8 = v11;
    *(_OWORD *)(v8 + 4) = *v9;
    v12 = xmmword_10015BF10;
    for (qword_10015BF28 = xmmword_10015BF10; v12; qword_10015BF28 = v12)
    {
      if (!*(_DWORD *)(v12 + 126) && *(_WORD *)(v12 + 12) == 10)
      {
        v13 = *(_BYTE **)(v12 + 40);
        v14 = *v13 ? *v13 + 1 : 0;
        if (SameDomainLabelPointer(&v13[v14], "\n_keepalive"))
        {
          v61[0] = 0;
          v61[1] = 0;
          v62 = 0;
          getKeepaliveRaddr((uint64_t)mDNSStorage, v12, (uint64_t)v61);
          if (mDNSSameAddress((int *)v61, v8))
          {
            v60 = 0;
            v59 = 0;
            if (GetValueForMACAddr(v10, (unint64_t)(v8 + 38), (uint64_t)&v59, v15, v16, v17, v18, v19))
            {
              if (HIWORD(v59) | (unsigned __int16)v59 | v60)
              {
                v73 = 0;
                v74 = 0;
                v75 = 0;
                v70 = 0;
                v71 = 0;
                v72 = 0;
                v69 = 0;
                v67 = 0;
                v68 = 0;
                v66 = 0;
                v91 = 0u;
                v92 = 0u;
                v89 = 0u;
                v90 = 0u;
                v87 = 0u;
                v88 = 0u;
                v85 = 0u;
                v86 = 0u;
                v83 = 0u;
                v84 = 0u;
                v81 = 0u;
                v82 = 0u;
                v79 = 0u;
                v80 = 0u;
                *(_OWORD *)buf = 0u;
                v78 = 0u;
                mDNS_ExtractKeepaliveInfo(v12, &v66, &v73, &v70, (uint64_t)&v68, &v65, &v64, (_WORD *)&v67 + 1, &v67, &v63);
                if (v66
                  && v73 != 4
                  && ((_DWORD)v73 != 6 || v74 | HIDWORD(v74) | v75 | HIDWORD(v73))
                  && v70 != 4
                  && ((_DWORD)v70 != 6 || v71 | HIDWORD(v71) | v72 | HIDWORD(v70))
                  && HIWORD(v67)
                  && (_WORD)v67)
                {
                  v20 = mDNS_snprintf(&buf[1]);
                  if (v20 == 255)
                  {
                    v21 = mDNSLogCategory_Default;
                    GetRRDisplayString_rdb((unsigned __int8 *)(v12 + 8), (unsigned __int16 *)(*(_QWORD *)(v12 + 48) + 4), word_100164580);
                    LogMsgWithLevel(v21, OS_LOG_TYPE_DEFAULT, "UpdateKeepaliveRData: could not allocate memory %s", v22, v23, v24, v25, v26, (int)word_100164580);
                  }
                  else
                  {
                    buf[0] = v20 + 1;
                    v33 = v20 + 2;
                    if ((unsigned __int16)(v20 + 2) <= 0x108u)
                      v34 = 264;
                    else
                      v34 = (unsigned __int16)(v20 + 2);
                    v56 = v34;
                    v35 = malloc_type_malloc(v34 + 4, 0xA172743EuLL);
                    if (!v35)
                      goto LABEL_56;
                    v55 = (uint64_t)v35;
                    *v35 = v56;
                    memcpy(v35 + 2, buf, v33);
                    v41 = v12 + 8;
                    v42 = *(unsigned __int16 **)(v12 + 48);
                    if (v42 != (unsigned __int16 *)(v12 + 908))
                    {
                      if (mDNS_LoggingEnabled == 1)
                      {
                        v54 = mDNSLogCategory_Default;
                        GetRRDisplayString_rdb((unsigned __int8 *)(v12 + 8), v42 + 2, word_100164580);
                        LogMsgWithLevel(v54, OS_LOG_TYPE_DEFAULT, "UpdateKeepaliveRData: Freed allocated memory for keep alive packet: %s ", v43, v44, v45, v46, v47, (int)word_100164580);
                        v41 = v12 + 8;
                        v42 = *(unsigned __int16 **)(v12 + 48);
                      }
                      if (v42)
                      {
                        free(v42);
                        v41 = v12 + 8;
                      }
                    }
                    SetNewRData(v41, v55, v33, v36, v37, v38, v39, v40);
                    if (mDNS_LoggingEnabled == 1)
                    {
                      v48 = mDNSLogCategory_Default;
                      GetRRDisplayString_rdb((unsigned __int8 *)(v12 + 8), (unsigned __int16 *)(*(_QWORD *)(v12 + 48) + 4), word_100164580);
                      LogMsgWithLevel(v48, OS_LOG_TYPE_DEFAULT, "UpdateKeepaliveRData: successfully updated the record %s", v49, v50, v51, v52, v53, (int)word_100164580);
                    }
                  }
                }
                else
                {
                  v27 = mDNSLogCategory_Default;
                  GetRRDisplayString_rdb((unsigned __int8 *)(v12 + 8), (unsigned __int16 *)(*(_QWORD *)(v12 + 48) + 4), word_100164580);
                  LogMsgWithLevel(v27, OS_LOG_TYPE_DEFAULT, "UpdateKeepaliveRData: not a valid record %s for keepalive %#a:%d %#a:%d", v28, v29, v30, v31, v32, (int)word_100164580);
                }
              }
            }
          }
        }
      }
      v12 = *(_QWORD *)v12;
    }
    free(v8);
  }
}

const __CFNumber *DictionaryIsEnabled(const __CFDictionary *a1)
{
  const __CFNumber *result;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int valuePtr;

  result = (const __CFNumber *)CFDictionaryGetValue(a1, CFSTR("Enabled"));
  if (result)
  {
    valuePtr = 0;
    if (CFNumberGetValue(result, kCFNumberSInt32Type, &valuePtr))
    {
      return (const __CFNumber *)(valuePtr != 0);
    }
    else
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ERROR: DictionaryIsEnabled - CFNumberGetValue", v2, v3, v4, v5, v6, v7);
      return 0;
    }
  }
  return result;
}

void mDNSPlatformUpdateDNSStatus(uint64_t a1)
{
  int v1;
  uint64_t v2;
  int v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!*(_BYTE *)(a1 + 354) && *(_WORD *)(a1 + 340) && !*(_BYTE *)(a1 + 355))
  {
    v1 = *(unsigned __int16 *)(a1 + 342);
    if (v1 == 1)
    {
      v2 = mDNSStorage[0];
      *(_BYTE *)(mDNSStorage[0] + 688) = 0;
    }
    else
    {
      v2 = mDNSStorage[0];
      if (v1 == 28)
        *(_BYTE *)(mDNSStorage[0] + 689) = 0;
    }
    v3 = *(unsigned __int8 *)(v2 + 688);
    if (*(_BYTE *)(v2 + 688))
    {
      if (!*(_BYTE *)(v2 + 689) && (mDNS_LoggingEnabled & 1) != 0)
        goto LABEL_14;
    }
    else if (mDNS_LoggingEnabled == 1)
    {
LABEL_14:
      v4 = mDNSLogCategory_Default;
      DNSTypeName(v1);
      LogMsgWithLevel(v4, OS_LOG_TYPE_DEFAULT, "mDNSPlatformUpdateDNSStatus: Trigger needed v4 %d, v6 %d, question %##s (%s)", v5, v6, v7, v8, v9, v3);
    }
  }
}

void mDNSPlatformTriggerDNSRetry(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  int v11;
  int v12;
  BOOL v13;
  char v14;
  uint64_t v15;
  int v16;
  NSObject *v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  NSObject *v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;

  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNSPlatformTriggerDNSRetry", 5029);
  v11 = dword_100158E08;
  v12 = *(_DWORD *)(mDNSStorage[0] + 692);
  if (v12)
    v13 = dword_100158E08 - v12 <= 179999;
  else
    v13 = 0;
  if (v13)
  {
    mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNSPlatformTriggerDNSRetry", 5038);
    return;
  }
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNSPlatformTriggerDNSRetry", 5041);
  if (a1 && !*(_BYTE *)(a1 + 354) && *(_WORD *)(a1 + 340))
  {
    v14 = 1;
    if (!*(_BYTE *)(a1 + 355))
    {
      v15 = mDNSStorage[0];
      v16 = *(unsigned __int8 *)(mDNSStorage[0] + 688);
      *(_BYTE *)(mDNSStorage[0] + 688) = 1;
      if (!v16)
      {
        if (mDNS_LoggingEnabled == 1)
        {
          v17 = mDNSLogCategory_Default;
          v18 = v11 - *(_DWORD *)(v15 + 692);
          DNSTypeName(*(unsigned __int16 *)(a1 + 342));
          LogMsgWithLevel(v17, OS_LOG_TYPE_DEFAULT, "mDNSPlatformTriggerDNSRetry: Triggering because of IPv4, last trigger %d ms, %##s (%s)", v19, v20, v21, v22, v23, v18);
        }
        v14 = 0;
      }
    }
  }
  else
  {
    v14 = 1;
  }
  if (!a2
    || *(_BYTE *)(a2 + 354)
    || !*(_WORD *)(a2 + 340)
    || *(_BYTE *)(a2 + 355)
    || (v24 = mDNSStorage[0], v25 = *(unsigned __int8 *)(mDNSStorage[0] + 689),
                              *(_BYTE *)(mDNSStorage[0] + 689) = 1,
                              v25))
  {
    if ((v14 & 1) != 0)
      return;
  }
  else if (mDNS_LoggingEnabled == 1)
  {
    v26 = mDNSLogCategory_Default;
    v27 = v11 - *(_DWORD *)(v24 + 692);
    DNSTypeName(*(unsigned __int16 *)(a2 + 342));
    LogMsgWithLevel(v26, OS_LOG_TYPE_DEFAULT, "mDNSPlatformTriggerDNSRetry: Triggering because of IPv6, last trigger %d ms, %##s (%s)", v28, v29, v30, v31, v32, v27);
  }
  v33 = dns_configuration_copy();
  if (v33)
  {
    v39 = v33;
    mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNSPlatformTriggerDNSRetry", 5078);
    AckConfigd(v39);
    mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNSPlatformTriggerDNSRetry", 5080);
    dns_configuration_free(v39);
  }
  else
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformTriggerDNSRetry: ERROR!! configd did not return config", v34, v35, v36, v37, v38, a9);
  }
}

uint64_t AckConfigd(uint64_t a1)
{
  int v2;

  mDNS_VerifyLockState("Check Lock", 1, dword_100158DF8, dword_100158DFC, (uint64_t)"AckConfigd", 5004);
  if (dword_100158E08 <= 1)
    v2 = 1;
  else
    v2 = dword_100158E08;
  *(_DWORD *)(mDNSStorage[0] + 692) = v2;
  return _dns_configuration_ack(a1, "com.apple.mDNSResponder");
}

uint64_t UpdateSearchDomainHash(_MD5_CTX *a1, const char *a2, uint64_t a3)
{
  const char *v4;
  uint64_t v5;
  int v6;
  unsigned int v7;
  NSObject *v8;
  size_t v9;
  size_t v10;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  char *v15;
  char __s[8];
  uint64_t v17;

  *(_QWORD *)__s = 0;
  v17 = 0;
  if (a2)
    v4 = a2;
  else
    v4 = ".";
  v5 = a3 + 5;
  if ((unint64_t)(a3 + 5) < 6 && ((0x2Du >> v5) & 1) != 0)
    v6 = dword_100100898[v5];
  else
    v6 = a3;
  v7 = mDNS_snprintf(__s);
  v8 = mDNSLogCategory_State;
  if (v7 >= 0x10 && os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 67109120;
    LODWORD(v13) = v6;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "UpdateSearchDomainHash: mDNS_snprintf failed for scopeid %u", buf, 8u);
    v8 = mDNSLogCategory_State;
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136315394;
    v13 = v4;
    v14 = 2080;
    v15 = __s;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "UpdateSearchDomainHash: buf %s, ifid_buf %s", buf, 0x16u);
  }
  v9 = strlen(v4);
  MD5_Update(a1, v4, v9 + 1);
  v10 = strlen(__s);
  return MD5_Update(a1, __s, v10 + 1);
}

void ConfigResolvers(int *a1, uint64_t a2, int a3, int a4, _MD5_CTX *a5)
{
  uint64_t v5;
  int *v6;
  void **v7;
  int v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned __int8 *v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  _BOOL4 v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  __int128 *v35;
  __int128 *v36;
  uint64_t v37;
  _BOOL4 v38;
  __int128 *v39;
  __int128 *v40;
  NSObject *v41;
  const char *v42;
  uint32_t v43;
  NSObject *v44;
  const char *v45;
  uint32_t v46;
  char *v47;
  char *v48;
  char *v49;
  char *v50;
  uint64_t v51;
  unsigned __int8 *v52;
  _BYTE *appended;
  NSObject *v54;
  uint8_t *m;
  unsigned int v56;
  uint64_t v57;
  int v58;
  unsigned __int8 *v59;
  const char *v60;
  size_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  int v73;
  NSObject *v74;
  uint8_t *j;
  unsigned int v76;
  uint64_t v77;
  uint8_t *i;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t *v82;
  int v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  int v89;
  _QWORD *v90;
  _DWORD *v91;
  uint8_t *k;
  uint64_t v93;
  unsigned int v94;
  uint64_t v97;
  uint8_t v100[48];
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  uint8_t buf[16];
  _OWORD v115[2];
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  __int128 v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  __int128 v126;
  __int128 v127;
  __int128 v128;
  uint64_t v129;

  v5 = a2;
  if ((_DWORD)a2 == 2)
  {
    v7 = (void **)(a1 + 9);
    v6 = a1 + 8;
  }
  else if ((_DWORD)a2 == 1)
  {
    v7 = (void **)(a1 + 4);
    v6 = a1 + 3;
  }
  else
  {
    if ((_DWORD)a2)
      return;
    v6 = a1;
    v7 = (void **)(a1 + 1);
  }
  v8 = *v6;
  v9 = *v7;
  qsort(*v7, *v6, 8uLL, (int (__cdecl *)(const void *, const void *))compare_dns_configs);
  if (v8 >= 1)
  {
    v10 = 0;
    v97 = v8;
    while (1)
    {
      v11 = v9[v10];
      v12 = mDNSLogCategory_State;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
      {
        v18 = *(unsigned __int8 **)v11;
        v19 = *(_DWORD *)(v11 + 8);
        *(_DWORD *)buf = 67241219;
        *(_DWORD *)&buf[4] = v5;
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = v10;
        *(_WORD *)&buf[14] = 2160;
        *(_QWORD *)&v115[0] = 1752392040;
        WORD4(v115[0]) = 2085;
        *(_QWORD *)((char *)v115 + 10) = v18;
        WORD1(v115[1]) = 1024;
        DWORD1(v115[1]) = v19;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "ConfigResolvers -- scope type: %{public, mdnsresponder:dns_scope_type}d, resolver[%d]: {domain: %{sensitive, mask.hash}s, name server count: %d}", buf, 0x28u);
      }
      v20 = *(unsigned int *)(v11 + 64);
      if ((_DWORD)v20)
      {
        v21 = *(_QWORD *)mDNSStorage[0];
        if (*(_QWORD *)mDNSStorage[0])
        {
          while (!*(_QWORD *)(v21 + 3552) || *(_DWORD *)(v21 + 3720) != (_DWORD)v20)
          {
            v21 = *(_QWORD *)(v21 + 3680);
            if (!v21)
              goto LABEL_16;
          }
          v20 = *(_QWORD *)(v21 + 3552);
        }
        else
        {
LABEL_16:
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ConfigParseInterfaceID: interface specific index %d not found (interface may not be UP)", v13, v14, v15, v16, v17, *(_DWORD *)(v11 + 64));
        }
      }
      else
      {
        v20 = 0;
      }
      if (!a3)
        goto LABEL_73;
      v22 = v9;
      v23 = v9[v10];
      v24 = *((_QWORD *)a1 + 3);
      v127 = 0u;
      v128 = 0u;
      v125 = 0u;
      v126 = 0u;
      v123 = 0u;
      v124 = 0u;
      v121 = 0u;
      v122 = 0u;
      v119 = 0u;
      v120 = 0u;
      v117 = 0u;
      v118 = 0u;
      v115[1] = 0u;
      v116 = 0u;
      if (!(_DWORD)v5)
        v20 = 0;
      *(_OWORD *)buf = 0uLL;
      v115[0] = 0uLL;
      v25 = v5;
      if (v5 <= 1)
        break;
      v37 = mDNSLogCategory_State;
      v38 = os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT);
      if (v20)
      {
        if (!v38)
          goto LABEL_72;
        v39 = &xmmword_10015BF38;
        while (1)
        {
          v39 = *(__int128 **)v39;
          if (!v39)
            break;
          v40 = v39;
          if (*((_QWORD *)v39 + 444) == v20)
            goto LABEL_41;
        }
        v40 = 0;
LABEL_41:
        v47 = (char *)v40 + 3606;
        *(_DWORD *)v100 = 67240450;
        if (v39)
          v48 = v47;
        else
          v48 = 0;
        *(_DWORD *)&v100[4] = 2;
        *(_WORD *)&v100[8] = 2082;
        *(_QWORD *)&v100[10] = v48;
        v41 = v37;
        v42 = "ConfigSearchDomains: Ignoring search domains for interface -- scope type: %{public, mdnsresponder:dns_scop"
              "e_type}d, ifname: %{public}s";
        v43 = 18;
      }
      else
      {
        if (!v38)
          goto LABEL_72;
        *(_DWORD *)v100 = 67240192;
        *(_DWORD *)&v100[4] = 2;
        v41 = v37;
        v42 = "ConfigSearchDomains: Ignoring search domains for interface -- scope type: %{public, mdnsresponder:dns_scope_type}d";
        v43 = 8;
      }
      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, v42, v100, v43);
LABEL_72:
      v5 = v25;
      v9 = v22;
      if (!a4)
        goto LABEL_77;
LABEL_73:
      if (*(_WORD *)(v11 + 20) != 5353 && *(_DWORD *)(v11 + 8))
        goto LABEL_77;
      v60 = *(const char **)(v11 + 48);
      if (!v60)
        goto LABEL_77;
      v61 = strlen(*(const char **)(v11 + 48));
      if (strncmp(v60, "mdns", v61))
        goto LABEL_77;
      v127 = 0u;
      v128 = 0u;
      v125 = 0u;
      v126 = 0u;
      v123 = 0u;
      v124 = 0u;
      v121 = 0u;
      v122 = 0u;
      v119 = 0u;
      v120 = 0u;
      v117 = 0u;
      v118 = 0u;
      v116 = 0u;
      *(_OWORD *)buf = 0u;
      memset(v115, 0, sizeof(v115));
      if (!AppendDNSNameString(buf, *(unsigned __int8 **)v11, v62, v63, v64, v65, v66, v67))
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ConfigNonUnicastResolver: config->resolver bad domain %s", v68, v69, v70, v71, v72, *(_QWORD *)v11);
        goto LABEL_77;
      }
      v73 = *(_DWORD *)(v11 + 56);
      v74 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEBUG))
        {
          for (i = buf; ; i += v79 + 1)
          {
            LOWORD(v76) = 257;
            if (i >= (uint8_t *)&v129 || !i)
              break;
            v79 = *i;
            if (v79 > 0x3F)
            {
              LOWORD(v76) = 257;
              goto LABEL_102;
            }
            if (!*i)
            {
              v76 = (_DWORD)i - buf + 1;
              goto LABEL_102;
            }
          }
          goto LABEL_102;
        }
      }
      else
      {
        v74 = mDNSLogCategory_Default_redacted;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEBUG))
        {
          for (j = buf; ; j += v77 + 1)
          {
            LOWORD(v76) = 257;
            if (j >= (uint8_t *)&v129 || !j)
              break;
            v77 = *j;
            if (v77 > 0x3F)
            {
              LOWORD(v76) = 257;
              break;
            }
            if (!*j)
            {
              v76 = (_DWORD)j - buf + 1;
              break;
            }
          }
LABEL_102:
          *(_DWORD *)v100 = 68158466;
          *(_DWORD *)&v100[4] = (unsigned __int16)v76;
          *(_WORD *)&v100[8] = 2098;
          *(_QWORD *)&v100[10] = buf;
          *(_WORD *)&v100[18] = 2048;
          *(_QWORD *)&v100[20] = 0;
          *(_WORD *)&v100[28] = 1024;
          *(_DWORD *)&v100[30] = v73;
          _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEBUG, "mDNS_AddMcastResolver: Adding %{public, mdnsresponder:domain_name}.*P, InterfaceID %p, timeout %u", v100, 0x22u);
        }
      }
      mDNS_VerifyLockState("Check Lock", 1, dword_100158DF8, dword_100158DFC, (uint64_t)"mDNS_AddMcastResolver", 14056);
      v80 = qword_10015BF58;
      if (!qword_10015BF58)
      {
        v82 = (uint64_t *)((char *)&dword_100158DF8 + &loc_100003160);
LABEL_115:
        v90 = malloc_type_calloc(1uLL, 0x118uLL, 0xF1748037uLL);
        if (!v90)
          __break(1u);
        *v82 = (uint64_t)v90;
        v90[1] = 0;
        v91 = (_DWORD *)*v82;
        v91[4] = 2;
        v91[69] = v73;
        for (k = buf; k < (uint8_t *)&v129; k += v93 + 1)
        {
          if (!k)
            break;
          v93 = *k;
          if (v93 > 0x3F)
            break;
          if (!*k)
          {
            v94 = (_DWORD)k - buf + 1;
            if ((unsigned __int16)v94 <= 0x100u)
            {
              memcpy(v91 + 5, buf, (unsigned __int16)v94);
              goto LABEL_125;
            }
            break;
          }
        }
        *((_BYTE *)v91 + 20) = 0;
LABEL_125:
        *(_QWORD *)*v82 = 0;
        goto LABEL_77;
      }
      v81 = 0;
      v82 = &qword_10015BF58;
      do
      {
        if (*(_QWORD *)(v80 + 8) || (v83 = SameDomainNameBytes((_BYTE *)(v80 + 20), buf), v80 = *v82, !v83))
        {
          v82 = (uint64_t *)v80;
        }
        else
        {
          v89 = *(_DWORD *)(v80 + 16);
          if ((v89 & 1) == 0)
          {
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Note: Mcast Resolver domain %##s (%p) registered more than once", v84, v85, v86, v87, v88, (int)buf);
            v80 = *v82;
            v89 = *(_DWORD *)(*v82 + 16);
          }
          *(_DWORD *)(v80 + 16) = v89 & 0xFFFFFFFE;
          *v82 = *(_QWORD *)v80;
          *(_QWORD *)v80 = 0;
          v81 = v80;
        }
        v80 = *v82;
      }
      while (*v82);
      if (!v81)
        goto LABEL_115;
      *v82 = v81;
LABEL_77:
      if (++v10 == v97)
        return;
    }
    v26 = *(_DWORD *)(v23 + 24);
    if (v26 < 1)
      goto LABEL_72;
    v27 = mDNSLogCategory_State;
    v28 = os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT);
    if (v20)
    {
      if (!v28)
        goto LABEL_52;
      v35 = &xmmword_10015BF38;
      while (1)
      {
        v35 = *(__int128 **)v35;
        if (!v35)
          break;
        v36 = v35;
        if (*((_QWORD *)v35 + 444) == v20)
          goto LABEL_47;
      }
      v36 = 0;
LABEL_47:
      v49 = (char *)v36 + 3606;
      *(_DWORD *)v100 = 67109890;
      if (v35)
        v50 = v49;
      else
        v50 = 0;
      *(_DWORD *)&v100[4] = v26;
      *(_WORD *)&v100[8] = 1026;
      *(_DWORD *)&v100[10] = v25;
      *(_WORD *)&v100[14] = 2048;
      *(_QWORD *)&v100[16] = v24;
      *(_WORD *)&v100[24] = 2082;
      *(_QWORD *)&v100[26] = v50;
      v44 = v27;
      v45 = "ConfigSearchDomains: configuring search domains -- count: %d, scope type: %{public, mdnsresponder:dns_scope_"
            "type}d, generation: %llu, ifname: %{public}s";
      v46 = 34;
    }
    else
    {
      if (!v28)
        goto LABEL_52;
      *(_DWORD *)v100 = 67109632;
      *(_DWORD *)&v100[4] = v26;
      *(_WORD *)&v100[8] = 1026;
      *(_DWORD *)&v100[10] = v25;
      *(_WORD *)&v100[14] = 2048;
      *(_QWORD *)&v100[16] = v24;
      v44 = v27;
      v45 = "ConfigSearchDomains: configuring search domains -- count: %d, scope type: %{public, mdnsresponder:dns_scope_"
            "type}d, generation: %llu";
      v46 = 24;
    }
    _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, v45, v100, v46);
LABEL_52:
    if (*(int *)(v23 + 24) >= 1)
    {
      v51 = 0;
      do
      {
        v52 = *(unsigned __int8 **)(*(_QWORD *)(v23 + 28) + 8 * v51);
        buf[0] = 0;
        appended = AppendDNSNameString(buf, v52, v29, v30, v31, v32, v33, v34);
        v54 = mDNSLogCategory_State;
        if (appended)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT))
          {
            for (m = buf; ; m += v57 + 1)
            {
              LOWORD(v56) = 257;
              if (m >= (uint8_t *)&v129 || !m)
                break;
              v57 = *m;
              if (v57 > 0x3F)
              {
                LOWORD(v56) = 257;
                break;
              }
              if (!*m)
              {
                v56 = (_DWORD)m - buf + 1;
                break;
              }
            }
            *(_DWORD *)v100 = 141558531;
            *(_QWORD *)&v100[4] = 1752392040;
            *(_WORD *)&v100[12] = 1040;
            *(_DWORD *)&v100[14] = (unsigned __int16)v56;
            *(_WORD *)&v100[18] = 2101;
            *(_QWORD *)&v100[20] = buf;
            _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "ConfigSearchDomains -- search domain: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P", v100, 0x1Cu);
          }
          UpdateSearchDomainHash(a5, *(const char **)(*(_QWORD *)(v23 + 28) + 8 * v51), v20);
          v112 = 0u;
          v113 = 0u;
          v110 = 0u;
          v111 = 0u;
          v108 = 0u;
          v109 = 0u;
          v106 = 0u;
          v107 = 0u;
          v104 = 0u;
          v105 = 0u;
          v102 = 0u;
          v103 = 0u;
          v101 = 0u;
          memset(v100, 0, sizeof(v100));
          v59 = *(unsigned __int8 **)(*(_QWORD *)(v23 + 28) + 8 * v51);
          if (v59 && AppendDNSNameString(v100, v59, v29, v30, v31, v32, v33, v34) && v100[0])
            mDNS_AddSearchDomain(v100, v20);
        }
        else if (os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_ERROR))
        {
          v58 = *(_DWORD *)(v23 + 8);
          *(_DWORD *)v100 = 67109376;
          *(_DWORD *)&v100[4] = v51;
          *(_WORD *)&v100[8] = 1024;
          *(_DWORD *)&v100[10] = v58;
          _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_ERROR, "ConfigSearchDomains: An invalid search domain was detected -- index: %d, name server count: %d", v100, 0xEu);
        }
        ++v51;
      }
      while (v51 < *(int *)(v23 + 24));
    }
    goto LABEL_72;
  }
}

uint64_t compare_dns_configs(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;
  BOOL v4;
  _BOOL4 v5;

  v2 = *(_DWORD *)(*(_QWORD *)a1 + 60);
  v3 = *(_DWORD *)(*(_QWORD *)a2 + 60);
  v4 = v2 >= v3;
  v5 = v2 != v3;
  if (v4)
    return v5;
  else
    return 0xFFFFFFFFLL;
}

void mDNSPlatformDynDNSHostNameStatusChanged(unsigned __int8 *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  unsigned __int8 *v10;
  unsigned __int8 v11;
  unsigned __int8 v13;
  CFStringRef v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  CFTypeRef v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  CFDictionaryRef v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  CFDictionaryRef v33;
  int v34;
  int valuePtr;
  CFTypeRef cf;
  CFTypeRef v37;
  void *values;
  void *keys;
  CFTypeRef v40;
  void *v41;
  char cStr;
  uint64_t v43;

  valuePtr = a2;
  if (mDNS_LoggingEnabled == 1)
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformDynDNSHostNameStatusChanged %d %##s", a4, a5, a6, a7, a8, a2);
  bzero(&cStr, 0x3F1uLL);
  ConvertDomainNameToCString_withescape(a1, (unsigned __int8 *)&cStr);
  LOBYTE(v9) = cStr;
  if (cStr)
  {
    v10 = (unsigned __int8 *)&v43;
    do
    {
      v11 = __tolower((char)v9);
      v9 = *v10;
      if (v11 == 46 && v9 == 0)
        v13 = 0;
      else
        v13 = v11;
      *(v10++ - 1) = v13;
    }
    while (v9);
  }
  v41 = CFSTR("HostNames");
  v14 = CFStringCreateWithCString(0, &cStr, 0x8000100u);
  keys = CFSTR("Status");
  v40 = v14;
  if (!v14)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SetDDNSNameStatus: CFStringCreateWithCString(%s) failed", v15, v16, v17, v18, v19, (int)&cStr);
    return;
  }
  v20 = v14;
  values = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  if (!values)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SetDDNSNameStatus: CFNumberCreate(%d) failed", v21, v22, v23, v24, v25, valuePtr);
LABEL_28:
    CFRelease(v20);
    return;
  }
  v37 = CFDictionaryCreate(0, (const void **)&keys, (const void **)&values, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v37)
  {
    cf = CFDictionaryCreate(0, &v40, &v37, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (cf)
    {
      v26 = CFDictionaryCreate(0, (const void **)&v41, &cf, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (v26)
      {
        v33 = v26;
        mDNSDynamicStoreSetConfig(2, v26, v27, v28, v29, v30, v31, v32, v34);
        CFRelease(v33);
      }
      if (cf)
      {
        CFRelease(cf);
        cf = 0;
      }
    }
    if (v37)
    {
      CFRelease(v37);
      v37 = 0;
    }
  }
  if (values)
  {
    CFRelease(values);
    values = 0;
  }
  v20 = v40;
  if (v40)
    goto LABEL_28;
}

uint64_t SupportsInNICProxy(uint64_t a1)
{
  NSObject *v2;
  uint8_t *v4;
  __int16 v6;
  __int16 v7;

  if (UseInternalSleepProxy)
    return CheckInterfaceSupport(a1, "mDNS_KEY");
  v2 = mDNSLogCategory_SPS;
  if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_SPS != mDNSLogCategory_State)
  {
    v2 = mDNSLogCategory_SPS_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_SPS_redacted, OS_LOG_TYPE_DEFAULT))
      return 0;
    v6 = 0;
    v4 = (uint8_t *)&v6;
    goto LABEL_12;
  }
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_SPS, OS_LOG_TYPE_DEFAULT))
  {
    v7 = 0;
    v4 = (uint8_t *)&v7;
LABEL_12:
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "SupportsInNICProxy: Internal Sleep Proxy is disabled", v4, 2u);
  }
  return 0;
}

uint64_t GetPortArray(int a1, unsigned __int16 *a2)
{
  const char *v2;
  uint64_t *v3;
  uint64_t v5;
  _BYTE *v6;
  uint64_t v7;
  _BYTE *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int16 *v13;
  int v14;

  if (a1 == 1)
    v2 = "\x04_udp";
  else
    v2 = "\x04_tcp";
  v3 = (uint64_t *)xmmword_10015BF10;
  if (!(_QWORD)xmmword_10015BF10)
    return 0;
  v5 = 0;
  do
  {
    if (*((_WORD *)v3 + 6) == 33)
    {
      v6 = (_BYTE *)v3[5];
      v7 = *v6 ? *v6 + 1 : 0;
      v8 = &v6[v7];
      v9 = *v8 ? *v8 + 1 : 0;
      if (SameDomainLabelPointer(&v8[v9], v2))
      {
        if (a2)
        {
          v10 = *(unsigned __int16 *)(v3[6] + 8);
          if ((_DWORD)v5)
          {
            v11 = v5;
            v12 = v5;
            v13 = a2;
            while (1)
            {
              v14 = *v13++;
              if (v14 == v10)
                break;
              if (!--v12)
                goto LABEL_22;
            }
          }
          else
          {
            v11 = 0;
LABEL_22:
            v5 = (v5 + 1);
            a2[v11] = v10;
          }
        }
        else
        {
          v5 = (v5 + 1);
        }
      }
    }
    v3 = (uint64_t *)*v3;
  }
  while (v3);
  return v5;
}

uint64_t CountProxyRecords(_DWORD *a1)
{
  uint64_t *v1;
  uint64_t v3;
  _BYTE *v4;
  _BYTE *v5;
  unsigned __int16 v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  *a1 = 0;
  v1 = (uint64_t *)xmmword_10015BF10;
  if ((_QWORD)xmmword_10015BF10)
  {
    v3 = 0;
    while ((*((_BYTE *)v1 + 123) & 1) != 0
         || *((unsigned __int8 *)v1 + 8) < 2u
         || v1[4]
         || !*((_BYTE *)v1 + 122) && !IsLocalDomain((_BYTE *)v1[5]))
    {
LABEL_22:
      v1 = (uint64_t *)*v1;
      if (!v1)
        return v3;
    }
    v4 = (_BYTE *)v1[5];
    v5 = v4;
    if (v4 == (_BYTE *)-256)
      goto LABEL_12;
LABEL_9:
    v6 = 257;
    if (v5 < v4 + 256 && v5)
    {
      do
      {
        v7 = *v5;
        if (v7 > 0x3F)
          break;
        if (!*v5)
        {
          v6 = (_WORD)v5 - (_WORD)v4 + 1;
          goto LABEL_19;
        }
        v5 += v7 + 1;
        if (v4 != (_BYTE *)-256)
          goto LABEL_9;
LABEL_12:
        ;
      }
      while (v5);
      v6 = 257;
    }
LABEL_19:
    *a1 += *((unsigned __int16 *)v1 + 11) + v6 + 10;
    if (mDNS_LoggingEnabled == 1)
    {
      v8 = mDNSLogCategory_Default;
      GetRRDisplayString_rdb((unsigned __int8 *)v1 + 8, (unsigned __int16 *)(v1[6] + 4), word_100164580);
      LogMsgWithLevel(v8, OS_LOG_TYPE_DEFAULT, "CountProxyRecords: %3u size %5u total %5u %s", v9, v10, v11, v12, v13, v3);
    }
    v3 = (v3 + 1);
    goto LABEL_22;
  }
  return 0;
}

void GetProxyRecords(unint64_t a1, _DWORD *a2, uint64_t a3, unsigned int *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v8;
  unint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  unint64_t v14;
  unsigned int v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  NSObject *v26;
  _WORD *v27;

  v8 = a4;
  v10 = a1 + 12;
  v11 = *a2;
  *(_DWORD *)a1 = 0;
  *(_QWORD *)(a1 + 4) = 0;
  v12 = (uint64_t *)xmmword_10015BF10;
  if ((_QWORD)xmmword_10015BF10)
  {
    v13 = a3;
    v14 = a1;
    v15 = 0;
    v16 = v10 + v11;
    v27 = (_WORD *)(a1 + 8);
    v17 = a1 + 12;
    do
    {
      if ((*((_BYTE *)v12 + 123) & 1) == 0
        && *((unsigned __int8 *)v12 + 8) >= 2u
        && !v12[4]
        && (*((_BYTE *)v12 + 122) || IsLocalDomain((_BYTE *)v12[5])))
      {
        *(_QWORD *)(v13 + 8 * v15) = v17;
        if ((v12[1] & 0x32) != 0)
          *((_WORD *)v12 + 7) |= 0x8000u;
        v17 = PutResourceRecordTTLWithLimit(v14, v17, v27, (uint64_t)(v12 + 1), *((unsigned int *)v12 + 4), v16, a7, a8);
        *((_WORD *)v12 + 7) &= ~0x8000u;
        if (mDNS_LoggingEnabled == 1)
        {
          v26 = mDNSLogCategory_Default;
          GetRRDisplayString_rdb((unsigned __int8 *)v12 + 8, (unsigned __int16 *)(v12[6] + 4), word_100164580);
          v13 = a3;
          v8 = a4;
          v14 = a1;
          LogMsgWithLevel(v26, OS_LOG_TYPE_DEFAULT, "GetProxyRecords: %3d start %p end %p size %5d total %5d %s", v18, v19, v20, v21, v22, v15);
        }
        ++v15;
      }
      v12 = (uint64_t *)*v12;
    }
    while (v12);
  }
  else
  {
    v15 = 0;
    LODWORD(v17) = a1 + 12;
  }
  *a2 = v17 - v10;
  if (v8)
    *v8 = v15;
}

uint64_t scalarSameDomainLabel(_BYTE *a1, unsigned __int8 *a2)
{
  unsigned int v2;
  unsigned __int8 *v3;
  unsigned __int8 *v4;
  int v5;
  int v6;
  int v7;
  int v8;

  v2 = *a1;
  if (v2 <= 0x3F && v2 == *a2)
  {
    if (!*a1)
      return 1;
    v3 = a1 + 1;
    v4 = a2 + 1;
    while (1)
    {
      v6 = *v3++;
      v5 = v6;
      v8 = *v4++;
      v7 = v8;
      if ((v5 - 65) < 0x1A)
        LOBYTE(v5) = v5 + 32;
      if ((v7 - 65) < 0x1A)
        LOBYTE(v7) = v7 + 32;
      if (v5 != v7)
        break;
      if (!--v2)
        return 1;
    }
  }
  return 0;
}

uint64_t vectorSameDomainLabel(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int8x8_t *v2;
  unsigned int v3;
  unsigned int v4;
  int8x8_t *v5;
  int8x16_t v6;
  int8x16_t v7;
  int8x16_t v8;
  uint32x2_t v9;
  uint64_t v10;
  unsigned int v11;
  int v12;

  v4 = *a1;
  v2 = (int8x8_t *)(a1 + 1);
  v3 = v4;
  if (v4 < 0x40)
  {
    if (v3 == *a2)
    {
      v5 = (int8x8_t *)(a2 + 1);
      if (v3 < 0x10)
      {
LABEL_8:
        if (v3 < 8)
          goto LABEL_11;
        while (1)
        {
          v9 = (uint32x2_t)vceq_s8(vadd_s8(vand_s8(vcgt_s8(vadd_s8(*v2, (int8x8_t)0x2525252525252525), (int8x8_t)0x6565656565656565), (int8x8_t)0x2020202020202020), *v2), vadd_s8(vand_s8(vcgt_s8(vadd_s8(*v5, (int8x8_t)0x2525252525252525), (int8x8_t)0x6565656565656565), (int8x8_t)0x2020202020202020), *v5));
          if (vpmin_u32(v9, v9).u32[0] != -1)
            break;
          ++v5;
          ++v2;
          v3 -= 8;
          if (v3 <= 7)
          {
LABEL_11:
            while (v3)
            {
              v11 = v2->u8[0];
              v2 = (int8x8_t *)((char *)v2 + 1);
              v10 = v11;
              v12 = v5->u8[0];
              v5 = (int8x8_t *)((char *)v5 + 1);
              --v3;
              if ((upper_to_lower_case_table[v10] + v10) != (upper_to_lower_case_table[v12]
                                                                                              + v12))
                return 0;
            }
            return 1;
          }
        }
      }
      else
      {
        v6.i64[0] = 0x2525252525252525;
        v6.i64[1] = 0x2525252525252525;
        v7.i64[0] = 0x6565656565656565;
        v7.i64[1] = 0x6565656565656565;
        v8.i64[0] = 0x2020202020202020;
        v8.i64[1] = 0x2020202020202020;
        while (vminvq_u32((uint32x4_t)vceqq_s8(vaddq_s8(vandq_s8(vcgtq_s8(vaddq_s8(*(int8x16_t *)v2->i8, v6), v7), v8), *(int8x16_t *)v2->i8), vaddq_s8(vandq_s8(vcgtq_s8(vaddq_s8(*(int8x16_t *)v5->i8, v6), v7), v8), *(int8x16_t *)v5->i8))) == -1)
        {
          v5 += 2;
          v2 += 2;
          v3 -= 16;
          if (v3 <= 0xF)
            goto LABEL_8;
        }
      }
    }
  }
  else
  {
    fwrite("v: Malformed label (too long)\n", 0x1EuLL, 1uLL, __stderrp);
  }
  return 0;
}

void FreeEtcHosts(uint64_t a1, uint64_t a2, int a3)
{
  NSObject *v5;
  _BYTE *v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  _BYTE *v12;

  if (a3 == -65792)
  {
    v5 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
      {
LABEL_10:
        v8 = (_BYTE *)(a1 + 47032);
        GetRRDisplayString_rdb((unsigned __int8 *)(a2 + 8), (unsigned __int16 *)(*(_QWORD *)(a2 + 48) + 4), v8);
        v9 = 141558275;
        v10 = 1752392040;
        v11 = 2085;
        v12 = v8;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "FreeEtcHosts: %{sensitive, mask.hash}s", (uint8_t *)&v9, 0x16u);
LABEL_12:
        free((void *)a2);
        return;
      }
    }
    else
    {
      v5 = mDNSLogCategory_NAT_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_10;
    }
    if (!a2)
      return;
    goto LABEL_12;
  }
}

_BYTE *GetRandomUUIDLocalHostname(_BYTE *a1)
{
  _OWORD v3[4];

  memset(v3, 0, sizeof(v3));
  GetRandomUUIDLabel(v3);
  *a1 = 0;
  AppendDomainLabel(a1, (unsigned __int8 *)v3);
  return AppendLiteralLabelString(a1, "local");
}

void DynamicStoreReconnected(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;

  v3 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  v11 = mDNSPlatformRawTime(v3, v4, v5, v6, v7, v8, v9, v10);
  *(_DWORD *)(mDNSStorage[0] + 680) = v11;
  if (mDNS_LoggingEnabled == 1)
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "DynamicStoreReconnected: Reconnected", v14, v15, v16, v17, v18, v26);
  SetLocalDomains(v11, v12, v13, v14, v15, v16, v17, v18, v26);
  if (*(_BYTE *)(a2 + 14424))
    mDNSPlatformDynDNSHostNameStatusChanged((unsigned __int8 *)(a2 + 14424), 1, v20, v21, v22, v23, v24, v25);
  KQueueUnlock((uint64_t)"DynamicStoreReconnected", v19, v20, v21, v22, v23, v24, v25);
}

void SetLocalDomains(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  __CFArray *Mutable;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __CFArray *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;

  Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
  if (Mutable)
  {
    v15 = Mutable;
    CFArrayAppendValue(Mutable, CFSTR("local"));
    CFArrayAppendValue(v15, CFSTR("254.169.in-addr.arpa"));
    CFArrayAppendValue(v15, CFSTR("8.e.f.ip6.arpa"));
    CFArrayAppendValue(v15, CFSTR("9.e.f.ip6.arpa"));
    CFArrayAppendValue(v15, CFSTR("a.e.f.ip6.arpa"));
    CFArrayAppendValue(v15, CFSTR("b.e.f.ip6.arpa"));
    mDNSDynamicStoreSetConfig(1, v15, v16, v17, v18, v19, v20, v21, v22);
    CFRelease(v15);
  }
  else
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SetLocalDomains: CFArrayCreateMutable failed", v10, v11, v12, v13, v14, a9);
  }
}

void PowerChanged(uint64_t a1, uint64_t a2, int a3, intptr_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  NSObject *v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;

  v7 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v7, v8, v9, v10, v11, v12, v13, v14);
  SystemWakeForNetworkAccess();
  *(_BYTE *)(a1 + 143) = 0;
  HIDWORD(v22) = a3;
  LODWORD(v22) = a3 + 536870336;
  switch((v22 >> 4))
  {
    case 0u:
      if (mDNS_LoggingEnabled == 1)
      {
        v23 = mDNSLogCategory_Default;
        v24 = "PowerChanged kIOMessageCanSystemPowerOff     (no action)";
        goto LABEL_26;
      }
      break;
    case 1u:
      if (mDNS_LoggingEnabled == 1)
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "PowerChanged kIOMessageSystemWillPowerOff", v17, v18, v19, v20, v21, v34);
      mDNSCoreMachineSleep(a1, 1);
      if (*(_BYTE *)(a1 + 141) == 2)
        mDNSMacOSXNetworkChanged(v25, v15, v16, v17, v18, v19, v20, v21);
      break;
    case 2u:
      if (mDNS_LoggingEnabled == 1)
      {
        v23 = mDNSLogCategory_Default;
        v24 = "PowerChanged kIOMessageSystemWillNotPowerOff (no action)";
        goto LABEL_26;
      }
      break;
    case 3u:
      if (mDNS_LoggingEnabled == 1)
      {
        v23 = mDNSLogCategory_Default;
        v24 = "PowerChanged kIOMessageCanSystemSleep";
        goto LABEL_26;
      }
      break;
    case 4u:
      if (mDNS_LoggingEnabled == 1)
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "PowerChanged kIOMessageSystemWillSleep", v17, v18, v19, v20, v21, v34);
      mDNSCoreMachineSleep(a1, 1);
      break;
    case 5u:
      if (mDNS_LoggingEnabled == 1)
      {
        v23 = mDNSLogCategory_Default;
        v24 = "PowerChanged kIOMessageSystemWillNotSleep    (no action)";
        goto LABEL_26;
      }
      break;
    case 0xCu:
      if (mDNS_LoggingEnabled == 1)
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "PowerChanged kIOMessageSystemHasPoweredOn", v17, v18, v19, v20, v21, v34);
      if (*(_BYTE *)(a1 + 141))
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "PowerChanged kIOMessageSystemHasPoweredOn: ERROR m->SleepState %d", v17, v18, v19, v20, v21, *(unsigned __int8 *)(a1 + 141));
        PowerOn((_DWORD *)a1);
      }
      mDNS_Lock_((unsigned int *)a1, (uint64_t)"PowerChanged", 6999);
      SetNetworkChanged(2000);
      mDNS_Unlock_(a1, (uint64_t)"PowerChanged", 7001);
      break;
    case 0xDu:
      if (mDNS_LoggingEnabled == 1)
      {
        v23 = mDNSLogCategory_Default;
        v24 = "PowerChanged kIOMessageSystemWillRestart     (no action)";
LABEL_26:
        LogMsgWithLevel(v23, OS_LOG_TYPE_DEFAULT, v24, v17, v18, v19, v20, v21, v34);
      }
      break;
    case 0xEu:
      if (mDNS_LoggingEnabled == 1)
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "PowerChanged kIOMessageSystemWillPowerOn", v17, v18, v19, v20, v21, v34);
      if (*(_BYTE *)(a1 + 141) != 2)
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "kIOMessageSystemWillPowerOn: ERROR m->SleepState %d", v17, v18, v19, v20, v21, *(unsigned __int8 *)(a1 + 141));
        *(_BYTE *)(a1 + 141) = 2;
        mDNSMacOSXNetworkChanged(v26, v27, v28, v29, v30, v31, v32, v33);
      }
      PowerOn((_DWORD *)a1);
      break;
    default:
      if (mDNS_LoggingEnabled == 1)
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "PowerChanged unknown message %X", v17, v18, v19, v20, v21, a3);
      break;
  }
  if (a3 == -536870288)
  {
    IOAllowPowerChange(*(_DWORD *)(*(_QWORD *)a1 + 568), a4);
  }
  else if (a3 == -536870272)
  {
    *(_QWORD *)(*(_QWORD *)a1 + 592) = a4;
  }
  KQueueUnlock((uint64_t)"PowerChanged Sleep/Wake", v15, v16, v17, v18, v19, v20, v21);
}

void RegisterLocalOnlyAddressRecord(_BYTE *a1, int a2, const void *a3, unsigned int a4)
{
  __int16 v6;
  void *v8;
  uint64_t v9;
  _BYTE *v10;
  uint64_t v11;
  _BYTE *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned __int16 v27;

  v6 = a2;
  if (a2 == 28)
  {
    if (a4 != 16)
      return;
  }
  else if (a2 != 1 || a4 != 4)
  {
    return;
  }
  v8 = malloc_type_calloc(1uLL, 0x498uLL, 0xF1748037uLL);
  if (v8)
  {
    v9 = (uint64_t)v8;
    mDNS_SetupResourceRecord((uint64_t)v8, 0, -2, v6, 1u, 32, 4, (uint64_t)FreeEtcHosts, 0);
    v10 = a1;
    if (a1 == (_BYTE *)-256)
    {
LABEL_9:
      while (v10)
      {
        v11 = *v10;
        if (v11 > 0x3F)
          break;
        if (!*v10)
        {
          v27 = (_WORD)v10 - (_WORD)a1 + 1;
          v12 = (_BYTE *)(v9 + 652);
          if (v27 > 0x100u)
            goto LABEL_15;
          __memcpy_chk(v12, a1, v27, 524);
          goto LABEL_16;
        }
        v10 += v11 + 1;
        if (a1 != (_BYTE *)-256)
          goto LABEL_8;
      }
    }
    else
    {
LABEL_8:
      if (v10 < a1 + 256)
        goto LABEL_9;
    }
    v12 = (_BYTE *)(v9 + 652);
LABEL_15:
    *v12 = 0;
LABEL_16:
    memcpy((void *)(*(_QWORD *)(v9 + 48) + 4), a3, a4);
    v19 = mDNS_Register_internal((uint64_t)mDNSStorage, v9, v13, v14, v15, v16, v17, v18);
    if (v19)
    {
      v20 = v19;
      v21 = mDNSLogCategory_Default;
      GetRRDisplayString_rdb((unsigned __int8 *)(v9 + 8), (unsigned __int16 *)(*(_QWORD *)(v9 + 48) + 4), word_100164580);
      LogMsgWithLevel(v21, OS_LOG_TYPE_DEFAULT, "RegisterLocalOnlyAddressRecord: mDNS_Register error %d registering %s", v22, v23, v24, v25, v26, v20);
      free((void *)v9);
    }
  }
  else
  {
    __break(1u);
  }
}

void mDNSMacOSXUpdateEtcHosts_internal()
{
  NSObject *v0;
  int handle;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _BYTE *v7;
  FILE *v8;
  FILE *v9;
  size_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  size_t v17;
  int v18;
  size_t v20;
  BOOL v21;
  const char *i;
  int v23;
  uint64_t v24;
  unsigned int v25;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int v35;
  BOOL v36;
  uint64_t v37;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  int v76;
  NSObject *v77;
  NSObject *v78;
  char *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t j;
  addrinfo *v86;
  addrinfo *v87;
  _QWORD *v88;
  _QWORD *v89;
  NSObject *v90;
  char *v91;
  int v92;
  NSObject *v93;
  int v94;
  char *v95;
  addrinfo *v96[502];
  addrinfo *v97;
  addrinfo v98;
  unsigned __int8 *v99;
  unsigned __int8 *v100;
  _QWORD v101[4];
  int v102;
  char v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  _BYTE v118[31];
  _BYTE v119[256];
  __int128 v120;
  __int128 v121;
  __int128 v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  __int128 v126;
  __int128 v127;
  __int128 v128;
  __int128 v129;
  __int128 v130;
  __int128 v131;
  __int128 v132;
  __int128 v133;
  __int128 v134;
  __int128 v135;

  bzero(v96, 0xFB0uLL);
  if (!mDNSMacOSXGetEtcHostsFD_etcq)
  {
    mDNSMacOSXGetEtcHostsFD_etcq = (uint64_t)&_dispatch_main_q;
    dispatch_async((dispatch_queue_t)&_dispatch_main_q, &__block_literal_global_423);
    goto LABEL_89;
  }
  v0 = mDNSMacOSXGetEtcHostsFD_hostssrc;
  if (mDNSMacOSXGetEtcHostsFD_hostssrc)
    goto LABEL_3;
  v76 = open("/etc/hosts", 0);
  if (v76 == -1)
  {
    if (mDNSMacOSXGetEtcHostsFD_etcsrc)
    {
      if (mDNS_LoggingEnabled != 1)
        goto LABEL_104;
      v90 = mDNSLogCategory_Default;
      v91 = "mDNSMacOSXGetEtcHostsFD: Returning etcfd because no etchosts";
    }
    else
    {
      v92 = open("/etc", 0);
      if (v92 == -1)
      {
        if (mDNS_LoggingEnabled != 1)
          goto LABEL_104;
        v90 = mDNSLogCategory_Default;
        v91 = "mDNSMacOSXGetEtcHostsFD: etc does not exist";
      }
      else
      {
        v76 = v92;
        v93 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_vnode, v92, 0x23uLL, (dispatch_queue_t)mDNSMacOSXGetEtcHostsFD_etcq);
        mDNSMacOSXGetEtcHostsFD_etcsrc = (uint64_t)v93;
        if (!v93)
          goto LABEL_126;
        dispatch_source_set_event_handler(v93, &__block_literal_global_429);
        v101[0] = _NSConcreteStackBlock;
        v101[1] = 0x40000000;
        v101[2] = __mDNSMacOSXGetEtcHostsFD_block_invoke_4;
        v101[3] = &__block_descriptor_tmp_433;
        v102 = v76;
        dispatch_source_set_cancel_handler((dispatch_source_t)mDNSMacOSXGetEtcHostsFD_etcsrc, v101);
        dispatch_resume((dispatch_object_t)mDNSMacOSXGetEtcHostsFD_etcsrc);
        v76 = open("/etc/hosts", 0x8000);
        if (v76 != -1)
          goto LABEL_92;
        v90 = mDNSLogCategory_Default;
        v91 = "mDNSMacOSXGetEtcHostsFD etc hosts does not exist, watching etc";
      }
    }
    LogMsgWithLevel(v90, OS_LOG_TYPE_DEFAULT, v91, v71, v72, v73, v74, v75, v94);
    goto LABEL_89;
  }
LABEL_92:
  v77 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_vnode, v76, 0x7FuLL, (dispatch_queue_t)mDNSMacOSXGetEtcHostsFD_etcq);
  mDNSMacOSXGetEtcHostsFD_hostssrc = (uint64_t)v77;
  if (!v77)
  {
LABEL_126:
    close(v76);
    goto LABEL_89;
  }
  dispatch_source_set_event_handler(v77, &__block_literal_global_436);
  *(_QWORD *)&v120 = _NSConcreteStackBlock;
  *((_QWORD *)&v120 + 1) = 0x40000000;
  *(_QWORD *)&v121 = __mDNSMacOSXGetEtcHostsFD_block_invoke_7;
  *((_QWORD *)&v121 + 1) = &__block_descriptor_tmp_441;
  LODWORD(v122) = v76;
  dispatch_source_set_cancel_handler((dispatch_source_t)mDNSMacOSXGetEtcHostsFD_hostssrc, &v120);
  dispatch_resume((dispatch_object_t)mDNSMacOSXGetEtcHostsFD_hostssrc);
  if (mDNSMacOSXGetEtcHostsFD_etcsrc)
  {
    dispatch_source_cancel((dispatch_source_t)mDNSMacOSXGetEtcHostsFD_etcsrc);
    if (mDNSMacOSXGetEtcHostsFD_etcsrc)
    {
      dispatch_release((dispatch_object_t)mDNSMacOSXGetEtcHostsFD_etcsrc);
      mDNSMacOSXGetEtcHostsFD_etcsrc = 0;
    }
  }
  if (mDNS_LoggingEnabled == 1)
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXGetEtcHostsFD: /etc/hosts being monitored, and not etc", v2, v3, v4, v5, v6, v94);
  v0 = mDNSMacOSXGetEtcHostsFD_hostssrc;
  if (!mDNSMacOSXGetEtcHostsFD_hostssrc)
  {
LABEL_89:
    if ((mDNS_LoggingEnabled & 1) == 0)
      goto LABEL_104;
LABEL_102:
    v78 = mDNSLogCategory_Default;
    v79 = "mDNSMacOSXUpdateEtcHosts: /etc/hosts is not present";
LABEL_103:
    LogMsgWithLevel(v78, OS_LOG_TYPE_DEFAULT, v79, v2, v3, v4, v5, v6, v94);
    goto LABEL_104;
  }
LABEL_3:
  handle = dispatch_source_get_handle(v0);
  v7 = &unk_100158000;
  if (handle == -1)
  {
    if (!mDNS_LoggingEnabled)
      goto LABEL_104;
    goto LABEL_102;
  }
  if (mDNS_LoggingEnabled)
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXUpdateEtcHosts: Parsing /etc/hosts fd %d", v2, v3, v4, v5, v6, handle);
  v8 = fopen("/etc/hosts", "r");
  if (!v8)
  {
    if (mDNS_LoggingEnabled != 1)
      goto LABEL_104;
    v78 = mDNSLogCategory_Default;
    v79 = "mDNSMacOSXParseEtcHosts: fp is NULL";
    goto LABEL_103;
  }
  v9 = v8;
  bzero(v101, 0x400uLL);
  while (fgets((char *)v101, 1024, v9))
  {
    if (LOBYTE(v101[0]) > 0x23u || ((1 << SLOBYTE(v101[0])) & 0x800002400) == 0)
    {
      v11 = strlen((const char *)v101);
      if (!v11)
        break;
      v17 = v11 - 1;
      v18 = *((unsigned __int8 *)v101 + v11 - 1);
      if (v18 == 13 || v18 == 10)
      {
        *((_BYTE *)v101 + v17) = 0;
        if (v11 == 1)
          goto LABEL_28;
        v20 = v11 - 2;
        v18 = *((unsigned __int8 *)v101 + v11 - 2);
      }
      else
      {
        v20 = v11 - 1;
        LODWORD(v17) = v11;
      }
      v21 = v18 == 13 || v18 == 10;
      if (!v21 || (*((_BYTE *)v101 + v20) = 0, LODWORD(v17) = v20, v20))
      {
        for (i = (const char *)v101; ; ++i)
        {
          v23 = *(unsigned __int8 *)i;
          if (v23 != 9 && v23 != 32)
            break;
          LODWORD(v17) = v17 - 1;
        }
        if ((int)v17 < 1)
        {
          LODWORD(v24) = 0;
          v27 = 0;
        }
        else
        {
          v24 = 0;
          while (1)
          {
            v25 = i[v24];
            if (v25 <= 0x2C && ((1 << v25) & 0x102100000200) != 0)
              break;
            if (v17 == ++v24)
            {
              v27 = 0;
              LODWORD(v24) = v17;
              goto LABEL_47;
            }
          }
          if (v25 == 37)
            v27 = v24 + 1;
          else
            v27 = 0;
          i[v24] = 0;
        }
LABEL_47:
        v135 = 0u;
        v134 = 0u;
        v133 = 0u;
        v132 = 0u;
        v131 = 0u;
        v130 = 0u;
        v129 = 0u;
        v128 = 0u;
        v127 = 0u;
        v126 = 0u;
        v125 = 0u;
        v124 = 0u;
        v123 = 0u;
        v122 = 0u;
        v121 = 0u;
        v120 = 0u;
        memset(v119, 0, sizeof(v119));
        memset(&v98, 0, sizeof(v98));
        v98.ai_flags = 4;
        v97 = 0;
        if (getaddrinfo(i, 0, &v98, &v97))
        {
          if (v7[3304] == 1)
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXParseEtcHostsLine: getaddrinfo returning null", v28, v29, v30, v31, v32, v94);
        }
        else
        {
          if (v27)
          {
            v95 = (char *)&i[v27];
            if ((int)v17 <= v27 + 1)
              LODWORD(v24) = v27 + 1;
            else
              LODWORD(v24) = v17;
            v33 = v27 + 1;
            while (1)
            {
              v34 = v33;
              if ((int)v33 >= (int)v17)
                break;
              v35 = i[v33++];
              ++v27;
              v36 = v35 > 0x2C;
              v37 = (1 << v35) & 0x100100000200;
              if (!v36 && v37 != 0)
              {
                i[v34] = 0;
                LODWORD(v24) = v27;
                break;
              }
            }
          }
          else
          {
            v95 = 0;
          }
          v100 = 0;
          v99 = 0;
          v39 = EtcHostsParseOneName((v24 + 1), v17, (uint64_t)i, &v100);
          if (v39 == (_DWORD)v17)
          {
            v46 = (int)v100;
            LOBYTE(v120) = 0;
            if (AppendDNSNameString(&v120, v100, v40, v41, v42, v43, v44, v45))
              mDNSMacOSXCreateEtcHostsEntry(&v120, (uint64_t)v97->ai_addr, 0, v95, (uint64_t)v96, v49, v50, v51);
            else
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXParseEtcHostsLine: ERROR!! cannot convert to domain name %s", v47, v48, v49, v50, v51, v46);
            goto LABEL_83;
          }
          v52 = v39;
          if (v39 == -1)
            goto LABEL_83;
          v117 = 0u;
          memset(v118, 0, sizeof(v118));
          v115 = 0u;
          v116 = 0u;
          v113 = 0u;
          v114 = 0u;
          v111 = 0u;
          v112 = 0u;
          v109 = 0u;
          v110 = 0u;
          v107 = 0u;
          v108 = 0u;
          v105 = 0u;
          v106 = 0u;
          v104 = 0u;
          v53 = (int)v100;
          v103 = 0;
          if (AppendDNSNameString(&v103, v100, v40, v41, v42, v43, v44, v45))
          {
            mDNSMacOSXCreateEtcHostsEntry(&v103, (uint64_t)v97->ai_addr, 0, v95, (uint64_t)v96, v56, v57, v58);
            if (v52 >= (int)v17)
              goto LABEL_81;
            v59 = 0;
            while (1)
            {
              v52 = EtcHostsParseOneName((v52 + 1), v17, (uint64_t)i, &v99);
              v53 = (int)v99;
              if (!v99)
                break;
              if (v59 && *(unsigned __int8 *)i == *v99)
                goto LABEL_81;
              v119[0] = 0;
              if (!AppendDNSNameString(v119, v99, v60, v61, v62, v63, v64, v65))
                goto LABEL_84;
              if (SameDomainNameBytes(&v103, v119))
              {
                if (mDNS_LoggingEnabled == 1)
                  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXParseEtcHostsLine: Ignoring entry with same names first %##s, name2 %##s", v66, v67, v68, v69, v70, (int)&v103);
              }
              else if (!mDNSMacOSXCreateEtcHostsEntry(v119, 0, (unint64_t)&v103, v95, (uint64_t)v96, v68, v69, v70))
              {
                goto LABEL_85;
              }
              ++v59;
LABEL_80:
              if (v52 >= (int)v17)
                goto LABEL_81;
            }
            if (v59)
              goto LABEL_80;
            if (mDNS_LoggingEnabled == 1)
              LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXParseEtcHostsLine: White space at the end of %##s", v61, v62, v63, v64, v65, (int)&v103);
LABEL_81:
            v7 = (_BYTE *)&unk_100158000;
LABEL_83:
            freeaddrinfo(v97);
          }
          else
          {
LABEL_84:
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXParseEtcHostsLine: ERROR!! cannot convert to domain name %s", v54, v55, v56, v57, v58, v53);
LABEL_85:
            freeaddrinfo(v97);
            v7 = (_BYTE *)&unk_100158000;
          }
        }
      }
      else
      {
LABEL_28:
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXParseEtcHosts: Length is zero!", v12, v13, v14, v15, v16, v94);
      }
    }
  }
  fclose(v9);
LABEL_104:
  mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"mDNSMacOSXUpdateEtcHosts_internal", 7811);
  if (EtcHostsAddNewEntries((uint64_t)v96, 1) || EtcHostsDeleteOldEntries((uint64_t)v96, 1))
  {
    mDNSCoreRestartAddressQueries(0, (void (*)(uint64_t *))FlushAllCacheRecords, (void (*)(uint64_t *, uint64_t))UpdateEtcHosts, (uint64_t)v96);
  }
  else if (mDNS_LoggingEnabled == 1)
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXUpdateEtcHosts: No work", v80, v81, v82, v83, v84, v94);
  }
  for (j = 0; j != 499; ++j)
  {
    v86 = v96[j + 3];
    if (v86)
    {
      do
      {
        v87 = *(addrinfo **)&v86->ai_flags;
        v88 = *(_QWORD **)&v86->ai_addrlen;
        if (v88)
        {
          do
          {
            v89 = (_QWORD *)*v88;
            free(v88);
            v88 = v89;
          }
          while (v89);
        }
        free(v86);
        v86 = v87;
      }
      while (v87);
    }
  }
  mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"mDNSMacOSXUpdateEtcHosts_internal", 7845);
}

void *CreatePTRRecord(_BYTE *a1)
{
  void *result;
  uint64_t v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE *v6;
  const char *i;
  uint64_t v9;
  unsigned int v10;
  unsigned __int16 v11;
  const char *j;
  uint64_t v14;
  _BYTE *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  result = malloc_type_calloc(1uLL, 0x498uLL, 0xF1748037uLL);
  if (!result)
  {
    __break(1u);
    return result;
  }
  v3 = (uint64_t)result;
  mDNS_SetupResourceRecord((uint64_t)result, 0, -2, 12, 0x1194u, 32, 4, 0, 0);
  v4 = a1;
  if (a1 == (_BYTE *)-256)
  {
LABEL_4:
    while (v4)
    {
      v5 = *v4;
      if (v5 > 0x3F)
        break;
      if (!*v4)
      {
        v11 = (_WORD)v4 - (_WORD)a1 + 1;
        v6 = (_BYTE *)(v3 + 652);
        if (v11 > 0x100u)
          goto LABEL_10;
        __memcpy_chk(v6, a1, v11, 524);
        goto LABEL_11;
      }
      v4 += v5 + 1;
      if (a1 != (_BYTE *)-256)
        goto LABEL_3;
    }
  }
  else
  {
LABEL_3:
    if (v4 < a1 + 256)
      goto LABEL_4;
  }
  v6 = (_BYTE *)(v3 + 652);
LABEL_10:
  *v6 = 0;
LABEL_11:
  for (i = "\tlocalhost"; ; i += v9 + 1)
  {
    if ("\tlocalhost" == (char *)-256)
    {
      if (!i)
        goto LABEL_22;
    }
    else if (i >= "ocket error %d errno %d (%s)" || i == 0)
    {
LABEL_22:
      LOWORD(v10) = 257;
      goto LABEL_26;
    }
    v9 = *(unsigned __int8 *)i;
    if (v9 > 0x3F)
      goto LABEL_22;
    if (!*i)
      break;
  }
  v10 = (_DWORD)i - "\tlocalhost" + 1;
LABEL_26:
  *(_WORD *)(v3 + 20) = v10;
  *(_BYTE *)(*(_QWORD *)(v3 + 48) + 4) = 0;
  for (j = "\tlocalhost"; ; j += v14 + 1)
  {
    if ("\tlocalhost" == (char *)-256)
    {
      if (!j)
        goto LABEL_37;
    }
    else if (j >= "ocket error %d errno %d (%s)" || j == 0)
    {
LABEL_37:
      v15 = (_BYTE *)(*(_QWORD *)(v3 + 48) + 4);
LABEL_38:
      *v15 = 0;
      goto LABEL_39;
    }
    v14 = *(unsigned __int8 *)j;
    if (v14 > 0x3F)
      goto LABEL_37;
    if (!*j)
      break;
  }
  v15 = (_BYTE *)(*(_QWORD *)(v3 + 48) + 4);
  if ((unsigned __int16)((_WORD)j - (unsigned __int16)"\tlocalhost" + 1) > 0x100u)
    goto LABEL_38;
  memcpy(v15, "\tlocalhost", (unsigned __int16)((_WORD)j - (unsigned __int16)"\tlocalhost" + 1));
LABEL_39:
  *(_DWORD *)(v3 + 24) = DomainNameHashValue(*(_QWORD *)(v3 + 40));
  SetNewRData(v3 + 8, 0, 0, v16, v17, v18, v19, v20);
  return (void *)mDNS_Register((unsigned int *)mDNSStorage, v3);
}

void __mDNSPlatformInit_setup_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v2 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v2, v3, v4, v5, v6, v7, v8, v9);
  mDNS_Lock_(*(unsigned int **)(a1 + 32), (uint64_t)"mDNSPlatformInit_setup_block_invoke", 8318);
  SetNetworkChanged(1000);
  mDNS_Unlock_(*(_QWORD *)(a1 + 32), (uint64_t)"mDNSPlatformInit_setup_block_invoke", 8320);
  KQueueUnlock((uint64_t)"util_managed_network_change_handler", v10, v11, v12, v13, v14, v15, v16);
}

uint64_t __mDNSMacOSXGetEtcHostsFD_block_invoke_4(uint64_t a1)
{
  return close(*(_DWORD *)(a1 + 32));
}

uint64_t __mDNSMacOSXGetEtcHostsFD_block_invoke_7(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (mDNS_LoggingEnabled == 1)
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXGetEtcHostsFD: Closing etchosts fd %d", a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 32));
  return close(*(_DWORD *)(a1 + 32));
}

uint64_t EtcHostsParseOneName(uint64_t result, int a2, uint64_t a3, _QWORD *a4)
{
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  BOOL v8;
  uint64_t v9;

  *a4 = 0;
  if ((int)result >= a2)
    return 0xFFFFFFFFLL;
  result = (int)result;
  while (1)
  {
    v4 = *(unsigned __int8 *)(a3 + result);
    if (v4 > 0x22)
      break;
    if (v4 != 9 && v4 != 32)
      goto LABEL_13;
LABEL_8:
    if (a2 == (_DWORD)++result)
      return 0xFFFFFFFFLL;
  }
  if (v4 == 44)
    goto LABEL_8;
  if (v4 == 35)
    return 0xFFFFFFFFLL;
LABEL_13:
  *a4 = a3 + result;
  v5 = (int)result + 1;
  while (1)
  {
    result = (result + 1);
    if ((int)result >= a2)
      break;
    v6 = v5;
    v7 = *(unsigned __int8 *)(a3 + v5++);
    v8 = v7 > 0x2C;
    v9 = (1 << v7) & 0x100100000200;
    if (!v8 && v9 != 0)
    {
      *(_BYTE *)(a3 + v6) = 0;
      return result;
    }
  }
  return result;
}

uint64_t mDNSMacOSXCreateEtcHostsEntry(_BYTE *a1, uint64_t a2, unint64_t a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v12;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  NSObject *v22;
  char *v23;
  uint64_t result;
  unsigned int v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  _DWORD *v33;
  uint64_t v34;
  _BYTE *v35;
  uint64_t v36;
  _BYTE *v37;
  int v38;
  uint64_t v39;
  BOOL v40;
  __int16 v41;
  unsigned __int16 v42;
  char *v43;
  char *v44;
  __int16 v45;
  uint64_t v46;
  char *v47;
  uint64_t v48;
  _BYTE *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  NSObject *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  int v61;

  if (!a1)
  {
    v22 = mDNSLogCategory_Default;
    v23 = "mDNSMacOSXCreateEtcHostsEntry: ERROR!! name NULL";
LABEL_17:
    LogMsgWithLevel(v22, OS_LOG_TYPE_DEFAULT, v23, (uint64_t)a4, a5, a6, a7, a8, v61);
    return 0;
  }
  if (!(a2 | a3))
  {
    v22 = mDNSLogCategory_Default;
    v23 = "mDNSMacOSXCreateEtcHostsEntry: ERROR!! sa and cname both NULL";
    goto LABEL_17;
  }
  if (a2)
  {
    v12 = *(unsigned __int8 *)(a2 + 1);
    if (v12 != 2 && v12 != 30)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXCreateEtcHostsEntry: ERROR!! sa with bad family %d", (uint64_t)a4, a5, a6, a7, a8, *(unsigned __int8 *)(a2 + 1));
      return 0;
    }
  }
  if (a4)
  {
    v14 = if_nametoindex(a4);
    if (!v14)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXCreateEtcHostsEntry: hosts entry %##s with invalid ifname %s", v15, v16, v17, v18, v19, (int)a1);
      return 0;
    }
    v20 = v14;
    if (a2)
      goto LABEL_12;
LABEL_20:
    v21 = 5;
    goto LABEL_21;
  }
  v20 = -2;
  if (!a2)
    goto LABEL_20;
LABEL_12:
  if (*(_BYTE *)(a2 + 1) == 2)
    v21 = 1;
  else
    v21 = 28;
LABEL_21:
  v25 = DomainNameHashValue((unint64_t)a1);
  v26 = AuthGroupForName(a5, v25, a1);
  if (!v26 || (v32 = v26[2]) == 0)
  {
LABEL_37:
    result = (uint64_t)malloc_type_calloc(1uLL, 0x498uLL, 0xF1748037uLL);
    if (result)
    {
      v34 = result;
      mDNS_SetupResourceRecord(result, 0, v20, v21, 1u, 32, 4, (uint64_t)FreeEtcHosts, 0);
      v35 = a1;
      if (a1 == (_BYTE *)-256)
      {
LABEL_40:
        while (v35)
        {
          v36 = *v35;
          if (v36 > 0x3F)
            break;
          if (!*v35)
          {
            v42 = (_WORD)v35 - (_WORD)a1 + 1;
            v37 = (_BYTE *)(v34 + 652);
            if (v42 > 0x100u)
              goto LABEL_46;
            __memcpy_chk(v37, a1, v42, 524);
            if (a2)
              goto LABEL_47;
            goto LABEL_56;
          }
          v35 += v36 + 1;
          if (a1 != (_BYTE *)-256)
            goto LABEL_39;
        }
      }
      else
      {
LABEL_39:
        if (v35 < a1 + 256)
          goto LABEL_40;
      }
      v37 = (_BYTE *)(v34 + 652);
LABEL_46:
      *v37 = 0;
      if (a2)
      {
LABEL_47:
        v38 = *(unsigned __int8 *)(a2 + 1);
        v39 = *(_QWORD *)(v34 + 48);
        v40 = v38 == 2;
        if (v38 == 2)
          v41 = 4;
        else
          v41 = 16;
        *(_WORD *)(v34 + 20) = v41;
        if (v40)
        {
          *(_DWORD *)(v39 + 4) = *(_DWORD *)(a2 + 4);
        }
        else
        {
          *(_DWORD *)(v39 + 4) = *(_DWORD *)(a2 + 8);
          *(_DWORD *)(*(_QWORD *)(v34 + 48) + 8) = *(_DWORD *)(a2 + 12);
          *(_DWORD *)(*(_QWORD *)(v34 + 48) + 12) = *(_DWORD *)(a2 + 16);
          *(_DWORD *)(*(_QWORD *)(v34 + 48) + 16) = *(_DWORD *)(a2 + 20);
        }
      }
      else
      {
LABEL_56:
        v43 = (char *)(a3 + 256);
        v44 = (char *)a3;
        if (a3 == -256)
          goto LABEL_60;
LABEL_57:
        v45 = 257;
        if (v44 < v43 && v44)
        {
          while (1)
          {
            v46 = *v44;
            if (v46 > 0x3F)
            {
LABEL_65:
              v45 = 257;
              goto LABEL_67;
            }
            if (!*v44)
              break;
            v44 += v46 + 1;
            if (a3 != -256)
              goto LABEL_57;
LABEL_60:
            if (!v44)
              goto LABEL_65;
          }
          v45 = (_WORD)v44 - a3 + 1;
        }
LABEL_67:
        *(_WORD *)(v34 + 20) = v45;
        *(_BYTE *)(*(_QWORD *)(v34 + 48) + 4) = 0;
        v47 = (char *)a3;
        if (a3 == -256)
        {
LABEL_69:
          while (v47)
          {
            v48 = *v47;
            if (v48 > 0x3F)
              break;
            if (!*v47)
            {
              v49 = (_BYTE *)(*(_QWORD *)(v34 + 48) + 4);
              if ((unsigned __int16)((_WORD)v47 - a3 + 1) > 0x100u)
                goto LABEL_75;
              memcpy(v49, (const void *)a3, (unsigned __int16)((_WORD)v47 - a3 + 1));
              goto LABEL_76;
            }
            v47 += v48 + 1;
            if (a3 != -256)
              goto LABEL_68;
          }
        }
        else
        {
LABEL_68:
          if (v47 < v43)
            goto LABEL_69;
        }
        v49 = (_BYTE *)(*(_QWORD *)(v34 + 48) + 4);
LABEL_75:
        *v49 = 0;
      }
LABEL_76:
      *(_DWORD *)(v34 + 24) = DomainNameHashValue(*(_QWORD *)(v34 + 40));
      SetNewRData(v34 + 8, 0, 0, v50, v51, v52, v53, v54);
      if (mDNS_LoggingEnabled == 1)
      {
        v55 = mDNSLogCategory_Default;
        GetRRDisplayString_rdb((unsigned __int8 *)(v34 + 8), (unsigned __int16 *)(*(_QWORD *)(v34 + 48) + 4), word_100164580);
        LogMsgWithLevel(v55, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXCreateEtcHostsEntry: Adding resource record %s ID %d", v56, v57, v58, v59, v60, (int)word_100164580);
      }
      InsertAuthRecord(a5, v34);
      return 1;
    }
    else
    {
      __break(1u);
    }
    return result;
  }
  while (1)
  {
    if (*(unsigned __int16 *)(v32 + 12) != v21)
      goto LABEL_36;
    if (v21 == 28)
      break;
    if (v21 == 5)
    {
      if (SameDomainNameBytes((_BYTE *)(*(_QWORD *)(v32 + 48) + 4), (_BYTE *)a3))
      {
        if (mDNS_LoggingEnabled == 1)
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXCreateEtcHostsEntry: Same cname %##s for name %##s", v27, v28, v29, v30, v31, a3);
        return 0;
      }
    }
    else if (*(_DWORD *)(*(_QWORD *)(v32 + 48) + 4) == *(_DWORD *)(a2 + 4) && v20 == *(_QWORD *)(v32 + 32))
    {
      if (mDNS_LoggingEnabled == 1)
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXCreateEtcHostsEntry: Same IPv4 address and InterfaceID for name %##s ID %d", v27, v28, v29, v30, v31, (int)a1);
      return 0;
    }
LABEL_36:
    v32 = *(_QWORD *)v32;
    if (!v32)
      goto LABEL_37;
  }
  v33 = *(_DWORD **)(v32 + 48);
  if (v33[1] != *(_DWORD *)(a2 + 8)
    || v33[2] != *(_DWORD *)(a2 + 12)
    || v33[3] != *(_DWORD *)(a2 + 16)
    || v33[4] != *(_DWORD *)(a2 + 20)
    || v20 != *(_QWORD *)(v32 + 32))
  {
    goto LABEL_36;
  }
  if (mDNS_LoggingEnabled == 1)
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXCreateEtcHostsEntry: Same IPv6 address and InterfaceID for name %##s ID %d", v27, v28, v29, v30, v31, (int)a1);
  return 0;
}

uint64_t EtcHostsAddNewEntries(uint64_t a1, int a2)
{
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  unsigned __int8 *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  NSObject *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  NSObject *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  _QWORD *v40;

  v4 = 0;
  while (1)
  {
    v39 = v4;
    v5 = *(_QWORD **)(a1 + 8 * v4 + 24);
    if (v5)
      break;
LABEL_32:
    v4 = v39 + 1;
    if (v39 == 498)
      return 0;
  }
  while (1)
  {
    v40 = v5;
    v6 = (_QWORD *)v5[2];
    if (v6)
      break;
LABEL_31:
    v5 = (_QWORD *)*v40;
    if (!*v40)
      goto LABEL_32;
  }
  v7 = 0;
  while (1)
  {
    v8 = (uint64_t)v6;
    v6 = (_QWORD *)*v6;
    v9 = AuthGroupForName((uint64_t)&unk_10015A640, *(_DWORD *)(v8 + 24), *(_BYTE **)(v8 + 40));
    if (!v9)
      break;
    v10 = v9[2];
    if (!v10)
      break;
    if (!v7)
      v7 = v9[2];
    while (1)
    {
      if (*(_DWORD *)(v10 + 24) == *(_DWORD *)(v8 + 24))
      {
        if (resource_records_have_same_dnssec_rr_category(*(_QWORD *)(v10 + 64), *(_QWORD *)(v8 + 64)))
        {
          if (*(unsigned __int16 *)(v10 + 12) == *(unsigned __int16 *)(v8 + 12)
            && *(unsigned __int16 *)(v10 + 14) == *(unsigned __int16 *)(v8 + 14)
            && *(unsigned __int16 *)(v10 + 20) == *(unsigned __int16 *)(v8 + 20)
            && *(_DWORD *)(v10 + 28) == *(_DWORD *)(v8 + 28))
          {
            v11 = (unsigned __int8 *)(v10 + 8);
            if (SameRDataBody(v10 + 8, (unsigned __int16 *)(*(_QWORD *)(v8 + 48) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName))
            {
              if (SameDomainNameBytes(*(_BYTE **)(v10 + 40), *(_BYTE **)(v8 + 40))
                && *(_QWORD *)(v10 + 32) == *(_QWORD *)(v8 + 32))
              {
                break;
              }
            }
          }
        }
      }
      v10 = *(_QWORD *)v10;
      if (!v10)
        goto LABEL_19;
    }
    v8 = v10;
    v25 = "EtcHostsAddNewEntries: Skipping, not adding %s";
    if ((mDNS_LoggingEnabled & 1) == 0)
      goto LABEL_27;
LABEL_26:
    v26 = mDNSLogCategory_Default;
    GetRRDisplayString_rdb(v11, (unsigned __int16 *)(*(_QWORD *)(v8 + 48) + 4), word_100164580);
    LogMsgWithLevel(v26, OS_LOG_TYPE_DEFAULT, v25, v27, v28, v29, v30, v31, (int)word_100164580);
LABEL_27:
    if (!v6)
      goto LABEL_31;
  }
LABEL_19:
  v11 = (unsigned __int8 *)(v8 + 8);
  if (!a2)
  {
    RemoveAuthRecord((uint64_t)mDNSStorage, a1, v8);
    if (v7)
      v18 = v7;
    else
      v18 = v8;
    *(_QWORD *)(v8 + 96) = v18;
    *(_QWORD *)v8 = 0;
    if (mDNS_LoggingEnabled == 1)
    {
      v19 = mDNSLogCategory_Default;
      GetRRDisplayString_rdb((unsigned __int8 *)(v8 + 8), (unsigned __int16 *)(*(_QWORD *)(v8 + 48) + 4), word_100164580);
      LogMsgWithLevel(v19, OS_LOG_TYPE_DEFAULT, "EtcHostsAddNewEntries: Adding %s ID %d", v20, v21, v22, v23, v24, (int)word_100164580);
    }
    v25 = "EtcHostsAddNewEntries: mDNS_Register failed for %s";
    if (!mDNS_Register_internal((uint64_t)mDNSStorage, v8, v12, v13, v14, v15, v16, v17))
      goto LABEL_27;
    goto LABEL_26;
  }
  if (mDNS_LoggingEnabled == 1)
  {
    v33 = mDNSLogCategory_Default;
    GetRRDisplayString_rdb((unsigned __int8 *)(v8 + 8), (unsigned __int16 *)(*(_QWORD *)(v8 + 48) + 4), word_100164580);
    LogMsgWithLevel(v33, OS_LOG_TYPE_DEFAULT, "EtcHostsAddNewEntries: Entry %s not registered with core yet", v34, v35, v36, v37, v38, (int)word_100164580);
  }
  return 1;
}

uint64_t EtcHostsDeleteOldEntries(uint64_t a1, int a2)
{
  uint64_t v2;
  void (*v3)(uint64_t, uint64_t, int);
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  void (*v9)(uint64_t, uint64_t, int);
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  NSObject *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  NSObject *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  NSObject *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t *v46;

  v2 = 0;
  v3 = FreeEtcHosts;
  do
  {
    v43 = v2;
    v4 = mDNSStorage[v2 + 786];
    if (v4)
    {
      while (2)
      {
        v46 = (uint64_t *)v4;
        v5 = *(_QWORD **)(v4 + 16);
        while (v5)
        {
          v6 = (uint64_t)v5;
          v5 = (_QWORD *)*v5;
          if (*(void (**)(uint64_t, uint64_t, int))(v6 + 104) == v3)
          {
            v7 = AuthGroupForName(a1, *(_DWORD *)(v6 + 24), *(_BYTE **)(v6 + 40));
            if (v7 && (v8 = v7[2]) != 0)
            {
              while (*(_DWORD *)(v8 + 24) != *(_DWORD *)(v6 + 24)
                   || !resource_records_have_same_dnssec_rr_category(*(_QWORD *)(v8 + 64), *(_QWORD *)(v6 + 64))|| *(unsigned __int16 *)(v8 + 12) != *(unsigned __int16 *)(v6 + 12)|| *(unsigned __int16 *)(v8 + 14) != *(unsigned __int16 *)(v6 + 14)|| *(unsigned __int16 *)(v8 + 20) != *(unsigned __int16 *)(v6 + 20)|| *(_DWORD *)(v8 + 28) != *(_DWORD *)(v6 + 28)|| !SameRDataBody(v8 + 8, (unsigned __int16 *)(*(_QWORD *)(v6 + 48) + 4), (uint64_t (*)(uint64_t, unsigned __int16 *))SameDomainName)|| !SameDomainNameBytes(*(_BYTE **)(v8 + 40), *(_BYTE **)(v6 + 40)))
              {
                v8 = *(_QWORD *)v8;
                if (!v8)
                  goto LABEL_17;
              }
              if (mDNS_LoggingEnabled == 1)
              {
                v30 = mDNSLogCategory_Default;
                GetRRDisplayString_rdb((unsigned __int8 *)(v6 + 8), (unsigned __int16 *)(*(_QWORD *)(v6 + 48) + 4), word_100164580);
                LogMsgWithLevel(v30, OS_LOG_TYPE_DEFAULT, "EtcHostsDeleteOldEntries: Old record %s found in new, skipping", v31, v32, v33, v34, v35, (int)word_100164580);
              }
            }
            else
            {
LABEL_17:
              if (a2)
              {
                if (mDNS_LoggingEnabled == 1)
                {
                  v37 = mDNSLogCategory_Default;
                  GetRRDisplayString_rdb((unsigned __int8 *)(v6 + 8), (unsigned __int16 *)(*(_QWORD *)(v6 + 48) + 4), word_100164580);
                  LogMsgWithLevel(v37, OS_LOG_TYPE_DEFAULT, "EtcHostsDeleteOldEntries: Record %s not found in new, deleting", v38, v39, v40, v41, v42, (int)word_100164580);
                }
                return 1;
              }
              v9 = v3;
              if (v6 == v46[2])
              {
                v10 = *(unsigned __int8 **)v6;
                if (*(_QWORD *)v6)
                {
                  v11 = *(unsigned __int8 **)v6;
                  do
                  {
                    if (*((_QWORD *)v11 + 12) == v6)
                    {
                      if (mDNS_LoggingEnabled == 1)
                      {
                        v12 = mDNSLogCategory_Default;
                        GetRRDisplayString_rdb(v11 + 8, (unsigned __int16 *)(*((_QWORD *)v11 + 6) + 4), word_100164580);
                        LogMsgWithLevel(v12, OS_LOG_TYPE_DEFAULT, "EtcHostsDeleteOldEntries: Updating Resource Record %s to primary", v13, v14, v15, v16, v17, (int)word_100164580);
                      }
                      *((_QWORD *)v11 + 12) = v10;
                    }
                    else
                    {
                      v18 = mDNSLogCategory_Default;
                      GetRRDisplayString_rdb(v11 + 8, (unsigned __int16 *)(*((_QWORD *)v11 + 6) + 4), word_100164580);
                      LogMsgWithLevel(v18, OS_LOG_TYPE_DEFAULT, "EtcHostsDeleteOldEntries: ERROR!! Resource Record %s not pointing to primary %##s", v19, v20, v21, v22, v23, (int)word_100164580);
                    }
                    v11 = *(unsigned __int8 **)v11;
                  }
                  while (v11);
                }
              }
              if (mDNS_LoggingEnabled == 1)
              {
                v24 = mDNSLogCategory_Default;
                GetRRDisplayString_rdb((unsigned __int8 *)(v6 + 8), (unsigned __int16 *)(*(_QWORD *)(v6 + 48) + 4), word_100164580);
                LogMsgWithLevel(v24, OS_LOG_TYPE_DEFAULT, "EtcHostsDeleteOldEntries: Deleting %s", v25, v26, v27, v28, v29, (int)word_100164580);
              }
              mDNS_Deregister_internal((uint64_t)mDNSStorage, v6, 0);
              v3 = v9;
            }
          }
        }
        v4 = *v46;
        if (*v46)
          continue;
        break;
      }
    }
    v2 = v43 + 1;
  }
  while (v43 != 498);
  return 0;
}

uint64_t FlushAllCacheRecords(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v8;
  uint64_t v9;
  _BYTE *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v21;
  uint8_t buf[4];
  uint64_t v23;
  __int16 v24;
  _BYTE *v25;

  v8 = (unsigned int *)result;
  v9 = 0;
  v10 = (_BYTE *)(result + 47032);
  do
  {
    v21 = v9;
    v11 = *(_QWORD **)&v8[2 * v9 + 68];
    if (v11)
    {
      while (1)
      {
        v12 = v11[2];
        if (v12)
          break;
LABEL_18:
        v11 = (_QWORD *)*v11;
        if (!v11)
          goto LABEL_19;
      }
      while (1)
      {
        if (*(_QWORD *)(v12 + 32))
          goto LABEL_17;
        if (!RRTypeAnswersQuestionType(v12 + 8, 1u, 3, a4, a5, a6, a7, a8))
        {
          result = RRTypeAnswersQuestionType(v12 + 8, 0x1Cu, 3, v13, v14, v15, v16, v17);
          if (!(_DWORD)result)
            goto LABEL_17;
        }
        v18 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled == 1 && mDNSLogCategory_Default != mDNSLogCategory_State)
          break;
        if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          goto LABEL_15;
LABEL_16:
        result = mDNS_PurgeCacheResourceRecord(v8, v12);
LABEL_17:
        v12 = *(_QWORD *)v12;
        if (!v12)
          goto LABEL_18;
      }
      v18 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_16;
LABEL_15:
      GetRRDisplayString_rdb((unsigned __int8 *)(v12 + 8), (unsigned __int16 *)(*(_QWORD *)(v12 + 48) + 4), v10);
      *(_DWORD *)buf = 141558275;
      v23 = 1752392040;
      v24 = 2085;
      v25 = v10;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "FlushAllCacheRecords: Purging Resourcerecord - record description: %{sensitive, mask.hash}s.", buf, 0x16u);
      goto LABEL_16;
    }
LABEL_19:
    v9 = v21 + 1;
  }
  while (v21 != 498);
  return result;
}

uint64_t UpdateEtcHosts(uint64_t a1, uint64_t a2)
{
  mDNS_VerifyLockState("Check Lock", 1, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"UpdateEtcHosts", 7755);
  EtcHostsDeleteOldEntries(a2, 0);
  return EtcHostsAddNewEntries(a2, 0);
}

void __mDNSMacOSXGetEtcHostsFD_block_invoke_5(id a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int data;

  data = dispatch_source_get_data((dispatch_source_t)mDNSMacOSXGetEtcHostsFD_hostssrc);
  if (mDNS_LoggingEnabled == 1)
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXGetEtcHostsFD: /etc/hosts changed 0x%x", v1, v2, v3, v4, v5, data);
  if ((data & 0x21) != 0)
  {
    dispatch_source_cancel((dispatch_source_t)mDNSMacOSXGetEtcHostsFD_hostssrc);
    if (mDNSMacOSXGetEtcHostsFD_hostssrc)
    {
      dispatch_release((dispatch_object_t)mDNSMacOSXGetEtcHostsFD_hostssrc);
      mDNSMacOSXGetEtcHostsFD_hostssrc = 0;
    }
    usleep(0xF4240u);
    dispatch_async((dispatch_queue_t)mDNSMacOSXGetEtcHostsFD_etcq, &__block_literal_global_439);
  }
  else if ((data & 2) != 0)
  {
    mDNSMacOSXUpdateEtcHosts();
  }
}

void mDNSMacOSXUpdateEtcHosts()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v0 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v0, v1, v2, v3, v4, v5, v6, v7);
  mDNSMacOSXUpdateEtcHosts_internal();
  KQueueUnlock((uint64_t)"/etc/hosts changed", v8, v9, v10, v11, v12, v13, v14);
}

void __mDNSMacOSXGetEtcHostsFD_block_invoke_2(id a1)
{
  int data;
  char v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  data = dispatch_source_get_data((dispatch_source_t)mDNSMacOSXGetEtcHostsFD_etcsrc);
  v2 = data;
  LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSMacOSXGetEtcHostsFD: /etc changed 0x%x", v3, v4, v5, v6, v7, data);
  if ((v2 & 0x21) != 0)
  {
    dispatch_source_cancel((dispatch_source_t)mDNSMacOSXGetEtcHostsFD_etcsrc);
    if (mDNSMacOSXGetEtcHostsFD_etcsrc)
    {
      dispatch_release((dispatch_object_t)mDNSMacOSXGetEtcHostsFD_etcsrc);
      mDNSMacOSXGetEtcHostsFD_etcsrc = 0;
    }
    dispatch_async((dispatch_queue_t)mDNSMacOSXGetEtcHostsFD_etcq, &__block_literal_global_432);
  }
  else if ((v2 & 2) != 0 && !mDNSMacOSXGetEtcHostsFD_hostssrc)
  {
    mDNSMacOSXUpdateEtcHosts();
  }
}

void PowerOn(_DWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;

  mDNSCoreMachineSleep((uint64_t)a1, 0);
  if (*(_QWORD *)(*(_QWORD *)a1 + 600))
  {
    v7 = time(0);
    mdns_power_cancel_all_events(CFSTR("com.apple.mDNSResponder"));
    v10 = *(_QWORD *)(*(_QWORD *)a1 + 600);
    v11 = v10 - v7;
    if (v11 < 31)
    {
      v12 = v7 - v10;
      if (v12 < 31)
      {
        if (mDNS_LoggingEnabled)
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "PowerChanged: Waking for network maintenance operations %d seconds early; re-sleeping in 20 seconds",
            v2,
            v3,
            v4,
            v5,
            v6,
            v11);
        *(_DWORD *)(*(_QWORD *)a1 + 608) = mDNS_TimeNow(a1, v8, v9, v2, v3, v4, v5, v6) + 20000;
      }
      else if (mDNS_LoggingEnabled)
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "PowerChanged PowerOn %d seconds late, assuming not maintenance wake", v2, v3, v4, v5, v6, v12);
      }
    }
    else if (mDNS_LoggingEnabled == 1)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "PowerChanged PowerOn %d seconds early, assuming not maintenance wake", v2, v3, v4, v5, v6, v11);
    }
  }
  if (*(_DWORD *)(mDNSStorage[0] + 584))
    v13 = mDNS_LoggingEnabled == 0;
  else
    v13 = 1;
  if (!v13)
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "Sleep Assertion is already being held. Will not attempt to get it again for %d seconds for %s", v2, v3, v4, v5, v6, 16);
}

CFTypeRef CopyNameFromKey(CFStringRef theString)
{
  const __CFArray *ArrayBySeparatingStrings;
  const __CFArray *v2;
  const void *ValueAtIndex;
  CFTypeRef v4;

  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0, theString, CFSTR("/"));
  if (!ArrayBySeparatingStrings)
    return 0;
  v2 = ArrayBySeparatingStrings;
  if (CFArrayGetCount(ArrayBySeparatingStrings) == 5)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(v2, 3);
    v4 = CFRetain(ValueAtIndex);
  }
  else
  {
    v4 = 0;
  }
  CFRelease(v2);
  return v4;
}

void GetRandomUUIDLabel(_BYTE *a1)
{
  _BYTE *v2;
  _BYTE *v3;
  char v4;
  BOOL v5;
  unsigned __int8 *v6;
  int v7;
  BOOL v8;
  _BYTE v9[37];
  uuid_t out;

  memset(out, 0, sizeof(out));
  memset(v9, 0, sizeof(v9));
  uuid_generate_random(out);
  uuid_unparse_lower(out, v9);
  v2 = a1 + 64;
  v3 = a1 + 1;
  v4 = v9[0];
  if (v9[0])
    v5 = v3 >= v2;
  else
    v5 = 1;
  if (!v5)
  {
    v6 = &v9[1];
    do
    {
      *v3++ = v4;
      v7 = *v6++;
      v4 = v7;
      if (v7)
        v8 = v3 >= v2;
      else
        v8 = 1;
    }
    while (!v8);
  }
  *a1 = (_BYTE)v3 + ~(_BYTE)a1;
}

void mDNSPlatformSendWakeupPacket(uint64_t a1, const char *a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  int v10;
  NSObject *v13;
  unsigned int v16;
  xpc_object_t v17;
  uint8_t buf[4];
  uint64_t v19;

  v9 = *(_QWORD *)mDNSStorage[0];
  if (!*(_QWORD *)mDNSStorage[0])
  {
LABEL_6:
    v13 = mDNSLogCategory_Default;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
        return;
      *(_DWORD *)buf = 134217984;
      v19 = a1;
    }
    else
    {
      v13 = mDNSLogCategory_Default_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
        return;
      *(_DWORD *)buf = 134217984;
      v19 = a1;
    }
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "GetInterfaceSupportsWakeOnLANPacket: Invalid interface id %p", buf, 0xCu);
    return;
  }
  v10 = a4;
  while (!*(_QWORD *)(v9 + 3776) || *(_DWORD *)(v9 + 3720) != (_DWORD)a1)
  {
    v9 = *(_QWORD *)(v9 + 3680);
    if (!v9)
      goto LABEL_6;
  }
  if (*(_DWORD *)(v9 + 3708) == 2)
  {
    v16 = -1;
    switch(a1)
    {
      case -5:
        v16 = -4;
        goto LABEL_22;
      case -3:
        v16 = -3;
        goto LABEL_22;
      case -2:
        goto LABEL_22;
      case 0:
        goto LABEL_20;
      default:
        v16 = a1;
        if ((_DWORD)a1)
        {
LABEL_22:
          if (mDNS_LoggingEnabled == 1)
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSSendWakeupPacket: Entered ethernet address[%s],ip_address[%s], interface_id[%d], iteration[%d]", a4, a5, a6, a7, a8, (int)a2);
          v17 = xpc_dictionary_create(0, 0, 0);
          xpc_dictionary_set_uint64(v17, "HelperMode", 6uLL);
          xpc_dictionary_set_uint64(v17, "interface_index", v16);
          xpc_dictionary_set_string(v17, "ethernet_address", a2);
          xpc_dictionary_set_string(v17, "ip_address", a3);
          xpc_dictionary_set_uint64(v17, "swp_iteration", v10);
          SendDict_ToServer(v17);
          if (v17)
            xpc_release(v17);
        }
        else
        {
LABEL_20:
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformSendWakeupPacket: ERROR!! Invalid InterfaceID %u", a4, a5, a6, a7, a8, 0);
        }
        break;
    }
  }
}

uint64_t mDNSPlatformInterfaceIsD2D(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v9;
  uint64_t v10;

  if (a1 == -5)
    return 0;
  if (a1 == -3)
    return 1;
  if ((unint64_t)(a1 + 2) < 3)
    return 0;
  if (AWDLInterfaceID)
    v9 = AWDLInterfaceID == a1;
  else
    v9 = 0;
  if (v9 || WiFiAwareInterfaceID && WiFiAwareInterfaceID == a1)
    return 1;
  v10 = *(_QWORD *)mDNSStorage[0];
  if (*(_QWORD *)mDNSStorage[0])
  {
    while (!*(_QWORD *)(v10 + 3776) || *(_DWORD *)(v10 + 3720) != (_DWORD)a1)
    {
      v10 = *(_QWORD *)(v10 + 3680);
      if (!v10)
        goto LABEL_17;
    }
    return *(unsigned __int8 *)(v10 + 3699);
  }
  else
  {
LABEL_17:
    if (mDNS_LoggingEnabled == 1)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "mDNSPlatformInterfaceIsD2D: Invalid interface index %d", a4, a5, a6, a7, a8, a1);
    return 0;
  }
}

uint64_t mDNSPlatformValidRecordForInterface(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  int v11;
  _BOOL4 v12;
  _BOOL4 v13;
  uint64_t result;
  NSObject *v16;
  uint64_t v18;
  _BYTE *v19;
  uint64_t v20;
  _BYTE *v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  __int16 v27;
  int v28;
  __int16 v29;
  uint64_t v30;
  __int16 v31;
  uint64_t v32;
  __int16 v33;
  int v34;

  if (!a2)
    goto LABEL_6;
  v10 = *(_QWORD *)mDNSStorage[0];
  if (!*(_QWORD *)mDNSStorage[0])
    goto LABEL_6;
  while (!*(_QWORD *)(v10 + 3776) || *(_DWORD *)(v10 + 3720) != (_DWORD)a2)
  {
    v10 = *(_QWORD *)(v10 + 3680);
    if (!v10)
      goto LABEL_6;
  }
  if (*(_BYTE *)(v10 + 3753))
  {
    v16 = mDNSLogCategory_mDNS;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_mDNS == mDNSLogCategory_State)
    {
      result = os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)result)
      {
        v18 = *(_QWORD *)(a1 + 40);
        if (v18)
        {
          v19 = *(_BYTE **)(a1 + 40);
          if (v18 == -256)
          {
LABEL_26:
            while (v19)
            {
              v20 = *v19;
              if (v20 > 0x3F)
                break;
              if (!*v19)
              {
                v23 = (unsigned __int16)((_WORD)v19 - v18 + 1);
                goto LABEL_46;
              }
              v19 += v20 + 1;
              if (v18 != -256)
                goto LABEL_25;
            }
          }
          else
          {
LABEL_25:
            if ((unint64_t)v19 < v18 + 256)
              goto LABEL_26;
          }
          v23 = 257;
        }
        else
        {
          v23 = 0;
        }
        goto LABEL_46;
      }
    }
    else
    {
      v16 = mDNSLogCategory_mDNS_redacted;
      result = os_log_type_enabled((os_log_t)mDNSLogCategory_mDNS_redacted, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)result)
      {
        v18 = *(_QWORD *)(a1 + 40);
        if (v18)
        {
          v21 = *(_BYTE **)(a1 + 40);
          if (v18 == -256)
          {
LABEL_35:
            while (v21)
            {
              v22 = *v21;
              if (v22 > 0x3F)
                break;
              if (!*v21)
              {
                v23 = (unsigned __int16)((_WORD)v21 - v18 + 1);
                goto LABEL_46;
              }
              v21 += v22 + 1;
              if (v18 != -256)
                goto LABEL_34;
            }
          }
          else
          {
LABEL_34:
            if ((unint64_t)v21 < v18 + 256)
              goto LABEL_35;
          }
          v23 = 257;
        }
        else
        {
          v23 = 0;
        }
LABEL_46:
        v24 = *(_QWORD *)(v10 + 3552);
        v25 = 141559043;
        v26 = 1752392040;
        v27 = 1040;
        v28 = v23;
        v29 = 2101;
        v30 = v18;
        v31 = 2082;
        v32 = v10 + 3606;
        v33 = 1024;
        v34 = v24;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "mDNSPlatformValidRecordForInterface: Filtering privacy risk -- name: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, ifname: %{public}s, ifid: %d", (uint8_t *)&v25, 0x2Cu);
        return 0;
      }
    }
  }
  else
  {
LABEL_6:
    if (*(_QWORD *)(a1 + 32) == a2 || !mDNSPlatformInterfaceIsD2D(a2, a2, a3, a4, a5, a6, a7, a8))
    {
      return 1;
    }
    else
    {
      v11 = *(_DWORD *)(a1 + 172);
      v12 = ((v11 - 1) & 0xFFFFFFFD) == 0;
      v13 = (v11 & 0xFFFFFFFE) == 2;
      if (AWDLInterfaceID == a2 || WiFiAwareInterfaceID == a2)
        return v13;
      else
        return v12;
    }
  }
  return result;
}

uint64_t mDNSPlatformValidQuestionForInterface(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  unsigned int v13;

  v9 = *(_QWORD *)(a1 + 136);
  v10 = *(_QWORD *)(a2 + 3552);
  if (v9 == v10 || !mDNSPlatformInterfaceIsD2D(v10, a2, a3, a4, a5, a6, a7, a8))
    return 1;
  v12 = *(_QWORD *)(a2 + 3552);
  v13 = *(_DWORD *)(a1 + 324);
  if (v12 == AWDLInterfaceID || v12 == WiFiAwareInterfaceID)
    return (v13 >> 20) & 1;
  else
    return (v13 >> 17) & 1;
}

char *_mrcs_dns_proxy_copy_description(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char *v8;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v16;
  char __s1[16];
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;

  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  *(_OWORD *)__s1 = 0u;
  v18 = 0u;
  v16 = 0;
  if (_mrcs_dns_proxy_print_description(a1, a2, __s1, 128, 0, (uint64_t)&v16, a7, a8))
    return 0;
  if (v16 > 0x7F)
  {
    v11 = v16 + 1;
    if (v16 == -1)
      goto LABEL_9;
    v12 = (char *)malloc_type_malloc(v16 + 1, 0xA172743EuLL);
    if (!v12)
      goto LABEL_9;
    v8 = v12;
    if (_mrcs_dns_proxy_print_description(a1, a2, v12, v11, 0, 0, v13, v14))
    {
LABEL_10:
      free(v8);
      return 0;
    }
  }
  else
  {
    v8 = strdup(__s1);
    if (!v8)
    {
LABEL_9:
      __break(1u);
      goto LABEL_10;
    }
  }
  return v8;
}

void _mrcs_dns_proxy_finalize(_QWORD *a1)
{
  char *v2;
  unint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  unint64_t i;
  void *v7;

  v4 = a1 + 5;
  v2 = (char *)a1[5];
  v3 = v4[1];
  if (v3)
  {
    v5 = 0;
    for (i = 0; i < v3; ++i)
    {
      if (*(_QWORD *)&v2[v5])
      {
        free(*(void **)&v2[v5]);
        v2 = (char *)a1[5];
        v3 = a1[6];
        *(_QWORD *)&v2[v5] = 0;
      }
      v5 += 16;
    }
  }
  else if (!v2)
  {
    goto LABEL_9;
  }
  free(v2);
  a1[5] = 0;
LABEL_9:
  v7 = (void *)a1[7];
  if (v7)
  {
    free(v7);
    a1[7] = 0;
  }
}

uint64_t _mrcs_dns_proxy_print_description(uint64_t a1, int a2, char *a3, uint64_t a4, _QWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  const char *v24;
  unsigned int v25;
  const char *v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  const char *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char v40;
  uint64_t result;
  unsigned int v42;
  const char *v43;
  int v44;
  int v45;
  char v46;
  _QWORD *v47;
  char *v48;
  char v49[16];
  _WORD v50[15];
  uint64_t v51;
  int v52;
  int v53;

  v48 = a3;
  v12 = (uint64_t)&a3[a4];
  if (a2)
  {
    v13 = mdns_snprintf_add(&v48, v12, "<%s: %p>: ", a4, (uint64_t)a5, a6, a7, a8, *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8));
    if (v13 < 0)
      return 4294960596;
    v14 = v13 & ~(v13 >> 31);
  }
  else
  {
    v14 = 0;
  }
  v15 = mdns_snprintf_add(&v48, v12, "input interfaces: {", a4, (uint64_t)a5, a6, a7, a8, v46);
  if (v15 < 0)
    return 4294960596;
  v47 = (_QWORD *)a6;
  v21 = v14 + (v15 & ~(v15 >> 31));
  if (*(_QWORD *)(a1 + 48))
  {
    v22 = 0;
    v23 = 0;
    v24 = "";
    do
    {
      v25 = mdns_snprintf_add(&v48, v12, "%s%s/%u", v16, v17, v18, v19, v20, (char)v24);
      if ((v25 & 0x80000000) != 0)
        return 4294960596;
      v21 += v25;
      ++v23;
      v22 += 16;
      v24 = ", ";
    }
    while (v23 < *(_QWORD *)(a1 + 48));
  }
  v26 = *(const char **)(a1 + 56);
  if (!v26)
    v26 = "";
  v27 = mdns_snprintf_add(&v48, v12, "}, output interface: %s/%u", v16, v17, v18, v19, v20, (char)v26);
  if (v27 < 0)
    return 4294960596;
  v33 = v21 + (v27 & ~(v27 >> 31));
  if (!*(_BYTE *)(a1 + 76))
    goto LABEL_19;
  v51 = *(_QWORD *)(a1 + 28);
  v52 = *(_DWORD *)(a1 + 36);
  v53 = 0;
  *(_OWORD *)v49 = 0u;
  memset(v50, 0, sizeof(v50));
  v34 = inet_ntop(30, &v51, v49, 0x2Eu);
  v40 = (char)v34;
  if (!v34)
  {
    if (*__error())
    {
      result = *__error();
      if ((_DWORD)result)
        return result;
      goto LABEL_17;
    }
    return 4294960596;
  }
LABEL_17:
  v42 = mdns_snprintf_add(&v48, v12, ", nat64 prefix: %s/%d", v35, v36, v37, v38, v39, v40);
  if ((v42 & 0x80000000) != 0)
    return 4294960596;
  v33 += v42;
LABEL_19:
  if (*(_BYTE *)(a1 + 77))
    v43 = "yes";
  else
    v43 = "no";
  v44 = mdns_snprintf_add(&v48, v12, ", forces AAAA synthesis: %s", v28, v29, v30, v31, v32, (char)v43);
  if (v44 < 0)
    return 4294960596;
  v45 = v44;
  if (a5)
    *a5 = v48 - a3;
  result = 0;
  if (v47)
    *v47 = v33 + (v45 & ~(v45 >> 31));
  return result;
}

char *_mrcs_dns_proxy_manager_copy_description(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char *v8;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v17;
  char __s1[16];
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;

  v48 = 0u;
  v49 = 0u;
  v46 = 0u;
  v47 = 0u;
  v44 = 0u;
  v45 = 0u;
  v42 = 0u;
  v43 = 0u;
  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  *(_OWORD *)__s1 = 0u;
  v19 = 0u;
  v17 = 0;
  if (_mrcs_dns_proxy_manager_print_description(a1, a2, __s1, 512, &v17, a6, a7, a8))
    return 0;
  if (v17 > 0x1FF)
  {
    v11 = v17 + 1;
    if (v17 == -1)
      goto LABEL_9;
    v12 = (char *)malloc_type_malloc(v17 + 1, 0xA172743EuLL);
    if (!v12)
      goto LABEL_9;
    v8 = v12;
    if (_mrcs_dns_proxy_manager_print_description(a1, a2, v12, v11, 0, v13, v14, v15))
    {
LABEL_10:
      free(v8);
      return 0;
    }
  }
  else
  {
    v8 = strdup(__s1);
    if (!v8)
    {
LABEL_9:
      __break(1u);
      goto LABEL_10;
    }
  }
  return v8;
}

void _mrcs_dns_proxy_manager_finalize(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 24);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 24) = 0;
  }
}

uint64_t _mrcs_dns_proxy_manager_print_description(uint64_t a1, int a2, char *a3, uint64_t a4, _QWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  CFIndex Count;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  CFIndex v21;
  CFIndex v22;
  char *v23;
  unsigned int v24;
  unsigned int v25;
  const void *ValueAtIndex;
  uint64_t v27;
  uint64_t v28;
  uint64_t result;
  int v30;
  int v31;
  char v32;
  char v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;

  v36 = a3;
  v10 = (uint64_t)&a3[a4];
  if (a2)
  {
    v11 = mdns_snprintf_add(&v36, v10, "<%s: %p>: ", a4, (uint64_t)a5, a6, a7, a8, *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8));
    if (v11 < 0)
      return 4294960596;
    v12 = v11 & ~(v11 >> 31);
  }
  else
  {
    v12 = 0;
  }
  v13 = mdns_snprintf_add(&v36, v10, "{", a4, (uint64_t)a5, a6, a7, a8, v32);
  if ((v13 & 0x80000000) != 0)
    return 4294960596;
  v14 = v12 + v13;
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 24));
  if (Count >= 1)
  {
    v21 = Count;
    v22 = 0;
    do
    {
      v23 = v22 ? "," : "";
      v24 = mdns_snprintf_add(&v36, v10, "%s\n\t", v16, v17, v18, v19, v20, (char)v23);
      if ((v24 & 0x80000000) != 0)
        return 4294960596;
      v25 = v24;
      v34 = 0;
      v35 = 0;
      ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 24), v22);
      result = _mrcs_dns_proxy_print_description((uint64_t)ValueAtIndex, 0, v36, v10 - (_QWORD)v36, &v35, (uint64_t)&v34, v27, v28);
      if ((_DWORD)result)
        return result;
      v36 += v35;
      v14 += v25 + v34;
    }
    while (v21 != ++v22);
  }
  v30 = mdns_snprintf_add(&v36, v10, "\n}", v16, v17, v18, v19, v20, v33);
  if (v30 < 0)
    return 4294960596;
  if (!a5)
    return 0;
  v31 = v30;
  result = 0;
  *a5 = v14 + (v31 & ~(v31 >> 31));
  return result;
}

uint64_t mrcs_dns_proxy_create(int *a1)
{
  uint64_t v2;
  uint64_t v3;
  _UNKNOWN **v4;
  void (*v5)(uint64_t);
  int v6;

  v2 = _os_object_alloc(OS_mrcs_dns_proxy, 80);
  v3 = v2;
  if (v2)
  {
    v4 = &_mrcs_dns_proxy_kind;
    *(_QWORD *)(v2 + 16) = &_mrcs_dns_proxy_kind;
    do
    {
      v5 = (void (*)(uint64_t))v4[2];
      if (v5)
        v5(v3);
      v4 = (_UNKNOWN **)*v4;
    }
    while (v4);
  }
  if (a1)
  {
    if (v3)
      v6 = 0;
    else
      v6 = -6728;
    *a1 = v6;
  }
  return v3;
}

char *mrcs_dns_proxy_set_output_interface(uint64_t a1, unsigned int a2)
{
  void *v3;
  char *result;

  *(_DWORD *)(a1 + 64) = a2;
  v3 = *(void **)(a1 + 56);
  if (v3)
  {
    free(v3);
    *(_QWORD *)(a1 + 56) = 0;
    a2 = *(_DWORD *)(a1 + 64);
  }
  result = mdns_system_interface_index_to_name(a2);
  *(_QWORD *)(a1 + 56) = result;
  return result;
}

uint64_t mrcs_dns_proxy_set_nat64_prefix(uint64_t a1, void *__src, unint64_t a3)
{
  unint64_t v3;
  __int128 v4;
  uint64_t result;
  char v6;
  int v9;
  uint64_t v10;
  unint64_t v11;

  *((_QWORD *)&v4 + 1) = a3;
  *(_QWORD *)&v4 = a3 - 32;
  v3 = v4 >> 3;
  if (v3 > 8 || ((0x11Fu >> v3) & 1) == 0)
    return 4294960553;
  v6 = a3;
  v9 = dword_1001002CC[v3];
  *(_QWORD *)(a1 + 28) = 0;
  v10 = a1 + 28;
  *(_DWORD *)(a1 + 36) = 0;
  v11 = a3 >> 3;
  if (a3 >= 8)
    memcpy((void *)(a1 + 28), __src, a3 >> 3);
  if ((v6 & 7) != 0)
    *(_BYTE *)(v10 + v11) = *(_BYTE *)(v10 + v11) & ~(-1 << (8 - (v6 & 7))) | *((_BYTE *)__src + v11) & (-1 << (8 - (v6 & 7)));
  result = 0;
  *(_DWORD *)(a1 + 24) = v9;
  *(_BYTE *)(a1 + 76) = 1;
  return result;
}

uint64_t ___mrcs_dns_proxy_manager_conflicts_with_proxy_block_invoke(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  BOOL v7;
  int v8;
  uint64_t v9;
  unint64_t v10;
  int *v11;
  int v12;
  _BOOL4 v13;
  unsigned int *v14;
  unsigned int *v15;
  size_t v16;
  BOOL v17;

  v2 = *(_QWORD *)(a2 + 48);
  if (!v2)
    return 1;
  v4 = 0;
  v5 = *(_QWORD *)(a1 + 32);
  v6 = *(_QWORD *)(v5 + 48);
  v7 = 1;
  do
  {
    if (v6)
    {
      v8 = *(_DWORD *)(*(_QWORD *)(a2 + 40) + 16 * v4 + 8);
      v9 = *(_QWORD *)(v5 + 40);
      if (*(_DWORD *)(v9 + 8) == v8)
        break;
      v10 = 0;
      v11 = (int *)(v9 + 24);
      while (v6 - 1 != v10)
      {
        v12 = *v11;
        v11 += 4;
        ++v10;
        if (v12 == v8)
        {
          if (v10 < v6)
            goto LABEL_10;
          break;
        }
      }
    }
    v7 = ++v4 < v2;
  }
  while (v4 != v2);
LABEL_10:
  if (!v7)
    return 1;
  if (*(_DWORD *)(a2 + 64) == *(_DWORD *)(v5 + 64))
  {
    v13 = *(_BYTE *)(a2 + 76) != 0;
    v14 = (unsigned int *)(a2 + 24);
    if (!*(_BYTE *)(a2 + 76))
      v14 = 0;
    v15 = (unsigned int *)(v5 + 24);
    if (!*(_BYTE *)(v5 + 76))
    {
      v15 = 0;
      v13 = 0;
    }
    if (v14 == v15)
    {
      if (!v13)
        return 1;
    }
    else
    {
      if (!v13)
        return 0;
      v16 = *v14;
      if ((_DWORD)v16 != *v15)
        return 0;
      v17 = (v16 - 4) < 5 || (_DWORD)v16 == 12;
      if (!v17 || memcmp(v14 + 1, v15 + 1, v16))
        return 0;
    }
    if (*(unsigned __int8 *)(a2 + 77) == *(unsigned __int8 *)(v5 + 77))
      return 1;
  }
  return 0;
}

uint64_t mrcs_dns_proxy_manager_get_proxy_by_input_interface(const __CFArray *a1, int a2)
{
  uint64_t v2;
  _QWORD v4[5];
  int v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2000000000;
  v9 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = __mrcs_dns_proxy_manager_get_proxy_by_input_interface_block_invoke;
  v4[3] = &unk_10013C960;
  v5 = a2;
  v4[4] = &v6;
  mdns_cfarray_enumerate(a1, (uint64_t)v4);
  v2 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v2;
}

BOOL __mrcs_dns_proxy_manager_get_proxy_by_input_interface_block_invoke(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  int v3;
  uint64_t v4;
  unint64_t v5;
  int *v6;
  int v7;

  v2 = *(_QWORD *)(a2 + 48);
  if (v2)
  {
    v3 = *(_DWORD *)(a1 + 40);
    v4 = *(_QWORD *)(a2 + 40);
    if (*(_DWORD *)(v4 + 8) == v3)
    {
LABEL_7:
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = a2;
    }
    else
    {
      v5 = 0;
      v6 = (int *)(v4 + 24);
      while (v2 - 1 != v5)
      {
        v7 = *v6;
        v6 += 4;
        ++v5;
        if (v7 == v3)
        {
          if (v5 >= v2)
            return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) == 0;
          goto LABEL_7;
        }
      }
    }
  }
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) == 0;
}

char *_mdns_trust_copy_description(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int128 v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *result;
  audit_token_t atoken;
  char *p_s1;
  char __s1;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  _BYTE v34[31];
  uint64_t v35;

  memset(v34, 0, sizeof(v34));
  v33 = 0u;
  v32 = 0u;
  v31 = 0u;
  v30 = 0u;
  v29 = 0u;
  v28 = 0u;
  v27 = 0u;
  v26 = 0u;
  v25 = 0u;
  v24 = 0u;
  v23 = 0u;
  v22 = 0u;
  v21 = 0u;
  v20 = 0u;
  p_s1 = &__s1;
  __s1 = 0;
  if (a2
    && (mdns_snprintf_add(&p_s1, (uint64_t)&v35, "<%s: %p>: ", a4, a5, a6, a7, a8, *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8)) & 0x80000000) != 0)
  {
    return 0;
  }
  if ((mdns_snprintf_add(&p_s1, (uint64_t)&v35, "%s ", a4, a5, a6, a7, a8, *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8)) & 0x80000000) != 0)
    return 0;
  v9 = *(_OWORD *)(a1 + 88);
  *(_OWORD *)atoken.val = *(_OWORD *)(a1 + 72);
  *(_OWORD *)&atoken.val[4] = v9;
  v10 = audit_token_to_pid(&atoken);
  if ((mdns_snprintf_add(&p_s1, (uint64_t)&v35, "for pid %d", v11, v12, v13, v14, v15, v10) & 0x80000000) != 0)
    return 0;
  result = strdup(&__s1);
  if (!result)
    __break(1u);
  return result;
}

void _mdns_trust_finalize(_QWORD *a1)
{
  uint64_t v2;
  NSObject *v3;
  NSObject *v4;
  void *v5;
  const void *v6;
  const void *v7;

  if (a1[7])
  {
    v2 = a1[8];
    if (v2)
      (*(void (**)(void))(v2 + 16))();
    a1[7] = 0;
  }
  v3 = a1[4];
  if (v3)
  {
    dispatch_release(v3);
    a1[4] = 0;
  }
  v4 = a1[5];
  if (v4)
  {
    dispatch_release(v4);
    a1[5] = 0;
  }
  v5 = (void *)a1[13];
  if (v5)
  {
    free(v5);
    a1[13] = 0;
  }
  v6 = (const void *)a1[8];
  if (v6)
  {
    _Block_release(v6);
    a1[8] = 0;
  }
  v7 = (const void *)a1[6];
  if (v7)
  {
    _Block_release(v7);
    a1[6] = 0;
  }
}

char *mdns_trust_create(_OWORD *a1, const char *a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  _UNKNOWN **v8;
  void (*v9)(uint64_t);
  __int128 v10;
  char *result;

  v6 = _os_object_alloc(OS_mdns_trust, 120);
  v7 = v6;
  if (v6)
  {
    v8 = &_mdns_trust_kind;
    *(_QWORD *)(v6 + 16) = &_mdns_trust_kind;
    do
    {
      v9 = (void (*)(uint64_t))v8[2];
      if (v9)
        v9(v7);
      v8 = (_UNKNOWN **)*v8;
    }
    while (v8);
  }
  *(_QWORD *)(v7 + 32) = dispatch_queue_create("trust-internal", 0);
  v10 = a1[1];
  *(_OWORD *)(v7 + 72) = *a1;
  *(_OWORD *)(v7 + 88) = v10;
  *(_DWORD *)(v7 + 112) = a3;
  if (!a2)
    return (char *)v7;
  result = strdup(a2);
  if (result)
  {
    *(_QWORD *)(v7 + 104) = result;
    return (char *)v7;
  }
  __break(1u);
  return result;
}

void _mdns_trust_activate_if_ready(NSObject **object)
{
  NSObject *v2;
  _QWORD block[5];

  if (*((_BYTE *)object + 26) && object[5] && !*((_BYTE *)object + 24))
  {
    os_retain(object);
    v2 = object[4];
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    block[2] = ___mdns_trust_activate_internal_block_invoke;
    block[3] = &__block_descriptor_tmp_8_4110;
    block[4] = object;
    dispatch_async(v2, block);
  }
}

void ___mdns_trust_activate_internal_block_invoke(uint64_t a1)
{
  _BYTE *v2;
  uint64_t v3;
  void *v4;
  const char *v5;
  int v6;
  NSObject *v7;
  void ***v8;
  id v9;
  void *v10;
  void *v11;
  int is_local_network_allowed;
  id v13;
  NSObject *v14;
  uint64_t v15;
  void *v16;
  const char *v17;
  __CFString *v18;
  id v19;
  NSObject *v20;
  __int128 v21;
  pid_t v22;
  void *v23;
  void *v24;
  void *context;
  void **v26;
  uint64_t v27;
  void (*v28)(uint64_t, int);
  void *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t v33;
  int v34;
  uint8_t v35[4];
  pid_t v36;
  audit_token_t buf;
  __CFString *v38;
  void ***v39;
  uint64_t *v40;

  v2 = *(_BYTE **)(a1 + 32);
  v2[24] = 1;
  os_retain(v2);
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(void **)(v3 + 32);
  v5 = *(const char **)(v3 + 104);
  v6 = *(_DWORD *)(v3 + 112);
  v26 = _NSConcreteStackBlock;
  v27 = 0x40000000;
  v28 = ___mdns_trust_activate_internal_block_invoke_2;
  v29 = &__block_descriptor_tmp_7_4112;
  v30 = v3;
  v7 = v4;
  v8 = &v26;
  context = objc_autoreleasePoolPush();
  v9 = _mdns_trust_checks_bundle_record_for_app((_OWORD *)(v3 + 72));
  v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
  v11 = v10;
  v31 = 0;
  v32 = &v31;
  v33 = 0x2020000000;
  v34 = 0;
  if (v10)
    is_local_network_allowed = _mdns_trust_checks_app_is_local_network_allowed(v10);
  else
    is_local_network_allowed = 1;
  v34 = is_local_network_allowed;
  if (objc_opt_class(NEConfigurationManager) && *((_DWORD *)v32 + 6) == 2)
  {
    v13 = _mdns_trust_log();
    v14 = objc_claimAutoreleasedReturnValue(v13);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
    {
      v15 = objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "localizedShortName", context, v26, v27, v28, v29, v30, v31));
      v16 = (void *)v15;
      v17 = "local";
      if (v5)
        v17 = v5;
      buf.val[0] = 138543618;
      *(_QWORD *)&buf.val[1] = v15;
      LOWORD(buf.val[3]) = 2082;
      *(_QWORD *)((char *)&buf.val[3] + 2) = v17;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "Local network alert for (%{public}@) query(%{public}s).", (uint8_t *)&buf, 0x16u);

    }
    if (v5)
      v18 = (__CFString *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v5));
    else
      v18 = CFSTR("local");
    v23 = (void *)objc_claimAutoreleasedReturnValue(+[NEConfigurationManager sharedManagerForAllUsers](NEConfigurationManager, "sharedManagerForAllUsers", context));
    v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "bundleIdentifier"));
    *(_QWORD *)buf.val = _NSConcreteStackBlock;
    *(_QWORD *)&buf.val[2] = 3221225472;
    *(_QWORD *)&buf.val[4] = __mdns_trust_checks_local_network_access_policy_update_block_invoke;
    *(_QWORD *)&buf.val[6] = &unk_10013F6A8;
    v40 = &v31;
    v38 = v11;
    v39 = v8;
    objc_msgSend(v23, "showLocalNetworkAlertForApp:withCompletionQueue:query:hasEntitlement:handler:", v24, v7, v18, v6 & 1, &buf);

  }
  else
  {
    if (!v11)
    {
      v19 = _mdns_trust_log();
      v20 = objc_claimAutoreleasedReturnValue(v19);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
      {
        v21 = *(_OWORD *)(v3 + 88);
        *(_OWORD *)buf.val = *(_OWORD *)(v3 + 72);
        *(_OWORD *)&buf.val[4] = v21;
        v22 = audit_token_to_pid(&buf);
        *(_DWORD *)v35 = 67109120;
        v36 = v22;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_INFO, "No bundle found for local network access policy update for PID(%d).", v35, 8u);
      }

    }
    *(_QWORD *)buf.val = _NSConcreteStackBlock;
    *(_QWORD *)&buf.val[2] = 3221225472;
    *(_QWORD *)&buf.val[4] = __mdns_trust_checks_local_network_access_policy_update_block_invoke_11;
    *(_QWORD *)&buf.val[6] = &unk_10013F6D0;
    v38 = v8;
    v39 = (void ***)&v31;
    dispatch_async(v7, &buf);
    v18 = v38;
  }

  _Block_object_dispose(&v31, 8);
  objc_autoreleasePoolPop(context);

  os_release(*(void **)(a1 + 32));
}

void sub_1000BB950(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ___mdns_trust_activate_internal_block_invoke_2(uint64_t a1, int a2)
{
  _BYTE *v3;
  uint64_t v5;
  NSObject *v6;
  _QWORD v7[5];
  int v8;

  v3 = *(_BYTE **)(a1 + 32);
  if (!v3[25])
  {
    v3[25] = 1;
    os_retain(v3);
    v5 = *(_QWORD *)(a1 + 32);
    v6 = *(NSObject **)(v5 + 40);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 0x40000000;
    v7[2] = ___mdns_trust_activate_internal_block_invoke_3;
    v7[3] = &__block_descriptor_tmp_4114;
    v7[4] = v5;
    v8 = a2;
    dispatch_async(v6, v7);
    v3 = *(_BYTE **)(a1 + 32);
  }
  os_release(v3);
}

void ___mdns_trust_activate_internal_block_invoke_3(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;

  v2 = *(_QWORD **)(a1 + 32);
  v3 = v2[6];
  if (v3)
  {
    (*(void (**)(_QWORD, _QWORD, BOOL))(v3 + 16))(v2[6], 0, *(_DWORD *)(a1 + 40) == 1);
    v2 = *(_QWORD **)(a1 + 32);
  }
  os_release(v2);
}

void mdns_trust_invalidate(uint64_t a1)
{
  NSObject *v2;
  _QWORD block[5];

  if (!*(_BYTE *)(a1 + 27))
  {
    *(_BYTE *)(a1 + 27) = 1;
    os_retain((void *)a1);
    v2 = *(NSObject **)(a1 + 32);
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    block[2] = ___mdns_trust_invalidate_internal_block_invoke;
    block[3] = &__block_descriptor_tmp_9_4117;
    block[4] = a1;
    dispatch_async(v2, block);
  }
}

void ___mdns_trust_invalidate_internal_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 32);
  if (*(_BYTE *)(v2 + 27))
  {
    if (!*(_BYTE *)(v2 + 25))
    {
      *(_BYTE *)(v2 + 25) = 1;
      v3 = *(_QWORD *)(v2 + 48);
      if (v3)
      {
        (*(void (**)(_QWORD, uint64_t, _QWORD))(v3 + 16))(*(_QWORD *)(v2 + 48), 1, 0);
        v2 = *(_QWORD *)(a1 + 32);
      }
    }
  }
  os_release((void *)v2);
}

void mdns_trust_set_queue(NSObject **object, dispatch_object_t a2)
{
  NSObject *v4;

  if (!*((_BYTE *)object + 26) || !object[5])
  {
    if (a2)
      dispatch_retain(a2);
    v4 = object[5];
    if (v4)
      dispatch_release(v4);
    object[5] = a2;
    _mdns_trust_activate_if_ready(object);
  }
}

void mdns_trust_set_event_handler(uint64_t a1, void *aBlock)
{
  void *v3;
  const void *v4;

  if (aBlock)
    v3 = _Block_copy(aBlock);
  else
    v3 = 0;
  v4 = *(const void **)(a1 + 48);
  if (v4)
    _Block_release(v4);
  *(_QWORD *)(a1 + 48) = v3;
}

void _mdns_client_finalize(_QWORD *a1)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  _QWORD v7[6];

  v3 = a1 + 4;
  v2 = a1[4];
  if (v2)
  {
    v4 = a1[5];
    if (v4)
    {
      v5 = a1[3];
      if (v5)
      {
        v7[0] = _NSConcreteStackBlock;
        v7[1] = 0x40000000;
        v7[2] = ___mdns_client_finalize_block_invoke;
        v7[3] = &__block_descriptor_tmp_3_4123;
        v7[4] = v4;
        v7[5] = v2;
        dispatch_async(v5, v7);
      }
    }
  }
  *v3 = 0;
  v3[1] = 0;
  v6 = a1[3];
  if (v6)
  {
    dispatch_release(v6);
    a1[3] = 0;
  }
}

uint64_t ___mdns_client_finalize_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 32))(*(_QWORD *)(a1 + 40));
}

void mdns_client_replace(void **a1, void *object)
{
  if (object)
    os_retain(object);
  if (*a1)
    os_release(*a1);
  *a1 = object;
}

void mdns_client_set_queue(uint64_t a1, dispatch_object_t object)
{
  NSObject *v4;

  if (!*(_BYTE *)(a1 + 49))
  {
    if (object)
      dispatch_retain(object);
    v4 = *(NSObject **)(a1 + 24);
    if (v4)
      dispatch_release(v4);
    *(_QWORD *)(a1 + 24) = object;
  }
}

void mdns_client_activate(uint64_t a1)
{
  void *v2;
  NSObject *v3;
  _QWORD block[5];

  *(_BYTE *)(a1 + 49) = 1;
  v2 = os_retain((void *)a1);
  v3 = (*(uint64_t (**)(void *))(*(_QWORD *)(a1 + 16) + 48))(v2);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = __mdns_client_activate_block_invoke;
  block[3] = &__block_descriptor_tmp_4141;
  block[4] = a1;
  dispatch_async(v3, block);
}

void __mdns_client_activate_block_invoke(uint64_t a1)
{
  uint64_t v1;
  void (*v2)(_QWORD);
  uint64_t v3;

  v1 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v1 + 48))
  {
    v2 = *(void (**)(_QWORD))(*(_QWORD *)(v1 + 16) + 64);
    v3 = *(_QWORD *)(a1 + 32);
    if (v2)
    {
      v2(*(_QWORD *)(a1 + 32));
      v3 = *(_QWORD *)(a1 + 32);
    }
    *(_BYTE *)(v1 + 48) = 1;
    v1 = v3;
  }
  os_release((void *)v1);
}

void mdns_client_invalidate(uint64_t a1)
{
  void *v2;
  NSObject *v3;
  _QWORD block[5];

  *(_BYTE *)(a1 + 49) = 1;
  v2 = os_retain((void *)a1);
  v3 = (*(uint64_t (**)(void *))(*(_QWORD *)(a1 + 16) + 48))(v2);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = __mdns_client_invalidate_block_invoke;
  block[3] = &__block_descriptor_tmp_2_4144;
  block[4] = a1;
  dispatch_async(v3, block);
}

void __mdns_client_invalidate_block_invoke(uint64_t a1)
{
  uint64_t v1;
  void (*v2)(_QWORD);
  uint64_t v3;

  v1 = *(_QWORD *)(a1 + 32);
  if (*(_BYTE *)(v1 + 48) != 2)
  {
    v2 = *(void (**)(_QWORD))(*(_QWORD *)(v1 + 16) + 72);
    v3 = *(_QWORD *)(a1 + 32);
    if (v2)
    {
      v2(*(_QWORD *)(a1 + 32));
      v3 = *(_QWORD *)(a1 + 32);
    }
    *(_BYTE *)(v1 + 48) = 2;
    v1 = v3;
  }
  os_release((void *)v1);
}

uint64_t _dnssec_obj_rr_validator_compare()
{
  return 2;
}

void _dnssec_obj_rr_validator_finalize(_QWORD *a1)
{
  unint64_t v2;
  unint64_t i;
  _QWORD *v4;
  void *v5;
  unint64_t v6;
  unint64_t j;
  _QWORD *v8;
  void *v9;
  unint64_t v10;
  unint64_t k;
  _QWORD *v12;
  void *v13;
  unint64_t v14;
  unint64_t m;
  _QWORD *v16;
  void *v17;
  unint64_t v18;
  unint64_t n;
  _QWORD *v20;
  void *v21;

  v2 = a1[3];
  if (v2)
  {
    for (i = 0; i < v2; ++i)
    {
      v4 = *(_QWORD **)(a1[2] + 8 * i);
      if (v4)
      {
        ref_count_obj_release(v4);
        v2 = a1[3];
        *(_QWORD *)(a1[2] + 8 * i) = 0;
      }
    }
  }
  v5 = (void *)a1[2];
  if (v5)
  {
    free(v5);
    a1[2] = 0;
  }
  v6 = a1[5];
  if (v6)
  {
    for (j = 0; j < v6; ++j)
    {
      v8 = *(_QWORD **)(a1[4] + 8 * j);
      if (v8)
      {
        ref_count_obj_release(v8);
        v6 = a1[5];
        *(_QWORD *)(a1[4] + 8 * j) = 0;
      }
    }
  }
  v9 = (void *)a1[4];
  if (v9)
  {
    free(v9);
    a1[4] = 0;
  }
  v10 = a1[7];
  if (v10)
  {
    for (k = 0; k < v10; ++k)
    {
      v12 = *(_QWORD **)(a1[6] + 8 * k);
      if (v12)
      {
        ref_count_obj_release(v12);
        v10 = a1[7];
        *(_QWORD *)(a1[6] + 8 * k) = 0;
      }
    }
  }
  v13 = (void *)a1[6];
  if (v13)
  {
    free(v13);
    a1[6] = 0;
  }
  v14 = a1[9];
  if (v14)
  {
    for (m = 0; m < v14; ++m)
    {
      v16 = *(_QWORD **)(a1[8] + 8 * m);
      if (v16)
      {
        ref_count_obj_release(v16);
        v14 = a1[9];
        *(_QWORD *)(a1[8] + 8 * m) = 0;
      }
    }
  }
  v17 = (void *)a1[8];
  if (v17)
  {
    free(v17);
    a1[8] = 0;
  }
  v18 = a1[12];
  if (v18)
  {
    for (n = 0; n < v18; ++n)
    {
      v20 = *(_QWORD **)(a1[10] + 8 * n);
      if (v20)
      {
        ref_count_obj_release(v20);
        *(_QWORD *)(a1[10] + 8 * n) = 0;
        v18 = a1[12];
      }
    }
  }
  v21 = (void *)a1[10];
  if (v21)
  {
    free(v21);
    a1[10] = 0;
  }
}

_QWORD *dnssec_obj_rr_validator_create(_DWORD **a1, size_t a2, _DWORD **a3, size_t a4, _DWORD **a5, size_t a6, _DWORD **a7, size_t a8, _DWORD **a9, size_t a10, _DWORD *a11)
{
  _QWORD *result;
  _QWORD *v20;
  size_t v21;
  _UNKNOWN **v23;
  uint64_t (*v24)(_QWORD *);
  size_t v25;
  size_t v26;
  _QWORD *v27;
  size_t v28;
  size_t v29;
  size_t v30;
  _QWORD *v31;
  _QWORD *v32;
  size_t v33;
  _DWORD *v34;
  _QWORD *v35;
  size_t v36;
  _DWORD *v37;
  _QWORD *v38;
  size_t v39;
  _DWORD *v40;
  _QWORD *v41;
  size_t v42;
  _DWORD *v43;
  _QWORD *v44;
  size_t v45;
  _DWORD *v46;
  size_t v47;
  _QWORD *v48;
  size_t v49;
  _QWORD *v50;
  _QWORD *v51;

  result = malloc_type_calloc(1uLL, 0x68uLL, 0xF1748037uLL);
  if (!result)
    goto LABEL_44;
  v20 = result;
  v49 = a6;
  v21 = a8;
  v23 = &_dnssec_obj_rr_validator_kind;
  result[1] = &_dnssec_obj_rr_validator_kind;
  do
  {
    v24 = (uint64_t (*)(_QWORD *))v23[2];
    if (v24)
      result = (_QWORD *)v24(v20);
    v23 = (_UNKNOWN **)*v23;
  }
  while (v23);
  ++*(_DWORD *)v20;
  if (!a2)
  {
    v51 = 0;
    v25 = v21;
    if (a4)
      goto LABEL_10;
LABEL_20:
    v48 = 0;
    v26 = v49;
    if (v49)
      goto LABEL_13;
LABEL_21:
    v50 = 0;
    if (v25)
      goto LABEL_16;
LABEL_22:
    v27 = 0;
    goto LABEL_23;
  }
  result = (_QWORD *)a2;
  if (a2 >> 61)
    goto LABEL_44;
  v25 = v21;
  result = malloc_type_calloc(a2, 8uLL, 0xF1748037uLL);
  v51 = result;
  if (!result)
    goto LABEL_44;
  if (!a4)
    goto LABEL_20;
LABEL_10:
  v26 = v49;
  if (a4 >> 61)
    goto LABEL_44;
  result = malloc_type_calloc(a4, 8uLL, 0xF1748037uLL);
  v48 = result;
  if (!result)
    goto LABEL_44;
  if (!v49)
    goto LABEL_21;
LABEL_13:
  if (v26 >> 61)
    goto LABEL_44;
  result = malloc_type_calloc(v26, 8uLL, 0xF1748037uLL);
  v50 = result;
  if (!result)
    goto LABEL_44;
  if (!v25)
    goto LABEL_22;
LABEL_16:
  if (v25 >> 61)
    goto LABEL_44;
  result = malloc_type_calloc(v25, 8uLL, 0xF1748037uLL);
  v27 = result;
  if (!result)
    goto LABEL_44;
LABEL_23:
  result = (_QWORD *)a10;
  if (a10)
  {
    if (a10 >> 61)
      goto LABEL_44;
    v47 = a2;
    v28 = a4;
    v29 = v26;
    v30 = v25;
    v31 = v27;
    result = malloc_type_calloc(a10, 8uLL, 0xF1748037uLL);
    v27 = v31;
    v25 = v30;
    v26 = v29;
    a4 = v28;
    a2 = v47;
    if (!result)
    {
LABEL_44:
      __break(1u);
      return result;
    }
  }
  if (a2)
  {
    v32 = v51;
    v33 = a2;
    do
    {
      v34 = *a1++;
      *v32++ = v34;
      ++*v34;
      --v33;
    }
    while (v33);
  }
  if (a4)
  {
    v35 = v48;
    v36 = a4;
    do
    {
      v37 = *a3++;
      *v35++ = v37;
      ++*v37;
      --v36;
    }
    while (v36);
  }
  if (v26)
  {
    v38 = v50;
    v39 = v26;
    do
    {
      v40 = *a5++;
      *v38++ = v40;
      ++*v40;
      --v39;
    }
    while (v39);
  }
  if (v25)
  {
    v41 = v27;
    v42 = v25;
    do
    {
      v43 = *a7++;
      *v41++ = v43;
      ++*v43;
      --v42;
    }
    while (v42);
  }
  if (a10)
  {
    v44 = result;
    v45 = a10;
    do
    {
      v46 = *a9++;
      *v44++ = v46;
      ++*v46;
      --v45;
    }
    while (v45);
  }
  v20[2] = v51;
  v20[3] = a2;
  v20[4] = v48;
  v20[5] = a4;
  v20[6] = v50;
  v20[7] = v26;
  v20[8] = v27;
  v20[9] = v25;
  v20[10] = result;
  v20[12] = a10;
  *((_DWORD *)v20 + 22) = 0;
  ++*(_DWORD *)v20;
  if (a11)
    *a11 = 0;
  ref_count_obj_release(v20);
  return v20;
}

uint64_t dnssec_obj_rr_validator_validate_rrset(uint64_t a1, int *a2)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  void *v10;
  int v11;
  uint64_t v12;
  int v13;
  BOOL v14;
  unint64_t v15;
  uint64_t v16;
  unsigned int v17;
  int v18;
  int v20;
  void *v21;
  int v22;

  v20 = 0;
  if (!*(_QWORD *)(a1 + 24))
  {
    v9 = 0;
    v18 = -89888;
    goto LABEL_39;
  }
  if (*(_WORD *)(**(_QWORD **)(a1 + 16) + 32) != 48)
  {
    v9 = dnssec_obj_rr_validator_validate_rrset_with_key_tag((_QWORD *)a1, 0, 0, &v20);
    if (!a2)
      return v9;
    goto LABEL_40;
  }
  if (*(_QWORD *)(a1 + 96))
  {
    v22 = -6700;
    if (*(_QWORD *)(a1 + 40))
    {
      v4 = 0;
      v5 = *(_DWORD *)(a1 + 88);
      while (1)
      {
        v6 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 8 * v4);
        v7 = *(_QWORD *)(v6 + 16);
        if (*(_WORD *)(v7 + 32) == 43)
          v8 = bswap32(**(unsigned __int16 **)(v7 + 24)) >> 16;
        else
          v8 = *(unsigned __int16 *)(v7 + 80);
        v21 = 0;
        v9 = dnssec_obj_rr_validator_validate_rrset_with_key_tag((_QWORD *)a1, v8, &v21, &v22);
        if ((_DWORD)v9 != 1)
          goto LABEL_18;
        v10 = v21;
        v11 = time(0);
        if (v11 - *(_DWORD *)(v6 + 24) < 0 || *(_DWORD *)(v6 + 28) - v11 < 0)
          break;
        v12 = *(_QWORD *)(v6 + 16);
        if (*(_WORD *)(v12 + 32) == 43)
        {
          if ((dnssec_obj_rr_ds_validates_dnskey(v12, (uint64_t)v10, 0) & 1) == 0)
            break;
        }
        else if (ref_count_obj_compare(v12, (uint64_t)v10, 1))
        {
          break;
        }
        v13 = 0;
        v9 = 1;
LABEL_17:
        v22 = v13;
LABEL_18:
        if (v21)
          ref_count_obj_release(v21);
        v14 = (_DWORD)v9 != 1;
        if (v5)
          v14 = (_DWORD)v9 == 0;
        if ((unint64_t)++v4 >= *(_QWORD *)(a1 + 96) || !v14)
          goto LABEL_38;
      }
      v9 = 3;
      v13 = -89893;
      goto LABEL_17;
    }
    goto LABEL_43;
  }
  if (*(_QWORD *)(a1 + 72))
  {
    v22 = -6700;
    if (!*(_QWORD *)(a1 + 40))
    {
LABEL_43:
      v9 = 0;
      v18 = -89889;
      goto LABEL_39;
    }
    v15 = 0;
    do
    {
      v16 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v15);
      v17 = bswap32(**(unsigned __int16 **)(v16 + 24)) >> 16;
      v21 = 0;
      v9 = dnssec_obj_rr_validator_validate_rrset_with_key_tag((_QWORD *)a1, v17, &v21, &v22);
      if ((_DWORD)v9 == 1)
      {
        if (dnssec_obj_rr_ds_validates_dnskey(v16, (uint64_t)v21, &v22))
          v9 = 1;
        else
          v9 = 3;
      }
      if (v21)
        ref_count_obj_release(v21);
      ++v15;
    }
    while (v15 < *(_QWORD *)(a1 + 72) && !(_DWORD)v9);
LABEL_38:
    v18 = v22;
  }
  else
  {
    v9 = 0;
    v18 = -89892;
  }
LABEL_39:
  v20 = v18;
  if (a2)
LABEL_40:
    *a2 = v20;
  return v9;
}

uint64_t dnssec_obj_rr_validator_validate_rrset_with_key_tag(_QWORD *a1, int a2, _QWORD *a3, _DWORD *a4)
{
  uint64_t v6;
  uint64_t v9;
  uint64_t *v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  unsigned int v27;
  time_t v28;
  __SecKey *RSAPublicKey;
  _BYTE *v30;
  uint64_t v31;
  int v32;
  int v33;
  NSObject *v34;
  uint64_t v35;
  size_t v37;
  unint64_t v38;
  uint64_t v39;
  unsigned int v40;
  char v41;
  uint64_t *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unsigned int v48;
  unsigned int v49;
  uint64_t v50;
  uint64_t v51;
  unsigned int v52;
  unsigned __int16 v53;
  size_t v54;
  size_t v55;
  uint64_t v56;
  uint64_t *v57;
  uint64_t *v58;
  char *v59;
  uint64_t *v60;
  unint64_t v61;
  uint64_t v62;
  size_t v63;
  uint64_t v64;
  char *signed_data;
  uint64_t v66;
  void *v67;
  uint64_t v68;
  unsigned int v69;
  unsigned int public_key_size;
  uint64_t v71;
  unsigned int v72;
  unsigned int v73;
  uint64_t *v74;
  char *v75;
  unsigned int v76;
  int v77;
  __int16 v78;
  const UInt8 *v79;
  unsigned __int8 *v80;
  unsigned __int8 *v81;
  uint64_t v82;
  __int16 v83;
  uint64_t v84;
  const __CFAllocator *v85;
  __CFData *Mutable;
  __CFData *v87;
  const __CFDictionary *v88;
  const __CFDictionary *v89;
  CFDataRef v90;
  int v91;
  const __CFAllocator *v92;
  uint8_t *v93;
  CFIndex OutputSize;
  uint64_t v95;
  const __CFData *v96;
  int v97;
  int v98;
  int v99;
  NSObject *v100;
  _QWORD *v103;
  uint64_t *v104;
  _DWORD *v105;
  int v106;
  UInt8 bytes;
  void *values[2];
  uint8_t buf[32];
  __int128 v110;
  __int128 v111;

  if (!a1[5])
  {
    v35 = 0;
    v99 = -89889;
LABEL_107:
    v106 = v99;
    goto LABEL_42;
  }
  if (!a1[7])
  {
    v35 = 0;
    v99 = -89890;
    goto LABEL_107;
  }
  v6 = a1[3];
  if (!v6)
  {
    v100 = mDNSLogCategory_DNSSEC;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
      {
LABEL_117:
        v106 = -89891;
        v35 = 3;
        goto LABEL_42;
      }
    }
    else
    {
      v100 = mDNSLogCategory_DNSSEC_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT))
        goto LABEL_117;
    }
    *(_DWORD *)buf = 136447234;
    *(_QWORD *)&buf[4] = "count > 0";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = "";
    *(_WORD *)&buf[22] = 2082;
    *(_QWORD *)&buf[24] = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rr.c";
    LOWORD(v110) = 1024;
    *(_DWORD *)((char *)&v110 + 2) = 266;
    WORD3(v110) = 2048;
    *((_QWORD *)&v110 + 1) = 0;
    _os_log_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", buf, 0x30u);
    goto LABEL_117;
  }
  v9 = v6 - 1;
  if (v6 == 1)
  {
    v106 = -89889;
  }
  else
  {
    v10 = (uint64_t *)a1[2];
    v11 = *(unsigned __int16 *)(*v10 + 34);
    v12 = *(unsigned __int16 *)(*v10 + 32);
    v13 = *(_QWORD *)(*v10 + 16);
    v14 = v10 + 1;
    do
    {
      v15 = *v14;
      if (*(unsigned __int16 *)(*v14 + 34) != v11
        || *(unsigned __int16 *)(v15 + 32) != v12
        || ref_count_obj_compare(*(_QWORD *)(v15 + 16), v13, 1))
      {
        goto LABEL_117;
      }
      ++v14;
      --v9;
    }
    while (v9);
    v16 = a1[5];
    v106 = -89889;
    if (!v16)
    {
      v35 = 0;
      goto LABEL_42;
    }
  }
  v103 = a3;
  v105 = a4;
  v17 = 0;
  while (1)
  {
    v18 = *(_QWORD *)(a1[4] + 8 * v17);
    v19 = *(_QWORD *)(v18 + 24);
    v20 = *(unsigned __int8 *)(v19 + 16);
    if (a2)
    {
      v21 = *(unsigned __int8 *)(v19 + 17) | (v20 << 8);
      if (v21 != a2)
        goto LABEL_23;
    }
    else
    {
      v21 = *(unsigned __int8 *)(v19 + 17) | (v20 << 8);
    }
    v22 = a1[7];
    if (v22)
    {
      v23 = (uint64_t *)a1[6];
      while (1)
      {
        v24 = *v23;
        if (*v23)
        {
          if (*(unsigned __int16 *)(v24 + 80) == v21
            && (dnssec_obj_rr_dnskey_is_valid_for_dnssec(*(_BYTE **)(v24 + 24), &v106) & 1) != 0)
          {
            break;
          }
        }
        ++v23;
        if (!--v22)
          goto LABEL_23;
      }
      v25 = *(_QWORD *)a1[2];
      v26 = (uint64_t *)bswap32(*(_DWORD *)(v19 + 12));
      v27 = bswap32(*(_DWORD *)(v19 + 8));
      v28 = time(0);
      RSAPublicKey = (__SecKey *)v28;
      if ((_DWORD)v28 - (_DWORD)v26 < 0 || ((v27 - (_DWORD)v28) & 0x80000000) != 0)
      {
        v34 = mDNSLogCategory_DNSSEC;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_ERROR))
            goto LABEL_38;
        }
        else
        {
          v34 = mDNSLogCategory_DNSSEC_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_ERROR))
          {
LABEL_38:
            *(_DWORD *)buf = 67109632;
            *(_DWORD *)&buf[4] = (_DWORD)v26;
            *(_WORD *)&buf[8] = 1024;
            *(_DWORD *)&buf[10] = (_DWORD)RSAPublicKey;
            *(_WORD *)&buf[14] = 1024;
            *(_DWORD *)&buf[16] = v27;
            _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "Invalid RRSIG timestamp - inception: %u, now: %u, expiration: %u", buf, 0x14u);
          }
        }
        v33 = -90000;
LABEL_40:
        v106 = v33;
        goto LABEL_23;
      }
      v106 = 0;
      if (dnssec_obj_rr_rrsig_covers_rr(v18, v25, &v106))
        break;
    }
LABEL_23:
    if ((unint64_t)++v17 >= a1[5])
    {
      v35 = 0;
      a4 = v105;
      goto LABEL_42;
    }
  }
  v30 = *(_BYTE **)(v24 + 24);
  if ((*v30 & 1) == 0)
  {
    v33 = -88888;
    goto LABEL_40;
  }
  v31 = *(_QWORD *)(v18 + 24);
  v32 = v30[3];
  v33 = -89895;
  if (*(unsigned __int8 *)(v31 + 2) != v32)
    goto LABEL_40;
  v33 = -89895;
  if (*(unsigned __int16 *)(v24 + 80) != bswap32(*(unsigned __int16 *)(v31 + 16)) >> 16)
    goto LABEL_40;
  if (ref_count_obj_compare(*(_QWORD *)(v18 + 80), *(_QWORD *)(v24 + 16), 1))
  {
    v33 = -89895;
    goto LABEL_40;
  }
  v106 = 0;
  v37 = a1[2];
  v38 = a1[3];
  if (v38)
  {
    v39 = *(_QWORD *)(v18 + 24);
    v40 = bswap32(*(_DWORD *)(v39 + 4));
    v41 = *(_BYTE *)(v39 + 3);
    v42 = (uint64_t *)a1[2];
    v43 = a1[3];
    do
    {
      v44 = *v42++;
      *(_DWORD *)(v44 + 44) = v40;
      *(_BYTE *)(v44 + 48) = v41;
      --v43;
    }
    while (v43);
  }
  dnssec_objs_sort(v37, v38);
  v45 = *(_QWORD *)(v18 + 24);
  v46 = *(unsigned __int16 *)(v18 + 36);
  v49 = *(unsigned __int8 *)(v45 + 18);
  v47 = v45 + 18;
  v48 = v49;
  LOWORD(v50) = v47;
  if (v49)
  {
    v50 = v47;
    do
    {
      v51 = v50 + v48;
      v52 = *(unsigned __int8 *)(v51 + 1);
      v50 = v51 + 1;
      v48 = v52;
    }
    while (v52);
  }
  v53 = v46 + v47 - 18 + ~(_WORD)v50;
  v54 = v46 - v53;
  v55 = v54;
  if (v38)
  {
    v26 = (uint64_t *)v37;
    RSAPublicKey = (__SecKey *)v38;
    v55 = v46 - v53;
    do
    {
      v56 = *v26++;
      dnssec_obj_rr_get_signed_data(v56);
      v55 += *(_QWORD *)(v56 + 64);
      RSAPublicKey = (__SecKey *)((char *)RSAPublicKey - 1);
    }
    while (RSAPublicKey);
  }
  if (!v55)
    goto LABEL_118;
  v57 = (uint64_t *)malloc_type_malloc(v55, 0xA172743EuLL);
  if (!v57)
    goto LABEL_118;
  v58 = v57;
  memcpy(v57, *(const void **)(v18 + 24), v54);
  v104 = v58;
  if (v38)
  {
    v59 = (char *)v58 + v54;
    v60 = (uint64_t *)v37;
    v61 = v38;
    do
    {
      v62 = *v60;
      dnssec_obj_rr_get_signed_data(*v60);
      v63 = *(_QWORD *)(v62 + 64);
      v64 = *v60++;
      signed_data = dnssec_obj_rr_get_signed_data(v64);
      memcpy(v59, signed_data, v63);
      v59 += v63;
      --v61;
    }
    while (v61);
    v106 = 0;
    do
    {
      v66 = *(_QWORD *)v37;
      *(_DWORD *)(v66 + 44) = 0;
      *(_BYTE *)(v66 + 48) = 0;
      *(_QWORD *)(v66 + 64) = 0;
      v67 = *(void **)(v66 + 56);
      if (v67)
      {
        free(v67);
        *(_QWORD *)(v66 + 56) = 0;
      }
      v37 += 8;
      --v38;
    }
    while (v38);
  }
  else
  {
    v106 = 0;
  }
  if (v103)
  {
    *v103 = v24;
    ++*(_DWORD *)v24;
  }
  v68 = *(_QWORD *)(v24 + 24);
  v69 = *(unsigned __int8 *)(v68 + 3);
  public_key_size = rdata_parser_dnskey_get_public_key_size(*(unsigned __int16 *)(v24 + 36));
  v71 = *(_QWORD *)(v18 + 24);
  v73 = *(unsigned __int8 *)(v71 + 18);
  v26 = (uint64_t *)(v71 + 18);
  v72 = v73;
  v74 = v26;
  if (v73)
  {
    v74 = v26;
    do
    {
      v75 = (char *)v74 + v72;
      v76 = v75[1];
      v74 = (uint64_t *)(v75 + 1);
      v72 = v76;
    }
    while (v76);
  }
  RSAPublicKey = 0;
  v77 = -88890;
  if (v69 > 0xE)
  {
LABEL_126:
    v35 = 0;
    v106 = v77;
    a4 = v105;
    v26 = v104;
    if (RSAPublicKey)
      goto LABEL_103;
    goto LABEL_104;
  }
  v78 = *(_WORD *)(v18 + 36);
  v79 = (const UInt8 *)(v68 + 4);
  v37 = public_key_size;
  if (((1 << v69) & 0x5A0) == 0)
  {
    if (((1 << v69) & 0x6000) == 0)
      goto LABEL_126;
    v83 = v78;
    bytes = 4;
    v85 = kCFAllocatorDefault;
    Mutable = CFDataCreateMutable(kCFAllocatorDefault, public_key_size + 1);
    if (!Mutable)
    {
      RSAPublicKey = 0;
LABEL_122:
      v77 = -6728;
      goto LABEL_126;
    }
    v87 = Mutable;
    CFDataAppendBytes(Mutable, &bytes, 1);
    CFDataAppendBytes(v87, v79, v37);
    *(_QWORD *)buf = kSecAttrKeyType;
    *(_QWORD *)&buf[8] = kSecAttrKeyClass;
    values[0] = (void *)kSecAttrKeyTypeECSECPrimeRandom;
    values[1] = (void *)kSecAttrKeyClassPublic;
    v88 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)buf, (const void **)values, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (v88)
    {
      v89 = v88;
      RSAPublicKey = SecKeyCreateWithData(v87, v88, 0);
      CFRelease(v89);
      if (RSAPublicKey)
      {
        CFRelease(v87);
        goto LABEL_84;
      }
      v77 = -6700;
    }
    else
    {
      v77 = -6728;
    }
    CFRelease(v87);
    RSAPublicKey = 0;
    goto LABEL_126;
  }
  if (!public_key_size || (v80 = (unsigned __int8 *)malloc_type_malloc(public_key_size, 0xA172743EuLL)) == 0)
  {
LABEL_118:
    __break(1u);
    goto LABEL_119;
  }
  v81 = v80;
  memcpy(v80, v79, v37);
  v82 = *v81;
  v83 = v78;
  if (*v81)
  {
    v84 = 1;
  }
  else
  {
    v82 = __rev16(*(unsigned __int16 *)(v81 + 1));
    v84 = 3;
  }
  *(_QWORD *)&buf[16] = &v81[v84];
  *(_QWORD *)&buf[24] = v82;
  *(_QWORD *)buf = &v81[v84 + v82];
  *(_QWORD *)&buf[8] = v37 - v82 - v84;
  v85 = kCFAllocatorDefault;
  RSAPublicKey = (__SecKey *)SecKeyCreateRSAPublicKey(kCFAllocatorDefault, buf, 32, 3);
  free(v81);
LABEL_84:
  v90 = CFDataCreate(v85, (const UInt8 *)v74 + 1, (unsigned __int16)(~((_WORD)v74 - (_WORD)v26) + v83 - 18));
  if (!v90)
    goto LABEL_122;
  v37 = (size_t)v90;
  v91 = -88890;
  v26 = v104;
  if (((1 << v69) & 0x5A0) != 0)
  {
    v92 = v85;
    v93 = (uint8_t *)v104;
    OutputSize = v55;
    goto LABEL_92;
  }
  if (v69 == 13)
  {
    v95 = 10;
    goto LABEL_91;
  }
  if (v69 != 14)
    goto LABEL_120;
  v95 = 11;
LABEL_91:
  v110 = 0u;
  v111 = 0u;
  memset(buf, 0, sizeof(buf));
  CCDigest(v95, v104, v55, buf);
  OutputSize = CCDigestGetOutputSize(v95);
  v93 = buf;
  v92 = v85;
LABEL_92:
  v96 = CFDataCreate(v92, v93, OutputSize);
  if (!v96)
  {
LABEL_119:
    v91 = -6728;
LABEL_120:
    v35 = 0;
    v106 = v91;
    a4 = v105;
    goto LABEL_102;
  }
  v35 = 3;
  if (((0x32Du >> (v69 - 5)) & 1) != 0)
  {
    v98 = SecKeyVerifySignature(RSAPublicKey, *(SecKeyAlgorithm *)*(&off_10013C5C0 + (v69 - 5)), v96, (CFDataRef)v37, 0);
    if (v98)
      v35 = 1;
    else
      v35 = 3;
    if (v98)
      v97 = 0;
    else
      v97 = -6748;
  }
  else
  {
    v97 = -6735;
  }
  a4 = v105;
  v106 = v97;
  CFRelease(v96);
LABEL_102:
  CFRelease((CFTypeRef)v37);
  if (RSAPublicKey)
LABEL_103:
    CFRelease(RSAPublicKey);
LABEL_104:
  free(v26);
LABEL_42:
  if (a4)
    *a4 = v106;
  return v35;
}

uint64_t _dnssec_obj_rr_compare(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t result;
  const void *v6;
  unsigned int v7;
  const void *v8;
  unsigned int v9;
  size_t v10;
  int v11;
  BOOL v12;

  if (a3)
  {
    if (*(unsigned __int16 *)(a1 + 34) == *(unsigned __int16 *)(a2 + 34)
      && *(unsigned __int16 *)(a1 + 32) == *(unsigned __int16 *)(a2 + 32)
      && *(unsigned __int16 *)(a1 + 36) == *(unsigned __int16 *)(a2 + 36)
      && !ref_count_obj_compare(*(_QWORD *)(a1 + 16), *(_QWORD *)(a2 + 16), 1))
    {
      return 2
           * (memcmp(*(const void **)(a1 + 24), *(const void **)(a2 + 24), *(unsigned __int16 *)(a1 + 36)) != 0);
    }
    else
    {
      return 2;
    }
  }
  else if (!ref_count_obj_compare(*(_QWORD *)(a1 + 16), *(_QWORD *)(a2 + 16), 1)
         && *(unsigned __int16 *)(a1 + 34) == *(unsigned __int16 *)(a2 + 34)
         && *(unsigned __int16 *)(a1 + 32) == *(unsigned __int16 *)(a2 + 32))
  {
    v6 = *(const void **)(a1 + 24);
    v7 = *(unsigned __int16 *)(a1 + 36);
    v8 = *(const void **)(a2 + 24);
    v9 = *(unsigned __int16 *)(a2 + 36);
    if (v7 >= v9)
      v10 = v9;
    else
      v10 = v7;
    v11 = memcmp(v6, v8, v10);
    if (v11 < 0)
    {
      return 0xFFFFFFFFLL;
    }
    else
    {
      v12 = v11 == 0;
      if (v11)
        result = 1;
      else
        result = 0xFFFFFFFFLL;
      if (v12 && v7 >= v9)
        return v7 > v9;
    }
  }
  else
  {
    return 3;
  }
  return result;
}

void _dnssec_obj_rr_finalize(uint64_t a1)
{
  _QWORD *v2;
  void *v3;
  void *v4;

  v2 = *(_QWORD **)(a1 + 16);
  if (v2)
  {
    ref_count_obj_release(v2);
    *(_QWORD *)(a1 + 16) = 0;
  }
  if (*(_BYTE *)(a1 + 38))
  {
    v3 = *(void **)(a1 + 24);
    if (v3)
    {
      free(v3);
      *(_QWORD *)(a1 + 24) = 0;
    }
  }
  v4 = *(void **)(a1 + 56);
  if (v4)
  {
    free(v4);
    *(_QWORD *)(a1 + 56) = 0;
  }
}

void dnssec_obj_rr_init_fields(uint64_t a1, unsigned __int8 *a2, __int16 a3, __int16 a4, const void *a5, unsigned int a6, int a7, uint64_t a8, int *a9)
{
  unsigned __int8 *v16;
  int v17;
  void *v18;
  const void *v19;
  int v20;

  v20 = 0;
  v16 = dnssec_obj_domain_name_create_with_labels(a2, a7, &v20);
  v17 = v20;
  if (v20)
    goto LABEL_9;
  *(_BYTE *)(a1 + 38) = a7;
  if (a7)
  {
    if (a6)
    {
      if (!a5)
      {
        v17 = -6705;
        v20 = -6705;
        goto LABEL_9;
      }
      v18 = malloc_type_malloc(a6, 0xA172743EuLL);
      if (!v18)
      {
        __break(1u);
        return;
      }
      v19 = v18;
      memcpy(v18, a5, a6);
      a5 = v19;
    }
    else
    {
      a5 = 0;
    }
  }
  v17 = 0;
  *(_QWORD *)(a1 + 16) = v16;
  *(_QWORD *)(a1 + 24) = a5;
  *(_WORD *)(a1 + 32) = a3;
  *(_WORD *)(a1 + 34) = a4;
  *(_WORD *)(a1 + 36) = a6;
  *(_DWORD *)(a1 + 40) = 3600;
  *(_QWORD *)(a1 + 72) = a8;
  v20 = 0;
  v16 = 0;
LABEL_9:
  if (a9)
    *a9 = v17;
  if (v16)
    ref_count_obj_release(v16);
}

char *dnssec_obj_rr_get_signed_data(uint64_t a1)
{
  char *v1;
  int v3;
  unsigned __int8 *v4;
  __int16 v5;
  __int16 v6;
  size_t v7;
  unint64_t v8;
  unsigned __int8 *v9;
  unsigned int v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  unsigned __int8 *v15;
  unsigned __int8 *v16;
  int v17;
  size_t v18;
  size_t v19;
  char *v20;
  char *v21;
  NSObject *v23;
  __int16 v26;
  char v27;
  uint8_t buf[4];
  const char *v29;
  __int16 v30;
  const char *v31;
  __int16 v32;
  const char *v33;
  __int16 v34;
  int v35;
  __int16 v36;
  uint64_t v37;

  v1 = *(char **)(a1 + 56);
  if (!v1)
  {
    v3 = *(_DWORD *)(a1 + 44);
    if (!v3)
      goto LABEL_23;
    v4 = *(unsigned __int8 **)(a1 + 16);
    v5 = *(_WORD *)(a1 + 32);
    v6 = *(_WORD *)(a1 + 34);
    v7 = *(unsigned __int16 *)(a1 + 36);
    v8 = *(unsigned __int8 *)(a1 + 48);
    *(_DWORD *)buf = 0;
    v9 = (unsigned __int8 *)*((_QWORD *)v4 + 2);
    v10 = *v9;
    if (*v9)
    {
      v11 = 0;
      v12 = *((_QWORD *)v4 + 2);
      do
      {
        ++v11;
        v13 = v12 + v10;
        v14 = *(unsigned __int8 *)(v13 + 1);
        v12 = v13 + 1;
        v10 = v14;
      }
      while (v14);
    }
    else
    {
      v11 = 0;
    }
    if (v11 < v8)
      goto LABEL_32;
    if (v11 == v8)
    {
      v15 = 0;
      ++*(_DWORD *)v4;
    }
    else
    {
      v27 = 0;
      v26 = 10753;
      v16 = dnssec_obj_domain_name_copy_parent_domain(v9, v11 - v8, (int *)buf);
      v15 = v16;
      v17 = *(_DWORD *)buf;
      if (*(_DWORD *)buf)
      {
        v4 = 0;
        if (!v16)
          goto LABEL_17;
        goto LABEL_16;
      }
      v4 = dnssec_obj_domain_name_create_concatenation_with_subdomain(&v26, *((_BYTE **)v16 + 2), buf);
      v17 = *(_DWORD *)buf;
      if (*(_DWORD *)buf)
      {
LABEL_15:
        if (!v15)
        {
LABEL_17:
          if (v17)
          {
            if (v4)
              ref_count_obj_release(v4);
            goto LABEL_32;
          }
          v18 = v7 + *((_QWORD *)v4 + 3);
          v19 = v18 + 10;
          if (v18 != -10)
          {
            v20 = (char *)malloc_type_malloc(v18 + 10, 0xA172743EuLL);
            if (v20)
            {
              v1 = v20;
              memcpy(v20, *((const void **)v4 + 2), *((_QWORD *)v4 + 3));
              v21 = &v1[*((_QWORD *)v4 + 3)];
              *v21 = HIBYTE(v5);
              v21[1] = v5;
              v21[2] = HIBYTE(v6);
              v21[3] = v6;
              v21[4] = HIBYTE(v3);
              v21[5] = BYTE2(v3);
              v21[6] = BYTE1(v3);
              v21[7] = v3;
              v21[8] = BYTE1(v7);
              v21[9] = v7;
              memcpy(v21 + 10, *(const void **)(a1 + 24), v7);
              ref_count_obj_release(v4);
              *(_QWORD *)(a1 + 56) = v1;
              *(_QWORD *)(a1 + 64) = v19;
              return v1;
            }
          }
          __break(1u);
LABEL_23:
          v23 = mDNSLogCategory_DNSSEC;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
          {
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
            {
LABEL_32:
              v1 = 0;
              *(_QWORD *)(a1 + 56) = 0;
              return v1;
            }
          }
          else
          {
            v23 = mDNSLogCategory_DNSSEC_redacted;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT))
              goto LABEL_32;
          }
          *(_DWORD *)buf = 136447234;
          v29 = "me->original_ttl != 0";
          v30 = 2082;
          v31 = "";
          v32 = 2082;
          v33 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rr.c";
          v34 = 1024;
          v35 = 430;
          v36 = 2048;
          v37 = 0;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", buf, 0x30u);
          goto LABEL_32;
        }
LABEL_16:
        ref_count_obj_release(v15);
        goto LABEL_17;
      }
    }
    v17 = 0;
    *(_DWORD *)buf = 0;
    goto LABEL_15;
  }
  return v1;
}

char *dnssec_obj_rr_copy_rdata_rfc_description(uint64_t a1, int *a2)
{
  uint64_t (*v4)(uint64_t, int *);
  char *result;
  size_t v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  int v11;

  v4 = *(uint64_t (**)(uint64_t, int *))(a1 + 72);
  if (v4)
    return (char *)v4(a1, a2);
  v6 = 2 * *(unsigned __int16 *)(a1 + 36) + 7;
  result = (char *)malloc_type_calloc(1uLL, v6, 0xF1748037uLL);
  if (result)
  {
    v7 = result;
    v8 = &result[v6];
    v9 = &result[snprintf(result, v6, "%u ", *(unsigned __int16 *)(a1 + 36))];
    v10 = put_hex_from_bytes(*(unsigned __int8 **)(a1 + 24), *(unsigned __int16 *)(a1 + 36), v9, v8 - v9);
    if (a2)
    {
      if (v10 == v9)
        v11 = -6751;
      else
        v11 = 0;
      *a2 = v11;
    }
    return v7;
  }
  else
  {
    __break(1u);
  }
  return result;
}

void *_mdns_dns_service_definition_copy_description(uint64_t a1, int a2, char a3)
{
  _QWORD *v6;
  _QWORD *v7;
  int v8;
  const char *v9;
  int appended;
  int v11;
  int v12;
  void *v13;
  int v14;
  const __CFArray *v16;
  int v17;
  int v18;
  const __CFSet *v19;
  int v20;
  uint64_t v21;
  _QWORD v22[7];
  char v23;
  _QWORD v24[7];
  char v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  int v33;

  v30 = 0;
  v31 = &v30;
  v32 = 0x2000000000;
  v33 = 0;
  v26 = 0;
  v27 = &v26;
  v28 = 0x2000000000;
  v29 = 0;
  v6 = (_QWORD *)mdns_string_builder_create();
  if (v6)
  {
    v7 = v6;
    if (!a2
      || (v8 = mdns_string_builder_append_formatted(v6, "<%s: %p>: ", *(const char **)(*(_QWORD *)(a1 + 16) + 8), (const void *)a1), (*((_DWORD *)v31 + 6) = v8) == 0))
    {
      v9 = *(const char **)(a1 + 40);
      if (!v9)
        v9 = "";
      appended = mdns_string_builder_append_formatted(v7, "interface: %s/%u, interface scope: ", v9, *(_DWORD *)(a1 + 48));
      *((_DWORD *)v31 + 6) = appended;
      if (!appended)
      {
        v11 = *(unsigned __int8 *)(a1 + 52);
        if (v11 == 2)
        {
          v12 = mdns_string_builder_append_formatted(v7, "unscoped+scoped", v21);
        }
        else if (v11 == 1)
        {
          v12 = mdns_string_builder_append_formatted(v7, "scoped");
        }
        else
        {
          v12 = *(_BYTE *)(a1 + 52)
              ? mdns_string_builder_append_formatted(v7, "«INVALID %d»")
              : mdns_string_builder_append_formatted(v7, "unscoped", v21);
        }
        *((_DWORD *)v31 + 6) = v12;
        if (!v12)
        {
          v14 = mdns_string_builder_append_formatted(v7, ", addresses: {");
          *((_DWORD *)v31 + 6) = v14;
          if (!v14)
          {
            v27[3] = 0;
            v16 = *(const __CFArray **)(a1 + 24);
            v24[0] = _NSConcreteStackBlock;
            v24[1] = 0x40000000;
            v24[2] = ___mdns_dns_service_definition_copy_description_block_invoke;
            v24[3] = &unk_10013CB10;
            v24[4] = &v30;
            v24[5] = &v26;
            v24[6] = v7;
            v25 = a3;
            mdns_cfarray_enumerate(v16, (uint64_t)v24);
            v13 = 0;
            if (*((_DWORD *)v31 + 6))
              goto LABEL_18;
            v17 = mdns_string_builder_append_formatted(v7, "}");
            *((_DWORD *)v31 + 6) = v17;
            if (!v17)
            {
              v18 = mdns_string_builder_append_formatted(v7, ", domains: {");
              *((_DWORD *)v31 + 6) = v18;
              if (!v18)
              {
                v27[3] = 0;
                v19 = *(const __CFSet **)(a1 + 32);
                v22[0] = _NSConcreteStackBlock;
                v22[1] = 0x40000000;
                v22[2] = ___mdns_dns_service_definition_copy_description_block_invoke_2;
                v22[3] = &unk_10013CB38;
                v22[4] = &v30;
                v22[5] = &v26;
                v22[6] = v7;
                v23 = a3;
                mdns_cfset_enumerate(v19, (uint64_t)v22);
                if (!*((_DWORD *)v31 + 6))
                {
                  v20 = mdns_string_builder_append_formatted(v7, "}");
                  *((_DWORD *)v31 + 6) = v20;
                  if (!v20)
                  {
                    v13 = mdns_string_builder_copy_string((uint64_t)v7);
                    goto LABEL_18;
                  }
                }
              }
            }
          }
        }
      }
    }
    v13 = 0;
LABEL_18:
    os_release(v7);
    goto LABEL_19;
  }
  v13 = 0;
LABEL_19:
  _Block_object_dispose(&v26, 8);
  _Block_object_dispose(&v30, 8);
  return v13;
}

void _mdns_dns_service_definition_finalize(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  void *v4;

  v2 = (const void *)a1[3];
  if (v2)
  {
    CFRelease(v2);
    a1[3] = 0;
  }
  v3 = (const void *)a1[4];
  if (v3)
  {
    CFRelease(v3);
    a1[4] = 0;
  }
  v4 = (void *)a1[5];
  if (v4)
  {
    free(v4);
    a1[5] = 0;
  }
}

BOOL ___mdns_dns_service_definition_copy_description_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = mdns_string_builder_append_description_with_prefix(*(_QWORD **)(a1 + 48), *(const char **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8)+ 24), a2, *(_BYTE *)(a1 + 56));
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = ", ";
  return *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) == 0;
}

BOOL ___mdns_dns_service_definition_copy_description_block_invoke_2(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = mdns_string_builder_append_description_with_prefix(*(_QWORD **)(a1 + 48), *(const char **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8)+ 24), a2, *(_BYTE *)(a1 + 56));
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = ", ";
  return *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) == 0;
}

_QWORD *mdns_dns_service_definition_create()
{
  uint64_t v0;
  _QWORD *v1;
  _UNKNOWN **v2;
  void (*v3)(_QWORD *);
  CFMutableArrayRef Mutable;
  CFMutableSetRef v5;

  v0 = _os_object_alloc(OS_mdns_dns_service_definition, 56);
  v1 = (_QWORD *)v0;
  if (v0)
  {
    v2 = &_mdns_dns_service_definition_kind;
    *(_QWORD *)(v0 + 16) = &_mdns_dns_service_definition_kind;
    do
    {
      v3 = (void (*)(_QWORD *))v2[2];
      if (v3)
        v3(v1);
      v2 = (_UNKNOWN **)*v2;
    }
    while (v2);
    Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
    v1[3] = Mutable;
    if (!Mutable
      || (v5 = CFSetCreateMutable(kCFAllocatorDefault, 0, (const CFSetCallBacks *)&mdns_domain_name_cf_set_callbacks),
          (v1[4] = v5) == 0))
    {
      os_release(v1);
      return 0;
    }
  }
  return v1;
}

uint64_t mdns_dns_service_definition_create_from_xpc_dictionary(void *a1, int *a2)
{
  _QWORD *v4;
  uint64_t v5;
  xpc_object_t optional_array;
  void *v7;
  size_t v8;
  size_t v9;
  size_t v10;
  char *v11;
  void *v12;
  void *v13;
  xpc_object_t v14;
  void *v15;
  size_t count;
  size_t v17;
  size_t v18;
  char *string;
  _QWORD *v20;
  int v21;
  void *v22;
  xpc_object_t value;
  unsigned int uint64_limited;
  unsigned int v25;
  xpc_object_t v26;
  unsigned __int8 v27;
  char v28;
  BOOL v29;
  BOOL v30;
  xpc_object_t object;
  void *v32;
  xpc_object_t v33;
  BOOL v34;
  BOOL v35;
  BOOL v37;
  int v38;
  BOOL v39;

  v38 = 0;
  v4 = mdns_dns_service_definition_create();
  v5 = (uint64_t)v4;
  if (!v4)
  {
    v21 = -6729;
    v38 = -6729;
    if (!a2)
      goto LABEL_32;
    goto LABEL_31;
  }
  optional_array = mdns_xpc_dictionary_get_optional_array(a1, "addresses");
  if (!optional_array)
  {
LABEL_9:
    v14 = mdns_xpc_dictionary_get_optional_array(a1, "domains");
    if (v14)
    {
      v15 = v14;
      count = xpc_array_get_count(v14);
      if (count)
      {
        v17 = count;
        v18 = 0;
        do
        {
          string = (char *)xpc_array_get_string(v15, v18);
          if (!string)
            goto LABEL_29;
          v20 = mdns_domain_name_create(string, &v38);
          v21 = v38;
          if (v38)
            goto LABEL_30;
          v22 = v20;
          CFSetAddValue(*(CFMutableSetRef *)(v5 + 32), v20);
          v38 = 0;
          if (v22)
          {
            os_release(v22);
            v21 = v38;
            if (v38)
              goto LABEL_30;
          }
        }
        while (v17 != ++v18);
      }
    }
    v37 = 0;
    value = xpc_dictionary_get_value(a1, "ifindex");
    uint64_limited = _mdns_xpc_object_get_uint64_limited(value, 0xFFFFFFFFuLL, &v37);
    if (!v37)
      goto LABEL_29;
    v25 = uint64_limited;
    v37 = 0;
    v39 = 0;
    v26 = xpc_dictionary_get_value(a1, "interface_scope");
    v27 = _mdns_xpc_object_get_uint64_limited(v26, 0xFFuLL, &v39);
    v28 = v27;
    v29 = !v39 || v27 >= 3u;
    v30 = !v29;
    v37 = v30;
    if (v29)
      goto LABEL_29;
    v37 = 0;
    object = _mdns_xpc_dictionary_get_object(a1, "local_purview", (const _xpc_type_s *)&_xpc_type_BOOL);
    v37 = object != 0;
    if (!object)
      goto LABEL_29;
    v32 = object;
    v37 = 0;
    v33 = _mdns_xpc_dictionary_get_object(a1, "mdns_alternative", (const _xpc_type_s *)&_xpc_type_BOOL);
    v37 = v33 != 0;
    if (!v33)
      goto LABEL_29;
    v34 = v32 == &_xpc_BOOL_true;
    v35 = v33 == &_xpc_BOOL_true;
    mdns_dns_service_definition_set_interface_index(v5, v25, v28);
    v21 = 0;
    v4 = 0;
    *(_BYTE *)(v5 + 53) = v34;
    *(_BYTE *)(v5 + 54) = v35;
    v38 = 0;
    if (!a2)
      goto LABEL_32;
LABEL_31:
    *a2 = v21;
    goto LABEL_32;
  }
  v7 = optional_array;
  v8 = xpc_array_get_count(optional_array);
  if (!v8)
  {
LABEL_8:
    v38 = 0;
    goto LABEL_9;
  }
  v9 = v8;
  v10 = 0;
  while (1)
  {
    v11 = (char *)xpc_array_get_string(v7, v10);
    if (!v11)
      break;
    v12 = (void *)mdns_address_create_from_ip_address_string(v11);
    if (!v12)
      break;
    v13 = v12;
    CFArrayAppendValue(*(CFMutableArrayRef *)(v5 + 24), v12);
    os_release(v13);
    if (v9 == ++v10)
      goto LABEL_8;
  }
LABEL_29:
  v21 = -6705;
  v38 = -6705;
LABEL_30:
  v4 = (_QWORD *)v5;
  v5 = 0;
  if (a2)
    goto LABEL_31;
LABEL_32:
  if (v4)
    os_release(v4);
  return v5;
}

void mdns_dns_service_definition_set_interface_index(uint64_t a1, unsigned int a2, char a3)
{
  void *v4;

  *(_BYTE *)(a1 + 52) = a3;
  if (*(_DWORD *)(a1 + 48) != a2)
  {
    *(_DWORD *)(a1 + 48) = a2;
    v4 = *(void **)(a1 + 40);
    if (v4)
    {
      free(v4);
      *(_QWORD *)(a1 + 40) = 0;
      a2 = *(_DWORD *)(a1 + 48);
    }
  }
  if (a2)
  {
    if (!*(_QWORD *)(a1 + 40))
      *(_QWORD *)(a1 + 40) = mdns_system_interface_index_to_name(a2);
  }
  else
  {
    *(_BYTE *)(a1 + 52) = 0;
  }
}

char *_mrcs_session_copy_description(_QWORD *a1)
{
  char *v2;

  v2 = 0;
  asprintf(&v2, "<%s: %p>", *(const char **)(a1[2] + 8), a1);
  return v2;
}

void _mrcs_session_finalize(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 32);
  if (v2)
  {
    xpc_release(v2);
    *(_QWORD *)(a1 + 32) = 0;
  }
}

char *_mrcs_dns_proxy_request_copy_description(_QWORD *a1)
{
  char *v2;

  v2 = 0;
  asprintf(&v2, "<%s: %p>", *(const char **)(a1[2] + 8), a1);
  return v2;
}

void _mrcs_dns_proxy_request_finalize(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 32);
  if (v2)
  {
    os_release(v2);
    *(_QWORD *)(a1 + 32) = 0;
  }
}

void *_mrcs_dns_service_registration_request_copy_description(_QWORD *a1, int a2, char a3)
{
  _QWORD *v6;
  _QWORD *v7;
  void *v8;
  uint64_t v9;

  v6 = (_QWORD *)mdns_string_builder_create();
  if (!v6)
    return 0;
  v7 = v6;
  if (a2 && mdns_string_builder_append_formatted(v6, "<%s: %p>: ", *(const char **)(a1[2] + 8), a1))
  {
    v8 = 0;
  }
  else
  {
    v9 = a1[4];
    if (v9 || (v9 = a1[5]) != 0)
      mdns_string_builder_append_description(v7, v9, a3);
    else
      mdns_string_builder_append_formatted(v7, "<empty dns service definition>");
    v8 = mdns_string_builder_copy_string((uint64_t)v7);
  }
  os_release(v7);
  return v8;
}

void _mrcs_dns_service_registration_request_finalize(uint64_t a1)
{
  void *v2;
  void *v3;

  v2 = *(void **)(a1 + 32);
  if (v2)
  {
    os_release(v2);
    *(_QWORD *)(a1 + 32) = 0;
  }
  v3 = *(void **)(a1 + 40);
  if (v3)
  {
    os_release(v3);
    *(_QWORD *)(a1 + 40) = 0;
  }
}

uint64_t __mrcs_server_set_dns_proxy_handlers_block_invoke(uint64_t result)
{
  if ((g_activated & 1) == 0)
    g_dns_proxy_handlers = *(_QWORD *)(result + 32);
  return result;
}

void ___mrcs_server_queue_block_invoke(id a1)
{
  _mrcs_server_queue_s_queue = (uint64_t)dispatch_queue_create("com.apple.mDNSResponder.control.server", 0);
}

uint64_t __mrcs_server_set_dns_service_registration_handlers_block_invoke(uint64_t result)
{
  if ((g_activated & 1) == 0)
    g_dns_service_registration_handlers = *(_QWORD *)(result + 32);
  return result;
}

uint64_t __mrcs_server_set_discovery_proxy_handlers_block_invoke(uint64_t result)
{
  if ((g_activated & 1) == 0)
    g_discovery_proxy_handlers = *(_QWORD *)(result + 32);
  return result;
}

uint64_t __mrcs_server_set_record_cache_handlers_block_invoke(uint64_t result)
{
  if ((g_activated & 1) == 0)
    g_record_cache_handlers = *(_QWORD *)(result + 32);
  return result;
}

void __mrcs_server_activate_block_invoke(id a1)
{
  _xpc_connection_s *mach_service;
  NSObject *v2;
  int v3;
  const char *v4;

  if (!_mrcs_dns_service_registration_request_kind_block_invoke_s_listener)
  {
    if (_mrcs_server_queue_s_once != -1)
      dispatch_once(&_mrcs_server_queue_s_once, &__block_literal_global_17);
    mach_service = xpc_connection_create_mach_service("com.apple.mDNSResponder.control", (dispatch_queue_t)_mrcs_server_queue_s_queue, 1uLL);
    _mrcs_dns_service_registration_request_kind_block_invoke_s_listener = (uint64_t)mach_service;
    if (mach_service)
    {
      xpc_connection_set_event_handler(mach_service, &__block_literal_global_11);
      xpc_connection_activate((xpc_connection_t)_mrcs_dns_service_registration_request_kind_block_invoke_s_listener);
      g_activated = 1;
    }
    else
    {
      if (_mdns_server_log_s_once_4261 != -1)
        dispatch_once(&_mdns_server_log_s_once_4261, &__block_literal_global_13);
      v2 = _mdns_server_log_s_log_4262;
      if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log_4262, OS_LOG_TYPE_FAULT))
      {
        v3 = 136446210;
        v4 = "com.apple.mDNSResponder.control";
        _os_log_fault_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_FAULT, "Failed to create XPC listener for %{public}s", (uint8_t *)&v3, 0xCu);
      }
    }
  }
}

void __mrcs_server_activate_block_invoke_8(id a1, const void *a2)
{
  uint64_t v3;
  uint64_t v4;
  _UNKNOWN **v5;
  void (*v6)(uint64_t);
  uint64_t *v7;
  uint64_t *v8;
  uint64_t v9;
  _xpc_connection_s *v10;
  _xpc_connection_s *v11;
  _QWORD handler[5];

  if (xpc_get_type((xpc_object_t)a2) == (xpc_type_t)&_xpc_type_connection)
  {
    v3 = _os_object_alloc(OS_mrcs_session, 56);
    if (v3)
    {
      v4 = v3;
      v5 = &_mrcs_session_kind;
      *(_QWORD *)(v3 + 16) = &_mrcs_session_kind;
      do
      {
        v6 = (void (*)(uint64_t))v5[2];
        if (v6)
          v6(v4);
        v5 = (_UNKNOWN **)*v5;
      }
      while (v5);
      *(_QWORD *)(v4 + 32) = a2;
      xpc_retain((xpc_object_t)a2);
      v7 = &g_session_list_4266;
      do
      {
        v8 = v7;
        v9 = *v7;
        v7 = (uint64_t *)(*v7 + 24);
      }
      while (v9);
      *(_QWORD *)(v4 + 24) = 0;
      *v8 = v4;
      os_retain((void *)v4);
      os_retain((void *)v4);
      v10 = *(_xpc_connection_s **)(v4 + 32);
      if (_mrcs_server_queue_s_once != -1)
        dispatch_once(&_mrcs_server_queue_s_once, &__block_literal_global_17);
      xpc_connection_set_target_queue(v10, (dispatch_queue_t)_mrcs_server_queue_s_queue);
      v11 = *(_xpc_connection_s **)(v4 + 32);
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 0x40000000;
      handler[2] = ___mrcs_session_activate_block_invoke;
      handler[3] = &__block_descriptor_tmp_19_4267;
      handler[4] = v4;
      xpc_connection_set_event_handler(v11, handler);
      xpc_connection_activate(*(xpc_connection_t *)(v4 + 32));
      os_release((void *)v4);
    }
    else
    {
      xpc_connection_cancel((xpc_connection_t)a2);
    }
  }
}

void ___mrcs_session_activate_block_invoke(uint64_t a1, xpc_object_t object)
{
  uint64_t v4;
  void *v5;
  uint64_t *v6;
  const char *string;
  const char *v8;
  uint64_t v9;
  const char **p_length;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t v13;
  BOOL v14;
  void *v15;
  _QWORD *i;
  void (*v17)(_QWORD);
  _QWORD *j;
  void (*v19)(_QWORD);
  void (*v20)(void);
  unsigned int v21;
  uint64_t uint64;
  uint64_t v23;
  uint64_t v24;
  _UNKNOWN **v25;
  xpc_object_t v26;
  int v27;
  xpc_object_t reply;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  void (*v33)(_QWORD);
  xpc_object_t empty;
  void *v35;
  uint64_t (*v36)(void);
  const char *v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  const char ***v41;
  uint64_t v42;
  int v43;
  xpc_object_t v44;
  int v45;
  uint64_t v46;
  _QWORD *v47;
  _QWORD *v48;
  _QWORD *v49;
  void (*v50)(_QWORD);
  xpc_object_t v51;
  void *v52;
  const char *v53;
  const char *v54;
  uint64_t key_tag;
  void (*v56)(const char *, uint64_t);
  const char **v57;
  const char **v58;
  const char **optional_array;
  const char **v60;
  size_t count;
  const char ***v62;
  xpc_object_t value;
  unsigned int uint64_limited;
  unsigned int v65;
  unint64_t v66;
  uint64_t v67;
  unint64_t v68;
  int *v69;
  int v70;
  size_t v71;
  const char **v72;
  uint64_t v73;
  unint64_t v74;
  uint64_t v75;
  unint64_t v76;
  void *v77;
  unsigned int output_interface;
  char *nat64_prefix;
  int v80;
  BOOL force_aaaa_synthesis;
  int v82;
  uint64_t v83;
  uint64_t v84;
  void (*v85)(uint64_t);
  xpc_object_t v86;
  void *v87;
  void *interface;
  void *v89;
  xpc_object_t v90;
  void *v91;
  size_t v92;
  size_t v93;
  CFMutableArrayRef Mutable;
  __CFArray *v95;
  size_t k;
  char *v97;
  void *v98;
  void *v99;
  xpc_object_t v100;
  void *v101;
  size_t v102;
  size_t v103;
  CFMutableArrayRef v104;
  __CFArray *v105;
  size_t m;
  char *v107;
  _QWORD *v108;
  void *v109;
  size_t v110;
  size_t v111;
  __CFArray *v112;
  size_t n;
  const UInt8 *data;
  int v115;
  CFDataRef v116;
  CFDataRef v117;
  uint64_t (*v118)(void);
  uint64_t *v119;
  xpc_object_t v120;
  void *v121;
  xpc_object_t v122;
  void *v123;
  int definition_type;
  int v125;
  uint64_t v126;
  _UNKNOWN **v127;
  void (*v128)(const char **);
  uint64_t v129;
  void (*v130)(const char *);
  uint64_t v131;
  size_t *v132;
  int v133;
  __CFArray *v134;
  uint64_t v135;
  int v136;
  int v137;
  uint64_t *v138;
  xpc_object_t xarray;
  xpc_object_t xarraya;
  xpc_object_t xarrayb;
  CFAllocatorRef allocator;
  BOOL v143;
  int v144;
  size_t length;
  uint64_t v146;
  const char *v147;
  uint64_t v148;
  const char *v149;
  uint64_t v150;
  const char *v151;
  uint64_t v152;
  const char *v153;
  uint64_t v154;
  const char *v155;
  uint64_t v156;
  const char *v157;
  uint64_t v158;
  const char *v159;
  uint64_t v160;
  const char *v161;
  uint64_t v162;

  if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_dictionary)
  {
    v4 = *(_QWORD *)(a1 + 32);
    if (object == &_xpc_error_connection_invalid)
    {
      v11 = &g_session_list_4266;
      do
      {
        v12 = v11;
        v13 = *v11;
        v11 = (uint64_t *)(*v11 + 24);
        if (v13)
          v14 = v13 == v4;
        else
          v14 = 1;
      }
      while (!v14);
      if (v13)
      {
        *v12 = *(_QWORD *)(v4 + 24);
        *(_QWORD *)(v4 + 24) = 0;
        os_release((void *)v4);
        v4 = *(_QWORD *)(a1 + 32);
      }
      v15 = *(void **)(v4 + 32);
      if (v15)
      {
        xpc_connection_cancel(*(xpc_connection_t *)(v4 + 32));
        xpc_release(v15);
        *(_QWORD *)(v4 + 32) = 0;
      }
      for (i = *(_QWORD **)(v4 + 40); i; i = *(_QWORD **)(v4 + 40))
      {
        *(_QWORD *)(v4 + 40) = i[3];
        v17 = *(void (**)(_QWORD))(g_dns_proxy_handlers + 8);
        if (v17)
          v17(i[4]);
        os_release(i);
      }
      for (j = *(_QWORD **)(v4 + 48); j; j = *(_QWORD **)(v4 + 48))
      {
        *(_QWORD *)(v4 + 48) = j[3];
        v19 = *(void (**)(_QWORD))(g_dns_service_registration_handlers + 8);
        if (v19)
          v19(j[7]);
        os_release(j);
      }
      if (g_current_discovery_proxy_owner == v4)
      {
        v20 = *(void (**)(void))(g_discovery_proxy_handlers + 8);
        if (!v20 || (v20(), (v4 = g_current_discovery_proxy_owner) != 0))
        {
          os_release((void *)v4);
          g_current_discovery_proxy_owner = 0;
        }
      }
      os_release(*(void **)(a1 + 32));
    }
    else
    {
      v5 = *(void **)(v4 + 32);
      if (v5)
      {
        xpc_connection_cancel(*(xpc_connection_t *)(v4 + 32));
        xpc_release(v5);
        *(_QWORD *)(*(_QWORD *)(a1 + 32) + 32) = 0;
      }
    }
    return;
  }
  v6 = *(uint64_t **)(a1 + 32);
  if (!v6[4])
    return;
  string = xpc_dictionary_get_string(object, "command");
  if (!string)
    goto LABEL_41;
  v8 = string;
  v9 = 0;
  v160 = 5;
  v161 = "record_cache.flush";
  v162 = 9;
  v146 = 8;
  length = (size_t)"record_cache.local_record_inquiry";
  v148 = 6;
  v147 = "discovery_proxy.start";
  v150 = 7;
  v149 = "discovery_proxy.stop";
  v152 = 1;
  v151 = "dns_proxy.start";
  v154 = 2;
  v153 = "dns_proxy.stop";
  v156 = 3;
  v155 = "dns_proxy.get_state";
  v158 = 4;
  v157 = "dns_service_registration.start";
  v159 = "dns_service_registration.stop";
  p_length = (const char **)&length;
  while (strcmp(v8, *p_length))
  {
    ++v9;
    p_length += 2;
    if (v9 == 9)
      goto LABEL_41;
  }
  v21 = *((unsigned __int8 *)&length + 16 * v9 + 8) - 1;
  if (v21 > 8)
  {
LABEL_41:
    LODWORD(v25) = -6707;
    goto LABEL_42;
  }
  if (!mdns_xpc_connection_is_entitled(v6[4], (uint64_t)off_10013CDC8[(*((_BYTE *)&length + 16 * v9 + 8) - 1)]))
  {
    LODWORD(v25) = -71168;
    goto LABEL_42;
  }
  switch(v21)
  {
    case 0u:
      uint64 = xpc_dictionary_get_uint64(object, "id");
      v23 = v6[5];
      if (v23)
      {
        do
        {
          v24 = v23;
          if (*(_QWORD *)(v23 + 40) == uint64)
          {
            LODWORD(v25) = -6709;
            goto LABEL_42;
          }
          v23 = *(_QWORD *)(v23 + 24);
        }
        while (v23);
        v138 = (uint64_t *)(v24 + 24);
        xarray = (xpc_object_t)uint64;
      }
      else
      {
        v138 = v6 + 5;
        xarray = (xpc_object_t)uint64;
      }
      v57 = (const char **)_mdns_xpc_dictionary_get_object(object, "params", (const _xpc_type_s *)&_xpc_type_dictionary);
      if (!v57)
      {
LABEL_129:
        LODWORD(v25) = -6705;
        goto LABEL_42;
      }
      v58 = v57;
      v144 = 0;
      v31 = mrcs_dns_proxy_create(&v144);
      LODWORD(v25) = v144;
      if (v144)
        goto LABEL_127;
      optional_array = (const char **)mdns_xpc_dictionary_get_optional_array(v58, "input_interfaces");
      if (!optional_array)
        goto LABEL_199;
      v60 = optional_array;
      allocator = (CFAllocatorRef)v58;
      count = xpc_array_get_count(optional_array);
      if (!count)
        goto LABEL_199;
      v62 = (const char ***)count;
      v41 = 0;
      v143 = 0;
      do
      {
        value = xpc_array_get_value(v60, (size_t)v41);
        uint64_limited = _mdns_xpc_object_get_uint64_limited(value, 0xFFFFFFFFuLL, &v143);
        if (!v143)
          goto LABEL_199;
        v65 = uint64_limited;
        v66 = *(_QWORD *)(v31 + 48);
        if (v66)
        {
          v67 = *(_QWORD *)(v31 + 40);
          if (*(_DWORD *)(v67 + 8) == uint64_limited)
            goto LABEL_113;
          v68 = 0;
          v69 = (int *)(v67 + 24);
          while (v66 - 1 != v68)
          {
            v70 = *v69;
            v69 += 4;
            ++v68;
            if (v70 == uint64_limited)
              goto LABEL_100;
          }
          v68 = *(_QWORD *)(v31 + 48);
LABEL_100:
          if (v68 < v66 || v66 == -1)
            goto LABEL_113;
          if (v66 >= 0xFFFFFFFFFFFFFFFLL)
            goto LABEL_200;
          v71 = v66 + 1;
        }
        else
        {
          v71 = 1;
        }
        v72 = (const char **)malloc_type_calloc(v71, 0x10uLL, 0xF1748037uLL);
        if (!v72)
        {
LABEL_200:
          __break(1u);
          goto LABEL_201;
        }
        p_length = v72;
        if (*(_QWORD *)(v31 + 48))
        {
          v73 = 0;
          v74 = 0;
          do
          {
            v75 = *(_QWORD *)(v31 + 40);
            *(_OWORD *)&v72[v73] = *(_OWORD *)(v75 + v73 * 8);
            *(_QWORD *)(v75 + v73 * 8) = 0;
            ++v74;
            v76 = *(_QWORD *)(v31 + 48);
            v73 += 2;
          }
          while (v74 < v76);
        }
        else
        {
          v76 = 0;
        }
        v58 = &v72[2 * v76];
        *((_DWORD *)v58 + 2) = v65;
        *v58 = mdns_system_interface_index_to_name(v65);
        v77 = *(void **)(v31 + 40);
        if (v77)
          free(v77);
        *(_QWORD *)(v31 + 40) = p_length;
        *(_QWORD *)(v31 + 48) = v71;
LABEL_113:
        v41 = (const char ***)((char *)v41 + 1);
      }
      while (v41 != v62);
      output_interface = mrc_xpc_dns_proxy_params_get_output_interface(allocator, &v143);
      if (!v143)
        goto LABEL_199;
      mrcs_dns_proxy_set_output_interface(v31, output_interface);
      length = 0;
      nat64_prefix = (char *)mrc_xpc_dns_proxy_params_get_nat64_prefix(allocator, &length);
      if (nat64_prefix)
      {
        v80 = mrcs_dns_proxy_set_nat64_prefix(v31, nat64_prefix, length);
        v144 = v80;
        if (v80)
        {
          LODWORD(v25) = v80;
          goto LABEL_127;
        }
      }
      force_aaaa_synthesis = mrc_xpc_dns_proxy_params_get_force_aaaa_synthesis(allocator, &v143);
      if (!v143)
      {
LABEL_199:
        LODWORD(v25) = -6705;
        v144 = -6705;
        goto LABEL_127;
      }
      *(_BYTE *)(v31 + 77) = force_aaaa_synthesis;
      LODWORD(v25) = v144;
      if (v144)
        goto LABEL_131;
      *(_DWORD *)(v31 + 72) = xpc_connection_get_euid((xpc_connection_t)v6[4]);
      if (!*(_QWORD *)g_dns_proxy_handlers)
        goto LABEL_130;
      v82 = (*(uint64_t (**)(uint64_t))g_dns_proxy_handlers)(v31);
      if (v82)
      {
        LODWORD(v25) = v82;
        goto LABEL_131;
      }
      v83 = _os_object_alloc(OS_mrcs_dns_proxy_request, 48);
      if (!v83)
      {
        LODWORD(v25) = -6728;
        goto LABEL_131;
      }
      v84 = v83;
      v25 = &_mrcs_dns_proxy_request_kind;
      *(_QWORD *)(v83 + 16) = &_mrcs_dns_proxy_request_kind;
      do
      {
        v85 = (void (*)(uint64_t))v25[2];
        if (v85)
          v85(v84);
        v25 = (_UNKNOWN **)*v25;
      }
      while (v25);
      *(_QWORD *)(v84 + 32) = v31;
      os_retain((void *)v31);
      *(_QWORD *)(v84 + 40) = xarray;
      *v138 = v84;
LABEL_127:
      if (v31)
        goto LABEL_131;
LABEL_42:
      v26 = object;
      v27 = (int)v25;
LABEL_43:
      reply = mrc_xpc_create_reply(v26, v27, 0);
      if (reply)
      {
LABEL_44:
        xpc_connection_send_message((xpc_connection_t)v6[4], reply);
        xpc_release(reply);
      }
      return;
    case 1u:
      v46 = xpc_dictionary_get_uint64(object, "id");
      v47 = v6 + 5;
      v48 = (_QWORD *)v6[5];
      if (!v48)
        goto LABEL_74;
      if (v48[5] == v46)
        goto LABEL_71;
      while (1)
      {
        v49 = v48;
        v48 = (_QWORD *)v48[3];
        if (!v48)
          goto LABEL_74;
        if (v48[5] == v46)
        {
          v47 = v49 + 3;
LABEL_71:
          *v47 = v48[3];
          v48[3] = 0;
          v50 = *(void (**)(_QWORD))(g_dns_proxy_handlers + 8);
          if (v50)
            v50(v48[4]);
          os_release(v48);
LABEL_187:
          LODWORD(v25) = 0;
          goto LABEL_42;
        }
      }
    case 2u:
      empty = xpc_dictionary_create_empty();
      if (!empty)
      {
        LODWORD(v25) = -6729;
        goto LABEL_42;
      }
      v35 = empty;
      v36 = *(uint64_t (**)(void))(g_dns_proxy_handlers + 16);
      if (!v36)
        goto LABEL_84;
      v37 = (const char *)v36();
      if (v37)
      {
        v38 = (char *)v37;
        xpc_dictionary_set_string(v35, "description", v37);
        free(v38);
        goto LABEL_65;
      }
      v45 = -6728;
      goto LABEL_165;
    case 3u:
      v144 = 0;
      v39 = xpc_dictionary_get_uint64(object, "id");
      v31 = v39;
      v41 = (const char ***)(v6 + 6);
      v40 = v6[6];
      if (!v40)
        goto LABEL_168;
      if (*(_QWORD *)(v40 + 48) == v39)
        goto LABEL_61;
      while (1)
      {
        v42 = *(_QWORD *)(v40 + 24);
        if (!v42)
          break;
        v40 = *(_QWORD *)(v40 + 24);
        if (*(_QWORD *)(v42 + 48) == v39)
        {
LABEL_61:
          v43 = -6721;
          goto LABEL_183;
        }
      }
      v41 = (const char ***)(v40 + 24);
LABEL_168:
      v120 = _mdns_xpc_dictionary_get_object(object, "params", (const _xpc_type_s *)&_xpc_type_dictionary);
      if (v120
        && (v121 = v120,
            (v122 = _mdns_xpc_dictionary_get_object(v120, "definition", (const _xpc_type_s *)&_xpc_type_dictionary)) != 0)
        && (v123 = v122,
            v143 = 0,
            definition_type = mrc_xpc_dns_service_registration_params_get_definition_type(v121, &v143),
            v143))
      {
        v125 = definition_type;
        v126 = _os_object_alloc(OS_mrcs_dns_service_registration_request, 64);
        if (v126)
        {
          v58 = (const char **)v126;
          v127 = &_mrcs_dns_service_registration_request_kind;
          *(_QWORD *)(v126 + 16) = &_mrcs_dns_service_registration_request_kind;
          do
          {
            v128 = (void (*)(const char **))v127[2];
            if (v128)
              v128(v58);
            v127 = (_UNKNOWN **)*v127;
          }
          while (v127);
          if (v125 == 2)
          {
            v58[5] = (const char *)mdns_dns_push_service_definition_create_from_xpc_dictionary(v123, &v144);
            if (!v144)
            {
              p_length = (const char **)_mdns_xpc_dictionary_get_object(v121, "reports_connection_errors", (const _xpc_type_s *)&_xpc_type_BOOL);
              v60 = (const char **)&_xpc_BOOL_true;
              if (p_length == (const char **)&_xpc_BOOL_true)
              {
LABEL_201:
                if (_mrcs_server_queue_s_once != -1)
                  dispatch_once(&_mrcs_server_queue_s_once, &__block_literal_global_17);
                v131 = _mrcs_server_queue_s_queue;
                length = (size_t)_NSConcreteStackBlock;
                v146 = 0x40000000;
                v147 = (const char *)___mrcs_session_handle_dns_service_registration_start_block_invoke;
                v148 = (uint64_t)&__block_descriptor_tmp_26_4268;
                v149 = (const char *)v6;
                v150 = v31;
                v132 = &length;
              }
              else
              {
                v131 = 0;
                v132 = 0;
              }
              if (!*(_QWORD *)g_dns_service_registration_handlers)
                goto LABEL_211;
              v135 = (*(uint64_t (**)(const char *, uint64_t, size_t *))g_dns_service_registration_handlers)(v58[5], v131, v132);
              if (v135)
                v136 = 0;
              else
                v136 = -6700;
              v144 = v136;
              v58[7] = (const char *)v135;
              if (p_length == v60 && v135)
              {
                os_retain(v6);
                goto LABEL_213;
              }
              if (v135)
                goto LABEL_213;
            }
          }
          else if (v125 == 1)
          {
            v58[4] = (const char *)mdns_dns_service_definition_create_from_xpc_dictionary(v123, &v144);
            if (!v144)
            {
              if (*(_QWORD *)g_dns_service_registration_handlers)
              {
                v129 = (*(uint64_t (**)(void))g_dns_service_registration_handlers)();
                if (v129)
                {
                  v144 = 0;
                  v58[7] = (const char *)v129;
LABEL_213:
                  v58[6] = (const char *)v31;
                  *v41 = v58;
                  goto LABEL_184;
                }
                v137 = -6700;
                goto LABEL_216;
              }
LABEL_211:
              v137 = -6714;
LABEL_216:
              v144 = v137;
              v58[7] = 0;
            }
          }
          else
          {
            v144 = -6705;
          }
          os_release(v58);
          goto LABEL_184;
        }
        v43 = -6728;
      }
      else
      {
LABEL_182:
        v43 = -6705;
      }
      goto LABEL_183;
    case 4u:
      v29 = xpc_dictionary_get_uint64(object, "id");
      v30 = v6 + 6;
      v31 = v6[6];
      if (!v31)
        goto LABEL_74;
      if (*(_QWORD *)(v31 + 48) == v29)
        goto LABEL_51;
      do
      {
        v32 = v31;
        v31 = *(_QWORD *)(v31 + 24);
        if (!v31)
        {
LABEL_74:
          LODWORD(v25) = -6708;
          goto LABEL_42;
        }
      }
      while (*(_QWORD *)(v31 + 48) != v29);
      v30 = (_QWORD *)(v32 + 24);
LABEL_51:
      *v30 = *(_QWORD *)(v31 + 24);
      *(_QWORD *)(v31 + 24) = 0;
      v33 = *(void (**)(_QWORD))(g_dns_service_registration_handlers + 8);
      if (v33)
      {
        v33(*(_QWORD *)(v31 + 56));
        LODWORD(v25) = 0;
      }
      else
      {
LABEL_130:
        LODWORD(v25) = -6714;
      }
LABEL_131:
      os_release((void *)v31);
      goto LABEL_42;
    case 5u:
      v144 = 0;
      if (g_current_discovery_proxy_owner)
      {
        v43 = -6719;
        goto LABEL_183;
      }
      v86 = _mdns_xpc_dictionary_get_object(object, "params", (const _xpc_type_s *)&_xpc_type_dictionary);
      if (!v86)
        goto LABEL_182;
      v87 = v86;
      v143 = 0;
      interface = mrc_xpc_discovery_proxy_params_get_interface(v86, &v143);
      if (!v143)
        goto LABEL_182;
      v89 = interface;
      v90 = mdns_xpc_dictionary_get_optional_array(v87, "addresses");
      if (!v90)
        goto LABEL_182;
      v91 = v90;
      v92 = xpc_array_get_count(v90);
      if (!v92)
        goto LABEL_182;
      v93 = v92;
      Mutable = CFArrayCreateMutable(kCFAllocatorDefault, v92, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
      if (!Mutable)
      {
        v43 = -6729;
LABEL_183:
        v144 = v43;
        goto LABEL_184;
      }
      v95 = Mutable;
      for (k = 0; k != v93; ++k)
      {
        v97 = (char *)xpc_array_get_string(v91, k);
        if (!v97)
          goto LABEL_195;
        v98 = (void *)mdns_address_create_from_ip_address_string(v97);
        if (!v98)
          goto LABEL_195;
        v99 = v98;
        CFArrayAppendValue(v95, v98);
        os_release(v99);
      }
      xarraya = v87;
      v100 = mdns_xpc_dictionary_get_optional_array(v87, "match_domains");
      if (v100 && (v101 = v100, (v102 = xpc_array_get_count(v100)) != 0))
      {
        v103 = v102;
        v104 = CFArrayCreateMutable(kCFAllocatorDefault, 0, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
        if (v104)
        {
          v105 = v104;
          for (m = 0; m != v103; ++m)
          {
            v107 = (char *)xpc_array_get_string(v101, m);
            if (!v107)
              goto LABEL_219;
            v108 = mdns_domain_name_create(v107, &v144);
            if (v144)
            {
              v112 = 0;
              goto LABEL_223;
            }
            v109 = v108;
            CFArrayAppendValue(v105, v108);
            if (v109)
              os_release(v109);
          }
          xarrayb = mdns_xpc_dictionary_get_optional_array(xarraya, "server_certificates");
          v110 = xpc_array_get_count(xarrayb);
          if (v110)
          {
            v111 = v110;
            v112 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
            if (v112)
            {
              for (n = 0; n != v111; ++n)
              {
                length = 0;
                data = (const UInt8 *)xpc_array_get_data(xarrayb, n, &length);
                v115 = -6705;
                if (!data || !length)
                  goto LABEL_221;
                v116 = CFDataCreate(kCFAllocatorDefault, data, length);
                if (!v116)
                {
                  v115 = -6729;
                  goto LABEL_221;
                }
                v117 = v116;
                CFArrayAppendValue(v112, v116);
                CFRelease(v117);
              }
              if (*(_QWORD *)g_discovery_proxy_handlers)
              {
                v144 = (*(uint64_t (**)(void *, __CFArray *, __CFArray *, __CFArray *))g_discovery_proxy_handlers)(v89, v95, v105, v112);
                if (!v144)
                {
                  g_current_discovery_proxy_owner = (uint64_t)v6;
                  os_retain(v6);
                }
LABEL_223:
                CFRelease(v95);
                CFRelease(v105);
                if (v112)
                {
                  v134 = v112;
                  goto LABEL_197;
                }
LABEL_184:
                LODWORD(v25) = v144;
                goto LABEL_42;
              }
              v115 = -6714;
LABEL_221:
              v144 = v115;
              goto LABEL_223;
            }
          }
          else
          {
LABEL_219:
            v112 = 0;
          }
          v115 = -6705;
          goto LABEL_221;
        }
        v133 = -6729;
      }
      else
      {
LABEL_195:
        v133 = -6705;
      }
      v144 = v133;
      v134 = v95;
LABEL_197:
      CFRelease(v134);
      goto LABEL_184;
    case 6u:
      if ((uint64_t *)g_current_discovery_proxy_owner != v6)
      {
        LODWORD(v25) = -6718;
        goto LABEL_42;
      }
      v118 = *(uint64_t (**)(void))(g_discovery_proxy_handlers + 8);
      if (v118)
      {
        LODWORD(v25) = v118();
        v119 = (uint64_t *)g_current_discovery_proxy_owner;
        if (!g_current_discovery_proxy_owner)
          goto LABEL_42;
      }
      else
      {
        LODWORD(v25) = -6714;
        v119 = v6;
      }
      os_release(v119);
      g_current_discovery_proxy_owner = 0;
      goto LABEL_42;
    case 7u:
      v44 = xpc_dictionary_create_empty();
      if (!v44)
      {
        v26 = object;
        v27 = -6729;
        goto LABEL_43;
      }
      v35 = v44;
      length = (size_t)_NSConcreteStackBlock;
      v146 = 0x40000000;
      v147 = (const char *)___mrcs_session_handle_record_cache_local_record_inquiry_block_invoke;
      v148 = (uint64_t)&__block_descriptor_tmp_28_4269;
      v149 = (const char *)v44;
      if (*(_QWORD *)g_record_cache_handlers)
      {
        (*(void (**)(size_t *))g_record_cache_handlers)(&length);
LABEL_65:
        v45 = 0;
      }
      else
      {
LABEL_84:
        v45 = -6714;
      }
LABEL_165:
      reply = mrc_xpc_create_reply(object, v45, v35);
      xpc_release(v35);
      if (!reply)
        return;
      goto LABEL_44;
    case 8u:
      v51 = _mdns_xpc_dictionary_get_object(object, "params", (const _xpc_type_s *)&_xpc_type_dictionary);
      if (!v51)
        goto LABEL_129;
      v52 = v51;
      v53 = xpc_dictionary_get_string(v51, "record_name");
      if (!v53)
        goto LABEL_129;
      v54 = v53;
      LOBYTE(length) = 0;
      key_tag = mrc_xpc_record_cache_flush_params_get_key_tag(v52, (BOOL *)&length);
      if ((_BYTE)length)
      {
        v56 = *(void (**)(const char *, uint64_t))(g_record_cache_handlers + 16);
        if (v56)
        {
          v56(v54, key_tag);
          goto LABEL_187;
        }
      }
      else
      {
        v130 = *(void (**)(const char *))(g_record_cache_handlers + 8);
        if (v130)
        {
          v130(v54);
          goto LABEL_187;
        }
      }
      LODWORD(v25) = -6714;
      goto LABEL_42;
    default:
      goto LABEL_41;
  }
}

void ___mrcs_session_handle_dns_service_registration_start_block_invoke(uint64_t a1, int a2, int a3)
{
  uint64_t v3;
  uint64_t v5;
  xpc_object_t empty;
  void *v7;
  xpc_object_t v8;

  if (a2 == 1)
  {
    v3 = *(_QWORD *)(a1 + 32);
    if (*(_QWORD *)(v3 + 32))
    {
      v5 = *(_QWORD *)(a1 + 40);
      empty = xpc_dictionary_create_empty();
      if (empty)
      {
        v7 = empty;
        xpc_dictionary_set_int64(empty, "connection_error", a3);
        v8 = xpc_dictionary_create_empty();
        xpc_dictionary_set_uint64(v8, "id", v5);
        xpc_dictionary_set_value(v8, "body", v7);
        xpc_release(v7);
        if (v8)
        {
          xpc_connection_send_message(*(xpc_connection_t *)(v3 + 32), v8);
          os_release(v8);
        }
      }
    }
  }
  else if (a2 == 2)
  {
    os_release(*(void **)(a1 + 32));
  }
}

void ___mrcs_session_handle_record_cache_local_record_inquiry_block_invoke(uint64_t a1, const char *a2, unsigned __int8 *a3, unsigned int a4, unsigned __int8 *a5)
{
  int v8;
  int v9;
  NSObject *v10;
  int v11;
  const void *v12;
  int v13;
  const char *v14;
  void *v15;
  const char *v16;
  xpc_object_t empty;
  xpc_object_t optional_array;
  void *v19;
  uint8_t buf[56];

  v19 = 0;
  if (a3)
  {
    v8 = DNSRecordDataToStringEx(a3, a4, 16, 0, 0, 0, (uint64_t)&v19);
    if (!v19)
    {
      v9 = v8;
      if (_mdns_server_log_s_once_4261 != -1)
        dispatch_once(&_mdns_server_log_s_once_4261, &__block_literal_global_13);
      v10 = _mdns_server_log_s_log_4262;
      if (os_log_type_enabled((os_log_t)_mdns_server_log_s_log_4262, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136380931;
        *(_QWORD *)&buf[4] = a2;
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v9;
        _os_log_fault_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_FAULT, "Failed to create device-info TXT RDATA string -- record name: '%{private}s', error: %{mdns:err}ld", buf, 0x16u);
      }
    }
  }
  memset(buf, 0, 46);
  v11 = a5[1];
  if (v11 == 30)
  {
    v12 = a5 + 8;
    v13 = 30;
    goto LABEL_11;
  }
  if (v11 == 2)
  {
    v12 = a5 + 4;
    v13 = 2;
LABEL_11:
    v14 = inet_ntop(v13, v12, (char *)buf, 0x2Eu);
    goto LABEL_13;
  }
  v14 = 0;
LABEL_13:
  v15 = *(void **)(a1 + 32);
  v16 = (const char *)v19;
  empty = xpc_dictionary_create_empty();
  xpc_dictionary_set_string(empty, "name", a2);
  if (v16)
    xpc_dictionary_set_string(empty, "rdata", v16);
  if (v14)
    xpc_dictionary_set_string(empty, "source_address", v14);
  optional_array = mdns_xpc_dictionary_get_optional_array(v15, "record_info");
  if (!optional_array)
  {
    optional_array = xpc_array_create_empty();
    xpc_dictionary_set_value(v15, "record_info", optional_array);
    if (optional_array)
      xpc_release(optional_array);
  }
  xpc_array_append_value(optional_array, empty);
  if (empty)
    xpc_release(empty);
  if (v19)
    free(v19);
}

void ___mdns_server_log_block_invoke_4278(id a1)
{
  _mdns_server_log_s_log_4262 = (uint64_t)os_log_create("com.apple.mdns", "mrcs_server");
}

char *_dnssec_obj_rr_dnskey_copy_rdata_rfc_description(uint64_t a1, int *a2)
{
  char *v2;
  int v3;
  unsigned int v6;
  uint64_t v7;
  size_t v8;
  char *v9;
  int v10;
  uint64_t v11;
  char *v12;
  char *v13;
  unsigned __int8 *v14;
  unsigned int public_key_size;
  int v16;
  _BOOL4 v17;

  v6 = (unsigned __int16)(rdata_parser_dnskey_get_public_key_size(*(unsigned __int16 *)(a1 + 36)) + 2) / 3u;
  v7 = snprintf(0, 0, "%u %u %u  (Key Tag: %u)", __rev16(**(unsigned __int16 **)(a1 + 24)), *(unsigned __int8 *)(*(_QWORD *)(a1 + 24) + 2), *(unsigned __int8 *)(*(_QWORD *)(a1 + 24) + 3), *(unsigned __int16 *)(a1 + 80))+ 4 * v6;
  v8 = v7 + 1;
  if (v7 == -1 || (v9 = (char *)malloc_type_calloc(1uLL, v7 + 1, 0xF1748037uLL)) == 0)
  {
    __break(1u);
  }
  else
  {
    v2 = v9;
    v10 = snprintf(v9, v8, "%u %u %u ", __rev16(**(unsigned __int16 **)(a1 + 24)), *(unsigned __int8 *)(*(_QWORD *)(a1 + 24) + 2), *(unsigned __int8 *)(*(_QWORD *)(a1 + 24) + 3));
    v3 = -6700;
    if (v10 >= 1)
    {
      v11 = 4 * v6;
      v12 = &v2[v8];
      v13 = &v2[v10];
      v14 = (unsigned __int8 *)(*(_QWORD *)(a1 + 24) + 4);
      public_key_size = rdata_parser_dnskey_get_public_key_size(*(unsigned __int16 *)(a1 + 36));
      base_x_encode(0, v14, public_key_size, v13);
      v16 = snprintf(&v13[v11], v12 - &v13[v11], " (Key Tag: %u)", *(unsigned __int16 *)(a1 + 80));
      v17 = v16 < 1;
      if (v16 >= 1)
        v3 = 0;
      else
        v3 = -6700;
      if (!a2)
        goto LABEL_9;
      goto LABEL_8;
    }
  }
  v17 = 1;
  if (a2)
LABEL_8:
    *a2 = v3;
LABEL_9:
  if (v17)
  {
    free(v2);
    return 0;
  }
  return v2;
}

uint64_t dnssec_obj_rr_dnskey_create(unsigned __int8 *a1, __int16 a2, _BYTE *a3, unsigned int a4, int *a5)
{
  uint64_t v5;
  _QWORD *v11;
  int v12;
  _UNKNOWN **v13;
  void (*v14)(uint64_t);
  uint64_t v15;
  unsigned int v16;
  int v17;
  unsigned int v18;
  uint64_t v19;
  NSObject *v21;
  int v22;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  int v30;
  __int16 v31;
  uint64_t v32;

  v22 = 0;
  if (a4 <= 4)
  {
    v5 = 0;
    v19 = 0;
    v12 = -6705;
    v22 = -6705;
  }
  else
  {
    v11 = malloc_type_calloc(1uLL, 0x58uLL, 0xF1748037uLL);
    if (v11)
    {
      v5 = (uint64_t)v11;
      v13 = &_dnssec_obj_rr_dnskey_kind;
      v11[1] = &_dnssec_obj_rr_dnskey_kind;
      do
      {
        v14 = (void (*)(uint64_t))v13[2];
        if (v14)
          v14(v5);
        v13 = (_UNKNOWN **)*v13;
      }
      while (v13);
      ++*(_DWORD *)v5;
      dnssec_obj_rr_init_fields(v5, a1, 48, a2, a3, a4, 0, (uint64_t)_dnssec_obj_rr_dnskey_copy_rdata_rfc_description, &v22);
      v12 = v22;
      if (!v22)
      {
        if (a3[3] != 1)
        {
          v15 = 0;
          v16 = 0;
          do
          {
            v17 = a3[v15];
            if ((v15 & 1) == 0)
              v17 <<= 8;
            v16 += v17;
            ++v15;
          }
          while (a4 != v15);
          v18 = v16 + HIWORD(v16);
          goto LABEL_14;
        }
        v21 = mDNSLogCategory_DNSSEC;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
          {
LABEL_28:
            *(_DWORD *)buf = 136447234;
            v24 = "rdata_parser_dnskey_get_algorithm(rdata) != DNSKEY_ALGORITHM_RSAMD5";
            v25 = 2082;
            v26 = "";
            v27 = 2082;
            v28 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rr_dnskey.c";
            v29 = 1024;
            v30 = 364;
            v31 = 2048;
            v32 = 0;
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", buf, 0x30u);
          }
        }
        else
        {
          v21 = mDNSLogCategory_DNSSEC_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT))
            goto LABEL_28;
        }
        LOWORD(v18) = 0;
LABEL_14:
        v12 = 0;
        *(_WORD *)(v5 + 80) = v18;
        ++*(_DWORD *)v5;
        v22 = 0;
        v19 = v5;
        goto LABEL_15;
      }
    }
    else
    {
      __break(1u);
    }
    v19 = 0;
  }
LABEL_15:
  if (a5)
    *a5 = v12;
  if (v5)
    ref_count_obj_release((_QWORD *)v5);
  return v19;
}

uint64_t dnssec_obj_rr_dnskey_is_valid_for_dnssec(_BYTE *a1, int *a2)
{
  char v2;
  unsigned int v3;
  unint64_t v4;
  int v5;
  BOOL v6;
  int v7;

  if ((*a1 & 1) != 0)
  {
    v2 = a1[2];
    if (v2)
    {
      v3 = a1[3] - 5;
      v4 = (0xF2DuLL >> (a1[3] - 5)) & 1;
      if (v4)
        v5 = 0;
      else
        v5 = -88890;
      v6 = v3 > 0xB;
      if (v3 <= 0xB)
        v2 = v4;
      else
        v2 = 0;
      if (v6)
        v7 = -88890;
      else
        v7 = v5;
    }
    else
    {
      v7 = -88889;
    }
  }
  else
  {
    v2 = 0;
    v7 = -88888;
  }
  if (a2)
    *a2 = v7;
  return v2 & 1;
}

void *_mdns_xpc_dictionary_get_int64_limited(void *a1, const char *a2, uint64_t a3, uint64_t a4, BOOL *a5)
{
  void *result;
  BOOL v9;

  result = _mdns_xpc_dictionary_get_object(a1, a2, (const _xpc_type_s *)&_xpc_type_int64);
  if (!result)
  {
    v9 = 0;
    if (!a5)
      return result;
    goto LABEL_5;
  }
  result = (void *)xpc_int64_get_value(result);
  v9 = (uint64_t)result >= a3 && (uint64_t)result <= a4;
  if (!v9)
    result = 0;
  if (a5)
LABEL_5:
    *a5 = v9;
  return result;
}

xpc_object_t _mdns_xpc_dictionary_get_object(void *a1, const char *a2, const _xpc_type_s *a3)
{
  xpc_object_t value;
  xpc_object_t v5;

  value = xpc_dictionary_get_value(a1, a2);
  v5 = value;
  if (value && xpc_get_type(value) != a3)
    return 0;
  return v5;
}

void *_mdns_xpc_object_get_uint64_limited(void *result, unint64_t a2, BOOL *a3)
{
  void *v5;
  BOOL v6;

  if (!result)
  {
LABEL_9:
    v6 = 0;
    if (!a3)
      return result;
    goto LABEL_6;
  }
  v5 = result;
  if (xpc_get_type(result) != (xpc_type_t)&_xpc_type_uint64)
  {
    result = 0;
    goto LABEL_9;
  }
  result = (void *)xpc_uint64_get_value(v5);
  v6 = (unint64_t)result <= a2;
  if ((unint64_t)result > a2)
    result = 0;
  if (a3)
LABEL_6:
    *a3 = v6;
  return result;
}

xpc_object_t mdns_xpc_dictionary_get_optional_array(void *a1, const char *a2)
{
  xpc_object_t value;
  xpc_object_t v3;

  value = xpc_dictionary_get_value(a1, a2);
  v3 = value;
  if (value && xpc_get_type(value) != (xpc_type_t)&_xpc_type_array)
    return 0;
  return v3;
}

BOOL mdns_xpc_connection_is_entitled(uint64_t a1, uint64_t a2)
{
  void *v2;
  void *v3;

  v2 = (void *)xpc_connection_copy_entitlement_value(a1, a2);
  v3 = v2;
  if (v2)
    xpc_release(v2);
  return v3 == &_xpc_BOOL_true;
}

xpc_object_t mdns_xpc_string_create_with_format(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  return xpc_string_create_with_format_and_arguments("%.*s", &a9);
}

uint64_t mdns_xpc_string_recreate(xpc_object_t *a1, char *string)
{
  xpc_object_t v4;
  const char *string_ptr;
  uint64_t result;

  v4 = *a1;
  if (!v4)
    goto LABEL_6;
  string_ptr = xpc_string_get_string_ptr(v4);
  if (!string_ptr || (result = strcmp(string_ptr, string), (_DWORD)result))
  {
    if (*a1)
    {
      xpc_release(*a1);
      *a1 = 0;
    }
LABEL_6:
    result = (uint64_t)xpc_string_create(string);
    *a1 = (xpc_object_t)result;
  }
  return result;
}

void *_mdns_address_copy_description(_QWORD *a1, int a2, char a3)
{
  _QWORD *v6;
  _QWORD *v7;
  void *v8;

  v6 = (_QWORD *)mdns_string_builder_create();
  if (!v6)
    return 0;
  v7 = v6;
  if (a2 && mdns_string_builder_append_formatted(v6, "<%s: %p>: ", *(const char **)(a1[2] + 8), a1)
    || mdns_string_builder_append_sockaddr_description(v7, (uint64_t)(a1 + 3), a3))
  {
    v8 = 0;
  }
  else
  {
    v8 = mdns_string_builder_copy_string((uint64_t)v7);
  }
  os_release(v7);
  return v8;
}

BOOL _mdns_address_equal(uint64_t a1, uint64_t a2)
{
  int v2;

  v2 = *(unsigned __int8 *)(a1 + 25);
  if (v2 != *(unsigned __int8 *)(a2 + 25))
    return 0;
  if (v2 == 30)
    return *(unsigned __int16 *)(a1 + 26) == *(unsigned __int16 *)(a2 + 26)
        && *(_QWORD *)(a1 + 32) == *(_QWORD *)(a2 + 32)
        && *(_QWORD *)(a1 + 40) == *(_QWORD *)(a2 + 40);
  return v2 == 2
      && *(unsigned __int16 *)(a1 + 26) == *(unsigned __int16 *)(a2 + 26)
      && *(_DWORD *)(a1 + 28) == *(_DWORD *)(a2 + 28);
}

uint64_t _mdns_address_new()
{
  uint64_t v0;
  uint64_t v1;
  _UNKNOWN **v2;
  void (*v3)(uint64_t);

  v0 = _os_object_alloc(OS_mdns_address, 56);
  v1 = v0;
  if (v0)
  {
    v2 = &_mdns_address_kind;
    *(_QWORD *)(v0 + 16) = &_mdns_address_kind;
    do
    {
      v3 = (void (*)(uint64_t))v2[2];
      if (v3)
        v3(v1);
      v2 = (_UNKNOWN **)*v2;
    }
    while (v2);
  }
  return v1;
}

uint64_t mdns_address_create_from_ip_address_string(char *a1)
{
  char *v1;
  int v2;
  _BYTE *v3;
  uint64_t result;
  uint64_t v5;
  unsigned int v6;
  unsigned __int8 *v7;
  char *v8;
  char *v9;
  int64_t v10;
  int v11;
  unsigned __int8 *v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  char v20[16];
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;

  v1 = a1;
  v19 = 0;
  v28 = 0uLL;
  v2 = *a1;
  if (v2 == 91)
  {
    v3 = a1 + 1;
    result = (uint64_t)strchr(a1 + 1, 93);
    if (!result)
      return result;
    v5 = result;
    if (_mdns_address_parse_ipv6(v3, (unsigned __int8 *)result, &v28, &v19))
      return 0;
    v6 = *(unsigned __int8 *)(v5 + 1);
    if (v6 == 58)
    {
      v7 = (unsigned __int8 *)(v5 + 2);
      goto LABEL_15;
    }
    if (*(_BYTE *)(v5 + 1))
      return 0;
LABEL_24:
    v14 = v19;
    result = _mdns_address_new();
    if (result)
    {
      *(_WORD *)(result + 24) = 7708;
      *(_WORD *)(result + 26) = bswap32(v6) >> 16;
      *(_OWORD *)(result + 32) = v28;
      *(_DWORD *)(result + 48) = v14;
    }
    return result;
  }
  if (!_mdns_address_parse_ipv6(a1, 0, &v28, &v19))
  {
    v6 = 0;
    goto LABEL_24;
  }
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  *(_OWORD *)v20 = 0u;
  v21 = 0u;
  v8 = strchr(v1, 58);
  if (v8)
  {
    v9 = v8;
    v10 = v8 - v1;
    if ((unint64_t)(v8 - v1) > 0x7F)
      return 0;
    __memcpy_chk(v20, v1, v10, 128);
    v20[v10] = 0;
    v7 = (unsigned __int8 *)(v9 + 1);
    v1 = v20;
  }
  else
  {
    v7 = 0;
  }
  if (inet_pton(2, v1, &v28) != 1)
    return 0;
LABEL_15:
  if (v7)
  {
    v11 = *v7;
    if ((v11 - 48) <= 9)
    {
      v6 = 0;
      v12 = v7 + 1;
      while (1)
      {
        v6 = 10 * v6 + (char)v11 - 48;
        if (HIWORD(v6))
          break;
        v13 = *v12++;
        v11 = v13;
        if ((v13 - 48) >= 0xA)
        {
          if (!v11)
            goto LABEL_23;
          return 0;
        }
      }
    }
    return 0;
  }
  v6 = 0;
LABEL_23:
  if (v2 == 91)
    goto LABEL_24;
  v15 = v28;
  v16 = BYTE1(v28);
  v17 = BYTE2(v28);
  v18 = BYTE3(v28);
  result = _mdns_address_new();
  if (result)
  {
    *(_WORD *)(result + 24) = 528;
    *(_WORD *)(result + 26) = bswap32(v6) >> 16;
    *(_DWORD *)(result + 28) = bswap32((v15 << 24) | (v16 << 16) | (v17 << 8) | v18);
  }
  return result;
}

uint64_t _mdns_address_parse_ipv6(_BYTE *a1, unsigned __int8 *a2, _OWORD *a3, _DWORD *a4)
{
  unsigned __int8 *v6;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unsigned __int8 *v12;
  unint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t result;
  unsigned __int8 *v17;
  unsigned __int8 *v18;
  int v19;
  _QWORD __dst[2];
  char v21;
  __int128 v22;
  char v23[16];
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;

  v6 = a2;
  if (!a2)
  {
    v6 = a1 - 1;
    while (*++v6)
      ;
  }
  v8 = v6 - a1;
  if (v6 <= a1)
  {
LABEL_8:
    v9 = 0;
  }
  else
  {
    v9 = (unint64_t)a1;
    while (*(_BYTE *)v9 != 37)
    {
      ++v9;
      if (!--v8)
        goto LABEL_8;
    }
  }
  if (v9)
    v10 = v9;
  else
    v10 = (unint64_t)v6;
  v29 = 0u;
  v30 = 0u;
  v11 = v10 - (_QWORD)a1;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  *(_OWORD *)v23 = 0u;
  v24 = 0u;
  if (v10 - (unint64_t)a1 > 0x7F)
    return 4294960554;
  __memcpy_chk(v23, a1, v10 - (_QWORD)a1, 128);
  v23[v11] = 0;
  v22 = 0uLL;
  if (inet_pton(30, v23, &v22) != 1)
    return 4294960554;
  if (v9)
  {
    v12 = (unsigned __int8 *)(v9 + 1);
    v13 = (unint64_t)&v6[-v9 - 1];
    __dst[0] = 0;
    __dst[1] = 0;
    v21 = 0;
    if (v13 >= 0x11)
    {
      if (v13 == -1 || (v14 = malloc_type_malloc((size_t)&v6[-v9], 0xA172743EuLL), (v15 = v14) == 0))
        __break(1u);
    }
    else
    {
      v14 = 0;
      v15 = __dst;
    }
    memcpy(v15, (const void *)(v9 + 1), (size_t)&v6[-v9 - 1]);
    *((_BYTE *)v15 + v13) = 0;
    LODWORD(v13) = if_nametoindex((const char *)v15);
    if (v14)
      free(v14);
    if (!(_DWORD)v13)
    {
      if (v12 >= v6)
        return 4294960554;
      v13 = 0;
      v17 = &v6[~v9];
      v18 = (unsigned __int8 *)(v9 + 1);
      while (1)
      {
        v19 = *v18;
        if ((v19 - 48) > 9)
          break;
        v13 = ((char)v19 - 48) + 10 * v13;
        if (HIDWORD(v13))
          return 4294960554;
        ++v18;
        if (!--v17)
        {
          v18 = v6;
          break;
        }
      }
      if (v18 != v6 || v18 == v12)
        return 4294960554;
    }
  }
  else
  {
    LODWORD(v13) = 0;
  }
  if (a3)
    *a3 = v22;
  result = 0;
  if (a4)
    *a4 = v13;
  return result;
}

uint64_t _dnssec_obj_denial_of_existence_compare(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  int v7;
  int v8;
  int v9;
  uint64_t result;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;

  if (*(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
    return 2;
  if (*(_DWORD *)(a1 + 44) != *(_DWORD *)(a2 + 44))
    return 2;
  v4 = *(unsigned __int8 *)(a1 + 72);
  if ((_DWORD)v4 != *(unsigned __int8 *)(a2 + 72) || *(unsigned __int8 *)(a1 + 40) != *(unsigned __int8 *)(a2 + 40))
    return 2;
  if (*(_BYTE *)(a1 + 72))
  {
    v5 = (unsigned __int8 *)(a2 + 104);
    v6 = (unsigned __int8 *)(a1 + 104);
    do
    {
      v8 = *v6++;
      v7 = v8;
      v9 = *v5++;
      if (v7 != v9)
        return 2;
    }
    while (--v4);
  }
  if (ref_count_obj_compare(*(_QWORD *)(a1 + 24), *(_QWORD *)(a2 + 24), 1))
    return 2;
  if (*(_BYTE *)(a1 + 40))
  {
    v11 = 0;
    while (!ref_count_obj_compare(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v11), *(_QWORD *)(*(_QWORD *)(a2 + 32) + 8 * v11), 1))
    {
      if (++v11 >= (unint64_t)*(unsigned __int8 *)(a1 + 40))
        goto LABEL_15;
    }
    return 2;
  }
LABEL_15:
  if (*(_BYTE *)(a1 + 72))
  {
    v12 = 0;
    while (!ref_count_obj_compare(*(_QWORD *)(a1 + 48 + 8 * v12), *(_QWORD *)(a2 + 48 + 8 * v12), 1))
    {
      ++v12;
      v13 = *(unsigned __int8 *)(a1 + 72);
      if (v12 >= v13)
      {
        if (!*(_BYTE *)(a1 + 72))
          return 0;
        v14 = 0;
        while (!*(_BYTE *)(a1 + v14 + 104))
        {
LABEL_26:
          result = 0;
          if (++v14 >= (unint64_t)v13)
            return result;
        }
        v15 = 0;
        while (!ref_count_obj_compare(*(_QWORD *)(*(_QWORD *)(a1 + 8 * v14 + 80) + 8 * v15), *(_QWORD *)(*(_QWORD *)(a2 + 8 * v14 + 80) + 8 * v15), 1))
        {
          if (++v15 >= (unint64_t)*(unsigned __int8 *)(a1 + v14 + 104))
          {
            LODWORD(v13) = *(unsigned __int8 *)(a1 + 72);
            goto LABEL_26;
          }
        }
        return 2;
      }
    }
    return 2;
  }
  return 0;
}

void _dnssec_obj_denial_of_existence_finalize(uint64_t a1)
{
  _QWORD *v2;
  unsigned int v3;
  unint64_t v4;
  _QWORD *v5;
  void *v6;
  int v7;
  unsigned int v8;
  unint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  unint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  unsigned __int8 v16;
  unint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  uint64_t v20;
  void *v21;
  _QWORD *v22;
  void *v23;

  v2 = *(_QWORD **)(a1 + 24);
  if (v2)
  {
    ref_count_obj_release(v2);
    *(_QWORD *)(a1 + 24) = 0;
  }
  v3 = *(unsigned __int8 *)(a1 + 40);
  if (*(_BYTE *)(a1 + 40))
  {
    v4 = 0;
    do
    {
      v5 = *(_QWORD **)(*(_QWORD *)(a1 + 32) + 8 * v4);
      if (v5)
      {
        ref_count_obj_release(v5);
        *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v4) = 0;
        v3 = *(unsigned __int8 *)(a1 + 40);
      }
      ++v4;
    }
    while (v4 < v3);
  }
  v6 = *(void **)(a1 + 32);
  if (v6)
  {
    free(v6);
    *(_QWORD *)(a1 + 32) = 0;
  }
  v7 = *(_DWORD *)(a1 + 44);
  if (v7 == 1)
  {
    v8 = *(unsigned __int8 *)(a1 + 72);
    if (!*(_BYTE *)(a1 + 72))
      return;
    v12 = 0;
    v13 = a1 + 48;
    do
    {
      v14 = *(_QWORD **)(v13 + 8 * v12);
      if (v14)
      {
        ref_count_obj_release(v14);
        *(_QWORD *)(v13 + 8 * v12) = 0;
        v8 = *(unsigned __int8 *)(a1 + 72);
      }
      ++v12;
    }
    while (v12 < v8);
  }
  else if (v7 == 2)
  {
    v8 = *(unsigned __int8 *)(a1 + 72);
    if (!*(_BYTE *)(a1 + 72))
      return;
    v9 = 0;
    v10 = a1 + 48;
    do
    {
      v11 = *(_QWORD **)(v10 + 8 * v9);
      if (v11)
      {
        ref_count_obj_release(v11);
        *(_QWORD *)(v10 + 8 * v9) = 0;
        v8 = *(unsigned __int8 *)(a1 + 72);
      }
      ++v9;
    }
    while (v9 < v8);
  }
  else
  {
    v8 = *(unsigned __int8 *)(a1 + 72);
  }
  if (v8)
  {
    v15 = 0;
    do
    {
      v16 = *(_BYTE *)(a1 + v15 + 104);
      if (v16)
      {
        v17 = 0;
        v18 = (_QWORD *)(a1 + 8 * v15 + 80);
        do
        {
          v19 = *(_QWORD **)(*v18 + 8 * v17);
          if (v19)
          {
            ref_count_obj_release(v19);
            *(_QWORD *)(*v18 + 8 * v17) = 0;
            v16 = *(_BYTE *)(a1 + v15 + 104);
          }
          ++v17;
        }
        while (v17 < v16);
      }
      v20 = a1 + 8 * v15;
      v23 = *(void **)(v20 + 80);
      v22 = (_QWORD *)(v20 + 80);
      v21 = v23;
      if (v23)
      {
        free(v21);
        *v22 = 0;
      }
      ++v15;
    }
    while (v15 < *(unsigned __int8 *)(a1 + 72));
  }
}

_QWORD *dnssec_obj_denial_of_existence_create(unsigned __int8 *a1, int a2, unsigned int a3, unsigned __int8 *a4, unsigned __int8 *a5, _DWORD *a6, unsigned __int8 *a7, unsigned int a8, uint64_t a9, unsigned __int8 a10, uint64_t *a11, unsigned __int8 a12, uint64_t a13, unsigned __int8 a14, int *a15)
{
  _QWORD *v15;
  size_t v16;
  uint64_t v17;
  unsigned __int8 *v21;
  BOOL v22;
  unsigned __int8 *v23;
  uint64_t v24;
  unint64_t k;
  uint64_t v26;
  uint64_t *v27;
  BOOL v28;
  uint64_t v29;
  _QWORD *v30;
  int *v31;
  _UNKNOWN **v32;
  void (*v33)(_QWORD *);
  BOOL v34;
  uint64_t v35;
  unint64_t i;
  uint64_t v37;
  unsigned __int8 *v38;
  unsigned __int8 *v39;
  size_t v40;
  unsigned __int8 *v41;
  unsigned __int8 *v42;
  unsigned __int8 *v43;
  unsigned int v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unsigned int v48;
  _BOOL4 v50;
  unsigned __int8 *v51;
  uint64_t v52;
  BOOL does_not_exist;
  uint64_t v54;
  unsigned __int8 *v55;
  unsigned __int8 *v56;
  unsigned __int8 *v57;
  _QWORD *v58;
  _DWORD *v59;
  _QWORD *v60;
  uint64_t j;
  uint64_t v62;
  _BYTE *v63;
  unsigned __int8 *parent;
  int v65;
  unsigned __int8 *v66;
  uint64_t *v67;
  unint64_t v68;
  uint64_t v69;
  _BYTE *v70;
  uint64_t nsec3_hashed_name;
  uint64_t v72;
  int v73;
  int v74;
  NSObject *v75;
  int v76;
  _QWORD *v77;
  int v78;
  BOOL v79;
  int v80;
  _QWORD *v81;
  int v82;
  _QWORD *v83;
  uint64_t v84;
  _BYTE *v85;
  __int16 v86;
  char v87;
  _DWORD *v88;
  _BYTE *v89;
  unsigned __int8 *v90;
  unsigned __int8 *v91;
  uint64_t v92;
  uint64_t v93;
  unsigned __int8 *v94;
  unsigned __int8 *v95;
  unsigned __int8 *v96;
  unint64_t v97;
  unint64_t v98;
  unsigned __int8 *v99;
  unsigned int v100;
  uint64_t v101;
  uint64_t v102;
  char v103;
  uint64_t v104;
  int v105;
  uint64_t v106;
  uint64_t v107;
  _BYTE *v108;
  unint64_t v109;
  unint64_t v110;
  char v111;
  _BYTE *v112;
  uint64_t v113;
  unint64_t v114;
  BOOL v115;
  int v116;
  _BYTE *v117;
  uint64_t v118;
  unint64_t v119;
  BOOL v120;
  int v121;
  uint64_t v122;
  unint64_t v123;
  BOOL v124;
  _BYTE *v125;
  int v126;
  unint64_t v127;
  _BYTE *v128;
  int v129;
  uint64_t v130;
  uint64_t v131;
  _BYTE *v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  _BYTE *v136;
  unint64_t v137;
  unint64_t v138;
  int v139;
  _QWORD *v140;
  uint64_t v141;
  unsigned __int8 v142;
  uint64_t v143;
  _QWORD *v144;
  uint64_t v145;
  unsigned __int8 v146;
  uint64_t v147;
  uint64_t v148;
  NSObject *v149;
  int v150;
  unsigned __int8 *v151;
  int v152;
  unsigned __int8 *v153;
  int v154;
  int v155;
  _BYTE *v156;
  uint64_t v157;
  unint64_t v158;
  BOOL v159;
  int v160;
  _BYTE *v161;
  uint64_t v162;
  unint64_t v163;
  BOOL v164;
  uint64_t v165;
  unint64_t v166;
  BOOL v167;
  _BYTE *v168;
  char v169;
  _QWORD *v170;
  uint64_t v171;
  unsigned __int8 v172;
  uint64_t v173;
  uint64_t v174;
  int v175;
  _QWORD *v176;
  uint64_t v177;
  unsigned __int8 v178;
  uint64_t v179;
  _QWORD *v180;
  uint64_t v181;
  unsigned __int8 v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  _QWORD *v186;
  unint64_t v187;
  int v188;
  unint64_t v189;
  uint64_t v190;
  size_t v191;
  void *v192;
  uint64_t v193;
  _QWORD *v194;
  unint64_t v195;
  unint64_t v196;
  _DWORD *v197;
  uint64_t v198;
  uint64_t v199;
  _QWORD *v200;
  uint8_t *v201;
  uint64_t v202;
  void *v203;
  unsigned __int8 *v204;
  uint64_t v205;
  _QWORD *v206;
  _QWORD *v207;
  _DWORD *v208;
  uint64_t v209;
  NSObject *v211;
  int v212;
  unsigned __int8 *v213;
  int v214;
  unsigned __int8 *v215;
  int v216;
  unsigned __int8 *v217;
  int v218;
  unsigned __int8 *v219;
  int v220;
  unsigned __int8 *v221;
  int v222;
  unsigned __int8 *v223;
  int v224;
  unsigned __int8 *v225;
  unsigned __int8 *v226;
  unsigned __int8 *v227;
  uint64_t v228;
  unsigned __int8 *v229;
  int *v231;
  uint64_t v232;
  uint64_t v234;
  int v235;
  _QWORD *v237;
  uint64_t v238;
  _BOOL4 v239;
  unsigned __int8 *v240;
  int v242;
  uint8_t buf[34];
  _BYTE v244[6];
  _QWORD v245[3];
  uint64_t v246;
  int v247;

  if (a6)
    v21 = a7;
  else
    v21 = 0;
  if (v21)
    v22 = a6 == 0;
  else
    v22 = 1;
  if (v22)
    v23 = 0;
  else
    v23 = (unsigned __int8 *)a8;
  if (a9)
    v24 = a10;
  else
    v24 = 0;
  if (a11)
    k = a12;
  else
    k = 0;
  v234 = v24;
  if ((_DWORD)v24)
    v26 = a9;
  else
    v26 = 0;
  if ((_DWORD)k)
    v27 = a11;
  else
    v27 = 0;
  if (!(v26 | (unint64_t)v27))
    a13 = 0;
  v227 = v23;
  v228 = a13;
  if (a13)
    v28 = (v26 | (unint64_t)v27) == 0;
  else
    v28 = 1;
  if (v28)
    v29 = 0;
  else
    v29 = a14;
  v232 = v29;
  v30 = malloc_type_calloc(1uLL, 0x70uLL, 0xF1748037uLL);
  if (!v30)
    goto LABEL_383;
  v15 = v30;
  v31 = a15;
  v32 = &_dnssec_obj_denial_of_existence_kind;
  v30[1] = &_dnssec_obj_denial_of_existence_kind;
  do
  {
    v33 = (void (*)(_QWORD *))v32[2];
    if (v33)
      v33(v15);
    v32 = (_UNKNOWN **)*v32;
  }
  while (v32);
  ++*(_DWORD *)v15;
  if (!(k | v234))
  {
    v81 = 0;
    v82 = -6705;
    goto LABEL_417;
  }
  if (!(_DWORD)k)
  {
    if (!(_DWORD)v234)
    {
      v81 = 0;
      *((_DWORD *)v15 + 11) = 0;
      *((_DWORD *)v15 + 4) = 0;
      v82 = -6705;
      v83 = v15;
      *((_BYTE *)v15 + 72) = 0;
      goto LABEL_378;
    }
    LODWORD(v246) = 0;
    v50 = (_DWORD)a5 == a3 || (_DWORD)a5 == 5;
    *((_DWORD *)v15 + 11) = 1;
    *((_DWORD *)v15 + 4) = 2;
    *((_BYTE *)v15 + 107) = 0;
    *((_BYTE *)v15 + 72) = 0;
    v51 = dnssec_obj_domain_name_create_with_labels(a1, 0, (int *)&v246);
    v231 = a15;
    v226 = v21;
    if ((_DWORD)v246)
    {
      v56 = 0;
      v17 = 0;
      v57 = 0;
      v55 = 0;
    }
    else
    {
      v52 = 0;
      while (1)
      {
        does_not_exist = dnssec_obj_rr_nsec_asserts_name_exists_data_does_not_exist(*(_QWORD *)(v26 + 8 * v52), (uint64_t)v51, a2, a3);
        v54 = *(_QWORD *)(v26 + 8 * v52);
        if (does_not_exist)
        {
          ++*(_DWORD *)v54;
          v15[*((unsigned __int8 *)v15 + 72) + 6] = v54;
          v84 = *((unsigned __int8 *)v15 + 72);
          ++*(_DWORD *)v15[v84 + 6];
          *((_BYTE *)v15 + 72) = v84 + 1;
          *((_DWORD *)v15 + 4) = 3;
          v85 = *(_BYTE **)(v54 + 24);
          v86 = *(_WORD *)(v54 + 36);
          if ((dnssec_obj_rr_nsec_covers_dns_type(v85, v86, 0x2Bu) & 1) != 0)
          {
            v87 = 0;
            v88 = a6;
          }
          else
          {
            v88 = a6;
            if ((dnssec_obj_rr_nsec_covers_dns_type(v85, v86, 6u) & 1) != 0)
              v87 = 0;
            else
              v87 = dnssec_obj_rr_nsec_covers_dns_type(v85, v86, 2u);
          }
          v55 = 0;
          v56 = 0;
          v17 = 0;
          v57 = 0;
          *((_BYTE *)v15 + 107) = v87;
          goto LABEL_211;
        }
        if ((dnssec_obj_rr_nsec_asserts_name_does_not_exist(*(_QWORD *)(v26 + 8 * v52), (uint64_t)v51, a2) & 1) != 0)
          break;
        if (v234 == ++v52)
        {
          v54 = 0;
          v55 = 0;
          v56 = 0;
          v17 = 0;
          v57 = 0;
          goto LABEL_206;
        }
      }
      v239 = v50;
      v55 = *(unsigned __int8 **)(v26 + 8 * v52);
      ++*(_DWORD *)v55;
      *(_DWORD *)buf = 0;
      v89 = (_BYTE *)*((_QWORD *)v51 + 2);
      if (*v89)
      {
        v90 = dnssec_obj_domain_name_copy_parent_domain(v89, 1uLL, (int *)buf);
        v91 = v90;
        v240 = v55;
        if (!*(_DWORD *)buf)
        {
          v92 = *((_QWORD *)v55 + 2);
          v93 = *((_QWORD *)v55 + 10);
          v94 = dnssec_obj_domain_name_copy_closest_common_ancestor(*(unsigned __int8 **)(v92 + 16), *((unsigned __int8 **)v90 + 2), buf);
          if (!*(_DWORD *)buf)
          {
            v95 = dnssec_obj_domain_name_copy_closest_common_ancestor(*(unsigned __int8 **)(v93 + 16), *((unsigned __int8 **)v91 + 2), buf);
            v96 = v95;
            if (*(_DWORD *)buf)
            {
              LODWORD(v246) = *(_DWORD *)buf;
              ref_count_obj_release(v91);
              v57 = 0;
              if (v96)
                goto LABEL_134;
            }
            else
            {
              v97 = *((_QWORD *)v94 + 3);
              v98 = *((_QWORD *)v95 + 3);
              if (v97 <= v98)
                v99 = v95;
              else
                v99 = v94;
              LOWORD(v242) = 10753;
              BYTE2(v242) = 0;
              v57 = dnssec_obj_domain_name_create_concatenation_with_subdomain(&v242, *((_BYTE **)v99 + 2), buf);
              LODWORD(v246) = *(_DWORD *)buf;
              ref_count_obj_release(v91);
              ref_count_obj_release(v99);
              if (v97 > v98)
              {
                v94 = 0;
LABEL_134:
                ref_count_obj_release(v96);
              }
            }
            v91 = v94;
            v100 = a3;
            v101 = v234;
            if (!v94)
              goto LABEL_137;
            goto LABEL_136;
          }
          v57 = 0;
          LODWORD(v246) = *(_DWORD *)buf;
          v96 = v91;
          goto LABEL_134;
        }
        LODWORD(v246) = *(_DWORD *)buf;
        if (v90)
        {
          v57 = 0;
          v100 = a3;
          v101 = v234;
LABEL_136:
          ref_count_obj_release(v91);
LABEL_137:
          if ((_DWORD)v246)
          {
            v56 = 0;
            v17 = 0;
            v54 = 0;
            v88 = a6;
            v55 = v240;
            goto LABEL_212;
          }
          v102 = 0;
          while (1)
          {
            v103 = dnssec_obj_rr_nsec_asserts_name_does_not_exist(*(_QWORD *)(v26 + 8 * v102), (uint64_t)v57, a2);
            v17 = *(_QWORD *)(v26 + 8 * v102);
            if ((v103 & 1) != 0)
              break;
            if (dnssec_obj_rr_nsec_asserts_name_exists_data_does_not_exist(*(_QWORD *)(v26 + 8 * v102), (uint64_t)v57, a2, v100))
            {
              v56 = *(unsigned __int8 **)(v26 + 8 * v102);
              ++*(_DWORD *)v56;
              v144 = v15 + 6;
              v55 = v240;
              v15[*((unsigned __int8 *)v15 + 72) + 6] = v240;
              v145 = *((unsigned __int8 *)v15 + 72);
              ++*(_DWORD *)v15[v145 + 6];
              v146 = v145 + 1;
              *((_BYTE *)v15 + 72) = v146;
              if (v56 != v240)
              {
                v144[v146] = v56;
                v147 = *((unsigned __int8 *)v15 + 72);
                ++*(_DWORD *)v144[v147];
                *((_BYTE *)v15 + 72) = v147 + 1;
              }
              v54 = 0;
              v17 = 0;
              v105 = 6;
              goto LABEL_205;
            }
            if (v101 == ++v102)
            {
              if (v239)
              {
                v54 = 0;
                v56 = 0;
                v17 = 0;
                v55 = v240;
                v15[*((unsigned __int8 *)v15 + 72) + 6] = v240;
                v104 = *((unsigned __int8 *)v15 + 72);
                ++*(_DWORD *)v15[v104 + 6];
                *((_BYTE *)v15 + 72) = v104 + 1;
                v105 = 5;
                goto LABEL_205;
              }
              v54 = 0;
              v56 = 0;
              v17 = 0;
              v88 = a6;
              v55 = v240;
LABEL_211:
              LODWORD(v246) = 0;
LABEL_212:
              dnssec_objs_sort((uint64_t)(v15 + 6), *((unsigned __int8 *)v15 + 72));
              v82 = v246;
              if (v56)
                ref_count_obj_release(v56);
              if (v17)
                ref_count_obj_release((_QWORD *)v17);
              if (v57)
                ref_count_obj_release(v57);
              if (v55)
                ref_count_obj_release(v55);
              if (v54)
                ref_count_obj_release((_QWORD *)v54);
              if (v51)
                ref_count_obj_release(v51);
              v31 = a15;
              if (!v82)
                goto LABEL_320;
              v149 = mDNSLogCategory_DNSSEC;
              if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
              {
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_DEBUG))
                {
                  v150 = (int)a1;
                  if (a1)
                  {
                    LODWORD(v221) = (_DWORD)a1;
                    v222 = *a1;
                    if (*a1)
                    {
                      v221 = a1;
                      do
                      {
                        v223 = &v221[v222];
                        v224 = v223[1];
                        v221 = v223 + 1;
                        v222 = v224;
                      }
                      while (v224);
                    }
                    v150 = (_DWORD)v221 - (_DWORD)a1 + 1;
                  }
LABEL_415:
                  *(_DWORD *)buf = 141559299;
                  *(_QWORD *)&buf[4] = 1752392040;
                  *(_WORD *)&buf[12] = 1040;
                  *(_DWORD *)&buf[14] = v150;
                  *(_WORD *)&buf[18] = 2101;
                  *(_QWORD *)&buf[20] = a1;
                  *(_WORD *)&buf[28] = 1024;
                  *(_DWORD *)&buf[30] = a3;
                  *(_WORD *)v244 = 1024;
                  *(_DWORD *)&v244[2] = v234;
                  LOWORD(v245[0]) = 2082;
                  *(_QWORD *)((char *)v245 + 2) = "Unknown DNSSEC error.";
                  _os_log_impl((void *)&_mh_execute_header, v149, OS_LOG_TYPE_DEBUG, "Failed to find out a provable denial of existence NSEC set - qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %u, NSEC count: %u, error: %{public}s", buf, 0x32u);
                }
              }
              else
              {
                v149 = mDNSLogCategory_DNSSEC_redacted;
                if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_DEBUG))
                {
                  v150 = (int)a1;
                  if (a1)
                  {
                    LODWORD(v151) = (_DWORD)a1;
                    v152 = *a1;
                    if (*a1)
                    {
                      v151 = a1;
                      do
                      {
                        v153 = &v151[v152];
                        v154 = v153[1];
                        v151 = v153 + 1;
                        v152 = v154;
                      }
                      while (v154);
                    }
                    v150 = (_DWORD)v151 - (_DWORD)a1 + 1;
                  }
                  goto LABEL_415;
                }
              }
LABEL_416:
              v81 = 0;
LABEL_417:
              v83 = v15;
              goto LABEL_378;
            }
          }
          ++*(_DWORD *)v17;
          v140 = v15 + 6;
          v55 = v240;
          v15[*((unsigned __int8 *)v15 + 72) + 6] = v240;
          v141 = *((unsigned __int8 *)v15 + 72);
          ++*(_DWORD *)v15[v141 + 6];
          v142 = v141 + 1;
          *((_BYTE *)v15 + 72) = v142;
          if ((unsigned __int8 *)v17 != v240)
          {
            v140[v142] = v17;
            v143 = *((unsigned __int8 *)v15 + 72);
            ++*(_DWORD *)v140[v143];
            *((_BYTE *)v15 + 72) = v143 + 1;
          }
          v54 = 0;
          v56 = 0;
          v105 = 4;
LABEL_205:
          *((_DWORD *)v15 + 4) = v105;
LABEL_206:
          v88 = a6;
          goto LABEL_211;
        }
      }
      else
      {
        LODWORD(v246) = -6736;
      }
      v56 = 0;
      v17 = 0;
      v57 = 0;
    }
    v54 = 0;
    v88 = a6;
    goto LABEL_212;
  }
  v231 = a15;
  v242 = 0;
  *((_DWORD *)v15 + 11) = 2;
  *((_DWORD *)v15 + 4) = 2;
  *((_BYTE *)v15 + 107) = 0;
  *((_BYTE *)v15 + 72) = 0;
  v226 = v21;
  if ((_DWORD)k != 1)
  {
    v34 = 0;
    v35 = *v27;
    for (i = 1; i != k; v34 = i >= k)
    {
      v37 = v27[i];
      if (v35 != v37)
      {
        v38 = *(unsigned __int8 **)(v35 + 24);
        v39 = *(unsigned __int8 **)(v37 + 24);
        if (*v38 != *v39)
          break;
        if (__rev16(*((unsigned __int16 *)v38 + 1)) != bswap32(*((unsigned __int16 *)v39 + 1)) >> 16)
          break;
        v40 = v38[4];
        if ((_DWORD)v40 != v39[4] || memcmp(v38 + 5, v39 + 5, v40))
          break;
      }
      ++i;
    }
    if (!v34)
      goto LABEL_385;
  }
  if ((a4 == 0) == ((_DWORD)a5 == a3))
    goto LABEL_385;
  if (__rev16(*(unsigned __int16 *)(*(_QWORD *)(*v27 + 24) + 2)) >= 0x65)
  {
    if (k <= 3)
    {
      *((_DWORD *)v15 + 4) = 1;
      v58 = v15 + 6;
      do
      {
        v59 = (_DWORD *)*v27++;
        *v58++ = v59;
        ++*v59;
        ++*((_BYTE *)v15 + 72);
        --k;
      }
      while (k);
      v17 = 0;
      v16 = 0;
      v27 = 0;
      v240 = 0;
      v60 = 0;
      a4 = 0;
      a5 = 0;
      v42 = 0;
      v229 = 0;
      goto LABEL_298;
    }
LABEL_385:
    v17 = 0;
    v16 = 0;
    v27 = 0;
    v240 = 0;
    v60 = 0;
    a4 = 0;
    a5 = 0;
    k = 0;
    v42 = 0;
    v229 = 0;
    goto LABEL_299;
  }
  v229 = dnssec_obj_domain_name_create_with_labels(a1, 0, &v242);
  if (v242)
  {
    v17 = 0;
    v16 = 0;
    v27 = 0;
    v240 = 0;
    v60 = 0;
    a4 = 0;
    a5 = 0;
    k = 0;
    v42 = 0;
    goto LABEL_299;
  }
  if (!a4)
    goto LABEL_75;
  v41 = dnssec_obj_domain_name_create_with_labels(a4, 0, &v242);
  v42 = v41;
  if (v242)
  {
LABEL_396:
    v17 = 0;
    v16 = 0;
    v27 = 0;
    v240 = 0;
LABEL_408:
    v60 = 0;
    a4 = 0;
    a5 = 0;
    k = 0;
    goto LABEL_299;
  }
  if (!v41)
  {
LABEL_75:
    for (j = 0; j != k; ++j)
    {
      v62 = v27[j];
      v63 = *(_BYTE **)(v62 + 24);
      if (*v63 == 1
        && v63[1] <= 1u
        && dnssec_obj_rr_nsec3_asserts_name_exists_data_does_not_exist(v62, (uint64_t)v229, a2, a3))
      {
        k = v27[j];
        ++*(_DWORD *)k;
        v15[*((unsigned __int8 *)v15 + 72) + 6] = k;
        v133 = *((unsigned __int8 *)v15 + 72);
        ++*(_DWORD *)v15[v133 + 6];
        *((_BYTE *)v15 + 72) = v133 + 1;
        *((_DWORD *)v15 + 4) = 3;
        v134 = *(_QWORD *)(k + 24);
        v135 = *(unsigned __int8 *)(v134 + 4)
             + v134
             + 5
             + *(unsigned __int8 *)(*(unsigned __int8 *)(v134 + 4) + v134 + 5);
        v136 = (_BYTE *)(v135 + 1);
        v137 = v135
             + 1
             + (unsigned __int16)(*(_WORD *)(k + 36)
                                - (*(unsigned __int8 *)(v134 + 4)
                                 + 5
                                 + *(unsigned __int8 *)(*(unsigned __int8 *)(v134 + 4) + v134 + 5)
                                 + 1));
        v138 = v135 + 2;
        if (v138 < v137)
        {
          v155 = 0;
          v156 = v136;
          do
          {
            v157 = v156[1];
            v158 = (unint64_t)&v156[v157 + 2];
            if (v158 > v137)
              break;
            if (*v156)
              v159 = 0;
            else
              v159 = v157 >= 6;
            if (v159)
              v155 |= (v156[7] & 0x10) >> 4;
            v156 += v157 + 2;
          }
          while (v158 + 1 < v137);
          LOBYTE(v139) = 0;
          if ((v155 & 1) == 0 && v138 < v137)
          {
            v160 = 0;
            v161 = v136;
            do
            {
              v162 = v161[1];
              v163 = (unint64_t)&v161[v162 + 2];
              if (v163 > v137)
                break;
              if (*v161)
                v164 = 1;
              else
                v164 = (_DWORD)v162 == 0;
              if (!v164)
                v160 |= (v161[2] & 2) >> 1;
              v161 += v162 + 2;
            }
            while (v163 + 1 < v137);
            LOBYTE(v139) = 0;
            if ((v160 & 1) == 0 && v138 < v137)
            {
              v139 = 0;
              do
              {
                v165 = v136[1];
                v166 = (unint64_t)&v136[v165 + 2];
                if (v166 > v137)
                  break;
                if (*v136)
                  v167 = 1;
                else
                  v167 = (_DWORD)v165 == 0;
                if (!v167)
                  v139 |= (v136[2] & 0x20) >> 5;
                v136 += v165 + 2;
              }
              while (v166 + 1 < v137);
            }
          }
        }
        else
        {
          LOBYTE(v139) = 0;
        }
        v17 = 0;
        v16 = 0;
        v27 = 0;
        v240 = 0;
        v60 = 0;
        a4 = 0;
        a5 = 0;
        v42 = 0;
        *((_BYTE *)v15 + 107) = v139 & 1;
        goto LABEL_298;
      }
    }
    v235 = 0;
    v16 = 0;
    v17 = 0;
    v240 = 0;
    v225 = 0;
    LODWORD(v246) = 0;
    parent = a1;
    v65 = a2;
LABEL_81:
    if (!*parent)
      goto LABEL_145;
    v237 = (_QWORD *)v16;
    v238 = v17;
    v66 = dnssec_obj_domain_name_create_with_labels(parent, 0, (int *)&v246);
    v67 = v27;
    v68 = k;
    while (1)
    {
      v69 = *v67;
      if (*v67)
      {
        v70 = *(_BYTE **)(v69 + 24);
        if (*v70 == 1 && v70[1] <= 1u)
        {
          if ((dnssec_obj_rr_nsec3_asserts_name_does_not_exist(*v67, (uint64_t)v66, v65) & 1) != 0)
          {
            ++*(_DWORD *)v69;
            if (v240)
              ref_count_obj_release(v240);
            ++*(_DWORD *)v66;
            if (v237)
              ref_count_obj_release(v237);
            v76 = 0;
            ++*(_DWORD *)v69;
            v235 = 1;
            v77 = (_QWORD *)v69;
            v240 = v66;
LABEL_120:
            ref_count_obj_release((_QWORD *)v69);
            v78 = v76;
            v16 = (size_t)v77;
            if (v66)
LABEL_103:
              ref_count_obj_release(v66);
LABEL_104:
            v17 = v238;
            if (v238)
              v79 = v16 == 0;
            else
              v79 = 1;
            v80 = !v79;
            v65 = a2;
            if (((v78 | v80) & 1) == 0)
            {
              parent = domain_name_labels_get_parent(parent, 1uLL);
              goto LABEL_81;
            }
            if ((v78 & 1) == 0)
            {
LABEL_145:
              if (v17 && v16)
              {
                v106 = *(_QWORD *)(v17 + 24);
                v107 = *(unsigned __int8 *)(v106 + 4)
                     + v106
                     + 5
                     + *(unsigned __int8 *)(*(unsigned __int8 *)(v106 + 4) + v106 + 5);
                v108 = (_BYTE *)(v107 + 1);
                v109 = v107
                     + 1
                     + (unsigned __int16)(*(_WORD *)(v17 + 36)
                                        - (*(unsigned __int8 *)(v106 + 4)
                                         + 5
                                         + *(unsigned __int8 *)(*(unsigned __int8 *)(v106 + 4) + v106 + 5)
                                         + 1));
                v110 = v107 + 2;
                if (v110 < v109)
                {
                  v111 = 0;
                  v112 = v108;
                  do
                  {
                    v113 = v112[1];
                    v114 = (unint64_t)&v112[v113 + 2];
                    if (v114 > v109)
                      break;
                    if (*v112)
                      v115 = 0;
                    else
                      v115 = v113 >= 5;
                    if (v115)
                      v111 |= v112[6];
                    v112 += v113 + 2;
                  }
                  while (v114 + 1 < v109);
                  if ((v111 & 1) != 0)
                    goto LABEL_418;
                  if (v110 < v109)
                  {
                    v116 = 0;
                    v117 = v108;
                    do
                    {
                      v118 = v117[1];
                      v119 = (unint64_t)&v117[v118 + 2];
                      if (v119 > v109)
                        break;
                      if (*v117)
                        v120 = 1;
                      else
                        v120 = (_DWORD)v118 == 0;
                      if (!v120)
                        v116 |= (v117[2] & 0x20) >> 5;
                      v117 += v118 + 2;
                    }
                    while (v119 + 1 < v109);
                    if (v110 >= v109)
                    {
                      LOBYTE(v121) = 0;
                    }
                    else
                    {
                      v121 = 0;
                      do
                      {
                        v122 = v108[1];
                        v123 = (unint64_t)&v108[v122 + 2];
                        if (v123 > v109)
                          break;
                        if (*v108)
                          v124 = 1;
                        else
                          v124 = (_DWORD)v122 == 0;
                        if (!v124)
                          v121 |= (v108[2] & 2) >> 1;
                        v108 += v122 + 2;
                      }
                      while (v123 + 1 < v109);
                    }
                    if ((v116 & 1) != 0 && (v121 & 1) == 0)
                    {
LABEL_418:
                      v60 = 0;
                      a4 = 0;
                      a5 = 0;
                      k = 0;
                      v42 = 0;
                      v242 = -90040;
                      goto LABEL_278;
                    }
                  }
                }
                buf[2] = 0;
                *(_WORD *)buf = 10753;
                a5 = dnssec_obj_domain_name_create_concatenation_with_subdomain(buf, *((_BYTE **)v225 + 2), &v242);
                if (v242)
                  goto LABEL_277;
                while (1)
                {
                  v168 = *(_BYTE **)(*v27 + 24);
                  if (*v168 == 1 && v168[1] <= 1u)
                  {
                    v169 = dnssec_obj_rr_nsec3_asserts_name_does_not_exist(*v27, (uint64_t)a5, a2);
                    a4 = (unsigned __int8 *)*v27;
                    if ((v169 & 1) != 0)
                    {
                      ++*(_DWORD *)a4;
                      v170 = v15 + 6;
                      v15[*((unsigned __int8 *)v15 + 72) + 6] = v17;
                      v171 = *((unsigned __int8 *)v15 + 72);
                      ++*(_DWORD *)v15[v171 + 6];
                      v172 = v171 + 1;
                      *((_BYTE *)v15 + 72) = v172;
                      if (v16 != v17)
                      {
                        v170[v172] = v16;
                        v173 = *((unsigned __int8 *)v15 + 72);
                        ++*(_DWORD *)v170[v173];
                        v172 = v173 + 1;
                        *((_BYTE *)v15 + 72) = v172;
                      }
                      v27 = (uint64_t *)v225;
                      if (a4 != (unsigned __int8 *)v17 && a4 != (unsigned __int8 *)v16)
                      {
                        v170[v172] = a4;
                        v174 = *((unsigned __int8 *)v15 + 72);
                        ++*(_DWORD *)v170[v174];
                        *((_BYTE *)v15 + 72) = v174 + 1;
                      }
                      if (a3 == 43 && (*(_BYTE *)(*(_QWORD *)(v16 + 24) + 1) & 1) != 0)
                        goto LABEL_384;
                      v60 = 0;
                      v175 = 4;
                      goto LABEL_296;
                    }
                    if (dnssec_obj_rr_nsec3_asserts_name_exists_data_does_not_exist(*v27, (uint64_t)a5, a2, a3))
                    {
                      v60 = (_QWORD *)*v27;
                      ++*(_DWORD *)*v27;
                      v180 = v15 + 6;
                      v15[*((unsigned __int8 *)v15 + 72) + 6] = v17;
                      v181 = *((unsigned __int8 *)v15 + 72);
                      ++*(_DWORD *)v15[v181 + 6];
                      v182 = v181 + 1;
                      *((_BYTE *)v15 + 72) = v182;
                      if (v16 != v17)
                      {
                        v180[v182] = v16;
                        v183 = *((unsigned __int8 *)v15 + 72);
                        ++*(_DWORD *)v180[v183];
                        v182 = v183 + 1;
                        *((_BYTE *)v15 + 72) = v182;
                      }
                      v27 = (uint64_t *)v225;
                      if (v60 != (_QWORD *)v17 && v60 != (_QWORD *)v16)
                      {
                        v180[v182] = v60;
                        v184 = *((unsigned __int8 *)v15 + 72);
                        ++*(_DWORD *)v180[v184];
                        *((_BYTE *)v15 + 72) = v184 + 1;
                      }
                      a4 = 0;
                      v175 = 6;
LABEL_296:
                      *((_DWORD *)v15 + 4) = v175;
                      goto LABEL_297;
                    }
                  }
                  ++v27;
                  if (!--k)
                  {
                    if (a3 == 43 && (*(_BYTE *)(*(_QWORD *)(v16 + 24) + 1) & 1) != 0)
                    {
                      v176 = v15 + 6;
                      v15[*((unsigned __int8 *)v15 + 72) + 6] = v17;
                      v177 = *((unsigned __int8 *)v15 + 72);
                      ++*(_DWORD *)v15[v177 + 6];
                      v178 = v177 + 1;
                      *((_BYTE *)v15 + 72) = v178;
                      if (v16 != v17)
                      {
                        v176[v178] = v16;
                        v179 = *((unsigned __int8 *)v15 + 72);
                        ++*(_DWORD *)v176[v179];
                        *((_BYTE *)v15 + 72) = v179 + 1;
                      }
                      v60 = 0;
                      a4 = 0;
                      *((_DWORD *)v15 + 4) = 3;
                      *((_BYTE *)v15 + 107) = 1;
                      v27 = (uint64_t *)v225;
                      goto LABEL_297;
                    }
                    v242 = 0;
LABEL_277:
                    v60 = 0;
                    a4 = 0;
                    k = 0;
                    v42 = 0;
LABEL_278:
                    v27 = (uint64_t *)v225;
                    goto LABEL_299;
                  }
                }
              }
            }
            v60 = 0;
            a4 = 0;
            a5 = 0;
            k = 0;
            v42 = 0;
            v242 = 0;
            goto LABEL_278;
          }
          if (*(unsigned __int16 *)(v69 + 34) == v65)
          {
            nsec3_hashed_name = dnssec_obj_domain_name_get_nsec3_hashed_name((uint64_t)v66, v69);
            if (nsec3_hashed_name)
            {
              v72 = nsec3_hashed_name;
              v73 = ref_count_obj_compare(*(_QWORD *)(v69 + 16), nsec3_hashed_name, 1);
              v74 = ref_count_obj_compare(*(_QWORD *)(v69 + 80), v72, 1);
              v65 = a2;
              if (!v73 || !v74)
              {
                ++*(_DWORD *)v69;
                if ((v235 & 1) != 0)
                {
                  ++*(_DWORD *)v66;
                  ++*(_DWORD *)v69;
                  v238 = v69;
                  v225 = v66;
                }
                v76 = v235 ^ 1;
                v77 = v237;
                goto LABEL_120;
              }
              goto LABEL_91;
            }
            v75 = mDNSLogCategory_DNSSEC;
            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
            {
              v65 = a2;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
              {
LABEL_98:
                *(_DWORD *)buf = 136447234;
                *(_QWORD *)&buf[4] = "hashed_name != NULL";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = "";
                *(_WORD *)&buf[22] = 2082;
                *(_QWORD *)&buf[24] = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_ob"
                                      "js/dnssec_obj_rr_nsec3.c";
                *(_WORD *)&buf[32] = 1024;
                *(_DWORD *)v244 = 281;
                *(_WORD *)&v244[4] = 2048;
                v245[0] = 0;
                _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", buf, 0x30u);
              }
            }
            else
            {
              v75 = mDNSLogCategory_DNSSEC_redacted;
              v65 = a2;
              if (os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT))
                goto LABEL_98;
            }
          }
        }
      }
LABEL_91:
      ++v67;
      if (!--v68)
      {
        if (v240)
          ref_count_obj_release(v240);
        v76 = 0;
        v235 = 0;
        v77 = 0;
        v240 = 0;
        v78 = 0;
        v16 = 0;
        v69 = (uint64_t)v237;
        if (v237)
          goto LABEL_120;
        if (v66)
          goto LABEL_103;
        goto LABEL_104;
      }
    }
  }
  v42 = dnssec_obj_domain_name_create_with_labels(a4, 1, &v242);
  if (v242)
    goto LABEL_396;
  if (!dnssec_obj_domain_name_is_sub_domain_of(*((unsigned __int8 **)v229 + 2), *((unsigned __int8 **)v42 + 2)))
    goto LABEL_405;
  v43 = (unsigned __int8 *)*((_QWORD *)v229 + 2);
  v44 = *v43;
  if (*v43)
  {
    v45 = 0;
    v46 = *((_QWORD *)v229 + 2);
    do
    {
      ++v45;
      v47 = v46 + v44;
      v48 = *(unsigned __int8 *)(v47 + 1);
      v46 = v47 + 1;
      v44 = v48;
    }
    while (v48);
  }
  else
  {
    v45 = 0;
  }
  v125 = (_BYTE *)*((_QWORD *)v42 + 2);
  v126 = *v125;
  if (*v125)
  {
    v127 = 0;
    do
    {
      ++v127;
      v128 = &v125[v126];
      v129 = v128[1];
      v125 = v128 + 1;
      v126 = v129;
    }
    while (v129);
  }
  else
  {
    v127 = 0;
  }
  if (v45 <= v127)
  {
LABEL_405:
    v17 = 0;
    v16 = 0;
    v27 = 0;
    v240 = 0;
    goto LABEL_193;
  }
  v240 = dnssec_obj_domain_name_copy_parent_domain(v43, v45 + ~v127, &v242);
  if (v242)
  {
    v17 = 0;
    v16 = 0;
    v27 = 0;
    goto LABEL_408;
  }
  v130 = 0;
  while (1)
  {
    v131 = v27[v130];
    v132 = *(_BYTE **)(v131 + 24);
    if (*v132 == 1
      && v132[1] <= 1u
      && (dnssec_obj_rr_nsec3_asserts_name_does_not_exist(v131, (uint64_t)v240, a2) & 1) != 0)
    {
      break;
    }
    if (k == ++v130)
    {
      v16 = 0;
      goto LABEL_192;
    }
  }
  v16 = v27[v130];
  ++*(_DWORD *)v16;
  if ((_DWORD)a5 == a3)
  {
    v17 = 0;
    v27 = 0;
    v60 = 0;
    a4 = 0;
    a5 = 0;
    k = 0;
    v15[*((unsigned __int8 *)v15 + 72) + 6] = v16;
    v148 = *((unsigned __int8 *)v15 + 72);
    ++*(_DWORD *)v15[v148 + 6];
    *((_BYTE *)v15 + 72) = v148 + 1;
    *((_DWORD *)v15 + 4) = 5;
    goto LABEL_298;
  }
LABEL_192:
  v17 = 0;
  v27 = 0;
LABEL_193:
  v60 = 0;
  a4 = 0;
  a5 = 0;
  for (k = 0; ; k = 0)
  {
LABEL_298:
    v242 = 0;
LABEL_299:
    dnssec_objs_sort((uint64_t)(v15 + 6), *((unsigned __int8 *)v15 + 72));
    v82 = v242;
    if (v60)
      ref_count_obj_release(v60);
    if (a4)
      ref_count_obj_release(a4);
    v31 = v231;
    if (a5)
      ref_count_obj_release(a5);
    if (v16)
      ref_count_obj_release((_QWORD *)v16);
    if (v17)
      ref_count_obj_release((_QWORD *)v17);
    if (v240)
      ref_count_obj_release(v240);
    if (v27)
      ref_count_obj_release(v27);
    if (k)
      ref_count_obj_release((_QWORD *)k);
    if (v42)
      ref_count_obj_release(v42);
    if (v229)
      ref_count_obj_release(v229);
    v88 = a6;
    if (v82)
    {
      v211 = mDNSLogCategory_DNSSEC;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_DEBUG))
          goto LABEL_416;
        v212 = (int)a1;
        if (a1)
        {
          LODWORD(v217) = (_DWORD)a1;
          v218 = *a1;
          if (*a1)
          {
            v217 = a1;
            do
            {
              v219 = &v217[v218];
              v220 = v219[1];
              v217 = v219 + 1;
              v218 = v220;
            }
            while (v220);
          }
          v212 = (_DWORD)v217 - (_DWORD)a1 + 1;
        }
      }
      else
      {
        v211 = mDNSLogCategory_DNSSEC_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_DEBUG))
          goto LABEL_416;
        v212 = (int)a1;
        if (a1)
        {
          LODWORD(v213) = (_DWORD)a1;
          v214 = *a1;
          if (*a1)
          {
            v213 = a1;
            do
            {
              v215 = &v213[v214];
              v216 = v215[1];
              v213 = v215 + 1;
              v214 = v216;
            }
            while (v216);
          }
          v212 = (_DWORD)v213 - (_DWORD)a1 + 1;
        }
      }
      *(_DWORD *)buf = 141559299;
      *(_QWORD *)&buf[4] = 1752392040;
      *(_WORD *)&buf[12] = 1040;
      *(_DWORD *)&buf[14] = v212;
      *(_WORD *)&buf[18] = 2101;
      *(_QWORD *)&buf[20] = a1;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = a3;
      *(_WORD *)v244 = 1024;
      *(_DWORD *)&v244[2] = v234;
      LOWORD(v245[0]) = 2082;
      *(_QWORD *)((char *)v245 + 2) = "Unknown DNSSEC error.";
      _os_log_impl((void *)&_mh_execute_header, v211, OS_LOG_TYPE_DEBUG, "Failed to find out a provable denial of existence NSEC3 set - qname: %{sensitive, mask.hash, mdnsresponder:domain_name}.*P, qtype: %u, NSEC3 count: %u, error: %{public}s", buf, 0x32u);
      v81 = 0;
      v83 = v15;
      v31 = v231;
      goto LABEL_378;
    }
LABEL_320:
    if ((_DWORD)v232)
      break;
    if (!v88)
      goto LABEL_377;
LABEL_367:
    v15[3] = v88;
    ++*v88;
    v204 = v227;
    if (!(_DWORD)v227)
      goto LABEL_377;
    LODWORD(v16) = 0;
    *(_DWORD *)buf = 0;
    a4 = v226;
    v27 = (uint64_t *)v226;
    a5 = v227;
    do
    {
      v205 = *v27++;
      v16 = (v16 + dnssec_obj_rr_rrsig_covers_rr(v205, (uint64_t)v88, (int *)buf));
      --a5;
    }
    while (a5);
    if (!(_DWORD)v16)
      goto LABEL_377;
    v206 = malloc_type_calloc(8uLL, v16, 0xF1748037uLL);
    if (v206)
    {
      v207 = v206;
      do
      {
        v208 = *(_DWORD **)a4;
        if (dnssec_obj_rr_rrsig_covers_rr(*(_QWORD *)a4, (uint64_t)v88, (int *)buf))
        {
          v209 = *((unsigned __int8 *)v15 + 40);
          v207[v209] = v208;
          ++*v208;
          *((_BYTE *)v15 + 40) = v209 + 1;
        }
        a4 += 8;
        --v204;
      }
      while (v204);
      v15[4] = v207;
LABEL_377:
      v82 = 0;
      v83 = 0;
      v81 = v15;
      goto LABEL_378;
    }
LABEL_383:
    __break(1u);
LABEL_384:
    v60 = 0;
    *((_DWORD *)v15 + 4) = 3;
    *((_BYTE *)v15 + 107) = 1;
LABEL_297:
    v42 = 0;
  }
  v185 = 0;
  v242 = 0;
  memset(buf, 0, 24);
  v246 = 0;
  v247 = 0;
  v186 = v15 + 6;
  LODWORD(v187) = *((unsigned __int8 *)v15 + 72);
  a4 = (unsigned __int8 *)&v246;
  v188 = v187;
  v17 = v228;
  do
  {
    if (!v188)
      goto LABEL_331;
    v189 = 0;
    v190 = *(_QWORD *)(v228 + 8 * v185);
    do
    {
      if (*((_DWORD *)v15 + 11) != 1)
      {
        if (!dnssec_obj_rr_rrsig_covers_rr(v190, v186[v189], &v242))
          goto LABEL_329;
LABEL_328:
        ++*((_DWORD *)&v246 + v189);
        goto LABEL_329;
      }
      if (dnssec_obj_rr_rrsig_covers_rr(v190, v186[v189], &v242))
        goto LABEL_328;
LABEL_329:
      ++v189;
      v187 = *((unsigned __int8 *)v15 + 72);
    }
    while (v189 < v187);
    v188 = *((unsigned __int8 *)v15 + 72);
LABEL_331:
    ++v185;
  }
  while (v185 != v232);
  if ((_DWORD)v187)
  {
    v27 = 0;
    v16 = (size_t)&v246;
    a5 = buf;
    do
    {
      v191 = *((unsigned int *)&v246 + (_QWORD)v27);
      if ((_DWORD)v191)
      {
        v192 = malloc_type_calloc(v191, 8uLL, 0xF1748037uLL);
        if (!v192)
          goto LABEL_383;
        *(_QWORD *)&buf[8 * (_QWORD)v27] = v192;
        LODWORD(v187) = *((unsigned __int8 *)v15 + 72);
      }
      v27 = (uint64_t *)((char *)v27 + 1);
    }
    while ((unint64_t)v27 < v187);
  }
  v193 = 0;
  v194 = v15 + 13;
  LODWORD(v195) = v187;
  while (2)
  {
    if (!(_DWORD)v187)
      goto LABEL_349;
    v196 = 0;
    v197 = *(_DWORD **)(v228 + 8 * v193);
    while (2)
    {
      if (*((_DWORD *)v15 + 11) == 1)
      {
        if (!dnssec_obj_rr_rrsig_covers_rr((uint64_t)v197, v194[v196 - 7], &v242))
          goto LABEL_347;
      }
      else if (!dnssec_obj_rr_rrsig_covers_rr((uint64_t)v197, v194[v196 - 7], &v242))
      {
        goto LABEL_347;
      }
      v198 = *(_QWORD *)&buf[8 * v196];
      if (v198)
      {
        *(_QWORD *)(v198 + 8 * *((unsigned __int8 *)v194 + v196)) = v197;
        ++*v197;
        ++*((_BYTE *)v194 + v196);
      }
LABEL_347:
      ++v196;
      v195 = *((unsigned __int8 *)v15 + 72);
      if (v196 < v195)
        continue;
      break;
    }
    LODWORD(v187) = *((unsigned __int8 *)v15 + 72);
LABEL_349:
    if (++v193 != v232)
      continue;
    break;
  }
  if ((_DWORD)v195)
  {
    v199 = v195;
    v200 = v15 + 10;
    v201 = buf;
    do
    {
      *v200++ = *(_QWORD *)v201;
      *(_QWORD *)v201 = 0;
      v201 += 8;
      --v199;
    }
    while (v199);
  }
  v202 = 0;
  v242 = 0;
  do
  {
    v203 = *(void **)&buf[v202];
    if (v203)
    {
      free(v203);
      *(_QWORD *)&buf[v202] = 0;
    }
    v202 += 8;
  }
  while (v202 != 24);
  v82 = v242;
  if (v242)
    v81 = 0;
  else
    v81 = v15;
  if (v242)
    v83 = v15;
  else
    v83 = 0;
  if (v88 && !v242)
    goto LABEL_367;
LABEL_378:
  if (v31)
    *v31 = v82;
  if (v83)
    ref_count_obj_release(v83);
  return v81;
}

void *_mrcs_cf_callback_retain(int a1, void *object)
{
  os_retain(object);
  return object;
}

void _mrcs_cf_callback_release(int a1, void *object)
{
  os_release(object);
}

const char *_mrcs_cf_callback_copy_description(uint64_t a1)
{
  return _mdns_obj_copy_description_as_cfstring(a1);
}

id _unicast_assist_cache_log()
{
  if (_unicast_assist_cache_log_s_once != -1)
    dispatch_once(&_unicast_assist_cache_log_s_once, &__block_literal_global_141);
  return (id)_unicast_assist_cache_log_s_log;
}

uint64_t _unicast_assist_data_to_addr(void *a1, int *a2)
{
  id v3;
  int v4;
  id v5;
  uint64_t v6;
  id v7;
  NSObject *v8;
  int v10;
  id v11;

  v3 = a1;
  if (objc_msgSend(v3, "length") == (id)4)
  {
    v4 = 4;
LABEL_5:
    v5 = objc_retainAutorelease(v3);
    memcpy(a2 + 1, objc_msgSend(v5, "bytes"), (size_t)objc_msgSend(v5, "length"));
    v6 = 0;
    *a2 = v4;
    goto LABEL_9;
  }
  if (objc_msgSend(v3, "length") == (id)16)
  {
    v4 = 6;
    goto LABEL_5;
  }
  v7 = _unicast_assist_cache_log();
  v8 = objc_claimAutoreleasedReturnValue(v7);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    v10 = 134217984;
    v11 = objc_msgSend(v3, "length");
    _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "unicast assist _unicate_assist_data_to_addr bad addr size %lu", (uint8_t *)&v10, 0xCu);
  }

  v6 = 4294960553;
LABEL_9:

  return v6;
}

uint64_t _unicast_assist_hash_for_interface(int a1, int a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v6;
  uint64_t *v8;
  _QWORD v9[7];
  int v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  int v18;

  v15 = 0;
  v16 = &v15;
  v17 = 0x2020000000;
  v18 = 0;
  v11 = 0;
  v12 = &v11;
  v13 = 0x2020000000;
  v14 = 0;
  v3 = *(_QWORD *)mDNSStorage[0];
  if (!*(_QWORD *)mDNSStorage[0])
  {
LABEL_5:
    v6 = 4294960569;
LABEL_6:
    v18 = v6;
    goto LABEL_7;
  }
  while (!*(_QWORD *)(v3 + 3776) || *(_DWORD *)(v3 + 3720) != a1)
  {
    v3 = *(_QWORD *)(v3 + 3680);
    if (!v3)
      goto LABEL_5;
  }
  if (!strcmp((const char *)(v3 + 3606), "lo0"))
  {
    v6 = 4294960591;
    goto LABEL_6;
  }
  if (_unicast_assist_hash_for_interface_onceToken != -1)
    dispatch_once(&_unicast_assist_hash_for_interface_onceToken, &__block_literal_global_147);
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  v9[2] = ___unicast_assist_hash_for_interface_block_invoke_150;
  v9[3] = &unk_10013D0C0;
  v10 = a2;
  v9[4] = &v15;
  v9[5] = &v11;
  v9[6] = v3;
  _unicast_assist_nwi_locked(v9);
  v8 = v16;
  v6 = *((unsigned int *)v16 + 6);
  if (a3 && !(_DWORD)v6)
  {
    *a3 = *((_DWORD *)v12 + 6);
    v6 = *((unsigned int *)v8 + 6);
  }
LABEL_7:
  _Block_object_dispose(&v11, 8);
  _Block_object_dispose(&v15, 8);
  return v6;
}

void sub_1000C302C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 64), 8);
  _Unwind_Resume(a1);
}

void unicast_assist_addr_add(_BYTE *a1, int a2, int a3, int a4, int *a5, uint64_t a6)
{
  if (_os_feature_enabled_impl("mDNSResponder", "unicast_assist_cache"))
    _unicast_assist_addr_update_ex(a1, a2, a3, a4, a5, a6, 0);
}

void _unicast_assist_addr_update_ex(_BYTE *a1, int a2, int a3, int a4, int *a5, uint64_t a6, int a7)
{
  int v11;
  int v12;
  uint64_t v13;
  _QWORD *v14;
  int *v15;
  int *v16;
  int *v17;
  int *v18;
  int v19;
  _QWORD *v20;
  int *v21;
  __int128 v22;
  const char *v23;
  int *v24;
  void **v25;
  int v26;
  int v27;
  void **v28;
  void **v29;
  void **v30;
  void **v31;
  void **v32;
  void **v33;
  void **v34;
  void **i;
  id v36;
  NSObject *v37;
  int v38;
  void **v39;
  int v40;
  id v41;
  NSObject *v42;
  const char *v43;
  _BYTE *v44;
  int v45;
  uint64_t v46;
  const char *v47;
  const char *v48;
  const char *v49;
  int v53;
  int v54;
  uint8_t buf[4];
  _BYTE v56[20];
  int v57;
  __int16 v58;
  int *v59;
  __int16 v60;
  int v61;
  __int16 v62;
  int v63;
  __int16 v64;
  _BYTE *v65;
  __int16 v66;
  const char *v67;
  __int16 v68;
  int v69;
  __int16 v70;
  int v71;
  __int16 v72;
  const char *v73;

  v54 = 0;
  if (_unicast_assist_hash_for_interface(a6, *a5, &v54))
    return;
  v11 = v54;
  v12 = *a5;
  v13 = s_interface_head_0;
  if (s_interface_head_0)
  {
    while (*(_QWORD *)(v13 + 24) != a6 || *(_DWORD *)(v13 + 32) != v54 || v12 != -1 && *(_DWORD *)(v13 + 36) != v12)
    {
      v13 = *(_QWORD *)v13;
      if (!v13)
        goto LABEL_8;
    }
    v15 = (int *)(v13 + 8);
  }
  else
  {
LABEL_8:
    v14 = malloc_type_calloc(1uLL, 0x28uLL, 0xF1748037uLL);
    if (!v14)
      goto LABEL_74;
    v14[1] = 0;
    v15 = (int *)(v14 + 1);
    v14[2] = v14 + 1;
    v14[3] = a6;
    *((_DWORD *)v14 + 8) = v11;
    *((_DWORD *)v14 + 9) = v12;
    *v14 = s_interface_head_0;
    s_interface_head_0 = (uint64_t)v14;
  }
  v16 = 0;
  v17 = v15;
  while (1)
  {
    v17 = *(int **)v17;
    if (!v17)
      break;
    v18 = v16;
    v19 = mDNSSameAddress(v17 + 4, a5);
    v16 = v17;
    if (v19)
    {
      if (*(int **)v15 == v17)
      {
        v24 = *(int **)v17;
        *(_QWORD *)v15 = *(_QWORD *)v17;
        if (!v24)
          *((_QWORD *)v15 + 1) = v15;
      }
      else
      {
        v20 = **(_QWORD ***)v18;
        *(_QWORD *)v18 = v20;
        if (!v20)
          *((_QWORD *)v15 + 1) = v18;
      }
      v23 = "updated";
      goto LABEL_21;
    }
  }
  v21 = (int *)malloc_type_calloc(1uLL, 0x28uLL, 0xF1748037uLL);
  if (!v21)
    goto LABEL_74;
  v17 = v21;
  *((_QWORD *)v21 + 1) = 0;
  v22 = *(_OWORD *)a5;
  v21[8] = a5[4];
  *((_OWORD *)v21 + 1) = v22;
  v23 = "added";
LABEL_21:
  v49 = v23;
  *(_QWORD *)v17 = 0;
  **((_QWORD **)v15 + 1) = v17;
  *((_QWORD *)v15 + 1) = v17;
  v25 = (void **)*((_QWORD *)v17 + 1);
  v26 = dword_100158E08;
  if (!v25)
    goto LABEL_48;
  v53 = a4;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v31 = (void **)*((_QWORD *)v17 + 1);
  do
  {
    v32 = (void **)*v31;
    if (v30 || *((_DWORD *)v31 + 2) != a2)
    {
      if (v27 == 18)
        v34 = v31;
      else
        v34 = 0;
      if (!v29)
      {
        v29 = v34;
        ++v27;
      }
      v33 = v25;
      if (!v30)
        goto LABEL_35;
    }
    else
    {
      *((_DWORD *)v31 + 3) = v26;
      if (v25 == v31)
      {
        v31 = 0;
        *((_QWORD *)v17 + 1) = v32;
        v33 = v32;
        v30 = v25;
        if (!v25)
          goto LABEL_35;
      }
      else
      {
        *v28 = *(void **)*v28;
        v33 = v25;
        v30 = v31;
        v31 = 0;
        if (!v30)
          goto LABEL_35;
      }
    }
    if (v29)
      goto LABEL_42;
LABEL_35:
    if (v31)
      v28 = v31;
    v25 = v33;
    v31 = v32;
  }
  while (v32);
  if (!v29)
    goto LABEL_46;
LABEL_42:
  for (i = (void **)*v29; *v29; i = (void **)*v29)
  {
    *v29 = *i;
    v36 = _unicast_assist_cache_log();
    v37 = objc_claimAutoreleasedReturnValue(v36);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
    {
      v38 = *((_DWORD *)i + 2);
      *(_DWORD *)buf = 68289282;
      *(_DWORD *)v56 = 20;
      *(_WORD *)&v56[4] = 2098;
      *(_QWORD *)&v56[6] = v17 + 4;
      *(_WORD *)&v56[14] = 1024;
      *(_DWORD *)&v56[16] = v38;
      _os_log_debug_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEBUG, "unicast assist qhash flushed (overflow) - %{public, mdnsresponder:ip_addr}.20P qhash %x", buf, 0x18u);
    }

    free(i);
  }
LABEL_46:
  a4 = v53;
  if (!v30)
  {
    v26 = dword_100158E08;
LABEL_48:
    v39 = (void **)malloc_type_calloc(1uLL, 0x18uLL, 0xF1748037uLL);
    if (v39)
    {
      v30 = v39;
      *((_DWORD *)v39 + 2) = a2;
      *((_DWORD *)v39 + 3) = v26;
      goto LABEL_50;
    }
LABEL_74:
    __break(1u);
  }
LABEL_50:
  *v30 = (void *)*((_QWORD *)v17 + 1);
  *((_QWORD *)v17 + 1) = v30;
  v40 = *((unsigned __int8 *)v30 + 16);
  *((_BYTE *)v30 + 16) = 0;
  *((_BYTE *)v30 + 17) = (a4 & 0x10) != 0;
  if (v40)
  {
    v41 = _unicast_assist_cache_log();
    v42 = objc_claimAutoreleasedReturnValue(v41);
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
    {
      if (a7)
        v43 = "refreshed";
      else
        v43 = v49;
      v44 = a1;
      if (a1)
      {
        v45 = 257;
        if (a1 == (_BYTE *)-256)
          goto LABEL_64;
LABEL_61:
        if (v44 < a1 + 256 && v44)
        {
          while (1)
          {
            v46 = *v44;
            if (v46 > 0x3F)
            {
LABEL_69:
              v45 = 257;
              goto LABEL_71;
            }
            if (!*v44)
              break;
            v44 += v46 + 1;
            if (a1 != (_BYTE *)-256)
              goto LABEL_61;
LABEL_64:
            if (!v44)
              goto LABEL_69;
          }
          v45 = (unsigned __int16)((_WORD)v44 - (_WORD)a1 + 1);
        }
      }
      else
      {
        v45 = 0;
      }
LABEL_71:
      v47 = DNSTypeName(a3);
      *(_DWORD *)buf = 136317698;
      v48 = "*";
      *(_QWORD *)v56 = v43;
      *(_QWORD *)&v56[10] = " (pending)";
      *(_WORD *)&v56[18] = 1042;
      *(_WORD *)&v56[8] = 2080;
      if ((a4 & 0x10) == 0)
        v48 = "";
      v57 = 20;
      v58 = 2098;
      v59 = a5;
      v60 = 1024;
      v61 = a6;
      v62 = 1040;
      v63 = v45;
      v64 = 2098;
      v65 = a1;
      v66 = 2082;
      v67 = v47;
      v68 = 1024;
      v69 = a2;
      v70 = 1024;
      v71 = a4;
      v72 = 2080;
      v73 = v48;
      _os_log_debug_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEBUG, "unicast assist record %s%s - %{public, mdnsresponder:ip_addr}.20P %2.2d %{public, mdnsresponder:domain_name}.*P %{public}s qhash %x rectype 0x%X%s", buf, 0x5Cu);
    }

  }
}

uint64_t ___unicast_assist_hash_for_interface_block_invoke_150(uint64_t a1)
{
  uint64_t result;
  int v3;
  uint64_t v4;

  result = nwi_state_get_ifstate(g_nwi_state_4467, *(_QWORD *)(a1 + 48) + 3606);
  if (result && (result = nwi_ifstate_get_signature()) != 0)
  {
    v3 = -2128831035;
    v4 = a1 + 40;
  }
  else
  {
    v4 = a1 + 32;
    v3 = -6727;
  }
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v4 + 8) + 24) = v3;
  return result;
}

void _unicast_assist_nwi_locked(void *a1)
{
  void (**v1)(_QWORD);

  v1 = a1;
  os_unfair_lock_lock((os_unfair_lock_t)&_unicast_assist_nwi_locked_s_lock);
  v1[2](v1);

  os_unfair_lock_unlock((os_unfair_lock_t)&_unicast_assist_nwi_locked_s_lock);
}

void ___unicast_assist_hash_for_interface_block_invoke(id a1)
{
  const char *notify_key;
  uint32_t v2;
  uint32_t v3;
  id v4;
  NSObject *v5;
  _DWORD v6[2];

  notify_key = (const char *)nwi_state_get_notify_key(a1);
  if (_unicast_assist_internal_queue_s_once != -1)
    dispatch_once(&_unicast_assist_internal_queue_s_once, &__block_literal_global_151);
  v2 = notify_register_dispatch(notify_key, &_unicast_assist_hash_for_interface_s_nwi_notify_token, (dispatch_queue_t)_unicast_assist_internal_queue_s_queue, &__block_literal_global_149);
  if (_unicast_assist_hash_for_interface_s_nwi_notify_token == -1)
  {
    v3 = v2;
    v4 = _unicast_assist_cache_log();
    v5 = objc_claimAutoreleasedReturnValue(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v6[0] = 67109120;
      v6[1] = v3;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to register for NWI state notifications (status %u)", (uint8_t *)v6, 8u);
    }

  }
  else
  {
    _unicast_assist_nwi_state_update();
  }
}

void _unicast_assist_nwi_state_update()
{
  uint64_t v0;
  id v1;
  NSObject *v2;
  _QWORD v3[6];
  uint8_t buf[8];
  uint8_t *v5;
  uint64_t v6;
  uint64_t v7;

  v0 = nwi_state_copy();
  if (!v0)
  {
    v1 = _unicast_assist_cache_log();
    v2 = objc_claimAutoreleasedReturnValue(v1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "Failed to copy NWI state", buf, 2u);
    }

  }
  *(_QWORD *)buf = 0;
  v5 = buf;
  v6 = 0x2020000000;
  v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = ___unicast_assist_nwi_state_update_block_invoke;
  v3[3] = &unk_10013D108;
  v3[4] = buf;
  v3[5] = v0;
  _unicast_assist_nwi_locked(v3);
  if (*((_QWORD *)v5 + 3))
  {
    nwi_state_release();
    *((_QWORD *)v5 + 3) = 0;
  }
  _Block_object_dispose(buf, 8);
}

void sub_1000C38F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___unicast_assist_nwi_state_update_block_invoke(uint64_t result)
{
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = g_nwi_state_4467;
  g_nwi_state_4467 = *(_QWORD *)(result + 40);
  return result;
}

void ___unicast_assist_internal_queue_block_invoke(id a1)
{
  dispatch_queue_t v1;
  void *v2;

  v1 = dispatch_queue_create("com.apple.mDNSResponder.unicast-assist.interface-monitor", 0);
  v2 = (void *)_unicast_assist_internal_queue_s_queue;
  _unicast_assist_internal_queue_s_queue = (uint64_t)v1;

}

void ___unicast_assist_cache_log_block_invoke(id a1)
{
  os_log_t v1;
  void *v2;

  v1 = os_log_create("com.apple.mDNSResponder", "ua_cache");
  v2 = (void *)_unicast_assist_cache_log_s_log;
  _unicast_assist_cache_log_s_log = (uint64_t)v1;

}

void __unicast_assist_init_block_invoke(id a1)
{
  NSObject *v1;
  _QWORD block[4];
  NSObject *v3;

  if (_os_feature_enabled_impl("mDNSResponder", "unicast_assist_cache")
    && objc_opt_class(SKPresence)
    && _os_feature_enabled_impl("mDNSResponder", "presence"))
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = __unicast_assist_init_block_invoke_2;
    block[3] = &unk_10013D018;
    v1 = dispatch_queue_create("com.apple.mDNSResponder.unicast_assist.statuskit", 0);
    v3 = v1;
    dispatch_async(v1, block);
    if (v1)

  }
}

void __unicast_assist_init_block_invoke_2(uint64_t a1)
{
  UAPresenceManager *v1;
  void *v2;

  v1 = -[UAPresenceManager initWithQueue:]([UAPresenceManager alloc], "initWithQueue:", *(_QWORD *)(a1 + 32));
  v2 = (void *)s_presense;
  s_presense = (uint64_t)v1;

}

void unicast_assist_addr_enumerate(int a1, uint64_t a2, void *a3)
{
  id v5;
  uint64_t i;
  uint64_t j;
  int v8;

  v5 = a3;
  if (_os_feature_enabled_impl("mDNSResponder", "unicast_assist_cache"))
  {
    v8 = 0;
    if (a2)
    {
      for (i = 0; ; ++i)
      {
        if (_unicast_assist_hash_for_interface(a2, dword_1000FF780[i], &v8))
        {
          if (i)
            goto LABEL_14;
        }
        else if (_unicast_assist_addr_enumerate_interface_hash(a1, a2, v8, v5) | i)
        {
          goto LABEL_14;
        }
      }
    }
    for (j = s_interface_head_0; j; j = *(_QWORD *)j)
    {
      if (!_unicast_assist_hash_for_interface(*(_QWORD *)(j + 24), *(_DWORD *)(j + 36), &v8)
        && v8 == *(_DWORD *)(j + 32)
        && _unicast_assist_addr_enumerate_interface_hash(a1, *(_QWORD *)(j + 24), v8, v5))
      {
        break;
      }
    }
  }
LABEL_14:

}

uint64_t _unicast_assist_addr_enumerate_interface_hash(int a1, uint64_t a2, int a3, void *a4)
{
  id v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v11;
  int v12;
  uint64_t *v13;
  id v14;
  NSObject *v15;
  _DWORD v16[2];

  v7 = a4;
  v8 = s_interface_head_0;
  if (!s_interface_head_0)
    goto LABEL_5;
  while (*(_QWORD *)(v8 + 24) != a2 || *(_DWORD *)(v8 + 32) != a3)
  {
    v8 = *(_QWORD *)v8;
    if (!v8)
      goto LABEL_5;
  }
  v11 = *(_QWORD **)(v8 + 8);
  if (v11)
  {
    v12 = 0;
    while (1)
    {
      v13 = (uint64_t *)v11[1];
      if (v13)
        break;
LABEL_14:
      v9 = 0;
      v11 = (_QWORD *)*v11;
      if (!v11)
        goto LABEL_6;
    }
    while (1)
    {
      if (*((_DWORD *)v13 + 2) == a1)
      {
        if ((*((unsigned int (**)(id, _QWORD *, uint64_t, _QWORD))v7 + 2))(v7, v11 + 2, a2, *((unsigned __int8 *)v13 + 17)))
        {
          *((_DWORD *)v13 + 3) = dword_100158E08;
          *((_BYTE *)v13 + 16) = 1;
          if (++v12 >= 20)
            break;
        }
      }
      v13 = (uint64_t *)*v13;
      if (!v13)
        goto LABEL_14;
    }
    v14 = _unicast_assist_cache_log();
    v15 = objc_claimAutoreleasedReturnValue(v14);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      v16[0] = 67109120;
      v16[1] = a1;
      _os_log_debug_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "unicast assist max limit reached - %x", (uint8_t *)v16, 8u);
    }

    v9 = 4294960545;
  }
  else
  {
LABEL_5:
    v9 = 0;
  }
LABEL_6:

  return v9;
}

void _unicast_assist_cache_free_addr(_QWORD *a1)
{
  _QWORD *i;

  for (i = (_QWORD *)a1[1]; i; i = (_QWORD *)a1[1])
  {
    a1[1] = *i;
    free(i);
  }
  free(a1);
}

void _unicast_assist_cache_free_interface(uint64_t **a1)
{
  uint64_t *v2;
  uint64_t **v3;
  uint64_t v4;

  v3 = a1 + 1;
  v2 = a1[1];
  if (v2)
  {
    do
    {
      v4 = *v2;
      *v3 = (uint64_t *)*v2;
      if (!v4)
        a1[2] = (uint64_t *)v3;
      _unicast_assist_cache_free_addr(v2);
      v2 = *v3;
    }
    while (*v3);
  }
  free(a1);
}

_BYTE *unicast_assist_auth_add(_BYTE *result, uint64_t a2, uint64_t a3)
{
  _BYTE *v5;
  id v6;
  NSObject *v7;
  int v8;
  _BYTE *v9;
  uint64_t v10;
  _DWORD v11[2];
  __int16 v12;
  _BYTE *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;

  if (s_presense)
  {
    v5 = result;
    v6 = _unicast_assist_cache_log();
    v7 = objc_claimAutoreleasedReturnValue(v6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      if (v5)
      {
        v9 = v5;
        if (v5 == (_BYTE *)-256)
          goto LABEL_11;
LABEL_8:
        v8 = 257;
        if (v9 < v5 + 256 && v9)
        {
          while (1)
          {
            v10 = *v9;
            if (v10 > 0x3F)
            {
LABEL_16:
              v8 = 257;
              goto LABEL_18;
            }
            if (!*v9)
              break;
            v9 += v10 + 1;
            if (v5 != (_BYTE *)-256)
              goto LABEL_8;
LABEL_11:
            if (!v9)
              goto LABEL_16;
          }
          v8 = (unsigned __int16)((_WORD)v9 - (_WORD)v5 + 1);
        }
      }
      else
      {
        v8 = 0;
      }
LABEL_18:
      v11[0] = 68158466;
      v11[1] = v8;
      v12 = 2098;
      v13 = v5;
      v14 = 1024;
      v15 = a2;
      v16 = 1024;
      v17 = a3;
      _os_log_debug_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "unicast assist auth_add %{public, mdnsresponder:domain_name}.*P qhash %x ifid %2.2d", (uint8_t *)v11, 0x1Eu);
    }

    return objc_msgSend((id)s_presense, "addQhash:forInterface:", a2, a3);
  }
  return result;
}

void *_mdns_resolver_copy_description(uint64_t a1, int a2, char a3)
{
  _QWORD *v6;
  _QWORD *v7;
  int appended;
  int v9;
  void *v10;
  NSObject *v12;
  const char *name;
  const char *v14;
  uint32_t index;
  int v16;
  int v17;
  const __CFArray *v18;
  int v19;
  _QWORD v20[7];
  char v21;
  _QWORD v22[4];
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  int v26;

  v23 = 0;
  v24 = &v23;
  v25 = 0x2000000000;
  v26 = 0;
  v22[0] = 0;
  v22[1] = v22;
  v22[2] = 0x2000000000;
  v22[3] = 0;
  v6 = (_QWORD *)mdns_string_builder_create();
  if (v6)
  {
    v7 = v6;
    if (a2)
    {
      appended = mdns_string_builder_append_formatted(v6, "<%s: %p>: ", *(const char **)(*(_QWORD *)(a1 + 16) + 8), (const void *)a1);
      *((_DWORD *)v24 + 6) = appended;
      if (appended)
        goto LABEL_5;
    }
    v9 = mdns_string_builder_append_formatted(v7, "%s", *(const char **)(*(_QWORD *)(a1 + 16) + 48));
    *((_DWORD *)v24 + 6) = v9;
    if (v9)
      goto LABEL_5;
    v12 = *(NSObject **)(a1 + 48);
    if (v12)
    {
      name = nw_interface_get_name(v12);
      v14 = name ? name : "???";
      index = nw_interface_get_index(*(nw_interface_t *)(a1 + 48));
      v16 = mdns_string_builder_append_formatted(v7, " using interface %s (%u)", v14, index);
      *((_DWORD *)v24 + 6) = v16;
      if (v16)
        goto LABEL_5;
    }
    v17 = mdns_string_builder_append_formatted(v7, " with servers [");
    *((_DWORD *)v24 + 6) = v17;
    if (v17)
      goto LABEL_5;
    v18 = *(const __CFArray **)(a1 + 56);
    v20[0] = _NSConcreteStackBlock;
    v20[1] = 0x40000000;
    v20[2] = ___mdns_resolver_copy_description_block_invoke;
    v20[3] = &unk_10013D760;
    v20[4] = &v23;
    v20[5] = v22;
    v20[6] = v7;
    v21 = a3;
    mdns_cfarray_enumerate(v18, (uint64_t)v20);
    if (*((_DWORD *)v24 + 6)
      || (v19 = mdns_string_builder_append_formatted(v7, "]"), (*((_DWORD *)v24 + 6) = v19) != 0))
    {
LABEL_5:
      v10 = 0;
    }
    else
    {
      v10 = mdns_string_builder_copy_string((uint64_t)v7);
    }
    os_release(v7);
  }
  else
  {
    v10 = 0;
  }
  _Block_object_dispose(v22, 8);
  _Block_object_dispose(&v23, 8);
  return v10;
}

void _mdns_resolver_finalize(_QWORD *a1)
{
  void *v2;
  void *v3;
  const void *v4;
  NSObject *v5;
  const void *v6;

  v2 = (void *)a1[6];
  if (v2)
  {
    nw_release(v2);
    a1[6] = 0;
  }
  v3 = (void *)a1[8];
  if (v3)
  {
    free(v3);
    a1[8] = 0;
  }
  v4 = (const void *)a1[7];
  if (v4)
  {
    CFRelease(v4);
    a1[7] = 0;
  }
  v5 = a1[9];
  if (v5)
  {
    dispatch_release(v5);
    a1[9] = 0;
  }
  v6 = (const void *)a1[10];
  if (v6)
  {
    _Block_release(v6);
    a1[10] = 0;
  }
}

BOOL ___mdns_resolver_copy_description_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = mdns_string_builder_append_description_with_prefix(*(_QWORD **)(a1 + 48), *(const char **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8)+ 24), a2, *(_BYTE *)(a1 + 56));
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = ", ";
  return *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) == 0;
}

void *_mdns_server_copy_description(uint64_t a1, int a2, int a3)
{
  _QWORD *v6;
  _QWORD *v7;
  const sockaddr *address;
  char v9;
  void *v10;
  const char *hostname;
  const char *v12;
  int v13;
  int port;
  _OWORD v16[4];

  v6 = (_QWORD *)mdns_string_builder_create();
  if (v6)
  {
    v7 = v6;
    if (!a2
      || !mdns_string_builder_append_formatted(v6, "<%s: %p>: ", *(const char **)(*(_QWORD *)(a1 + 16) + 8), (const void *)a1))
    {
      if (nw_endpoint_get_type(*(nw_endpoint_t *)(a1 + 48)) == nw_endpoint_type_address)
      {
        address = nw_endpoint_get_address(*(nw_endpoint_t *)(a1 + 48));
        if (*(_BYTE *)(a1 + 111))
          v9 = a3 | 2;
        else
          v9 = a3;
        if (!mdns_string_builder_append_sockaddr_description(v7, (uint64_t)address, v9))
        {
LABEL_18:
          v10 = mdns_string_builder_copy_string((uint64_t)v7);
          goto LABEL_19;
        }
      }
      else
      {
        memset(v16, 0, sizeof(v16));
        hostname = nw_endpoint_get_hostname(*(nw_endpoint_t *)(a1 + 48));
        v12 = "«MISSING HOSTNAME»";
        if (hostname)
        {
          v12 = hostname;
          if (a3)
          {
            v13 = DNSMessagePrintObfuscatedString((uint64_t)v16, hostname);
            v12 = "«REDACTED HOSTNAME»";
            if (v13 >= 0)
              v12 = (const char *)v16;
          }
        }
        if (!mdns_string_builder_append_formatted(v7, "%s", v12))
        {
          if (*(_BYTE *)(a1 + 111))
            goto LABEL_18;
          port = nw_endpoint_get_port(*(nw_endpoint_t *)(a1 + 48));
          if (!mdns_string_builder_append_formatted(v7, ":%u", port))
            goto LABEL_18;
        }
      }
    }
    v10 = 0;
LABEL_19:
    os_release(v7);
    return v10;
  }
  return 0;
}

void _mdns_server_finalize(_QWORD *a1)
{
  void *v2;
  void *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;

  v2 = (void *)a1[6];
  if (v2)
  {
    nw_release(v2);
    a1[6] = 0;
  }
  v3 = (void *)a1[7];
  if (v3)
  {
    nw_release(v3);
    a1[7] = 0;
  }
  v4 = (_QWORD *)a1[8];
  if (v4)
  {
    v5 = (_QWORD *)*v4;
    if (*v4)
    {
      do
      {
        v6 = (_QWORD *)*v5;
        _pqw_qname_item_free(v5);
        v5 = v6;
      }
      while (v6);
    }
    free(v4);
    a1[8] = 0;
  }
}

void _pqw_qname_item_free(_QWORD *a1)
{
  void *v2;

  v2 = (void *)a1[1];
  if (v2)
    free(v2);
  free(a1);
}

void *_mdns_session_copy_description(_QWORD *a1, int a2)
{
  _QWORD *v4;
  void *v5;
  void *v6;

  v4 = (_QWORD *)mdns_string_builder_create();
  if (!v4)
    return 0;
  v5 = v4;
  if (a2 && mdns_string_builder_append_formatted(v4, "<%s: %p>: ", *(const char **)(a1[2] + 8), a1))
    v6 = 0;
  else
    v6 = mdns_string_builder_copy_string((uint64_t)v5);
  os_release(v5);
  return v6;
}

void _mdns_session_finalize(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 32);
  if (v2)
  {
    os_release(v2);
    *(_QWORD *)(a1 + 32) = 0;
  }
  *(_QWORD *)(a1 + 48) = 0;
}

void _mdns_https_resolver_finalize(_QWORD *a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  const void *v8;

  v2 = (void *)a1[18];
  if (v2)
  {
    free(v2);
    a1[18] = 0;
  }
  v3 = (void *)a1[19];
  if (v3)
  {
    free(v3);
    a1[19] = 0;
  }
  v4 = (void *)a1[20];
  if (v4)
  {
    free(v4);
    a1[20] = 0;
  }
  v5 = (void *)a1[21];
  if (v5)
  {
    xpc_release(v5);
    a1[21] = 0;
  }
  v6 = (void *)a1[22];
  if (v6)
  {
    nw_release(v6);
    a1[22] = 0;
  }
  v7 = (void *)a1[23];
  if (v7)
  {
    nw_release(v7);
    a1[23] = 0;
  }
  v8 = (const void *)a1[24];
  if (v8)
  {
    CFRelease(v8);
    a1[24] = 0;
  }
}

uint64_t _mdns_https_resolver_set_provider_name(uint64_t a1, char *a2)
{
  mdns_replace_string((void **)(a1 + 144), a2);
  return 0;
}

uint64_t _mdns_https_resolver_set_connection_hostname(uint64_t a1, char *a2)
{
  mdns_replace_string((void **)(a1 + 152), a2);
  return 0;
}

uint64_t _mdns_https_resolver_set_port(uint64_t result, __int16 a2)
{
  *(_WORD *)(result + 228) = a2;
  return result;
}

uint64_t _mdns_https_resolver_set_url_path(uint64_t a1, char *a2)
{
  mdns_replace_string((void **)(a1 + 160), a2);
  return 0;
}

uint64_t _mdns_https_resolver_set_identity(uint64_t a1, UInt8 *bytes, CFIndex length)
{
  CFTypeRef v4;
  uint64_t result;
  const void *v6;
  unsigned int v7;

  v7 = 0;
  if (bytes)
  {
    v4 = _mdns_copy_sec_identity(bytes, length, (int *)&v7);
    result = v7;
    if (v7)
      return result;
  }
  else
  {
    v4 = 0;
  }
  v6 = *(const void **)(a1 + 192);
  if (v6)
    CFRelease(v6);
  result = 0;
  *(_QWORD *)(a1 + 192) = v4;
  return result;
}

uint64_t _mdns_https_resolver_update_odoh_config_async(void *a1, char *__s1, char *a3, const void *a4, size_t a5, void *a6)
{
  xpc_object_t v6;
  char *v10;
  char *v12;
  _QWORD block[9];

  v10 = a3;
  if (__s1)
  {
    v12 = strdup(__s1);
    if (!v12)
      goto LABEL_14;
    if (!v10)
      goto LABEL_7;
LABEL_6:
    v10 = strdup(v10);
    if (v10)
      goto LABEL_7;
LABEL_14:
    __break(1u);
LABEL_15:
    dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
LABEL_13:
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    block[2] = ___mdns_https_resolver_update_odoh_config_async_block_invoke;
    block[3] = &__block_descriptor_tmp_39_4594;
    block[4] = v12;
    block[5] = a1;
    block[6] = v10;
    block[7] = v6;
    block[8] = a6;
    dispatch_async((dispatch_queue_t)_mdns_resolver_queue_s_queue, block);
    return 0;
  }
  v12 = 0;
  if (a3)
    goto LABEL_6;
LABEL_7:
  v6 = 0;
  if (!a4 || !a5 || (v6 = xpc_data_create(a4, a5)) != 0)
  {
    if (a6)
      nw_retain(a6);
    os_retain(a1);
    if (_mdns_resolver_queue_s_once == -1)
      goto LABEL_13;
    goto LABEL_15;
  }
  if (v12)
    free(v12);
  if (v10)
    free(v10);
  return 4294960567;
}

nw_parameters_t _mdns_https_resolver_get_stream_params(_QWORD *a1, int *a2)
{
  nw_parameters_t v3;
  int v4;
  nw_parameters_t tcp;
  int v8;
  const char *v9;
  NSObject *v10;
  char *v11;
  _QWORD v12[6];
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  char v16;

  v3 = (nw_parameters_t)a1[23];
  if (!v3)
  {
    if (a1[18])
    {
      v13 = 0;
      v14 = &v13;
      v15 = 0x2000000000;
      v16 = 0;
      v12[0] = _NSConcreteStackBlock;
      v12[1] = 0x40000000;
      v12[2] = ___mdns_https_resolver_create_stream_params_block_invoke;
      v12[3] = &unk_10013D690;
      v12[4] = &v13;
      v12[5] = a1;
      tcp = _mdns_nw_parameters_create_tcp(v12);
      if (!tcp)
      {
        _Block_object_dispose(&v13, 8);
        v4 = -6729;
        goto LABEL_20;
      }
      v3 = tcp;
      v8 = *((unsigned __int8 *)v14 + 24);
      _Block_object_dispose(&v13, 8);
      if (!v8)
      {
        nw_release(v3);
        v4 = -6700;
LABEL_20:
        v3 = 0;
        goto LABEL_17;
      }
    }
    else
    {
      v3 = _mdns_nw_parameters_create_tcp(_nw_parameters_configure_protocol_default_configuration);
      if (!v3)
      {
        v4 = -6729;
        goto LABEL_17;
      }
    }
    v11 = 0;
    v9 = (const char *)a1[20];
    if (!v9)
      v9 = "";
    asprintf(&v11, "https://%s%s", (const char *)a1[18], v9);
    nw_parameters_set_url(v3, v11);
    if (v11)
      free(v11);
    v10 = a1[6];
    if (v10)
      nw_parameters_require_interface(v3, v10);
    v4 = 0;
LABEL_17:
    a1[23] = v3;
    if (!a2)
      return v3;
    goto LABEL_3;
  }
  v4 = 0;
  if (a2)
LABEL_3:
    *a2 = v4;
  return v3;
}

uint64_t _mdns_https_resolver_get_effective_connection_hostname(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 152);
  if (!result)
    return *(_QWORD *)(a1 + 144);
  return result;
}

uint64_t _mdns_https_resolver_get_custom_port(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 228);
}

uint64_t _mdns_https_resolver_get_client_address(uint64_t a1)
{
  return a1 + 200;
}

void ___mdns_https_resolver_create_stream_params_block_invoke(uint64_t a1, nw_protocol_options_t options)
{
  NSObject *v3;
  NSObject *v4;

  v3 = nw_tls_copy_sec_protocol_options(options);
  if (v3)
  {
    v4 = v3;
    sec_protocol_options_set_tls_server_name(v3, *(const char **)(*(_QWORD *)(a1 + 40) + 144));
    sec_protocol_options_set_peer_authentication_required(v4, 1);
    sec_protocol_options_add_tls_application_protocol(v4, "h2");
    sec_release(v4);
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  }
}

nw_parameters_t _mdns_nw_parameters_create_tcp(void *a1)
{
  nw_parameters_t secure_tcp;
  nw_parameters_t v2;

  secure_tcp = nw_parameters_create_secure_tcp(a1, _nw_parameters_configure_protocol_default_configuration);
  v2 = secure_tcp;
  if (secure_tcp)
  {
    nw_parameters_set_indefinite(secure_tcp, 0);
    nw_parameters_set_no_wake_from_sleep(v2, 1);
  }
  return v2;
}

void ___mdns_https_resolver_update_odoh_config_async_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  _QWORD *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;

  v2 = *(_QWORD *)(a1 + 32);
  if (v2)
  {
    v3 = *(_QWORD *)(a1 + 40);
    v4 = *(void **)(v3 + 144);
    if (v4)
    {
      free(v4);
      *(_QWORD *)(*(_QWORD *)(a1 + 40) + 144) = 0;
      v2 = *(_QWORD *)(a1 + 32);
      v3 = *(_QWORD *)(a1 + 40);
    }
    *(_QWORD *)(v3 + 144) = v2;
  }
  v5 = *(_QWORD *)(a1 + 48);
  if (v5)
  {
    v6 = *(_QWORD *)(a1 + 40);
    v7 = *(void **)(v6 + 160);
    if (v7)
    {
      free(v7);
      *(_QWORD *)(*(_QWORD *)(a1 + 40) + 160) = 0;
      v6 = *(_QWORD *)(a1 + 40);
      v5 = *(_QWORD *)(a1 + 48);
    }
    *(_QWORD *)(v6 + 160) = v5;
  }
  v8 = *(_QWORD **)(a1 + 40);
  v10 = *(void **)(a1 + 56);
  v9 = *(void **)(a1 + 64);
  v11 = (void *)v8[23];
  if (v11)
  {
    nw_release(v11);
    v8[23] = 0;
  }
  v12 = (void *)v8[21];
  if (v12 != v10)
  {
    if (v12)
      xpc_release(v12);
    v8[21] = v10;
    if (v10)
      xpc_retain(v10);
  }
  v13 = (void *)v8[22];
  if (v13 != v9)
  {
    if (v13)
      nw_release(v13);
    v8[22] = v9;
    if (v9)
      nw_retain(v9);
  }
  v14 = *(void **)(a1 + 56);
  if (v14)
    xpc_release(v14);
  v15 = *(void **)(a1 + 64);
  if (v15)
    nw_release(v15);
  os_release(*(void **)(a1 + 40));
}

void ___mdns_resolver_queue_block_invoke(id a1)
{
  _mdns_resolver_queue_s_queue = (uint64_t)dispatch_queue_create("com.apple.mdns.resolver-queue", 0);
}

CFTypeRef _mdns_copy_sec_identity(UInt8 *bytes, CFIndex length, int *a3)
{
  CFDataRef v4;
  CFDataRef v5;
  __CFDictionary *Mutable;
  __CFDictionary *v7;
  OSStatus v8;
  CFTypeID v9;
  CFTypeRef v10;
  NSObject *v11;
  int v12;
  NSObject *v14;
  NSObject *v15;
  CFStringRef v16;
  CFTypeID v17;
  CFTypeRef result;
  uint8_t buf[4];
  CFDataRef v20;
  __int16 v21;
  CFStringRef v22;

  result = 0;
  v4 = CFDataCreate(0, bytes, length);
  if (!v4)
  {
LABEL_21:
    v10 = 0;
    v12 = -6729;
    if (!a3)
      return v10;
    goto LABEL_14;
  }
  v5 = v4;
  Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    CFRelease(v5);
    goto LABEL_21;
  }
  v7 = Mutable;
  CFDictionarySetValue(Mutable, kSecReturnRef, kCFBooleanTrue);
  CFDictionarySetValue(v7, kSecValuePersistentRef, v5);
  CFDictionarySetValue(v7, kSecClass, kSecClassIdentity);
  CFDictionarySetValue(v7, kSecUseSystemKeychain, kCFBooleanTrue);
  v8 = SecItemCopyMatching(v7, &result);
  if (v8)
  {
    v12 = v8;
    if (_mdns_resolver_log_s_once != -1)
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    v15 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412546;
      v20 = v5;
      v21 = 2048;
      v22 = (CFStringRef)v12;
      _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Failed to find identity item -- reference: %@, error: %{mdns:err}ld", buf, 0x16u);
    }
    v10 = 0;
  }
  else if (result && (v9 = CFGetTypeID(result), v9 == SecIdentityGetTypeID()))
  {
    v10 = result;
    result = 0;
    if (_mdns_resolver_log_s_once != -1)
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    v11 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138412290;
      v20 = v5;
      _os_log_debug_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "Found identity with reference %@", buf, 0xCu);
    }
    v12 = 0;
  }
  else
  {
    if (_mdns_resolver_log_s_once != -1)
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    v14 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_FAULT))
    {
      if (result)
      {
        v17 = CFGetTypeID(result);
        v16 = CFCopyTypeIDDescription(v17);
      }
      else
      {
        v16 = CFSTR("none");
      }
      *(_DWORD *)buf = 138412546;
      v20 = v5;
      v21 = 2114;
      v22 = v16;
      _os_log_fault_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_FAULT, "Unexpected identity item type -- reference: %@, type: %{public}@", buf, 0x16u);
    }
    v10 = 0;
    v12 = -6756;
  }
  CFRelease(v5);
  CFRelease(v7);
  if (result)
    CFRelease(result);
  if (a3)
LABEL_14:
    *a3 = v12;
  return v10;
}

void ___mdns_resolver_log_block_invoke(id a1)
{
  _mdns_resolver_log_s_log = (uint64_t)os_log_create("com.apple.mdns", "resolver");
}

void _mdns_tls_resolver_finalize(_QWORD *a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v2 = (void *)a1[18];
  if (v2)
  {
    free(v2);
    a1[18] = 0;
  }
  v3 = (void *)a1[19];
  if (v3)
  {
    free(v3);
    a1[19] = 0;
  }
  v4 = (void *)a1[20];
  if (v4)
  {
    nw_release(v4);
    a1[20] = 0;
  }
  v5 = (void *)a1[21];
  if (v5)
  {
    sec_release(v5);
    a1[21] = 0;
  }
}

uint64_t _mdns_tls_resolver_set_provider_name(uint64_t a1, char *a2)
{
  mdns_replace_string((void **)(a1 + 144), a2);
  return 0;
}

uint64_t _mdns_tls_resolver_set_connection_hostname(uint64_t a1, char *a2)
{
  mdns_replace_string((void **)(a1 + 152), a2);
  return 0;
}

uint64_t _mdns_tls_resolver_set_port(uint64_t result, __int16 a2)
{
  *(_WORD *)(result + 176) = a2;
  return result;
}

uint64_t _mdns_tls_resolver_set_identity(uint64_t a1, UInt8 *bytes, CFIndex length)
{
  __SecIdentity *v4;
  uint64_t result;
  sec_identity_t v6;
  void *v7;
  unsigned int v8;

  v8 = 0;
  if (bytes)
  {
    v4 = (__SecIdentity *)_mdns_copy_sec_identity(bytes, length, (int *)&v8);
    result = v8;
    if (v8)
      return result;
    v6 = sec_identity_create(v4);
    if (v4)
      CFRelease(v4);
    if (!v6)
      return 4294960567;
  }
  else
  {
    v6 = 0;
  }
  v7 = *(void **)(a1 + 168);
  if (v7)
    sec_release(v7);
  result = 0;
  *(_QWORD *)(a1 + 168) = v6;
  return result;
}

nw_parameters_t _mdns_tls_resolver_get_stream_params(_QWORD *a1, int *a2)
{
  nw_parameters_t v3;
  int v4;
  nw_parameters_t tcp;
  int v8;
  NSObject *v9;
  _QWORD v10[6];
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  char v14;

  v3 = (nw_parameters_t)a1[20];
  if (!v3)
  {
    if (a1[18] || a1[21])
    {
      v11 = 0;
      v12 = &v11;
      v13 = 0x2000000000;
      v14 = 0;
      v10[0] = _NSConcreteStackBlock;
      v10[1] = 0x40000000;
      v10[2] = ___mdns_tls_resolver_create_stream_params_block_invoke;
      v10[3] = &unk_10013D5A0;
      v10[4] = &v11;
      v10[5] = a1;
      tcp = _mdns_nw_parameters_create_tcp(v10);
      if (!tcp)
      {
        _Block_object_dispose(&v11, 8);
        v4 = -6729;
LABEL_19:
        v3 = 0;
        goto LABEL_12;
      }
      v3 = tcp;
      v8 = *((unsigned __int8 *)v12 + 24);
      _Block_object_dispose(&v11, 8);
      if (!v8)
      {
        v4 = -6777;
LABEL_18:
        nw_release(v3);
        goto LABEL_19;
      }
    }
    else
    {
      v3 = _mdns_nw_parameters_create_tcp(_nw_parameters_configure_protocol_default_configuration);
      if (!v3)
      {
        v4 = -6729;
        goto LABEL_12;
      }
    }
    v9 = a1[6];
    if (v9)
      nw_parameters_require_interface(v3, v9);
    v4 = _mdns_add_dns_over_bytestream_framer(v3);
    if (!v4)
    {
LABEL_12:
      a1[20] = v3;
      if (!a2)
        return v3;
      goto LABEL_3;
    }
    goto LABEL_18;
  }
  v4 = 0;
  if (a2)
LABEL_3:
    *a2 = v4;
  return v3;
}

uint64_t _mdns_tls_resolver_get_effective_connection_hostname(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 152);
  if (!result)
    return *(_QWORD *)(a1 + 144);
  return result;
}

uint64_t _mdns_tls_resolver_get_custom_port(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 176);
}

void ___mdns_tls_resolver_create_stream_params_block_invoke(uint64_t a1, nw_protocol_options_t options)
{
  NSObject *v3;
  NSObject *v4;
  uint64_t v5;
  const char *v6;
  NSObject *v7;
  _QWORD verify_block[5];

  v3 = nw_tls_copy_sec_protocol_options(options);
  if (v3)
  {
    v4 = v3;
    v5 = *(_QWORD *)(a1 + 40);
    v6 = *(const char **)(v5 + 144);
    if (v6)
    {
      sec_protocol_options_set_tls_server_name(v3, v6);
      sec_protocol_options_set_peer_authentication_required(v4, 1);
      v5 = *(_QWORD *)(a1 + 40);
    }
    v7 = *(NSObject **)(v5 + 168);
    if (v7)
    {
      sec_protocol_options_set_local_identity(v4, v7);
      v5 = *(_QWORD *)(a1 + 40);
    }
    verify_block[0] = _NSConcreteStackBlock;
    verify_block[1] = 0x40000000;
    verify_block[2] = ___mdns_tls_resolver_create_stream_params_block_invoke_2;
    verify_block[3] = &__block_descriptor_tmp_34_4623;
    verify_block[4] = v5;
    if (_mdns_resolver_queue_s_once != -1)
      dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
    sec_protocol_options_set_verify_block(v4, verify_block, (dispatch_queue_t)_mdns_resolver_queue_s_queue);
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
    sec_release(v4);
  }
}

uint64_t _mdns_add_dns_over_bytestream_framer(NSObject *a1)
{
  nw_protocol_stack_t v1;
  NSObject *v2;
  void *v3;
  nw_protocol_options_t options;
  uint64_t v5;

  v1 = nw_parameters_copy_default_protocol_stack(a1);
  if (!v1)
    return 4294960567;
  v2 = v1;
  if (_mdns_copy_dns_over_bytestream_framer_s_once != -1)
    dispatch_once(&_mdns_copy_dns_over_bytestream_framer_s_once, &__block_literal_global_11_4609);
  if (!_mdns_copy_dns_over_bytestream_framer_s_framer_def
    || (nw_retain((void *)_mdns_copy_dns_over_bytestream_framer_s_framer_def),
        (v3 = (void *)_mdns_copy_dns_over_bytestream_framer_s_framer_def) == 0))
  {
    v5 = 4294960567;
    options = v2;
LABEL_9:
    nw_release(options);
    return v5;
  }
  options = nw_framer_create_options((nw_protocol_definition_t)_mdns_copy_dns_over_bytestream_framer_s_framer_def);
  if (options)
  {
    nw_protocol_stack_prepend_application_protocol(v2, options);
    v5 = 0;
  }
  else
  {
    v5 = 4294960567;
  }
  nw_release(v2);
  nw_release(v3);
  if (options)
    goto LABEL_9;
  return v5;
}

void ___mdns_copy_dns_over_bytestream_framer_block_invoke(id a1)
{
  _mdns_copy_dns_over_bytestream_framer_s_framer_def = (uint64_t)nw_framer_create_definition("DNS over byte-stream", 0, &__block_literal_global_24);
}

int ___mdns_create_dns_over_bytestream_framer_block_invoke(id a1, nw_framer *a2)
{
  nw_framer_set_input_handler((nw_framer_t)a2, &__block_literal_global_14_4614);
  nw_framer_set_output_handler((nw_framer_t)a2, &__block_literal_global_20_4615);
  return 1;
}

void _mdns_normal_resolver_kind_block_invoke_3(id a1, nw_framer *a2, nw_protocol_metadata *a3, unint64_t a4, BOOL a5)
{
  uint8_t output_buffer[2];

  if (a4 < 0x10000)
  {
    *(_WORD *)output_buffer = bswap32(a4) >> 16;
    nw_framer_write_output((nw_framer_t)a2, output_buffer, 2uLL);
    nw_framer_write_output_no_copy((nw_framer_t)a2, a4);
  }
  else
  {
    nw_framer_mark_failed_with_error((nw_framer_t)a2, 40);
  }
}

unint64_t _mdns_normal_resolver_kind_block_invoke(id a1, nw_framer *a2)
{
  size_t v3;
  NSObject *v4;
  uint8_t temp_buffer[2];

  do
  {
    *(_WORD *)temp_buffer = 0;
    if (!nw_framer_parse_input((nw_framer_t)a2, 2uLL, 2uLL, temp_buffer, &__block_literal_global_17_4620))
      break;
    v3 = __rev16(*(unsigned __int16 *)temp_buffer);
    v4 = nw_framer_message_create((nw_framer_t)a2);
    LODWORD(v3) = nw_framer_deliver_input_no_copy((nw_framer_t)a2, v3, v4, 1);
    nw_release(v4);
  }
  while ((_DWORD)v3);
  return 2;
}

unint64_t _mdns_normal_resolver_kind_block_invoke_2(id a1, char *a2, unint64_t a3, BOOL a4)
{
  return 2 * (a3 > 1);
}

void ___mdns_tls_resolver_create_stream_params_block_invoke_2(uint64_t a1, int a2, sec_trust_t trust, uint64_t a4)
{
  __SecTrust *v6;
  OSStatus Allowed;
  OSStatus v8;
  OSStatus v9;
  NSObject *v10;
  uint64_t v11;
  const char *v12;
  OSStatus v13;
  uint64_t v14;
  _QWORD result[5];
  uint8_t buf[4];
  uint64_t v17;
  __int16 v18;
  uint64_t v19;

  v6 = sec_trust_copy_ref(trust);
  Allowed = SecTrustSetNetworkFetchAllowed(v6, 0);
  if (Allowed)
  {
    v9 = Allowed;
    if (_mdns_resolver_log_s_once != -1)
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    v10 = _mdns_resolver_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
      goto LABEL_15;
    v11 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 144);
    *(_DWORD *)buf = 136315394;
    v17 = v11;
    v18 = 2048;
    v19 = v9;
    v12 = "Failed to disable network fetch for trust evaluation -- provider name: %s, error: %{mdns:err}ld";
LABEL_18:
    _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, v12, buf, 0x16u);
    goto LABEL_15;
  }
  if (_mdns_resolver_queue_s_once != -1)
    dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
  result[0] = _NSConcreteStackBlock;
  result[1] = 0x40000000;
  result[2] = ___mdns_tls_resolver_create_stream_params_block_invoke_30;
  result[3] = &unk_10013D558;
  result[4] = a4;
  v8 = SecTrustEvaluateAsyncWithError(v6, (dispatch_queue_t)_mdns_resolver_queue_s_queue, result);
  if (!v8)
  {
    if (!v6)
      return;
    goto LABEL_6;
  }
  v13 = v8;
  if (_mdns_resolver_log_s_once != -1)
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
  v10 = _mdns_resolver_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
  {
    v14 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 144);
    *(_DWORD *)buf = 136315394;
    v17 = v14;
    v18 = 2048;
    v19 = v13;
    v12 = "Failed to start aynchronous trust evaluation -- provider name: %s, error: %{mdns:err}ld";
    goto LABEL_18;
  }
LABEL_15:
  (*(void (**)(uint64_t, _QWORD))(a4 + 16))(a4, 0);
  if (v6)
LABEL_6:
    CFRelease(v6);
}

uint64_t ___mdns_tls_resolver_create_stream_params_block_invoke_30(uint64_t a1, uint64_t a2, char a3, uint64_t a4)
{
  NSObject *v6;
  int v8;
  uint64_t v9;

  if ((a3 & 1) == 0)
  {
    if (_mdns_resolver_log_s_once != -1)
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    v6 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
    {
      v8 = 138412290;
      v9 = a4;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Aynchronous trust evaluation failed: %@", (uint8_t *)&v8, 0xCu);
    }
  }
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

NSObject *_mdns_create_tcp_parameters(int *a1)
{
  NSObject *tcp;
  NSObject *v3;
  int v4;

  tcp = _mdns_nw_parameters_create_tcp(_nw_parameters_configure_protocol_disable);
  v3 = tcp;
  if (tcp)
  {
    v4 = _mdns_add_dns_over_bytestream_framer(tcp);
    if (v4)
    {
      nw_release(v3);
      v3 = 0;
    }
    else
    {
      nw_parameters_set_prefer_no_proxy(v3, 1);
    }
  }
  else
  {
    v4 = -6729;
  }
  if (a1)
    *a1 = v4;
  return v3;
}

void _mdns_normal_resolver_finalize(uint64_t a1)
{
  void *v2;
  void *v3;

  v2 = *(void **)(a1 + 144);
  if (v2)
  {
    nw_release(v2);
    *(_QWORD *)(a1 + 144) = 0;
  }
  v3 = *(void **)(a1 + 152);
  if (v3)
  {
    nw_release(v3);
    *(_QWORD *)(a1 + 152) = 0;
  }
}

nw_parameters_t _mdns_normal_resolver_get_datagram_params(uint64_t a1, int *a2)
{
  nw_parameters_t v3;
  int v4;
  nw_parameters_t secure_udp;

  v3 = *(nw_parameters_t *)(a1 + 144);
  if (v3)
  {
    v4 = 0;
    if (a2)
LABEL_3:
      *a2 = v4;
  }
  else
  {
    secure_udp = nw_parameters_create_secure_udp(_nw_parameters_configure_protocol_disable, _nw_parameters_configure_protocol_default_configuration);
    v3 = secure_udp;
    if (secure_udp)
    {
      nw_parameters_set_no_wake_from_sleep(secure_udp, 1);
      v4 = 0;
    }
    else
    {
      v4 = -6729;
    }
    *(_QWORD *)(a1 + 144) = v3;
    if (a2)
      goto LABEL_3;
  }
  return v3;
}

NSObject *_mdns_normal_resolver_get_stream_params(uint64_t a1, int *a2)
{
  NSObject *result;
  int v5;
  int v6;

  result = *(NSObject **)(a1 + 152);
  if (!result && (v6 = 0, result = _mdns_create_tcp_parameters(&v6), *(_QWORD *)(a1 + 152) = result, (v5 = v6) != 0))
  {
    result = 0;
    if (!a2)
      return result;
  }
  else
  {
    v5 = 0;
    if (!a2)
      return result;
  }
  *a2 = v5;
  return result;
}

uint64_t _mdns_resolver_add_server_by_endpoint(uint64_t a1, void *a2)
{
  CFIndex Count;
  int v5;
  uint64_t v6;
  uint64_t v7;
  _UNKNOWN **v8;
  void (*v9)(uint64_t);
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;

  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 56));
  if (Count > 31)
    return 4294960532;
  v5 = Count;
  v6 = _os_object_alloc(OS_mdns_server, 120);
  if (!v6)
    return 4294960568;
  v7 = v6;
  v8 = &_mdns_server_kind;
  *(_QWORD *)(v6 + 16) = &_mdns_server_kind;
  do
  {
    v9 = (void (*)(uint64_t))v8[2];
    if (v9)
      v9(v7);
    v8 = (_UNKNOWN **)*v8;
  }
  while (v8);
  *(_QWORD *)(v7 + 48) = a2;
  nw_retain(a2);
  v10 = *(_QWORD *)(a1 + 16);
  if (*(_WORD *)(v10 + 156))
  {
    v11 = *(unsigned __int16 *)(v10 + 156);
    if (nw_endpoint_get_port(*(nw_endpoint_t *)(v7 + 48)) == v11)
      *(_BYTE *)(v7 + 111) = 1;
  }
  *(_DWORD *)(v7 + 100) = v5 + 1;
  v12 = mach_continuous_time();
  if (mdns_mach_ticks_per_second_s_once != -1)
    dispatch_once(&mdns_mach_ticks_per_second_s_once, &__block_literal_global_3428);
  v13 = v12 - 3600 * mdns_mach_ticks_per_second_s_ticks_per_second;
  *(_QWORD *)(v7 + 80) = v13;
  *(_QWORD *)(v7 + 88) = v13;
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 56), (const void *)v7);
  os_release((void *)v7);
  return 0;
}

void __mdns_resolver_activate_block_invoke(uint64_t a1)
{
  uint64_t v1;
  CFIndex Count;
  CFIndex v3;
  CFIndex v4;
  _QWORD *v5;
  char *ValueAtIndex;
  uint64_t evaluator_for_endpoint;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;
  unsigned int v15;
  const char *v16;
  uint64_t (*v17)(uint64_t);
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t (*v21)(uint64_t);
  uint64_t v22;
  uint64_t host_with_numeric_port;
  void *v24;
  NSObject *v25;
  const void *v26;
  _QWORD v28[6];
  _BYTE buf[24];
  void *v30;
  uint64_t v31;
  char *v32;

  v1 = *(_QWORD *)(a1 + 32);
  if (*(_BYTE *)(v1 + 136) || *(_BYTE *)(v1 + 135))
    goto LABEL_31;
  *(_BYTE *)(v1 + 135) = 1;
  if (*(_QWORD *)(v1 + 80) && !*(_QWORD *)(v1 + 72))
  {
    if (_mdns_resolver_log_s_once != -1)
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    v25 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "API misuse: an event handler without a queue is useless!", buf, 2u);
    }
    v26 = *(const void **)(v1 + 80);
    if (v26)
    {
      _Block_release(v26);
      *(_QWORD *)(v1 + 80) = 0;
    }
  }
  if (!*(_DWORD *)(v1 + 124))
    *(_DWORD *)(v1 + 124) = 1000;
  if (CFArrayGetCount(*(CFArrayRef *)(v1 + 56)) <= 0)
  {
    v17 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(v1 + 16) + 120);
    if (v17)
    {
      v18 = v17(v1);
      if (v18)
      {
        v19 = v18;
        v20 = *(_QWORD *)(v1 + 16);
        v21 = *(uint64_t (**)(uint64_t))(v20 + 128);
        if (v21)
        {
          v22 = v21(v1);
          if ((_DWORD)v22)
            goto LABEL_38;
          v20 = *(_QWORD *)(v1 + 16);
        }
        v22 = *(unsigned __int16 *)(v20 + 156);
LABEL_38:
        host_with_numeric_port = nw_endpoint_create_host_with_numeric_port(v19, v22);
        if (host_with_numeric_port)
        {
          v24 = (void *)host_with_numeric_port;
          if (*(_QWORD *)(v1 + 48))
            nw_endpoint_set_interface(host_with_numeric_port);
          _mdns_resolver_add_server_by_endpoint(v1, v24);
          nw_release(v24);
        }
      }
    }
  }
  Count = CFArrayGetCount(*(CFArrayRef *)(v1 + 56));
  if (Count >= 1)
  {
    v3 = Count;
    v4 = 0;
    v5 = (_QWORD *)(v1 + 24);
    do
    {
      ValueAtIndex = (char *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v1 + 56), v4);
      *((_QWORD *)ValueAtIndex + 3) = 0;
      *v5 = ValueAtIndex;
      if (nw_endpoint_get_type(*((nw_endpoint_t *)ValueAtIndex + 6)) == nw_endpoint_type_address)
      {
        evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint(*((_QWORD *)ValueAtIndex + 6), 0);
        *((_QWORD *)ValueAtIndex + 7) = evaluator_for_endpoint;
        if (evaluator_for_endpoint)
        {
          v8 = evaluator_for_endpoint;
          if (_mdns_resolver_queue_s_once != -1)
            dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
          nw_path_evaluator_set_queue(v8, _mdns_resolver_queue_s_queue);
          os_retain((void *)v1);
          os_retain(ValueAtIndex);
          v9 = *((_QWORD *)ValueAtIndex + 7);
          if (_mdns_resolver_queue_s_once != -1)
            dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
          *(_QWORD *)buf = _NSConcreteStackBlock;
          *(_QWORD *)&buf[8] = 0x40000000;
          *(_QWORD *)&buf[16] = ___mdns_resolver_set_up_server_path_evaluator_block_invoke;
          v30 = &__block_descriptor_tmp_61_4669;
          v31 = v1;
          v32 = ValueAtIndex;
          nw_path_evaluator_set_update_handler(v9, _mdns_resolver_queue_s_queue, buf);
          v10 = *((_QWORD *)ValueAtIndex + 7);
          v28[0] = _NSConcreteStackBlock;
          v28[1] = 0x40000000;
          v28[2] = ___mdns_resolver_set_up_server_path_evaluator_block_invoke_62;
          v28[3] = &__block_descriptor_tmp_63;
          v28[4] = v1;
          v28[5] = ValueAtIndex;
          nw_path_evaluator_set_cancel_handler(v10, v28);
          nw_path_evaluator_start(*((_QWORD *)ValueAtIndex + 7));
          v11 = nw_path_evaluator_copy_path(*((_QWORD *)ValueAtIndex + 7));
          if (v11)
          {
            v12 = v11;
            ValueAtIndex[106] = _mdns_get_server_usability_from_path(v11, (*(_DWORD *)(*(_QWORD *)(v1 + 16) + 144) - 3) < 2);
            nw_release(v12);
          }
          goto LABEL_23;
        }
        if (_mdns_resolver_log_s_once != -1)
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
        v13 = _mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138412290;
          *(_QWORD *)&buf[4] = ValueAtIndex;
          _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Failed to create path evaluator for %@", buf, 0xCu);
        }
      }
      ValueAtIndex[106] = 2;
LABEL_23:
      if (_mdns_resolver_log_s_once != -1)
        dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
      v14 = _mdns_resolver_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
      {
        v15 = ValueAtIndex[106] + 1;
        v16 = "<INVALID USABILITY>";
        if (v15 <= 5)
          v16 = off_10013DC68[v15];
        *(_DWORD *)buf = 138412546;
        *(_QWORD *)&buf[4] = ValueAtIndex;
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v16;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Server %@ usability is %{public}s", buf, 0x16u);
      }
      ++v4;
      v5 = ValueAtIndex + 24;
    }
    while (v3 != v4);
  }
  _mdns_resolver_check_for_problematic_servers(v1);
  v1 = *(_QWORD *)(a1 + 32);
LABEL_31:
  os_release((void *)v1);
}

void ___mdns_resolver_set_up_server_path_evaluator_block_invoke(uint64_t a1, NSObject *a2)
{
  char server_usability_from_path;
  uint64_t v4;
  int v5;
  unsigned int v6;
  NSObject *v7;
  uint64_t v8;
  unsigned int v9;
  const char *v10;
  NSObject *v11;
  uint64_t v12;
  int v14;
  uint64_t v15;
  __int16 v16;
  const char *v17;

  server_usability_from_path = _mdns_get_server_usability_from_path(a2, (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16) + 144) - 3) < 2);
  v4 = *(_QWORD *)(a1 + 40);
  v5 = *(char *)(v4 + 106);
  if (server_usability_from_path != *(_BYTE *)(v4 + 106))
  {
    v6 = v5 - 1;
    *(_BYTE *)(v4 + 106) = server_usability_from_path;
    if ((server_usability_from_path - 1) > 3u)
    {
      if (v6 <= 3)
      {
        if (_mdns_resolver_log_s_once != -1)
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
        v11 = _mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
        {
          v12 = *(_QWORD *)(a1 + 40);
          v14 = 138412290;
          v15 = v12;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Server %@ usability is now unusable", (uint8_t *)&v14, 0xCu);
        }
      }
    }
    else
    {
      if (_mdns_resolver_log_s_once != -1)
        dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
      v7 = _mdns_resolver_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
      {
        v8 = *(_QWORD *)(a1 + 40);
        v9 = *(char *)(v8 + 106) + 1;
        if (v9 > 5)
          v10 = "<INVALID USABILITY>";
        else
          v10 = off_10013DC68[v9];
        v14 = 138412546;
        v15 = v8;
        v16 = 2082;
        v17 = v10;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Server %@ usability is now %{public}s", (uint8_t *)&v14, 0x16u);
      }
      if (v5 == 4 || v6 >= 4)
      {
        _mdns_resolver_unpenalize_server(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), 0);
        _mdns_resolver_handle_revived_server(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), 1, 0);
      }
    }
  }
}

void ___mdns_resolver_set_up_server_path_evaluator_block_invoke_62(uint64_t a1)
{
  os_release(*(void **)(a1 + 32));
  os_release(*(void **)(a1 + 40));
}

uint64_t _mdns_get_server_usability_from_path(NSObject *a1, int a2)
{
  nw_path_status_t status;
  char v5;
  NSObject *v6;
  NSObject *v7;
  const sockaddr *address;
  int sa_family;

  status = nw_path_get_status(a1);
  v5 = 1;
  if (status != nw_path_status_satisfied && status != nw_path_status_satisfiable)
  {
    if (status == nw_path_status_unsatisfied)
    {
      if ((nw_path_is_per_app_vpn(a1) & 1) != 0)
        return 3;
      if (nw_path_get_reason(a1) == 2)
        return 4;
      if ((nw_path_has_nat64_prefixes(a1) & 1) != 0 || a2 && nw_path_has_dns(a1))
      {
        v6 = nw_path_copy_endpoint(a1);
        if (v6)
        {
          v7 = v6;
          if (nw_endpoint_get_type(v6) == nw_endpoint_type_address)
          {
            address = nw_endpoint_get_address(v7);
            if (address)
            {
              sa_family = address->sa_family;
              nw_release(v7);
              if (sa_family == 2)
                return 2;
              else
                return -1;
            }
          }
          nw_release(v7);
        }
      }
    }
    return -1;
  }
  return v5;
}

void _mdns_resolver_check_for_problematic_servers(uint64_t a1)
{
  uint64_t v2;
  dispatch_source_t v3;
  NSObject *v4;
  dispatch_time_t v5;
  NSObject *v6;
  NSObject *v7;
  _QWORD handler[5];
  uint8_t buf[16];

  if (!*(_BYTE *)(*(_QWORD *)(a1 + 16) + 158) || *(_QWORD *)(a1 + 104))
    return;
  v2 = *(_QWORD *)(a1 + 24);
  if (!v2)
  {
LABEL_8:
    if (!*(_BYTE *)(a1 + 140))
    {
      if (_mdns_resolver_queue_s_once != -1)
        dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
      v3 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, (dispatch_queue_t)_mdns_resolver_queue_s_queue);
      *(_QWORD *)(a1 + 104) = v3;
      if (!v3)
      {
        if (_mdns_resolver_log_s_once != -1)
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
        v7 = _mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to create probe timer", buf, 2u);
        }
        return;
      }
      v4 = v3;
      v5 = dispatch_time(0x8000000000000000, 7200000000000);
      dispatch_source_set_timer(v4, v5, 0x68C61714000uLL, 0x53D1AC1000uLL);
      v6 = *(NSObject **)(a1 + 104);
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 0x40000000;
      handler[2] = ___mdns_resolver_check_for_problematic_servers_block_invoke;
      handler[3] = &__block_descriptor_tmp_125_4673;
      handler[4] = a1;
      dispatch_source_set_event_handler(v6, handler);
      dispatch_activate(*(dispatch_object_t *)(a1 + 104));
      _mdns_resolver_start_probe_querier(a1);
    }
    if (!*(_BYTE *)(a1 + 139))
    {
      *(_BYTE *)(a1 + 139) = 1;
      _mdns_resolver_generate_connection_event(a1);
    }
    return;
  }
  while ((*(char *)(v2 + 106) - 1) > 3 || *(_BYTE *)(v2 + 110) || *(_DWORD *)(v2 + 96) >= 3u)
  {
    v2 = *(_QWORD *)(v2 + 24);
    if (!v2)
      goto LABEL_8;
  }
}

void ___mdns_resolver_check_for_problematic_servers_block_invoke(uint64_t a1)
{
  _mdns_resolver_start_probe_querier(*(_QWORD *)(a1 + 32));
}

void _mdns_resolver_start_probe_querier(uint64_t a1)
{
  uint64_t v2;
  uint64_t querier;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  NSObject *v12;
  uint8_t buf[16];

  v2 = *(_QWORD *)(a1 + 112);
  if (v2)
  {
    mdns_client_invalidate(v2);
    os_release(*(void **)(a1 + 112));
    *(_QWORD *)(a1 + 112) = 0;
  }
  querier = mdns_resolver_create_querier((void *)a1);
  *(_QWORD *)(a1 + 112) = querier;
  if (querier)
  {
    v10 = *(_DWORD *)(a1 + 120) + 1;
    *(_DWORD *)(a1 + 120) = v10;
    mdns_querier_set_log_label(querier, "PQ%u", v4, v5, v6, v7, v8, v9, v10);
    v11 = *(_QWORD *)(a1 + 112);
    if (_mdns_resolver_queue_s_once != -1)
      dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
    mdns_client_set_queue(v11, (dispatch_object_t)_mdns_resolver_queue_s_queue);
    mdns_querier_set_query(*(_QWORD *)(a1 + 112), "\x05apple\x03com", 2);
    mdns_client_activate(*(_QWORD *)(a1 + 112));
  }
  else
  {
    if (_mdns_resolver_log_s_once != -1)
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    v12 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Failed to create probe querier", buf, 2u);
    }
  }
}

void _mdns_resolver_generate_connection_event(uint64_t a1)
{
  xpc_object_t v2;

  v2 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_BOOL(v2, "cannot_connect", *(_BYTE *)(a1 + 139));
  _mdns_resolver_generate_event((NSObject **)a1, 2, v2);
  if (v2)
    xpc_release(v2);
}

void _mdns_resolver_generate_event(NSObject **object, int a2, void *a3)
{
  NSObject *v6;
  _QWORD block[6];
  int v8;

  if (!*((_BYTE *)object + 136))
  {
    if (object[10])
    {
      os_retain(object);
      xpc_retain(a3);
      v6 = object[9];
      block[0] = _NSConcreteStackBlock;
      block[1] = 0x40000000;
      block[2] = ___mdns_resolver_generate_event_block_invoke;
      block[3] = &__block_descriptor_tmp_108_4675;
      v8 = a2;
      block[4] = object;
      block[5] = a3;
      dispatch_async(v6, block);
    }
  }
}

void ___mdns_resolver_generate_event_block_invoke(uint64_t a1)
{
  void *v2;

  (*(void (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 80) + 16))();
  os_release(*(void **)(a1 + 32));
  v2 = *(void **)(a1 + 40);
  if (v2)
    xpc_release(v2);
}

uint64_t mdns_resolver_create_querier(void *a1)
{
  uint64_t v2;
  uint64_t v3;
  _UNKNOWN **v4;
  void (*v5)(uint64_t);
  uint64_t v6;
  uint64_t v7;

  v2 = _os_object_alloc(OS_mdns_querier, 256);
  if (!v2)
    return 0;
  v3 = v2;
  v4 = &_mdns_querier_kind;
  *(_QWORD *)(v2 + 16) = &_mdns_querier_kind;
  do
  {
    v5 = (void (*)(uint64_t))v4[2];
    if (v5)
      v5(v3);
    v4 = (_UNKNOWN **)*v4;
  }
  while (v4);
  *(_DWORD *)(v3 + 208) = 0;
  *(_QWORD *)(v3 + 64) = a1;
  os_retain(a1);
  v6 = mdns_query_message_create();
  *(_QWORD *)(v3 + 88) = v6;
  if (v6)
    v7 = v3;
  else
    v7 = 0;
  if (!v6)
    os_release((void *)v3);
  return v7;
}

void mdns_querier_set_log_label(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  char *v10;
  void *v11;
  char *v12;
  char *v13[2];

  if (!*(_BYTE *)(a1 + 49))
  {
    v13[0] = 0;
    v13[1] = &a9;
    vasprintf(v13, a2, &a9);
    if (v13[0])
    {
      v12 = 0;
      asprintf(&v12, "[%s] ", v13[0]);
      v10 = v12;
      if (v12)
      {
        v11 = *(void **)(a1 + 128);
        if (v11)
        {
          free(v11);
          v10 = v12;
        }
        *(_QWORD *)(a1 + 128) = v10;
        v12 = 0;
      }
      if (v13[0])
        free(v13[0]);
    }
  }
}

void mdns_querier_set_query(uint64_t a1, _BYTE *a2, uint64_t a3)
{
  _QWORD *v5;
  int v6;

  v6 = 0;
  v5 = mdns_domain_name_create_with_labels(a2, &v6);
  if (!v6 && !*(_BYTE *)(a1 + 49))
    (*(void (**)(uint64_t, _QWORD *, uint64_t, uint64_t))(*(_QWORD *)(a1 + 16) + 56))(a1, v5, a3, 1);
  if (v5)
    os_release(v5);
}

void *_mdns_querier_copy_description(_QWORD *a1, int a2, char a3)
{
  _QWORD *v6;
  _QWORD *v7;
  void *v9;
  int v10;
  const char *v11;

  v6 = (_QWORD *)mdns_string_builder_create();
  if (!v6)
    return 0;
  v7 = v6;
  if (a2 && mdns_string_builder_append_formatted(v6, "<%s: %p>: ", *(const char **)(a1[2] + 8), a1))
    goto LABEL_18;
  if (mdns_string_builder_append_description(v7, *(_QWORD *)(a1[11] + 56), a3))
    goto LABEL_18;
  if (DNSRecordTypeValueToString(*(unsigned __int16 *)(a1[11] + 64))
     ? mdns_string_builder_append_formatted(v7, " %s")
     : mdns_string_builder_append_formatted(v7, " TYPE%u"))
  {
    goto LABEL_18;
  }
  v10 = *(unsigned __int16 *)(a1[11] + 66);
  v11 = "ANY";
  if (v10 != 255)
    v11 = 0;
  if (v10 == 1)
    v11 = "IN";
  if (v11
     ? mdns_string_builder_append_formatted(v7, " %s")
     : mdns_string_builder_append_formatted(v7, " CLASS%u"))
  {
LABEL_18:
    v9 = 0;
  }
  else
  {
    v9 = mdns_string_builder_copy_string((uint64_t)v7);
  }
  os_release(v7);
  return v9;
}

void _mdns_querier_finalize(_QWORD *a1)
{
  void *v2;
  const void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;

  a1[9] = 0;
  v2 = (void *)a1[8];
  if (v2)
  {
    os_release(v2);
    a1[8] = 0;
  }
  v3 = (const void *)a1[10];
  if (v3)
  {
    _Block_release(v3);
    a1[10] = 0;
  }
  v4 = (void *)a1[11];
  if (v4)
  {
    os_release(v4);
    a1[11] = 0;
  }
  v5 = (void *)a1[16];
  if (v5)
  {
    free(v5);
    a1[16] = 0;
  }
  v6 = (void *)a1[17];
  if (v6)
  {
    os_release(v6);
    a1[17] = 0;
  }
  v7 = (void *)a1[20];
  if (v7)
  {
    os_release(v7);
    a1[20] = 0;
  }
  v8 = (void *)a1[24];
  if (v8)
  {
    os_release(v8);
    a1[24] = 0;
  }
  _mdns_querier_clear_delegation((uint64_t)a1);
}

uint64_t _mdns_querier_get_internal_queue()
{
  if (_mdns_resolver_queue_s_once != -1)
    dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
  return _mdns_resolver_queue_s_queue;
}

void _mdns_querier_set_query(uint64_t a1, void *a2, __int16 a3, __int16 a4)
{
  uint64_t v7;

  mdns_query_message_set_qname(*(_QWORD *)(a1 + 88), a2);
  v7 = *(_QWORD *)(a1 + 88);
  if ((*(_BYTE *)(v7 + 70) & 0x20) == 0)
  {
    *(_WORD *)(v7 + 64) = a3;
    *(_WORD *)(v7 + 66) = a4;
  }
}

void _mdns_querier_activate(_BYTE *object)
{
  unsigned int v2;
  uint32_t v3;
  uint64_t v4;
  char v5;
  uint64_t v6;
  uint64_t (*v7)(void);
  uint64_t v8;
  int v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  int message_construct;
  uint64_t v15;
  const char *v16;
  signed int v17;
  NSObject *oneshot_timer;
  NSObject *v19;
  int v20;
  NSObject *v21;
  _QWORD *v22;
  _QWORD *v23;
  uint64_t v24;
  NSObject *v25;
  int v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int128 handler;
  void (*v31)(uint64_t);
  void *v32;
  _BYTE *v33;
  uint64_t v34;

  if (!object[249])
  {
    object[249] = 1;
    if (!object[254])
    {
      os_retain(object);
      object[254] = 1;
    }
    if (*(_BYTE *)(*(_QWORD *)(*((_QWORD *)object + 8) + 16) + 160))
    {
      LOWORD(v2) = 0;
    }
    else
    {
      v3 = arc4random();
      v2 = v3 + v3 / 0xFFFF + 1;
    }
    v4 = *((_QWORD *)object + 11);
    v5 = *(_BYTE *)(v4 + 70);
    if ((v5 & 0x20) == 0)
    {
      *(_WORD *)(v4 + 68) = v2;
      *(_BYTE *)(v4 + 70) = v5 & 0xF7 | (8 * *(_BYTE *)(*(_QWORD *)(*((_QWORD *)object + 8) + 16) + 159));
      v4 = *((_QWORD *)object + 11);
      v5 = *(_BYTE *)(v4 + 70);
    }
    v6 = *((_QWORD *)object + 8);
    if ((v5 & 0x20) == 0)
    {
      *(_BYTE *)(v4 + 70) = v5 & 0xEF | (16 * ((*(_DWORD *)(*(_QWORD *)(v6 + 16) + 144) - 3) < 2));
      v6 = *((_QWORD *)object + 8);
    }
    v7 = *(uint64_t (**)(void))(*(_QWORD *)(v6 + 16) + 136);
    if (v7)
    {
      v8 = v7();
      if (v8)
      {
        v9 = *(unsigned __int8 *)(v8 + 1);
        if (v9 == 30)
        {
          v12 = *((_QWORD *)object + 11);
          if ((*(_BYTE *)(v12 + 70) & 0x20) == 0)
          {
            *(_WORD *)(v12 + 71) = 14338;
            *(_QWORD *)(v12 + 81) = 0;
            *(_QWORD *)(v12 + 73) = 0;
            v13 = *(_DWORD *)(v8 + 8);
            *(_DWORD *)(v12 + 76) = *(_DWORD *)(v8 + 11);
            *(_DWORD *)(v12 + 73) = v13;
          }
        }
        else if (v9 == 2)
        {
          v10 = *((_QWORD *)object + 11);
          if ((*(_BYTE *)(v10 + 70) & 0x20) == 0)
          {
            v11 = bswap32(*(_DWORD *)(v8 + 4));
            *(_WORD *)(v10 + 71) = 6145;
            *(_QWORD *)(v10 + 76) = 0;
            *(_QWORD *)(v10 + 81) = 0;
            *(_BYTE *)(v10 + 73) = HIBYTE(v11);
            *(_BYTE *)(v10 + 74) = BYTE2(v11);
            *(_BYTE *)(v10 + 75) = BYTE1(v11);
          }
        }
      }
    }
    message_construct = mdns_query_message_construct(*((_QWORD *)object + 11));
    if (message_construct)
    {
      _mdns_querier_conclude_with_error_async(object, message_construct);
      return;
    }
    if (object[249] == 1)
    {
      v15 = *((_QWORD *)object + 8);
      if (*(_BYTE *)(v15 + 136))
      {
        _mdns_querier_conclude_async(object);
        return;
      }
      if (*((_QWORD *)object + 16))
        v16 = (const char *)*((_QWORD *)object + 16);
      else
        v16 = "";
      v17 = *((_DWORD *)object + 59);
      if (v17)
      {
        if (v17 < 1)
        {
          if (_mdns_resolver_log_s_once != -1)
            dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
          v21 = _mdns_resolver_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
          {
            LODWORD(handler) = 136446210;
            *(_QWORD *)((char *)&handler + 4) = v16;
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_INFO, "%{public}sPending querier will start when DNS traffic is observed", (uint8_t *)&handler, 0xCu);
          }
          goto LABEL_37;
        }
        oneshot_timer = _mdns_resolver_create_oneshot_timer(v17, 0);
        *((_QWORD *)object + 19) = oneshot_timer;
        if (oneshot_timer)
        {
          *(_QWORD *)&handler = _NSConcreteStackBlock;
          *((_QWORD *)&handler + 1) = 0x40000000;
          v31 = ___mdns_resolver_handle_new_querier_block_invoke;
          v32 = &__block_descriptor_tmp_135_4698;
          v33 = object;
          v34 = v15;
          dispatch_source_set_event_handler(oneshot_timer, &handler);
          if (_mdns_resolver_log_s_once != -1)
            dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
          v19 = _mdns_resolver_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
          {
            v20 = *((_DWORD *)object + 59);
            v26 = 136446466;
            v27 = v16;
            v28 = 1024;
            v29 = v20;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_INFO, "%{public}sPending querier will start after at most %d ms or when DNS traffic is observed", (uint8_t *)&v26, 0x12u);
          }
          dispatch_activate(*((dispatch_object_t *)object + 19));
LABEL_37:
          v22 = (_QWORD *)(v15 + 40);
          do
          {
            v23 = v22;
            v24 = *v22;
            v22 = (_QWORD *)(*v22 + 56);
          }
          while (v24);
          *v23 = object;
          os_retain(object);
          return;
        }
        if (_mdns_resolver_log_s_once != -1)
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
        v25 = _mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
        {
          LODWORD(handler) = 136446210;
          *(_QWORD *)((char *)&handler + 4) = v16;
          _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "%{public}sFailed to create flexible start timer for querier, will start immediately", (uint8_t *)&handler, 0xCu);
        }
      }
      _mdns_resolver_start_querier(v15, object);
    }
  }
}

void _mdns_querier_invalidate(uint64_t a1)
{
  _mdns_querier_conclude_ex(a1, 3, 0, 0);
}

uint64_t _mdns_querier_get_name(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 88) + 56);
}

uint64_t _mdns_querier_get_type(uint64_t a1)
{
  return *(unsigned __int16 *)(*(_QWORD *)(a1 + 88) + 64);
}

uint64_t _mdns_querier_get_class(uint64_t a1)
{
  return *(unsigned __int16 *)(*(_QWORD *)(a1 + 88) + 66);
}

void _mdns_querier_conclude_ex(uint64_t a1, int a2, int a3, _QWORD *a4)
{
  NSObject *v8;
  NSObject *v9;
  NSObject *v10;
  void *v11;
  void *v12;
  void *v13;
  unsigned __int16 *v14;
  unint64_t v15;
  unsigned int v16;
  unsigned int v17;
  unint64_t v18;
  _BYTE *v19;
  _BYTE *v20;
  unsigned __int16 *v21;
  unsigned __int16 *v22;
  uint64_t v23;
  unsigned __int16 *v24;
  unsigned __int16 *v25;
  uint64_t v26;
  char v27;
  size_t v28;
  const char *v29;
  unsigned int v30;
  uint64_t v31;
  unsigned int v32;
  _UNKNOWN **v33;
  void (*v34)(uint64_t);
  uint64_t v35;
  NSObject *v36;
  const char *v37;
  const char *v38;
  const char *v39;
  const char *v40;
  NSObject *v41;
  const char *v42;
  uint64_t v43;
  const char *v44;
  unsigned __int16 v45;
  CFStringRef v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  xpc_object_t v55;
  uint64_t v56;
  unint64_t v57;
  char *v58;
  char *v59;
  NSObject *v60;
  NSObject *v61;
  _BYTE *v62;
  void *v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t v66;
  NSObject *v67;
  NSObject *v68;
  const char *v69;
  uint64_t v70;
  int v71;
  int v72;
  const char *v73;
  const char *v74;
  NSObject *v75;
  uint64_t v76;
  const char *v77;
  _QWORD block[6];
  char v79;
  size_t size;
  int v81;
  _BYTE buf[12];
  __int16 v83;
  _BYTE v84[14];
  __int16 v85;
  uint64_t v86;

  v8 = *(NSObject **)(a1 + 96);
  if (v8)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 96));
    dispatch_release(v8);
    *(_QWORD *)(a1 + 96) = 0;
  }
  v9 = *(NSObject **)(a1 + 120);
  if (v9)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 120));
    dispatch_release(v9);
    *(_QWORD *)(a1 + 120) = 0;
  }
  v10 = *(NSObject **)(a1 + 152);
  if (v10)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 152));
    dispatch_release(v10);
    *(_QWORD *)(a1 + 152) = 0;
  }
  v11 = *(void **)(a1 + 144);
  if (v11)
  {
    os_release(v11);
    *(_QWORD *)(a1 + 144) = 0;
  }
  _mdns_resolver_deregister_querier(*(_QWORD *)(a1 + 64), a1);
  if (*(_BYTE *)(a1 + 249) != 3)
  {
    *(_BYTE *)(a1 + 249) = 3;
    switch(a2)
    {
      case 1:
        if (a4)
          os_retain(a4);
        v12 = *(void **)(a1 + 136);
        if (v12)
          os_release(v12);
        *(_QWORD *)(a1 + 136) = a4;
        v13 = *(void **)(a1 + 160);
        if (v13)
        {
          os_release(v13);
          *(_QWORD *)(a1 + 160) = 0;
          a4 = *(_QWORD **)(a1 + 136);
        }
        v14 = (unsigned __int16 *)a4[4];
        v15 = a4[5];
        *(_QWORD *)buf = 0;
        if (!DNSMessageGetAnswerSection((unint64_t)v14, v15, (char **)buf))
        {
          v16 = __rev16(v14[4]) + (bswap32(v14[3]) >> 16);
          if (v16)
          {
            while (1)
            {
              LOWORD(size) = 0;
              if (_DNSMessageExtractRecordEx((unint64_t)v14, v15, *(char **)buf, 0, &size, 0, 0, 0, 0, 0, 0, 0, 0, buf)|| (unsigned __int16)size == 41)
              {
                break;
              }
              if (!--v16)
                goto LABEL_22;
            }
          }
          else
          {
LABEL_22:
            v17 = __rev16(v14[5]);
            if (v17)
            {
              v18 = 0;
              v19 = 0;
              while (1)
              {
                LOWORD(size) = 0;
                v20 = *(_BYTE **)buf;
                if (_DNSMessageExtractRecordEx((unint64_t)v14, v15, *(char **)buf, 0, &size, 0, 0, 0, 0, 0, 0, 0, 0, buf))break;
                if ((unsigned __int16)size == 41)
                {
                  if (v19 || *v20)
                    break;
                  v18 = *(_QWORD *)buf - (_QWORD)v20;
                  v19 = v20;
                }
                if (!--v17)
                {
                  if (!v19 || v18 < 0xB)
                    break;
                  v21 = (unsigned __int16 *)&v19[v18];
                  v22 = (unsigned __int16 *)(v19 + 11);
                  while (1)
                  {
                    v23 = 0;
                    if (v21 <= v22 || (unint64_t)((char *)v21 - (char *)v22) < 4)
                      goto LABEL_90;
                    v24 = v22;
                    v25 = v22 + 2;
                    v26 = __rev16(v24[1]);
                    if ((char *)v21 - (char *)v25 < v26)
                      goto LABEL_89;
                    v22 = (unsigned __int16 *)((char *)v25 + v26);
                    if (__rev16(*v24) == 15)
                    {
                      if (v26 < 2)
                        goto LABEL_89;
                      v27 = (_BYTE)v22 - ((_BYTE)v24 + 6);
                      v28 = (unsigned __int16)((_WORD)v22 - ((_WORD)v24 + 6));
                      if ((_WORD)v22 == (_WORD)v24 + 6)
                        v29 = 0;
                      else
                        v29 = (const char *)(v24 + 3);
                      v30 = v24[2];
                      v31 = _os_object_alloc(OS_mdns_extended_dns_error, 40);
                      v23 = v31;
                      if (!v31)
                        goto LABEL_90;
                      v32 = bswap32(v30) >> 16;
                      v33 = &_mdns_extended_dns_error_kind;
                      *(_QWORD *)(v31 + 16) = &_mdns_extended_dns_error_kind;
                      do
                      {
                        v34 = (void (*)(uint64_t))v33[2];
                        if (v34)
                          v34(v23);
                        v33 = (_UNKNOWN **)*v33;
                      }
                      while (v33);
                      if (v28)
                      {
                        v35 = *(_QWORD *)(v23 + 24);
                      }
                      else
                      {
                        if (_mdns_copy_empty_string_s_once != -1)
                          dispatch_once(&_mdns_copy_empty_string_s_once, &__block_literal_global_6964);
                        if (_mdns_copy_empty_string_s_empty_string)
                        {
                          xpc_retain((xpc_object_t)_mdns_copy_empty_string_s_empty_string);
                          v35 = _mdns_copy_empty_string_s_empty_string;
                        }
                        else
                        {
                          v35 = 0;
                        }
                        *(_QWORD *)(v23 + 24) = v35;
                      }
                      if (v35
                        || (v45 = strnlen(v29, v28),
                            (v46 = CFStringCreateWithBytes(kCFAllocatorDefault, (const UInt8 *)v29, v45, 0x8000100u, 0)) != 0)
                        && (CFRelease(v46),
                            v55 = mdns_xpc_string_create_with_format(v47, v48, v49, v50, v51, v52, v53, v54, v27),
                            (*(_QWORD *)(v23 + 24) = v55) != 0))
                      {
                        *(_WORD *)(v23 + 32) = v32;
                        goto LABEL_90;
                      }
                      os_release((void *)v23);
                      goto LABEL_89;
                    }
                  }
                }
              }
            }
          }
        }
LABEL_89:
        v23 = 0;
LABEL_90:
        *(_QWORD *)(a1 + 160) = v23;
        LODWORD(v56) = *(unsigned __int8 *)(*(_QWORD *)(a1 + 64) + 133);
        if (!*(_BYTE *)(*(_QWORD *)(a1 + 64) + 133))
          goto LABEL_116;
        v56 = *(_QWORD *)(a1 + 136);
        if (!v56)
          goto LABEL_116;
        v57 = *(_QWORD *)(v56 + 32);
        if (!v57)
          goto LABEL_105;
        v81 = 0;
        size = 0;
        v58 = DNSMessageCollapse(v57, *(_QWORD *)(v56 + 40), &size, (char **)&v81);
        if (!v58)
          goto LABEL_102;
        v59 = v58;
        v60 = dispatch_data_create(v58, size, 0, _dispatch_data_destructor_free);
        if (v60)
        {
          v61 = v60;
          v62 = mdns_message_create_with_dispatch_data(v60, 1);
          dispatch_release(v61);
          if (v62)
          {
            os_retain(v62);
            v63 = *(void **)(a1 + 136);
            if (v63)
              os_release(v63);
            *(_QWORD *)(a1 + 136) = v62;
            os_release(v62);
            v64 = *(_QWORD *)(a1 + 136);
            if (v64)
            {
              v65 = *(_QWORD *)(v64 + 32);
              v66 = *(_QWORD *)(v64 + 40);
            }
            else
            {
              v65 = 0;
              v66 = 0;
            }
            if (_mdns_resolver_log_s_once != -1)
              dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
            v68 = _mdns_resolver_log_s_log;
            if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
            {
              v69 = "";
              v70 = *(_QWORD *)(a1 + 136);
              if (*(_QWORD *)(a1 + 128))
                v69 = *(const char **)(a1 + 128);
              v71 = 12;
              *(_DWORD *)buf = 136446978;
              if (v66 < 0xC)
                v71 = v66;
              *(_QWORD *)&buf[4] = v69;
              v83 = 1040;
              *(_DWORD *)v84 = v71;
              *(_WORD *)&v84[4] = 2098;
              *(_QWORD *)&v84[6] = v65;
              v85 = 2112;
              v86 = v70;
              _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "%{public}sUsing squashed response -- %{public,mdns:dnshdr}.*P, %@", buf, 0x26u);
            }
            LODWORD(v56) = 1;
            goto LABEL_116;
          }
        }
        else
        {
          free(v59);
        }
        v81 = -6729;
LABEL_102:
        if (_mdns_resolver_log_s_once != -1)
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
        v67 = _mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
        {
          v77 = *(const char **)(a1 + 128);
          if (!v77)
            v77 = "";
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = v77;
          v83 = 2048;
          *(_QWORD *)v84 = v81;
          _os_log_error_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_ERROR, "%{public}sFailed to squash response -- error:%{mdns:err}ld", buf, 0x16u);
        }
LABEL_105:
        LODWORD(v56) = 0;
LABEL_116:
        if (a3 == 1)
          v72 = 1;
        else
          v72 = v56;
        *(_BYTE *)(a1 + 253) = v72;
        if (v72 == 1)
        {
          if (_mdns_resolver_log_s_once != -1)
            dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
          v36 = _mdns_resolver_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
          {
            v73 = *(const char **)(a1 + 128);
            if (!v73)
              v73 = "";
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = v73;
            v38 = "%{public}sQuerier concluded -- reason: response (fabricated)";
            goto LABEL_132;
          }
        }
        else
        {
          if (_mdns_resolver_log_s_once != -1)
            dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
          v36 = _mdns_resolver_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
          {
            v74 = *(const char **)(a1 + 128);
            if (!v74)
              v74 = "";
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = v74;
            v38 = "%{public}sQuerier concluded -- reason: response";
            goto LABEL_132;
          }
        }
LABEL_133:
        v75 = *(NSObject **)(a1 + 24);
        if (v75)
        {
          v76 = *(_QWORD *)(a1 + 80);
          *(_QWORD *)(a1 + 80) = 0;
          os_retain((void *)a1);
          block[0] = _NSConcreteStackBlock;
          block[1] = 0x40000000;
          block[2] = ___mdns_querier_conclude_ex_block_invoke;
          block[3] = &unk_10013D6F8;
          v79 = a2;
          block[4] = v76;
          block[5] = a1;
          dispatch_async(v75, block);
        }
        if (*(_BYTE *)(a1 + 254))
        {
          *(_BYTE *)(a1 + 254) = 0;
          os_release((void *)a1);
        }
        return;
      case 2:
        if (_mdns_resolver_log_s_once != -1)
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
        v36 = _mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
        {
          v37 = *(const char **)(a1 + 128);
          if (!v37)
            v37 = "";
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = v37;
          v38 = "%{public}sQuerier concluded -- reason: timeout";
          goto LABEL_132;
        }
        goto LABEL_133;
      case 3:
        if (_mdns_resolver_log_s_once != -1)
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
        v36 = _mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
        {
          v39 = *(const char **)(a1 + 128);
          if (!v39)
            v39 = "";
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = v39;
          v38 = "%{public}sQuerier concluded -- reason: invalidation";
          goto LABEL_132;
        }
        goto LABEL_133;
      case 4:
        if (_mdns_resolver_log_s_once != -1)
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
        v36 = _mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
        {
          v40 = *(const char **)(a1 + 128);
          if (!v40)
            v40 = "";
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = v40;
          v38 = "%{public}sQuerier concluded -- reason: resolver invalidation";
          goto LABEL_132;
        }
        goto LABEL_133;
      case 5:
        *(_DWORD *)(a1 + 240) = a3;
        if (_mdns_resolver_log_s_once != -1)
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
        v41 = _mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
        {
          v42 = *(const char **)(a1 + 128);
          if (!v42)
            v42 = "";
          v43 = *(int *)(a1 + 240);
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = v42;
          v83 = 2048;
          *(_QWORD *)v84 = v43;
          _os_log_error_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "%{public}sQuerier concluded -- error: %{mdns:err}ld", buf, 0x16u);
        }
        goto LABEL_133;
      case 6:
        if (_mdns_resolver_log_s_once != -1)
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
        v36 = _mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
        {
          v44 = *(const char **)(a1 + 128);
          if (!v44)
            v44 = "";
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = v44;
          v38 = "%{public}sQuerier concluded -- reason: connection problem";
LABEL_132:
          _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_INFO, v38, buf, 0xCu);
        }
        goto LABEL_133;
      default:
        goto LABEL_133;
    }
  }
}

void _mdns_resolver_deregister_querier(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  BOOL v8;
  _QWORD *v9;
  uint64_t v10;
  BOOL v11;

  v4 = *(NSObject **)(a2 + 96);
  if (v4)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a2 + 96));
    dispatch_release(v4);
    *(_QWORD *)(a2 + 96) = 0;
  }
  _mdns_forget_session_list((uint64_t *)(a2 + 104));
  _mdns_forget_session_list((uint64_t *)(a2 + 112));
  v5 = (_QWORD *)(a1 + 32);
  do
  {
    v6 = v5;
    v7 = *v5;
    v5 = (_QWORD *)(*v5 + 56);
    if (v7)
      v8 = v7 == a2;
    else
      v8 = 1;
  }
  while (!v8);
  if (v7)
    goto LABEL_17;
  v9 = (_QWORD *)(a1 + 40);
  do
  {
    v6 = v9;
    v10 = *v9;
    v9 = (_QWORD *)(*v9 + 56);
    if (v10)
      v11 = v10 == a2;
    else
      v11 = 1;
  }
  while (!v11);
  if (v10)
  {
LABEL_17:
    *v6 = *(_QWORD *)(a2 + 56);
    *(_QWORD *)(a2 + 56) = 0;
    os_release((void *)a2);
  }
}

void ___mdns_querier_conclude_ex_block_invoke(uint64_t a1)
{
  uint64_t v2;
  const void *v3;

  *(_BYTE *)(*(_QWORD *)(a1 + 40) + 248) = *(_BYTE *)(a1 + 48);
  v2 = *(_QWORD *)(a1 + 32);
  if (v2)
  {
    (*(void (**)(void))(v2 + 16))();
    v3 = *(const void **)(a1 + 32);
    if (v3)
      _Block_release(v3);
  }
  os_release(*(void **)(a1 + 40));
}

void _mdns_forget_session_list(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *a1;
  if (*a1)
  {
    *a1 = 0;
    do
    {
      v2 = *(_QWORD *)(v1 + 24);
      *(_QWORD *)(v1 + 24) = 0;
      _mdns_session_invalidate((_BYTE *)v1);
      os_release((void *)v1);
      v1 = v2;
    }
    while (v2);
  }
}

void _mdns_session_invalidate(_BYTE *a1)
{
  _QWORD block[5];

  a1[88] = 3;
  os_retain(a1);
  if (_mdns_resolver_queue_s_once != -1)
    dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = ___mdns_session_invalidate_block_invoke;
  block[3] = &__block_descriptor_tmp_45_4697;
  block[4] = a1;
  dispatch_async((dispatch_queue_t)_mdns_resolver_queue_s_queue, block);
}

void ___mdns_session_invalidate_block_invoke(uint64_t a1)
{
  uint64_t v2;
  void (*v3)(_QWORD);

  _mdns_session_invalidate_internal(*(_QWORD *)(a1 + 32));
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(void (**)(_QWORD))(*(_QWORD *)(v2 + 72) + 16);
  if (v3)
  {
    v3(*(_QWORD *)(v2 + 48));
    v2 = *(_QWORD *)(a1 + 32);
  }
  *(_QWORD *)(v2 + 48) = 0;
  os_release(*(void **)(a1 + 32));
}

void _mdns_session_invalidate_internal(uint64_t a1)
{
  NSObject *v2;
  void (*v3)(uint64_t);

  v2 = *(NSObject **)(a1 + 40);
  if (v2)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 40));
    dispatch_release(v2);
    *(_QWORD *)(a1 + 40) = 0;
  }
  v3 = *(void (**)(uint64_t))(*(_QWORD *)(a1 + 16) + 72);
  if (v3)
    v3(a1);
}

void _mdns_querier_conclude_async(void *a1)
{
  _QWORD v2[5];
  char v3;

  os_retain(a1);
  if (_mdns_resolver_queue_s_once != -1)
    dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 0x40000000;
  v2[2] = ___mdns_querier_conclude_async_block_invoke;
  v2[3] = &__block_descriptor_tmp_136_4811;
  v2[4] = a1;
  v3 = 4;
  dispatch_async((dispatch_queue_t)_mdns_resolver_queue_s_queue, v2);
}

NSObject *_mdns_resolver_create_oneshot_timer(unsigned int a1, unsigned int a2)
{
  if (_mdns_resolver_queue_s_once != -1)
    dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
  return _mdns_dispatch_create_monotonic_timer(a1, 0xFFFFFFFFFFFFFFFFLL, a2, _mdns_resolver_queue_s_queue);
}

void ___mdns_resolver_handle_new_querier_block_invoke(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  BOOL v7;
  NSObject *v8;
  const char *v9;
  int v10;
  const char *v11;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(NSObject **)(v2 + 152);
  if (v3)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(v2 + 152));
    dispatch_release(v3);
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 152) = 0;
    v2 = *(_QWORD *)(a1 + 32);
  }
  v4 = (_QWORD *)(*(_QWORD *)(a1 + 40) + 40);
  do
  {
    v5 = v4;
    v6 = *v4;
    v4 = (_QWORD *)(*v4 + 56);
    if (v6)
      v7 = v6 == v2;
    else
      v7 = 1;
  }
  while (!v7);
  if (v6)
  {
    *v5 = *(_QWORD *)(v2 + 56);
    *(_QWORD *)(v2 + 56) = 0;
    os_release((void *)v2);
    if (_mdns_resolver_log_s_once != -1)
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    v8 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
    {
      v9 = *(const char **)(*(_QWORD *)(a1 + 32) + 128);
      if (!v9)
        v9 = "";
      v10 = 136446210;
      v11 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "%{public}sStarting pending querier because leeway elapsed", (uint8_t *)&v10, 0xCu);
    }
    _mdns_resolver_start_querier(*(_QWORD *)(a1 + 40), *(_BYTE **)(a1 + 32));
  }
}

void _mdns_resolver_start_querier(uint64_t a1, _BYTE *object)
{
  unsigned int v4;
  int v5;

  if (object[249] == 1)
  {
    object[249] = 2;
    v4 = *((_DWORD *)object + 56);
    if (v4 && (v5 = _mdns_querier_reset_time_limit((uint64_t)object, v4)) != 0)
      _mdns_querier_conclude_with_error_async(object, v5);
    else
      _mdns_resolver_register_querier_ex(a1, object, 0);
  }
}

void _mdns_querier_conclude_with_error_async(void *a1, int a2)
{
  _QWORD v4[5];
  int v5;

  os_retain(a1);
  if (_mdns_resolver_queue_s_once != -1)
    dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___mdns_querier_conclude_with_error_async_block_invoke;
  v4[3] = &__block_descriptor_tmp_66_4702;
  v4[4] = a1;
  v5 = a2;
  dispatch_async((dispatch_queue_t)_mdns_resolver_queue_s_queue, v4);
}

void ___mdns_querier_conclude_with_error_async_block_invoke(uint64_t a1)
{
  _mdns_querier_conclude_ex(*(_QWORD *)(a1 + 32), 5, *(_DWORD *)(a1 + 40), 0);
  os_release(*(void **)(a1 + 32));
}

uint64_t _mdns_querier_reset_time_limit(uint64_t a1, unsigned int a2)
{
  NSObject *v4;
  const char *v5;
  NSObject *v6;
  NSObject *oneshot_timer;
  _QWORD handler[5];
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  unsigned int v13;

  if (*(_BYTE *)(a1 + 249) != 2)
    return 0;
  if (_mdns_resolver_log_s_once != -1)
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
  v4 = _mdns_resolver_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
  {
    v5 = *(const char **)(a1 + 128);
    if (!v5)
      v5 = "";
    *(_DWORD *)buf = 136446466;
    v11 = v5;
    v12 = 1024;
    v13 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "%{public}sResetting time limit to %u ms", buf, 0x12u);
  }
  v6 = *(NSObject **)(a1 + 120);
  if (v6)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 120));
    dispatch_release(v6);
    *(_QWORD *)(a1 + 120) = 0;
  }
  if (!a2)
    return 0;
  oneshot_timer = _mdns_resolver_create_oneshot_timer(a2, 5u);
  *(_QWORD *)(a1 + 120) = oneshot_timer;
  if (oneshot_timer)
  {
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 0x40000000;
    handler[2] = ___mdns_querier_reset_time_limit_block_invoke;
    handler[3] = &__block_descriptor_tmp_116_4809;
    handler[4] = a1;
    dispatch_source_set_event_handler(oneshot_timer, handler);
    dispatch_activate(*(dispatch_object_t *)(a1 + 120));
    return 0;
  }
  return 4294960567;
}

uint64_t _mdns_resolver_register_querier_ex(uint64_t a1, _WORD *object, int a3)
{
  uint64_t v5;
  BOOL v6;
  char v7;
  uint64_t v8;
  NSObject *v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  int v13;
  int v15;
  unint64_t v16;
  __int16 v17;
  unint64_t v18;

  v5 = *(_QWORD *)(a1 + 16);
  if (*(_BYTE *)(v5 + 158))
    v6 = 0;
  else
    v6 = a3 == 0;
  if (v6)
  {
    if (*(_BYTE *)(v5 + 161) && *(_BYTE *)(a1 + 134))
    {
      v8 = *(_QWORD *)(a1 + 88) - mach_continuous_time();
      if ((v8 & 0x8000000000000000) == 0)
      {
        if (_mdns_resolver_log_s_once != -1)
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
        v9 = _mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
        {
          if (mdns_mach_ticks_per_second_s_once != -1)
            dispatch_once(&mdns_mach_ticks_per_second_s_once, &__block_literal_global_3428);
          v15 = 134218240;
          v16 = v8 / mdns_mach_ticks_per_second_s_ticks_per_second;
          v17 = 2048;
          v18 = 1000
              * (v8 % mdns_mach_ticks_per_second_s_ticks_per_second)
              / mdns_mach_ticks_per_second_s_ticks_per_second;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "Suspicious mode (%lld.%03lld seconds left): forcing query over bytestream", (uint8_t *)&v15, 0x16u);
        }
        object[125] = 259;
        goto LABEL_6;
      }
      *(_BYTE *)(a1 + 134) = 0;
    }
    v7 = 0;
    *((_BYTE *)object + 251) = 0;
    *((_QWORD *)object + 27) = 0;
    *((_DWORD *)object + 53) = 0;
    goto LABEL_20;
  }
  *((_BYTE *)object + 251) = 1;
LABEL_6:
  v7 = 0;
  *((_QWORD *)object + 27) = 0;
  *((_DWORD *)object + 53) = 0;
  if (!*(_BYTE *)(a1 + 138))
    v7 = *(_BYTE *)(*(_QWORD *)(a1 + 16) + 162) ^ 1;
LABEL_20:
  *((_BYTE *)object + 252) = v7;
  v10 = (_QWORD *)(a1 + 32);
  do
  {
    v11 = v10;
    v12 = *v10;
    v10 = (_QWORD *)(*v10 + 56);
  }
  while (v12);
  *v11 = object;
  os_retain(object);
  *((_QWORD *)object + 9) = 0;
  *((_BYTE *)object + 247) = 0;
  if (*((_BYTE *)object + 251))
    v13 = 2000;
  else
    v13 = *(_DWORD *)(*((_QWORD *)object + 8) + 124);
  *((_DWORD *)object + 51) = v13;
  return _mdns_querier_initiate_send(object);
}

void _mdns_querier_initiate_send(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  void *v4;
  uint64_t eligible_server;
  uint64_t v6;
  int v7;
  int v8;
  NSObject *v9;
  const char *v10;
  NSObject *v11;
  const char *v12;
  uint64_t v13;
  size_t v14;
  NSObject *v15;
  NSObject *v16;
  NSObject *v17;
  _BYTE *v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  const char *v22;
  NSObject *oneshot_timer;
  _QWORD *v24;
  _QWORD *v25;
  NSObject *v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  NSObject *v30;
  int v31;
  NSObject *v32;
  const char *v33;
  unsigned int v34;
  void *v35;
  const char *v36;
  const char *v37;
  int v38;
  void *v39;
  NSObject *v40;
  const char *v41;
  _QWORD handler[5];
  int v43;
  _BYTE buf[24];
  void *v45;
  uint64_t v46;
  void *v47;
  char v48;

  v2 = *(NSObject **)(a1 + 96);
  if (v2)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 96));
    dispatch_release(v2);
    *(_QWORD *)(a1 + 96) = 0;
  }
  v3 = *(_QWORD *)(a1 + 72);
  v4 = &unk_100150000;
  while (1)
  {
    if (v3)
      goto LABEL_8;
    if (*(_QWORD *)(a1 + 144) && !_mdns_resolver_get_server(*(_QWORD *)(a1 + 64), *(_DWORD *)(a1 + 228)))
      break;
    eligible_server = _mdns_querier_get_eligible_server(a1);
    _mdns_querier_set_current_server(a1, eligible_server);
    v3 = *(_QWORD *)(a1 + 72);
    if (!v3)
    {
      if (_mdns_resolver_log_s_once != -1)
        dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
      v32 = *((_QWORD *)v4 + 183);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
      {
        v33 = *(const char **)(a1 + 128);
        if (!v33)
          v33 = "";
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = v33;
        _os_log_debug_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEBUG, "%{public}sNo more eligible servers", buf, 0xCu);
      }
      return;
    }
LABEL_8:
    v6 = *(_QWORD *)(a1 + 64);
    if (*(_DWORD *)(*(_QWORD *)(v6 + 16) + 144) == 1 || *(_DWORD *)(v6 + 128))
    {
      v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 16) + 88))(a1);
      if ((v7 & 0xFFFE) == 0x40)
      {
        v8 = v7;
        if (*(_BYTE *)(v3 + 112))
        {
          if (_mdns_resolver_log_s_once != -1)
            dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
          v9 = *((_QWORD *)v4 + 183);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
          {
            v10 = *(const char **)(a1 + 128);
            if (!v10)
              v10 = "";
            *(_DWORD *)buf = 136446722;
            *(_QWORD *)&buf[4] = v10;
            *(_WORD *)&buf[12] = 2112;
            *(_QWORD *)&buf[14] = v3;
            *(_WORD *)&buf[22] = 1024;
            LODWORD(v45) = v8;
            v11 = v9;
            v12 = "%{public}sNot sending query to server %@, which mixes up responses of type %{mdns:rrtype}d";
LABEL_18:
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, v12, buf, 0x1Cu);
            goto LABEL_19;
          }
          goto LABEL_19;
        }
        if (!*(_BYTE *)(v3 + 107))
        {
          v21 = *(_QWORD *)(v3 + 64);
          if (v21)
          {
            if (*(_DWORD *)(v21 + 8) >= *(_DWORD *)(v21 + 12))
            {
              if (_mdns_resolver_log_s_once != -1)
                dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
              v9 = *((_QWORD *)v4 + 183);
              if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
              {
                v22 = *(const char **)(a1 + 128);
                if (!v22)
                  v22 = "";
                *(_DWORD *)buf = 136446722;
                *(_QWORD *)&buf[4] = v22;
                *(_WORD *)&buf[12] = 2112;
                *(_QWORD *)&buf[14] = v3;
                *(_WORD *)&buf[22] = 1024;
                LODWORD(v45) = v8;
                v11 = v9;
                v12 = "%{public}sNot sending query to server %@, which ignores queries of type %{mdns:rrtype}d";
                goto LABEL_18;
              }
LABEL_19:
              if (!*(_QWORD *)(a1 + 144))
              {
                v13 = *(_QWORD *)(a1 + 88);
                v14 = *(_QWORD *)(v13 + 40);
                if (v14 < 0xD)
                {
                  v38 = -6762;
                }
                else
                {
                  v15 = malloc_type_malloc(*(_QWORD *)(v13 + 40), 0xA172743EuLL);
                  if (v15)
                  {
                    v9 = v15;
                    memcpy(v15, *(const void **)(v13 + 32), v14);
                    WORD1(v9->isa) = -31615;
                    v16 = dispatch_data_create(v9, v14, 0, _dispatch_data_destructor_free);
                    if (!v16)
                      goto LABEL_90;
                    v17 = v16;
                    v18 = mdns_message_create_with_dispatch_data(v16, 1);
                    dispatch_release(v17);
                    *(_QWORD *)(a1 + 144) = v18;
                    if (!v18)
                    {
                      v38 = -6729;
LABEL_92:
                      v39 = (void *)a1;
LABEL_93:
                      _mdns_querier_conclude_with_error_async(v39, v38);
                      return;
                    }
                    *(_WORD *)(a1 + 244) = -4;
                    v4 = &unk_100150000;
                    goto LABEL_25;
                  }
                  __break(1u);
LABEL_90:
                  free(v9);
                  v38 = -6729;
                }
                *(_QWORD *)(a1 + 144) = 0;
                goto LABEL_92;
              }
LABEL_25:
              v19 = 0;
              if ((*(_DWORD *)(v3 + 100) - 1) >= 0x20)
                v20 = 0;
              else
                v20 = 1 << (*(_BYTE *)(v3 + 100) - 1);
              *(_DWORD *)(a1 + 228) |= v20;
              *(_QWORD *)(a1 + 72) = 0;
              *(_BYTE *)(a1 + 247) = 0;
              goto LABEL_31;
            }
          }
        }
      }
    }
    v19 = *(_QWORD *)(a1 + 72);
LABEL_31:
    v3 = 0;
    if (v19)
    {
      oneshot_timer = _mdns_resolver_create_oneshot_timer(*(_DWORD *)(a1 + 204), 5u);
      *(_QWORD *)(a1 + 96) = oneshot_timer;
      if (!oneshot_timer)
      {
        v39 = (void *)a1;
        v38 = -6729;
        goto LABEL_93;
      }
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 0x40000000;
      handler[2] = ___mdns_querier_initiate_send_block_invoke;
      handler[3] = &__block_descriptor_tmp_64;
      handler[4] = a1;
      dispatch_source_set_event_handler(oneshot_timer, handler);
      dispatch_activate(*(dispatch_object_t *)(a1 + 96));
      v24 = *(_QWORD **)(a1 + 72);
      if (*(_BYTE *)(a1 + 252))
      {
        if (!v24)
          return;
        v25 = (_QWORD *)v24[4];
        if (v25)
          goto LABEL_68;
        if (_mdns_resolver_log_s_once != -1)
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
        v26 = *((_QWORD *)v4 + 183);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
        {
          v37 = *(const char **)(a1 + 128);
          if (!v37)
            v37 = "";
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = v37;
          *(_WORD *)&buf[12] = 2112;
          *(_QWORD *)&buf[14] = v24;
          _os_log_debug_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEBUG, "%{public}sCreating shared session to %@", buf, 0x16u);
        }
        v43 = 0;
        v25 = _mdns_resolver_create_session(*(_QWORD *)(a1 + 64), v24, 1, 0, 0, &v43);
        if (v25)
        {
          os_retain(*(void **)(a1 + 64));
          if (!*((_BYTE *)v25 + 88))
          {
            v25[6] = *(_QWORD *)(a1 + 64);
            v25[9] = _mdns_querier_get_shared_session_s_resolver_callbacks;
            *((_DWORD *)v25 + 20) = 10000;
          }
          _mdns_session_activate((uint64_t)v25);
          v24[4] = v25;
LABEL_68:
          if ((*(_DWORD *)(v25[4] + 100) - 1) >= 0x20)
            v31 = 0;
          else
            v31 = 1 << (*(_BYTE *)(v25[4] + 100) - 1);
          *(_DWORD *)(a1 + 212) |= v31;
          _mdns_querier_send_query(a1, (uint64_t)v25);
          return;
        }
        if (_mdns_resolver_log_s_once != -1)
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
        v40 = _mdns_resolver_log_s_log;
        if (!os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
          goto LABEL_102;
        *(_DWORD *)buf = 138412546;
        *(_QWORD *)&buf[4] = v24;
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v43;
        v41 = "Failed to create session to %@ for resolver: %{mdns:err}ld";
      }
      else
      {
        if (!v24)
          return;
        v27 = 112;
        if (*(_BYTE *)(a1 + 251))
        {
          v28 = (_QWORD *)(a1 + 112);
        }
        else
        {
          v27 = 104;
          v28 = (_QWORD *)(a1 + 104);
        }
        v29 = *(_QWORD *)(a1 + v27);
        if (v29)
        {
          while (1)
          {
            v25 = (_QWORD *)v29;
            if (*(_QWORD **)(v29 + 32) == v24)
              goto LABEL_68;
            v29 = *(_QWORD *)(v29 + 24);
            if (!v29)
            {
              v28 = v25 + 3;
              break;
            }
          }
        }
        if (_mdns_resolver_log_s_once != -1)
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
        v30 = *((_QWORD *)v4 + 183);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
        {
          v36 = *(const char **)(a1 + 128);
          if (!v36)
            v36 = "";
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = v36;
          *(_WORD *)&buf[12] = 2112;
          *(_QWORD *)&buf[14] = v24;
          _os_log_debug_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEBUG, "%{public}sCreating session to %@", buf, 0x16u);
        }
        v43 = 0;
        v25 = _mdns_resolver_create_session(*(_QWORD *)(a1 + 64), v24, *(unsigned __int8 *)(a1 + 251), a1 + 168, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 88) + 56) + 24), &v43);
        if (v25)
        {
          os_retain((void *)a1);
          if (!*((_BYTE *)v25 + 88))
          {
            v25[6] = a1;
            v25[9] = _mdns_querier_get_unshared_session_s_querier_callbacks;
            if (*(_BYTE *)(a1 + 251))
              *((_DWORD *)v25 + 20) = 10000;
          }
          _mdns_session_activate((uint64_t)v25);
          *v28 = v25;
          goto LABEL_68;
        }
        if (_mdns_resolver_log_s_once != -1)
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
        v40 = _mdns_resolver_log_s_log;
        if (!os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
        {
LABEL_102:
          _mdns_resolver_penalize_server_ex(*(_QWORD *)(a1 + 64), (uint64_t)v24, 0, 0, 0);
          *(_QWORD *)(a1 + 72) = 0;
          *(_BYTE *)(a1 + 247) = 0;
          return;
        }
        *(_DWORD *)buf = 138412546;
        *(_QWORD *)&buf[4] = v24;
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v43;
        v41 = "Failed to create session to %@ for querier: %{mdns:err}ld";
      }
      _os_log_error_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, v41, buf, 0x16u);
      goto LABEL_102;
    }
  }
  v34 = *(unsigned __int16 *)(a1 + 244);
  v35 = *(void **)(a1 + 144);
  os_retain((void *)a1);
  os_retain(v35);
  if (_mdns_resolver_queue_s_once != -1)
    dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
  *(_QWORD *)buf = _NSConcreteStackBlock;
  *(_QWORD *)&buf[8] = 0x40000000;
  *(_QWORD *)&buf[16] = ___mdns_querier_conclude_with_response_async_block_invoke;
  v45 = &__block_descriptor_tmp_65_4704;
  v48 = v34 >> 15;
  v46 = a1;
  v47 = v35;
  dispatch_async((dispatch_queue_t)_mdns_resolver_queue_s_queue, buf);
}

uint64_t _mdns_resolver_get_server(uint64_t a1, int a2)
{
  uint64_t result;
  uint64_t *v3;
  BOOL v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  NSObject *v13;
  unsigned int v14;
  uint64_t v15;
  int v16;
  uint8_t buf[4];
  uint64_t v18;
  __int16 v19;
  unint64_t v20;
  __int16 v21;
  unint64_t v22;

  v3 = (uint64_t *)(a1 + 24);
  result = *(_QWORD *)(a1 + 24);
  if (result)
  {
    if (*(_DWORD *)(result + 100) != 1
      || *(_BYTE *)(result + 108)
      || ((*(char *)(result + 106) - 1) <= 3 ? (v5 = (a2 & 1) == 0) : (v5 = 0), !v5))
    {
      v6 = mach_continuous_time();
      v7 = *v3;
      if (*v3)
      {
        v8 = v6;
        v9 = v3;
        do
        {
          if (*(_BYTE *)(v7 + 108) && (v10 = v8 - *(_QWORD *)(v7 + 72), v10 >= 0))
          {
            *v9 = *(_QWORD *)(v7 + 24);
            *(_QWORD *)(v7 + 24) = 0;
            *(_BYTE *)(v7 + 108) = 0;
            v11 = *v3;
            if (*v3 && !*(_BYTE *)(v11 + 108))
            {
              v14 = *(_DWORD *)(v7 + 100);
              v12 = v3;
              if (*(_DWORD *)(v11 + 100) <= v14)
              {
                do
                {
                  v15 = v11;
                  v11 = *(_QWORD *)(v11 + 24);
                }
                while (v11 && !*(_BYTE *)(v11 + 108) && *(_DWORD *)(v11 + 100) <= v14);
                v12 = (uint64_t *)(v15 + 24);
              }
            }
            else
            {
              v12 = v3;
            }
            *(_QWORD *)(v7 + 24) = v11;
            *v12 = v7;
            if (_mdns_resolver_log_s_once != -1)
              dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
            v13 = _mdns_resolver_log_s_log;
            if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
            {
              if (mdns_mach_ticks_per_second_s_once != -1)
                dispatch_once(&mdns_mach_ticks_per_second_s_once, &__block_literal_global_3428);
              *(_DWORD *)buf = 138412802;
              v18 = v7;
              v19 = 2048;
              v20 = v10 / (unint64_t)mdns_mach_ticks_per_second_s_ticks_per_second;
              v21 = 2048;
              v22 = 1000
                  * (v10 % (unint64_t)mdns_mach_ticks_per_second_s_ticks_per_second)
                  / mdns_mach_ticks_per_second_s_ticks_per_second;
              _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_INFO, "Unpenalizing server %@ (penalty expired %lld.%03lld seconds ago)", buf, 0x20u);
            }
          }
          else
          {
            v9 = (uint64_t *)(v7 + 24);
          }
          v7 = *v9;
        }
        while (*v9);
        for (result = *v3; result; result = *(_QWORD *)(result + 24))
        {
          if ((*(char *)(result + 106) - 1) <= 3)
          {
            v16 = (*(_DWORD *)(result + 100) - 1) >= 0x20 ? 0 : 1 << (*(_BYTE *)(result + 100) - 1);
            if ((v16 & a2) == 0)
              break;
          }
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

void ___mdns_querier_conclude_with_response_async_block_invoke(uint64_t a1)
{
  _mdns_querier_conclude_ex(*(_QWORD *)(a1 + 32), 1, *(unsigned __int8 *)(a1 + 48), *(_QWORD **)(a1 + 40));
  os_release(*(void **)(a1 + 32));
  os_release(*(void **)(a1 + 40));
}

uint64_t _mdns_querier_get_eligible_server(uint64_t a1)
{
  int v2;
  uint64_t result;
  uint64_t v4;
  NSObject *v6;
  const char *v7;
  int v8;
  const char *v9;

  v2 = *(_DWORD *)(a1 + 228);
  if (*(_BYTE *)(a1 + 251))
    v2 |= *(_DWORD *)(a1 + 216) | *(_DWORD *)(a1 + 220);
  result = _mdns_resolver_get_server(*(_QWORD *)(a1 + 64), v2);
  if (result)
  {
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 112);
    if (v4 && v4 != a1)
    {
      if (_mdns_resolver_log_s_once != -1)
        dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
      v6 = _mdns_resolver_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
      {
        v7 = *(const char **)(a1 + 128);
        if (!v7)
          v7 = "";
        v8 = 136446210;
        v9 = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}sBacking off while probe querier is active", (uint8_t *)&v8, 0xCu);
      }
      return 0;
    }
  }
  return result;
}

uint64_t _mdns_querier_set_current_server(uint64_t result, uint64_t a2)
{
  int v2;
  int v3;

  *(_QWORD *)(result + 72) = a2;
  *(_BYTE *)(result + 247) = 0;
  if (a2)
  {
    v2 = (*(_DWORD *)(a2 + 100) - 1) >= 0x20 ? 0 : 1 << (*(_BYTE *)(a2 + 100) - 1);
    if ((v2 & *(_DWORD *)(result + 212)) == 0)
    {
      if (*(_BYTE *)(result + 251))
        v3 = 2000;
      else
        v3 = *(_DWORD *)(*(_QWORD *)(result + 64) + 124);
      *(_DWORD *)(result + 204) = v3;
    }
  }
  return result;
}

uint64_t ___mdns_querier_initiate_send_block_invoke(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  int v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  _BYTE *v8;
  int v9;
  _QWORD *v10;
  unsigned int v11;
  int v12;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(NSObject **)(v1 + 96);
  if (v2)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(v1 + 96));
    dispatch_release(v2);
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 96) = 0;
    v1 = *(_QWORD *)(a1 + 32);
  }
  v4 = *(unsigned __int8 *)(v1 + 251);
  if (*(_BYTE *)(v1 + 251))
    v5 = 900000;
  else
    v5 = 30000;
  v6 = *(_DWORD *)(v1 + 204);
  if (v6 <= v5 >> 1)
    v5 = 2 * v6;
  *(_DWORD *)(v1 + 204) = v5;
  v7 = *(_QWORD *)(v1 + 72);
  if (v7)
  {
    if (v4)
    {
      _mdns_resolver_penalize_server_ex(*(_QWORD *)(v1 + 64), *(_QWORD *)(v1 + 72), 0, 0, 0);
      *(_QWORD *)(v1 + 72) = 0;
      v8 = (_BYTE *)(v1 + 247);
LABEL_22:
      *v8 = 0;
      return _mdns_querier_initiate_send(v1);
    }
    v8 = (_BYTE *)(v1 + 247);
    v9 = *(unsigned __int8 *)(v1 + 247);
    if (v9 == 255 || (*v8 = v9 + 1, v9))
    {
      v10 = *(_QWORD **)(v1 + 104);
      if (v10)
      {
        while (v10[4] != v7)
        {
          v10 = (_QWORD *)v10[3];
          if (!v10)
            goto LABEL_21;
        }
        _mdns_resolver_penalize_server_ex(*(_QWORD *)(v1 + 64), v7, 1, v1, v10[8]);
        v11 = *(_DWORD *)(v7 + 100) - 1;
        if (v11 < 0x20)
          v12 = ~(1 << v11);
        else
          v12 = -1;
        *(_DWORD *)(v1 + 200) &= v12;
      }
LABEL_21:
      *(_QWORD *)(v1 + 72) = 0;
      goto LABEL_22;
    }
  }
  return _mdns_querier_initiate_send(v1);
}

_QWORD *_mdns_resolver_create_session(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, int *a6)
{
  int v12;
  _QWORD *v13;
  _QWORD *v14;
  _UNKNOWN **v15;
  void (*v16)(_QWORD *);
  _UNKNOWN **v17;
  void (*v18)(_QWORD *);
  int v19;
  _UNKNOWN **v20;
  void (*v21)(_QWORD *);
  uint64_t v22;
  uint64_t (*v23)(_QWORD *, uint64_t, uint64_t, uint64_t, uint64_t);
  int v24;
  uint64_t (*v25)(_QWORD *);
  char v26;
  uint64_t (*v27)(_QWORD *);
  char v28;

  v12 = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 144);
  if ((v12 - 2) < 2)
    goto LABEL_5;
  if (v12 == 4)
  {
    v13 = (_QWORD *)_os_object_alloc(OS_mdns_session, 200);
    v14 = v13;
    if (!v13)
      goto LABEL_38;
    v17 = &_mdns_url_session_kind;
    v13[2] = &_mdns_url_session_kind;
    do
    {
      v18 = (void (*)(_QWORD *))v17[2];
      if (v18)
        v18(v14);
      v17 = (_UNKNOWN **)*v17;
    }
    while (v17);
  }
  else
  {
    if (v12 != 1)
    {
      v13 = 0;
      v14 = 0;
      v19 = -6756;
      goto LABEL_33;
    }
    if ((_DWORD)a3)
    {
LABEL_5:
      v13 = (_QWORD *)_os_object_alloc(OS_mdns_session, 112);
      v14 = v13;
      if (v13)
      {
        v15 = &_mdns_connection_session_kind;
        v13[2] = &_mdns_connection_session_kind;
        do
        {
          v16 = (void (*)(_QWORD *))v15[2];
          if (v16)
            v16(v14);
          v15 = (_UNKNOWN **)*v15;
        }
        while (v15);
        goto LABEL_23;
      }
LABEL_38:
      v19 = -6728;
      goto LABEL_33;
    }
    v13 = (_QWORD *)_os_object_alloc(OS_mdns_session, 144);
    v14 = v13;
    if (!v13)
      goto LABEL_38;
    v20 = &_mdns_udp_socket_session_kind;
    v13[2] = &_mdns_udp_socket_session_kind;
    do
    {
      v21 = (void (*)(_QWORD *))v20[2];
      if (v21)
        v21(v14);
      v20 = (_UNKNOWN **)*v20;
    }
    while (v20);
  }
LABEL_23:
  v14[4] = a2;
  os_retain(a2);
  v22 = v14[2];
  v23 = *(uint64_t (**)(_QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(v22 + 56);
  if (v23)
  {
    v24 = v23(v14, a1, a3, a4, a5);
    if (v24)
    {
      v19 = v24;
      v13 = v14;
      v14 = 0;
      goto LABEL_33;
    }
    v22 = v14[2];
  }
  v25 = *(uint64_t (**)(_QWORD *))(v22 + 88);
  if (v25)
    v26 = v25(v14);
  else
    v26 = *(_BYTE *)(v22 + 104) != 0;
  *((_BYTE *)v14 + 89) = v26;
  v27 = *(uint64_t (**)(_QWORD *))(v22 + 96);
  if (v27)
    v28 = v27(v14);
  else
    v28 = *(_BYTE *)(v22 + 105) != 0;
  v13 = 0;
  v19 = 0;
  *((_BYTE *)v14 + 90) = v28;
LABEL_33:
  if (a6)
    *a6 = v19;
  if (v13)
    os_release(v13);
  return v14;
}

void _mdns_session_activate(uint64_t a1)
{
  unsigned int v2;
  NSObject *oneshot_timer;
  uint64_t v4;
  uint64_t (*v5)(uint64_t);
  int v6;
  int v7;
  _QWORD handler[5];

  if (!*(_BYTE *)(a1 + 88))
  {
    v2 = *(_DWORD *)(a1 + 80);
    if (v2)
    {
      oneshot_timer = _mdns_resolver_create_oneshot_timer(v2, 5u);
      *(_QWORD *)(a1 + 40) = oneshot_timer;
      if (!oneshot_timer)
      {
        v7 = -6729;
        goto LABEL_13;
      }
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 0x40000000;
      handler[2] = ___mdns_session_activate_block_invoke;
      handler[3] = &__block_descriptor_tmp_117_4742;
      handler[4] = a1;
      dispatch_source_set_event_handler(oneshot_timer, handler);
      dispatch_activate(*(dispatch_object_t *)(a1 + 40));
    }
    v4 = mach_continuous_time();
    *(_QWORD *)(a1 + 56) = v4;
    if (mdns_mach_ticks_per_second_s_once != -1)
      dispatch_once(&mdns_mach_ticks_per_second_s_once, &__block_literal_global_3428);
    *(_QWORD *)(a1 + 64) = v4 - 3600 * mdns_mach_ticks_per_second_s_ticks_per_second;
    v5 = *(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 16) + 64);
    if (!v5 || (v6 = v5(a1)) == 0)
    {
      *(_BYTE *)(a1 + 88) = 1;
      return;
    }
    v7 = v6;
LABEL_13:
    *(_BYTE *)(a1 + 88) = 2;
    _mdns_common_session_terminate_async((void *)a1, v7);
  }
}

void _mdns_resolver_penalize_server_ex(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  int v10;
  int v11;
  int v12;
  uint64_t *v13;
  int v14;
  uint64_t *v15;
  unsigned __int8 *v16;
  int v17;
  uint64_t *v18;
  uint64_t *v19;
  _QWORD *v20;
  _QWORD *v21;
  NSObject *v22;
  const char *v23;
  int v24;
  int v25;
  _QWORD *v26;
  _QWORD *v27;
  uint64_t v28;
  BOOL v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  NSObject *v33;
  const char *v34;
  const sockaddr *address;
  int v36;
  const char *v37;
  __int16 v38;
  _BYTE v39[10];
  __int16 v40;
  uint64_t v41;
  __int16 v42;
  int v43;

  if (a3)
  {
    if (!a4)
      goto LABEL_25;
    if (!*(_DWORD *)(a1 + 128))
      goto LABEL_25;
    if (*(_BYTE *)(a2 + 107))
      goto LABEL_25;
    v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a4 + 16) + 88))(a4);
    if ((v10 & 0xFFFE) != 0x40)
      goto LABEL_25;
    v11 = (*(_DWORD *)(a2 + 100) - 1) >= 0x20 ? 0 : 1 << (*(_BYTE *)(a2 + 100) - 1);
    if ((v11 & *(_DWORD *)(a4 + 200)) == 0)
      goto LABEL_25;
    v12 = v10;
    v13 = *(uint64_t **)(a2 + 64);
    if (!v13)
    {
      v14 = *(_DWORD *)(*(_QWORD *)(a4 + 64) + 128);
      v15 = (uint64_t *)malloc_type_calloc(1uLL, 0x10uLL, 0xF1748037uLL);
      if (!v15)
        goto LABEL_52;
      v13 = v15;
      *((_DWORD *)v15 + 3) = v14;
      *(_QWORD *)(a2 + 64) = v15;
    }
    v16 = *(unsigned __int8 **)(*(_QWORD *)(*(_QWORD *)(a4 + 88) + 56) + 24);
    if (!_pqw_info_can_accept_qname(v13, v16))
      goto LABEL_25;
    v17 = *((_DWORD *)v13 + 3);
    if (*((_DWORD *)v13 + 2) >= (v17 - 1))
    {
      v20 = (_QWORD *)*v13;
      if (*v13)
      {
        do
        {
          v21 = (_QWORD *)*v20;
          _pqw_qname_item_free(v20);
          v20 = v21;
        }
        while (v21);
        *v13 = 0;
        v17 = *((_DWORD *)v13 + 3);
      }
LABEL_20:
      *((_DWORD *)v13 + 2) = v17;
      if (_mdns_resolver_log_s_once == -1)
        goto LABEL_21;
      goto LABEL_53;
    }
    v18 = (uint64_t *)malloc_type_calloc(1uLL, 0x10uLL, 0xF1748037uLL);
    if (v18)
    {
      v19 = v18;
      DomainNameDupEx(v16, v18 + 1, 0);
      *v19 = *v13;
      *v13 = (uint64_t)v19;
      v17 = *((_DWORD *)v13 + 2) + 1;
      goto LABEL_20;
    }
LABEL_52:
    __break(1u);
LABEL_53:
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
LABEL_21:
    v22 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      v23 = *(const char **)(a4 + 128);
      if (!v23)
        v23 = "";
      v24 = *((_DWORD *)v13 + 2);
      v25 = *((_DWORD *)v13 + 3);
      v36 = 136447234;
      v37 = v23;
      v38 = 1024;
      *(_DWORD *)v39 = v24;
      *(_WORD *)&v39[4] = 1024;
      *(_DWORD *)&v39[6] = v25;
      v40 = 2112;
      v41 = a2;
      v42 = 1024;
      v43 = v12;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%{public}sNo response (%u/%u) from server %@ for qtype %{mdns:rrtype}d", (uint8_t *)&v36, 0x28u);
    }
LABEL_25:
    if (a5 - *(_QWORD *)(a2 + 80) < 0)
      return;
  }
  v26 = (_QWORD *)(a1 + 24);
  do
  {
    v27 = v26;
    v28 = *v26;
    v26 = (_QWORD *)(*v26 + 24);
    if (v28)
      v29 = v28 == a2;
    else
      v29 = 1;
  }
  while (!v29);
  if (v28)
  {
    *v27 = *(_QWORD *)(a2 + 24);
    *(_QWORD *)(a2 + 24) = 0;
    v30 = mach_continuous_time();
    if (mdns_mach_ticks_per_second_s_once != -1)
      dispatch_once(&mdns_mach_ticks_per_second_s_once, &__block_literal_global_3428);
    *(_QWORD *)(a2 + 72) = v30 + 60 * mdns_mach_ticks_per_second_s_ticks_per_second;
    *(_BYTE *)(a2 + 108) = 1;
    do
    {
      v31 = v27;
      v32 = *v27;
      v27 = (_QWORD *)(*v27 + 24);
    }
    while (v32);
    *v31 = a2;
  }
  if (_mdns_resolver_log_s_once != -1)
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
  v33 = _mdns_resolver_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
  {
    v34 = "";
    if (a4 && *(_QWORD *)(a4 + 128))
      v34 = *(const char **)(a4 + 128);
    v36 = 136446466;
    v37 = v34;
    v38 = 2112;
    *(_QWORD *)v39 = a2;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_INFO, "%{public}sPenalizing server %@ for 60 seconds", (uint8_t *)&v36, 0x16u);
  }
  if (a3)
  {
    if (!*(_BYTE *)(a2 + 109))
      *(_BYTE *)(a2 + 109) = 1;
    if (*(_BYTE *)(a1 + 132))
    {
      if (nw_endpoint_get_type(*(nw_endpoint_t *)(a2 + 48)) == nw_endpoint_type_address)
      {
        address = nw_endpoint_get_address(*(nw_endpoint_t *)(a2 + 48));
        _mdns_symptoms_report_dns_server_symptom(413697, (uint64_t)address);
      }
    }
  }
}

void _mdns_querier_send_query(uint64_t a1, uint64_t a2)
{
  int v3;

  if ((*(_DWORD *)(*(_QWORD *)(a2 + 32) + 100) - 1) >= 0x20)
    v3 = 0;
  else
    v3 = 1 << (*(_BYTE *)(*(_QWORD *)(a2 + 32) + 100) - 1);
  if (*(_BYTE *)(a2 + 88) == 1 && *(_BYTE *)(a2 + 90))
  {
    *(_DWORD *)(a1 + 216) &= ~v3;
    if (!*(_BYTE *)(a2 + 89) || (*(_DWORD *)(a1 + 220) & v3) == 0)
    {
      _mdns_querier_send_query_immediate(a1, a2);
      *(_DWORD *)(a1 + 220) |= v3;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 216) |= v3;
  }
}

void _mdns_querier_send_query_immediate(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void (*v7)(uint64_t, uint64_t, uint64_t);
  unsigned int *v8;
  unsigned int v9;
  const char *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  const char *interface_log_string;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t (*v19)(_QWORD, _QWORD, uint64_t);
  uint64_t v20;
  void *v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  const char *v27;
  NSObject *v28;
  uint32_t v29;
  _QWORD *v30;
  uint64_t (*v31)(_QWORD, _QWORD, uint64_t);
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  const char *v42;
  NSObject *v43;
  uint32_t v44;
  uint64_t v45;
  unsigned int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  uint64_t *v52;
  uint64_t v53;
  __int16 v54;
  uint64_t v55;
  uint32_t v56;
  __int16 v57;
  __int16 v58;
  uint64_t v59;
  uint64_t v60;
  void (*v61)(uint64_t, uint64_t, uint64_t);
  int v62;
  uint64_t v63;
  unint64_t v64;
  _QWORD *v65;
  uint64_t (*v66)(_QWORD, _QWORD, uint64_t);
  uint64_t v67;
  void *v68;
  NSObject *v69;
  const char *v70;
  unsigned int v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  int v75;
  const char *v76;
  int v77;
  uint64_t v78;
  NSObject *v79;
  const char *v80;
  unsigned int v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  int v85;
  const char *v86;
  int v87;
  uint64_t v88;
  NSObject *v89;
  const char *v90;
  int v91;
  const char *v92;
  __int16 v93;
  unint64_t v94;
  __int16 v95;
  unsigned int v96;
  __int16 v97;
  uint64_t v98;
  __int16 v99;
  int v100;
  __int16 v101;
  const char *v102;
  __int16 v103;
  _BYTE v104[28];

  if (*(_BYTE *)(a2 + 88) == 1)
  {
    v4 = *(_QWORD *)(a1 + 88);
    v5 = *(unsigned __int16 *)(v4 + 64);
    v6 = *(_QWORD *)(v4 + 24);
    *(_QWORD *)(a2 + 64) = mach_continuous_time();
    v7 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a2 + 16) + 80);
    if (v7)
      v7(a2, v6, v5);
  }
  v8 = (unsigned int *)(a1 + 208);
  do
    v9 = __ldaxr(v8);
  while (__stlxr(v9 + 1, v8));
  if (*(_QWORD *)(a1 + 128))
    v10 = *(const char **)(a1 + 128);
  else
    v10 = "";
  v11 = *(_QWORD *)(*(_QWORD *)(a1 + 88) + 40);
  v12 = *(_QWORD *)(a1 + 64);
  v13 = 152;
  if (!*(_BYTE *)(a2 + 89))
    v13 = 148;
  v14 = *(_DWORD *)(*(_QWORD *)(v12 + 16) + v13);
  interface_log_string = _mdns_resolver_get_interface_log_string(v12);
  v16 = *(_QWORD *)(a1 + 88);
  if (v11 < 0xC)
  {
    if (*(_BYTE *)(a1 + 255))
    {
      v30 = (_QWORD *)(v16 + 16);
      while (1)
      {
        v30 = (_QWORD *)*v30;
        if (!v30)
          break;
        v31 = (uint64_t (*)(_QWORD, _QWORD, uint64_t))v30[3];
        if (v31)
        {
          v32 = v31(*(_QWORD *)(a1 + 88), 0, 1);
          if (!v32)
            break;
          v21 = (void *)v32;
          if (_mdns_resolver_log_s_once != -1)
            dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
          v33 = _mdns_resolver_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
          {
            v34 = *(_DWORD *)(a1 + 208);
            v35 = *(_QWORD *)(a2 + 32);
            v36 = *(_QWORD *)(*(_QWORD *)(a1 + 88) + 32);
            v91 = 136448258;
            v92 = v10;
            v93 = 2048;
            v94 = v11;
            v95 = 1024;
            v96 = v34;
            v97 = 2112;
            v98 = v35;
            v99 = 1024;
            v100 = v14;
            v101 = 2082;
            v102 = interface_log_string;
            v103 = 1040;
            *(_DWORD *)v104 = v11;
            *(_WORD *)&v104[4] = 2098;
            *(_QWORD *)&v104[6] = v36;
            *(_WORD *)&v104[14] = 2082;
            *(_QWORD *)&v104[16] = v21;
            v27 = "%{public}sSent %zu-byte query #%u to %@ over %{mdns:protocol}d via %{public}s -- %{public,mdns:dnshdr}.*P, %{public}s";
            v28 = v33;
            v29 = 80;
LABEL_30:
            _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, v27, (uint8_t *)&v91, v29);
          }
LABEL_31:
          free(v21);
          goto LABEL_41;
        }
      }
    }
    if (_mdns_resolver_log_s_once != -1)
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    v45 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      v46 = *(_DWORD *)(a1 + 208);
      v47 = *(_QWORD *)(a2 + 32);
      v48 = *(_QWORD *)(*(_QWORD *)(a1 + 88) + 32);
      v91 = 136448258;
      v92 = v10;
      v93 = 2048;
      v94 = v11;
      v95 = 1024;
      v96 = v46;
      v97 = 2112;
      v98 = v47;
      v99 = 1024;
      v100 = v14;
      v101 = 2082;
      v102 = interface_log_string;
      v103 = 1040;
      *(_DWORD *)v104 = v11;
      *(_WORD *)&v104[4] = 2098;
      *(_QWORD *)&v104[6] = v48;
      *(_WORD *)&v104[14] = 2112;
      *(_QWORD *)&v104[16] = v16;
      v42 = "%{public}sSent %zu-byte query #%u to %@ over %{mdns:protocol}d via %{public}s -- %{public,mdns:dnshdr}.*P, %@";
      v43 = v45;
      v44 = 80;
      goto LABEL_40;
    }
  }
  else
  {
    v17 = *(_QWORD *)(v16 + 32);
    if (*(_BYTE *)(a1 + 255))
    {
      v18 = (_QWORD *)(v16 + 16);
      while (1)
      {
        v18 = (_QWORD *)*v18;
        if (!v18)
          break;
        v19 = (uint64_t (*)(_QWORD, _QWORD, uint64_t))v18[3];
        if (v19)
        {
          v20 = v19(*(_QWORD *)(a1 + 88), 0, 1);
          if (!v20)
            break;
          v21 = (void *)v20;
          if (_mdns_resolver_log_s_once != -1)
            dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
          v22 = _mdns_resolver_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
          {
            v23 = *v8;
            v24 = *(_QWORD *)(a2 + 32);
            v25 = bswap32(*(_DWORD *)v17);
            v26 = bswap64(*(_QWORD *)(v17 + 4));
            v91 = 136448258;
            v92 = v10;
            v93 = 2048;
            v94 = v11;
            v95 = 1024;
            v96 = v23;
            v97 = 2112;
            v98 = v24;
            v99 = 1024;
            v100 = v14;
            v101 = 2082;
            v102 = interface_log_string;
            v103 = 2048;
            *(_QWORD *)v104 = v25;
            *(_WORD *)&v104[8] = 2048;
            *(_QWORD *)&v104[10] = v26;
            *(_WORD *)&v104[18] = 2082;
            *(_QWORD *)&v104[20] = v21;
            v27 = "%{public}sSent %zu-byte query #%u to %@ over %{mdns:protocol}d via %{public}s -- %{mdns:dns.idflags}08"
                  "lX, counts: %{mdns:dns.counts}016llX, %{public}s";
            v28 = v22;
            v29 = 84;
            goto LABEL_30;
          }
          goto LABEL_31;
        }
      }
    }
    if (_mdns_resolver_log_s_once != -1)
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    v37 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      v38 = *v8;
      v39 = *(_QWORD *)(a2 + 32);
      v40 = bswap32(*(_DWORD *)v17);
      v41 = bswap64(*(_QWORD *)(v17 + 4));
      v91 = 136448258;
      v92 = v10;
      v93 = 2048;
      v94 = v11;
      v95 = 1024;
      v96 = v38;
      v97 = 2112;
      v98 = v39;
      v99 = 1024;
      v100 = v14;
      v101 = 2082;
      v102 = interface_log_string;
      v103 = 2048;
      *(_QWORD *)v104 = v40;
      *(_WORD *)&v104[8] = 2048;
      *(_QWORD *)&v104[10] = v41;
      *(_WORD *)&v104[18] = 2112;
      *(_QWORD *)&v104[20] = v16;
      v42 = "%{public}sSent %zu-byte query #%u to %@ over %{mdns:protocol}d via %{public}s -- %{mdns:dns.idflags}08lX, co"
            "unts: %{mdns:dns.counts}016llX, %@";
      v43 = v37;
      v44 = 84;
LABEL_40:
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, v42, (uint8_t *)&v91, v44);
    }
  }
LABEL_41:
  if (!*(_DWORD *)(*(_QWORD *)(a1 + 64) + 128))
    goto LABEL_48;
  v49 = *(_QWORD *)(a2 + 32);
  if (*(_BYTE *)(v49 + 107))
    goto LABEL_48;
  v50 = *(_QWORD *)(a1 + 88);
  if ((*(_WORD *)(v50 + 64) & 0xFFFE) != 0x40)
    goto LABEL_48;
  v51 = (*(_DWORD *)(v49 + 100) - 1) >= 0x20 ? 0 : 1 << (*(_BYTE *)(v49 + 100) - 1);
  if ((v51 & *(_DWORD *)(a1 + 200)) != 0)
    goto LABEL_48;
  v52 = *(uint64_t **)(v49 + 64);
  if (v52)
  {
    if (!_pqw_info_can_accept_qname(v52, *(unsigned __int8 **)(*(_QWORD *)(v50 + 56) + 24)))
      goto LABEL_48;
  }
  v53 = *(_QWORD *)(a1 + 192);
  if (v53)
    goto LABEL_72;
  v54 = *(_WORD *)(v49 + 104);
  if (!v54)
  {
    if (nw_endpoint_get_type(*(nw_endpoint_t *)(v49 + 48)) == nw_endpoint_type_address)
    {
      if (nw_endpoint_get_address(*(nw_endpoint_t *)(v49 + 48))->sa_family == 30)
        v54 = 28;
      else
        v54 = 1;
    }
    else
    {
      v54 = 1;
    }
    *(_WORD *)(v49 + 104) = v54;
  }
  v55 = mdns_query_message_create();
  if (!v55)
  {
LABEL_107:
    *(_QWORD *)(a1 + 192) = 0;
    if (_mdns_resolver_log_s_once != -1)
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    v89 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
    {
      v90 = *(const char **)(a1 + 128);
      if (!v90)
        v90 = "";
      v91 = 136446210;
      v92 = v90;
      _os_log_error_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_ERROR, "%{public}sFailed to create test query", (uint8_t *)&v91, 0xCu);
    }
    goto LABEL_48;
  }
  v53 = v55;
  mdns_query_message_set_qname(v55, *(void **)(v50 + 56));
  if ((*(_BYTE *)(v53 + 70) & 0x20) == 0)
  {
    *(_WORD *)(v53 + 64) = v54;
    *(_WORD *)(v53 + 66) = *(_WORD *)(v50 + 66);
  }
  v56 = arc4random();
  if ((*(_BYTE *)(v53 + 70) & 0x20) == 0)
  {
    if (v56 % 0xFFFF == 65534)
      v57 = 1;
    else
      v57 = -2 - v56 % 0xFFFF;
    if (v56 % 0xFFFF + 1 == *(unsigned __int16 *)(v50 + 68))
      v58 = v57;
    else
      v58 = v56 % 0xFFFF + 1;
    *(_WORD *)(v53 + 68) = v58;
  }
  if (mdns_query_message_construct(v53))
  {
    os_release((void *)v53);
    goto LABEL_107;
  }
  *(_QWORD *)(a1 + 192) = v53;
LABEL_72:
  if (*(_BYTE *)(a2 + 88) == 1)
  {
    v59 = *(_QWORD *)(v53 + 24);
    v60 = *(unsigned __int16 *)(v53 + 64);
    *(_QWORD *)(a2 + 64) = mach_continuous_time();
    v61 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a2 + 16) + 80);
    if (v61)
      v61(a2, v59, v60);
  }
  v62 = *(unsigned __int8 *)(a1 + 246);
  if (v62 != 255)
    *(_BYTE *)(a1 + 246) = v62 + 1;
  v63 = *(_QWORD *)(a1 + 192);
  if (v63)
  {
    v64 = *(_QWORD *)(v63 + 40);
    if (*(_BYTE *)(a1 + 255))
    {
      v65 = (_QWORD *)(v63 + 16);
      while (1)
      {
        v65 = (_QWORD *)*v65;
        if (!v65)
          break;
        v66 = (uint64_t (*)(_QWORD, _QWORD, uint64_t))v65[3];
        if (v66)
        {
          v67 = v66(*(_QWORD *)(a1 + 192), 0, 1);
          if (!v67)
            break;
          v68 = (void *)v67;
          if (_mdns_resolver_log_s_once != -1)
            dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
          v69 = _mdns_resolver_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
          {
            if (*(_QWORD *)(a1 + 128))
              v70 = *(const char **)(a1 + 128);
            else
              v70 = "";
            v71 = *(unsigned __int8 *)(a1 + 246);
            v72 = *(_QWORD *)(a2 + 32);
            v73 = *(_QWORD *)(a1 + 64);
            v74 = 152;
            if (!*(_BYTE *)(a2 + 89))
              v74 = 148;
            v75 = *(_DWORD *)(*(_QWORD *)(v73 + 16) + v74);
            v76 = _mdns_resolver_get_interface_log_string(v73);
            v77 = 12;
            v78 = *(_QWORD *)(*(_QWORD *)(a1 + 192) + 32);
            if (v64 < 0xC)
              v77 = v64;
            v91 = 136448258;
            v92 = v70;
            v93 = 2048;
            v94 = v64;
            v95 = 1024;
            v96 = v71;
            v97 = 2112;
            v98 = v72;
            v99 = 1024;
            v100 = v75;
            v101 = 2082;
            v102 = v76;
            v103 = 1040;
            *(_DWORD *)v104 = v77;
            *(_WORD *)&v104[4] = 2098;
            *(_QWORD *)&v104[6] = v78;
            *(_WORD *)&v104[14] = 2082;
            *(_QWORD *)&v104[16] = v68;
            _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEFAULT, "%{public}sSent %zu-byte test query #%u to %@ over %{mdns:protocol}d via %{public}s -- %{public,mdns:dnshdr}.*P, %{public}s", (uint8_t *)&v91, 0x50u);
          }
          free(v68);
          goto LABEL_48;
        }
      }
    }
    if (_mdns_resolver_log_s_once != -1)
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    v79 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      if (*(_QWORD *)(a1 + 128))
        v80 = *(const char **)(a1 + 128);
      else
        v80 = "";
      v81 = *(unsigned __int8 *)(a1 + 246);
      v82 = *(_QWORD *)(a2 + 32);
      v83 = *(_QWORD *)(a1 + 64);
      v84 = 152;
      if (!*(_BYTE *)(a2 + 89))
        v84 = 148;
      v85 = *(_DWORD *)(*(_QWORD *)(v83 + 16) + v84);
      v86 = _mdns_resolver_get_interface_log_string(v83);
      v87 = 12;
      v88 = *(_QWORD *)(*(_QWORD *)(a1 + 192) + 32);
      if (v64 < 0xC)
        v87 = v64;
      v91 = 136448258;
      v92 = v80;
      v93 = 2048;
      v94 = v64;
      v95 = 1024;
      v96 = v81;
      v97 = 2112;
      v98 = v82;
      v99 = 1024;
      v100 = v85;
      v101 = 2082;
      v102 = v86;
      v103 = 1040;
      *(_DWORD *)v104 = v87;
      *(_WORD *)&v104[4] = 2098;
      *(_QWORD *)&v104[6] = v88;
      *(_WORD *)&v104[14] = 2112;
      *(_QWORD *)&v104[16] = v63;
      _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_DEFAULT, "%{public}sSent %zu-byte test query #%u to %@ over %{mdns:protocol}d via %{public}s -- %{public,mdns:dnshdr}.*P, %@", (uint8_t *)&v91, 0x50u);
    }
  }
LABEL_48:
  _mdns_resolver_start_pending_queriers(*(_QWORD *)(a1 + 64));
}

const char *_mdns_resolver_get_interface_log_string(uint64_t a1)
{
  char *v1;
  char **v2;
  NSObject *v4;
  const char *name;
  const char *v6;

  v2 = (char **)(a1 + 64);
  v1 = *(char **)(a1 + 64);
  if (!v1)
  {
    v4 = *(NSObject **)(a1 + 48);
    if (v4)
    {
      name = nw_interface_get_name(v4);
      v4 = *(NSObject **)(a1 + 48);
      if (v4)
        LODWORD(v4) = nw_interface_get_index(v4);
    }
    else
    {
      name = "any";
    }
    v6 = "";
    if (name)
      v6 = name;
    asprintf(v2, "%s/%u", v6, (_DWORD)v4);
    v1 = *v2;
  }
  if (v1)
    return v1;
  else
    return "???";
}

BOOL _pqw_info_can_accept_qname(uint64_t *a1, unsigned __int8 *a2)
{
  uint64_t **v3;
  _BOOL8 result;

  if (*((_DWORD *)a1 + 2) >= *((_DWORD *)a1 + 3))
    return 0;
  v3 = (uint64_t **)a1;
  while (1)
  {
    v3 = (uint64_t **)*v3;
    result = v3 == 0;
    if (!v3)
      break;
    if (DomainNameEqual((unsigned __int8 *)v3[1], a2))
      return 0;
  }
  return result;
}

void _mdns_resolver_start_pending_queriers(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;
  NSObject *v4;
  _QWORD handler[5];
  uint8_t buf[16];

  if (*(_QWORD *)(a1 + 40))
  {
    v2 = *(NSObject **)(a1 + 96);
    if (v2)
    {
LABEL_7:
      dispatch_source_merge_data(v2, 1uLL);
      return;
    }
    if (_mdns_resolver_queue_s_once != -1)
      dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
    v3 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_data_or, 0, 0, (dispatch_queue_t)_mdns_resolver_queue_s_queue);
    *(_QWORD *)(a1 + 96) = v3;
    if (v3)
    {
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 0x40000000;
      handler[2] = ___mdns_resolver_start_pending_queriers_block_invoke;
      handler[3] = &__block_descriptor_tmp_115_4720;
      handler[4] = a1;
      dispatch_source_set_event_handler(v3, handler);
      dispatch_activate(*(dispatch_object_t *)(a1 + 96));
      v2 = *(NSObject **)(a1 + 96);
      goto LABEL_7;
    }
    if (_mdns_resolver_log_s_once != -1)
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    v4 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Failed to create pending querier starter GCD source", buf, 2u);
    }
  }
}

void ___mdns_resolver_start_pending_queriers_block_invoke(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  NSObject *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint8_t buf[4];
  const char *v11;

  v1 = *(_QWORD *)(a1 + 32);
  v4 = *(_QWORD *)(v1 + 40);
  v2 = (_QWORD *)(v1 + 40);
  v3 = v4;
  if (v4)
  {
    do
    {
      *v2 = *(_QWORD *)(v3 + 56);
      *(_QWORD *)(v3 + 56) = 0;
      if (_mdns_resolver_log_s_once != -1)
        dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
      v6 = _mdns_resolver_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
      {
        v7 = *(const char **)(v3 + 128);
        if (!v7)
          v7 = "";
        *(_DWORD *)buf = 136446210;
        v11 = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "%{public}sStarting pending querier due to observed traffic activity", buf, 0xCu);
      }
      _mdns_resolver_start_querier(*(_QWORD *)(a1 + 32), (_BYTE *)v3);
      os_release((void *)v3);
      v8 = *(_QWORD *)(a1 + 32);
      v9 = *(_QWORD *)(v8 + 40);
      v2 = (_QWORD *)(v8 + 40);
      v3 = v9;
    }
    while (v9);
  }
}

void _mdns_querier_session_handle_event(uint64_t a1, int a2, int a3, uint64_t a4)
{
  NSObject *v8;
  BOOL v9;
  os_log_type_t v10;
  const char *v11;
  int v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  int v21;
  const char *v22;
  char v23;
  int v24;
  int v25;
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  uint64_t v30;

  if (_mdns_resolver_log_s_once != -1)
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
  v8 = _mdns_resolver_log_s_log;
  if (a3)
    v9 = a2 == 3;
  else
    v9 = 0;
  if (v9)
    v10 = OS_LOG_TYPE_ERROR;
  else
    v10 = OS_LOG_TYPE_INFO;
  if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, v10))
  {
    v11 = *(const char **)(a4 + 128);
    if (!v11)
      v11 = "";
    v25 = 136446722;
    v26 = v11;
    v27 = 1024;
    v28 = a2;
    v29 = 2048;
    v30 = a3;
    _os_log_impl((void *)&_mh_execute_header, v8, v10, "%{public}sQuerier session event -- type: %{mdns:session_event}d, error: %{mdns:err}ld", (uint8_t *)&v25, 0x1Cu);
  }
  if ((a2 - 3) < 2)
  {
    v12 = *(unsigned __int8 *)(a1 + 89);
    v13 = (_QWORD *)(a4 + 104);
    if (*(_BYTE *)(a1 + 89))
      v13 = (_QWORD *)(a4 + 112);
    do
    {
      v14 = v13;
      v15 = *v13;
      v13 = (_QWORD *)(*v13 + 24);
      if (v15)
        v16 = v15 == a1;
      else
        v16 = 1;
    }
    while (!v16);
    if (!v15)
      return;
    *v14 = *(_QWORD *)(a1 + 24);
    *(_QWORD *)(a1 + 24) = 0;
    _mdns_session_invalidate((_BYTE *)a1);
    os_release((void *)a1);
    if (!v12)
      return;
    v17 = *(_QWORD *)(a1 + 32);
    if (a2 == 3)
    {
      if (a3)
      {
        v18 = *(_QWORD *)(a4 + 64);
        _mdns_resolver_generate_error_event((NSObject **)v18, a3);
      }
      else
      {
        if (*(_BYTE *)(a4 + 249) == 3)
          goto LABEL_44;
        v18 = *(_QWORD *)(a4 + 64);
      }
      if (*(_QWORD *)(a4 + 128))
        v22 = *(const char **)(a4 + 128);
      else
        v22 = "";
      v23 = _mdns_resolver_handle_stream_error(v18, v17, v22);
      v24 = *(unsigned __int8 *)(v18 + 140);
      _mdns_resolver_penalize_server_ex(v18, v17, 0, 0, 0);
      if (v24 && (v23 & 1) != 0)
        goto LABEL_43;
    }
LABEL_44:
    _mdns_querier_handle_stream_termination((int8x8_t *)a4, v17);
    return;
  }
  if (a2 != 2)
  {
    if (a2 == 1)
      _mdns_querier_send_query(a4, a1);
    return;
  }
  if (*(_BYTE *)(a1 + 89))
  {
    v19 = *(_QWORD *)(a4 + 64);
    v20 = *(_QWORD *)(a4 + 128) ? *(const char **)(a4 + 128) : "";
    v21 = _mdns_resolver_handle_stream_lateness(*(_QWORD *)(a4 + 64), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 56), v20);
    if (*(_BYTE *)(v19 + 140))
    {
      if (v21)
LABEL_43:
        _mdns_querier_conclude_ex(a4, 6, 0, 0);
    }
  }
}

void _mdns_querier_session_receive(uint64_t a1, NSObject *a2, uint64_t a3)
{
  _BYTE *v5;
  _BYTE *v6;
  int v7;
  BOOL *v8;
  _BOOL4 v9;
  __int16 *v10;
  int is_response_acceptable;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  char v17;
  uint64_t v18;
  uint64_t v19;
  int is_query_response;
  int v21;
  uint64_t v22;
  uint64_t v23;
  NSObject *v24;
  int v25;
  BOOL (*v26)(int);
  __int16 v27;
  __int16 v28;
  uint8_t buf[4];
  int v30;

  v5 = mdns_message_create_with_dispatch_data(a2, 1);
  if (v5)
  {
    v6 = v5;
    v28 = 0;
    v7 = *(unsigned __int8 *)(a1 + 89);
    if (*(_BYTE *)(a1 + 89))
      v8 = 0;
    else
      v8 = (BOOL *)&v28 + 1;
    if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a3 + 64) + 16) + 161))
      v9 = *(_BYTE *)(a1 + 89) != 0;
    else
      v9 = 1;
    if (v9)
      v10 = 0;
    else
      v10 = &v28;
    v27 = 0;
    is_response_acceptable = _mdns_querier_is_response_acceptable(a3, (uint64_t)v5, v8, v10, &v27);
    if (*(_QWORD *)(a3 + 128))
      v12 = *(const char **)(a3 + 128);
    else
      v12 = "";
    _mdns_resolver_log_receive(*(_QWORD *)(a3 + 64), a1, v6, is_response_acceptable, v12, *(unsigned __int8 *)(a3 + 255));
    v13 = *(_QWORD *)(a1 + 32);
    if (is_response_acceptable)
    {
      v14 = *(_QWORD *)(a3 + 64);
      v15 = *(_QWORD *)(a1 + 56);
      v16 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a3 + 16) + 88))(a3);
      _mdns_resolver_note_responsiveness(v14, v13, v7 != 0, v15, v16);
      if (v27 > 9 || ((1 << v27) & 0x209) == 0)
      {
        _mdns_querier_handle_bad_rcode(a3, v6, v27, v13);
        goto LABEL_49;
      }
      if (v7 || !HIBYTE(v28))
      {
        _mdns_querier_conclude_ex(a3, 1, 0, v6);
        goto LABEL_49;
      }
      *(_BYTE *)(a3 + 250) = 1;
    }
    else
    {
      if ((_BYTE)v28)
        v17 = v9;
      else
        v17 = 1;
      if ((v17 & 1) != 0)
      {
        v18 = *(_QWORD *)(a3 + 64);
        if (*(_DWORD *)(v18 + 128))
        {
          v19 = *(_QWORD *)(a3 + 192);
          if (v19)
          {
            is_query_response = _mdns_message_is_query_response_ex(*((char **)v6 + 4), *((_QWORD *)v6 + 5), v19, 0, 0, 1);
            v18 = *(_QWORD *)(a3 + 64);
            if (is_query_response)
            {
              if ((*(_DWORD *)(v13 + 100) - 1) >= 0x20)
                v21 = 0;
              else
                v21 = 1 << (*(_BYTE *)(v13 + 100) - 1);
              *(_DWORD *)(a3 + 200) |= v21;
              _mdns_resolver_note_responsiveness(v18, v13, v7 != 0, *(_QWORD *)(a1 + 56), *(unsigned __int16 *)(*(_QWORD *)(a3 + 192) + 64));
              goto LABEL_49;
            }
          }
        }
        if (*(_DWORD *)(*(_QWORD *)(v18 + 16) + 144) == 1 && !*(_BYTE *)(v13 + 112))
        {
          v25 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a3 + 16) + 88))(a3);
          v26 = _mdns_qtype_is_problematic;
          if (v25 != 1 && v25 != 28)
          {
            if ((v25 & 0xFFFE) != 0x40)
              goto LABEL_49;
            v26 = _mdns_qtype_is_address_type;
          }
          *(_WORD *)buf = 0;
          if (_mdns_message_is_query_response_ex(*((char **)v6 + 4), *((_QWORD *)v6 + 5), *(_QWORD *)(a3 + 88), 0, buf, 0)&& v26(*(unsigned __int16 *)buf))
          {
            *(_BYTE *)(v13 + 112) = 1;
          }
        }
LABEL_49:
        os_release(v6);
        return;
      }
      *(_BYTE *)(a3 + 250) = 2;
      v22 = *(_QWORD *)(a3 + 64);
      if (mdns_mach_ticks_per_second_s_once != -1)
        dispatch_once(&mdns_mach_ticks_per_second_s_once, &__block_literal_global_3428);
      v23 = mdns_mach_ticks_per_second_s_ticks_per_second;
      *(_QWORD *)(v22 + 88) = mach_continuous_time() + 10 * v23;
      *(_BYTE *)(v22 + 134) = 1;
      if (_mdns_resolver_log_s_once != -1)
        dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
      v24 = _mdns_resolver_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 67109120;
        v30 = 10;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_INFO, "Got suspicious response, entering suspicious mode for %d seconds", buf, 8u);
      }
    }
    _mdns_resolver_deregister_querier(*(_QWORD *)(a3 + 64), a3);
    _mdns_resolver_register_querier_ex(*(_QWORD *)(a3 + 64), (_WORD *)a3, 1);
    goto LABEL_49;
  }
  _mdns_querier_conclude_ex(a3, 5, -6729, 0);
}

uint64_t _mdns_querier_is_response_acceptable(uint64_t a1, uint64_t a2, BOOL *a3, _BYTE *a4, _WORD *a5)
{
  unint64_t v7;
  uint64_t v11;
  uint64_t result;
  uint64_t v13;
  char v14;
  BOOL v15;
  char v16;
  __int16 v17;

  v7 = *(_QWORD *)(a2 + 40);
  if (v7 < 0xC)
  {
    result = 0;
LABEL_21:
    v16 = 0;
    if (!a4)
      return result;
    goto LABEL_18;
  }
  v17 = 0;
  v11 = *(_QWORD *)(a2 + 32);
  result = _mdns_message_is_query_response_ex((char *)v11, v7, *(_QWORD *)(a1 + 88), &v17, 0, 0);
  if (!(_DWORD)result)
    goto LABEL_21;
  v13 = *(_QWORD *)(a1 + 88);
  if (v17 == *(_WORD *)(v13 + 68))
  {
    v14 = *(_BYTE *)(v11 + 3);
    if (a3)
    {
      v15 = (*(_BYTE *)(v11 + 2) & 2) != 0
         && ((*(_BYTE *)(v13 + 70) & 4) != 0
          || !__rev16(*(unsigned __int16 *)(v11 + 6))
          || !__rev16(*(unsigned __int16 *)(v11 + 8)) && !__rev16(*(unsigned __int16 *)(v11 + 10)));
      *a3 = v15;
    }
    if (a5)
      *a5 = v14 & 0xF;
    result = 1;
  }
  else
  {
    result = 0;
  }
  v16 = 1;
  if (a4)
LABEL_18:
    *a4 = v16 & (result ^ 1);
  return result;
}

void _mdns_resolver_log_receive(uint64_t a1, uint64_t a2, _QWORD *a3, int a4, const char *a5, int a6)
{
  const char *v10;
  unint64_t v11;
  uint64_t v12;
  int v13;
  const char *interface_log_string;
  uint64_t v15;
  _QWORD *v16;
  uint64_t (*v17)(_QWORD *, _QWORD, uint64_t);
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  const char *v24;
  NSObject *v25;
  uint32_t v26;
  _QWORD *v27;
  uint64_t (*v28)(_QWORD *, _QWORD, uint64_t);
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  const char *v37;
  NSObject *v38;
  uint32_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  const char *v44;
  __int16 v45;
  int v46;
  __int16 v47;
  unint64_t v48;
  __int16 v49;
  uint64_t v50;
  __int16 v51;
  int v52;
  __int16 v53;
  const char *v54;
  __int16 v55;
  _BYTE v56[28];

  if (a5)
    v10 = a5;
  else
    v10 = "";
  v11 = a3[5];
  v12 = 152;
  if (!*(_BYTE *)(a2 + 89))
    v12 = 148;
  v13 = *(_DWORD *)(*(_QWORD *)(a1 + 16) + v12);
  interface_log_string = _mdns_resolver_get_interface_log_string(a1);
  if (v11 < 0xC)
  {
    if (a6)
    {
      v27 = a3 + 2;
      while (1)
      {
        v27 = (_QWORD *)*v27;
        if (!v27)
          break;
        v28 = (uint64_t (*)(_QWORD *, _QWORD, uint64_t))v27[3];
        if (v28)
        {
          v29 = v28(a3, 0, 1);
          if (!v29)
            break;
          v19 = (void *)v29;
          if (_mdns_resolver_log_s_once != -1)
            dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
          v30 = _mdns_resolver_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
          {
            v31 = *(_QWORD *)(a2 + 32);
            v32 = a3[4];
            v43 = 136448258;
            v44 = v10;
            v45 = 1024;
            v46 = a4;
            v47 = 2048;
            v48 = v11;
            v49 = 2112;
            v50 = v31;
            v51 = 1024;
            v52 = v13;
            v53 = 2082;
            v54 = interface_log_string;
            v55 = 1040;
            *(_DWORD *)v56 = v11;
            *(_WORD *)&v56[4] = 2098;
            *(_QWORD *)&v56[6] = v32;
            *(_WORD *)&v56[14] = 2082;
            *(_QWORD *)&v56[16] = v19;
            v24 = "%{public}sReceived %{mdns:acceptable}d %zu-byte response from %@ over %{mdns:protocol}d via %{public}s"
                  " -- %{public,mdns:dnshdr}.*P, %{public}s";
            v25 = v30;
            v26 = 80;
LABEL_25:
            _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, v24, (uint8_t *)&v43, v26);
          }
LABEL_26:
          free(v19);
          return;
        }
      }
    }
    if (_mdns_resolver_log_s_once != -1)
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    v40 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      v41 = *(_QWORD *)(a2 + 32);
      v42 = a3[4];
      v43 = 136448258;
      v44 = v10;
      v45 = 1024;
      v46 = a4;
      v47 = 2048;
      v48 = v11;
      v49 = 2112;
      v50 = v41;
      v51 = 1024;
      v52 = v13;
      v53 = 2082;
      v54 = interface_log_string;
      v55 = 1040;
      *(_DWORD *)v56 = v11;
      *(_WORD *)&v56[4] = 2098;
      *(_QWORD *)&v56[6] = v42;
      *(_WORD *)&v56[14] = 2112;
      *(_QWORD *)&v56[16] = a3;
      v37 = "%{public}sReceived %{mdns:acceptable}d %zu-byte response from %@ over %{mdns:protocol}d via %{public}s -- %{"
            "public,mdns:dnshdr}.*P, %@";
      v38 = v40;
      v39 = 80;
      goto LABEL_35;
    }
  }
  else
  {
    v15 = a3[4];
    if (a6)
    {
      v16 = a3 + 2;
      while (1)
      {
        v16 = (_QWORD *)*v16;
        if (!v16)
          break;
        v17 = (uint64_t (*)(_QWORD *, _QWORD, uint64_t))v16[3];
        if (v17)
        {
          v18 = v17(a3, 0, 1);
          if (!v18)
            break;
          v19 = (void *)v18;
          if (_mdns_resolver_log_s_once != -1)
            dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
          v20 = _mdns_resolver_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
          {
            v21 = *(_QWORD *)(a2 + 32);
            v22 = bswap32(*(_DWORD *)v15);
            v23 = bswap64(*(_QWORD *)(v15 + 4));
            v43 = 136448258;
            v44 = v10;
            v45 = 1024;
            v46 = a4;
            v47 = 2048;
            v48 = v11;
            v49 = 2112;
            v50 = v21;
            v51 = 1024;
            v52 = v13;
            v53 = 2082;
            v54 = interface_log_string;
            v55 = 2048;
            *(_QWORD *)v56 = v22;
            *(_WORD *)&v56[8] = 2048;
            *(_QWORD *)&v56[10] = v23;
            *(_WORD *)&v56[18] = 2082;
            *(_QWORD *)&v56[20] = v19;
            v24 = "%{public}sReceived %{mdns:acceptable}d %zu-byte response from %@ over %{mdns:protocol}d via %{public}s"
                  " -- %{mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX, %{public}s";
            v25 = v20;
            v26 = 84;
            goto LABEL_25;
          }
          goto LABEL_26;
        }
      }
    }
    if (_mdns_resolver_log_s_once != -1)
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    v33 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      v34 = *(_QWORD *)(a2 + 32);
      v35 = bswap32(*(_DWORD *)v15);
      v36 = bswap64(*(_QWORD *)(v15 + 4));
      v43 = 136448258;
      v44 = v10;
      v45 = 1024;
      v46 = a4;
      v47 = 2048;
      v48 = v11;
      v49 = 2112;
      v50 = v34;
      v51 = 1024;
      v52 = v13;
      v53 = 2082;
      v54 = interface_log_string;
      v55 = 2048;
      *(_QWORD *)v56 = v35;
      *(_WORD *)&v56[8] = 2048;
      *(_QWORD *)&v56[10] = v36;
      *(_WORD *)&v56[18] = 2112;
      *(_QWORD *)&v56[20] = a3;
      v37 = "%{public}sReceived %{mdns:acceptable}d %zu-byte response from %@ over %{mdns:protocol}d via %{public}s -- %{"
            "mdns:dns.idflags}08lX, counts: %{mdns:dns.counts}016llX, %@";
      v38 = v33;
      v39 = 84;
LABEL_35:
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, v37, (uint8_t *)&v43, v39);
    }
  }
}

void _mdns_resolver_note_responsiveness(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  const sockaddr *address;
  unsigned int v9;
  unsigned int v10;
  NSObject *oneshot_timer;
  uint64_t v12;
  NSObject *v13;
  unsigned int v14;
  NSObject *v15;
  int v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;
  NSObject *v20;
  void **v21;
  __int128 v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  if (a4 - *(_QWORD *)(a2 + 80) >= 1)
    *(_QWORD *)(a2 + 80) = a4;
  if ((a5 & 0xFFFFFFFE) == 0x40 && !*(_BYTE *)(a2 + 107))
    *(_BYTE *)(a2 + 107) = 1;
  _mdns_resolver_unpenalize_server(a1, a2, 1);
  if (*(_BYTE *)(a2 + 109))
  {
    *(_BYTE *)(a2 + 109) = 0;
    if (*(_BYTE *)(a1 + 132))
    {
      if (nw_endpoint_get_type(*(nw_endpoint_t *)(a2 + 48)) == nw_endpoint_type_address)
      {
        address = nw_endpoint_get_address(*(nw_endpoint_t *)(a2 + 48));
        _mdns_symptoms_report_dns_server_symptom(413698, (uint64_t)address);
      }
    }
  }
  if (!a3)
  {
    if (!*(_QWORD *)(a2 + 40))
    {
      v9 = *(_DWORD *)(a1 + 124);
      if (v9 / 0xA + v9 <= v9)
        v10 = *(_DWORD *)(a1 + 124);
      else
        v10 = v9 / 0xA + v9;
      oneshot_timer = _mdns_resolver_create_oneshot_timer(v10, 5u);
      *(_QWORD *)(a2 + 40) = oneshot_timer;
      if (oneshot_timer)
      {
        v12 = mach_continuous_time();
        v13 = *(NSObject **)(a2 + 40);
        v21 = _NSConcreteStackBlock;
        *(_QWORD *)&v22 = 0x40000000;
        *((_QWORD *)&v22 + 1) = ___mdns_resolver_schedule_fast_recovery_check_block_invoke;
        v23 = &__block_descriptor_tmp_114_4728;
        v24 = a2;
        v25 = a1;
        v26 = v12;
        dispatch_source_set_event_handler(v13, &v21);
        dispatch_activate(*(dispatch_object_t *)(a2 + 40));
      }
      else
      {
        if (_mdns_resolver_log_s_once != -1)
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
        v20 = _mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v21) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Failed to create fast recovery timer", (uint8_t *)&v21, 2u);
        }
      }
    }
    goto LABEL_31;
  }
  if (!*(_BYTE *)(*(_QWORD *)(a1 + 16) + 158))
    goto LABEL_31;
  if (*(_BYTE *)(a2 + 110))
  {
    *(_DWORD *)(a2 + 96) = 0;
    *(_BYTE *)(a2 + 110) = 0;
  }
  else
  {
    v14 = *(_DWORD *)(a2 + 96);
    *(_DWORD *)(a2 + 96) = 0;
    *(_BYTE *)(a2 + 110) = 0;
    if (v14 < 3)
      goto LABEL_25;
  }
  if (_mdns_resolver_log_s_once != -1)
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
  v15 = _mdns_resolver_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEFAULT))
  {
    v16 = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 152);
    LODWORD(v21) = 67109378;
    HIDWORD(v21) = v16;
    LOWORD(v22) = 2112;
    *(_QWORD *)((char *)&v22 + 2) = a2;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Cleared stream problems with %{mdns:protocol}d server %@", (uint8_t *)&v21, 0x12u);
  }
LABEL_25:
  if (*(_BYTE *)(a1 + 139))
  {
    v17 = *(_QWORD *)(a1 + 24);
    if (v17)
    {
      while ((*(char *)(v17 + 106) - 1) > 3 || *(_BYTE *)(v17 + 110) || *(_DWORD *)(v17 + 96) >= 3u)
      {
        v17 = *(_QWORD *)(v17 + 24);
        if (!v17)
          goto LABEL_31;
      }
      *(_BYTE *)(a1 + 139) = 0;
      v18 = *(NSObject **)(a1 + 104);
      if (v18)
      {
        dispatch_source_cancel(*(dispatch_source_t *)(a1 + 104));
        dispatch_release(v18);
        *(_QWORD *)(a1 + 104) = 0;
      }
      v19 = *(_QWORD *)(a1 + 112);
      if (v19)
      {
        mdns_client_invalidate(v19);
        os_release(*(void **)(a1 + 112));
        *(_QWORD *)(a1 + 112) = 0;
      }
      _mdns_resolver_generate_connection_event(a1);
      os_retain((void *)a1);
      if (_mdns_resolver_queue_s_once != -1)
        dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
      v21 = _NSConcreteStackBlock;
      *(_QWORD *)&v22 = 0x40000000;
      *((_QWORD *)&v22 + 1) = ___mdns_resolver_start_serverless_queries_async_block_invoke;
      v23 = &__block_descriptor_tmp_113_4726;
      v24 = a1;
      dispatch_async((dispatch_queue_t)_mdns_resolver_queue_s_queue, &v21);
    }
  }
LABEL_31:
  _mdns_resolver_start_pending_queriers(a1);
}

void _mdns_querier_handle_bad_rcode(uint64_t a1, void *object, int a3, uint64_t a4)
{
  int v8;
  int v9;
  void *v10;
  void *v11;
  _QWORD *v12;

  if ((*(_DWORD *)(a4 + 100) - 1) >= 0x20)
    v8 = 0;
  else
    v8 = 1 << (*(_BYTE *)(a4 + 100) - 1);
  *(_DWORD *)(a1 + 228) |= v8;
  v9 = *(__int16 *)(a1 + 244);
  v10 = *(void **)(a1 + 144);
  if (v9 < 0)
  {
    if (v10)
    {
      os_release(v10);
      *(_QWORD *)(a1 + 144) = 0;
    }
    *(_WORD *)(a1 + 244) = 0;
  }
  else if (v10 && (a3 == 5 || v9 != 5))
  {
    goto LABEL_15;
  }
  os_retain(object);
  v11 = *(void **)(a1 + 144);
  if (v11)
    os_release(v11);
  *(_QWORD *)(a1 + 144) = object;
  *(_WORD *)(a1 + 244) = a3;
LABEL_15:
  if (a3 == 5)
    _mdns_resolver_penalize_server_ex(*(_QWORD *)(a1 + 64), a4, 0, 0, 0);
  if (_mdns_resolver_get_server(*(_QWORD *)(a1 + 64), *(_DWORD *)(a1 + 228)))
  {
    if (*(_QWORD *)(a1 + 72) == a4)
    {
      *(_QWORD *)(a1 + 72) = 0;
      *(_BYTE *)(a1 + 247) = 0;
      _mdns_querier_initiate_send(a1);
    }
  }
  else
  {
    v12 = *(_QWORD **)(a1 + 144);
    *(_QWORD *)(a1 + 144) = 0;
    _mdns_querier_conclude_ex(a1, 1, 0, v12);
    os_release(v12);
  }
}

uint64_t _mdns_message_is_query_response_ex(char *a1, unint64_t a2, uint64_t a3, _WORD *a4, _WORD *a5, char a6)
{
  unsigned int v10;
  uint64_t result;
  int v12;
  _OWORD v13[16];

  if (a2 < 0xC)
    return 0;
  v10 = __rev16(*(unsigned __int16 *)a1);
  if (!a4 && v10 != *(unsigned __int16 *)(a3 + 68))
    return 0;
  if ((a1[2] & 0xF8) != 0x80)
    return 0;
  if (__rev16(*((unsigned __int16 *)a1 + 2)) != 1)
    return 0;
  v12 = 0;
  memset(v13, 0, sizeof(v13));
  if (DNSMessageExtractQuestion((unint64_t)a1, a2, a1 + 12, (char *)v13, (_WORD *)&v12 + 1, &v12, 0))return 0;
  if ((a6 & 1) == 0)
  {
    result = DomainNameEqual((unsigned __int8 *)v13, *(unsigned __int8 **)(*(_QWORD *)(a3 + 56) + 24));
    if (!(_DWORD)result)
      return result;
  }
  if (!a5 && HIWORD(v12) != *(unsigned __int16 *)(a3 + 64) || (unsigned __int16)v12 != *(unsigned __int16 *)(a3 + 66))
    return 0;
  if (a4)
    *a4 = v10;
  if (a5)
    *a5 = HIWORD(v12);
  return 1;
}

BOOL _mdns_qtype_is_address_type(int a1)
{
  return a1 == 1 || a1 == 28;
}

BOOL _mdns_qtype_is_problematic(int a1)
{
  return (a1 & 0xFFFFFFFE) == 64;
}

void _mdns_resolver_unpenalize_server(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t *v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  BOOL v8;
  NSObject *v9;
  const char *v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;

  if (!*(_BYTE *)(a2 + 108))
    return;
  v4 = (uint64_t *)(a1 + 24);
  v5 = (_QWORD *)(a1 + 24);
  do
  {
    v6 = v5;
    v7 = *v5;
    v5 = (_QWORD *)(*v5 + 24);
    if (v7)
      v8 = v7 == a2;
    else
      v8 = 1;
  }
  while (!v8);
  if (!v7)
    return;
  *v6 = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a2 + 24) = 0;
  *(_BYTE *)(a2 + 108) = 0;
  if (a3)
  {
    if (_mdns_resolver_log_s_once != -1)
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    v9 = _mdns_resolver_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
      goto LABEL_19;
    v14 = 138412290;
    v15 = a2;
    v10 = "Unpenalizing responsive server %@";
  }
  else
  {
    if (_mdns_resolver_log_s_once != -1)
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    v9 = _mdns_resolver_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
      goto LABEL_19;
    v14 = 138412290;
    v15 = a2;
    v10 = "Unpenalizing server %@";
  }
  _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, v10, (uint8_t *)&v14, 0xCu);
LABEL_19:
  v11 = *v4;
  if (*v4)
  {
    if (!*(_BYTE *)(v11 + 108))
    {
      v12 = *(_DWORD *)(a2 + 100);
      if (*(_DWORD *)(v11 + 100) <= v12)
      {
        do
        {
          v13 = v11;
          v11 = *(_QWORD *)(v11 + 24);
        }
        while (v11 && !*(_BYTE *)(v11 + 108) && *(_DWORD *)(v11 + 100) <= v12);
        v4 = (uint64_t *)(v13 + 24);
      }
    }
  }
  *(_QWORD *)(a2 + 24) = v11;
  *v4 = a2;
}

void ___mdns_resolver_start_serverless_queries_async_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;

  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 136))
  {
    v3 = *(_QWORD *)(v2 + 24);
    if (v3)
    {
      while ((*(char *)(v3 + 106) - 1) > 3)
      {
        v3 = *(_QWORD *)(v3 + 24);
        if (!v3)
          goto LABEL_14;
      }
      v4 = *(_QWORD *)(v2 + 32);
      if (v4)
      {
        do
        {
          if (!*(_QWORD *)(v4 + 72))
          {
            *(_QWORD *)(v4 + 72) = 0;
            *(_BYTE *)(v4 + 247) = 0;
            if (*(_BYTE *)(v4 + 251))
              v5 = 2000;
            else
              v5 = *(_DWORD *)(*(_QWORD *)(v4 + 64) + 124);
            *(_DWORD *)(v4 + 204) = v5;
            _mdns_querier_initiate_send(v4);
          }
          v4 = *(_QWORD *)(v4 + 56);
        }
        while (v4);
        v2 = *(_QWORD *)(a1 + 32);
      }
    }
  }
LABEL_14:
  os_release((void *)v2);
}

void ___mdns_resolver_schedule_fast_recovery_check_block_invoke(_QWORD *a1)
{
  uint64_t v2;
  NSObject *v3;

  v2 = a1[4];
  v3 = *(NSObject **)(v2 + 40);
  if (v3)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(v2 + 40));
    dispatch_release(v3);
    *(_QWORD *)(a1[4] + 40) = 0;
    v2 = a1[4];
  }
  _mdns_resolver_handle_revived_server(a1[5], v2, 0, a1[6]);
}

void _mdns_resolver_handle_revived_server(uint64_t a1, uint64_t a2, char a3, uint64_t a4)
{
  int v5;
  uint64_t i;
  uint64_t v8;
  _QWORD *v9;
  NSObject *v10;
  const char *v11;
  int v12;
  uint8_t buf[4];
  const char *v15;

  if (!*(_BYTE *)(a1 + 136) && (*(char *)(a2 + 106) - 5) >= 0xFFFFFFFC)
  {
    v5 = (*(_DWORD *)(a2 + 100) - 1) >= 0x20 ? 0 : 1 << (*(_BYTE *)(a2 + 100) - 1);
    for (i = *(_QWORD *)(a1 + 32); i; i = *(_QWORD *)(i + 56))
    {
      if ((*(_DWORD *)(i + 228) & v5) == 0)
      {
        v8 = *(_QWORD *)(i + 72);
        if (*(_BYTE *)(i + 251))
        {
          if (!v8)
            goto LABEL_22;
        }
        else
        {
          if ((a3 & 1) == 0)
          {
            if (!*(_BYTE *)(a2 + 107)
              && ((*(uint64_t (**)(uint64_t))(*(_QWORD *)(i + 16) + 88))(i) & 0xFFFE) == 0x40)
            {
              continue;
            }
            v9 = *(_QWORD **)(i + 104);
            if (v9)
            {
              while (v9[4] != a2)
              {
                v9 = (_QWORD *)v9[3];
                if (!v9)
                  goto LABEL_19;
              }
              if (v9[8] - a4 > 0)
                continue;
            }
          }
LABEL_19:
          if (!v8 || v8 == a2 || *(_BYTE *)(v8 + 109))
          {
LABEL_22:
            *(_DWORD *)(i + 212) &= ~v5;
            if (_mdns_resolver_log_s_once != -1)
              dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
            v10 = _mdns_resolver_log_s_log;
            if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
            {
              v11 = *(const char **)(i + 128);
              if (!v11)
                v11 = "";
              *(_DWORD *)buf = 136446210;
              v15 = v11;
              _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "%{public}sRestarting querier", buf, 0xCu);
            }
            *(_QWORD *)(i + 72) = 0;
            *(_BYTE *)(i + 247) = 0;
            if (*(_BYTE *)(i + 251))
              v12 = 2000;
            else
              v12 = *(_DWORD *)(*(_QWORD *)(i + 64) + 124);
            *(_DWORD *)(i + 204) = v12;
            _mdns_querier_initiate_send(i);
          }
        }
      }
    }
  }
}

void _mdns_resolver_generate_error_event(NSObject **a1, int a2)
{
  xpc_object_t v4;

  v4 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_int64(v4, "error_code", a2);
  _mdns_resolver_generate_event(a1, 3, v4);
  if (v4)
    xpc_release(v4);
}

uint64_t _mdns_resolver_handle_stream_error(uint64_t a1, uint64_t a2, const char *a3)
{
  uint64_t v6;
  unint64_t v7;
  unsigned int v8;
  BOOL v9;
  int v10;
  _BOOL4 v11;

  if (*(_BYTE *)(*(_QWORD *)(a1 + 16) + 158))
  {
    v6 = mach_continuous_time();
    v7 = v6 - *(_QWORD *)(a2 + 88);
    if (mdns_mach_ticks_per_second_s_once != -1)
      dispatch_once(&mdns_mach_ticks_per_second_s_once, &__block_literal_global_3428);
    if (v7 >= mdns_mach_ticks_per_second_s_ticks_per_second)
    {
      v8 = *(_DWORD *)(a2 + 96);
      if (*(_BYTE *)(a2 + 110))
        v9 = 1;
      else
        v9 = v8 >= 3;
      v10 = !v9;
      *(_QWORD *)(a2 + 88) = v6;
      if (v8 == -1)
      {
        v11 = 1;
      }
      else
      {
        *(_DWORD *)(a2 + 96) = v8 + 1;
        v11 = v8 > 1;
      }
      if ((v10 & v11) == 1)
        _mdns_resolver_log_server_problems(a1, a2, a3);
    }
    _mdns_resolver_check_for_problematic_servers(a1);
  }
  return *(unsigned __int8 *)(a1 + 139);
}

void _mdns_querier_handle_stream_termination(int8x8_t *a1, uint64_t a2)
{
  unsigned int v3;
  unsigned int v4;
  int8x8_t v5;
  uint64_t eligible_server;
  uint64_t v7;

  v3 = *(_DWORD *)(a2 + 100) - 1;
  if (v3 < 0x20)
    v4 = ~(1 << v3);
  else
    v4 = -1;
  a1[27] = vand_s8((int8x8_t)vdup_n_s32(v4), a1[27]);
  v5 = a1[9];
  if (*(_QWORD *)&v5 != a2)
  {
    if (*(_QWORD *)&v5 || *(_QWORD *)&a1[12])
      return;
LABEL_14:
    _mdns_querier_initiate_send((uint64_t)a1);
    return;
  }
  eligible_server = _mdns_querier_get_eligible_server((uint64_t)a1);
  if (eligible_server)
  {
    if (*(_BYTE *)(eligible_server + 108))
      v7 = 0;
    else
      v7 = eligible_server;
  }
  else
  {
    v7 = 0;
  }
  _mdns_querier_set_current_server((uint64_t)a1, v7);
  if (a1[9])
    goto LABEL_14;
}

uint64_t _mdns_resolver_handle_stream_lateness(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  unsigned int v5;

  if (*(_BYTE *)(*(_QWORD *)(a1 + 16) + 158) && a3 - *(_QWORD *)(a2 + 80) >= 1)
  {
    if (*(_BYTE *)(a2 + 110))
    {
      *(_BYTE *)(a2 + 110) = 1;
    }
    else
    {
      v5 = *(_DWORD *)(a2 + 96);
      *(_BYTE *)(a2 + 110) = 1;
      if (v5 <= 2)
        _mdns_resolver_log_server_problems(a1, a2, a4);
    }
    _mdns_resolver_check_for_problematic_servers(a1);
  }
  return *(unsigned __int8 *)(a1 + 139);
}

void _mdns_resolver_log_server_problems(uint64_t a1, uint64_t a2, const char *a3)
{
  NSObject *v6;
  const char *v7;
  int v8;
  int v9;
  int v10;
  int v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  uint64_t v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;

  if (_mdns_resolver_log_s_once != -1)
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
  v6 = _mdns_resolver_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
  {
    v7 = "";
    v8 = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 152);
    if (a3)
      v7 = a3;
    v9 = *(unsigned __int8 *)(a2 + 110);
    v10 = *(_DWORD *)(a2 + 96);
    v11 = 136447234;
    v12 = v7;
    v13 = 1024;
    v14 = v8;
    v15 = 2112;
    v16 = a2;
    v17 = 1024;
    v18 = v9;
    v19 = 1024;
    v20 = v10;
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "%{public}sHaving stream problems with %{mdns:protocol}d server %@ -- lateness: %{BOOL}d, error count: %u", (uint8_t *)&v11, 0x28u);
  }
}

uint64_t ___mdns_session_activate_block_invoke(uint64_t a1)
{
  uint64_t result;
  NSObject *v3;
  uint64_t (**v4)(uint64_t, uint64_t, _QWORD, _QWORD);

  result = *(_QWORD *)(a1 + 32);
  v3 = *(NSObject **)(result + 40);
  if (v3)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(result + 40));
    dispatch_release(v3);
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 40) = 0;
    result = *(_QWORD *)(a1 + 32);
  }
  if (*(_BYTE *)(result + 88) == 1)
  {
    v4 = *(uint64_t (***)(uint64_t, uint64_t, _QWORD, _QWORD))(result + 72);
    if (*v4)
      return (*v4)(result, 2, 0, *(_QWORD *)(result + 48));
  }
  return result;
}

void _mdns_common_session_terminate_async(void *a1, int a2)
{
  _QWORD v4[5];
  int v5;

  os_retain(a1);
  if (_mdns_resolver_queue_s_once != -1)
    dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = ___mdns_common_session_terminate_async_block_invoke;
  v4[3] = &__block_descriptor_tmp_109;
  v4[4] = a1;
  v5 = a2;
  dispatch_async((dispatch_queue_t)_mdns_resolver_queue_s_queue, v4);
}

void ___mdns_common_session_terminate_async_block_invoke(uint64_t a1)
{
  _mdns_common_session_finish(*(_QWORD *)(a1 + 32), 3, *(unsigned int *)(a1 + 40));
  os_release(*(void **)(a1 + 32));
}

void _mdns_common_session_finish(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void (**v6)(uint64_t, uint64_t, uint64_t, _QWORD);

  if (*(_BYTE *)(a1 + 88) != 3)
  {
    _mdns_session_invalidate_internal(a1);
    *(_BYTE *)(a1 + 88) = 3;
    v6 = *(void (***)(uint64_t, uint64_t, uint64_t, _QWORD))(a1 + 72);
    if (*v6)
      (*v6)(a1, a2, a3, *(_QWORD *)(a1 + 48));
  }
}

void _mdns_resolver_session_handle_event(uint64_t a1, int a2, int a3, uint64_t a4)
{
  NSObject *v8;
  BOOL v9;
  os_log_type_t v10;
  int v11;
  uint64_t i;
  uint64_t v13;
  int8x8_t *j;
  _DWORD v15[2];
  __int16 v16;
  uint64_t v17;

  if (_mdns_resolver_log_s_once != -1)
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
  v8 = _mdns_resolver_log_s_log;
  if (a3)
    v9 = a2 == 3;
  else
    v9 = 0;
  if (v9)
    v10 = OS_LOG_TYPE_ERROR;
  else
    v10 = OS_LOG_TYPE_INFO;
  if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, v10))
  {
    v15[0] = 67109376;
    v15[1] = a2;
    v16 = 2048;
    v17 = a3;
    _os_log_impl((void *)&_mh_execute_header, v8, v10, "Resolver session event -- type: %{mdns:session_event}d, error: %{mdns:err}ld", (uint8_t *)v15, 0x12u);
  }
  if ((a2 - 3) >= 2)
  {
    if (a2 == 2)
    {
      _mdns_resolver_handle_stream_lateness(a4, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 56), 0);
    }
    else if (a2 == 1)
    {
      v11 = (*(_DWORD *)(*(_QWORD *)(a1 + 32) + 100) - 1) >= 0x20
          ? 0
          : 1 << (*(_BYTE *)(*(_QWORD *)(a1 + 32) + 100) - 1);
      for (i = *(_QWORD *)(a4 + 32); i; i = *(_QWORD *)(i + 56))
      {
        if (*(_BYTE *)(i + 251))
        {
          if ((*(_DWORD *)(i + 216) & v11) != 0)
            _mdns_querier_send_query(i, a1);
        }
      }
    }
    return;
  }
  v13 = *(_QWORD *)(a4 + 24);
  if (!v13)
    return;
  while (*(_QWORD *)(v13 + 32) != a1)
  {
    v13 = *(_QWORD *)(v13 + 24);
    if (!v13)
      return;
  }
  if (a1)
  {
    _mdns_session_invalidate((_BYTE *)a1);
    os_release(*(void **)(v13 + 32));
    *(_QWORD *)(v13 + 32) = 0;
  }
  if (a2 == 3)
  {
    if (a3)
    {
      _mdns_resolver_generate_error_event((NSObject **)a4, a3);
LABEL_33:
      _mdns_resolver_handle_stream_error(a4, v13, 0);
      _mdns_resolver_penalize_server_ex(a4, v13, 0, 0, 0);
      goto LABEL_35;
    }
    if (!*(_DWORD *)(a1 + 84))
      goto LABEL_33;
  }
LABEL_35:
  for (j = *(int8x8_t **)(a4 + 32); j; j = (int8x8_t *)j[7])
  {
    if (j[31].i8[3])
      _mdns_querier_handle_stream_termination(j, v13);
  }
}

void _mdns_resolver_session_receive(uint64_t a1, NSObject *a2, uint64_t a3)
{
  _BYTE *v5;
  _QWORD *v6;
  uint64_t v7;
  char v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  __int16 v16;

  v5 = mdns_message_create_with_dispatch_data(a2, 1);
  if (!v5)
    return;
  v6 = v5;
  v7 = *(_QWORD *)(a3 + 32);
  if (!v7)
    goto LABEL_19;
  v8 = 0;
  do
  {
    while (1)
    {
      v9 = v7;
      v7 = *(_QWORD *)(v7 + 56);
      v16 = 0;
      if (_mdns_querier_is_response_acceptable(v9, (uint64_t)v6, 0, 0, &v16))
        break;
LABEL_15:
      if (!v7)
        goto LABEL_18;
    }
    if ((v8 & 1) == 0)
    {
      if (*(_QWORD *)(v9 + 128))
        v10 = *(const char **)(v9 + 128);
      else
        v10 = "";
      _mdns_resolver_log_receive(a3, a1, v6, 1, v10, *(unsigned __int8 *)(v9 + 255));
    }
    v11 = *(_QWORD *)(a1 + 32);
    v12 = *(unsigned __int8 *)(a1 + 89);
    v13 = *(_QWORD *)(a1 + 56);
    v14 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)(v9 + 16) + 88))(v9);
    _mdns_resolver_note_responsiveness(a3, v11, v12, v13, v14);
    if (v16 <= 9 && ((1 << v16) & 0x209) != 0)
    {
      v8 = 1;
      _mdns_querier_conclude_ex(v9, 1, 0, v6);
      goto LABEL_15;
    }
    _mdns_querier_handle_bad_rcode(v9, v6, v16, *(_QWORD *)(a1 + 32));
    v8 = 1;
  }
  while (v7);
LABEL_18:
  if ((v8 & 1) == 0)
LABEL_19:
    _mdns_resolver_log_receive(a3, a1, v6, 0, 0, 0);
  os_release(v6);
}

void _mdns_url_session_finalize(_QWORD *a1)
{
  void *v2;
  void *v3;
  void *v4;

  v2 = (void *)a1[14];
  if (v2)
  {
    nw_release(v2);
    a1[14] = 0;
  }
  v3 = (void *)a1[15];
  if (v3)
  {
    nw_release(v3);
    a1[15] = 0;
  }
  _mdns_url_session_forget_crypto(a1);
  v4 = (void *)a1[23];
  if (v4)
  {
    os_release(v4);
    a1[23] = 0;
  }
}

uint64_t _mdns_url_session_initialize(uint64_t a1, _QWORD *a2)
{
  void *v4;
  uint64_t (*v5)(_QWORD *, unsigned int *);
  NSObject *v6;
  uint64_t result;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  NSObject *v11;
  uint64_t v12;
  const char *v13;
  unsigned int v14;
  uint8_t buf[4];
  const char *v16;

  v14 = 0;
  if (*(_DWORD *)(a2[2] + 144) == 4)
    v4 = a2;
  else
    v4 = 0;
  *(_QWORD *)(a1 + 184) = v4;
  if (v4)
  {
    os_retain(v4);
    v5 = *(uint64_t (**)(_QWORD *, unsigned int *))(a2[2] + 112);
    if (v5)
    {
      v6 = v5(a2, &v14);
      result = v14;
      if (!v14)
      {
        v8 = nw_parameters_copy_url_endpoint(v6);
        *(_QWORD *)(a1 + 112) = v8;
        if (v8)
        {
          v9 = nw_parameters_copy(v6);
          *(_QWORD *)(a1 + 120) = v9;
          v10 = nw_parameters_copy_default_protocol_stack(v9);
          nw_protocol_stack_clear_application_protocols(v10);
          if (v10)
            nw_release(v10);
          nw_parameters_set_metadata(*(_QWORD *)(a1 + 120), 0);
          nw_parameters_set_fast_open_enabled(*(nw_parameters_t *)(a1 + 120), 1);
          return v14;
        }
        else
        {
          return 4294960567;
        }
      }
    }
    else
    {
      return 4294960561;
    }
  }
  else
  {
    if (_mdns_resolver_log_s_once != -1)
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    v11 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_FAULT))
    {
      v12 = *(unsigned int *)(a2[2] + 144);
      if (v12 > 4)
        v13 = "<INVALID RESOLVER TYPE>";
      else
        v13 = off_10013DC98[v12];
      *(_DWORD *)buf = 136446210;
      v16 = v13;
      _os_log_fault_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, "Trying to initialize an mdns_url_session using a non-https resolver of type %{public}s", buf, 0xCu);
    }
    return 4294960540;
  }
  return result;
}

uint64_t _mdns_url_session_activate(_QWORD *a1)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t v3;

  if (*(_QWORD *)(a1[23] + 176))
  {
    if ((unint64_t)g_pending_odoh_connection_count >= 0xA)
    {
      v1 = &g_pending_odoh_sessions;
      do
      {
        v2 = v1;
        v3 = *v1;
        v1 = (uint64_t *)(*v1 + 104);
      }
      while (v3);
      *v2 = (uint64_t)a1;
      os_retain(a1);
      _mdns_url_session_schedule_interrupt_for_oldest_active_odoh_session();
    }
    else
    {
      _mdns_url_session_activate_for_odoh(a1);
    }
  }
  else
  {
    _mdns_common_session_make_ready_async(a1);
  }
  return 0;
}

void _mdns_url_session_invalidate(_QWORD *a1)
{
  NSObject *v2;
  uint64_t v3;
  void *v4;
  void *v5;
  void *v6;
  uint64_t *v7;
  uint64_t *v8;
  _QWORD *v9;
  BOOL v10;
  NSObject *v11;
  NSObject *v12;
  uint64_t *v13;
  uint64_t *v14;
  _QWORD *v15;
  BOOL v16;
  NSObject *v17;
  void *v18;
  int v19;
  uint64_t v20;

  v2 = a1[16];
  if (v2)
  {
    v3 = a1[17];
    if (v3)
    {
      nw_connection_end_activity();
      nw_activity_complete_with_reason(v3, 4);
      v2 = a1[16];
    }
    nw_connection_cancel(v2);
    v4 = (void *)a1[16];
    if (v4)
    {
      nw_release(v4);
      a1[16] = 0;
    }
  }
  v5 = (void *)a1[17];
  if (v5)
  {
    nw_release(v5);
    a1[17] = 0;
  }
  v6 = (void *)a1[18];
  if (v6)
  {
    http_task_cancel(v6);
    a1[18] = 0;
  }
  _mdns_url_session_forget_crypto(a1);
  _mdns_url_session_handle_connection_no_longer_pending((uint64_t)a1);
  v7 = &g_active_odoh_sessions;
  do
  {
    v8 = v7;
    v9 = (_QWORD *)*v7;
    v7 = (uint64_t *)(*v7 + 104);
    if (v9)
      v10 = v9 == a1;
    else
      v10 = 1;
  }
  while (!v10);
  if (v9)
  {
    *v8 = a1[13];
    a1[13] = 0;
    os_release(a1);
    --g_active_odoh_session_count;
    if (_mdns_resolver_log_s_once != -1)
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    v11 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEBUG))
    {
      v19 = 134217984;
      v20 = g_active_odoh_session_count;
      _os_log_debug_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "Active ODoH session count decrease: %zu", (uint8_t *)&v19, 0xCu);
    }
    v12 = g_active_odoh_session_interrupt_timer;
    if (g_active_odoh_session_interrupt_timer)
    {
      dispatch_source_cancel((dispatch_source_t)g_active_odoh_session_interrupt_timer);
      dispatch_release(v12);
      g_active_odoh_session_interrupt_timer = 0;
    }
    if (g_pending_odoh_sessions)
      _mdns_url_session_schedule_interrupt_for_oldest_active_odoh_session();
  }
  else
  {
    v13 = &g_pending_odoh_sessions;
    do
    {
      v14 = v13;
      v15 = (_QWORD *)*v13;
      v13 = (uint64_t *)(*v13 + 104);
      if (v15)
        v16 = v15 == a1;
      else
        v16 = 1;
    }
    while (!v16);
    if (v15)
    {
      *v14 = a1[13];
      a1[13] = 0;
      os_release(a1);
    }
    if (!g_pending_odoh_sessions)
    {
      v17 = g_active_odoh_session_interrupt_timer;
      if (g_active_odoh_session_interrupt_timer)
      {
        dispatch_source_cancel((dispatch_source_t)g_active_odoh_session_interrupt_timer);
        dispatch_release(v17);
        g_active_odoh_session_interrupt_timer = 0;
      }
    }
  }
  v18 = (void *)a1[23];
  if (v18)
  {
    os_release(v18);
    a1[23] = 0;
  }
}

void _mdns_url_session_send(uint64_t a1, NSObject *a2, unsigned int a3)
{
  size_t p_applier;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  _BOOL4 v10;
  size_t length;
  unsigned __int16 *bytes_ptr;
  void *options;
  int v14;
  NSObject *v15;
  NSObject *v16;
  NSObject *v17;
  nw_connection_t v18;
  NSObject *v19;
  void *v20;
  NSObject *v21;
  NSObject *v22;
  uint64_t v23;
  void *v24;
  const char *v25;
  const char *v26;
  size_t v27;
  uint64_t v28;
  const char *v29;
  void *v30;
  NSObject *metadata_for_request;
  NSObject *v32;
  NSObject *v33;
  void *v34;
  const char *url;
  _QWORD *v36;
  id v37;
  id v38;
  void *v39;
  id v40;
  id v41;
  __CFString *v42;
  void *v43;
  void *v44;
  void *v45;
  void *v46;
  void *v47;
  id v48;
  unsigned int v49;
  id v50;
  __CFString *v51;
  NSObject *v52;
  NSObject *v53;
  NSString *v54;
  void *v55;
  uint64_t v56;
  uint64_t v57;
  void *v58;
  id v59;
  _QWORD *v60;
  id v61;
  void *v62;
  void *v63;
  id v64;
  void *v65;
  void *v66;
  void *v67;
  uint64_t v68;
  const char *v69;
  uint64_t v70;
  unint64_t v71;
  unint64_t v72;
  BOOL v73;
  uint64_t v74;
  NSObject *v75;
  int v76;
  const char *v77;
  uint8_t *v78;
  uint64_t v79;
  void *v80;
  void *v81;
  int v82;
  int v83;
  uint64_t v84;
  NSObject *v85;
  uint32_t v86;
  char *v87;
  char *v88;
  void *v89;
  int v90;
  void *v91;
  int v92;
  NSObject *v93;
  void *v94;
  void *v95;
  void *v96;
  uint64_t v97;
  int v98;
  int v99;
  NSObject *v100;
  _WORD *v101;
  void *v102;
  int v103;
  int v104;
  NSObject *v105;
  dispatch_data_t v106;
  NSObject *v107;
  NSObject *v108;
  uint64_t v109;
  uint32_t v110;
  size_t v111;
  void *v112;
  size_t v113;
  NSObject *v114;
  uint64_t v115;
  void *context;
  char *contexta;
  size_t size;
  uint64_t sizea;
  NSObject *buffer;
  void *buffera;
  void *bufferb;
  unsigned int v123;
  id v124;
  _QWORD v125[5];
  BOOL v126;
  _QWORD completion[5];
  BOOL v128;
  char v129;
  _QWORD handler[5];
  __int128 applier;
  __int128 v132;
  __int128 v133;
  __int128 v134;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  __int128 v138;
  size_t v139;
  uint64_t v140;
  void *v141;
  uint8_t buf[8];
  uint8_t *v143;
  uint64_t v144;
  uint64_t (*v145)(uint64_t, uint64_t);
  void (*v146)(uint64_t);
  id v147;

  if (_mdns_resolver_log_s_once != -1)
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
  p_applier = (size_t)&applier;
  v7 = _mdns_resolver_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEBUG))
  {
    v70 = *(_QWORD *)(a1 + 112);
    LODWORD(applier) = 138412290;
    *(_QWORD *)((char *)&applier + 4) = v70;
    _os_log_debug_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "Sending message on URL %@", (uint8_t *)&applier, 0xCu);
  }
  v8 = *(_QWORD *)(a1 + 184);
  if (!v8)
  {
    v112 = 0;
    v114 = 0;
    v10 = 0;
    goto LABEL_47;
  }
  v123 = a3;
  v9 = *(_QWORD *)(v8 + 168);
  v10 = v9 != 0;
  if (!v9)
  {
    options = 0;
    v14 = 0;
    v15 = 0;
    goto LABEL_23;
  }
  length = xpc_data_get_length(*(xpc_object_t *)(v8 + 168));
  bytes_ptr = (unsigned __int16 *)xpc_data_get_bytes_ptr(*(xpc_object_t *)(v8 + 168));
  if (nw_http_oblivious_config_is_valid(bytes_ptr, length))
  {
    *(_QWORD *)&applier = 0;
    if (nw_endpoint_get_port(*(nw_endpoint_t *)(a1 + 112)) == 443)
    {
      nw_endpoint_get_hostname(*(nw_endpoint_t *)(a1 + 112));
      nw_endpoint_get_url_path(*(_QWORD *)(a1 + 112));
      asprintf((char **)&applier, "/dns-query?targethost=%s&targetpath=%s");
    }
    else
    {
      nw_endpoint_get_hostname(*(nw_endpoint_t *)(a1 + 112));
      nw_endpoint_get_url_path(*(_QWORD *)(a1 + 112));
      asprintf((char **)&applier, "/dns-query?targethost=%s:%u&targetpath=%s");
    }
    options = (void *)nw_oblivious_http_create_options(bytes_ptr, length, applier);
    if ((_QWORD)applier)
    {
      free((void *)applier);
      *(_QWORD *)&applier = 0;
    }
    if (options)
    {
      v15 = 0;
      v14 = 1;
      goto LABEL_23;
    }
    if (_mdns_resolver_log_s_once != -1)
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    v75 = _mdns_resolver_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
    {
LABEL_87:
      options = 0;
      v15 = 0;
LABEL_88:
      v76 = -6700;
      goto LABEL_89;
    }
    *(_WORD *)buf = 0;
    v77 = "Failed to create oblivious http options";
    v78 = buf;
LABEL_92:
    _os_log_error_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_ERROR, v77, v78, 2u);
    goto LABEL_87;
  }
  if (!a2 || !bytes_ptr)
  {
    if (_mdns_crypto_log_s_once != -1)
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_120);
    v68 = _mdns_crypto_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
      goto LABEL_83;
    *(_WORD *)buf = 0;
    v69 = "Parameters are NULL";
LABEL_110:
    v85 = v68;
    v86 = 2;
LABEL_111:
    _os_log_error_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_ERROR, v69, buf, v86);
    goto LABEL_83;
  }
  if (length <= 1)
  {
    if (_mdns_crypto_log_s_once == -1)
    {
LABEL_16:
      v16 = _mdns_crypto_log_s_log;
      if (!os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
      {
LABEL_82:
        v68 = _mdns_crypto_log_s_log;
        if (!os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
        {
LABEL_83:
          v74 = _mdns_resolver_log_s_once;
LABEL_84:
          if (v74 != -1)
            dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
          v75 = _mdns_resolver_log_s_log;
          if (!os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
            goto LABEL_87;
          LOWORD(applier) = 0;
          v77 = "Failed to create oblivious request";
          v78 = (uint8_t *)&applier;
          goto LABEL_92;
        }
        *(_WORD *)buf = 0;
        v69 = "Failed to parse supported config";
        goto LABEL_110;
      }
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)(p_applier + 164) = length;
      _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Config length is too short: %zu", buf, 0xCu);
LABEL_80:
      if (_mdns_crypto_log_s_once != -1)
        dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_120);
      goto LABEL_82;
    }
LABEL_144:
    dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_120);
    goto LABEL_16;
  }
  v71 = bswap32(*bytes_ptr) >> 16;
  if (length - 2 == v71)
  {
    ++bytes_ptr;
    while (!mdns_odoh_config_is_valid_inner(bytes_ptr, v71))
    {
      if (v71 >= 4)
      {
        v72 = bswap32(bytes_ptr[1]) >> 16;
        bytes_ptr = (unsigned __int16 *)((char *)bytes_ptr + v72);
        v73 = v71 > v72;
        v71 -= v72;
        if (v73)
          continue;
      }
      goto LABEL_80;
    }
    if (!bytes_ptr)
      goto LABEL_80;
  }
  else if (!mdns_odoh_config_is_valid_inner(bytes_ptr, length))
  {
    goto LABEL_80;
  }
  v79 = cchpke_params_x25519_AESGCM128_HKDF_SHA256();
  p_applier = cchpke_params_sizeof_kdf_hash();
  buffera = (void *)ccsha256_di(p_applier);
  if (!p_applier)
    goto LABEL_143;
  length = bytes_ptr[5];
  v80 = malloc_type_calloc(1uLL, p_applier, 0xF1748037uLL);
  if (!v80)
    goto LABEL_143;
  v81 = v80;
  v82 = cchkdf_extract(buffera, 0, 0, (bswap32(length) >> 16) + 8, bytes_ptr + 2, v80);
  if (v82)
  {
    v83 = v82;
    free(v81);
    if (_mdns_crypto_log_s_once != -1)
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_120);
    v84 = _mdns_crypto_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
      goto LABEL_83;
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v83;
    v69 = "Extract error: %d";
    v85 = v84;
    v86 = 8;
    goto LABEL_111;
  }
  v111 = dispatch_data_get_size(a2);
  v110 = arc4random_uniform(0x10u);
  sizea = v111 + v110 + 4;
  length = cchpke_params_sizeof_aead_tag(v79);
  v115 = v79;
  v113 = length;
  contexta = (char *)cchpke_params_sizeof_kem_enc(v79);
  v87 = &contexta[length + sizea];
  if (&v87[p_applier] == (char *)-5)
    goto LABEL_143;
  length = 1;
  v109 = (uint64_t)&v87[p_applier + 5];
  v88 = (char *)malloc_type_calloc(1uLL, v109, 0xF1748037uLL);
  if (!v88)
    goto LABEL_143;
  *v88 = 1;
  *(_WORD *)(v88 + 1) = bswap32(p_applier) >> 16;
  v89 = v88;
  v90 = cchkdf_expand(buffera, p_applier, v81, 11, "odoh key id", p_applier, v88 + 3);
  v91 = v81;
  v92 = v90;
  free(v91);
  if (v92)
  {
    if (_mdns_crypto_log_s_once != -1)
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_120);
    v93 = _mdns_crypto_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v92;
      _os_log_error_impl((void *)&_mh_execute_header, v93, OS_LOG_TYPE_ERROR, "Expand error: %d", buf, 8u);
    }
    v94 = v89;
    goto LABEL_127;
  }
  p_applier += 3;
  bufferb = v89;
  length = (size_t)v89 + p_applier;
  *(_WORD *)length = bswap32(v87) >> 16;
  v95 = malloc_type_calloc(1uLL, 0x60uLL, 0xF1748037uLL);
  if (!v95)
    goto LABEL_143;
  v96 = v95;
  LODWORD(v141) = 0;
  v97 = ccrng(&v141);
  length += 2;
  v98 = cchpke_initiator_setup(v96, v115, v97, bswap32(bytes_ptr[5]) >> 16, bytes_ptr + 6, 10, "odoh query", contexta, length);
  if (v98)
  {
    v99 = v98;
    if (_mdns_crypto_log_s_once != -1)
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_120);
    v100 = _mdns_crypto_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v99;
      _os_log_error_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_ERROR, "Setup error: %d", buf, 8u);
    }
LABEL_126:
    free(bufferb);
    v94 = v96;
LABEL_127:
    free(v94);
    goto LABEL_83;
  }
  if (v111 + v110 == -4 || (v101 = malloc_type_calloc(1uLL, sizea, 0xF1748037uLL)) == 0)
  {
LABEL_143:
    __break(1u);
    goto LABEL_144;
  }
  v102 = v101;
  *v101 = bswap32(v111) >> 16;
  *(_WORD *)((char *)v101 + v111 + 2) = bswap32(v110) >> 16;
  *(_QWORD *)&applier = _NSConcreteStackBlock;
  *((_QWORD *)&applier + 1) = 0x40000000;
  *(_QWORD *)&v132 = __mdns_encrypt_oblivious_request_block_invoke;
  *((_QWORD *)&v132 + 1) = &__block_descriptor_tmp_129;
  *(_QWORD *)&v133 = v101 + 1;
  dispatch_data_apply(a2, &applier);
  v103 = cchpke_initiator_encrypt(v96, p_applier, bufferb, sizea, v102, &contexta[length], v113, &contexta[length + sizea]);
  if (v103)
  {
    v104 = v103;
    if (_mdns_crypto_log_s_once != -1)
      dispatch_once(&_mdns_crypto_log_s_once, &__block_literal_global_120);
    v105 = _mdns_crypto_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_crypto_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v104;
      _os_log_error_impl((void *)&_mh_execute_header, v105, OS_LOG_TYPE_ERROR, "Encrypt error: %d", buf, 8u);
    }
    free(v102);
    goto LABEL_126;
  }
  *(_QWORD *)(a1 + 152) = v96;
  *(_QWORD *)(a1 + 160) = 96;
  *(_QWORD *)(a1 + 168) = v102;
  *(_QWORD *)(a1 + 176) = sizea;
  v106 = dispatch_data_create(bufferb, v109, 0, _dispatch_data_destructor_free);
  v74 = _mdns_resolver_log_s_once;
  if (!v106)
    goto LABEL_84;
  v15 = v106;
  if (_mdns_resolver_log_s_once != -1)
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
  v107 = _mdns_resolver_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEBUG))
  {
    LOWORD(applier) = 0;
    _os_log_debug_impl((void *)&_mh_execute_header, v107, OS_LOG_TYPE_DEBUG, "Created oblivious request", (uint8_t *)&applier, 2u);
  }
  options = 0;
  v14 = 0;
  a2 = v15;
LABEL_23:
  if (!*(_QWORD *)(v8 + 176))
  {
    v112 = options;
    v114 = v15;
    a3 = v123;
LABEL_47:
    os_retain((void *)a1);
    v34 = *(void **)(*(_QWORD *)(a1 + 32) + 48);
    url = nw_endpoint_get_url(*(nw_endpoint_t *)(a1 + 112));
    size = *(_QWORD *)(v8 + 192);
    v125[0] = _NSConcreteStackBlock;
    v125[1] = 0x40000000;
    v125[2] = ___mdns_url_session_send_block_invoke_104;
    v125[3] = &__block_descriptor_tmp_106;
    v125[4] = a1;
    v126 = v10;
    v124 = v34;
    buffer = a2;
    v36 = v125;
    context = objc_autoreleasePoolPush();
    if (v10)
    {
      v37 = objc_alloc((Class)NSMutableURLRequest);
      v38 = objc_alloc((Class)NSURL);
      v39 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", url));
      v40 = objc_msgSend(v38, "initWithString:", v39);
      v41 = objc_msgSend(v37, "initWithURL:", v40);

      objc_msgSend(v41, "setHTTPMethod:", CFSTR("POST"));
      objc_msgSend(v41, "setHTTPBody:", buffer);
      v42 = CFSTR("application/oblivious-dns-message");
    }
    else
    {
      v43 = (void *)objc_claimAutoreleasedReturnValue(-[NSObject base64EncodedStringWithOptions:](buffer, "base64EncodedStringWithOptions:", 0));
      v44 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v43, "stringByReplacingOccurrencesOfString:withString:", CFSTR("/"), CFSTR("_")));

      v45 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v44, "stringByReplacingOccurrencesOfString:withString:", CFSTR("+"), CFSTR("-")));
      v46 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v45, "stringByReplacingOccurrencesOfString:withString:", CFSTR("="), &stru_10013FAA0));

      v47 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s?dns=%@"), url, v46));
      v48 = objc_alloc((Class)NSMutableURLRequest);
      v49 = a3;
      v50 = objc_msgSend(objc_alloc((Class)NSURL), "initWithString:", v47);
      v41 = objc_msgSend(v48, "initWithURL:", v50);

      a3 = v49;
      objc_msgSend(v41, "setHTTPMethod:", CFSTR("GET"));

      v42 = CFSTR("application/dns-message");
    }
    v51 = v42;
    objc_msgSend(v41, "setValue:forHTTPHeaderField:", v51, CFSTR("accept"));
    objc_msgSend(v41, "setValue:forHTTPHeaderField:", v51, CFSTR("content-type"));
    v52 = nw_endpoint_copy_interface(v124);
    v53 = v52;
    if (v52)
    {
      v54 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", nw_interface_get_name(v52));
      v55 = (void *)objc_claimAutoreleasedReturnValue(v54);
      objc_msgSend(v41, "setBoundInterfaceIdentifier:", v55);

    }
    *(_QWORD *)buf = 0;
    v143 = buf;
    v144 = 0x3032000000;
    v145 = __Block_byref_object_copy_;
    v146 = __Block_byref_object_dispose_;
    v147 = 0;
    if (a3 == 28)
    {
      v56 = 2;
    }
    else
    {
      if (a3 != 1)
      {
LABEL_58:
        *(_QWORD *)&applier = _NSConcreteStackBlock;
        *((_QWORD *)&applier + 1) = 3221225472;
        *(_QWORD *)&v132 = __http_task_create_dns_query_block_invoke;
        *((_QWORD *)&v132 + 1) = &unk_100139D30;
        *(_QWORD *)&v134 = buf;
        v59 = v41;
        *(_QWORD *)&v133 = v59;
        v60 = v36;
        *((_QWORD *)&v133 + 1) = v60;
        v61 = _http_task_create_data_task(v59, &applier);
        v62 = (void *)objc_claimAutoreleasedReturnValue(v61);
        objc_msgSend(v62, "set_hostOverride:", v124);
        if (v62 && *((_QWORD *)v143 + 5))
          objc_msgSend(v62, "set_nw_activity:");
        if (size)
        {
          v63 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v62, "_effectiveConfiguration"));
          v64 = objc_msgSend(objc_alloc((Class)NSURLSessionConfiguration), "_initWithConfiguration:", v63);
          v139 = size;
          v140 = _kCFStreamPropertySSLClientCertificates;
          v65 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v139, 1));
          v141 = v65;
          v66 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v141, &v140, 1));
          objc_msgSend(v64, "set_socketStreamProperties:", v66);

          objc_msgSend(v62, "_adoptEffectiveConfiguration:", v64);
        }

        _Block_object_dispose(buf, 8);
        objc_autoreleasePoolPop(context);

        *(_QWORD *)(a1 + 144) = v62;
        if (v62)
        {
          v67 = objc_autoreleasePoolPush();
          objc_msgSend(v62, "resume");
          objc_autoreleasePoolPop(v67);
          options = v112;
          v15 = v114;
          if (!v112)
            goto LABEL_66;
          goto LABEL_65;
        }
        os_release((void *)a1);
        if (_mdns_resolver_log_s_once != -1)
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
        options = v112;
        v15 = v114;
        v108 = _mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
        {
          LOWORD(applier) = 0;
          _os_log_error_impl((void *)&_mh_execute_header, v108, OS_LOG_TYPE_ERROR, "Failed to create HTTP task", (uint8_t *)&applier, 2u);
        }
        goto LABEL_88;
      }
      v56 = 1;
    }
    v57 = nw_activity_create(33, v56);
    v58 = (void *)*((_QWORD *)v143 + 5);
    *((_QWORD *)v143 + 5) = v57;

    if (*((_QWORD *)v143 + 5))
      nw_activity_activate();
    goto LABEL_58;
  }
  nw_parameters_clear_custom_proxy_configs(*(_QWORD *)(a1 + 120));
  nw_parameters_add_custom_proxy_config(*(_QWORD *)(a1 + 120), *(_QWORD *)(v8 + 176));
  if (options)
  {
    v17 = nw_parameters_copy_default_protocol_stack(*(nw_parameters_t *)(a1 + 120));
    nw_protocol_stack_clear_application_protocols(v17);
    nw_protocol_stack_append_application_protocol(v17, options);
    if (v17)
      nw_release(v17);
  }
  v18 = nw_connection_create(*(nw_endpoint_t *)(a1 + 112), *(nw_parameters_t *)(a1 + 120));
  *(_QWORD *)(a1 + 128) = v18;
  if (!v18)
  {
    v76 = -6729;
LABEL_89:
    _mdns_common_session_terminate_async((void *)a1, v76);
    if (!options)
      goto LABEL_66;
LABEL_65:
    nw_release(options);
    goto LABEL_66;
  }
  os_retain((void *)a1);
  v19 = *(NSObject **)(a1 + 128);
  v20 = options;
  v21 = v15;
  if (_mdns_resolver_queue_s_once != -1)
    dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
  nw_connection_set_queue(v19, (dispatch_queue_t)_mdns_resolver_queue_s_queue);
  v22 = *(NSObject **)(a1 + 128);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 0x40000000;
  handler[2] = ___mdns_url_session_send_block_invoke;
  handler[3] = &__block_descriptor_tmp_91;
  handler[4] = a1;
  nw_connection_set_state_changed_handler(v22, handler);
  v23 = nw_http_fields_create();
  v24 = (void *)v23;
  if (v9)
    v25 = "Oblivious Message";
  else
    v25 = "HTTP Message";
  if (((v9 != 0) & (v14 ^ 1)) != 0)
    v26 = "application/oblivious-dns-message";
  else
    v26 = "application/dns-message";
  nw_http_fields_set_value_by_name(v23, nw_http_field_name_accept, v26);
  nw_http_fields_set_value_by_name(v24, nw_http_field_name_content_type, v26);
  v27 = dispatch_data_get_size(a2);
  v137 = 0u;
  v138 = 0u;
  v135 = 0u;
  v136 = 0u;
  v133 = 0u;
  v134 = 0u;
  applier = 0u;
  v132 = 0u;
  snprintf((char *)&applier, 0x80uLL, "%zu", v27);
  nw_http_fields_set_value_by_name(v24, nw_http_field_name_content_length, &applier);
  v28 = nw_http_request_method_post;
  v29 = nw_endpoint_get_url(*(nw_endpoint_t *)(a1 + 112));
  v30 = (void *)nw_http_request_create_from_url(v28, v29);
  nw_http_request_set_header_fields(v30, v24);
  metadata_for_request = nw_http_create_metadata_for_request(v30);
  if (v30)
    nw_release(v30);
  v32 = nw_content_context_create(v25);
  nw_content_context_set_metadata_for_protocol(v32, metadata_for_request);
  if (metadata_for_request)
    nw_release(metadata_for_request);
  if (v24)
    nw_release(v24);
  nw_content_context_set_is_final(v32, 1);
  nw_connection_send(*(nw_connection_t *)(a1 + 128), a2, v32, 1, _nw_connection_send_idempotent_content);
  if (v32)
    nw_release(v32);
  nw_connection_start(*(nw_connection_t *)(a1 + 128));
  *(_QWORD *)(a1 + 136) = _mdns_create_and_start_connection_activity(*(_QWORD *)(a1 + 128), v123);
  v33 = *(NSObject **)(a1 + 128);
  completion[0] = _NSConcreteStackBlock;
  completion[1] = 0x40000000;
  completion[2] = ___mdns_url_session_send_block_invoke_96;
  completion[3] = &__block_descriptor_tmp_103;
  completion[4] = a1;
  v128 = v9 != 0;
  v129 = v14;
  nw_connection_receive_message(v33, completion);
  v15 = v21;
  options = v20;
  if (v20)
    goto LABEL_65;
LABEL_66:
  if (v15)
    dispatch_release(v15);
}

void sub_1000CDE00(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 176), 8);
  _Unwind_Resume(a1);
}

void ___mdns_url_session_send_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  __int16 v12;
  uint64_t v13;
  __int16 v14;
  uint64_t v15;

  v5 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(v5 + 128))
  {
    if (_mdns_resolver_log_s_once != -1)
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    v7 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEBUG))
    {
      v8 = nw_connection_state_to_string(a2);
      v9 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 128);
      v10 = 136315650;
      v11 = v8;
      v12 = 2112;
      v13 = v9;
      v14 = 2112;
      v15 = a3;
      _os_log_debug_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "Connection state changed to %s for connection %@ error %@", (uint8_t *)&v10, 0x20u);
    }
    switch((_DWORD)a2)
    {
      case 3:
        _mdns_url_session_handle_connection_no_longer_pending(*(_QWORD *)(a1 + 32));
        break;
      case 4:
        _mdns_common_session_finish(*(_QWORD *)(a1 + 32), 3, 4294960543);
        break;
      case 5:
        v5 = *(_QWORD *)(a1 + 32);
LABEL_10:
        _mdns_url_session_handle_connection_no_longer_pending(v5);
        os_release(*(void **)(a1 + 32));
        break;
    }
  }
  else if ((_DWORD)a2 == 5)
  {
    goto LABEL_10;
  }
}

uint64_t _mdns_create_and_start_connection_activity(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  if ((_DWORD)a2 != 1)
  {
    if ((_DWORD)a2 != 28)
      return 0;
    a2 = 2;
  }
  v3 = nw_activity_create(33, a2);
  if (v3)
    nw_connection_start_activity(a1, v3);
  return v3;
}

void ___mdns_url_session_send_block_invoke_96(uint64_t a1, uint64_t error_code, NSObject *a3, uint64_t a4, NSObject *a5)
{
  NSObject *v9;
  NSObject *v10;
  void *v11;
  void *v12;
  NSObject *v13;
  os_log_type_t v15;
  const char *v16;
  NSObject *v17;
  int v18;
  char v19;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  char v30;
  _QWORD v31[5];
  uint8_t buf[4];
  _QWORD v33[3];
  __int128 v34;
  uint64_t v35;
  uint64_t v36;

  if (!*(_QWORD *)(*(_QWORD *)(a1 + 32) + 128))
    return;
  if (_mdns_resolver_log_s_once != -1)
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
  v9 = _mdns_resolver_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEBUG))
  {
    LODWORD(v34) = 134217984;
    *(_QWORD *)((char *)&v34 + 4) = error_code;
    _os_log_debug_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "Received data %p", (uint8_t *)&v34, 0xCu);
  }
  *(_QWORD *)&v34 = 0;
  *((_QWORD *)&v34 + 1) = &v34;
  v35 = 0x2000000000;
  v36 = 0;
  if (a3)
  {
    v10 = nw_protocol_copy_http_definition();
    a3 = nw_content_context_copy_protocol_metadata(a3, v10);
    if (v10)
      nw_release(v10);
    if (a3)
    {
      v11 = (void *)nw_http_metadata_copy_response(a3);
      nw_release(a3);
      if (v11)
      {
        LODWORD(a3) = nw_http_response_get_status_code(v11);
        v12 = (void *)nw_http_response_copy_header_fields(v11);
        v31[0] = _NSConcreteStackBlock;
        v31[1] = 0x40000000;
        v31[2] = ___mdns_url_session_send_block_invoke_98;
        v31[3] = &unk_10013DA70;
        v31[4] = &v34;
        nw_http_fields_access_value_by_name(v12, "client-address", v31);
        if (v12)
          nw_release(v12);
        nw_release(v11);
      }
      else
      {
        LODWORD(a3) = 0;
      }
    }
  }
  if (_mdns_resolver_log_s_once != -1)
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
  v13 = _mdns_resolver_log_s_log;
  if ((_DWORD)a3 != 200 || error_code == 0)
    v15 = OS_LOG_TYPE_INFO;
  else
    v15 = OS_LOG_TYPE_DEBUG;
  if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, v15))
  {
    v16 = "";
    if (!error_code)
      v16 = "out";
    *(_DWORD *)buf = 67109378;
    LODWORD(v33[0]) = (_DWORD)a3;
    WORD2(v33[0]) = 2082;
    *(_QWORD *)((char *)v33 + 6) = v16;
    _os_log_impl((void *)&_mh_execute_header, v13, v15, "Received HTTP status %u with%{public}s body", buf, 0x12u);
  }
  if (error_code)
  {
    if (*(_BYTE *)(a1 + 40))
    {
      if (*(_BYTE *)(a1 + 41))
      {
        v17 = 0;
      }
      else
      {
        error_code = (uint64_t)mdns_decrypt_oblivious_response(error_code, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 152), *(_QWORD *)(*(_QWORD *)(a1 + 32) + 160), *(const void **)(*(_QWORD *)(a1 + 32) + 168), *(_QWORD *)(*(_QWORD *)(a1 + 32) + 176));
        if (_mdns_resolver_log_s_once != -1)
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
        v21 = _mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 138412290;
          v33[0] = error_code;
          _os_log_debug_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEBUG, "Decrypted %@", buf, 0xCu);
        }
        v17 = error_code;
        if (!error_code)
        {
          v19 = 0;
          v18 = 0;
          error_code = 4294960520;
          goto LABEL_47;
        }
      }
      v22 = *(NSObject **)(*((_QWORD *)&v34 + 1) + 24);
      if (v22)
        _mdns_https_resolver_set_client_address(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 184), v22);
      v23 = *(_QWORD *)(a1 + 32);
      v24 = *(_QWORD *)(v23 + 184);
      if (!*(_BYTE *)(v24 + 230))
      {
        *(_BYTE *)(v24 + 230) = 1;
        _mdns_resolver_generate_error_event((NSObject **)v24, 0);
        v23 = *(_QWORD *)(a1 + 32);
      }
      _mdns_common_session_invoke_receive(v23, error_code);
      if (v17)
        dispatch_release(v17);
    }
    else
    {
      v20 = *(NSObject **)(*((_QWORD *)&v34 + 1) + 24);
      if (v20)
        _mdns_https_resolver_set_client_address(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 184), v20);
      _mdns_common_session_invoke_receive(*(_QWORD *)(a1 + 32), error_code);
    }
    error_code = 0;
    v19 = 1;
    v18 = 1;
  }
  else
  {
    v18 = 0;
    v19 = 1;
  }
LABEL_47:
  v25 = *(void **)(*((_QWORD *)&v34 + 1) + 24);
  if (v25)
  {
    nw_release(v25);
    *(_QWORD *)(*((_QWORD *)&v34 + 1) + 24) = 0;
  }
  v26 = *(_QWORD *)(a1 + 32);
  v27 = *(_QWORD *)(v26 + 136);
  if (v27)
  {
    v28 = v18 ? 2 : 3;
    nw_connection_end_activity(*(_QWORD *)(v26 + 128), v27);
    nw_activity_complete_with_reason(v27, v28);
    v29 = *(void **)(*(_QWORD *)(a1 + 32) + 136);
    if (v29)
    {
      nw_release(v29);
      *(_QWORD *)(*(_QWORD *)(a1 + 32) + 136) = 0;
    }
  }
  if ((v18 & 1) != 0)
  {
    v30 = v19 ^ 1;
    if (!a5)
      v30 = 1;
    if ((v30 & 1) == 0)
      error_code = nw_error_get_error_code(a5);
  }
  else
  {
    if ((_DWORD)a3 == 401)
    {
      error_code = 4294960520;
    }
    else if ((_DWORD)a3)
    {
      error_code = 4294960560;
    }
    else if (a5)
    {
      error_code = nw_error_get_error_code(a5);
    }
    else
    {
      error_code = 4294960543;
    }
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 184) + 230) = 0;
  }
  _mdns_common_session_finish(*(_QWORD *)(a1 + 32), 3, error_code);
  _Block_object_dispose(&v34, 8);
}

void ___mdns_url_session_send_block_invoke_104(uint64_t a1, NSObject *a2, int a3, uint64_t a4)
{
  uint64_t v4;
  int v9;
  NSObject *v10;
  NSObject *v11;
  NSObject *v12;
  NSObject *v13;
  unsigned int Code;
  int v15;
  uint64_t v16;

  v4 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(v4 + 144))
  {
    v9 = *(unsigned __int8 *)(a1 + 40);
    if (_mdns_resolver_log_s_once != -1)
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    v10 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEBUG))
    {
      v15 = 138412290;
      v16 = (uint64_t)a2;
      _os_log_debug_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "Received response %@", (uint8_t *)&v15, 0xCu);
      if (a2)
      {
LABEL_6:
        if (v9)
        {
          v11 = mdns_decrypt_oblivious_response(a2, *(_QWORD *)(v4 + 152), *(_QWORD *)(v4 + 160), *(const void **)(v4 + 168), *(_QWORD *)(v4 + 176));
          if (_mdns_resolver_log_s_once != -1)
            dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
          v12 = _mdns_resolver_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEBUG))
          {
            v15 = 138412290;
            v16 = (uint64_t)v11;
            _os_log_debug_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "Decrypted response %@", (uint8_t *)&v15, 0xCu);
          }
          a2 = v11;
          if (!v11)
          {
            if (a3 == 401)
              a4 = 4294960520;
            else
              a4 = 4294960519;
LABEL_29:
            _mdns_common_session_finish(*(_QWORD *)(a1 + 32), 3, a4);
            v4 = *(_QWORD *)(a1 + 32);
            goto LABEL_30;
          }
        }
        else
        {
          v11 = 0;
        }
        _mdns_common_session_invoke_receive(v4, (uint64_t)a2);
        if (!a4)
        {
LABEL_27:
          if (v11)
            dispatch_release(v11);
          goto LABEL_29;
        }
LABEL_20:
        if (_mdns_resolver_log_s_once != -1)
          dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
        v13 = _mdns_resolver_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
        {
          v15 = 138412290;
          v16 = a4;
          _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Got error %@", (uint8_t *)&v15, 0xCu);
        }
        Code = CFErrorGetCode((CFErrorRef)a4);
        if (Code)
          a4 = Code;
        else
          a4 = 4294960596;
        goto LABEL_27;
      }
    }
    else if (a2)
    {
      goto LABEL_6;
    }
    v11 = 0;
    if (!a4)
      goto LABEL_27;
    goto LABEL_20;
  }
LABEL_30:
  os_release((void *)v4);
}

void _mdns_common_session_invoke_receive(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  int v5;
  void (*v6)(uint64_t, uint64_t, _QWORD);

  if (*(_BYTE *)(a1 + 88) == 1)
  {
    v4 = *(NSObject **)(a1 + 40);
    if (v4)
    {
      dispatch_source_cancel(*(dispatch_source_t *)(a1 + 40));
      dispatch_release(v4);
      *(_QWORD *)(a1 + 40) = 0;
    }
    v5 = *(_DWORD *)(a1 + 84);
    if (v5 != -1)
      *(_DWORD *)(a1 + 84) = v5 + 1;
    v6 = *(void (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)(a1 + 72) + 8);
    if (v6)
      v6(a1, a2, *(_QWORD *)(a1 + 48));
  }
}

void ___mdns_url_session_send_block_invoke_98(uint64_t a1, char *hostname)
{
  NSObject *v3;
  uint64_t v4;
  int v5;
  uint64_t v6;

  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = nw_endpoint_create_host(hostname, "0");
  if (_mdns_resolver_log_s_once != -1)
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
  v3 = _mdns_resolver_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEBUG))
  {
    v4 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    v5 = 138412290;
    v6 = v4;
    _os_log_debug_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "Received client address %@", (uint8_t *)&v5, 0xCu);
  }
}

const sockaddr *_mdns_https_resolver_set_client_address(uint64_t a1, nw_endpoint_t endpoint)
{
  sockaddr *v2;
  const sockaddr *result;
  int sa_family;
  sockaddr v5;

  *(_QWORD *)(a1 + 200) = 0;
  v2 = (sockaddr *)(a1 + 200);
  *(_DWORD *)(a1 + 224) = 0;
  *(_QWORD *)(a1 + 208) = 0;
  *(_QWORD *)(a1 + 216) = 0;
  result = nw_endpoint_get_address(endpoint);
  if (result)
  {
    sa_family = result->sa_family;
    if (sa_family == 30)
    {
      v5 = *result;
      *(_OWORD *)&v2->sa_data[10] = *(_OWORD *)&result->sa_data[10];
    }
    else
    {
      if (sa_family != 2)
        return result;
      v5 = *result;
    }
    *v2 = v5;
  }
  return result;
}

void _mdns_url_session_handle_connection_no_longer_pending(uint64_t a1)
{
  unint64_t v1;
  uint64_t v2;
  BOOL v3;

  if (*(_BYTE *)(a1 + 192))
  {
    v1 = --g_pending_odoh_connection_count;
    *(_BYTE *)(a1 + 192) = 0;
    v2 = g_pending_odoh_sessions;
    if (g_pending_odoh_sessions)
      v3 = v1 > 9;
    else
      v3 = 1;
    if (!v3)
    {
      g_pending_odoh_sessions = *(_QWORD *)(g_pending_odoh_sessions + 104);
      *(_QWORD *)(v2 + 104) = 0;
      _mdns_url_session_activate_for_odoh((_BYTE *)v2);
      os_release((void *)v2);
    }
  }
}

void _mdns_url_session_activate_for_odoh(_BYTE *object)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  NSObject *v5;
  int v6;
  uint64_t v7;

  object[192] = 1;
  ++g_pending_odoh_connection_count;
  v2 = &g_active_odoh_sessions;
  do
  {
    v3 = v2;
    v4 = *v2;
    v2 = (uint64_t *)(*v2 + 104);
  }
  while (v4);
  *v3 = (uint64_t)object;
  os_retain(object);
  *((_QWORD *)object + 12) = mach_continuous_time();
  ++g_active_odoh_session_count;
  if (_mdns_resolver_log_s_once != -1)
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
  v5 = _mdns_resolver_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEBUG))
  {
    v6 = 134217984;
    v7 = g_active_odoh_session_count;
    _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Active ODoH session count increase: %zu", (uint8_t *)&v6, 0xCu);
  }
  _mdns_common_session_make_ready_async(object);
}

void _mdns_common_session_make_ready_async(void *a1)
{
  _QWORD block[5];

  os_retain(a1);
  if (_mdns_resolver_queue_s_once != -1)
    dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = ___mdns_common_session_make_ready_async_block_invoke;
  block[3] = &__block_descriptor_tmp_87_4773;
  block[4] = a1;
  dispatch_async((dispatch_queue_t)_mdns_resolver_queue_s_queue, block);
}

void ___mdns_common_session_make_ready_async_block_invoke(uint64_t a1)
{
  _mdns_common_session_invoke_ready_event_handler(*(_QWORD *)(a1 + 32));
  os_release(*(void **)(a1 + 32));
}

uint64_t _mdns_common_session_invoke_ready_event_handler(uint64_t result)
{
  uint64_t (**v1)(uint64_t, uint64_t, _QWORD, _QWORD);

  if (*(_BYTE *)(result + 88) == 1 && !*(_BYTE *)(result + 90))
  {
    *(_BYTE *)(result + 90) = 1;
    v1 = *(uint64_t (***)(uint64_t, uint64_t, _QWORD, _QWORD))(result + 72);
    if (*v1)
      return (*v1)(result, 1, 0, *(_QWORD *)(result + 48));
  }
  return result;
}

void _mdns_url_session_forget_crypto(_QWORD *a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v2 = (void *)a1[19];
  if (v2)
  {
    memset_s(v2, a1[20], 0, a1[20]);
    v3 = (void *)a1[19];
    if (v3)
    {
      free(v3);
      a1[19] = 0;
    }
  }
  a1[20] = 0;
  v4 = (void *)a1[21];
  if (v4)
  {
    memset_s(v4, a1[22], 0, a1[22]);
    v5 = (void *)a1[21];
    if (v5)
    {
      free(v5);
      a1[21] = 0;
    }
  }
  a1[22] = 0;
}

void _mdns_url_session_schedule_interrupt_for_oldest_active_odoh_session()
{
  _QWORD *v0;
  BOOL v1;
  uint64_t v2;
  unsigned int v3;
  _QWORD v4[5];
  _QWORD handler[5];

  v0 = (_QWORD *)g_active_odoh_sessions;
  if (g_active_odoh_sessions)
    v1 = g_active_odoh_session_interrupt_timer == 0;
  else
    v1 = 0;
  if (v1)
  {
    v2 = mach_continuous_time() - v0[12];
    if (mdns_mach_ticks_per_second_s_once != -1)
      dispatch_once(&mdns_mach_ticks_per_second_s_once, &__block_literal_global_3428);
    if (v2 / mdns_mach_ticks_per_second_s_ticks_per_second > 9)
      v3 = 0;
    else
      v3 = 10000
         - (1000 * (v2 % mdns_mach_ticks_per_second_s_ticks_per_second) / mdns_mach_ticks_per_second_s_ticks_per_second
          + 1000 * (v2 / mdns_mach_ticks_per_second_s_ticks_per_second));
    g_active_odoh_session_interrupt_timer = (uint64_t)_mdns_resolver_create_oneshot_timer(v3, 5u);
    if (g_active_odoh_session_interrupt_timer)
    {
      os_retain(v0);
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 0x40000000;
      handler[2] = ___mdns_url_session_schedule_interrupt_for_oldest_active_odoh_session_block_invoke;
      handler[3] = &__block_descriptor_tmp_85;
      handler[4] = v0;
      dispatch_source_set_event_handler((dispatch_source_t)g_active_odoh_session_interrupt_timer, handler);
      v4[0] = _NSConcreteStackBlock;
      v4[1] = 0x40000000;
      v4[2] = ___mdns_url_session_schedule_interrupt_for_oldest_active_odoh_session_block_invoke_2;
      v4[3] = &__block_descriptor_tmp_86;
      v4[4] = v0;
      dispatch_source_set_cancel_handler((dispatch_source_t)g_active_odoh_session_interrupt_timer, v4);
      dispatch_activate((dispatch_object_t)g_active_odoh_session_interrupt_timer);
    }
  }
}

void ___mdns_url_session_schedule_interrupt_for_oldest_active_odoh_session_block_invoke(uint64_t a1)
{
  NSObject *v2;

  v2 = g_active_odoh_session_interrupt_timer;
  if (g_active_odoh_session_interrupt_timer)
  {
    dispatch_source_cancel((dispatch_source_t)g_active_odoh_session_interrupt_timer);
    dispatch_release(v2);
    g_active_odoh_session_interrupt_timer = 0;
  }
  _mdns_common_session_finish(*(_QWORD *)(a1 + 32), 4, 0);
}

void ___mdns_url_session_schedule_interrupt_for_oldest_active_odoh_session_block_invoke_2(uint64_t a1)
{
  os_release(*(void **)(a1 + 32));
}

uint64_t _mdns_udp_socket_session_init(uint64_t result)
{
  *(_DWORD *)(result + 136) = -1;
  return result;
}

uint64_t _mdns_udp_socket_session_finalize(uint64_t a1)
{
  uint64_t result;

  result = *(unsigned int *)(a1 + 136);
  if ((result & 0x80000000) == 0)
  {
    result = close(result);
    *(_DWORD *)(a1 + 136) = -1;
  }
  return result;
}

uint64_t _mdns_udp_socket_session_initialize(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, unsigned __int8 *a5)
{
  const sockaddr *address;
  int sa_family;
  const sockaddr *v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  unsigned __int8 *v17;
  unsigned int v18;
  uint32_t v19;
  int v20;
  unsigned int v21;
  NSObject *v23;
  NSObject *v24;
  int v25;
  NSObject *v26;
  int v27;
  NSObject *v28;
  int v29;
  NSObject *v30;
  int v31;
  int v32;
  NSObject *v33;
  NSObject *v34;
  int v35;
  int v36;
  NSObject *v37;
  const char *v38;
  int v39;
  int v40;
  __int128 v41;
  int v42;
  int v43;
  NSObject *v44;
  const char *v45;
  uint64_t v46;
  NSObject *v47;
  size_t v48;
  _DWORD *v50;
  const sockaddr *v51;
  int v52;
  audit_token_t v53[32];
  _QWORD v54[2];
  uint8_t buf[4];
  _BYTE v56[10];
  unsigned int v57;

  address = nw_endpoint_get_address(*(nw_endpoint_t *)(*(_QWORD *)(a1 + 32) + 48));
  sa_family = address->sa_family;
  if (sa_family != 30 && sa_family != 2)
    return 4294960540;
  v12 = address;
  v54[0] = 0;
  v54[1] = 0;
  if (sa_family == 30)
  {
    if (*(_DWORD *)&address->sa_data[6] || *(_DWORD *)&address->sa_data[10])
      goto LABEL_9;
    v35 = *(_DWORD *)&address[1].sa_len;
    if (v35)
    {
      if (v35 == -65536)
      {
        v36 = *(_DWORD *)&address[1].sa_data[2];
LABEL_139:
        LOWORD(v54[0]) = 528;
        WORD1(v54[0]) = *(_WORD *)address->sa_data;
        HIDWORD(v54[0]) = v36;
        v12 = (const sockaddr *)v54;
        sa_family = 2;
        goto LABEL_10;
      }
    }
    else
    {
      v36 = *(_DWORD *)&address[1].sa_data[2];
      if ((v36 | 0x1000000) != 0x1000000)
        goto LABEL_139;
    }
LABEL_9:
    sa_family = 30;
  }
LABEL_10:
  if (sa_family == 2)
    v13 = 2;
  else
    v13 = 30;
  v14 = socket(v13, 2, 17);
  if ((v14 & 0x80000000) != 0)
  {
    if (*__error())
    {
      v16 = *__error();
      if (!(_DWORD)v16)
        goto LABEL_16;
    }
    else
    {
      v16 = 4294960596;
    }
    if (_mdns_resolver_log_s_once != -1)
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    v33 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
    {
      v53[0].val[0] = 134217984;
      *(_QWORD *)&v53[0].val[1] = (int)v16;
      _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "Failed to create UDP socket: %{darwin.errno}ld", (uint8_t *)v53, 0xCu);
    }
    return v16;
  }
LABEL_16:
  v52 = 1;
  if (sa_family == 2)
  {
    if (!setsockopt(v14, 0xFFFF, 4226, &v52, 4u))
      goto LABEL_43;
    if (*__error())
    {
      v15 = *__error();
      if (!v15)
        goto LABEL_43;
    }
    else
    {
      v15 = -6700;
    }
    if (_mdns_resolver_log_s_once != -1)
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    v34 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
    {
      v53[0].val[0] = 67109120;
      v53[0].val[1] = v15;
      _os_log_error_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "setsockopt() for SOL_SOCKET/SO_RANDOMPORT failed %{darwin.errno}d", (uint8_t *)v53, 8u);
    }
  }
  else
  {
    v50 = a4;
    v51 = v12;
    v17 = a5;
    v18 = 0;
    *(_QWORD *)&v53[0].val[2] = 0;
    *(_QWORD *)&v53[0].val[4] = 0;
    v53[0].val[6] = 0;
    *(_QWORD *)v53[0].val = 7708;
    *(in6_addr *)&v53[0].val[2] = in6addr_any;
    while (1)
    {
      v19 = arc4random() | 0xFFFFC000;
      HIWORD(v53[0].val[0]) = bswap32(v19) >> 16;
      if (!bind(v14, (const sockaddr *)v53, 0x1Cu))
      {
        v20 = 0;
        goto LABEL_32;
      }
      if (!*__error())
        break;
      v20 = *__error();
      v21 = v18 + 1;
      if (v20 != 48 || v18++ >= 0x270F)
        goto LABEL_33;
    }
    v20 = -6700;
LABEL_32:
    v21 = v18 + 1;
LABEL_33:
    if (v20)
    {
      if (_mdns_resolver_log_s_once != -1)
        dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
      v23 = _mdns_resolver_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134218240;
        *(_QWORD *)v56 = v20;
        *(_WORD *)&v56[8] = 1024;
        v57 = v21;
        _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Binding IPv6 socket to random port failed -- error: %{mdns:err}ld, tries: %d", buf, 0x12u);
      }
    }
    else
    {
      if (_mdns_resolver_log_s_once != -1)
        dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
      v24 = _mdns_resolver_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)v56 = (unsigned __int16)v19;
        *(_WORD *)&v56[4] = 1024;
        *(_DWORD *)&v56[6] = v21;
        _os_log_debug_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEBUG, "Binding IPv6 socket to random port succeeded -- port: %u, tries: %d", buf, 0xEu);
      }
    }
    a5 = v17;
    a4 = v50;
    v12 = v51;
  }
LABEL_43:
  if (!setsockopt(v14, 0xFFFF, 4130, &v52, 4u))
    goto LABEL_52;
  if (*__error())
  {
    v25 = *__error();
    if (!v25)
      goto LABEL_52;
  }
  else
  {
    v25 = -6700;
  }
  if (_mdns_resolver_log_s_once != -1)
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
  v26 = _mdns_resolver_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
  {
    v53[0].val[0] = 67109120;
    v53[0].val[1] = v25;
    _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "setsockopt() for SOL_SOCKET/SO_NOSIGPIPE failed %{darwin.errno}d", (uint8_t *)v53, 8u);
  }
LABEL_52:
  if (setsockopt(v14, 0xFFFF, 0x10000, &v52, 4u))
  {
    if (*__error())
    {
      v27 = *__error();
      if (!v27)
        goto LABEL_61;
    }
    else
    {
      v27 = -6700;
    }
    if (_mdns_resolver_log_s_once != -1)
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    v28 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
    {
      v53[0].val[0] = 67109120;
      v53[0].val[1] = v27;
      _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "setsockopt() for SOL_SOCKET/SO_NOWAKEFROMSLEEP failed %{darwin.errno}d", (uint8_t *)v53, 8u);
    }
  }
LABEL_61:
  v29 = fcntl(v14, 3, 0);
  if (fcntl(v14, 4, v29 | 4u) == -1 && *__error())
    __error();
  v30 = *(NSObject **)(a2 + 48);
  if (v30)
  {
    *(_DWORD *)buf = 0;
    *(_DWORD *)buf = nw_interface_get_index(v30);
    if (sa_family == 2)
    {
      if (!setsockopt(v14, 0, 25, buf, 4u))
        goto LABEL_96;
      if (*__error())
      {
        v31 = *__error();
        if (!v31)
          goto LABEL_96;
      }
      else
      {
        v31 = -6700;
      }
      if (_mdns_resolver_log_s_once != -1)
        dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
      v37 = _mdns_resolver_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
      {
        v53[0].val[0] = 67109120;
        v53[0].val[1] = v31;
        v38 = "setsockopt() for IPPROTO_IP/IP_BOUND_IF failed %{darwin.errno}d";
        goto LABEL_141;
      }
    }
    else
    {
      if (!setsockopt(v14, 41, 125, buf, 4u))
        goto LABEL_96;
      if (*__error())
      {
        v32 = *__error();
        if (!v32)
          goto LABEL_96;
      }
      else
      {
        v32 = -6700;
      }
      if (_mdns_resolver_log_s_once != -1)
        dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
      v37 = _mdns_resolver_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
      {
        v53[0].val[0] = 67109120;
        v53[0].val[1] = v32;
        v38 = "setsockopt() for IPPROTO_IPV6/IPV6_BOUND_IF failed %{darwin.errno}d";
LABEL_141:
        _os_log_error_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, v38, (uint8_t *)v53, 8u);
        if (!a4)
          goto LABEL_126;
        goto LABEL_97;
      }
    }
  }
LABEL_96:
  if (!a4)
    goto LABEL_126;
LABEL_97:
  v39 = a4[4];
  if (v39 == 3)
  {
    v41 = *(_OWORD *)(*(_QWORD *)a4 + 40);
    *(_OWORD *)v53[0].val = *(_OWORD *)(*(_QWORD *)a4 + 24);
    *(_OWORD *)&v53[0].val[4] = v41;
    *(_DWORD *)buf = audit_token_to_pid(v53);
    if (!setsockopt(v14, 0xFFFF, 4359, buf, 4u))
      goto LABEL_126;
    if (*__error())
    {
      v42 = *__error();
      if (!v42)
        goto LABEL_126;
    }
    else
    {
      v42 = -6700;
    }
    if (_mdns_resolver_log_s_once != -1)
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    v44 = _mdns_resolver_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
      goto LABEL_126;
    v53[0].val[0] = 67109120;
    v53[0].val[1] = v42;
    v45 = "setsockopt() for SOL_SOCKET/SO_DELEGATED failed %{darwin.errno}d";
LABEL_144:
    _os_log_error_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, v45, (uint8_t *)v53, 8u);
    goto LABEL_126;
  }
  if (v39 == 2)
  {
    if (!setsockopt(v14, 0xFFFF, 4360, a4, 0x10u))
      goto LABEL_126;
    if (*__error())
    {
      v43 = *__error();
      if (!v43)
        goto LABEL_126;
    }
    else
    {
      v43 = -6700;
    }
    if (_mdns_resolver_log_s_once != -1)
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    v44 = _mdns_resolver_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
      goto LABEL_126;
    v53[0].val[0] = 67109120;
    v53[0].val[1] = v43;
    v45 = "setsockopt() for SOL_SOCKET/SO_DELEGATED_UUID failed %{darwin.errno}d";
    goto LABEL_144;
  }
  if (v39 != 1 || !setsockopt(v14, 0xFFFF, 4359, a4, 4u))
    goto LABEL_126;
  if (!*__error())
  {
    v40 = -6700;
LABEL_113:
    if (_mdns_resolver_log_s_once != -1)
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    v44 = _mdns_resolver_log_s_log;
    if (!os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
      goto LABEL_126;
    v53[0].val[0] = 67109120;
    v53[0].val[1] = v40;
    v45 = "setsockopt() for SOL_SOCKET/SO_DELEGATED failed %{darwin.errno}d";
    goto LABEL_144;
  }
  v40 = *__error();
  if (v40)
    goto LABEL_113;
LABEL_126:
  if (!a5)
  {
LABEL_133:
    if (sa_family == 2)
      v48 = 16;
    else
      v48 = 28;
    memcpy((void *)(a1 + 104), v12, v48);
    v16 = 0;
    *(_DWORD *)(a1 + 132) = v48;
    *(_DWORD *)(a1 + 136) = v14;
    return v16;
  }
  bzero(v53, 0x3F1uLL);
  v46 = DomainNameToString(a5, 0, (unsigned __int8 *)v53, 0);
  if (!(_DWORD)v46)
  {
    if ((ne_session_set_socket_attributes(v14, v53, 0) & 1) == 0)
    {
      if (_mdns_resolver_log_s_once != -1)
        dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
      v47 = _mdns_resolver_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)v56 = v53;
        _os_log_error_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, "ne_session_set_socket_attributes() failed for '%s'", buf, 0xCu);
      }
    }
    goto LABEL_133;
  }
  v16 = v46;
  if ((v14 & 0x80000000) == 0)
    close(v14);
  return v16;
}

uint64_t _mdns_udp_socket_session_activate(uint64_t a1)
{
  uintptr_t v2;
  dispatch_source_t v3;

  v2 = *(int *)(a1 + 136);
  if (_mdns_resolver_queue_s_once != -1)
    dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
  v3 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, v2, 0, (dispatch_queue_t)_mdns_resolver_queue_s_queue);
  *(_QWORD *)(a1 + 96) = v3;
  if (!v3)
    return 4294960567;
  os_retain((void *)a1);
  dispatch_set_context(*(dispatch_object_t *)(a1 + 96), (void *)a1);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(a1 + 96), (dispatch_function_t)_mdns_udp_socket_session_read_handler);
  dispatch_source_set_cancel_handler_f(*(dispatch_source_t *)(a1 + 96), (dispatch_function_t)_mdns_udp_socket_session_cancel_handler);
  dispatch_activate(*(dispatch_object_t *)(a1 + 96));
  return 0;
}

void _mdns_udp_socket_session_invalidate(uint64_t a1)
{
  NSObject *v1;

  v1 = *(NSObject **)(a1 + 96);
  if (v1)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 96));
    dispatch_release(v1);
    *(_QWORD *)(a1 + 96) = 0;
  }
}

void _mdns_udp_socket_session_send(uint64_t a1, dispatch_data_t data)
{
  dispatch_data_t v3;
  NSObject *v4;
  int v5;
  NSObject *v6;
  uint64_t v7;
  size_t v8;
  void *buffer_ptr;
  uint8_t buf[4];
  uint64_t v11;
  __int16 v12;
  int v13;

  v8 = 0;
  buffer_ptr = 0;
  v3 = dispatch_data_create_map(data, (const void **)&buffer_ptr, &v8);
  if (v3)
  {
    v4 = v3;
    if (sendto(*(_DWORD *)(a1 + 136), buffer_ptr, v8, 0, (const sockaddr *)(a1 + 104), *(_DWORD *)(a1 + 132)) < 0)
    {
      if (*__error())
      {
        v5 = *__error();
        if (!v5)
          goto LABEL_11;
      }
      else
      {
        v5 = -6700;
      }
      if (_mdns_resolver_log_s_once != -1)
        dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
      v6 = _mdns_resolver_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
      {
        v7 = *(_QWORD *)(a1 + 32);
        *(_DWORD *)buf = 138412546;
        v11 = v7;
        v12 = 1024;
        v13 = v5;
        _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "sending to %@ failed: %{darwin.errno}d", buf, 0x12u);
      }
    }
LABEL_11:
    dispatch_release(v4);
  }
}

void _mdns_udp_socket_session_read_handler(uint64_t a1)
{
  ssize_t v2;
  uint64_t v3;
  int v4;
  int v5;
  BOOL v6;
  dispatch_data_t v7;
  NSObject *v8;
  socklen_t v9;
  sockaddr v10;
  uint64_t v11;
  int v12;
  _OWORD buffer[32];

  memset(buffer, 0, sizeof(buffer));
  *(_QWORD *)&v10.sa_len = 0;
  *(_QWORD *)&v10.sa_data[6] = 0;
  v12 = 0;
  v11 = 0;
  v9 = 28;
  v2 = recvfrom(*(_DWORD *)(a1 + 136), buffer, 0x200uLL, 0, &v10, &v9);
  if (v2 < 0)
  {
    if (*__error())
    {
      v3 = *__error();
      if (!(_DWORD)v3)
        goto LABEL_4;
      if ((_DWORD)v3 == 35)
        return;
    }
    else
    {
      v3 = 4294960596;
    }
    _mdns_common_session_finish(a1, 3, v3);
    return;
  }
LABEL_4:
  if (*(_BYTE *)(a1 + 105) == 2)
  {
    if (*(_DWORD *)(a1 + 108) != *(_DWORD *)&v10.sa_data[2])
      return;
    v4 = *(unsigned __int16 *)(a1 + 106);
    v5 = *(unsigned __int16 *)v10.sa_data;
    goto LABEL_7;
  }
  v6 = *(_QWORD *)(a1 + 112) == *(_QWORD *)&v10.sa_data[6] && *(_QWORD *)(a1 + 120) == v11;
  if (!v6 || *(unsigned __int16 *)(a1 + 106) != *(unsigned __int16 *)v10.sa_data)
    return;
  if (*(unsigned __int8 *)(a1 + 112) == 254 && (*(_BYTE *)(a1 + 113) & 0xC0) == 0x80)
  {
    v4 = *(_DWORD *)(a1 + 128);
    if (v4)
    {
      v5 = v12;
LABEL_7:
      if (v4 != v5)
        return;
    }
  }
  if (_mdns_resolver_queue_s_once != -1)
    dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
  v7 = dispatch_data_create(buffer, v2, (dispatch_queue_t)_mdns_resolver_queue_s_queue, 0);
  if (v7)
  {
    v8 = v7;
    _mdns_common_session_invoke_receive(a1, (uint64_t)v7);
    dispatch_release(v8);
  }
}

void _mdns_udp_socket_session_cancel_handler(_DWORD *object)
{
  int v2;

  v2 = object[34];
  if ((v2 & 0x80000000) == 0)
  {
    close(v2);
    object[34] = -1;
  }
  os_release(object);
}

uint64_t _mdns_connection_session_initialize(uint64_t a1, uint64_t a2, int a3, NSObject *a4, unsigned __int8 *a5)
{
  uint64_t v8;
  BOOL v9;
  uint64_t (*v10)(uint64_t, unsigned int *);
  uint64_t v11;
  NSObject *v12;
  char v13;
  uint64_t (*v14)(uint64_t, unsigned int *);
  uint64_t v15;
  nw_parameters_t v16;
  int isa;
  __int128 v19;
  uint64_t v20;
  NSObject *v21;
  const sockaddr *address;
  nw_endpoint_t v23;
  NSObject *v24;
  int v25;
  uint64_t port;
  uint64_t host_with_numeric_port;
  void *v28;
  int v29;
  NSObject *v30;
  nw_connection_t v31;
  unsigned int v33;
  _BYTE buf[992];

  v33 = 0;
  v8 = *(_QWORD *)(a2 + 16);
  if (*(_BYTE *)(v8 + 158))
    v9 = 0;
  else
    v9 = a3 == 0;
  if (v9)
  {
    v14 = *(uint64_t (**)(uint64_t, unsigned int *))(v8 + 104);
    if (v14)
    {
      v15 = v14(a2, &v33);
      v13 = v33;
      if (v33)
        return v33;
      v12 = v15;
      goto LABEL_11;
    }
    return -6735;
  }
  v10 = *(uint64_t (**)(uint64_t, unsigned int *))(v8 + 112);
  if (!v10)
    return -6735;
  v11 = v10(a2, &v33);
  if (v33)
    return v33;
  v12 = v11;
  v13 = 1;
LABEL_11:
  *(_BYTE *)(a1 + 104) = v13;
  if (!a4)
    goto LABEL_25;
  if ((LODWORD(a4[2].isa) - 1) > 2)
  {
    a4 = 0;
    goto LABEL_25;
  }
  v16 = nw_parameters_copy(v12);
  if (!v16)
    return -6729;
  v12 = v16;
  isa = (int)a4[2].isa;
  switch(isa)
  {
    case 3:
      v19 = *(_OWORD *)((char *)a4->isa + 40);
      *(_OWORD *)buf = *(_OWORD *)((char *)a4->isa + 24);
      *(_OWORD *)&buf[16] = v19;
      nw_parameters_set_source_application(v16, buf);
      break;
    case 2:
      nw_parameters_set_e_proc_uuid(v16, a4);
      break;
    case 1:
      nw_parameters_set_pid(v16);
      break;
  }
  a4 = v12;
LABEL_25:
  v20 = *(_QWORD *)(a1 + 32);
  v21 = *(NSObject **)(v20 + 48);
  if (a5)
  {
    address = nw_endpoint_get_address(*(nw_endpoint_t *)(v20 + 48));
    v23 = nw_endpoint_create_address(address);
    if (v23)
    {
      v24 = v23;
      bzero(buf, 0x3F1uLL);
      v25 = DomainNameToString(a5, 0, buf, 0);
      if (v25)
      {
        v29 = v25;
      }
      else
      {
        port = nw_endpoint_get_port(v24);
        host_with_numeric_port = nw_endpoint_create_host_with_numeric_port(buf, port);
        if (host_with_numeric_port)
        {
          v28 = (void *)host_with_numeric_port;
          nw_endpoint_set_parent_endpoint(v24, host_with_numeric_port, 0);
          nw_release(v28);
          v21 = v24;
          goto LABEL_39;
        }
        v29 = -6729;
      }
      nw_release(v24);
    }
    else
    {
      v29 = -6729;
    }
    if (_mdns_resolver_log_s_once != -1)
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    v30 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412546;
      *(_QWORD *)&buf[4] = v21;
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v29;
      _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Failed to create domain-attributed endpoint for %@: %{mdns:err}ld", buf, 0x16u);
    }
  }
  v24 = 0;
LABEL_39:
  v31 = nw_connection_create(v21, v12);
  *(_QWORD *)(a1 + 96) = v31;
  if (v31)
  {
    if (!a4)
      goto LABEL_42;
    goto LABEL_41;
  }
  v33 = -6729;
  if (a4)
LABEL_41:
    nw_release(a4);
LABEL_42:
  if (v24)
    nw_release(v24);
  return v33;
}

uint64_t _mdns_connection_session_activate(nw_connection_t *a1)
{
  NSObject *v2;
  NSObject *v3;
  NSObject *v4;
  _QWORD v6[5];
  _QWORD completion[5];

  os_retain(a1);
  v2 = a1[12];
  if (_mdns_resolver_queue_s_once != -1)
    dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
  nw_connection_set_queue(v2, (dispatch_queue_t)_mdns_resolver_queue_s_queue);
  v3 = a1[12];
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = ___mdns_connection_session_activate_block_invoke;
  v6[3] = &__block_descriptor_tmp_70_4801;
  v6[4] = a1;
  nw_connection_set_state_changed_handler(v3, v6);
  nw_connection_start(a1[12]);
  v4 = a1[12];
  completion[0] = _NSConcreteStackBlock;
  completion[1] = 0x40000000;
  completion[2] = ___mdns_connection_session_schedule_receive_block_invoke;
  completion[3] = &__block_descriptor_tmp_72_4802;
  completion[4] = a1;
  nw_connection_receive_message(v4, completion);
  return 0;
}

void _mdns_connection_session_invalidate(uint64_t a1)
{
  NSObject *v2;
  void *v3;

  v2 = *(NSObject **)(a1 + 96);
  if (v2)
  {
    nw_connection_cancel(v2);
    v3 = *(void **)(a1 + 96);
    if (v3)
    {
      nw_release(v3);
      *(_QWORD *)(a1 + 96) = 0;
    }
  }
}

void _mdns_connection_session_send(uint64_t a1, NSObject *a2, uint64_t a3)
{
  NSObject *v6;
  uint64_t started;
  NSObject *v8;
  uint64_t v9;
  _QWORD v10[6];
  uint8_t buf[4];
  uint64_t v12;

  if (_mdns_resolver_log_s_once != -1)
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
  v6 = _mdns_resolver_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEBUG))
  {
    v9 = *(_QWORD *)(a1 + 96);
    *(_DWORD *)buf = 138412290;
    v12 = v9;
    _os_log_debug_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "Sending message on connection %@", buf, 0xCu);
  }
  started = _mdns_create_and_start_connection_activity(*(_QWORD *)(a1 + 96), a3);
  v8 = *(NSObject **)(a1 + 96);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = ___mdns_connection_session_send_block_invoke;
  v10[3] = &__block_descriptor_tmp_74;
  v10[4] = started;
  v10[5] = a1;
  nw_connection_send(v8, a2, _nw_content_context_default_message, 1, v10);
}

uint64_t _mdns_connection_session_is_bytestream(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 104);
}

void ___mdns_connection_session_send_block_invoke(uint64_t a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;

  v4 = *(void **)(a1 + 32);
  if (v4)
  {
    v5 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 96);
    if (v5)
    {
      nw_connection_end_activity(v5, v4);
      v4 = *(void **)(a1 + 32);
    }
    nw_release(v4);
  }
  if (a2)
  {
    v6 = *(_QWORD *)(a1 + 40);
    if (*(_QWORD *)(v6 + 96))
      _mdns_common_session_finish(v6, 3, 4294960543);
  }
}

void ___mdns_connection_session_activate_block_invoke(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  __int16 v10;
  uint64_t v11;

  v4 = *(_QWORD **)(a1 + 32);
  if (v4[12])
  {
    if (_mdns_resolver_log_s_once != -1)
      dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
    v5 = _mdns_resolver_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_DEBUG))
    {
      v6 = nw_connection_state_to_string(a2);
      v7 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 96);
      v8 = 136315394;
      v9 = v6;
      v10 = 2112;
      v11 = v7;
      _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Connection state changed to %s for connection %@", (uint8_t *)&v8, 0x16u);
    }
    switch((_DWORD)a2)
    {
      case 3:
        _mdns_common_session_invoke_ready_event_handler(*(_QWORD *)(a1 + 32));
        break;
      case 4:
        _mdns_common_session_finish(*(_QWORD *)(a1 + 32), 3, 4294960543);
        break;
      case 5:
        v4 = *(_QWORD **)(a1 + 32);
LABEL_10:
        os_release(v4);
        break;
    }
  }
  else if ((_DWORD)a2 == 5)
  {
    goto LABEL_10;
  }
}

void ___mdns_connection_session_schedule_receive_block_invoke(uint64_t a1, uint64_t a2, nw_content_context_t context, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  _BOOL4 is_final;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  _QWORD completion[5];

  v6 = *(_QWORD *)(a1 + 32);
  if (*(_QWORD *)(v6 + 96))
  {
    if (a2)
      _mdns_common_session_invoke_receive(v6, a2);
    if (context)
      is_final = nw_content_context_get_is_final(context);
    else
      is_final = 0;
    v10 = *(_QWORD *)(a1 + 32);
    if (a5 || is_final)
    {
      if (a5)
        v12 = 4294960543;
      else
        v12 = 0;
      _mdns_common_session_finish(v10, 3, v12);
    }
    else
    {
      v11 = *(NSObject **)(v10 + 96);
      completion[0] = _NSConcreteStackBlock;
      completion[1] = 0x40000000;
      completion[2] = ___mdns_connection_session_schedule_receive_block_invoke;
      completion[3] = &__block_descriptor_tmp_72_4802;
      completion[4] = v10;
      nw_connection_receive_message(v11, completion);
    }
  }
}

void ___mdns_querier_reset_time_limit_block_invoke(uint64_t a1)
{
  _mdns_querier_conclude_ex(*(_QWORD *)(a1 + 32), 2, 0, 0);
}

void ___mdns_querier_conclude_async_block_invoke(uint64_t a1)
{
  _mdns_querier_conclude_ex(*(_QWORD *)(a1 + 32), *(unsigned __int8 *)(a1 + 40), 0, 0);
  os_release(*(void **)(a1 + 32));
}

void _mdns_querier_clear_delegation(uint64_t a1)
{
  void **v2;
  int v3;

  v2 = (void **)(a1 + 168);
  v3 = *(_DWORD *)(a1 + 184);
  switch(v3)
  {
    case 3:
      if (*v2)
      {
        os_release(*v2);
        *v2 = 0;
      }
      break;
    case 2:
      uuid_clear((unsigned __int8 *)(a1 + 168));
      break;
    case 1:
      *(_DWORD *)v2 = 0;
      break;
  }
  *(_DWORD *)(a1 + 184) = 0;
}

void mdns_resolver_invalidate(void *a1)
{
  _QWORD block[5];

  os_retain(a1);
  if (_mdns_resolver_queue_s_once != -1)
    dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = __mdns_resolver_invalidate_block_invoke;
  block[3] = &__block_descriptor_tmp_4_4826;
  block[4] = a1;
  dispatch_async((dispatch_queue_t)_mdns_resolver_queue_s_queue, block);
}

void __mdns_resolver_invalidate_block_invoke(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  void *v5;
  _BYTE *v6;
  NSObject *v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  _QWORD block[5];

  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 136))
  {
    *(_BYTE *)(v2 + 136) = 1;
    v3 = *(NSObject **)(v2 + 104);
    if (v3)
    {
      dispatch_source_cancel(*(dispatch_source_t *)(v2 + 104));
      dispatch_release(v3);
      *(_QWORD *)(v2 + 104) = 0;
    }
    v4 = *(_QWORD *)(v2 + 112);
    if (v4)
    {
      mdns_client_invalidate(v4);
      os_release(*(void **)(v2 + 112));
      *(_QWORD *)(v2 + 112) = 0;
    }
    while (1)
    {
      v8 = *(_QWORD *)(v2 + 24);
      if (!v8)
        break;
      *(_QWORD *)(v2 + 24) = *(_QWORD *)(v8 + 24);
      if (*(_QWORD *)(v8 + 56))
      {
        nw_path_evaluator_cancel();
        v5 = *(void **)(v8 + 56);
        if (v5)
        {
          nw_release(v5);
          *(_QWORD *)(v8 + 56) = 0;
        }
      }
      v6 = *(_BYTE **)(v8 + 32);
      if (v6)
      {
        _mdns_session_invalidate(v6);
        os_release(*(void **)(v8 + 32));
        *(_QWORD *)(v8 + 32) = 0;
      }
      v7 = *(NSObject **)(v8 + 40);
      if (v7)
      {
        dispatch_source_cancel(*(dispatch_source_t *)(v8 + 40));
        dispatch_release(v7);
        *(_QWORD *)(v8 + 40) = 0;
      }
    }
    _mdns_resolver_invalidate_and_forget_queriers((_QWORD **)(v2 + 32));
    _mdns_resolver_invalidate_and_forget_queriers((_QWORD **)(v2 + 40));
    v9 = *(NSObject **)(v2 + 96);
    if (v9)
    {
      dispatch_source_cancel(*(dispatch_source_t *)(v2 + 96));
      dispatch_release(v9);
      *(_QWORD *)(v2 + 96) = 0;
    }
    if (*(_QWORD *)(v2 + 80))
    {
      os_retain((void *)v2);
      v10 = *(NSObject **)(v2 + 72);
      block[0] = _NSConcreteStackBlock;
      block[1] = 0x40000000;
      block[2] = ___mdns_resolver_invalidate_internal_block_invoke;
      block[3] = &__block_descriptor_tmp_44_4827;
      block[4] = v2;
      dispatch_async(v10, block);
    }
  }
  os_release(*(void **)(a1 + 32));
}

void _mdns_resolver_invalidate_and_forget_queriers(_QWORD **a1)
{
  _QWORD *v1;
  _QWORD *v2;

  v1 = *a1;
  if (*a1)
  {
    *a1 = 0;
    do
    {
      v2 = (_QWORD *)v1[7];
      v1[7] = 0;
      _mdns_querier_conclude_ex((uint64_t)v1, 4, 0, 0);
      os_release(v1);
      v1 = v2;
    }
    while (v2);
  }
}

void ___mdns_resolver_invalidate_internal_block_invoke(uint64_t a1)
{
  (*(void (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 80) + 16))();
  os_release(*(void **)(a1 + 32));
}

void __mdns_resolver_prepare_for_system_sleep_block_invoke(id a1)
{
  NSObject *v1;
  void *v2;
  uint8_t v3[16];

  if (_mdns_resolver_log_s_once != -1)
    dispatch_once(&_mdns_resolver_log_s_once, &__block_literal_global_48);
  v1 = _mdns_resolver_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_resolver_log_s_log, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_INFO, "Preparing for system sleep", v3, 2u);
  }
  v2 = objc_autoreleasePoolPush();
  _http_task_shared_session_critical_region(&__block_literal_global_395);
  objc_autoreleasePoolPop(v2);
}

void mdns_querier_set_delegator_uuid(uint64_t a1, const unsigned __int8 *a2)
{
  uuid_t dst;

  if (!*(_BYTE *)(a1 + 49))
  {
    memset(dst, 0, sizeof(dst));
    uuid_copy(dst, a2);
    _mdns_querier_clear_delegation(a1);
    *(_DWORD *)(a1 + 184) = 2;
    uuid_copy((unsigned __int8 *)(a1 + 168), dst);
  }
}

void mdns_querier_set_delegator_audit_token(uint64_t a1, void *object)
{
  if (!*(_BYTE *)(a1 + 49))
  {
    os_retain(object);
    _mdns_querier_clear_delegation(a1);
    *(_DWORD *)(a1 + 184) = 3;
    *(_QWORD *)(a1 + 168) = object;
  }
}

void mdns_querier_set_result_handler(uint64_t a1, void *aBlock)
{
  void *v3;
  const void *v4;

  if (!*(_BYTE *)(a1 + 49))
  {
    if (aBlock)
      v3 = _Block_copy(aBlock);
    else
      v3 = 0;
    v4 = *(const void **)(a1 + 80);
    if (v4)
      _Block_release(v4);
    *(_QWORD *)(a1 + 80) = v3;
  }
}

void mdns_querier_set_time_limit_ms(void *a1, int a2)
{
  _QWORD v4[5];
  int v5;

  os_retain(a1);
  if (_mdns_resolver_queue_s_once != -1)
    dispatch_once(&_mdns_resolver_queue_s_once, &__block_literal_global_138);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = __mdns_querier_set_time_limit_ms_block_invoke;
  v4[3] = &__block_descriptor_tmp_7_4855;
  v4[4] = a1;
  v5 = a2;
  dispatch_async((dispatch_queue_t)_mdns_resolver_queue_s_queue, v4);
}

void __mdns_querier_set_time_limit_ms_block_invoke(uint64_t a1)
{
  uint64_t v2;
  unsigned int v3;
  int v4;

  v2 = *(_QWORD *)(a1 + 32);
  if (*(_BYTE *)(v2 + 249) != 3)
  {
    v3 = *(_DWORD *)(a1 + 40);
    *(_DWORD *)(v2 + 224) = v3;
    v4 = _mdns_querier_reset_time_limit(v2, v3);
    if (v4)
      _mdns_querier_conclude_with_error_async((void *)v2, v4);
  }
  os_release(*(void **)(a1 + 32));
}

BOOL mdns_querier_match(uint64_t a1, unsigned __int8 *a2, int a3, int a4)
{
  unsigned __int8 *v4;
  _BOOL8 result;

  result = 0;
  if (*(unsigned __int16 *)(a1 + 64) == a3 && *(unsigned __int16 *)(a1 + 66) == a4)
  {
    v4 = *(unsigned __int8 **)(*(_QWORD *)(a1 + 56) + 24);
    if (v4)
    {
      if (DomainNameEqual(v4, a2))
        return 1;
    }
  }
  return result;
}

void *SendPortMapRequest(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  int v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  int v12;
  const char *v13;
  NSObject *v14;
  unsigned int v15;
  int v17;
  __int16 v18;
  int v19;
  __int16 v20;
  uint8_t buf[4];
  unsigned int v22;
  __int16 v23;
  int v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  _OWORD v37[2];
  uint64_t v38;
  _QWORD v39[4];

  v4 = *(unsigned __int16 *)(a2 + 176);
  v5 = v4;
  if (!*(_WORD *)(a2 + 176))
    v5 = *(unsigned __int16 *)(a2 + 174);
  memset(v39, 0, 30);
  memset(v37, 0, sizeof(v37));
  v38 = 0;
  v25 = 0u;
  v26 = 0u;
  v27 = 0u;
  v28 = 0u;
  v29 = 0u;
  v30 = 0u;
  v31 = 0u;
  v32 = 0u;
  v33 = 0u;
  v34 = 0u;
  v6 = bswap32(v5);
  v35 = 0u;
  v36 = 0u;
  v7 = *(_DWORD *)(a2 + 136);
  v8 = v7 + HIWORD(v6);
  v9 = *(_QWORD *)(a1 + 14720);
  if (!v9)
  {
LABEL_14:
    v20 = 0;
    v19 = 0;
    v17 = 0;
    v18 = 0;
    v12 = (unsigned __int16)v8;
    mDNS_snprintf(&v19);
    mDNS_snprintf(&v17);
    mDNS_snprintf(v37);
    mDNS_snprintf(v39);
    *(_QWORD *)&v25 = "NewRemoteHost";
    *((_QWORD *)&v25 + 1) = "string";
    *(_QWORD *)&v26 = "";
    *((_QWORD *)&v26 + 1) = "NewExternalPort";
    *(_QWORD *)&v27 = "ui2";
    *((_QWORD *)&v27 + 1) = &v19;
    *(_QWORD *)&v28 = "NewProtocol";
    *((_QWORD *)&v28 + 1) = "string";
    v13 = "TCP";
    if (*(_BYTE *)(a2 + 172) == 1)
      v13 = "UDP";
    *(_QWORD *)&v29 = v13;
    *((_QWORD *)&v29 + 1) = "NewInternalPort";
    *(_QWORD *)&v30 = "ui2";
    *((_QWORD *)&v30 + 1) = &v17;
    *(_QWORD *)&v31 = "NewInternalClient";
    *((_QWORD *)&v31 + 1) = "string";
    *(_QWORD *)&v32 = v39;
    *((_QWORD *)&v32 + 1) = "NewEnabled";
    *(_QWORD *)&v33 = "BOOLean";
    *((_QWORD *)&v33 + 1) = "1";
    *(_QWORD *)&v34 = "NewPortMappingDescription";
    *((_QWORD *)&v34 + 1) = "string";
    *(_QWORD *)&v35 = v37;
    *((_QWORD *)&v35 + 1) = "NewLeaseDuration";
    *(_QWORD *)&v36 = "ui4";
    *((_QWORD *)&v36 + 1) = "0";
    v14 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
      {
LABEL_21:
        v15 = bswap32(*(unsigned __int16 *)(a2 + 174));
        *(_DWORD *)buf = 67109376;
        v22 = HIWORD(v15);
        v23 = 1024;
        v24 = v12;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "SendPortMapRequest: internal %u external %u", buf, 0xEu);
      }
    }
    else
    {
      v14 = mDNSLogCategory_NAT_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_21;
    }
    return SendSOAPMsgControlAction(a1, a2 + 32, (uint64_t)"AddPortMapping", 8, (uint64_t)&v25, 3);
  }
  while (v9 == a2)
  {
    v9 = a2;
LABEL_13:
    v9 = *(_QWORD *)v9;
    if (!v9)
      goto LABEL_14;
  }
  v10 = *(unsigned __int16 *)(v9 + 176);
  if (!*(_WORD *)(v9 + 176))
    v10 = *(unsigned __int16 *)(v9 + 174);
  if (*(unsigned __int16 *)(v9 + 136) + (bswap32(v10) >> 16) != (unsigned __int16)v8)
    goto LABEL_13;
  if (v7 <= 99)
  {
    *(_DWORD *)(a2 + 136) = ++v7;
    v11 = v4;
    if (!v4)
      v11 = *(unsigned __int16 *)(a2 + 174);
    v8 = v7 + (bswap32(v11) >> 16);
    v9 = a1 + 14720;
    goto LABEL_13;
  }
  natTraversalHandlePortMapReplyWithAddress(a1, a2, *(_QWORD *)(a1 + 15016), 4, *(unsigned int *)(a1 + 14744), 0, 0, 2);
  return 0;
}

void *SendSOAPMsgControlAction(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, int a6)
{
  unsigned __int16 *v6;
  uint64_t v10;
  int v11;
  _BYTE *v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t TCPConnection;
  NSObject *v17;
  uint8_t *v19;
  void *result;
  void *v22;
  uint8_t buf[2];
  __int16 v26;

  v6 = (unsigned __int16 *)(a1 + 15036);
  if (!*(_WORD *)(a1 + 15036) || !*(_QWORD *)(a1 + 15056) || !*(_QWORD *)(a1 + 15072))
  {
    TCPConnection = 4294901747;
    v17 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
        return (void *)TCPConnection;
      v26 = 0;
      v19 = (uint8_t *)&v26;
    }
    else
    {
      v17 = mDNSLogCategory_NAT_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
        return (void *)TCPConnection;
      *(_WORD *)buf = 0;
      v19 = buf;
    }
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "SendSOAPMsgControlAction: no SOAP port, URL or address string", v19, 2u);
    return (void *)TCPConnection;
  }
  v10 = a1 + 28960;
  v11 = mDNS_snprintf((void *)(a1 + 28960));
  v12 = (_BYTE *)(v10 + v11);
  *v12 = 0;
  if (a4 < 1)
  {
    v13 = 0;
  }
  else
  {
    v13 = 0;
    v14 = a4;
    v15 = a5 + 16;
    do
    {
      v13 += mDNS_snprintf(&v12[v13]);
      v15 += 24;
      --v14;
    }
    while (v14);
  }
  mDNS_snprintf((void *)(a1 + 28960 + v13 + v11));
  result = *(void **)(a2 + 64);
  if (result)
  {
LABEL_22:
    *(_DWORD *)(a2 + 72) = mDNS_snprintf(result);
    TCPConnection = MakeTCPConnection(a1, a2, (int *)(a1 + 12696), *v6, a6);
    if ((_DWORD)TCPConnection)
    {
      v22 = *(void **)(a2 + 64);
      if (v22)
        free(v22);
      *(_QWORD *)(a2 + 64) = 0;
    }
    return (void *)TCPConnection;
  }
  result = malloc_type_malloc(0x2000uLL, 0xA172743EuLL);
  if (result)
  {
    *(_QWORD *)(a2 + 64) = result;
    goto LABEL_22;
  }
  __break(1u);
  return result;
}

uint64_t MakeTCPConnection(uint64_t a1, uint64_t a2, int *a3, unsigned int a4, int a5)
{
  __int16 v7;
  BOOL v8;
  uint64_t v9;
  NSObject *v10;
  __int128 v14;
  void *v15;
  void *v17;
  NSObject *v18;
  _QWORD *v19;
  char v20;
  NSObject *v21;
  uint64_t v22;
  NSObject *v23;
  unsigned int v24;
  uint64_t v25;
  unsigned int v26;
  unsigned int v27;
  NSObject *v28;
  void *v29;
  void *v30;
  __int16 v32;
  uint8_t buf[4];
  uint64_t v34;
  __int16 v35;
  int v36;
  __int16 v37;
  int *v38;
  __int16 v39;
  unsigned int v40;

  v32 = 0;
  v7 = a4;
  if (a3[1])
    v8 = (unsigned __int16)a4 == 0;
  else
    v8 = 1;
  if (v8)
  {
    v9 = 4294901747;
    v10 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
        return v9;
    }
    else
    {
      v10 = mDNSLogCategory_NAT_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
        return v9;
    }
    *(_DWORD *)buf = 141558787;
    v34 = 1752392040;
    v35 = 1045;
    v36 = 20;
    v37 = 2101;
    v38 = a3;
    v39 = 1024;
    v40 = bswap32(a4) >> 16;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "LNT MakeTCPConnection: bad address/port %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P:%d", buf, 0x22u);
    return v9;
  }
  *(_QWORD *)(a2 + 8) = a1;
  v14 = *(_OWORD *)a3;
  *(_DWORD *)(a2 + 52) = a3[4];
  *(_OWORD *)(a2 + 36) = v14;
  *(_WORD *)(a2 + 56) = a4;
  *(_DWORD *)(a2 + 32) = a5;
  *(_QWORD *)(a2 + 96) = 0;
  *(_DWORD *)(a2 + 88) = 0x2000;
  v15 = *(void **)(a2 + 80);
  if (v15)
  {
    bzero(v15, 0x2000uLL);
  }
  else
  {
    v17 = malloc_type_malloc(0x2000uLL, 0xA172743EuLL);
    if (!v17)
      __break(1u);
    *(_QWORD *)(a2 + 80) = v17;
  }
  if (*(_QWORD *)(a2 + 24))
  {
    v18 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        goto LABEL_26;
      }
    }
    else
    {
      v18 = mDNSLogCategory_NAT_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
LABEL_26:
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "MakeTCPConnection: closing previous open connection", buf, 2u);
      }
    }
    mDNSPlatformTCPCloseConnection(*(_DWORD **)(a2 + 24));
    *(_QWORD *)(a2 + 24) = 0;
  }
  v19 = mDNSPlatformTCPSocket(0, *a3, &v32, 0, 0);
  *(_QWORD *)(a2 + 24) = v19;
  v20 = gSensitiveLoggingEnabled;
  v21 = mDNSLogCategory_NAT;
  if (mDNSLogCategory_NAT == mDNSLogCategory_State)
    v20 = 0;
  if (v19)
  {
    if ((v20 & 1) != 0)
    {
      v21 = mDNSLogCategory_NAT_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
        goto LABEL_39;
    }
    else if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
    {
      goto LABEL_39;
    }
    v24 = bswap32(*(unsigned __int16 *)(a2 + 56)) >> 16;
    *(_DWORD *)buf = 141558787;
    v34 = 1752392040;
    v35 = 1045;
    v36 = 20;
    v37 = 2101;
    v38 = (int *)(a2 + 36);
    v39 = 1024;
    v40 = v24;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "MakeTCPConnection: connecting to %{sensitive, mask.hash, mdnsresponder:ip_addr}.20P:%d", buf, 0x22u);
LABEL_39:
    v25 = mDNSPlatformTCPConnect(*(_QWORD *)(a2 + 24), a3, v7, 0, (uint64_t)tcpConnectionCallback, a2);
    if ((_DWORD)v25 == -65787)
      return 0;
    v9 = v25;
    if ((_DWORD)v25 == -65789)
    {
      v26 = *(_DWORD *)(a1 + 48);
      v27 = *(_DWORD *)(a1 + 52) + 1;
      *(_DWORD *)(a1 + 52) = v27;
      mDNS_VerifyLockState("Drop Lock", 0, v26, v27, (uint64_t)"MakeTCPConnection", 570);
      tcpConnectionCallback(*(_DWORD **)(a2 + 24), a2, 1, 0);
      mDNS_VerifyLockState("Reclaim Lock", 0, *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 52), (uint64_t)"MakeTCPConnection", 572);
      v9 = 0;
      --*(_DWORD *)(a1 + 52);
      return v9;
    }
    v28 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        goto LABEL_55;
      }
    }
    else
    {
      v28 = mDNSLogCategory_NAT_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
LABEL_55:
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "LNT MakeTCPConnection: connection failed", buf, 2u);
      }
    }
    mDNSPlatformTCPCloseConnection(*(_DWORD **)(a2 + 24));
    *(_QWORD *)(a2 + 24) = 0;
    v30 = *(void **)(a2 + 80);
    if (v30)
      free(v30);
    *(_QWORD *)(a2 + 80) = 0;
    return v9;
  }
  if ((v20 & 1) != 0)
  {
    v22 = mDNSLogCategory_NAT_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v23 = v22;
LABEL_49:
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "LNT MakeTCPConnection: unable to create TCP socket", buf, 2u);
    }
  }
  else if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    v23 = v21;
    goto LABEL_49;
  }
  v29 = *(void **)(a2 + 80);
  if (v29)
    free(v29);
  *(_QWORD *)(a2 + 80) = 0;
  return 4294901757;
}

void tcpConnectionCallback(_DWORD *a1, uint64_t a2, int a3, int a4)
{
  _DWORD *v8;
  NSObject *v9;
  NSObject *v12;
  unsigned int v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v22;
  const char *v23;
  NSObject *v24;
  _BOOL4 v26;
  NSObject *v27;
  uint32_t v28;
  uint64_t v29;
  int v30;
  int v31;
  unint64_t v32;
  NSObject *v33;
  int v34;
  uint64_t v35;
  const char *v36;
  const char *v37;
  uint64_t v38;
  uint64_t v39;
  const char *v40;
  int v41;
  uint64_t v42;
  const char *v43;
  const char *v44;
  ssize_t v45;
  NSObject *v46;
  NSObject *v49;
  uint32_t v50;
  const char *v51;
  uint64_t v53;
  uint64_t v54;
  void *v55;
  void *v56;
  _QWORD *v57;
  _QWORD *v58;
  BOOL v59;
  uint64_t v60;
  uint64_t v61;
  NSObject *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  NSObject *v71;
  int v72;
  uint64_t v73;
  int v74;
  char v75;
  uint8_t buf[4];
  uint64_t v77;
  __int16 v78;
  _BYTE v79[20];
  const char *v80;
  int v81;
  __int16 v82;
  uint64_t v83;
  __int16 v84;
  uint64_t v85;
  __int16 v86;
  uint64_t v87;
  __int16 v88;
  uint64_t v89;

  v75 = 0;
  v8 = *(_DWORD **)(a2 + 24);
  if (v8 == a1)
    goto LABEL_20;
  v9 = mDNSLogCategory_NAT;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
    {
LABEL_10:
      *(_DWORD *)buf = 134218240;
      v77 = (uint64_t)v8;
      v78 = 2048;
      *(_QWORD *)v79 = a1;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "tcpConnectionCallback: WARNING- tcpInfo->sock(%p) != sock(%p) !!! Printing tcpInfo struct", buf, 0x16u);
    }
  }
  else
  {
    v9 = mDNSLogCategory_NAT_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
      goto LABEL_10;
  }
  v12 = mDNSLogCategory_NAT;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
      goto LABEL_20;
    goto LABEL_19;
  }
  v12 = mDNSLogCategory_NAT_redacted;
  if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
  {
LABEL_19:
    v15 = bswap32(*(unsigned __int16 *)(a2 + 56));
    v16 = *(_DWORD *)(a2 + 32);
    v17 = *(_DWORD *)(a2 + 104);
    v18 = *(_QWORD *)(a2 + 64);
    v19 = *(_QWORD *)(a2 + 80);
    *(_DWORD *)buf = 141560323;
    v77 = 1752392040;
    v78 = 1045;
    *(_DWORD *)v79 = 20;
    *(_WORD *)&v79[4] = 2101;
    *(_QWORD *)&v79[6] = a2 + 36;
    *(_WORD *)&v79[14] = 1024;
    *(_DWORD *)&v79[16] = HIWORD(v15);
    LOWORD(v80) = 1024;
    *(_DWORD *)((char *)&v80 + 2) = v16;
    HIWORD(v80) = 1024;
    v81 = v17;
    v82 = 2160;
    v83 = 1752392040;
    v84 = 2085;
    v85 = v18;
    v86 = 2160;
    v87 = 1752392040;
    v88 = 2085;
    v89 = v19;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "tcpConnectionCallback: tcpInfo->Address:Port [%{sensitive, mask.hash, mdnsresponder:ip_addr}.20P:%d] tcpInfo->op[%d] tcpInfo->retries[%d] tcpInfo->Request[%{sensitive, mask.hash}s] tcpInfo->Reply[%{sensitive, mask.hash}s]", buf, 0x56u);
  }
LABEL_20:
  mDNS_Lock_(*(unsigned int **)(a2 + 8), (uint64_t)"tcpConnectionCallback", 408);
  if (!a4)
  {
    if (a3)
    {
      v24 = mDNSLogCategory_NAT;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
          goto LABEL_83;
        *(_WORD *)buf = 0;
      }
      else
      {
        v24 = mDNSLogCategory_NAT_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
        {
LABEL_83:
          if (mDNSPlatformWriteTCP((uint64_t)a1, *(const void **)(a2 + 64), *(int *)(a2 + 72)) == *(_DWORD *)(a2 + 72))
          {
LABEL_84:
            tcpConnectionCallback_LNTERRORcount = 0;
            mDNS_Unlock_(*(_QWORD *)(a2 + 8), (uint64_t)"tcpConnectionCallback", 522);
            return;
          }
          v20 = mDNSLogCategory_NAT;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
          {
            v22 = 0;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
              goto LABEL_40;
            *(_WORD *)buf = 0;
            v23 = "tcpConnectionCallback: error writing";
          }
          else
          {
            v20 = mDNSLogCategory_NAT_redacted;
            v22 = 0;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
              goto LABEL_40;
            *(_WORD *)buf = 0;
            v23 = "tcpConnectionCallback: error writing";
          }
          goto LABEL_38;
        }
        *(_WORD *)buf = 0;
      }
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "tcpConnectionCallback: connection established, sending message", buf, 2u);
      goto LABEL_83;
    }
    v45 = mDNSPlatformReadTCP((uint64_t)a1, (void *)(*(_QWORD *)(a2 + 80) + *(_QWORD *)(a2 + 96)), *(int *)(a2 + 88) - *(_QWORD *)(a2 + 96), &v75);
    v46 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
        goto LABEL_104;
      *(_DWORD *)buf = 134217984;
      v77 = v45;
    }
    else
    {
      v46 = mDNSLogCategory_NAT_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
      {
LABEL_104:
        if (v45 < 0)
        {
          v60 = mDNSLogCategory_NAT;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
          {
            v22 = 0;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
              goto LABEL_40;
            *(_DWORD *)buf = 134217984;
            v77 = v45;
            v23 = "tcpConnectionCallback - read returned %ld";
          }
          else
          {
            v60 = mDNSLogCategory_NAT_redacted;
            v22 = 0;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
              goto LABEL_40;
            *(_DWORD *)buf = 134217984;
            v77 = v45;
            v23 = "tcpConnectionCallback - read returned %ld";
          }
          v27 = v60;
LABEL_152:
          v28 = 12;
          goto LABEL_39;
        }
        if (v75)
        {
          v53 = mDNSLogCategory_NAT;
          if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
          {
            v22 = 0;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
              goto LABEL_40;
            v70 = *(_QWORD *)(a2 + 96);
            *(_DWORD *)buf = 134217984;
            v77 = v70;
            v23 = "tcpConnectionCallback: socket closed by remote end %lu";
          }
          else
          {
            v53 = mDNSLogCategory_NAT_redacted;
            v22 = 0;
            if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
              goto LABEL_40;
            v54 = *(_QWORD *)(a2 + 96);
            *(_DWORD *)buf = 134217984;
            v77 = v54;
            v23 = "tcpConnectionCallback: socket closed by remote end %lu";
          }
          v27 = v53;
          goto LABEL_152;
        }
        v61 = *(_QWORD *)(a2 + 96) + v45;
        *(_QWORD *)(a2 + 96) = v61;
        v62 = mDNSLogCategory_NAT;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
            goto LABEL_156;
          *(_DWORD *)buf = 134217984;
          v77 = v61;
        }
        else
        {
          v62 = mDNSLogCategory_NAT_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
            goto LABEL_156;
          *(_DWORD *)buf = 134217984;
          v77 = v61;
        }
        _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "tcpConnectionCallback tcpInfo->nread %lu", buf, 0xCu);
LABEL_156:
        if (*(_QWORD *)(a2 + 96) <= 0x2000uLL)
          goto LABEL_165;
        v71 = mDNSLogCategory_NAT;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            goto LABEL_163;
          }
        }
        else
        {
          v71 = mDNSLogCategory_NAT_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
LABEL_163:
            _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, "result truncated...", buf, 2u);
          }
        }
        *(_QWORD *)(a2 + 96) = 0x2000;
LABEL_165:
        v72 = *(_DWORD *)(a2 + 32);
        v22 = 1;
        switch(v72)
        {
          case 1:
            handleLNTDeviceDescriptionResponse((_QWORD *)a2, v63, v64, v65, v66, v67, v68, v69, v74);
            goto LABEL_84;
          case 2:
            handleLNTGetExternalAddressResponse((_QWORD *)a2);
            goto LABEL_84;
          case 3:
            handleLNTPortMappingResponse(a2, v63, v64, v65, v66, v67, v68, v69, v74);
            goto LABEL_84;
          case 4:
            goto LABEL_40;
          default:
            v73 = mDNSLogCategory_NAT;
            if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
            {
              v22 = 0;
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
                goto LABEL_40;
              *(_DWORD *)buf = 67109120;
              LODWORD(v77) = v72;
              v23 = "tcpConnectionCallback: bad tcp operation! %d";
            }
            else
            {
              v73 = mDNSLogCategory_NAT_redacted;
              v22 = 0;
              if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
                goto LABEL_40;
              *(_DWORD *)buf = 67109120;
              LODWORD(v77) = v72;
              v23 = "tcpConnectionCallback: bad tcp operation! %d";
            }
            v27 = v73;
            v28 = 8;
            break;
        }
        goto LABEL_39;
      }
      *(_DWORD *)buf = 134217984;
      v77 = v45;
    }
    _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "tcpConnectionCallback: mDNSPlatformReadTCP read %ld bytes", buf, 0xCu);
    goto LABEL_104;
  }
  v20 = mDNSLogCategory_NAT;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
  {
    v22 = 0;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v23 = "tcpConnectionCallback: received error";
LABEL_38:
      v27 = v20;
      v28 = 2;
LABEL_39:
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, v23, buf, v28);
      v22 = 0;
    }
  }
  else
  {
    v20 = mDNSLogCategory_NAT_redacted;
    v26 = os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT);
    v22 = 0;
    if (v26)
    {
      *(_WORD *)buf = 0;
      v23 = "tcpConnectionCallback: received error";
      goto LABEL_38;
    }
  }
LABEL_40:
  v29 = *(_QWORD *)(a2 + 8);
  v30 = tcpConnectionCallback_LNTERRORcount;
  if (!tcpConnectionCallback_LNTERRORcount
    || (*(_DWORD *)(v29 + 64) - tcpConnectionCallback_lastErrorTime) >= 0x3E8)
  {
    tcpConnectionCallback_lastErrorTime = *(_DWORD *)(v29 + 64);
    tcpConnectionCallback_LNTERRORcount = 1;
    goto LABEL_48;
  }
  tcpConnectionCallback_lastErrorTime = *(_DWORD *)(v29 + 64);
  v31 = ++tcpConnectionCallback_LNTERRORcount;
  HIDWORD(v32) = 652835029 * (v30 + 1);
  LODWORD(v32) = HIDWORD(v32);
  if ((v32 >> 3) > 0x418937)
    goto LABEL_48;
  v33 = mDNSLogCategory_NAT;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
  {
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_ERROR))
      goto LABEL_140;
    *(_DWORD *)buf = 67109120;
    LODWORD(v77) = v31;
  }
  else
  {
    v33 = mDNSLogCategory_NAT_redacted;
    if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_ERROR))
      goto LABEL_140;
    *(_DWORD *)buf = 67109120;
    LODWORD(v77) = v31;
  }
  _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "ERROR: tcpconnectioncallback -> got error status %u times", buf, 8u);
LABEL_140:
  if (tcpConnectionCallback_LNTERRORcount >= 0x3E8)
    __assert_rtn("tcpConnectionCallback", "LegacyNATTraversal.c", 480, "LNTERRORcount < 1000");
LABEL_48:
  v34 = *(_DWORD *)(a2 + 32);
  switch(v34)
  {
    case 3:
      v38 = *(_QWORD *)(a2 + 16);
      if (!v38)
        goto LABEL_115;
      v39 = mDNSLogCategory_NAT;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
          goto LABEL_115;
        v40 = "failure";
        v41 = *(_DWORD *)(v38 + 168);
        if (!v41)
          v40 = "success";
      }
      else
      {
        v39 = mDNSLogCategory_NAT_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
          goto LABEL_115;
        v40 = "failure";
        v41 = *(_DWORD *)(v38 + 168);
        if (!v41)
          v40 = "success";
      }
      *(_DWORD *)buf = 136446466;
      v77 = (uint64_t)v40;
      v78 = 1024;
      *(_DWORD *)v79 = v41;
      v44 = "tcpConnectionCallback: PortMapRequest %{public}s result %d";
      v49 = v39;
      v50 = 18;
      break;
    case 2:
      v42 = mDNSLogCategory_NAT;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
          goto LABEL_115;
        if (*(_DWORD *)(v29 + 14744))
          v51 = "success";
        else
          v51 = "failure";
        *(_DWORD *)buf = 136446210;
        v77 = (uint64_t)v51;
        v44 = "tcpConnectionCallback: AddressRequest %{public}s";
      }
      else
      {
        v42 = mDNSLogCategory_NAT_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
          goto LABEL_115;
        if (*(_DWORD *)(v29 + 14744))
          v43 = "success";
        else
          v43 = "failure";
        *(_DWORD *)buf = 136446210;
        v77 = (uint64_t)v43;
        v44 = "tcpConnectionCallback: AddressRequest %{public}s";
      }
      v49 = v42;
      v50 = 12;
      break;
    case 1:
      v35 = mDNSLogCategory_NAT;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
          goto LABEL_115;
        v36 = *(const char **)(v29 + 15072);
        v37 = "NULL";
        if (!v36)
          v36 = "NULL";
        if (*(_QWORD *)(v29 + 15056))
          v37 = *(const char **)(v29 + 15056);
      }
      else
      {
        v35 = mDNSLogCategory_NAT_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
          goto LABEL_115;
        v36 = *(const char **)(v29 + 15072);
        v37 = "NULL";
        if (!v36)
          v36 = "NULL";
        if (*(_QWORD *)(v29 + 15056))
          v37 = *(const char **)(v29 + 15056);
      }
      *(_DWORD *)buf = 141558787;
      v77 = 1752392040;
      v78 = 2085;
      *(_QWORD *)v79 = v36;
      *(_WORD *)&v79[8] = 2160;
      *(_QWORD *)&v79[10] = 1752392040;
      *(_WORD *)&v79[18] = 2085;
      v80 = v37;
      v44 = "tcpConnectionCallback: DeviceDescription SOAP address %{sensitive, mask.hash}s SOAP path %{sensitive, mask.hash}s";
      v49 = v35;
      v50 = 42;
      break;
    default:
      goto LABEL_115;
  }
  _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, v44, buf, v50);
LABEL_115:
  mDNSPlatformTCPCloseConnection(a1);
  *(_QWORD *)(a2 + 24) = 0;
  v55 = *(void **)(a2 + 64);
  if (v55)
  {
    free(v55);
    *(_QWORD *)(a2 + 64) = 0;
  }
  v56 = *(void **)(a2 + 80);
  if (v56)
  {
    free(v56);
    *(_QWORD *)(a2 + 80) = 0;
    mDNS_Unlock_(*(_QWORD *)(a2 + 8), (uint64_t)"tcpConnectionCallback", 522);
    if ((v22 & 1) == 0)
      return;
  }
  else
  {
    mDNS_Unlock_(*(_QWORD *)(a2 + 8), (uint64_t)"tcpConnectionCallback", 522);
    if (!v22)
      return;
  }
  v57 = (_QWORD *)(*(_QWORD *)(a2 + 8) + 15008);
  do
  {
    v58 = v57;
    v57 = (_QWORD *)*v57;
    if (v57)
      v59 = v57 == (_QWORD *)a2;
    else
      v59 = 1;
  }
  while (!v59);
  if (v57)
  {
    *v58 = *v57;
    if (a2)
      free((void *)a2);
  }
}

void handleLNTDeviceDescriptionResponse(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v9;
  char *v10;
  uint64_t v12;
  unint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t *v25;
  void *v26;
  uint64_t *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  _BOOL4 v32;
  uint64_t v33;
  char *v34;
  NSObject *v35;
  char *v36;
  NSObject *v37;
  char *v38;
  uint64_t v39;
  int v40;
  char *v41;

  v9 = a1[1];
  v10 = (char *)a1[10];
  v41 = v10;
  if (*(_WORD *)(v9 + 15036))
    return;
  v12 = a1[12];
  v13 = (unint64_t)&v10[v12];
  v14 = ParseHTTPResponseCode((const char **)&v41, (unsigned __int8 *)&v10[v12]);
  if (v14 != 200)
  {
    v20 = v14;
    if ((unsigned __int16)v14 == 404)
      LNT_ClearState(v9);
    if (mDNS_LoggingEnabled == 1)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handleLNTDeviceDescriptionResponse: HTTP Result code: %d", v15, v16, v17, v18, v19, v20);
    return;
  }
  *(_BYTE *)(v9 + 15048) = 0;
  v21 = v41;
  if (v41 && (unint64_t)v41 < v13)
  {
    do
    {
      if ((*v21 & 0xDF) == 0x57 && !strncasecmp(v21, "WANIPConnection:1", 0x11uLL))
        break;
      if (!++v21)
        break;
    }
    while ((unint64_t)v21 < v13);
  }
  v41 = v21;
  if (v21 == (char *)v13)
  {
    v21 = (char *)a1[10];
    if (v21 && (unint64_t)v21 < v13)
    {
      while ((*v21 & 0xDF) != 0x57 || strncasecmp(v21, "WANPPPConnection:1", 0x12uLL))
      {
        if (!++v21 || (unint64_t)v21 >= v13)
          goto LABEL_21;
      }
      v41 = v21;
      *(_BYTE *)(v9 + 15048) = 1;
      goto LABEL_23;
    }
LABEL_21:
    v41 = v21;
  }
  if (!v21)
  {
LABEL_62:
    if (mDNS_LoggingEnabled != 1)
      return;
    v35 = mDNSLogCategory_Default;
    v36 = "handleLNTDeviceDescriptionResponse: didn't find WANIPConnection:1 or WANPPPConnection:1 string";
    goto LABEL_64;
  }
LABEL_23:
  if (v21 == (char *)v13)
    goto LABEL_62;
  while ((unint64_t)v21 < v13)
  {
    if ((*v21 & 0xDF) == 0x43 && !strncasecmp(v21, "controlURL", 0xAuLL))
      break;
    if (!++v21)
      break;
  }
  if (!v21 || v21 == (char *)v13)
  {
    if (mDNS_LoggingEnabled != 1)
      return;
    v35 = mDNSLogCategory_Default;
    v36 = "handleLNTDeviceDescriptionResponse: didn't find controlURL string";
    goto LABEL_64;
  }
  v22 = (uint64_t)(v21 + 11);
  v41 = v21 + 11;
  if ((unint64_t)(v21 + 11) >= v13)
  {
    if (mDNS_LoggingEnabled != 1)
      return;
    v35 = mDNSLogCategory_Default;
    v36 = "handleLNTDeviceDescriptionResponse: past end of buffer and no body!";
    goto LABEL_64;
  }
  v23 = &v10[v12] - v21 - 11;
  v24 = v21 + 11;
  while (*v24 != 60)
  {
    ++v24;
    if (!--v23)
    {
      v24 = &v10[v12];
      break;
    }
  }
  *(_WORD *)(v9 + 15036) = *(_WORD *)(v9 + 15034);
  v25 = (uint64_t *)(v9 + 15072);
  v26 = *(void **)(v9 + 15072);
  if (v26)
  {
    free(v26);
    *v25 = 0;
  }
  v27 = (uint64_t *)(v9 + 15056);
  v28 = *(void **)(v9 + 15056);
  if (v28)
  {
    free(v28);
    *v27 = 0;
  }
  if (!ParseHttpUrl(v22, (unint64_t)v24, (_QWORD *)(v9 + 15072), (_WORD *)(v9 + 15036), (_QWORD *)(v9 + 15056)))
  {
    v30 = *v25;
    if (*v25)
      goto LABEL_71;
    v31 = a1[10];
    v32 = v31 < (unint64_t)v24;
    if (v31 && v31 < (unint64_t)v24)
    {
      while ((*(_BYTE *)v31 & 0xDF) != 0x55 || strncasecmp((const char *)v31, "URLBase", 7uLL))
      {
        v32 = ++v31 < (unint64_t)v24;
        if (!v31 || v31 >= (unint64_t)v24)
          goto LABEL_48;
      }
    }
    else
    {
LABEL_48:
      if (!v32)
        goto LABEL_69;
    }
    if (mDNS_LoggingEnabled == 1)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handleLNTDeviceDescriptionResponse: found URLBase", v15, v16, v17, v18, v19, v40);
    v41 = (char *)(v31 + 8);
    if (v31 + 8 < (unint64_t)v24)
    {
      v33 = (uint64_t)&v24[-v31 - 8];
      v34 = (char *)(v31 + 8);
      while (!v34 || *v34 != 60)
      {
        ++v34;
        if (!--v33)
          goto LABEL_66;
      }
      v24 = v34;
    }
LABEL_66:
    if (ParseHttpUrl(v31 + 8, (unint64_t)v24, (_QWORD *)(v9 + 15072), (_WORD *)(v9 + 15036), 0)
      && mDNS_LoggingEnabled)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handleLNTDeviceDescriptionResponse: failed to parse URLBase", v15, v16, v17, v18, v19, v40);
    }
LABEL_69:
    v30 = *v25;
    if (!*v25)
    {
      AllocAndCopy((_QWORD *)(v9 + 15072), *(char **)(v9 + 15064), v29, v15, v16, v17, v18, v19, v40);
      v30 = *(_QWORD *)(v9 + 15072);
      if (!v30)
      {
        v37 = mDNSLogCategory_Default;
        v38 = "handleLNTDeviceDescriptionResponse: UPnPSOAPAddressString is NULL";
        goto LABEL_73;
      }
    }
LABEL_71:
    if (mDNS_LoggingEnabled != 1)
      goto LABEL_74;
    v37 = mDNSLogCategory_Default;
    v40 = v30;
    v38 = "handleLNTDeviceDescriptionResponse: SOAP address string [%s]";
LABEL_73:
    LogMsgWithLevel(v37, OS_LOG_TYPE_DEFAULT, v38, v15, v16, v17, v18, v19, v40);
LABEL_74:
    v39 = *v27;
    if (*v27
      || (AllocAndCopy((_QWORD *)(v9 + 15056), *(char **)(v9 + 15040), v29, v15, v16, v17, v18, v19, v40),
          (v39 = *(_QWORD *)(v9 + 15056)) != 0))
    {
      if (mDNS_LoggingEnabled == 1)
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handleLNTDeviceDescriptionResponse: SOAP URL [%s]", v15, v16, v17, v18, v19, v39);
      return;
    }
    v35 = mDNSLogCategory_Default;
    v36 = "handleLNTDeviceDescriptionResponse: UPnPSOAPURL is NULL";
LABEL_64:
    LogMsgWithLevel(v35, OS_LOG_TYPE_DEFAULT, v36, v15, v16, v17, v18, v19, a9);
  }
}

void handleLNTGetExternalAddressResponse(_QWORD *a1)
{
  uint64_t v1;
  char *v2;
  uint64_t v3;
  unint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  char *v12;
  int64_t v13;
  unint64_t v14;
  uint64_t v15;
  _BYTE *v16;
  char *v17;
  int v18;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  char *v27;
  int v28;

  v1 = a1[1];
  v28 = 0;
  v2 = (char *)a1[10];
  v27 = v2;
  v3 = a1[12];
  v4 = (unint64_t)&v2[v3];
  v5 = ParseHTTPResponseCode((const char **)&v27, (unsigned __int8 *)&v2[v3]);
  v11 = v5;
  if (v5 == 404)
  {
    LNT_ClearState(v1);
LABEL_22:
    if (mDNS_LoggingEnabled == 1)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handleLNTGetExternalAddressResponse: HTTP Result code: %d", v6, v7, v8, v9, v10, v11);
    return;
  }
  if ((unsigned __int16)v5 != 200)
    goto LABEL_22;
  v12 = v27;
  if ((unint64_t)v27 < v4)
  {
    v13 = &v2[v3] - v27;
    while (strncasecmp(v12, handleLNTGetExternalAddressResponse_tagname, 0x14uLL))
    {
      ++v12;
      if (!--v13)
      {
        v12 = &v2[v3];
        break;
      }
    }
  }
  v14 = (unint64_t)(v12 + 20);
  v27 = v12 + 20;
  if ((unint64_t)(v12 + 20) < v4)
  {
    v15 = &v2[v3] - v12 - 20;
    while (*(_BYTE *)v14 != 62)
    {
      v27 = (char *)++v14;
      if (!--v15)
      {
        v14 = (unint64_t)&v2[v3];
        break;
      }
    }
  }
  v16 = (_BYTE *)(v14 + 1);
  v27 = (char *)(v14 + 1);
  if (v14 + 1 < v4)
  {
    v17 = &v2[v3 + ~v14];
    while (1)
    {
      v18 = *v16;
      if (v18 != 46 && (v18 - 48) > 9)
        break;
      ++v16;
      if (!--v17)
        return;
    }
    *v16 = 0;
    v20 = (int)v27;
    if (inet_pton(2, v27, &v28) <= 0)
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handleLNTGetExternalAddressResponse: Router returned bad address %s", v21, v22, v23, v24, v25, v20);
      v28 = 0;
      v26 = 3;
    }
    else
    {
      if (mDNS_LoggingEnabled == 1)
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handleLNTGetExternalAddressResponse: External IP address is %.4a", v21, v22, v23, v24, v25, (int)&v28);
      v26 = 0;
    }
    natTraversalHandleAddressReply(v1, v26, v28, v21, v22, v23, v24, v25);
  }
}

void handleLNTPortMappingResponse(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v10;
  char *v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  char *v21;
  uint64_t v22;
  int v23;
  const char *v26;
  const char *v27;
  size_t v28;
  NSObject *v29;
  char *v30;
  unsigned int v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  char *v40;

  v10 = *(_QWORD *)(a1 + 8);
  v11 = *(char **)(a1 + 80);
  v40 = v11;
  v12 = *(_QWORD *)(a1 + 96);
  v13 = &v11[v12];
  v14 = v10 + 14720;
  while (1)
  {
    v14 = *(_QWORD *)v14;
    if (!v14)
      break;
    if (v14 == *(_QWORD *)(a1 + 16))
    {
      v20 = ParseHTTPResponseCode((const char **)&v40, (unsigned __int8 *)&v11[v12]);
      if ((unsigned __int16)v20 <= 0x1F3u)
      {
        if ((unsigned __int16)v20 == 200)
        {
          if (mDNS_LoggingEnabled == 1)
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handleLNTPortMappingResponse: got a valid response, sending reply to natTraversalHandlePortMapReply(internal %d external %d retries %d)", v15, v16, v17, v18, v19, bswap32(*(unsigned __int16 *)(v14 + 174)) >> 16);
          v31 = *(unsigned __int16 *)(v14 + 176);
          if (!*(_WORD *)(v14 + 176))
            v31 = *(unsigned __int16 *)(v14 + 174);
          v32 = bswap32(*(unsigned __int16 *)(v14 + 136) + (bswap32(v31) >> 16)) >> 16;
          *(_DWORD *)(a1 + 104) = 0;
          natTraversalHandlePortMapReplyWithAddress(v10, v14, *(_QWORD *)(v10 + 15016), 0, *(unsigned int *)(v10 + 14744), v32, 7200, 2);
        }
        else if ((unsigned __int16)v20 == 404)
        {
          LNT_ClearState(v10);
        }
        goto LABEL_38;
      }
      if ((unsigned __int16)v20 == 65534)
      {
        v29 = mDNSLogCategory_Default;
        v30 = "handleLNTPortMappingResponse got unexpected response code";
      }
      else
      {
        if ((unsigned __int16)v20 != 65533)
        {
          if ((unsigned __int16)v20 == 500)
          {
            v21 = v40;
            if (v40)
            {
              if (v40 != v13)
              {
                v22 = &v11[v12] - v40;
                while (1)
                {
                  v23 = *v21;
                  if ((v23 & 0xFFFFFFDF) != 0x43 || v22 < 8)
                  {
                    if (v23 != 62 || v22 < 15)
                      goto LABEL_22;
                    v26 = v21;
                    v27 = ">718</errorCode";
                    v28 = 15;
                  }
                  else
                  {
                    v26 = v21;
                    v27 = "Conflict";
                    v28 = 8;
                  }
                  if (!strncasecmp(v26, v27, v28))
                  {
                    v33 = *(_DWORD *)(a1 + 104);
                    if (v33 > 99)
                    {
                      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handleLNTPortMappingResponse too many conflict retries %d %d", v15, v16, v17, v18, v19, bswap32(*(unsigned __int16 *)(v14 + 174)) >> 16);
                      natTraversalHandlePortMapReplyWithAddress(v10, v14, *(_QWORD *)(v10 + 15016), 4, *(unsigned int *)(v10 + 14744), 0, 0, 2);
                    }
                    else
                    {
                      *(_DWORD *)(a1 + 104) = v33 + 1;
                      SendPortMapRequest(*(_QWORD *)(a1 + 8), v14);
                      if (mDNS_LoggingEnabled == 1)
                        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handleLNTPortMappingResponse: Conflict retry %d", v34, v35, v36, v37, v38, *(_DWORD *)(a1 + 104));
                    }
                    return;
                  }
LABEL_22:
                  if (++v21)
                  {
                    --v22;
                    if (v21 != v13)
                      continue;
                  }
                  break;
                }
              }
            }
          }
LABEL_38:
          if (mDNS_LoggingEnabled == 1 && v20 != 200 && (unsigned __int16)v20 != 500)
            LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handleLNTPortMappingResponse: HTTP Result code: %d", v15, v16, v17, v18, v19, v20);
          return;
        }
        v29 = mDNSLogCategory_Default;
        v30 = "handleLNTPortMappingResponse got data that was not a valid HTTP response";
      }
      LogMsgWithLevel(v29, OS_LOG_TYPE_DEFAULT, v30, v15, v16, v17, v18, v19, v39);
      goto LABEL_38;
    }
  }
  if (mDNS_LoggingEnabled == 1)
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "handleLNTPortMappingResponse: can't find matching tcpInfo in NATTraversals!", a4, a5, a6, a7, a8, a9);
}

uint64_t ParseHTTPResponseCode(const char **a1, unsigned __int8 *a2)
{
  const char *v2;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 *v12;
  _WORD *v14;
  unsigned __int8 *v15;
  int v19;

  v2 = *a1;
  if (a2 - (unsigned __int8 *)*a1 < 5)
    return -1;
  if (strncasecmp(*a1, "HTTP/", 5uLL))
    return -3;
  v12 = (unsigned __int8 *)(v2 + 5);
  if (v2 != (const char *)-5 && v12 != a2)
  {
    while (1)
    {
      v19 = *v12;
      if (v19 == 10)
        return -3;
      if (v19 != 32)
      {
        if (++v12)
        {
          if (v12 != a2)
            continue;
        }
      }
      break;
    }
  }
  if (v12 == a2)
    return -1;
  v14 = v12 + 1;
  if (a2 - (v12 + 1) < 3)
    return -1;
  v15 = v12 + 4;
  if (v12 != (unsigned __int8 *)-4)
  {
    do
    {
      if (v15 == a2)
        break;
      if (*v15 == 10)
        break;
      ++v15;
    }
    while (v15);
  }
  if (v15 == a2)
    return -1;
  *a1 = (const char *)(v15 + 1);
  if (*v14 == 12338 && v12[3] == 48)
  {
    return 200;
  }
  else if (*v14 == 12340 && v12[3] == 52)
  {
    return 404;
  }
  else if (*v14 == 12341 && v12[3] == 48)
  {
    return 500;
  }
  else
  {
    if (mDNS_LoggingEnabled == 1)
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ParseHTTPResponseCode found unexpected result code: %c%c%c", v6, v7, v8, v9, v10, v12[1]);
    return -2;
  }
}

uint64_t ParseHttpUrl(uint64_t result, unint64_t a2, _QWORD *a3, _WORD *a4, _QWORD *a5)
{
  unsigned __int8 *v7;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  unsigned __int8 *v19;
  uint64_t v20;
  unsigned __int8 *v21;
  unsigned __int8 *v22;
  unsigned int v23;
  uint64_t v24;
  unsigned __int8 *v25;
  int v26;
  unsigned __int8 *v27;
  unsigned __int8 *v28;
  int v29;
  int v30;

  v7 = (unsigned __int8 *)result;
  if ((uint64_t)(a2 - result) >= 7)
  {
    result = strncasecmp((const char *)result, "http://", 7uLL);
    if (!(_DWORD)result)
    {
      v19 = v7 + 7;
      if ((unint64_t)(v7 + 7) >= a2)
      {
        v15 = 4294901756;
        if (mDNS_LoggingEnabled == 1)
          LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "ParseHttpUrl: past end of buffer parsing host:port", v10, v11, v12, v13, v14, v30);
        return v15;
      }
      if (v7 == (unsigned __int8 *)-7)
      {
        result = (uint64_t)malloc_type_malloc(1uLL, 0xA172743EuLL);
        if (result)
          *a3 = result;
        goto LABEL_36;
      }
      v20 = 0;
      while (1)
      {
        v21 = &v7[v20];
        if (v7[v20 + 7] == 47)
          break;
        ++v20;
        v22 = v21 + 8;
        if (!v22 || v22 == (unsigned __int8 *)a2)
        {
          v21 = &v7[v20];
          break;
        }
      }
      v7 = v21 + 7;
      v23 = v20 + 1;
      if ((_DWORD)v20 == -1)
        goto LABEL_36;
      result = (uint64_t)malloc_type_malloc((v20 + 1), 0xA172743EuLL);
      if (!result)
        goto LABEL_36;
      *a3 = result;
      if (v23 < 2)
      {
LABEL_25:
        *(_BYTE *)result = 0;
      }
      else
      {
        v24 = (int)v23;
        v25 = v19;
        while (1)
        {
          v26 = *v25;
          *(_BYTE *)result = v26;
          if (!v26)
            break;
          ++result;
          ++v25;
          if ((unint64_t)--v24 <= 1)
            goto LABEL_25;
        }
      }
      v27 = v7 - 1;
      while (v27 > v19)
      {
        v28 = v27--;
        v29 = *v28;
        result = (uint64_t)(v28 + 1);
        if (v29 == 58)
        {
          result = strtol((const char *)result, 0, 10);
          *a4 = bswap32(result) >> 16;
          break;
        }
      }
    }
  }
  v15 = 0;
  if (!a5 || (unint64_t)v7 >= a2)
    return v15;
  v16 = a2 - (_DWORD)v7;
  v17 = (a2 - (_DWORD)v7 + 1);
  if (v16 != -1)
  {
    result = (uint64_t)malloc_type_malloc((v16 + 1), 0xA172743EuLL);
    if (result)
    {
      *a5 = result;
      if (v7)
      {
        if (v17 < 2)
        {
LABEL_11:
          v15 = 0;
          *(_BYTE *)result = 0;
        }
        else
        {
          while (1)
          {
            v18 = *v7;
            *(_BYTE *)result = v18;
            if (!v18)
              return 0;
            ++result;
            ++v7;
            if ((unint64_t)--v17 <= 1)
              goto LABEL_11;
          }
        }
        return v15;
      }
    }
  }
LABEL_36:
  __break(1u);
  return result;
}

void AllocAndCopy(_QWORD *a1, char *__s, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  size_t v16;
  void *v17;

  if (__s)
  {
    v16 = strlen(__s) + 1;
    if (HIDWORD(v16))
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "AllocAndCopy: can't allocate string", v11, v12, v13, v14, v15, a9);
    }
    else if ((_DWORD)v16 && (v17 = malloc_type_malloc(v16, 0xA172743EuLL)) != 0)
    {
      *a1 = v17;
      memcpy(v17, __s, v16);
    }
    else
    {
      __break(1u);
    }
  }
}

void GetDeviceDescription(uint64_t a1, uint64_t a2)
{
  unsigned __int16 *v2;
  void *v5;
  void *v6;
  NSObject *v7;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint8_t buf[4];
  uint64_t v14;

  v2 = (unsigned __int16 *)(a1 + 15034);
  if (!*(_WORD *)(a1 + 15036))
  {
    if (!*(_QWORD *)(a1 + 15040) || !*(_QWORD *)(a1 + 15064))
    {
      v7 = mDNSLogCategory_NAT;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
          return;
        *(_WORD *)buf = 0;
      }
      else
      {
        v7 = mDNSLogCategory_NAT_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
          return;
        *(_WORD *)buf = 0;
      }
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "GetDeviceDescription: no router URL or address string!", buf, 2u);
      return;
    }
    v5 = *(void **)(a2 + 64);
    if (v5)
    {
      bzero(v5, 0x2000uLL);
      v6 = *(void **)(a2 + 64);
    }
    else
    {
      v6 = malloc_type_malloc(0x2000uLL, 0xA172743EuLL);
      if (!v6)
        __break(1u);
      *(_QWORD *)(a2 + 64) = v6;
    }
    *(_DWORD *)(a2 + 72) = mDNS_snprintf(v6);
    v10 = mDNSLogCategory_NAT;
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_NAT == mDNSLogCategory_State)
    {
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT, OS_LOG_TYPE_DEFAULT))
      {
        v12 = *(_QWORD *)(a2 + 64);
        *(_DWORD *)buf = 136446210;
        v14 = v12;
        goto LABEL_25;
      }
    }
    else
    {
      v10 = mDNSLogCategory_NAT_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_NAT_redacted, OS_LOG_TYPE_DEFAULT))
      {
        v11 = *(_QWORD *)(a2 + 64);
        *(_DWORD *)buf = 136446210;
        v14 = v11;
LABEL_25:
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Describe Device: [%{public}s]", buf, 0xCu);
      }
    }
    MakeTCPConnection(a1, a2, (int *)(a1 + 12696), *v2, 1);
  }
}

void LNT_SendDiscoveryMsg(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  int *v7;
  uint64_t v8;

  if (!*(_BYTE *)(a1 + 141))
  {
    v2 = a1 + 15032;
    if (*(_WORD *)(a1 + 15034))
    {
      v3 = *(void **)(a1 + 15024);
      if (v3)
      {
        CloseSocketSet(*(_QWORD *)(a1 + 15024));
        free(v3);
        *(_QWORD *)(a1 + 15024) = 0;
      }
      if (!*(_WORD *)(v2 + 4) && !*(_QWORD *)(a1 + 14920))
        GetDeviceDescription(a1, a1 + 14896);
    }
    else
    {
      v4 = a1 + 28960;
      if (*(int *)(a1 + 14736) < 251)
        *(_BYTE *)v2 = 0;
      v5 = mDNS_snprintf((void *)(a1 + 28960));
      if (*(_DWORD *)(a1 + 12700))
      {
        v6 = v5;
        v7 = *(int **)(a1 + 15024);
        if (!v7)
        {
          v7 = mDNSPlatformUDPSocket(0);
          *(_QWORD *)(a1 + 15024) = v7;
        }
        v8 = v4 + v6;
        mDNSPlatformSendUDP((_QWORD *)a1, (unsigned __int16 *)(a1 + 28960), v8, 0, (uint64_t)v7, (int *)(a1 + 12696), 0x6C07u, 0);
        mDNSPlatformSendUDP((_QWORD *)a1, (unsigned __int16 *)(a1 + 28960), v8, 0, *(_QWORD *)(a1 + 15024), LNT_SendDiscoveryMsg_multicastDest, 0x6C07u, 0);
      }
      *(_BYTE *)v2 = *(_BYTE *)v2 == 0;
    }
  }
}

uint64_t dump_state_to_fd(unsigned int a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  int v50;
  uint64_t v51;
  uint64_t i;
  uint64_t v53;
  uint64_t *v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  unint64_t v59;
  uint64_t v60;
  __int128 *v61;
  __int128 *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  int v89;
  _QWORD *j;
  uint64_t *k;
  int v92;
  int v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  int v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  int v115;
  int v116;
  uint64_t v117;
  int v118;
  _QWORD *v119;
  unsigned __int8 *v120;
  uint64_t v121;
  int v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  int v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  int v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  int v180;
  int n;
  int v182;
  __int128 *v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  const char *v204;
  const char *v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t ii;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  _QWORD *jj;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  _QWORD *v247;
  int v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  uint64_t v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  uint64_t v284;
  _QWORD *v285;
  uint64_t v286;
  uint64_t v287;
  uint64_t v288;
  uint64_t v289;
  uint64_t v290;
  uint64_t v291;
  _QWORD *v292;
  uint64_t v293;
  uint64_t v294;
  uint64_t v295;
  uint64_t v296;
  uint64_t v297;
  uint64_t v298;
  _QWORD *v299;
  __int128 *v300;
  uint64_t v301;
  uint64_t v302;
  uint64_t v303;
  uint64_t v304;
  uint64_t v305;
  uint64_t v306;
  uint64_t v307;
  uint64_t v308;
  uint64_t v309;
  uint64_t v310;
  uint64_t v311;
  uint64_t v312;
  uint64_t v313;
  uint64_t v314;
  uint64_t v315;
  uint64_t v316;
  uint64_t v317;
  uint64_t v318;
  uint64_t v319;
  uint64_t v320;
  uint64_t v321;
  uint64_t v322;
  uint64_t v323;
  uint64_t v324;
  uint64_t v325;
  uint64_t v326;
  uint64_t v327;
  uint64_t v328;
  uint64_t v329;
  uint64_t v330;
  uint64_t v331;
  uint64_t v332;
  uint64_t v333;
  uint64_t v334;
  uint64_t v335;
  uint64_t v336;
  uint64_t v337;
  uint64_t v338;
  uint64_t v339;
  uint64_t v340;
  uint64_t v341;
  uint64_t v342;
  uint64_t v343;
  uint64_t v344;
  uint64_t v345;
  uint64_t v346;
  uint64_t v347;
  uint64_t v348;
  uint64_t v349;
  uint64_t v350;
  uint64_t v351;
  uint64_t v352;
  uint64_t v353;
  uint64_t v354;
  uint64_t v355;
  uint64_t v356;
  uint64_t v357;
  uint64_t v358;
  uint64_t v359;
  uint64_t v360;
  uint64_t v361;
  uint64_t v362;
  uint64_t v363;
  uint64_t v364;
  uint64_t v365;
  uint64_t v366;
  uint64_t v367;
  uint64_t v368;
  uint64_t v369;
  uint64_t v370;
  uint64_t v371;
  uint64_t v372;
  uint64_t v373;
  uint64_t v374;
  uint64_t v375;
  uint64_t v376;
  uint64_t v377;
  uint64_t v378;
  uint64_t v379;
  uint64_t v380;
  uint64_t v381;
  uint64_t v382;
  uint64_t v383;
  uint64_t v384;
  uint64_t v385;
  uint64_t v386;
  uint64_t v387;
  uint64_t v388;
  uint64_t v389;
  uint64_t v390;
  uint64_t v391;
  uint64_t v392;
  uint64_t v393;
  uint64_t v394;
  uint64_t v395;
  uint64_t v396;
  uint64_t v397;
  uint64_t v398;
  uint64_t v399;
  uint64_t v400;
  uint64_t v401;
  uint64_t v402;
  uint64_t v403;
  uint64_t v404;
  uint64_t v405;
  uint64_t v406;
  uint64_t v407;
  uint64_t v408;
  uint64_t v409;
  uint64_t v410;
  uint64_t v411;
  uint64_t v412;
  uint64_t v413;
  uint64_t v414;
  uint64_t v415;
  uint64_t v416;
  uint64_t v417;
  uint64_t v418;
  uint64_t v419;
  uint64_t v420;
  uint64_t v421;
  uint64_t v422;
  uint64_t v423;
  uint64_t v424;
  uint64_t v425;
  uint64_t v426;
  uint64_t v427;
  uint64_t v428;
  uint64_t v429;
  uint64_t v430;
  uint64_t v431;
  uint64_t v432;
  uint64_t v433;
  uint64_t v434;
  uint64_t v435;
  uint64_t v436;
  uint64_t v437;
  uint64_t v438;
  uint64_t v439;
  uint64_t v440;
  uint64_t v441;
  uint64_t v442;
  uint64_t v443;
  uint64_t v444;
  uint64_t v445;
  uint64_t v446;
  uint64_t v447;
  uint64_t v448;
  uint64_t v449;
  uint64_t v450;
  uint64_t v451;
  uint64_t v452;
  uint64_t v453;
  uint64_t v454;
  uint64_t v455;
  uint64_t v456;
  uint64_t v457;
  uint64_t v458;
  uint64_t v459;
  uint64_t v460;
  uint64_t v461;
  uint64_t v462;
  uint64_t v463;
  uint64_t v464;
  uint64_t v465;
  uint64_t v466;
  uint64_t v467;
  uint64_t v468;
  uint64_t v469;
  uint64_t v470;
  uint64_t v471;
  uint64_t v472;
  uint64_t v473;
  uint64_t v474;
  int v475;
  uint64_t v476;
  uint64_t v477;
  uint64_t v478;
  uint64_t v479;
  uint64_t v480;
  uint64_t v481;
  uint64_t v482;
  uint64_t v483;
  uint64_t v484;
  uint64_t v485;
  uint64_t v486;
  uint64_t v487;
  int v488;
  uint64_t v489;
  uint64_t v490;
  uint64_t v491;
  uint64_t v492;
  uint64_t v493;
  uint64_t v494;
  uint64_t v495;
  uint64_t v496;
  uint64_t v497;
  uint64_t v498;
  uint64_t v499;
  uint64_t v500;
  int v501;
  uint64_t v502;
  uint64_t v503;
  uint64_t v504;
  uint64_t v505;
  uint64_t v506;
  uint64_t v507;
  uint64_t v508;
  uint64_t v509;
  uint64_t v510;
  uint64_t v511;
  uint64_t v512;
  uint64_t v513;
  const char *v514;
  uint64_t v515;
  uint64_t v516;
  uint64_t v517;
  uint64_t v518;
  uint64_t v519;
  uint64_t v520;
  const char *v521;
  uint64_t v522;
  uint64_t v523;
  uint64_t v524;
  uint64_t v525;
  uint64_t v526;
  uint64_t v527;
  uint64_t v528;
  uint64_t v529;
  uint64_t v530;
  uint64_t v531;
  uint64_t v532;
  uint64_t v533;
  uint64_t v534;
  uint64_t v535;
  uint64_t v536;
  uint64_t v537;
  uint64_t v538;
  uint64_t v539;
  uint64_t v540;
  uint64_t v541;
  uint64_t v542;
  uint64_t v543;
  uint64_t v544;
  uint64_t v545;
  uint64_t v546;
  uint64_t v547;
  uint64_t v548;
  uint64_t v549;
  uint64_t v550;
  uint64_t v551;
  uint64_t v552;
  uint64_t v553;
  uint64_t v554;
  uint64_t v555;
  uint64_t v556;
  uint64_t v557;
  uint64_t v558;
  uint64_t v559;
  uint64_t v560;
  uint64_t v561;
  uint64_t v562;
  uint64_t v563;
  uint64_t v564;
  uint64_t v565;
  uint64_t v566;
  uint64_t v567;
  uint64_t v568;
  uint64_t v569;
  uint64_t v570;
  uint64_t v571;
  uint64_t v572;
  uint64_t v573;
  uint64_t v574;
  uint64_t v575;
  uint64_t v576;
  uint64_t v577;
  uint64_t v578;
  uint64_t v579;
  uint64_t v580;
  uint64_t v581;
  uint64_t v582;
  uint64_t v583;
  uint64_t v584;
  uint64_t v585;
  uint64_t v586;
  uint64_t v587;
  uint64_t v588;
  uint64_t v589;
  uint64_t v590;
  uint64_t v591;
  uint64_t v592;
  uint64_t v593;
  uint64_t v594;
  uint64_t v595;
  uint64_t v596;
  uint64_t v597;
  uint64_t v598;
  uint64_t v599;
  uint64_t v600;
  uint64_t v601;
  uint64_t v602;
  uint64_t v603;
  uint64_t v604;
  uint64_t v605;
  uint64_t v606;
  uint64_t v607;
  uint64_t v608;
  uint64_t v609;
  uint64_t v610;
  uint64_t v611;
  uint64_t v612;
  uint64_t v613;
  uint64_t v614;
  uint64_t v615;
  uint64_t v616;
  uint64_t v617;
  uint64_t v618;
  uint64_t v619;
  uint64_t v620;
  uint64_t v621;
  uint64_t v622;
  uint64_t v623;
  uint64_t v624;
  uint64_t v625;
  uint64_t v626;
  uint64_t v627;
  uint64_t v628;
  uint64_t v629;
  uint64_t v630;
  uint64_t v631;
  uint64_t v632;
  uint64_t v633;
  uint64_t v634;
  uint64_t v635;
  uint64_t v636;
  uint64_t v637;
  uint64_t v638;
  uint64_t v639;
  uint64_t v640;
  uint64_t v641;
  uint64_t v642;
  uint64_t v643;
  uint64_t v644;
  uint64_t v645;
  uint64_t v646;
  uint64_t v647;
  uint64_t v648;
  uint64_t v649;
  uint64_t v650;
  uint64_t v651;
  uint64_t v652;
  uint64_t v653;
  uint64_t v654;
  uint64_t v655;
  uint64_t v656;
  uint64_t v657;
  uint64_t v658;
  uint64_t v659;
  uint64_t v660;
  uint64_t v661;
  uint64_t v662;
  uint64_t v663;
  uint64_t v664;
  uint64_t v665;
  uint64_t v666;
  uint64_t v667;
  uint64_t v668;
  uint64_t v669;
  uint64_t v670;
  uint64_t v671;
  uint64_t v672;
  uint64_t v673;
  uint64_t v674;
  uint64_t v675;
  uint64_t v676;
  uint64_t v677;
  uint64_t v678;
  uint64_t v679;
  uint64_t v680;
  uint64_t v681;
  uint64_t v682;
  uint64_t v683;
  uint64_t v684;
  uint64_t v685;
  uint64_t v686;
  uint64_t v687;
  uint64_t v688;
  uint64_t v689;
  uint64_t v690;
  uint64_t v691;
  uint64_t v692;
  uint64_t v693;
  uint64_t v694;
  uint64_t v695;
  uint64_t v696;
  uint64_t v697;
  uint64_t v698;
  uint64_t v699;
  uint64_t v700;
  uint64_t v701;
  uint64_t v702;
  uint64_t v703;
  uint64_t v704;
  uint64_t v705;
  uint64_t v706;
  uint64_t v707;
  uint64_t v708;
  uint64_t v709;
  uint64_t v710;
  uint64_t v711;
  uint64_t v712;
  uint64_t v713;
  uint64_t v714;
  uint64_t v715;
  uint64_t v716;
  uint64_t v717;
  uint64_t v718;
  uint64_t v719;
  uint64_t v720;
  uint64_t v721;
  uint64_t v722;
  uint64_t v723;
  uint64_t v724;
  uint64_t v725;
  uint64_t v726;
  uint64_t v727;
  uint64_t v728;
  uint64_t v729;
  uint64_t v730;
  uint64_t v731;
  uint64_t v732;
  uint64_t v733;
  uint64_t v734;
  uint64_t v735;
  uint64_t v736;
  uint64_t v737;
  uint64_t v738;
  uint64_t v739;
  uint64_t v740;
  uint64_t v741;
  uint64_t v742;
  uint64_t v743;
  uint64_t v744;
  uint64_t v745;
  uint64_t v746;
  uint64_t v747;
  uint64_t v748;
  uint64_t v749;
  uint64_t v750;
  uint64_t v751;
  uint64_t v752;
  uint64_t v753;
  uint64_t v754;
  uint64_t v755;
  uint64_t v756;
  uint64_t v757;
  uint64_t v758;
  uint64_t v759;
  uint64_t v760;
  uint64_t v761;
  uint64_t v762;
  uint64_t kk;
  uint64_t v764;
  const char *v765;
  uint64_t DNSServiceManager;
  uint64_t v767;
  uint64_t v768;
  uint64_t v769;
  uint64_t v770;
  uint64_t v771;
  uint64_t v772;
  uint64_t v773;
  uint64_t v774;
  uint64_t v775;
  uint64_t v776;
  uint64_t v777;
  uint64_t v778;
  uint64_t v779;
  uint64_t v780;
  uint64_t v781;
  uint64_t v782;
  uint64_t v783;
  uint64_t v784;
  uint64_t v785;
  uint64_t v786;
  uint64_t v787;
  uint64_t v788;
  uint64_t v789;
  uint64_t v790;
  uint64_t v791;
  uint64_t v792;
  uint64_t v793;
  uint64_t v794;
  uint64_t v795;
  uint64_t v796;
  _QWORD *v797;
  uint64_t v798;
  uint64_t v799;
  uint64_t v800;
  uint64_t v801;
  uint64_t v802;
  uint64_t v803;
  unsigned __int8 *v804;
  uint64_t v805;
  uint64_t v806;
  uint64_t v807;
  uint64_t v808;
  uint64_t v809;
  uint64_t v810;
  uint64_t v811;
  uint64_t v812;
  uint64_t v813;
  uint64_t v814;
  uint64_t v815;
  uint64_t v816;
  uint64_t v817;
  uint64_t v818;
  uint64_t v819;
  uint64_t v820;
  uint64_t v821;
  uint64_t v822;
  uint64_t v823;
  uint64_t v824;
  uint64_t v825;
  uint64_t v826;
  uint64_t v827;
  uint64_t v828;
  uint64_t v829;
  uint64_t v830;
  uint64_t v831;
  uint64_t v832;
  uint64_t v833;
  uint64_t v834;
  uint64_t v835;
  uint64_t v836;
  uint64_t v837;
  uint64_t v838;
  uint64_t v839;
  uint64_t v840;
  uint64_t v841;
  uint64_t v842;
  uint64_t v843;
  uint64_t v844;
  uint64_t v845;
  uint64_t v846;
  uint64_t v847;
  uint64_t v848;
  uint64_t v849;
  uint64_t v850;
  uint64_t v851;
  uint64_t v852;
  uint64_t v853;
  uint64_t v854;
  uint64_t v855;
  uint64_t v856;
  uint64_t v857;
  uint64_t v858;
  uint64_t v859;
  uint64_t v860;
  uint64_t v861;
  uint64_t v862;
  uint64_t v863;
  uint64_t v864;
  uint64_t v865;
  uint64_t v866;
  uint64_t v867;
  uint64_t v868;
  uint64_t v869;
  uint64_t v870;
  uint64_t v871;
  uint64_t v872;
  uint64_t v873;
  uint64_t v874;
  uint64_t v875;
  uint64_t v876;
  uint64_t v877;
  uint64_t v878;
  uint64_t v879;
  uint64_t v880;
  uint64_t v881;
  uint64_t v882;
  uint64_t v883;
  uint64_t v884;
  uint64_t v885;
  uint64_t v886;
  uint64_t v887;
  uint64_t v888;
  uint64_t v889;
  uint64_t v890;
  uint64_t v891;
  uint64_t v892;
  uint64_t v893;
  uint64_t v894;
  uint64_t v895;
  uint64_t v896;
  uint64_t v897;
  uint64_t v898;
  uint64_t v899;
  uint64_t v900;
  uint64_t v901;
  uint64_t v902;
  uint64_t v903;
  uint64_t v904;
  uint64_t v905;
  uint64_t v906;
  uint64_t v907;
  uint64_t v908;
  uint64_t v909;
  uint64_t v910;
  uint64_t v911;
  uint64_t v912;
  uint64_t v913;
  uint64_t v914;
  uint64_t v915;
  uint64_t v916;
  uint64_t v917;
  uint64_t v918;
  uint64_t v919;
  uint64_t *v920;
  uint64_t v921;
  uint64_t v922;
  uint64_t v923;
  uint64_t v924;
  uint64_t v925;
  uint64_t v926;
  uint64_t v927;
  uint64_t v928;
  uint64_t v929;
  uint64_t v930;
  uint64_t v931;
  uint64_t v932;
  uint64_t v933;
  uint64_t v934;
  uint64_t v935;
  uint64_t v936;
  uint64_t v937;
  uint64_t v938;
  uint64_t v939;
  uint64_t v940;
  uint64_t v941;
  uint64_t v942;
  uint64_t v943;
  uint64_t v944;
  uint64_t v945;
  uint64_t v946;
  uint64_t v947;
  uint64_t v948;
  uint64_t v949;
  uint64_t v950;
  uint64_t v951;
  uint64_t v952;
  uint64_t v953;
  uint64_t v954;
  uint64_t v955;
  uint64_t v956;
  uint64_t v957;
  uint64_t v958;
  uint64_t v959;
  uint64_t v960;
  uint64_t v961;
  uint64_t v962;
  uint64_t v963;
  uint64_t v964;
  uint64_t v965;
  uint64_t v966;
  uint64_t v967;
  uint64_t v968;
  uint64_t v969;
  uint64_t v970;
  uint64_t v971;
  uint64_t v972;
  uint64_t v973;
  uint64_t v974;
  uint64_t v975;
  uint64_t v976;
  uint64_t v977;
  uint64_t v978;
  uint64_t v979;
  uint64_t v980;
  uint64_t v981;
  uint64_t v982;
  uint64_t v983;
  uint64_t v984;
  uint64_t v985;
  uint64_t v986;
  uint64_t v987;
  uint64_t v988;
  uint64_t v989;
  uint64_t v990;
  uint64_t v991;
  uint64_t v992;
  uint64_t v993;
  uint64_t v994;
  uint64_t v995;
  uint64_t v996;
  uint64_t v997;
  uint64_t v998;
  uint64_t v999;
  uint64_t v1000;
  uint64_t v1001;
  uint64_t v1002;
  uint64_t v1003;
  uint64_t v1004;
  uint64_t v1005;
  uint64_t v1006;
  uint64_t v1007;
  uint64_t v1008;
  uint64_t v1009;
  uint64_t v1010;
  int v1011;
  uint64_t v1012;
  uint64_t v1013;
  uint64_t v1014;
  uint64_t v1015;
  uint64_t v1016;
  uint64_t v1017;
  uint64_t v1018;
  uint64_t v1019;
  uint64_t v1020;
  uint64_t v1021;
  uint64_t v1022;
  uint64_t v1023;
  uint64_t v1024;
  uint64_t v1025;
  uint64_t v1026;
  uint64_t v1027;
  uint64_t v1028;
  uint64_t v1029;
  uint64_t v1030;
  uint64_t v1031;
  uint64_t v1032;
  uint64_t v1033;
  uint64_t v1034;
  uint64_t v1035;
  uint64_t v1036;
  uint64_t v1037;
  uint64_t v1038;
  uint64_t v1039;
  uint64_t v1040;
  uint64_t v1041;
  uint64_t v1042;
  uint64_t v1043;
  uint64_t v1044;
  uint64_t v1045;
  uint64_t v1046;
  uint64_t v1047;
  uint64_t v1048;
  uint64_t v1049;
  uint64_t v1050;
  uint64_t v1051;
  uint64_t v1052;
  uint64_t v1053;
  uint64_t v1054;
  uint64_t v1055;
  uint64_t v1056;
  uint64_t v1057;
  uint64_t v1058;
  uint64_t v1059;
  uint64_t v1060;
  uint64_t v1061;
  uint64_t v1062;
  int v1063;
  uint64_t v1064;
  uint64_t v1065;
  _QWORD *v1066;
  unsigned int v1067;
  uint64_t v1068;
  uint64_t v1069;
  uint64_t v1070;
  uint64_t v1071;
  uint64_t v1072;
  uint64_t v1073;
  _QWORD *v1074;
  int v1075;
  unsigned int v1076;
  unsigned int v1077;
  uint64_t v1078;
  uint64_t v1079;
  uint64_t v1080;
  uint64_t v1081;
  uint64_t v1082;
  uint64_t v1083;
  uint64_t v1084;
  char *v1085;
  uint64_t v1086;
  uint64_t v1087;
  uint64_t v1088;
  uint64_t v1089;
  uint64_t v1090;
  uint64_t v1091;
  uint64_t v1092;
  uint64_t v1093;
  uint64_t v1094;
  uint64_t v1095;
  uint64_t v1096;
  uint64_t v1097;
  uint64_t v1098;
  uint64_t v1099;
  uint64_t v1100;
  uint64_t v1101;
  uint64_t v1102;
  uint64_t v1103;
  uint64_t v1104;
  uint64_t v1105;
  uint64_t v1106;
  uint64_t v1107;
  uint64_t v1108;
  uint64_t v1109;
  NSObject *v1110;
  uint64_t v1111;
  uint64_t v1112;
  uint64_t v1113;
  uint64_t v1114;
  uint64_t v1115;
  uint64_t v1116;
  int v1118;
  int v1119;
  int v1120;
  int v1121;
  int v1122;
  int v1123;
  int v1124;
  int v1125;
  int v1126;
  int v1127;
  int v1128;
  int v1129;
  int v1130;
  int v1131;
  int v1132;
  int v1133;
  int v1134;
  int v1135;
  int v1136;
  int v1137;
  int v1138;
  int v1139;
  int v1140;
  int v1141;
  int v1142;
  int v1143;
  int v1144;
  int v1145;
  int v1146;
  int v1147;
  int v1148;
  int v1149;
  int v1150;
  int v1151;
  int v1152;
  int v1153;
  int v1154;
  int v1155;
  int v1156;
  int v1157;
  int v1158;
  int v1159;
  int v1160;
  int v1161;
  int v1162;
  int v1163;
  int v1164;
  int v1165;
  int v1166;
  int v1167;
  int v1168;
  int v1169;
  int v1170;
  int v1171;
  int v1172;
  int v1173;
  int v1174;
  int v1175;
  int v1176;
  int v1177;
  uint64_t *v1178;
  uint64_t v1179;
  uint64_t *v1180;
  uint64_t v1181;
  _QWORD *v1182;
  int v1183;
  uint64_t v1184;
  int m;
  int v1186;
  uint64_t v1187;
  int v1188;
  unsigned int v1189;
  _QWORD v1190[4];
  int v1191;
  uint64_t v1192;
  _OWORD v1193[2];
  _OWORD v1194[2];
  uint64_t v1195;
  timeval v1196;

  time(0);
  v1177 = mDNS_TimeNow(mDNSStorage, v2, v3, v4, v5, v6, v7, v8);
  memset(v1193, 0, sizeof(v1193));
  LogToFD(a1, "---- BEGIN STATE LOG ---- %s %s %d", v9, v10, v11, v12, v13, v14, (int)"mDNSResponder mDNSResponder-2559.2.4 (Aug  3 2024 11:06:39)");
  v1196.tv_sec = 0;
  *(_QWORD *)&v1196.tv_usec = 0;
  gettimeofday(&v1196, 0);
  getLocalTimestampFromTimeval((uint64_t)&v1196, (char *)v1193);
  v1189 = a1;
  LogToFD(a1, "Date: %s", v15, v16, v17, v18, v19, v20, (int)v1193);
  v21 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v1196.tv_sec) = 136446210;
      *(__darwin_time_t *)((char *)&v1196.tv_sec + 4) = (__darwin_time_t)v1193;
      goto LABEL_7;
    }
  }
  else
  {
    v21 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v1196.tv_sec) = 136446210;
      *(__darwin_time_t *)((char *)&v1196.tv_sec + 4) = (__darwin_time_t)v1193;
LABEL_7:
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "---- BEGIN STATE LOG ---- (%{public}s)", (uint8_t *)&v1196, 0xCu);
    }
  }
  v29 = mDNS_TimeNow(mDNSStorage, v22, v23, v24, v25, v26, v27, v28);
  LODWORD(v1196.tv_sec) = 0;
  LODWORD(v1194[0]) = 0;
  v1192 = 0;
  LogToFD(a1, "------------ Cache -------------", v30, v31, v32, v33, v34, v35, v1118);
  LogToFD(a1, "Slt Q     TTL if     U Type     DNSSEC                                   rdlen", v36, v37, v38, v39, v40, v41, v1119);
  v48 = 0;
  v49 = 0;
  v50 = 0;
  v1188 = v29;
  do
  {
    v51 = mDNSStorage[v48 + 34];
    if (v51)
    {
      do
      {
        v1180 = (uint64_t *)v51;
        v1183 = v49;
        for (i = *(_QWORD *)(v51 + 16); i; v29 = v1188)
        {
          v53 = *(_QWORD *)(i + 32);
          if (v53)
            v54 = (uint64_t *)((char *)&v1192 + 4);
          else
            v54 = &v1192;
          v55 = *(_QWORD *)(i + 56);
          if (v55)
          {
            if (!v53)
            {
              v56 = *(_QWORD *)(v55 + 24);
              if (v56)
              {
                v57 = *(unsigned __int8 *)(v56 + 280);
                if (v57 == 5 || v57 == 2)
                  v53 = *(unsigned int *)(v56 + 256);
                else
                  v53 = 0;
              }
            }
          }
          v59 = -274877907 * (v29 - *(_DWORD *)(i + 80));
          v60 = (v59 >> 63) + (SHIDWORD(v59) >> 6) + *(_DWORD *)(i + 16);
          v61 = &xmmword_10015BF38;
          while (1)
          {
            v61 = *(__int128 **)v61;
            if (!v61)
              break;
            v62 = v61;
            if (*((_QWORD *)v61 + 444) == v53)
              goto LABEL_28;
          }
          v62 = 0;
LABEL_28:
          if (v61)
            v63 = (uint64_t)v62 + 3606;
          else
            v63 = 0;
          if (*(_QWORD *)(i + 96))
            ++v50;
          PrintOneCacheRecordToFD(a1, i, v48, v60, v63, v54);
          v64 = *(_QWORD *)(i + 120);
          if (v64)
            PrintOneCacheRecordToFD(a1, v64, v48, v60, v63, v54);
          i = *(_QWORD *)i;
        }
        v49 = v1183 + 1;
        v51 = *v1180;
      }
      while (*v1180);
    }
    ++v48;
  }
  while (v48 != 499);
  if (dword_100158EBC != HIDWORD(v1192) + v49 + (_DWORD)v1192)
    LogToFD(a1, "Cache use mismatch: rrcache_totalused is %lu, true count %lu", v42, v43, v44, v45, v46, v47, dword_100158EBC);
  if ((_DWORD)qword_100158EC4 != v50)
    LogToFD(a1, "Cache use mismatch: rrcache_active is %lu, true count %lu", v42, v43, v44, v45, v46, v47, qword_100158EC4);
  LogToFD(a1, "Cache size %u entities; %u in use (%u group, %u multicast, %u unicast); %u referenced by active questions",
    v42,
    v43,
    v44,
    v45,
    v46,
    v47,
    dword_100158EB8);
  LogToFD(a1, "--------- Auth Records ---------", v65, v66, v67, v68, v69, v70, v1120);
  v71 = a1;
  LogAuthRecordsToFD(a1, v29, xmmword_10015BF10, 0, v72, v73, v74, v75);
  LogToFD(a1, "--------- LocalOnly, P2P Auth Records ---------", v76, v77, v78, v79, v80, v81, v1121);
  v88 = 0;
  v89 = 1;
  do
  {
    v1184 = v88;
    for (j = (_QWORD *)mDNSStorage[v88 + 786]; j; j = (_QWORD *)*j)
    {
      for (k = (uint64_t *)j[2]; k; k = (uint64_t *)*k)
      {
        if ((void (*)(uint64_t, uint64_t, int))k[13] != FreeEtcHosts)
        {
          if (v89)
            LogToFD(v71, "  State       Interface", v82, v83, v84, v85, v86, v87, v1122);
          v92 = *((_DWORD *)k + 43);
          if (v92 == 5)
          {
            v100 = k[4];
            v101 = RecordTypeName(*((unsigned __int8 *)k + 8));
            GetRRDisplayString_rdb((unsigned __int8 *)k + 8, (unsigned __int16 *)(k[6] + 4), word_100164580);
            if (v100 == -5)
            {
              v71 = a1;
              LogToFD(a1, " %s   BLE %s", v102, v103, v104, v105, v106, v107, v101);
            }
            else
            {
              v71 = a1;
              LogToFD(a1, " %s   PP  %s", v102, v103, v104, v105, v106, v107, v101);
            }
          }
          else if (v92 == 4)
          {
            v93 = RecordTypeName(*((unsigned __int8 *)k + 8));
            GetRRDisplayString_rdb((unsigned __int8 *)k + 8, (unsigned __int16 *)(k[6] + 4), word_100164580);
            LogToFD(v71, " %s   LO  %s", v94, v95, v96, v97, v98, v99, v93);
          }
          v89 = 0;
        }
      }
    }
    v88 = v1184 + 1;
  }
  while (v1184 != 498);
  if (v89)
    LogToFD(v71, "<None>", v82, v83, v84, v85, v86, v87, v1122);
  LogToFD(v71, "--------- /etc/hosts ---------", v82, v83, v84, v85, v86, v87, v1122);
  v114 = 0;
  v115 = 0;
  v116 = 0;
  v117 = 0;
  v118 = 1;
  do
  {
    v119 = (_QWORD *)mDNSStorage[v114 + 786];
    if (v119)
      ++v116;
    v1181 = v114;
    for (m = v116; v119; v117 = v121)
    {
      v120 = (unsigned __int8 *)v119[2];
      if (v120)
      {
        do
        {
          if (*((void (**)(uint64_t, uint64_t, int))v120 + 13) == FreeEtcHosts)
          {
            if (v118)
              LogToFD(v71, "  State       Interface", v108, v109, v110, v111, v112, v113, v1123);
            v121 = (v117 + 1);
            if ((int)v117 <= 49)
            {
              if (*((_DWORD *)v120 + 43) == 4)
              {
                if (*((_QWORD *)v120 + 4) == -2)
                {
                  v129 = RecordTypeName(v120[8]);
                  GetRRDisplayString_rdb(v120 + 8, (unsigned __int16 *)(*((_QWORD *)v120 + 6) + 4), word_100164580);
                  LogToFD(v71, " %s   LO %s", v130, v131, v132, v133, v134, v135, v129);
                }
                else
                {
                  v122 = RecordTypeName(v120[8]);
                  GetRRDisplayString_rdb(v120 + 8, (unsigned __int16 *)(*((_QWORD *)v120 + 6) + 4), word_100164580);
                  LogToFD(v71, " %s   %u  %s", v123, v124, v125, v126, v127, v128, v122);
                }
              }
              v118 = 0;
            }
            else
            {
              v118 = 0;
              v115 = 1;
            }
          }
          else
          {
            v121 = v117;
          }
          v120 = *(unsigned __int8 **)v120;
          v117 = v121;
        }
        while (v120);
      }
      else
      {
        v121 = v117;
      }
      v119 = (_QWORD *)*v119;
    }
    v116 = m;
    v114 = v1181 + 1;
  }
  while (v1181 != 498);
  if (v118)
  {
    LogToFD(v71, "<None>", v108, v109, v110, v111, v112, v113, v1123);
    v136 = v1188;
  }
  else
  {
    v136 = v1188;
    if (v115)
      LogToFD(v71, "<Truncated: to 50 records, Total records %d, Total Auth Groups %d, Auth Slots %d>", v108, v109, v110, v111, v112, v113, v117);
  }
  LogToFD(v71, "------ Duplicate Records -------", v108, v109, v110, v111, v112, v113, v1123);
  LogAuthRecordsToFD(v71, v136, *((uint64_t *)&xmmword_10015BF10 + 1), 0, v137, v138, v139, v140);
  LogToFD(v71, "----- Auth Records Proxied -----", v141, v142, v143, v144, v145, v146, v1124);
  LogAuthRecordsToFD(v71, v136, xmmword_10015BF10, &v1196, v147, v148, v149, v150);
  LogToFD(v71, "-- Duplicate Records Proxied ---", v151, v152, v153, v154, v155, v156, v1125);
  LogAuthRecordsToFD(v71, v136, *((uint64_t *)&xmmword_10015BF10 + 1), v1194, v157, v158, v159, v160);
  LogToFD(v71, "---------- Questions -----------", v161, v162, v163, v164, v165, v166, v1126);
  if ((_QWORD)xmmword_100158E88)
  {
    LogToFD(v71, "   Int  Next if     T NumAns Qptr               DupOf              SU SQ DNSSEC Type    Name", v167, v168, v169, v170, v171, v172, v1127);
    v179 = xmmword_100158E88;
    v180 = 0;
    for (n = 0; v179; v179 = *(_QWORD *)(v179 + 8))
    {
      v182 = *(_DWORD *)(v179 + 212);
      v1186 = v182 / 1000;
      v183 = &xmmword_10015BF38;
      do
        v183 = *(__int128 **)v183;
      while (v183 && *((_QWORD *)v183 + 444) != *(_QWORD *)(v179 + 136));
      ++n;
      if (v182)
        ++v180;
      DNSTypeName(*(unsigned __int16 *)(v179 + 342));
      v71 = v1189;
      LogToFD(v1189, "%6d%6d %-7s%s %6d 0x%p 0x%p %1d %2d  %-7s%-8s%##s%s", v184, v185, v186, v187, v188, v189, v1186);
    }
    LogToFD(v71, "%lu question%s; %lu active", v173, v174, v175, v176, v177, v178, n);
  }
  else
  {
    LogToFD(v71, "<None>", v167, v168, v169, v170, v171, v172, v1127);
  }
  LogToFD(v71, "----- LocalOnly, P2P Questions -----", v190, v191, v192, v193, v194, v195, v1128);
  v202 = unk_100158EA0;
  if (unk_100158EA0)
  {
    do
    {
      v203 = *(_QWORD *)(v202 + 136);
      if (v203 == -5)
        v204 = "BLE";
      else
        v204 = "P2P";
      if (v203 == -2)
        v205 = "LO ";
      else
        LODWORD(v205) = (_DWORD)v204;
      DNSTypeName(*(unsigned __int16 *)(v202 + 342));
      v1130 = (int)v205;
      v71 = v1189;
      LogToFD(v1189, "                 %3s   %5d  %-6s%##s%s", v206, v207, v208, v209, v210, v211, v1130);
      v202 = *(_QWORD *)(v202 + 8);
    }
    while (v202);
  }
  else
  {
    LogToFD(v71, "<None>", v196, v197, v198, v199, v200, v201, v1129);
  }
  LogToFD(v71, "---- Active UDS Client Requests ----", v212, v213, v214, v215, v216, v217, v1131);
  v224 = all_requests;
  if (all_requests)
  {
    do
    {
      v225 = *(_QWORD *)(v224 + 24);
      if (v225)
      {
        for (ii = all_requests; ii && ii != v224; ii = *(_QWORD *)(ii + 16))
        {
          if (ii == v225)
            goto LABEL_116;
        }
        LogToFD(v71, "%3d: Orhpan operation %p; parent %p not found in request list",
          v218,
          v219,
          v220,
          v221,
          v222,
          v223,
          *(_DWORD *)(v224 + 176));
      }
      LogClientInfoToFD(v71, v224);
LABEL_116:
      v224 = *(_QWORD *)(v224 + 16);
    }
    while (v224);
  }
  else
  {
    LogToFD(v71, "<None>", v218, v219, v220, v221, v222, v223, v1132);
  }
  LogToFD(v71, "-------- NAT Traversals --------", v218, v219, v220, v221, v222, v223, v1132);
  LogToFD(v71, "ExtAddress %.4a Retry %d Interval %d", v228, v229, v230, v231, v232, v233, (int)&dword_10015C760);
  for (jj = (_QWORD *)xmmword_10015C748; jj; jj = (_QWORD *)*jj)
    LogToFD(v71, "%p %s Int %5d %s Err %d Retry %5d Interval %5d Expire %5d Req %.4a:%d Ext %.4a:%d", v234, v235, v236, v237, v238, v239, (int)jj);
  LogToFD(v71, "--------- AuthInfoList ---------", v234, v235, v236, v237, v238, v239, v1133);
  v247 = (_QWORD *)qword_10015BFA0;
  if (qword_10015BFA0)
  {
    v248 = v1188;
    do
    {
      LogToFD(v71, "%##s %##s %##s %d %d", v241, v242, v243, v244, v245, v246, (_DWORD)v247 + 12);
      v247 = (_QWORD *)*v247;
    }
    while (v247);
  }
  else
  {
    LogToFD(v71, "<None>", v241, v242, v243, v244, v245, v246, v1134);
    v248 = v1188;
  }
  LogToFD(v71, "---------- Misc State ----------", v241, v242, v243, v244, v245, v246, v1135);
  LogToFD(v71, "PrimaryMAC:   %.6a", v249, v250, v251, v252, v253, v254, (int)&dword_100158DE0);
  LogToFD(v71, "m->SleepState %d (%s) seq %d", v255, v256, v257, v258, v259, v260, BYTE1(dword_100158E54));
  if (*(_QWORD *)((char *)&dword_100158E54 + &loc_100003A80 + 2 + 2))
    LogToFD(v71, "Offering Sleep Proxy Service: %#s", v261, v262, v263, v264, v265, v266, qword_10015D270);
  else
    LogToFD(v71, "Not offering Sleep Proxy Service", v261, v262, v263, v264, v265, v266, v1136);
  if (dword_10015DB78 == LODWORD(v1194[0]) + LODWORD(v1196.tv_sec))
    LogToFD(v71, "ProxyRecords: %d + %d = %d", v267, v268, v269, v270, v271, v272, v1196.tv_sec);
  else
    LogToFD(v71, "ProxyRecords: MISMATCH %d + %d = %d ≠ %d", v267, v268, v269, v270, v271, v272, v1196.tv_sec);
  LogToFD(v71, "------ Auto Browse Domains -----", v273, v274, v275, v276, v277, v278, v1137);
  v285 = (_QWORD *)AutoBrowseDomains;
  if (AutoBrowseDomains)
  {
    do
    {
      LogToFD(v71, "%##s", v279, v280, v281, v282, v283, v284, (_DWORD)v285 + 12);
      v285 = (_QWORD *)*v285;
    }
    while (v285);
  }
  else
  {
    LogToFD(v71, "<None>", v279, v280, v281, v282, v283, v284, v1138);
  }
  LogToFD(v71, "--- Auto Registration Domains --", v279, v280, v281, v282, v283, v284, v1139);
  v292 = (_QWORD *)AutoRegistrationDomains;
  if (AutoRegistrationDomains)
  {
    do
    {
      LogToFD(v71, "%##s", v286, v287, v288, v289, v290, v291, (_DWORD)v292 + 12);
      v292 = (_QWORD *)*v292;
    }
    while (v292);
  }
  else
  {
    LogToFD(v71, "<None>", v286, v287, v288, v289, v290, v291, v1140);
  }
  LogToFD(v71, "--- Search Domains --", v286, v287, v288, v289, v290, v291, v1141);
  v299 = (_QWORD *)SearchList;
  if (SearchList)
  {
    do
    {
      v300 = &xmmword_10015BF38;
      do
        v300 = *(__int128 **)v300;
      while (v300 && *((_QWORD *)v300 + 444) != v299[34]);
      LogToFD(v71, "%##s %s", v293, v294, v295, v296, v297, v298, (_DWORD)v299 + 8);
      v299 = (_QWORD *)*v299;
    }
    while (v299);
  }
  else
  {
    LogToFD(v71, "<None>", v293, v294, v295, v296, v297, v298, v1142);
  }
  LogToFD(v71, "--- MDNS Statistics ---", v293, v294, v295, v296, v297, v298, v1143);
  LogToFD(v71, "Name Conflicts                 %u", v301, v302, v303, v304, v305, v306, *(_DWORD *)&byte_100158E40[&loc_100004D50]);
  LogToFD(v71, "KnownUnique Name Conflicts     %u", v307, v308, v309, v310, v311, v312, *(_DWORD *)((char *)&qword_100158E44 + &loc_100004D50));
  LogToFD(v71, "Duplicate Query Suppressions   %u", v313, v314, v315, v316, v317, v318, *(_DWORD *)((char *)&qword_100158E44 + &loc_100004D50 + 4));
  LogToFD(v71, "KA Suppressions                %u", v319, v320, v321, v322, v323, v324, *(_DWORD *)((char *)&unk_100158E4C + &loc_100004D50));
  LogToFD(v71, "KA Multiple Packets            %u", v325, v326, v327, v328, v329, v330, *(int *)((char *)&dword_100158E50 + &loc_100004D50));
  LogToFD(v71, "Poof Cache Deletions           %u", v331, v332, v333, v334, v335, v336, *(int *)((char *)&dword_100158E54 + &loc_100004D50));
  LogToFD(v71, "--------------------------------", v337, v338, v339, v340, v341, v342, v1144);
  LogToFD(v71, "Multicast packets Sent         %u", v343, v344, v345, v346, v347, v348, dword_100158E74);
  LogToFD(v71, "Multicast packets Received     %u", v349, v350, v351, v352, v353, v354, dword_100158E50);
  LogToFD(v71, "Remote Subnet packets          %u", v355, v356, v357, v358, v359, v360, dword_100158E78);
  LogToFD(v71, "QU questions  received         %u", v361, v362, v363, v364, v365, v366, *(_DWORD *)((char *)&unk_100158E58 + &loc_100004D50));
  LogToFD(v71, "Normal multicast questions     %u", v367, v368, v369, v370, v371, v372, *(_DWORD *)((char *)&qword_100158E5C + &loc_100004D50));
  LogToFD(v71, "Answers for questions          %u", v373, v374, v375, v376, v377, v378, *(_DWORD *)((char *)&qword_100158E5C + &loc_100004D50 + 4));
  LogToFD(v71, "Unicast responses              %u", v379, v380, v381, v382, v383, v384, *(int *)((char *)&dword_100158E64 + &loc_100004D50));
  LogToFD(v71, "Multicast responses            %u", v385, v386, v387, v388, v389, v390, *(int *)((char *)&dword_100158E68 + &loc_100004D50));
  LogToFD(v71, "Unicast response Demotions     %u", v391, v392, v393, v394, v395, v396, *(int *)((char *)&dword_100158E6C + &loc_100004D50));
  LogToFD(v71, "--------------------------------", v397, v398, v399, v400, v401, v402, v1145);
  LogToFD(v71, "Sleeps                         %u", v403, v404, v405, v406, v407, v408, *(_DWORD *)((char *)&unk_100158E70 + &loc_100004D50));
  LogToFD(v71, "Wakeups                        %u", v409, v410, v411, v412, v413, v414, *(int *)((char *)&dword_100158E74 + &loc_100004D50));
  LogToFD(v71, "Interface UP events            %u", v415, v416, v417, v418, v419, v420, *(int *)((char *)&dword_100158E78 + &loc_100004D50));
  LogToFD(v71, "Interface UP Flap events       %u", v421, v422, v423, v424, v425, v426, *(int *)((char *)&dword_100158E7C + &loc_100004D50));
  LogToFD(v71, "Interface Down events          %u", v427, v428, v429, v430, v431, v432, *(int *)((char *)&dword_100158E80 + &loc_100004D50));
  LogToFD(v71, "Interface DownFlap events      %u", v433, v434, v435, v436, v437, v438, *(_DWORD *)((char *)&unk_100158E84 + &loc_100004D50));
  LogToFD(v71, "Cache refresh queries          %u", v439, v440, v441, v442, v443, v444, *(_DWORD *)((char *)&xmmword_100158E88 + &loc_100004D50));
  LogToFD(v71, "Cache refreshed                %u", v445, v446, v447, v448, v449, v450, *(_DWORD *)((char *)&xmmword_100158E88 + &loc_100004D50 + 4));
  LogToFD(v71, "Wakeup on Resolves             %u", v451, v452, v453, v454, v455, v456, *(_DWORD *)((char *)&xmmword_100158E88 + &loc_100004D50 + 8));
  LogToFD(v71, "---- Task Scheduling Timers ----", v457, v458, v459, v460, v461, v462, v1146);
  LogToFD(v71, "BonjourEnabled %d", v463, v464, v465, v466, v467, v468, byte_100158E40[0]);
  if (*((_QWORD *)&xmmword_100158E88 + 1))
  {
    v475 = *(_DWORD *)(*((_QWORD *)&xmmword_100158E88 + 1) + 204);
    DNSTypeName(*(unsigned __int16 *)(*((_QWORD *)&xmmword_100158E88 + 1) + 342));
    LogToFD(v71, "NewQuestion DelayAnswering %d %d %##s (%s)", v476, v477, v478, v479, v480, v481, v475);
  }
  else
  {
    LogToFD(v71, "NewQuestion <NONE>", v469, v470, v471, v472, v473, v474, v1147);
  }
  if (qword_100158EA8)
  {
    v488 = qword_100158EA8 + 376;
    DNSTypeName(*(unsigned __int16 *)(qword_100158EA8 + 342));
    LogToFD(v71, "NewLocalOnlyQuestions %##s (%s)", v489, v490, v491, v492, v493, v494, v488);
  }
  else
  {
    LogToFD(v71, "NewLocalOnlyQuestions <NONE>", v482, v483, v484, v485, v486, v487, v1148);
  }
  if (qword_10015BF20)
  {
    v501 = *(unsigned __int8 *)(qword_10015BF20 + 8);
    GetRRDisplayString_rdb((unsigned __int8 *)(qword_10015BF20 + 8), (unsigned __int16 *)(*(_QWORD *)(qword_10015BF20 + 48) + 4), word_100164580);
    LogToFD(v71, "NewLocalRecords %02X %s", v502, v503, v504, v505, v506, v507, v501);
  }
  else
  {
    LogToFD(v71, "NewLocalRecords <NONE>", v495, v496, v497, v498, v499, v500, v1149);
  }
  if ((_QWORD)xmmword_10015C8D0)
    v514 = "";
  else
    v514 = " <NONE>";
  LogToFD(v71, "SPSProxyListChanged%s", v508, v509, v510, v511, v512, v513, (int)v514);
  if ((_BYTE)dword_100158E54)
    v521 = "";
  else
    v521 = " <NONE>";
  LogToFD(v71, "LocalRemoveEvents%s", v515, v516, v517, v518, v519, v520, (int)v521);
  LogToFD(v71, "m->WABBrowseQueriesCount %d", v522, v523, v524, v525, v526, v527, SDWORD2(xmmword_10015C720));
  LogToFD(v71, "m->WABLBrowseQueriesCount %d", v528, v529, v530, v531, v532, v533, SHIDWORD(xmmword_10015C720));
  LogToFD(v71, "m->WABRegQueriesCount %d", v534, v535, v536, v537, v538, v539, dword_10015C730);
  LogToFD(v71, "m->AutoTargetServices %u", v540, v541, v542, v543, v544, v545, *(_DWORD *)((char *)mDNSStorage + &loc_100004DBC));
  LogToFD(v71, "m->AutoTargetAWDLIncludedCount %u", v546, v547, v548, v549, v550, v551, dword_10015B870);
  LogToFD(v71, "m->AutoTargetAWDLOnlyCount     %u", v552, v553, v554, v555, v556, v557, dword_10015B874);
  LogToFD(v71, "                         ABS (hex)  ABS (dec)  REL (hex)  REL (dec)", v558, v559, v560, v561, v562, v563, v1150);
  LogToFD(v71, "m->timenow               %08X %11d", v564, v565, v566, v567, v568, v569, v248);
  LogToFD(v71, "m->timenow_adjust        %08X %11d", v570, v571, v572, v573, v574, v575, dword_100158E04);
  LogToFD(v71, "m->NextScheduledEvent    %08X %11d  %08X %11d", v576, v577, v578, v579, v580, v581, dword_100158E10);
  LogToFD(v71, "m->NextuDNSEvent         %08X %11d  %08X %11d", v582, v583, v584, v585, v586, v587, dword_10015BF50);
  LogToFD(v71, "m->NextSRVUpdate         %08X %11d  %08X %11d", v588, v589, v590, v591, v592, v593, dword_10015BF54);
  LogToFD(v71, "m->NextScheduledNATOp    %08X %11d  %08X %11d", v594, v595, v596, v597, v598, v599, dword_100158E30);
  LogToFD(v71, "m->retryGetAddr          %08X %11d  %08X %11d", v600, v601, v602, v603, v604, v605, dword_10015C75C);
  LogToFD(v71, "m->NextCacheCheck        %08X %11d  %08X %11d", v606, v607, v608, v609, v610, v611, dword_100158E20);
  LogToFD(v71, "m->NextScheduledSPS      %08X %11d  %08X %11d", v612, v613, v614, v615, v616, v617, dword_100158E34);
  LogToFD(v71, "m->NextScheduledKA       %08X %11d  %08X %11d", v618, v619, v620, v621, v622, v623, dword_100158E38);
  LogToFD(v71, "m->NextBonjourDisableTime  %08X %11d  %08X %11d", v624, v625, v626, v627, v628, v629, dword_100158E3C);
  LogToFD(v71, "m->NextScheduledSPRetry  %08X %11d  %08X %11d", v630, v631, v632, v633, v634, v635, dword_100158E7C);
  LogToFD(v71, "m->DelaySleep            %08X %11d  %08X %11d", v636, v637, v638, v639, v640, v641, qword_100158E5C);
  LogToFD(v71, "m->NextScheduledQuery    %08X %11d  %08X %11d", v642, v643, v644, v645, v646, v647, dword_100158E24);
  LogToFD(v71, "m->NextScheduledProbe    %08X %11d  %08X %11d", v648, v649, v650, v651, v652, v653, dword_100158E28);
  LogToFD(v71, "m->NextScheduledResponse %08X %11d  %08X %11d", v654, v655, v656, v657, v658, v659, dword_100158E2C);
  LogToFD(v71, "m->SuppressQueries       %08X %11d  %08X %11d", v660, v661, v662, v663, v664, v665, qword_100158E18);
  LogToFD(v71, "m->SuppressResponses     %08X %11d  %08X %11d", v666, v667, v668, v669, v670, v671, SHIDWORD(qword_100158E18));
  LogToFD(v71, "m->SuppressProbes        %08X %11d  %08X %11d", v672, v673, v674, v675, v676, v677, dword_10015BF48);
  LogToFD(v71, "m->ProbeFailTime         %08X %11d  %08X %11d", v678, v679, v680, v681, v682, v683, SDWORD2(xmmword_10015BF38));
  LogToFD(v71, "m->DelaySleep            %08X %11d  %08X %11d", v684, v685, v686, v687, v688, v689, qword_100158E5C);
  LogToFD(v71, "m->SleepLimit            %08X %11d  %08X %11d", v690, v691, v692, v693, v694, v695, SHIDWORD(qword_100158E5C));
  LogToFD(v71, "m->NextScheduledStopTime  %08X %11d  %08X %11d", v696, v697, v698, v699, v700, v701, dword_100158E80);
  LogToFD(v71, "----- Platform Timers -----", v702, v703, v704, v705, v706, v707, v1151);
  LogToFD(v71, "m->NextCacheCheck        %08X %11d  %08X %11d", v708, v709, v710, v711, v712, v713, dword_100158E20);
  LogToFD(v71, "m->NetworkChanged        %08X %11d  %08X %11d", v714, v715, v716, v717, v718, v719, dword_100158DD0);
  LogToFD(v71, "m->p->NotifyUser         %08X %11d  %08X %11d", v720, v721, v722, v723, v724, v725, *(_DWORD *)(mDNSStorage[0] + 492));
  LogToFD(v71, "m->p->HostNameConflict   %08X %11d  %08X %11d", v726, v727, v728, v729, v730, v731, *(_DWORD *)(mDNSStorage[0] + 496));
  LogToFD(v71, "m->p->KeyChainTimer      %08X %11d  %08X %11d", v732, v733, v734, v735, v736, v737, *(_DWORD *)(mDNSStorage[0] + 500));
  LogToFD(v71, "----- KQSocketEventSources -----", v738, v739, v740, v741, v742, v743, v1152);
  v750 = gEventSources;
  if (gEventSources)
  {
    do
    {
      LogToFD(v71, "%3d %s %s", v744, v745, v746, v747, v748, v749, *(_DWORD *)(v750 + 8));
      v750 = *(_QWORD *)v750;
    }
    while (v750);
  }
  else
  {
    LogToFD(v71, "<None>", v744, v745, v746, v747, v748, v749, v1153);
  }
  LogToFD(v71, "------ Network Interfaces ------", v744, v745, v746, v747, v748, v749, v1154);
  if (*(_QWORD *)mDNSStorage[0])
  {
    LogToFD(v71, "Struct addr          Registered                     MAC               BSSID                                Functional Type  Interface Address", v751, v752, v753, v754, v755, v756, v1155);
    for (kk = *(_QWORD *)mDNSStorage[0]; kk; kk = *(_QWORD *)(kk + 3680))
    {
      if (*(_BYTE *)(kk + 3696))
      {
        v764 = *(unsigned int *)(kk + 3748);
        v765 = "Unrecognized";
        if (v764 <= 7)
          v765 = off_10013DD18[v764];
        LogToFD(v71, "%p %2ld, %p,  %s %-8.8s %.6a %.6a %s %s %s %s %s %s %-16.16s %#a", (uint64_t)v765, kk + 3560, v759, v760, v761, v762, kk);
      }
      else
      {
        LogToFD(v71, "%p %2ld, %p,  %s %-6s %.6a %.6a %#-14a dormant for %d seconds", v757, v758, v759, v760, v761, v762, kk);
      }
    }
  }
  else
  {
    LogToFD(v71, "<None>", v751, v752, v753, v754, v755, v756, v1155);
  }
  LogToFD(v71, "----------- DNS Services -----------", v757, v758, v759, v760, v761, v762, v1156);
  DNSServiceManager = Querier_GetDNSServiceManager();
  if (DNSServiceManager)
  {
    v1190[0] = _NSConcreteStackBlock;
    v1190[1] = 0x40000000;
    v1190[2] = __dump_state_to_fd_block_invoke;
    v1190[3] = &__block_descriptor_tmp_5114;
    v1191 = v71;
    mdns_dns_service_manager_enumerate(DNSServiceManager, (uint64_t)v1190);
  }
  LogToFD(v71, "v4answers %d", v767, v768, v769, v770, v771, v772, *(unsigned __int8 *)(mDNSStorage[0] + 688));
  LogToFD(v71, "v6answers %d", v773, v774, v775, v776, v777, v778, *(unsigned __int8 *)(mDNSStorage[0] + 689));
  LogToFD(v71, "Last DNS Trigger: %d ms ago", v779, v780, v781, v782, v783, v784, v1177 - *(_DWORD *)(mDNSStorage[0] + 692));
  LogToFD(v71, "--------- Mcast Resolvers ----------", v785, v786, v787, v788, v789, v790, v1157);
  v797 = (_QWORD *)qword_10015BF58;
  if (qword_10015BF58)
  {
    do
    {
      LogToFD(v71, "Mcast Resolver %##s timeout %u", v791, v792, v793, v794, v795, v796, (_DWORD)v797 + 20);
      v797 = (_QWORD *)*v797;
    }
    while (v797);
  }
  else
  {
    LogToFD(v71, "<None>", v791, v792, v793, v794, v795, v796, v1158);
  }
  LogToFD(v71, "------------ Hostnames -------------", v791, v792, v793, v794, v795, v796, v1159);
  v804 = (unsigned __int8 *)xmmword_10015C720;
  if ((_QWORD)xmmword_10015C720)
  {
    do
    {
      GetRRDisplayString_rdb(v804 + 472, (unsigned __int16 *)(*((_QWORD *)v804 + 64) + 4), word_100164580);
      LogToFD(v1189, "%##s v4 %d %s", v805, v806, v807, v808, v809, v810, (_DWORD)v804 + 208);
      GetRRDisplayString_rdb(v804 + 1648, (unsigned __int16 *)(*((_QWORD *)v804 + 211) + 4), word_100164580);
      LODWORD(v71) = v1189;
      LogToFD(v1189, "%##s v6 %d %s", v811, v812, v813, v814, v815, v816, (_DWORD)v804 + 208);
      v804 = *(unsigned __int8 **)v804;
    }
    while (v804);
  }
  else
  {
    LogToFD(v71, "<None>", v798, v799, v800, v801, v802, v803, v1160);
  }
  LogToFD(v71, "--------------- FQDN ---------------", v817, v818, v819, v820, v821, v822, v1161);
  if (byte_10015C620[0])
    LogToFD(v71, "%##s", v823, v824, v825, v826, v827, v828, (int)byte_10015C620);
  else
    LogToFD(v71, "<None>", v823, v824, v825, v826, v827, v828, v1162);
  LogToFD(v71, "----    DNS Cache Analytics     -----", v829, v830, v831, v832, v833, v834, v1163);
  LogToFD(v71, "----    Unicast Requests", v835, v836, v837, v838, v839, v840, v1164);
  LogToFD(v71, "Cache Hit: %llu", v841, v842, v843, v844, v845, v846, sCacheRequest_UnicastHitCount);
  LogToFD(v71, "Cache Miss: %llu", v847, v848, v849, v850, v851, v852, sCacheRequest_UnicastMissCount);
  LogToFD(v71, "----    Unicast Usage", v853, v854, v855, v856, v857, v858, v1165);
  LogToFD(v71, "Cache Hit: %llu", v859, v860, v861, v862, v863, v864, sCacheUsage_UnicastHitCount);
  LogToFD(v71, "Cache Miss: %llu", v865, v866, v867, v868, v869, v870, sCacheUsage_UnicastMissCount);
  LogToFD(v71, "----    Multicast Requests", v871, v872, v873, v874, v875, v876, v1166);
  LogToFD(v71, "Cache Hit: %llu", v877, v878, v879, v880, v881, v882, sCacheRequest_MulticastHitCount);
  LogToFD(v71, "Cache Miss: %llu", v883, v884, v885, v886, v887, v888, sCacheRequest_MulticastMissCount);
  LogToFD(v71, "----    Multicast Usage", v889, v890, v891, v892, v893, v894, v1167);
  LogToFD(v71, "Cache Hit: %llu", v895, v896, v897, v898, v899, v900, sCacheUsage_MulticastHitCount);
  LogToFD(v71, "Cache Miss: %llu", v901, v902, v903, v904, v905, v906, sCacheUsage_MulticastMissCount);
  LogToFD(v71, "----    DNS Query Analytics     -----", v907, v908, v909, v910, v911, v912, v1168);
  v919 = 0;
  v920 = &qword_1001647B0;
  do
  {
    if (*(v920 - 6))
    {
      LogToFD(v1189, "----    Network:   %s\n        Transport: %s", v913, v914, v915, v916, v917, v918, (int)off_10013F4D0[v919]);
      LogToFD(v1189, "Latency: %llums", v921, v922, v923, v924, v925, v926, *(v920 - 5) / (unint64_t)*(v920 - 6));
      LogToFD(v1189, "Query Bytes: %llu", v927, v928, v929, v930, v931, v932, *(v920 - 4));
      LogToFD(v1189, "Reply Bytes: %llu", v933, v934, v935, v936, v937, v938, *(v920 - 3));
      LogToFD(v1189, "----    V4", v939, v940, v941, v942, v943, v944, v1170);
      LogToFD(v1189, "Queries: %llu", v945, v946, v947, v948, v949, v950, *(v920 - 2));
      LogToFD(v1189, "Reply Pos: %llu", v951, v952, v953, v954, v955, v956, *(v920 - 1));
      LogToFD(v1189, "Reply Neg: %llu", v957, v958, v959, v960, v961, v962, *v920);
      LogToFD(v1189, "----    V6", v963, v964, v965, v966, v967, v968, v1171);
      LogToFD(v1189, "Queries: %llu", v969, v970, v971, v972, v973, v974, v920[1]);
      LogToFD(v1189, "Reply Pos: %llu", v975, v976, v977, v978, v979, v980, v920[2]);
      LogToFD(v1189, "Reply Neg: %llu", v981, v982, v983, v984, v985, v986, v920[3]);
      LogToFD(v1189, "----    HTTPS", v987, v988, v989, v990, v991, v992, v1172);
      LogToFD(v1189, "Queries: %llu", v993, v994, v995, v996, v997, v998, v920[4]);
      LogToFD(v1189, "Reply Pos: %llu", v999, v1000, v1001, v1002, v1003, v1004, v920[5]);
      LogToFD(v1189, "Reply Neg: %llu", v1005, v1006, v1007, v1008, v1009, v1010, v920[6]);
    }
    ++v919;
    v920 += 13;
  }
  while (v919 != 4);
  v1011 = v1189;
  LogToFD(v1189, "----    Unicast Assist", v913, v914, v915, v916, v917, v918, v1169);
  LogToFD(v1189, "Assist Unicast: %llu", v1012, v1013, v1014, v1015, v1016, v1017, sUnicastAssist_UnicastCount);
  LogToFD(v1189, "Assist Multicast: %llu", v1018, v1019, v1020, v1021, v1022, v1023, sUnicastAssist_MulticastCount);
  LogToFD(v1189, "Non-assist Unicast: %llu", v1024, v1025, v1026, v1027, v1028, v1029, sNonUnicastAssist_UnicastCount);
  LogToFD(v1189, "Non-assist Multicast: %llu", v1030, v1031, v1032, v1033, v1034, v1035, sNonUnicastAssist_MulticastCount);
  if ((_os_feature_enabled_impl("mDNSResponder", "unicast_assist_cache") & 1) != 0)
  {
    mDNS_TimeNow(mDNSStorage, v1036, v1037, v1038, v1039, v1040, v1041, v1042);
    bzero(&v1196, 0x400uLL);
    v1195 = 0;
    memset(v1194, 0, sizeof(v1194));
    LogToFD(v1189, "----    Unicast Assist Cache    -----", v1043, v1044, v1045, v1046, v1047, v1048, v1173);
    LogToFD(v1189, "----    Cache Records", v1049, v1050, v1051, v1052, v1053, v1054, v1174);
    v1061 = s_interface_head_0;
    if (s_interface_head_0)
    {
      v1062 = 0;
      v1063 = 0;
      v1064 = 0;
      v1065 = 0;
      do
      {
        v1179 = v1065;
        LogToFD(v1189, "ifhash %x ifid %2.2d", v1055, v1056, v1057, v1058, v1059, v1060, *(_DWORD *)(v1061 + 32));
        v1062 += 40;
        v1178 = (uint64_t *)v1061;
        v1066 = *(_QWORD **)(v1061 + 8);
        if (v1066)
        {
          do
          {
            v1187 = v1064;
            mDNS_snprintf(v1194);
            LOBYTE(v1196.tv_sec) = 0;
            v1067 = mDNS_snprintf(&v1196);
            v1062 += 40;
            v1182 = v1066;
            v1074 = (_QWORD *)v1066[1];
            if (v1074)
            {
              v1075 = 0;
              v1076 = v1067;
              do
              {
                if ((v1075 + 1) < 6)
                {
                  ++v1075;
                }
                else
                {
                  v1076 += mDNS_snprintf((char *)&v1196 + v1076);
                  v1075 -= 4;
                }
                v1077 = mDNS_snprintf((char *)&v1196 + v1076) + v1076;
                v1078 = mDNS_snprintf((char *)&v1196 + v1077) + v1077;
                v1076 = mDNS_snprintf((char *)&v1196 + v1078) + v1078;
                v1062 += 24;
                ++v1063;
                v1074 = (_QWORD *)*v1074;
              }
              while (v1074);
            }
            v1064 = v1187 + 1;
            LogToFD(v1189, "  %s", v1068, v1069, v1070, v1071, v1072, v1073, (int)&v1196);
            v1066 = (_QWORD *)*v1182;
          }
          while (*v1182);
        }
        v1065 = v1179 + 1;
        v1061 = *v1178;
      }
      while (*v1178);
    }
    else
    {
      LODWORD(v1065) = 0;
      LODWORD(v1064) = 0;
      v1063 = 0;
      LODWORD(v1062) = 0;
    }
    v1011 = v1189;
    LogToFD(v1189, "----    Cache Record Stats", v1055, v1056, v1057, v1058, v1059, v1060, v1175);
    LogToFD(v1189, "If Hash Count: %lu", v1086, v1087, v1088, v1089, v1090, v1091, v1065);
    LogToFD(v1189, "Addr Count:    %lu", v1092, v1093, v1094, v1095, v1096, v1097, v1064);
    LogToFD(v1189, "Qhash Count:   %lu", v1098, v1099, v1100, v1101, v1102, v1103, v1063);
    v1176 = v1062;
    v1085 = "Total Size:    %lu bytes";
  }
  else
  {
    LogToFD(v1189, "----    Unicast Assist Cache    -----", v1037, v1038, v1039, v1040, v1041, v1042, v1173);
    v1085 = "Feature Flag: mDNSResponder/unicast_assist_cache DISABLED";
  }
  LogToFD(v1011, v1085, v1079, v1080, v1081, v1082, v1083, v1084, v1176);
  LogToFD(v1011, "Date: %s", v1104, v1105, v1106, v1107, v1108, v1109, (int)v1193);
  v1110 = mDNSLogCategory_Default;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
  {
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v1196.tv_sec) = 136446210;
      *(__darwin_time_t *)((char *)&v1196.tv_sec + 4) = (__darwin_time_t)v1193;
      goto LABEL_215;
    }
  }
  else
  {
    v1110 = mDNSLogCategory_Default_redacted;
    if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v1196.tv_sec) = 136446210;
      *(__darwin_time_t *)((char *)&v1196.tv_sec + 4) = (__darwin_time_t)v1193;
LABEL_215:
      _os_log_impl((void *)&_mh_execute_header, v1110, OS_LOG_TYPE_DEFAULT, "---- END STATE LOG ---- (%{public}s)", (uint8_t *)&v1196, 0xCu);
    }
  }
  return LogToFD(v1011, "----  END STATE LOG  ---- %s %s %d", v1111, v1112, v1113, v1114, v1115, v1116, (int)"mDNSResponder mDNSResponder-2559.2.4 (Aug  3 2024 11:06:39)");
}

uint64_t __dump_state_to_fd_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v9;
  uint64_t (*v10)(uint64_t, _QWORD, _QWORD);
  void *v11;
  const char *v12;

  v9 = (_QWORD *)(a2 + 16);
  while (1)
  {
    v9 = (_QWORD *)*v9;
    if (!v9)
      break;
    v10 = (uint64_t (*)(uint64_t, _QWORD, _QWORD))v9[3];
    if (v10)
    {
      v11 = (void *)v10(a2, 0, 0);
      goto LABEL_6;
    }
  }
  v11 = 0;
LABEL_6:
  v12 = "<missing description>";
  if (v11)
    LODWORD(v12) = (_DWORD)v11;
  LogToFD(*(_DWORD *)(a1 + 32), "%s", a3, a4, a5, a6, a7, a8, (int)v12);
  if (v11)
    free(v11);
  return 1;
}

void UpdateDebugState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  CFMutableDictionaryRef Mutable;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __CFDictionary *v15;
  CFNumberRef v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  CFNumberRef v22;
  CFNumberRef v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  CFNumberRef v29;
  CFNumberRef v30;
  CFNumberRef v31;
  CFNumberRef v32;
  CFNumberRef v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  __CFDictionary *v40;
  int v41;
  int v42;
  int valuePtr;

  v42 = 0;
  valuePtr = 1;
  Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    v15 = Mutable;
    v16 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
    if (v16)
    {
      v22 = v16;
      v23 = CFNumberCreate(0, kCFNumberSInt32Type, &v42);
      if (v23)
      {
        v29 = v23;
        if (mDNS_LoggingEnabled)
          v30 = v22;
        else
          v30 = v23;
        CFDictionarySetValue(v15, CFSTR("VerboseLogging"), v30);
        if (mDNS_PacketLoggingEnabled)
          v31 = v22;
        else
          v31 = v29;
        CFDictionarySetValue(v15, CFSTR("PacketLogging"), v31);
        if (mDNS_McastLoggingEnabled)
          v32 = v22;
        else
          v32 = v29;
        CFDictionarySetValue(v15, CFSTR("McastLogging"), v32);
        if (mDNS_McastTracingEnabled)
          v33 = v22;
        else
          v33 = v29;
        CFDictionarySetValue(v15, CFSTR("McastTracing"), v33);
        CFRelease(v22);
        CFRelease(v29);
        mDNSDynamicStoreSetConfig(6, v15, v34, v35, v36, v37, v38, v39, v41);
        v40 = v15;
      }
      else
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "UpdateDebugState: Could not create CFNumber zero", v24, v25, v26, v27, v28, v41);
        v40 = v22;
      }
      CFRelease(v40);
    }
    else
    {
      LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "UpdateDebugState: Could not create CFNumber one", v17, v18, v19, v20, v21, v41);
    }
  }
  else
  {
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "UpdateDebugState: Could not create dict", v10, v11, v12, v13, v14, a9);
  }
}

BOOL PreferencesGetValueBool(const __CFString *a1, _BOOL8 a2)
{
  const __CFBoolean *v3;
  const __CFBoolean *v4;
  CFTypeID v5;

  v3 = (const __CFBoolean *)CFPreferencesCopyAppValue(a1, CFSTR("com.apple.mDNSResponder"));
  if (v3)
  {
    v4 = v3;
    v5 = CFGetTypeID(v3);
    if (v5 == CFBooleanGetTypeID())
      a2 = CFBooleanGetValue(v4) != 0;
    CFRelease(v4);
  }
  return a2;
}

uint64_t PreferencesGetValueInt(const __CFString *a1, uint64_t a2)
{
  const __CFNumber *v3;
  const __CFNumber *v4;
  CFTypeID v5;
  unsigned int valuePtr;

  v3 = (const __CFNumber *)CFPreferencesCopyAppValue(a1, CFSTR("com.apple.mDNSResponder"));
  if (v3)
  {
    v4 = v3;
    valuePtr = 0;
    v5 = CFGetTypeID(v3);
    if (v5 == CFNumberGetTypeID())
    {
      if (CFNumberGetValue(v4, kCFNumberIntType, &valuePtr))
        a2 = valuePtr;
      else
        a2 = a2;
    }
    CFRelease(v4);
  }
  return a2;
}

void HandleSIG(mach_msg_id_t a1)
{
  mach_msg_return_t v2;
  mach_msg_header_t msg;

  msg.msgh_remote_port = signal_port;
  msg.msgh_local_port = 0;
  *(_QWORD *)&msg.msgh_bits = 0x1800000014;
  msg.msgh_voucher_port = 0;
  msg.msgh_id = a1;
  v2 = mach_msg(&msg, 17, 0x18u, 0, 0, 0, 0);
  if (v2)
  {
    if (v2 == 268435460)
      mach_msg_destroy(&msg);
    if (a1 == 15 || a1 == 2)
      exit(-1);
  }
}

void SignalCallback(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  _BOOL8 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  NSObject *v22;
  NSObject *v23;
  uint64_t v25;
  const char *v27;
  int v28;
  NSObject *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  NSObject *v36;
  uint64_t v38;
  NSObject *v40;
  NSObject *v42;
  uint64_t *i;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  NSObject *v54;
  uint32_t v55;
  NSObject *v56;
  uint32_t v57;
  const char *v58;
  int v59;
  uint64_t v60;
  const char *v61;
  uint64_t **v63;
  _BOOL8 v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  int v73;
  int v75;
  const char *v76;
  const char *v77;
  const char *v78;
  uint64_t j;
  _QWORD *k;
  _QWORD *m;
  int v82;
  char *v83;

  v3 = pthread_mutex_lock((pthread_mutex_t *)(mDNSStorage[0] + 616));
  *(_DWORD *)(mDNSStorage[0] + 680) = mDNSPlatformRawTime(v3, v4, v5, v6, v7, v8, v9, v10);
  v11 = *(_DWORD *)(a2 + 20);
  switch(v11)
  {
    case 15:
      goto LABEL_12;
    case 16:
    case 17:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
      goto LABEL_19;
    case 18:
      mDNS_McastTracingEnabled = 0;
      mDNS_McastLoggingEnabled = 0;
      mDNS_PacketLoggingEnabled = 0;
      mDNS_LoggingEnabled = 0;
      v12 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        v13 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT);
        if (!v13)
          goto LABEL_134;
        LOWORD(v82) = 0;
        v21 = "All mDNSResponder Debug Logging/Tracing Disabled (USR1/USR2/PROF)";
      }
      else
      {
        v12 = mDNSLogCategory_Default_redacted;
        v13 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT);
        if (!v13)
          goto LABEL_134;
        LOWORD(v82) = 0;
        v21 = "All mDNSResponder Debug Logging/Tracing Disabled (USR1/USR2/PROF)";
      }
      v56 = v12;
      v57 = 2;
      goto LABEL_133;
    case 27:
      v28 = mDNS_McastLoggingEnabled;
      mDNS_McastLoggingEnabled = mDNS_McastLoggingEnabled == 0;
      v29 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          goto LABEL_81;
        v58 = "Disabled";
        if (!v28)
          v58 = "Enabled";
        v82 = 136446210;
        v83 = (char *)v58;
      }
      else
      {
        v29 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          goto LABEL_81;
        v35 = "Disabled";
        if (!v28)
          v35 = "Enabled";
        v82 = 136446210;
        v83 = (char *)v35;
      }
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "SIGPROF: Multicast Logging %{public}s", (uint8_t *)&v82, 0xCu);
LABEL_81:
      LogMcastStateInfo(0, 1, 1, v30, v31, v32, v33, v34, v82);
      if (mDNS_McastLoggingEnabled)
        v59 = mDNS_PacketLoggingEnabled;
      else
        v59 = 0;
      mDNS_McastTracingEnabled = v59;
      v60 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        v13 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT);
        if (!v13)
          goto LABEL_134;
        v77 = "Disabled";
        if (v59)
          v77 = "Enabled";
        v82 = 136446210;
        v83 = (char *)v77;
        v21 = "SIGPROF: Multicast Tracing is %{public}s";
      }
      else
      {
        v60 = mDNSLogCategory_Default_redacted;
        v13 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT);
        if (!v13)
          goto LABEL_134;
        v61 = "Disabled";
        if (v59)
          v61 = "Enabled";
        v82 = 136446210;
        v83 = (char *)v61;
        v21 = "SIGPROF: Multicast Tracing is %{public}s";
      }
      goto LABEL_132;
    case 28:
      v36 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          goto LABEL_93;
        LOWORD(v82) = 0;
        goto LABEL_92;
      }
      v36 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v82) = 0;
LABEL_92:
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "SIGWINCH: Purge unicast assist cache", (uint8_t *)&v82, 2u);
      }
LABEL_93:
      if (_os_feature_enabled_impl("mDNSResponder", "unicast_assist_cache"))
      {
        while (1)
        {
          v63 = (uint64_t **)s_interface_head_0;
          if (!s_interface_head_0)
            break;
          s_interface_head_0 = *(_QWORD *)s_interface_head_0;
          _unicast_assist_cache_free_interface(v63);
        }
      }
      goto LABEL_145;
    case 29:
      v38 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          goto LABEL_145;
        LOWORD(v82) = 0;
        v27 = "Sending SIGINFO to mDNSResponder daemon is deprecated. To trigger state dump, please use 'dns-sd -O', ente"
              "r 'dns-sd -h' for more information";
        goto LABEL_126;
      }
      v38 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v82) = 0;
        v27 = "Sending SIGINFO to mDNSResponder daemon is deprecated. To trigger state dump, please use 'dns-sd -O', ente"
              "r 'dns-sd -h' for more information";
        goto LABEL_126;
      }
      goto LABEL_145;
    case 30:
      mDNS_LoggingEnabled = 1;
      v40 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        v65 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT);
        if (!v65)
          goto LABEL_101;
        v82 = 136446210;
        v83 = "Enabled";
        goto LABEL_100;
      }
      v40 = mDNSLogCategory_Default_redacted;
      v65 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT);
      if (v65)
      {
        v82 = 136446210;
        v83 = "Enabled";
LABEL_100:
        _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "SIGUSR1: Logging %{public}s on Apple Platforms", (uint8_t *)&v82, 0xCu);
      }
LABEL_101:
      if (mDNS_LoggingEnabled)
        v73 = 50;
      else
        v73 = 250;
      WatchDogReportingThreshold = v73;
      UpdateDebugState(v65, v66, v67, v68, v69, v70, v71, v72, v82);
      v38 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          goto LABEL_145;
        LOWORD(v82) = 0;
        v27 = "USR1 Logging Enabled";
      }
      else
      {
        v38 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          goto LABEL_145;
        LOWORD(v82) = 0;
        v27 = "USR1 Logging Enabled";
      }
LABEL_126:
      v54 = v38;
      v55 = 2;
LABEL_127:
      _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, v27, (uint8_t *)&v82, v55);
      goto LABEL_145;
    case 31:
      mDNS_PacketLoggingEnabled = 1;
      v42 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          goto LABEL_111;
        v82 = 136446210;
        v83 = "Enabled";
        goto LABEL_110;
      }
      v42 = mDNSLogCategory_Default_redacted;
      if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
      {
        v82 = 136446210;
        v83 = "Enabled";
LABEL_110:
        _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "SIGUSR2: Packet Logging %{public}s on Apple Platforms", (uint8_t *)&v82, 0xCu);
      }
LABEL_111:
      if (mDNS_McastLoggingEnabled)
        v75 = mDNS_PacketLoggingEnabled;
      else
        v75 = 0;
      mDNS_McastTracingEnabled = v75;
      v60 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        v13 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT);
        if (!v13)
          goto LABEL_134;
        v78 = "Disabled";
        if (v75)
          v78 = "Enabled";
        v82 = 136446210;
        v83 = (char *)v78;
        v21 = "SIGUSR2: Multicast Tracing is %{public}s";
      }
      else
      {
        v60 = mDNSLogCategory_Default_redacted;
        v13 = os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT);
        if (!v13)
          goto LABEL_134;
        v76 = "Disabled";
        if (v75)
          v76 = "Enabled";
        v82 = 136446210;
        v83 = (char *)v76;
        v21 = "SIGUSR2: Multicast Tracing is %{public}s";
      }
LABEL_132:
      v56 = v60;
      v57 = 12;
LABEL_133:
      _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, v21, (uint8_t *)&v82, v57);
LABEL_134:
      UpdateDebugState(v13, v14, v15, v16, v17, v18, v19, v20, v82);
      goto LABEL_145;
    default:
      if (v11 == 2)
      {
LABEL_12:
        v23 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          {
            v82 = 136446210;
            v83 = "mDNSResponder mDNSResponder-2559.2.4 (Aug  3 2024 11:06:39)";
LABEL_62:
            _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "%{public}s stopping", (uint8_t *)&v82, 0xCu);
          }
        }
        else
        {
          v23 = mDNSLogCategory_Default_redacted;
          if (os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          {
            v82 = 136446210;
            v83 = "mDNSResponder mDNSResponder-2559.2.4 (Aug  3 2024 11:06:39)";
            goto LABEL_62;
          }
        }
        while (all_requests)
          AbortUnlinkAndFree((_QWORD *)all_requests);
        for (i = (uint64_t *)LocalDomainEnumRecords; LocalDomainEnumRecords; i = (uint64_t *)LocalDomainEnumRecords)
        {
          LocalDomainEnumRecords = *i;
          mDNS_Deregister((unsigned int *)mDNSStorage, (uint64_t)(i + 1));
        }
        if ((listenfd & 0x80000000) == 0)
        {
          close(listenfd);
          unlink("/var/run/mDNSResponder");
        }
        mDNS_StartExit();
        goto LABEL_145;
      }
      if (v11 != 1)
      {
LABEL_19:
        v25 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
            goto LABEL_145;
          v82 = 67109120;
          LODWORD(v83) = v11;
          v27 = "SignalCallback: Unknown signal %d";
        }
        else
        {
          v25 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
            goto LABEL_145;
          v82 = 67109120;
          LODWORD(v83) = v11;
          v27 = "SignalCallback: Unknown signal %d";
        }
        v54 = v25;
        v55 = 8;
        goto LABEL_127;
      }
      v22 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT))
          goto LABEL_138;
        LOWORD(v82) = 0;
      }
      else
      {
        v22 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_DEFAULT))
          goto LABEL_138;
        LOWORD(v82) = 0;
      }
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "SIGHUP: Purge cache", (uint8_t *)&v82, 2u);
LABEL_138:
      mDNS_Lock_((unsigned int *)mDNSStorage, (uint64_t)"SignalCallback", 638);
      for (j = 0; j != 499; ++j)
      {
        for (k = (_QWORD *)mDNSStorage[j + 34]; k; k = (_QWORD *)*k)
        {
          for (m = (_QWORD *)k[2]; m; m = (_QWORD *)*m)
            mDNS_PurgeCacheResourceRecord((unsigned int *)mDNSStorage, (uint64_t)m);
        }
      }
      mDNSCoreRestartQueries((uint64_t)mDNSStorage);
      mDNS_Unlock_((uint64_t)mDNSStorage, (uint64_t)"SignalCallback", 645);
LABEL_145:
      KQueueUnlock((uint64_t)"Unix Signal", v47, v48, v49, v50, v51, v52, v53);
      return;
  }
}

void mDNSPreferencesSetNames(int a1, __int128 *a2, __int128 *a3)
{
  uint64_t v6;
  uint64_t v7;
  _OWORD *v8;
  uint64_t v9;
  _OWORD *v10;
  size_t v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  NSObject *v18;
  _BOOL4 v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  const char *v28;
  uint64_t v29;
  uint8_t *v30;
  unsigned int v31;
  uint8_t *v32;
  uint8_t v33;
  uint64_t v34;
  char *v35;
  unsigned int v36;
  __int128 *v37;
  char v38;
  CFStringRef v39;
  const __CFString *v40;
  const __SCPreferences *v41;
  const __SCPreferences *v42;
  CFStringRef v43;
  uint64_t v44;
  CFStringRef v45;
  const __CFString *v46;
  const __SCPreferences *v47;
  const __SCPreferences *v48;
  int v49;
  NSObject *v50;
  const char *v51;
  int v52;
  NSObject *v53;
  NSObject *v54;
  void *__s1;
  const __SCPreferences *v56;
  int v57;
  uint8_t buf[64];
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  CFStringEncoding nameEncoding;
  uint64_t v64;
  __int16 v65;
  uint64_t v66;
  __int16 v67;
  uint64_t v68;

  v6 = mDNSStorage[0];
  if (a1 == 1)
    v7 = 364;
  else
    v7 = 236;
  if (a1 == 1)
    v8 = (_OWORD *)(mDNSStorage[0] + 364);
  else
    v8 = (_OWORD *)(mDNSStorage[0] + 236);
  if (a1 == 1)
    v9 = 428;
  else
    v9 = 300;
  if (a1 == 1)
    v10 = (_OWORD *)(mDNSStorage[0] + 428);
  else
    v10 = (_OWORD *)(mDNSStorage[0] + 300);
  if (a2 && a3)
  {
    v11 = *(unsigned __int8 *)a2;
    if ((_DWORD)v11 == *(unsigned __int8 *)a3)
    {
      __s1 = (char *)a3 + 1;
      if (!memcmp((char *)a2 + 1, (char *)a3 + 1, v11)
        && (_DWORD)v11 == *(unsigned __int8 *)(v6 + v7)
        && !memcmp((char *)a2 + 1, (char *)v8 + 1, v11)
        && (_DWORD)v11 == *(unsigned __int8 *)(v6 + v9)
        && !memcmp(__s1, (char *)v10 + 1, v11))
      {
        return;
      }
    }
  }
  else if (!a2)
  {
    *(_BYTE *)(mDNSStorage[0] + v7) = 0;
    if (a3)
      goto LABEL_24;
    goto LABEL_26;
  }
  v12 = *a2;
  v13 = a2[1];
  v14 = a2[3];
  v8[2] = a2[2];
  v8[3] = v14;
  *v8 = v12;
  v8[1] = v13;
  if (a3)
  {
LABEL_24:
    v15 = *a3;
    v16 = a3[1];
    v17 = a3[3];
    v10[2] = a3[2];
    v10[3] = v17;
    *v10 = v15;
    v10[1] = v16;
    goto LABEL_27;
  }
LABEL_26:
  *(_BYTE *)(v6 + v9) = 0;
LABEL_27:
  v18 = mDNSLogCategory_State;
  v19 = os_log_type_enabled((os_log_t)mDNSLogCategory_State, OS_LOG_TYPE_DEFAULT);
  if (a1 != 1)
  {
    if (!v19)
      goto LABEL_43;
    v24 = *(unsigned __int8 *)(v6 + v7) + 1;
    v25 = *(unsigned __int8 *)(v6 + v9) + 1;
    if (a2)
    {
      v26 = *(unsigned __int8 *)a2 + 1;
      if (a3)
      {
LABEL_35:
        v27 = *(unsigned __int8 *)a3 + 1;
LABEL_41:
        *(_DWORD *)buf = 141560835;
        *(_QWORD *)&buf[4] = 1752392040;
        *(_WORD *)&buf[12] = 1040;
        *(_DWORD *)&buf[14] = v24;
        *(_WORD *)&buf[18] = 2101;
        *(_QWORD *)&buf[20] = v8;
        *(_WORD *)&buf[28] = 2160;
        *(_QWORD *)&buf[30] = 1752392040;
        *(_WORD *)&buf[38] = 1040;
        *(_DWORD *)&buf[40] = v25;
        *(_WORD *)&buf[44] = 2101;
        *(_QWORD *)&buf[46] = v10;
        *(_WORD *)&buf[54] = 2160;
        *(_QWORD *)&buf[56] = 1752392040;
        LOWORD(v59) = 1040;
        *(_DWORD *)((char *)&v59 + 2) = v26;
        WORD3(v59) = 2101;
        *((_QWORD *)&v59 + 1) = a2;
        LOWORD(v60) = 2160;
        *(_QWORD *)((char *)&v60 + 2) = 1752392040;
        WORD5(v60) = 1040;
        HIDWORD(v60) = v27;
        LOWORD(v61) = 2101;
        *(_QWORD *)((char *)&v61 + 2) = a3;
        v28 = "mDNSPreferencesSetNames: changing local host name -- last change: %{sensitive, mask.hash, mdnsresponder:do"
              "main_label}.*P -> %{sensitive, mask.hash, mdnsresponder:domain_label}.*P, current change: %{sensitive, mas"
              "k.hash, mdnsresponder:domain_label}.*P -> %{sensitive, mask.hash, mdnsresponder:domain_label}.*P";
        goto LABEL_42;
      }
    }
    else
    {
      v26 = 0;
      if (a3)
        goto LABEL_35;
    }
    v27 = 0;
    goto LABEL_41;
  }
  if (!v19)
    goto LABEL_43;
  v20 = *(unsigned __int8 *)(v6 + v7) + 1;
  v21 = *(unsigned __int8 *)(v6 + v9) + 1;
  if (!a2)
  {
    v22 = 0;
    if (a3)
      goto LABEL_31;
LABEL_37:
    v23 = 0;
    goto LABEL_38;
  }
  v22 = *(unsigned __int8 *)a2 + 1;
  if (!a3)
    goto LABEL_37;
LABEL_31:
  v23 = *(unsigned __int8 *)a3 + 1;
LABEL_38:
  *(_DWORD *)buf = 141560835;
  *(_QWORD *)&buf[4] = 1752392040;
  *(_WORD *)&buf[12] = 1040;
  *(_DWORD *)&buf[14] = v20;
  *(_WORD *)&buf[18] = 2101;
  *(_QWORD *)&buf[20] = v8;
  *(_WORD *)&buf[28] = 2160;
  *(_QWORD *)&buf[30] = 1752392040;
  *(_WORD *)&buf[38] = 1040;
  *(_DWORD *)&buf[40] = v21;
  *(_WORD *)&buf[44] = 2101;
  *(_QWORD *)&buf[46] = v10;
  *(_WORD *)&buf[54] = 2160;
  *(_QWORD *)&buf[56] = 1752392040;
  LOWORD(v59) = 1040;
  *(_DWORD *)((char *)&v59 + 2) = v22;
  WORD3(v59) = 2101;
  *((_QWORD *)&v59 + 1) = a2;
  LOWORD(v60) = 2160;
  *(_QWORD *)((char *)&v60 + 2) = 1752392040;
  WORD5(v60) = 1040;
  HIDWORD(v60) = v23;
  LOWORD(v61) = 2101;
  *(_QWORD *)((char *)&v61 + 2) = a3;
  v28 = "mDNSPreferencesSetNames: changing computer name -- last change: %{sensitive, mask.hash, mdnsresponder:domain_lab"
        "el}.*P -> %{sensitive, mask.hash, mdnsresponder:domain_label}.*P, current change: %{sensitive, mask.hash, mdnsre"
        "sponder:domain_label}.*P -> %{sensitive, mask.hash, mdnsresponder:domain_label}.*P";
LABEL_42:
  _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v28, buf, 0x6Au);
LABEL_43:
  v31 = *(unsigned __int8 *)a2;
  v30 = (uint8_t *)a2 + 1;
  v29 = v31;
  v61 = 0u;
  v62 = 0u;
  v59 = 0u;
  v60 = 0u;
  memset(buf, 0, sizeof(buf));
  if (v31 <= 0x3FuLL)
  {
    if (v30 >= &v30[v29])
    {
      v32 = buf;
    }
    else
    {
      v32 = buf;
      do
      {
        v33 = *v30++;
        *v32++ = v33;
        --v29;
      }
      while (v29);
    }
    *v32 = 0;
  }
  if (a3)
  {
    v36 = *(unsigned __int8 *)a3;
    v35 = (char *)a3 + 1;
    v34 = v36;
    if (v36 <= 0x3FuLL)
    {
      v37 = &v59;
      if (v35 < &v35[v34])
      {
        v37 = &v59;
        do
        {
          v38 = *v35++;
          *(_BYTE *)v37 = v38;
          v37 = (__int128 *)((char *)v37 + 1);
          --v34;
        }
        while (v34);
      }
      *(_BYTE *)v37 = 0;
    }
  }
  if ((_BYTE)v59 && strcmp((const char *)buf, (const char *)&v59))
  {
    if (a1 != 2)
    {
      if (a1 != 1)
        return;
      v39 = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)&v59, 0x8000100u);
      if (!v39)
      {
        v49 = -6700;
LABEL_77:
        v50 = mDNSLogCategory_Default;
        if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
        {
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
            return;
        }
        else
        {
          v50 = mDNSLogCategory_Default_redacted;
          if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
            return;
        }
        nameEncoding = 141558531;
        v64 = 1752392040;
        v65 = 2085;
        v66 = (uint64_t)&v59;
        v67 = 2048;
        v68 = v49;
        v51 = "Failed to set computer name -- name: %{sensitive, mask.hash}s, error: %ld";
LABEL_93:
        _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_ERROR, v51, (uint8_t *)&nameEncoding, 0x20u);
        return;
      }
      v40 = v39;
      v57 = 0;
      v41 = _mdns_system_create_locked_prefs(&v57);
      v56 = v41;
      if (!v57)
      {
        v42 = v41;
        nameEncoding = 0;
        v43 = SCDynamicStoreCopyComputerName(0, &nameEncoding);
        if (v43)
          v44 = nameEncoding;
        else
          v44 = 134217984;
        if (v43)
          CFRelease(v43);
        if (SCPreferencesSetComputerName(v42, v40, v44))
        {
          v57 = 0;
LABEL_75:
          v57 = _mdns_system_commit_and_apply_prefs(v42);
          goto LABEL_76;
        }
        if (SCError())
        {
          v57 = SCError();
          if (!v57)
            goto LABEL_75;
        }
        else
        {
          v57 = -6700;
        }
        if (mdns_system_log_s_once != -1)
          dispatch_once(&mdns_system_log_s_once, &__block_literal_global_6694);
        v53 = mdns_system_log_s_log;
        if (os_log_type_enabled((os_log_t)mdns_system_log_s_log, OS_LOG_TYPE_ERROR))
        {
          nameEncoding = 138412802;
          v64 = (uint64_t)v40;
          v65 = 2048;
          v66 = v44;
          v67 = 2048;
          v68 = v57;
          _os_log_error_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_ERROR, "SCPreferencesSetComputerName failed -- name: '%@', encoding: 0x%lX, error: %{mdns:err}ld", (uint8_t *)&nameEncoding, 0x20u);
        }
      }
LABEL_76:
      _mdns_system_unlock_and_forget_prefs(&v56);
      v49 = v57;
      CFRelease(v40);
      if (!v49)
        return;
      goto LABEL_77;
    }
    v45 = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)&v59, 0x8000100u);
    if (!v45)
    {
      v52 = -6700;
LABEL_85:
      v50 = mDNSLogCategory_Default;
      if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_Default == mDNSLogCategory_State)
      {
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default, OS_LOG_TYPE_ERROR))
          return;
      }
      else
      {
        v50 = mDNSLogCategory_Default_redacted;
        if (!os_log_type_enabled((os_log_t)mDNSLogCategory_Default_redacted, OS_LOG_TYPE_ERROR))
          return;
      }
      nameEncoding = 141558531;
      v64 = 1752392040;
      v65 = 2085;
      v66 = (uint64_t)&v59;
      v67 = 2048;
      v68 = v52;
      v51 = "Failed to set local hostname -- name: %{sensitive, mask.hash}s, error: %ld";
      goto LABEL_93;
    }
    v46 = v45;
    v57 = 0;
    v47 = _mdns_system_create_locked_prefs(&v57);
    v56 = v47;
    if (!v57)
    {
      v48 = v47;
      if (SCPreferencesSetLocalHostName(v47, v46))
      {
        v57 = 0;
LABEL_83:
        v57 = _mdns_system_commit_and_apply_prefs(v48);
        goto LABEL_84;
      }
      if (SCError())
      {
        v57 = SCError();
        if (!v57)
          goto LABEL_83;
      }
      else
      {
        v57 = -6700;
      }
      if (mdns_system_log_s_once != -1)
        dispatch_once(&mdns_system_log_s_once, &__block_literal_global_6694);
      v54 = mdns_system_log_s_log;
      if (os_log_type_enabled((os_log_t)mdns_system_log_s_log, OS_LOG_TYPE_ERROR))
      {
        nameEncoding = 138412546;
        v64 = (uint64_t)v46;
        v65 = 2048;
        v66 = v57;
        _os_log_error_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_ERROR, "SCPreferencesSetLocalHostName failed -- name: '%@', error: %{mdns:err}ld", (uint8_t *)&nameEncoding, 0x16u);
      }
    }
LABEL_84:
    _mdns_system_unlock_and_forget_prefs(&v56);
    v52 = v57;
    CFRelease(v46);
    if (!v52)
      return;
    goto LABEL_85;
  }
}

void SetLowWater(uint64_t a1, int a2)
{
  int v3;
  NSObject *v4;
  int v5;
  int *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  NSObject *v13;
  int v14;
  int *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;

  v21 = a2;
  v3 = *(_DWORD *)(a1 + 16);
  if ((v3 & 0x80000000) == 0 && setsockopt(v3, 0xFFFF, 4100, &v21, 4u) < 0)
  {
    v4 = mDNSLogCategory_Default;
    v5 = *(_DWORD *)(a1 + 16);
    __error();
    v6 = __error();
    strerror(*v6);
    LogMsgWithLevel(v4, OS_LOG_TYPE_DEFAULT, "SO_RCVLOWAT IPv4 %d error %d errno %d (%s)", v7, v8, v9, v10, v11, v5);
  }
  v12 = *(_DWORD *)(a1 + 48);
  if ((v12 & 0x80000000) == 0 && setsockopt(v12, 0xFFFF, 4100, &v21, 4u) < 0)
  {
    v13 = mDNSLogCategory_Default;
    v14 = *(_DWORD *)(a1 + 48);
    __error();
    v15 = __error();
    strerror(*v15);
    LogMsgWithLevel(v13, OS_LOG_TYPE_DEFAULT, "SO_RCVLOWAT IPv6 %d error %d errno %d (%s)", v16, v17, v18, v19, v20, v14);
  }
}

uint64_t kqUDSEventCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(a3 + 40))(a1, *(_QWORD *)(a3 + 48));
}

uint64_t SendDict_ToServer(void *a1)
{
  _xpc_connection_s *mach_service;
  _xpc_connection_s *v3;
  NSObject *v4;
  NSObject *v5;
  dispatch_time_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  int v15;
  _QWORD handler[7];
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;

  v21 = 0;
  v22 = &v21;
  v23 = 0x2000000000;
  v24 = 0;
  v17 = 0;
  v18 = &v17;
  v19 = 0x2000000000;
  v20 = -3;
  HelperLog((int)"SendDict_ToServer Sending msg to Daemon", a1);
  mach_service = xpc_connection_create_mach_service("com.apple.mDNSResponder_Helper", (dispatch_queue_t)HelperQueue, 2uLL);
  if (mach_service)
  {
    v3 = mach_service;
    xpc_connection_set_event_handler(mach_service, &__block_literal_global_5334);
    xpc_connection_activate(v3);
    v4 = dispatch_semaphore_create(0);
    if (v4)
    {
      v5 = v4;
      dispatch_retain(v4);
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 0x40000000;
      handler[2] = __SendDict_ToServer_block_invoke;
      handler[3] = &unk_10013DD60;
      handler[4] = &v17;
      handler[5] = &v21;
      handler[6] = v5;
      xpc_connection_send_message_with_reply(v3, a1, (dispatch_queue_t)HelperQueue, handler);
      v6 = dispatch_time(0, 5000000000);
      if (dispatch_semaphore_wait(v5, v6))
      {
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SendDict_ToServer: UNEXPECTED WAIT_TIME in dispatch_semaphore_wait", v7, v8, v9, v10, v11, v15);
        xpc_connection_cancel(v3);
        dispatch_semaphore_wait(v5, 0xFFFFFFFFFFFFFFFFLL);
      }
      if (mDNS_LoggingEnabled == 1)
        LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "SendDict_ToServer returning with errorcode[%d]", v7, v8, v9, v10, v11, *((_DWORD *)v18 + 6));
      xpc_connection_cancel(v3);
      xpc_release(v3);
      dispatch_release(v5);
    }
    else
    {
      xpc_connection_cancel(v3);
      xpc_release(v3);
    }
  }
  v12 = (void *)v22[3];
  if (v12)
  {
    xpc_release(v12);
    v22[3] = 0;
  }
  v13 = *((unsigned int *)v18 + 6);
  _Block_object_dispose(&v17, 8);
  _Block_object_dispose(&v21, 8);
  return v13;
}

void HelperLog(int a1, xpc_object_t object)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;

  v8 = xpc_copy_description(object);
  if (mDNS_LoggingEnabled == 1)
    LogMsgWithLevel(mDNSLogCategory_Default, OS_LOG_TYPE_DEFAULT, "HelperLog %s: %s", v3, v4, v5, v6, v7, a1);
  if (v8)
    free(v8);
}

char *_mdns_obj_copy_description(_QWORD *a1)
{
  char *v2;

  v2 = 0;
  asprintf(&v2, "<%s: %p>", *(const char **)(a1[2] + 8), a1);
  return v2;
}

const char *_mdns_obj_copy_description_as_cfstring(uint64_t a1)
{
  _QWORD *v1;
  uint64_t (*v2)(void);
  const char *result;
  char *v4;

  v1 = (_QWORD *)(a1 + 16);
  do
  {
    v1 = (_QWORD *)*v1;
    if (!v1)
      return 0;
    v2 = (uint64_t (*)(void))v1[3];
  }
  while (!v2);
  result = (const char *)v2();
  if (result)
  {
    v4 = (char *)result;
    result = (const char *)CFStringCreateWithCStringNoCopy(0, result, 0x8000100u, kCFAllocatorMalloc);
    if (!result)
    {
      free(v4);
      return 0;
    }
  }
  return result;
}

void _dnssec_obj_rr_rrsig_finalize(uint64_t a1)
{
  _QWORD *v2;

  v2 = *(_QWORD **)(a1 + 80);
  if (v2)
  {
    ref_count_obj_release(v2);
    *(_QWORD *)(a1 + 80) = 0;
  }
}

char *_dnssec_obj_rr_rrsig_copy_rdata_rfc_description(uint64_t a1, int *a2)
{
  uint64_t v4;
  uint64_t v5;
  char *v6;
  _BYTE *v7;
  uint64_t v8;
  _BYTE *v9;
  _BYTE *v10;
  _BYTE *v11;
  _BYTE *v12;
  int v13;
  unsigned int v14;
  BOOL v15;
  uint64_t v16;
  unsigned __int16 *v18;
  unsigned int v19;
  unsigned __int16 *v20;
  char *v21;
  unsigned int v22;
  unint64_t v23;
  char *v24;
  int v25;
  const char *v26;
  int v27;
  size_t v28;
  char *v29;
  int v30;
  char v31;
  char v32;
  tm v34;
  time_t v35;
  time_t v36;
  char v37[1009];
  char v38[16];
  char v39[16];

  memset(v39, 0, 15);
  memset(v38, 0, 15);
  v4 = *(_QWORD *)(a1 + 24);
  v36 = bswap32(*(_DWORD *)(v4 + 12));
  v35 = bswap32(*(_DWORD *)(v4 + 8));
  memset(&v34, 0, sizeof(v34));
  gmtime_r(&v36, &v34);
  strftime(v39, 0xFuLL, "%Y%m%d%H%M%S", &v34);
  gmtime_r(&v35, &v34);
  strftime(v38, 0xFuLL, "%Y%m%d%H%M%S", &v34);
  v5 = *(_QWORD *)(a1 + 80);
  v6 = v37;
  bzero(v37, 0x3F1uLL);
  v7 = *(_BYTE **)(v5 + 16);
  LODWORD(v8) = *v7;
  if (*v7)
  {
    v9 = &v7[*(_QWORD *)(v5 + 24)];
    v6 = v37;
    v10 = *(_BYTE **)(v5 + 16);
    do
    {
      if (v8 > 0x3F || (v11 = &v10[v8 + 1], v11 - v7 > 255))
      {
        v24 = 0;
        v27 = -6742;
        goto LABEL_132;
      }
      if (v11 >= v9)
      {
        v24 = 0;
        v27 = -6750;
        goto LABEL_132;
      }
      v12 = v10 + 1;
      if (v12 < v11)
      {
        v8 = v8;
        do
        {
          v13 = *v12;
          v14 = v13 - 32;
          if ((v13 - 32) > 0x5E)
          {
            *v6 = 92;
            v6[1] = (*v12 / 0x64u) | 0x30;
            v6[2] = (*v12 / 0xAu - 10 * ((unsigned __int16)(26 * (*v12 / 0xAu)) >> 8)) | 0x30;
            v6[3] = (*v12 % 0xAu) | 0x30;
            v6 += 4;
          }
          else
          {
            v15 = v14 > 0x3C;
            v16 = (1 << v14) & 0x1000000000004001;
            if (!v15 && v16 != 0)
              *v6++ = 92;
            *v6++ = v13;
          }
          ++v12;
          --v8;
        }
        while (v8);
      }
      *v6++ = 46;
      LODWORD(v8) = *v11;
      v10 = v11;
    }
    while (*v11);
    if (v11 != v7)
      goto LABEL_20;
  }
  *v6++ = 46;
LABEL_20:
  *v6 = 0;
  v18 = *(unsigned __int16 **)(a1 + 24);
  v19 = *((unsigned __int8 *)v18 + 18);
  v20 = v18 + 9;
  if (*((_BYTE *)v18 + 18))
  {
    v20 = v18 + 9;
    do
    {
      v21 = (char *)v20 + v19;
      v22 = v21[1];
      v20 = (unsigned __int16 *)(v21 + 1);
      v19 = v22;
    }
    while (v22);
  }
  v23 = (unsigned __int16)(~((_WORD)v20 - ((_WORD)v18 + 18)) + *(_WORD *)(a1 + 36) - 18);
  v24 = (char *)(4 * (((v23 + 2) * (unsigned __int128)0x5555555555555556uLL) >> 64));
  v25 = __rev16(*v18);
  if (v25 > 248)
  {
    if (v25 >= 0x8000)
    {
      switch(v25)
      {
        case 0x8000:
          v26 = "TA";
          break;
        case 0x8001:
          v26 = "DLV";
          break;
        case 0xFFFF:
          v26 = "Reserved";
          break;
        default:
LABEL_120:
          v26 = 0;
          break;
      }
    }
    else
    {
      switch(v25)
      {
        case 249:
          v26 = "TKEY";
          break;
        case 250:
          v26 = "TSIG";
          break;
        case 251:
          v26 = "IXFR";
          break;
        case 252:
          v26 = "AXFR";
          break;
        case 253:
          v26 = "MAILB";
          break;
        case 254:
          v26 = "MAILA";
          break;
        case 255:
          v26 = "ANY";
          break;
        case 256:
          v26 = "URI";
          break;
        case 257:
          v26 = "CAA";
          break;
        case 258:
          v26 = "AVC";
          break;
        case 259:
          v26 = "DOA";
          break;
        case 260:
          v26 = "AMTRELAY";
          break;
        default:
          goto LABEL_120;
      }
    }
  }
  else
  {
    v26 = "A";
    switch(v25)
    {
      case 1:
        break;
      case 2:
        v26 = "NS";
        break;
      case 3:
        v26 = "MD";
        break;
      case 4:
        v26 = "MF";
        break;
      case 5:
        v26 = "CNAME";
        break;
      case 6:
        v26 = "SOA";
        break;
      case 7:
        v26 = "MB";
        break;
      case 8:
        v26 = "MG";
        break;
      case 9:
        v26 = "MR";
        break;
      case 10:
        v26 = "NULL";
        break;
      case 11:
        v26 = "WKS";
        break;
      case 12:
        v26 = "PTR";
        break;
      case 13:
        v26 = "HINFO";
        break;
      case 14:
        v26 = "MINFO";
        break;
      case 15:
        v26 = "MX";
        break;
      case 16:
        v26 = "TXT";
        break;
      case 17:
        v26 = "RP";
        break;
      case 18:
        v26 = "AFSDB";
        break;
      case 19:
        v26 = "X25";
        break;
      case 20:
        v26 = "ISDN";
        break;
      case 21:
        v26 = "RT";
        break;
      case 22:
        v26 = "NSAP";
        break;
      case 23:
        v26 = "NSAP-PTR";
        break;
      case 24:
        v26 = "SIG";
        break;
      case 25:
        v26 = "KEY";
        break;
      case 26:
        v26 = "PX";
        break;
      case 27:
        v26 = "GPOS";
        break;
      case 28:
        v26 = "AAAA";
        break;
      case 29:
        v26 = "LOC";
        break;
      case 30:
        v26 = "NXT";
        break;
      case 31:
        v26 = "EID";
        break;
      case 32:
        v26 = "NIMLOC";
        break;
      case 33:
        v26 = "SRV";
        break;
      case 34:
        v26 = "ATMA";
        break;
      case 35:
        v26 = "NAPTR";
        break;
      case 36:
        v26 = "KX";
        break;
      case 37:
        v26 = "CERT";
        break;
      case 38:
        v26 = "A6";
        break;
      case 39:
        v26 = "DNAME";
        break;
      case 40:
        v26 = "SINK";
        break;
      case 41:
        v26 = "OPT";
        break;
      case 42:
        v26 = "APL";
        break;
      case 43:
        v26 = "DS";
        break;
      case 44:
        v26 = "SSHFP";
        break;
      case 45:
        v26 = "IPSECKEY";
        break;
      case 46:
        v26 = "RRSIG";
        break;
      case 47:
        v26 = "NSEC";
        break;
      case 48:
        v26 = "DNSKEY";
        break;
      case 49:
        v26 = "DHCID";
        break;
      case 50:
        v26 = "NSEC3";
        break;
      case 51:
        v26 = "NSEC3PARAM";
        break;
      case 52:
        v26 = "TLSA";
        break;
      case 53:
        v26 = "SMIMEA";
        break;
      case 55:
        v26 = "HIP";
        break;
      case 56:
        v26 = "NINFO";
        break;
      case 57:
        v26 = "RKEY";
        break;
      case 58:
        v26 = "TALINK";
        break;
      case 59:
        v26 = "CDS";
        break;
      case 60:
        v26 = "CDNSKEY";
        break;
      case 61:
        v26 = "OPENPGPKEY";
        break;
      case 62:
        v26 = "CSYNC";
        break;
      case 63:
        v26 = "ZONEMD";
        break;
      case 64:
        v26 = "SVCB";
        break;
      case 65:
        v26 = "HTTPS";
        break;
      case 99:
        v26 = "SPF";
        break;
      case 100:
        v26 = "UINFO";
        break;
      case 101:
        v26 = "UID";
        break;
      case 102:
        v26 = "GID";
        break;
      case 103:
        v26 = "UNSPEC";
        break;
      case 104:
        v26 = "NID";
        break;
      case 105:
        v26 = "L32";
        break;
      case 106:
        v26 = "L64";
        break;
      case 107:
        v26 = "LP";
        break;
      case 108:
        v26 = "EUI48";
        break;
      case 109:
        v26 = "EUI64";
        break;
      default:
        goto LABEL_120;
    }
  }
  v28 = ((unint64_t)v24 | 1)
      + snprintf(0, 0, "%s %u %u %u %s %s %u %s ", v26, *((unsigned __int8 *)v18 + 2), *((unsigned __int8 *)v18 + 3), bswap32(*((_DWORD *)v18 + 1)), v39, v38, __rev16(v18[8]), v37);
  if (v28 && (v29 = (char *)malloc_type_calloc(1uLL, v28, 0xF1748037uLL)) != 0)
  {
    v24 = v29;
    v30 = snprintf(v29, v28, "%s %u %u %u %s %s %u %s ", v26, *(unsigned __int8 *)(*(_QWORD *)(a1 + 24) + 2), *(unsigned __int8 *)(*(_QWORD *)(a1 + 24) + 3), bswap32(*(_DWORD *)(*(_QWORD *)(a1 + 24) + 4)), v39, v38, __rev16(*(unsigned __int16 *)(*(_QWORD *)(a1 + 24) + 16)), v37);
    if (v30 >= 1)
    {
      base_x_encode(0, (unsigned __int8 *)v20 + 1, v23, &v24[v30]);
      v31 = 0;
      v27 = 0;
      if (!a2)
        goto LABEL_126;
      goto LABEL_125;
    }
  }
  else
  {
    __break(1u);
  }
  v27 = -6700;
LABEL_132:
  v31 = 1;
  if (a2)
LABEL_125:
    *a2 = v27;
LABEL_126:
  v32 = v31 ^ 1;
  if (!v24)
    v32 = 1;
  if ((v32 & 1) == 0)
  {
    free(v24);
    return 0;
  }
  return v24;
}

uint64_t dnssec_obj_rr_rrsig_create(unsigned __int8 *a1, const void *a2, unsigned int a3, int a4, int *a5)
{
  uint64_t v5;
  _QWORD *v11;
  int v12;
  _UNKNOWN **v13;
  void (*v14)(uint64_t);
  _QWORD *v15;
  int v17;

  v17 = 0;
  if (rdata_parser_rrsig_check_validity((uint64_t)a2, a3))
  {
    v11 = malloc_type_calloc(1uLL, 0x58uLL, 0xF1748037uLL);
    if (v11)
    {
      v5 = (uint64_t)v11;
      v13 = &_dnssec_obj_rr_rrsig_kind;
      v11[1] = &_dnssec_obj_rr_rrsig_kind;
      do
      {
        v14 = (void (*)(uint64_t))v13[2];
        if (v14)
          v14(v5);
        v13 = (_UNKNOWN **)*v13;
      }
      while (v13);
      ++*(_DWORD *)v5;
      dnssec_obj_rr_init_fields(v5, a1, 46, 1, a2, a3, a4, (uint64_t)_dnssec_obj_rr_rrsig_copy_rdata_rfc_description, &v17);
      *(_QWORD *)(v5 + 80) = dnssec_obj_domain_name_create_with_labels((unsigned __int8 *)(*(_QWORD *)(v5 + 24) + 18), 0, &v17);
      v12 = v17;
      if (!v17)
      {
        v15 = 0;
        v17 = 0;
        goto LABEL_9;
      }
    }
    else
    {
      __break(1u);
    }
    v15 = (_QWORD *)v5;
    v5 = 0;
  }
  else
  {
    v15 = 0;
    v5 = 0;
    v12 = -6705;
    v17 = -6705;
  }
LABEL_9:
  if (a5)
    *a5 = v12;
  if (v15)
    ref_count_obj_release(v15);
  return v5;
}

BOOL dnssec_obj_rr_rrsig_covers_rr(uint64_t a1, uint64_t a2, int *a3)
{
  int v4;
  unsigned __int16 *v5;
  uint64_t v8;
  _BYTE *v9;
  int v10;
  unint64_t v11;
  _BYTE *v12;
  int v13;
  uint64_t v14;
  _BOOL8 result;

  v4 = -90005;
  v5 = *(unsigned __int16 **)(a1 + 24);
  if (*(unsigned __int16 *)(a2 + 32) == bswap32(*v5) >> 16)
  {
    v8 = *(_QWORD *)(a2 + 16);
    v9 = *(_BYTE **)(v8 + 16);
    v10 = *v9;
    if (*v9)
    {
      v11 = 0;
      do
      {
        ++v11;
        v12 = &v9[v10];
        v13 = v12[1];
        v9 = v12 + 1;
        v10 = v13;
      }
      while (v13);
    }
    else
    {
      v11 = 0;
    }
    if (v11 < *((unsigned __int8 *)v5 + 3))
    {
      result = 0;
      v4 = -90002;
    }
    else if (ref_count_obj_compare(*(_QWORD *)(a1 + 16), *(_QWORD *)(a2 + 16), 1))
    {
      result = 0;
      v4 = -90003;
    }
    else if (*(unsigned __int16 *)(a1 + 34) == *(unsigned __int16 *)(a2 + 34))
    {
      v14 = *(_QWORD *)(a1 + 80);
      if (!ref_count_obj_compare(v8, v14, 1)
        || (result = dnssec_obj_domain_name_is_sub_domain_of(*(unsigned __int8 **)(v8 + 16), *(unsigned __int8 **)(v14 + 16))))
      {
        v4 = 0;
        result = 1;
      }
    }
    else
    {
      result = 0;
      v4 = -90004;
    }
  }
  else
  {
    result = 0;
    v4 = -90001;
  }
  if (a3)
    *a3 = v4;
  return result;
}

uint64_t DNSMessageExtractDomainName(unint64_t a1, uint64_t a2, char *__src, char *__dst, _QWORD *a5)
{
  char *v6;
  uint64_t result;
  unint64_t v8;
  _BYTE *v10;
  unsigned int v11;
  char *v12;
  char *v13;
  uint64_t v14;
  char *v15;

  if (__dst)
    v6 = __dst + 256;
  else
    v6 = 0;
  result = 4294960586;
  if ((unint64_t)__src < a1)
    return result;
  v8 = a1 + a2;
  if (a1 + a2 <= (unint64_t)__src)
    return result;
  v10 = __dst;
  v11 = *__src;
  if (*__src)
  {
    v12 = 0;
    do
    {
      if (v11 > 0x3F)
      {
        if ((~v11 & 0xC0) != 0)
          return 4294960554;
        if ((uint64_t)(v8 - (_QWORD)__src) < 2)
          return 4294960546;
        if (!v12)
        {
          v12 = __src + 2;
          if (!v10)
            goto LABEL_23;
        }
        __src = (char *)(a1 + (__src[1] | ((unint64_t)(v11 & 0x3F) << 8)));
        if ((unint64_t)__src >= v8)
          return 4294960546;
        v11 = *__src;
        if (v11 > 0xBF)
          return 4294960554;
      }
      else
      {
        v13 = &__src[v11 + 1];
        if ((unint64_t)v13 >= v8)
          return 4294960546;
        if (v10)
        {
          v14 = v11 + 1;
          if (v6 - v10 <= v14)
            return 4294960545;
          memcpy(v10, __src, v11 + 1);
          v10 += v14;
        }
        v11 = *v13;
        __src = v13;
      }
    }
    while (v11);
    if (!v10)
      goto LABEL_23;
    goto LABEL_22;
  }
  v12 = 0;
  if (__dst)
LABEL_22:
    *v10 = 0;
LABEL_23:
  result = 0;
  if (a5)
  {
    if (v12)
      v15 = v12;
    else
      v15 = __src + 1;
    *a5 = v15;
  }
  return result;
}

uint64_t DNSMessageExtractDomainNameString(unint64_t a1, uint64_t a2, char *a3, unsigned __int8 *a4, _QWORD *a5)
{
  uint64_t result;
  uint64_t v8;
  _OWORD __dst[16];

  v8 = 0;
  memset(__dst, 0, sizeof(__dst));
  result = DNSMessageExtractDomainName(a1, a2, a3, (char *)__dst, &v8);
  if (!(_DWORD)result)
  {
    result = DomainNameToString((unsigned __int8 *)__dst, 0, a4, 0);
    if (a5)
    {
      if (!(_DWORD)result)
        *a5 = v8;
    }
  }
  return result;
}

uint64_t DomainNameToString(unsigned __int8 *a1, unint64_t a2, unsigned __int8 *a3, _QWORD *a4)
{
  uint64_t i;
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  unsigned __int8 v8;
  char v10;
  char v11;
  uint64_t result;

  if (a2 && (uint64_t)(a2 - (_QWORD)a1) < 1)
    return 4294960546;
  LODWORD(i) = *a1;
  if (*a1)
  {
    v5 = a1;
    do
    {
      if (i > 0x3F)
        return 4294960554;
      v6 = &v5[i + 1];
      if (v6 - a1 > 255)
        return 4294960554;
      if (a2 && (unint64_t)v6 >= a2)
        return 4294960546;
      v7 = v5 + 1;
      if (v7 < v6)
      {
        for (i = i; i; --i)
        {
          v8 = *v7;
          if (((char)*v7 - 32) > 0x5E)
          {
            if ((*v7 & 0x80) == 0)
            {
              *a3 = 92;
              if (v8 <= 0x63u)
                v10 = 48;
              else
                v10 = 49;
              a3[1] = v10;
              if (v8 >= 0x64u)
                v11 = v8 / 0xAu - 10;
              else
                v11 = v8 / 0xAu;
              a3[2] = v11 + 48;
              a3[3] = (v8 % 0xAu) | 0x30;
              a3 += 4;
              goto LABEL_26;
            }
          }
          else if (*v7 - 32 <= 0x3C && ((1 << (v8 - 32)) & 0x1000000000004001) != 0)
          {
            *a3++ = 92;
          }
          *a3++ = v8;
LABEL_26:
          ++v7;
        }
      }
      *a3++ = 46;
      LODWORD(i) = *v6;
      v5 = v6;
    }
    while (*v6);
    if (v6 != a1)
      goto LABEL_30;
  }
  *a3++ = 46;
  v6 = a1;
LABEL_30:
  *a3 = 0;
  result = 0;
  if (a4)
    *a4 = v6 + 1;
  return result;
}

uint64_t DNSMessageExtractQuestion(unint64_t a1, uint64_t a2, char *a3, char *a4, _WORD *a5, _WORD *a6, _QWORD *a7)
{
  uint64_t result;
  unsigned __int16 *v13;
  unsigned __int16 *v14;

  v14 = 0;
  result = DNSMessageExtractDomainName(a1, a2, a3, a4, &v14);
  if (!(_DWORD)result)
  {
    v13 = v14;
    if (a1 + a2 - (unint64_t)v14 < 4)
    {
      return 4294960546;
    }
    else
    {
      if (a5)
        *a5 = bswap32(*v14) >> 16;
      if (a6)
        *a6 = bswap32(v13[1]) >> 16;
      result = 0;
      if (a7)
        *a7 = v13 + 2;
    }
  }
  return result;
}

uint64_t _DNSMessageExtractRecordEx(unint64_t a1, uint64_t a2, char *a3, char *a4, _WORD *a5, _WORD *a6, _DWORD *a7, unsigned __int16 **a8, unint64_t *a9, char *a10, size_t a11, _QWORD *a12, _QWORD *a13, _QWORD *a14)
{
  uint64_t result;
  char *v20;
  unsigned __int16 *v21;
  unint64_t v22;
  unsigned int v23;
  unint64_t v25;
  size_t v26;
  char *v27;

  v27 = 0;
  result = DNSMessageExtractDomainName(a1, a2, a3, a4, &v27);
  if (!(_DWORD)result)
  {
    v20 = v27;
    if (a1 + a2 - (unint64_t)v27 < 0xA)
      return 4294960546;
    v21 = (unsigned __int16 *)(v27 + 10);
    v22 = __rev16(*((unsigned __int16 *)v27 + 4));
    if (a1 + a2 - (unint64_t)(v27 + 10) < v22)
    {
      return 4294960546;
    }
    else
    {
      v25 = 0;
      v26 = 0;
      v23 = bswap32(*(unsigned __int16 *)v27) >> 16;
      if (!a11 && !a13
        || (result = DNSMessageExtractRData(a1, a2, v27 + 10, v22, v23, a10, a11, &v26, &v25), !(_DWORD)result))
      {
        if (a5)
          *a5 = v23;
        if (a6)
          *a6 = bswap32(*((unsigned __int16 *)v20 + 1)) >> 16;
        if (a7)
          *a7 = bswap32(*((_DWORD *)v20 + 1));
        if (a8)
          *a8 = v21;
        if (a9)
          *a9 = v22;
        if (a12)
          *a12 = v26;
        if (a13)
          *a13 = v25;
        result = 0;
        if (a14)
          *a14 = (char *)v21 + v22;
      }
    }
  }
  return result;
}

uint64_t DNSMessageExtractRData(unint64_t a1, uint64_t a2, char *__src, unint64_t a4, int a5, char *a6, size_t a7, size_t *a8, unint64_t *a9)
{
  size_t v10;
  unint64_t v12;
  char *v16;
  uint64_t result;
  int v18;
  char *v19;
  char *v20;
  int v21;
  char *v22;
  void *v23;
  char *v24;
  int v25;
  char *v26;
  char *v27;
  int v28;
  int64_t v29;
  unint64_t v30;
  BOOL v31;
  uint64_t v32;
  char *v33;
  size_t v34;
  char *v35;
  int v36;
  char *v37;
  char *v38;
  int v39;
  char *v40;
  unint64_t v41;
  int v42;
  char *v43;
  char *v44;
  int v45;
  int64_t v46;
  unint64_t v47;
  char *v48;
  _BYTE *v49;
  int v50;
  char *v51;
  char *v52;
  int v53;
  char *v54;
  int64_t v55;
  int v56;
  char *v57;
  char *v58;
  int v59;
  int64_t v60;
  unint64_t v61;
  char *v62;
  size_t v63;
  char *v64;
  size_t v65;
  int v66;
  char *v67;
  char *v68;
  int v69;
  char *v70;
  int v71;
  char *v72;
  char *v73;
  int v74;
  unint64_t v75;
  void *v76;
  _OWORD __dst[16];
  char __srca[264];

  v10 = a7;
  v12 = a4;
  v76 = 0;
  memset(__srca, 0, 256);
  memset(__dst, 0, sizeof(__dst));
  v16 = &__src[a4];
  switch(a5)
  {
    case 2:
    case 3:
    case 4:
    case 5:
    case 7:
    case 8:
    case 9:
    case 12:
    case 39:
      result = DNSMessageExtractDomainName(a1, a2, __src, __srca, &v76);
      if (!(_DWORD)result)
      {
        if (v76 != v16)
          goto LABEL_77;
        v18 = __srca[0];
        v19 = __srca;
        if (__srca[0])
        {
          do
          {
            v20 = &v19[v18];
            v21 = v20[1];
            v19 = v20 + 1;
            v18 = v21;
          }
          while (v21);
        }
        v12 = v19 - __srca + 1;
        if (v12 < v10)
          v10 = v19 - __srca + 1;
        v22 = __srca;
        v23 = a6;
        goto LABEL_9;
      }
      break;
    case 6:
      result = DNSMessageExtractDomainName(a1, a2, __src, __srca, &v76);
      if (!(_DWORD)result)
      {
        result = DNSMessageExtractDomainName(a1, a2, (char *)v76, (char *)__dst, &v76);
        if (!(_DWORD)result)
        {
          v49 = v76;
          if (v16 - (_BYTE *)v76 != 20)
            goto LABEL_77;
          v50 = __srca[0];
          v51 = __srca;
          if (__srca[0])
          {
            do
            {
              v52 = &v51[v50];
              v53 = v52[1];
              v51 = v52 + 1;
              v50 = v53;
            }
            while (v53);
          }
          v54 = &a6[v10];
          v55 = v51 - __srca;
          v56 = LOBYTE(__dst[0]);
          v57 = (char *)__dst;
          if (LOBYTE(__dst[0]))
          {
            do
            {
              v58 = &v57[v56];
              v59 = v58[1];
              v57 = v58 + 1;
              v56 = v59;
            }
            while (v59);
          }
          v60 = v57 - (char *)__dst;
          v61 = v57 - (char *)__dst + 1;
          v12 = v55 + v61 + 21;
          if (v55 + 1 < v10)
            v10 = v55 + 1;
          memcpy(a6, __srca, v10);
          v62 = &a6[v10];
          if (v54 - v62 >= v61)
            v63 = v60 + 1;
          else
            v63 = v54 - v62;
          memcpy(v62, __dst, v63);
          v64 = &v62[v63];
          if ((unint64_t)(v54 - v64) >= 0x14)
            v65 = 20;
          else
            v65 = v54 - v64;
          goto LABEL_70;
        }
      }
      break;
    case 14:
    case 17:
    case 26:
      result = DNSMessageExtractDomainName(a1, a2, __src, __srca, &v76);
      if (!(_DWORD)result)
      {
        result = DNSMessageExtractDomainName(a1, a2, (char *)v76, (char *)__dst, &v76);
        if (!(_DWORD)result)
        {
          if (v76 != v16)
            goto LABEL_77;
          v36 = __srca[0];
          v37 = __srca;
          if (__srca[0])
          {
            do
            {
              v38 = &v37[v36];
              v39 = v38[1];
              v37 = v38 + 1;
              v36 = v39;
            }
            while (v39);
          }
          v40 = &a6[v10];
          v41 = v37 - __srca + 1;
          v42 = LOBYTE(__dst[0]);
          v43 = (char *)__dst;
          if (LOBYTE(__dst[0]))
          {
            do
            {
              v44 = &v43[v42];
              v45 = v44[1];
              v43 = v44 + 1;
              v42 = v45;
            }
            while (v45);
          }
          v46 = v43 - (char *)__dst;
          v47 = v43 - (char *)__dst + 1;
          v12 = v47 + v41;
          if (v41 < v10)
            v10 = v37 - __srca + 1;
          memcpy(a6, __srca, v10);
          v33 = &a6[v10];
          if (v40 - v33 >= v47)
            v34 = v46 + 1;
          else
            v34 = v40 - v33;
          v35 = (char *)__dst;
          goto LABEL_36;
        }
      }
      break;
    case 15:
    case 18:
    case 21:
    case 36:
      if (a4 < 3)
        goto LABEL_77;
      result = DNSMessageExtractDomainName(a1, a2, __src + 2, __srca, &v76);
      if (!(_DWORD)result)
      {
        if (v76 != v16)
          goto LABEL_77;
        v24 = &a6[v10];
        v25 = __srca[0];
        v26 = __srca;
        if (__srca[0])
        {
          do
          {
            v27 = &v26[v25];
            v28 = v27[1];
            v26 = v27 + 1;
            v25 = v28;
          }
          while (v28);
        }
        v29 = v26 - __srca;
        v30 = v26 - __srca + 1;
        v12 = v26 - __srca + 3;
        v31 = v10 >= 2;
        v32 = 2;
        goto LABEL_16;
      }
      break;
    case 33:
      if (a4 < 7)
        goto LABEL_77;
      result = DNSMessageExtractDomainName(a1, a2, __src + 6, __srca, &v76);
      if (!(_DWORD)result)
      {
        if (v76 != v16)
          goto LABEL_77;
        v24 = &a6[v10];
        v66 = __srca[0];
        v67 = __srca;
        if (__srca[0])
        {
          do
          {
            v68 = &v67[v66];
            v69 = v68[1];
            v67 = v68 + 1;
            v66 = v69;
          }
          while (v69);
        }
        v29 = v67 - __srca;
        v30 = v67 - __srca + 1;
        v12 = v67 - __srca + 7;
        v31 = v10 >= 6;
        v32 = 6;
LABEL_16:
        if (v31)
          v10 = v32;
        memcpy(a6, __src, v10);
        v33 = &a6[v10];
        if (v24 - v33 >= v30)
          v34 = v29 + 1;
        else
          v34 = v24 - v33;
        v35 = __srca;
LABEL_36:
        memcpy(v33, v35, v34);
        v48 = &v33[v34];
        goto LABEL_71;
      }
      break;
    case 47:
      result = DNSMessageExtractDomainName(a1, a2, __src, __srca, &v76);
      if (!(_DWORD)result)
      {
        v49 = v76;
        if (v76 <= v16)
        {
          v70 = &a6[v10];
          v71 = __srca[0];
          v72 = __srca;
          if (__srca[0])
          {
            do
            {
              v73 = &v72[v71];
              v74 = v73[1];
              v72 = v73 + 1;
              v71 = v74;
            }
            while (v74);
          }
          v75 = v16 - (_BYTE *)v76;
          v12 = v72 - __srca + 1 + v16 - (_BYTE *)v76;
          if (v72 - __srca + 1 < v10)
            v10 = v72 - __srca + 1;
          memcpy(a6, __srca, v10);
          v64 = &a6[v10];
          if (v70 - v64 >= v75)
            v65 = v16 - v49;
          else
            v65 = v70 - v64;
LABEL_70:
          memcpy(v64, v49, v65);
          v48 = &v64[v65];
LABEL_71:
          v10 = v48 - a6;
          goto LABEL_72;
        }
LABEL_77:
        result = 4294960554;
      }
      break;
    default:
      if (a7 >= a4)
        v10 = a4;
      v23 = a6;
      v22 = __src;
LABEL_9:
      memcpy(v23, v22, v10);
LABEL_72:
      if (a8)
        *a8 = v10;
      result = 0;
      if (a9)
        *a9 = v12;
      break;
  }
  return result;
}

uint64_t DNSMessageGetAnswerSection(unint64_t a1, unint64_t a2, char **a3)
{
  uint64_t v3;
  uint64_t v4;
  unsigned int v7;
  char *v8;
  unint64_t v10;
  uint64_t result;
  _QWORD v12[9];

  if (a2 < 0xC)
    return 4294960553;
  v12[7] = v3;
  v12[8] = v4;
  v7 = __rev16(*(unsigned __int16 *)(a1 + 4));
  v8 = (char *)(a1 + 12);
  if (v7)
  {
    v10 = a1 + a2;
    while (1)
    {
      v12[0] = 0;
      result = DNSMessageExtractDomainName(a1, a2, v8, 0, v12);
      if ((_DWORD)result)
        break;
      if (v10 - v12[0] <= 3)
        return 4294960546;
      v8 = (char *)(v12[0] + 4);
      if (!--v7)
        goto LABEL_7;
    }
  }
  else
  {
LABEL_7:
    result = 0;
    if (a3)
      *a3 = v8;
  }
  return result;
}

char *DNSMessageCollapse(unint64_t a1, unint64_t a2, _QWORD *a3, char **a4)
{
  int DomainName;
  int v9;
  char *v10;
  char *v11;
  int v12;
  int64_t v13;
  unsigned int v14;
  int v15;
  int v16;
  char v17;
  unsigned int v18;
  char *v19;
  char *v20;
  char v21;
  unsigned int v22;
  char *v23;
  unsigned int v24;
  char v25;
  unsigned __int16 v26;
  __int16 v27;
  char *v28;
  char *v29;
  int v30;
  char *v31;
  char *v32;
  char *v33;
  char v34;
  __int16 v35;
  char *v36;
  _QWORD *v38;
  char **v39;
  unint64_t __n;
  char *v41;
  char v42;
  unsigned int v43;
  size_t size;
  unsigned int v45;
  char *v46;
  unsigned __int16 v47;
  unsigned int v48;
  size_t v49;
  unsigned __int16 v50;
  char *v51;
  int v52;
  char *v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  char __dst[256];
  char __src[264];

  v53 = 0;
  v52 = 0;
  memset(__src, 0, 256);
  memset(__dst, 0, sizeof(__dst));
  if (a2 < 0xC)
  {
LABEL_69:
    v36 = 0;
    v20 = 0;
    DomainName = -6743;
    goto LABEL_58;
  }
  if (__rev16(*(unsigned __int16 *)(a1 + 4)) != 1)
  {
    v36 = 0;
    v20 = 0;
    DomainName = -6764;
    goto LABEL_58;
  }
  v53 = (char *)(a1 + 12);
  DomainName = DNSMessageExtractQuestion(a1, a2, (char *)(a1 + 12), __src, (_WORD *)&v52 + 1, &v52, &v53);
  if (DomainName)
    goto LABEL_63;
  if ((unsigned __int16)v52 != 1)
  {
    v36 = 0;
    v20 = 0;
    DomainName = -6756;
    goto LABEL_58;
  }
  v9 = __src[0];
  v38 = a3;
  v10 = __src;
  if (__src[0])
  {
    do
    {
      v11 = &v10[v9];
      v12 = v11[1];
      v10 = v11 + 1;
      v9 = v12;
    }
    while (v12);
  }
  v13 = v10 - __src;
  __n = v10 - __src + 1;
  v41 = v53;
  __memcpy_chk(__dst, __src, __n, 256);
  v14 = __rev16(*(unsigned __int16 *)(a1 + 6));
  if (v14)
  {
    v15 = 0;
    v43 = -1;
LABEL_9:
    v16 = 0;
    v53 = v41;
    v17 = 1;
    while (1)
    {
      v51 = 0;
      LODWORD(v49) = 0;
      LOWORD(v48) = 0;
      v50 = 0;
      v68 = 0u;
      v69 = 0u;
      v66 = 0u;
      v67 = 0u;
      v64 = 0u;
      v65 = 0u;
      v62 = 0u;
      v63 = 0u;
      v60 = 0u;
      v61 = 0u;
      v58 = 0u;
      v59 = 0u;
      v56 = 0u;
      v57 = 0u;
      v54 = 0u;
      v55 = 0u;
      DomainName = _DNSMessageExtractRecordEx(a1, a2, v53, (char *)&v54, &v48, &v50, &v49, (unsigned __int16 **)&v51, 0, 0, 0, 0, 0, &v53);
      if (DomainName)
        break;
      if ((unsigned __int16)v48 == 5
        && v50 == (unsigned __int16)v52
        && DomainNameEqual((unsigned __int8 *)&v54, (unsigned __int8 *)__dst))
      {
        DomainName = DNSMessageExtractDomainName(a1, a2, v51, __dst, 0);
        if (DomainName)
          break;
        v17 = 0;
        v18 = v43;
        if (v43 >= v49)
          v18 = v49;
        v43 = v18;
        if (++v16 == v14)
          goto LABEL_22;
      }
      else if (v14 == ++v16)
      {
        if ((v17 & 1) != 0)
          goto LABEL_25;
LABEL_22:
        if (++v15 != v14)
          goto LABEL_9;
        goto LABEL_25;
      }
    }
LABEL_63:
    v36 = 0;
LABEL_57:
    v20 = 0;
    goto LABEL_58;
  }
  v43 = -1;
LABEL_25:
  v39 = a4;
  v46 = 0;
  v19 = 0;
  v20 = 0;
  size = v13 + 17;
  v21 = 1;
  a4 = &v53;
  while (1)
  {
    v42 = v21;
    v53 = v41;
    if (v14)
      break;
    v45 = 0;
    if (v20)
      goto LABEL_52;
LABEL_45:
    if (!size || (v29 = (char *)malloc_type_calloc(1uLL, size, 0xF1748037uLL)) == 0)
    {
      __break(1u);
      goto LABEL_69;
    }
    v20 = v29;
    if (size < 0xC)
      goto LABEL_67;
    v30 = *(_DWORD *)a1;
    *((_WORD *)v29 + 2) = *(_WORD *)(a1 + 4);
    *(_DWORD *)v29 = v30;
    *(_DWORD *)(v29 + 6) = 0;
    *((_WORD *)v29 + 5) = 0;
    if (size - 12 < __n)
      goto LABEL_67;
    v31 = &v29[size];
    v32 = v29 + 12;
    memcpy(v29 + 12, __src, __n);
    v33 = &v32[__n];
    v46 = v31;
    if ((unint64_t)(v31 - &v32[__n]) < 4)
      goto LABEL_67;
    v21 = 0;
    v34 = BYTE2(v52);
    v35 = v52;
    *v33 = HIBYTE(v52);
    v33[1] = v34;
    v33[2] = HIBYTE(v35);
    v33[3] = v35;
    v19 = v33 + 4;
    *((_WORD *)v20 + 2) = 256;
    if ((v42 & 1) == 0)
      goto LABEL_54;
  }
  v45 = 0;
  v22 = v14;
  do
  {
    v51 = 0;
    v49 = 0;
    v48 = 0;
    v50 = 0;
    v47 = 0;
    v68 = 0u;
    v69 = 0u;
    v66 = 0u;
    v67 = 0u;
    v64 = 0u;
    v65 = 0u;
    v62 = 0u;
    v63 = 0u;
    v60 = 0u;
    v61 = 0u;
    v58 = 0u;
    v59 = 0u;
    v56 = 0u;
    v57 = 0u;
    v54 = 0u;
    v55 = 0u;
    v23 = v53;
    DomainName = _DNSMessageExtractRecordEx(a1, a2, v53, (char *)&v54, &v50, &v47, &v48, 0, 0, 0, 0, 0, &v49, &v53);
    if (DomainName)
      goto LABEL_65;
    if (v50 == HIWORD(v52)
      && v47 == (unsigned __int16)v52
      && DomainNameEqual((unsigned __int8 *)&v54, (unsigned __int8 *)__dst))
    {
      if (v20)
      {
        if (v46 - v19 < 2)
          goto LABEL_64;
        *(_WORD *)v19 = 3264;
        if ((unint64_t)(v46 - v19 - 2) < 0xA)
          goto LABEL_64;
        v24 = v48;
        if (v48 >= v43)
          v24 = v43;
        v48 = v24;
        v25 = v50;
        v26 = v47;
        v27 = v49;
        v19[2] = HIBYTE(v50);
        v19[3] = v25;
        v19[4] = HIBYTE(v26);
        v19[5] = v26;
        v19[6] = HIBYTE(v24);
        v19[7] = BYTE2(v24);
        v19[8] = BYTE1(v24);
        v19[9] = v24;
        v19[10] = HIBYTE(v27);
        v19[11] = v27;
        v28 = v19 + 12;
        if (v46 - v28 < v49)
        {
LABEL_64:
          DomainName = -6762;
LABEL_65:
          v36 = 0;
          goto LABEL_66;
        }
        DomainName = _DNSMessageExtractRecordEx(a1, a2, v23, 0, 0, 0, 0, 0, 0, v28, v49, &v51, 0, 0);
        if (DomainName)
          goto LABEL_65;
        v19 = &v51[(_QWORD)v28];
        ++v45;
      }
      else
      {
        size += v49 + 12;
      }
    }
    --v22;
  }
  while (v22);
  if (!v20)
    goto LABEL_45;
LABEL_52:
  if (size >= 0xC)
  {
    *((_WORD *)v20 + 3) = bswap32(v45) >> 16;
LABEL_54:
    a4 = v39;
    DomainName = 0;
    if (v38)
      *v38 = v19 - v20;
    v36 = v20;
    goto LABEL_57;
  }
LABEL_67:
  v36 = 0;
  DomainName = -6762;
LABEL_66:
  a4 = v39;
LABEL_58:
  if (a4)
    *(_DWORD *)a4 = DomainName;
  if (v20)
    free(v20);
  return v36;
}

uint64_t DomainNameEqual(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2;
  unsigned __int8 *v3;
  uint64_t v4;
  int v5;

  if (a1 == a2)
    return 1;
  v2 = a2;
  v3 = a1;
  while (1)
  {
    v4 = *v3;
    if (v3 != v2)
    {
      v5 = *v2;
      if ((_DWORD)v4 != v5 || mdns_memcmp_us_ascii_case_insensitive(v3 + 1, v2 + 1, *v3, v5))
        break;
    }
    v3 += v4 + 1;
    v2 += v4 + 1;
    if (!(_DWORD)v4)
      return 1;
  }
  return 0;
}

_BYTE *DomainNameDupEx(_BYTE *result, _QWORD *a2, size_t *a3)
{
  const void *v5;
  int v6;
  _BYTE *v7;
  _BYTE *v8;
  int v9;
  size_t v10;
  _BYTE *v11;

  v5 = result;
  v6 = *result;
  v7 = result;
  if (*result)
  {
    v7 = result;
    do
    {
      v8 = &v7[v6];
      v9 = v8[1];
      v7 = v8 + 1;
      v6 = v9;
    }
    while (v9);
  }
  v10 = v7 - result + 1;
  if (v7 - result == -1 || (result = malloc_type_malloc(v7 - result + 1, 0xA172743EuLL)) == 0)
  {
    __break(1u);
  }
  else
  {
    v11 = result;
    result = memcpy(result, v5, v10);
    *a2 = v11;
    if (a3)
      *a3 = v10;
  }
  return result;
}

uint64_t DomainNameFromString(_BYTE *a1, char *a2)
{
  uint64_t v2;
  unint64_t v3;
  _BYTE *v4;
  _BYTE *v5;
  _BYTE *v6;
  unsigned __int8 *v7;
  int v8;
  int v9;
  int v10;
  char *v11;

  *a1 = 0;
  v2 = *a2;
  if (*a2)
  {
    if ((_DWORD)v2 == 46)
    {
      v2 = a2[1];
      if (!a2[1])
        return v2;
      LODWORD(v2) = 46;
    }
    v3 = (unint64_t)(a1 + 255);
    while (2)
    {
      if ((unint64_t)(a1 + 64) >= v3)
        v4 = (_BYTE *)v3;
      else
        v4 = a1 + 64;
      v5 = a1 + 1;
      v6 = a1 + 1;
      v7 = (unsigned __int8 *)a2;
      do
      {
        a2 = (char *)(v7 + 1);
        if ((_DWORD)v2 == 92)
        {
          LODWORD(v2) = *a2;
          if (!*a2)
            return 4294960546;
          a2 = (char *)(v7 + 2);
          if (v2 - 48 <= 9)
          {
            v8 = *a2;
            if ((v8 - 48) <= 9)
            {
              v9 = v7[3];
              if ((v9 - 48) <= 9)
              {
                v10 = 100 * v2 + 10 * (char)v8 + (char)v9;
                v11 = (char *)(v7 + 4);
                if (v10 < 5584)
                {
                  a2 = v11;
                  LOBYTE(v2) = v10 + 48;
                }
              }
            }
          }
        }
        else if ((_DWORD)v2 == 46)
        {
          break;
        }
        if (v6 >= v4)
          return 4294960545;
        *v6++ = v2;
        LODWORD(v2) = *a2;
        v7 = (unsigned __int8 *)a2;
      }
      while (*a2);
      if (v6 == v5)
      {
        return 4294960554;
      }
      else
      {
        *a1 = (_BYTE)v6 - (_BYTE)v5;
        *v6 = 0;
        v2 = *a2;
        a1 = v6;
        if (*a2)
          continue;
      }
      break;
    }
  }
  return v2;
}

const char *DNSRecordTypeValueToString(int a1)
{
  int v1;
  const char *result;

  if (a1 > 248)
  {
    if (a1 >= 0x8000)
    {
      switch(a1)
      {
        case 0x8000:
          return "TA";
        case 0x8001:
          return "DLV";
        case 0xFFFF:
          return "Reserved";
        default:
          return 0;
      }
    }
    else
    {
      switch(a1)
      {
        case 249:
          result = "TKEY";
          break;
        case 250:
          result = "TSIG";
          break;
        case 251:
          result = "IXFR";
          break;
        case 252:
          result = "AXFR";
          break;
        case 253:
          result = "MAILB";
          break;
        case 254:
          result = "MAILA";
          break;
        case 255:
          result = "ANY";
          break;
        case 256:
          result = "URI";
          break;
        case 257:
          result = "CAA";
          break;
        case 258:
          result = "AVC";
          break;
        case 259:
          result = "DOA";
          break;
        case 260:
          result = "AMTRELAY";
          break;
        default:
          return 0;
      }
    }
  }
  else
  {
    v1 = a1 - 1;
    result = "A";
    switch(v1)
    {
      case 0:
        return result;
      case 1:
        result = "NS";
        break;
      case 2:
        result = "MD";
        break;
      case 3:
        result = "MF";
        break;
      case 4:
        result = "CNAME";
        break;
      case 5:
        result = "SOA";
        break;
      case 6:
        result = "MB";
        break;
      case 7:
        result = "MG";
        break;
      case 8:
        result = "MR";
        break;
      case 9:
        result = "NULL";
        break;
      case 10:
        result = "WKS";
        break;
      case 11:
        result = "PTR";
        break;
      case 12:
        result = "HINFO";
        break;
      case 13:
        result = "MINFO";
        break;
      case 14:
        result = "MX";
        break;
      case 15:
        result = "TXT";
        break;
      case 16:
        result = "RP";
        break;
      case 17:
        result = "AFSDB";
        break;
      case 18:
        result = "X25";
        break;
      case 19:
        result = "ISDN";
        break;
      case 20:
        result = "RT";
        break;
      case 21:
        result = "NSAP";
        break;
      case 22:
        result = "NSAP-PTR";
        break;
      case 23:
        result = "SIG";
        break;
      case 24:
        result = "KEY";
        break;
      case 25:
        result = "PX";
        break;
      case 26:
        result = "GPOS";
        break;
      case 27:
        result = "AAAA";
        break;
      case 28:
        result = "LOC";
        break;
      case 29:
        result = "NXT";
        break;
      case 30:
        result = "EID";
        break;
      case 31:
        result = "NIMLOC";
        break;
      case 32:
        result = "SRV";
        break;
      case 33:
        result = "ATMA";
        break;
      case 34:
        result = "NAPTR";
        break;
      case 35:
        result = "KX";
        break;
      case 36:
        result = "CERT";
        break;
      case 37:
        result = "A6";
        break;
      case 38:
        result = "DNAME";
        break;
      case 39:
        result = "SINK";
        break;
      case 40:
        result = "OPT";
        break;
      case 41:
        result = "APL";
        break;
      case 42:
        result = "DS";
        break;
      case 43:
        result = "SSHFP";
        break;
      case 44:
        result = "IPSECKEY";
        break;
      case 45:
        result = "RRSIG";
        break;
      case 46:
        result = "NSEC";
        break;
      case 47:
        result = "DNSKEY";
        break;
      case 48:
        result = "DHCID";
        break;
      case 49:
        result = "NSEC3";
        break;
      case 50:
        result = "NSEC3PARAM";
        break;
      case 51:
        result = "TLSA";
        break;
      case 52:
        result = "SMIMEA";
        break;
      case 54:
        result = "HIP";
        break;
      case 55:
        result = "NINFO";
        break;
      case 56:
        result = "RKEY";
        break;
      case 57:
        result = "TALINK";
        break;
      case 58:
        result = "CDS";
        break;
      case 59:
        result = "CDNSKEY";
        break;
      case 60:
        result = "OPENPGPKEY";
        break;
      case 61:
        result = "CSYNC";
        break;
      case 62:
        result = "ZONEMD";
        break;
      case 63:
        result = "SVCB";
        break;
      case 64:
        result = "HTTPS";
        break;
      case 98:
        result = "SPF";
        break;
      case 99:
        result = "UINFO";
        break;
      case 100:
        result = "UID";
        break;
      case 101:
        result = "GID";
        break;
      case 102:
        result = "UNSPEC";
        break;
      case 103:
        result = "NID";
        break;
      case 104:
        result = "L32";
        break;
      case 105:
        result = "L64";
        break;
      case 106:
        result = "LP";
        break;
      case 107:
        result = "EUI48";
        break;
      case 108:
        result = "EUI64";
        break;
      default:
        return 0;
    }
  }
  return result;
}

void DNSMessageToString(char *a1, unint64_t a2, unsigned int a3, uint64_t a4)
{
  const char *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t (*v8)(_OWORD *, const char *, ...);
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  int CUSymAddr_DataBuffer_AppendF_sAddr;
  uint64_t i;
  char *v14;
  int v15;
  unsigned __int8 *v16;
  int v17;
  char *v18;
  _BOOL4 v19;
  int v20;
  int v21;
  char *v22;
  const char *v23;
  const char *v24;
  const char *v25;
  int v26;
  int v27;
  const char *v28;
  const char *v29;
  int v30;
  const char *v31;
  const char *v32;
  const char *v33;
  int v34;
  const char *v35;
  const char *v36;
  int v37;
  int v38;
  _BOOL4 v39;
  int v40;
  int v41;
  char *v42;
  int v43;
  int v44;
  const char *v45;
  const char *v46;
  int v47;
  int v48;
  int v49;
  const char *v50;
  int v51;
  const char *v52;
  const char *v53;
  const char *v54;
  int v55;
  int v56;
  int DomainName;
  char *v58;
  char *v59;
  char *v60;
  const char *v61;
  const char *v62;
  int64_t v63;
  char *v64;
  unsigned int v65;
  unint64_t v66;
  unint64_t v67;
  const char *v68;
  int v69;
  int v70;
  unsigned __int8 *v71;
  const char *v72;
  const char *v73;
  const char *v74;
  const char *v75;
  unsigned int v76;
  unsigned __int8 *v77;
  unint64_t v78;
  const char *v79;
  const char *v80;
  unint64_t v81;
  const char *v82;
  const char *v83;
  int v84;
  unint64_t v85;
  const char *v86;
  const char *v87;
  unint64_t v88;
  const char *v89;
  const char *v90;
  uint64_t v91;
  unsigned __int8 *v92;
  unint64_t v93;
  unint64_t v95;
  char *v96;
  unint64_t v97;
  uint64_t v98;
  unint64_t v99;
  uint64_t v100;
  unint64_t v102;
  unsigned int v103;
  unsigned int v104;
  unsigned int v105;
  const char *v106;
  unsigned int v107;
  unint64_t v108;
  int v109;
  uint64_t v112;
  void *v113;
  char *v114;
  _OWORD v115[3];
  uint64_t v116;
  int v117;
  int v118;
  unint64_t v119;
  unsigned __int8 *v120;
  void *v121;
  unsigned __int8 *v122;
  _OWORD v123[16];
  _BYTE v124[271];
  unsigned __int8 v125[1009];
  _BYTE v126[512];
  unint64_t v127[32];
  void *__src[127];

  v113 = 0;
  if (_GetCUSymAddr_DataBuffer_Init_sOnce != -1)
    dispatch_once(&_GetCUSymAddr_DataBuffer_Init_sOnce, &__block_literal_global_5576);
  v116 = 0;
  memset(v115, 0, sizeof(v115));
  v114 = 0;
  v112 = 0;
  memset(v126, 0, sizeof(v126));
  bzero(v125, 0x3F1uLL);
  memset(v124, 0, 256);
  memset(v123, 0, sizeof(v123));
  if (!_GetCUSymAddr_DataBuffer_Init_sAddr)
    goto LABEL_636;
  _GetCUSymAddr_DataBuffer_Init_sAddr(v115, v126, 512, -1);
  if (a2 < 0xC)
    goto LABEL_636;
  v107 = __rev16(*((unsigned __int16 *)a1 + 2));
  v105 = __rev16(*((unsigned __int16 *)a1 + 3));
  v104 = __rev16(*((unsigned __int16 *)a1 + 4));
  v102 = ((unint64_t)a1[2] >> 3) & 0xF;
  v103 = __rev16(*((unsigned __int16 *)a1 + 5));
  v5 = "";
  if ((a3 & 0x20) != 0)
  {
LABEL_74:
    if ((a3 & 0x10) != 0)
      goto LABEL_628;
    goto LABEL_75;
  }
  v6 = a1[3] | (a1[2] << 8);
  v7 = __rev16(*(unsigned __int16 *)a1);
  if ((a3 & 4) != 0)
  {
    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
      goto LABEL_636;
    v8 = (uint64_t (*)(_OWORD *, const char *, ...))_GetCUSymAddr_DataBuffer_AppendF_sAddr;
    v11 = 81;
    if ((v6 & 0x8000u) != 0)
      v11 = 82;
    v99 = v6;
    v100 = v11;
    v98 = v7;
    v10 = "id: 0x%04X (%u), flags: 0x%04X (%c/";
  }
  else
  {
    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
      || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "ID:               0x%04X (%u)\n", v7, v7))
    {
      goto LABEL_636;
    }
    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
      goto LABEL_636;
    v8 = (uint64_t (*)(_OWORD *, const char *, ...))_GetCUSymAddr_DataBuffer_AppendF_sAddr;
    v9 = 81;
    if ((v6 & 0x8000u) != 0)
      v9 = 82;
    v98 = v9;
    v10 = "Flags:            0x%04X %c/";
  }
  if (v8(v115, v10))
    goto LABEL_636;
  if (v102 > 6 || (_DWORD)v102 == 3)
  {
    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
      goto LABEL_636;
    CUSymAddr_DataBuffer_AppendF_sAddr = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "OPCODE%d");
  }
  else
  {
    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
      goto LABEL_636;
    CUSymAddr_DataBuffer_AppendF_sAddr = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "%s");
  }
  if (CUSymAddr_DataBuffer_AppendF_sAddr)
    goto LABEL_636;
  for (i = 0; i != 14; i += 2)
  {
    if (((uint64_t)(&kDNSHeaderFlagsDescs)[i + 1] & (unsigned __int16)v6) != 0)
    {
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
        || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, ", %s", (&kDNSHeaderFlagsDescs)[i]))
      {
        goto LABEL_636;
      }
    }
  }
  if ((v6 & 0xF) > 0xB)
  {
    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
      goto LABEL_636;
    v96 = (char *)(v6 & 0xF);
    v15 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, ", RCODE%d");
  }
  else
  {
    v14 = (&off_10013F900)[v6 & 0xF];
    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
      goto LABEL_636;
    v96 = v14;
    v15 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, ", %s");
  }
  if (v15)
    goto LABEL_636;
  if ((a3 & 4) == 0)
  {
    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
      || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "\n", v96, v98))
    {
      goto LABEL_636;
    }
    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
      || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "Question count:   %u\n", v107))
    {
      goto LABEL_636;
    }
    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
      || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "Answer count:     %u\n", v105))
    {
      goto LABEL_636;
    }
    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
      || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "Authority count:  %u\n", v104))
    {
      goto LABEL_636;
    }
    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
      || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "Additional count: %u\n", v103))
    {
      goto LABEL_636;
    }
    v5 = "";
    goto LABEL_74;
  }
  if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
    dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
  if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
    || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, ")", v96, v98))
  {
    goto LABEL_636;
  }
  if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
    dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
  if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
    || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, ", counts: %u/%u/%u/%u", v107, v105, v104, v103))
  {
    goto LABEL_636;
  }
  v5 = ", ";
  if ((a3 & 0x10) != 0)
    goto LABEL_628;
LABEL_75:
  v109 = (a3 >> 3) & 1;
  v114 = a1 + 12;
  if (!v107)
  {
    v16 = 0;
    v22 = v124;
LABEL_200:
    if (v104 + v105 + v103)
    {
      v38 = 0;
      while (1)
      {
        __src[0] = 0;
        v127[0] = 0;
        LODWORD(v122) = 0;
        LOWORD(v121) = 0;
        LOWORD(v120) = 0;
        if (_DNSMessageExtractRecordEx((unint64_t)a1, a2, v114, v22, &v121, &v120, &v122, (unsigned __int16 **)__src, v127, 0, 0, 0, 0, &v114)|| DomainNameToString((unsigned __int8 *)v22, 0, v125, 0))
        {
          goto LABEL_636;
        }
        v39 = (__int16)v120 < 0;
        if ((a3 & 1) != 0)
          LOWORD(v120) = (unsigned __int16)v120 & 0x7FFF;
        v40 = a3 & v39;
        if ((a3 & 4) == 0)
          break;
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
          || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "%s", v5))
        {
          goto LABEL_636;
        }
        if (v16 && DomainNameEqual((unsigned __int8 *)v22, v16))
        {
          v42 = v22;
          v22 = (char *)v16;
        }
        else
        {
          if (DomainNameToString((unsigned __int8 *)v22, 0, v125, 0))
            goto LABEL_636;
          if (v109 && _NameIsPrivate((const char *)v125))
          {
            if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
              dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
            if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
              goto LABEL_636;
            v43 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "%~s ");
          }
          else
          {
            if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
              dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
            if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
              goto LABEL_636;
            v43 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "%s ");
          }
          if (v43)
            goto LABEL_636;
          if (v22 == v124)
            v42 = (char *)v123;
          else
            v42 = v124;
          *v42 = 0;
        }
        if ((unsigned __int16)v121 == 41)
        {
          if (v40)
          {
            if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
              dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
            if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
              || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "CF "))
            {
              goto LABEL_636;
            }
          }
          if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
            dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
          if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
            || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "OPT %u", (unsigned __int16)v120))
          {
            goto LABEL_636;
          }
          if ((_DWORD)v122)
          {
            if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
              dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
            if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
              goto LABEL_636;
            v44 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " 0x%08X");
          }
          else
          {
            if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
              dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
            if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
              goto LABEL_636;
            v44 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " 0");
          }
        }
        else
        {
          if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
            dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
          if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
            || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "%u", (_DWORD)v122))
          {
            goto LABEL_636;
          }
          if (v40)
          {
            if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
              dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
            if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
              || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " CF"))
            {
              goto LABEL_636;
            }
          }
          v45 = "ANY";
          if ((unsigned __int16)v120 != 255)
            v45 = 0;
          if ((unsigned __int16)v120 == 1)
            v46 = "IN";
          else
            v46 = v45;
          if (v46)
          {
            if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
              dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
            if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
              goto LABEL_636;
            v47 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " %s");
          }
          else
          {
            if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
              dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
            if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
              goto LABEL_636;
            v47 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " CLASS%u");
          }
          if (v47)
            goto LABEL_636;
          if (DNSRecordTypeValueToString((unsigned __int16)v121))
          {
            if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
              dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
            if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
              goto LABEL_636;
            v44 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " %s");
          }
          else
          {
            if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
              dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
            if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
              goto LABEL_636;
            v44 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " TYPE%u");
          }
        }
        v5 = ", ";
        if (v44)
          goto LABEL_636;
LABEL_371:
        if ((a3 & 2) == 0)
          DNSRecordDataToStringEx((unsigned __int8 *)__src[0], v127[0], (unsigned __int16)v121, (unint64_t)a1, a2, v109, (uint64_t)&v113);
        if (v113)
        {
          if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
            dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
          if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
            || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " %s", (const char *)v113))
          {
            goto LABEL_636;
          }
          if (v113)
          {
            free(v113);
            v113 = 0;
          }
        }
        else
        {
          if (v109)
          {
            if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
              dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
            if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
              goto LABEL_636;
            v95 = v127[0];
            v56 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " [%zu B]");
          }
          else
          {
            if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
              dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
            if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
              goto LABEL_636;
            v97 = v127[0];
            v99 = v127[0];
            v95 = (unint64_t)__src[0];
            v56 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " %#H");
          }
          if (v56)
            goto LABEL_636;
        }
        if ((a3 & 4) != 0)
        {
          if ((unsigned __int16)v121 == 5)
          {
            DomainName = DNSMessageExtractDomainName((unint64_t)a1, a2, (char *)__src[0], v42, 0);
            v58 = v124;
            if (v42 == v124)
              v58 = (char *)v123;
            if (!DomainName)
            {
              v22 = v42;
              v42 = v58;
            }
            *v42 = 0;
          }
        }
        else
        {
          if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
            dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
          if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
            || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "\n"))
          {
            goto LABEL_636;
          }
        }
        ++v38;
        v16 = (unsigned __int8 *)v22;
        v22 = v42;
        if (v105 + v103 + v104 == v38)
          goto LABEL_403;
      }
      if (!v105 || v38)
      {
        if (v104 && v105 == v38)
        {
          if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
            dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
          if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
            goto LABEL_636;
          v41 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "\nAUTHORITY SECTION\n");
        }
        else
        {
          if (!v103 || v104 + v105 != v38)
          {
LABEL_283:
            if ((unsigned __int16)v121 == 41)
            {
              if (v109 && _NameIsPrivate((const char *)v125))
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                  goto LABEL_636;
                v48 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "%~s");
              }
              else
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                  goto LABEL_636;
                v48 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "%s");
              }
              if (v48)
                goto LABEL_636;
              if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
              if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                goto LABEL_636;
              v50 = "";
              if (v40)
                v50 = " CF";
              if (_GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "%s OPT %u", v50, (unsigned __int16)v120))
                goto LABEL_636;
              if ((_DWORD)v122)
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                  goto LABEL_636;
                v51 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " 0x%08X");
              }
              else
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                  goto LABEL_636;
                v51 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " 0");
              }
            }
            else
            {
              if (v109)
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                  goto LABEL_636;
                v49 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "%~-42s");
              }
              else
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                  goto LABEL_636;
                v49 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "%-42s");
              }
              if (v49)
                goto LABEL_636;
              if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
              if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                goto LABEL_636;
              v52 = "";
              if (v40)
                v52 = "CF";
              if (_GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " %6u %2s", (_DWORD)v122, v52))
                goto LABEL_636;
              v53 = "ANY";
              if ((unsigned __int16)v120 != 255)
                v53 = 0;
              if ((unsigned __int16)v120 == 1)
                v54 = "IN";
              else
                v54 = v53;
              if (v54)
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                  goto LABEL_636;
                v55 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " %s");
              }
              else
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                  goto LABEL_636;
                v55 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " CLASS%u");
              }
              if (v55)
                goto LABEL_636;
              if (DNSRecordTypeValueToString((unsigned __int16)v121))
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                  goto LABEL_636;
                v51 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " %-5s");
              }
              else
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                  goto LABEL_636;
                v51 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " TYPE%u");
              }
            }
            v42 = v22;
            v22 = (char *)v16;
            if (v51)
              goto LABEL_636;
            goto LABEL_371;
          }
          if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
            dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
          if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
            goto LABEL_636;
          v41 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "\nADDITIONAL SECTION\n");
        }
      }
      else
      {
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
          goto LABEL_636;
        v41 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "\nANSWER SECTION\n");
      }
      if (v41)
        goto LABEL_636;
      goto LABEL_283;
    }
LABEL_403:
    if ((_DWORD)v102 == 6)
    {
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "["))
        goto LABEL_636;
      v59 = a1;
      v60 = v114;
      v108 = (unint64_t)&a1[a2];
      if (v114 < &a1[a2])
      {
        if (((a3 >> 2) & 1) != 0)
          v61 = "";
        else
          v61 = "\n\t";
        if (((a3 >> 2) & 1) != 0)
          v62 = ", ";
        else
          v62 = ",\n\t";
        v106 = v62;
        while (v60 >= v59)
        {
          if (v108 - (unint64_t)v60 < 4)
            break;
          v63 = __rev16(*((unsigned __int16 *)v60 + 1));
          v64 = v60 + 4;
          if ((uint64_t)(v108 - (_QWORD)(v60 + 4)) < v63)
            break;
          v65 = *(unsigned __int16 *)v60;
          v66 = (unint64_t)&v64[v63];
          v114 = &v64[v63];
          if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
            dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
          if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
            || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "%s", v61))
          {
            break;
          }
          v67 = __rev16(v65);
          v68 = "Reserved";
          switch((int)v67)
          {
            case 0:
              goto LABEL_437;
            case 1:
              v68 = "KeepAlive";
              goto LABEL_437;
            case 2:
              v68 = "Retry Delay";
              goto LABEL_437;
            case 3:
              v68 = "Encryption Padding";
LABEL_437:
              if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
              if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                goto LABEL_636;
              v95 = (unint64_t)v68;
              v69 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "%s: ");
LABEL_441:
              if (v69)
                goto LABEL_636;
              v121 = 0;
              v122 = (unsigned __int8 *)(v60 + 4);
              bzero(__src, 0x3F1uLL);
              switch((int)v67)
              {
                case '@':
                  v70 = DNSMessageExtractDomainNameString((unint64_t)a1, a2, v60 + 4, (unsigned __int8 *)__src, &v122);
                  if (v70)
                    goto LABEL_566;
                  v71 = v122;
                  if (v66 - (_QWORD)v122 != 4)
                    goto LABEL_619;
                  if (v109 && _NameIsPrivate((const char *)__src))
                  {
                    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                      goto LABEL_619;
                    v95 = (unint64_t)__src;
                    v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "%~s");
                  }
                  else
                  {
                    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                      goto LABEL_619;
                    v95 = (unint64_t)__src;
                    v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "%s");
                  }
                  if (v70)
                    goto LABEL_566;
                  v78 = __rev16(*((unsigned __int16 *)v71 + 1));
                  v79 = "ANY";
                  if ((_DWORD)v78 != 255)
                    v79 = 0;
                  if ((_DWORD)v78 == 1)
                    v80 = "IN";
                  else
                    v80 = v79;
                  if (v80)
                  {
                    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                      goto LABEL_619;
                    v95 = (unint64_t)v80;
                    v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " %s");
                  }
                  else
                  {
                    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                      goto LABEL_619;
                    v95 = v78;
                    v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " CLASS%u");
                  }
                  if (v70)
                    goto LABEL_566;
                  v85 = __rev16(*(unsigned __int16 *)v71);
                  v86 = DNSRecordTypeValueToString(v85);
                  if (v86)
                  {
                    v87 = v86;
                    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                    if (_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                    {
                      v95 = (unint64_t)v87;
                      v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " %s");
                      goto LABEL_612;
                    }
                  }
                  else
                  {
                    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                    if (_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                    {
                      v95 = v85;
                      v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " TYPE%u");
                      goto LABEL_612;
                    }
                  }
                  goto LABEL_619;
                case 'A':
                  if (v66 <= (unint64_t)v64)
                    goto LABEL_636;
                  break;
                case 'B':
                  if ((_DWORD)v63 != 2)
                    goto LABEL_636;
                  v76 = *((unsigned __int16 *)v60 + 2);
                  if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                    dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                  if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                    goto LABEL_619;
                  v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "%u", __rev16(v76));
                  goto LABEL_566;
                case 'C':
                  v70 = DNSMessageExtractDomainNameString((unint64_t)a1, a2, v60 + 4, (unsigned __int8 *)__src, &v122);
                  if (v70)
                    goto LABEL_566;
                  v77 = v122;
                  if (v66 - (unint64_t)v122 < 4)
                    goto LABEL_619;
                  v122 += 4;
                  if (v109 && _NameIsPrivate((const char *)__src))
                  {
                    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                      goto LABEL_619;
                    v95 = (unint64_t)__src;
                    v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "%~s");
                  }
                  else
                  {
                    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                      goto LABEL_619;
                    v95 = (unint64_t)__src;
                    v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "%s");
                  }
                  if (v70)
                    goto LABEL_566;
                  v81 = __rev16(*((unsigned __int16 *)v77 + 1));
                  v82 = "ANY";
                  if ((_DWORD)v81 != 255)
                    v82 = 0;
                  if ((_DWORD)v81 == 1)
                    v83 = "IN";
                  else
                    v83 = v82;
                  if (v83)
                  {
                    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                      goto LABEL_619;
                    v95 = (unint64_t)v83;
                    v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " %s");
                  }
                  else
                  {
                    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                      goto LABEL_619;
                    v95 = v81;
                    v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " CLASS%u");
                  }
                  if (v70)
                    goto LABEL_566;
                  v88 = __rev16(*(unsigned __int16 *)v77);
                  v89 = DNSRecordTypeValueToString(v88);
                  if (v89)
                  {
                    v90 = v89;
                    v91 = a2;
                    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                      goto LABEL_619;
                    v95 = (unint64_t)v90;
                    v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " %s");
                  }
                  else
                  {
                    v91 = a2;
                    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                      goto LABEL_619;
                    v95 = v88;
                    v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " TYPE%u");
                  }
                  if (v70)
                    goto LABEL_566;
                  v92 = v122;
                  v93 = v66 - (_QWORD)v122;
                  DNSRecordDataToStringEx(v122, v66 - (_QWORD)v122, v88, (unint64_t)a1, v91, v109, (uint64_t)&v121);
                  if (v121)
                  {
                    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                      goto LABEL_619;
                    v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " %s", (const char *)v121);
                    if (v70)
                      goto LABEL_566;
                    if (v121)
                    {
                      free(v121);
                      v121 = 0;
                    }
                  }
                  else
                  {
                    if (v109)
                    {
                      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                        goto LABEL_619;
                      v95 = v93;
                      v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " [%zu B]");
                    }
                    else
                    {
                      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                        goto LABEL_619;
                      v97 = v93;
                      v99 = v93;
                      v95 = (unint64_t)v92;
                      v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " '%H'");
                    }
LABEL_612:
                    if (v70)
                      goto LABEL_566;
                  }
                  goto LABEL_613;
                default:
                  if (v109)
                  {
                    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                    if (_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                    {
                      v95 = v63;
                      v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "[%u B]");
                      goto LABEL_566;
                    }
                  }
                  else
                  {
                    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                    if (_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                    {
                      v97 = v63;
                      v99 = v63;
                      v95 = (unint64_t)(v60 + 4);
                      v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "'%H'");
                      goto LABEL_566;
                    }
                  }
                  goto LABEL_619;
              }
              break;
            default:
              switch((int)v67)
              {
                case '@':
                  v68 = "SUBSCRIBE";
                  goto LABEL_437;
                case 'A':
                  v68 = "PUSH";
                  goto LABEL_437;
                case 'B':
                  v68 = "UNSUBSCRIBE";
                  goto LABEL_437;
                case 'C':
                  v68 = "RECONFIRM";
                  goto LABEL_437;
                default:
                  if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                    dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                  if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                    goto LABEL_636;
                  v95 = v67;
                  v69 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "DSO-TYPE%u: ");
                  break;
              }
              goto LABEL_441;
          }
          while (1)
          {
            v119 = 0;
            v120 = 0;
            v117 = 0;
            v118 = 0;
            memset(v127, 0, sizeof(v127));
            v70 = _DNSMessageExtractRecordEx((unint64_t)a1, a2, v64, (char *)v127, (_WORD *)&v117 + 1, &v117, &v118, (unsigned __int16 **)&v120, &v119, 0, 0, 0, 0, &v122);
            if (v70)
            {
LABEL_566:
              v84 = v70;
              goto LABEL_614;
            }
            if ((unint64_t)v122 > v66)
              break;
            v70 = DomainNameToString((unsigned __int8 *)v127, 0, (unsigned __int8 *)__src, 0);
            if (v70)
              goto LABEL_566;
            if (v109 && _NameIsPrivate((const char *)__src))
            {
              if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
              if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                goto LABEL_619;
              v95 = (unint64_t)__src;
              v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "%~s");
            }
            else
            {
              if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
              if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                goto LABEL_619;
              v95 = (unint64_t)__src;
              v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "%s");
            }
            if (v70)
              goto LABEL_566;
            if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
              dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
            if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
            {
LABEL_619:
              v84 = -6735;
              goto LABEL_614;
            }
            v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " 0x%08X", v118);
            if (v70)
              goto LABEL_566;
            v72 = "ANY";
            if ((unsigned __int16)v117 != 255)
              v72 = 0;
            if ((unsigned __int16)v117 == 1)
              v73 = "IN";
            else
              v73 = v72;
            if (v73)
            {
              if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
              if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                goto LABEL_619;
              v95 = (unint64_t)v73;
              v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " %s");
            }
            else
            {
              if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
              if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                goto LABEL_619;
              v95 = (unsigned __int16)v117;
              v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " CLASS%u");
            }
            if (v70)
              goto LABEL_566;
            v74 = DNSRecordTypeValueToString(HIWORD(v117));
            if (v74)
            {
              v75 = v74;
              if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
              if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                goto LABEL_619;
              v95 = (unint64_t)v75;
              v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " %s");
            }
            else
            {
              if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
              if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                goto LABEL_619;
              v95 = HIWORD(v117);
              v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " TYPE%u");
            }
            if (v70)
              goto LABEL_566;
            DNSRecordDataToStringEx(v120, v119, HIWORD(v117), (unint64_t)a1, a2, v109, (uint64_t)&v121);
            if (v121)
            {
              if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
              if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                goto LABEL_619;
              v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " %s", (const char *)v121);
              if (v70)
                goto LABEL_566;
              if (v121)
              {
                free(v121);
                v121 = 0;
              }
            }
            else
            {
              if (v109)
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                  goto LABEL_619;
                v95 = v119;
                v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " [%zu B]");
              }
              else
              {
                if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                  dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                  goto LABEL_619;
                v97 = v119;
                v99 = v119;
                v95 = (unint64_t)v120;
                v70 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " %#H");
              }
              if (v70)
                goto LABEL_566;
            }
            v64 = (char *)v122;
            if ((unint64_t)v122 >= v66)
            {
LABEL_613:
              v84 = 0;
              goto LABEL_614;
            }
          }
          v84 = -6750;
LABEL_614:
          if (v121)
            free(v121);
          if (v84)
            break;
          v60 = v114;
          v61 = v106;
          v59 = a1;
          if ((unint64_t)v114 >= v108)
            goto LABEL_621;
        }
        goto LABEL_636;
      }
LABEL_621:
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
        goto LABEL_636;
      if (((a3 >> 2) & 1) != 0
         ? _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "]", v95, v97, v99, v100)
         : _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "\n]", v95, v97, v99, v100))
      {
        goto LABEL_636;
      }
    }
LABEL_628:
    if (_GetCUSymAddr_DataBuffer_Append_sOnce != -1)
      dispatch_once(&_GetCUSymAddr_DataBuffer_Append_sOnce, &__block_literal_global_223);
    if (_GetCUSymAddr_DataBuffer_Append_sAddr && !_GetCUSymAddr_DataBuffer_Append_sAddr(v115, "", 1))
    {
      if (_GetCUSymAddr_DataBuffer_Detach_sOnce != -1)
        dispatch_once(&_GetCUSymAddr_DataBuffer_Detach_sOnce, &__block_literal_global_226);
      if (_GetCUSymAddr_DataBuffer_Detach_sAddr)
        _GetCUSymAddr_DataBuffer_Detach_sAddr(v115, a4, &v112);
    }
    goto LABEL_636;
  }
  v16 = 0;
  v17 = 0;
  v18 = v124;
  while (1)
  {
    LOWORD(__src[0]) = 0;
    LOWORD(v127[0]) = 0;
    if (DNSMessageExtractQuestion((unint64_t)a1, a2, v114, v18, __src, v127, &v114))
      break;
    v19 = SLOWORD(v127[0]) < 0;
    if ((a3 & 1) != 0)
      LOWORD(v127[0]) &= ~0x8000u;
    v20 = a3 & v19;
    if ((a3 & 4) != 0)
    {
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
        || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "%s", v5))
      {
        break;
      }
      if (v16 && DomainNameEqual((unsigned __int8 *)v18, v16))
      {
        v22 = v18;
        v18 = (char *)v16;
      }
      else
      {
        if (DomainNameToString((unsigned __int8 *)v18, 0, v125, 0))
          break;
        if (v109 && _NameIsPrivate((const char *)v125))
        {
          if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
            dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
          if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
            break;
          v27 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "%~s ");
        }
        else
        {
          if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
            dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
          if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
            break;
          v27 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "%s ");
        }
        if (v27)
          break;
        if (v18 == v124)
          v22 = (char *)v123;
        else
          v22 = v124;
        *v22 = 0;
      }
      v28 = "ANY";
      if (LOWORD(v127[0]) != 255)
        v28 = 0;
      if (LOWORD(v127[0]) == 1)
        v29 = "IN";
      else
        v29 = v28;
      if (v29)
      {
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
          break;
        v30 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "%s");
      }
      else
      {
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
          break;
        v30 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "CLASS%u");
      }
      if (v30)
        break;
      if ((a3 & 1) != 0)
      {
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
          break;
        v31 = "QM";
        if (v20)
          v31 = "QU";
        if (_GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " %s", v31))
          break;
      }
      v32 = DNSRecordTypeValueToString(LOWORD(__src[0]));
      if (v32)
      {
        v33 = v32;
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
          break;
        v95 = (unint64_t)v33;
        v34 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " %s?");
      }
      else
      {
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
          break;
        v95 = LOWORD(__src[0]);
        v34 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " TYPE%u?");
      }
      v5 = ", ";
      if (v34)
        break;
    }
    else
    {
      if (!v17)
      {
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr
          || _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "\nQUESTION SECTION\n"))
        {
          break;
        }
      }
      if (DomainNameToString((unsigned __int8 *)v18, 0, v125, 0))
        break;
      if (v109 && _NameIsPrivate((const char *)v125))
      {
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
          break;
        v21 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "%~-30s");
      }
      else
      {
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
          break;
        v21 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, "%-30s");
      }
      if (v21)
        break;
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
        break;
      v23 = "QM";
      if (v20)
        v23 = "QU";
      if ((a3 & 1) == 0)
        v23 = "";
      if (_GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " %2s", v23))
        break;
      v24 = "ANY";
      if (LOWORD(v127[0]) != 255)
        v24 = 0;
      if (LOWORD(v127[0]) == 1)
        v25 = "IN";
      else
        v25 = v24;
      if (v25)
      {
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
          break;
        v26 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " %s");
      }
      else
      {
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
          break;
        v26 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " CLASS%u");
      }
      if (v26)
        break;
      v35 = DNSRecordTypeValueToString(LOWORD(__src[0]));
      if (v35)
      {
        v36 = v35;
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
          break;
        v95 = (unint64_t)v36;
        v37 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " %-5s\n");
      }
      else
      {
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
          break;
        v95 = LOWORD(__src[0]);
        v37 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v115, " TYPE%u\n");
      }
      v22 = v18;
      v18 = (char *)v16;
      if (v37)
        break;
    }
    v16 = (unsigned __int8 *)v18;
    ++v17;
    v18 = v22;
    if (v107 == v17)
      goto LABEL_200;
  }
LABEL_636:
  if (v113)
    free(v113);
  if (_GetCUSymAddr_DataBuffer_Free_sOnce != -1)
    dispatch_once(&_GetCUSymAddr_DataBuffer_Free_sOnce, &__block_literal_global_229);
  if (_GetCUSymAddr_DataBuffer_Free_sAddr)
    _GetCUSymAddr_DataBuffer_Free_sAddr(v115);
}

uint64_t _NameIsPrivate(const char *a1)
{
  uint64_t result;

  result = strcasecmp(a1, ".");
  if ((_DWORD)result)
    return strcasecmp(a1, "ipv4only.arpa.") != 0;
  return result;
}

uint64_t DNSRecordDataToStringEx(unsigned __int8 *a1, unint64_t a2, int a3, unint64_t a4, uint64_t a5, int a6, uint64_t a7)
{
  unint64_t v14;
  uint64_t appended;
  uint64_t v16;
  unint64_t v17;
  unsigned __int8 *v18;
  unsigned __int8 *v19;
  unint64_t v20;
  unsigned __int8 *v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned __int8 v31;
  char v32;
  uint64_t v33;
  unsigned int v34;
  char *v35;
  unsigned int v36;
  unsigned int *v37;
  const char *v38;
  unsigned int v39;
  const char *v40;
  const char *v41;
  const char *v42;
  unsigned int *v43;
  unsigned int *v44;
  const char *v45;
  char v46;
  const char *v47;
  const char *v48;
  unsigned int *v49;
  const char *v50;
  char v51;
  unint64_t v52;
  unsigned int *i;
  const char *v54;
  unsigned int v55;
  unsigned int *v56;
  const char *v57;
  uint64_t CUSymAddr_DataBuffer_AppendF_sAddr;
  unsigned int *v59;
  const char *v60;
  unsigned int *v61;
  const char *v62;
  unsigned int *v64;
  const char *v65;
  const char *v67;
  uint64_t v68;
  int v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  _OWORD v73[3];
  uint64_t v74;
  unsigned __int8 *v75;
  unsigned int *v76;
  unsigned __int8 v77[1009];
  _BYTE v78[256];
  void *v79[127];

  if (_GetCUSymAddr_DataBuffer_Init_sOnce != -1)
    dispatch_once(&_GetCUSymAddr_DataBuffer_Init_sOnce, &__block_literal_global_5576);
  v74 = 0;
  v75 = 0;
  memset(v73, 0, sizeof(v73));
  v72 = 0;
  memset(v78, 0, sizeof(v78));
  bzero(v77, 0x3F1uLL);
  if (!_GetCUSymAddr_DataBuffer_Init_sAddr)
    goto LABEL_349;
  v14 = (unint64_t)&a1[a2];
  _GetCUSymAddr_DataBuffer_Init_sAddr(v73, v78, 256, -1);
  if (a3 <= 27)
  {
    switch(a3)
    {
      case 1:
        if (a2 != 4)
          goto LABEL_350;
        appended = _AppendIPv4Address((uint64_t)v73, 0, (unsigned int *)a1, a6);
        if ((_DWORD)appended)
          goto LABEL_341;
        goto LABEL_333;
      case 2:
      case 5:
      case 12:
        if (a4)
        {
          appended = DNSMessageExtractDomainNameString(a4, a5, (char *)a1, v77, 0);
          if (!(_DWORD)appended)
            goto LABEL_331;
        }
        else
        {
          appended = DomainNameToString(a1, (unint64_t)&a1[a2], v77, 0);
          if (!(_DWORD)appended)
            goto LABEL_331;
        }
        goto LABEL_341;
      case 6:
        if (a4)
        {
          appended = DNSMessageExtractDomainNameString(a4, a5, (char *)a1, v77, &v75);
          if ((_DWORD)appended)
            goto LABEL_341;
          if ((unint64_t)v75 >= v14)
            goto LABEL_350;
          appended = _AppendDomainNameStringEx((uint64_t)v73, 0, a6, (const char *)v77);
          if ((_DWORD)appended)
            goto LABEL_341;
          appended = DNSMessageExtractDomainNameString(a4, a5, (char *)v75, v77, &v75);
          if ((_DWORD)appended)
            goto LABEL_341;
        }
        else
        {
          appended = DomainNameToString(a1, (unint64_t)&a1[a2], v77, &v75);
          if ((_DWORD)appended)
            goto LABEL_341;
          appended = _AppendDomainNameStringEx((uint64_t)v73, 0, a6, (const char *)v77);
          if ((_DWORD)appended)
            goto LABEL_341;
          appended = DomainNameToString(v75, (unint64_t)&a1[a2], v77, &v75);
          if ((_DWORD)appended)
            goto LABEL_341;
        }
        appended = _AppendDomainNameStringEx((uint64_t)v73, " ", a6, (const char *)v77);
        if ((_DWORD)appended)
          goto LABEL_341;
        v64 = (unsigned int *)v75;
        if (v14 - (_QWORD)v75 != 20)
          goto LABEL_350;
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
          goto LABEL_349;
        CUSymAddr_DataBuffer_AppendF_sAddr = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v73, " %u %u %u %u %u", bswap32(*v64), bswap32(v64[1]), bswap32(v64[2]), bswap32(v64[3]), bswap32(v64[4]));
        if ((_DWORD)CUSymAddr_DataBuffer_AppendF_sAddr)
          goto LABEL_342;
        goto LABEL_333;
      case 13:
      case 16:
        if (!a2)
          goto LABEL_350;
        if (a6)
        {
          if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
            dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
          if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
            goto LABEL_349;
          appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v73, "[%zu B]");
        }
        else if (a2 == 1)
        {
          if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
            dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
          if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
            goto LABEL_349;
          appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v73, "%#H");
        }
        else
        {
          if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
            dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
          if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
            goto LABEL_349;
          appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v73, "%#{txt}");
        }
        if (!(_DWORD)appended)
          goto LABEL_333;
        goto LABEL_341;
      case 15:
        if ((uint64_t)a2 < 3)
          goto LABEL_350;
        v36 = *(unsigned __int16 *)a1;
        v35 = (char *)(a1 + 2);
        v34 = v36;
        if (a4)
        {
          appended = DNSMessageExtractDomainNameString(a4, a5, v35, v77, 0);
          if ((_DWORD)appended)
            goto LABEL_341;
        }
        else
        {
          appended = DomainNameToString((unsigned __int8 *)v35, v14, v77, 0);
          if ((_DWORD)appended)
            goto LABEL_341;
        }
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
          goto LABEL_349;
        appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v73, "%u", __rev16(v34));
        if ((_DWORD)appended)
          goto LABEL_341;
        v65 = " ";
        break;
      default:
        goto LABEL_115;
    }
LABEL_332:
    appended = _AppendDomainNameStringEx((uint64_t)v73, v65, a6, (const char *)v77);
    if ((_DWORD)appended)
      goto LABEL_341;
LABEL_333:
    if (_GetCUSymAddr_DataBuffer_Append_sOnce != -1)
      dispatch_once(&_GetCUSymAddr_DataBuffer_Append_sOnce, &__block_literal_global_223);
    if (_GetCUSymAddr_DataBuffer_Append_sAddr)
    {
      appended = _GetCUSymAddr_DataBuffer_Append_sAddr(v73, "", 1);
      if (!(_DWORD)appended)
      {
        if (_GetCUSymAddr_DataBuffer_Detach_sOnce != -1)
          dispatch_once(&_GetCUSymAddr_DataBuffer_Detach_sOnce, &__block_literal_global_226);
        if (_GetCUSymAddr_DataBuffer_Detach_sAddr)
        {
          appended = _GetCUSymAddr_DataBuffer_Detach_sAddr(v73, a7, &v72);
          goto LABEL_341;
        }
        goto LABEL_349;
      }
LABEL_341:
      CUSymAddr_DataBuffer_AppendF_sAddr = appended;
      goto LABEL_342;
    }
LABEL_349:
    CUSymAddr_DataBuffer_AppendF_sAddr = 4294960561;
    goto LABEL_342;
  }
  switch(a3)
  {
    case '+':
      if (a2 < 4)
        goto LABEL_350;
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
        goto LABEL_349;
      appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v73, "%u %u %u", __rev16(*(unsigned __int16 *)a1), a1[2], a1[3]);
      if ((_DWORD)appended)
        goto LABEL_341;
      if (a2 == 4)
        goto LABEL_333;
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
        goto LABEL_349;
      appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v73, " %.4H", a1 + 4, a2 - 4, a2 - 4);
      if ((_DWORD)appended)
        goto LABEL_341;
      goto LABEL_333;
    case ',':
    case '-':
    case '1':
      goto LABEL_115;
    case '.':
      LODWORD(v76) = 0;
      v70 = 0;
      v71 = 0;
      v69 = 0;
      if (a2 < 0x13)
        goto LABEL_350;
      if (DNSRecordTypeValueToString(__rev16(*(unsigned __int16 *)a1)))
      {
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
          goto LABEL_349;
        appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v73, "%s");
      }
      else
      {
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
          goto LABEL_349;
        appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v73, "TYPE%u");
      }
      if ((_DWORD)appended)
        goto LABEL_341;
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
        goto LABEL_349;
      appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v73, " %u %u %u", a1[2], a1[3], bswap32(*((_DWORD *)a1 + 1)));
      if ((_DWORD)appended)
        goto LABEL_341;
      LODWORD(v76) = 0;
      v70 = 0;
      v71 = 0;
      v69 = 0;
      if (_GetCUSymAddr_SecondsToYMD_HMS_sOnce != -1)
        dispatch_once(&_GetCUSymAddr_SecondsToYMD_HMS_sOnce, &__block_literal_global_241);
      if (!_GetCUSymAddr_SecondsToYMD_HMS_sAddr)
        goto LABEL_349;
      _GetCUSymAddr_SecondsToYMD_HMS_sAddr(bswap32(*((_DWORD *)a1 + 2)) + 0xE77934880, &v76, (char *)&v71 + 4, &v71, (char *)&v70 + 4, &v70, &v69);
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
        goto LABEL_349;
      appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v73, " %u%02u%02u%02u%02u%02u", (_DWORD)v76, HIDWORD(v71), v71, HIDWORD(v70), v70, v69);
      if ((_DWORD)appended)
        goto LABEL_341;
      if (_GetCUSymAddr_SecondsToYMD_HMS_sOnce != -1)
        dispatch_once(&_GetCUSymAddr_SecondsToYMD_HMS_sOnce, &__block_literal_global_241);
      if (!_GetCUSymAddr_SecondsToYMD_HMS_sAddr)
        goto LABEL_349;
      _GetCUSymAddr_SecondsToYMD_HMS_sAddr(bswap32(*((_DWORD *)a1 + 3)) + 0xE77934880, &v76, (char *)&v71 + 4, &v71, (char *)&v70 + 4, &v70, &v69);
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
        goto LABEL_349;
      appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v73, " %u%02u%02u%02u%02u%02u", (_DWORD)v76, HIDWORD(v71), v71, HIDWORD(v70), v70, v69);
      if ((_DWORD)appended)
        goto LABEL_341;
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
        goto LABEL_349;
      appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v73, " %u", __rev16(*((unsigned __int16 *)a1 + 8)));
      if ((_DWORD)appended)
        goto LABEL_341;
      v75 = a1 + 18;
      appended = DomainNameToString(a1 + 18, v14, v77, &v75);
      if ((_DWORD)appended)
        goto LABEL_341;
      appended = _AppendDomainNameStringEx((uint64_t)v73, " ", a6, (const char *)v77);
      if ((_DWORD)appended)
        goto LABEL_341;
      v79[0] = 0;
      if (_GetCUSymAddr_Base64EncodeCopyEx_sOnce != -1)
        dispatch_once(&_GetCUSymAddr_Base64EncodeCopyEx_sOnce, &__block_literal_global_238);
      if (!_GetCUSymAddr_Base64EncodeCopyEx_sAddr)
        goto LABEL_349;
      appended = _GetCUSymAddr_Base64EncodeCopyEx_sAddr(v75, v14 - (_QWORD)v75, 0, v79, 0);
      if ((_DWORD)appended)
        goto LABEL_341;
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
      if (_GetCUSymAddr_DataBuffer_AppendF_sAddr)
      {
        v16 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v73, " %s", (const char *)v79[0]);
LABEL_299:
        CUSymAddr_DataBuffer_AppendF_sAddr = v16;
      }
      else
      {
LABEL_352:
        CUSymAddr_DataBuffer_AppendF_sAddr = 4294960561;
      }
      if (v79[0])
        free(v79[0]);
      if ((_DWORD)CUSymAddr_DataBuffer_AppendF_sAddr)
        goto LABEL_342;
      goto LABEL_333;
    case '/':
      if (a4)
      {
        appended = DNSMessageExtractDomainNameString(a4, a5, (char *)a1, v77, &v75);
        if ((_DWORD)appended)
          goto LABEL_341;
      }
      else
      {
        appended = DomainNameToString(a1, (unint64_t)&a1[a2], v77, &v75);
        if ((_DWORD)appended)
          goto LABEL_341;
      }
      if ((unint64_t)v75 >= v14)
        goto LABEL_350;
      appended = _AppendDomainNameStringEx((uint64_t)v73, 0, a6, (const char *)v77);
      if ((_DWORD)appended)
        goto LABEL_341;
      appended = _DNSRecordDataAppendTypeBitMap((uint64_t)v73, v75, (uint64_t)&a1[a2]);
      if ((_DWORD)appended)
        goto LABEL_341;
      goto LABEL_333;
    case '0':
      if (a2 < 5)
        goto LABEL_350;
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
        goto LABEL_349;
      appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v73, "%u %u %u", __rev16(*(unsigned __int16 *)a1), a1[2], a1[3]);
      if ((_DWORD)appended)
        goto LABEL_341;
      v75 = a1 + 4;
      v79[0] = 0;
      if (_GetCUSymAddr_Base64EncodeCopyEx_sOnce != -1)
        dispatch_once(&_GetCUSymAddr_Base64EncodeCopyEx_sOnce, &__block_literal_global_238);
      if (!_GetCUSymAddr_Base64EncodeCopyEx_sAddr)
        goto LABEL_349;
      appended = _GetCUSymAddr_Base64EncodeCopyEx_sAddr(v75, v14 - (_QWORD)v75, 0, v79, 0);
      if ((_DWORD)appended)
        goto LABEL_341;
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
        goto LABEL_352;
      v16 = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v73, " %s", (const char *)v79[0]);
      goto LABEL_299;
    case '2':
      if (a2 < 5)
        goto LABEL_350;
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
        goto LABEL_349;
      appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v73, "%u %u %u", *a1, a1[1], __rev16(*((unsigned __int16 *)a1 + 1)));
      if ((_DWORD)appended)
        goto LABEL_341;
      v75 = a1 + 4;
      if ((uint64_t)(a2 - 4) < 1)
        goto LABEL_350;
      v75 = a1 + 5;
      v17 = a1[4];
      if (a2 - 5 < v17)
        goto LABEL_350;
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
        goto LABEL_349;
      appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v73, " %.4H", v75, v17, v17);
      if ((_DWORD)appended)
        goto LABEL_341;
      v18 = &v75[v17];
      v75 = v18;
      if ((uint64_t)(v14 - (_QWORD)v18) < 1)
        goto LABEL_350;
      v19 = v18 + 1;
      v75 = v18 + 1;
      v20 = *v18;
      if (v14 - (unint64_t)(v18 + 1) < v20)
        goto LABEL_350;
      if (!*v18)
        goto LABEL_76;
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
        goto LABEL_349;
      appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v73, " ");
      if ((_DWORD)appended)
        goto LABEL_341;
      v19 = v75;
LABEL_76:
      v21 = &v19[v20];
      while (2)
      {
        v22 = v21 - v75;
        if (v21 != v75)
        {
          v79[0] = 0;
          v23 = 0;
          switch(v22)
          {
            case 1uLL:
              v24 = 0;
              v25 = (unint64_t)*v75++ << 32;
              goto LABEL_94;
            case 2uLL:
              v30 = 0;
              v28 = (unint64_t)v75[1] << 24;
              v25 = v28 | ((unint64_t)*v75 << 32);
              v75 += 2;
              goto LABEL_91;
            case 3uLL:
              v31 = v75[2];
              v28 = ((unint64_t)v31 << 16) | ((unint64_t)v75[1] << 24);
              v25 = v28 | ((unint64_t)*v75 << 32);
              v75 += 3;
              BYTE4(v79[0]) = DNSRecordDataToStringEx_kBase32ExtendedHex[2 * (v31 & 0xF)];
              v30 = 5;
              goto LABEL_91;
            case 4uLL:
              goto LABEL_81;
            default:
              v23 = v75[4];
LABEL_81:
              v26 = v75[3];
              v27 = v23 | (v26 << 8);
              v28 = ((unint64_t)v75[1] << 24) | ((unint64_t)v75[2] << 16) | v27;
              v25 = v28 | ((unint64_t)*v75 << 32);
              v29 = 5;
              if (v22 < 5)
                v29 = v21 - v75;
              v75 += v29;
              if (v22 == 1)
              {
                v24 = 0;
              }
              else
              {
                if (v22 == 4)
                {
                  v30 = 7;
                }
                else
                {
                  HIBYTE(v79[0]) = DNSRecordDataToStringEx_kBase32ExtendedHex[v23 & 0x1F];
                  v30 = 8;
                }
                v32 = DNSRecordDataToStringEx_kBase32ExtendedHex[(v26 >> 2) & 0x1F];
                BYTE6(v79[0]) = DNSRecordDataToStringEx_kBase32ExtendedHex[(v27 >> 5) & 0x1F];
                BYTE5(v79[0]) = v32;
                BYTE4(v79[0]) = DNSRecordDataToStringEx_kBase32ExtendedHex[(v28 >> 15) & 0x1F];
LABEL_91:
                BYTE3(v79[0]) = DNSRecordDataToStringEx_kBase32ExtendedHex[(v28 >> 20) & 0x1F];
                BYTE2(v79[0]) = DNSRecordDataToStringEx_kBase32ExtendedHex[(v28 >> 25) & 0x1F];
                if (v30)
                  v24 = v30;
                else
                  v24 = 4;
              }
LABEL_94:
              BYTE1(v79[0]) = DNSRecordDataToStringEx_kBase32ExtendedHex[(v25 >> 30) & 0x1F];
              LOBYTE(v79[0]) = DNSRecordDataToStringEx_kBase32ExtendedHex[v25 >> 35];
              if (_GetCUSymAddr_DataBuffer_Append_sOnce != -1)
                dispatch_once(&_GetCUSymAddr_DataBuffer_Append_sOnce, &__block_literal_global_223);
              if (!_GetCUSymAddr_DataBuffer_Append_sAddr)
                goto LABEL_349;
              if (v24)
                v33 = v24;
              else
                v33 = 2;
              appended = _GetCUSymAddr_DataBuffer_Append_sAddr(v73, v79, v33);
              if ((_DWORD)appended)
                goto LABEL_341;
              continue;
          }
        }
        break;
      }
      appended = _DNSRecordDataAppendTypeBitMap((uint64_t)v73, v21, v14);
      if ((_DWORD)appended)
        goto LABEL_341;
      goto LABEL_333;
    default:
      if (a3 == 28)
      {
        if (a2 == 16)
        {
          appended = _AppendIPv6Address((uint64_t)v73, 0, (uint64_t)a1, a6);
          if (!(_DWORD)appended)
            goto LABEL_333;
          goto LABEL_341;
        }
        goto LABEL_350;
      }
      if (a3 == 33)
      {
        if (a2 >= 7)
        {
          if (a4)
          {
            appended = DNSMessageExtractDomainNameString(a4, a5, (char *)a1 + 6, v77, 0);
            if ((_DWORD)appended)
              goto LABEL_341;
          }
          else
          {
            appended = DomainNameToString(a1 + 6, (unint64_t)&a1[a2], v77, 0);
            if ((_DWORD)appended)
              goto LABEL_341;
          }
          if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
            dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
          if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
            goto LABEL_349;
          appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v73, "%u %u %u ", __rev16(*(unsigned __int16 *)a1), __rev16(*((unsigned __int16 *)a1 + 1)), __rev16(*((unsigned __int16 *)a1 + 2)));
          if ((_DWORD)appended)
            goto LABEL_341;
LABEL_331:
          v65 = 0;
          goto LABEL_332;
        }
LABEL_350:
        CUSymAddr_DataBuffer_AppendF_sAddr = 4294960554;
        goto LABEL_342;
      }
LABEL_115:
      if ((a3 & 0xFFFFFFFE) != 0x40)
      {
        if (a3 != 41)
        {
          CUSymAddr_DataBuffer_AppendF_sAddr = 4294960582;
          goto LABEL_342;
        }
        appended = _AppendOPTRDataString((uint64_t)v73, (unsigned __int16 *)a1, (unint64_t)&a1[a2], a6);
        if (!(_DWORD)appended)
          goto LABEL_333;
        goto LABEL_341;
      }
      if (v14 < (unint64_t)a1)
      {
        CUSymAddr_DataBuffer_AppendF_sAddr = 4294960586;
      }
      else
      {
        if (a2 < 2)
          goto LABEL_350;
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
          goto LABEL_349;
        appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v73, "%u", __rev16(*(unsigned __int16 *)a1));
        if ((_DWORD)appended)
          goto LABEL_341;
        bzero(v79, 0x3F1uLL);
        v76 = (unsigned int *)(a1 + 2);
        appended = DomainNameToString(a1 + 2, (unint64_t)&a1[a2], (unsigned __int8 *)v79, &v76);
        if ((_DWORD)appended)
          goto LABEL_341;
        v68 = a7;
        appended = _AppendDomainNameStringEx((uint64_t)v73, " ", a6, (const char *)v79);
        if ((_DWORD)appended)
          goto LABEL_341;
        v37 = v76;
        if ((unint64_t)v76 >= v14)
        {
LABEL_347:
          a7 = v68;
          goto LABEL_333;
        }
        while (2)
        {
          if (v14 - (unint64_t)v37 >= 4)
          {
            v38 = (const char *)__rev16(*(unsigned __int16 *)v37);
            v39 = *((unsigned __int16 *)v37 + 1);
            v40 = _DNSSVCBKeyToString((int)v38);
            if (v40)
            {
              v41 = v40;
              if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
              if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                goto LABEL_349;
              v67 = v41;
              appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v73, " %s=\"");
            }
            else
            {
              if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
              if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                goto LABEL_349;
              v67 = v38;
              appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v73, " key%u=\"");
            }
            if ((_DWORD)appended)
              goto LABEL_341;
            v42 = (const char *)__rev16(v39);
            v43 = v37 + 1;
            v76 = v37 + 1;
            if (v14 - (unint64_t)(v37 + 1) >= v42)
            {
              switch((int)v38)
              {
                case 0:
                  if ((v42 & 1) != 0)
                    goto LABEL_350;
                  v44 = (unsigned int *)&v42[(_QWORD)v43];
                  if ((const char *)v43 >= &v42[(_QWORD)v43])
                    goto LABEL_238;
                  v45 = 0;
                  v46 = 1;
                  do
                  {
                    v47 = (const char *)__rev16(*(unsigned __int16 *)v43);
                    v76 = (unsigned int *)((char *)v43 + 2);
                    v48 = _DNSSVCBKeyToString((int)v47);
                    if ((v46 & 1) == 0)
                    {
                      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                        goto LABEL_349;
                      appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v73, "%s", v45);
                      if ((_DWORD)appended)
                        goto LABEL_341;
                    }
                    if (v48)
                    {
                      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                        goto LABEL_349;
                      v67 = v48;
                      appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v73, "%s");
                    }
                    else
                    {
                      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                        goto LABEL_349;
                      v67 = v47;
                      appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v73, "key%u");
                    }
                    if ((_DWORD)appended)
                      goto LABEL_341;
                    v46 = 0;
                    v43 = v76;
                    v45 = ",";
                  }
                  while (v76 < v44);
                  goto LABEL_238;
                case 1:
                  v49 = (unsigned int *)&v42[(_QWORD)v43];
                  if (v43 >= v49)
                    goto LABEL_238;
                  v50 = 0;
                  v51 = 1;
                  while (1)
                  {
                    v76 = (unsigned int *)((char *)v43 + 1);
                    v52 = *(unsigned __int8 *)v43;
                    if ((char *)v49 - ((char *)v43 + 1) < v52)
                      goto LABEL_350;
                    v43 = (unsigned int *)((char *)v43 + 1);
                    if ((v51 & 1) == 0)
                    {
                      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                        goto LABEL_349;
                      appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v73, "%s", v50);
                      if ((_DWORD)appended)
                        goto LABEL_341;
                      v43 = v76;
                    }
                    for (i = (unsigned int *)((char *)v43 + v52); v43 < i; v76 = v43)
                    {
                      v54 = (const char *)*(unsigned __int8 *)v43;
                      if (((_DWORD)v54 - 32) > 0x5E)
                      {
                        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                          goto LABEL_349;
                        v67 = v54;
                        appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v73, "\\%03d");
                      }
                      else if ((_DWORD)v54 == 92 || (_DWORD)v54 == 44)
                      {
                        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                          goto LABEL_349;
                        v67 = v54;
                        appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v73, "\\%c");
                      }
                      else
                      {
                        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                          goto LABEL_349;
                        v67 = v54;
                        appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v73, "%c");
                      }
                      if ((_DWORD)appended)
                        goto LABEL_341;
                      v43 = (unsigned int *)((char *)v76 + 1);
                    }
                    v51 = 0;
                    v50 = ",";
                    if (v43 >= v49)
                      goto LABEL_238;
                  }
                case 2:
                  goto LABEL_163;
                case 3:
                  if ((_DWORD)v42 != 2)
                    goto LABEL_350;
                  v55 = *((unsigned __int16 *)v37 + 2);
                  v76 = (unsigned int *)&v42[(_QWORD)v43];
                  if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                    dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                  if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                    goto LABEL_349;
                  appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v73, "%u", __rev16(v55));
                  if ((_DWORD)appended)
                    goto LABEL_341;
                  goto LABEL_238;
                case 4:
                  if ((v42 & 3) != 0)
                    goto LABEL_350;
                  v56 = (unsigned int *)&v42[(_QWORD)v43];
                  if (v43 >= v56)
                    goto LABEL_238;
                  v57 = "";
                  while (2)
                  {
                    CUSymAddr_DataBuffer_AppendF_sAddr = _AppendIPv4Address((uint64_t)v73, (uint64_t)v57, v43, a6);
                    if ((_DWORD)CUSymAddr_DataBuffer_AppendF_sAddr)
                      goto LABEL_342;
                    v43 = v76 + 1;
                    v76 = v43;
                    if (v43 < v56)
                    {
                      v57 = ",";
                      continue;
                    }
                    goto LABEL_238;
                  }
                case 5:
                  goto LABEL_159;
                case 6:
                  if ((v42 & 0xF) != 0)
                    goto LABEL_350;
                  v59 = (unsigned int *)&v42[(_QWORD)v43];
                  if (v43 >= v59)
                    goto LABEL_238;
                  v60 = "";
                  while (2)
                  {
                    CUSymAddr_DataBuffer_AppendF_sAddr = _AppendIPv6Address((uint64_t)v73, (uint64_t)v60, (uint64_t)v43, a6);
                    if ((_DWORD)CUSymAddr_DataBuffer_AppendF_sAddr)
                      goto LABEL_342;
                    v43 = v76 + 4;
                    v76 = v43;
                    if (v43 < v59)
                    {
                      v60 = ",";
                      continue;
                    }
                    goto LABEL_238;
                  }
                default:
                  if ((_DWORD)v38 == 32769)
                  {
LABEL_159:
                    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                      goto LABEL_349;
                    v67 = (const char *)v76;
                    appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v73, "%.4H");
                  }
                  else
                  {
LABEL_163:
                    if (!a6)
                    {
                      v61 = (unsigned int *)&v42[(_QWORD)v43];
                      while (v43 < v61)
                      {
                        v62 = (const char *)*(unsigned __int8 *)v43;
                        if (((_DWORD)v62 - 33) > 0x5D)
                        {
                          if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                            dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                          if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                            goto LABEL_349;
                          v67 = v62;
                          appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v73, "\\%03d");
                        }
                        else if (((_DWORD)v62 - 34) > 0x3A
                               || ((1 << (v62 - 34)) & 0x4000000020000C1) == 0)
                        {
                          if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                            dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                          if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                            goto LABEL_349;
                          v67 = v62;
                          appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v73, "%c");
                        }
                        else
                        {
                          if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                            dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                          if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                            goto LABEL_349;
                          v67 = v62;
                          appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v73, "\\%c");
                        }
                        if ((_DWORD)appended)
                          goto LABEL_341;
                        v43 = (unsigned int *)((char *)v76 + 1);
                        v76 = (unsigned int *)((char *)v76 + 1);
                      }
                      goto LABEL_238;
                    }
                    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                      goto LABEL_349;
                    v67 = v42;
                    appended = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v73, "<%u redacted bytes>");
                  }
                  if ((_DWORD)appended)
                    goto LABEL_341;
                  v76 = (unsigned int *)&v42[(_QWORD)v76];
LABEL_238:
                  if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
                    dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
                  if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
                    goto LABEL_349;
                  CUSymAddr_DataBuffer_AppendF_sAddr = _GetCUSymAddr_DataBuffer_AppendF_sAddr(v73, "\"", v67);
                  if ((_DWORD)CUSymAddr_DataBuffer_AppendF_sAddr)
                    goto LABEL_342;
                  v37 = v76;
                  if ((unint64_t)v76 >= v14)
                    goto LABEL_347;
                  continue;
              }
            }
          }
          break;
        }
        CUSymAddr_DataBuffer_AppendF_sAddr = 4294960546;
      }
LABEL_342:
      if (_GetCUSymAddr_DataBuffer_Free_sOnce != -1)
        dispatch_once(&_GetCUSymAddr_DataBuffer_Free_sOnce, &__block_literal_global_229);
      if (_GetCUSymAddr_DataBuffer_Free_sAddr)
        _GetCUSymAddr_DataBuffer_Free_sAddr(v73);
      return CUSymAddr_DataBuffer_AppendF_sAddr;
  }
}

uint64_t _AppendIPv4Address(uint64_t a1, uint64_t a2, unsigned int *a3, int a4)
{
  unsigned int v4;
  BOOL v5;
  int v6;

  if (a4)
  {
    v4 = bswap32(*a3);
    if (v4)
      v5 = v4 == 2130706433;
    else
      v5 = 1;
    v6 = !v5;
  }
  else
  {
    v6 = 0;
  }
  return _AppendIPAddress(a1, a2, (uint64_t)a3, 4, v6);
}

uint64_t _AppendIPv6Address(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  BOOL v4;
  int v5;

  if (a4)
  {
    if (*(_QWORD *)a3 | *(_QWORD *)(a3 + 7))
      v4 = 1;
    else
      v4 = *(unsigned __int8 *)(a3 + 15) > 1u;
    v5 = v4;
  }
  else
  {
    v5 = 0;
  }
  return _AppendIPAddress(a1, a2, a3, 16, v5);
}

uint64_t _AppendDomainNameStringEx(uint64_t a1, const char *a2, int a3, const char *a4)
{
  const char *v6;

  if (a2)
    v6 = a2;
  else
    v6 = "";
  if (a3 && _NameIsPrivate(a4))
  {
    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
    if (_GetCUSymAddr_DataBuffer_AppendF_sAddr)
      return _GetCUSymAddr_DataBuffer_AppendF_sAddr(a1, "%s%~s", v6, a4);
  }
  else
  {
    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
    if (_GetCUSymAddr_DataBuffer_AppendF_sAddr)
      return _GetCUSymAddr_DataBuffer_AppendF_sAddr(a1, "%s%s");
  }
  return 4294960561;
}

uint64_t _DNSRecordDataAppendTypeBitMap(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v5;
  unsigned __int8 *v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  int v10;
  BOOL v11;
  const char *v12;
  uint64_t result;
  uint64_t v14;
  uint64_t v15;
  char __str[16];
  __int128 v18;

  v3 = a3 - (_QWORD)a2;
  if (a3 - (uint64_t)a2 >= 1)
  {
    while (2)
    {
      if ((unint64_t)v3 < 3)
        return 4294960554;
      v5 = a2[1];
      if ((v5 - 33) < 0xFFFFFFE0)
        return 4294960554;
      v6 = a2 + 2;
      if (a3 - (uint64_t)(a2 + 2) < v5)
        return 4294960554;
      v14 = a3 - (_QWORD)(a2 + 2);
      v15 = a2[1];
      v7 = 0;
      v8 = 8 * v5;
      v9 = *a2 << 8;
      if ((8 * v5) <= 1)
        v10 = 1;
      else
        v10 = 8 * v5;
      v11 = 1;
      while (1)
      {
        if (((v6[(unint64_t)v7 >> 3] >> (~(_BYTE)v7 & 7)) & 1) != 0)
        {
          *(_OWORD *)__str = 0u;
          v18 = 0u;
          v12 = DNSRecordTypeValueToString(v9 + v7);
          if (!v12)
          {
            v12 = __str;
            snprintf(__str, 0x20uLL, "TYPE%u", v9 + v7);
          }
          if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
            dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
          if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
            return 4294960561;
          result = _GetCUSymAddr_DataBuffer_AppendF_sAddr(a1, " %s", v12);
          if ((_DWORD)result)
            break;
        }
        v11 = ++v7 < v8;
        if (v10 == v7)
        {
          v6 += v15;
          v3 = a3 - (_QWORD)v6;
          goto LABEL_19;
        }
      }
      v3 = v14;
      if (v11)
        return result;
LABEL_19:
      a2 = v6;
      if (v3 > 0)
        continue;
      break;
    }
  }
  return 0;
}

const char *_DNSSVCBKeyToString(int a1)
{
  const char *result;
  const char *v4;

  result = "mandatory";
  switch(a1)
  {
    case 0:
      return result;
    case 1:
      result = "alpn";
      break;
    case 2:
      result = "no-default-alpn";
      break;
    case 3:
      result = "port";
      break;
    case 4:
      result = "ipv4hint";
      break;
    case 5:
      result = "echconfig";
      break;
    case 6:
      result = "ipv6hint";
      break;
    case 7:
      result = "dohpath";
      break;
    default:
      v4 = "odohconfig";
      if (a1 != 32769)
        v4 = 0;
      if (a1 == 0x8000)
        result = "dohuri";
      else
        result = v4;
      break;
  }
  return result;
}

uint64_t _AppendOPTRDataString(uint64_t a1, unsigned __int16 *a2, unint64_t a3, int a4)
{
  unsigned __int16 *v5;
  const char *v7;
  _BYTE *v8;
  unint64_t v9;
  unsigned int v10;
  uint64_t result;
  unsigned int v12;
  unsigned __int16 *v13;
  unsigned int v14;
  unsigned int v15;
  const char *v16;

  if ((unint64_t)a2 > a3)
    return 4294960586;
  v5 = a2;
  v7 = "";
  while (1)
  {
    if ((unint64_t)v5 >= a3)
      return 0;
    if (a3 - (unint64_t)v5 < 4)
      break;
    v8 = v5 + 2;
    v9 = __rev16(v5[1]);
    if (a3 - (unint64_t)(v5 + 2) < v9)
      break;
    v10 = *v5;
    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
      return 4294960561;
    result = _GetCUSymAddr_DataBuffer_AppendF_sAddr(a1, "%s{", v7);
    if ((_DWORD)result)
      return result;
    v12 = __rev16(v10);
    if (v12 == 12)
    {
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
        return 4294960561;
      result = _GetCUSymAddr_DataBuffer_AppendF_sAddr(a1, "Padding");
    }
    else if (v12 == 15)
    {
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
        return 4294960561;
      result = _GetCUSymAddr_DataBuffer_AppendF_sAddr(a1, "EDE");
    }
    else
    {
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
        return 4294960561;
      result = _GetCUSymAddr_DataBuffer_AppendF_sAddr(a1, "CODE%u");
    }
    if ((_DWORD)result)
      return result;
    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
      return 4294960561;
    result = _GetCUSymAddr_DataBuffer_AppendF_sAddr(a1, ", ");
    if ((_DWORD)result)
      return result;
    v13 = (unsigned __int16 *)&v8[v9];
    if (v12 == 15 && (_DWORD)v9)
    {
      if (v9 < 2)
        return 4294960546;
      v14 = v5[2];
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
        return 4294960561;
      v15 = __rev16(v14);
      result = _GetCUSymAddr_DataBuffer_AppendF_sAddr(a1, "code: %u", v15);
      if ((_DWORD)result)
        return result;
      if (v15 <= 0x18)
      {
        v16 = off_10013E0E8[v15];
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
          return 4294960561;
        result = _GetCUSymAddr_DataBuffer_AppendF_sAddr(a1, " (%s)", v16);
        if ((_DWORD)result)
          return result;
      }
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
        return 4294960561;
      result = _GetCUSymAddr_DataBuffer_AppendF_sAddr(a1, ", extra-text: ");
      if ((_DWORD)result)
        return result;
      if (!a4 || (_WORD)v13 == (_WORD)v5 + 6)
      {
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
          return 4294960561;
        result = _GetCUSymAddr_DataBuffer_AppendF_sAddr(a1, "'%.*s'");
      }
      else
      {
        if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
          dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
        if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
          return 4294960561;
        result = _GetCUSymAddr_DataBuffer_AppendF_sAddr(a1, "«REDACTED»");
      }
    }
    else if (a4)
    {
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
        return 4294960561;
      result = _GetCUSymAddr_DataBuffer_AppendF_sAddr(a1, "[%u B]");
    }
    else if (v12 == 12 && (_DWORD)v9 && !*v8 && !memcmp(v5 + 2, (char *)v5 + 5, v9 - 1))
    {
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
        return 4294960561;
      result = _GetCUSymAddr_DataBuffer_AppendF_sAddr(a1, "<%u zero bytes>");
    }
    else
    {
      if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
        dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
      if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
        return 4294960561;
      result = _GetCUSymAddr_DataBuffer_AppendF_sAddr(a1, "'%H'");
    }
    if ((_DWORD)result)
      return result;
    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
    if (!_GetCUSymAddr_DataBuffer_AppendF_sAddr)
      return 4294960561;
    result = _GetCUSymAddr_DataBuffer_AppendF_sAddr(a1, "}");
    v5 = v13;
    v7 = ", ";
    if ((_DWORD)result)
      return result;
  }
  return 4294960546;
}

uint64_t _AppendIPAddress(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t result;
  _OWORD v9[2];
  char v10;

  if ((_DWORD)a4 != 16 && (_DWORD)a4 != 4)
    return 4294960553;
  if (!a5)
  {
    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
    if (_GetCUSymAddr_DataBuffer_AppendF_sAddr)
      return _GetCUSymAddr_DataBuffer_AppendF_sAddr(a1, "%s%.*a");
    return 4294960561;
  }
  v10 = 0;
  memset(v9, 0, sizeof(v9));
  if (_GetCUSymAddr_SNPrintF_sOnce != -1)
    dispatch_once(&_GetCUSymAddr_SNPrintF_sOnce, &__block_literal_global_244);
  if (!_GetCUSymAddr_SNPrintF_sAddr)
    return 4294960561;
  result = _GetCUSymAddr_SNPrintF_sAddr(v9, 33, "%.4H", a3, a4, a4);
  if ((result & 0x80000000) == 0)
  {
    if (_GetCUSymAddr_DataBuffer_AppendF_sOnce != -1)
      dispatch_once(&_GetCUSymAddr_DataBuffer_AppendF_sOnce, &__block_literal_global_213);
    if (_GetCUSymAddr_DataBuffer_AppendF_sAddr)
      return _GetCUSymAddr_DataBuffer_AppendF_sAddr(a1, "%s%~s");
    return 4294960561;
  }
  return result;
}

uint64_t DNSMessagePrintObfuscatedString(uint64_t a1, const char *a2)
{
  if (_NameIsPrivate(a2))
  {
    if (_GetCUSymAddr_SNPrintF_sOnce != -1)
      dispatch_once(&_GetCUSymAddr_SNPrintF_sOnce, &__block_literal_global_244);
    if (_GetCUSymAddr_SNPrintF_sAddr)
      return _GetCUSymAddr_SNPrintF_sAddr(a1, 64, "%~s", a2);
  }
  else
  {
    if (_GetCUSymAddr_SNPrintF_sOnce != -1)
      dispatch_once(&_GetCUSymAddr_SNPrintF_sOnce, &__block_literal_global_244);
    if (_GetCUSymAddr_SNPrintF_sAddr)
      return _GetCUSymAddr_SNPrintF_sAddr(a1, 64, "%s");
  }
  return 4294960561;
}

uint64_t _DNSMessagePrintObfuscatedIPAddress(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  _OWORD v7[2];
  char v8;

  if (a3 != 16 && a3 != 4)
    return 4294960553;
  if (_GetCUSymAddr_SNPrintF_sOnce != -1)
    dispatch_once(&_GetCUSymAddr_SNPrintF_sOnce, &__block_literal_global_244);
  if (!_GetCUSymAddr_SNPrintF_sAddr)
    return 4294960561;
  v8 = 0;
  memset(v7, 0, sizeof(v7));
  result = _GetCUSymAddr_SNPrintF_sAddr(v7, 33, "%.4H", a2, a3, a3);
  if ((result & 0x80000000) == 0)
  {
    if (_GetCUSymAddr_SNPrintF_sOnce != -1)
      dispatch_once(&_GetCUSymAddr_SNPrintF_sOnce, &__block_literal_global_244);
    if (_GetCUSymAddr_SNPrintF_sAddr)
      return _GetCUSymAddr_SNPrintF_sAddr(a1, 64, "%~s", v7);
    return 4294960561;
  }
  return result;
}

char *put_hex_from_bytes(unsigned __int8 *a1, uint64_t a2, char *__str, unint64_t a4)
{
  char *v4;
  uint64_t v5;
  unsigned __int8 *v6;
  char *v7;
  int v8;

  v4 = __str;
  if (a1)
  {
    v5 = a2;
    if (a2)
    {
      if (2 * a2 < a4)
      {
        v6 = a1;
        v7 = &__str[a4];
        do
        {
          v8 = *v6++;
          v4 += snprintf(v4, v7 - v4, "%02X", v8);
          --v5;
        }
        while (v5);
      }
    }
  }
  return v4;
}

uint64_t _dnssec_obj_rr_nsec3_compare(uint64_t a1, uint64_t a2, char a3)
{
  _BYTE *v6;
  unsigned __int8 *parent;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  NSObject *v12;
  int v15;
  const char *v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  uint64_t v24;

  if ((a3 & 1) != 0)
    return 3;
  v6 = *(_BYTE **)(*(_QWORD *)(a2 + 16) + 16);
  parent = domain_name_labels_get_parent(*(_BYTE **)(*(_QWORD *)(a1 + 16) + 16), 1uLL);
  if (!parent)
  {
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      v12 = mDNSLogCategory_DNSSEC;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
        return 2;
    }
    else
    {
      v12 = mDNSLogCategory_DNSSEC_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT))
        return 2;
    }
    v15 = 136447234;
    v16 = "my_parent != NULL";
    v17 = 2082;
    v18 = "";
    v19 = 2082;
    v20 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rr_nsec3.c";
    v21 = 1024;
    v22 = 205;
    v23 = 2048;
    v24 = 0;
LABEL_26:
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", (uint8_t *)&v15, 0x30u);
    return 2;
  }
  v8 = parent;
  v9 = domain_name_labels_get_parent(v6, 1uLL);
  if (!v9)
  {
    if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
    {
      v12 = mDNSLogCategory_DNSSEC;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT))
        return 2;
    }
    else
    {
      v12 = mDNSLogCategory_DNSSEC_redacted;
      if (!os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT))
        return 2;
    }
    v15 = 136447234;
    v16 = "others_parent != NULL";
    v17 = 2082;
    v18 = "";
    v19 = 2082;
    v20 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rr_nsec3.c";
    v21 = 1024;
    v22 = 208;
    v23 = 2048;
    v24 = 0;
    goto LABEL_26;
  }
  if (domain_name_labels_canonical_compare(v8, v9, 1))
    return 2;
  return domain_name_label_canonical_compare(*(unsigned __int8 **)(*(_QWORD *)(a1 + 16) + 16), *(unsigned __int8 **)(*(_QWORD *)(a2 + 16) + 16), 0);
}

void _dnssec_obj_rr_nsec3_finalize(uint64_t a1)
{
  _QWORD *v2;

  v2 = *(_QWORD **)(a1 + 80);
  if (v2)
  {
    ref_count_obj_release(v2);
    *(_QWORD *)(a1 + 80) = 0;
  }
}

BOOL dnssec_obj_rr_nsec3_asserts_name_exists_data_does_not_exist(uint64_t a1, uint64_t a2, int a3, unsigned int a4)
{
  uint64_t v6;
  unsigned __int8 *v7;
  unsigned __int16 v8;
  unint64_t v9;
  int v10;
  uint64_t v11;
  unint64_t v12;
  BOOL v13;
  _BOOL8 result;
  uint64_t nsec3_hashed_name;
  NSObject *v16;
  int v18;
  const char *v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  uint64_t v27;

  if (*(unsigned __int16 *)(a1 + 34) != a3)
    return 0;
  v6 = *(_QWORD *)(a1 + 24);
  v7 = (unsigned __int8 *)(*(unsigned __int8 *)(v6 + 4)
                         + v6
                         + 5
                         + *(unsigned __int8 *)(*(unsigned __int8 *)(v6 + 4) + v6 + 5)
                         + 1);
  v8 = *(_WORD *)(a1 + 36)
     - (*(unsigned __int8 *)(v6 + 4)
      + 5
      + *(unsigned __int8 *)(*(unsigned __int8 *)(v6 + 4) + v6 + 5)
      + 1);
  if ((rdata_parser_type_bit_maps_cover_dns_type(v7, v8, a4) & 1) != 0)
    return 0;
  v9 = (unint64_t)&v7[v8];
  if ((unint64_t)(v7 + 1) < v9)
  {
    v10 = 0;
    do
    {
      v11 = v7[1];
      v12 = (unint64_t)&v7[v11 + 2];
      if (v12 > v9)
        break;
      if (*v7)
        v13 = 1;
      else
        v13 = (_DWORD)v11 == 0;
      if (!v13)
        v10 |= (v7[2] & 4) >> 2;
      v7 += v11 + 2;
    }
    while (v12 + 1 < v9);
    if ((v10 & 1) != 0)
      return 0;
  }
  nsec3_hashed_name = dnssec_obj_domain_name_get_nsec3_hashed_name(a2, a1);
  if (nsec3_hashed_name)
    return ref_count_obj_compare(*(_QWORD *)(a1 + 16), nsec3_hashed_name, 1) == 0;
  v16 = mDNSLogCategory_DNSSEC;
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
  {
    result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
    if (result)
    {
LABEL_25:
      v18 = 136447234;
      v19 = "hashed_name != NULL";
      v20 = 2082;
      v21 = "";
      v22 = 2082;
      v23 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rr_nsec3.c";
      v24 = 1024;
      v25 = 316;
      v26 = 2048;
      v27 = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", (uint8_t *)&v18, 0x30u);
      return 0;
    }
  }
  else
  {
    v16 = mDNSLogCategory_DNSSEC_redacted;
    result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
    if (result)
      goto LABEL_25;
  }
  return result;
}

uint64_t dnssec_obj_rr_nsec3_asserts_name_does_not_exist(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t nsec3_hashed_name;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t result;
  NSObject *v12;
  int v13;
  const char *v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  uint64_t v22;

  if (*(unsigned __int16 *)(a1 + 34) != a3)
    return 0;
  v4 = *(_QWORD *)(a1 + 16);
  v5 = *(_QWORD *)(a1 + 80);
  nsec3_hashed_name = dnssec_obj_domain_name_get_nsec3_hashed_name(a2, a1);
  if (nsec3_hashed_name)
  {
    v7 = nsec3_hashed_name;
    v8 = *(unsigned __int8 *)(a1 + 88);
    v9 = ref_count_obj_compare(v4, nsec3_hashed_name, 0);
    if (v8)
    {
      if (v9 == -1)
        return 1;
      return ref_count_obj_compare(v7, v5, 0) == -1;
    }
    if (v9 == -1)
      return ref_count_obj_compare(v7, v5, 0) == -1;
    return 0;
  }
  if (gSensitiveLoggingEnabled != 1 || mDNSLogCategory_DNSSEC == mDNSLogCategory_State)
  {
    v12 = mDNSLogCategory_DNSSEC;
    result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC, OS_LOG_TYPE_FAULT);
    if ((_DWORD)result)
    {
LABEL_18:
      v13 = 136447234;
      v14 = "hashed_name != NULL";
      v15 = 2082;
      v16 = "";
      v17 = 2082;
      v18 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponder/mDNSMacOSX/dnssec_v2/dnssec_objs/dnssec_obj_rr_nsec3.c";
      v19 = 1024;
      v20 = 339;
      v21 = 2048;
      v22 = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_FAULT, "AssertMacros: %{public}s, %{public}s file: %{public}s, line: %d, value: %ld", (uint8_t *)&v13, 0x30u);
      return 0;
    }
  }
  else
  {
    v12 = mDNSLogCategory_DNSSEC_redacted;
    result = os_log_type_enabled((os_log_t)mDNSLogCategory_DNSSEC_redacted, OS_LOG_TYPE_FAULT);
    if ((_DWORD)result)
      goto LABEL_18;
  }
  return result;
}

uint64_t _mdns_dso_session_init(uint64_t result)
{
  unint64_t v1;
  unint64_t v2;

  *(_QWORD *)(result + 116) = 0x36EE8000003A98;
  do
  {
    v1 = __ldxr(&_mdns_dso_session_get_next_id_s_last_id);
    v2 = v1 + 1;
  }
  while (__stxr(v2, &_mdns_dso_session_get_next_id_s_last_id));
  *(_QWORD *)(result + 40) = v2;
  return result;
}

char *_mdns_dso_session_copy_description(uint64_t a1)
{
  uint64_t (*v1)(void);
  char *result;

  v1 = *(uint64_t (**)(void))(*(_QWORD *)(a1 + 16) + 200);
  if (v1)
    return (char *)v1();
  result = strdup("<This is a DSO session object.>");
  if (!result)
    __break(1u);
  return result;
}

void _mdns_dso_session_finalize(uint64_t a1)
{
  NSObject *v2;
  const void *v3;
  const void *v4;
  void *v5;
  void *v6;
  NSObject *v7;

  v2 = *(NSObject **)(a1 + 48);
  if (v2)
  {
    dispatch_release(v2);
    *(_QWORD *)(a1 + 48) = 0;
  }
  v3 = *(const void **)(a1 + 56);
  if (v3)
  {
    _Block_release(v3);
    *(_QWORD *)(a1 + 56) = 0;
  }
  v4 = *(const void **)(a1 + 64);
  if (v4)
  {
    _Block_release(v4);
    *(_QWORD *)(a1 + 64) = 0;
  }
  v5 = *(void **)(a1 + 88);
  if (v5)
  {
    free(v5);
    *(_QWORD *)(a1 + 88) = 0;
  }
  v6 = *(void **)(a1 + 96);
  if (v6)
  {
    free(v6);
    *(_QWORD *)(a1 + 96) = 0;
  }
  v7 = *(NSObject **)(a1 + 72);
  if (v7)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 72));
    dispatch_release(v7);
    *(_QWORD *)(a1 + 72) = 0;
  }
}

int32x2_t _mdns_dso_client_session_init(int32x2_t *a1)
{
  int32x2_t result;

  result = vdup_n_s32(0x3A98u);
  a1[16] = result;
  a1[26].i8[6] = 1;
  return result;
}

void _mdns_dso_client_session_finalize(uint64_t a1)
{
  void *v2;
  void *v3;
  const void *v4;
  const void *v5;
  void *v6;
  void *v7;
  NSObject *v8;
  NSObject *v9;
  const void *v10;

  v2 = *(void **)(a1 + 136);
  if (v2)
  {
    os_release(v2);
    *(_QWORD *)(a1 + 136) = 0;
  }
  if (*(_QWORD *)(a1 + 144))
  {
    nw_resolver_cancel();
    v3 = *(void **)(a1 + 144);
    if (v3)
    {
      nw_release(v3);
      *(_QWORD *)(a1 + 144) = 0;
    }
  }
  v4 = *(const void **)(a1 + 152);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 152) = 0;
  }
  v5 = *(const void **)(a1 + 160);
  if (v5)
  {
    CFRelease(v5);
    *(_QWORD *)(a1 + 160) = 0;
  }
  v6 = *(void **)(a1 + 168);
  if (v6)
  {
    os_release(v6);
    *(_QWORD *)(a1 + 168) = 0;
  }
  v7 = *(void **)(a1 + 176);
  if (v7)
  {
    os_release(v7);
    *(_QWORD *)(a1 + 176) = 0;
  }
  v8 = *(NSObject **)(a1 + 184);
  if (v8)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 184));
    dispatch_release(v8);
    *(_QWORD *)(a1 + 184) = 0;
  }
  v9 = *(NSObject **)(a1 + 192);
  if (v9)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 192));
    dispatch_release(v9);
    *(_QWORD *)(a1 + 192) = 0;
  }
  v10 = *(const void **)(a1 + 200);
  if (v10)
  {
    _Block_release(v10);
    *(_QWORD *)(a1 + 200) = 0;
  }
}

uint64_t _mdns_dso_client_session_activate(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  const __CFArray *v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t srv;
  void *v11;
  nw_parameters_t v12;
  NSObject *v13;
  uint64_t v14;
  NSObject *v15;
  void *v16;
  void *v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  void **v24;
  uint64_t v25;
  void *v26;
  void *v27;
  uint64_t v28;
  uint8_t v29[4];
  uint64_t v30;
  __int16 v31;
  uint64_t v32;
  __int16 v33;
  int v34;
  _BYTE buf[24];
  void *v36;
  uint64_t v37;

  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 152)) < 1)
  {
    v9 = *(_QWORD *)(a1 + 136);
    if (!v9)
      return 4294960591;
    srv = nw_endpoint_create_srv(*(_QWORD *)(v9 + 40));
    if (!srv)
      return 4294960567;
    v11 = (void *)srv;
    v12 = nw_parameters_create();
    if (!v12)
    {
      nw_release(v11);
      return 4294960567;
    }
    v13 = v12;
    v14 = *(unsigned int *)(a1 + 208);
    if ((_DWORD)v14)
    {
      v15 = nw_interface_create_with_index(v14);
      if (!v15)
        goto LABEL_30;
      nw_parameters_require_interface(v13, v15);
    }
    else
    {
      v15 = 0;
    }
    v17 = (void *)nw_resolver_create_with_endpoint(v11, v13);
    if (v17)
    {
      v18 = (uint64_t)v17;
      nw_retain(v17);
      v24 = _NSConcreteStackBlock;
      v25 = 0x40000000;
      v26 = ___mdns_dso_client_session_start_srv_resolution_block_invoke;
      v27 = &__block_descriptor_tmp_20_5991;
      v28 = v18;
      nw_resolver_set_cancel_handler(v18, &v24);
      if (_mdns_dso_session_queue_s_once != -1)
        dispatch_once(&_mdns_dso_session_queue_s_once, &__block_literal_global_66);
      *(_QWORD *)buf = _NSConcreteStackBlock;
      *(_QWORD *)&buf[8] = 0x40000000;
      *(_QWORD *)&buf[16] = ___mdns_dso_client_session_start_srv_resolution_block_invoke_2;
      v36 = &__block_descriptor_tmp_22_5992;
      v37 = a1;
      nw_resolver_set_update_handler(v18, _mdns_dso_session_queue_s_queue, buf);
      if (_mdns_dso_session_log_s_once != -1)
        dispatch_once(&_mdns_dso_session_log_s_once, &__block_literal_global_5946);
      v19 = _mdns_dso_session_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_dso_session_log_s_log, OS_LOG_TYPE_DEFAULT))
      {
        v20 = *(_QWORD *)(a1 + 40);
        v21 = *(_QWORD *)(a1 + 136);
        v22 = *(_DWORD *)(a1 + 208);
        *(_DWORD *)v29 = 134218498;
        v30 = v20;
        v31 = 2112;
        v32 = v21;
        v33 = 1024;
        v34 = v22;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "[DSO%llu] Start -> Start SRV resolution -- service name: %@, interface index: %u", v29, 0x1Cu);
      }
      v5 = 0;
      *(_QWORD *)(a1 + 144) = v18;
      *(_BYTE *)(a1 + 214) = 2;
LABEL_31:
      nw_release(v11);
      nw_release(v13);
      if (v15)
      {
        v16 = v15;
LABEL_33:
        nw_release(v16);
        return v5;
      }
      return v5;
    }
LABEL_30:
    v5 = 4294960567;
    goto LABEL_31;
  }
  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 152)) >= 1)
  {
    v2 = nw_array_create();
    if (v2)
    {
      v3 = v2;
      v4 = *(const __CFArray **)(a1 + 152);
      v24 = _NSConcreteStackBlock;
      v25 = 0x40000000;
      v26 = ___mdns_dso_client_session_start_connection_with_server_addresses_block_invoke;
      v27 = &__block_descriptor_tmp_10_5989;
      v28 = v3;
      if (mdns_cfarray_enumerate(v4, (uint64_t)&v24) && nw_array_get_count(v3))
      {
        *(_BYTE *)(a1 + 214) = 3;
        v5 = _mdns_dso_client_session_add_nw_endpoints(a1, v3);
        if (!(_DWORD)v5)
        {
          if (_mdns_dso_session_log_s_once != -1)
            dispatch_once(&_mdns_dso_session_log_s_once, &__block_literal_global_5946);
          v6 = _mdns_dso_session_log_s_log;
          v5 = 0;
          if (os_log_type_enabled((os_log_t)_mdns_dso_session_log_s_log, OS_LOG_TYPE_DEFAULT))
          {
            v7 = *(_QWORD *)(a1 + 40);
            v8 = *(_QWORD *)(a1 + 152);
            *(_DWORD *)buf = 134218242;
            *(_QWORD *)&buf[4] = v7;
            *(_WORD *)&buf[12] = 2112;
            *(_QWORD *)&buf[14] = v8;
            _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "[DSO%llu] Start -> Start connection directly -- addresses: %@", buf, 0x16u);
            v5 = 0;
          }
        }
      }
      else
      {
        v5 = 4294960539;
      }
      v16 = (void *)v3;
      goto LABEL_33;
    }
    return 4294960567;
  }
  return 4294960578;
}

uint64_t _mdns_dso_client_session_check_configuration(uint64_t a1)
{
  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 152)) <= 0 && !*(_QWORD *)(a1 + 136)
    || !*(_QWORD *)(a1 + 200)
    || !*(_WORD *)(a1 + 212))
  {
    return 4294960578;
  }
  if (*(_BYTE *)(a1 + 214) == 1)
    return 0;
  return 4294960587;
}

nw_connection_t _mdns_dso_client_session_prepare_connection(uint64_t a1, int *a2)
{
  uint64_t v4;
  nw_parameters_t secure_tcp;
  NSObject *v6;
  nw_protocol_stack_t v7;
  NSObject *v8;
  NSObject *options;
  uint64_t v10;
  nw_connection_t v11;
  int v12;
  _QWORD v14[6];

  v4 = *(_QWORD *)(a1 + 16);
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 0x40000000;
  v14[2] = ___mdns_dso_session_create_tls_nw_parameters_block_invoke;
  v14[3] = &__block_descriptor_tmp_26_5985;
  v14[4] = a1;
  v14[5] = v4;
  secure_tcp = nw_parameters_create_secure_tcp(v14, _nw_parameters_configure_protocol_default_configuration);
  if (!secure_tcp)
  {
LABEL_16:
    v11 = 0;
    v12 = -6729;
    if (!a2)
      return v11;
    goto LABEL_13;
  }
  v6 = secure_tcp;
  nw_parameters_set_no_wake_from_sleep(secure_tcp, 1);
  v7 = nw_parameters_copy_default_protocol_stack(v6);
  if (!v7)
  {
    nw_release(v6);
    goto LABEL_16;
  }
  v8 = v7;
  if (_mdns_get_dns_over_bytestream_protocol_definition_s_once != -1)
    dispatch_once(&_mdns_get_dns_over_bytestream_protocol_definition_s_once, &__block_literal_global_6166);
  if (!_mdns_get_dns_over_bytestream_protocol_definition_s_framer_def)
  {
    options = 0;
    goto LABEL_19;
  }
  options = nw_framer_create_options((nw_protocol_definition_t)_mdns_get_dns_over_bytestream_protocol_definition_s_framer_def);
  if (!options)
  {
LABEL_19:
    v11 = 0;
LABEL_20:
    v12 = -6729;
    goto LABEL_10;
  }
  nw_protocol_stack_prepend_application_protocol(v8, options);
  v10 = *(_QWORD *)(a1 + 176);
  if (v10)
  {
    v11 = nw_connection_create(*(nw_endpoint_t *)(v10 + 24), v6);
    if (v11)
    {
      v12 = 0;
      goto LABEL_10;
    }
    goto LABEL_20;
  }
  v11 = 0;
  v12 = -6718;
LABEL_10:
  nw_release(v6);
  nw_release(v8);
  if (options)
    nw_release(options);
  if (a2)
LABEL_13:
    *a2 = v12;
  return v11;
}

BOOL _mdns_dso_client_session_evaluate_trust(uint64_t a1, int a2, sec_trust_t trust, int *a4)
{
  __SecTrust *v6;
  __SecTrust *v7;
  const __CFArray *v8;
  const __CFData *v9;
  _BOOL8 v10;
  int Code;
  NSObject *v12;
  uint64_t v14;
  CFErrorRef error;
  uint8_t buf[4];
  uint64_t v17;
  __int16 v18;
  CFErrorRef v19;

  error = 0;
  if (trust)
  {
    v6 = sec_trust_copy_ref(trust);
    if (v6)
    {
      v7 = v6;
      v8 = *(const __CFArray **)(a1 + 160);
      if (v8)
      {
        SecTrustSetNetworkFetchAllowed(v6, 0);
        SecTrustSetAnchorCertificatesOnly(v7, 1u);
        SecTrustSetAnchorCertificates(v7, v8);
        v9 = SecTrustCopyExceptions(v7);
        if (v9)
          SecTrustSetExceptions(v7, v9);
        v10 = SecTrustEvaluateWithError(v7, &error);
        if (v10)
        {
          Code = 0;
        }
        else if (error)
        {
          if (_mdns_dso_session_log_s_once != -1)
            dispatch_once(&_mdns_dso_session_log_s_once, &__block_literal_global_5946);
          v12 = _mdns_dso_session_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_dso_session_log_s_log, OS_LOG_TYPE_ERROR))
          {
            v14 = *(_QWORD *)(a1 + 40);
            *(_DWORD *)buf = 134218242;
            v17 = v14;
            v18 = 2112;
            v19 = error;
            _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "[DSO%llu] TLS certificate evaluation failed -- reason: %@", buf, 0x16u);
          }
          Code = CFErrorGetCode(error);
        }
        else
        {
          Code = -6754;
        }
        CFRelease(v7);
        if (v9)
          CFRelease(v9);
      }
      else
      {
        CFRelease(v6);
        Code = 0;
        v10 = 1;
      }
      if (error)
        CFRelease(error);
    }
    else
    {
      v10 = 0;
      Code = -6729;
    }
  }
  else
  {
    v10 = 0;
    Code = -6705;
  }
  if (a4)
    *a4 = Code;
  return v10;
}

uint64_t _mdns_dso_client_session_set_connection_ready(uint64_t result)
{
  *(_BYTE *)(result + 214) = 5;
  return result;
}

uint64_t _mdns_dso_client_session_prepare_session(uint64_t a1)
{
  uint64_t keepalive_message;
  dispatch_data_t *v3;
  NSObject *monotonic_timer;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD handler[5];
  uint8_t buf[4];
  uint64_t v11;

  if (*(_BYTE *)(a1 + 214) != 5)
    return 4294960587;
  keepalive_message = _mdns_dso_session_create_keepalive_message(a1, *(_WORD *)(a1 + 212));
  if (!keepalive_message)
    return 4294960567;
  v3 = (dispatch_data_t *)keepalive_message;
  if (_mdns_dso_session_queue_s_once != -1)
    dispatch_once(&_mdns_dso_session_queue_s_once, &__block_literal_global_66);
  monotonic_timer = _mdns_dispatch_create_monotonic_timer(0x7530u, 0xFFFFFFFFFFFFFFFFLL, 5u, _mdns_dso_session_queue_s_queue);
  if (monotonic_timer)
  {
    *(_QWORD *)(a1 + 192) = monotonic_timer;
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 0x40000000;
    handler[2] = ___mdns_dso_client_session_prepare_session_block_invoke;
    handler[3] = &__block_descriptor_tmp_27_5982;
    handler[4] = a1;
    dispatch_source_set_event_handler(monotonic_timer, handler);
    if (_mdns_dso_session_log_s_once != -1)
      dispatch_once(&_mdns_dso_session_log_s_once, &__block_literal_global_5946);
    v5 = _mdns_dso_session_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dso_session_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_QWORD *)(a1 + 40);
      *(_DWORD *)buf = 134217984;
      v11 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "[DSO%llu] Connection ready -> Preparing session", buf, 0xCu);
    }
    _mdns_dso_session_send_data_immediately(a1, v3[3], 0, 0);
    dispatch_activate(*(dispatch_object_t *)(a1 + 192));
    v7 = 0;
    *(_BYTE *)(a1 + 214) = 6;
  }
  else
  {
    v7 = 4294960567;
  }
  os_release(v3);
  return v7;
}

BOOL _mdns_dso_client_session_expects_message(uint64_t a1)
{
  return (*(_BYTE *)(a1 + 214) & 0xFE) == 6;
}

BOOL _mdns_dso_client_session_is_session_ready(uint64_t a1)
{
  return *(_BYTE *)(a1 + 214) == 7;
}

uint64_t _mdns_dso_client_session_set_up_inactivity_timer(uint64_t a1, unsigned int a2)
{
  unsigned int v2;
  NSObject *monotonic_timer;
  NSObject *v5;
  NSObject *v6;
  uint64_t result;
  _QWORD v8[5];
  unsigned int v9;

  v2 = a2;
  if (!a2)
    v2 = *(_DWORD *)(a1 + 128);
  if (v2 == -1)
    return 0;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = ___mdns_dso_client_session_set_up_inactivity_timer_ex_block_invoke;
  v8[3] = &__block_descriptor_tmp_28_5980;
  v8[4] = a1;
  v9 = v2;
  if (_mdns_dso_session_queue_s_once != -1)
    dispatch_once(&_mdns_dso_session_queue_s_once, &__block_literal_global_66);
  monotonic_timer = _mdns_dispatch_create_monotonic_timer(v2, 0xFFFFFFFFFFFFFFFFLL, 5u, _mdns_dso_session_queue_s_queue);
  if (!monotonic_timer)
    return 4294960567;
  v5 = monotonic_timer;
  dispatch_source_set_event_handler(monotonic_timer, v8);
  v6 = *(NSObject **)(a1 + 72);
  if (v6)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 72));
    dispatch_release(v6);
  }
  result = 0;
  *(_QWORD *)(a1 + 72) = v5;
  return result;
}

BOOL _mdns_dso_client_session_check_if_dso_message_belongs_to_user(uint64_t a1, _QWORD *a2)
{
  unsigned __int16 *v4;
  unint64_t v5;

  v4 = (unsigned __int16 *)a2[4];
  v5 = a2[5];
  if (mdns_dso_message_is_unidirectional(v4, v5))
    return *(unsigned __int16 *)(a2[2] + 56) > 2u;
  _mdns_dso_message_get_header((uint64_t)v4, v5);
  return *(unsigned __int16 *)(a1 + 212) != bswap32(*v4) >> 16;
}

uint64_t _mdns_dso_client_session_process_dso_message(uint64_t a1, _QWORD *a2, _BYTE *a3, char *a4)
{
  uint64_t v5;
  _UNKNOWN **v6;
  int v7;
  int v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  char v15;
  uint64_t result;
  int v17;
  NSObject *v18;
  uint64_t v19;
  NSObject *v20;
  uint64_t v21;
  NSObject *v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;

  v6 = (_UNKNOWN **)(a2 + 2);
  v5 = a2[2];
  v7 = *(unsigned __int16 *)(v5 + 56);
  if (!*(_WORD *)(v5 + 56))
  {
    v15 = 0;
    result = 4294960554;
    goto LABEL_36;
  }
  v11 = *(_BYTE *)(_mdns_dso_message_get_header(a2[4], a2[5]) + 3) & 0xF;
  if (!mdns_dso_message_is_unidirectional((unsigned __int16 *)a2[4], a2[5]))
  {
    if (v7 != 1)
      goto LABEL_25;
    v17 = *(unsigned __int8 *)(a1 + 214);
    if (v17 == 7)
    {
      if (v11)
      {
LABEL_24:
        v15 = 0;
LABEL_35:
        result = 0;
        goto LABEL_36;
      }
      result = _mdns_dso_client_session_accept_keepalive_message(a1, (uint64_t)a2, a3);
      if (!(_DWORD)result)
      {
        if (_mdns_dso_session_log_s_once != -1)
          dispatch_once(&_mdns_dso_session_log_s_once, &__block_literal_global_5946);
        v22 = _mdns_dso_session_log_s_log;
        v15 = 1;
        if (os_log_type_enabled((os_log_t)_mdns_dso_session_log_s_log, OS_LOG_TYPE_INFO))
        {
          v23 = *(_QWORD *)(a1 + 40);
          v24 = 134217984;
          v25 = v23;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_INFO, "[DSO%llu] Keepalive message acked", (uint8_t *)&v24, 0xCu);
        }
        goto LABEL_35;
      }
    }
    else
    {
      if (v17 != 6)
        goto LABEL_25;
      if (v11)
      {
        v15 = 0;
        result = 4294960543;
        goto LABEL_36;
      }
      result = _mdns_dso_client_session_accept_keepalive_message(a1, (uint64_t)a2, 0);
      if (!(_DWORD)result)
      {
        *(_BYTE *)(a1 + 214) = 7;
        v18 = *(NSObject **)(a1 + 192);
        if (v18)
        {
          dispatch_source_cancel(*(dispatch_source_t *)(a1 + 192));
          dispatch_release(v18);
          *(_QWORD *)(a1 + 192) = 0;
        }
        result = _mdns_dso_session_schedule_inactivity_timer_ex((_QWORD *)a1, 0);
        if (!(_DWORD)result)
        {
          v19 = *(_QWORD *)(a1 + 176);
          if (!v19)
            goto LABEL_25;
          *(_QWORD *)(v19 + 32) = 0;
          if (_mdns_dso_session_log_s_once != -1)
            dispatch_once(&_mdns_dso_session_log_s_once, &__block_literal_global_5946);
          v20 = _mdns_dso_session_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_dso_session_log_s_log, OS_LOG_TYPE_DEFAULT))
          {
            v21 = *(_QWORD *)(a1 + 40);
            v24 = 134218242;
            v25 = v21;
            v26 = 2112;
            v27 = a1;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "[DSO%llu] Preparing session -> Session ready -- session: %@", (uint8_t *)&v24, 0x16u);
          }
          _mdns_dso_client_session_schedule_user_event(a1, 3, 0);
          goto LABEL_24;
        }
      }
    }
    v15 = 0;
    goto LABEL_36;
  }
  if (v7 != 1)
  {
    if (v7 == 2)
    {
      do
        v6 = (_UNKNOWN **)*v6;
      while (v6 != (_UNKNOWN **)&_mdns_dso_retry_delay_message_kind);
      v12 = bswap32(*(_DWORD *)(a2[4] + 16));
      v13 = *(_QWORD *)(a1 + 176);
      v14 = mach_continuous_time();
      if (mdns_mach_ticks_per_second_s_once != -1)
        dispatch_once(&mdns_mach_ticks_per_second_s_once, &__block_literal_global_3428);
      v15 = 0;
      *(_QWORD *)(v13 + 40) = mdns_mach_ticks_per_second_s_ticks_per_second * (v12 / 0x3E8uLL)
                            + mdns_mach_ticks_per_second_s_ticks_per_second * (unint64_t)(v12 % 0x3E8) / 0x3E8
                            + v14;
      *a3 = 1;
      goto LABEL_35;
    }
LABEL_25:
    v15 = 0;
    result = 4294960560;
    goto LABEL_36;
  }
  if (v11)
    goto LABEL_24;
  result = _mdns_dso_client_session_accept_keepalive_message(a1, (uint64_t)a2, a3);
  v15 = 0;
  if (!(_DWORD)result)
    goto LABEL_35;
LABEL_36:
  if (a4)
    *a4 = v15;
  return result;
}

void _mdns_dso_client_session_handle_error(uint64_t a1, unsigned int a2)
{
  NSObject *v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  __int16 v8;
  uint64_t v9;

  if (a2 - 51 <= 0xE && ((1 << (a2 - 51)) & 0x6609) != 0 && *(_BYTE *)(a1 + 215))
  {
    if (_mdns_dso_session_log_s_once != -1)
      dispatch_once(&_mdns_dso_session_log_s_once, &__block_literal_global_5946);
    v4 = _mdns_dso_session_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dso_session_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      v5 = *(_QWORD *)(a1 + 40);
      v6 = 134218240;
      v7 = v5;
      v8 = 2048;
      v9 = a2;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "[DSO%llu] Reporting connection error to the client -- error: %{mdns:err}ld", (uint8_t *)&v6, 0x16u);
    }
    _mdns_dso_client_session_schedule_user_event(a1, 2, a2);
  }
}

uint64_t _mdns_dso_client_session_check_and_move_to_closing_state(uint64_t a1, int a2)
{
  int v2;
  char v4;

  v2 = *(unsigned __int8 *)(a1 + 214);
  if ((v2 & 0xFE) == 8)
    return 0;
  if (a2)
  {
    if (v2 == 3)
      return 0;
    v4 = 3;
  }
  else
  {
    v4 = 8;
  }
  *(_BYTE *)(a1 + 214) = v4;
  return 1;
}

void _mdns_dso_client_session_close(uint64_t a1, int a2, int a3, int a4, int a5, int a6)
{
  NSObject *v12;
  NSObject *v13;
  _QWORD *v14;
  uint64_t v15;
  NSObject *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  char v21;
  int v22;
  int v23;
  uint64_t v24;

  v12 = *(NSObject **)(a1 + 184);
  if (v12)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 184));
    dispatch_release(v12);
    *(_QWORD *)(a1 + 184) = 0;
  }
  v13 = *(NSObject **)(a1 + 192);
  if (v13)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 192));
    dispatch_release(v13);
    *(_QWORD *)(a1 + 192) = 0;
  }
  v14 = *(_QWORD **)(a1 + 176);
  if (!v14)
  {
LABEL_11:
    if (a5)
      goto LABEL_12;
LABEL_23:
    if (!a6)
      return;
    goto LABEL_24;
  }
  if (a3)
  {
    if (a4)
    {
      v15 = mach_continuous_time();
      if (mdns_mach_ticks_per_second_s_once != -1)
        dispatch_once(&mdns_mach_ticks_per_second_s_once, &__block_literal_global_3428);
      v14[5] = v15 + 3600 * mdns_mach_ticks_per_second_s_ticks_per_second;
      v14 = *(_QWORD **)(a1 + 176);
      if (!v14)
        goto LABEL_11;
    }
    else
    {
      ++v14[4];
    }
  }
  os_release(v14);
  *(_QWORD *)(a1 + 176) = 0;
  if (!a5)
    goto LABEL_23;
LABEL_12:
  if (_mdns_dso_session_log_s_once != -1)
    dispatch_once(&_mdns_dso_session_log_s_once, &__block_literal_global_5946);
  v16 = _mdns_dso_session_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_dso_session_log_s_log, OS_LOG_TYPE_DEFAULT))
  {
    v17 = *(_QWORD *)(a1 + 40);
    v23 = 134217984;
    v24 = v17;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "[DSO%llu] Restarting DSO session", (uint8_t *)&v23, 0xCu);
  }
  do
  {
    v18 = __ldxr(&_mdns_dso_session_get_next_id_s_last_id);
    v19 = v18 + 1;
  }
  while (__stxr(v19, &_mdns_dso_session_get_next_id_s_last_id));
  *(_QWORD *)(a1 + 40) = v19;
  *(_BYTE *)(a1 + 214) = 3;
  if (!_mdns_dso_client_session_connect_or_delay_reconnecting(a1))
  {
    v20 = a1;
    v21 = 1;
    v22 = 0;
LABEL_25:
    _mdns_dso_client_session_schedule_user_event(v20, v21, v22);
    return;
  }
  if ((a6 & 1) != 0)
  {
LABEL_24:
    *(_BYTE *)(a1 + 214) = 8;
    v20 = a1;
    v21 = 4;
    v22 = a2;
    goto LABEL_25;
  }
}

BOOL _mdns_dso_client_session_check_and_move_to_done_state(uint64_t a1)
{
  int v1;

  v1 = *(unsigned __int8 *)(a1 + 214);
  if (v1 != 9)
    *(_BYTE *)(a1 + 214) = 9;
  return v1 != 9;
}

void _mdns_dso_client_session_invalidate(uint64_t a1)
{
  const void *v2;

  _mdns_dso_client_session_schedule_user_event(a1, 5, 0);
  v2 = *(const void **)(a1 + 200);
  if (v2)
  {
    _Block_release(v2);
    *(_QWORD *)(a1 + 200) = 0;
  }
}

void *_mdns_dso_client_session_copy_description(uint64_t a1, int a2, char a3)
{
  _QWORD *v6;
  _QWORD *v7;
  int appended;
  void *v9;
  const char *v10;
  const __CFArray *v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  NSObject *v15;
  char *v16;
  char *v17;
  int64_t v18;
  unint64_t v19;
  _QWORD v21[7];
  char v22;
  _QWORD v23[4];
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  int v27;

  v24 = 0;
  v25 = &v24;
  v26 = 0x2000000000;
  v27 = 0;
  v6 = (_QWORD *)mdns_string_builder_create();
  if (v6)
  {
    v7 = v6;
    if (a2
      && (appended = mdns_string_builder_append_formatted(v6, "<%s: %p>: ", *(const char **)(*(_QWORD *)(a1 + 16) + 8), (const void *)a1), (*((_DWORD *)v25 + 6) = appended) != 0))
    {
      v9 = 0;
    }
    else
    {
      mdns_string_builder_append_formatted(v7, "[DSO%llu", *(_QWORD *)(a1 + 40));
      if (!*(_BYTE *)(a1 + 124))
        mdns_string_builder_append_formatted(v7, " inactive");
      if (*(unsigned __int8 *)(a1 + 214) - 1 > 8)
        v10 = "invalid_session_state";
      else
        v10 = (&off_10013E630)[(*(_BYTE *)(a1 + 214) - 1)];
      mdns_string_builder_append_formatted(v7, " %s", v10);
      if (CFArrayGetCount(*(CFArrayRef *)(a1 + 152)) < 1)
      {
        v12 = *(_QWORD *)(a1 + 136);
        if (v12)
        {
          mdns_string_builder_append_description_with_prefix(v7, " ", v12, a3);
          mdns_string_builder_append_formatted(v7, "@interface %u", *(_DWORD *)(a1 + 208));
        }
      }
      else
      {
        v23[0] = 0;
        v23[1] = v23;
        v23[2] = 0x2000000000;
        v23[3] = " ";
        v11 = *(const __CFArray **)(a1 + 152);
        v21[0] = _NSConcreteStackBlock;
        v21[1] = 0x40000000;
        v21[2] = ___mdns_dso_client_session_copy_description_block_invoke;
        v21[3] = &unk_10013E590;
        v21[5] = v23;
        v21[6] = v7;
        v21[4] = &v24;
        v22 = a3;
        mdns_cfarray_enumerate(v11, (uint64_t)v21);
        _Block_object_dispose(v23, 8);
      }
      v13 = *(_QWORD *)(a1 + 176);
      if (v13)
      {
        if (*(_QWORD *)(a1 + 136))
          v14 = "->";
        else
          v14 = " ";
        mdns_string_builder_append_description_with_prefix(v7, v14, v13, a3);
      }
      v15 = *(NSObject **)(a1 + 80);
      if (v15)
      {
        v16 = nw_connection_copy_description(v15);
        if (v16)
        {
          v17 = v16;
          mdns_string_builder_append_formatted(v7, ", %s", v16);
          free(v17);
        }
      }
      mdns_string_builder_append_formatted(v7, ", activity count: %zu", *(_QWORD *)(a1 + 104));
      if (*(_QWORD *)(a1 + 32))
      {
        v18 = mach_continuous_time() - *(_QWORD *)(a1 + 32);
        if (v18 >= 1)
        {
          v19 = mdns_ticks_to_milliseconds(v18);
          mdns_string_builder_append_formatted(v7, ", last activity %llums ago", v19);
        }
      }
      mdns_string_builder_append_formatted(v7, ", inactivity timeout: %ums, keepalive interval: %ums", *(_DWORD *)(a1 + 128), *(_DWORD *)(a1 + 132));
      mdns_string_builder_append_formatted(v7, ", keepalive msg id: %u", *(unsigned __int16 *)(a1 + 212));
      if (*(_BYTE *)(a1 + 215))
        mdns_string_builder_append_formatted(v7, ", reports connection error");
      mdns_string_builder_append_formatted(v7, "]");
      v9 = mdns_string_builder_copy_string((uint64_t)v7);
    }
    os_release(v7);
  }
  else
  {
    v9 = 0;
  }
  _Block_object_dispose(&v24, 8);
  return v9;
}

BOOL ___mdns_dso_client_session_copy_description_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = mdns_string_builder_append_description_with_prefix(*(_QWORD **)(a1 + 48), *(const char **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8)+ 24), a2, *(_BYTE *)(a1 + 56));
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = ", ";
  return *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) == 0;
}

void _mdns_dso_client_session_schedule_user_event(uint64_t a1, char a2, int a3)
{
  void *v6;
  NSObject *v7;
  _QWORD block[6];
  int v9;
  char v10;

  if (*(_QWORD *)(a1 + 200))
  {
    os_retain((void *)a1);
    v6 = _Block_copy(*(const void **)(a1 + 200));
    v7 = *(NSObject **)(a1 + 48);
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    block[2] = ___mdns_dso_client_session_schedule_user_event_block_invoke;
    block[3] = &unk_10013E528;
    v10 = a2;
    v9 = a3;
    block[4] = v6;
    block[5] = a1;
    dispatch_async(v7, block);
  }
}

void ___mdns_dso_client_session_schedule_user_event_block_invoke(uint64_t a1)
{
  const void *v2;

  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  os_release(*(void **)(a1 + 40));
  v2 = *(const void **)(a1 + 32);
  if (v2)
    _Block_release(v2);
}

uint64_t _mdns_dso_client_session_connect_or_delay_reconnecting(uint64_t a1)
{
  uint64_t v1;
  CFIndex Count;
  uint64_t v3;
  CFIndex v4;
  char v5;
  char v6;
  unint64_t v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  _QWORD *ValueAtIndex;
  unsigned int priority;
  int weight;
  int v14;
  int v15;
  unint64_t v16;
  unsigned int v17;
  char v18;
  uint64_t v19;
  uint32_t v20;
  int v21;
  CFIndex v22;
  uint32_t v23;
  uint64_t v24;
  _QWORD *v25;
  int v26;
  void *v27;
  char v28;
  NSObject *v29;
  NSObject *monotonic_timer;
  NSObject *v31;
  uint64_t v32;
  void *v34;
  void *v35;
  NSObject *v36;
  NSObject *v37;
  NSObject *v38;
  NSObject *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int v43;
  _QWORD completion[5];
  _BYTE handler[32];
  uint64_t v46;
  void *v47;

  v1 = a1;
  if (*(_BYTE *)(a1 + 214) != 3)
  {
    v19 = 4294960587;
    goto LABEL_64;
  }
  v42 = *(_QWORD *)(a1 + 168);
  Count = CFArrayGetCount(*(CFArrayRef *)(v42 + 24));
  if (Count < 1)
  {
    v19 = 4294960569;
    goto LABEL_46;
  }
  v3 = Count;
  v41 = v1;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  *(_DWORD *)handler = 0;
  v9 = -1;
  v10 = 0xFFFF;
  do
  {
    ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v42 + 24), v4);
    LODWORD(completion[0]) = 0;
    if ((_mdns_dso_server_endpoint_is_usable_now((uint64_t)ValueAtIndex, handler, (int *)completion) & 1) != 0)
    {
      if ((v5 & 1) == 0)
        v5 = 1;
      priority = nw_endpoint_get_priority(ValueAtIndex[3]);
      weight = nw_endpoint_get_weight(ValueAtIndex[3]);
      if (v10 <= priority)
        v14 = v8;
      else
        v14 = 0;
      v15 = v14 + weight;
      if (v10 <= priority)
        v16 = v7;
      else
        v16 = 0;
      if (!weight)
        ++v16;
      if (v10 >= priority)
      {
        v10 = priority;
        v8 = v15;
        v7 = v16;
      }
    }
    else
    {
      v17 = completion[0];
      if (v9 < LODWORD(completion[0]))
        v17 = v9;
      if (*(_DWORD *)handler == -6760)
        v9 = v17;
      v6 |= *(_DWORD *)handler == -6760;
    }
    ++v4;
  }
  while (v3 != v4);
  if ((v5 & 1) == 0)
  {
    if ((v6 & 1) != 0)
    {
      v18 = 1;
      v19 = 4294960536;
      v1 = v41;
      goto LABEL_47;
    }
    v19 = 4294960569;
LABEL_45:
    v1 = v41;
LABEL_46:
    v9 = 0;
    v18 = 0;
LABEL_47:
    v27 = *(void **)(v1 + 176);
    if (v27)
    {
      os_release(v27);
      *(_QWORD *)(v1 + 176) = 0;
    }
    v28 = v18 ^ 1;
    if ((_DWORD)v19 != -6760)
      v28 = 1;
    if ((v28 & 1) == 0 && v9)
    {
      v29 = *(NSObject **)(v1 + 184);
      if (v29)
      {
        dispatch_source_cancel(*(dispatch_source_t *)(v1 + 184));
        dispatch_release(v29);
        *(_QWORD *)(v1 + 184) = 0;
      }
      if (_mdns_dso_session_queue_s_once != -1)
        dispatch_once(&_mdns_dso_session_queue_s_once, &__block_literal_global_66);
      monotonic_timer = _mdns_dispatch_create_monotonic_timer(v9, 0xFFFFFFFFFFFFFFFFLL, 5u, _mdns_dso_session_queue_s_queue);
      *(_QWORD *)(v1 + 184) = monotonic_timer;
      if (monotonic_timer)
      {
        *(_QWORD *)handler = _NSConcreteStackBlock;
        *(_QWORD *)&handler[8] = 0x40000000;
        *(_QWORD *)&handler[16] = ___mdns_dso_client_session_schedule_reconnecting_block_invoke;
        *(_QWORD *)&handler[24] = &__block_descriptor_tmp_19_5948;
        v46 = v1;
        dispatch_source_set_event_handler(monotonic_timer, handler);
        dispatch_activate(*(dispatch_object_t *)(v1 + 184));
        v19 = 0;
      }
      else
      {
        v19 = 4294960567;
      }
      if (_mdns_dso_session_log_s_once != -1)
        dispatch_once(&_mdns_dso_session_log_s_once, &__block_literal_global_5946);
      v31 = _mdns_dso_session_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_dso_session_log_s_log, OS_LOG_TYPE_DEFAULT))
      {
        v32 = *(_QWORD *)(v1 + 40);
        *(_DWORD *)handler = 134218498;
        *(_QWORD *)&handler[4] = v32;
        *(_WORD *)&handler[12] = 1024;
        *(_DWORD *)&handler[14] = v9;
        *(_WORD *)&handler[18] = 2112;
        *(_QWORD *)&handler[20] = v1;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "[DSO%llu] -> Wait for reconnection -- delay: %ums, session: %@", handler, 0x1Cu);
      }
      if (!(_DWORD)v19)
        return v19;
    }
LABEL_64:
    _mdns_dso_session_handle_failure(v1, v19, 1, 0);
    return v19;
  }
  v20 = arc4random() % (v8 + 1);
  if (v7)
    v21 = arc4random() % v7 + 1;
  else
    v21 = 0;
  v22 = 0;
  v23 = 0;
  if (v3 <= 1)
    v24 = 1;
  else
    v24 = v3;
  while (1)
  {
    v25 = CFArrayGetValueAtIndex(*(CFArrayRef *)(v42 + 24), v22);
    if (!_mdns_dso_server_endpoint_is_usable_now((uint64_t)v25, 0, 0)
      || nw_endpoint_get_priority(v25[3]) != v10)
    {
      goto LABEL_43;
    }
    v26 = nw_endpoint_get_weight(v25[3]);
    if (!v20)
      break;
    if (v26)
    {
      v23 += v26;
      if (v23 >= v20)
        goto LABEL_66;
    }
LABEL_43:
    if (v24 == ++v22)
    {
LABEL_44:
      v19 = 4294960560;
      goto LABEL_45;
    }
  }
  if (v26)
    goto LABEL_43;
  if (!v21)
    goto LABEL_44;
  if (--v21)
    goto LABEL_43;
LABEL_66:
  v1 = v41;
  *(_QWORD *)(v41 + 176) = v25;
  os_retain(v25);
  v43 = 0;
  v34 = (void *)(*(uint64_t (**)(uint64_t, unsigned int *))(*(_QWORD *)(v1 + 16) + 64))(v1, &v43);
  v35 = v34;
  if (!v43)
  {
    *(_QWORD *)(v41 + 80) = v34;
    nw_retain(v34);
    os_retain((void *)v41);
    nw_retain(v35);
    v36 = *(NSObject **)(v41 + 80);
    if (_mdns_dso_session_queue_s_once != -1)
      dispatch_once(&_mdns_dso_session_queue_s_once, &__block_literal_global_66);
    nw_connection_set_queue(v36, (dispatch_queue_t)_mdns_dso_session_queue_s_queue);
    v37 = *(NSObject **)(v41 + 80);
    *(_QWORD *)handler = _NSConcreteStackBlock;
    *(_QWORD *)&handler[8] = 0x40000000;
    *(_QWORD *)&handler[16] = ___mdns_dso_session_prepare_connection_with_nw_connection_block_invoke;
    *(_QWORD *)&handler[24] = &__block_descriptor_tmp_15_5954;
    v46 = v41;
    v47 = v35;
    nw_connection_set_state_changed_handler(v37, handler);
    nw_connection_start(*(nw_connection_t *)(v41 + 80));
    v38 = *(NSObject **)(v41 + 80);
    completion[0] = _NSConcreteStackBlock;
    completion[1] = 0x40000000;
    completion[2] = ___mdns_dso_session_schedule_receive_block_invoke;
    completion[3] = &__block_descriptor_tmp_17_5955;
    completion[4] = v41;
    nw_connection_receive_message(v38, completion);
    if (_mdns_dso_session_log_s_once != -1)
      dispatch_once(&_mdns_dso_session_log_s_once, &__block_literal_global_5946);
    v39 = _mdns_dso_session_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dso_session_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      v40 = *(_QWORD *)(v41 + 40);
      *(_DWORD *)handler = 134218242;
      *(_QWORD *)&handler[4] = v40;
      *(_WORD *)&handler[12] = 2112;
      *(_QWORD *)&handler[14] = v35;
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "[DSO%llu] Start connection -- connection: %@", handler, 0x16u);
    }
  }
  if (v35)
    nw_release(v35);
  v19 = v43;
  if (v43)
    goto LABEL_46;
  return v19;
}

uint64_t ___mdns_dso_client_session_schedule_reconnecting_block_invoke(uint64_t a1)
{
  return _mdns_dso_client_session_connect_or_delay_reconnecting(*(_QWORD *)(a1 + 32));
}

void _mdns_dso_session_handle_failure(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  void (*v9)(uint64_t, uint64_t);
  NSObject *v10;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;

  v8 = *(_QWORD *)(a1 + 16);
  v9 = *(void (**)(uint64_t, uint64_t))(v8 + 152);
  if (v9)
  {
    v9(a1, a2);
    v8 = *(_QWORD *)(a1 + 16);
  }
  if ((*(unsigned int (**)(uint64_t, uint64_t))(v8 + 168))(a1, a4))
  {
    _mdns_dso_session_close_internal(a1, a2, a3, 0, a4, 1);
    if (_mdns_dso_session_log_s_once != -1)
      dispatch_once(&_mdns_dso_session_log_s_once, &__block_literal_global_5946);
    v10 = _mdns_dso_session_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dso_session_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      v11 = *(_QWORD *)(a1 + 40);
      v14 = 134218752;
      v15 = v11;
      v16 = 2048;
      v17 = (int)a2;
      v18 = 1024;
      v19 = a3;
      v20 = 1024;
      v21 = a4;
      v12 = "[DSO%llu] DSO session failed, closing -- error: %{mdns:err}ld, forcibly: %{BOOL}d, restartable: %{BOOL}d";
LABEL_12:
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v12, (uint8_t *)&v14, 0x22u);
    }
  }
  else
  {
    if (_mdns_dso_session_log_s_once != -1)
      dispatch_once(&_mdns_dso_session_log_s_once, &__block_literal_global_5946);
    v10 = _mdns_dso_session_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dso_session_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      v13 = *(_QWORD *)(a1 + 40);
      v14 = 134218752;
      v15 = v13;
      v16 = 2048;
      v17 = (int)a2;
      v18 = 1024;
      v19 = a3;
      v20 = 1024;
      v21 = a4;
      v12 = "[DSO%llu] DSO session failed, waiting to restart -- error: %{mdns:err}ld, forcibly: %{BOOL}d, restartable: %{BOOL}d";
      goto LABEL_12;
    }
  }
}

uint64_t _mdns_dso_session_close_internal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  NSObject *v12;
  void *v13;
  void *v14;
  void *v15;

  _mdns_dso_session_stop_inactivity_timer(a1);
  *(_QWORD *)(a1 + 104) = 0;
  v12 = *(NSObject **)(a1 + 80);
  if (v12)
  {
    if ((_DWORD)a3)
      nw_connection_force_cancel(v12);
    else
      nw_connection_cancel(v12);
    v13 = *(void **)(a1 + 80);
    if (v13)
    {
      nw_release(v13);
      *(_QWORD *)(a1 + 80) = 0;
    }
    v14 = *(void **)(a1 + 88);
    if (v14)
    {
      free(v14);
      *(_QWORD *)(a1 + 88) = 0;
    }
    v15 = *(void **)(a1 + 96);
    if (v15)
    {
      free(v15);
      *(_QWORD *)(a1 + 96) = 0;
    }
    *(_DWORD *)(a1 + 112) = 0;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 16) + 176))(a1, a2, a3, a4, a5, a6);
}

void _mdns_dso_session_stop_inactivity_timer(uint64_t a1)
{
  NSObject *v2;

  v2 = *(NSObject **)(a1 + 72);
  if (v2)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 72));
    dispatch_release(v2);
    *(_QWORD *)(a1 + 72) = 0;
  }
  *(_QWORD *)(a1 + 32) = 0;
}

void ___mdns_dso_session_queue_block_invoke(id a1)
{
  _mdns_dso_session_queue_s_queue = (uint64_t)dispatch_queue_create("com.apple.mdns.dso-session-queue", 0);
}

void ___mdns_dso_session_prepare_connection_with_nw_connection_block_invoke(uint64_t a1, uint64_t a2, nw_error_t error)
{
  uint64_t error_code;
  NSObject *isa;
  NSObject *v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  NSObject *v12;
  const char *hostname;
  char *v14;
  nw_path_t v15;
  void *v16;
  unsigned int v17;
  char *v18;
  char *v19;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _BYTE v27[22];
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  uint64_t v31;

  if (*(_QWORD *)(*(_QWORD *)(a1 + 32) + 80) != *(_QWORD *)(a1 + 40))
    goto LABEL_2;
  if (error)
    error_code = nw_error_get_error_code(error);
  else
    error_code = 0;
  if (_mdns_dso_session_log_s_once != -1)
    dispatch_once(&_mdns_dso_session_log_s_once, &__block_literal_global_5946);
  isa = &unk_100158000;
  v7 = _mdns_dso_session_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_dso_session_log_s_log, OS_LOG_TYPE_DEBUG))
  {
    v21 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 40);
    v22 = nw_connection_state_to_string(a2);
    v23 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 80);
    *(_DWORD *)v27 = 134218754;
    *(_QWORD *)&v27[4] = v21;
    *(_WORD *)&v27[12] = 2082;
    *(_QWORD *)&v27[14] = v22;
    v28 = 2112;
    v29 = v23;
    v30 = 2048;
    v31 = (int)error_code;
    _os_log_debug_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "[DSO%llu] DSO session connection state change -- state: %{public}s, connection: %@, error: %{mdns:err}ld", v27, 0x2Au);
  }
  switch((int)a2)
  {
    case 0:
    case 1:
    case 2:
      return;
    case 3:
      v8 = nw_connection_copy_connected_local_endpoint(*(_QWORD *)(a1 + 40));
      v9 = nw_connection_copy_connected_remote_endpoint(*(_QWORD *)(a1 + 40));
      if (_mdns_dso_session_log_s_once == -1)
        goto LABEL_15;
      break;
    case 4:
      if ((_DWORD)error_code != 54)
        goto LABEL_42;
      if (_mdns_dso_session_log_s_once != -1)
        dispatch_once(&_mdns_dso_session_log_s_once, &__block_literal_global_5946);
      v20 = _mdns_dso_session_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_dso_session_log_s_log, OS_LOG_TYPE_ERROR))
      {
        v24 = *(_QWORD *)(a1 + 32);
        v25 = *(_QWORD *)(v24 + 40);
        v26 = *(_QWORD *)(v24 + 80);
        *(_DWORD *)v27 = 134218242;
        *(_QWORD *)&v27[4] = v25;
        *(_WORD *)&v27[12] = 2112;
        *(_QWORD *)&v27[14] = v26;
        _os_log_error_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "[DSO%llu] DSO session is forcibly aborted by the other side -- %@", v27, 0x16u);
      }
      error_code = 54;
      goto LABEL_43;
    case 5:
      goto LABEL_3;
    default:
      error_code = 4294960587;
      goto LABEL_43;
  }
  while (1)
  {
    dispatch_once(&_mdns_dso_session_log_s_once, &__block_literal_global_5946);
LABEL_15:
    isa = isa[351].isa;
    if (os_log_type_enabled(isa, OS_LOG_TYPE_DEFAULT))
    {
      v10 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 40);
      *(_DWORD *)v27 = 134218498;
      *(_QWORD *)&v27[4] = v10;
      *(_WORD *)&v27[12] = 2112;
      *(_QWORD *)&v27[14] = v8;
      v28 = 2112;
      v29 = v9;
      _os_log_impl((void *)&_mh_execute_header, isa, OS_LOG_TYPE_DEFAULT, "[DSO%llu] Start connection -> Connection ready -- %@ <---> %@", v27, 0x20u);
    }
    if (v8)
      nw_release(v8);
    if (v9)
      nw_release((void *)v9);
    v9 = *(_QWORD *)(a1 + 32);
    v11 = *(void **)(v9 + 88);
    if (v11)
    {
      free(v11);
      *(_QWORD *)(v9 + 88) = 0;
    }
    v12 = nw_connection_copy_endpoint(*(nw_connection_t *)(v9 + 80));
    if (v12)
    {
      v8 = v12;
      hostname = nw_endpoint_get_hostname(v12);
      if (!hostname)
        goto LABEL_44;
      v14 = strdup(hostname);
      if (!v14)
        goto LABEL_44;
      *(_QWORD *)(v9 + 88) = v14;
      nw_release(v8);
    }
    *(_DWORD *)(v9 + 112) = 0;
    v15 = nw_connection_copy_current_path(*(nw_connection_t *)(v9 + 80));
    if (v15)
    {
      v8 = v15;
      *(_DWORD *)(v9 + 112) = nw_path_get_interface_index();
      nw_release(v8);
    }
    v16 = *(void **)(v9 + 96);
    if (v16)
    {
      free(v16);
      *(_QWORD *)(v9 + 96) = 0;
    }
    v17 = *(_DWORD *)(v9 + 112);
    if (!v17)
      goto LABEL_35;
    memset(v27, 0, 17);
    v18 = if_indextoname(v17, v27);
    if (!v18)
      goto LABEL_35;
    v19 = strdup(v18);
    if (v19)
      break;
LABEL_44:
    __break(1u);
  }
  *(_QWORD *)(v9 + 96) = v19;
LABEL_35:
  (*(void (**)(uint64_t))(*(_QWORD *)(v9 + 16) + 80))(v9);
  error_code = (*(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16) + 88))();
LABEL_42:
  if ((_DWORD)error_code)
  {
LABEL_43:
    _mdns_dso_session_handle_failure(*(_QWORD *)(a1 + 32), error_code, 1, 1);
LABEL_2:
    if ((_DWORD)a2 == 5)
    {
LABEL_3:
      os_release(*(void **)(a1 + 32));
      nw_release(*(void **)(a1 + 40));
    }
  }
}

void ___mdns_dso_session_schedule_receive_block_invoke(uint64_t a1, NSObject *a2, nw_content_context_t context, uint64_t a4, uint64_t a5)
{
  uint64_t error_code;
  _BOOL4 is_final;
  _BOOL4 v9;
  void (*v10)(void);
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  NSObject *v14;
  uint32_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  _BYTE *v19;
  _QWORD *v20;
  _UNKNOWN **v21;
  NSObject *v22;
  uint64_t v23;
  size_t v24;
  void *v25;
  uint64_t v26;
  int v27;
  void *v28;
  NSObject *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  void (*v34)(_QWORD);
  NSObject *v35;
  _UNKNOWN **v36;
  NSObject *v37;
  uint64_t v38;
  size_t size;
  void *v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  char v44;
  char v45;
  _BYTE buf[24];
  void *v47;
  __int128 v48;
  NSObject *v49;

  if (!*(_QWORD *)(*(_QWORD *)(a1 + 32) + 80))
    return;
  error_code = a5;
  v44 = 0;
  if (context)
  {
    is_final = nw_content_context_get_is_final(context);
    if (!error_code)
      goto LABEL_5;
    goto LABEL_4;
  }
  is_final = 0;
  if (a5)
LABEL_4:
    error_code = nw_error_get_error_code((nw_error_t)error_code);
LABEL_5:
  if ((_DWORD)error_code)
    v9 = 0;
  else
    v9 = is_final;
  if (v9)
  {
    v10 = *(void (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16) + 160);
    if (v10)
      v10();
    v44 = 1;
    if (_mdns_dso_session_log_s_once != -1)
      dispatch_once(&_mdns_dso_session_log_s_once, &__block_literal_global_5946);
    v11 = _mdns_dso_session_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dso_session_log_s_log, OS_LOG_TYPE_ERROR))
    {
      v12 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 40);
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = v12;
      v13 = "[DSO%llu] DSO session is gracefully closed by the other side.";
      v14 = v11;
      v15 = 12;
      goto LABEL_58;
    }
  }
  else if ((_DWORD)error_code == 61 || (_DWORD)error_code == 54)
  {
    if (_mdns_dso_session_log_s_once != -1)
      dispatch_once(&_mdns_dso_session_log_s_once, &__block_literal_global_5946);
    v16 = _mdns_dso_session_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dso_session_log_s_log, OS_LOG_TYPE_ERROR))
    {
      v43 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 40);
      *(_DWORD *)buf = 134218240;
      *(_QWORD *)&buf[4] = v43;
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = error_code;
      v13 = "[DSO%llu] DSO session is forcibly aborted by the other side -- error: %{mdns:err}ld";
      v14 = v16;
      v15 = 22;
LABEL_58:
      _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, v13, buf, v15);
      if (!a2)
        goto LABEL_39;
LABEL_21:
      if (dispatch_data_get_size(a2))
      {
        v17 = (*(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16) + 96))();
        v18 = *(_QWORD *)(a1 + 32);
        if (!v17)
        {
          error_code = 4294960587;
          goto LABEL_40;
        }
        v19 = mdns_message_create_with_dispatch_data(a2, 1);
        if (!v19)
        {
          v18 = *(_QWORD *)(a1 + 32);
          error_code = 4294960567;
          goto LABEL_40;
        }
        v20 = v19;
        v21 = (_UNKNOWN **)*((_QWORD *)v19 + 2);
        if (!v21)
          goto LABEL_31;
        while (v21 != &_mdns_dso_message_kind)
        {
          v21 = (_UNKNOWN **)*v21;
          if (!v21)
            goto LABEL_31;
        }
        if (!(*(unsigned int (**)(uint64_t, _BYTE *))(*(_QWORD *)(v18 + 16) + 120))(v18, v19))
        {
          v45 = 0;
          v36 = (_UNKNOWN **)v20[2];
          if (v36)
          {
            while (v36 != &_mdns_dso_message_kind)
            {
              v36 = (_UNKNOWN **)*v36;
              if (!v36)
                goto LABEL_51;
            }
            error_code = (*(uint64_t (**)(uint64_t, _QWORD *, char *, char *))(*(_QWORD *)(v18 + 16) + 128))(v18, v20, &v44, &v45);
            if (!v45)
            {
              if (_mdns_dso_session_log_s_once != -1)
                dispatch_once(&_mdns_dso_session_log_s_once, &__block_literal_global_5946);
              v37 = _mdns_dso_session_log_s_log;
              if (os_log_type_enabled((os_log_t)_mdns_dso_session_log_s_log, OS_LOG_TYPE_DEFAULT))
              {
                v38 = *(_QWORD *)(v18 + 40);
                size = dispatch_data_get_size(a2);
                v40 = *(void **)(v18 + 88);
                v41 = *(_QWORD *)(v18 + 96);
                v42 = *(_DWORD *)(v18 + 112);
                *(_DWORD *)buf = 134219010;
                *(_QWORD *)&buf[4] = v38;
                *(_WORD *)&buf[12] = 2048;
                *(_QWORD *)&buf[14] = size;
                *(_WORD *)&buf[22] = 2082;
                v47 = v40;
                LOWORD(v48) = 2082;
                *(_QWORD *)((char *)&v48 + 2) = v41;
                WORD5(v48) = 1024;
                HIDWORD(v48) = v42;
                _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "[DSO%llu] Received %zu-byte session DSO message from %{public}s over DSO session via %{public}s/%u", buf, 0x30u);
              }
            }
          }
          else
          {
LABEL_51:
            error_code = 4294960560;
          }
        }
        else
        {
LABEL_31:
          if (_mdns_dso_session_log_s_once != -1)
            dispatch_once(&_mdns_dso_session_log_s_once, &__block_literal_global_5946);
          v22 = _mdns_dso_session_log_s_log;
          if (os_log_type_enabled((os_log_t)_mdns_dso_session_log_s_log, OS_LOG_TYPE_DEFAULT))
          {
            v23 = *(_QWORD *)(v18 + 40);
            v24 = dispatch_data_get_size(a2);
            v25 = *(void **)(v18 + 88);
            v26 = *(_QWORD *)(v18 + 96);
            v27 = *(_DWORD *)(v18 + 112);
            *(_DWORD *)buf = 134219010;
            *(_QWORD *)&buf[4] = v23;
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v24;
            *(_WORD *)&buf[22] = 2082;
            v47 = v25;
            LOWORD(v48) = 2082;
            *(_QWORD *)((char *)&v48 + 2) = v26;
            WORD5(v48) = 1024;
            HIDWORD(v48) = v27;
            _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "[DSO%llu] Received %zu-byte user DSO message from %{public}s over DSO session via %{public}s/%u", buf, 0x30u);
          }
          if (*(_QWORD *)(v18 + 64))
          {
            os_retain((void *)v18);
            dispatch_retain(a2);
            v28 = _Block_copy(*(const void **)(v18 + 64));
            v29 = *(NSObject **)(v18 + 48);
            *(_QWORD *)buf = _NSConcreteStackBlock;
            *(_QWORD *)&buf[8] = 0x40000000;
            *(_QWORD *)&buf[16] = ___mdns_dso_session_schedule_user_receive_block_invoke;
            v47 = &unk_10013E420;
            *(_QWORD *)&v48 = v28;
            *((_QWORD *)&v48 + 1) = v18;
            v49 = a2;
            dispatch_async(v29, buf);
          }
          error_code = 0;
        }
        os_release(v20);
      }
      goto LABEL_39;
    }
  }
  if (a2)
    goto LABEL_21;
LABEL_39:
  v18 = *(_QWORD *)(a1 + 32);
  if ((_DWORD)error_code)
  {
LABEL_40:
    v30 = v18;
    v31 = error_code;
    v32 = 1;
    v33 = 1;
LABEL_43:
    _mdns_dso_session_handle_failure(v30, v31, v32, v33);
    return;
  }
  if (v44)
  {
    v30 = *(_QWORD *)(a1 + 32);
    v31 = 0;
    v32 = 0;
    v33 = 0;
    goto LABEL_43;
  }
  v34 = *(void (**)(_QWORD))(*(_QWORD *)(v18 + 16) + 136);
  if (v34)
  {
    v34(*(_QWORD *)(a1 + 32));
    v18 = *(_QWORD *)(a1 + 32);
  }
  v35 = *(NSObject **)(v18 + 80);
  *(_QWORD *)buf = _NSConcreteStackBlock;
  *(_QWORD *)&buf[8] = 0x40000000;
  *(_QWORD *)&buf[16] = ___mdns_dso_session_schedule_receive_block_invoke;
  v47 = &__block_descriptor_tmp_17_5955;
  *(_QWORD *)&v48 = v18;
  nw_connection_receive_message(v35, buf);
}

void ___mdns_dso_session_schedule_user_receive_block_invoke(uint64_t a1)
{
  NSObject *v2;
  const void *v3;

  if ((*(unsigned int (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 16) + 104))())
    (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  os_release(*(void **)(a1 + 40));
  v2 = *(NSObject **)(a1 + 48);
  if (v2)
    dispatch_release(v2);
  v3 = *(const void **)(a1 + 32);
  if (v3)
    _Block_release(v3);
}

void ___mdns_dso_session_log_block_invoke(id a1)
{
  _mdns_dso_session_log_s_log = (uint64_t)os_log_create("com.apple.mdns", "dso_session");
}

uint64_t _mdns_dso_client_session_schedule_keepalive_message(uint64_t a1)
{
  NSObject *v2;
  unsigned int v3;
  NSObject *monotonic_timer;
  _QWORD handler[5];

  if (*(_BYTE *)(a1 + 214) != 7)
    return 4294960587;
  v2 = *(NSObject **)(a1 + 192);
  if (v2)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 192));
    dispatch_release(v2);
    *(_QWORD *)(a1 + 192) = 0;
  }
  v3 = *(_DWORD *)(a1 + 132);
  if (v3 == -1)
    return 0;
  if (_mdns_dso_session_queue_s_once != -1)
    dispatch_once(&_mdns_dso_session_queue_s_once, &__block_literal_global_66);
  monotonic_timer = _mdns_dispatch_create_monotonic_timer(v3, 0xFFFFFFFFFFFFFFFFLL, 5u, _mdns_dso_session_queue_s_queue);
  *(_QWORD *)(a1 + 192) = monotonic_timer;
  if (monotonic_timer)
  {
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 0x40000000;
    handler[2] = ___mdns_dso_client_session_schedule_keepalive_message_block_invoke;
    handler[3] = &__block_descriptor_tmp_30_5971;
    handler[4] = a1;
    dispatch_source_set_event_handler(monotonic_timer, handler);
    dispatch_activate(*(dispatch_object_t *)(a1 + 192));
    return 0;
  }
  return 4294960567;
}

void ___mdns_dso_client_session_schedule_keepalive_message_block_invoke(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  NSObject *v4;
  uint64_t keepalive_message;
  void *v6;
  uint64_t v7;
  int v8;
  uint64_t v9;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(NSObject **)(v2 + 192);
  if (v3)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(v2 + 192));
    dispatch_release(v3);
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 192) = 0;
    v2 = *(_QWORD *)(a1 + 32);
  }
  if (*(_BYTE *)(v2 + 214) == 7)
  {
    if (_mdns_dso_session_log_s_once != -1)
      dispatch_once(&_mdns_dso_session_log_s_once, &__block_literal_global_5946);
    v4 = _mdns_dso_session_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dso_session_log_s_log, OS_LOG_TYPE_DEBUG))
    {
      v7 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 40);
      v8 = 134217984;
      v9 = v7;
      _os_log_debug_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "[DSO%llu] Sending keepalive message", (uint8_t *)&v8, 0xCu);
    }
    keepalive_message = _mdns_dso_session_create_keepalive_message(*(_QWORD *)(a1 + 32), *(_WORD *)(*(_QWORD *)(a1 + 32) + 212));
    if (keepalive_message)
    {
      v6 = (void *)keepalive_message;
      _mdns_dso_session_send_data_immediately(*(_QWORD *)(a1 + 32), *(dispatch_data_t *)(keepalive_message + 24), 1, 1);
      os_release(v6);
    }
  }
}

uint64_t _mdns_dso_session_create_keepalive_message(uint64_t a1, __int16 a2)
{
  uint64_t result;
  uint64_t v5;
  _UNKNOWN **v6;
  void (*v7)(uint64_t);
  _BYTE *message;

  result = _os_object_alloc(OS_mdns_dso_keepalive_message_builder, 40);
  if (result)
  {
    v5 = result;
    v6 = &_mdns_dso_keepalive_message_builder_kind;
    *(_QWORD *)(result + 16) = &_mdns_dso_keepalive_message_builder_kind;
    do
    {
      v7 = (void (*)(uint64_t))v6[2];
      if (v7)
        v7(v5);
      v6 = (_UNKNOWN **)*v6;
    }
    while (v6);
    *(_WORD *)(v5 + 28) = a2;
    *(_QWORD *)(v5 + 32) = *(_QWORD *)(a1 + 116);
    message = mdns_dso_message_builder_create_message(v5);
    os_release((void *)v5);
    return (uint64_t)message;
  }
  return result;
}

void _mdns_dso_session_send_data_immediately(uint64_t a1, dispatch_data_t data, char a3, char a4)
{
  NSObject *v7;
  _QWORD v8[7];
  char v9;
  char v10;

  v7 = *(NSObject **)(a1 + 80);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = ___mdns_dso_session_send_data_immediately_block_invoke;
  v8[3] = &__block_descriptor_tmp_32_5973;
  v8[4] = a1;
  v8[5] = v7;
  v8[6] = dispatch_data_get_size(data);
  v9 = a4;
  v10 = a3;
  nw_connection_send(v7, data, _nw_content_context_default_message, 1, v8);
}

void ___mdns_dso_session_send_data_immediately_block_invoke(uint64_t a1, nw_error_t error)
{
  _QWORD *v2;
  uint64_t error_code;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  int v33;
  __int16 v34;
  uint64_t v35;

  v2 = *(_QWORD **)(a1 + 32);
  if (v2[10] != *(_QWORD *)(a1 + 40))
    return;
  if (error)
  {
    error_code = nw_error_get_error_code(error);
    if ((_DWORD)error_code)
    {
      v5 = error_code;
      if (_mdns_dso_session_log_s_once != -1)
        dispatch_once(&_mdns_dso_session_log_s_once, &__block_literal_global_5946);
      v6 = _mdns_dso_session_log_s_log;
      if (os_log_type_enabled((os_log_t)_mdns_dso_session_log_s_log, OS_LOG_TYPE_ERROR))
      {
        v19 = *(_QWORD *)(a1 + 32);
        v20 = *(_QWORD *)(v19 + 40);
        v21 = *(_QWORD *)(a1 + 48);
        v22 = *(_QWORD *)(v19 + 88);
        v23 = *(_QWORD *)(v19 + 96);
        LODWORD(v19) = *(_DWORD *)(v19 + 112);
        v24 = 134219266;
        v25 = v20;
        v26 = 2048;
        v27 = v21;
        v28 = 2082;
        v29 = v22;
        v30 = 2082;
        v31 = v23;
        v32 = 1024;
        v33 = v19;
        v34 = 2048;
        v35 = (int)v5;
        _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "[DSO%llu] Failed to send %zu-byte DSO message to %{public}s over DSO session via %{public}s/%u -- error: %{mdns:err}ld", (uint8_t *)&v24, 0x3Au);
      }
      _mdns_dso_session_handle_failure(*(_QWORD *)(a1 + 32), v5, 1, 1);
      return;
    }
  }
  else if ((*(unsigned int (**)(_QWORD))(v2[2] + 104))(*(_QWORD *)(a1 + 32)) && !v2[13])
  {
    _mdns_dso_session_schedule_inactivity_timer_ex(*(_QWORD **)(a1 + 32), 0);
  }
  if (*(_BYTE *)(a1 + 56))
    return;
  if (*(_BYTE *)(a1 + 57))
  {
    if (_mdns_dso_session_log_s_once != -1)
      dispatch_once(&_mdns_dso_session_log_s_once, &__block_literal_global_5946);
    v7 = _mdns_dso_session_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dso_session_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      v8 = *(_QWORD *)(a1 + 32);
      v9 = *(_QWORD *)(v8 + 40);
      v10 = *(_QWORD *)(a1 + 48);
      v11 = *(_QWORD *)(v8 + 88);
      v12 = *(_QWORD *)(v8 + 96);
      LODWORD(v8) = *(_DWORD *)(v8 + 112);
      v24 = 134219010;
      v25 = v9;
      v26 = 2048;
      v27 = v10;
      v28 = 2082;
      v29 = v11;
      v30 = 2082;
      v31 = v12;
      v32 = 1024;
      v33 = v8;
      v13 = "[DSO%llu] Sent %zu-byte user DSO message to %{public}s over DSO session via %{public}s/%u";
LABEL_23:
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v13, (uint8_t *)&v24, 0x30u);
    }
  }
  else
  {
    if (_mdns_dso_session_log_s_once != -1)
      dispatch_once(&_mdns_dso_session_log_s_once, &__block_literal_global_5946);
    v7 = _mdns_dso_session_log_s_log;
    if (os_log_type_enabled((os_log_t)_mdns_dso_session_log_s_log, OS_LOG_TYPE_DEFAULT))
    {
      v14 = *(_QWORD *)(a1 + 32);
      v15 = *(_QWORD *)(v14 + 40);
      v16 = *(_QWORD *)(a1 + 48);
      v17 = *(_QWORD *)(v14 + 88);
      v18 = *(_QWORD *)(v14 + 96);
      LODWORD(v14) = *(_DWORD *)(v14 + 112);
      v24 = 134219010;
      v25 = v15;
      v26 = 2048;
      v27 = v16;
      v28 = 2082;
      v29 = v17;
      v30 = 2082;
      v31 = v18;
      v32 = 1024;
      v33 = v14;
      v13 = "[DSO%llu] Sent %zu-byte session DSO message to %{public}s over DSO session via %{public}s/%u";
      goto LABEL_23;
    }
  }
}

uint64_t _mdns_dso_session_schedule_inactivity_timer_ex(_QWORD *a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;

  if (!(*(unsigned int (**)(void))(a1[2] + 104))() || a1[13])
    return 4294960587;
  _mdns_dso_session_stop_inactivity_timer((uint64_t)a1);
  result = (*(uint64_t (**)(_QWORD *, uint64_t))(a1[2] + 112))(a1, a2);
  if (!(_DWORD)result)
  {
    result = a1[9];
    if (result)
    {
      dispatch_activate((dispatch_object_t)result);
      v5 = mach_continuous_time();
      result = 0;
      a1[4] = v5;
    }
  }
  return result;
}

uint64_t _mdns_dso_client_session_accept_keepalive_message(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  _UNKNOWN **v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  int64_t v15;
  unint64_t v16;
  NSObject *v17;

  v5 = *(_UNKNOWN ***)(a2 + 16);
  if (v5)
  {
    v6 = a2;
    while (v5 != (_UNKNOWN **)&_mdns_dso_keepalive_message_kind)
    {
      v5 = (_UNKNOWN **)*v5;
      if (!v5)
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    v6 = 0;
  }
  v7 = *(_QWORD *)(v6 + 32);
  if (*(_QWORD *)(v6 + 40) - 16 >= __rev16(*(unsigned __int16 *)(v7 + 14)))
    v8 = (unsigned int *)(v7 + 16);
  else
    v8 = 0;
  v9 = bswap32(*v8);
  if (v9 <= 0x1388)
    v10 = 5000;
  else
    v10 = v9;
  *(_DWORD *)(a1 + 128) = v10;
  if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)(a1 + 16) + 104))(a1) || *(_QWORD *)(a1 + 104))
    goto LABEL_14;
  if (!*(_QWORD *)(a1 + 72))
    return 4294960587;
  v15 = mach_continuous_time() - *(_QWORD *)(a1 + 32);
  if (v15 < 0)
    return 4294960587;
  v16 = mdns_ticks_to_milliseconds(v15);
  v17 = *(NSObject **)(a1 + 72);
  if (v17)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 72));
    dispatch_release(v17);
    *(_QWORD *)(a1 + 72) = 0;
  }
  if (v16 >= v10)
  {
    if (a3)
      *a3 = 1;
    goto LABEL_14;
  }
  if (a3)
    *a3 = 0;
  result = _mdns_dso_session_schedule_inactivity_timer_ex((_QWORD *)a1, v10 - v16);
  if (!(_DWORD)result)
  {
LABEL_14:
    result = 0;
    v12 = *(_QWORD *)(v6 + 32);
    v13 = v12 + 16;
    if (*(_QWORD *)(v6 + 40) - 16 < __rev16(*(unsigned __int16 *)(v12 + 14)))
      v13 = 0;
    v14 = bswap32(*(_DWORD *)(v13 + 4));
    if (v14 <= 0x2710)
      v14 = 10000;
    *(_DWORD *)(a1 + 132) = v14;
  }
  return result;
}

void ___mdns_dso_client_session_set_up_inactivity_timer_ex_block_invoke(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  __int16 v8;
  int v9;

  if (_mdns_dso_session_log_s_once != -1)
    dispatch_once(&_mdns_dso_session_log_s_once, &__block_literal_global_5946);
  v2 = _mdns_dso_session_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_dso_session_log_s_log, OS_LOG_TYPE_DEFAULT))
  {
    v3 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 40);
    v4 = *(_DWORD *)(a1 + 40);
    v6 = 134218240;
    v7 = v3;
    v8 = 1024;
    v9 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "[DSO%llu] Hit inactivity timeout, closing the idle session -- inactivity timeout: %ums", (uint8_t *)&v6, 0x12u);
  }
  _mdns_dso_session_stop_inactivity_timer(*(_QWORD *)(a1 + 32));
  v5 = *(_QWORD *)(a1 + 32);
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)(v5 + 16) + 104))(v5))
  {
    if (!*(_QWORD *)(v5 + 104))
      _mdns_dso_session_handle_failure(*(_QWORD *)(a1 + 32), 0, 0, 0);
  }
}

void ___mdns_dso_client_session_prepare_session_block_invoke(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(NSObject **)(v2 + 192);
  if (v3)
  {
    dispatch_source_cancel(*(dispatch_source_t *)(v2 + 192));
    dispatch_release(v3);
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 192) = 0;
    v2 = *(_QWORD *)(a1 + 32);
  }
  if (*(_BYTE *)(v2 + 214) == 6)
    _mdns_dso_session_handle_failure(v2, 4294960574, 1, 1);
}

void ___mdns_dso_session_create_tls_nw_parameters_block_invoke(uint64_t a1, nw_protocol_options_t options)
{
  NSObject *v3;
  uint64_t v4;
  _QWORD *v5;
  NSObject *v6;
  _QWORD v7[6];

  v3 = nw_tls_copy_sec_protocol_options(options);
  v4 = *(_QWORD *)(a1 + 32);
  v5 = *(_QWORD **)(v4 + 56);
  if (v5)
  {
    v6 = *(NSObject **)(v4 + 48);
  }
  else
  {
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 0x40000000;
    v7[2] = ___mdns_dso_session_create_tls_nw_parameters_block_invoke_2;
    v7[3] = &__block_descriptor_tmp_24_5987;
    v7[4] = *(_QWORD *)(a1 + 40);
    v7[5] = v4;
    if (_mdns_dso_session_queue_s_once != -1)
      dispatch_once(&_mdns_dso_session_queue_s_once, &__block_literal_global_66);
    v6 = _mdns_dso_session_queue_s_queue;
    v5 = v7;
  }
  sec_protocol_options_set_verify_block(v3, v5, v6);
  if (v3)
    sec_release(v3);
}

uint64_t ___mdns_dso_session_create_tls_nw_parameters_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t (*v5)(_QWORD, uint64_t, uint64_t, _QWORD);
  uint64_t v6;

  v5 = *(uint64_t (**)(_QWORD, uint64_t, uint64_t, _QWORD))(*(_QWORD *)(a1 + 32) + 72);
  if (v5)
    v6 = v5(*(_QWORD *)(a1 + 40), a2, a3, 0);
  else
    v6 = 0;
  return (*(uint64_t (**)(uint64_t, uint64_t))(a4 + 16))(a4, v6);
}

nw_endpoint_t ___mdns_dso_client_session_start_connection_with_server_addresses_block_invoke(uint64_t a1, uint64_t a2)
{
  _OWORD *v3;
  int v4;
  nw_endpoint_t result;
  void *v6;
  _BYTE v7[28];

  *(_DWORD *)&v7[24] = 0;
  *(_QWORD *)&v7[16] = 0;
  v3 = (_OWORD *)(a2 + 24);
  v4 = *(unsigned __int8 *)(a2 + 25);
  if (v4 == 30)
  {
    *(_OWORD *)v7 = *v3;
    *(_OWORD *)&v7[12] = *(_OWORD *)(a2 + 36);
  }
  else
  {
    result = 0;
    if (v4 != 2)
      return result;
    *(_OWORD *)v7 = *v3;
  }
  if (!*(_WORD *)&v7[2])
    *(_WORD *)&v7[2] = 21763;
  result = nw_endpoint_create_address((const sockaddr *)v7);
  if (result)
  {
    v6 = result;
    nw_array_append(*(_QWORD *)(a1 + 32), result);
    nw_release(v6);
    return (nw_endpoint_t)1;
  }
  return result;
}

uint64_t _mdns_dso_client_session_add_nw_endpoints(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  _UNKNOWN **v6;
  void (*v7)(_QWORD *);
  CFMutableArrayRef Mutable;
  int v9;
  uint64_t v10;
  _QWORD block[5];
  _QWORD v13[6];
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  int v17;

  v14 = 0;
  v15 = &v14;
  v16 = 0x2000000000;
  v17 = 0;
  v4 = _os_object_alloc(OS_mdns_dso_server_endpoint_manager, 32);
  if (v4)
  {
    v5 = (_QWORD *)v4;
    v6 = &_mdns_dso_server_endpoint_manager_kind;
    *(_QWORD *)(v4 + 16) = &_mdns_dso_server_endpoint_manager_kind;
    do
    {
      v7 = (void (*)(_QWORD *))v6[2];
      if (v7)
        v7(v5);
      v6 = (_UNKNOWN **)*v6;
    }
    while (v6);
    Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, (const CFArrayCallBacks *)&mdns_cfarray_callbacks);
    v5[3] = Mutable;
    if (Mutable)
      v9 = 0;
    else
      v9 = -6729;
    if (!Mutable)
      v5 = 0;
    v17 = v9;
    v10 = *((unsigned int *)v15 + 6);
    if ((_DWORD)v10)
    {
      if (Mutable)
      {
        os_release(v5);
        v10 = *((unsigned int *)v15 + 6);
      }
      goto LABEL_19;
    }
  }
  else
  {
    v17 = -6728;
    v10 = *((unsigned int *)v15 + 6);
    if ((_DWORD)v10)
      goto LABEL_19;
    v5 = 0;
  }
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 0x40000000;
  v13[2] = ___mdns_dso_client_session_add_nw_endpoints_block_invoke;
  v13[3] = &unk_10013E398;
  v13[4] = &v14;
  v13[5] = v5;
  nw_array_apply(a2, v13);
  *(_QWORD *)(a1 + 168) = v5;
  *(_BYTE *)(a1 + 214) = 3;
  os_retain((void *)a1);
  if (_mdns_dso_session_queue_s_once != -1)
    dispatch_once(&_mdns_dso_session_queue_s_once, &__block_literal_global_66);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = ___mdns_dso_client_session_add_nw_endpoints_block_invoke_2;
  block[3] = &__block_descriptor_tmp_13_5997;
  block[4] = a1;
  dispatch_async((dispatch_queue_t)_mdns_dso_session_queue_s_queue, block);
  v10 = 0;
  *((_DWORD *)v15 + 6) = 0;
LABEL_19:
  _Block_object_dispose(&v14, 8);
  return v10;
}

void ___mdns_dso_client_session_start_srv_resolution_block_invoke(uint64_t a1)
{
  nw_release(*(void **)(a1 + 32));
}

void ___mdns_dso_client_session_start_srv_resolution_block_invoke_2(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t srv_weighted_variant;
  void *v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  void *v11;
  int v12;
  uint64_t v13;
  __int16 v14;
  uint64_t v15;

  if (a2 == 2)
  {
    if (!a3)
    {
      v8 = 4294960569;
LABEL_16:
      _mdns_dso_session_handle_failure(*(_QWORD *)(a1 + 32), v8, 1, 0);
      return;
    }
    v5 = *(_QWORD *)(a1 + 32);
    if (*(_BYTE *)(v5 + 214) == 2)
    {
      srv_weighted_variant = nw_resolver_create_srv_weighted_variant(a3);
      if (srv_weighted_variant)
      {
        v7 = (void *)srv_weighted_variant;
        v8 = _mdns_dso_client_session_add_nw_endpoints(v5, srv_weighted_variant);
        if (_mdns_dso_session_log_s_once != -1)
          dispatch_once(&_mdns_dso_session_log_s_once, &__block_literal_global_5946);
        v9 = _mdns_dso_session_log_s_log;
        if (os_log_type_enabled((os_log_t)_mdns_dso_session_log_s_log, OS_LOG_TYPE_DEFAULT))
        {
          v10 = *(_QWORD *)(v5 + 40);
          v12 = 134218242;
          v13 = v10;
          v14 = 2112;
          v15 = a3;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "[DSO%llu] Start SRV resolution -> SRV resolution finished -- endpoints: %@", (uint8_t *)&v12, 0x16u);
        }
        nw_release(v7);
      }
      else
      {
        v8 = 4294960567;
      }
    }
    else
    {
      v8 = 4294960587;
    }
    nw_resolver_cancel(*(_QWORD *)(v5 + 144));
    v11 = *(void **)(v5 + 144);
    if (v11)
    {
      nw_release(v11);
      *(_QWORD *)(v5 + 144) = 0;
    }
    if ((_DWORD)v8)
      goto LABEL_16;
  }
}

BOOL ___mdns_dso_client_session_add_nw_endpoints_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  _UNKNOWN **v8;
  void (*v9)(_QWORD *);
  int v10;

  v5 = *(_QWORD *)(a1 + 40);
  v6 = _os_object_alloc(OS_mdns_dso_server_endpoint, 48);
  if (v6)
  {
    v7 = (_QWORD *)v6;
    v8 = &_mdns_dso_server_endpoint_kind;
    *(_QWORD *)(v6 + 16) = &_mdns_dso_server_endpoint_kind;
    do
    {
      v9 = (void (*)(_QWORD *))v8[2];
      if (v9)
        v9(v7);
      v8 = (_UNKNOWN **)*v8;
    }
    while (v8);
    v7[3] = nw_retain(a3);
    CFArrayAppendValue(*(CFMutableArrayRef *)(v5 + 24), v7);
    os_release(v7);
    v10 = 0;
  }
  else
  {
    v10 = -6728;
  }
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v10;
  return *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) == 0;
}

void ___mdns_dso_client_session_add_nw_endpoints_block_invoke_2(uint64_t a1)
{
  _BYTE *v2;

  v2 = *(_BYTE **)(a1 + 32);
  if (v2[214] == 3)
  {
    _mdns_dso_client_session_connect_or_delay_reconnecting((uint64_t)v2);
    v2 = *(_BYTE **)(a1 + 32);
  }
  os_release(v2);
}

void __mdns_dso_session_add_activity_block_invoke(uint64_t a1)
{
  uint64_t v2;

  if ((*(unsigned int (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16) + 104))())
  {
    v2 = *(_QWORD *)(a1 + 32);
    ++*(_QWORD *)(v2 + 104);
    _mdns_dso_session_stop_inactivity_timer(v2);
    os_release(*(void **)(a1 + 32));
  }
}

void __mdns_dso_session_remove_activity_block_invoke(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  if ((*(unsigned int (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16) + 104))())
  {
    v2 = *(_QWORD *)(a1 + 32);
    v3 = *(_QWORD *)(v2 + 104);
    if (v3)
    {
      *(_QWORD *)(v2 + 104) = v3 - 1;
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)(v2 + 16) + 104))(v2))
      {
        if (!*(_QWORD *)(v2 + 104))
          _mdns_dso_session_schedule_inactivity_timer_ex(*(_QWORD **)(a1 + 32), 0);
      }
    }
    os_release(*(void **)(a1 + 32));
  }
}

void mdns_dso_session_send(_QWORD *a1, NSObject *a2)
{
  _QWORD v4[6];

  if ((*(unsigned int (**)(void))(a1[2] + 104))())
  {
    os_retain(a1);
    dispatch_retain(a2);
    if (_mdns_dso_session_queue_s_once != -1)
      dispatch_once(&_mdns_dso_session_queue_s_once, &__block_literal_global_66);
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 0x40000000;
    v4[2] = __mdns_dso_session_send_block_invoke;
    v4[3] = &__block_descriptor_tmp_5_6007;
    v4[4] = a1;
    v4[5] = a2;
    dispatch_async((dispatch_queue_t)_mdns_dso_session_queue_s_queue, v4);
  }
}

void __mdns_dso_session_send_block_invoke(uint64_t a1)
{
  int v2;
  _QWORD *v3;
  uint64_t (*v4)(void);
  uint64_t v5;
  NSObject *v6;

  v2 = (*(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16) + 104))();
  v3 = *(_QWORD **)(a1 + 32);
  if (v2)
  {
    _mdns_dso_session_send_data_immediately((uint64_t)v3, *(dispatch_data_t *)(a1 + 40), 1, 0);
    v3 = *(_QWORD **)(a1 + 32);
    v4 = *(uint64_t (**)(void))(v3[2] + 144);
    if (v4)
    {
      v5 = v4();
      v3 = *(_QWORD **)(a1 + 32);
      if ((_DWORD)v5)
      {
        _mdns_dso_session_handle_failure((uint64_t)v3, v5, 1, 1);
        v3 = *(_QWORD **)(a1 + 32);
      }
    }
  }
  os_release(v3);
  v6 = *(NSObject **)(a1 + 40);
  if (v6)
    dispatch_release(v6);
}

void mdns_dso_session_invalidate(void *a1)
{
  _QWORD block[5];

  os_retain(a1);
  if (_mdns_dso_session_queue_s_once != -1)
    dispatch_once(&_mdns_dso_session_queue_s_once, &__block_literal_global_66);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = __mdns_dso_session_invalidate_block_invoke;
  block[3] = &__block_descriptor_tmp_7_6009;
  block[4] = a1;
  dispatch_async((dispatch_queue_t)_mdns_dso_session_queue_s_queue, block);
}

void __mdns_dso_session_invalidate_block_invoke(uint64_t a1)
{
  _QWORD *v2;
  const void *v3;
  const void *v4;
  uint64_t v5;
  uint64_t monotonic_time_ns;
  unint64_t v7;
  int64_t v8;
  NSObject *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  __int16 v13;
  unint64_t v14;
  __int16 v15;
  unint64_t v16;

  if ((*(unsigned int (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16) + 184))())
  {
    _mdns_dso_session_close_internal(*(_QWORD *)(a1 + 32), 0, 0, 1, 0, 0);
    v2 = *(_QWORD **)(a1 + 32);
    v3 = (const void *)v2[7];
    if (v3)
    {
      _Block_release(v3);
      v2[7] = 0;
    }
    v4 = (const void *)v2[8];
    if (v4)
    {
      _Block_release(v4);
      v2[8] = 0;
    }
    (*(void (**)(_QWORD *))(v2[2] + 192))(v2);
  }
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 24);
  monotonic_time_ns = mdns_get_monotonic_time_ns();
  v7 = (monotonic_time_ns - v5) / 0xF4240uLL;
  if (__ROR8__(0x790FB65668C26139 * v7, 6) <= 0x10C6F7A0B5EDuLL)
    v8 = (monotonic_time_ns - v5) / 0xF4240uLL;
  else
    v8 = v7 + 1;
  if (_mdns_dso_session_log_s_once != -1)
    dispatch_once(&_mdns_dso_session_log_s_once, &__block_literal_global_5946);
  v9 = _mdns_dso_session_log_s_log;
  if (os_log_type_enabled((os_log_t)_mdns_dso_session_log_s_log, OS_LOG_TYPE_DEFAULT))
  {
    v10 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 40);
    v11 = 134218496;
    v12 = v10;
    v13 = 2048;
    v14 = (unint64_t)((unsigned __int128)(v8 * (__int128)0x20C49BA5E353F7CFLL) >> 64) >> 7;
    v15 = 2048;
    v16 = v8 - 1000 * v14;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "[DSO%llu] DSO session invalidated -- duration: %{mdns:time_duration}lld %lldms", (uint8_t *)&v11, 0x20u);
  }
  os_release(*(void **)(a1 + 32));
}

uint64_t dnssec_objs_sort(uint64_t result, unint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;

  v2 = a2 - 2;
  if (a2 >= 2)
  {
    v3 = result;
    v4 = 0;
    v5 = (_QWORD *)result;
    do
    {
      v6 = v4++;
      v7 = *(_QWORD *)(v3 + 8 * v4);
      result = ref_count_obj_compare(v7, *(_QWORD *)(v3 + 8 * v6), 0);
      v8 = v4;
      if ((_DWORD)result == -1)
      {
        v9 = v5;
        v8 = v4;
        do
        {
          v9[1] = *v9;
          if (!--v8)
            break;
          v10 = *--v9;
          result = ref_count_obj_compare(v7, v10, 0);
        }
        while ((_DWORD)result == -1);
      }
      *(_QWORD *)(v3 + 8 * v8) = v7;
      ++v5;
    }
    while (v6 != v2);
  }
  return result;
}

void __is_airplay_demo_mode_enabled_block_invoke(id a1)
{
  if (is_apple_internal_build_s_once != -1)
    dispatch_once(&is_apple_internal_build_s_once, &__block_literal_global_2_6036);
  if (is_apple_internal_build_is_internal)
    is_airplay_demo_mode_enabled_is_demo_mode_enabled = CFPreferencesGetAppBooleanValue(CFSTR("EnableTetheredDisplayPortMode"), kCFPreferencesAnyApplication, 0) != 0;
}

void __is_apple_internal_build_block_invoke(id a1)
{
  is_apple_internal_build_is_internal = os_variant_has_internal_diagnostics("com.apple.mDNSResponder");
}

id _system_util_log()
{
  if (_system_util_log_s_once != -1)
    dispatch_once(&_system_util_log_s_once, &__block_literal_global_10_6046);
  return (id)_system_util_log_s_log;
}

void ___system_util_log_block_invoke(id a1)
{
  os_log_t v1;
  void *v2;

  v1 = os_log_create("com.apple.mDNSResponder", "system_util");
  v2 = (void *)_system_util_log_s_log;
  _system_util_log_s_log = (uint64_t)v1;

}

uint64_t __util_device_media_access_unicast_addr_enumerate_block_invoke(uint64_t a1, int a2, uint64_t a3, int a4)
{
  uint64_t v6;
  void *v7;
  uint64_t v8;
  int v10;

  v10 = a4;
  if (a2 == 2)
    v6 = 4;
  else
    v6 = 16;
  v7 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithLength:](NSMutableData, "dataWithLength:", v6 + 4));
  objc_msgSend(v7, "appendBytes:length:", a3, v6);
  objc_msgSend(v7, "appendBytes:length:", &v10, 4);
  if ((objc_msgSend(*(id *)(a1 + 32), "containsObject:", v7) & 1) != 0)
  {
    v8 = 1;
  }
  else
  {
    objc_msgSend(*(id *)(a1 + 32), "addObject:", v7);
    v8 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
  }

  return v8;
}

id util_is_car_play(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  unsigned int v6;
  void *v7;
  id v8;

  v2 = objc_autoreleasePoolPush();
  v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a1));
  if (v3)
  {
    v4 = (void *)objc_opt_new(CWFInterface);
    objc_msgSend(v4, "activate");
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "interfaceName"));
    v6 = objc_msgSend(v5, "isEqualToString:", v3);

    if (v6)
    {
      v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "currentKnownNetworkProfile"));
      v8 = objc_msgSend(v7, "isCarPlay");

    }
    else
    {
      v8 = 0;
    }
    objc_msgSend(v4, "invalidate");

  }
  else
  {
    v8 = 0;
  }

  objc_autoreleasePoolPop(v2);
  return v8;
}

id util_is_managed_network(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  unsigned int v6;
  void *v7;
  id v8;

  v2 = objc_autoreleasePoolPush();
  v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a1));
  if (v3)
  {
    v4 = (void *)objc_opt_new(CWFInterface);
    objc_msgSend(v4, "activate");
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "interfaceName"));
    v6 = objc_msgSend(v5, "isEqualToString:", v3);

    if (v6)
    {
      v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "currentKnownNetworkProfile"));
      v8 = objc_msgSend(v7, "isBlueAtlasNetwork");

    }
    else
    {
      v8 = 0;
    }
    objc_msgSend(v4, "invalidate");

  }
  else
  {
    v8 = 0;
  }

  objc_autoreleasePoolPop(v2);
  return v8;
}

void util_managed_network_change_handler(void *a1)
{
  id v1;
  _QWORD block[4];
  id v3;

  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = __util_managed_network_change_handler_block_invoke;
  block[3] = &unk_10013E738;
  v3 = a1;
  v1 = v3;
  dispatch_async((dispatch_queue_t)&_dispatch_main_q, block);

}

void __util_managed_network_change_handler_block_invoke(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  void *v4;
  id v5;
  void *v6;
  void *v7;
  unsigned __int8 v8;
  id v9;
  id v10;
  NSObject *v11;
  NSObject *v12;
  void *v13;
  id v14;
  NSObject *v15;
  id v16;
  _QWORD v17[4];
  id v18;
  id location;
  uint8_t buf[4];
  id v21;

  v2 = objc_autoreleasePoolPush();
  if (util_managed_network_change_handler_s_interface)
  {
    objc_msgSend((id)util_managed_network_change_handler_s_interface, "stopMonitoringEventType:", 30);
  }
  else
  {
    v3 = objc_opt_new(CWFInterface);
    v4 = (void *)util_managed_network_change_handler_s_interface;
    util_managed_network_change_handler_s_interface = v3;

    objc_msgSend((id)util_managed_network_change_handler_s_interface, "activate");
  }
  v5 = objc_retainBlock(*(id *)(a1 + 32));
  v6 = (void *)util_managed_network_change_handler_s_handler;
  util_managed_network_change_handler_s_handler = (uint64_t)v5;

  if (util_managed_network_change_handler_s_handler)
  {
    location = 0;
    objc_initWeak(&location, (id)util_managed_network_change_handler_s_interface);
    v7 = (void *)util_managed_network_change_handler_s_interface;
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 3221225472;
    v17[2] = __util_managed_network_change_handler_block_invoke_2;
    v17[3] = &unk_10013E710;
    objc_copyWeak(&v18, &location);
    objc_msgSend(v7, "setEventHandler:", v17);
    v16 = 0;
    v8 = objc_msgSend((id)util_managed_network_change_handler_s_interface, "startMonitoringEventType:error:", 30, &v16);
    v9 = v16;
    v10 = _system_util_log();
    v11 = objc_claimAutoreleasedReturnValue(v10);
    v12 = v11;
    if ((v8 & 1) != 0)
    {
      if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "Registered for known network privacy risk changes", buf, 2u);
      }
    }
    else if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      v21 = v9;
      _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Failed to register for known network changes with error %@", buf, 0xCu);
    }

    objc_destroyWeak(&v18);
    objc_destroyWeak(&location);
  }
  else
  {
    objc_msgSend((id)util_managed_network_change_handler_s_interface, "setEventHandler:", 0);
    objc_msgSend((id)util_managed_network_change_handler_s_interface, "invalidate");
    v13 = (void *)util_managed_network_change_handler_s_interface;
    util_managed_network_change_handler_s_interface = 0;

    v14 = _system_util_log();
    v15 = objc_claimAutoreleasedReturnValue(v14);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_INFO, "Un-registering for known network privacy risk changes", buf, 2u);
    }

  }
  objc_autoreleasePoolPop(v2);
}

void sub_1000E34E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  id *v16;

  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void __util_managed_network_change_handler_block_invoke_2(uint64_t a1)
{
  _QWORD block[4];
  id v2;

  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = __util_managed_network_change_handler_block_invoke_3;
  block[3] = &unk_10013E6E8;
  objc_copyWeak(&v2, (id *)(a1 + 32));
  dispatch_async((dispatch_queue_t)&_dispatch_main_q, block);
  objc_destroyWeak(&v2);
}

void __util_managed_network_change_handler_block_invoke_3(uint64_t a1)
{
  void *v2;
  id *v3;
  id WeakRetained;
  id v5;
  void *v6;
  unsigned int v7;
  void *v8;
  char v9;
  id v10;
  NSObject *v11;
  uint64_t v12;
  _DWORD v13[2];

  v2 = objc_autoreleasePoolPush();
  v3 = (id *)(a1 + 32);
  WeakRetained = objc_loadWeakRetained(v3);

  if (WeakRetained)
  {
    v5 = objc_loadWeakRetained(v3);
    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "currentKnownNetworkProfile"));
    v7 = objc_msgSend(v6, "isBlueAtlasNetwork");

    v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "currentKnownNetworkProfile"));
    WeakRetained = objc_msgSend(v8, "shortSSID");

  }
  else
  {
    v7 = 0;
  }
  if (util_managed_network_change_handler_s_handler)
  {
    v9 = (id)util_managed_network_change_handler_s_last_blue_atlas_id == WeakRetained ? 0 : v7;
    if ((v9 & 1) != 0 || (v7 & 1) == 0 && (util_managed_network_change_handler_s_last_blue_atlas_id || !WeakRetained))
    {
      v10 = _system_util_log();
      v11 = objc_claimAutoreleasedReturnValue(v10);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        v13[0] = 67109120;
        v13[1] = v7;
        _os_log_debug_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "Updating privacy risk status %d", (uint8_t *)v13, 8u);
      }

      (*(void (**)(void))(util_managed_network_change_handler_s_handler + 16))();
    }
  }
  if (v7)
    v12 = (uint64_t)WeakRetained;
  else
    v12 = 0;
  util_managed_network_change_handler_s_last_blue_atlas_id = v12;
  objc_autoreleasePoolPop(v2);
}

