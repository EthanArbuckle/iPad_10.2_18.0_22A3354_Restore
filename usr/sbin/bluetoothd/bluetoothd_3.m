uint64_t sub_1001DF3FC(uint64_t a1, uint64_t a2)
{
  unsigned int v3;
  __int16 v4;
  uint64_t v5;
  char *v6;
  size_t v7;
  int v8;
  int v9;
  uint64_t v10;
  __int128 v11;
  int v12;
  unsigned __int16 v13;
  signed int v14;
  unsigned __int16 v15;
  unsigned int v16;
  uint64_t v17;
  char v18;
  int v19;
  int v20;
  NSObject *v21;
  uint64_t v22;
  _BYTE **v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  NSObject *v27;
  NSObject *v28;
  __int128 v30;
  unsigned int v31;
  uint64_t v32;
  __int128 v33;
  __int128 v34;
  _QWORD v35[16];
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  uint8_t buf[4];
  void *v44;
  __int16 v45;
  int v46;

  v32 = a2;
  v3 = *(unsigned __int16 *)(a2 + 4);
  v4 = *(_WORD *)(sub_1001E3CCC((int *)a1) + 72);
  __chkstk_darwin();
  v6 = (char *)&v30 - v5;
  bzero((char *)&v30 - v5, v7);
  v8 = *(unsigned __int8 *)(sub_1001E3CCC((int *)a1) + 77);
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  v36 = 0u;
  v34 = 0u;
  memset(v35, 0, 120);
  v33 = 0u;
  v9 = *(unsigned __int16 *)(sub_1001E3CCC((int *)a1) + 72);
  if (*(unsigned __int8 *)(sub_1001E3CCC((int *)a1) + 66) * v9 >= v3
    || *(_BYTE *)(sub_1001E3CCC((int *)a1) + 64) == 3)
  {
    v10 = sub_1001E3CCC((int *)a1);
    if (!v3)
      return 531;
    v12 = 0;
    if (*(_BYTE *)(v10 + 78))
      v13 = v4 - 8;
    else
      v13 = v4 - 6;
    v14 = v13;
    v31 = v8 & 0xFFFFFFFD;
    *(_QWORD *)&v11 = 136446466;
    v30 = v11;
    while (1)
    {
      if ((int)(v3 - v12) >= v14)
        v15 = v14;
      else
        v15 = v3 - v12;
      if (v31)
        goto LABEL_12;
      if (!v12 && v3 == v15)
      {
        *(_BYTE *)(sub_1001E3CCC((int *)a1) + 77) = 0;
        v15 = v3;
        goto LABEL_23;
      }
      if (v12)
      {
LABEL_12:
        v16 = v12 + v15;
        if (v16 >= v3)
        {
          if (v16 != v3)
          {
            sub_100253460();
            *(_BYTE *)(sub_1001E3CCC((int *)a1) + 77) = 0;
            goto LABEL_23;
          }
          v17 = sub_1001E3CCC((int *)a1);
          v18 = 2;
        }
        else
        {
          v17 = sub_1001E3CCC((int *)a1);
          v18 = 3;
        }
        *(_BYTE *)(v17 + 77) = v18;
      }
      else
      {
        *(_BYTE *)(sub_1001E3CCC((int *)a1) + 77) = 1;
        v15 -= 2;
      }
LABEL_23:
      v19 = sub_100053900(v6, v32, v15);
      if (v19 != v15)
      {
        v20 = v19;
        if (sub_10005549C())
        {
          sub_100054530("Failed to get the full payload size (%d), only got %d bytes", v15, v20);
          v21 = sub_1000544A0(0x2Fu);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            v26 = sub_100054494();
            *(_DWORD *)buf = v30;
            v44 = v26;
            v45 = 1024;
            v46 = 0xFFFF;
            _os_log_error_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "%{public}s (status=%{bluetooth:OI_STATUS}u)", buf, 0x12u);
          }
        }
        v15 = v20;
      }
      sub_1000532A8((uint64_t)&v36, 1u);
      sub_10005336C((unsigned __int8 *)&v36, v6, v15, 2u);
      BYTE8(v34) = *(_BYTE *)(sub_1001E3CCC((int *)a1) + 77);
      WORD5(v34) = v3;
      LOBYTE(v33) = *(__int16 *)(sub_1001E3CCC((int *)a1) + 38) == -1;
      *(_OWORD *)&v35[1] = v36;
      *(_OWORD *)&v35[3] = v37;
      *(_OWORD *)&v35[11] = v41;
      *(_OWORD *)&v35[13] = v42;
      *(_OWORD *)&v35[5] = v38;
      *(_OWORD *)&v35[7] = v39;
      *(_OWORD *)&v35[9] = v40;
      v22 = *(_QWORD *)(a1 + 128);
      v35[2] = a1;
      v35[0] = v22;
      *(_QWORD *)(a1 + 128) = 0;
      v23 = (_BYTE **)sub_1001E3CCC((int *)a1);
      v24 = sub_1001F3A24((uint64_t)&v33, *v23, 0, *(_WORD *)(a1 + 4));
      v25 = v24;
      if ((_DWORD)v24 != 412)
      {
        if ((_DWORD)v24)
        {
          if (sub_10005549C())
          {
            sub_100054530("Failed to send packet. Bailing. result %!", v25);
            v27 = sub_1000544A0(0x2Fu);
            if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
              sub_1006CE7A4();
          }
        }
        return v25;
      }
      v12 = (unsigned __int16)(v15 + v12);
      if (v12 == v3)
        return v25;
    }
  }
  if (sub_10005549C())
  {
    sub_100054530("Error, packet too large (exceeds MaxPDUSize * window)");
    v28 = sub_1000544A0(0x2Fu);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  return 472;
}

uint64_t sub_1001DF7F8(uint64_t a1, uint64_t a2)
{
  unsigned int v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  _BYTE **v10;
  uint64_t v11;
  _QWORD *v12;
  NSObject *v13;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  __int16 v25;
  char v26;
  char v27;

  if (a2)
  {
    if (a1)
      goto LABEL_3;
  }
  else
  {
    sub_100253460();
    if (a1)
      goto LABEL_3;
  }
  sub_100253460();
LABEL_3:
  if (*(_DWORD *)a1 != 2 && *(_DWORD *)a1 != 4)
    sub_100253460();
  v24 = 0;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  v15 = 0u;
  v5 = *(unsigned __int16 *)(a2 + 4);
  if (v5 <= *(unsigned __int16 *)(sub_1001E3CCC((int *)a1) + 32))
  {
    v25 = v5 + 2 * (*(_BYTE *)(sub_1001E3CCC((int *)a1) + 78) != 0);
    v26 = *(_BYTE *)(sub_1001E3CCC((int *)a1) + 8);
    v27 = *(_BYTE *)(sub_1001E3CCC((int *)a1) + 9);
    sub_1000532A8((uint64_t)&v17 + 8, 2u);
    sub_10005336C((unsigned __int8 *)&v17 + 8, (char *)&v25, 4uLL, 0);
    sub_10025444C((unsigned __int8 *)&v17 + 8, a2);
    LOBYTE(v15) = *(__int16 *)(sub_1001E3CCC((int *)a1) + 38) == -1;
    v9 = *(_QWORD *)(a1 + 128);
    *(_QWORD *)&v18 = a1;
    *(_QWORD *)&v17 = v9;
    *(_QWORD *)(a1 + 128) = 0;
    BYTE1(v15) = *(_DWORD *)(a2 + 8) == 626;
    v10 = (_BYTE **)sub_1001E3CCC((int *)a1);
    v11 = sub_1001F3A24((uint64_t)&v15, *v10, 0, *(_WORD *)(a1 + 4));
    v8 = v11;
    if ((_DWORD)v11)
    {
      if ((_DWORD)v11 != 412)
      {
        if (sub_10005549C())
        {
          v12 = (_QWORD *)sub_1001E3CCC((int *)a1);
          sub_100054530("OI_ConnectMan_WriteMBUF %! to %p", v8, *v12, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24);
          v13 = sub_1000544A0(0x2Fu);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
      }
      sub_100253FD8((uint64_t)&v17 + 8);
    }
  }
  else
  {
    if (sub_10005549C())
    {
      v6 = sub_1001E3CCC((int *)a1);
      sub_100054530("MTU size (%d) exceeded! - data length = %d", *(unsigned __int16 *)(v6 + 32), v5);
      v7 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 472;
  }
  return v8;
}

void sub_1001DFA10(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  NSObject *v10;
  int *v11;
  void (*v12)(uint64_t, uint64_t, uint64_t, _QWORD, uint64_t);
  NSObject *v13;
  NSObject *v14;
  int *v15;

  v15 = 0;
  if (sub_1001DB044(a1, (uint64_t *)&v15))
  {
    if (sub_10005549C())
    {
      sub_100054530("Data received for invalid CID %d, ignoring packet", a1);
      v10 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return;
  }
  if (!sub_1001E3CCC(v15))
  {
    if (!sub_10005549C())
      return;
    sub_100054530("Invalid packets.");
    v13 = sub_1000544A0(0x2Fu);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      return;
LABEL_12:
    sub_1006CE7A4();
    return;
  }
  if (*(_BYTE *)(sub_1001E3CCC(v15) + 16) == 4)
  {
    v11 = v15;
    v15[21] += a3;
    v12 = (void (*)(uint64_t, uint64_t, uint64_t, _QWORD, uint64_t))*((_QWORD *)v11 + 5);
    if (v12)
      v12(a1, a2, a3, 0, a4);
    else
      (*((void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))v11 + 4))(a1, a2, a3, a4, a5);
    return;
  }
  if (sub_10005549C())
  {
    sub_100054530("Data received for connection not in OPEN state, ignoring packet with cid %d", a1);
    v14 = sub_1000544A0(0x2Fu);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      goto LABEL_12;
  }
}

void sub_1001DFBA8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  NSObject *v12;
  int *v13;
  void (*v14)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  NSObject *v15;
  NSObject *v16;
  int *v17;

  v17 = 0;
  if (sub_1001DB044(a1, (uint64_t *)&v17))
  {
    if (sub_10005549C())
    {
      sub_100054530("Data received for invalid CID %d, ignoring packet", a1);
      v12 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return;
  }
  if (!sub_1001E3CCC(v17))
  {
    if (!sub_10005549C())
      return;
    sub_100054530("Invalid packets.");
    v15 = sub_1000544A0(0x2Fu);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      return;
LABEL_12:
    sub_1006CE7A4();
    return;
  }
  if (*(_BYTE *)(sub_1001E3CCC(v17) + 16) == 4)
  {
    v13 = v17;
    v17[21] += a3;
    v14 = (void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))*((_QWORD *)v13 + 5);
    if (v14)
      v14(a1, a2, a3, a4, a5);
    else
      (*((void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))v13 + 4))(a1, a2, a3, a5, a6);
    return;
  }
  if (sub_10005549C())
  {
    sub_100054530("Data received for connection not in OPEN state, ignoring packet");
    v16 = sub_1000544A0(0x2Fu);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      goto LABEL_12;
  }
}

void sub_1001DFD3C(uint64_t a1, uint64_t a2, int a3, _DWORD *a4, int a5, int a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t i;
  void (*v15)(uint64_t);
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  int *v22;

  v22 = 0;
  v12 = sub_10019AEA4(a1);
  v13 = v12;
  if (v12)
  {
    if (!a6)
    {
      if (a3 == 2 && a5 == 4)
      {
        *(_DWORD *)(v12 + 229) = *a4;
        if (*(char *)a4 < 0 && !sub_1002011BC((uint64_t)sub_1001DFD3C, a2, a1, 3))
          return;
      }
      else if (a3 == 3 && a5 == 8)
      {
        *(_QWORD *)(v12 + 233) = *(_QWORD *)a4;
      }
    }
    for (i = 0; i != 6; i += 2)
    {
      v15 = (void (*)(uint64_t))qword_100984CB0[i];
      if (v15
        && ((*(unsigned __int8 *)(v13 + ((unint64_t)LOWORD(qword_100984CB0[i + 1]) >> 3) + 233) >> (qword_100984CB0[i + 1] & 7)) & 1) != 0)
      {
        v15(a1);
      }
    }
    goto LABEL_11;
  }
  sub_100253460();
  if (!sub_10005549C()
    || (sub_100054530("Received infoResponseCallback from %:, but it appears this device is no longer connected", a1),
        v16 = sub_1000544A0(0x2Fu),
        !os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)))
  {
LABEL_11:
    if (!a2)
      return;
    goto LABEL_12;
  }
  sub_1006CE7A4();
  if (!a2)
    return;
LABEL_12:
  v17 = sub_1001DB900(a1, &v22);
  if ((_DWORD)v17)
  {
    v18 = v17;
    if (sub_10005549C())
    {
      sub_100054530("no waiting channel found for completed ACL link %: %!", a1, v18);
      v19 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  else
  {
    if (*(_BYTE *)(sub_1001E3CCC(v22) + 16) || *(_BYTE *)(sub_1001E3CCC(v22) + 25) != 1)
      sub_100253460();
    *(_QWORD *)sub_1001E3CCC(v22) = v13;
    *(_BYTE *)(sub_1001E3CCC(v22) + 25) = 2;
    v20 = sub_1001E3CCC(v22);
    v21 = sub_10025495C((uint64_t)sub_1001DE4A8, v20 + 10, *((__int128 **)v22 + 8), v22 + 18, 0);
    if ((_DWORD)v21)
      sub_1001DFF68((uint64_t)v22, v21);
  }
}

void sub_1001DFF68(uint64_t a1, uint64_t a2)
{
  _BYTE *v4;
  char v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  _BYTE *v11;
  char v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  if (a1)
  {
    if ((_DWORD)a2)
    {
LABEL_3:
      sub_1001DCE10(a1, a2);
      return;
    }
  }
  else
  {
    sub_100253460();
    if ((_DWORD)a2)
      goto LABEL_3;
  }
  if (*(_DWORD *)a1 == 3)
  {
    v4 = *(_BYTE **)sub_1001E3CCC((int *)a1);
    v5 = sub_1001FEFA4();
    v6 = *(unsigned __int16 *)(sub_1001E3CCC((int *)a1) + 8);
    v10 = sub_1001FF230("aac", 0xCu, (int *)a1, v4, v5, v7, v8, v9, v6);
    goto LABEL_10;
  }
  if (!sub_1001EEDEC((int *)a1) || sub_1001EED08((int *)a1))
  {
    v11 = *(_BYTE **)sub_1001E3CCC((int *)a1);
    v12 = sub_1001FEFA4();
    v10 = sub_1001FF230("aa", 2u, (int *)a1, v11, v12, v13, v14, v15, *(unsigned __int16 *)(a1 + 6));
LABEL_10:
    if (!v10)
    {
      *(_BYTE *)(sub_1001E3CCC((int *)a1) + 16) = 1;
      *(_BYTE *)(sub_1001E3CCC((int *)a1) + 25) = 0;
    }
  }
}

void sub_1001E0084(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  NSObject *v19;
  NSObject *v20;
  _BYTE *v21;
  uint64_t v22;
  uint64_t v23;
  int *v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  NSObject *v30;
  void *v31;
  uint64_t v32;
  int v33;
  int *v34;
  NSObject *v35;
  uint64_t v36;
  NSObject *v37;
  int *v38;
  uint8_t buf[4];
  void *v40;

  v38 = 0;
  if (byte_100984CE0)
  {
    if (sub_10005549C())
    {
      sub_100054530("Rejecting connect attempt, PTS error code is overriden to %d", byte_100984CE0);
      v10 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
LABEL_14:
    sub_1001FF230("aaaa", 3u, 0, (_BYTE *)a1, a4, v7, v8, v9, 0);
    return;
  }
  if ((a2 & 0x1010101) != 1)
  {
    if (sub_10005549C())
    {
      sub_100054530("%! - rejecting connect attempt to invalid PSM %d", 407, a2);
      v19 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    goto LABEL_14;
  }
  v12 = sub_10018007C(a1);
  if ((_DWORD)v12)
  {
    v13 = v12;
    if (sub_10005549C())
    {
      sub_100054530("OI_LP_ConnectionAdded failed (%!), rejecting connection", v13);
      v18 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
LABEL_20:
    v21 = (_BYTE *)a1;
    v22 = a3;
    v23 = 4;
LABEL_21:
    sub_1001E0470(v21, v22, v23, a4, v14, v15, v16, v17);
    return;
  }
  if (sub_1001DC04C(2u, (uint64_t *)&v38, 0))
  {
    if (sub_10005549C())
    {
      sub_100054530("Failed to allocate channel, rejecting connection");
      v20 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    goto LABEL_20;
  }
  v24 = v38;
  *((_WORD *)v38 + 3) = a2;
  v25 = sub_1001E3CCC(v24);
  v26 = *(_WORD *)(a1 + 52);
  *(_DWORD *)(v25 + 10) = *(_DWORD *)(a1 + 48);
  *(_WORD *)(v25 + 14) = v26;
  *(_BYTE *)(sub_1001E3CCC(v38) + 24) = 1;
  *(_QWORD *)sub_1001E3CCC(v38) = a1;
  *(_WORD *)(sub_1001E3CCC(v38) + 8) = a3;
  *(_BYTE *)(sub_1001E3CCC(v38) + 29) = a4;
  *(_BYTE *)(sub_1001E3CCC(v38) + 16) = 2;
  if (sub_10005549C())
  {
    v27 = *((unsigned __int16 *)v38 + 2);
    v28 = *((unsigned __int16 *)v38 + 3);
    v29 = sub_1001E3CCC(v38);
    sub_100054530("RecvConnectReq cid=%d psm=%d addr=%:", v27, v28, v29 + 10);
    v30 = sub_1000544A0(0x2Fu);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      v31 = sub_100054494();
      *(_DWORD *)buf = 136446210;
      v40 = v31;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  v32 = sub_1001E3CCC(v38);
  v33 = sub_1001E3D78(v32 + 10, *((unsigned __int16 *)v38 + 2), *((unsigned __int16 *)v38 + 3));
  v34 = v38;
  if (v33)
  {
    sub_1001DC658((uint64_t)v38);
    if (sub_10005549C())
    {
      sub_100054530("Connection refused - invalid PSM");
      v35 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    v21 = (_BYTE *)a1;
    v22 = a3;
    v23 = 2;
    goto LABEL_21;
  }
  if (*v38)
  {
    if (!*(_BYTE *)(a1 + 228))
    {
      *(_BYTE *)(a1 + 228) = 1;
      v36 = sub_1001E3CCC(v34);
      if (sub_1002011BC((uint64_t)sub_1001DFD3C, 0, v36 + 10, 2))
      {
        if (sub_10005549C())
        {
          sub_100054530("Could not ask device for extended features.");
          v37 = sub_1000544A0(0x2Fu);
          if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
      }
    }
  }
}

uint64_t sub_1001E0470(_BYTE *a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1001FF230("aaaa", 3u, 0, a1, a4, a6, a7, a8, 0);
  return sub_10018014C((uint64_t)a1, 0x13u);
}

void sub_1001E04C8(uint64_t a1, int a2, __int16 a3, unsigned int a4, uint64_t a5, int a6)
{
  NSObject *v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;
  int *v16;
  uint64_t v17;
  int *v18;
  uint64_t v19;
  _OWORD *v20;
  int v21;
  int *v22;
  unsigned int v23;
  int v24;
  uint64_t v25;
  _OWORD v26[3];
  int *v27;

  v27 = 0;
  memset(v26, 0, 44);
  if (sub_1001DB584(a1, a6, &v27))
  {
    if (sub_10005549C())
    {
      sub_100054530("RecvConnectRsp, unknown identifier 0x%x, ignoring", a6);
      v11 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return;
  }
  if (!sub_1001E3CCC(v27))
  {
    if (!sub_10005549C())
      return;
    sub_100054530("Invalid packets.");
    v13 = sub_1000544A0(0x2Fu);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      return;
    goto LABEL_13;
  }
  if (*(_QWORD *)sub_1001E3CCC(v27) == a1)
  {
    if (*(_BYTE *)(sub_1001E3CCC(v27) + 16) == 1)
    {
      if (a4 <= 1 && *((unsigned __int16 *)v27 + 2) != a2)
      {
        if (sub_10005549C())
        {
          sub_100054530("RecvConnectRsp, wrong source CID (s/b %d, rcvd %d).  Dropping connection", *((unsigned __int16 *)v27 + 2), a2);
          v15 = sub_1000544A0(0x2Fu);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
        v16 = v27;
        v17 = 454;
        goto LABEL_35;
      }
      *(_WORD *)(sub_1001E3CCC(v27) + 8) = a3;
      *(_BYTE *)(sub_1001E3CCC(v27) + 25) = 3;
      if (a4 == 1)
      {
        v18 = v27;
        v19 = sub_100252DE8(0x2Fu);
        sub_1001FEFC8(v18, *(unsigned __int16 *)(v19 + 8));
        return;
      }
      if (!a4)
      {
        if (sub_1001EEEC8() && (*(_BYTE *)(a1 + 229) & 0x20) != 0)
          sub_1001E3CCC(v27);
        v20 = v26;
        v21 = sub_1001EEC70(v27, 1, (uint64_t)v26);
        if (v21 != 1)
        {
          if (v21 == 2)
          {
            v16 = v27;
            v17 = 461;
            goto LABEL_35;
          }
          v20 = 0;
        }
        sub_1001E07CC(v27);
        v22 = v27;
        v23 = *(unsigned __int16 *)(sub_1001E3CCC(v27) + 36);
        v24 = *(unsigned __int16 *)(sub_1001E3CCC(v27) + 38);
        v25 = sub_1001E3CCC(v27);
        sub_1001E087C(v22, v23, v24, *(unsigned __int16 *)(v25 + 40), (uint64_t)v20);
        return;
      }
      v16 = v27;
      v17 = a4 + 450;
LABEL_35:
      sub_1001DCE10((uint64_t)v16, v17);
      return;
    }
    if (!sub_10005549C())
      return;
    sub_100054530("RecvConnectRsp, unexpected connect RSP, ignoring");
    v14 = sub_1000544A0(0x2Fu);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      return;
LABEL_13:
    sub_1006CE7A4();
    return;
  }
  if (sub_10005549C())
  {
    sub_100054530("RecvConnectRsp not excpected for this ACL handle");
    v12 = sub_1000544A0(0x2Fu);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      sub_1006D3770();
  }
}

uint64_t sub_1001E07CC(int *a1)
{
  int v2;
  uint64_t v3;
  char v4;
  int v5;
  uint64_t v6;
  const void *v8[2];
  int *v9;

  v9 = a1;
  if (!a1)
    sub_100253460();
  v2 = *(unsigned __int8 *)(sub_1001E3CCC(a1) + 16);
  v3 = sub_1001E3CCC(a1);
  if (v2 == 4)
    v4 = 5;
  else
    v4 = 3;
  *(_BYTE *)(v3 + 16) = v4;
  v8[0] = 0;
  *(_BYTE *)(sub_1001E3CCC(a1) + 26) = 0;
  *(_BYTE *)(sub_1001E3CCC(a1) + 27) = 0;
  v8[1] = &v9;
  LOWORD(v8[0]) = 8;
  v5 = *(unsigned __int16 *)(sub_100252DE8(0x2Fu) + 10);
  v6 = sub_1001E3CCC(v9);
  return sub_10004A9EC((uint64_t)sub_1001E2A1C, v8, v5, (int *)(v6 + 80));
}

uint64_t sub_1001E087C(int *a1, unsigned int a2, int a3, int a4, uint64_t a5)
{
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  NSObject *v14;
  uint64_t v15;
  NSObject *v16;
  uint64_t *v17;
  int *v18;
  uint64_t v19;
  NSObject *v20;
  unsigned int v21;
  uint64_t v23;
  _BYTE *v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;

  if (*(_BYTE *)(sub_1001E3CCC(a1) + 16) != 4
    && *(_BYTE *)(sub_1001E3CCC(a1) + 16) != 3
    && *(_BYTE *)(sub_1001E3CCC(a1) + 16) != 5)
  {
    if (sub_10005549C())
    {
      v19 = sub_1001E3CCC(a1);
      sub_100054530("invalid state for config (%d)", *(unsigned __int8 *)(v19 + 16));
      v20 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 408;
  }
  sub_1001E3CCC(a1);
  sub_1001E3CCC(a1);
  *(_WORD *)(sub_1001E3CCC(a1) + 36) = a2;
  *(_WORD *)(sub_1001E3CCC(a1) + 38) = a3;
  v10 = (uint64_t *)sub_1001E3CCC(a1);
  v11 = sub_1001F37D8(*v10);
  if (!(_DWORD)v11)
  {
    if ((a3 - 1) <= 0xFFFD)
    {
      sub_1001E3CCC(a1);
      v15 = sub_10004C9BC(85, sub_1001E2C2C);
      if ((_DWORD)v15)
      {
        v12 = v15;
        if (sub_10005549C())
        {
          sub_100054530("Write flushTO failed %!", v12, (858993460 * (unint64_t)(8 * a3)) >> 32);
          v16 = sub_1000544A0(0x2Fu);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
            goto LABEL_7;
        }
        return v12;
      }
    }
    if (a4 != 0xFFFF)
    {
      v17 = (uint64_t *)sub_1001E3CCC(a1);
      v12 = sub_1001DCD0C(*v17);
      if ((_DWORD)v12)
        return v12;
    }
    if (*(_BYTE *)(sub_1001E3CCC(a1) + 25) != 3)
    {
      if (!a5)
        goto LABEL_42;
      goto LABEL_44;
    }
    if (*a1 != 4 && *a1 != 2)
      goto LABEL_41;
    v18 = a1;
    if (!*(_WORD *)(sub_1001E3CCC(a1) + 38))
    {
      v18 = (int *)sub_1001DAF2C();
      if (!*(_WORD *)(sub_100252DE8(0x2Fu) + 2))
        goto LABEL_41;
      v21 = 0;
      while (1)
      {
        if (v18 != a1 && (*v18 == 4 || *v18 == 2))
        {
          v23 = *(_QWORD *)sub_1001E3CCC(a1);
          if (v23 != *(_QWORD *)sub_1001E3CCC(v18)
            && *(_WORD *)(sub_1001E3CCC(v18) + 38)
            && (*(__int16 *)(sub_1001E3CCC(v18) + 38) != -1 || (byte_100998F6A & 0x40) == 0))
          {
            break;
          }
        }
        ++v21;
        v18 += 36;
        if (v21 >= *(unsigned __int16 *)(sub_100252DE8(0x2Fu) + 2))
          goto LABEL_41;
      }
    }
    if (*(_WORD *)(sub_1001E3CCC(v18) + 38) != 0xFFFF)
    {
      if (!a5)
      {
LABEL_42:
        if (*(_BYTE *)(sub_1001E3CCC(a1) + 52))
        {
          sub_1001E3CCC(a1);
          sub_1001E3CCC(a1);
          sub_1001E3CCC(a1);
          sub_1001E3CCC(a1);
        }
      }
LABEL_44:
      if (*(_BYTE *)(sub_1001E3CCC(a1) + 16) == 4)
        sub_1001E07CC(a1);
      v24 = *(_BYTE **)sub_1001E3CCC(a1);
      v25 = sub_1001FEFA4();
      v26 = sub_1001E3CCC(a1);
      sub_1001FF230("aamsfro", 4u, a1, v24, v25, v27, v28, v29, *(unsigned __int16 *)(v26 + 8));
      v12 = 0;
      *(_BYTE *)(sub_1001E3CCC(a1) + 26) = 2;
      return v12;
    }
LABEL_41:
    if (!a5)
      goto LABEL_42;
    goto LABEL_44;
  }
  v12 = v11;
  if (sub_10005549C())
  {
    v13 = (_QWORD *)sub_1001E3CCC(a1);
    sub_100054530("OI_Sar_SetMTU(%d, %d) failed %!", *v13, a2, v12);
    v14 = sub_1000544A0(0x2Fu);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
LABEL_7:
      sub_1006CE7A4();
  }
  return v12;
}

void sub_1001E0CF8(uint64_t a1, char a2, unsigned int a3, int a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;
  int *v16;
  int v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  int v22;
  int v23;
  unsigned int v24;
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;
  uint64_t v29;
  unsigned int v30;
  NSObject *v31;
  _OWORD *v32;
  int v33;
  char v34;
  char v35;
  NSObject *v36;
  int *v37;
  uint64_t v38;
  int v39;
  int v40;
  _BOOL4 v41;
  int v42;
  uint64_t v43;
  char *v44;
  _OWORD *v45;
  char *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  NSObject *v50;
  void (*v51)(uint64_t, _QWORD, uint64_t, _QWORD);
  uint64_t v52;
  uint64_t v53;
  int v54;
  NSObject *v55;
  int *v56;
  unsigned int v57;
  int v58;
  uint64_t v59;
  char *v60;
  _OWORD *v61;
  char *v62;
  __int16 *v63;
  _OWORD v64[3];
  char v65;
  __int16 v66;
  __int16 v67;
  int *v68;

  v68 = 0;
  v67 = *(_WORD *)(sub_100252DE8(0x28u) + 8);
  v66 = -1;
  v65 = 1;
  memset(v64, 0, 44);
  v10 = sub_1001DB044(a3, (uint64_t *)&v68);
  if ((_DWORD)v10)
  {
    v11 = v10;
    if (sub_10005549C())
    {
      sub_100054530("cid %d not found %!", a3, v11);
      v12 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
LABEL_16:
        sub_1006CE7A4();
        return;
      }
    }
    return;
  }
  if (*v68 != 2)
  {
    if (sub_10005549C())
    {
      sub_100054530("Ignoring configuration request on non-connection channel %d", a3);
      v14 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        goto LABEL_16;
    }
    return;
  }
  if (!sub_1001E3CCC(v68))
  {
    if (sub_10005549C())
    {
      sub_100054530("Invalid packets.");
      v15 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        goto LABEL_16;
    }
    return;
  }
  if (*(_QWORD *)sub_1001E3CCC(v68) != a1)
  {
    if (sub_10005549C())
    {
      sub_100054530("OI_ConnectMan_RecvConfigReq unexpected CID");
      v13 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        sub_1006D37D8();
    }
    return;
  }
  v16 = v68;
  if (*v68 == 2)
  {
    v17 = *(unsigned __int8 *)(sub_1001E3CCC(v68) + 16);
    v16 = v68;
    if (v17 == 3)
    {
      v18 = *(unsigned __int8 *)(sub_1001E3CCC(v68) + 26);
      v16 = v68;
      if (!v18)
      {
        v19 = *(unsigned __int8 *)(sub_1001E3CCC(v68) + 27);
        v16 = v68;
        if (!v19)
        {
          v20 = *(unsigned __int8 *)(sub_1001E3CCC(v68) + 24);
          v16 = v68;
          if (v20)
          {
            v21 = sub_1001E3CCC(v68);
            sub_100049F6C(*(unsigned int *)(v21 + 80));
            sub_1001E07CC(v68);
            v16 = v68;
          }
        }
      }
    }
  }
  if (*(_BYTE *)(sub_1001E3CCC(v16) + 16) == 4)
    sub_1001E07CC(v68);
  if ((*(_BYTE *)(sub_1001E3CCC(v68) + 16) == 3 || *(_BYTE *)(sub_1001E3CCC(v68) + 16) == 5)
    && !*(_BYTE *)(sub_1001E3CCC(v68) + 27))
  {
    v22 = *(unsigned __int8 *)(sub_1001E3CCC(v68) + 16);
    if ((*(_BYTE *)a5 & 1) != 0)
    {
      if (*(unsigned __int16 *)(a5 + 4) < 0x30u
        || *(_BYTE *)(sub_1001E3CCC(v68) + 16) == 5
        && (v24 = *(unsigned __int16 *)(a5 + 4), v24 < *(unsigned __int16 *)(sub_1001E3CCC(v68) + 32)))
      {
        v63 = &v67;
        v23 = 1;
      }
      else
      {
        v25 = *(_WORD *)(a5 + 4);
        *(_WORD *)(sub_1001E3CCC(v68) + 32) = v25;
        v23 = 0;
        v63 = (__int16 *)(sub_1001E3CCC(v68) + 32);
      }
    }
    else
    {
      v23 = 0;
      v63 = 0;
    }
    v26 = *(_DWORD *)a5;
    if ((*(_DWORD *)a5 & 2) != 0)
    {
      if (*(_WORD *)(a5 + 6))
      {
        v27 = *(_WORD *)(a5 + 6);
        *(_WORD *)(sub_1001E3CCC(v68) + 34) = v27;
        v26 = *(_DWORD *)a5;
      }
      else
      {
        v23 = 1;
      }
    }
    if ((v26 & 4) != 0 && *(unsigned __int8 *)(a5 + 8) >= 2u)
      v23 = 1;
    v28 = sub_1001EEEC8();
    if ((v26 & 0x10) == 0)
    {
      if (!v28 || (*(_BYTE *)(a1 + 229) & 0x20) == 0)
      {
        v29 = 0;
        goto LABEL_55;
      }
      *(_BYTE *)(sub_1001E3CCC(v68) + 78) = 1;
      goto LABEL_54;
    }
    if ((v28 & 1) != 0)
    {
      v30 = *(unsigned __int8 *)(a5 + 20);
      if (v30 <= 1)
      {
        *(_BYTE *)(sub_1001E3CCC(v68) + 78) = v30;
LABEL_54:
        v29 = sub_1001E3CCC(v68) + 78;
LABEL_55:
        if ((*(_DWORD *)a5 & 8) != 0)
        {
          v33 = sub_1001EEEE4(v68, a5, 1, (uint64_t)v64);
          v23 = v33;
          if ((*(_BYTE *)a5 & 0x10) != 0)
          {
            if (v33 == 2)
            {
              v32 = 0;
            }
            else if (BYTE10(v64[0]) - 3 <= 1 && sub_1001EEEC8())
            {
              v35 = *(_BYTE *)(a1 + 229);
              v32 = v64;
              if ((v35 & 0x20) != 0)
                goto LABEL_75;
            }
            else
            {
              v32 = v64;
            }
            goto LABEL_74;
          }
          if (v33 == 2)
          {
            v32 = 0;
          }
          else if (BYTE10(v64[0]) - 3 <= 1 && sub_1001EEEC8())
          {
            v34 = *(_BYTE *)(a1 + 229);
            v32 = v64;
            if ((v34 & 0x20) != 0)
              goto LABEL_75;
          }
          else
          {
            v32 = v64;
          }
        }
        else
        {
          v32 = 0;
          if ((*(_DWORD *)a5 & 0x10) != 0)
          {
LABEL_74:
            *(_BYTE *)(sub_1001E3CCC(v68) + 78) = 0;
            v29 = sub_1001E3CCC(v68) + 78;
            goto LABEL_75;
          }
        }
        v29 = 0;
        *(_BYTE *)(sub_1001E3CCC(v68) + 78) = 0;
LABEL_75:
        if ((*(_BYTE *)a5 & 0x20) != 0 && *(unsigned __int8 *)(a5 + 25) > 1u)
        {
          v39 = v22;
          v40 = 0;
          v41 = 0;
          v23 = 1;
        }
        else
        {
          if (v23 == 2)
          {
            if (sub_10005549C())
            {
              sub_100054530("Critical negotiation : disconnecting.");
              v36 = sub_1000544A0(0x2Fu);
              if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
                sub_1006CE7A4();
            }
            v37 = v68;
            v38 = 452;
LABEL_82:
            sub_1001DED8C(v37, v38);
            return;
          }
          v39 = v22;
          v40 = 0;
          v41 = v23 == 0;
          if (!v23 && !a4)
          {
            v23 = 0;
            v40 = 1;
            *(_BYTE *)(sub_1001E3CCC(v68) + 27) = 1;
            v41 = 1;
          }
        }
        *(_BYTE *)(sub_1001E3CCC(v68) + 29) = a2;
        if (v63)
          *(_BYTE *)(sub_1001E3CCC(v68) + 31) = 1;
        if ((a4 & 1) == 0)
        {
          v42 = *(unsigned __int8 *)(sub_1001E3CCC(v68) + 31);
          v43 = sub_1001E3CCC(v68);
          if (v42)
            *(_BYTE *)(v43 + 31) = 0;
        }
        if (!v32)
        {
          v32 = v64;
          v54 = sub_1001EEC70(v68, 1, (uint64_t)v64);
          if (v54 != 1)
          {
            if (v54 == 2)
            {
              if (sub_10005549C())
              {
                sub_100054530("Critical negotiation : disconnecting.");
                v55 = sub_1000544A0(0x2Fu);
                if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
                  sub_1006CE7A4();
              }
              v37 = v68;
              if (v41)
                v38 = 0;
              else
                v38 = (v23 + 450);
              goto LABEL_82;
            }
            v32 = 0;
          }
        }
        v44 = (char *)v32 + 14;
        if (!v32)
          v44 = 0;
        v45 = v32 + 1;
        if (!v32)
          v45 = 0;
        v46 = (char *)v32 + 18;
        if (!v32)
          v46 = 0;
        v62 = v46;
        v60 = v44;
        v61 = v45;
        sub_1001E14D4(v68, v23, a4);
        if (v40)
        {
          if (*(_BYTE *)(sub_1001E3CCC(v68) + 26) == 3)
          {
            if (v39 != 5)
            {
              v47 = *(unsigned __int16 *)(sub_1001E3CCC(v68) + 32);
              v48 = sub_1001F2880(*((unsigned __int16 *)v68 + 2));
              if ((_DWORD)v48)
              {
                v49 = v48;
                if (sub_10005549C())
                {
                  sub_100054530("Queue Tag serviced failed with status %!", v49, v60, v61, v62, v29);
                  v50 = sub_1000544A0(0x2Fu);
                  if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
                    sub_1006CE7A4();
                }
              }
              v51 = *(void (**)(uint64_t, _QWORD, uint64_t, _QWORD))(sub_1001E3CCC(v68) + 96);
              v52 = *((unsigned __int16 *)v68 + 2);
              v53 = sub_1001E3CCC(v68);
              v51(v52, *(unsigned __int16 *)(v53 + 36), v47, 0);
            }
          }
          else if (!*(_BYTE *)(sub_1001E3CCC(v68) + 26))
          {
            v56 = v68;
            v57 = *(unsigned __int16 *)(sub_1001E3CCC(v68) + 36);
            v58 = *(unsigned __int16 *)(sub_1001E3CCC(v68) + 38);
            v59 = sub_1001E3CCC(v68);
            sub_1001E087C(v56, v57, v58, *(unsigned __int16 *)(v59 + 40), (uint64_t)v32);
          }
        }
        return;
      }
    }
    else if (sub_10005549C())
    {
      sub_100054530("We don't support FCS.");
      v31 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    v29 = 0;
    v23 = 1;
    goto LABEL_55;
  }
}

uint64_t sub_1001E14D4(int *a1, int a2, char a3)
{
  _BYTE *v6;
  char v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;
  uint64_t v13;

  v6 = *(_BYTE **)sub_1001E3CCC(a1);
  v7 = *(_BYTE *)(sub_1001E3CCC(a1) + 29);
  v8 = sub_1001E3CCC(a1);
  result = sub_1001FF230("aaamsfro", 5u, 0, v6, v7, v9, v10, v11, *(unsigned __int16 *)(v8 + 8));
  if (!a2 && (a3 & 1) == 0)
  {
    *(_BYTE *)(sub_1001E3CCC(a1) + 27) = 3;
    result = sub_1001E3CCC(a1);
    if (*(_BYTE *)(result + 26) == 3)
    {
      v13 = sub_1001E3CCC(a1);
      sub_100049F6C(*(unsigned int *)(v13 + 80));
      *(_BYTE *)(sub_1001E3CCC(a1) + 16) = 4;
      *(_BYTE *)(sub_1001E3CCC(a1) + 25) = 0;
      result = sub_1001E3CCC(a1);
      *(_BYTE *)(result + 28) = 0;
    }
  }
  return result;
}

void sub_1001E1618(uint64_t a1, uint64_t a2, unsigned int a3, char a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char *a9, __int16 a10)
{
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  NSObject *v17;
  NSObject *v18;
  char v19;
  NSObject *v20;
  int v21;
  uint64_t v22;
  NSObject *v23;
  int *v24;
  unsigned int v25;
  int v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  void (*v31)(uint64_t, _QWORD, uint64_t, _QWORD);
  uint64_t v32;
  uint64_t v33;
  _BYTE v34[48];
  int *v35;

  v35 = 0;
  memset(v34, 0, 44);
  v14 = sub_1001DB044(a3, (uint64_t *)&v35);
  if ((_DWORD)v14)
  {
    v15 = v14;
    if (sub_10005549C())
    {
      sub_100054530("cid %d not found %!", a3, v15, *(_OWORD *)v34, *(_QWORD *)&v34[16], *(_OWORD *)&v34[24], *(_QWORD *)&v34[40]);
      v16 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return;
  }
  if (!sub_1001E3CCC(v35))
  {
    if (!sub_10005549C())
      return;
    sub_100054530("Invalid packets.");
    v18 = sub_1000544A0(0x2Fu);
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      return;
LABEL_13:
    sub_1006CE7A4();
    return;
  }
  if (*(_QWORD *)sub_1001E3CCC(v35) != a1)
  {
    if (sub_10005549C())
    {
      sub_100054530("OI_ConnectMan_RecvConfigRsp unexpected CID");
      v17 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        sub_1006D37D8();
    }
    return;
  }
  if (*(_BYTE *)(sub_1001E3CCC(v35) + 16) != 3 && *(_BYTE *)(sub_1001E3CCC(v35) + 16) != 5
    || *(_BYTE *)(sub_1001E3CCC(v35) + 26) != 2)
  {
    if (!sub_10005549C())
      return;
    sub_100054530("Invalid state for configuration");
    v20 = sub_1000544A0(0x2Fu);
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      return;
    goto LABEL_13;
  }
  if (a10)
  {
    if (a8)
      LODWORD(a8) = sub_1001EEEE4(v35, a8, 0, (uint64_t)v34);
    if (a9)
      v19 = *a9;
    else
      v19 = 0;
    *(_BYTE *)(sub_1001E3CCC(v35) + 78) = v19;
    if ((_DWORD)a8 != 2)
    {
      v24 = v35;
      v25 = *(unsigned __int16 *)(sub_1001E3CCC(v35) + 36);
      v26 = *(unsigned __int16 *)(sub_1001E3CCC(v35) + 38);
      v27 = sub_1001E3CCC(v35);
      sub_1001E087C(v24, v25, v26, *(unsigned __int16 *)(v27 + 40), (uint64_t)v34);
      return;
    }
    v21 = 2;
  }
  else
  {
    v21 = 0;
  }
  v22 = sub_1001E3CCC(v35);
  if (a10)
  {
    if (sub_10005549C())
    {
      sub_100054530("config rsp = %!\n", v21 | 0x1CCu);
      v23 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    sub_1001DED8C(v35, (v21 + 450));
  }
  else
  {
    v28 = *(unsigned __int8 *)(v22 + 16);
    if ((a4 & 1) == 0)
    {
      *(_BYTE *)(sub_1001E3CCC(v35) + 26) = 3;
      if (*(_BYTE *)(sub_1001E3CCC(v35) + 27) == 3)
      {
        *(_BYTE *)(sub_1001E3CCC(v35) + 16) = 4;
        *(_BYTE *)(sub_1001E3CCC(v35) + 25) = 0;
        v29 = sub_1001E3CCC(v35);
        sub_100049F6C(*(unsigned int *)(v29 + 80));
        *(_BYTE *)(sub_1001E3CCC(v35) + 28) = 0;
      }
    }
    if (*(_BYTE *)(sub_1001E3CCC(v35) + 26) == 3 && *(_BYTE *)(sub_1001E3CCC(v35) + 27) == 3 && v28 != 5)
    {
      v30 = *(unsigned __int16 *)(sub_1001E3CCC(v35) + 32);
      v31 = *(void (**)(uint64_t, _QWORD, uint64_t, _QWORD))(sub_1001E3CCC(v35) + 96);
      v32 = *((unsigned __int16 *)v35 + 2);
      v33 = sub_1001E3CCC(v35);
      v31(v32, *(unsigned __int16 *)(v33 + 36), v30, 0);
    }
  }
}

void sub_1001E19BC(_BYTE *a1, unsigned int a2, int a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;
  _BYTE *v16;
  char v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int *v22;

  v22 = 0;
  v8 = sub_1001DB044(a2, (uint64_t *)&v22);
  if ((_DWORD)v8)
  {
    v9 = v8;
    if (sub_10005549C())
    {
      sub_100054530("No channel exists for CID %d (%!)", a2, v9);
      v12 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    sub_100200BB4(a1, 2u, 0, a2, a3, a4, v10, v11);
    return;
  }
  if (!sub_1001E3CCC(v22))
  {
    if (!sub_10005549C())
      return;
    sub_100054530("Invalid packets.");
    v14 = sub_1000544A0(0x2Fu);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      return;
LABEL_15:
    sub_1006CE7A4();
    return;
  }
  if (*(unsigned __int16 *)(sub_1001E3CCC(v22) + 8) != a3)
  {
    if (!sub_10005549C())
      return;
    sub_100054530("Invalid source CID %d", a3);
    v15 = sub_1000544A0(0x2Fu);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      return;
    goto LABEL_15;
  }
  if (*(_BYTE **)sub_1001E3CCC(v22) == a1)
  {
    *(_BYTE *)(sub_1001E3CCC(v22) + 29) = a4;
    v16 = *(_BYTE **)sub_1001E3CCC(v22);
    v17 = *(_BYTE *)(sub_1001E3CCC(v22) + 29);
    v18 = *((unsigned __int16 *)v22 + 2);
    sub_1001E3CCC(v22);
    sub_1001FF230("aa", 7u, 0, v16, v17, v19, v20, v21, v18);
    sub_1001DCE10((uint64_t)v22, 431);
  }
  else if (sub_10005549C())
  {
    sub_100054530("OI_ConnectMan_RecvDisconnectReq unexpected CID");
    v13 = sub_1000544A0(0x2Fu);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      sub_1006D37D8();
  }
}

void sub_1001E1BD4(__int128 *a1, unsigned int a2, unsigned int a3, char a4)
{
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  NSObject *v12;
  NSObject *v13;
  __int128 *v14;
  char v15;
  __int16 v16;
  uint64_t v17;
  int *v18;

  v18 = 0;
  v8 = sub_1001DB044(a2, (uint64_t *)&v18);
  if ((_DWORD)v8)
  {
    v9 = v8;
    if (sub_10005549C())
    {
      sub_100054530("No channel exists for CID %d (%!)", a2, v9);
      v10 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    sub_10022F410(a1, 2, 0, a2, a3, a4);
    return;
  }
  if (!sub_1001E3CCC(v18))
  {
    if (!sub_10005549C())
      return;
    sub_100054530("Invalid packets.");
    v12 = sub_1000544A0(0x2Fu);
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      return;
LABEL_15:
    sub_1006CE7A4();
    return;
  }
  if (*(unsigned __int16 *)(sub_1001E3CCC(v18) + 8) != a3)
  {
    if (!sub_10005549C())
      return;
    sub_100054530("Invalid source CID %d", a3);
    v13 = sub_1000544A0(0x2Fu);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      return;
    goto LABEL_15;
  }
  if (*(__int128 **)sub_1001E3CCC(v18) == a1)
  {
    *(_BYTE *)(sub_1001E3CCC(v18) + 29) = a4;
    v14 = *(__int128 **)sub_1001E3CCC(v18);
    v15 = *(_BYTE *)(sub_1001E3CCC(v18) + 29);
    v16 = *((_WORD *)v18 + 2);
    v17 = sub_1001E3CCC(v18);
    sub_10022F7A4(v14, v15, v16, *(_WORD *)(v17 + 8));
    sub_1001DCE10((uint64_t)v18, 431);
  }
  else if (sub_10005549C())
  {
    sub_100054530("OI_ConnectMan_RecvDisconnectReq unexpected CID");
    v11 = sub_1000544A0(0x2Fu);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      sub_1006D37D8();
  }
}

void sub_1001E1DDC(uint64_t a1, int a2, unsigned int a3)
{
  NSObject *v6;
  NSObject *v7;
  int *v8;
  uint64_t v9;
  int *v10;

  v10 = 0;
  if (!sub_1001DB044(a3, (uint64_t *)&v10)
    && sub_1001E3CCC(v10)
    && *(_BYTE *)(sub_1001E3CCC(v10) + 16) == 6
    && *(unsigned __int16 *)(sub_1001E3CCC(v10) + 8) == a2
    && *((unsigned __int16 *)v10 + 2) == a3)
  {
    if (*(_QWORD *)sub_1001E3CCC(v10) == a1)
    {
      *(_BYTE *)(sub_1001E3CCC(v10) + 28) = 0;
      v8 = v10;
      v9 = sub_1001E3CCC(v10);
      sub_1001DCE10((uint64_t)v8, *(unsigned int *)(v9 + 20));
    }
    else if (sub_10005549C())
    {
      sub_100054530("OI_ConnectMan_RecvDisconnectRsp unexpected CID");
      v7 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_1006D37D8();
    }
  }
  else if (sub_10005549C())
  {
    sub_100054530("Invalid packet");
    v6 = sub_1000544A0(0x2Fu);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
}

void sub_1001E1F20(uint64_t a1, unsigned int a2, int a3)
{
  NSObject *v6;
  NSObject *v7;
  int *v8;

  v8 = 0;
  if (!sub_1001DB044(a2, (uint64_t *)&v8)
    && sub_1001E3CCC(v8)
    && *(_BYTE *)(sub_1001E3CCC(v8) + 16) == 6
    && *(unsigned __int16 *)(sub_1001E3CCC(v8) + 8) == a3
    && *((unsigned __int16 *)v8 + 2) == a2)
  {
    if (*(_QWORD *)sub_1001E3CCC(v8) == a1)
    {
      sub_1001DCE10((uint64_t)v8, 436);
    }
    else if (sub_10005549C())
    {
      sub_100054530("LE_ConnectMan_RecvDisconnectRsp unexpected CID");
      v7 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_1006D37D8();
    }
  }
  else if (sub_10005549C())
  {
    sub_100054530("Invalid packet");
    v6 = sub_1000544A0(0x2Fu);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
}

uint64_t sub_1001E204C(uint64_t a1, uint64_t a2, __int16 a3, unsigned int a4, int a5, int a6, uint64_t a7, uint64_t a8)
{
  NSObject *v11;
  __int16 v12;
  __int128 *v13;
  char v14;
  __int16 v15;
  NSObject *v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  int *v25;
  uint64_t v26;
  __int16 v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  NSObject *v31;
  uint64_t result;
  uint64_t v33;
  NSObject *v34;
  uint64_t v35;
  int *v36;

  v36 = 0;
  if (byte_100984CE0)
  {
    if (sub_10005549C())
    {
      sub_100054530("Rejecting connect attempt, PTS error code is overriden to %d", byte_100984CE0);
      v11 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    v12 = byte_100984CE0;
    v13 = (__int128 *)a1;
    v14 = a7;
    v15 = a3;
    return sub_10022EEE0(v13, v14, v15, 0, 0, 0, v12);
  }
  if ((a2 - 1) >= 0x7F && (a2 & 0xFF80) != 0x80)
  {
    if (sub_10005549C())
    {
      sub_100054530("%! - rejecting connect attempt due to invalid PSM %d", 582, a2);
      v21 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
LABEL_11:
    v13 = (__int128 *)a1;
    v14 = a7;
    v15 = a3;
    v12 = 2;
    return sub_10022EEE0(v13, v14, v15, 0, 0, 0, v12);
  }
  if ((a3 & 0xFFC0) != 0x40)
  {
    if (sub_10005549C())
    {
      sub_100054530("%! - Rejecting connect attempt due to source CID out of range", 589);
      v23 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    v13 = (__int128 *)a1;
    v14 = a7;
    v15 = a3;
    v12 = 9;
    return sub_10022EEE0(v13, v14, v15, 0, 0, 0, v12);
  }
  v35 = 0;
  sub_1001DB410(a3, a1, &v35);
  if (v35)
  {
    if (sub_10005549C())
    {
      sub_100054530("%! - Rejecting connect attempt due to source CID already connected", 10);
      v22 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    v13 = (__int128 *)a1;
    v14 = a7;
    v15 = a3;
    v12 = 10;
    return sub_10022EEE0(v13, v14, v15, 0, 0, 0, v12);
  }
  if (sub_1001DC04C(2u, (uint64_t *)&v36, 1))
  {
    if (!sub_10005549C())
      goto LABEL_32;
    sub_100054530("%! - rejecting connect attempt due to ailure to allocate channel", 584);
    v24 = sub_1000544A0(0x2Fu);
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      goto LABEL_32;
    goto LABEL_31;
  }
  v25 = v36;
  *((_WORD *)v36 + 3) = a2;
  v26 = sub_1001E3CCC(v25);
  v27 = *(_WORD *)(a1 + 52);
  *(_DWORD *)(v26 + 10) = *(_DWORD *)(a1 + 48);
  *(_WORD *)(v26 + 14) = v27;
  v28 = sub_1001E3CCC(v36);
  v29 = *(_DWORD *)(a1 + 51);
  *(_DWORD *)(v28 + 104) = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(v28 + 107) = v29;
  *(_BYTE *)(sub_1001E3CCC(v36) + 24) = 1;
  *(_QWORD *)sub_1001E3CCC(v36) = a1;
  *(_WORD *)(sub_1001E3CCC(v36) + 8) = a3;
  *(_BYTE *)(sub_1001E3CCC(v36) + 29) = a7;
  if (14 * a5 < a4)
    LOWORD(a4) = 14 * a5;
  *(_WORD *)(sub_1001E3CCC(v36) + 32) = a4;
  *(_WORD *)(sub_1001E3CCC(v36) + 60) = a5;
  v30 = sub_1001D7F74(v36, a6);
  if ((_DWORD)v30)
  {
    sub_1001DC658((uint64_t)v36);
    if (!sub_10005549C())
      goto LABEL_32;
    sub_100054530("%! - rejecting connect attempt due to failure to init remote parameters, returned %!(%d), ejecting connection", 584, v30, v30);
    v31 = sub_1000544A0(0x2Fu);
    if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      goto LABEL_32;
LABEL_31:
    sub_1006CE7A4();
LABEL_32:
    v13 = (__int128 *)a1;
    v14 = a7;
    v15 = a3;
    v12 = 4;
    return sub_10022EEE0(v13, v14, v15, 0, 0, 0, v12);
  }
  *(_BYTE *)(sub_1001E3CCC(v36) + 16) = 2;
  v33 = sub_1001E3CCC(v36);
  result = sub_1001E3EBC(v33 + 104, *((unsigned __int16 *)v36 + 2), *((unsigned __int16 *)v36 + 3), a7, a8);
  if ((_DWORD)result)
  {
    sub_1001DC658((uint64_t)v36);
    if (sub_10005549C())
    {
      sub_100054530("%! - rejecting connect attempt due to failure to find a handler for this channel", 582);
      v34 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    goto LABEL_11;
  }
  return result;
}

void sub_1001E2494(uint64_t a1, __int16 a2, unsigned int a3, int a4, int a5, int a6, int a7)
{
  NSObject *v14;
  NSObject *v15;
  NSObject *v16;
  __int16 v17;
  unsigned __int16 v18;
  int v19;
  unsigned __int16 v20;
  NSObject *v21;
  NSObject *v22;
  _WORD *v23;
  _QWORD *v24;
  NSObject *v25;
  void *v26;
  int *v27;
  uint64_t v28;
  NSObject *v29;
  unsigned __int16 v30;
  int v31;
  NSObject *v32;
  NSObject *v33;
  uint64_t *v34;
  uint64_t v35;
  void (*v36)(uint64_t, uint64_t, _QWORD, uint64_t);
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int *v40;
  uint8_t buf[4];
  void *v42;

  v40 = 0;
  if (sub_1001DB6A4(a1, a7, &v40))
  {
    if (sub_10005549C())
    {
      sub_100054530("RecvLeConnectRsp, unknown identifier 0x%x, ignoring", a7);
      v14 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return;
  }
  if (!sub_1001E3CCC(v40))
  {
    if (!sub_10005549C())
      return;
    sub_100054530("Invalid packets.");
    v16 = sub_1000544A0(0x2Fu);
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      return;
LABEL_13:
    sub_1006CE7A4();
    return;
  }
  if (*(_QWORD *)sub_1001E3CCC(v40) != a1)
  {
    if (sub_10005549C())
    {
      sub_100054530("RecvLeConnectRsp not excpected for this ACL handle");
      v15 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        sub_1006D3770();
    }
    return;
  }
  if (*(_BYTE *)(sub_1001E3CCC(v40) + 16) != 1)
  {
    if (!sub_10005549C())
      return;
    sub_100054530("RecvLeConnectRsp, unexpected connect RSP, ignoring");
    v22 = sub_1000544A0(0x2Fu);
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      return;
    goto LABEL_13;
  }
  if ((a6 - 7) >= 2 && a6 != 5)
  {
    if (a6)
    {
      v27 = v40;
      v28 = (a6 + 580);
    }
    else
    {
      if ((a2 & 0xFFC0) == 0x40)
      {
        *(_WORD *)(sub_1001E3CCC(v40) + 8) = a2;
        if (14 * a4 >= a3)
          v17 = a3;
        else
          v17 = 14 * a4;
        *(_WORD *)(sub_1001E3CCC(v40) + 32) = v17;
        *(_WORD *)(sub_1001E3CCC(v40) + 60) = a4;
        v18 = sub_1001D7F74(v40, a5);
        v19 = v18;
        if (v18)
        {
          v20 = v18;
          if (!sub_10005549C())
            goto LABEL_51;
          sub_100054530("LE_L2CAP_InitRemoteParams returned %d\n", v19);
          v21 = sub_1000544A0(0x2Fu);
          if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
            goto LABEL_51;
        }
        else
        {
          v30 = sub_1001EF3B0(v40, 5, 0);
          v31 = v30;
          if (v30)
          {
            v20 = v30;
            if (!sub_10005549C())
              goto LABEL_51;
            sub_100054530("BT_L2CAP_Flow_InitChannel returned %d\n", v31);
            v32 = sub_1000544A0(0x2Fu);
            if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
              goto LABEL_51;
          }
          else
          {
            v20 = sub_1001F0E30(*((unsigned __int16 *)v40 + 2), 15, 5u, 0, (uint64_t *)v40 + 12, v40[19]);
            if (!v20)
              goto LABEL_52;
            if (!sub_10005549C()
              || (sub_100054530("BT_L2CAP_Queue_Register returned %d\n", v20),
                  v33 = sub_1000544A0(0x2Fu),
                  !os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)))
            {
LABEL_51:
              sub_1001DCE10((uint64_t)v40, 4);
LABEL_52:
              if (!v20)
              {
                v34 = (uint64_t *)sub_1001E3CCC(v40);
                v35 = sub_1001F37D8(*v34);
                *(_BYTE *)(sub_1001E3CCC(v40) + 16) = 4;
                v36 = *(void (**)(uint64_t, uint64_t, _QWORD, uint64_t))(sub_1001E3CCC(v40) + 96);
                v37 = *((unsigned __int16 *)v40 + 2);
                v38 = *(unsigned __int16 *)(sub_1001E3CCC(v40) + 36);
                v39 = sub_1001E3CCC(v40);
                v36(v37, v38, *(unsigned __int16 *)(v39 + 32), v35);
              }
              return;
            }
          }
        }
        sub_1006CE7A4();
        goto LABEL_51;
      }
      if (sub_10005549C())
      {
        sub_100054530("destination CID out of range");
        v29 = sub_1000544A0(0x2Fu);
        if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      v27 = v40;
      v28 = 9;
    }
    sub_1001DCE10((uint64_t)v27, v28);
    return;
  }
  v23 = sub_100052DC0(2uLL);
  if (!v23)
  {
    sub_1001DC658((uint64_t)v40);
    sub_1001DCE10((uint64_t)v40, 1164);
  }
  *v23 = *((_WORD *)v40 + 2);
  v24 = *(_QWORD **)(a1 + 224);
  if (!v24)
  {
    v24 = sub_100251288(0, 0);
    *(_QWORD *)(a1 + 224) = v24;
  }
  sub_10025142C((uint64_t)v24, (uint64_t)v23, 0);
  if (sub_10005549C())
  {
    sub_100054530("Start Pairing");
    v25 = sub_1000544A0(0x2Fu);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      v26 = sub_100054494();
      *(_DWORD *)buf = 136446210;
      v42 = v26;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  sub_1002380C4(a1, 1);
}

uint64_t sub_1001E2984(uint64_t a1, __int16 a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;

  v2 = 0;
  while (qword_100984CB0[v2] != a1)
  {
    v2 += 2;
    if (v2 == 6)
      goto LABEL_6;
  }
  qword_100984CB0[v2] = 0;
LABEL_6:
  v3 = 0;
  while (1)
  {
    v4 = qword_100984CB0[v3];
    if (!v4)
      break;
    v3 += 2;
    if (v3 == 6)
      return 104;
  }
  v5 = &qword_100984CB0[v3];
  *v5 = a1;
  *((_WORD *)v5 + 4) = a2;
  return v4;
}

uint64_t sub_1001E29E4(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;

  v1 = 0;
  while (qword_100984CB0[v1] != a1)
  {
    v1 += 2;
    if (v1 == 6)
      return 404;
  }
  result = 0;
  qword_100984CB0[v1] = 0;
  return result;
}

uint64_t sub_1001E2A1C(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t result;
  unsigned int v15;
  int v16;
  uint64_t v17;
  NSObject *v18;

  v1 = **(_QWORD **)(a1 + 8);
  if (v1)
  {
    if (sub_10005549C())
    {
      sub_100054530("L2CAP Config Timeout on cid %d, psm %d", *(unsigned __int16 *)(v1 + 4), *(unsigned __int16 *)(v1 + 6));
      v2 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  else
  {
    sub_100253460();
  }
  if (*(_DWORD *)v1 != 2
    || *(_BYTE *)(sub_1001E3CCC((int *)v1) + 16) != 3
    || *(_BYTE *)(sub_1001E3CCC((int *)v1) + 26)
    || *(_BYTE *)(sub_1001E3CCC((int *)v1) + 27)
    || !*(_BYTE *)(sub_1001E3CCC((int *)v1) + 24))
  {
    if (sub_10005549C())
    {
      if (*(_DWORD *)v1 == 2)
      {
        v3 = sub_1001E3CCC((int *)v1);
        v11 = (const char *)sub_10025304C(v3 + 10, v4, v5, v6, v7, v8, v9, v10);
      }
      else
      {
        v11 = "group";
      }
      sub_100054530("Configuration process timed out, remote device %s", v11);
      v12 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    v13 = 464;
    return sub_1001DED8C((int *)v1, v13);
  }
  sub_1001E07CC(v1);
  if (sub_1001EEEC8() && (*(_BYTE *)(*(_QWORD *)sub_1001E3CCC((int *)v1) + 229) & 0x20) != 0)
    sub_1001E3CCC((int *)v1);
  v15 = *(unsigned __int16 *)(sub_1001E3CCC((int *)v1) + 36);
  v16 = *(unsigned __int16 *)(sub_1001E3CCC((int *)v1) + 38);
  v17 = sub_1001E3CCC((int *)v1);
  result = sub_1001E087C((int *)v1, v15, v16, *(unsigned __int16 *)(v17 + 40), 0);
  if ((_DWORD)result)
  {
    v13 = result;
    if (sub_10005549C())
    {
      sub_100054530("ConfigReqHelper failed %!", v13);
      v18 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return sub_1001DED8C((int *)v1, v13);
  }
  return result;
}

void sub_1001E2C2C(uint64_t a1)
{
  NSObject *v2;

  if ((_DWORD)a1 && sub_10005549C())
  {
    sub_100054530("Failed to write FlushTO %!", a1);
    v2 = sub_1000544A0(0x2Fu);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
}

uint64_t sub_1001E2CD0(_BYTE *a1, unsigned int a2, uint64_t a3)
{
  unsigned int v6;
  char v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  unsigned __int16 *v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  NSObject *v16;
  _OWORD v18[2];
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;
  uint64_t v27;
  int v28;

  v27 = 0;
  if (!a3)
    sub_100253460();
  v28 = 0;
  memset(v18, 0, sizeof(v18));
  v19 = 0u;
  v20 = 0u;
  v21 = 0u;
  v22 = 0u;
  v23 = 0u;
  v24 = 0u;
  v25 = 0u;
  v26 = 0;
  if (a2 == 2)
  {
    v6 = *(unsigned __int16 *)(a3 + 4);
    sub_1000532A8((uint64_t)&v19 + 8, 2u);
    v7 = v6;
    v8 = v6 >> 8;
    goto LABEL_5;
  }
  v9 = sub_1001DB044(a2, &v27);
  if ((_DWORD)v9)
    return v9;
  if (*(_DWORD *)v27 == 3)
  {
    v10 = *(unsigned __int16 *)(a3 + 4);
    if (v10 <= *(unsigned __int16 *)sub_1001E40C4(v27))
    {
      sub_1000532A8((uint64_t)&v19 + 8, 2u);
      if (a2 == 43)
      {
        LOBYTE(v18[0]) = a1[129] == 0;
LABEL_17:
        sub_10025444C((unsigned __int8 *)&v19 + 8, a3);
        if (v27)
        {
          v13 = *(_QWORD *)(v27 + 128);
          *(_QWORD *)(v27 + 128) = 0;
        }
        else
        {
          v13 = 0;
        }
        *(_QWORD *)&v19 = v13;
        v14 = sub_1001F3A24((uint64_t)v18, a1, 0, a2);
        v9 = v14;
        if ((_DWORD)v14)
        {
          if ((_DWORD)v14 != 412)
          {
            if (sub_10005549C())
            {
              sub_100054530("OI_ConnectMan_WriteMBUF %!", v9);
              v15 = sub_1000544A0(0x2Fu);
              if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
                sub_1006CE7A4();
            }
          }
          sub_100253FD8((uint64_t)&v19 + 8);
        }
        return v9;
      }
      v7 = v10;
      v8 = v10 >> 8;
LABEL_5:
      LOBYTE(v28) = v7;
      BYTE1(v28) = v8;
      HIWORD(v28) = a2;
      sub_10005336C((unsigned __int8 *)&v19 + 8, (char *)&v28, 4uLL, 0);
      if (a2 == 2)
      {
        LOBYTE(v18[0]) = 1;
        *(_QWORD *)&v20 = 0;
        if (v27)
        {
          *(_QWORD *)&v19 = *(_QWORD *)(v27 + 128);
          *(_QWORD *)(v27 + 128) = 0;
        }
        else
        {
          *(_QWORD *)&v19 = 0;
        }
      }
      else
      {
        LOBYTE(v18[0]) = *(__int16 *)(sub_1001E40C4(v27) + 2) == -1;
        *(_QWORD *)&v20 = v27;
      }
      goto LABEL_17;
    }
    if (sub_10005549C())
    {
      v11 = (unsigned __int16 *)sub_1001E40C4(v27);
      sub_100054530("MTU size (%d) exceeded! - data length = %d", *v11, v10);
      v12 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 472;
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("CID %d is not a fixed channel", a2);
      v16 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 532;
  }
}

void sub_1001E2F98(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  NSObject *v26;
  uint64_t v27;

  v27 = 0;
  if (sub_1001DB044(a2, &v27))
  {
    if (sub_10005549C())
    {
      sub_100054530("Can't find channel %d, dropping packet.", a2);
      v10 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  else
  {
    v11 = v27;
    *(_DWORD *)(v27 + 84) += a4;
    if ((*(_BYTE *)(sub_1001E40C4(v11) + 4) & 1) != 0 && !*(_BYTE *)(a1 + 2)
      || (*(_BYTE *)(sub_1001E40C4(v27) + 4) & 2) != 0 && *(_BYTE *)(a1 + 2) == 4)
    {
      v12 = sub_1001E40C4(v27);
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v12 + 24))(a1, a3, a4, a5);
    }
    else
    {
      sub_100253460();
      if (sub_10005549C())
      {
        v20 = *(unsigned __int8 *)(a1 + 2);
        v21 = sub_1001E40C4(v27);
        sub_100054530("Fixed Channel 0x%x on wrong physical link 0x%x, should be 0x%x", a2, v20, *(unsigned __int8 *)(v21 + 4));
        v22 = sub_1000544A0(0x2Fu);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          sub_1006CEE54();
      }
      v23 = sub_100196768(5u, v13, v14, v15, v16, v17, v18, v19, a1);
      v24 = sub_1001A1F70(a1, v23);
      if ((_DWORD)v24)
      {
        v25 = v24;
        if (sub_10005549C())
        {
          sub_100054530("Disconnect failed with status %!", v25, 19);
          v26 = sub_1000544A0(0x2Fu);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
            sub_1006CEE54();
        }
      }
    }
  }
}

uint64_t sub_1001E3164()
{
  unsigned __int16 *v0;

  v0 = (unsigned __int16 *)sub_100252DE8(0x2Fu);
  qword_100984CE8 = (uint64_t)sub_100114588(16 * *v0);
  if (qword_100984CE8)
    return 0;
  else
    return 106;
}

uint64_t sub_1001E319C(unsigned int a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v6;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;

  v10 = 0;
  if (a2)
  {
    if (sub_1001DB044(a1, &v10))
      return 434;
    v4 = *(_QWORD **)sub_1001E4020(v10);
    if (!v4)
      return 434;
    if (*(_DWORD *)v4 != *(_DWORD *)a2 || *((unsigned __int16 *)v4 + 2) != *(unsigned __int16 *)(a2 + 4))
    {
      while (1)
      {
        v6 = v4;
        v4 = (_QWORD *)v4[2];
        if (!v4)
          return 434;
        if (*(_DWORD *)v4 == *(_DWORD *)a2 && *((unsigned __int16 *)v4 + 2) == *(unsigned __int16 *)(a2 + 4))
          goto LABEL_18;
      }
    }
    v6 = 0;
LABEL_18:
    v8 = v4[2];
    if (v6)
      v9 = v6 + 2;
    else
      v9 = (_QWORD *)sub_1001E4020(v10);
    *v9 = v8;
    sub_10018014C(v4[1], 0x13u);
    sub_100053298(v4);
    return 0;
  }
  else
  {
    sub_100253460();
    return 101;
  }
}

uint64_t sub_1001E3278(uint64_t a1, __int128 *a2, uint64_t a3)
{
  int v6;
  __int128 *v7;
  uint64_t v8;
  _OWORD v10[2];
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  _WORD v19[3];

  if (!a3)
    sub_100253460();
  v18 = 0;
  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  v11 = 0u;
  memset(v10, 0, sizeof(v10));
  if (a2)
  {
    v6 = 0;
  }
  else
  {
    if (!*(_QWORD *)sub_1001E4020(a1))
      return 426;
    v6 = 2;
  }
  v19[0] = *(_WORD *)(a3 + 4) + 2;
  v19[1] = 2;
  v19[2] = *(_WORD *)(a1 + 6);
  sub_1000532A8((uint64_t)&v11 + 8, 2u);
  sub_10005336C((unsigned __int8 *)&v11 + 8, (char *)v19, 6uLL, 0);
  sub_10025444C((unsigned __int8 *)&v11 + 8, a3);
  LOBYTE(v10[0]) = 0;
  *(_QWORD *)&v11 = 0;
  *(_QWORD *)&v12 = a1;
  if (a2)
    v7 = a2;
  else
    v7 = &xmmword_100984558;
  v8 = sub_1001F3A24((uint64_t)v10, v7, v6, *(_WORD *)(a1 + 4));
  if ((_DWORD)v8)
    sub_100253FD8((uint64_t)&v11 + 8);
  return v8;
}

void sub_1001E339C(uint64_t a1, _WORD *a2, unsigned int a3)
{
  __int16 v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  unint64_t v8;
  _WORD *v9;
  uint64_t v10;
  void (*v11)(uint64_t, _WORD *, uint64_t);

  if (a3 >= 6)
  {
    if (!a2)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/group.c");
    v4 = a3;
    v5 = (unsigned __int16)*a2;
    if (!*a2)
    {
      if (sub_10005549C())
      {
        sub_100054530("psm should be non-zero");
        v6 = sub_1000544A0(0x2Fu);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
          sub_1006CEF28(v6);
      }
    }
    if (*(_WORD *)sub_100252DE8(0x2Fu))
    {
      v7 = 0;
      v8 = 0;
      v9 = a2 + 1;
      v10 = (unsigned __int16)(v4 - 2);
      do
      {
        if ((_DWORD)v5 == *(unsigned __int16 *)(qword_100984CE8 + v7))
        {
          v11 = *(void (**)(uint64_t, _WORD *, uint64_t))(qword_100984CE8 + v7 + 8);
          if (v11)
            v11(v5, v9, v10);
        }
        ++v8;
        v7 += 16;
      }
      while (v8 < *(unsigned __int16 *)sub_100252DE8(0x2Fu));
    }
  }
}

uint64_t sub_1001E34A8(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  unsigned __int16 *v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  NSObject *v17;

  if (a1)
  {
    if (sub_10005549C())
    {
      sub_100054530("OI_L2CAP_Init: configuration parameter is deprecated");
      v2 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    sub_100252E2C(a1, 0x2Fu);
  }
  if (HIDWORD(xmmword_1009991F8))
    return 0;
  if (!sub_100252DE8(0x2Fu))
    sub_100253460();
  if (!sub_100252DE8(0x2Fu))
    return 127;
  v5 = (unsigned __int16 *)sub_100252DE8(0x2Fu);
  qword_100984CF0 = (uint64_t)sub_100114588(32 * *v5);
  if (!qword_100984CF0)
    return 106;
  v6 = sub_1001DAF38();
  if ((_DWORD)v6)
  {
    v3 = v6;
    if (sub_10005549C())
    {
      sub_100054530("OI_ChanMan_Init failed %!", v3);
      v7 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
LABEL_39:
        sub_1006CE7A4();
    }
  }
  else
  {
    v8 = sub_1001E3164();
    if ((_DWORD)v8)
    {
      v3 = v8;
      if (sub_10005549C())
      {
        sub_100054530("OI_GroupMan_Init failed %!", v3);
        v9 = sub_1000544A0(0x2Fu);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          goto LABEL_39;
      }
    }
    else
    {
      v10 = sub_1001FEEE0();
      if ((_DWORD)v10)
      {
        v3 = v10;
        if (sub_10005549C())
        {
          sub_100054530("OI_SignalMan_Init failed %!", v3);
          v11 = sub_1000544A0(0x2Fu);
          if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
            goto LABEL_39;
        }
      }
      else
      {
        v12 = sub_1001F359C();
        if ((_DWORD)v12)
        {
          v3 = v12;
          if (sub_10005549C())
          {
            sub_100054530("Sar_Init failed %!", v3);
            v13 = sub_1000544A0(0x2Fu);
            if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
              goto LABEL_39;
          }
        }
        else
        {
          v14 = sub_1001F28E8();
          if ((_DWORD)v14)
          {
            v3 = v14;
            if (sub_10005549C())
            {
              sub_100054530("Queue_Init failed %!", v3);
              v15 = sub_1000544A0(0x2Fu);
              if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
                goto LABEL_39;
            }
          }
          else
          {
            if (!BYTE9(xmmword_100998F98) || (sub_1001DD8F4(), !(_DWORD)v16))
            {
              v3 = 0;
              HIDWORD(xmmword_1009991F8) = 1;
              return v3;
            }
            v3 = v16;
            if (sub_10005549C())
            {
              sub_100054530("LE_SecurityCbInit failed %!", v3);
              v17 = sub_1000544A0(0x2Fu);
              if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
                goto LABEL_39;
            }
          }
        }
      }
    }
  }
  return v3;
}

uint64_t sub_1001E3794(unsigned __int16 *a1)
{
  unsigned __int16 i;
  unsigned int v3;
  uint64_t result;

  for (i = 192; ; ++i)
  {
    v3 = i;
    if ((sub_1001E37E8(i) & 1) == 0)
      break;
    if (v3 >= 0xFF)
      return 104;
  }
  result = 0;
  *a1 = i;
  return result;
}

uint64_t sub_1001E37E8(int a1)
{
  uint64_t v2;
  unint64_t v3;

  if (!*(_WORD *)sub_100252DE8(0x2Fu))
    return 0;
  v2 = 0;
  v3 = 0;
  while (*(unsigned __int16 *)(qword_100984CF0 + v2) != a1 || *(_BYTE *)(qword_100984CF0 + v2 + 24) != 1)
  {
    ++v3;
    v2 += 32;
    if (v3 >= *(unsigned __int16 *)sub_100252DE8(0x2Fu))
      return 0;
  }
  return 1;
}

uint64_t sub_1001E3870(int a1, uint64_t a2)
{
  if (!HIDWORD(xmmword_1009991F8))
    sub_100253460();
  if ((a1 & 0x1010101) == 1)
    return sub_1001E38D0(a1, 0, a2, 0);
  else
    return 482;
}

uint64_t sub_1001E38D0(int a1, char a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  uint64_t v9;
  unint64_t v10;
  NSObject *v11;
  uint64_t v12;

  if ((sub_1001E3C48(a1) & 1) != 0 || (sub_1001E37E8(a1) & 1) != 0)
    return 402;
  if (*(_WORD *)sub_100252DE8(0x2Fu))
  {
    v9 = 0;
    v10 = 0;
    while (*(_WORD *)(qword_100984CF0 + v9))
    {
      ++v10;
      v9 += 32;
      if (v10 >= *(unsigned __int16 *)sub_100252DE8(0x2Fu))
        goto LABEL_8;
    }
    result = 0;
    v12 = qword_100984CF0 + v9;
    *(_WORD *)v12 = a1;
    *(_QWORD *)(v12 + 8) = a3;
    *(_QWORD *)(v12 + 16) = a4;
    *(_BYTE *)(v12 + 24) = a2;
  }
  else
  {
LABEL_8:
    if (sub_10005549C())
    {
      sub_100054530("Could not register L2CAP: no resources.");
      v11 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 104;
  }
  return result;
}

uint64_t sub_1001E39CC(int a1, uint64_t a2)
{
  if (!HIDWORD(xmmword_1009991F8))
    sub_100253460();
  if ((a1 - 1) < 0x7F || (a1 & 0xFF80) == 0x80)
    return sub_1001E38D0(a1, 1, 0, a2);
  else
    return 482;
}

uint64_t sub_1001E3A38(int a1)
{
  return sub_1001E3A40(a1, 0);
}

uint64_t sub_1001E3A40(int a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t result;
  int v8;
  uint64_t v9;

  v4 = sub_1001DAF2C();
  if (!*(_WORD *)sub_100252DE8(0x2Fu))
    return 120;
  v5 = 0;
  v6 = 0;
  while (*(unsigned __int16 *)(qword_100984CF0 + v5) != a1 || *(unsigned __int8 *)(qword_100984CF0 + v5 + 24) != a2)
  {
    ++v6;
    v5 += 32;
    if (v6 >= *(unsigned __int16 *)sub_100252DE8(0x2Fu))
      return 120;
  }
  if (*(_WORD *)(sub_100252DE8(0x2Fu) + 2))
  {
    v8 = 0;
    while (*(_DWORD *)v4 != 2
         || !*(_BYTE *)(sub_1001E3CCC((int *)v4) + 16)
         || !*(_BYTE *)(sub_1001E3CCC((int *)v4) + 24)
         || *(unsigned __int16 *)(v4 + 6) != a1)
    {
      v4 += 144;
      if (++v8 >= *(unsigned __int16 *)(sub_100252DE8(0x2Fu) + 2))
        goto LABEL_14;
    }
    return 141;
  }
  else
  {
LABEL_14:
    result = 0;
    v9 = qword_100984CF0 + v5;
    *(_WORD *)v9 = 0;
    *(_QWORD *)(v9 + 8) = 0;
    *(_QWORD *)(v9 + 16) = 0;
    *(_BYTE *)(v9 + 24) = 0;
  }
  return result;
}

uint64_t sub_1001E3B60(int a1)
{
  return sub_1001E3A40(a1, 1);
}

uint64_t sub_1001E3B68(_WORD *a1)
{
  char v2;
  int v3;
  int v4;
  char v5;
  unsigned __int16 v6;
  NSObject *v7;

  if (!a1)
    sub_100253460();
  v2 = 0;
  v3 = 61435;
  v4 = 4101;
  do
  {
    if ((v2 & 1) != 0)
      return 0;
    if ((v4 & 0x101) != 1)
      sub_100253460();
    v5 = sub_1001E3C48((unsigned __int16)v4);
    if ((v5 & 1) == 0)
      *a1 = v4;
    v2 = v5 ^ 1;
    v6 = v4 + 2;
    if (((v4 + 2) & 0x100) != 0)
      v6 = v4 + 258;
    if (v6 <= 0x1005u)
      v4 = 4101;
    else
      v4 = v6;
    --v3;
  }
  while (v3);
  if (sub_10005549C())
  {
    sub_100054530("Failed to allocate PSM: no resources.");
    v7 = sub_1000544A0(0x2Fu);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  return 104;
}

uint64_t sub_1001E3C48(int a1)
{
  uint64_t v2;
  unint64_t v3;

  if (!*(_WORD *)sub_100252DE8(0x2Fu))
    return 0;
  v2 = 0;
  v3 = 0;
  while (*(unsigned __int16 *)(qword_100984CF0 + v2) != a1 || *(_BYTE *)(qword_100984CF0 + v2 + 24))
  {
    ++v3;
    v2 += 32;
    if (v3 >= *(unsigned __int16 *)sub_100252DE8(0x2Fu))
      return 0;
  }
  return 1;
}

uint64_t sub_1001E3CCC(int *a1)
{
  int v2;
  NSObject *v4;
  uint64_t result;

  v2 = *a1;
  if (*a1 != 2 && v2 != 4)
  {
    if (sub_10005549C())
    {
      sub_100054530("Invalid access: type %d, cid %d, psm %d", *a1, *((unsigned __int16 *)a1 + 2), *((unsigned __int16 *)a1 + 3));
      v4 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    v2 = *a1;
  }
  if (v2 != 2 && v2 != 4)
    sub_100253460();
  result = *((_QWORD *)a1 + 14);
  if (!result)
  {
    sub_100253460();
    return *((_QWORD *)a1 + 14);
  }
  return result;
}

uint64_t sub_1001E3D78(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  unint64_t v7;
  NSObject *v8;
  NSObject *v9;

  if (*(_WORD *)sub_100252DE8(0x2Fu))
  {
    v6 = 0;
    v7 = 0;
    while (*(unsigned __int16 *)(qword_100984CF0 + v6) != (_DWORD)a3 || *(_BYTE *)(qword_100984CF0 + v6 + 24))
    {
      ++v7;
      v6 += 32;
      if (v7 >= *(unsigned __int16 *)sub_100252DE8(0x2Fu))
        goto LABEL_6;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(qword_100984CF0 + v6 + 8))(a3, a1, a2);
    return 0;
  }
  else
  {
LABEL_6:
    if (sub_10005549C())
    {
      sub_100054530("%! (%d over %d", 407, a3, 0);
      v8 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    if (sub_10005549C())
    {
      sub_100054530("addr %:", a1);
      v9 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    return 407;
  }
}

uint64_t sub_1001E3EBC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  unint64_t v10;
  NSObject *v11;
  NSObject *v12;
  _QWORD v14[2];

  if (*(_WORD *)sub_100252DE8(0x2Fu))
  {
    v9 = 0;
    v10 = 0;
    while (*(unsigned __int16 *)(qword_100984CF0 + v9) != (_DWORD)a3 || *(_BYTE *)(qword_100984CF0 + v9 + 24) != 1)
    {
      ++v10;
      v9 += 32;
      if (v10 >= *(unsigned __int16 *)sub_100252DE8(0x2Fu))
        goto LABEL_6;
    }
    v14[0] = 0;
    v14[1] = 0;
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD *))(qword_100984CF0 + v9 + 16))(a3, a1, a2, a5, v14);
    return 0;
  }
  else
  {
LABEL_6:
    if (sub_10005549C())
    {
      sub_100054530("%! (%d over %d)", 407, a3, 1);
      v11 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    if (sub_10005549C())
    {
      sub_100054530("addr %:", a1);
      v12 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    return 407;
  }
}

uint64_t sub_1001E4020(uint64_t a1)
{
  NSObject *v2;
  uint64_t result;

  if (*(_DWORD *)a1 != 1)
  {
    if (sub_10005549C())
    {
      sub_100054530("Invalid access: type %d, cid %d, psm %d", *(_DWORD *)a1, *(unsigned __int16 *)(a1 + 4), *(unsigned __int16 *)(a1 + 6));
      v2 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    if (*(_DWORD *)a1 != 1)
      sub_100253460();
  }
  result = *(_QWORD *)(a1 + 104);
  if (!result)
  {
    sub_100253460();
    return *(_QWORD *)(a1 + 104);
  }
  return result;
}

uint64_t sub_1001E40C4(uint64_t a1)
{
  NSObject *v2;
  uint64_t result;

  if (*(_DWORD *)a1 != 3)
  {
    if (sub_10005549C())
    {
      sub_100054530("Invalid access: type %d, cid %d, psm %d", *(_DWORD *)a1, *(unsigned __int16 *)(a1 + 4), *(unsigned __int16 *)(a1 + 6));
      v2 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    if (*(_DWORD *)a1 != 3)
      sub_100253460();
  }
  result = *(_QWORD *)(a1 + 120);
  if (!result)
  {
    sub_100253460();
    return *(_QWORD *)(a1 + 120);
  }
  return result;
}

uint64_t sub_1001E4168()
{
  return byte_100984CF8;
}

uint64_t sub_1001E4174(uint64_t result)
{
  byte_100984CF8 = result;
  return result;
}

uint64_t sub_1001E4180(uint64_t *a1, _QWORD *a2)
{
  char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  const char *v48;
  uint64_t result;
  void *v50;
  void *v51;
  uint64_t v52;
  uint64_t v53;
  char __str[16];
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;

  v4 = getenv("BT_HCI_TRANSPORT");
  if (v4)
  {
    v68 = 0u;
    v69 = 0u;
    v66 = 0u;
    v67 = 0u;
    v64 = 0u;
    v65 = 0u;
    v62 = 0u;
    v63 = 0u;
    v60 = 0u;
    v61 = 0u;
    v58 = 0u;
    v59 = 0u;
    v56 = 0u;
    v57 = 0u;
    *(_OWORD *)__str = 0u;
    v55 = 0u;
    __strlcpy_chk(__str, v4, 256, 256);
    v12 = strtok(__str, ":");
    if (v12)
    {
      v20 = v12;
      sub_100253320((uint64_t)"Searching for transport: \"%s\"\n", v13, v14, v15, v16, v17, v18, v19, (uint64_t)v12);
      v28 = (uint64_t *)&off_10091ED08;
      do
      {
        v29 = *v28;
        if (!*v28)
        {
          sub_100253320((uint64_t)"FATAL ERROR - HCI Transport\t%s could not be matched.\n", v21, v22, v23, v24, v25, v26, v27, (uint64_t)v20);
          return 1065;
        }
        ++v28;
      }
      while (strcmp(*(const char **)(v29 + 8), v20));
      v30 = strtok(0, ":");
      if (v30)
      {
        v38 = sub_1001E4458(v30, v31, v32, v33, v34, v35, v36, v37);
        if (!v38)
          return 1065;
        v39 = v38;
        v40 = strtok(0, ":");
        if (v40)
          *(_QWORD *)(v39 + 16) = strdup(v40);
        goto LABEL_15;
      }
      v39 = sub_1001E4458(*(const char **)(v29 + 8), v31, v32, v33, v34, v35, v36, v37);
      if (v39)
      {
LABEL_15:
        result = 0;
        *a1 = v39;
        *a2 = v29;
        return result;
      }
    }
    return 1065;
  }
  sub_100253320((uint64_t)"BT_HCI_TRANSPORT not set - Attempting to read from plist.\n", v5, v6, v7, v8, v9, v10, v11, v52);
  switch(sub_1001702EC())
  {
    case 0u:
      v48 = "HCI Transport is set to USB\n";
      goto LABEL_25;
    case 1u:
      sub_100253320((uint64_t)"HCI Transport is set to H4\n", v41, v42, v43, v44, v45, v46, v47, v53);
      result = 0;
      v50 = &unk_100978730;
      goto LABEL_20;
    case 2u:
      sub_100253320((uint64_t)"HCI Transport is set to H4DS\n", v41, v42, v43, v44, v45, v46, v47, v53);
      result = 0;
      v50 = &unk_100978878;
      goto LABEL_20;
    case 3u:
      sub_100253320((uint64_t)"HCI Transport is set to H4BC\n", v41, v42, v43, v44, v45, v46, v47, v53);
      result = 0;
      v50 = &unk_1009787D0;
      goto LABEL_20;
    case 4u:
      sub_100253320((uint64_t)"HCI Transport is set to H5\n", v41, v42, v43, v44, v45, v46, v47, v53);
      result = 0;
      v50 = &unk_100978918;
LABEL_20:
      *a2 = v50;
      v51 = &unk_100978630;
      goto LABEL_27;
    case 5u:
      v48 = "BCSP Transport not supported - Setting to USB\n";
      goto LABEL_25;
    case 6u:
      sub_100253320((uint64_t)"HCI Transport is set to APPLEBT\n", v41, v42, v43, v44, v45, v46, v47, v53);
      result = 0;
      *a2 = &unk_100978588;
      v51 = &unk_100978508;
      goto LABEL_27;
    case 7u:
      sub_100253320((uint64_t)"HCI Transport is set to PCIE Skywalk\n", v41, v42, v43, v44, v45, v46, v47, v53);
      result = 0;
      *a2 = &unk_100978468;
      v51 = &unk_1009783E8;
      goto LABEL_27;
    case 0xAu:
      sub_100253320((uint64_t)"HCI Transport is set to virtual\n", v41, v42, v43, v44, v45, v46, v47, v53);
      result = 0;
      *a2 = &unk_10097A968;
      v51 = &unk_10097A8E8;
      goto LABEL_27;
    default:
      v48 = "HCI Transport is unknown - Setting to USB\n";
LABEL_25:
      sub_100253320((uint64_t)v48, v41, v42, v43, v44, v45, v46, v47, v53);
      result = 0;
      *a2 = &unk_100978A38;
      v51 = &unk_1009789B8;
LABEL_27:
      *a1 = (uint64_t)v51;
      break;
  }
  return result;
}

uint64_t sub_1001E4458(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *i;
  uint64_t v17;

  sub_100253320((uint64_t)"Searching for driver: \"%s\"\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)a1);
  for (i = (uint64_t *)&off_10091ED60; ; ++i)
  {
    v17 = *i;
    if (!*i)
      break;
    if (!strcmp(*(const char **)(v17 + 8), a1))
      return v17;
  }
  sub_100253320((uint64_t)"FATAL ERROR - HCI Driver\t %s could not be matched.\n", v9, v10, v11, v12, v13, v14, v15, (uint64_t)a1);
  return v17;
}

uint64_t sub_1001E44D0(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  __int16 v3;
  __int16 v4;
  uint64_t result;
  NSObject *v6;
  NSObject *v7;
  unsigned int v8;
  int *v12;

  v2 = *(unsigned __int16 *)(a1 + 36);
  v12 = 0;
  if (v2 == *(unsigned __int16 *)(a2 + 36))
  {
    v3 = *(_WORD *)(a1 + 38);
    v4 = *(_WORD *)(a2 + 38);
    if (!sub_1001DB044(v2, (uint64_t *)&v12))
    {
      v8 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(v12) + 112) + 4);
      if (v3 <= v8 || v4 <= v8)
      {
        if (v3 < v8 && v4 > v8)
          return 1;
        if (v3 > v8 && v4 < v8)
          return 0xFFFFFFFFLL;
      }
      return v3 - v4;
    }
    result = sub_10005549C();
    if ((_DWORD)result)
    {
      sub_100054530("Can't get channel (0x%x), this is bad.", v2);
      v6 = sub_1000544A0(0x2Fu);
      result = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
      if ((_DWORD)result)
      {
        sub_1006CE7A4();
        return 0;
      }
    }
  }
  else
  {
    result = sub_10005549C();
    if ((_DWORD)result)
    {
      sub_100054530("WTF ?? Can't compare 2 packets with different CID");
      v7 = sub_1000544A0(0x2Fu);
      result = os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
      if ((_DWORD)result)
      {
        sub_1006CE7A4();
        return 0;
      }
    }
  }
  return result;
}

void sub_1001E45FC(unsigned __int16 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;

  sub_100253320((uint64_t)"cid=0x%x, txState=%s, rxState=%s, nextTxSeq=%d, expectedACKSeq=%d, expectedTxSeq=%d, bufferSeq=%d, remoteBusy=%d, localbusy=%d", a2, a3, a4, a5, a6, a7, a8, *a1);
  sub_100253320((uint64_t)"sRejListSize=%d, retryCount=%d, rnrSent=%d, rejActioned=%d, srejActioned=%d, sRejSaveReqSeq=%d, sendRej=%d, bufferSeqSrej=%d, framesSent=%d\n", v9, v10, v11, v12, v13, v14, v15, a1[72]);
  if (*((_DWORD *)a1 + 40))
    v23 = "YES";
  else
    v23 = "NO";
  sub_100253320((uint64_t)"retransmissionTimer=%s, monitorTimer=%s\n", v16, v17, v18, v19, v20, v21, v22, (uint64_t)v23);
}

uint64_t sub_1001E471C(int *a1)
{
  int v2;
  uint64_t v3;
  int v4;
  char v5;

  *(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 2) = 0;
  v2 = *(unsigned __int8 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 16);
  v3 = *(_QWORD *)(sub_1001E3CCC(a1) + 112);
  v4 = *(unsigned __int8 *)(v3 + 14);
  *(_BYTE *)(v3 + 14) = 0;
  v5 = v4 != 0;
  if (v2)
    return sub_1001E4788((uint64_t)a1, 1, v5);
  else
    return sub_1001E49E0((uint64_t)a1, 1, v5);
}

uint64_t sub_1001E4788(uint64_t a1, char a2, char a3)
{
  uint64_t v6;
  size_t v7;
  uint64_t v8;
  NSObject *v9;
  __int16 v11;
  __int128 v12;
  __int128 v13;
  _OWORD v14[7];
  uint64_t v15;
  uint64_t v16;

  v15 = 0;
  memset(v14, 0, sizeof(v14));
  v12 = 0u;
  v13 = 0u;
  v16 = 0;
  v11 = 0;
  LOBYTE(v12) = *(__int16 *)(sub_1001E3CCC((int *)a1) + 38) == -1;
  *((_QWORD *)&v12 + 1) = *(_QWORD *)sub_1001E3CCC((int *)a1);
  LODWORD(v13) = 0;
  WORD2(v13) = *(_WORD *)(a1 + 4);
  WORD3(v13) = 256;
  BYTE8(v13) = 0;
  v6 = sub_1001E3CCC((int *)a1);
  v7 = (sub_1001EF8A8((int *)a1, 2, a2, a3, *(_BYTE *)(*(_QWORD *)(v6 + 112) + 10), (_WORD *)&v16 + 2)+ 4);
  WORD5(v13) = 2 * (*(_BYTE *)(sub_1001E3CCC((int *)a1) + 78) != 0) + v7;
  LOBYTE(v16) = v7 - 4 + 2 * (*(_BYTE *)(sub_1001E3CCC((int *)a1) + 78) != 0);
  BYTE1(v16) = (unsigned __int16)(v7 - 4 + 2 * (*(_BYTE *)(sub_1001E3CCC((int *)a1) + 78) != 0)) >> 8;
  WORD1(v16) = *(_WORD *)(sub_1001E3CCC((int *)a1) + 8);
  sub_1000532A8((uint64_t)v14 + 8, 2u);
  sub_10005336C((unsigned __int8 *)v14 + 8, (char *)&v16, v7, 2u);
  if (*(_BYTE *)(sub_1001E3CCC((int *)a1) + 78))
  {
    sub_1001EE884((uint64_t)v14 + 8, &v11);
    sub_10005336C((unsigned __int8 *)v14 + 8, (char *)&v11, 2uLL, 2u);
  }
  v8 = sub_1001F21A8((uint64_t)&v12);
  if ((_DWORD)v8)
  {
    if (sub_10005549C())
    {
      sub_100054530("Failed to send S-Frame %!.", v8);
      v9 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  else
  {
    *(_BYTE *)(*(_QWORD *)(sub_1001E3CCC((int *)a1) + 112) + 147) = 1;
  }
  return v8;
}

uint64_t sub_1001E49C0(int *a1)
{
  uint64_t v1;
  uint64_t result;

  v1 = *(_QWORD *)(sub_1001E3CCC(a1) + 112);
  result = *(unsigned __int8 *)(v1 + 14);
  *(_BYTE *)(v1 + 14) = 0;
  return result;
}

uint64_t sub_1001E49E0(uint64_t a1, char a2, char a3)
{
  uint64_t v6;
  size_t v7;
  uint64_t v8;
  NSObject *v9;
  __int16 v11;
  __int128 v12;
  __int128 v13;
  _OWORD v14[7];
  uint64_t v15;
  uint64_t v16;

  v15 = 0;
  memset(v14, 0, sizeof(v14));
  v12 = 0u;
  v13 = 0u;
  v16 = 0;
  v11 = 0;
  LOBYTE(v12) = *(__int16 *)(sub_1001E3CCC((int *)a1) + 38) == -1;
  *((_QWORD *)&v12 + 1) = *(_QWORD *)sub_1001E3CCC((int *)a1);
  LODWORD(v13) = 0;
  WORD2(v13) = *(_WORD *)(a1 + 4);
  WORD3(v13) = 256;
  BYTE8(v13) = 0;
  v6 = sub_1001E3CCC((int *)a1);
  v7 = (sub_1001EF8A8((int *)a1, 0, a2, a3, *(_BYTE *)(*(_QWORD *)(v6 + 112) + 10), (_WORD *)&v16 + 2)+ 4);
  WORD5(v13) = 2 * (*(_BYTE *)(sub_1001E3CCC((int *)a1) + 78) != 0) + v7;
  LOBYTE(v16) = v7 - 4 + 2 * (*(_BYTE *)(sub_1001E3CCC((int *)a1) + 78) != 0);
  BYTE1(v16) = (unsigned __int16)(v7 - 4 + 2 * (*(_BYTE *)(sub_1001E3CCC((int *)a1) + 78) != 0)) >> 8;
  WORD1(v16) = *(_WORD *)(sub_1001E3CCC((int *)a1) + 8);
  sub_1000532A8((uint64_t)v14 + 8, 2u);
  sub_10005336C((unsigned __int8 *)v14 + 8, (char *)&v16, v7, 2u);
  if (*(_BYTE *)(sub_1001E3CCC((int *)a1) + 78))
  {
    sub_1001EE884((uint64_t)v14 + 8, &v11);
    sub_10005336C((unsigned __int8 *)v14 + 8, (char *)&v11, 2uLL, 2u);
  }
  v8 = sub_1001F21A8((uint64_t)&v12);
  if ((_DWORD)v8)
  {
    if (sub_10005549C())
    {
      sub_100054530("Failed to send S-Frame %!.", v8);
      v9 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  return v8;
}

uint64_t sub_1001E4C04(int *a1, char a2)
{
  uint64_t result;

  result = sub_1001E3CCC(a1);
  *(_BYTE *)(*(_QWORD *)(result + 112) + 156) = a2;
  return result;
}

uint64_t sub_1001E4C2C(int *a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  NSObject *v7;
  uint64_t v8;

  v3 = sub_1001E3CCC(a1);
  v4 = sub_100251684(*(_QWORD *)(*(_QWORD *)(v3 + 112) + 176));
  v8 = v4;
  if (v4)
  {
    while (1)
    {
      v5 = sub_1002516A8(v4);
      if (*(unsigned __int16 *)(v5 + 38) == a2)
        return *(unsigned __int8 *)(v5 + 48);
      sub_10025168C((uint64_t)&v8);
      v4 = v8;
      if (!v8)
        goto LABEL_4;
    }
  }
  else
  {
LABEL_4:
    result = sub_10005549C();
    if ((_DWORD)result)
    {
      sub_100054530("Could not find frame %d in retransmission list", a2);
      v7 = sub_1000544A0(0x2Fu);
      result = os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
      if ((_DWORD)result)
      {
        sub_1006CE7A4();
        return 0;
      }
    }
  }
  return result;
}

void sub_1001E4CD8(uint64_t a1, _BYTE *a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  unint64_t v11;
  NSObject *v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  NSObject *v23;
  unsigned int v24;
  _WORD *v25;
  uint64_t v26;
  __int16 v27;
  __int16 v28;
  NSObject *v29;
  NSObject *v30;
  unsigned __int16 v31;
  void *v32;
  NSObject *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint8_t buf[4];
  void *v51;

  if (!a2 || a3 <= 1)
  {
    if (sub_10005549C())
    {
      sub_100054530("Received bad packet with length %d", a3);
      v13 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    goto LABEL_14;
  }
  if ((*a2 & 1) != 0)
  {
    if (a3 != 2 && a3 != 4)
    {
      if (sub_10005549C())
      {
        sub_100054530("Received bad S-Frame packet with length %d", a3);
        v29 = sub_1000544A0(0x2Fu);
        if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
          sub_1006CEEC0();
      }
      goto LABEL_14;
    }
    v22 = *(unsigned __int16 *)a2;
    if ((_DWORD)a4)
    {
      if (sub_10005549C())
      {
        sub_100054530("AP wakeup by SFrame bundleID=com.apple.bluetoothd, dataLen=%d", a3);
        v23 = sub_1000544A0(0x2Fu);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446210;
          v51 = sub_100054494();
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
        }
      }
    }
    if (!*(_BYTE *)(*(_QWORD *)(sub_1001E3CCC((int *)a1) + 112) + 3))
    {
      sub_1001E6F68(a1, v22);
      return;
    }
    if (*(_BYTE *)(*(_QWORD *)(sub_1001E3CCC((int *)a1) + 112) + 3) == 1)
      __asm { BR              X10 }
    if (*(_BYTE *)(*(_QWORD *)(sub_1001E3CCC((int *)a1) + 112) + 3) == 2)
      __asm { BR              X10 }
LABEL_49:
    v34 = sub_1001E3CCC((int *)a1);
    sub_1001E45FC(*(unsigned __int16 **)(v34 + 112), v35, v36, v37, v38, v39, v40, v41);
    v42 = sub_1001E3CCC((int *)a1);
    sub_1001E45FC(*(unsigned __int16 **)(v42 + 112), v43, v44, v45, v46, v47, v48, v49);
    return;
  }
  v10 = sub_1001E3CCC((int *)a1);
  v11 = 4;
  if (!*(_BYTE *)(v10 + 78))
    v11 = 2;
  if (v11 > a3)
  {
    if (sub_10005549C())
    {
      sub_100054530("Received bad I-Frame packet with length %d", a3);
      v12 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
LABEL_14:
    v14 = sub_1001E3CCC((int *)a1);
    sub_1001E45FC(*(unsigned __int16 **)(v14 + 112), v15, v16, v17, v18, v19, v20, v21);
    return;
  }
  v24 = *(unsigned __int16 *)a2;
  v25 = sub_100052DC0(0x18uLL);
  if (v25)
  {
    v26 = (uint64_t)v25;
    *v25 = *(_WORD *)(a1 + 4);
    v25[1] = (v24 >> 1) & 0x3F;
    *((_BYTE *)v25 + 4) = v24 >> 14;
    if (v24 >> 14 == 1)
    {
      v27 = a2[2] | (a2[4] << 8);
      v28 = -4;
    }
    else
    {
      v27 = 0;
      v28 = -2;
    }
    v31 = v28 + a3;
    v25[3] = v27;
    v25[8] = v31;
    v32 = sub_100052DC0(v31);
    *(_QWORD *)(v26 + 8) = v32;
    if (v32)
    {
      memmove(v32, &a2[a3 - *(unsigned __int16 *)(v26 + 16)], *(unsigned __int16 *)(v26 + 16));
      if (!*(_BYTE *)(*(_QWORD *)(sub_1001E3CCC((int *)a1) + 112) + 3))
      {
        sub_1001E892C((int *)a1, v24, v26, a4, a5);
        return;
      }
      if (*(_BYTE *)(*(_QWORD *)(sub_1001E3CCC((int *)a1) + 112) + 3) == 1)
      {
        sub_1001E94E8((int *)a1, v24, v26, a4, a5);
        return;
      }
      if (*(_BYTE *)(*(_QWORD *)(sub_1001E3CCC((int *)a1) + 112) + 3) == 2)
      {
        sub_1001E9A10((int *)a1, v24, v26, a4, a5);
        return;
      }
      goto LABEL_49;
    }
    sub_100053298((void *)v26);
    if (sub_10005549C())
    {
      sub_100054530("Could not allocate enough memory for incoming frame.");
      v33 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
        goto LABEL_44;
    }
  }
  else if (sub_10005549C())
  {
    sub_100054530("Could not allocate enough memory for incoming frame.");
    v30 = sub_1000544A0(0x2Fu);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
LABEL_44:
      sub_1006CE7A4();
  }
}

void sub_1001E6F68(uint64_t a1, int a2)
{
  __asm { BR              X10 }
}

uint64_t sub_1001E6FAC()
{
  uint64_t v0;
  unsigned int v1;
  unsigned int v2;
  unsigned int v3;
  int v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  unsigned int v16;
  int v17;
  _BOOL4 v18;
  unsigned int v19;
  int v20;
  _BOOL4 v21;
  unsigned int v22;
  int v23;
  _BOOL4 v24;
  _BOOL4 v25;
  NSObject *v26;
  uint64_t v27;
  uint64_t v28;
  NSObject *v29;
  NSObject *v30;
  NSObject *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  unsigned int v41;
  int v42;
  int v43;
  unsigned int v44;
  int v45;
  _BOOL4 v46;
  unsigned int v47;
  int v48;
  _BOOL4 v49;
  unsigned int v50;
  int v51;
  _BOOL4 v52;
  NSObject *v53;

  if (!(v1 & 0x80 | (v1 >> 4) & 1))
  {
    v6 = (v1 >> 8) & 0x3F;
    if (*(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 6) <= v6
      && v6 <= *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 4))
    {
      goto LABEL_13;
    }
    v7 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 6);
    v8 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 6);
    if (v7 <= v6)
    {
      if (v6 - v8 <= *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 176) + 32))
      {
LABEL_13:
        sub_1001EB06C(v0, (v1 >> 8) & 0x3F, 0);
        if (*(_BYTE *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 15))
        {
          v9 = sub_1001E3CCC((int *)v0);
          if (sub_100056080(*(_QWORD *)(*(_QWORD *)(v9 + 112) + 176)))
          {
            v10 = sub_1001EAE74((int *)v0);
            if ((_DWORD)v10)
            {
              v11 = v10;
              if (sub_10005549C())
              {
                sub_100054530("Failed to start retransmission timer %!.", v11);
                v12 = sub_1000544A0(0x2Fu);
                if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
                  sub_1006CE7A4();
              }
            }
          }
        }
        *(_BYTE *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 15) = 0;
        goto LABEL_20;
      }
    }
    else if (((*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 176) + 32)
              + (_BYTE)v8) & 0x3Fu) >= v6)
    {
      goto LABEL_13;
    }
    if (!sub_10005549C())
      goto LABEL_63;
    if (*(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 6) <= v6
      && v6 <= *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 4))
    {
      v18 = 1;
    }
    else
    {
      v16 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 6);
      v17 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 6);
      v18 = v16 <= v6
          ? v6 - v17 <= *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 176) + 32)
          : ((*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 176) + 32)
            + (_BYTE)v17) & 0x3Fu) >= v6;
    }
    sub_100054530("S-Frame Receiver Ready Error: ValidReqSeq %d, ValidF-bit %d", v18, 1);
    v30 = sub_1000544A0(0x2Fu);
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      goto LABEL_63;
    goto LABEL_62;
  }
  if ((v1 & 0x80) != 0)
  {
    v13 = (v1 >> 8) & 0x3F;
    if (*(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 6) > v13
      || v13 > *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 4))
    {
      v14 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 6);
      v15 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 6);
      if (v14 <= v13)
      {
        if (v13 - v15 > *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 176) + 32))
        {
LABEL_34:
          if (!sub_10005549C())
            goto LABEL_63;
          if (*(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 6) <= v13
            && v13 <= *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 4))
          {
            v21 = 1;
          }
          else
          {
            v19 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 6);
            v20 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 6);
            v21 = v19 <= v13
                ? v13 - v20 <= *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 176) + 32)
                : ((*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 176) + 32)
                  + (_BYTE)v20) & 0x3Fu) >= v13;
          }
          v25 = *(_BYTE *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 2) == 0;
          sub_100054530("S-Frame Receiver Ready Error: ValidReqSeq %d, ValidF-bit %d", v21, v25);
          v26 = sub_1000544A0(0x2Fu);
          if (!os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
            goto LABEL_63;
          goto LABEL_62;
        }
      }
      else if (((*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 176) + 32)
                + (_BYTE)v15) & 0x3Fu) < v13)
      {
        goto LABEL_34;
      }
    }
    if (*(_BYTE *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 2))
      goto LABEL_34;
    *(_BYTE *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 15) = 0;
    sub_1001EB06C(v0, (v1 >> 8) & 0x3F, 1);
    if (*(_BYTE *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 148))
    {
      v5 = 0;
      *(_BYTE *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 148) = 0;
      return v5;
    }
    v27 = sub_1001EB21C(v0, (v1 >> 8) & 0x3F, (v1 & 0x10) != 0);
    if ((_DWORD)v27)
    {
      v28 = v27;
      if (sub_10005549C())
      {
        sub_100054530("Failed to retransmit I-Frames %!.", v28);
        v29 = sub_1000544A0(0x2Fu);
        if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
    }
LABEL_20:
    sub_1001EB1D8(v0, 0);
    return 0;
  }
  if (((v1 >> 4) & 1) != 0)
  {
    v2 = (v1 >> 8) & 0x3F;
    if (*(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 6) <= v2
      && v2 <= *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 4))
    {
      goto LABEL_8;
    }
    v3 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 6);
    v4 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 6);
    if (v3 <= v2)
    {
      if (v2 - v4 <= *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 176) + 32))
        goto LABEL_8;
    }
    else if (((*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 176) + 32)
              + (_BYTE)v4) & 0x3Fu) >= v2)
    {
LABEL_8:
      sub_1001EB06C(v0, (v1 >> 8) & 0x3F, 0);
      sub_1001EB500((int *)v0);
      v5 = 0;
      *(_BYTE *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 15) = 0;
      return v5;
    }
    if (sub_10005549C())
    {
      if (*(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 6) <= v2
        && v2 <= *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 4))
      {
        v24 = 1;
      }
      else
      {
        v22 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 6);
        v23 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 6);
        v24 = v22 <= v2
            ? v2 - v23 <= *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 176) + 32)
            : ((*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 176) + 32)
              + (_BYTE)v23) & 0x3Fu) >= v2;
      }
      sub_100054530("S-Frame Receiver Ready Error: ValidReqSeq %d, ValidF-bit %d", v24, 1);
      v31 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
LABEL_62:
        sub_1006CEEC0();
    }
  }
LABEL_63:
  v32 = sub_1001E3CCC((int *)v0);
  sub_1001E45FC(*(unsigned __int16 **)(v32 + 112), v33, v34, v35, v36, v37, v38, v39);
  if (sub_10005549C())
  {
    v40 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 6);
    v41 = (v1 >> 8) & 0x3F;
    v42 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 4);
    v43 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 176) + 32);
    if (*(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 6) <= v41
      && v41 <= *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 4))
    {
      v46 = 1;
    }
    else
    {
      v44 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 6);
      v45 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 6);
      if (v44 <= v41)
        v46 = v41 - v45 <= *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 176) + 32);
      else
        v46 = ((*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 176) + 32)
              + (_BYTE)v45) & 0x3Fu) >= v41;
    }
    if (*(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 6) <= v41
      && v41 <= *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 4))
    {
      v49 = 1;
    }
    else
    {
      v47 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 6);
      v48 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 6);
      if (v47 <= v41)
        v49 = v41 - v48 <= *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 176) + 32);
      else
        v49 = ((*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 176) + 32)
              + (_BYTE)v48) & 0x3Fu) >= v41;
    }
    v50 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 6);
    v51 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 6);
    if (v50 <= v41)
      v52 = v41 - v51 <= *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 176) + 32);
    else
      v52 = ((*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC((int *)v0) + 112) + 176) + 32)
            + (_BYTE)v51) & 0x3Fu) >= v41;
    sub_100054530("Invalid S-Frame header while in RECV e:%d, r:%d, n:%d, u:%d, WITH_VALID_REQSEQ=%d, WITH_VALID_REQSEQ_VALUE=%d, WITH_VALID_REQSEQ_BOUNDS=%d", v40, v41, v42, v43, v46, v49, v52);
    v53 = sub_1000544A0(0x2Fu);
    if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return sub_1001DEB7C(*(unsigned __int16 *)(v0 + 4), 436);
}

uint64_t sub_1001E892C(int *a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unsigned int v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  __int16 v19;
  int v20;
  int v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  __int16 v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  int v31;
  int v32;
  unsigned int v33;
  unsigned int v34;
  int v35;
  __int16 v36;
  int v37;
  unsigned int v38;
  unsigned int v39;
  int v40;
  unsigned int v41;
  unsigned int v42;
  int v43;
  unsigned int v44;
  unsigned int v45;
  int v46;
  unsigned int v47;
  int v48;
  int v49;
  unsigned int v50;
  unsigned int v51;
  int v52;
  __int16 v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unsigned int v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t result;
  __int16 v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  int v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  __int16 v93;
  uint64_t v94;
  uint64_t v95;
  NSObject *v96;
  uint64_t v97;
  uint64_t v98;
  char v99;
  uint64_t v100;
  uint64_t v101;
  NSObject *v102;
  uint64_t v103;
  __int16 v104;
  uint64_t v105;
  uint64_t v106;
  NSObject *v107;

  v10 = a2 >> 7;
  v11 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 8);
  v12 = (a2 >> 1) & 0x3F;
  if ((v10 & 1) == 0)
  {
    if (v11 != v12)
      goto LABEL_21;
    v13 = (a2 >> 8) & 0x3F;
    if (*(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6) > v13
      || v13 > *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 4))
    {
      v14 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6);
      v15 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6);
      if (v14 <= v13)
      {
        if (v13 - v15 > *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 176) + 32))
          goto LABEL_21;
      }
      else if (((*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 176) + 32)
                + (_BYTE)v15) & 0x3Fu) < v13)
      {
        goto LABEL_21;
      }
    }
    if (*(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 16))
      goto LABEL_21;
    v19 = (*(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 8) + 1) & 0x3F;
    *(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 8) = v19;
    sub_1001EB06C((uint64_t)a1, (a2 >> 8) & 0x3F, 0);
    sub_1001EBE18(a1, a3, a4, a5);
LABEL_17:
    sub_1001EB90C((uint64_t)a1);
    return 0;
  }
  if (v11 != v12)
    goto LABEL_21;
  v16 = (a2 >> 8) & 0x3F;
  if (*(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6) > v16
    || v16 > *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 4))
  {
    v17 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6);
    v18 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6);
    if (v17 <= v16)
    {
      if (v16 - v18 > *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 176) + 32))
        goto LABEL_21;
    }
    else if (((*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 176) + 32)
              + (_BYTE)v18) & 0x3Fu) < v16)
    {
      goto LABEL_21;
    }
  }
  if (!*(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 2)
    && !*(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 16))
  {
    v104 = (*(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 8) + 1) & 0x3F;
    *(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 8) = v104;
    sub_1001EB06C((uint64_t)a1, (a2 >> 8) & 0x3F, 1);
    sub_1001EBE18(a1, a3, a4, a5);
    if (*(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 148))
    {
      *(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 148) = 0;
    }
    else
    {
      v105 = sub_1001EB21C((uint64_t)a1, (a2 >> 8) & 0x3F, 0);
      if ((_DWORD)v105)
      {
        v106 = v105;
        if (sub_10005549C())
        {
          sub_100054530("Failed to retransmit I-Frames %!.", v106);
          v107 = sub_1000544A0(0x2Fu);
          if (os_log_type_enabled(v107, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
      }
      sub_1001EB1D8((uint64_t)a1, 0);
    }
    goto LABEL_17;
  }
LABEL_21:
  v20 = (a2 >> 7) & 1;
  v21 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 10);
  v22 = *(unsigned __int8 *)(sub_1001E3CCC(a1) + 54) + v21;
  v23 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 10);
  if (v22 > 0x3F)
  {
    if (v12 < v23)
    {
      v25 = *(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 10);
      if (((*(_BYTE *)(sub_1001E3CCC(a1) + 54) + (_BYTE)v25) & 0x3Fu) <= v12)
        goto LABEL_41;
    }
  }
  else
  {
    if (v23 > v12)
      goto LABEL_41;
    v24 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 10);
    if (*(unsigned __int8 *)(sub_1001E3CCC(a1) + 54) + v24 < v12)
      goto LABEL_41;
  }
  v26 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 8);
  v27 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 10);
  v28 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 10);
  if (v26 >= v27)
  {
    if (v28 > v12)
      goto LABEL_41;
LABEL_31:
    if (v12 >= *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 8))
      goto LABEL_41;
    goto LABEL_32;
  }
  if (v28 > v12)
    goto LABEL_31;
LABEL_32:
  v29 = (a2 >> 8) & 0x3F;
  if (*(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6) > v29
    || v29 > *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 4))
  {
    v30 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6);
    v31 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6);
    if (v30 <= v29)
    {
      if (v29 - v31 > *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 176) + 32))
        goto LABEL_41;
    }
    else if (((*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 176) + 32)
              + (_BYTE)v31) & 0x3Fu) < v29)
    {
      goto LABEL_41;
    }
  }
  if ((!v20 || !*(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 2))
    && !*(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 16))
  {
    v85 = sub_1001E3CCC(a1);
    sub_1001E45FC(*(unsigned __int16 **)(v85 + 112), v86, v87, v88, v89, v90, v91, v92);
    v62 = (uint64_t)a1;
    v63 = (a2 >> 8) & 0x3F;
LABEL_96:
    sub_1001EB06C(v62, v63, v20);
    return 0;
  }
LABEL_41:
  v32 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 10);
  v33 = *(unsigned __int8 *)(sub_1001E3CCC(a1) + 54) + v32;
  v34 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 10);
  if (v33 > 0x3F)
  {
    if (v12 < v34)
    {
      v36 = *(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 10);
      if (((*(_BYTE *)(sub_1001E3CCC(a1) + 54) + (_BYTE)v36) & 0x3Fu) <= v12)
        goto LABEL_61;
    }
  }
  else
  {
    if (v34 > v12)
      goto LABEL_61;
    v35 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 10);
    if (*(unsigned __int8 *)(sub_1001E3CCC(a1) + 54) + v35 < v12)
      goto LABEL_61;
  }
  v37 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 10);
  v38 = *(unsigned __int8 *)(sub_1001E3CCC(a1) + 54) + v37;
  v39 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 8);
  if (v38 > 0x3F)
  {
    if (v12 <= v39)
    {
      v40 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 8);
      if (v40 + *(unsigned __int8 *)(sub_1001E3CCC(a1) + 54) - 64 <= (int)v12)
        goto LABEL_61;
    }
  }
  else if (v12 <= v39)
  {
    goto LABEL_61;
  }
  v41 = (a2 >> 8) & 0x3F;
  if (*(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6) > v41
    || v41 > *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 4))
  {
    v42 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6);
    v43 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6);
    if (v42 <= v41)
    {
      if (v41 - v43 > *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 176) + 32))
        goto LABEL_61;
    }
    else if (((*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 176) + 32)
              + (_BYTE)v43) & 0x3Fu) < v41)
    {
      goto LABEL_61;
    }
  }
  if (v20 && *(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 2)
    || *(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 16))
  {
LABEL_61:
    if (*(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 8) == v12)
    {
      v44 = (a2 >> 8) & 0x3F;
      if (*(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6) <= v44
        && v44 <= *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 4))
      {
        goto LABEL_87;
      }
      v45 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6);
      v46 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6);
      if (v45 <= v44)
      {
        if (v44 - v46 <= *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 176) + 32))
          goto LABEL_87;
      }
      else if (((*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 176) + 32)
                + (_BYTE)v46) & 0x3Fu) >= v44)
      {
LABEL_87:
        if ((!v20 || !*(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 2))
          && *(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 16))
        {
          sub_1001EB06C((uint64_t)a1, v44, v20);
          sub_1001EBE94(a1, a3);
          v73 = (*(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 8) + 1) & 0x3F;
          v74 = sub_1001E3CCC(a1);
          result = 0;
          *(_WORD *)(*(_QWORD *)(v74 + 112) + 8) = v73;
          return result;
        }
      }
    }
    else
    {
      v44 = (a2 >> 8) & 0x3F;
    }
    if (*(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6) > v44
      || v44 > *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 4))
    {
      v47 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6);
      v48 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6);
      if (v47 <= v44)
      {
        if (v44 - v48 > *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 176) + 32))
        {
LABEL_85:
          v64 = sub_1001E3CCC(a1);
          sub_1001E45FC(*(unsigned __int16 **)(v64 + 112), v65, v66, v67, v68, v69, v70, v71);
          return 543;
        }
      }
      else if (((*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 176) + 32)
                + (_BYTE)v48) & 0x3Fu) < v44)
      {
        goto LABEL_85;
      }
    }
    v49 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 10);
    v50 = *(unsigned __int8 *)(sub_1001E3CCC(a1) + 54) + v49;
    v51 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 10);
    if (v50 > 0x3F)
    {
      if (v12 < v51)
      {
        v53 = *(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 10);
        if (((*(_BYTE *)(sub_1001E3CCC(a1) + 54) + (_BYTE)v53) & 0x3Fu) <= v12)
          goto LABEL_85;
      }
    }
    else
    {
      if (v51 > v12)
        goto LABEL_85;
      v52 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 10);
      if (*(unsigned __int8 *)(sub_1001E3CCC(a1) + 54) + v52 < v12)
        goto LABEL_85;
    }
    if (*(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 8) == v12
      || v20 && *(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 2)
      || !*(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 16))
    {
      goto LABEL_85;
    }
    v54 = sub_1001E3CCC(a1);
    sub_1001E45FC(*(unsigned __int16 **)(v54 + 112), v55, v56, v57, v58, v59, v60, v61);
    v62 = (uint64_t)a1;
    v63 = v44;
    goto LABEL_96;
  }
  v75 = sub_1001E3CCC(a1);
  sub_1001E45FC(*(unsigned __int16 **)(v75 + 112), v76, v77, v78, v79, v80, v81, v82);
  if (v12 >= *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 8))
  {
    v84 = v12 - *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 8);
  }
  else
  {
    v83 = sub_1001E3CCC(a1);
    if ((int)(*(unsigned __int16 *)(*(_QWORD *)(v83 + 112) + 8) - (v12 | 0x40)) >= 0)
      v84 = -((*(unsigned __int16 *)(*(_QWORD *)(v83 + 112) + 8) - (v12 | 0x40)) & 0x3F);
    else
      v84 = (((unsigned __int16)v12 | 0x40) - *(_WORD *)(*(_QWORD *)(v83 + 112) + 8)) & 0x3F;
  }
  sub_1001EB06C((uint64_t)a1, v41, v20);
  if (v84 > 2)
  {
    v100 = sub_1001EC060((uint64_t)a1);
    if ((_DWORD)v100)
    {
      v101 = v100;
      if (sub_10005549C())
      {
        sub_100054530("Failed to send a REJ %!", v101);
        v102 = sub_1000544A0(0x2Fu);
        if (os_log_type_enabled(v102, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
    }
    v103 = sub_1001E3CCC(a1);
    result = 0;
    v98 = *(_QWORD *)(v103 + 112);
    v99 = 1;
  }
  else
  {
    *(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 144) = 0;
    *(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 151) = 0;
    v93 = *(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 10);
    *(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 152) = v93;
    sub_1001EBE94(a1, a3);
    v94 = sub_1001EBF3C(a1, v12);
    if ((_DWORD)v94)
    {
      v95 = v94;
      if (sub_10005549C())
      {
        sub_100054530("Failed to send SREJ : %!", v95);
        v96 = sub_1000544A0(0x2Fu);
        if (os_log_type_enabled(v96, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
    }
    v97 = sub_1001E3CCC(a1);
    result = 0;
    v98 = *(_QWORD *)(v97 + 112);
    v99 = 2;
  }
  *(_BYTE *)(v98 + 3) = v99;
  return result;
}

uint64_t sub_1001E94E8(int *a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unsigned int v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  __int16 v19;
  uint64_t v20;
  uint64_t result;
  int v22;
  unsigned int v23;
  unsigned int v24;
  int v25;
  __int16 v26;
  int v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  unsigned int v31;
  unsigned int v32;
  int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  NSObject *v46;

  v10 = a2 >> 7;
  v11 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 8);
  v12 = (a2 >> 1) & 0x3F;
  if ((v10 & 1) == 0)
  {
    if (v11 != v12)
      goto LABEL_19;
    v13 = (a2 >> 8) & 0x3F;
    if (*(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6) > v13
      || v13 > *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 4))
    {
      v14 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6);
      v15 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6);
      if (v14 <= v13)
      {
        if (v13 - v15 > *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 176) + 32))
          goto LABEL_19;
      }
      else if (((*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 176) + 32)
                + (_BYTE)v15) & 0x3Fu) < v13)
      {
        goto LABEL_19;
      }
    }
    v19 = (*(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 8) + 1) & 0x3F;
    *(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 8) = v19;
    sub_1001EB06C((uint64_t)a1, v13, 0);
    sub_1001EBE18(a1, a3, a4, a5);
LABEL_16:
    sub_1001EB90C((uint64_t)a1);
    v20 = sub_1001E3CCC(a1);
    result = 0;
    *(_BYTE *)(*(_QWORD *)(v20 + 112) + 3) = 0;
    return result;
  }
  if (v11 != v12)
    goto LABEL_19;
  v16 = (a2 >> 8) & 0x3F;
  if (*(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6) <= v16
    && v16 <= *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 4))
  {
    goto LABEL_18;
  }
  v17 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6);
  v18 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6);
  if (v17 <= v16)
  {
    if (v16 - v18 > *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 176) + 32))
      goto LABEL_19;
    goto LABEL_18;
  }
  if (((*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 176) + 32) + (_BYTE)v18) & 0x3Fu) >= v16)
  {
LABEL_18:
    if (*(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 2))
      goto LABEL_19;
    v43 = (*(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 8) + 1) & 0x3F;
    *(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 8) = v43;
    sub_1001EB06C((uint64_t)a1, v16, 1);
    sub_1001EBE18(a1, a3, a4, a5);
    if (*(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 148))
    {
      *(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 148) = 0;
    }
    else
    {
      v44 = sub_1001EB21C((uint64_t)a1, v16, 0);
      if ((_DWORD)v44)
      {
        v45 = v44;
        if (sub_10005549C())
        {
          sub_100054530("Failed to retransmit I-Frames %!.", v45);
          v46 = sub_1000544A0(0x2Fu);
          if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
      }
      sub_1001EB1D8((uint64_t)a1, 0);
    }
    goto LABEL_16;
  }
LABEL_19:
  v22 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 10);
  v23 = *(unsigned __int8 *)(sub_1001E3CCC(a1) + 54) + v22;
  v24 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 10);
  if (v23 > 0x3F)
  {
    if (v12 < v24)
    {
      v26 = *(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 10);
      if (((*(_BYTE *)(sub_1001E3CCC(a1) + 54) + (_BYTE)v26) & 0x3Fu) <= v12)
        goto LABEL_38;
    }
  }
  else
  {
    if (v24 > v12)
      goto LABEL_38;
    v25 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 10);
    if (*(unsigned __int8 *)(sub_1001E3CCC(a1) + 54) + v25 < v12)
      goto LABEL_38;
  }
  v27 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 10);
  v28 = *(unsigned __int8 *)(sub_1001E3CCC(a1) + 54) + v27;
  v29 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 8);
  if (v28 > 0x3F)
  {
    if (v12 <= v29)
    {
      v30 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 8);
      if (v30 + *(unsigned __int8 *)(sub_1001E3CCC(a1) + 54) - 64 <= (int)v12)
        goto LABEL_38;
    }
  }
  else if (v12 <= v29)
  {
    goto LABEL_38;
  }
  v31 = (a2 >> 8) & 0x3F;
  if (*(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6) > v31
    || v31 > *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 4))
  {
    v32 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6);
    v33 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6);
    if (v32 <= v31)
    {
      if (v31 - v33 > *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 176) + 32))
      {
LABEL_38:
        v35 = sub_1001E3CCC(a1);
        sub_1001E45FC(*(unsigned __int16 **)(v35 + 112), v36, v37, v38, v39, v40, v41, v42);
        return 544;
      }
    }
    else if (((*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 176) + 32)
              + (_BYTE)v33) & 0x3Fu) < v31)
    {
      goto LABEL_38;
    }
  }
  v34 = (a2 >> 7) & 1;
  if (v34 && *(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 2))
    goto LABEL_38;
  sub_1001EB06C((uint64_t)a1, v31, v34);
  return 0;
}

uint64_t sub_1001E9A10(int *a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  __int16 v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;
  NSObject *v22;
  unsigned int v23;
  unsigned int v24;
  int v25;
  unsigned int v26;
  unsigned int v27;
  int v28;
  int v29;
  unsigned int v30;
  unsigned int v31;
  int v32;
  __int16 v33;
  int v34;
  unsigned int v35;
  unsigned int v36;
  int v37;
  __int16 v38;
  uint64_t v39;
  unsigned int v40;
  int v41;
  int v42;
  unsigned int v43;
  unsigned int v44;
  int v45;
  int v46;
  unsigned int v47;
  unsigned int v48;
  int v49;
  __int16 v50;
  int v51;
  unsigned int v52;
  unsigned int v53;
  int v54;
  unsigned int v55;
  unsigned int v56;
  int v57;
  unsigned __int8 v58;
  unsigned int v59;
  unsigned int v60;
  int v61;
  uint64_t v62;
  uint64_t v63;
  NSObject *v64;
  unsigned int v65;
  unsigned int v66;
  int v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  NSObject *v77;
  uint64_t v78;
  NSObject *v79;
  __int16 v80;
  NSObject *v81;
  uint64_t v82;
  uint64_t v83;
  NSObject *v84;
  _OWORD __src[8];

  v10 = (a2 >> 1) & 0x3F;
  if (*(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 144)
    && *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 18) == v10)
  {
    v11 = (a2 >> 8) & 0x3F;
    if (*(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6) > v11
      || v11 > *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 4))
    {
      v12 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6);
      v13 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6);
      if (v12 <= v11)
      {
        if (v11 - v13 > *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 176) + 32))
          goto LABEL_14;
      }
      else if (((*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 176) + 32)
                + (_BYTE)v13) & 0x3Fu) < v11)
      {
        goto LABEL_14;
      }
    }
    if ((((a2 >> 7) & 1) == 0 || !*(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 2))
      && !*(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 151)
      && *(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 144) == 1)
    {
      sub_1001EBE94(a1, a3);
      sub_1001EC4AC(a1);
      sub_1001EB06C((uint64_t)a1, (a2 >> 8) & 0x3F, (a2 >> 7) & 1);
      sub_1001EC5A8(a1, a3, a4, a5);
      v14 = *(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 152);
      *(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 10) = v14;
      sub_1001EB90C((uint64_t)a1);
      v15 = 0;
      *(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 3) = 0;
      return v15;
    }
  }
LABEL_14:
  if (*(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 144)
    && *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 18) == v10)
  {
    v16 = (a2 >> 8) & 0x3F;
    if (*(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6) > v16
      || v16 > *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 4))
    {
      v17 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6);
      v18 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6);
      if (v17 <= v16)
      {
        if (v16 - v18 > *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 176) + 32))
          goto LABEL_31;
      }
      else if (((*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 176) + 32)
                + (_BYTE)v18) & 0x3Fu) < v16)
      {
        goto LABEL_31;
      }
    }
    if ((((a2 >> 7) & 1) == 0 || !*(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 2))
      && *(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 151)
      && *(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 144) == 1)
    {
      sub_1001EBE94(a1, a3);
      sub_1001EC4AC(a1);
      sub_1001EB06C((uint64_t)a1, (a2 >> 8) & 0x3F, (a2 >> 7) & 1);
      sub_1001EC5A8(a1, a3, a4, a5);
      v19 = *(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 152);
      *(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 10) = v19;
      v20 = sub_1001EC060((uint64_t)a1);
      if ((_DWORD)v20)
      {
        v21 = v20;
        if (sub_10005549C())
        {
          sub_100054530("Failed to send a REJ %!", v21);
          v22 = sub_1000544A0(0x2Fu);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
      }
      v15 = 0;
      *(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 3) = 1;
      return v15;
    }
  }
LABEL_31:
  if (*(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 144)
    && *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 18) == v10)
  {
    v23 = (a2 >> 8) & 0x3F;
    if (*(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6) > v23
      || v23 > *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 4))
    {
      v24 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6);
      v25 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6);
      if (v24 <= v23)
      {
        if (v23 - v25 > *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 176) + 32))
          goto LABEL_43;
      }
      else if (((*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 176) + 32)
                + (_BYTE)v25) & 0x3Fu) < v23)
      {
        goto LABEL_43;
      }
    }
    if ((((a2 >> 7) & 1) == 0 || !*(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 2))
      && *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 144) >= 2u)
    {
      sub_1001EBE94(a1, a3);
      sub_1001EC4AC(a1);
      sub_1001EB06C((uint64_t)a1, (a2 >> 8) & 0x3F, (a2 >> 7) & 1);
      sub_1001EC5A8(a1, a3, a4, a5);
      return 0;
    }
  }
LABEL_43:
  if (*(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 8) != v10)
    goto LABEL_52;
  v26 = (a2 >> 8) & 0x3F;
  if (*(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6) > v26
    || v26 > *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 4))
  {
    v27 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6);
    v28 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6);
    if (v27 <= v26)
    {
      if (v26 - v28 > *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 176) + 32))
        goto LABEL_52;
    }
    else if (((*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 176) + 32)
              + (_BYTE)v28) & 0x3Fu) < v26)
    {
      goto LABEL_52;
    }
  }
  if (((a2 >> 7) & 1) == 0 || !*(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 2))
  {
    v37 = (a2 >> 7) & 1;
    sub_1001EBE94(a1, a3);
    v38 = (*(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 8) + 1) & 0x3F;
    *(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 8) = v38;
    v39 = (uint64_t)a1;
    v40 = v26;
    v41 = v37;
LABEL_125:
    sub_1001EB06C(v39, v40, v41);
    return 0;
  }
LABEL_52:
  v29 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 10);
  v30 = *(unsigned __int8 *)(sub_1001E3CCC(a1) + 54) + v29;
  v31 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 10);
  if (v30 > 0x3F)
  {
    if (v10 < v31)
    {
      v33 = *(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 10);
      if (((*(_BYTE *)(sub_1001E3CCC(a1) + 54) + (_BYTE)v33) & 0x3Fu) <= v10)
        goto LABEL_73;
    }
  }
  else
  {
    if (v31 > v10)
      goto LABEL_73;
    v32 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 10);
    if (*(unsigned __int8 *)(sub_1001E3CCC(a1) + 54) + v32 < v10)
      goto LABEL_73;
  }
  v34 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 10);
  v35 = *(unsigned __int8 *)(sub_1001E3CCC(a1) + 54) + v34;
  v36 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 8);
  if (v35 > 0x3F)
  {
    if (v10 <= v36)
    {
      v42 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 8);
      if (v42 + *(unsigned __int8 *)(sub_1001E3CCC(a1) + 54) - 64 <= (int)v10)
        goto LABEL_73;
    }
  }
  else if (v10 <= v36)
  {
    goto LABEL_73;
  }
  v43 = (a2 >> 8) & 0x3F;
  if (*(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6) > v43
    || v43 > *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 4))
  {
    v44 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6);
    v45 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6);
    if (v44 <= v43)
    {
      if (v43 - v45 > *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 176) + 32))
        goto LABEL_73;
    }
    else if (((*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 176) + 32)
              + (_BYTE)v45) & 0x3Fu) < v43)
    {
      goto LABEL_73;
    }
  }
  if ((((a2 >> 7) & 1) == 0 || !*(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 2))
    && !*(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 151))
  {
    sub_1001EBE94(a1, a3);
    sub_1001EB06C((uint64_t)a1, (a2 >> 8) & 0x3F, (a2 >> 7) & 1);
    v62 = sub_1001EBF3C(a1, (a2 >> 1) & 0x3F);
    if ((_DWORD)v62)
    {
      v63 = v62;
      if (sub_10005549C())
      {
        sub_100054530("Failed to send SREJ : %!", v63);
        v64 = sub_1000544A0(0x2Fu);
        if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
    }
    return 0;
  }
LABEL_73:
  v46 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 10);
  v47 = *(unsigned __int8 *)(sub_1001E3CCC(a1) + 54) + v46;
  v48 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 10);
  if (v47 > 0x3F)
  {
    if (v10 < v48)
    {
      v50 = *(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 10);
      if (((*(_BYTE *)(sub_1001E3CCC(a1) + 54) + (_BYTE)v50) & 0x3Fu) <= v10)
        goto LABEL_94;
    }
  }
  else
  {
    if (v48 > v10)
      goto LABEL_94;
    v49 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 10);
    if (*(unsigned __int8 *)(sub_1001E3CCC(a1) + 54) + v49 < v10)
      goto LABEL_94;
  }
  v51 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 10);
  v52 = *(unsigned __int8 *)(sub_1001E3CCC(a1) + 54) + v51;
  v53 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 8);
  if (v52 > 0x3F)
  {
    if (v10 <= v53)
    {
      v54 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 8);
      if (v54 + *(unsigned __int8 *)(sub_1001E3CCC(a1) + 54) - 64 <= (int)v10)
        goto LABEL_94;
    }
  }
  else if (v10 <= v53)
  {
    goto LABEL_94;
  }
  v55 = (a2 >> 8) & 0x3F;
  if (*(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6) > v55
    || v55 > *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 4))
  {
    v56 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6);
    v57 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6);
    if (v56 <= v55)
    {
      if (v55 - v57 > *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 176) + 32))
        goto LABEL_94;
    }
    else if (((*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 176) + 32)
              + (_BYTE)v57) & 0x3Fu) < v55)
    {
      goto LABEL_94;
    }
  }
  if ((((a2 >> 7) & 1) == 0 || !*(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 2))
    && *(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 151))
  {
    v41 = (a2 >> 7) & 1;
    v39 = (uint64_t)a1;
    v40 = (a2 >> 8) & 0x3F;
    goto LABEL_125;
  }
LABEL_94:
  if (!*(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 144)
    || !*(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 144))
  {
    goto LABEL_114;
  }
  v58 = 0;
  while (*(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 2 * v58 + 18) != v10)
  {
    if (*(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 144) <= ++v58)
      goto LABEL_114;
  }
  if (*(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 144)
    && *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 18) == v10)
  {
    goto LABEL_114;
  }
  v59 = (a2 >> 8) & 0x3F;
  if (*(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6) > v59
    || v59 > *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 4))
  {
    v60 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6);
    v61 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6);
    if (v60 <= v59)
    {
      if (v59 - v61 > *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 176) + 32))
      {
LABEL_114:
        if (*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 8 * v10 + 184))
        {
          v65 = (a2 >> 8) & 0x3F;
          if (*(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6) <= v65
            && v65 <= *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 4))
          {
            goto LABEL_121;
          }
          v66 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6);
          v67 = *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 6);
          if (v66 > v65)
          {
            if (((*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 176) + 32)
                 + (_BYTE)v67) & 0x3Fu) < v65)
              goto LABEL_123;
            goto LABEL_121;
          }
          if (v65 - v67 <= *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 176) + 32))
          {
LABEL_121:
            if (((a2 >> 7) & 1) != 0 && *(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 2))
              goto LABEL_123;
            v41 = (a2 >> 7) & 1;
            v39 = (uint64_t)a1;
            v40 = (a2 >> 8) & 0x3F;
            goto LABEL_125;
          }
        }
LABEL_123:
        v68 = sub_1001E3CCC(a1);
        sub_1001E45FC(*(unsigned __int16 **)(v68 + 112), v69, v70, v71, v72, v73, v74, v75);
        return 545;
      }
    }
    else if (((*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 176) + 32)
              + (_BYTE)v61) & 0x3Fu) < v59)
    {
      goto LABEL_114;
    }
  }
  if (((a2 >> 7) & 1) != 0 && *(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 2))
    goto LABEL_114;
  sub_1001EBE94(a1, a3);
  sub_1001EB06C((uint64_t)a1, (a2 >> 8) & 0x3F, (a2 >> 7) & 1);
  LOWORD(a3) = *(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 18);
  memset(__src, 0, 126);
  if (*(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 144) >= 2u)
  {
    v78 = 0;
    while (1)
    {
      v15 = sub_1001EBC00((uint64_t)a1, a3, 0);
      if ((_DWORD)v15)
        break;
      if (v78 == 62)
      {
        if (sub_10005549C())
        {
          sub_100054530("Could not find txSeq %d in our SREJ list", v10);
          v84 = sub_1000544A0(0x2Fu);
          if (os_log_type_enabled(v84, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
        goto LABEL_130;
      }
      LODWORD(a3) = *(unsigned __int8 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 2 * v78++ + 20);
      if ((_DWORD)a3 == v10)
      {
        LOBYTE(a3) = v10;
        goto LABEL_142;
      }
    }
    if (sub_10005549C())
    {
      sub_100054530("Failed to send SREJ: %!", v15);
      v79 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v79, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
LABEL_142:
    v80 = *(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 144);
    if ((unsigned __int16)(v80 + ~v78) >= 0x40u)
    {
      if (sub_10005549C())
      {
        sub_100054530("Number of sRejFramesRemaining is too large %d", (unsigned __int16)(v80 + ~v78));
        v81 = sub_1000544A0(0x2Fu);
        if (os_log_type_enabled(v81, OS_LOG_TYPE_FAULT))
          sub_1006D3840(v81);
      }
      goto LABEL_130;
    }
    v82 = sub_1001E3CCC(a1);
    __memmove_chk(__src, *(_QWORD *)(v82 + 112) + 2 * v78 + 20, 2 * (unsigned __int16)(v80 + ~v78), 126);
    *((_WORD *)__src + (unsigned __int16)(v80 + ~v78)) = a3;
    v83 = sub_1001E3CCC(a1);
    memmove((void *)(*(_QWORD *)(v83 + 112) + 18), __src, 0x7EuLL);
    *(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 144) = v80 - v78;
    if ((_DWORD)v15)
      goto LABEL_131;
  }
  else
  {
    sub_100253460();
LABEL_130:
    v15 = 538;
LABEL_131:
    if (sub_10005549C())
    {
      sub_100054530("Failed to send SREJ list : %!", v15);
      v77 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v77, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  return v15;
}

uint64_t sub_1001EA980(int *a1)
{
  uint64_t result;
  uint64_t v3;

  result = sub_1001E3CCC(a1);
  if (*(_DWORD *)(*(_QWORD *)(result + 112) + 160))
  {
    v3 = sub_1001E3CCC(a1);
    sub_100049F6C(*(unsigned int *)(*(_QWORD *)(v3 + 112) + 160));
    result = sub_1001E3CCC(a1);
    *(_DWORD *)(*(_QWORD *)(result + 112) + 160) = 0;
  }
  return result;
}

uint64_t sub_1001EA9D0(int *a1)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v7;
  uint64_t v8;
  NSObject *v9;
  const void *v10[2];

  if (!*(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 156) || !*(_WORD *)(sub_1001E3CCC(a1) + 70))
    return 0;
  if (*(_DWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 164))
  {
    v2 = *(_DWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 164);
    v3 = sub_1001E3CCC(a1);
    v4 = sub_1002537E8(v2, (5243 * (*(unsigned __int16 *)(v3 + 70) >> 2)) >> 17);
  }
  else
  {
    v10[1] = a1 + 1;
    v10[0] = (const void *)2;
    v7 = (5243 * (*(unsigned __int16 *)(sub_1001E3CCC(a1) + 70) >> 2)) >> 17;
    v8 = sub_1001E3CCC(a1);
    v4 = sub_10004A9EC((uint64_t)sub_1001EC638, v10, v7, (int *)(*(_QWORD *)(v8 + 112) + 164));
  }
  v5 = v4;
  if ((_DWORD)v4)
  {
    if (sub_10005549C())
    {
      sub_100054530("Could not register timer %!", v5);
      v9 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  return v5;
}

double sub_1001EAB04(uint64_t a1)
{
  char *v2;
  _QWORD *v3;
  double result;
  char *v5;

  if (*(_QWORD *)(sub_1001E3CCC((int *)a1) + 112))
  {
    v2 = *(char **)(sub_1001E3CCC((int *)a1) + 112);
    sub_1002512C0(*((_QWORD **)v2 + 22));
  }
  else
  {
    v2 = (char *)sub_100052DC0(0x2C8uLL);
    *(_QWORD *)(sub_1001E3CCC((int *)a1) + 112) = v2;
  }
  *(_WORD *)v2 = *(_WORD *)(a1 + 4);
  v2[2] = 1;
  *((_WORD *)v2 + 7) = 0;
  v2[16] = 0;
  *(_QWORD *)(v2 + 3) = 0;
  v2[11] = 0;
  *((_QWORD *)v2 + 18) = 0;
  *((_DWORD *)v2 + 38) = 0;
  v2[156] = 1;
  *((_QWORD *)v2 + 20) = 0;
  *((_DWORD *)v2 + 42) = 0;
  v3 = sub_100251288(0, 0);
  result = 0.0;
  *(_OWORD *)(v2 + 184) = 0u;
  v5 = v2 + 184;
  *((_QWORD *)v5 - 1) = v3;
  *((_OWORD *)v5 + 1) = 0u;
  *((_OWORD *)v5 + 2) = 0u;
  *((_OWORD *)v5 + 3) = 0u;
  *((_OWORD *)v5 + 4) = 0u;
  *((_OWORD *)v5 + 5) = 0u;
  *((_OWORD *)v5 + 6) = 0u;
  *((_OWORD *)v5 + 7) = 0u;
  *((_OWORD *)v5 + 8) = 0u;
  *((_OWORD *)v5 + 9) = 0u;
  *((_OWORD *)v5 + 10) = 0u;
  *((_OWORD *)v5 + 11) = 0u;
  *((_OWORD *)v5 + 12) = 0u;
  *((_OWORD *)v5 + 13) = 0u;
  *((_OWORD *)v5 + 14) = 0u;
  *((_OWORD *)v5 + 15) = 0u;
  *((_OWORD *)v5 + 16) = 0u;
  *((_OWORD *)v5 + 17) = 0u;
  *((_OWORD *)v5 + 18) = 0u;
  *((_OWORD *)v5 + 19) = 0u;
  *((_OWORD *)v5 + 20) = 0u;
  *((_OWORD *)v5 + 21) = 0u;
  *((_OWORD *)v5 + 22) = 0u;
  *((_OWORD *)v5 + 23) = 0u;
  *((_OWORD *)v5 + 24) = 0u;
  *((_OWORD *)v5 + 25) = 0u;
  *((_OWORD *)v5 + 26) = 0u;
  *((_OWORD *)v5 + 27) = 0u;
  *((_OWORD *)v5 + 28) = 0u;
  *((_OWORD *)v5 + 29) = 0u;
  *((_OWORD *)v5 + 30) = 0u;
  *((_OWORD *)v5 + 31) = 0u;
  *((_QWORD *)v5 + 64) = 0;
  *((_DWORD *)v5 + 130) = 0;
  return result;
}

uint64_t sub_1001EABF0(int *a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t i;
  _QWORD *v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t j;

  result = sub_1001E3CCC(a1);
  v3 = *(_QWORD *)(result + 112);
  if (v3)
  {
    for (i = 184; i != 696; i += 8)
    {
      v5 = *(_QWORD **)(v3 + i);
      if (v5)
      {
        sub_1001EACD4(v5);
        *(_QWORD *)(v3 + i) = 0;
      }
    }
    v6 = *(void **)(v3 + 696);
    if (v6)
    {
      sub_100053298(v6);
      *(_QWORD *)(v3 + 696) = 0;
    }
    sub_1001EAD04(a1);
    sub_1001EA980(a1);
    v7 = *(unsigned int *)(v3 + 168);
    if ((_DWORD)v7)
    {
      sub_100049F6C(v7);
      *(_DWORD *)(v3 + 168) = 0;
    }
    v8 = *(_QWORD *)(v3 + 176);
    if (v8)
    {
      v9 = sub_100251684(v8);
      for (j = v9; j; v9 = j)
      {
        v10 = (_QWORD *)sub_1002516A8(v9);
        v11 = v10[5];
        if (v11)
          sub_100253F14(v11);
        sub_100053298(v10);
        sub_10025168C((uint64_t)&j);
      }
      sub_1002512C0(*(_QWORD **)(v3 + 176));
    }
    sub_100053298((void *)v3);
    result = sub_1001E3CCC(a1);
    *(_QWORD *)(result + 112) = 0;
  }
  return result;
}

void sub_1001EACD4(_QWORD *ptr)
{
  void *v2;

  v2 = (void *)ptr[1];
  if (v2)
    sub_100053298(v2);
  ptr[1] = 0;
  sub_100053298(ptr);
}

uint64_t sub_1001EAD04(int *a1)
{
  uint64_t result;
  uint64_t v3;

  result = sub_1001E3CCC(a1);
  if (*(_DWORD *)(*(_QWORD *)(result + 112) + 164))
  {
    v3 = sub_1001E3CCC(a1);
    sub_100049F6C(*(unsigned int *)(*(_QWORD *)(v3 + 112) + 164));
    result = sub_1001E3CCC(a1);
    *(_DWORD *)(*(_QWORD *)(result + 112) + 164) = 0;
  }
  return result;
}

uint64_t sub_1001EAD54(int *a1)
{
  uint64_t v1;
  __int16 v2;

  v1 = *(_QWORD *)(sub_1001E3CCC(a1) + 112);
  v2 = *(_WORD *)(v1 + 4);
  *(_WORD *)(v1 + 4) = ((_BYTE)v2 + 1) & 0x3F;
  return v2;
}

BOOL sub_1001EAD80(int *a1)
{
  uint64_t v2;
  unsigned int v3;

  v2 = sub_1001E3CCC(a1);
  v3 = sub_100056080(*(_QWORD *)(*(_QWORD *)(v2 + 112) + 176));
  return v3 < *(unsigned __int8 *)(sub_1001E3CCC(a1) + 66)
      && !*(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 15)
      && *(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 2) == 1;
}

uint64_t sub_1001EADF8(int *a1, uint64_t a2)
{
  uint64_t v4;

  v4 = *(_QWORD *)(sub_1001E3CCC(a1) + 112);
  if (*(_BYTE *)(sub_1001E3CCC(a1) + 67))
    ++*(_BYTE *)(a2 + 48);
  ++*(_WORD *)(v4 + 154);
  sub_1001EAE74(a1);
  sub_10025147C(*(_QWORD *)(v4 + 176), a2, 8, sub_1001E44D0);
  return 0;
}

uint64_t sub_1001EAE74(int *a1)
{
  uint64_t v2;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  NSObject *v9;
  const void *v10[2];

  if (!*(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 156)
    || !*(_WORD *)(sub_1001E3CCC(a1) + 68)
    || *(_DWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 164))
  {
    return 0;
  }
  if (*(_DWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 160))
  {
    v4 = *(_DWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 160);
    v5 = sub_1001E3CCC(a1);
    v6 = sub_1002537E8(v4, (5243 * (*(unsigned __int16 *)(v5 + 68) >> 2)) >> 17);
  }
  else
  {
    v10[1] = a1 + 1;
    v10[0] = (const void *)2;
    v7 = (5243 * (*(unsigned __int16 *)(sub_1001E3CCC(a1) + 68) >> 2)) >> 17;
    v8 = sub_1001E3CCC(a1);
    v6 = sub_10004A9EC((uint64_t)sub_1001EC82C, v10, v7, (int *)(*(_QWORD *)(v8 + 112) + 160));
  }
  v2 = v6;
  if ((_DWORD)v6)
  {
    if (sub_10005549C())
    {
      sub_100054530("Could not register timer %!", v2);
      v9 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  return v2;
}

uint64_t sub_1001EAFBC(int *a1)
{
  uint64_t v1;

  v1 = sub_1001E3CCC(a1);
  return (unsigned __int16)sub_100056080(*(_QWORD *)(*(_QWORD *)(v1 + 112) + 176));
}

uint64_t sub_1001EAFE0(int *a1)
{
  return *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 8);
}

uint64_t sub_1001EAFFC(int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t i;

  v5 = *(_QWORD *)(sub_1001E3CCC(a1) + 112);
  if (v5)
  {
    v6 = *(_QWORD *)(v5 + 176);
    if (v6)
    {
      v7 = sub_100251684(v6);
      for (i = v7; i; v7 = i)
      {
        v8 = sub_1002516A8(v7);
        if (*(_QWORD *)(v8 + 8) == a2)
          *(_QWORD *)(v8 + 8) = a3;
        sub_10025168C((uint64_t)&i);
      }
    }
  }
  return 0;
}

uint64_t sub_1001EB06C(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;

  if (*(_BYTE *)(*(_QWORD *)(sub_1001E3CCC((int *)a1) + 112) + 2) == 1)
    return sub_1001EB838((int *)a1, a2);
  result = sub_1001EB838((int *)a1, a2);
  if (a3 == 1)
  {
    sub_1001EAD04((int *)a1);
    v7 = sub_1001E3CCC((int *)a1);
    if (sub_100056080(*(_QWORD *)(*(_QWORD *)(v7 + 112) + 176)))
    {
      v8 = sub_1001EAE74((int *)a1);
      if ((_DWORD)v8)
      {
        v9 = v8;
        if (sub_10005549C())
        {
          sub_100054530("Failed to restart retransmission timer : %!", v9);
          v10 = sub_1000544A0(0x2Fu);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
      }
    }
    *(_BYTE *)(*(_QWORD *)(sub_1001E3CCC((int *)a1) + 112) + 2) = 1;
    return sub_1001F0DF4(*(unsigned __int16 *)(a1 + 4));
  }
  return result;
}

uint64_t sub_1001EB174(int *a1, char a2, char a3)
{
  if (*(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 16))
    return sub_1001E4788((uint64_t)a1, a2, a3);
  else
    return sub_1001E49E0((uint64_t)a1, a2, a3);
}

uint64_t sub_1001EB1D8(uint64_t a1, char a2)
{
  if (!*(_BYTE *)(*(_QWORD *)(sub_1001E3CCC((int *)a1) + 112) + 14))
    *(_BYTE *)(*(_QWORD *)(sub_1001E3CCC((int *)a1) + 112) + 14) = a2;
  return sub_1001F0DF4(*(unsigned __int16 *)(a1 + 4));
}

uint64_t sub_1001EB21C(uint64_t a1, int a2, char a3)
{
  uint64_t v6;
  uint64_t v7;
  char v8;
  NSObject *v9;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  NSObject *v16;
  void *v17;
  NSObject *v18;
  _QWORD *v19;
  _OWORD v20[2];
  uint64_t v21;
  uint8_t buf[4];
  void *v23;
  __int16 v24;
  int v25;

  v6 = *(_QWORD *)(sub_1001E3CCC((int *)a1) + 112);
  v21 = 0;
  memset(v20, 0, sizeof(v20));
  v7 = sub_100251684(*(_QWORD *)(v6 + 176));
  v19 = (_QWORD *)v7;
  if (v7)
  {
    v8 = a3 ^ 1;
    while (*(unsigned __int16 *)(sub_1002516A8(v7) + 38) != a2)
    {
      sub_10025168C((uint64_t)&v19);
      v7 = (uint64_t)v19;
      if (!v19)
        goto LABEL_5;
    }
    v11 = v19;
    do
    {
      v12 = sub_1002516A8((uint64_t)v19);
      sub_100251374((uint64_t)v20, v12, 8);
    }
    while ((sub_10025168C((uint64_t)&v19) & 1) != 0);
    sub_100251798(*(_QWORD **)(v6 + 176), v11, 0);
    v13 = sub_100251684((uint64_t)v20);
    v19 = (_QWORD *)v13;
    if (v13)
    {
      while (1)
      {
        v14 = sub_1002516A8(v13);
        if (*(_BYTE *)(sub_1001E3CCC((int *)a1) + 67))
        {
          v15 = *(unsigned __int8 *)(v14 + 48);
          if (v15 >= *(unsigned __int8 *)(sub_1001E3CCC((int *)a1) + 67))
            break;
        }
        if ((v8 & 1) == 0)
          *(_BYTE *)(v6 + 14) = 1;
        if (sub_1001F2328(v14))
        {
          if (sub_10005549C())
          {
            sub_100054530("Failed to retransmit packet.");
            v16 = sub_1000544A0(0x2Fu);
            if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
            {
              v17 = sub_100054494();
              *(_DWORD *)buf = 136446466;
              v23 = v17;
              v24 = 1024;
              v25 = 0xFFFF;
              _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "%{public}s (status=%{bluetooth:OI_STATUS}u)", buf, 0x12u);
            }
          }
          sub_10025147C(*(_QWORD *)(v6 + 176), v14, 8, sub_1001E44D0);
        }
        sub_10025168C((uint64_t)&v19);
        v13 = (uint64_t)v19;
        v8 = 1;
        if (!v19)
          goto LABEL_22;
      }
      if (sub_10005549C())
      {
        sub_100054530("Retry count exceeded");
        v18 = sub_1000544A0(0x2Fu);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          sub_1006CEEC0();
      }
      sub_1001DEB7C(*(unsigned __int16 *)(a1 + 4), 436);
      return 541;
    }
    else
    {
LABEL_22:
      sub_100251314((uint64_t)v20);
      if (!*(_DWORD *)(*(_QWORD *)(sub_1001E3CCC((int *)a1) + 112) + 160))
        sub_1001EAE74((int *)a1);
      return 0;
    }
  }
  else
  {
LABEL_5:
    if (sub_10005549C())
    {
      sub_100054530("Could not find the IFrame with reqSeq %d", a2);
      v9 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 540;
  }
}

uint64_t sub_1001EB500(int *a1)
{
  uint64_t v2;
  int v3;
  char v4;
  uint64_t v5;

  *(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 154) = 0;
  v2 = *(_QWORD *)(sub_1001E3CCC(a1) + 112);
  v3 = *(unsigned __int8 *)(v2 + 16);
  if (*(_BYTE *)(v2 + 16))
  {
    sub_1001E4788((uint64_t)a1, 0, 1);
    v4 = 0;
  }
  else
  {
    v4 = 1;
  }
  if (*(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 15))
  {
    v5 = sub_1001E3CCC(a1);
    if (sub_100056080(*(_QWORD *)(*(_QWORD *)(v5 + 112) + 176)))
      sub_1001EAE74(a1);
  }
  if (!*(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 16)
    && !*(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 154))
  {
    sub_1001E49E0((uint64_t)a1, 0, v3 == 0);
    v4 = 0;
  }
  return sub_1001EB1D8((uint64_t)a1, v4);
}

uint64_t sub_1001EB5DC(uint64_t a1, int a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;

  result = sub_1001E3CCC((int *)a1);
  if (a2 == 1 && *(_BYTE *)(*(_QWORD *)(result + 112) + 2) != 1)
  {
    sub_1001EAD04((int *)a1);
    v5 = sub_1001E3CCC((int *)a1);
    if (sub_100056080(*(_QWORD *)(*(_QWORD *)(v5 + 112) + 176)))
    {
      v6 = sub_1001EAE74((int *)a1);
      if ((_DWORD)v6)
      {
        v7 = v6;
        if (sub_10005549C())
        {
          sub_100054530("Failed to restart retransmission timer : %!", v7);
          v8 = sub_1000544A0(0x2Fu);
          if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
      }
    }
    *(_BYTE *)(*(_QWORD *)(sub_1001E3CCC((int *)a1) + 112) + 2) = 1;
    return sub_1001F0DF4(*(unsigned __int16 *)(a1 + 4));
  }
  return result;
}

uint64_t sub_1001EB6B0(uint64_t a1, int a2, int a3)
{
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  NSObject *v11;
  NSObject *v12;
  void *ptr;

  v6 = *(_QWORD *)(sub_1001E3CCC((int *)a1) + 112);
  v7 = (void *)sub_100251684(*(_QWORD *)(v6 + 176));
  ptr = v7;
  if (!v7)
  {
LABEL_18:
    if (!*(_DWORD *)(*(_QWORD *)(sub_1001E3CCC((int *)a1) + 112) + 160))
    {
      sub_1001EAD04((int *)a1);
      sub_1001EAE74((int *)a1);
    }
    return 0;
  }
  while (1)
  {
    v8 = sub_1002516A8((uint64_t)v7);
    if (*(unsigned __int16 *)(v8 + 38) == a2)
      break;
    sub_10025168C((uint64_t)&ptr);
    v7 = ptr;
    if (!ptr)
      goto LABEL_18;
  }
  v9 = v8;
  if (!*(_BYTE *)(sub_1001E3CCC((int *)a1) + 67)
    || (v10 = *(unsigned __int8 *)(v9 + 48), v10 < *(unsigned __int8 *)(sub_1001E3CCC((int *)a1) + 67)))
  {
    if (a3)
      *(_BYTE *)(v6 + 14) = 1;
    if (sub_1001F2328(v9))
    {
      if (sub_10005549C())
      {
        sub_100054530("Failed to retransmit packet.");
        v11 = sub_1000544A0(0x2Fu);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
    }
    else
    {
      sub_1002516FC(*(_QWORD *)(v6 + 176), ptr, 0);
    }
    goto LABEL_18;
  }
  if (sub_10005549C())
  {
    sub_100054530("Retry count exceeded");
    v12 = sub_1000544A0(0x2Fu);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  sub_1001DEB7C(*(unsigned __int16 *)(a1 + 4), 436);
  return 542;
}

uint64_t sub_1001EB838(int *a1, unsigned int a2)
{
  uint64_t v4;
  void *v5;
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  BOOL v10;
  _BOOL4 v11;
  uint64_t result;
  void *v14;
  void *ptr;

  v4 = *(_QWORD *)(sub_1001E3CCC(a1) + 112);
  v5 = (void *)sub_100251684(*(_QWORD *)(v4 + 176));
  ptr = v5;
  if (v5)
  {
    do
    {
      while (1)
      {
        v6 = sub_1002516A8((uint64_t)v5);
        v7 = *(unsigned __int16 *)(v4 + 6);
        v8 = *(unsigned __int16 *)(v6 + 38);
        if (v7 <= v8 && v8 < a2)
          break;
        v10 = v7 > v8 && v8 >= a2;
        v11 = !v10;
        if (v7 > a2 && v11)
          break;
        sub_10025168C((uint64_t)&ptr);
        v5 = ptr;
        if (!ptr)
          goto LABEL_21;
      }
      sub_1001F0104((_QWORD *)v6);
      v14 = ptr;
      sub_10025168C((uint64_t)&v14);
      sub_1002516FC(*(_QWORD *)(v4 + 176), ptr, 1);
      v5 = v14;
      ptr = v14;
    }
    while (v14);
  }
LABEL_21:
  *(_WORD *)(v4 + 6) = a2;
  result = sub_100056080(*(_QWORD *)(v4 + 176));
  if (!(_DWORD)result)
    return sub_1001EA980(a1);
  return result;
}

uint64_t sub_1001EB90C(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  unsigned int v5;
  unsigned int *v6;
  int v7;
  unsigned __int16 v8;
  unsigned int v9;
  unsigned int v10;
  int v11;
  int *v12;
  const void *v13[2];

  v2 = *(_QWORD *)(sub_1001E3CCC((int *)a1) + 112);
  if (*(_BYTE *)(v2 + 16))
    return sub_1001E4788(a1, 0, 0);
  if (!*(_BYTE *)(v2 + 15))
  {
    if (sub_1001F23F8(*(unsigned __int16 *)(a1 + 4)))
    {
      v4 = sub_1001E3CCC((int *)a1);
      v5 = sub_100056080(*(_QWORD *)(*(_QWORD *)(v4 + 112) + 176));
      if (v5 < *(unsigned __int8 *)(sub_1001E3CCC((int *)a1) + 66))
        return sub_1001EB1D8(a1, 0);
    }
  }
  v13[1] = (const void *)(a1 + 4);
  v13[0] = (const void *)2;
  v7 = *(_DWORD *)(v2 + 168);
  v6 = (unsigned int *)(v2 + 168);
  v8 = *((_WORD *)v6 - 78) + 1;
  *((_WORD *)v6 - 78) = v8;
  if (!v7)
  {
    v11 = 1;
    v12 = (int *)v6;
    return sub_10004A9EC((uint64_t)sub_1001EBA58, v13, v11, v12);
  }
  v9 = v8;
  result = sub_1001E3CCC((int *)a1);
  if (*(unsigned __int8 *)(result + 54) <= 0x23u)
  {
    result = sub_1001E3CCC((int *)a1);
    v10 = *(unsigned __int8 *)(result + 54) >> 2;
  }
  else
  {
    v10 = 8;
  }
  if (v10 < v9)
  {
    sub_100049F6C(*v6);
    v11 = 0;
    v12 = 0;
    return sub_10004A9EC((uint64_t)sub_1001EBA58, v13, v11, v12);
  }
  return result;
}

void sub_1001EBA58(uint64_t a1)
{
  unsigned int v1;
  NSObject *v2;
  int *v3;

  v1 = **(unsigned __int16 **)(a1 + 8);
  v3 = 0;
  if (sub_1001DB044(v1, (uint64_t *)&v3))
  {
    if (sub_10005549C())
    {
      sub_100054530("SFrame ac Timeout triggered on a released channel (0x%x), this is bad.", v1);
      v2 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  else
  {
    *(_WORD *)(*(_QWORD *)(sub_1001E3CCC(v3) + 112) + 12) = 0;
    *(_DWORD *)(*(_QWORD *)(sub_1001E3CCC(v3) + 112) + 168) = 0;
    sub_1001E49E0((uint64_t)v3, 0, 0);
  }
}

uint64_t sub_1001EBB08(int *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;

  if (*(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 144))
  {
    v2 = *(_QWORD *)(sub_1001E3CCC(a1) + 112);
    v3 = sub_1001E3CCC(a1);
    v4 = sub_1001EBC00((uint64_t)a1, *(_BYTE *)(v2 + 2 * *(unsigned __int16 *)(*(_QWORD *)(v3 + 112) + 144) + 16), 1);
    if ((_DWORD)v4)
    {
      if (sub_10005549C())
      {
        sub_100054530("Failed to send SREJ : %!", v4);
        v5 = sub_1000544A0(0x2Fu);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
    }
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("Nothing queued in SREJ list.");
      v6 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 539;
  }
  return v4;
}

uint64_t sub_1001EBC00(uint64_t a1, char a2, char a3)
{
  size_t v6;
  uint64_t v7;
  NSObject *v8;
  __int16 v10;
  __int128 v11;
  __int128 v12;
  _OWORD v13[7];
  uint64_t v14;
  uint64_t v15;

  v14 = 0;
  memset(v13, 0, sizeof(v13));
  v11 = 0u;
  v12 = 0u;
  v15 = 0;
  v10 = 0;
  LOBYTE(v11) = *(__int16 *)(sub_1001E3CCC((int *)a1) + 38) == -1;
  *((_QWORD *)&v11 + 1) = *(_QWORD *)sub_1001E3CCC((int *)a1);
  LODWORD(v12) = 0;
  WORD2(v12) = *(_WORD *)(a1 + 4);
  WORD3(v12) = 256;
  BYTE8(v12) = 0;
  v6 = (sub_1001EF8A8((int *)a1, 3, 0, a3, a2, (_WORD *)&v15 + 2) + 4);
  WORD5(v12) = 2 * (*(_BYTE *)(sub_1001E3CCC((int *)a1) + 78) != 0) + v6;
  LOBYTE(v15) = v6 - 4 + 2 * (*(_BYTE *)(sub_1001E3CCC((int *)a1) + 78) != 0);
  BYTE1(v15) = (unsigned __int16)(v6 - 4 + 2 * (*(_BYTE *)(sub_1001E3CCC((int *)a1) + 78) != 0)) >> 8;
  WORD1(v15) = *(_WORD *)(sub_1001E3CCC((int *)a1) + 8);
  sub_1000532A8((uint64_t)v13 + 8, 2u);
  sub_10005336C((unsigned __int8 *)v13 + 8, (char *)&v15, v6, 2u);
  if (*(_BYTE *)(sub_1001E3CCC((int *)a1) + 78))
  {
    sub_1001EE884((uint64_t)v13 + 8, &v10);
    sub_10005336C((unsigned __int8 *)v13 + 8, (char *)&v10, 2uLL, 2u);
  }
  v7 = sub_1001F21A8((uint64_t)&v11);
  if ((_DWORD)v7)
  {
    if (sub_10005549C())
    {
      sub_100054530("Failed to send S-Frame %!.", v7);
      v8 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  return v7;
}

void sub_1001EBE18(int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __int16 v8;

  v8 = (*(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 10) + 1) & 0x3F;
  *(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 10) = v8;
  sub_1001EA980(a1);
  sub_1001EAD04(a1);
  sub_1001EC27C((uint64_t)a1, a2, a3, a4);
}

uint64_t sub_1001EBE94(int *a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t result;

  if (*(_QWORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 8 * *(unsigned __int16 *)(a2 + 2) + 184))
  {
    if (sub_10005549C())
    {
      sub_100054530("Got the same frame twice (txSeq=%d", *(unsigned __int16 *)(a2 + 2));
      v4 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  result = sub_1001E3CCC(a1);
  *(_QWORD *)(*(_QWORD *)(result + 112) + 8 * *(unsigned __int16 *)(a2 + 2) + 184) = a2;
  return result;
}

uint64_t sub_1001EBF3C(int *a1, unsigned __int8 a2)
{
  unsigned int v4;
  unsigned __int8 v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v12;

  v4 = *(unsigned __int8 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 8);
  v5 = a2 + 64;
  if (v4 <= a2)
    v5 = a2;
  v6 = v5;
  if (v5 <= v4)
  {
LABEL_6:
    v10 = 0;
  }
  else
  {
    while (1)
    {
      v7 = sub_1001EBC00((uint64_t)a1, v4 & 0x3F, 0);
      if ((_DWORD)v7)
        break;
      v8 = *(_QWORD *)(sub_1001E3CCC(a1) + 112);
      *(_WORD *)(v8 + 2 * *(unsigned __int16 *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 144) + 18) = v4 & 0x3F;
      v9 = sub_1001E3CCC(a1);
      ++*(_WORD *)(*(_QWORD *)(v9 + 112) + 144);
      LOBYTE(v4) = v4 + 1;
      if (v6 <= v4)
        goto LABEL_6;
    }
    v10 = v7;
    if (sub_10005549C())
    {
      sub_100054530("Failed to send SREJ : %!", v10);
      v12 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  *(_WORD *)(*(_QWORD *)(sub_1001E3CCC(a1) + 112) + 8) = (a2 + 1) & 0x3F;
  return v10;
}

uint64_t sub_1001EC060(uint64_t a1)
{
  uint64_t v2;
  size_t v3;
  uint64_t v4;
  NSObject *v5;
  __int16 v7;
  __int128 v8;
  __int128 v9;
  _OWORD v10[7];
  uint64_t v11;
  uint64_t v12;

  v11 = 0;
  memset(v10, 0, sizeof(v10));
  v8 = 0u;
  v9 = 0u;
  v12 = 0;
  v7 = 0;
  LOBYTE(v8) = *(__int16 *)(sub_1001E3CCC((int *)a1) + 38) == -1;
  *((_QWORD *)&v8 + 1) = *(_QWORD *)sub_1001E3CCC((int *)a1);
  LODWORD(v9) = 0;
  WORD2(v9) = *(_WORD *)(a1 + 4);
  WORD3(v9) = 256;
  BYTE8(v9) = 0;
  v2 = sub_1001E3CCC((int *)a1);
  v3 = (sub_1001EF8A8((int *)a1, 1, 0, 0, *(_BYTE *)(*(_QWORD *)(v2 + 112) + 8), (_WORD *)&v12 + 2)
                       + 4);
  WORD5(v9) = 2 * (*(_BYTE *)(sub_1001E3CCC((int *)a1) + 78) != 0) + v3;
  v12 = (v3 - 4 + 2 * (*(_BYTE *)(sub_1001E3CCC((int *)a1) + 78) != 0));
  *(_DWORD *)((char *)&v12 + 1) = ((unsigned __int16)(v3
                                                                     - 4
                                                                     + 2
                                                                     * (*(_BYTE *)(sub_1001E3CCC((int *)a1) + 78) != 0)) >> 8);
  WORD1(v12) = *(_WORD *)(sub_1001E3CCC((int *)a1) + 8);
  sub_1000532A8((uint64_t)v10 + 8, 2u);
  sub_10005336C((unsigned __int8 *)v10 + 8, (char *)&v12, v3, 2u);
  if (*(_BYTE *)(sub_1001E3CCC((int *)a1) + 78))
  {
    sub_1001EE884((uint64_t)v10 + 8, &v7);
    sub_10005336C((unsigned __int8 *)v10 + 8, (char *)&v7, 2uLL, 2u);
  }
  v4 = sub_1001F21A8((uint64_t)&v8);
  if ((_DWORD)v4)
  {
    if (sub_10005549C())
    {
      sub_100054530("Failed to send S-Frame %!.", v4);
      v5 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  return v4;
}

void sub_1001EC27C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  char *v9;
  size_t v10;
  uint64_t v11;
  int v12;
  char v13;
  NSObject *v14;
  NSObject *v15;
  uint64_t v16;

  v8 = *(_QWORD *)(sub_1001E3CCC((int *)a1) + 112);
  if (*(_BYTE *)(a2 + 4) == 1)
  {
    if (*(_QWORD *)(v8 + 696))
      sub_100253460();
    v9 = (char *)sub_100052DC0(*(unsigned __int16 *)(a2 + 6));
    *(_QWORD *)(v8 + 696) = v9;
    if (!v9)
      goto LABEL_21;
    *(_BYTE *)(v8 + 708) = 0;
  }
  else
  {
    if (!*(_BYTE *)(a2 + 4))
    {
      sub_1001DFBA8(*(unsigned __int16 *)(a1 + 4), *(_QWORD *)(a2 + 8), *(unsigned __int16 *)(a2 + 16), *(unsigned __int16 *)(a2 + 2), a3, a4);
LABEL_12:
      sub_1001EACD4((_QWORD *)a2);
      return;
    }
    v9 = *(char **)(v8 + 696);
    if (!v9)
    {
      if (sub_10005549C())
      {
        sub_100054530("Looks like we didn't get a START before this position (%d) -> ignoring.", *(unsigned __int8 *)(a2 + 4));
        v14 = sub_1000544A0(0x2Fu);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      goto LABEL_12;
    }
  }
  v10 = *(unsigned __int16 *)(a2 + 16);
  v11 = *(unsigned int *)(v8 + 704);
  if (*(unsigned __int16 *)(a2 + 6) - v11 >= v10)
  {
    memmove(&v9[v11], *(const void **)(a2 + 8), v10);
    v12 = *(_DWORD *)(v8 + 704) + *(unsigned __int16 *)(a2 + 16);
    *(_DWORD *)(v8 + 704) = v12;
    v13 = *(_BYTE *)(v8 + 708) | a3;
    *(_BYTE *)(v8 + 708) = v13;
    if (*(_BYTE *)(a2 + 4) == 2)
    {
      sub_1001DFBA8(*(unsigned __int16 *)(a1 + 4), *(_QWORD *)(v8 + 696), (unsigned __int16)v12, *(unsigned __int16 *)(a2 + 2), v13 != 0, a4);
      sub_100053298(*(void **)(v8 + 696));
      *(_QWORD *)(v8 + 696) = 0;
      *(_DWORD *)(v8 + 704) = 0;
    }
    goto LABEL_12;
  }
  if (sub_10005549C())
  {
    sub_100054530("retransmissionData->reassemblyPacket buffer space (%d) is too small for received data (%d).", *(unsigned __int16 *)(a2 + 6) - *(_DWORD *)(v8 + 704), *(unsigned __int16 *)(a2 + 16));
    a2 = sub_1000544A0(0x2Fu);
    if (os_log_type_enabled((os_log_t)a2, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  sub_100112D60(428);
LABEL_21:
  if (sub_10005549C())
  {
    sub_100054530("Failed to allocate %d bytes for retransmissionData.", *(unsigned __int16 *)(a2 + 6));
    v15 = sub_1000544A0(0x2Fu);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  v16 = sub_100112D60(106);
  sub_1001EC4AC(v16);
}

uint64_t sub_1001EC4AC(int *a1)
{
  uint64_t v2;
  __int16 v3;
  uint64_t v4;
  char *v5;
  size_t v6;
  uint64_t result;
  uint64_t v8;
  size_t v9;
  uint64_t v10;
  uint64_t v11;

  v2 = sub_1001E3CCC(a1);
  v3 = *(_WORD *)(*(_QWORD *)(v2 + 112) + 144);
  __chkstk_darwin(v2, v3);
  v5 = (char *)&v11 - v4;
  bzero((char *)&v11 - v4, v6);
  result = sub_1001E3CCC(a1);
  v8 = *(_QWORD *)(result + 112);
  if ((v3 & 0xFE) != 0)
  {
    v9 = (v3 - 1);
    memmove(v5, (const void *)(v8 + 20), v9);
    v10 = sub_1001E3CCC(a1);
    memmove((void *)(*(_QWORD *)(v10 + 112) + 18), v5, v9);
    result = sub_1001E3CCC(a1);
    --*(_WORD *)(*(_QWORD *)(result + 112) + 144);
  }
  else
  {
    *(_WORD *)(v8 + 144) = 0;
  }
  return result;
}

void sub_1001EC5A8(int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unsigned int v9;
  uint64_t i;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;

  v8 = *(_QWORD *)(sub_1001E3CCC(a1) + 112);
  v9 = *(unsigned __int16 *)(a2 + 2);
  if (v9 == *(unsigned __int16 *)(v8 + 152))
  {
    for (i = v8 + 8 * v9; ; i = v8 + 8 * v9)
    {
      v13 = *(_QWORD *)(i + 184);
      v12 = (_QWORD *)(i + 184);
      v11 = v13;
      if (!v13)
        break;
      sub_1001EC27C((uint64_t)a1, v11, a3, a4);
      *(_WORD *)(v8 + 152) = (*(_WORD *)(v8 + 152) + 1) & 0x3F;
      *v12 = 0;
      v9 = (v9 + 1) & 0x3F;
    }
  }
}

void sub_1001EC638(uint64_t a1)
{
  unsigned int v1;
  NSObject *v2;
  int *v3;
  unsigned int v4;
  char v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  int *v13;

  v1 = **(unsigned __int16 **)(a1 + 8);
  v13 = 0;
  if (sub_1001DB044(v1, (uint64_t *)&v13))
  {
    if (sub_10005549C())
    {
      sub_100054530("Monitor timer triggered on a released channel (0x%x), this is bad.", v1);
      v2 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
LABEL_20:
        sub_1006CE7A4();
    }
  }
  else
  {
    *(_DWORD *)(*(_QWORD *)(sub_1001E3CCC(v13) + 112) + 164) = 0;
    v3 = v13;
    if (*(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(v13) + 112) + 2))
    {
      sub_100253460();
      return;
    }
    v4 = *(unsigned __int8 *)(*(_QWORD *)(sub_1001E3CCC(v3) + 112) + 146);
    if (v4 >= *(unsigned __int8 *)(sub_1001E3CCC(v3) + 67))
    {
      if (sub_10005549C())
      {
        sub_100054530("Monitor timeout expired");
        v9 = sub_1000544A0(0x2Fu);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          sub_1006CEEC0();
      }
      sub_1001DEB7C(*((unsigned __int16 *)v3 + 2), 436);
    }
    else
    {
      v5 = *(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(v3) + 112) + 146) + 1;
      *(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(v3) + 112) + 146) = v5;
      v6 = sub_1001EB174(v3, 1, 0);
      if ((_DWORD)v6)
      {
        v7 = v6;
        if (sub_10005549C())
        {
          sub_100054530("Failed to send RR or RNR : %!", v7);
          v8 = sub_1000544A0(0x2Fu);
          if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
            goto LABEL_20;
        }
      }
      else
      {
        v10 = sub_1001EA9D0(v3);
        if ((_DWORD)v10)
        {
          v11 = v10;
          if (sub_10005549C())
          {
            sub_100054530("Failed to start monitor timer %!.", v11);
            v12 = sub_1000544A0(0x2Fu);
            if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
              goto LABEL_20;
          }
        }
      }
    }
  }
}

void sub_1001EC82C(uint64_t a1)
{
  unsigned int v1;
  NSObject *v2;
  int *v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  int *v10;

  v1 = **(unsigned __int16 **)(a1 + 8);
  v10 = 0;
  if (sub_1001DB044(v1, (uint64_t *)&v10))
  {
    if (sub_10005549C())
    {
      sub_100054530("Monitor timer triggered on a released channel (0x%x), this is bad.", v1);
      v2 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
LABEL_4:
        sub_1006CE7A4();
    }
  }
  else
  {
    *(_DWORD *)(*(_QWORD *)(sub_1001E3CCC(v10) + 112) + 160) = 0;
    v3 = v10;
    if (*(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(v10) + 112) + 2) == 1)
    {
      v4 = sub_1001EB174(v3, 1, 0);
      if ((_DWORD)v4)
      {
        v5 = v4;
        if (sub_10005549C())
        {
          sub_100054530("Failed to send RR or RNR : %!", v5);
          v6 = sub_1000544A0(0x2Fu);
          if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
            goto LABEL_4;
        }
      }
      else
      {
        *(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(v3) + 112) + 146) = 1;
        v7 = sub_1001EA9D0(v3);
        if ((_DWORD)v7)
        {
          v8 = v7;
          if (sub_10005549C())
          {
            sub_100054530("Failed to start monitor timer %!.", v8);
            v9 = sub_1000544A0(0x2Fu);
            if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
              sub_1006CE7A4();
          }
        }
        *(_BYTE *)(*(_QWORD *)(sub_1001E3CCC(v3) + 112) + 2) = 0;
      }
    }
    else
    {
      sub_100253460();
    }
  }
}

void sub_1001EC9BC(uint64_t a1, __int16 a2, int a3)
{
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  const void *v7[2];
  _DWORD v8[2];

  qword_100984D00 = a1;
  word_100984D08 = a2;
  if (a3 != 1216)
  {
    if ((byte_100984D0C & 1) == 0)
      sub_100253460();
    v7[0] = (const void *)8;
    byte_100984D0C = 0;
    sub_10004AD30((uint64_t)&unk_100984D14);
    v8[0] = a3;
    v8[1] = byte_100984D10;
    v7[1] = v8;
    v4 = sub_10004AE90((uint64_t)sub_1001ECAA0, v7, 0);
    if ((_DWORD)v4)
    {
      v5 = v4;
      if (sub_10005549C())
      {
        sub_100054530("OI_Dispatch_RegisterFunc failed %!", v5);
        v6 = sub_1000544A0(0x3Au);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
    }
  }
}

void sub_1001ECAA0(uint64_t a1)
{
  sub_10019CB24(*(unsigned __int8 *)(*(_QWORD *)(a1 + 8) + 4), **(unsigned int **)(a1 + 8));
}

uint64_t sub_1001ECAB0()
{
  uint64_t result;
  _DWORD *v1;

  result = sub_10016F6C8();
  if (!(_DWORD)result)
  {
    v1 = sub_100114588(0x810uLL);
    qword_100984D20 = (uint64_t)v1;
    v1[509] = 4;
    *((_BYTE *)v1 + 2060) = 0;
    if (*((_BYTE *)v1 + 2040))
      *((_BYTE *)v1 + 2040) = 0;
    qword_100984D28 = 0;
    sub_10004AD30((uint64_t)&unk_100984D14);
    *(_BYTE *)(qword_100984D20 + 2049) = 0;
    sub_1001ED440(5);
    return 109;
  }
  return result;
}

uint64_t sub_1001ECB24()
{
  if (*(_DWORD *)(qword_100984D20 + 2036) == 4)
    return 109;
  else
    return 0;
}

uint64_t sub_1001ECB44()
{
  return 2032;
}

uint64_t sub_1001ECB4C(int a1, __int16 a2, int a3)
{
  char v5;
  uint64_t v6;
  unsigned __int16 v7;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;

  v5 = a1;
  if (a1 != 1 && *(_BYTE *)(qword_100984D20 + 2040))
    return 129;
  if (a1 == 2)
    v7 = 5;
  else
    v7 = 4;
  if (byte_100984D0C == 1)
  {
    sub_100253460();
    return 118;
  }
  else
  {
    if (!qword_100984D00)
      sub_100253460();
    v9 = (unsigned __int16)word_100984D08;
    if (!word_100984D08)
    {
      sub_100253460();
      v9 = (unsigned __int16)word_100984D08;
    }
    v10 = qword_100984D00;
    v6 = 105;
    if (qword_100984D00 && v9)
    {
      if (a3 + v7 <= v9)
      {
        *(_BYTE *)qword_100984D00 = v5;
        *(_WORD *)(v10 + 1) = a2;
        *(_WORD *)(v10 + 3) = a3;
        if (a3)
          sub_100053868((char *)(v10 + v7));
        else
          sub_10004A104();
        byte_100984D10 = v5;
        byte_100984D0C = 1;
        v6 = sub_10016F698();
        if ((_DWORD)v6)
        {
          sub_10004AD30((uint64_t)&unk_100984D14);
          byte_100984D0C = 0;
        }
        v11 = qword_100984D20;
        if (*(_BYTE *)(qword_100984D20 + 2040) && *(_DWORD *)(qword_100984D20 + 2036) == 4)
        {
          *(_BYTE *)(qword_100984D20 + 2049) = 0;
          *(_DWORD *)(v11 + 2036) = 1;
          *(_WORD *)(v11 + 2042) = 5;
          sub_1001ED440(0x7FFF);
        }
      }
      else
      {
        sub_100253460();
        return 105;
      }
    }
  }
  return v6;
}

uint64_t sub_1001ECCC4(uint64_t __src, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  char *v9;
  uint64_t v10;
  double v11;
  double v12;
  double v13;
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  NSObject *v25;
  int v26;
  __int16 v27;
  char *v28;
  char v29;
  uint64_t v30;
  __int16 v31;
  size_t v32;
  uint64_t v33;
  int v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  NSObject *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  NSObject *v51;
  unsigned __int16 v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  NSObject *v60;
  void *v61;
  void *v62;
  void *v63;
  void *v64;
  uint64_t v66;
  uint64_t v67;
  uint8_t v68[4];
  uint64_t v69;
  _BYTE buf[12];
  __int16 v71;
  int v72;

  if ((_DWORD)a2)
  {
    v8 = a2;
    v9 = (char *)__src;
    do
    {
      v10 = qword_100984D20;
      if (*(_BYTE *)(qword_100984D20 + 2040))
      {
        *(_QWORD *)buf = 0;
        v67 = 0;
        sub_1001135CC(&v67);
        sub_10011362C(v67, qword_100984D28, &stru_100984D30, buf, v11, v12, v13);
        if ((_DWORD)v14)
        {
          v15 = v14;
          if (sub_10005549C())
          {
            v66 = v15;
            sub_100054530("OI_AbsoluteTime_Diff returned %!");
            v16 = sub_1000544A0(0x3Au);
            if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
              sub_1006CEDF0(v68, &v69, v16);
          }
        }
        if ((*(unsigned int *)&buf[4] | ((unint64_t)*(unsigned int *)buf << 32)) >= 0x12A153440)
          sub_100112D60(112);
        __src = j__usleep(0);
        v10 = qword_100984D20;
      }
      switch(*(_DWORD *)(v10 + 2036))
      {
        case 0:
        case 4:
          goto LABEL_53;
        case 1:
          v17 = *v9;
          if ((v17 - 1) >= 4u)
          {
            if (sub_10005549C())
            {
              sub_100054530("unknown packet type received %d", v17);
              v43 = sub_1000544A0(0x3Au);
              if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
              {
                v62 = sub_100054494();
                *(_DWORD *)buf = 136446466;
                *(_QWORD *)&buf[4] = v62;
                v71 = 1024;
                v72 = 0xFFFF;
                _os_log_error_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_ERROR, "%{public}s (status=%{bluetooth:OI_STATUS}u)", buf, 0x12u);
              }
            }
            sub_100253320((uint64_t)"VirtualCTRL: unknown packet type received %d\n", v36, v37, v38, v39, v40, v41, v42, v17);
            __src = sub_1001ED640(240);
          }
          else
          {
            *(_WORD *)(v10 + 2042) = 0x2000300040003uLL >> (16 * (v17 - 1));
            *(_BYTE *)(v10 + 2048) = v17;
            *(_WORD *)(v10 + 2044) = 0;
            *(_DWORD *)(v10 + 2036) = 2;
            __src = sub_1001ED440(20);
          }
          if (*(_DWORD *)(qword_100984D20 + 2036) == 2)
          {
            ++v9;
            --v8;
          }
          continue;
        case 2:
          v26 = 0;
          v27 = *(_WORD *)(v10 + 2042);
          v28 = v9;
          break;
        case 3:
          if ((unsigned __int16)v8 >= *(unsigned __int16 *)(v10 + 2042))
            v32 = *(unsigned __int16 *)(v10 + 2042);
          else
            v32 = (unsigned __int16)v8;
          __src = (uint64_t)memmove((void *)(v10 + *(unsigned __int16 *)(v10 + 2044) + 4), v9, v32);
          v33 = qword_100984D20;
          v34 = *(unsigned __int16 *)(qword_100984D20 + 2042);
          v8 -= v32;
          *(_WORD *)(qword_100984D20 + 2044) += v32;
          v9 += v32;
          v35 = v34 - v32;
          *(_WORD *)(v33 + 2042) = v35;
          if (v35)
            continue;
          goto LABEL_47;
        default:
          if (sub_10005549C())
          {
            sub_100054530("Invalid receive state %d", *(_DWORD *)(qword_100984D20 + 2036));
            v25 = sub_1000544A0(0x3Au);
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
            {
              v61 = sub_100054494();
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = v61;
              v71 = 1024;
              v72 = 0xFFFF;
              _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "%{public}s (status=%{bluetooth:OI_STATUS}u)", buf, 0x12u);
            }
          }
          sub_100253320((uint64_t)"VirtualCTRL: Invalid receive state %d\n", v18, v19, v20, v21, v22, v23, v24, *(unsigned int *)(qword_100984D20 + 2036));
          sub_1001ED640(242);
          sub_100253460();
          continue;
      }
      while (v27)
      {
        v29 = *v28++;
        v30 = *(unsigned __int16 *)(v10 + 2044);
        *(_WORD *)(v10 + 2044) = v30 + 1;
        *(_BYTE *)(v10 + v30 + 4) = v29;
        v27 = *(_WORD *)(v10 + 2042) - 1;
        *(_WORD *)(v10 + 2042) = v27;
        if ((unsigned __int16)++v26 >= (unsigned __int16)v8)
        {
          v26 = v8;
          if (v27)
            goto LABEL_46;
          break;
        }
      }
      *(_DWORD *)(v10 + 2036) = 3;
      switch(*(_BYTE *)(v10 + 2048))
      {
        case 1:
        case 3:
          v31 = *(unsigned __int8 *)(v10 + 6);
          goto LABEL_41;
        case 2:
          v31 = *(_WORD *)(v10 + 6);
          goto LABEL_41;
        case 4:
          v31 = *(unsigned __int8 *)(v10 + 5);
LABEL_41:
          *(_WORD *)(v10 + 2042) = v31;
          v52 = *(_WORD *)(v10 + 2044) + v31;
          *(_WORD *)(v10 + 2046) = v52;
          if (v52 >= 0x7F1u)
          {
            if (sub_10005549C())
            {
              sub_100054530("RxPacketHeader - bogus packet length (%d)", *(unsigned __int16 *)(qword_100984D20 + 2046));
              v60 = sub_1000544A0(0x3Au);
              if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
              {
                v63 = sub_100054494();
                *(_DWORD *)buf = 136446466;
                *(_QWORD *)&buf[4] = v63;
                v71 = 1024;
                v72 = 0xFFFF;
                _os_log_error_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_ERROR, "%{public}s (status=%{bluetooth:OI_STATUS}u)", buf, 0x12u);
              }
            }
            sub_100253320((uint64_t)"VirtualCTRL: RxPacketHeader - bogus packet length (%d)\n", v53, v54, v55, v56, v57, v58, v59, *(unsigned __int16 *)(qword_100984D20 + 2046));
            __src = sub_1001ED640(244);
          }
          break;
        default:
          if (sub_10005549C())
          {
            sub_100054530("Invalid packet type %d", *(unsigned __int8 *)(qword_100984D20 + 2048));
            v51 = sub_1000544A0(0x3Au);
            if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
            {
              v64 = sub_100054494();
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = v64;
              v71 = 1024;
              v72 = 0xFFFF;
              _os_log_error_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_ERROR, "%{public}s (status=%{bluetooth:OI_STATUS}u)", buf, 0x12u);
            }
          }
          sub_100253320((uint64_t)"VirtualCTRL: Invalid packet type %d\n", v44, v45, v46, v47, v48, v49, v50, *(unsigned __int8 *)(qword_100984D20 + 2048));
          sub_1001ED640(240);
          sub_100253460();
          v26 = 0;
          break;
      }
LABEL_46:
      v9 += (unsigned __int16)v26;
      v8 -= v26;
      v33 = qword_100984D20;
      if (!*(_WORD *)(qword_100984D20 + 2042))
      {
LABEL_47:
        if (*(_BYTE *)(v33 + 2040))
        {
          sub_1001ED778();
        }
        else
        {
          if (*(unsigned __int16 *)(v33 + 2046) >= 0x7F1u)
            sub_100253460();
          sub_1001ED7F4(__src, a2, a3, a4, a5, a6, a7, a8, v66);
        }
      }
    }
    while ((_WORD)v8);
  }
LABEL_53:
  if (*(_WORD *)(qword_100984D20 + 2042))
    return *(unsigned __int16 *)(qword_100984D20 + 2042);
  else
    return 5;
}

uint64_t sub_1001ED2AC(int a1, __int16 a2, size_t __len, void *__src)
{
  char v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;

  v4 = a1;
  if (a1 != 1 && *(_BYTE *)(qword_100984D20 + 2040))
    return 129;
  v6 = 4;
  if (a1 == 2)
    v6 = 5;
  if (byte_100984D0C == 1)
  {
    sub_100253460();
    return 118;
  }
  else
  {
    v7 = qword_100984D00;
    if (qword_100984D00)
      v8 = word_100984D08 == 0;
    else
      v8 = 1;
    if (v8)
    {
      return 105;
    }
    else
    {
      *(_BYTE *)qword_100984D00 = a1;
      *(_WORD *)(v7 + 1) = a2;
      *(_WORD *)(v7 + 3) = __len;
      memmove((void *)(v7 + v6), __src, __len);
      byte_100984D10 = v4;
      byte_100984D0C = 1;
      v9 = sub_10016F698();
      v5 = v9;
      if ((_DWORD)v9)
      {
        sub_10004AD30((uint64_t)&unk_100984D14);
        byte_100984D0C = 0;
      }
      v10 = qword_100984D20;
      if (*(_BYTE *)(qword_100984D20 + 2040) && *(_DWORD *)(qword_100984D20 + 2036) == 4)
      {
        *(_BYTE *)(qword_100984D20 + 2049) = 0;
        *(_DWORD *)(v10 + 2036) = 1;
        *(_WORD *)(v10 + 2042) = 5;
        sub_1001ED440(0x7FFF);
      }
    }
  }
  return v5;
}

void sub_1001ED3E4(int a1)
{
  if (a1)
  {
    if (!*(_BYTE *)(qword_100984D20 + 2040))
    {
      *(_BYTE *)(qword_100984D20 + 2040) = 1;
      sub_1001135CC(&qword_100984D28);
      sub_1001135F4(&stru_100984D30);
    }
  }
  else
  {
    if (*(_BYTE *)(qword_100984D20 + 2040))
      *(_BYTE *)(qword_100984D20 + 2040) = 0;
    qword_100984D28 = 0;
  }
}

uint64_t sub_1001ED440(int a1)
{
  if (sub_10004A088(*(_DWORD *)qword_100984D20))
    return sub_1002537E8(*(_DWORD *)qword_100984D20, a1);
  else
    return sub_10004A9EC((uint64_t)sub_1001ED498, 0, a1, (int *)qword_100984D20);
}

void sub_1001ED498()
{
  uint64_t v0;
  unsigned int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;

  v0 = qword_100984D20;
  v1 = *(_DWORD *)(qword_100984D20 + 2036);
  if (v1 < 2)
  {
    if (!*(_BYTE *)(qword_100984D20 + 2040))
    {
LABEL_14:
      sub_1001ED440(0x7FFFLL);
      return;
    }
    if (sub_10005549C())
    {
      sub_100054530("timed out waiting for reset response %d", *(_DWORD *)(qword_100984D20 + 2036));
      v10 = sub_1000544A0(0x3Au);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_1006CEE54();
    }
  }
  else
  {
    if (v1 - 2 < 2)
    {
      if (sub_10005549C())
      {
        sub_100054530("Timed out while receiving a packet. Current state:%d", *(_DWORD *)(qword_100984D20 + 2036));
        v9 = sub_1000544A0(0x3Au);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          sub_1006CEE54();
      }
      sub_100253320((uint64_t)"VirtualCTRL: Timed out while receiving a packet. Current state:%d\n", v2, v3, v4, v5, v6, v7, v8, *(unsigned int *)(qword_100984D20 + 2036));
      sub_1001ED640(241);
      return;
    }
    if (v1 == 4)
    {
      if (*(_BYTE *)(qword_100984D20 + 2040))
        return;
      *(_BYTE *)(qword_100984D20 + 2049) = 0;
      *(_DWORD *)(v0 + 2036) = 1;
      *(_WORD *)(v0 + 2042) = 5;
      goto LABEL_14;
    }
    if (sub_10005549C())
    {
      sub_100054530("Invalid receive state %d", *(_DWORD *)(qword_100984D20 + 2036));
      v18 = sub_1000544A0(0x3Au);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    sub_100253320((uint64_t)"VirtualCTRL: Invalid receive state %d\n", v11, v12, v13, v14, v15, v16, v17, *(unsigned int *)(qword_100984D20 + 2036));
    sub_1001ED640(243);
    sub_100253460();
  }
}

uint64_t sub_1001ED640(int a1)
{
  NSObject *v2;
  uint64_t v3;

  if (sub_10005549C())
  {
    sub_100054530("RxErrorDetected:%d", a1);
    v2 = sub_1000544A0(0x3Au);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1006CE80C();
  }
  v3 = qword_100984D20;
  if (!*(_BYTE *)(qword_100984D20 + 2040))
  {
    *(_WORD *)(qword_100984D20 + 4) = 272;
    *(_BYTE *)(v3 + 6) = a1;
    *(_WORD *)(v3 + 2046) = 3;
    *(_BYTE *)(v3 + 2048) = 4;
    sub_1001ED6FC();
    v3 = qword_100984D20;
  }
  *(_DWORD *)(v3 + 2036) = 4;
  sub_1001ED3E4(1);
  return sub_1001ED440(5);
}

void sub_1001ED6FC()
{
  uint64_t v0;
  _QWORD v1[2];

  v0 = qword_100984D20;
  if (*(unsigned __int16 *)(qword_100984D20 + 2046) >= 0x7F1u)
  {
    sub_100253460();
    v0 = qword_100984D20;
  }
  *(_BYTE *)(v0 + 2049) = 0;
  *(_DWORD *)(v0 + 2036) = 1;
  *(_WORD *)(v0 + 2042) = 5;
  sub_1001ED440(0x7FFFLL);
  v1[1] = 0;
  v1[0] = mach_continuous_time();
  sub_100047AB0(*(unsigned __int8 *)(qword_100984D20 + 2048), (unsigned __int8 *)(qword_100984D20 + 4), *(unsigned __int16 *)(qword_100984D20 + 2046), (uint64_t)v1);
}

void sub_1001ED778()
{
  uint64_t v0;
  char v1;
  char *v2;
  int v3;
  int v4;

  if (*(_BYTE *)(qword_100984D20 + 2048) == 4 && *(_WORD *)(qword_100984D20 + 2046) == 6)
  {
    v0 = 0;
    v1 = 1;
    v2 = &byte_10073AF8F;
    do
    {
      v3 = (*(v2 - 1) & *(_BYTE *)(qword_100984D20 + 4 + v0));
      v4 = *v2;
      v2 += 2;
      if (v3 != v4)
        v1 = 0;
      ++v0;
    }
    while (v0 != 6);
    if ((v1 & 1) != 0)
    {
      if (*(_BYTE *)(qword_100984D20 + 2040))
        *(_BYTE *)(qword_100984D20 + 2040) = 0;
      qword_100984D28 = 0;
      sub_1001ED6FC();
    }
  }
}

void sub_1001ED7F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;
  _QWORD v10[2];

  v9 = qword_100984D20;
  if (*(unsigned __int16 *)(qword_100984D20 + 2046) >= 0x7F1u)
  {
    sub_100253460();
    v9 = qword_100984D20;
  }
  if (*(_BYTE *)(v9 + 2060))
  {
    sub_100253320((uint64_t)"Rx routing suspended during stack termination!\n", a2, a3, a4, a5, a6, a7, a8, a9);
  }
  else
  {
    *(_BYTE *)(v9 + 2049) = 0;
    *(_DWORD *)(v9 + 2036) = 1;
    *(_WORD *)(v9 + 2042) = 5;
    sub_1001ED440(0x7FFF);
    v10[1] = 0;
    v10[0] = mach_continuous_time();
    sub_100047AB0(*(unsigned __int8 *)(qword_100984D20 + 2048), (unsigned __int8 *)(qword_100984D20 + 4), *(unsigned __int16 *)(qword_100984D20 + 2046), (uint64_t)v10);
  }
}

uint64_t sub_1001ED894()
{
  return 0;
}

void sub_1001ED89C()
{
  *(_BYTE *)(qword_100984D20 + 2060) = 1;
}

char *sub_1001ED8B0(char *result, int a2)
{
  uint64_t v2;
  int v3;
  char *v4;
  char v5;

  if (a2 >= 2)
  {
    v2 = a2 >> 1;
    v3 = a2 - 1;
    v4 = result;
    do
    {
      v5 = *v4;
      *v4++ = result[v3];
      result[v3--] = v5;
      --v2;
    }
    while (v2);
  }
  return result;
}

uint64_t sub_1001ED8E4(const void *a1, unsigned int a2, void *a3, int a4)
{
  unint64_t v8;
  unsigned int v9;
  unint64_t v10;
  unsigned int v11;
  size_t v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  NSObject *v17;
  NSObject *v18;
  __int128 v20;
  __int128 v21;
  __int128 v22;

  v22 = 0uLL;
  v21 = 0uLL;
  v20 = *(_OWORD *)"1pmt";
  v8 = a2;
  __memmove_chk(&v22, a1, a2, 16);
  if (a2 <= 0xF)
  {
    v9 = 16 - a2;
    v10 = v8;
    do
    {
      v11 = v9 - a2;
      if (v9 >= a2)
        v12 = a2;
      else
        v12 = v9;
      memmove((char *)&v22 + v10, a1, v12);
      v10 += v8;
      v9 = v11;
    }
    while (v10 < 0x10);
  }
  if (!a4)
  {
    v16 = sub_10018571C(&v22, 0x746D7031u, &v21);
    if ((_DWORD)v16)
    {
      v14 = v16;
      if (sub_10005549C())
      {
        sub_100054530("SMP_Crypto_h6 failed creating ILK %!", v14);
        v17 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          sub_1006CEEC0();
      }
      return v14;
    }
    goto LABEL_16;
  }
  v13 = sub_100185854(&v22, &v20, &v21);
  if (!(_DWORD)v13)
  {
LABEL_16:
    v14 = sub_10018571C(&v21, 0x6C656272u, a3);
    if ((_DWORD)v14)
    {
      if (sub_10005549C())
      {
        sub_100054530("SMP_Crypto_h6 failed creating LTK %!", v14);
        v18 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          goto LABEL_19;
      }
    }
    return v14;
  }
  v14 = v13;
  if (sub_10005549C())
  {
    sub_100054530("SMP_Crypto_h7 failed creating ILK %!", v14);
    v15 = sub_1000544A0(0x43u);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
LABEL_19:
      sub_1006CEEC0();
  }
  return v14;
}

uint64_t sub_1001EDAEC(uint64_t a1, unsigned int a2, void *a3, int a4)
{
  unsigned int v7;
  unint64_t v8;
  unsigned int v9;
  size_t v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  NSObject *v15;
  NSObject *v16;
  __int128 v18;
  __int128 v19;
  __int128 v20;

  v20 = 0uLL;
  v19 = 0uLL;
  v18 = *(_OWORD *)"2pmt";
  __memmove_chk(&v20, a1, a2, 16);
  if (a2 <= 0xF)
  {
    v7 = 16 - a2;
    v8 = a2;
    do
    {
      v9 = v7 - a2;
      if (v7 >= a2)
        v10 = a2;
      else
        v10 = v7;
      memmove((char *)&v20 + v8, a3, v10);
      v8 += a2;
      v7 = v9;
    }
    while (v8 < 0x10);
  }
  if (!a4)
  {
    v14 = sub_10018571C(&v20, 0x746D7032u, &v19);
    if ((_DWORD)v14)
    {
      v12 = v14;
      if (sub_10005549C())
      {
        sub_100054530("SMP_Crypto_h6 failed creating ILK %!", v12);
        v15 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          sub_1006CEEC0();
      }
      return v12;
    }
    goto LABEL_16;
  }
  v11 = sub_100185854(&v20, &v18, &v19);
  if (!(_DWORD)v11)
  {
LABEL_16:
    v12 = sub_10018571C(&v19, 0x62726C65u, a3);
    if ((_DWORD)v12)
    {
      if (sub_10005549C())
      {
        sub_100054530("SMP_Crypto_h6 failed creating LK %!", v12);
        v16 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          goto LABEL_19;
      }
    }
    return v12;
  }
  v12 = v11;
  if (sub_10005549C())
  {
    sub_100054530("SMP_Crypto_h7 failed creating ILTK %!", v12);
    v13 = sub_1000544A0(0x43u);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
LABEL_19:
      sub_1006CEEC0();
  }
  return v12;
}

__int128 *sub_1001EDCF0()
{
  return &xmmword_100984D38;
}

__int128 *sub_1001EDCFC()
{
  return &xmmword_100984D48;
}

__n128 sub_1001EDD08(__n128 *a1)
{
  __n128 result;

  result = *a1;
  xmmword_100984D38 = (__int128)*a1;
  return result;
}

__n128 sub_1001EDD1C(__n128 *a1)
{
  __n128 result;

  result = *a1;
  xmmword_100984D48 = (__int128)*a1;
  return result;
}

void sub_1001EDD30(char *ptr, uint64_t a2, int a3)
{
  uint64_t v4;
  uint64_t v6;
  _BOOL8 v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  uint64_t v11;
  BOOL v13;
  __int128 v14;

  v4 = a2;
  v6 = *(_QWORD *)ptr;
  v14 = 0uLL;
  if ((_DWORD)a2)
  {
    v7 = 0;
  }
  else
  {
    v14 = *(_OWORD *)(ptr + 562);
    v7 = ptr[593] != 0;
  }
  v8 = *((unsigned int *)ptr + 3);
  if ((_DWORD)v8)
  {
    sub_100049F6C(v8);
    *((_DWORD *)ptr + 3) = 0;
  }
  if (!(_DWORD)v4)
  {
    if (ptr[612])
    {
      if (sub_10005549C())
      {
        sub_100054530("Pairing completed with a compromised device");
        v9 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      v4 = 4832;
    }
    else
    {
      v4 = 0;
    }
  }
  if (*((_DWORD *)ptr + 154))
  {
    if (sub_10005549C())
    {
      sub_100054530("using override status %d", *((_DWORD *)ptr + 154));
      v10 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    v4 = *((unsigned int *)ptr + 154);
  }
  sub_100053298(ptr);
  if (sub_10019AC00(v6))
  {
    *(_QWORD *)(v6 + 240) = 0;
    if (a3 && unk_1009990F8)
    {
      if (*(_BYTE *)(v6 + 55))
        v11 = v6 + 56;
      else
        v11 = 0;
      unk_1009990F8(v6 + 48, v11, v4, 0);
    }
    v13 = (_DWORD)v4 == 4832 || (_DWORD)v4 == 0;
    *(_BYTE *)(v6 + 208) = v13;
    sub_100213108(v6);
  }
  else if (sub_10019AB28(v6))
  {
    *(_QWORD *)(v6 + 312) = 0;
    if (a3)
    {
      if (off_100999100)
        off_100999100(v6 + 48, v4, &v14, v7, 0);
    }
  }
}

void sub_1001EDF20(uint64_t a1, unsigned __int8 *a2, int a3)
{
  unsigned int v6;
  _QWORD *v7;
  NSObject *v8;
  void (*v9)(uint64_t, unsigned __int8 *, _QWORD);
  NSObject *v10;
  NSObject *v11;

  if (!a2 || !a3)
  {
    if (!sub_10005549C())
      return;
    sub_100054530("BR/EDR Security Manager error : invalid size %d", a3);
    v8 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      return;
LABEL_19:
    sub_1006CE7A4();
    return;
  }
  if (sub_10019AB28(a1))
  {
    v6 = *a2;
    if (v6 < 0xF)
    {
      v7 = &unk_10091D3F8;
      goto LABEL_12;
    }
  }
  if (!sub_10019AC00(a1) || (v6 = *a2, v6 >= 0xF))
  {
    if (!sub_10005549C())
      return;
    sub_100054530("Invalid connection");
    v10 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      return;
    goto LABEL_19;
  }
  v7 = &unk_10091F0A8;
LABEL_12:
  v9 = (void (*)(uint64_t, unsigned __int8 *, _QWORD))v7[v6];
  if (v9)
  {
    v9(a1, a2 + 1, (unsigned __int16)(a3 - 1));
    return;
  }
  if (sub_10005549C())
  {
    sub_100054530("Unknow SMP header 0x%x or invalid connection", *a2);
    v11 = sub_1000544A0(0x43u);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      goto LABEL_19;
  }
}

uint64_t sub_1001EE0AC(uint64_t a1)
{
  uint64_t v2;

  if (sub_10019AC00(a1))
  {
    v2 = a1 + 240;
    return *(_QWORD *)v2;
  }
  if (sub_10019AB28(a1))
  {
    v2 = a1 + 312;
    return *(_QWORD *)v2;
  }
  return 0;
}

uint64_t sub_1001EE0F4(__int128 *a1, char *a2, size_t a3, int a4)
{
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  unsigned int v15;
  uint64_t v16;
  NSObject *v17;
  int *v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;

  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v20 = 0u;
  if (!sub_10019AC00((uint64_t)a1) && !sub_10019AB28((uint64_t)a1))
  {
    if (sub_10005549C())
    {
      sub_100054530("Invalid handle");
      v13 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 4820;
  }
  v8 = sub_1000532A8((uint64_t)&v20, 1u);
  if (!(_DWORD)v8)
  {
    v11 = sub_10005336C((unsigned __int8 *)&v20, a2, a3, 2u);
    if ((_DWORD)v11)
    {
      v9 = v11;
      if (sub_10005549C())
      {
        sub_100054530("Failed to append mbuf result %!", v9);
        v12 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          goto LABEL_26;
      }
      return v9;
    }
    if (sub_10019AB28((uint64_t)a1))
    {
      v15 = 7;
    }
    else
    {
      if (!sub_10019AC00((uint64_t)a1))
      {
        v9 = 0;
        goto LABEL_23;
      }
      v15 = 6;
    }
    v9 = sub_1001DBC18(0, v15, a1, (uint64_t)&v20, 0);
    if ((_DWORD)v9)
      sub_100253460();
LABEL_23:
    sub_100253FD8((uint64_t)&v20);
    v16 = sub_1001EE0AC((uint64_t)a1);
    if ((_DWORD)v9)
    {
      if (sub_10005549C())
      {
        sub_100054530("Could not write to the SMP channel for handle 0x%x with status %!", a1, v9, v20, v21, v22, v23, v24, v25, v26);
        v17 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          goto LABEL_26;
      }
    }
    else
    {
      v18 = (int *)v16;
      if (v16)
      {
        v19 = *(unsigned int *)(v16 + 12);
        if ((_DWORD)v19)
        {
          sub_100049F6C(v19);
          v18[3] = 0;
        }
        if (a4)
          sub_1001EE334(v18);
      }
      return 0;
    }
    return v9;
  }
  v9 = v8;
  if (sub_10005549C())
  {
    sub_100054530("Failed to init mbuf result %!", v9);
    v10 = sub_1000544A0(0x43u);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
LABEL_26:
      sub_1006CEEC0();
  }
  return v9;
}

void sub_1001EE334(int *a1)
{
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  const void *v4[2];

  v4[1] = a1;
  v4[0] = (const void *)8;
  v1 = sub_10004A9EC((uint64_t)sub_1001EE6C4, v4, 300, a1 + 3);
  if ((_DWORD)v1)
  {
    v2 = v1;
    if (sub_10005549C())
    {
      sub_100054530("Could not register timeout for SMP Tx wth status %!.", v2);
      v3 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
}

_BYTE *sub_1001EE3C4(uint64_t a1)
{
  _BYTE *v2;
  _BYTE *v3;

  if (sub_10019AC00(a1) && *(_QWORD *)(a1 + 240) || sub_10019AB28(a1) && *(_QWORD *)(a1 + 312))
    return 0;
  v3 = sub_100052DC0(0x270uLL);
  v2 = v3;
  if (v3)
  {
    bzero(v3, 0x270uLL);
    *(_QWORD *)v2 = a1;
    v2[8] = 0;
  }
  if (sub_10019AC00(a1))
  {
    *(_QWORD *)(a1 + 240) = v2;
    sub_10021301C(a1);
  }
  else if (sub_10019AB28(a1))
  {
    *(_QWORD *)(a1 + 312) = v2;
  }
  return v2;
}

BOOL sub_1001EE460(uint64_t a1, char a2, char a3, char a4, unsigned int a5, char a6, char a7)
{
  char v9;

  *(_BYTE *)(a1 + 78) = a2;
  *(_BYTE *)(a1 + 79) = a3;
  *(_BYTE *)(a1 + 80) = a4;
  *(_BYTE *)(a1 + 82) = a6;
  *(_BYTE *)(a1 + 83) = a7;
  if (sub_10019AC00(*(_QWORD *)a1))
  {
    if (a5 >= 0x10)
      v9 = 16;
    else
      v9 = a5;
    *(_BYTE *)(a1 + 81) = v9;
  }
  else
  {
    *(_BYTE *)(a1 + 9) = 1;
  }
  return sub_1001EE4C0((uint64_t *)a1);
}

BOOL sub_1001EE4C0(uint64_t *a1)
{
  _BOOL8 result;

  result = sub_10019AC00(*a1);
  if (result)
  {
    result = sub_10019AC00(*a1);
    if (!result)
      return sub_10019AB28(*a1);
  }
  return result;
}

BOOL sub_1001EE504(uint64_t a1)
{
  return sub_10019AC00(a1) && *(_QWORD *)(a1 + 240) || sub_10019AB28(a1) && *(_QWORD *)(a1 + 312);
}

uint64_t sub_1001EE550(uint64_t result)
{
  byte_10097A8A8 = result;
  return result;
}

uint64_t sub_1001EE55C()
{
  return byte_10097A8A8;
}

uint64_t sub_1001EE568(char a1)
{
  if ((a1 + 16) > 0x1Eu)
    return 4800;
  else
    return dword_10073AFC0[(char)(a1 + 16)];
}

const char *sub_1001EE594()
{
  return "";
}

void sub_1001EE5A0(uint64_t a1, char a2)
{
  NSObject *v4;
  uint8_t buf[4];
  void *v6;

  if (sub_10002825C())
  {
    if (sub_10005549C())
    {
      sub_100054530("SMP State device:%: %s -> %s", *(_QWORD *)a1 + 49, "", "");
      v4 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v6 = sub_100054494();
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
  }
  *(_BYTE *)(a1 + 8) = a2;
}

BOOL sub_1001EE68C(uint64_t a1, int a2)
{
  return *(unsigned __int8 *)(a1 + 8) == a2;
}

uint64_t sub_1001EE69C(uint64_t a1, int a2)
{
  uint64_t result;

  result = sub_1001EE0AC(a1);
  if (result)
    *(_DWORD *)(result + 616) = a2;
  return result;
}

void sub_1001EE6C4(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  uint64_t v3;
  char *v4;
  _BOOL4 v5;
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;

  v1 = **(_QWORD **)(a1 + 8);
  if (sub_10005549C())
  {
    sub_100054530("SMP timeout for handle 0x%x.", v1);
    v2 = sub_1000544A0(0x43u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  if (!sub_10019AC00(v1) && !sub_10019AB28(v1))
  {
    if (!sub_10005549C())
      return;
    sub_100054530("Handle is not valid anymore, probably disconnected. Ignoring.");
    v8 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      return;
LABEL_17:
    sub_1006CEEC0();
    return;
  }
  v3 = sub_1001EE0AC(v1);
  if (!v3)
  {
    if (!sub_10005549C())
      return;
    sub_100054530("No pairing entry for handle 0x%x", v1);
    v7 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      return;
    goto LABEL_17;
  }
  v4 = (char *)v3;
  v5 = sub_10019AC00(v1);
  v6 = 4807;
  if (v5)
  {
    if (v4[490])
      v6 = 4807;
    else
      v6 = 4827;
  }
  sub_1001EDD30(v4, v6, 1);
}

BOOL sub_1001EE80C(char *a1, unsigned int a2, char *a3, unsigned int a4, int a5)
{
  int v8;
  _BOOL8 result;
  unsigned __int16 v10;

  v10 = 0;
  v8 = sub_10015D2EC(a1, a2, &v10);
  result = 0;
  if (!v8)
    return !sub_10015D2EC(a3, a4, &v10) && v10 == a5;
  return result;
}

uint64_t sub_1001EE884(uint64_t a1, _WORD *a2)
{
  size_t v4;
  uint64_t v5;
  char *v6;
  uint64_t result;
  _BYTE v8[6];
  __int16 v9;

  v4 = *(unsigned __int16 *)(a1 + 4);
  __chkstk_darwin();
  v6 = &v8[-v5];
  bzero(&v8[-v5], v4);
  v9 = 0;
  sub_100053900(v6, a1, v4);
  sub_1002540B4(a1);
  result = sub_10015D2EC(v6, v4, &v9);
  if (!(_DWORD)result)
    *a2 = v9;
  return result;
}

int *sub_1001EE94C(unsigned int a1)
{
  int *result;
  int *v2;

  v2 = 0;
  if (sub_1001DB044(a1, (uint64_t *)&v2))
    return 0;
  result = v2;
  if (v2)
  {
    if (*(_BYTE *)(sub_1001E3CCC(v2) + 64))
      return (int *)*(unsigned __int8 *)(sub_1001E3CCC(v2) + 66);
    return 0;
  }
  return result;
}

BOOL sub_1001EE99C(unsigned int a1)
{
  BOOL v2;
  int *v3;

  v3 = 0;
  if (!sub_1001DB044(a1, (uint64_t *)&v3) && (*v3 != 4 ? (v2 = *v3 == 2) : (v2 = 1), v2))
    return *(_BYTE *)(sub_1001E3CCC(v3) + 64) == 3;
  else
    return 0;
}

BOOL sub_1001EE9F0(unsigned int a1)
{
  BOOL v2;
  int *v3;

  v3 = 0;
  if (!sub_1001DB044(a1, (uint64_t *)&v3) && (*v3 != 4 ? (v2 = *v3 == 2) : (v2 = 1), v2))
    return *(_BYTE *)(sub_1001E3CCC(v3) + 64) == 5;
  else
    return 0;
}

uint64_t sub_1001EEA44(unsigned int a1)
{
  uint64_t result;
  NSObject *v3;
  int *v4;

  v4 = 0;
  if (sub_1001DB044(a1, (uint64_t *)&v4))
  {
    result = sub_10005549C();
    if ((_DWORD)result)
    {
      sub_100054530("Invalid channel 0x%x", a1);
      v3 = sub_1000544A0(0x2Fu);
      result = os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
      if ((_DWORD)result)
      {
        sub_1006CE7A4();
        return 0;
      }
    }
  }
  else
  {
    return *(_BYTE *)(sub_1001E3CCC(v4) + 64) != 3 || sub_1001EAD80(v4);
  }
  return result;
}

uint64_t sub_1001EEAE8(unsigned int a1)
{
  int *v2;

  v2 = 0;
  if (sub_1001DB044(a1, (uint64_t *)&v2) || *(_BYTE *)(sub_1001E3CCC(v2) + 64) != 3)
    return 0;
  else
    return sub_1001EAD54(v2);
}

uint64_t sub_1001EEB34(unsigned int a1)
{
  int *v2;

  v2 = 0;
  if (sub_1001DB044(a1, (uint64_t *)&v2))
    return 0;
  else
    return sub_1001D8094(v2);
}

uint64_t sub_1001EEB6C(unsigned int a1, uint64_t a2)
{
  int *v4;

  v4 = 0;
  if (sub_1001DB044(a1, (uint64_t *)&v4))
    return 533;
  if (*(_BYTE *)(sub_1001E3CCC(v4) + 64) == 3)
    return sub_1001EADF8(v4, a2);
  return 534;
}

uint64_t sub_1001EEBD0(unsigned int a1)
{
  int *v2;

  v2 = 0;
  if (sub_1001DB044(a1, (uint64_t *)&v2) || *(_BYTE *)(sub_1001E3CCC(v2) + 64) != 3)
    return 0;
  else
    return sub_1001EAFBC(v2);
}

uint64_t sub_1001EEC1C(unsigned int a1, char a2)
{
  uint64_t result;
  int *v4;

  v4 = 0;
  result = sub_1001DB044(a1, (uint64_t *)&v4);
  if (!(_DWORD)result)
  {
    result = sub_1001E3CCC(v4);
    if (*(_BYTE *)(result + 64) == 3)
      return sub_1001E4C04(v4, a2);
  }
  return result;
}

uint64_t sub_1001EEC70(int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;

  if (sub_1001EED08(a1))
  {
    v6 = *(unsigned __int8 *)(sub_1001E3CCC(a1) + 64);
    *(_BYTE *)(a3 + 10) = v6;
    ((void (*)(int *, uint64_t, uint64_t))off_10091EDB8[v6])(a1, a2, a3);
    if (!*(_BYTE *)(sub_1001E3CCC(a1) + 64))
      return sub_1001EEDEC(a1);
  }
  else
  {
    if ((sub_1001EEDEC(a1) & 1) != 0)
      return 2;
    *(_BYTE *)(a3 + 10) = 0;
  }
  return 1;
}

BOOL sub_1001EED08(int *a1)
{
  uint64_t v2;
  int v3;
  NSObject *v4;
  _BOOL8 result;

  v2 = *(_QWORD *)sub_1001E3CCC(a1);
  v3 = *(unsigned __int8 *)(sub_1001E3CCC(a1) + 64);
  if (*(_BYTE *)(v2 + 2))
  {
    if (sub_10005549C())
    {
      sub_100054530("Forcing channel mode for non-ACL handle.");
      v4 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return v3 == 0;
  }
  else
  {
    result = 1;
    switch(v3)
    {
      case 0:
        return result;
      case 1:
        result = *(_BYTE *)(v2 + 229) & 1;
        break;
      case 2:
        result = (*(unsigned __int8 *)(v2 + 229) >> 1) & 1;
        break;
      case 3:
        result = (*(unsigned __int8 *)(v2 + 229) >> 3) & 1;
        break;
      case 4:
        result = (*(unsigned __int8 *)(v2 + 229) >> 2) & 1;
        break;
      default:
        result = 0;
        break;
    }
  }
  return result;
}

uint64_t sub_1001EEDEC(int *a1)
{
  if (!a1)
    sub_100253460();
  return *(unsigned __int8 *)(sub_1001E3CCC(a1) + 65);
}

uint64_t sub_1001EEE1C(int a1)
{
  uint64_t result;
  NSObject *v4;

  result = 1;
  switch(a1)
  {
    case 0:
      return result;
    case 1:
    case 2:
    case 4:
      goto LABEL_2;
    case 3:
      result = *(_BYTE *)(sub_100252DE8(0x2Fu) + 12) != 0;
      break;
    default:
      result = sub_10005549C();
      if ((_DWORD)result)
      {
        sub_100054530("Unknown mode 0x%x.", a1);
        v4 = sub_1000544A0(0x2Fu);
        result = os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
        if ((_DWORD)result)
        {
          sub_1006CE7A4();
LABEL_2:
          result = 0;
        }
      }
      break;
  }
  return result;
}

uint64_t sub_1001EEEC8()
{
  return *(unsigned __int8 *)(sub_100252DE8(0x2Fu) + 13);
}

uint64_t sub_1001EEEE4(int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  NSObject *v18;
  NSObject *v19;
  const char *v20;
  NSObject *v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  uint64_t v25;
  const char *v26;
  NSObject *v27;
  NSObject *v28;
  NSObject *v29;

  v8 = *(unsigned __int8 *)(sub_1001E3CCC(a1) + 64);
  v9 = *(unsigned __int8 *)(a2 + 10);
  if (v8 == v9)
  {
    *(_BYTE *)(a4 + 10) = v8;
    goto LABEL_3;
  }
  v14 = sub_1001EEDEC(a1);
  v15 = v14;
  if (!(_DWORD)a3)
  {
    if (v14)
    {
      v17 = 2;
      if (sub_10005549C())
      {
        if (v9 > 5)
          v20 = "L2CAP_FLOW_MODE_UNKNOWN";
        else
          v20 = off_10091EE18[(char)v9];
        if (v8 > 5)
          v26 = "L2CAP_FLOW_MODE_UNKNOWN";
        else
          v26 = off_10091EE18[(char)v8];
        sub_100054530("Remote responded with %s, since our mode (%s) is mandatory, failing.", v20, v26);
        v27 = sub_1000544A0(0x2Fu);
        if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
          return 2;
        goto LABEL_60;
      }
      return v17;
    }
    if (sub_1001EEE1C(v9))
      goto LABEL_44;
    if (sub_10005549C())
    {
      sub_100054530("Remote device responded with a mode we don't support, falling back to basic.");
      v22 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    goto LABEL_46;
  }
  v16 = *(unsigned __int8 *)(sub_1001E3CCC(a1) + 76);
  if (!v15)
  {
    if (v16)
    {
      if (!sub_1001EEE1C(v9))
      {
        v17 = 2;
        if (sub_10005549C())
        {
          sub_100054530("Remote device requested an unsupported mode a second time, failling negotiation.");
          v21 = sub_1000544A0(0x2Fu);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
            goto LABEL_60;
          return 2;
        }
        return v17;
      }
LABEL_47:
      *(_BYTE *)(a4 + 10) = v9;
LABEL_3:
      v10 = sub_1001E3CCC(a1);
      v11 = *(unsigned __int8 *)(a2 + 10);
      v12 = *(unsigned __int8 *)(a4 + 10);
      if ((_DWORD)v12 != (_DWORD)v11)
      {
        if ((_DWORD)v12 == *(unsigned __int8 *)(v10 + 64))
        {
          if (sub_10005549C())
          {
            sub_100054530("Mode negotiation resulted in using our mode -> using our params.");
            v19 = sub_1000544A0(0x2Fu);
            if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
              sub_1006CE7A4();
          }
        }
        ((void (*)(int *, uint64_t, uint64_t))off_10091EDB8[v12])(a1, a3, a4);
        return 1;
      }
      if (*(_BYTE *)(a2 + 10))
      {
        if ((_DWORD)v11 != 3)
          goto LABEL_58;
        if (*(unsigned __int8 *)(a2 + 11) - 64 <= 0xFFFFFFC0)
        {
          if (sub_10005549C())
          {
            sub_100054530("Invalid parameter %s:%d=%d", "checkParams", 539, *(unsigned __int8 *)(a2 + 11));
            v13 = sub_1000544A0(0x2Fu);
            if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
LABEL_57:
              sub_1006CE7A4();
          }
LABEL_58:
          v17 = 2;
          if (sub_10005549C())
          {
            sub_100054530("Remote side parameters are invalid, bailing.");
            v29 = sub_1000544A0(0x2Fu);
            if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
LABEL_60:
              sub_1006CE7A4();
            return 2;
          }
          return v17;
        }
        if ((a3 & 1) == 0)
        {
          if ((unsigned __int16)(*(_WORD *)(a2 + 14) + 5535) <= 0x1602u)
          {
            if (sub_10005549C())
            {
              sub_100054530("Invalid parameter %s:%d=%d", "checkParams", 542, *(unsigned __int16 *)(a2 + 14));
              v23 = sub_1000544A0(0x2Fu);
              if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
                goto LABEL_57;
            }
            goto LABEL_58;
          }
          if ((unsigned __int16)(*(_WORD *)(a2 + 16) + 5535) <= 0x1602u)
          {
            if (sub_10005549C())
            {
              sub_100054530("Invalid parameter %s:%d=%d", "checkParams", 544, *(unsigned __int16 *)(a2 + 16));
              v28 = sub_1000544A0(0x2Fu);
              if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
                goto LABEL_57;
            }
            goto LABEL_58;
          }
        }
      }
      ((void (*)(int *, uint64_t, uint64_t))*(&off_10091EDE8 + v11))(a1, a2, a4);
      return 0;
    }
    if (sub_1001EED08(a1))
    {
LABEL_44:
      if (v9 > v8)
      {
LABEL_45:
        *(_BYTE *)(a4 + 10) = v8;
        v25 = sub_1001E3CCC(a1);
        ++*(_BYTE *)(v25 + 76);
        goto LABEL_3;
      }
      goto LABEL_47;
    }
LABEL_46:
    *(_BYTE *)(a4 + 10) = 0;
    goto LABEL_3;
  }
  if (!v16)
  {
    if (!sub_1001EED08(a1))
    {
      v17 = 2;
      if (sub_10005549C())
      {
        sub_100054530("Remote device doesn't support our mandatory mode, can't negotiate.");
        v24 = sub_1000544A0(0x2Fu);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          goto LABEL_60;
        return 2;
      }
      return v17;
    }
    goto LABEL_45;
  }
  v17 = 2;
  if (sub_10005549C())
  {
    sub_100054530("Failed to negotiate mode.");
    v18 = sub_1000544A0(0x2Fu);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      goto LABEL_60;
    return 2;
  }
  return v17;
}

uint64_t sub_1001EF3B0(int *a1, int a2, char a3)
{
  uint64_t result;
  NSObject *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __int16 v12;
  uint64_t v13;
  uint64_t v14;
  __int16 v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;
  __int16 v22;
  __int16 v23;
  __int16 v24;
  __int16 v25;
  __int16 v26;
  uint64_t v27;
  unsigned __int16 v28;

  v28 = 0;
  if (a1)
  {
    sub_1001A10C0(&v28);
    if (v28 - 12 <= (unsigned __int16)word_10097A8AA)
      word_10097A8AA = v28 - 12;
    result = 490;
    switch(a2)
    {
      case 0:
        *(_BYTE *)(sub_1001E3CCC(a1) + 66) = 0;
        *(_BYTE *)(sub_1001E3CCC(a1) + 67) = 0;
        *(_WORD *)(sub_1001E3CCC(a1) + 68) = 0;
        *(_WORD *)(sub_1001E3CCC(a1) + 70) = 0;
        *(_WORD *)(sub_1001E3CCC(a1) + 72) = 0;
        *(_BYTE *)(sub_1001E3CCC(a1) + 54) = 0;
        *(_BYTE *)(sub_1001E3CCC(a1) + 55) = 0;
        *(_WORD *)(sub_1001E3CCC(a1) + 56) = 0;
        *(_WORD *)(sub_1001E3CCC(a1) + 58) = 0;
        *(_WORD *)(sub_1001E3CCC(a1) + 60) = 0;
        goto LABEL_22;
      case 3:
        v8 = *(unsigned __int16 *)(sub_1001E3CCC(a1) + 48);
        v9 = sub_1001E3CCC(a1);
        if (v8)
        {
          if (!*(_BYTE *)(v9 + 42))
            sub_100253460();
          if (!*(_BYTE *)(sub_1001E3CCC(a1) + 43))
            sub_100253460();
          v10 = sub_1001E3CCC(a1);
          v11 = sub_1001E3CCC(a1);
          v12 = *(_WORD *)(v11 + 50);
          *(_QWORD *)(v10 + 66) = *(_QWORD *)(v11 + 42);
          *(_WORD *)(v10 + 74) = v12;
          v13 = sub_1001E3CCC(a1);
          v14 = sub_1001E3CCC(a1);
          v15 = *(_WORD *)(v14 + 50);
          *(_QWORD *)(v13 + 54) = *(_QWORD *)(v14 + 42);
          *(_WORD *)(v13 + 62) = v15;
        }
        else
        {
          *(_BYTE *)(v9 + 66) = 63;
          *(_BYTE *)(sub_1001E3CCC(a1) + 67) = 16;
          *(_WORD *)(sub_1001E3CCC(a1) + 68) = 2000;
          *(_WORD *)(sub_1001E3CCC(a1) + 70) = 12000;
          v23 = word_10097A8AA - 4;
          *(_WORD *)(sub_1001E3CCC(a1) + 72) = v23;
          *(_BYTE *)(sub_1001E3CCC(a1) + 54) = 63;
          *(_BYTE *)(sub_1001E3CCC(a1) + 55) = 16;
          *(_WORD *)(sub_1001E3CCC(a1) + 56) = 2000;
          *(_WORD *)(sub_1001E3CCC(a1) + 58) = 12000;
          v24 = word_10097A8AA - 4;
          *(_WORD *)(sub_1001E3CCC(a1) + 60) = v24;
        }
        sub_1001EAB04((uint64_t)a1);
        goto LABEL_22;
      case 4:
        v16 = *(unsigned __int16 *)(sub_1001E3CCC(a1) + 48);
        v17 = sub_1001E3CCC(a1) + 66;
        if (v16)
        {
          v18 = sub_1001E3CCC(a1);
          v19 = *(_WORD *)(v18 + 50);
          *(_QWORD *)v17 = *(_QWORD *)(v18 + 42);
          *(_WORD *)(v17 + 8) = v19;
          v20 = sub_1001E3CCC(a1);
          v21 = sub_1001E3CCC(a1);
          v22 = *(_WORD *)(v21 + 50);
          *(_QWORD *)(v20 + 54) = *(_QWORD *)(v21 + 42);
          *(_WORD *)(v20 + 62) = v22;
        }
        else
        {
          *(_BYTE *)v17 = 0;
          *(_BYTE *)(sub_1001E3CCC(a1) + 67) = 0;
          *(_WORD *)(sub_1001E3CCC(a1) + 68) = 0;
          *(_WORD *)(sub_1001E3CCC(a1) + 70) = 0;
          v25 = word_10097A8AA - 4;
          *(_WORD *)(sub_1001E3CCC(a1) + 72) = v25;
          *(_BYTE *)(sub_1001E3CCC(a1) + 54) = 0;
          *(_BYTE *)(sub_1001E3CCC(a1) + 55) = 0;
          *(_WORD *)(sub_1001E3CCC(a1) + 56) = 0;
          *(_WORD *)(sub_1001E3CCC(a1) + 58) = 0;
          v26 = word_10097A8AA - 4;
          *(_WORD *)(sub_1001E3CCC(a1) + 60) = v26;
        }
        goto LABEL_22;
      case 5:
        *(_BYTE *)(sub_1001E3CCC(a1) + 66) = 0;
        *(_BYTE *)(sub_1001E3CCC(a1) + 67) = 0;
        *(_WORD *)(sub_1001E3CCC(a1) + 68) = 0;
        *(_WORD *)(sub_1001E3CCC(a1) + 70) = 0;
        *(_BYTE *)(sub_1001E3CCC(a1) + 54) = 0;
        *(_BYTE *)(sub_1001E3CCC(a1) + 55) = 0;
        *(_WORD *)(sub_1001E3CCC(a1) + 56) = 0;
        *(_WORD *)(sub_1001E3CCC(a1) + 58) = 0;
LABEL_22:
        *(_BYTE *)(sub_1001E3CCC(a1) + 64) = a2;
        *(_BYTE *)(sub_1001E3CCC(a1) + 65) = a3;
        v27 = sub_1001E3CCC(a1);
        result = 0;
        *(_BYTE *)(v27 + 52) = a2;
        break;
      default:
        return result;
    }
  }
  else
  {
    sub_100253460();
    if (sub_10005549C())
    {
      sub_100054530("Invalid channel");
      v7 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 535;
  }
  return result;
}

uint64_t sub_1001EF7A4(int *a1)
{
  uint64_t result;

  if (*(_BYTE *)(sub_1001E3CCC(a1) + 52) == 3 || *(_BYTE *)(sub_1001E3CCC(a1) + 64) == 3)
    return sub_1001EABF0(a1);
  result = sub_1001E3CCC(a1);
  if (*(_BYTE *)(result + 64) == 5)
    return sub_1001D80B0(a1);
  return result;
}

uint64_t sub_1001EF818(int *a1, _WORD *a2, __int16 a3, char a4)
{
  int v8;
  BOOL v9;
  int v11;

  v8 = *(unsigned __int8 *)(sub_1001E3CCC(a1) + 64);
  if ((v8 - 3) < 2)
  {
    v11 = ((sub_1001E49C0(a1) & 1) << 7) | (2 * (a4 & 0x3F));
    *a2 = (a3 << 14) | ((sub_1001EAFE0(a1) & 0x3F) << 8) | v11;
    return 2;
  }
  else
  {
    if (v8)
      v9 = v8 == 5;
    else
      v9 = 1;
    if (!v9)
      sub_100253460();
    return 0;
  }
}

uint64_t sub_1001EF8A8(int *a1, char a2, char a3, char a4, char a5, _WORD *a6)
{
  int v11;
  BOOL v12;

  v11 = *(unsigned __int8 *)(sub_1001E3CCC(a1) + 64);
  if ((v11 - 3) < 2)
  {
    *a6 = ((16 * (a3 & 1)) | (4 * (a2 & 3)) | (a4 << 7)) | 1 | ((a5 & 0x3F) << 8);
    return 2;
  }
  else
  {
    if (v11)
      v12 = v11 == 5;
    else
      v12 = 1;
    if (!v12)
      sub_100253460();
    return 0;
  }
}

void sub_1001EF934(unsigned int a1, unsigned __int16 *a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  NSObject *v10;
  int *v11;

  v11 = 0;
  if (sub_1001DB044(a1, (uint64_t *)&v11))
  {
    if (sub_10005549C())
    {
      sub_100054530("Unable to get channel from CID=0x%x", a1);
      v10 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  else
  {
    if (!*(_BYTE *)(sub_1001E3CCC(v11) + 64))
      sub_100253460();
    if (*(_BYTE *)(sub_1001E3CCC(v11) + 64) == 3)
    {
      sub_1001E4CD8((uint64_t)v11, a2, a3, a4, a5);
    }
    else if (*(_BYTE *)(sub_1001E3CCC(v11) + 64) == 5)
    {
      sub_1001D8234((uint64_t)v11, a2, a3, a4, a5);
    }
    else
    {
      sub_100253460();
    }
  }
}

uint64_t sub_1001EFA50(unsigned int a1)
{
  int *v2;

  v2 = 0;
  if (sub_1001DB044(a1, (uint64_t *)&v2))
    return 537;
  if (*(_BYTE *)(sub_1001E3CCC(v2) + 64) == 3)
    return sub_1001E471C(v2);
  return 0;
}

void sub_1001EFAA4(int *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (*(_BYTE *)(sub_1001E3CCC(a1) + 64) == 3)
  {
    v2 = sub_1001E3CCC(a1);
    sub_1001E45FC(*(unsigned __int16 **)(v2 + 112), v3, v4, v5, v6, v7, v8, v9);
  }
}

uint64_t sub_1001EFAEC(int *a1, int a2, uint64_t a3)
{
  int v6;
  uint64_t result;
  __int16 v8;
  __int16 v9;
  __int16 v10;
  __int16 v11;

  v6 = *(unsigned __int8 *)(a3 + 10);
  result = sub_1001E3CCC(a1);
  if (v6 == *(unsigned __int8 *)(result + 64))
  {
    *(_WORD *)(a3 + 11) = 4159;
    if (a2)
      v8 = 0;
    else
      v8 = 2000;
    if (a2)
      v9 = 0;
    else
      v9 = 12000;
    *(_WORD *)(a3 + 14) = v8;
    *(_WORD *)(a3 + 16) = v9;
    v10 = word_10097A8AA - 4;
  }
  else
  {
    *(_BYTE *)(a3 + 11) = *(_BYTE *)(sub_1001E3CCC(a1) + 66);
    *(_BYTE *)(a3 + 12) = *(_BYTE *)(sub_1001E3CCC(a1) + 67);
    if (a2)
    {
      v11 = 0;
      *(_WORD *)(a3 + 14) = 0;
    }
    else
    {
      *(_WORD *)(a3 + 14) = *(_WORD *)(sub_1001E3CCC(a1) + 68);
      v11 = *(_WORD *)(sub_1001E3CCC(a1) + 70);
    }
    *(_WORD *)(a3 + 16) = v11;
    result = sub_1001E3CCC(a1);
    v10 = *(_WORD *)(result + 72);
  }
  *(_WORD *)(a3 + 18) = v10;
  return result;
}

uint64_t sub_1001EFBC0(int *a1, uint64_t a2, uint64_t a3)
{
  int v5;
  uint64_t result;
  __int16 v7;

  v5 = *(unsigned __int8 *)(a3 + 10);
  result = sub_1001E3CCC(a1);
  if (v5 == *(unsigned __int8 *)(result + 64))
  {
    v7 = word_10097A8AA - 4;
  }
  else
  {
    result = sub_1001E3CCC(a1);
    v7 = *(_WORD *)(result + 72);
  }
  *(_WORD *)(a3 + 18) = v7;
  return result;
}

uint64_t sub_1001EFC1C(uint64_t a1, uint64_t a2)
{
  char v3;

  v3 = *(_BYTE *)(a2 + 10);
  *(_BYTE *)(sub_1001E3CCC((int *)a1) + 64) = v3;
  return sub_1001F24A0(*(unsigned __int16 *)(a1 + 4));
}

uint64_t sub_1001EFC48(uint64_t a1, uint64_t a2, _WORD *a3)
{
  char v6;
  char v7;
  char v8;
  __int16 v9;
  __int16 v10;
  __int16 v11;
  __int16 v12;
  __int16 v13;
  __int16 v14;

  v6 = *(_BYTE *)(a2 + 10);
  *(_BYTE *)(sub_1001E3CCC((int *)a1) + 64) = v6;
  v7 = *(_BYTE *)(a2 + 11);
  *(_BYTE *)(sub_1001E3CCC((int *)a1) + 66) = v7;
  v8 = *(_BYTE *)(a2 + 12);
  *(_BYTE *)(sub_1001E3CCC((int *)a1) + 67) = v8;
  v9 = *(_WORD *)(a2 + 14);
  *(_WORD *)(sub_1001E3CCC((int *)a1) + 68) = v9;
  if (!*(_WORD *)(a2 + 14))
    *(_WORD *)(sub_1001E3CCC((int *)a1) + 68) = 2000;
  v10 = *(_WORD *)(a2 + 16);
  *(_WORD *)(sub_1001E3CCC((int *)a1) + 70) = v10;
  if (!*(_WORD *)(sub_1001E3CCC((int *)a1) + 70))
    *(_WORD *)(sub_1001E3CCC((int *)a1) + 70) = 12000;
  v11 = *(_WORD *)(a2 + 18);
  *(_WORD *)(sub_1001E3CCC((int *)a1) + 72) = v11;
  LOBYTE(v11) = *(_BYTE *)(a2 + 10);
  *(_BYTE *)(sub_1001E3CCC((int *)a1) + 52) = v11;
  *(_BYTE *)(sub_1001E3CCC((int *)a1) + 54) = 63;
  *(_BYTE *)(sub_1001E3CCC((int *)a1) + 55) = 16;
  *(_WORD *)(sub_1001E3CCC((int *)a1) + 56) = 2000;
  *(_WORD *)(sub_1001E3CCC((int *)a1) + 58) = 12000;
  v12 = word_10097A8AA - 4;
  *(_WORD *)(sub_1001E3CCC((int *)a1) + 60) = v12;
  if (a3)
  {
    *(_WORD *)((char *)a3 + 11) = *(_WORD *)(a2 + 11);
    v13 = *(_WORD *)(a2 + 14);
    if (!v13)
      v13 = 2000;
    a3[7] = v13;
    v14 = *(_WORD *)(a2 + 16);
    if (!v14)
      v14 = 12000;
    a3[8] = v14;
    a3[9] = *(_WORD *)(a2 + 18);
  }
  sub_1001EAB04(a1);
  return sub_1001F24A0(*(unsigned __int16 *)(a1 + 4));
}

uint64_t sub_1001EFDB8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  char v6;
  __int16 v7;
  __int16 v8;

  v6 = *(_BYTE *)(a2 + 10);
  *(_BYTE *)(sub_1001E3CCC((int *)a1) + 64) = v6;
  v7 = *(_WORD *)(a2 + 18);
  *(_WORD *)(sub_1001E3CCC((int *)a1) + 72) = v7;
  LOBYTE(v7) = *(_BYTE *)(a2 + 10);
  *(_BYTE *)(sub_1001E3CCC((int *)a1) + 52) = v7;
  v8 = word_10097A8AA - 4;
  *(_WORD *)(sub_1001E3CCC((int *)a1) + 60) = v8;
  if (a3)
    *(_WORD *)(a3 + 18) = *(_WORD *)(a2 + 18);
  return sub_1001F24A0(*(unsigned __int16 *)(a1 + 4));
}

uint64_t sub_1001EFE38(uint64_t result, uint64_t a2)
{
  _DWORD *v3;
  uint64_t v4;
  _BOOL4 v6;
  unsigned __int16 *v7;
  NSObject *v8;
  __int128 buf;

  if (qword_100984D58)
  {
    v3 = (_DWORD *)result;
    v4 = qword_100984D58;
    while (*(unsigned __int16 *)(v4 + 24) != *(unsigned __int16 *)(result + 4))
    {
      v4 = *(_QWORD *)(v4 + 80);
      if (v4 == qword_100984D58 || v4 == 0)
        return result;
    }
    if (*(_BYTE *)(v4 + 16))
    {
      sub_1001EFFDC(*(void **)(v4 + 8), a2);
      return (uint64_t)sub_1001EFFDC(*(void **)v4, a2);
    }
    else
    {
      v6 = sub_1001F005C(v4);
      sub_1001EFFDC(*(void **)v4, a2);
      result = sub_1001F005C(v4);
      if (v6 && (result & 1) == 0 && *v3 == 3)
      {
        v7 = (unsigned __int16 *)(v4 + 24);
        if (sub_10005549C())
        {
          sub_100054530("queueDrained, cid 0x%x\n", *v7);
          v8 = sub_1000544A0(0x2Fu);
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 136446210;
            *(_QWORD *)((char *)&buf + 4) = sub_100054494();
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, " %{public}s", (uint8_t *)&buf, 0xCu);
          }
        }
        *(_QWORD *)&buf = 2;
        *((_QWORD *)&buf + 1) = v7;
        return sub_10004A9EC((uint64_t)sub_1001F2B48, (const void **)&buf, 0, 0);
      }
    }
  }
  return result;
}

void *sub_1001EFFDC(void *result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  void *ptr;

  if (result)
  {
    v3 = (uint64_t)result;
    result = (void *)sub_100251684((uint64_t)result);
    for (ptr = result; result; ptr = result)
    {
      while (1)
      {
        v4 = sub_1002516A8((uint64_t)result);
        if (v4)
        {
          if (*(_QWORD *)(v4 + 8) == a2)
            break;
        }
        sub_10025168C((uint64_t)&ptr);
        result = ptr;
        if (!ptr)
          return result;
      }
      sub_1002516FC(v3, ptr, 1);
      result = (void *)sub_100251684(v3);
    }
  }
  return result;
}

BOOL sub_1001F005C(uint64_t a1)
{
  _BOOL4 v3;
  unsigned int v4;
  unsigned int v5;

  if (*(_BYTE *)(a1 + 16))
  {
    return sub_100056080(*(_QWORD *)a1) - *(_DWORD *)(a1 + 20) == *(unsigned __int8 *)(a1 + 26);
  }
  else
  {
    v3 = sub_1001EE9F0(*(unsigned __int16 *)(a1 + 24));
    v4 = sub_100056080(*(_QWORD *)a1);
    v5 = *(unsigned __int8 *)(a1 + 26);
    if (!v3)
      return v4 >= v5;
    return v4 == v5 - sub_1001F0704(*(unsigned __int16 *)(a1 + 24));
  }
}

void *sub_1001F00E4(uint64_t a1)
{
  return sub_1001EFFDC((void *)qword_100984D68, a1);
}

void *sub_1001F00F4(uint64_t a1)
{
  return sub_1001EFFDC((void *)qword_100984D70, a1);
}

void sub_1001F0104(_QWORD *ptr)
{
  int v2;
  void *v3;

  v2 = *(unsigned __int8 *)ptr;
  v3 = (void *)ptr[3];
  if (v2)
  {
    if (v3)
LABEL_3:
      sub_100253F14((uint64_t)v3);
  }
  else
  {
    if (v3)
      sub_100254090(v3);
    v3 = (void *)ptr[5];
    if (v3)
      goto LABEL_3;
  }
  sub_100053298(ptr);
}

void sub_1001F014C(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  const char *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  int v91;
  unsigned __int8 *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  int v108;
  unsigned __int8 *v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  int v132;
  unsigned __int8 *v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;

  if (a2)
  {
    if (*(unsigned __int16 *)(a2 + 24) == a1)
    {
      sub_100253320((uint64_t)"\t cid : 0x%x, address %p\n", a2, a3, a4, a5, a6, a7, a8, a1);
      if (*(_BYTE *)(a2 + 29))
        v17 = "Yes";
      else
        v17 = "No";
      sub_100253320((uint64_t)"\t\t stalled : %s\n", v10, v11, v12, v13, v14, v15, v16, (uint64_t)v17);
      if (*(_BYTE *)(a2 + 16))
        v25 = "Yes";
      else
        v25 = "No";
      sub_100253320((uint64_t)"\t\t retransmitEnabled : %s\n", v18, v19, v20, v21, v22, v23, v24, (uint64_t)v25);
      sub_100253320((uint64_t)"\t\t maxPackets : %d\n", v26, v27, v28, v29, v30, v31, v32, *(unsigned __int8 *)(a2 + 26));
      sub_100253320((uint64_t)"\t\t priority : %d\n", v33, v34, v35, v36, v37, v38, v39, *(unsigned __int8 *)(a2 + 27));
      sub_100253320((uint64_t)"\t\t transport : 0x%x\n", v40, v41, v42, v43, v44, v45, v46, *(unsigned __int8 *)(a2 + 28));
      if (*(_QWORD *)(a2 + 64))
        v54 = "Yes";
      else
        v54 = "No";
      sub_100253320((uint64_t)"\t\t readyForTx : %s\n", v47, v48, v49, v50, v51, v52, v53, (uint64_t)v54);
      sub_100253320((uint64_t)"\t\t packetSent : 0x%x\n", v55, v56, v57, v58, v59, v60, v61, *(_QWORD *)(a2 + 72));
      sub_100253320((uint64_t)"\t\t nextQueue : 0x%x\n", v62, v63, v64, v65, v66, v67, v68, *(_QWORD *)(a2 + 80));
      sub_100253320((uint64_t)"\t\t previousQueue : 0x%x\n", v69, v70, v71, v72, v73, v74, v75, *(_QWORD *)(a2 + 88));
      if (*(_BYTE *)(a2 + 16))
      {
        sub_100253320((uint64_t)"\t\t iFrames : %p\n", v76, v77, v78, v79, v80, v81, v82, *(_QWORD *)a2);
        v83 = sub_100251684(*(_QWORD *)a2);
        v148 = v83;
        if (v83)
        {
          v91 = 0;
          do
          {
            v92 = (unsigned __int8 *)sub_1002516A8(v83);
            sub_100253320((uint64_t)"\tiFrame number %d\n", v93, v94, v95, v96, v97, v98, v99, (unsigned __int16)v91);
            sub_1001F03CC(v92, v100, v101, v102, v103, v104, v105, v106);
            sub_10025168C((uint64_t)&v148);
            ++v91;
            v83 = v148;
          }
          while (v148);
        }
        sub_100253320((uint64_t)"\t\t sFrames : %p\n", v84, v85, v86, v87, v88, v89, v90, *(_QWORD *)(a2 + 8));
        v107 = sub_100251684(*(_QWORD *)(a2 + 8));
        v148 = v107;
        if (v107)
        {
          v108 = 0;
          do
          {
            v109 = (unsigned __int8 *)sub_1002516A8(v107);
            sub_100253320((uint64_t)"\tsFrame number %d\n", v110, v111, v112, v113, v114, v115, v116, (unsigned __int16)v108);
            sub_1001F03CC(v109, v117, v118, v119, v120, v121, v122, v123);
            sub_10025168C((uint64_t)&v148);
            ++v108;
            v107 = v148;
          }
          while (v148);
        }
      }
      else
      {
        sub_100253320((uint64_t)"\t\t dataQueues : %p\n", v76, v77, v78, v79, v80, v81, v82, *(_QWORD *)a2);
        v131 = sub_100251684(*(_QWORD *)a2);
        v148 = v131;
        if (v131)
        {
          v132 = 0;
          do
          {
            v133 = (unsigned __int8 *)sub_1002516A8(v131);
            sub_100253320((uint64_t)"\tFrame number %d\n", v134, v135, v136, v137, v138, v139, v140, (unsigned __int16)v132);
            sub_1001F03CC(v133, v141, v142, v143, v144, v145, v146, v147);
            sub_10025168C((uint64_t)&v148);
            ++v132;
            v131 = v148;
          }
          while (v148);
        }
      }
    }
  }
  else
  {
    sub_100253460();
    sub_100253320((uint64_t)"Queue is null, cid 0x%x", v124, v125, v126, v127, v128, v129, v130, a1);
  }
}

void sub_1001F03CC(unsigned __int8 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;

  sub_100253320((uint64_t)"\t\t\t address : %p\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)a1);
  sub_100253320((uint64_t)"\t\t\t frameType : 0x%x\n", v9, v10, v11, v12, v13, v14, v15, *a1);
  if (a1[1])
    v23 = "Yes";
  else
    v23 = "No";
  sub_100253320((uint64_t)"\t\t\t reliable : %s\n", v16, v17, v18, v19, v20, v21, v22, (uint64_t)v23);
  sub_100253320((uint64_t)"\t\t\t sendState : 0x%x\n", v24, v25, v26, v27, v28, v29, v30, *((unsigned int *)a1 + 1));
  sub_100253320((uint64_t)"\t\t\t handle : %p\n", v31, v32, v33, v34, v35, v36, v37, *((_QWORD *)a1 + 1));
  sub_100253320((uint64_t)"\t\t\t mbuf : %p\n", v38, v39, v40, v41, v42, v43, v44, *((_QWORD *)a1 + 3));
  sub_100253320((uint64_t)"\t\t\t priority : %d\n", v45, v46, v47, v48, v49, v50, v51, a1[32]);
  sub_100253320((uint64_t)"\t\t\t packetPosition : 0x%x\n", v52, v53, v54, v55, v56, v57, v58, a1[33]);
  sub_100253320((uint64_t)"\t\t\t totalSize : %d\n", v59, v60, v61, v62, v63, v64, v65, *((unsigned __int16 *)a1 + 17));
  sub_100253320((uint64_t)"\t\t\t cid : 0x%x\n", v66, v67, v68, v69, v70, v71, v72, *((unsigned __int16 *)a1 + 18));
  sub_100253320((uint64_t)"\t\t\t txSequence : %d\n", v73, v74, v75, v76, v77, v78, v79, *((unsigned __int16 *)a1 + 19));
  if (*((_QWORD *)a1 + 5))
    sub_100253320((uint64_t)"\t\t\t payloadMBuf : %p, numbytes %d\n", v80, v81, v82, v83, v84, v85, v86, *((_QWORD *)a1 + 5));
  else
    sub_100253320((uint64_t)"\t\t\t payloadMBuf : NONE\n", v80, v81, v82, v83, v84, v85, v86, v94);
  sub_100253320((uint64_t)"\t\t\t retryCount : %d\n", v87, v88, v89, v90, v91, v92, v93, a1[48]);
}

void sub_1001F051C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  BOOL v67;
  int v68;
  unsigned __int8 *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  int v84;
  unsigned __int8 *v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;

  v8 = qword_100984D58;
  v102 = 0;
  sub_100253320((uint64_t)"L2CAP Queue states :\n", a2, a3, a4, a5, a6, a7, a8, v100);
  sub_100253320((uint64_t)"\trunning = 0x%x\n", v9, v10, v11, v12, v13, v14, v15, byte_100984D78);
  sub_100253320((uint64_t)"\tnbQueues = %d\n", v16, v17, v18, v19, v20, v21, v22, byte_100984D60);
  sub_100253320((uint64_t)"\tqueues = %p\n", v23, v24, v25, v26, v27, v28, v29, qword_100984D58);
  sub_100253320((uint64_t)"\tfragmentedQueue = %p\n", v30, v31, v32, v33, v34, v35, v36, qword_100984D68);
  sub_100253320((uint64_t)"\tunstallableQueue = %p\n", v37, v38, v39, v40, v41, v42, v43, qword_100984D70);
  v51 = 0;
  if (dword_100984D7C <= 2)
    v51 = off_10091EE48[dword_100984D7C];
  sub_100253320((uint64_t)"TxQ State: %s\n", v44, v45, v46, v47, v48, v49, v50, (uint64_t)v51);
  sub_100253320((uint64_t)"L2CAP Queues :\n", v52, v53, v54, v55, v56, v57, v58, v101);
  if (v8)
  {
    do
    {
      sub_1001F014C(*(unsigned __int16 *)(v8 + 24), v8, v61, v62, v63, v64, v65, v66);
      v8 = *(_QWORD *)(v8 + 80);
      if (v8)
        v67 = v8 == qword_100984D58;
      else
        v67 = 1;
    }
    while (!v67);
  }
  if (qword_100984D68)
  {
    sub_100253320((uint64_t)"Fragmented Queue : %p\n", v60, v61, v62, v63, v64, v65, v66, qword_100984D68);
    v59 = sub_100251684(qword_100984D68);
    v102 = v59;
    if (v59)
    {
      v68 = 0;
      do
      {
        v69 = (unsigned __int8 *)sub_1002516A8(v59);
        sub_100253320((uint64_t)"\tFrame number %d\n", v70, v71, v72, v73, v74, v75, v76, (unsigned __int16)v68);
        sub_1001F03CC(v69, v77, v78, v79, v80, v81, v82, v83);
        sub_10025168C((uint64_t)&v102);
        ++v68;
        v59 = v102;
      }
      while (v102);
    }
  }
  if (qword_100984D70)
  {
    sub_100253320((uint64_t)"Unstallable Queue : %p\n", v60, v61, v62, v63, v64, v65, v66, qword_100984D70);
    v59 = sub_100251684(qword_100984D70);
    v102 = v59;
    if (v59)
    {
      v84 = 0;
      do
      {
        v85 = (unsigned __int8 *)sub_1002516A8(v59);
        sub_100253320((uint64_t)"\tPacket number %d\n", v86, v87, v88, v89, v90, v91, v92, (unsigned __int16)v84);
        sub_1001F03CC(v85, v93, v94, v95, v96, v97, v98, v99);
        sub_10025168C((uint64_t)&v102);
        ++v84;
        v59 = v102;
      }
      while (v102);
    }
  }
  sub_1001DB12C(v59, v60, v61, v62, v63, v64, v65, v66);
}

uint64_t sub_1001F0704(unsigned int a1)
{
  BOOL v2;
  int *v3;

  v3 = 0;
  if (!sub_1001DB044(a1, (uint64_t *)&v3)
    && v3
    && (*v3 != 4 ? (v2 = *v3 == 2) : (v2 = 1), v2 && sub_1001EE9F0(*((unsigned __int16 *)v3 + 2))))
  {
    return sub_1001D7F58(v3);
  }
  else
  {
    return 1;
  }
}

uint64_t sub_1001F0760(unsigned int a1)
{
  unsigned int v1;
  uint64_t v2;
  NSObject *v4;
  uint64_t result;
  uint64_t v6;
  NSObject *v7;

  if (qword_100984D58)
  {
    v1 = a1;
    v2 = qword_100984D58;
    while (*(unsigned __int16 *)(v2 + 24) != a1)
    {
      v2 = *(_QWORD *)(v2 + 80);
      if (v2 == qword_100984D58 || v2 == 0)
        goto LABEL_9;
    }
  }
  else
  {
LABEL_9:
    sub_100253460();
    __break(1u);
  }
  if (!*(_BYTE *)(v2 + 16))
  {
    if (!sub_100056080(*(_QWORD *)v2))
      sub_100253460();
    v6 = sub_100251574(*(_QWORD *)v2, 0);
    if (v6)
    {
      (*(void (**)(uint64_t, uint64_t))(v2 + 72))(v2, v6);
      sub_1001DBB90(v1);
    }
    else
    {
      result = sub_10005549C();
      if (!(_DWORD)result)
        return result;
      sub_100054530("Invalid packet");
      v7 = sub_1000544A0(0x2Fu);
      result = os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
      if (!(_DWORD)result)
        return result;
      sub_1006CE7A4();
    }
    return 0;
  }
  if (sub_10005549C())
  {
    sub_100054530("Should not be flushing Queue with E/RT enabled");
    v4 = sub_1000544A0(0x2Fu);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  return 485;
}

void sub_1001F0880()
{
  dword_100984D7C = 2;
}

void sub_1001F0890(int a1)
{
  if (!a1 && dword_100984D7C == 1 || a1 && dword_100984D7C != 2)
  {
    dword_100984D7C = 2;
    sub_1001F08C0();
  }
}

void sub_1001F08C0()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  _QWORD *v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  __int16 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  NSObject *v29;
  void *v30;
  uint64_t v31;
  int v32;
  _QWORD *ptr;
  uint64_t v34;
  uint64_t v35;
  _BYTE buf[12];
  __int16 v37;
  int v38;

  ptr = sub_100251288(0, (uint64_t)sub_1001F0104);
  v34 = 0;
  while (1)
  {
    v35 = 0;
    v0 = sub_100113398();
    v1 = qword_100984D58;
    if (qword_100984D58)
    {
      v2 = v0;
      v3 = (_QWORD *)qword_100984D58;
      do
      {
        v4 = v3[7];
        v5 = v2 - v3[6];
        if (v5 > v4 || v4 == 0xFFFFFFFF && v5 >= 0xFA1)
        {
          v6 = sub_1001F2F94((uint64_t)v3, (uint64_t)&v35, v2, &v34);
          if (v6)
            goto LABEL_18;
          v1 = qword_100984D58;
        }
        v3 = (_QWORD *)v3[10];
        if (v3 == (_QWORD *)v1)
        {
          v35 = 0;
          if (!v1)
            goto LABEL_20;
LABEL_14:
          while (1)
          {
            v6 = sub_1001F2F94(v1, (uint64_t)&v35, v2, &v34);
            if (v6)
              break;
            v1 = *(_QWORD *)(v1 + 80);
            if (v1 == qword_100984D58)
            {
              v35 = 0;
              goto LABEL_20;
            }
            if (!v1)
              goto LABEL_20;
          }
LABEL_18:
          v7 = v6;
          goto LABEL_23;
        }
      }
      while (v3);
      if (v1)
        goto LABEL_14;
    }
LABEL_20:
    if (!sub_1001F32E8((uint64_t)&v35))
      break;
    if (!v35)
    {
      v35 = 0;
      break;
    }
    v7 = qword_100984D68;
    if (!qword_100984D68)
      break;
LABEL_23:
    sub_1001A01C4(*(_QWORD *)(v35 + 8));
    v8 = v35;
    v9 = *(_DWORD *)(v35 + 4);
    if (v9 != 1)
    {
      if (v9)
      {
        sub_100253460();
        v9 = 1;
      }
      else
      {
        *(_DWORD *)(v35 + 4) = 1;
        if (*(_BYTE *)(v8 + 1) && (byte_100998F6A & 0x40) != 0)
        {
          v9 = 0;
        }
        else if (*(_WORD *)(v8 + 36) == 43)
        {
          v9 = 3;
        }
        else
        {
          v9 = 2;
        }
      }
    }
    v10 = sub_1001A021C(*(unsigned __int16 **)(v8 + 8), v9, *(_DWORD *)(v8 + 16), *(_QWORD *)(v8 + 24));
    v11 = v10;
    if ((_DWORD)v10 == 613)
    {
      if (!sub_10019C340())
        sub_100112D60(613);
    }
    else if (!(_DWORD)v10)
    {
      if (*(_WORD *)(*(_QWORD *)(v8 + 24) + 4))
        *(_DWORD *)(v8 + 4) = 1;
      else
        *(_DWORD *)(v8 + 4) = 2;
      goto LABEL_47;
    }
    if (sub_10005549C()
      && (sub_100054530("OI_HCIAPI_WriteAclData failed with %!", v11),
          v12 = sub_1000544A0(0x2Fu),
          os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)))
    {
      sub_1006D2C38();
      if (!(_DWORD)v11)
        goto LABEL_47;
    }
    else if (!(_DWORD)v11)
    {
      goto LABEL_47;
    }
    if (sub_10005549C())
    {
      sub_100054530("Send packet fail with status %!", v11);
      v13 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        sub_1006D2C38();
    }
    if ((_DWORD)v11 == 118 || (_DWORD)v11 == 613)
      goto LABEL_91;
    *(_DWORD *)(v35 + 4) = 2;
LABEL_47:
    v14 = v35;
    if (*(_DWORD *)(v35 + 4) == 2)
    {
      *(_QWORD *)buf = 0;
      v15 = sub_1001DB044(*(unsigned __int16 *)(v35 + 36), (uint64_t *)buf);
      v16 = v35;
      if (!v15 && *(_BYTE *)v35 != 1)
        *(_DWORD *)(*(_QWORD *)buf + 80) += *(unsigned __int16 *)(v35 + 34);
      if (*(_QWORD *)(v16 + 56))
      {
        v17 = sub_1001A12A8(*(_QWORD *)(v16 + 8));
        v16 = v35;
        v18 = *(_QWORD *)(v35 + 8);
        *(_WORD *)(v18 + 18) = v17;
        *(_QWORD *)(v18 + 8) = *(_QWORD *)(v16 + 56);
      }
      v19 = sub_1001F2DDC(v7);
      if (v16 != v19)
      {
        sub_1001F051C(v19, v20, v21, v22, v23, v24, v25, v26);
        sub_100253460();
      }
      if (v7 == qword_100984D68)
      {
        if (qword_100984D58)
        {
          v7 = qword_100984D58;
          while (*(unsigned __int16 *)(v7 + 24) != *(unsigned __int16 *)(v35 + 36))
          {
            v7 = *(_QWORD *)(v7 + 80);
            if (v7 == qword_100984D58 || v7 == 0)
              goto LABEL_64;
          }
        }
        else
        {
LABEL_64:
          sub_100253460();
          v7 = 0;
        }
      }
      if (v7 == qword_100984D70)
      {
        if (qword_100984D58)
        {
          v7 = qword_100984D58;
          while (*(unsigned __int16 *)(v7 + 24) != *(unsigned __int16 *)(v35 + 36))
          {
            v7 = *(_QWORD *)(v7 + 80);
            if (v7 == qword_100984D58 || v7 == 0)
              goto LABEL_74;
          }
        }
        else
        {
LABEL_74:
          sub_100253460();
          v7 = 0;
        }
      }
      if (*(_QWORD *)(v7 + 40))
        sub_100049F6C(*(unsigned int *)(v7 + 32));
      (*(void (**)(uint64_t, uint64_t))(v7 + 72))(v7, v35);
    }
    else if (qword_100984D68 != v7)
    {
      if (sub_1001F2DDC(v7) != v14)
      {
        if (sub_10005549C())
        {
          sub_100054530("Wrong packet dequeued !!!");
          v29 = sub_1000544A0(0x2Fu);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
          {
            v30 = sub_100054494();
            *(_DWORD *)buf = 136446466;
            *(_QWORD *)&buf[4] = v30;
            v37 = 1024;
            v38 = 0xFFFF;
            _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "%{public}s (status=%{bluetooth:OI_STATUS}u)", buf, 0x12u);
          }
        }
      }
      sub_10025142C(qword_100984D68, v14, 8);
    }
  }
  v31 = qword_100984D58;
  if (sub_100056080(qword_100984D68) || sub_100056080(qword_100984D70))
  {
LABEL_89:
    v32 = 1;
  }
  else
  {
    do
    {
      if (!v31)
        break;
      if (*(_BYTE *)(v31 + 16) && sub_100056080(*(_QWORD *)(v31 + 8))
        || sub_100056080(*(_QWORD *)v31))
      {
        goto LABEL_89;
      }
      v31 = *(_QWORD *)(v31 + 80);
    }
    while (v31 != qword_100984D58);
    v32 = 0;
  }
  dword_100984D7C = v32;
LABEL_91:
  sub_1002512C0(ptr);
}

uint64_t sub_1001F0DF4(uint64_t result)
{
  uint64_t v1;

  if (qword_100984D58)
  {
    v1 = qword_100984D58;
    do
    {
      if (*(unsigned __int16 *)(v1 + 24) == (_DWORD)result)
        break;
      v1 = *(_QWORD *)(v1 + 80);
    }
    while (v1 != qword_100984D58 && v1 != 0);
  }
  dword_100984D7C = 2;
  return result;
}

uint64_t sub_1001F0E30(unsigned int a1, char a2, unsigned int a3, uint64_t a4, uint64_t *a5, unsigned int a6)
{
  uint64_t v13;
  void *v15;
  uint64_t v16;
  int v17;
  unsigned int v18;
  void *v19;
  void *v20;
  _BOOL4 v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  unsigned __int16 **v26;
  int *v27;

  v27 = 0;
  if (byte_100984D60 > 0x29u)
    return 104;
  if (!qword_100984D58)
  {
LABEL_11:
    v15 = sub_100052DC0(0x68uLL);
    if (!v15)
      return 106;
    v16 = (uint64_t)v15;
    if (a3 >= 0x13)
      v17 = 19;
    else
      v17 = a3;
    if (a3)
      v18 = v17;
    else
      v18 = 1;
    if (sub_1001EE99C(a1))
    {
      *(_BYTE *)(v16 + 16) = 1;
      *(_DWORD *)(v16 + 20) = 0;
      *(_QWORD *)v16 = sub_100251288(0, (uint64_t)sub_1001F0104);
      *(_QWORD *)(v16 + 8) = sub_100251288(0, (uint64_t)sub_1001F0104);
      v19 = sub_1001F1084;
      v20 = sub_1001F11D0;
    }
    else
    {
      v21 = sub_1001EE9F0(a1);
      *(_BYTE *)(v16 + 16) = 0;
      *(_DWORD *)(v16 + 20) = 0;
      *(_QWORD *)v16 = sub_100251288(0, (uint64_t)sub_1001F0104);
      if (v21)
      {
        v19 = sub_1001F1244;
        v20 = sub_1001F1360;
      }
      else
      {
        v19 = sub_1001F13BC;
        v20 = sub_1001F14F8;
      }
    }
    *(_QWORD *)(v16 + 64) = v19;
    *(_QWORD *)(v16 + 72) = v20;
    *(_QWORD *)(v16 + 56) = a6;
    *(_WORD *)(v16 + 24) = a1;
    *(_BYTE *)(v16 + 26) = a2;
    *(_BYTE *)(v16 + 27) = v18;
    *(_WORD *)(v16 + 28) = 255;
    *(_QWORD *)(v16 + 40) = a4;
    *(_DWORD *)(v16 + 32) = 0;
    *(_QWORD *)(v16 + 48) = sub_100113398();
    v22 = qword_100984D58;
    if (qword_100984D58)
    {
      v23 = qword_100984D58;
      while (*(unsigned __int8 *)(v23 + 27) >= v18)
      {
        v23 = *(_QWORD *)(v23 + 80);
        if (qword_100984D58 == v23)
        {
          v23 = qword_100984D58;
          break;
        }
      }
      v24 = *(_QWORD *)(v23 + 88);
      *(_QWORD *)(v16 + 80) = v23;
      *(_QWORD *)(v16 + 88) = v24;
      *(_QWORD *)(*(_QWORD *)(v23 + 88) + 80) = v16;
      *(_QWORD *)(v23 + 88) = v16;
      if (*(unsigned __int8 *)(v22 + 27) >= v18)
        goto LABEL_34;
      v25 = &qword_100984D58;
    }
    else
    {
      qword_100984D58 = v16;
      *(_QWORD *)(v16 + 80) = v16;
      v25 = (uint64_t *)(v16 + 88);
    }
    *v25 = v16;
LABEL_34:
    if (a5)
      *a5 = v16;
    ++byte_100984D60;
    if (!sub_1001DB044(a1, (uint64_t *)&v27) && *v27 == 4)
    {
      v26 = (unsigned __int16 **)sub_1001E3CCC(v27);
      sub_100176394(*v26);
    }
    return 0;
  }
  v13 = qword_100984D58;
  while (*(unsigned __int16 *)(v13 + 24) != a1)
  {
    v13 = *(_QWORD *)(v13 + 80);
    if (v13 == qword_100984D58 || v13 == 0)
      goto LABEL_11;
  }
  return 119;
}

uint64_t sub_1001F1084(uint64_t a1, uint64_t *a2)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v11;
  uint64_t result;
  uint64_t v13;

  if (!a1)
    sub_100253460();
  *a2 = 0;
  if (*(_BYTE *)(a1 + 29))
    return 0;
  v4 = (uint64_t *)(a1 + 8);
  if (!sub_100056080(*(_QWORD *)(a1 + 8)))
  {
    v4 = (uint64_t *)a1;
    if (!sub_100056080(*(_QWORD *)a1))
    {
      if (*(_QWORD *)(a1 + 56) == 0xFFFFFFFFLL)
      {
        v13 = sub_100113398();
        result = 0;
        *(_QWORD *)(a1 + 48) = v13;
        return result;
      }
      return 0;
    }
  }
  v5 = sub_10025155C(*v4);
  *(_QWORD *)(a1 + 96) = *v4;
  v6 = *(_QWORD *)(v5 + 8);
  v7 = *(unsigned __int8 *)(v6 + 2);
  if (!*(_BYTE *)(v6 + 2) && byte_1009990D1 == 0)
    return 0;
  if (v7 == 4 && byte_1009990D2 == 0)
    return 0;
  if (v7 == 8 && byte_1009990D0 == 0)
    return 0;
  v11 = v5;
  if (!sub_10019AB28(*(_QWORD *)(v5 + 8))
    && !sub_10019ABD0(v6)
    && !sub_10019AC00(v6)
    && !sub_10019AC30(v6)
    || (*(_BYTE *)(*(_QWORD *)(v11 + 8) + 2) || (result = sub_10019AC68(v6), (_DWORD)result))
    && (result = sub_1001F3418(v6, *(unsigned __int8 *)(a1 + 27)), (_DWORD)result))
  {
    *a2 = v11;
    return 1;
  }
  return result;
}

void sub_1001F11D0(uint64_t a1, _BYTE *a2)
{
  void *v3;

  v3 = (void *)*((_QWORD *)a2 + 3);
  if (*a2)
  {
    sub_100253F14((uint64_t)v3);
    *((_QWORD *)a2 + 3) = 0;
    sub_100053298(a2);
  }
  else
  {
    if (v3)
    {
      sub_100254090(v3);
      *((_QWORD *)a2 + 3) = 0;
    }
    sub_1002540B4(*((_QWORD *)a2 + 5));
    if (sub_1001EEB6C(*((unsigned __int16 *)a2 + 18), (uint64_t)a2))
      sub_1001F0104(a2);
  }
}

uint64_t sub_1001F1244(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  uint64_t v9;
  int *v10;

  if (!a1)
    sub_100253460();
  *a2 = 0;
  v4 = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 96) = *(_QWORD *)a1;
  if (!sub_100056080(v4))
  {
    if (*(_QWORD *)(a1 + 56) == 0xFFFFFFFFLL)
    {
      v9 = sub_100113398();
      result = 0;
      *(_QWORD *)(a1 + 48) = v9;
      return result;
    }
    return 0;
  }
  v5 = sub_10025155C(*(_QWORD *)a1);
  if (!sub_10019AB28(*(_QWORD *)(v5 + 8))
    && !sub_10019ABD0(*(_QWORD *)(v5 + 8))
    && !sub_10019AC00(*(_QWORD *)(v5 + 8))
    && !sub_10019AC30(*(_QWORD *)(v5 + 8)))
  {
    goto LABEL_17;
  }
  v10 = 0;
  v6 = *(_QWORD *)(v5 + 8);
  if (*(_BYTE *)(v6 + 2) == 4 && byte_1009990D2 == 0)
    return 0;
  result = sub_10019AC9C(v6);
  if (!(_DWORD)result)
    return result;
  if (sub_1001DB044(*(unsigned __int16 *)(a1 + 24), (uint64_t *)&v10) && v10)
    return 0;
  result = sub_1001D80FC(v10);
  if ((_DWORD)result)
  {
    result = sub_1001F3418(*(_QWORD *)(v5 + 8), *(unsigned __int8 *)(v5 + 32));
    if ((_DWORD)result)
    {
LABEL_17:
      *a2 = v5;
      return 1;
    }
  }
  return result;
}

void sub_1001F1360(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  int *v4;

  v4 = 0;
  if (!sub_1001DB044(*(unsigned __int16 *)(a2 + 36), (uint64_t *)&v4))
    sub_1001D81F4(v4, 1u);
  v3 = *(_QWORD *)(a2 + 24);
  if (v3)
  {
    sub_100253F14(v3);
    *(_QWORD *)(a2 + 24) = 0;
  }
  sub_100053298((void *)a2);
}

BOOL sub_1001F13BC(uint64_t a1, uint64_t *a2)
{
  _BOOL8 result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;

  if (!a1)
    sub_100253460();
  *a2 = 0;
  if (*(_BYTE *)(a1 + 29))
    return 0;
  v5 = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 96) = *(_QWORD *)a1;
  v6 = sub_10025155C(v5);
  if (!v6)
  {
    if (*(_QWORD *)(a1 + 56) == 0xFFFFFFFFLL)
    {
      v10 = sub_100113398();
      result = 0;
      *(_QWORD *)(a1 + 48) = v10;
      return result;
    }
    return 0;
  }
  v7 = v6;
  v8 = *(_QWORD *)(v6 + 8);
  if (!sub_10019AB28(v8) && !sub_10019ABD0(v8) && !sub_10019AC00(v8) && !sub_10019AC30(v8))
  {
LABEL_26:
    *a2 = v7;
    return 1;
  }
  v9 = *(unsigned __int8 *)(v8 + 2);
  if (v9 == 8)
    goto LABEL_24;
  if (v9 != 4)
  {
    if (!*(_BYTE *)(v8 + 2))
    {
      if (byte_1009990D1 && (sub_10019AC68(v8) & 1) != 0)
        goto LABEL_25;
      return 0;
    }
    sub_100253460();
LABEL_24:
    if (byte_1009990D0)
      goto LABEL_25;
    return 0;
  }
  if (!*(_BYTE *)(v8 + 129) && (!byte_1009990D2 || !sub_10019AC9C(v8)))
    return 0;
LABEL_25:
  result = sub_1001F3418(v8, *(unsigned __int8 *)(v7 + 32));
  if (result)
    goto LABEL_26;
  return result;
}

void sub_1001F14F8(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;

  if (!a2)
    sub_100253460();
  v3 = a2[3];
  if (v3 || (sub_100253460(), (v3 = a2[3]) != 0))
  {
    sub_100253F14(v3);
    a2[3] = 0;
  }
  sub_100053298(a2);
}

void *sub_1001F153C(void *result)
{
  int v1;
  _QWORD **v2;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;

  if (byte_100984D78 == 1)
  {
    v1 = (int)result;
    if (!qword_100984D58)
    {
LABEL_22:
      sub_1001F1640(qword_100984D68, v1);
      return sub_1001F1640(qword_100984D70, v1);
    }
    v2 = (_QWORD **)qword_100984D58;
    while (*((unsigned __int16 *)v2 + 12) != (_DWORD)result)
    {
      v2 = (_QWORD **)v2[10];
      if (v2 == (_QWORD **)qword_100984D58 || v2 == 0)
        goto LABEL_22;
    }
    if (v2[5])
      sub_100049F6C(*((unsigned int *)v2 + 8));
    v4 = v2[10];
    if (v4 == v2)
    {
      v6 = 0;
    }
    else
    {
      v5 = v2[11];
      v5[10] = v4;
      v6 = (uint64_t)v2[10];
      *(_QWORD *)(v6 + 88) = v5;
      if ((_QWORD **)qword_100984D58 != v2)
      {
LABEL_19:
        --byte_100984D60;
        if (*((_BYTE *)v2 + 16))
          sub_1002512C0(v2[1]);
        sub_1002512C0(*v2);
        sub_100053298(v2);
        goto LABEL_22;
      }
    }
    qword_100984D58 = v6;
    goto LABEL_19;
  }
  return result;
}

void *sub_1001F1640(uint64_t a1, int a2)
{
  void *result;
  uint64_t v5;
  void *ptr;

  result = (void *)sub_100251684(a1);
  for (ptr = result; ptr; result = ptr)
  {
    while (1)
    {
      v5 = sub_1002516A8((uint64_t)result);
      if (!v5 || *(unsigned __int16 *)(v5 + 36) != a2)
        break;
      sub_1002516FC(a1, ptr, 1);
      result = (void *)sub_100251684(a1);
      ptr = result;
      if (!result)
        return result;
    }
    sub_10025168C((uint64_t)&ptr);
  }
  return result;
}

uint64_t sub_1001F16BC(int a1)
{
  uint64_t v1;

  if (!qword_100984D58)
    return 0;
  v1 = qword_100984D58;
  while (*(unsigned __int16 *)(v1 + 24) != a1)
  {
    v1 = *(_QWORD *)(v1 + 80);
    if (v1 == qword_100984D58 || v1 == 0)
      return 0;
  }
  return sub_100056080(*(_QWORD *)v1);
}

void sub_1001F16F8(unsigned int a1)
{
  uint64_t v2;
  int v4;
  int v5;
  _BOOL4 v6;
  unsigned int v7;
  unsigned int v8;
  const void *v9[2];

  if (!qword_100984D58)
    return;
  v2 = qword_100984D58;
  while (*(unsigned __int16 *)(v2 + 24) != a1)
  {
    v2 = *(_QWORD *)(v2 + 80);
    if (v2 == qword_100984D58 || v2 == 0)
      return;
  }
  if (!*(_BYTE *)(v2 + 16))
  {
    v6 = sub_1001EE9F0(a1);
    v7 = sub_100056080(*(_QWORD *)v2);
    v8 = *(unsigned __int8 *)(v2 + 26);
    if (v6)
    {
      if (v7 != v8 - sub_1001F0704(a1))
        goto LABEL_14;
    }
    else if (v7 < v8)
    {
      goto LABEL_14;
    }
LABEL_13:
    v9[0] = (const void *)2;
    v9[1] = (const void *)(v2 + 24);
    sub_10004A9EC((uint64_t)sub_1001F2B48, v9, 0, 0);
    goto LABEL_14;
  }
  if (sub_100056080(*(_QWORD *)v2))
  {
    v4 = sub_100056080(*(_QWORD *)v2);
    if (v4 + sub_1001EEBD0(*(unsigned __int16 *)(v2 + 24)) >= *(unsigned __int8 *)(v2 + 26))
      goto LABEL_13;
  }
LABEL_14:
  v5 = *(unsigned __int8 *)(v2 + 16);
  sub_100251314(*(_QWORD *)v2);
  if (v5)
    sub_100251314(*(_QWORD *)(v2 + 8));
}

int *sub_1001F1814(int *result, unsigned __int16 *a2, unint64_t a3, char a4)
{
  int *v7;
  uint64_t v8;
  unsigned int v9;
  BOOL v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  int *v14;

  v7 = result;
  v8 = qword_100984D58;
  do
  {
    if (!v8)
      break;
    v9 = *(unsigned __int16 *)(v8 + 24);
    if (a3)
    {
      if (v9 == *a2)
      {
        v10 = 1;
      }
      else
      {
        v11 = 1;
        do
        {
          v12 = v11;
          if (a3 == v11)
            break;
          v13 = a2[v11++];
        }
        while (v9 != v13);
        v10 = v12 < a3;
      }
    }
    else
    {
      v10 = 0;
    }
    v14 = 0;
    result = (int *)sub_1001DB044(v9, (uint64_t *)&v14);
    if (!v10 && !(_DWORD)result)
    {
      result = v14;
      if (*v14 == 2)
      {
        result = (int *)sub_1001E3CCC(v14);
        if (*(int **)result == v7)
          *(_BYTE *)(v8 + 29) = a4;
      }
    }
    v8 = *(_QWORD *)(v8 + 80);
  }
  while (v8 != qword_100984D58);
  if ((a4 & 1) == 0)
    dword_100984D7C = 2;
  return result;
}

uint64_t sub_1001F190C(uint64_t result, unsigned __int16 *a2, uint64_t a3, char a4)
{
  uint64_t v7;
  uint64_t v8;
  char v9;
  uint64_t v10;
  unsigned __int16 *v11;
  int v12;
  int *v13;

  v7 = result;
  v13 = 0;
  v8 = qword_100984D58;
  do
  {
    if (!v8)
      break;
    result = *(unsigned __int16 *)(v8 + 24);
    v9 = 0;
    if (a3)
    {
      v10 = a3;
      v11 = a2;
      do
      {
        v12 = *v11++;
        v9 |= (_DWORD)result == v12;
        --v10;
      }
      while (v10);
    }
    if (result >= 0x40 && (v9 & 1) == 0)
    {
      result = sub_1001DB044(result, (uint64_t *)&v13);
      if (!(_DWORD)result)
      {
        result = (uint64_t)v13;
        if (*v13 == 4)
        {
          result = sub_1001E3CCC(v13);
          if (*(_QWORD *)result == v7)
            *(_BYTE *)(v8 + 29) = a4;
        }
      }
    }
    v8 = *(_QWORD *)(v8 + 80);
  }
  while (v8 != qword_100984D58);
  if ((a4 & 1) == 0)
    dword_100984D7C = 2;
  return result;
}

uint64_t sub_1001F19E4(const void *a1, const void *a2, unsigned __int16 *a3, unint64_t a4)
{
  uint64_t v8;
  mach_header_64 *v9;
  unsigned int v10;
  _BOOL4 v11;
  uint64_t v12;
  unint64_t v13;
  int v14;
  BOOL v15;
  mach_header_64 *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  const void **v24;
  NSObject *v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  unsigned __int16 *v30;
  unint64_t v31;
  uint64_t result;
  uint64_t v33;
  unsigned int v34;
  unsigned __int16 *v35;
  unint64_t v36;
  int *v37;
  uint64_t i;
  uint8_t buf[4];
  void *v40;

  v37 = 0;
  i = 0;
  v8 = qword_100984D58;
  v9 = (mach_header_64 *)&_mh_execute_header;
  do
  {
    if (!v8)
      break;
    v10 = *(unsigned __int16 *)(v8 + 24);
    if (v10 >= 0x40)
    {
      if (a4)
      {
        if (v10 == *a3)
        {
          v11 = 1;
        }
        else
        {
          v12 = 1;
          do
          {
            v13 = v12;
            if (a4 == v12)
              break;
            v14 = a3[v12++];
          }
          while (v10 != v14);
          v11 = v13 < a4;
        }
      }
      else
      {
        v11 = 0;
      }
      if (!sub_1001DB044(v10, (uint64_t *)&v37))
      {
        v15 = *v37 != 4 || v11;
        if (!v15 && *(const void **)sub_1001E3CCC(v37) == a1)
        {
          *(_QWORD *)sub_1001E3CCC(v37) = a2;
          v16 = v9;
          if (*(_BYTE *)(v8 + 16))
            v17 = *(_QWORD *)(v8 + 8);
          else
            v17 = 0;
          v18 = *(_QWORD *)v8;
          if (*(_QWORD *)v8)
          {
            if (sub_100056080(*(_QWORD *)v8))
            {
              v19 = sub_100251684(v18);
              for (i = v19; i; v19 = i)
              {
                v20 = sub_1002516A8(v19);
                if (*(const void **)(v20 + 8) == a1)
                  *(_QWORD *)(v20 + 8) = a2;
                sub_10025168C((uint64_t)&i);
              }
            }
          }
          v9 = v16;
          if (v17)
          {
            if (sub_100056080(v17))
            {
              v21 = sub_100251684(v17);
              for (i = v21; i; v21 = i)
              {
                v22 = sub_1002516A8(v21);
                if (*(const void **)(v22 + 8) == a1)
                  *(_QWORD *)(v22 + 8) = a2;
                sub_10025168C((uint64_t)&i);
              }
            }
          }
          sub_1001EAFFC(v37, (uint64_t)a1, (uint64_t)a2);
        }
      }
      if (sub_10005549C())
      {
        v23 = *(unsigned __int16 *)(v8 + 24);
        v24 = (const void **)sub_1001E3CCC(v37);
        sub_100054530("CID:0x%04x cidExcluded:%d currentHandle:%p oldHandle:%p newHandle:%p", v23, v11, *v24, a1, a2);
        v25 = sub_1000544A0(0x2Fu);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          v26 = sub_100054494();
          *(_DWORD *)buf = 136446210;
          v40 = v26;
          _os_log_impl(v9, v25, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
        }
      }
    }
    v8 = *(_QWORD *)(v8 + 80);
  }
  while (v8 != qword_100984D58);
  v27 = sub_100251684(qword_100984D68);
  for (i = v27; i; v27 = i)
  {
    v28 = sub_1002516A8(v27);
    if (a4)
    {
      v29 = *(unsigned __int16 *)(v28 + 36);
      v30 = a3;
      v31 = a4;
      do
      {
        if (v29 >= 0x40 && v29 != *v30 && *(const void **)(v28 + 8) == a1)
          *(_QWORD *)(v28 + 8) = a2;
        ++v30;
        --v31;
      }
      while (v31);
    }
    sub_10025168C((uint64_t)&i);
  }
  result = sub_100251684(qword_100984D70);
  for (i = result; i; result = i)
  {
    v33 = sub_1002516A8(result);
    if (a4)
    {
      v34 = *(unsigned __int16 *)(v33 + 36);
      v35 = a3;
      v36 = a4;
      do
      {
        if (v34 >= 0x40 && v34 != *v35 && *(const void **)(v33 + 8) == a1)
          *(_QWORD *)(v33 + 8) = a2;
        ++v35;
        --v36;
      }
      while (v36);
    }
    sub_10025168C((uint64_t)&i);
  }
  return result;
}

uint64_t sub_1001F1D40(uint64_t a1)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v5;
  unsigned __int16 *v7;
  int v8;
  int v9;
  int v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  _BYTE *v14;
  void *v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  _BYTE *v22;
  _BYTE *v23;
  unsigned int v24;
  _BOOL4 v25;
  uint64_t *v26;
  unsigned int *v27;
  unsigned int v28;
  const void *v29[2];
  __int16 v30;

  if (!qword_100984D58)
    return 404;
  v2 = *(unsigned __int16 *)(a1 + 20);
  v3 = qword_100984D58;
  while (*(unsigned __int16 *)(v3 + 24) != v2)
  {
    v3 = *(_QWORD *)(v3 + 80);
    if (v3 == qword_100984D58 || v3 == 0)
      return 404;
  }
  v7 = (unsigned __int16 *)(v3 + 24);
  v8 = sub_1001EE99C(v2);
  v9 = *(unsigned __int8 *)(v3 + 16);
  if (v9 != v8)
  {
    sub_100253460();
    v9 = *(unsigned __int8 *)(v3 + 16);
  }
  if (v9)
  {
    v10 = sub_100056080(*(_QWORD *)v3);
    v11 = v10 - *(_DWORD *)(v3 + 20);
    v12 = *(unsigned __int8 *)(v3 + 26);
    if (v11 >= v12)
      return 410;
    v13 = v10;
    if (v11 == v12 - 1)
      v5 = 0;
    else
      v5 = 412;
    v14 = sub_100052DC0(0x40uLL);
    if (!v14)
      return 106;
    v15 = v14;
    *v14 = 0;
    v14[1] = *(_BYTE *)a1;
    *((_DWORD *)v14 + 1) = 0;
    *((_QWORD *)v14 + 1) = *(_QWORD *)(a1 + 8);
    *((_DWORD *)v14 + 4) = *(_DWORD *)(a1 + 16);
    if (sub_100253D90((_QWORD *)v14 + 5, a1 + 40, 0))
    {
      sub_100053298(v15);
      return 106;
    }
    *((_BYTE *)v15 + 32) = *(_BYTE *)(v3 + 27);
    *((_BYTE *)v15 + 33) = *(_BYTE *)(a1 + 24);
    *((_WORD *)v15 + 17) = *(_WORD *)(a1 + 26);
    v19 = *(unsigned __int16 *)(v3 + 24);
    *((_WORD *)v15 + 18) = v19;
    *((_WORD *)v15 + 19) = sub_1001EEAE8(v19);
    *((_QWORD *)v15 + 3) = 0;
    *((_BYTE *)v15 + 48) = 0;
    *((_QWORD *)v15 + 7) = *(_QWORD *)(a1 + 32);
    if (!v13 && *(_QWORD *)(v3 + 56) == 0xFFFFFFFFLL)
      *(_QWORD *)(v3 + 48) = sub_100113398();
    v20 = *(_QWORD *)v3;
    v21 = (uint64_t)v15;
    goto LABEL_53;
  }
  v29[0] = 0;
  v30 = 0;
  v16 = sub_100056080(*(_QWORD *)v3);
  if (v16 >= *(unsigned __int8 *)(v3 + 26))
  {
    v5 = 410;
    goto LABEL_54;
  }
  v17 = v16;
  if (sub_1001EE9F0(*v7)
    && (v18 = *(unsigned __int8 *)(v3 + 26), v17 >= ~sub_1001F0704(*(unsigned __int16 *)(v3 + 24)) + v18))
  {
    v5 = 0;
  }
  else if (v17 == *(unsigned __int8 *)(v3 + 26) - 1)
  {
    v5 = 0;
  }
  else
  {
    v5 = 412;
  }
  v22 = sub_100052DC0(0x40uLL);
  if (!v22)
  {
LABEL_43:
    v5 = 106;
    goto LABEL_54;
  }
  v23 = v22;
  *v22 = -1;
  v24 = *v7;
  *((_WORD *)v23 + 18) = v24;
  v23[1] = *(_BYTE *)a1;
  *((_DWORD *)v23 + 1) = 0;
  *((_QWORD *)v23 + 1) = *(_QWORD *)(a1 + 8);
  *((_DWORD *)v23 + 4) = *(_DWORD *)(a1 + 16);
  *((_QWORD *)v23 + 7) = *(_QWORD *)(a1 + 32);
  v25 = 0;
  if (!sub_1001DB044(v24, (uint64_t *)v29))
    v25 = (*(_DWORD *)v29[0] == 4 || *(_DWORD *)v29[0] == 2) && *(_BYTE *)(sub_1001E3CCC((int *)v29[0]) + 78) != 0;
  v26 = (uint64_t *)(v23 + 24);
  if (sub_100253D90((_QWORD *)v23 + 3, a1 + 40, v25))
  {
    sub_100053298(v23);
    goto LABEL_43;
  }
  if (v25)
  {
    sub_1001EE884(*v26, &v30);
    sub_10005336C((unsigned __int8 *)*v26, (char *)&v30, 2uLL, 0);
  }
  *((_WORD *)v23 + 17) = *(_WORD *)(*((_QWORD *)v23 + 3) + 4);
  *((_QWORD *)v23 + 5) = 0;
  v23[32] = *(_BYTE *)(v3 + 27);
  if (!v17 && *(_QWORD *)(v3 + 56) == 0xFFFFFFFFLL)
    *(_QWORD *)(v3 + 48) = sub_100113398();
  if (*(_BYTE *)(a1 + 1))
    v20 = qword_100984D70;
  else
    v20 = *(_QWORD *)v3;
  v21 = (uint64_t)v23;
LABEL_53:
  sub_10025142C(v20, v21, 8);
LABEL_54:
  if ((_DWORD)v5 == 412 || !(_DWORD)v5)
  {
    dword_100984D7C = 2;
    if (*(_QWORD *)(v3 + 40))
    {
      v28 = *(_DWORD *)(v3 + 32);
      v27 = (unsigned int *)(v3 + 32);
      if (sub_10004A088(v28))
      {
        sub_1002537E8(*v27, 300);
      }
      else
      {
        v29[1] = v7;
        v29[0] = (const void *)2;
        sub_10004A9EC((uint64_t)sub_1001F20B8, v29, 300, (int *)v27);
      }
    }
  }
  return v5;
}

void sub_1001F20B8(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  void (*v7)(uint64_t);

  if (a1)
  {
    v1 = **(unsigned __int16 **)(a1 + 8);
    if (qword_100984D58)
    {
      v2 = qword_100984D58;
      while (*(unsigned __int16 *)(v2 + 24) != (_DWORD)v1)
      {
        v2 = *(_QWORD *)(v2 + 80);
        if (v2 == qword_100984D58 || v2 == 0)
          goto LABEL_10;
      }
    }
    else
    {
LABEL_10:
      sub_100253460();
      v2 = 0;
    }
    if (!*(_QWORD *)(v2 + 40))
      sub_100253460();
    v4 = *(_QWORD *)(v2 + 48);
    v5 = sub_100113398();
    if (sub_10005549C())
    {
      sub_100054530("Stall Monitor detected TX stall on CID 0x%04x Priority= %u maxLatency=%llu lastServiceTime=%llu, deltaTime=%llu ms,  CB 0x%x", v1, *(unsigned __int8 *)(v2 + 27), *(_QWORD *)(v2 + 56), *(_QWORD *)(v2 + 48), v4 - v5, *(_QWORD *)(v2 + 40));
      v6 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    v7 = *(void (**)(uint64_t))(v2 + 40);
    if (v7)
      v7(v1);
  }
  else
  {
    sub_100253460();
  }
}

uint64_t sub_1001F21A8(uint64_t a1)
{
  uint64_t v2;
  int v4;
  _BYTE *v5;
  uint64_t v6;
  uint64_t result;
  NSObject *v8;

  if (!qword_100984D58)
    goto LABEL_15;
  v2 = qword_100984D58;
  while (*(unsigned __int16 *)(v2 + 24) != *(unsigned __int16 *)(a1 + 20))
  {
    v2 = *(_QWORD *)(v2 + 80);
    if (v2 == qword_100984D58 || v2 == 0)
      goto LABEL_15;
  }
  if (*(_BYTE *)(v2 + 16))
  {
    sub_100056080(*(_QWORD *)(v2 + 8));
    v4 = sub_100056080(*(_QWORD *)(v2 + 8));
    v5 = sub_100052DC0(0x40uLL);
    if (!v5)
      return 106;
    v6 = (uint64_t)v5;
    *v5 = 1;
    v5[1] = *(_BYTE *)a1;
    *((_DWORD *)v5 + 1) = 0;
    *((_QWORD *)v5 + 1) = *(_QWORD *)(a1 + 8);
    *((_DWORD *)v5 + 4) = *(_DWORD *)(a1 + 16);
    if (sub_100253D90((_QWORD *)v5 + 3, a1 + 40, 0))
    {
      sub_100053298((void *)v6);
      return 106;
    }
    *(_BYTE *)(v6 + 32) = *(_BYTE *)(v2 + 27);
    *(_BYTE *)(v6 + 33) = *(_BYTE *)(a1 + 24);
    *(_WORD *)(v6 + 34) = *(_WORD *)(a1 + 26);
    *(_WORD *)(v6 + 36) = *(_WORD *)(v2 + 24);
    *(_BYTE *)(v6 + 48) = 0;
    *(_QWORD *)(v6 + 56) = 0;
    *(_QWORD *)(v6 + 40) = 0;
    if (*(_QWORD *)(v2 + 56) == 0xFFFFFFFFLL && !v4)
      *(_QWORD *)(v2 + 48) = sub_100113398();
    sub_10025142C(*(_QWORD *)(v2 + 8), v6, 8);
    result = 0;
    dword_100984D7C = 2;
  }
  else
  {
LABEL_15:
    if (sub_10005549C())
    {
      sub_100054530("Can't retransmit a basic flow control channel.");
      v8 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    sub_100253460();
    return 509;
  }
  return result;
}

uint64_t sub_1001F2328(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;
  NSObject *v4;

  if (!qword_100984D58)
    goto LABEL_12;
  v1 = qword_100984D58;
  while (*(unsigned __int16 *)(v1 + 24) != *(unsigned __int16 *)(a1 + 36))
  {
    v1 = *(_QWORD *)(v1 + 80);
    if (v1 == qword_100984D58 || v1 == 0)
      goto LABEL_12;
  }
  if (*(_BYTE *)(v1 + 16))
  {
    *(_DWORD *)(a1 + 4) = 0;
    sub_100251374(*(_QWORD *)v1, a1, 8);
    result = 0;
    ++*(_DWORD *)(v1 + 20);
    dword_100984D7C = 2;
  }
  else
  {
LABEL_12:
    if (sub_10005549C())
    {
      sub_100054530("Can't retransmit a basic flow control channel.");
      v4 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    sub_100253460();
    return 510;
  }
  return result;
}

uint64_t sub_1001F23F8(int a1)
{
  uint64_t v1;
  uint64_t result;
  NSObject *v4;

  if (qword_100984D58)
  {
    v1 = qword_100984D58;
    while (*(unsigned __int16 *)(v1 + 24) != a1)
    {
      v1 = *(_QWORD *)(v1 + 80);
      if (v1 == qword_100984D58 || v1 == 0)
        goto LABEL_12;
    }
    if (*(_BYTE *)(v1 + 16))
      return sub_100056080(*(_QWORD *)v1) != 0;
  }
LABEL_12:
  result = sub_10005549C();
  if ((_DWORD)result)
  {
    sub_100054530("Why is this called with a channel where retransmission isn't enabled ?");
    v4 = sub_1000544A0(0x2Fu);
    result = os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
    {
      sub_1006CE7A4();
      return 0;
    }
  }
  return result;
}

uint64_t sub_1001F24A0(unsigned int a1)
{
  _QWORD **v2;
  uint64_t result;
  int v5;
  unsigned int v6;
  int v7;
  int v8;
  NSObject *v9;
  _QWORD *v10;
  NSObject *v11;
  unsigned __int8 v12;

  if (!qword_100984D58)
    return 404;
  v2 = (_QWORD **)qword_100984D58;
  while (*((unsigned __int16 *)v2 + 12) != a1)
  {
    v2 = (_QWORD **)v2[10];
    if (v2 == (_QWORD **)qword_100984D58 || v2 == 0)
      return 404;
  }
  v5 = *((unsigned __int8 *)v2 + 16);
  if (v5 == sub_1001EE99C(a1))
  {
    v6 = *((unsigned __int8 *)v2 + 26);
    if (sub_1001EE94C(a1) < v6)
      return 0;
    goto LABEL_27;
  }
  v7 = *((unsigned __int8 *)v2 + 16);
  v8 = sub_100056080((uint64_t)*v2);
  if (!v7)
  {
    if (v8)
    {
      if (sub_10005549C())
      {
        sub_100054530("Warning there is packets queued in the basic queue. This will drop packets");
        v11 = sub_1000544A0(0x2Fu);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      sub_1001F16F8(a1);
    }
    sub_1002512C0(*v2);
    *((_BYTE *)v2 + 16) = 1;
    *((_DWORD *)v2 + 5) = 0;
    *v2 = sub_100251288(0, (uint64_t)sub_1001F0104);
    v2[1] = sub_100251288(0, (uint64_t)sub_1001F0104);
    v2[8] = sub_1001F1084;
    v2[9] = sub_1001F11D0;
LABEL_27:
    v12 = sub_1001EE94C(a1);
    result = 0;
    *((_BYTE *)v2 + 26) = v12 + 1;
    return result;
  }
  if (v8 || sub_100056080((uint64_t)v2[1]))
  {
    if (sub_10005549C())
    {
      sub_100054530("Warning there is packets queued in the sFrame or iFrame queues. This will drop packets");
      v9 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    sub_1001F16F8(a1);
  }
  *((_BYTE *)v2 + 16) = 0;
  *((_DWORD *)v2 + 5) = 0;
  sub_1002512C0(*v2);
  sub_1002512C0(v2[1]);
  v10 = sub_100251288(0, (uint64_t)sub_1001F0104);
  result = 0;
  *v2 = v10;
  v2[8] = sub_1001F13BC;
  v2[9] = sub_1001F14F8;
  return result;
}

uint64_t sub_1001F2690(int a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v1 = qword_100984D58;
  if (!qword_100984D58)
    return 404;
  v2 = qword_100984D58;
  while (*(unsigned __int16 *)(v2 + 24) != a1)
  {
    v2 = *(_QWORD *)(v2 + 80);
    if (v2 == qword_100984D58 || v2 == 0)
      return 404;
  }
  *(_BYTE *)(v2 + 27) = 10;
  if (v1 == v2)
    return 0;
  v5 = *(_QWORD *)(v2 + 80);
  if (v2 == v5)
    return 0;
  result = 0;
  v6 = *(_QWORD *)(v2 + 88);
  *(_QWORD *)(v6 + 80) = v5;
  *(_QWORD *)(*(_QWORD *)(v2 + 80) + 88) = v6;
  v7 = *(_QWORD *)(v1 + 88);
  *(_QWORD *)(v2 + 80) = v1;
  *(_QWORD *)(v2 + 88) = v7;
  *(_QWORD *)(*(_QWORD *)(v1 + 88) + 80) = v2;
  *(_QWORD *)(v1 + 88) = v2;
  qword_100984D58 = v2;
  return result;
}

uint64_t sub_1001F2718(int a1, unsigned int a2, unsigned int a3)
{
  char v4;
  uint64_t v5;
  uint64_t result;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  if (!qword_100984D58)
    return 404;
  v4 = a2;
  v5 = qword_100984D58;
  while (*(unsigned __int16 *)(v5 + 24) != a1)
  {
    v5 = *(_QWORD *)(v5 + 80);
    if (v5 == qword_100984D58 || v5 == 0)
      return 404;
  }
  if (a2 >= 0x14)
  {
    sub_100253460();
    if (sub_10005549C())
    {
      v4 = 19;
      sub_100054530("Scaling down requested priority to %d", 19);
      v8 = sub_1000544A0(0x2Fu);
      if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        goto LABEL_17;
      sub_1006CEEC0();
    }
    v4 = 19;
    goto LABEL_17;
  }
  if (a2 != 12)
  {
LABEL_17:
    sub_10011EB94((_opaque_pthread_t *)qword_100984D80, 0, 0, 0, 1);
    goto LABEL_18;
  }
  sub_10011EB94((_opaque_pthread_t *)qword_100984D80, 0, 0, 0, 0);
  v4 = 12;
LABEL_18:
  *(_QWORD *)(v5 + 56) = a3;
  *(_QWORD *)(v5 + 48) = sub_100113398();
  *(_BYTE *)(v5 + 27) = v4;
  v9 = qword_100984D58;
  if (qword_100984D58 == v5)
    return 0;
  v10 = *(_QWORD *)(v5 + 80);
  if (v5 == v10)
    return 0;
  result = 0;
  v11 = *(_QWORD *)(v5 + 88);
  *(_QWORD *)(v11 + 80) = v10;
  *(_QWORD *)(*(_QWORD *)(v5 + 80) + 88) = v11;
  v12 = *(_QWORD *)(v9 + 88);
  *(_QWORD *)(v5 + 80) = v9;
  *(_QWORD *)(v5 + 88) = v12;
  *(_QWORD *)(*(_QWORD *)(v9 + 88) + 80) = v5;
  *(_QWORD *)(v9 + 88) = v5;
  qword_100984D58 = v5;
  return result;
}

uint64_t sub_1001F2880(int a1)
{
  uint64_t v1;
  uint64_t result;
  uint64_t v4;

  if (!qword_100984D58)
    return 404;
  v1 = qword_100984D58;
  while (*(unsigned __int16 *)(v1 + 24) != a1)
  {
    v1 = *(_QWORD *)(v1 + 80);
    if (v1 == qword_100984D58 || v1 == 0)
      return 404;
  }
  v4 = sub_100113398();
  result = 0;
  *(_QWORD *)(v1 + 48) = v4;
  return result;
}

uint64_t sub_1001F28DC()
{
  return j__pthread_cond_signal(&stru_100984D88);
}

uint64_t sub_1001F28E8()
{
  uint64_t result;

  if (byte_100984D78 == 1)
    sub_100253460();
  if (byte_100984D60)
    sub_100253460();
  if (qword_100984D58)
    sub_100253460();
  byte_100984D78 = 1;
  sub_10011EC54(&stru_100984D88);
  sub_10011EC54(&stru_100984DB8);
  dword_100984D7C = 0;
  qword_100984D68 = (uint64_t)sub_100251288(0, (uint64_t)sub_1001F0104);
  qword_100984D70 = (uint64_t)sub_100251288(0, (uint64_t)sub_1001F0104);
  sub_1001F0E30(1u, 48, 0xAu, 0, 0, 0xFFFFFFFF);
  sub_1001F0E30(2u, 5, 1u, 0, 0, 0xFFFFFFFF);
  if (!sub_10011EAC8((pthread_t *)&qword_100984D80, (void *(__cdecl *)(void *))sub_1001F2A04, 0))
    return 511;
  sub_10011EB64((_opaque_pthread_t *)qword_100984D80, 63);
  result = 0;
  byte_100984DE8 = 1;
  return result;
}

uint64_t sub_1001F2A04()
{
  sub_10011EC38("TxLoop");
  sub_1000477B8();
  if (byte_100984D78 == 1)
  {
    do
    {
      sub_1001F08C0();
      sub_10010B3A4(&stru_100984D88);
    }
    while ((byte_100984D78 & 1) != 0);
  }
  sub_1000478A0();
  byte_100984DE8 = 0;
  j__pthread_cond_signal(&stru_100984DB8);
  return 0;
}

BOOL sub_1001F2A74()
{
  if ((byte_100984D78 & 1) == 0)
    sub_100253460();
  if (!qword_100984D58)
    sub_100253460();
  if (byte_100984D60 <= 1u)
    sub_100253460();
  sub_1001F153C((void *)1);
  sub_1001F153C((void *)2);
  sub_1002512C0((_QWORD *)qword_100984D68);
  qword_100984D68 = 0;
  sub_1002512C0((_QWORD *)qword_100984D70);
  qword_100984D70 = 0;
  byte_100984D60 = 0;
  qword_100984D58 = 0;
  byte_100984D78 = 0;
  dword_100984D7C = 0;
  j__pthread_cond_signal(&stru_100984D88);
  do
    sub_10010B3A4(&stru_100984DB8);
  while ((byte_100984DE8 & 1) != 0);
  sub_10011EC78(&stru_100984D88);
  return sub_10011EC78(&stru_100984DB8);
}

uint64_t sub_1001F2B48(uint64_t a1)
{
  return sub_1001DBB20(**(unsigned __int16 **)(a1 + 8));
}

void sub_1001F2B54(uint64_t a1)
{
  unsigned int v2;
  NSObject *v3;
  BOOL v4;
  NSObject *v5;
  __int16 v6;
  unsigned __int16 v7;
  __int16 v8;
  unsigned __int8 *v9;
  unsigned int v10;
  NSObject *v11;
  __int16 v12;
  int *v13;
  uint64_t v14;
  __int16 v15;

  v2 = *(unsigned __int16 *)(a1 + 36);
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v12 = 0;
  if (!sub_1001DB044(v2, (uint64_t *)&v13) && (*v13 != 4 ? (v4 = *v13 == 2) : (v4 = 1), v4))
  {
    if (!*(_QWORD *)(a1 + 24))
    {
      WORD1(v14) = *(_WORD *)(sub_1001E3CCC(v13) + 8);
      if (*(_BYTE *)a1)
      {
        if (sub_10005549C())
        {
          sub_100054530("Why are we trying to add a header to a S-Frame ???");
          v5 = sub_1000544A0(0x2Fu);
          if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
            goto LABEL_4;
        }
      }
      else
      {
        v6 = sub_1001EF818(v13, (_WORD *)&v14 + 2, *(unsigned __int8 *)(a1 + 33), *(_WORD *)(a1 + 38));
        v7 = v6 + 4;
        if (*(_BYTE *)(a1 + 33) == 1)
        {
          *(_WORD *)((char *)&v14 + (unsigned __int16)(v6 + 4)) = *(_WORD *)(a1 + 34);
          v7 = v6 + 6;
        }
        v8 = *(_WORD *)(*(_QWORD *)(a1 + 40) + 4) + v7 - 4;
        LOBYTE(v14) = v8 + 2 * (*(_BYTE *)(sub_1001E3CCC(v13) + 78) != 0);
        BYTE1(v14) = (unsigned __int16)(v8 + 2 * (*(_BYTE *)(sub_1001E3CCC(v13) + 78) != 0)) >> 8;
        v9 = (unsigned __int8 *)sub_100253D54(7u);
        *(_QWORD *)(a1 + 24) = v9;
        if (v9)
        {
          sub_10005336C(v9, (char *)&v14, v7, 0);
          if (!*(_BYTE *)a1)
            sub_10025444C(*(unsigned __int8 **)(a1 + 24), *(_QWORD *)(a1 + 40));
          if (*(_BYTE *)(sub_1001E3CCC(v13) + 78))
          {
            sub_1001EE884(*(_QWORD *)(a1 + 24), &v12);
            sub_10005336C(*(unsigned __int8 **)(a1 + 24), (char *)&v12, 2uLL, 0);
          }
          v10 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 24) + 4);
          if (v10 > *(unsigned __int16 *)(sub_1001E3CCC(v13) + 72))
            sub_100253460();
        }
        else if (sub_10005549C())
        {
          sub_100054530("Failed to allocate a MBUF for flow control.");
          v11 = sub_1000544A0(0x2Fu);
          if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
            goto LABEL_4;
        }
      }
    }
  }
  else if (sub_10005549C())
  {
    sub_100054530("Failed to get channel for CID 0x%x", v2);
    v3 = sub_1000544A0(0x2Fu);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
LABEL_4:
      sub_1006CE7A4();
  }
}

uint64_t sub_1001F2DDC(uint64_t a1)
{
  uint64_t v1;
  _BOOL4 v3;
  unsigned int v4;
  unsigned int v5;
  int v6;
  uint64_t v7;
  int v8;
  NSObject *v9;
  const void *v10[2];

  v1 = a1;
  if (qword_100984D68 == a1 || qword_100984D70 == a1)
    return sub_100251574(a1, 0);
  if (!*(_BYTE *)(a1 + 16))
  {
    if (!sub_100056080(*(_QWORD *)a1))
      sub_100253460();
    v3 = sub_1001EE9F0(*(unsigned __int16 *)(v1 + 24));
    v4 = sub_100056080(*(_QWORD *)v1);
    v5 = *(unsigned __int8 *)(v1 + 26);
    if (v3)
    {
      v6 = v5 - sub_1001F0704(*(unsigned __int16 *)(v1 + 24));
      v7 = sub_100251574(*(_QWORD *)v1, 0);
      if (v4 != v6)
        return v7;
    }
    else
    {
      v7 = sub_100251574(*(_QWORD *)v1, 0);
      if (v4 < v5)
        return v7;
    }
LABEL_18:
    v10[0] = (const void *)2;
    v10[1] = (const void *)(v1 + 24);
    sub_10004A9EC((uint64_t)sub_1001F2B48, v10, 0, 0);
    return v7;
  }
  if (sub_100056080(*(_QWORD *)(a1 + 8)))
  {
    a1 = *(_QWORD *)(v1 + 8);
    return sub_100251574(a1, 0);
  }
  if (!sub_100056080(*(_QWORD *)v1))
  {
    if (sub_10005549C())
    {
      sub_100054530("Failed to dequeue packet, there is no SFrames or IFrames queued.");
      v9 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    sub_100253460();
    return 0;
  }
  v8 = *(_DWORD *)(v1 + 20);
  if (v8)
    *(_DWORD *)(v1 + 20) = v8 - 1;
  v7 = sub_100251574(*(_QWORD *)v1, 0);
  if (sub_100056080(*(_QWORD *)v1) - *(_DWORD *)(v1 + 20) == *(unsigned __int8 *)(v1 + 26) - 1)
    goto LABEL_18;
  return v7;
}

uint64_t sub_1001F2F94(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  BOOL v17;
  BOOL v18;
  BOOL v19;
  uint64_t v20;
  unsigned int v21;
  NSObject *v23;
  uint64_t *v25;
  _BYTE *v26;
  uint64_t v28;

  v7 = a1;
  if (!(*(unsigned int (**)(void))(a1 + 64))())
    return 0;
  if (sub_1001F32E8(a2))
  {
    if (qword_100984D58)
    {
      v8 = *(unsigned __int16 *)(*(_QWORD *)a2 + 36);
      v9 = qword_100984D58;
      while (*(unsigned __int16 *)(v9 + 24) != v8)
      {
        v9 = *(_QWORD *)(v9 + 80);
        if (v9 == qword_100984D58 || v9 == 0)
          goto LABEL_11;
      }
      if (!*(_BYTE *)(v9 + 16) || (sub_1001EEA44(v8) & 1) != 0)
      {
        v25 = &qword_100984D68;
        goto LABEL_72;
      }
      return 0;
    }
LABEL_11:
    if (sub_10005549C())
    {
      sub_100054530("Fragmented packet with cid 0x%4x available, but no queue with corresponding CID exists", *(unsigned __int16 *)(*(_QWORD *)a2 + 36));
      v11 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    goto LABEL_55;
  }
  v12 = sub_100251684(qword_100984D70);
  v13 = v12;
  v28 = v12;
  if (!a2)
  {
    sub_100253460();
    if (v13)
      goto LABEL_18;
LABEL_40:
    if (*(_BYTE *)(v7 + 16))
    {
      if (!sub_100056080(*(_QWORD *)(v7 + 8)))
      {
        if (!sub_1001EEA44(*(unsigned __int16 *)(v7 + 24)))
          return 0;
        v26 = (_BYTE *)sub_10025155C(*(_QWORD *)v7);
        *(_QWORD *)a2 = v26;
        if (!*v26)
          sub_1001F2B54((uint64_t)v26);
LABEL_63:
        if (qword_100984D68 != v7 && qword_100984D70 != v7)
          goto LABEL_79;
        return v7;
      }
      v20 = *(_QWORD *)(v7 + 8);
    }
    else
    {
      v20 = *(_QWORD *)v7;
    }
    *(_QWORD *)a2 = sub_10025155C(v20);
    goto LABEL_63;
  }
  if (!v12)
    goto LABEL_40;
  while (1)
  {
LABEL_18:
    v14 = sub_1002516A8(v13);
    v15 = *(_QWORD *)(v14 + 8);
    if (*(_QWORD *)a2 && v15 != *(_QWORD *)(*(_QWORD *)a2 + 8))
      goto LABEL_39;
    if (!sub_10019AB28(v15)
      && !sub_10019ABD0(*(_QWORD *)(v14 + 8))
      && !sub_10019AC00(*(_QWORD *)(v14 + 8))
      && !sub_10019AC30(*(_QWORD *)(v14 + 8)))
    {
      break;
    }
    v16 = *(unsigned __int8 *)(*(_QWORD *)(v14 + 8) + 2);
    if (*(_BYTE *)(*(_QWORD *)(v14 + 8) + 2))
      v17 = 1;
    else
      v17 = byte_1009990D1 == 0;
    if (!v17
      || (v16 == 4 ? (v18 = byte_1009990D2 == 0) : (v18 = 1),
          !v18 || (v16 == 8 ? (v19 = byte_1009990D0 == 0) : (v19 = 1), !v19)))
    {
      *(_QWORD *)a2 = v14;
      sub_1002516B0(qword_100984D70, v28);
      v14 = *(_QWORD *)a2;
      goto LABEL_44;
    }
LABEL_39:
    sub_10025168C((uint64_t)&v28);
    v13 = v28;
    if (!v28)
      goto LABEL_40;
  }
  *(_QWORD *)a2 = v14;
LABEL_44:
  if (!qword_100984D58)
  {
LABEL_52:
    if (sub_10005549C())
    {
      sub_100054530("Unstallable packet with cid 0x%4x available, but no queue with corresponding CID exists", *(unsigned __int16 *)(*(_QWORD *)a2 + 36));
      v23 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
LABEL_55:
    sub_100253460();
    return 0;
  }
  v21 = *(unsigned __int16 *)(v14 + 36);
  v9 = qword_100984D58;
  while (*(unsigned __int16 *)(v9 + 24) != v21)
  {
    v9 = *(_QWORD *)(v9 + 80);
    if (v9 == qword_100984D58 || v9 == 0)
      goto LABEL_52;
  }
  if (*(_BYTE *)(v9 + 16) && (sub_1001EEA44(v21) & 1) == 0)
    return 0;
  v25 = &qword_100984D70;
LABEL_72:
  v7 = *v25;
  if (*v25)
  {
    if (v7 == qword_100984D68 || v7 == qword_100984D70)
    {
      *a4 = a3 - *(_QWORD *)(v9 + 48);
      *(_QWORD *)(v9 + 48) = a3;
    }
    else
    {
LABEL_79:
      *a4 = a3 - *(_QWORD *)(v7 + 48);
      *(_QWORD *)(v7 + 48) = a3;
    }
  }
  return v7;
}

uint64_t sub_1001F32E8(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  BOOL v7;
  BOOL v8;
  BOOL v9;
  uint64_t v11;

  v2 = sub_100251684(qword_100984D68);
  v3 = v2;
  v11 = v2;
  if (!a1)
  {
    sub_100253460();
    if (v3)
      goto LABEL_5;
    return 0;
  }
  if (!v2)
    return 0;
  while (1)
  {
LABEL_5:
    v4 = sub_1002516A8(v3);
    v5 = *(_QWORD *)(v4 + 8);
    if (*(_QWORD *)a1 && v5 != *(_QWORD *)(*(_QWORD *)a1 + 8))
      goto LABEL_26;
    if (!sub_10019AB28(v5)
      && !sub_10019ABD0(*(_QWORD *)(v4 + 8))
      && !sub_10019AC00(*(_QWORD *)(v4 + 8))
      && !sub_10019AC30(*(_QWORD *)(v4 + 8)))
    {
      break;
    }
    v6 = *(unsigned __int8 *)(*(_QWORD *)(v4 + 8) + 2);
    if (*(_BYTE *)(*(_QWORD *)(v4 + 8) + 2))
      v7 = 1;
    else
      v7 = byte_1009990D1 == 0;
    if (!v7
      || (v6 == 4 ? (v8 = byte_1009990D2 == 0) : (v8 = 1), !v8 || (v6 == 8 ? (v9 = byte_1009990D0 == 0) : (v9 = 1), !v9)))
    {
      *(_QWORD *)a1 = v4;
      sub_1002516B0(qword_100984D68, v11);
      return 1;
    }
LABEL_26:
    sub_10025168C((uint64_t)&v11);
    v3 = v11;
    if (!v11)
      return 0;
  }
  *(_QWORD *)a1 = v4;
  return 1;
}

BOOL sub_1001F3418(uint64_t a1, unsigned int a2)
{
  _BOOL4 v4;
  int v5;
  int v6;
  int v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  unsigned int v11;
  int v12;
  int v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  NSObject *v18;
  int v19;

  if (*(_BYTE *)(a1 + 2) == 4)
  {
    v8 = sub_1001A1198();
    v9 = sub_10019C27C();
    v11 = sub_1001A240C(2);
    if (*(_BYTE *)(a1 + 129))
      return 1;
    v10 = v11;
  }
  else
  {
    if (*(_BYTE *)(a1 + 2))
    {
      sub_100253460();
      return 0;
    }
    v4 = sub_1001A2420();
    v5 = sub_1001A2434();
    if (v5)
      v6 = 2;
    else
      v6 = 1;
    if (v4)
      v7 = v6;
    else
      v7 = v5;
    v8 = sub_1001A1110() - v7;
    v9 = sub_10019C1AC();
    v10 = sub_1001A240C(0) - v7;
  }
  v19 = 0;
  if (!v9)
  {
    if (sub_10005549C())
    {
      sub_100054530("connectionHandle %x and NumOfConnections %d", a1, 0);
      v18 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    return 1;
  }
  v12 = sub_1001DC2E4(a1, &v19);
  if (v9 + 2 * v19 <= v8)
    v13 = 2;
  else
    v13 = v19 + v9 <= v8;
  v14 = v8 - v9 + (v12 - v19) * v13;
  v15 = v14 + 1;
  if (v10 >= v14 + 1)
    v16 = v14 + 1;
  else
    v16 = v10;
  if (v15 <= *(unsigned __int16 *)(a1 + 16))
    return 0;
  if (a2 <= 0xA)
    return !*(_WORD *)(a1 + 16) || v16 > v13 * v12;
  return v16 != 0;
}

uint64_t sub_1001F3590()
{
  return sub_10022D328(off_10091EE60);
}

uint64_t sub_1001F359C()
{
  qword_100984DF0 = 0;
  *(_QWORD *)&word_100984DF8 = 0;
  sub_100186540(sub_1001F3C7C);
  sub_10024B8F8((uint64_t (*)(_QWORD, _QWORD, _QWORD))sub_1001F3BC8);
  sub_100254920((uint64_t)sub_1001F3CF8);
  sub_10022D270((__n128 *)off_10091EE60);
  return sub_1001927B0(&off_10091EE78, 0);
}

uint64_t sub_1001F35F4(uint64_t a1)
{
  _WORD *v2;
  _WORD *v3;
  void *v4;
  int v5;
  uint64_t result;
  _QWORD *v7;

  v2 = sub_100052DC0(0x18uLL);
  if (!v2)
    return 104;
  v3 = v2;
  v2[6] = 48;
  v4 = sub_100052DC0(0x30uLL);
  *(_QWORD *)v3 = v4;
  if (!v4)
  {
    sub_100053298(v3);
    return 104;
  }
  v3[7] = 0;
  v5 = *(unsigned __int8 *)(a1 + 2);
  if (v5 == 8)
  {
    result = 0;
    *(_QWORD *)(a1 + 64) = v3;
  }
  else if (v5 == 4)
  {
    *(_QWORD *)(a1 + 192) = v3;
    v7 = sub_100251288(0, 0);
    result = 0;
    *(_QWORD *)(a1 + 224) = v7;
  }
  else
  {
    result = 0;
    if (!*(_BYTE *)(a1 + 2))
    {
      result = 0;
      *(_QWORD *)(a1 + 160) = v3;
    }
  }
  return result;
}

void sub_1001F369C(uint64_t a1)
{
  int v2;
  void **v3;
  void **v4;
  uint64_t *v5;
  void **v6;
  void **v7;
  void **v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int16 *v12;
  uint64_t v13;
  int *v14;

  v2 = *(unsigned __int8 *)(a1 + 2);
  if (v2 == 8)
  {
    v5 = (uint64_t *)(a1 + 64);
    v7 = *(void ***)(a1 + 64);
    if (!v7)
      return;
    sub_100053298(*v7);
    goto LABEL_11;
  }
  if (v2 == 4)
  {
    v8 = *(void ***)(a1 + 192);
    if (v8)
    {
      sub_100053298(*v8);
      sub_100053298(*(void **)(a1 + 192));
      *(_QWORD *)(a1 + 192) = 0;
    }
    v10 = *(_QWORD *)(a1 + 224);
    v5 = (uint64_t *)(a1 + 224);
    v9 = v10;
    if (v10)
    {
      v11 = sub_100251574(v9, 0);
      if (v11)
      {
        v12 = (unsigned __int16 *)v11;
        do
        {
          v14 = 0;
          if (!sub_1001DB044(*v12, (uint64_t *)&v14) && *(_QWORD *)(sub_1001E3CCC(v14) + 96))
          {
            v13 = sub_1001E3CCC(v14);
            (*(void (**)(_QWORD, _QWORD, _QWORD, uint64_t))(v13 + 96))(*((unsigned __int16 *)v14 + 2), 0, 0, 414);
          }
          sub_100053298(v12);
          v12 = (unsigned __int16 *)sub_100251574(*v5, 0);
        }
        while (v12);
      }
      sub_1002512C0((_QWORD *)*v5);
      goto LABEL_23;
    }
  }
  else if (!*(_BYTE *)(a1 + 2))
  {
    v3 = *(void ***)(a1 + 160);
    if (v3)
    {
      sub_100053298(*v3);
      sub_100053298(*(void **)(a1 + 160));
      *(_QWORD *)(a1 + 160) = 0;
    }
    v6 = *(void ***)(a1 + 168);
    v5 = (uint64_t *)(a1 + 168);
    v4 = v6;
    if (v6)
    {
      if (!*v4)
      {
LABEL_12:
        sub_100053298(v4);
LABEL_23:
        *v5 = 0;
        return;
      }
      sub_100053298(*v4);
      *(_QWORD *)*v5 = 0;
LABEL_11:
      v4 = (void **)*v5;
      goto LABEL_12;
    }
  }
}

uint64_t sub_1001F37D8(uint64_t a1)
{
  uint64_t result;
  unsigned int v3;
  int v4;
  uint64_t *v5;
  uint64_t v6;
  void *v7;
  void *v8;
  size_t v9;
  NSObject *v10;
  void *v11;
  NSObject *v12;
  void *v13;
  unsigned int v14;
  NSObject *v15;
  NSObject *v16;

  if (!sub_10019AB28(a1) && !sub_10019AC00(a1))
  {
    result = sub_10019AC30(a1);
    if (!(_DWORD)result)
      return result;
  }
  v3 = sub_1001DB7C4(a1, 1);
  if (v3 <= 0x2F)
    sub_100253460();
  v4 = *(unsigned __int8 *)(a1 + 2);
  if (v4 == 8)
  {
    v5 = (uint64_t *)(a1 + 64);
    goto LABEL_12;
  }
  if (v4 == 4)
  {
    v5 = (uint64_t *)(a1 + 192);
LABEL_12:
    v6 = *v5;
    if (*v5)
      goto LABEL_14;
    goto LABEL_13;
  }
  if (!*(_BYTE *)(a1 + 2))
  {
    v5 = (uint64_t *)(a1 + 160);
    goto LABEL_12;
  }
LABEL_13:
  sub_100253460();
  v6 = 0;
LABEL_14:
  if (v3 == *(unsigned __int16 *)(v6 + 12))
    return 0;
  v7 = *(void **)v6;
  if (!*(_WORD *)(v6 + 14))
  {
    sub_100053298(*(void **)v6);
    v11 = sub_100052DC0(v3);
    *(_QWORD *)v6 = v11;
    if (v11)
    {
LABEL_35:
      result = 0;
      *(_WORD *)(v6 + 12) = v3;
      return result;
    }
    if (sub_10005549C())
    {
      sub_100054530("Could not allocate new reassembly buffer");
      v12 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    v13 = sub_100052DC0(*(unsigned __int16 *)(v6 + 12));
    *(_QWORD *)v6 = v13;
    if (!v13)
      sub_100253460();
    return 106;
  }
  v8 = sub_100052DC0(v3);
  *(_QWORD *)v6 = v8;
  if (v8)
  {
    v9 = *(unsigned __int16 *)(v6 + 14);
    if (v9 <= v3)
    {
      memmove(v8, v7, v9);
    }
    else
    {
      if (sub_10005549C())
      {
        sub_100054530("The new MTU is smaller than the current data size we have in the buffer ... dropping the current data (curRecvCount == %d, newBufsize=%d)", *(unsigned __int16 *)(v6 + 14), v3);
        v10 = sub_1000544A0(0x2Fu);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      *(_WORD *)(v6 + 14) = 0;
      *(_BYTE *)(v6 + 16) = 0;
    }
    sub_100053298(v7);
    goto LABEL_35;
  }
  *(_QWORD *)v6 = v7;
  v14 = *(unsigned __int16 *)(v6 + 12);
  result = sub_10005549C();
  if (v3 >= v14)
  {
    if ((_DWORD)result)
    {
      sub_100054530("No resources for larger reassembly buffer");
      v16 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 106;
  }
  if ((_DWORD)result)
  {
    sub_100054530("Could not allocate new reassembly buffer - continuing with existing buffer");
    v15 = sub_1000544A0(0x2Fu);
    result = os_log_type_enabled(v15, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
    {
      sub_1006CE7A4();
      return 0;
    }
  }
  return result;
}

uint64_t sub_1001F3A24(uint64_t a1, _BYTE *a2, int a3, __int16 a4)
{
  NSObject *v9;
  NSObject *v10;
  NSObject *v11;

  if (a3)
    goto LABEL_2;
  if (!sub_10019AB28((uint64_t)a2) && !sub_10019AC00((uint64_t)a2) && !sub_10019AC30((uint64_t)a2))
  {
    if (!sub_10005549C())
      return 414;
    sub_100054530("Invalid handle");
    v11 = sub_1000544A0(0x2Fu);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      return 414;
    goto LABEL_21;
  }
  if (sub_10019AB28((uint64_t)a2) && (a2[152] == 255 || (a2[54] & 0xFE) == 6))
  {
    if (!sub_10005549C())
      return 414;
    sub_100054530("Link going down");
    v9 = sub_1000544A0(0x2Fu);
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      return 414;
    goto LABEL_21;
  }
  if (!sub_10019AC00((uint64_t)a2) || (a2[124] & 0xFE) != 6)
  {
    if (!sub_10019AC30((uint64_t)a2) || (a2[60] & 0xFE) != 6)
    {
LABEL_2:
      *(_QWORD *)(a1 + 8) = a2;
      *(_WORD *)(a1 + 20) = a4;
      *(_DWORD *)(a1 + 16) = a3;
      return sub_1001F1D40(a1);
    }
    if (sub_10005549C())
    {
      sub_100054530("Invalid handle");
      v10 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
LABEL_21:
        sub_1006CE7A4();
    }
  }
  return 414;
}

void sub_1001F3BC0(uint64_t a1, uint64_t a2, int a3)
{
  sub_1001F3BC8(a1, a1, a3);
}

void sub_1001F3BC8(uint64_t a1, uint64_t a2, int a3)
{
  char v4;
  NSObject *v5;

  if (*(_BYTE *)(a2 + 2) == 4)
  {
    sub_10019C594(a2);
    sub_1001F0890(1);
  }
  else if (*(_BYTE *)(a2 + 2))
  {
    if (sub_10005549C())
    {
      sub_100054530("Invalid connection type.");
      v5 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  else
  {
    v4 = a3;
    if (a3)
    {
      if (!*(_BYTE *)(a2 + 153))
      {
        sub_10019C594(a2);
        sub_1001F0890(1);
      }
    }
    *(_BYTE *)(a2 + 153) = v4;
  }
}

void sub_1001F3C7C(uint64_t a1, uint64_t a2)
{
  NSObject *v2;

  if (*(_BYTE *)(a2 + 2))
  {
    if (sub_10005549C())
    {
      sub_100054530("Received mode change for non ACL connection handle.");
      v2 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  else
  {
    sub_10019C594(a2);
    sub_1001F0890(3);
  }
}

void sub_1001F3CF8(uint64_t a1)
{
  sub_10019C594(a1);
  sub_1001F0890(2);
}

_BYTE *sub_1001F3D14(_BYTE *result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (!result[2])
  {
    v1 = (uint64_t)result;
    result[192] = 1;
    if (result[152] == 2)
    {
      if (result[256])
      {
        v9 = 0;
        sub_10004AD30((uint64_t)&v9);
        result = (_BYTE *)sub_100258A4C((int *)(v1 + 204), (int *)&v9);
        if (result <= (5 * *(unsigned __int16 *)(v1 + 136)) >> 3)
        {
          result = (_BYTE *)sub_100196768(0x2Au, v2, v3, v4, v5, v6, v7, v8, v1);
          if (!(_DWORD)result)
            *(_BYTE *)(v1 + 152) |= 0x80u;
        }
        *(_QWORD *)(v1 + 204) = v9;
      }
    }
  }
  return result;
}

void sub_1001F3DAC(unsigned __int16 *a1, unsigned int a2, int a3, uint64_t a4, size_t a5, uint64_t a6, uint64_t a7)
{
  NSObject *v13;
  int v14;
  NSObject *v15;
  NSObject *v16;
  NSObject *v17;
  _BOOL4 v18;
  uint64_t v19;
  unsigned int v20;
  uint8_t buf[4];
  void *v22;

  if (*(_BYTE *)(a7 + 8))
  {
    if (sub_10005549C())
    {
      sub_100054530("HciEvent_AclDataPacketReceived: wakeupCause ACL Packet from BT Controller (handle=0x%04x pbf=%d bf=%d dataLen=%d)\n", *a1, a2, a3, a5);
      v13 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v22 = sub_100054494();
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
  }
  if (*((_BYTE *)a1 + 2))
  {
    if ((_DWORD)a5)
      goto LABEL_7;
LABEL_15:
    if (!sub_10005549C())
      return;
    sub_100054530("SAR, HciEvent_AclDataPacketReceived received zero-length packet, ignoring");
    v15 = sub_1000544A0(0x2Fu);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      return;
LABEL_26:
    sub_1006CE7A4();
    return;
  }
  if (!*((_DWORD *)a1 + 37))
    sub_10017FF38((uint64_t)a1);
  *((_BYTE *)a1 + 192) = 1;
  if (!(_DWORD)a5)
    goto LABEL_15;
LABEL_7:
  if (a3 == 4 && *(_WORD *)(a4 + 2) != 2)
  {
    if (!sub_10005549C())
      return;
    sub_100054530("SAR, HciEvent_AclDataPacketReceived received APB for wrong CID=%d, ignoring", *(unsigned __int16 *)(a4 + 2));
    v16 = sub_1000544A0(0x2Fu);
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      return;
    goto LABEL_26;
  }
  v14 = *(unsigned __int8 *)(a7 + 8);
  switch(a2)
  {
    case 0u:
    case 2u:
      if (!a3 && *((_BYTE *)a1 + 25))
      {
        v18 = v14 != 0;
        v19 = (uint64_t)a1;
        v20 = a2;
        goto LABEL_31;
      }
      sub_1001F429C((char *)a4, a5, (uint64_t)a1, a3, v14 != 0, a7);
      break;
    case 1u:
      if (a3 || !*((_BYTE *)a1 + 25))
      {
        sub_1001F45B0((char *)a4, a5, (uint64_t)a1, a3, v14 != 0, a7);
      }
      else
      {
        v18 = v14 != 0;
        v19 = (uint64_t)a1;
        v20 = 1;
LABEL_31:
        sub_1001F4150(v19, v20, (char *)a4, a5, v18, a7);
      }
      break;
    case 3u:
      sub_1001E2F98((uint64_t)a1, 0x2Bu, a4, a5, v14 != 0);
      break;
    default:
      if (sub_10005549C())
      {
        sub_100054530("Invalid packet boundary flag - dropping packet");
        v17 = sub_1000544A0(0x2Fu);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          goto LABEL_26;
      }
      break;
  }
}

uint64_t sub_1001F408C(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;
  unint64_t v4;
  BOOL v5;
  void (*v6)(_QWORD);

  v2 = sub_1001DAF2C();
  result = sub_100252DE8(0x2Fu);
  if (*(_WORD *)(result + 2))
  {
    v4 = 0;
    do
    {
      v5 = *(_DWORD *)v2 == 4 || *(_DWORD *)v2 == 2;
      if (v5
        && *(_QWORD *)sub_1001E3CCC((int *)v2) == a1
        && *(_BYTE *)(sub_1001E3CCC((int *)v2) + 16) == 4
        && sub_1001DB0E8((int *)v2))
      {
        sub_1001EFA50(*(unsigned __int16 *)(v2 + 4));
        ++*(_DWORD *)(v2 + 88);
        v6 = *(void (**)(_QWORD))(v2 + 136);
        if (v6)
          v6(*(unsigned __int16 *)(v2 + 4));
      }
      ++v4;
      result = sub_100252DE8(0x2Fu);
      v2 += 144;
    }
    while (v4 < *(unsigned __int16 *)(result + 2));
  }
  return result;
}

void sub_1001F4150(uint64_t a1, unsigned int a2, char *a3, unsigned int a4, int a5, uint64_t a6)
{
  unsigned __int16 v12;
  __int16 v13;
  unsigned __int16 v14;
  int v15;
  size_t v16;
  NSObject *v17;
  char *v18;
  size_t v19;
  uint64_t v20;
  int v21;
  char v22;
  uint64_t v23;

  v12 = 0;
  v13 = 0;
  v14 = a4;
  while (1)
  {
    v15 = *(unsigned __int16 *)(a1 + 28);
    *(_WORD *)(a1 + 28) = 0;
    if (!v15)
      LOWORD(v15) = *(_WORD *)a3 + 4;
    if (a2 >= 3)
      break;
    if ((unsigned __int16)v15 >= v14)
      v16 = v14;
    else
      v16 = (unsigned __int16)v15;
    if (a2 != 1 || v13)
      sub_1001F429C(a3, v16, a1, 0, a5, a6);
    else
      sub_1001F45B0(a3, v16, a1, 0, a5, a6);
    v12 += v16;
    v14 = a4 - v12;
    if (a4 < v12)
      v14 = 0;
    if (v12 == a4)
      return;
    if (v12 > a4)
    {
      *(_WORD *)(a1 + 28) = v12 - a4;
      return;
    }
    a3 += v16;
    ++v13;
  }
  sub_100253460();
  if ((sub_10005549C() & 1) != 0)
  {
    sub_100054530("L2CAPAGG RX: This should never happen, Invalid packet boundary flag for aggregated packets - dropping packet");
    v17 = sub_1000544A0(0x2Fu);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  v18 = (char *)sub_100112D60(411);
  sub_1001F429C(v18, v19, v20, v21, v22, v23);
}

void sub_1001F429C(char *__src, size_t __len, uint64_t a3, int a4, char a5, uint64_t a6)
{
  unsigned int v10;
  int v12;
  NSObject *v13;
  _QWORD *v14;
  _WORD *v15;
  _WORD *v16;
  size_t v17;
  NSObject *v18;
  char *v19;
  int v20;
  size_t v21;
  unsigned int v22;
  NSObject *v23;
  NSObject *v24;
  unsigned int v25;
  _BOOL8 v26;
  unsigned __int16 *v27;
  uint64_t v28;
  unsigned __int16 *v29;
  size_t v30;
  unsigned __int16 *v31;
  unsigned int v32;
  uint64_t v33;

  v10 = __len;
  v12 = *(unsigned __int8 *)(a3 + 2);
  if (!a4)
  {
    if (v12 == 8)
    {
      v14 = (_QWORD *)(a3 + 64);
    }
    else if (v12 == 4)
    {
      v14 = (_QWORD *)(a3 + 192);
    }
    else
    {
      if (*(_BYTE *)(a3 + 2))
      {
LABEL_17:
        sub_100253460();
        v15 = 0;
        goto LABEL_18;
      }
      v14 = (_QWORD *)(a3 + 160);
    }
    v15 = (_WORD *)*v14;
    if (*v14)
      goto LABEL_18;
    goto LABEL_17;
  }
  if (!*(_BYTE *)(a3 + 2))
  {
    v15 = *(_WORD **)(a3 + 168);
    if (!v15)
    {
      if (!sub_10019AB28(a3))
        return;
      v16 = sub_100114588(0x18uLL);
      *(_QWORD *)(a3 + 168) = v16;
      if (!v16)
        return;
      v15 = v16;
      v16[6] = *(_WORD *)(sub_100252DE8(0x2Fu) + 4);
      *(_QWORD *)(a3 + 168) = v15;
    }
LABEL_18:
    v17 = (unsigned __int16)v15[6];
    if (v15[7])
    {
      if (sub_10005549C())
      {
        sub_100054530("SAR: Rcvd FIRST packet, previous packet incomplete.  Discarding previous packet.");
        v18 = sub_1000544A0(0x2Fu);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      v15[7] = 0;
      *((_BYTE *)v15 + 16) = 0;
    }
    if (v10 <= 3)
    {
      memmove(v15 + 4, __src, v10);
      v15[7] += v10;
      return;
    }
    v20 = *(_DWORD *)__src;
    v19 = __src + 4;
    *((_DWORD *)v15 + 2) = v20;
    *((_BYTE *)v15 + 16) = a5;
    v21 = (unsigned __int16)v20;
    v22 = (unsigned __int16)(v10 - 4);
    if ((unsigned __int16)v20 < v22)
    {
      if (sub_10005549C())
      {
        sub_100054530("Packet size of %d exceeds the payload length %d", (unsigned __int16)(v10 - 4), v21);
        v23 = sub_1000544A0(0x2Fu);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          goto LABEL_32;
      }
      return;
    }
    if (v21 > v17)
    {
      if (sub_10005549C())
      {
        sub_100054530("Recv_FirstPacket, length in L2CAP header %d exceeds buffer size %d", v21, v17);
        v24 = sub_1000544A0(0x2Fu);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          goto LABEL_32;
      }
      return;
    }
    v25 = (unsigned __int16)v15[5];
    v33 = 0;
    v32 = v25;
    if (sub_1001DB044(v25, &v33))
    {
      if ((_DWORD)v21 == v22)
        goto LABEL_35;
    }
    else
    {
      v31 = *(unsigned __int16 **)(v33 + 48);
      if ((_DWORD)v21 == v22)
      {
        if (v31)
        {
          memmove(*(void **)(v33 + 48), v19, (unsigned __int16)(v10 - 4));
          v26 = *((_BYTE *)v15 + 16) != 0;
          v27 = (unsigned __int16 *)a3;
          v28 = v32;
          v29 = v31;
          v30 = (unsigned __int16)(v10 - 4);
          goto LABEL_39;
        }
LABEL_35:
        v26 = *((_BYTE *)v15 + 16) != 0;
        v27 = (unsigned __int16 *)a3;
        v28 = v32;
        v29 = (unsigned __int16 *)v19;
        v30 = v21;
LABEL_39:
        sub_1001F49AC(v27, v28, v29, v30, v26, a6);
        return;
      }
      if (v31)
      {
LABEL_45:
        memmove(v31, v19, (unsigned __int16)(v10 - 4));
        v15[7] = v10;
        return;
      }
    }
    v31 = *(unsigned __int16 **)v15;
    if (!*(_QWORD *)v15)
    {
      if (!a4)
        sub_100253460();
      v31 = (unsigned __int16 *)sub_100052DC0(v17);
      *(_QWORD *)v15 = v31;
      if (!v31)
        return;
    }
    goto LABEL_45;
  }
  if (sub_10005549C())
  {
    sub_100054530("Broadcast packet on non-ACL handle 0x%x. Bailing.", a3);
    v13 = sub_1000544A0(0x2Fu);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
LABEL_32:
      sub_1006CE7A4();
  }
}

void sub_1001F45B0(char *__src, size_t __len, uint64_t a3, int a4, int a5, uint64_t a6)
{
  unsigned int v9;
  char *v10;
  int v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  __int16 v15;
  NSObject *v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  NSObject *v20;
  unsigned __int16 v21;
  int v22;
  NSObject *v23;
  unsigned int v24;
  NSObject *v25;
  uint64_t v26;
  unsigned __int16 *v27;
  char v28;
  unsigned __int16 *v29;
  _BOOL8 v30;
  size_t v31;
  unsigned __int16 *v32;
  uint64_t v33;
  NSObject *v34;
  char *v35;
  NSObject *v36;
  unsigned __int16 *v37;
  unsigned __int16 v38;
  __int16 v39;
  char v40;
  uint64_t v41;

  v9 = __len;
  v10 = __src;
  v11 = *(unsigned __int8 *)(a3 + 2);
  if (a4)
  {
    if (*(_BYTE *)(a3 + 2))
      goto LABEL_15;
    v12 = (uint64_t *)(a3 + 168);
  }
  else if (v11 == 8)
  {
    v12 = (uint64_t *)(a3 + 64);
  }
  else if (v11 == 4)
  {
    v12 = (uint64_t *)(a3 + 192);
  }
  else
  {
    if (*(_BYTE *)(a3 + 2))
      goto LABEL_15;
    v12 = (uint64_t *)(a3 + 160);
  }
  v13 = *v12;
  if (!*v12 || (v14 = *(unsigned __int16 *)(v13 + 14), !*(_WORD *)(v13 + 14)))
  {
LABEL_15:
    if (sub_10005549C())
    {
      sub_100054530("CONTINUE packet with no FIRST packet - discarding this CONTINUE packet");
      v16 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        goto LABEL_17;
    }
    return;
  }
  if ((v14 + __len) <= 3)
  {
    memmove((void *)(v13 + v14 + 8), __src, __len);
    v15 = *(_WORD *)(v13 + 14) + v9;
LABEL_14:
    *(_WORD *)(v13 + 14) = v15;
    return;
  }
  if (v14 > 3)
  {
    LOWORD(v18) = *(_WORD *)(v13 + 8);
    v21 = v14 - 4;
    v19 = *(unsigned __int16 *)(v13 + 12);
    v22 = __len;
    goto LABEL_30;
  }
  v17 = 4 - v14;
  memmove((void *)(v13 + 8 + v14), __src, 4 - v14);
  v18 = *(unsigned __int16 *)(v13 + 8);
  v19 = *(unsigned __int16 *)(v13 + 12);
  if (v18 > v19)
  {
    if (!sub_10005549C())
      goto LABEL_34;
    sub_100054530("Length in L2CAP header %d exceeds MTU %d", v18, *(unsigned __int16 *)(v13 + 12));
    v20 = sub_1000544A0(0x2Fu);
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      goto LABEL_34;
    goto LABEL_33;
  }
  if (v18 >= v9)
  {
    v21 = 0;
    v10 += v17;
    LOWORD(v9) = v9 - v17;
    v22 = (unsigned __int16)v9;
LABEL_30:
    v24 = v22 + v21;
    if (v24 > v19)
    {
      if (!sub_10005549C())
        goto LABEL_34;
      sub_100054530("Received data %d exceeds exceeds buffer size %d", v24, *(unsigned __int16 *)(v13 + 12));
      v25 = sub_1000544A0(0x2Fu);
      if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        goto LABEL_34;
LABEL_33:
      sub_1006CE7A4();
      goto LABEL_34;
    }
    v26 = *(unsigned __int16 *)(v13 + 10);
    v41 = 0;
    if (sub_1001DB044(v26, &v41) || (v37 = *(unsigned __int16 **)(v41 + 48)) == 0)
    {
      memmove((void *)(*(_QWORD *)v13 + v21), v10, (unsigned __int16)v9);
      v27 = 0;
      v28 = 1;
      if (!a5)
        goto LABEL_39;
    }
    else
    {
      v40 = 0;
      v39 = 0;
      v38 = 0;
      if (sub_1001DCC5C(v26, &v39, &v38, &v40) || v24 > v38)
      {
        if (sub_10005549C())
        {
          sub_100054530("Received %d length data exceeding upper layer l2cap buffer size %d", v24, v38);
          v36 = sub_1000544A0(0x2Fu);
          if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
        return;
      }
      v35 = (char *)v37 + v21;
      v27 = v37;
      memmove(v35, v10, (unsigned __int16)v9);
      v28 = 0;
      if (!a5)
      {
LABEL_39:
        if ((unsigned __int16)v24 == (unsigned __int16)v18)
        {
          *(_WORD *)(v13 + 14) = 0;
          if ((v28 & 1) != 0)
          {
            v29 = *(unsigned __int16 **)v13;
            v30 = *(_BYTE *)(v13 + 16) != 0;
            v31 = (unsigned __int16)v18;
            v32 = (unsigned __int16 *)a3;
            v33 = v26;
          }
          else
          {
            v30 = *(_BYTE *)(v13 + 16) != 0;
            v31 = (unsigned __int16)v18;
            v32 = (unsigned __int16 *)a3;
            v33 = v26;
            v29 = v27;
          }
          sub_1001F49AC(v32, v33, v29, v31, v30, a6);
          goto LABEL_35;
        }
        if ((unsigned __int16)v24 <= (unsigned __int16)v18)
        {
          v15 = v24 + 4;
          goto LABEL_14;
        }
        if (sub_10005549C())
        {
          sub_100054530("Received data %d exceeds size in L2CAP header %d", (unsigned __int16)v24, (unsigned __int16)v18);
          v34 = sub_1000544A0(0x2Fu);
          if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
LABEL_34:
        *(_WORD *)(v13 + 14) = 0;
LABEL_35:
        *(_BYTE *)(v13 + 16) = 0;
        return;
      }
    }
    *(_BYTE *)(v13 + 16) = 1;
    goto LABEL_39;
  }
  if (sub_10005549C())
  {
    sub_100054530("Packet size of %d exceeds the expected payload length %d", v9, v18);
    v23 = sub_1000544A0(0x2Fu);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
LABEL_17:
      sub_1006CE7A4();
  }
}

void sub_1001F49AC(unsigned __int16 *a1, uint64_t a2, unsigned __int16 *a3, size_t a4, uint64_t a5, uint64_t a6)
{
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;
  int v15;
  NSObject *v16;
  int v17;
  int v18;
  const void **v19;
  NSObject *v20;
  int *v21;
  uint8_t buf[4];
  void *v23;

  v21 = 0;
  if ((_DWORD)a5)
  {
    if (sub_10005549C())
    {
      sub_100054530("UpperLayerRecv: wakeupCause Packet from BT Controller (handle=0x%04x cid=0x%4x, len=%d)\n", *a1, a2, a4);
      v12 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v23 = sub_100054494();
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
  }
  word_100984DF8 = a2;
  switch((_DWORD)a2)
  {
    case 2:
      sub_1001E339C((uint64_t)a1, a3, a4);
LABEL_15:
      word_100984DF8 = 0;
      return;
    case 1:
      sub_10020133C(a1, a3, a4);
      goto LABEL_15;
    case 0:
      if (sub_10005549C())
      {
        sub_100054530("%! (%d)", 105, 0);
        v13 = sub_1000544A0(0x2Fu);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      goto LABEL_15;
  }
  if (a2 <= 0x3F)
  {
    sub_1001E2F98((uint64_t)a1, a2, (uint64_t)a3, a4, a5);
    goto LABEL_15;
  }
  if (sub_1001DB044(a2, (uint64_t *)&v21))
  {
    if (sub_10005549C())
    {
      sub_100054530("Data received for invalid CID %d, ignoring packet", a2);
      v14 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
LABEL_39:
        sub_1006CE7A4();
    }
  }
  else if (sub_1001E3CCC(v21))
  {
    if (*(unsigned __int16 **)sub_1001E3CCC(v21) == a1)
    {
      if (!*(_BYTE *)(sub_1001E3CCC(v21) + 78)
        || (v17 = *(unsigned __int16 *)((char *)a3 + a4 - 2),
            *(_WORD *)buf = a4,
            *(_WORD *)&buf[2] = a2,
            LOWORD(a4) = a4 - 2,
            sub_1001EE80C((char *)buf, 4u, (char *)a3, (unsigned __int16)a4, v17)))
      {
        if (sub_1001EE99C(a2) || sub_1001EE9F0(a2))
          sub_1001EF934(a2, a3, (unsigned __int16)a4, a5, a6);
        else
          sub_1001DFA10(a2, (uint64_t)a3, (unsigned __int16)a4, a5, a6);
        goto LABEL_15;
      }
    }
    else
    {
      if (a1)
        v15 = *a1;
      else
        v15 = 0xFFFF;
      if (*(_QWORD *)sub_1001E3CCC(v21))
        v18 = **(unsigned __int16 **)sub_1001E3CCC(v21);
      else
        v18 = 0xFFFF;
      if (sub_10005549C())
      {
        v19 = (const void **)sub_1001E3CCC(v21);
        sub_100054530("(CID: %#06x) Received ACL handle %#06x (%p) does not match stored handle %#06x (%p), ignoring packet", a2, v15, a1, v18, *v19);
        v20 = sub_1000544A0(0x2Fu);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          goto LABEL_39;
      }
    }
  }
  else if (sub_10005549C())
  {
    sub_100054530("No connection data, ignoring packet", a2);
    v16 = sub_1000544A0(0x2Fu);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      goto LABEL_39;
  }
}

void sub_1001F4D44(int a1, const void *a2)
{
  NSObject *v4;

  dword_100984E00 = a1;
  if ((a1 - 1) > 0x7CE)
  {
    if ((a1 - 2000) > 0x7CF)
    {
      if (sub_10005549C())
      {
        sub_100054530("Invalid chipset %d", a1);
        v4 = sub_1000544A0(0x54u);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
          sub_1006CEEC0();
      }
    }
    else
    {
      sub_10011F9D0(&off_100984F10);
      sub_10011F9AC((void (**)(uint64_t *, uint64_t))&off_100985800, a2);
    }
  }
  else
  {
    sub_1001B7074(&off_100984F10);
    sub_1001B7050((void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))&off_100985800, a2);
  }
}

uint64_t sub_1001F4E24()
{
  return dword_100984E00;
}

uint64_t sub_1001F4E30(int a1, uint64_t a2)
{
  uint64_t v2;

  if ((a1 - 1) >= 0x7CF && a1 != 6000 && (a1 - 4000) < 0xFFFFF830)
    return 101;
  v2 = 0;
  dword_10097A8AC = a1;
  qword_100985808 = a2;
  return v2;
}

uint64_t sub_1001F4E78()
{
  uint64_t v0;
  NSObject *v1;

  sub_1001F4D44(dword_10097A8AC, (const void *)qword_100985808);
  dword_100984F08 = 0;
  v0 = sub_1001864F4((uint64_t)sub_1001F4F14, 0);
  if ((_DWORD)v0)
  {
    if (sub_10005549C())
    {
      sub_100054530("Failed to register vsevent %!", v0);
      v1 = sub_1000544A0(0x54u);
      if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  return v0;
}

void sub_1001F4F14(unsigned __int8 *a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  int v6;
  unsigned __int8 *v7;
  __int16 v8;
  __int16 v9;
  __int16 v10;
  __int16 v11;

  if (a2)
  {
    if (!a1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/vsc.c");
    v7 = a1;
    v8 = a2;
    v11 = 1;
    v9 = a2;
    if (a2 <= 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/vsc/vsc.c");
    v6 = *a1;
    v10 = 2;
    if (a2 - 2 != a1[1])
      sub_100253460();
    if (v6 == 14)
    {
      if (a2 >= 6)
        return;
      goto LABEL_12;
    }
    if (v6 != 255)
    {
      if (v6 != 15 || a2 == 6)
        return;
LABEL_12:
      sub_100253460();
      return;
    }
    if (a2 <= 2)
      sub_100253460();
    if (off_100985800)
      off_100985800(&v7, a4);
  }
}

void sub_1001F501C(uint64_t a1)
{
  NSObject *v1;

  qword_100985830 = a1;
  if ((dword_100984E00 - 1) > 0x7CE)
  {
    if ((dword_100984E00 - 2000) > 0x7CF)
    {
      if (sub_10005549C())
      {
        sub_100054530("Invalid chipset %d", dword_100984E00);
        v1 = sub_1000544A0(0x54u);
        if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
          sub_1006CEEC0();
      }
    }
    else
    {
      sub_10011FA98(&unk_100985810);
    }
  }
  else
  {
    sub_1001B70A8(&unk_100985810);
  }
}

void sub_1001F50DC(uint64_t a1)
{
  NSObject *v1;

  qword_1009859A8 = a1;
  if ((dword_100984E00 - 1) > 0x7CE)
  {
    if ((dword_100984E00 - 2001) > 0x7CE)
    {
      if (sub_10005549C())
      {
        sub_100054530("Invalid chipset %d for LMP Halt VSE Callback Registration", dword_100984E00);
        v1 = sub_1000544A0(0x54u);
        if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
          sub_1006CEEC0();
      }
    }
    else
    {
      sub_10011FA98(&unk_100985810);
    }
  }
  else
  {
    sub_1001B70A8(&unk_100985810);
  }
}

void sub_1001F519C(uint64_t a1)
{
  NSObject *v1;

  qword_1009858E8 = a1;
  if ((dword_100984E00 - 1) > 0x7CE)
  {
    if (sub_10005549C())
    {
      sub_100054530("Invalid chipset %d for Advanced Sniff Mode Change Registration", dword_100984E00);
      v1 = sub_1000544A0(0x54u);
      if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  else
  {
    sub_1001B70A8(&unk_100985810);
  }
}

uint64_t sub_1001F5238()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100984F10)
  {
    v0 = off_100984F10();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F52C0()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100984F20)
  {
    v0 = off_100984F20();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F5348()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100984F18)
  {
    v0 = off_100984F18();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F53D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  NSObject *v9;

  if (!sub_10019AC00(a1))
    return 122;
  if (off_100984F28)
  {
    v8 = off_100984F28(a1, a2, a3, a4);
    if (!(_DWORD)v8)
      return v8;
  }
  else
  {
    v8 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v8);
    v9 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v8;
}

uint64_t sub_1001F5490(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  NSObject *v7;

  if (!sub_10019AC00(a1))
    return 122;
  if (off_100984F30)
  {
    v6 = off_100984F30(a1, a2, a3);
    if (!(_DWORD)v6)
      return v6;
  }
  else
  {
    v6 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v6);
    v7 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v6;
}

uint64_t sub_1001F5548()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100984F38)
  {
    v0 = off_100984F38();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F55D0()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100984F40)
  {
    v0 = off_100984F40();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F5658()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100984F48)
  {
    v0 = off_100984F48();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F56E0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  NSObject *v7;

  if (!sub_10019AC00(a1))
    return 122;
  if (off_100984F50)
  {
    v6 = off_100984F50(a1, a2, a3);
    if (!(_DWORD)v6)
      return v6;
  }
  else
  {
    v6 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v6);
    v7 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v6;
}

uint64_t sub_1001F5798()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100984F70)
  {
    v0 = off_100984F70();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F5820()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100984F78)
  {
    v0 = off_100984F78();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F58A8()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100984F80)
  {
    v0 = off_100984F80();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F5930()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100984F88)
  {
    v0 = off_100984F88();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F59B8(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;

  if (!a1)
    return 101;
  if (off_100984F90)
  {
    v1 = off_100984F90();
    if (!(_DWORD)v1)
      return v1;
  }
  else
  {
    v1 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v1);
    v2 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v1;
}

uint64_t sub_1001F5A4C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100984F98)
  {
    v0 = off_100984F98();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F5AD4()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100984FA0)
  {
    v0 = off_100984FA0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F5B5C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100984FA8)
  {
    v0 = off_100984FA8();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F5BE4()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100984FB0)
  {
    v0 = off_100984FB0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F5C6C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100984FB8)
  {
    v0 = off_100984FB8();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F5CF4()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100984F58)
  {
    v0 = off_100984F58();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F5D7C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100984F60)
  {
    v0 = off_100984F60();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F5E04(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  NSObject *v7;
  uint64_t v8;

  if (!a2)
    return 101;
  v8 = 0;
  v5 = sub_100182588(a2, &v8);
  if (!(_DWORD)v5)
  {
    if (off_100984F68)
    {
      v5 = off_100984F68(a1, v8, a3);
      if (!(_DWORD)v5)
        return v5;
    }
    else
    {
      v5 = 3601;
    }
    if (sub_10005549C())
    {
      sub_100054530("VSC failed %!", v5);
      v7 = sub_1000544A0(0x54u);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  return v5;
}

uint64_t sub_1001F5ECC()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100984FC0)
  {
    v0 = off_100984FC0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F5F54()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100984FC8)
  {
    v0 = off_100984FC8();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F5FDC(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;

  if (!a1)
    return 101;
  if (off_100984FD0)
  {
    v1 = off_100984FD0();
    if (!(_DWORD)v1)
      return v1;
  }
  else
  {
    v1 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v1);
    v2 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v1;
}

uint64_t sub_1001F6070()
{
  uint64_t v0;
  NSObject *v1;

  if (dword_100984E00 != 12)
    return 3601;
  if (off_100984FE8)
  {
    v0 = off_100984FE8();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F6110()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100984FF0)
  {
    v0 = off_100984FF0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F6198()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100984FF8)
  {
    v0 = off_100984FF8();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F6220()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985020)
  {
    v0 = off_100985020();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F62A8()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985038)
  {
    v0 = off_100985038();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F6330()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985030)
  {
    v0 = off_100985030();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F63B8(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v5;
  uint64_t v6;
  NSObject *v8;
  int v9;
  __int16 v10;
  uint64_t v11;

  v11 = 0;
  v5 = sub_100225368(a2);
  v9 = v5;
  v10 = WORD2(v5);
  v6 = sub_100182588((uint64_t)&v9, &v11);
  if (!(_DWORD)v6)
  {
    if (off_100985040)
    {
      v6 = off_100985040(a1, v11, a3);
      if (!(_DWORD)v6)
        return v6;
    }
    else
    {
      v6 = 3601;
    }
    if (sub_10005549C())
    {
      sub_100054530("VSC failed %!", v6);
      v8 = sub_1000544A0(0x54u);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  return v6;
}

uint64_t sub_1001F6488()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985048)
  {
    v0 = off_100985048();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F6510()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985050)
  {
    v0 = off_100985050();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F6598()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985058)
  {
    v0 = off_100985058();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F6620()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985060)
  {
    v0 = off_100985060();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F66A8()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985068)
  {
    v0 = off_100985068();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F6730(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  NSObject *v3;

  if (off_100985648)
  {
    v2 = off_100985648(a1, a2);
    if (!(_DWORD)v2)
      return v2;
  }
  else
  {
    v2 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v2);
    v3 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v2;
}

uint64_t sub_1001F67C8(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5, unsigned int a6, unsigned int a7, unsigned int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,int a23,char a24,uint64_t a25)
{
  uint64_t v25;
  NSObject *v26;
  uint64_t v28;

  if (off_1009857E0)
  {
    BYTE4(v28) = a24;
    LODWORD(v28) = a23;
    v25 = off_1009857E0(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19,
            a20,
            a21,
            a22,
            v28,
            a25);
    if (!(_DWORD)v25)
      return v25;
  }
  else
  {
    v25 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v25);
    v26 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v25;
}

uint64_t sub_1001F69A0()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009857E8)
  {
    v0 = off_1009857E8();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F6A28()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985078)
  {
    v0 = off_100985078();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F6AB0()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985080)
  {
    v0 = off_100985080();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC LMP Halt failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F6B38()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985088)
  {
    v0 = off_100985088();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F6BC0()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985098)
  {
    v0 = off_100985098();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F6C48()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009856E0)
  {
    v0 = off_1009856E0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F6CD0(unsigned int a1, uint64_t a2)
{
  uint64_t v2;
  NSObject *v3;

  v2 = 101;
  if (a1 <= 1 && a2)
  {
    if (off_1009850B8)
    {
      v2 = off_1009850B8();
      if (!(_DWORD)v2)
        return v2;
    }
    else
    {
      v2 = 3601;
    }
    if (sub_10005549C())
    {
      sub_100054530("VSC failed %!", v2);
      v3 = sub_1000544A0(0x54u);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  return v2;
}

uint64_t sub_1001F6D68(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  NSObject *v4;

  v3 = 101;
  if (a2 && a3)
  {
    if (off_1009850A0)
    {
      v3 = off_1009850A0();
      if (!(_DWORD)v3)
        return v3;
    }
    else
    {
      v3 = 3601;
    }
    if (sub_10005549C())
    {
      sub_100054530("VSC failed %!", v3);
      v4 = sub_1000544A0(0x54u);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  return v3;
}

uint64_t sub_1001F6DFC(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  NSObject *v3;

  if (!a2)
    return 101;
  if (off_1009850A8)
  {
    v2 = off_1009850A8();
    if (!(_DWORD)v2)
      return v2;
  }
  else
  {
    v2 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v2);
    v3 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v2;
}

uint64_t sub_1001F6E90()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009850B0)
  {
    v0 = off_1009850B0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F6F18()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009850D0)
  {
    v0 = off_1009850D0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F6FA0(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;

  if (!a1)
    return 101;
  if (off_1009850D8)
  {
    v1 = off_1009850D8();
    if (!(_DWORD)v1)
      return v1;
  }
  else
  {
    v1 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v1);
    v2 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v1;
}

uint64_t sub_1001F7034(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;

  if (!a1)
    return 101;
  if (off_1009851C0)
  {
    v1 = off_1009851C0();
    if (!(_DWORD)v1)
      return v1;
  }
  else
  {
    v1 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v1);
    v2 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v1;
}

uint64_t sub_1001F70C8()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009851E8)
  {
    v0 = off_1009851E8();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F7150()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009850E0)
  {
    v0 = off_1009850E0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F71D8(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  NSObject *v3;

  v2 = 101;
  if (a1 && a2 <= 0x15)
  {
    if (off_1009850E8)
    {
      v2 = off_1009850E8();
      if (!(_DWORD)v2)
        return v2;
    }
    else
    {
      v2 = 3601;
    }
    if (sub_10005549C())
    {
      sub_100054530("VSC failed %!", v2);
      v3 = sub_1000544A0(0x54u);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  return v2;
}

uint64_t sub_1001F7270(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  NSObject *v3;

  v2 = 101;
  if (a1 && a2 <= 0x15)
  {
    if (off_1009850F0)
    {
      v2 = off_1009850F0();
      if (!(_DWORD)v2)
        return v2;
    }
    else
    {
      v2 = 3601;
    }
    if (sub_10005549C())
    {
      sub_100054530("VSC failed %!", v2);
      v3 = sub_1000544A0(0x54u);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  return v2;
}

uint64_t sub_1001F7308()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009850F8)
  {
    v0 = off_1009850F8();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F7390()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009854B8)
  {
    v0 = off_1009854B8();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F7418()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009854C0)
  {
    v0 = off_1009854C0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F74A0(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  uint64_t v4;
  NSObject *v5;

  v4 = 101;
  if (a4 <= a2 && a2 <= 0x19 && a1 && a3)
  {
    if (off_100985158)
    {
      v4 = off_100985158(a1, a2, a3);
      if (!(_DWORD)v4)
        return v4;
    }
    else
    {
      v4 = 3601;
    }
    if (sub_10005549C())
    {
      sub_100054530("VSC failed %!", v4);
      v5 = sub_1000544A0(0x54u);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  return v4;
}

uint64_t sub_1001F756C(unsigned int a1, unsigned int a2, uint64_t a3)
{
  uint64_t v4;
  BOOL v7;
  NSObject *v8;

  if ((a1 - 21) < 0xECu || a3 == 0)
    return 101;
  v7 = a1 > 4 && a2 != 0;
  v4 = 101;
  if (a2 <= 0x19 && !v7)
  {
    if (off_100985168)
    {
      v4 = off_100985168();
      if (!(_DWORD)v4)
        return v4;
    }
    else
    {
      v4 = 3601;
    }
    if (sub_10005549C())
    {
      sub_100054530("VSC failed %!", v4);
      v8 = sub_1000544A0(0x54u);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  return v4;
}

uint64_t sub_1001F7628()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009851A0)
  {
    v0 = off_1009851A0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F76B0()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985170)
  {
    v0 = off_100985170();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F7738(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t v5;
  NSObject *v6;

  v5 = 101;
  if (a5 == 3 && a3 == 3 && a2 && a4)
  {
    if (off_100985178)
    {
      v5 = off_100985178();
      if (!(_DWORD)v5)
        return v5;
    }
    else
    {
      v5 = 3601;
    }
    if (sub_10005549C())
    {
      sub_100054530("VSC failed %!", v5);
      v6 = sub_1000544A0(0x54u);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  return v5;
}

uint64_t sub_1001F77E4()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985180)
  {
    v0 = off_100985180();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F786C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985188)
  {
    v0 = off_100985188();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F78F4(unsigned __int8 a1)
{
  uint64_t v1;
  NSObject *v2;

  if (off_100985190)
  {
    v1 = off_100985190(a1);
    if (!(_DWORD)v1)
      return v1;
  }
  else
  {
    v1 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v1);
    v2 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v1;
}

uint64_t sub_1001F7980()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985198)
  {
    v0 = off_100985198();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F7A08(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  uint64_t v4;
  NSObject *v5;

  v4 = 101;
  if (a4 <= a2 && a2 <= 0x16 && a1 && a3)
  {
    if (off_100985100)
    {
      v4 = off_100985100(a1, a2);
      if (!(_DWORD)v4)
        return v4;
    }
    else
    {
      v4 = 3601;
    }
    if (sub_10005549C())
    {
      sub_100054530("VSC failed %!", v4);
      v5 = sub_1000544A0(0x54u);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  return v4;
}

uint64_t sub_1001F7AB4()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985140)
  {
    v0 = off_100985140();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F7B3C(char a1, unsigned int a2, uint64_t a3)
{
  uint64_t v5;
  NSObject *v6;

  if ((a1 - 26) < 0xE7u || a2 > 1 || a3 == 0)
    return 101;
  if (off_100985148)
  {
    v5 = off_100985148();
    if (!(_DWORD)v5)
      return v5;
  }
  else
  {
    v5 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v5);
    v6 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v5;
}

uint64_t sub_1001F7BE4()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985128)
  {
    v0 = off_100985128();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F7C6C(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  NSObject *v11;

  if (!sub_10019AC00(a1))
    return 122;
  v8 = *(unsigned __int16 *)(a1 + 80);
  if (*(_WORD *)(a1 + 80) || (sub_100253460(), v8 = *(unsigned __int16 *)(a1 + 80), *(_WORD *)(a1 + 80)))
  {
    v9 = a3 / v8;
    if (v9 >= 0x100)
      sub_100253460();
  }
  else
  {
    LOBYTE(v9) = 127;
  }
  if (off_100985108)
  {
    v10 = off_100985108(a1, a2, v9, a4);
    if (!(_DWORD)v10)
      return v10;
  }
  else
  {
    v10 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v10);
    v11 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v10;
}

uint64_t sub_1001F7D58(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  NSObject *v9;

  if (!sub_10019AC00(a1))
    return 122;
  if (!a2)
    return 101;
  if (off_100985110)
  {
    v8 = off_100985110(a1, a2, a3, a4);
    if (!(_DWORD)v8)
      return v8;
  }
  else
  {
    v8 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v8);
    v9 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v8;
}

uint64_t sub_1001F7E24(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;

  if (!a1)
    return 101;
  if (off_100985118)
  {
    v1 = off_100985118();
    if (!(_DWORD)v1)
      return v1;
  }
  else
  {
    v1 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v1);
    v2 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v1;
}

uint64_t sub_1001F7EB8(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  NSObject *v3;

  if (!a1)
    return 101;
  if (off_100985710)
  {
    v2 = off_100985710(a1, a2);
    if (!(_DWORD)v2)
      return v2;
  }
  else
  {
    v2 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v2);
    v3 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v2;
}

uint64_t sub_1001F7F64()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985718)
  {
    v0 = off_100985718();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F7FEC(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;

  if (!a1)
    return 101;
  if (off_100985708)
  {
    v1 = off_100985708(a1);
    if (!(_DWORD)v1)
      return v1;
  }
  else
  {
    v1 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v1);
    v2 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v1;
}

uint64_t sub_1001F8088(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  NSObject *v3;

  if (off_1009851F0)
  {
    v2 = off_1009851F0(a1, a2);
    if (!(_DWORD)v2)
      return v2;
  }
  else
  {
    v2 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v2);
    v3 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v2;
}

uint64_t sub_1001F8138(unint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  _DWORD v7[2];

  if (!a1)
    return 101;
  v3 = sub_10019AF68(a1);
  if (!sub_10019AC00(v3))
    return 122;
  *(_DWORD *)((char *)v7 + 3) = 0;
  v7[0] = 0;
  v4 = 101;
  if (!sub_1002214B4(v3, (uint64_t)v7, 0) && !LOBYTE(v7[0]))
  {
    if (off_1009851F8)
    {
      v4 = off_1009851F8(v3, (char *)v7 + 1, a2);
      if (!(_DWORD)v4)
        return v4;
    }
    else
    {
      v4 = 3601;
    }
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v4);
    v5 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v4;
}

uint64_t sub_1001F8228(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  uint64_t v7;

  if (!sub_10019AC00(a1))
    return 122;
  WORD2(v7) = 0;
  LODWORD(v7) = 0;
  if (off_1009851F8)
  {
    v4 = off_1009851F8(a1, &v7, a2);
    if (!(_DWORD)v4)
      return v4;
  }
  else
  {
    v4 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v4, v7);
    v5 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v4;
}

uint64_t sub_1001F82DC(_QWORD *a1)
{
  uint64_t v1;
  NSObject *v3;

  if (!a1 || !*a1)
    return 101;
  if (off_100985130)
  {
    v1 = off_100985130();
    if (!(_DWORD)v1)
      return v1;
  }
  else
  {
    v1 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v1);
    v3 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v1;
}

uint64_t sub_1001F8374(uint64_t a1)
{
  uint64_t v1;
  NSObject *v3;

  if (!a1 || !*(_QWORD *)(a1 + 8))
    return 101;
  if (off_1009851A8)
  {
    v1 = off_1009851A8();
    if (!(_DWORD)v1)
      return v1;
  }
  else
  {
    v1 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v1);
    v3 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v1;
}

uint64_t sub_1001F840C(_QWORD *a1)
{
  uint64_t v1;
  NSObject *v3;

  if (!a1 || !*a1)
    return 101;
  if (off_1009851B0)
  {
    v1 = off_1009851B0();
    if (!(_DWORD)v1)
      return v1;
  }
  else
  {
    v1 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v1);
    v3 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v1;
}

uint64_t sub_1001F84A4(int a1, __int16 a2, __int16 a3)
{
  uint64_t v3;
  NSObject *v4;

  if (!a1 || (v3 = 101, (unsigned __int16)(a2 - 16385) >= 0xC003u) && (unsigned __int16)(a3 - 16385) >= 0xC003u)
  {
    if (off_1009851B8)
    {
      v3 = off_1009851B8();
      if (!(_DWORD)v3)
        return v3;
    }
    else
    {
      v3 = 3601;
    }
    if (sub_10005549C())
    {
      sub_100054530("VSC failed %!", v3);
      v4 = sub_1000544A0(0x54u);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  return v3;
}

uint64_t sub_1001F8554(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v14;
  int v15;
  NSObject *v16;
  __int16 *v17;

  if (a4)
  {
    if (!a1)
      return 101;
  }
  else
  {
    sub_100253460();
    if (!a1)
      return 101;
  }
  v17 = 0;
  v10 = sub_100182588(a1, (uint64_t *)&v17);
  if (!(_DWORD)v10)
  {
    v11 = (uint64_t)v17;
    if (*v17 == -1)
      return 101;
    v12 = *((_DWORD *)v17 + 62);
    if ((a2 - 3) <= 0xFFFFFFFD && (v12 - 1) < 2)
      return 101;
    if ((_DWORD)a3)
    {
      *((_DWORD *)v17 + 62) = v12 | a2;
      *a4 = v12 | a2;
      if (!v12)
      {
LABEL_23:
        if (off_100985208)
        {
          v10 = off_100985208(a1, a3, a2, a5);
          if (!(_DWORD)v10)
            return v10;
        }
        else
        {
          v10 = 3601;
        }
        if (sub_10005549C())
        {
          sub_100054530("VSC failed %!", v10);
          v16 = sub_1000544A0(0x54u);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
            sub_1006CEEC0();
        }
        return v10;
      }
    }
    else
    {
      v14 = v12 & ~(_DWORD)a2;
      *((_DWORD *)v17 + 62) = v14;
      if (v12 && !v14)
      {
        if (*(_BYTE *)(v11 + 144) == 1)
        {
          v15 = *(unsigned __int8 *)(v11 + 197);
          if (*(_BYTE *)(v11 + 197))
          {
            *(_BYTE *)(v11 + 197) = 0;
            sub_10018C8E8(v11, 2);
            v15 = *((_DWORD *)v17 + 62);
          }
        }
        else
        {
          v15 = 0;
        }
        *a4 = v15;
        goto LABEL_23;
      }
      *a4 = v14;
    }
    return 3603;
  }
  return v10;
}

uint64_t sub_1001F86D4()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985200)
  {
    v0 = off_100985200();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F875C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985210)
  {
    v0 = off_100985210();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F87E4()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985218)
  {
    v0 = off_100985218();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F886C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985228)
  {
    v0 = off_100985228();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F88F4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  NSObject *v7;
  uint64_t v8;

  if (!a2)
    return 101;
  v8 = 0;
  v5 = sub_100182588(a2, &v8);
  if (!(_DWORD)v5)
  {
    if (off_100985230)
    {
      v5 = off_100985230(a1, v8, a3);
      if (!(_DWORD)v5)
        return v5;
    }
    else
    {
      v5 = 3601;
    }
    if (sub_10005549C())
    {
      sub_100054530("VSC failed %!", v5);
      v7 = sub_1000544A0(0x54u);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  return v5;
}

uint64_t sub_1001F89BC()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985238)
  {
    v0 = off_100985238();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F8A44(uint64_t a1)
{
  uint64_t v1;
  NSObject *v3;

  if (a1)
    return 101;
  if (off_100985240)
  {
    v1 = off_100985240(0);
    if (!(_DWORD)v1)
      return v1;
  }
  else
  {
    v1 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v1);
    v3 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v1;
}

uint64_t sub_1001F8AD8(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  NSObject *v5;
  uint64_t v6;

  if (!a1)
    return 101;
  v6 = 0;
  v3 = sub_100182588(a1, &v6);
  if (!(_DWORD)v3)
  {
    if (off_100985248)
    {
      v3 = off_100985248(v6, a2);
      if (!(_DWORD)v3)
        return v3;
    }
    else
    {
      v3 = 3601;
    }
    if (sub_10005549C())
    {
      sub_100054530("VSC failed %!", v3);
      v5 = sub_1000544A0(0x54u);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  return v3;
}

uint64_t sub_1001F8B88()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985258)
  {
    v0 = off_100985258();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F8C10(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  NSObject *v5;
  uint64_t v6;

  if (!a1)
    return 101;
  v6 = 0;
  v3 = sub_100182588(a1, &v6);
  if (!(_DWORD)v3)
  {
    if (off_100985260)
    {
      v3 = off_100985260(v6, a2);
      if (!(_DWORD)v3)
        return v3;
    }
    else
    {
      v3 = 3601;
    }
    if (sub_10005549C())
    {
      sub_100054530("VSC failed %!", v3);
      v5 = sub_1000544A0(0x54u);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  return v3;
}

uint64_t sub_1001F8CC0(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;

  if (!a1)
    return 101;
  if (off_100985268)
  {
    v1 = off_100985268();
    if (!(_DWORD)v1)
      return v1;
  }
  else
  {
    v1 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v1);
    v2 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v1;
}

uint64_t sub_1001F8D54(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;

  if (!a1)
    return 101;
  if (off_100985270)
  {
    v1 = off_100985270();
    if (!(_DWORD)v1)
      return v1;
  }
  else
  {
    v1 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v1);
    v2 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v1;
}

uint64_t sub_1001F8DE8(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;

  if (!a1)
    return 101;
  if (off_100985278)
  {
    v1 = off_100985278();
    if (!(_DWORD)v1)
      return v1;
  }
  else
  {
    v1 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v1);
    v2 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v1;
}

uint64_t sub_1001F8E7C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  NSObject *v9;
  uint64_t v10;

  if (!a1)
    return 101;
  v10 = 0;
  v7 = sub_100182588(a1, &v10);
  if (!(_DWORD)v7)
  {
    if (off_100985280)
    {
      v7 = off_100985280(v10, a2, a3, a4);
      if (!(_DWORD)v7)
        return v7;
    }
    else
    {
      v7 = 3601;
    }
    if (sub_10005549C())
    {
      sub_100054530("VSC failed %!", v7);
      v9 = sub_1000544A0(0x54u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  return v7;
}

uint64_t sub_1001F8F44(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v13;
  NSObject *v15;
  uint64_t v16;

  if (!a1)
    return 101;
  v16 = 0;
  v13 = sub_100182588(a1, &v16);
  if (!(_DWORD)v13)
  {
    if (off_100985288)
    {
      v13 = off_100985288(v16, a2, a3, a4, a5, a6, a7);
      if (!(_DWORD)v13)
        return v13;
    }
    else
    {
      v13 = 3601;
    }
    if (sub_10005549C())
    {
      sub_100054530("VSC failed %!", v13);
      v15 = sub_1000544A0(0x54u);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  return v13;
}

uint64_t sub_1001F9034(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9, uint64_t a10)
{
  uint64_t v17;
  NSObject *v19;
  uint64_t v20;

  if (!a1)
    return 101;
  v20 = 0;
  v17 = sub_100182588(a1, &v20);
  if (!(_DWORD)v17)
  {
    if (off_100985290)
    {
      v17 = off_100985290(v20, a2, a3, a4, a5, a6, a7, a8, a9, a10);
      if (!(_DWORD)v17)
        return v17;
    }
    else
    {
      v17 = 3601;
    }
    if (sub_10005549C())
    {
      sub_100054530("VSC failed %!", v17);
      v19 = sub_1000544A0(0x54u);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  return v17;
}

uint64_t sub_1001F913C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985298)
  {
    v0 = off_100985298();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F91C4()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009852A0)
  {
    v0 = off_1009852A0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F924C(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;

  if (!a1)
    return 101;
  if (off_1009852A8)
  {
    v1 = off_1009852A8();
    if (!(_DWORD)v1)
      return v1;
  }
  else
  {
    v1 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v1);
    v2 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v1;
}

uint64_t sub_1001F92E0(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;

  if (!a1)
    return 101;
  if (off_1009852B0)
  {
    v1 = off_1009852B0();
    if (!(_DWORD)v1)
      return v1;
  }
  else
  {
    v1 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v1);
    v2 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v1;
}

uint64_t sub_1001F9374(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;

  if (!a1)
    return 101;
  if (off_1009852B8)
  {
    v1 = off_1009852B8();
    if (!(_DWORD)v1)
      return v1;
  }
  else
  {
    v1 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v1);
    v2 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v1;
}

uint64_t sub_1001F9408(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;

  if (!a1)
    return 101;
  if (off_1009852C0)
  {
    v1 = off_1009852C0();
    if (!(_DWORD)v1)
      return v1;
  }
  else
  {
    v1 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v1);
    v2 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v1;
}

uint64_t sub_1001F949C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009852C8)
  {
    v0 = off_1009852C8();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F9524()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009852D0)
  {
    v0 = off_1009852D0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F95AC()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009852D8)
  {
    v0 = off_1009852D8();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F9634()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009852E0)
  {
    v0 = off_1009852E0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F96BC()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009852E8)
  {
    v0 = off_1009852E8();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F9744()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009852F8)
  {
    v0 = off_1009852F8();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F97CC()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985300)
  {
    v0 = off_100985300();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F9854()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985308)
  {
    v0 = off_100985308();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F98DC()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985310)
  {
    v0 = off_100985310();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F9964()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985318)
  {
    v0 = off_100985318();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F99EC()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985320)
  {
    v0 = off_100985320();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F9A74()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985328)
  {
    v0 = off_100985328();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F9AFC(unsigned __int16 *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  NSObject *v9;

  if (!sub_10019AC00((uint64_t)a1))
    return 122;
  if (off_100985340)
  {
    v8 = off_100985340(*a1, a2, a3, a4);
    if (!(_DWORD)v8)
      return v8;
  }
  else
  {
    v8 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v8);
    v9 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v8;
}

uint64_t sub_1001F9BBC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;
  NSObject *v11;
  uint64_t v12;

  if (!a1)
    return 101;
  v12 = 0;
  v9 = sub_100182588(a1, &v12);
  if (!(_DWORD)v9)
  {
    if (off_1009852F0)
    {
      v9 = off_1009852F0(v12, a2, a3, a4, a5);
      if (!(_DWORD)v9)
        return v9;
    }
    else
    {
      v9 = 3601;
    }
    if (sub_10005549C())
    {
      sub_100054530("VSC failed %!", v9);
      v11 = sub_1000544A0(0x54u);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  return v9;
}

uint64_t sub_1001F9C94()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985330)
  {
    v0 = off_100985330();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F9D1C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985338)
  {
    v0 = off_100985338();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F9DA4()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985348)
  {
    v0 = off_100985348();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F9E2C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985350)
  {
    v0 = off_100985350();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001F9EB4(uint64_t a1)
{
  uint64_t v1;
  NSObject *v3;
  unsigned __int16 *v4;

  if (!a1)
    return 101;
  v4 = 0;
  v1 = sub_100182588(a1, (uint64_t *)&v4);
  if ((_DWORD)v1)
    return v1;
  if (*v4 == 0xFFFF)
    return 101;
  if (off_1009853A8)
  {
    v1 = off_1009853A8();
    if (!(_DWORD)v1)
      return v1;
  }
  else
  {
    v1 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v1);
    v3 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v1;
}

uint64_t sub_1001F9F84(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  NSObject *v7;

  if (sub_10019AC00(a1))
  {
    if (off_100985358)
    {
      v6 = off_100985358(a1, a2, a3);
      if (!(_DWORD)v6)
        return v6;
    }
    else
    {
      v6 = 3601;
    }
  }
  else
  {
    v6 = 122;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v6);
    v7 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v6;
}

uint64_t sub_1001FA03C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985360)
  {
    v0 = off_100985360();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FA0C4()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985368)
  {
    v0 = off_100985368();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FA14C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985370)
  {
    v0 = off_100985370();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FA1D4()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985378)
  {
    v0 = off_100985378();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FA25C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  NSObject *v8;

  if (!sub_10019AC00(a1))
    return 122;
  if (*(unsigned __int16 *)(a1 + 94) == (_DWORD)a2)
    return 3603;
  *(_WORD *)(a1 + 94) = a2;
  if (off_1009853B8)
  {
    v6 = off_1009853B8(a1, a2, a3);
    if (!(_DWORD)v6)
      return v6;
  }
  else
  {
    v6 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v6);
    v8 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v6;
}

uint64_t sub_1001FA328(uint64_t a1, unsigned __int16 a2)
{
  uint64_t v2;
  NSObject *v3;

  if (off_100985670)
  {
    v2 = off_100985670(a1, a2);
    if (!(_DWORD)v2)
      return v2;
  }
  else
  {
    v2 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v2);
    v3 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v2;
}

uint64_t sub_1001FA3B4()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985678)
  {
    v0 = off_100985678();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FA43C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985380)
  {
    v0 = off_100985380();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FA4C4()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985388)
  {
    v0 = off_100985388();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FA54C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985390)
  {
    v0 = off_100985390();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FA5D4()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985398)
  {
    v0 = off_100985398();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FA65C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009853C0)
  {
    v0 = off_1009853C0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FA6E4()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009853C8)
  {
    v0 = off_1009853C8();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FA76C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009853D0)
  {
    v0 = off_1009853D0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FA7F4()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009853D8)
  {
    v0 = off_1009853D8();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FA87C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009853E0)
  {
    v0 = off_1009853E0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FA904()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009853E8)
  {
    v0 = off_1009853E8();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FA98C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009853F0)
  {
    v0 = off_1009853F0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FAA14()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009853F8)
  {
    v0 = off_1009853F8();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FAA9C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985400)
  {
    v0 = off_100985400();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FAB24()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985408)
  {
    v0 = off_100985408();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FABAC()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985410)
  {
    v0 = off_100985410();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FAC34()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985418)
  {
    v0 = off_100985418();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FACBC()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985420)
  {
    v0 = off_100985420();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FAD44()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985428)
  {
    v0 = off_100985428();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FADCC()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985430)
  {
    v0 = off_100985430();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FAE54()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985438)
  {
    v0 = off_100985438();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FAEDC()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985440)
  {
    v0 = off_100985440();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FAF64()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985448)
  {
    v0 = off_100985448();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FAFEC()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985450)
  {
    v0 = off_100985450();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FB074()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985458)
  {
    v0 = off_100985458();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FB0FC()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985460)
  {
    v0 = off_100985460();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FB184(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  NSObject *v3;

  if (off_100985468)
  {
    v2 = off_100985468(a1, a2);
    if (!(_DWORD)v2)
      return v2;
  }
  else
  {
    v2 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v2);
    v3 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v2;
}

uint64_t sub_1001FB23C(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  NSObject *v3;

  if (off_100985470)
  {
    v2 = off_100985470(a1, a2);
    if (!(_DWORD)v2)
      return v2;
  }
  else
  {
    v2 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v2);
    v3 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v2;
}

uint64_t sub_1001FB2DC(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  NSObject *v3;

  if (off_100985478)
  {
    v2 = off_100985478(a1, a2);
    if (!(_DWORD)v2)
      return v2;
  }
  else
  {
    v2 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v2);
    v3 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v2;
}

uint64_t sub_1001FB384(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  NSObject *v3;

  if (off_100985480)
  {
    v2 = off_100985480(a1, a2);
    if (!(_DWORD)v2)
      return v2;
  }
  else
  {
    v2 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v2);
    v3 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v2;
}

uint64_t sub_1001FB43C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985488)
  {
    v0 = off_100985488();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FB4C4()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985490)
  {
    v0 = off_100985490();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FB54C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985498)
  {
    v0 = off_100985498();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FB5D4()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009854A0)
  {
    v0 = off_1009854A0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FB65C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009854A8)
  {
    v0 = off_1009854A8();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FB6E4()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009854B0)
  {
    v0 = off_1009854B0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FB76C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009854D8)
  {
    v0 = off_1009854D8();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FB7F4()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009854E0)
  {
    v0 = off_1009854E0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FB87C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985508)
  {
    v0 = off_100985508();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FB904()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985510)
  {
    v0 = off_100985510();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FB98C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985518)
  {
    v0 = off_100985518();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FBA14()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985660)
  {
    v0 = off_100985660();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FBA9C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009857C0)
  {
    v0 = off_1009857C0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FBB24()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985520)
  {
    v0 = off_100985520();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FBBAC()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985618)
  {
    v0 = off_100985618();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FBC34(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;

  if (off_100985538)
  {
    v1 = off_100985538(a1);
    if (!(_DWORD)v1)
      return v1;
  }
  else
  {
    v1 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v1);
    v2 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v1;
}

uint64_t sub_1001FBCC4()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985540)
  {
    v0 = off_100985540();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FBD4C(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  NSObject *v3;

  if (off_100985550)
  {
    v2 = off_100985550(a1, a2);
    if (!(_DWORD)v2)
      return v2;
  }
  else
  {
    v2 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v2);
    v3 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v2;
}

uint64_t sub_1001FBDE4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  NSObject *v8;

  if (off_100985558)
  {
    v7 = off_100985558(a1, a2, a3, a4, a5, a6, a7);
    if (!(_DWORD)v7)
      return v7;
  }
  else
  {
    v7 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v7);
    v8 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v7;
}

uint64_t sub_1001FBE9C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985560)
  {
    v0 = off_100985560();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FBF24(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  NSObject *v4;

  if (off_100985568)
  {
    v3 = off_100985568(a1, a2, a3);
    if (!(_DWORD)v3)
      return v3;
  }
  else
  {
    v3 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v3);
    v4 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v3;
}

uint64_t sub_1001FBFC4()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985578)
  {
    v0 = off_100985578();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FC04C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985588)
  {
    v0 = off_100985588();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FC0D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  NSObject *v5;

  if (off_100985580)
  {
    v4 = off_100985580(a1, a2, a3, a4);
    if (!(_DWORD)v4)
      return v4;
  }
  else
  {
    v4 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v4);
    v5 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v4;
}

uint64_t sub_1001FC184()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985598)
  {
    v0 = off_100985598();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FC20C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009855A0)
  {
    v0 = off_1009855A0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FC294()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009855A8)
  {
    v0 = off_1009855A8();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FC31C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009855B0)
  {
    v0 = off_1009855B0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FC3A4()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009855B8)
  {
    v0 = off_1009855B8();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FC42C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009855C0)
  {
    v0 = off_1009855C0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FC4B4()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009855C8)
  {
    v0 = off_1009855C8();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FC53C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009855D0)
  {
    v0 = off_1009855D0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FC5C4()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009855D8)
  {
    v0 = off_1009855D8();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FC64C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009855E0)
  {
    v0 = off_1009855E0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FC6D4(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4;
  NSObject *v5;

  if (off_1009855E8)
  {
    v4 = off_1009855E8(a1, a2, a3);
    if (!(_DWORD)v4)
      goto LABEL_8;
  }
  else
  {
    v4 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v4);
    v5 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
LABEL_8:
  free(a3);
  return v4;
}

uint64_t sub_1001FC774()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009855F0)
  {
    v0 = off_1009855F0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FC7FC()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009855F8)
  {
    v0 = off_1009855F8();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FC884()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985600)
  {
    v0 = off_100985600();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FC90C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009856E8)
  {
    v0 = off_1009856E8();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FC994()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985640)
  {
    v0 = off_100985640();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FCA1C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985688)
  {
    v0 = off_100985688();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FCAA4()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985690)
  {
    v0 = off_100985690();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FCB2C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985698)
  {
    v0 = off_100985698();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FCBB4()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009856A0)
  {
    v0 = off_1009856A0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FCC3C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009856A8)
  {
    v0 = off_1009856A8();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FCCC4()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009856B0)
  {
    v0 = off_1009856B0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FCD4C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009856B8)
  {
    v0 = off_1009856B8();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FCDD4()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009856C0)
  {
    v0 = off_1009856C0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FCE5C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009856C8)
  {
    v0 = off_1009856C8();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FCEE4()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985680)
  {
    v0 = off_100985680();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FCF6C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009856D8)
  {
    v0 = off_1009856D8();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FCFF4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  NSObject *v6;

  if (off_100985700)
  {
    v5 = off_100985700(a1, a2, a3, a4, a5);
    if (!(_DWORD)v5)
      return v5;
  }
  else
  {
    v5 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v5);
    v6 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v5;
}

uint64_t sub_1001FD0CC()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009856D0)
  {
    v0 = off_1009856D0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FD154()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009853A0)
  {
    v0 = off_1009853A0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FD1DC()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009854F0)
  {
    v0 = off_1009854F0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FD264()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985608)
  {
    v0 = off_100985608();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FD2EC()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985620)
  {
    v0 = off_100985620();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FD374()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985628)
  {
    v0 = off_100985628();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FD3FC()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009853B0)
  {
    v0 = off_1009853B0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FD484()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985630)
  {
    v0 = off_100985630();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FD50C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985638)
  {
    v0 = off_100985638();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FD594(_BYTE *a1, uint64_t a2, uint64_t a3)
{
  int v3;
  const char *v5;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;

  v3 = a3;
  if (a1[30] == (_DWORD)a3)
  {
    if (sub_10005549C())
    {
      v5 = "enabled";
      if (!v3)
        v5 = "disabled";
      sub_100054530("Phy stats for handle %p is already %s", a1, v5);
      v6 = sub_1000544A0(0x54u);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 408;
  }
  else
  {
    if (off_1009854C8)
    {
      v7 = off_1009854C8(a1, a2, a3);
      if (!(_DWORD)v7)
      {
        a1[30] = v3 != 0;
        return v7;
      }
    }
    else
    {
      v7 = 3601;
    }
    if (sub_10005549C())
    {
      sub_100054530("VSC PhyStatsEnable failed %!", v7);
      v8 = sub_1000544A0(0x54u);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  return v7;
}

uint64_t sub_1001FD6B0(_BYTE *a1, uint64_t a2, uint64_t a3)
{
  int v3;
  const char *v5;
  const char *v6;
  NSObject *v7;
  uint64_t v8;
  NSObject *v9;

  v3 = a3;
  if (a1[31] == (_DWORD)a3)
  {
    if (sub_10005549C())
    {
      v5 = "disable";
      if (v3 == 2)
        v5 = "flush";
      if ((v3 & 0xFFFFFFFB) == 1)
        v6 = "enable";
      else
        v6 = v5;
      sub_100054530("State of Phy stats for handle %p is already %s", a1, v6);
      v7 = sub_1000544A0(0x54u);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 408;
  }
  else
  {
    if (off_1009854C8)
    {
      v8 = off_1009854C8(a1, a2, a3);
      if (!(_DWORD)v8)
      {
        a1[31] = v3;
        a1[30] = v3 != 0;
        return v8;
      }
    }
    else
    {
      v8 = 3601;
    }
    if (sub_10005549C())
    {
      sub_100054530("VSC PhyStatsEnable failed %!", v8);
      v9 = sub_1000544A0(0x54u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  return v8;
}

uint64_t sub_1001FD7E4()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985668)
  {
    v0 = off_100985668();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FD86C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985000)
  {
    v0 = off_100985000();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FD8F4()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985008)
  {
    v0 = off_100985008();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FD97C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985610)
  {
    v0 = off_100985610();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FDA04()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009854D0)
  {
    v0 = off_1009854D0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FDA8C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985720)
  {
    v0 = off_100985720();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FDB14()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009854E8)
  {
    v0 = off_1009854E8();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FDB9C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009854F8)
  {
    v0 = off_1009854F8();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FDC24()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985500)
  {
    v0 = off_100985500();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FDCAC()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985220)
  {
    v0 = off_100985220();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FDD34()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985528)
  {
    v0 = off_100985528();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FDE00()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985530)
  {
    v0 = off_100985530();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FDE88()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009856F0)
  {
    v0 = off_1009856F0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FDF10()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009856F8)
  {
    v0 = off_1009856F8();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FDF98()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985728)
  {
    v0 = off_100985728();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FE020(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  NSObject *v3;

  if (off_100985650)
  {
    v2 = off_100985650(a1, a2);
    if (!(_DWORD)v2)
      return v2;
  }
  else
  {
    v2 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v2);
    v3 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v2;
}

uint64_t sub_1001FE0C0()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985658)
  {
    v0 = off_100985658();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FE148(unsigned int a1, __int16 a2, uint64_t a3, unsigned int a4)
{
  uint64_t v4;
  NSObject *v5;

  if ((dword_100984E00 - 1) > 0x7CE || (v4 = 101, (a2 & 0x8000) == 0) && a1 <= 4 && a3 && a4 <= 0xE6)
  {
    if (off_100985730)
    {
      v4 = off_100985730();
      if (!(_DWORD)v4)
        return v4;
    }
    else
    {
      v4 = 3601;
    }
    if (sub_10005549C())
    {
      sub_100054530("VSC failed %!", v4);
      v5 = sub_1000544A0(0x54u);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  return v4;
}

uint64_t sub_1001FE200(uint64_t a1, int a2)
{
  uint64_t v2;
  NSObject *v3;

  if ((dword_100984E00 - 1) <= 0x7CE && (!a1 || a2 != 250 && a2 != 210))
    return 101;
  if (off_100985738)
  {
    v2 = off_100985738();
    if (!(_DWORD)v2)
      return v2;
  }
  else
  {
    v2 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v2);
    v3 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v2;
}

uint64_t sub_1001FE2B8(unsigned int a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  NSObject *v4;

  if ((dword_100984E00 - 1) > 0x7CE || (v3 = 101, a1 <= 0x18) && a2 && a3 <= 0xCF)
  {
    if (off_100985740)
    {
      v3 = off_100985740();
      if (!(_DWORD)v3)
        return v3;
    }
    else
    {
      v3 = 3601;
    }
    if (sub_10005549C())
    {
      sub_100054530("VSC failed %!", v3);
      v4 = sub_1000544A0(0x54u);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  return v3;
}

uint64_t sub_1001FE36C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985750)
  {
    v0 = off_100985750();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FE3F4()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985780)
  {
    v0 = off_100985780();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FE47C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985758)
  {
    v0 = off_100985758();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FE504()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985788)
  {
    v0 = off_100985788();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FE58C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985760)
  {
    v0 = off_100985760();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FE614()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985768)
  {
    v0 = off_100985768();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FE69C()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985770)
  {
    v0 = off_100985770();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FE724()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985778)
  {
    v0 = off_100985778();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FE7AC(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;

  if (!a1)
    return 101;
  if (off_100985748)
  {
    v1 = off_100985748();
    if (!(_DWORD)v1)
      return v1;
  }
  else
  {
    v1 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v1);
    v2 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v1;
}

uint64_t sub_1001FE840()
{
  uint64_t v0;
  NSObject *v1;

  if (off_100985790)
  {
    v0 = off_100985790();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FE8C8(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;

  if (!a1)
    return 101;
  if (off_100985798)
  {
    v1 = off_100985798();
    if (!(_DWORD)v1)
      return v1;
  }
  else
  {
    v1 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v1);
    v2 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v1;
}

uint64_t sub_1001FE95C(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;

  if (!a1)
    return 101;
  if (off_1009857A0)
  {
    v1 = off_1009857A0();
    if (!(_DWORD)v1)
      return v1;
  }
  else
  {
    v1 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v1);
    v2 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v1;
}

uint64_t sub_1001FE9F0()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009857A8)
  {
    v0 = off_1009857A8();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FEA78(uint64_t a1)
{
  uint64_t v1;
  NSObject *v3;

  if (!a1 || !*(_QWORD *)(a1 + 8) || !*(_QWORD *)(a1 + 32))
    return 101;
  if (off_1009857F0)
  {
    v1 = off_1009857F0();
    if (!(_DWORD)v1)
      return v1;
  }
  else
  {
    v1 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("%s failed %!", "BT_VSC_AddToFilterAcceptListUnified", v1);
    v3 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v1;
}

uint64_t sub_1001FEB20()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009857B0)
  {
    v0 = off_1009857B0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FEBA8(unsigned int a1, uint64_t a2)
{
  uint64_t v2;
  NSObject *v3;

  v2 = 101;
  if (a1 <= 0x1E && a2)
  {
    if (off_1009857B8)
    {
      v2 = off_1009857B8();
      if (!(_DWORD)v2)
        return v2;
    }
    else
    {
      v2 = 3601;
    }
    if (sub_10005549C())
    {
      sub_100054530("VSC failed %!", v2);
      v3 = sub_1000544A0(0x54u);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  return v2;
}

uint64_t sub_1001FEC40(int a1, const void *a2, unsigned int a3, uint64_t (*a4)(_QWORD, _QWORD, _QWORD, _QWORD), uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  NSObject *v9;
  uint64_t v11;

  v8 = sub_100196B34(a1, a2, a3, a4, a5, a6, a7, a8, a5, v11);
  if ((_DWORD)v8)
  {
    if (sub_10005549C())
    {
      sub_100054530("%s failed %!", "BT_VSC_sendRawHCIcmd", v8);
      v9 = sub_1000544A0(0x54u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  return v8;
}

uint64_t sub_1001FECC0()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009857C8)
  {
    v0 = off_1009857C8();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FED48()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009857D0)
  {
    v0 = off_1009857D0();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FEDD0()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009857D8)
  {
    v0 = off_1009857D8();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FEE58()
{
  uint64_t v0;
  NSObject *v1;

  if (off_1009857F8)
  {
    v0 = off_1009857F8();
    if (!(_DWORD)v0)
      return v0;
  }
  else
  {
    v0 = 3601;
  }
  if (sub_10005549C())
  {
    sub_100054530("VSC failed %!", v0);
    v1 = sub_1000544A0(0x54u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v0;
}

uint64_t sub_1001FEEE0()
{
  byte_1009859D8 = 0;
  qword_1009859E8 = 0;
  return 0;
}

uint64_t sub_1001FEEF8(char *a1)
{
  int v2;
  char v3;

  *(_DWORD *)a1 = 0;
  if (sub_1001EEE1C(2))
    *a1 |= 1u;
  if (sub_1001EEE1C(1))
    *a1 |= 2u;
  if (sub_1001EEE1C(3))
    *a1 |= 8u;
  if (sub_1001EEE1C(4))
    *a1 |= 0x10u;
  v2 = sub_1001EEEC8();
  v3 = *a1;
  if (v2)
    v3 = *a1 | 0x20;
  *a1 = v3 | 0x80;
  a1[1] |= 2u;
  return 0;
}

uint64_t sub_1001FEFA4()
{
  unsigned __int8 v0;

  if (((byte_1009859D8 + 1) & 0x100) != 0)
    v0 = byte_1009859D8 + 2;
  else
    v0 = byte_1009859D8 + 1;
  byte_1009859D8 = v0;
  return v0;
}

uint64_t sub_1001FEFC8(int *a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  const void *v6[2];
  int *v7;

  v6[1] = &v7;
  v7 = a1;
  v6[0] = (const void *)8;
  v3 = sub_1001E3CCC(a1);
  sub_100049F6C(*(unsigned int *)(v3 + 84));
  *(_DWORD *)(sub_1001E3CCC(v7) + 84) = 0;
  v4 = sub_1001E3CCC(v7);
  return sub_10004A9EC((uint64_t)sub_1001FF038, v6, a2, (int *)(v4 + 84));
}

void sub_1001FF038(uint64_t a1)
{
  int *v1;
  NSObject *v2;
  NSObject *v3;
  NSObject *v4;
  NSObject *v5;
  NSObject *v6;

  v1 = **(int ***)(a1 + 8);
  if (*v1)
  {
    *(_DWORD *)(sub_1001E3CCC(**(int ***)(a1 + 8)) + 84) = 0;
    switch(*(_BYTE *)(sub_1001E3CCC(v1) + 16))
    {
      case 1:
        if (!sub_10005549C())
          goto LABEL_18;
        sub_100054530("Timeout waiting for CONNECT_RSP");
        v4 = sub_1000544A0(0x2Fu);
        if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
          goto LABEL_18;
        goto LABEL_17;
      case 3:
      case 5:
        if (sub_10005549C())
        {
          sub_100054530("Timeout waiting for CONFIG_RSP");
          v2 = sub_1000544A0(0x2Fu);
          if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
            goto LABEL_17;
        }
        goto LABEL_18;
      case 6:
        if (sub_10005549C())
        {
          sub_100054530("Timeout waiting for DISCONNECT_RSP");
          v6 = sub_1000544A0(0x2Fu);
          if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
LABEL_17:
            sub_1006CE7A4();
        }
LABEL_18:
        sub_1001DCE10((uint64_t)v1, 559);
        break;
      default:
        if (sub_10005549C())
        {
          sub_100054530("Timeout for unknown message type!");
          v5 = sub_1000544A0(0x2Fu);
          if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
            goto LABEL_8;
        }
        break;
    }
  }
  else if (sub_10005549C())
  {
    sub_100054530("Timer expired, but channel %p is not used any more.", v1);
    v3 = sub_1000544A0(0x2Fu);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
LABEL_8:
      sub_1006CE7A4();
  }
}

uint64_t sub_1001FF1F4(int *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = sub_1001E3CCC(a1);
  sub_100049F6C(*(unsigned int *)(v2 + 84));
  v4 = v3;
  *(_DWORD *)(sub_1001E3CCC(a1) + 84) = 0;
  return v4;
}

uint64_t sub_1001FF230(_BYTE *a1, unsigned int a2, int *a3, _BYTE *a4, char a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t result;
  int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int *v18;
  unsigned int *v19;
  uint64_t v20;
  uint64_t *v21;
  _BYTE *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char **v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char v31;
  char **v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char v38;
  unsigned __int16 v39;
  unsigned __int16 v40;
  unsigned __int16 v41;
  unsigned __int16 v42;
  uint64_t *v43;
  const void *v44;
  int v45;
  char *v46;
  uint64_t v47;
  int v48;
  uint64_t *v49;
  uint64_t v50;
  uint64_t v51;
  char **v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  char v57;
  char **v58;
  char *v59;
  unsigned int v60;
  char v61;
  char **v62;
  char *v63;
  unsigned int v64;
  char v65;
  uint64_t *v66;
  _BYTE *v67;
  char v68;
  unsigned __int16 v69;
  uint64_t *v70;
  _BYTE *v71;
  char v72;
  unsigned __int16 v73;
  uint64_t *v74;
  _BYTE *v75;
  char v76;
  unsigned int v77;
  uint64_t v78;
  int *v79;
  char v80;
  _BYTE *v81;
  void *ptr;
  uint64_t v83;
  uint64_t *v84;

  v83 = 0;
  v84 = 0;
  ptr = 0;
  result = sub_10020081C((uint64_t *)&ptr, 107, a2, a5);
  if ((_DWORD)result)
    return result;
  v79 = a3;
  v80 = a5;
  v81 = a4;
  v15 = 0;
  LOBYTE(v16) = 0;
  LOBYTE(v17) = 0;
  v84 = &a9;
  while (2)
  {
    switch(*a1)
    {
      case 'a':
        v18 = (unsigned int *)v84++;
        if (HIBYTE(v83))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 626, "OI_STATUS OI_SendGeneric2(char *, uint8_t, L2CAPChannel *, OI_HCI_CONNECTION_HANDLE, unsigned int, ...)");
LABEL_157:
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
        }
        if (WORD1(v83) - WORD2(v83) <= 1 || BYTE6(v83) != 2)
          goto LABEL_157;
        v16 = *v18;
        *((_BYTE *)ptr + WORD2(v83)) = *v18;
        v17 = v16 >> 8;
        *((_BYTE *)ptr + WORD2(v83) + 1) = BYTE1(v16);
        WORD2(v83) += 2;
        v15 += 2;
        goto LABEL_136;
      case 'b':
      case 'e':
      case 'g':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'l':
      case 'n':
      case 'p':
      case 'q':
        goto LABEL_136;
      case 'c':
        v19 = (unsigned int *)v84++;
        if (HIBYTE(v83))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 633, "OI_STATUS OI_SendGeneric2(char *, uint8_t, L2CAPChannel *, OI_HCI_CONNECTION_HANDLE, unsigned int, ...)");
LABEL_159:
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
        }
        v20 = WORD2(v83);
        if (WORD1(v83) <= WORD2(v83) || BYTE6(v83) != 2)
          goto LABEL_159;
        LOBYTE(v17) = 0;
        v16 = *v19;
        ++WORD2(v83);
        *((_BYTE *)ptr + v20) = v16;
        ++v15;
        goto LABEL_136;
      case 'd':
        v43 = v84++;
        v44 = (const void *)*v43;
        v84 = v43 + 2;
        v45 = *((_DWORD *)v43 + 2);
        v46 = (char *)ptr;
        v47 = WORD2(v83);
        if (HIBYTE(v83))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 723, "OI_STATUS OI_SendGeneric2(char *, uint8_t, L2CAPChannel *, OI_HCI_CONNECTION_HANDLE, unsigned int, ...)");
          v48 = 0;
        }
        else
        {
          v48 = WORD1(v83) - WORD2(v83);
        }
        if (v48 < (unsigned __int16)v45 || BYTE6(v83) != 2)
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
        v15 += v45;
        memmove(&v46[v47], v44, (unsigned __int16)v45);
        WORD2(v83) += v45;
        goto LABEL_136;
      case 'f':
        v21 = v84++;
        v22 = (_BYTE *)*v21;
        if (!v22)
          goto LABEL_136;
        if (HIBYTE(v83))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 659, "OI_STATUS OI_SendGeneric2(char *, uint8_t, L2CAPChannel *, OI_HCI_CONNECTION_HANDLE, unsigned int, ...)");
LABEL_162:
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
        }
        v23 = WORD2(v83);
        if (WORD1(v83) <= WORD2(v83) || BYTE6(v83) != 2)
          goto LABEL_162;
        ++WORD2(v83);
        *((_BYTE *)ptr + v23) = 2;
        if (HIBYTE(v83))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 661, "OI_STATUS OI_SendGeneric2(char *, uint8_t, L2CAPChannel *, OI_HCI_CONNECTION_HANDLE, unsigned int, ...)");
LABEL_164:
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
        }
        v24 = WORD2(v83);
        if (WORD1(v83) <= WORD2(v83) || BYTE6(v83) != 2)
          goto LABEL_164;
        ++WORD2(v83);
        *((_BYTE *)ptr + v24) = 2;
        if (HIBYTE(v83))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 663, "OI_STATUS OI_SendGeneric2(char *, uint8_t, L2CAPChannel *, OI_HCI_CONNECTION_HANDLE, unsigned int, ...)");
LABEL_166:
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
        }
        v25 = WORD2(v83);
        if (WORD1(v83) - WORD2(v83) <= 1 || BYTE6(v83) != 2)
          goto LABEL_166;
        goto LABEL_75;
      case 'm':
        v49 = v84++;
        v22 = (_BYTE *)*v49;
        if (!v22)
          goto LABEL_136;
        if (HIBYTE(v83))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 643, "OI_STATUS OI_SendGeneric2(char *, uint8_t, L2CAPChannel *, OI_HCI_CONNECTION_HANDLE, unsigned int, ...)");
LABEL_192:
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
        }
        v50 = WORD2(v83);
        if (WORD1(v83) <= WORD2(v83) || BYTE6(v83) != 2)
          goto LABEL_192;
        ++WORD2(v83);
        *((_BYTE *)ptr + v50) = 1;
        if (HIBYTE(v83))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 645, "OI_STATUS OI_SendGeneric2(char *, uint8_t, L2CAPChannel *, OI_HCI_CONNECTION_HANDLE, unsigned int, ...)");
LABEL_194:
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
        }
        v51 = WORD2(v83);
        if (WORD1(v83) <= WORD2(v83) || BYTE6(v83) != 2)
          goto LABEL_194;
        ++WORD2(v83);
        *((_BYTE *)ptr + v51) = 2;
        if (HIBYTE(v83))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 647, "OI_STATUS OI_SendGeneric2(char *, uint8_t, L2CAPChannel *, OI_HCI_CONNECTION_HANDLE, unsigned int, ...)");
LABEL_196:
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
        }
        v25 = WORD2(v83);
        if (WORD1(v83) - WORD2(v83) <= 1 || BYTE6(v83) != 2)
          goto LABEL_196;
LABEL_75:
        *((_BYTE *)ptr + v25) = *v22;
        *((_BYTE *)ptr + WORD2(v83) + 1) = v22[1];
        WORD2(v83) += 2;
        v15 += 4;
        goto LABEL_136;
      case 'o':
        v26 = (char **)v84++;
        v27 = *v26;
        if (!v27)
          goto LABEL_136;
        if (HIBYTE(v83))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 756, "OI_STATUS OI_SendGeneric2(char *, uint8_t, L2CAPChannel *, OI_HCI_CONNECTION_HANDLE, unsigned int, ...)");
LABEL_168:
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
        }
        v28 = WORD2(v83);
        if (WORD1(v83) <= WORD2(v83) || BYTE6(v83) != 2)
          goto LABEL_168;
        ++WORD2(v83);
        *((_BYTE *)ptr + v28) = 5;
        if (HIBYTE(v83))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 758, "OI_STATUS OI_SendGeneric2(char *, uint8_t, L2CAPChannel *, OI_HCI_CONNECTION_HANDLE, unsigned int, ...)");
LABEL_170:
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
        }
        v29 = WORD2(v83);
        if (WORD1(v83) <= WORD2(v83) || BYTE6(v83) != 2)
          goto LABEL_170;
        ++WORD2(v83);
        *((_BYTE *)ptr + v29) = 1;
        if (HIBYTE(v83))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 760, "OI_STATUS OI_SendGeneric2(char *, uint8_t, L2CAPChannel *, OI_HCI_CONNECTION_HANDLE, unsigned int, ...)");
LABEL_172:
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
        }
        v30 = WORD2(v83);
        if (WORD1(v83) <= WORD2(v83) || BYTE6(v83) != 2)
          goto LABEL_172;
        v31 = *v27;
        ++WORD2(v83);
        *((_BYTE *)ptr + v30) = v31;
        v15 += 3;
        goto LABEL_136;
      case 'r':
        v52 = (char **)v84++;
        v53 = *v52;
        if (!v53)
          goto LABEL_136;
        if (HIBYTE(v83))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 675, "OI_STATUS OI_SendGeneric2(char *, uint8_t, L2CAPChannel *, OI_HCI_CONNECTION_HANDLE, unsigned int, ...)");
LABEL_198:
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
        }
        v54 = WORD2(v83);
        if (WORD1(v83) <= WORD2(v83) || BYTE6(v83) != 2)
          goto LABEL_198;
        ++WORD2(v83);
        *((_BYTE *)ptr + v54) = 4;
        if (HIBYTE(v83))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 677, "OI_STATUS OI_SendGeneric2(char *, uint8_t, L2CAPChannel *, OI_HCI_CONNECTION_HANDLE, unsigned int, ...)");
LABEL_200:
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
        }
        v55 = WORD2(v83);
        if (WORD1(v83) <= WORD2(v83) || BYTE6(v83) != 2)
          goto LABEL_200;
        ++WORD2(v83);
        *((_BYTE *)ptr + v55) = 9;
        if (HIBYTE(v83))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 679, "OI_STATUS OI_SendGeneric2(char *, uint8_t, L2CAPChannel *, OI_HCI_CONNECTION_HANDLE, unsigned int, ...)");
LABEL_202:
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
        }
        v56 = WORD2(v83);
        if (WORD1(v83) <= WORD2(v83) || BYTE6(v83) != 2)
          goto LABEL_202;
        v57 = *v53;
        ++WORD2(v83);
        *((_BYTE *)ptr + v56) = v57;
        v58 = (char **)v84++;
        v59 = *v58;
        if (*v58)
        {
          if (HIBYTE(v83))
          {
            sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 684, "OI_STATUS OI_SendGeneric2(char *, uint8_t, L2CAPChannel *, OI_HCI_CONNECTION_HANDLE, unsigned int, ...)");
LABEL_204:
            sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
          }
          v60 = WORD2(v83);
          if (WORD1(v83) <= WORD2(v83) || BYTE6(v83) != 2)
            goto LABEL_204;
          v61 = *v59;
        }
        else
        {
          if (HIBYTE(v83))
          {
            sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 686, "OI_STATUS OI_SendGeneric2(char *, uint8_t, L2CAPChannel *, OI_HCI_CONNECTION_HANDLE, unsigned int, ...)");
LABEL_214:
            sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
          }
          v60 = WORD2(v83);
          if (WORD1(v83) <= WORD2(v83))
            goto LABEL_214;
          v61 = v16;
          if (BYTE6(v83) != 2)
            goto LABEL_214;
        }
        WORD2(v83) = v60 + 1;
        *((_BYTE *)ptr + v60) = v61;
        v62 = (char **)v84++;
        v63 = *v62;
        if (*v62)
        {
          if (HIBYTE(v83))
          {
            sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 690, "OI_STATUS OI_SendGeneric2(char *, uint8_t, L2CAPChannel *, OI_HCI_CONNECTION_HANDLE, unsigned int, ...)");
LABEL_206:
            sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
          }
          v64 = WORD2(v83);
          if (WORD1(v83) <= WORD2(v83) || BYTE6(v83) != 2)
            goto LABEL_206;
          v65 = *v63;
        }
        else
        {
          if (HIBYTE(v83))
          {
            sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 692, "OI_STATUS OI_SendGeneric2(char *, uint8_t, L2CAPChannel *, OI_HCI_CONNECTION_HANDLE, unsigned int, ...)");
LABEL_216:
            sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
          }
          v64 = WORD2(v83);
          if (WORD1(v83) <= WORD2(v83))
            goto LABEL_216;
          v65 = v16;
          if (BYTE6(v83) != 2)
            goto LABEL_216;
        }
        WORD2(v83) = v64 + 1;
        *((_BYTE *)ptr + v64) = v65;
        v66 = v84++;
        v67 = (_BYTE *)*v66;
        if (v67)
        {
          if (HIBYTE(v83))
          {
            sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 697, "OI_STATUS OI_SendGeneric2(char *, uint8_t, L2CAPChannel *, OI_HCI_CONNECTION_HANDLE, unsigned int, ...)");
LABEL_208:
            sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
          }
          if (WORD1(v83) - WORD2(v83) <= 1 || BYTE6(v83) != 2)
            goto LABEL_208;
          *((_BYTE *)ptr + WORD2(v83)) = *v67;
          v68 = v67[1];
        }
        else
        {
          if (HIBYTE(v83))
          {
            sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 699, "OI_STATUS OI_SendGeneric2(char *, uint8_t, L2CAPChannel *, OI_HCI_CONNECTION_HANDLE, unsigned int, ...)");
LABEL_218:
            sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
          }
          if (WORD1(v83) - WORD2(v83) <= 1 || BYTE6(v83) != 2)
            goto LABEL_218;
          *((_BYTE *)ptr + WORD2(v83)) = v16;
          v68 = v17;
        }
        *((_BYTE *)ptr + WORD2(v83) + 1) = v68;
        v69 = WORD2(v83) + 2;
        WORD2(v83) += 2;
        v70 = v84++;
        v71 = (_BYTE *)*v70;
        if (v71)
        {
          if (HIBYTE(v83))
          {
            sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 703, "OI_STATUS OI_SendGeneric2(char *, uint8_t, L2CAPChannel *, OI_HCI_CONNECTION_HANDLE, unsigned int, ...)");
LABEL_210:
            sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
          }
          if (WORD1(v83) - v69 <= 1 || BYTE6(v83) != 2)
            goto LABEL_210;
          *((_BYTE *)ptr + v69) = *v71;
          v72 = v71[1];
        }
        else
        {
          if (HIBYTE(v83))
          {
            sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 705, "OI_STATUS OI_SendGeneric2(char *, uint8_t, L2CAPChannel *, OI_HCI_CONNECTION_HANDLE, unsigned int, ...)");
LABEL_220:
            sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
          }
          if (WORD1(v83) - v69 <= 1 || BYTE6(v83) != 2)
            goto LABEL_220;
          *((_BYTE *)ptr + v69) = v16;
          v72 = v17;
        }
        *((_BYTE *)ptr + WORD2(v83) + 1) = v72;
        v73 = WORD2(v83) + 2;
        WORD2(v83) += 2;
        v74 = v84++;
        v75 = (_BYTE *)*v74;
        if (v75)
        {
          if (HIBYTE(v83))
          {
            sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 709, "OI_STATUS OI_SendGeneric2(char *, uint8_t, L2CAPChannel *, OI_HCI_CONNECTION_HANDLE, unsigned int, ...)");
LABEL_212:
            sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
          }
          if (WORD1(v83) - v73 <= 1 || BYTE6(v83) != 2)
            goto LABEL_212;
          *((_BYTE *)ptr + v73) = *v75;
          v76 = v75[1];
        }
        else
        {
          if (HIBYTE(v83))
          {
            sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 711, "OI_STATUS OI_SendGeneric2(char *, uint8_t, L2CAPChannel *, OI_HCI_CONNECTION_HANDLE, unsigned int, ...)");
LABEL_222:
            sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
          }
          if (WORD1(v83) - v73 <= 1 || BYTE6(v83) != 2)
            goto LABEL_222;
          *((_BYTE *)ptr + v73) = v16;
          v76 = v17;
        }
        *((_BYTE *)ptr + WORD2(v83) + 1) = v76;
        WORD2(v83) += 2;
        v15 += 11;
        goto LABEL_136;
      case 's':
        v32 = (char **)v84++;
        v33 = *v32;
        if (!v33)
          goto LABEL_136;
        if (HIBYTE(v83))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 732, "OI_STATUS OI_SendGeneric2(char *, uint8_t, L2CAPChannel *, OI_HCI_CONNECTION_HANDLE, unsigned int, ...)");
LABEL_174:
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
        }
        v34 = WORD2(v83);
        if (WORD1(v83) <= WORD2(v83) || BYTE6(v83) != 2)
          goto LABEL_174;
        ++WORD2(v83);
        *((_BYTE *)ptr + v34) = 3;
        if (HIBYTE(v83))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 734, "OI_STATUS OI_SendGeneric2(char *, uint8_t, L2CAPChannel *, OI_HCI_CONNECTION_HANDLE, unsigned int, ...)");
LABEL_176:
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
        }
        v35 = WORD2(v83);
        if (WORD1(v83) <= WORD2(v83) || BYTE6(v83) != 2)
          goto LABEL_176;
        ++WORD2(v83);
        *((_BYTE *)ptr + v35) = 22;
        if (HIBYTE(v83))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 736, "OI_STATUS OI_SendGeneric2(char *, uint8_t, L2CAPChannel *, OI_HCI_CONNECTION_HANDLE, unsigned int, ...)");
LABEL_178:
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
        }
        v36 = WORD2(v83);
        if (WORD1(v83) <= WORD2(v83) || BYTE6(v83) != 2)
          goto LABEL_178;
        ++WORD2(v83);
        *((_BYTE *)ptr + v36) = 0;
        if (HIBYTE(v83))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 738, "OI_STATUS OI_SendGeneric2(char *, uint8_t, L2CAPChannel *, OI_HCI_CONNECTION_HANDLE, unsigned int, ...)");
LABEL_180:
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
        }
        v37 = WORD2(v83);
        if (WORD1(v83) <= WORD2(v83) || BYTE6(v83) != 2)
          goto LABEL_180;
        v38 = *v33;
        ++WORD2(v83);
        *((_BYTE *)ptr + v37) = v38;
        if (HIBYTE(v83))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 740, "OI_STATUS OI_SendGeneric2(char *, uint8_t, L2CAPChannel *, OI_HCI_CONNECTION_HANDLE, unsigned int, ...)");
LABEL_182:
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
        }
        if (WORD1(v83) - WORD2(v83) <= 3 || BYTE6(v83) != 2)
          goto LABEL_182;
        *((_BYTE *)ptr + WORD2(v83)) = 0;
        *(_WORD *)((char *)ptr + WORD2(v83) + 1) = 0;
        *((_BYTE *)ptr + WORD2(v83) + 3) = 0;
        v39 = WORD2(v83) + 4;
        WORD2(v83) += 4;
        if (HIBYTE(v83))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 741, "OI_STATUS OI_SendGeneric2(char *, uint8_t, L2CAPChannel *, OI_HCI_CONNECTION_HANDLE, unsigned int, ...)");
LABEL_184:
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
        }
        if (WORD1(v83) - v39 <= 3 || BYTE6(v83) != 2)
          goto LABEL_184;
        *((_BYTE *)ptr + v39) = 0;
        *(_WORD *)((char *)ptr + WORD2(v83) + 1) = 0;
        *((_BYTE *)ptr + WORD2(v83) + 3) = 0;
        v40 = WORD2(v83) + 4;
        WORD2(v83) += 4;
        if (HIBYTE(v83))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 742, "OI_STATUS OI_SendGeneric2(char *, uint8_t, L2CAPChannel *, OI_HCI_CONNECTION_HANDLE, unsigned int, ...)");
LABEL_186:
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
        }
        if (WORD1(v83) - v40 <= 3 || BYTE6(v83) != 2)
          goto LABEL_186;
        *((_BYTE *)ptr + v40) = 0;
        *(_WORD *)((char *)ptr + WORD2(v83) + 1) = 0;
        *((_BYTE *)ptr + WORD2(v83) + 3) = 0;
        v41 = WORD2(v83) + 4;
        WORD2(v83) += 4;
        if (HIBYTE(v83))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 743, "OI_STATUS OI_SendGeneric2(char *, uint8_t, L2CAPChannel *, OI_HCI_CONNECTION_HANDLE, unsigned int, ...)");
LABEL_188:
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
        }
        if (WORD1(v83) - v41 <= 3 || BYTE6(v83) != 2)
          goto LABEL_188;
        *((_BYTE *)ptr + v41) = -1;
        *((_BYTE *)ptr + WORD2(v83) + 1) = -1;
        *((_BYTE *)ptr + WORD2(v83) + 2) = -1;
        *((_BYTE *)ptr + WORD2(v83) + 3) = -1;
        v42 = WORD2(v83) + 4;
        WORD2(v83) += 4;
        if (HIBYTE(v83))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 744, "OI_STATUS OI_SendGeneric2(char *, uint8_t, L2CAPChannel *, OI_HCI_CONNECTION_HANDLE, unsigned int, ...)");
LABEL_190:
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
        }
        if (WORD1(v83) - v42 <= 3 || BYTE6(v83) != 2)
          goto LABEL_190;
        *((_BYTE *)ptr + v42) = -1;
        *((_BYTE *)ptr + WORD2(v83) + 1) = -1;
        *((_BYTE *)ptr + WORD2(v83) + 2) = -1;
        *((_BYTE *)ptr + WORD2(v83) + 3) = -1;
        WORD2(v83) += 4;
        v15 += 24;
LABEL_136:
        ++a1;
        continue;
      default:
        if (*a1)
          goto LABEL_136;
        v77 = WORD2(v83);
        WORD2(v83) = 0;
        if (HIBYTE(v83))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 776, "OI_STATUS OI_SendGeneric2(char *, uint8_t, L2CAPChannel *, OI_HCI_CONNECTION_HANDLE, unsigned int, ...)");
          goto LABEL_224;
        }
        if (WORD1(v83) <= 1u || BYTE6(v83) != 2)
LABEL_224:
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
        *(_BYTE *)ptr = v15 + 4;
        *((_BYTE *)ptr + WORD2(v83) + 1) = (unsigned __int16)(v15 + 4) >> 8;
        WORD2(v83) += 2;
        if (WORD1(v83) <= 5u)
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
        WORD2(v83) = 6;
        if (HIBYTE(v83))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 778, "OI_STATUS OI_SendGeneric2(char *, uint8_t, L2CAPChannel *, OI_HCI_CONNECTION_HANDLE, unsigned int, ...)");
          goto LABEL_227;
        }
        if (WORD1(v83) <= 7u || BYTE6(v83) != 2)
LABEL_227:
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
        *((_BYTE *)ptr + 6) = v15;
        *((_BYTE *)ptr + WORD2(v83) + 1) = BYTE1(v15);
        WORD2(v83) += 2;
        if (v77 > WORD1(v83))
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
        WORD2(v83) = v77;
        if (BYTE6(v83) == 2)
          WORD1(v83) = v77;
        BYTE6(v83) = 15;
        if (a2 <= 6 && ((1 << a2) & 0x54) != 0)
        {
          if (!v79)
            sub_100253460();
          v78 = sub_100252DE8(0x2Fu);
          if (sub_1001FEFC8(v79, *(unsigned __int16 *)(v78 + 6)))
          {
            sub_100053298(ptr);
            return 104;
          }
          *(_BYTE *)(sub_1001E3CCC(v79) + 28) = v80;
        }
        return sub_100200B08(v81, (uint64_t)&ptr);
    }
  }
}

uint64_t sub_10020081C(uint64_t *a1, __int16 a2, char a3, char a4)
{
  __int16 v8;
  _BYTE *v9;
  unsigned __int16 v10;
  __int16 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t result;

  v8 = a2 + 8;
  v9 = sub_100052DC0((unsigned __int16)(a2 + 8));
  if (v9)
  {
    if (!v8)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
    *a1 = (uint64_t)v9;
    *((_WORD *)a1 + 4) = v8;
    *((_DWORD *)a1 + 3) = 0x20000;
    *((_WORD *)a1 + 5) = v8;
    if (v8 == 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
    *v9 = a2 + 4;
    *(_BYTE *)(*a1 + *((unsigned __int16 *)a1 + 6) + 1) = (unsigned __int16)(a2 + 4) >> 8;
    v10 = *((_WORD *)a1 + 6) + 2;
    *((_WORD *)a1 + 6) = v10;
    if (*((_BYTE *)a1 + 15))
    {
      sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 457, "OI_STATUS InitCommandPacket(OI_BYTE_STREAM *, uint16_t, uint8_t, uint8_t)");
    }
    else if (*((unsigned __int16 *)a1 + 5) - v10 > 1 && *((_BYTE *)a1 + 14) == 2)
    {
      *(_BYTE *)(*a1 + v10) = 1;
      *(_BYTE *)(*a1 + *((unsigned __int16 *)a1 + 6) + 1) = 0;
      v11 = *((_WORD *)a1 + 6);
      *((_WORD *)a1 + 6) = v11 + 2;
      if (*((_BYTE *)a1 + 15))
      {
        sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 460, "OI_STATUS InitCommandPacket(OI_BYTE_STREAM *, uint16_t, uint8_t, uint8_t)");
      }
      else if (*((unsigned __int16 *)a1 + 5) > (unsigned __int16)(v11 + 2) && *((_BYTE *)a1 + 14) == 2)
      {
        v12 = *a1;
        *((_WORD *)a1 + 6) = v11 + 3;
        *(_BYTE *)(v12 + (unsigned __int16)(v11 + 2)) = a3;
        if (*((_BYTE *)a1 + 15))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 461, "OI_STATUS InitCommandPacket(OI_BYTE_STREAM *, uint16_t, uint8_t, uint8_t)");
        }
        else
        {
          v13 = *((unsigned __int16 *)a1 + 6);
          if (*((unsigned __int16 *)a1 + 5) > v13 && *((_BYTE *)a1 + 14) == 2)
          {
            v14 = *a1;
            *((_WORD *)a1 + 6) = v13 + 1;
            *(_BYTE *)(v14 + v13) = a4;
            if (*((_BYTE *)a1 + 15))
            {
              sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 462, "OI_STATUS InitCommandPacket(OI_BYTE_STREAM *, uint16_t, uint8_t, uint8_t)");
            }
            else
            {
              v15 = *((unsigned __int16 *)a1 + 6);
              if (*((unsigned __int16 *)a1 + 5) - (int)v15 > 1 && *((_BYTE *)a1 + 14) == 2)
              {
                result = 0;
                *(_BYTE *)(*a1 + v15) = a2;
                *(_BYTE *)(*a1 + *((unsigned __int16 *)a1 + 6) + 1) = HIBYTE(a2);
                *((_WORD *)a1 + 6) += 2;
                return result;
              }
            }
            sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
          }
        }
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
      }
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
    }
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
  }
  return 106;
}

uint64_t sub_100200B08(_BYTE *a1, uint64_t a2)
{
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  unsigned int v7;

  v4 = (unsigned __int8 *)sub_100114588(0x98uLL);
  if (!v4)
    return 106;
  v5 = v4;
  v6 = v4 + 40;
  sub_1000532A8((uint64_t)(v4 + 40), 1u);
  sub_10005336C(v6, *(char **)a2, *(unsigned __int16 *)(a2 + 10), 1u);
  *v5 = 1;
  *((_QWORD *)v5 + 4) = 0;
  v7 = sub_1001F3A24((uint64_t)v5, a1, 0, 1);
  if (v7)
  {
    sub_100253FD8((uint64_t)v6);
    sub_100053298(v5);
  }
  if (v7 == 412)
    return 0;
  else
    return v7;
}

uint64_t sub_100200BB4(_BYTE *a1, unsigned int a2, __int16 a3, __int16 a4, __int16 a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  int v10;

  v10 = 0;
  if (a2 == 2)
  {
    LOWORD(v10) = a4;
    BYTE2(v10) = a5;
    v8 = 3;
    HIBYTE(a3) = HIBYTE(a5);
    goto LABEL_5;
  }
  if (a2 == 1)
  {
    LOBYTE(v10) = a3;
    v8 = 1;
LABEL_5:
    *(_BYTE *)((unint64_t)&v10 | v8) = HIBYTE(a3);
  }
  return sub_1001FF230("ad", 1u, 0, a1, a6, a6, a7, a8, a2);
}

uint64_t sub_100200C50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __int16 a5)
{
  _BYTE *v10;
  uint64_t v11;
  char v12;
  int v13;
  uint64_t v14;

  if (a3 && a1)
  {
    v10 = sub_100114588(0xE0uLL);
    if (v10)
    {
      v11 = (uint64_t)v10;
      v10[152] = 8;
      *((_QWORD *)v10 + 24) = qword_1009859E8;
      qword_1009859E8 = (uint64_t)v10;
      if (((byte_1009859D8 + 1) & 0x100) != 0)
        v12 = byte_1009859D8 + 2;
      else
        v12 = byte_1009859D8 + 1;
      byte_1009859D8 = v12;
      v10[153] = v12;
      v13 = *(_DWORD *)a3;
      *((_WORD *)v10 + 92) = *(_WORD *)(a3 + 4);
      *((_DWORD *)v10 + 45) = v13;
      *((_QWORD *)v10 + 21) = a2;
      *((_QWORD *)v10 + 25) = a1;
      *((_QWORD *)v10 + 26) = a4;
      *((_WORD *)v10 + 108) = a5;
      v14 = sub_10017FDB8((uint64_t)sub_100200D38, a3);
      if ((_DWORD)v14)
        sub_10020107C(v11, 0);
    }
    else
    {
      return 104;
    }
  }
  else
  {
    sub_100253460();
    return 101;
  }
  return v14;
}

void sub_100200D38(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  int v5;
  uint64_t v6;
  NSObject *v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  _BYTE *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  uint64_t v16;
  _BYTE *v17;
  unsigned __int16 v18;
  size_t v19;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  const void *v23[2];
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  v5 = a1;
  v6 = qword_1009859E8;
  if (qword_1009859E8)
  {
    while (*(_DWORD *)(v6 + 180) != *(_DWORD *)a2 || *(unsigned __int16 *)(v6 + 184) != *(unsigned __int16 *)(a2 + 4))
    {
      v6 = *(_QWORD *)(v6 + 192);
      if (!v6)
        goto LABEL_7;
    }
    v26 = v6;
    if ((_DWORD)a1)
    {
      sub_10020107C(v6, a1);
      return;
    }
    v24 = 0;
    v25 = 0;
    *(_QWORD *)(v6 + 160) = a3;
    v9 = *(unsigned __int8 *)(v6 + 152);
    if (v9 == 8)
    {
      v10 = sub_10020081C(&v24, *(_WORD *)(v6 + 216) + 2, 8, *(_BYTE *)(v6 + 153));
      if (!(_DWORD)v10)
      {
        if (HIBYTE(v25))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 879, "void CommandConnectCB(OI_STATUS, OI_BD_ADDR *, OI_HCI_CONNECTION_HANDLE)");
        }
        else
        {
          v14 = WORD1(v25);
          v15 = WORD2(v25);
          if (WORD1(v25) - WORD2(v25) > 1 && BYTE6(v25) == 2)
          {
            v16 = v24;
            v17 = (_BYTE *)(v24 + WORD2(v25));
            *v17 = *(_BYTE *)(v6 + 216);
            v17[1] = *(_BYTE *)(v6 + 217);
            v18 = v15 + 2;
            v19 = *(unsigned __int16 *)(v6 + 216);
            if (v14 - (unsigned __int16)(v15 + 2) < (int)v19)
              sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
            memmove((void *)(v16 + v18), *(const void **)(v6 + 208), v19);
            v13 = *(_WORD *)(v6 + 216) + v18;
LABEL_26:
            WORD2(v25) = v13;
            WORD1(v25) = v13;
            BYTE6(v25) = 15;
            v10 = sub_100200B08(a3, (uint64_t)&v24);
            if ((_DWORD)v10)
              goto LABEL_27;
LABEL_30:
            v23[1] = &v26;
            v23[0] = (const void *)8;
            v21 = sub_100252DE8(0x2Fu);
            v22 = sub_10004A9EC((uint64_t)sub_10020185C, v23, *(unsigned __int16 *)(v21 + 6), (int *)(v26 + 176));
            if (!(_DWORD)v22)
              return;
            v10 = v22;
            v6 = v26;
            goto LABEL_32;
          }
        }
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
      }
    }
    else
    {
      if (v9 != 10)
        goto LABEL_30;
      v10 = sub_10020081C(&v24, 2, 10, *(_BYTE *)(v6 + 153));
      if (!(_DWORD)v10)
      {
        if (HIBYTE(v25))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 871, "void CommandConnectCB(OI_STATUS, OI_BD_ADDR *, OI_HCI_CONNECTION_HANDLE)");
        }
        else
        {
          v11 = WORD2(v25);
          if (WORD1(v25) - WORD2(v25) > 1 && BYTE6(v25) == 2)
          {
            v12 = (_BYTE *)(v24 + WORD2(v25));
            *v12 = *(_BYTE *)(v6 + 200);
            v12[1] = *(_BYTE *)(v6 + 201);
            v13 = v11 + 2;
            goto LABEL_26;
          }
        }
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
      }
    }
LABEL_27:
    if (sub_10005549C())
    {
      sub_100054530("Failed to send command");
      v20 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        sub_1006D2728();
    }
LABEL_32:
    sub_10020107C(v6, v10);
    return;
  }
LABEL_7:
  if (!sub_10005549C()
    || (sub_100054530("Missing command tracker %:", a2),
        v8 = sub_1000544A0(0x2Fu),
        !os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)))
  {
    if (v5)
      return;
LABEL_10:
    sub_10018014C((uint64_t)a3, 0x13u);
    return;
  }
  sub_1006D38B8();
  if (!v5)
    goto LABEL_10;
}

void sub_10020107C(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;

  if (!qword_1009859E8)
    sub_100253460();
  v4 = *(_QWORD *)(a1 + 160);
  if (v4)
    sub_10018014C(v4, 0x13u);
  v5 = &qword_1009859E8;
  v6 = qword_1009859E8;
  if (qword_1009859E8 == a1)
  {
LABEL_9:
    *v5 = *(_QWORD *)(a1 + 192);
    sub_100049F6C(*(unsigned int *)(a1 + 176));
    if ((_DWORD)a2)
    {
      v8 = sub_10019AEA4(a1 + 180);
      if (sub_10019AB28(v8)
        || (v9 = sub_10019AEA4(a1 + 180), sub_10019ABD0(v9))
        || (v10 = sub_10019AEA4(a1 + 180), sub_10019AC00(v10))
        || (v11 = sub_10019AEA4(a1 + 180), sub_10019AC30(v11)))
      {
        v12 = *(unsigned __int8 *)(a1 + 152);
        if (v12 == 10)
        {
          (*(void (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, uint64_t))(a1 + 208))(a1 + 180, *(_QWORD *)(a1 + 168), *(unsigned __int16 *)(a1 + 200), 0, 0, a2);
        }
        else if (v12 == 8)
        {
          (*(void (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, uint64_t))(a1 + 200))(a1 + 180, *(_QWORD *)(a1 + 168), *(_QWORD *)(a1 + 208), *(unsigned __int16 *)(a1 + 216), 0, 0, a2);
        }
        else
        {
          sub_100253460();
        }
      }
    }
    sub_100053298((void *)a1);
  }
  else
  {
    while (v6)
    {
      v7 = v6;
      v6 = *(_QWORD *)(v6 + 192);
      if (v6 == a1)
      {
        v5 = (uint64_t *)(v7 + 192);
        goto LABEL_9;
      }
    }
  }
}

uint64_t sub_1002011BC(uint64_t a1, uint64_t a2, uint64_t a3, __int16 a4)
{
  _BYTE *v8;
  uint64_t v9;
  char v10;
  int v11;
  uint64_t v12;
  NSObject *v14;

  if (a1 && a3)
  {
    v8 = sub_100114588(0xE0uLL);
    if (v8)
    {
      v9 = (uint64_t)v8;
      v8[152] = 10;
      *((_QWORD *)v8 + 24) = qword_1009859E8;
      qword_1009859E8 = (uint64_t)v8;
      if (((byte_1009859D8 + 1) & 0x100) != 0)
        v10 = byte_1009859D8 + 2;
      else
        v10 = byte_1009859D8 + 1;
      byte_1009859D8 = v10;
      v8[153] = v10;
      v11 = *(_DWORD *)a3;
      *((_WORD *)v8 + 92) = *(_WORD *)(a3 + 4);
      *((_DWORD *)v8 + 45) = v11;
      *((_QWORD *)v8 + 21) = a2;
      *((_WORD *)v8 + 100) = a4;
      *((_QWORD *)v8 + 26) = a1;
      v12 = sub_10017FDB8((uint64_t)sub_100200D38, a3);
      if ((_DWORD)v12)
        sub_10020107C(v9, 0);
    }
    else
    {
      if (sub_10005549C())
      {
        sub_100054530("AllocCommandTracker() failed");
        v14 = sub_1000544A0(0x2Fu);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return 104;
    }
  }
  else
  {
    sub_100253460();
    return 101;
  }
  return v12;
}

uint64_t sub_1002012E0(unsigned int a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v4;
  __int16 v5;
  int *v6;

  v6 = 0;
  if (sub_1001DB044(a1, (uint64_t *)&v6))
    return 403;
  v4 = sub_1001E3CCC(v6);
  result = 0;
  v5 = *(_WORD *)(v4 + 14);
  *(_DWORD *)a2 = *(_DWORD *)(v4 + 10);
  *(_WORD *)(a2 + 4) = v5;
  return result;
}

void sub_10020133C(_BYTE *a1, unsigned __int16 *a2, size_t size)
{
  NSObject *v3;
  unsigned int v4;
  NSObject *v6;
  unsigned __int16 *v7;
  unsigned __int16 *v8;
  unsigned __int16 *v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned __int16 v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  int v20;
  unsigned int v22;
  NSObject *v23;
  void *v24;
  void *v25;
  NSObject *v26;
  NSObject *v27;
  int *v28;
  unsigned __int16 *v29;
  __int16 v30;
  unsigned __int16 v31;
  int v32;
  uint8_t buf[4];
  void *v34;
  __int16 v35;
  int v36;

  v28 = 0;
  if (!a1[2])
  {
    v4 = size;
    if (size <= 3)
    {
      if (sub_10005549C())
      {
        sub_100054530("Received L2CAP header with 0 length, disc ACL", a1 + 48);
        v6 = sub_1000544A0(0x2Fu);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
          sub_1006CEEC0();
      }
      sub_100180494((uint64_t)(a1 + 48), 0x13u);
      return;
    }
    v7 = a2;
    if (a2[1] + 4 == (_DWORD)size)
    {
      v8 = 0;
    }
    else
    {
      v9 = (unsigned __int16 *)sub_100052DC0(size);
      if (!v9)
      {
        if (sub_10005549C())
        {
          sub_100054530("OI_SignalMan_Recv Malloc failed!");
          v26 = sub_1000544A0(0x2Fu);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
            goto LABEL_4;
        }
        return;
      }
      v8 = v9;
      memmove(v9, v7, v4);
      v7 = v8;
    }
    v29 = v7;
    v30 = v4;
    v32 = 0x10000;
    v31 = v4;
    while (1)
    {
      v10 = v31;
      v11 = (unsigned __int16)v32;
      if (v31 <= (unsigned __int16)v32)
        break;
      if (BYTE2(v32) != 1)
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
      LOWORD(v32) = v32 + 1;
      if (v31 <= (unsigned __int16)(v11 + 1))
      {
        HIBYTE(v32) = 1;
        sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1852, "void OI_SignalMan_Recv(OI_HCI_CONNECTION_HANDLE, uint8_t *, uint16_t)");
LABEL_47:
        HIBYTE(v32) = 1;
        if (sub_10005549C())
        {
          sub_100054530("OI_SignalMan_Recv - %!", 411);
          v27 = sub_1000544A0(0x2Fu);
          if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
        break;
      }
      v12 = *((unsigned __int8 *)v29 + v11);
      LOWORD(v32) = v11 + 2;
      if (v31 - (unsigned __int16)(v11 + 2) <= 1)
        goto LABEL_47;
      v13 = *((unsigned __int8 *)v29 + v11 + 1);
      v14 = *(unsigned __int16 *)((char *)v29 + v11 + 2);
      v15 = v11 + 4;
      LOWORD(v32) = v15;
      if ((v12 - 18) > 0xFFFFFFEE)
      {
        if (v12 <= 0x11 && ((1 << v12) & 0x2A0AA) != 0)
        {
          if (sub_1001DB584((uint64_t)a1, v13, &v28))
            break;
          sub_1001FF1F4(v28);
          v15 = v32;
          v10 = v31;
        }
        v22 = v14 + v15;
        if (v22 <= v10)
        {
          qword_10091EE98[v12](&v29, v13, v14, a1);
          if (v22 > v31)
            sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
        }
        else
        {
          if (sub_10005549C())
          {
            sub_100054530("%! - Signalling packet length error", 411);
            v23 = sub_1000544A0(0x2Fu);
            if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
            {
              v25 = sub_100054494();
              *(_DWORD *)buf = 136446466;
              v34 = v25;
              v35 = 1024;
              v36 = 0xFFFF;
              _os_log_error_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "%{public}s (status=%{bluetooth:OI_STATUS}u)", buf, 0x12u);
            }
          }
          LOWORD(v22) = v31;
        }
      }
      else
      {
        if (sub_10005549C())
        {
          sub_100054530("Unrecognized command (%d), sending CommandReject", v12);
          v19 = sub_1000544A0(0x2Fu);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            v24 = sub_100054494();
            *(_DWORD *)buf = 136446466;
            v34 = v24;
            v35 = 1024;
            v36 = 0xFFFF;
            _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "%{public}s (status=%{bluetooth:OI_STATUS}u)", buf, 0x12u);
          }
        }
        *(_DWORD *)buf = 0;
        sub_1001FF230("ad", 1u, 0, a1, v13, v16, v17, v18, 0);
        if (HIBYTE(v32))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1861, "void OI_SignalMan_Recv(OI_HCI_CONNECTION_HANDLE, uint8_t *, uint16_t)");
          v20 = 0;
        }
        else
        {
          v20 = v31 - (unsigned __int16)v32;
        }
        if (v20 < (int)v14)
        {
          HIBYTE(v32) = 1;
LABEL_51:
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1847, "void OI_SignalMan_Recv(OI_HCI_CONNECTION_HANDLE, uint8_t *, uint16_t)");
          break;
        }
        LOWORD(v22) = v32 + v14;
      }
      LOWORD(v32) = v22;
      if (HIBYTE(v32))
        goto LABEL_51;
    }
    if (v8)
      sub_100053298(v8);
    return;
  }
  if (sub_10005549C())
  {
    sub_100054530("Signalling channel should only be used by ACL handles.");
    v3 = sub_1000544A0(0x2Fu);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
LABEL_4:
      sub_1006CE7A4();
  }
}

void *sub_100201844(void *result)
{
  off_1009859E0 = result;
  return result;
}

void sub_100201850()
{
  off_1009859E0 = 0;
}

void sub_10020185C(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = **(_QWORD **)(a1 + 8);
  if (*(_BYTE *)(v1 + 152) == 8)
    v2 = 440;
  else
    v2 = 441;
  sub_10020107C(v1, v2);
}

void sub_100201878(uint64_t a1, int a2, int a3, uint64_t a4)
{
  int v8;
  uint64_t v9;
  unsigned __int16 v10;
  NSObject *v11;
  NSObject *v12;
  int v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  NSObject *v17;
  NSObject *v18;
  NSObject *v19;
  NSObject *v20;
  uint64_t v21;
  int *v23;
  _WORD v24[3];

  qmemcpy(v24, "IOIOIO", sizeof(v24));
  if (*(_BYTE *)(a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1006, "void SignalMan_RecvCommandReject(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
    v8 = 0;
  }
  else
  {
    v8 = *(unsigned __int16 *)(a1 + 10) - *(unsigned __int16 *)(a1 + 12);
  }
  if (v8 < a3)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
  if (*(_BYTE *)(a1 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
  v23 = 0;
  if (*(_BYTE *)(a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1009, "void SignalMan_RecvCommandReject(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
LABEL_10:
    *(_BYTE *)(a1 + 15) = 1;
    v10 = 20297;
    goto LABEL_11;
  }
  v9 = *(unsigned __int16 *)(a1 + 12);
  if (*(unsigned __int16 *)(a1 + 10) - (int)v9 < 2)
    goto LABEL_10;
  v10 = *(_WORD *)(*(_QWORD *)a1 + v9);
  *(_WORD *)(a1 + 12) = v9 + 2;
LABEL_11:
  if (sub_10005549C())
  {
    sub_100054530("Received Command Reject, identifier %d, handle %d, reason %d", a2, a4, v10);
    v11 = sub_1000544A0(0x2Fu);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  if (v10 == 2)
  {
    if (*(_BYTE *)(a1 + 14) != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
    if (*(_BYTE *)(a1 + 15))
    {
      sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1020, "void SignalMan_RecvCommandReject(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
      v13 = *(unsigned __int8 *)(a1 + 14);
      *(_BYTE *)(a1 + 15) = 1;
      if (v13 != 1)
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
    }
    else
    {
      v15 = *(unsigned __int16 *)(a1 + 12);
      if (*(unsigned __int16 *)(a1 + 10) - (int)v15 > 1)
      {
        v24[1] = *(_WORD *)(*(_QWORD *)a1 + v15);
        *(_WORD *)(a1 + 12) = v15 + 2;
        if (*(unsigned __int16 *)(a1 + 10) - (unsigned __int16)(v15 + 2) >= 2)
        {
          v24[0] = *(_WORD *)(*(_QWORD *)a1 + (unsigned __int16)(v15 + 2));
          *(_WORD *)(a1 + 12) = v15 + 4;
LABEL_42:
          if (sub_10005549C())
          {
            sub_100054530("  Rejected - invalid CID, localCID %d, remoteCID %d", v24[1], v24[0]);
            v18 = sub_1000544A0(0x2Fu);
            if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
              goto LABEL_44;
          }
          goto LABEL_45;
        }
LABEL_41:
        *(_BYTE *)(a1 + 15) = 1;
        goto LABEL_42;
      }
      *(_BYTE *)(a1 + 15) = 1;
    }
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1021, "void SignalMan_RecvCommandReject(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
    goto LABEL_41;
  }
  if (v10 == 1)
  {
    if (*(_BYTE *)(a1 + 14) != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
    if (*(_BYTE *)(a1 + 15))
    {
      sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1016, "void SignalMan_RecvCommandReject(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
    }
    else
    {
      v16 = *(unsigned __int16 *)(a1 + 12);
      if (*(unsigned __int16 *)(a1 + 10) - (int)v16 >= 2)
      {
        v24[2] = *(_WORD *)(*(_QWORD *)a1 + v16);
        *(_WORD *)(a1 + 12) = v16 + 2;
LABEL_36:
        if (sub_10005549C())
        {
          sub_100054530("  Rejected - MTU exceeded, max MTU = %d", v24[2]);
          v17 = sub_1000544A0(0x2Fu);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
            goto LABEL_44;
        }
        goto LABEL_45;
      }
    }
    *(_BYTE *)(a1 + 15) = 1;
    goto LABEL_36;
  }
  if (v10)
  {
    if (sub_10005549C())
    {
      sub_100054530("  Rejected - unknown reason code");
      v14 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        goto LABEL_44;
    }
  }
  else if (sub_10005549C())
  {
    sub_100054530("  Rejected - Command not understood");
    v12 = sub_1000544A0(0x2Fu);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
LABEL_44:
      sub_1006CE7A4();
  }
LABEL_45:
  if (*(_BYTE *)(a1 + 15))
  {
    if (sub_10005549C())
    {
      sub_100054530("SignalMan_RecvCommandReject - %!", 411);
      v19 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  else if (sub_1001DB584(a4, a2, &v23))
  {
    if (sub_10005549C())
    {
      sub_100054530("No channel found for identifier %d, ignoring command reject packet", a2);
      v20 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  else if (*v23 == 2)
  {
    v21 = sub_1001E3CCC(v23);
    if (*(_DWORD *)(a4 + 48) != *(_DWORD *)(v21 + 10)
      || *(unsigned __int16 *)(a4 + 52) != *(unsigned __int16 *)(v21 + 14))
    {
      sub_100253460();
    }
    sub_1001DCE10((uint64_t)v23, 445);
  }
}

void sub_100201D70(uint64_t a1, char a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v12;
  unsigned __int16 v13;
  __int16 v14;

  v14 = 771;
  if (*(_BYTE *)(a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1067, "void SignalMan_RecvConnectReq(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
    v12 = 0;
  }
  else
  {
    v12 = *(unsigned __int16 *)(a1 + 10) - *(unsigned __int16 *)(a1 + 12);
  }
  if (v12 < a3)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
  v13 = 0;
  if (!sub_1002524E0((uint64_t *)a1, 1u, (uint64_t)&v14, 2u, a5, a6, a7, a8, (uint64_t)&v13))
    sub_1001E0084(a4, v13, 0, a2);
}

void sub_100201E44(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v12;
  __int16 v13;
  int v14;

  v14 = 50529027;
  if (*(_BYTE *)(a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1089, "void SignalMan_RecvConnectRsp(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
    v12 = 0;
  }
  else
  {
    v12 = *(unsigned __int16 *)(a1 + 10) - *(unsigned __int16 *)(a1 + 12);
  }
  if (v12 < a3)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
  v13 = 0;
  if (!sub_1002524E0((uint64_t *)a1, 1u, (uint64_t)&v14, 4u, a5, a6, a7, a8, (uint64_t)&v13))
    sub_1001E04C8(a4, 0, v13, 0, 0, a2);
}

void sub_100201F30(uint64_t *a1, char a2, unsigned int a3, uint64_t a4)
{
  int v8;
  uint64_t v9;
  int v10;
  char v11;
  uint64_t v12;
  NSObject *v13;
  unsigned int v14;
  unsigned int v15;
  _BYTE *v16;
  int v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  char v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  unsigned __int16 v25;
  unsigned int v26;
  int v27;
  NSObject *v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  uint64_t v34;
  int v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unsigned __int16 v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unsigned __int16 v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  void *v63;
  NSObject *v64;
  uint64_t v65;
  uint64_t v66;
  NSObject *v67;
  NSObject *v68;
  _BYTE *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  NSObject *v74;
  NSObject *v75;
  NSObject *v76;
  char v77;
  unsigned __int16 v78;
  uint64_t v79;
  unsigned __int16 v80;
  unsigned int v81;
  int __len;
  _OWORD v83[3];
  _BYTE buf[12];
  __int16 v85;
  int v86;

  memset(v83, 0, 44);
  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1158, "void SignalMan_RecvConfigReq(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
    v8 = 0;
  }
  else
  {
    v8 = *((unsigned __int16 *)a1 + 5) - *((unsigned __int16 *)a1 + 6);
  }
  if (v8 < (int)a3)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
  if (*((_BYTE *)a1 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
  v9 = *((unsigned __int16 *)a1 + 6);
  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1164, "void SignalMan_RecvConfigReq(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
    v10 = *((unsigned __int8 *)a1 + 14);
    *((_BYTE *)a1 + 15) = 1;
    if (v10 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
    goto LABEL_13;
  }
  if (*((unsigned __int16 *)a1 + 5) - (int)v9 <= 1)
  {
    *((_BYTE *)a1 + 15) = 1;
LABEL_13:
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1165, "void SignalMan_RecvConfigReq(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
    v78 = 0;
    goto LABEL_14;
  }
  v78 = *(_WORD *)(*a1 + v9);
  *((_WORD *)a1 + 6) = v9 + 2;
  if (*((unsigned __int16 *)a1 + 5) - (unsigned __int16)(v9 + 2) >= 2)
  {
    v11 = *(_BYTE *)(*a1 + (unsigned __int16)(v9 + 2));
    *((_WORD *)a1 + 6) = v9 + 4;
    goto LABEL_15;
  }
LABEL_14:
  v11 = 0;
  *((_BYTE *)a1 + 15) = 1;
LABEL_15:
  v81 = v9 + a3;
  if (a3 <= 3)
  {
    if (sub_10005549C())
    {
      sub_100054530("Bogus length in configuration request - must be corrupt packet");
      v13 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        sub_1006D3998();
    }
    v12 = 411;
  }
  else
  {
    v12 = 0;
  }
  v79 = a4;
  v77 = a2;
  v14 = *((unsigned __int16 *)a1 + 6);
  v15 = v81;
  if (v81 > v14)
  {
    v80 = 0;
    v16 = 0;
    LOBYTE(v17) = 0;
    __len = 0;
    while (1)
    {
      if (*((_BYTE *)a1 + 15))
        goto LABEL_134;
      if (*((_BYTE *)a1 + 14) != 1)
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
      v18 = *((unsigned __int16 *)a1 + 5);
      if (v18 <= v14)
        break;
      v19 = *a1;
      v20 = v14 + 1;
      *((_WORD *)a1 + 6) = v20;
      v21 = *(_BYTE *)(v19 + v14);
      if (v18 <= v20)
      {
        LOBYTE(v17) = v21;
        goto LABEL_30;
      }
      v22 = *a1;
      *((_WORD *)a1 + 6) = v14 + 2;
      __len = *(unsigned __int8 *)(v22 + v20);
      v23 = 1;
LABEL_31:
      v17 = v21 & 0x7F;
      switch(v21 & 0x7F)
      {
        case 1:
          if (*((_BYTE *)a1 + 14) != 1)
            sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
          if ((v23 & 1) != 0)
          {
            v24 = *((unsigned __int16 *)a1 + 6);
            if (*((unsigned __int16 *)a1 + 5) - (int)v24 >= 2)
            {
              WORD2(v83[0]) = *(_WORD *)(*a1 + v24);
              *((_WORD *)a1 + 6) = v24 + 2;
              goto LABEL_90;
            }
          }
          else
          {
            sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1190, "void SignalMan_RecvConfigReq(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
          }
          *((_BYTE *)a1 + 15) = 1;
LABEL_90:
          LODWORD(v83[0]) |= 1u;
          goto LABEL_114;
        case 2:
          LODWORD(v83[0]) |= 2u;
          if (*((_BYTE *)a1 + 14) != 1)
            sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
          if ((v23 & 1) == 0)
          {
            v51 = 1194;
            goto LABEL_112;
          }
          v30 = *((unsigned __int16 *)a1 + 6);
          if (*((unsigned __int16 *)a1 + 5) - (int)v30 < 2)
            goto LABEL_113;
          WORD3(v83[0]) = *(_WORD *)(*a1 + v30);
          goto LABEL_81;
        case 3:
          LODWORD(v83[0]) |= 4u;
          if ((v23 & 1) == 0)
          {
            sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1198, "void SignalMan_RecvConfigReq(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
LABEL_83:
            *((_BYTE *)a1 + 15) = 1;
            if (*((_BYTE *)a1 + 14) != 1)
LABEL_176:
              sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
            sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1199, "void SignalMan_RecvConfigReq(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
            goto LABEL_85;
          }
          v31 = *((unsigned __int16 *)a1 + 6);
          if (*((unsigned __int16 *)a1 + 5) <= v31)
            goto LABEL_83;
          v32 = v31 + 1;
          *((_WORD *)a1 + 6) = v31 + 1;
          if (*((_BYTE *)a1 + 14) != 1)
            goto LABEL_176;
          v33 = *((unsigned __int16 *)a1 + 5);
          if (v33 > v32)
          {
            v34 = *a1;
            v35 = v31 + 2;
            *((_WORD *)a1 + 6) = v35;
            BYTE8(v83[0]) = *(_BYTE *)(v34 + v32);
            v36 = v33 - v35;
            goto LABEL_86;
          }
LABEL_85:
          *((_BYTE *)a1 + 15) = 1;
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1200, "void SignalMan_RecvConfigReq(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
          v36 = 0;
LABEL_86:
          if (v36 < __len - 2)
            goto LABEL_113;
          v43 = *((_WORD *)a1 + 6) + __len - 2;
          goto LABEL_124;
        case 4:
          LODWORD(v83[0]) |= 8u;
          if (*((_BYTE *)a1 + 14) != 1)
            sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
          if (!v23)
          {
            sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1204, "void SignalMan_RecvConfigReq(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
            v52 = *((unsigned __int8 *)a1 + 14);
            *((_BYTE *)a1 + 15) = 1;
            if (v52 != 1)
              sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
LABEL_101:
            sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1205, "void SignalMan_RecvConfigReq(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
            v55 = *((unsigned __int8 *)a1 + 14);
            *((_BYTE *)a1 + 15) = 1;
            if (v55 != 1)
              sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
LABEL_102:
            sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1206, "void SignalMan_RecvConfigReq(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
            v56 = *((unsigned __int8 *)a1 + 14);
            *((_BYTE *)a1 + 15) = 1;
            if (v56 != 1)
              sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
LABEL_103:
            sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1207, "void SignalMan_RecvConfigReq(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
            v57 = *((unsigned __int8 *)a1 + 14);
            *((_BYTE *)a1 + 15) = 1;
            if (v57 != 1)
              sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
LABEL_104:
            sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1208, "void SignalMan_RecvConfigReq(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
            v58 = *((unsigned __int8 *)a1 + 14);
            *((_BYTE *)a1 + 15) = 1;
            if (v58 != 1)
              sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
LABEL_105:
            v51 = 1209;
            goto LABEL_112;
          }
          v37 = *((unsigned __int16 *)a1 + 6);
          if (*((unsigned __int16 *)a1 + 5) <= v37)
          {
            *((_BYTE *)a1 + 15) = 1;
            goto LABEL_101;
          }
          v38 = *a1;
          *((_WORD *)a1 + 6) = v37 + 1;
          BYTE10(v83[0]) = *(_BYTE *)(v38 + v37);
          if (*((unsigned __int16 *)a1 + 5) <= (v37 + 1))
          {
            *((_BYTE *)a1 + 15) = 1;
            goto LABEL_102;
          }
          v39 = *a1;
          v40 = v37 + 2;
          *((_WORD *)a1 + 6) = v37 + 2;
          BYTE11(v83[0]) = *(_BYTE *)(v39 + v37 + 1);
          if (*((unsigned __int16 *)a1 + 5) <= (v37 + 2))
          {
            *((_BYTE *)a1 + 15) = 1;
            goto LABEL_103;
          }
          v41 = *a1;
          v42 = v37 + 3;
          *((_WORD *)a1 + 6) = v42;
          BYTE12(v83[0]) = *(_BYTE *)(v41 + v40);
          if (*((unsigned __int16 *)a1 + 5) - v42 <= 1)
          {
            *((_BYTE *)a1 + 15) = 1;
            goto LABEL_104;
          }
          HIWORD(v83[0]) = *(_WORD *)(*a1 + v42);
          *((_WORD *)a1 + 6) = v42 + 2;
          if (*((unsigned __int16 *)a1 + 5) - (unsigned __int16)(v42 + 2) <= 1)
          {
            *((_BYTE *)a1 + 15) = 1;
            goto LABEL_105;
          }
          LOWORD(v83[1]) = *(_WORD *)(*a1 + (unsigned __int16)(v42 + 2));
          *((_WORD *)a1 + 6) = v42 + 4;
          if (*((unsigned __int16 *)a1 + 5) - (unsigned __int16)(v42 + 4) < 2)
            goto LABEL_113;
          WORD1(v83[1]) = *(_WORD *)(*a1 + (unsigned __int16)(v42 + 4));
          v43 = v42 + 6;
          goto LABEL_124;
        case 5:
          LODWORD(v83[0]) |= 0x10u;
          if (*((_BYTE *)a1 + 14) != 1)
            sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
          if ((v23 & 1) == 0)
          {
            v51 = 1212;
            goto LABEL_112;
          }
          v44 = *((unsigned __int16 *)a1 + 6);
          if (*((unsigned __int16 *)a1 + 5) <= v44)
            goto LABEL_113;
          v45 = *a1;
          *((_WORD *)a1 + 6) = v44 + 1;
          BYTE4(v83[1]) = *(_BYTE *)(v45 + v44);
          goto LABEL_114;
        case 6:
          LODWORD(v83[0]) |= 0x20u;
          if (*((_BYTE *)a1 + 14) != 1)
            sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
          if (!v23)
          {
            sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1215, "void SignalMan_RecvConfigReq(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
            v53 = *((unsigned __int8 *)a1 + 14);
            *((_BYTE *)a1 + 15) = 1;
            if (v53 != 1)
              sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
LABEL_107:
            sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1216, "void SignalMan_RecvConfigReq(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
            v59 = *((unsigned __int8 *)a1 + 14);
            *((_BYTE *)a1 + 15) = 1;
            if (v59 != 1)
              sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
LABEL_108:
            sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1217, "void SignalMan_RecvConfigReq(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
            v60 = *((unsigned __int8 *)a1 + 14);
            *((_BYTE *)a1 + 15) = 1;
            if (v60 != 1)
              sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
LABEL_109:
            sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1218, "void SignalMan_RecvConfigReq(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
            v61 = *((unsigned __int8 *)a1 + 14);
            *((_BYTE *)a1 + 15) = 1;
            if (v61 != 1)
              sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
LABEL_110:
            sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1219, "void SignalMan_RecvConfigReq(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
            v62 = *((unsigned __int8 *)a1 + 14);
            *((_BYTE *)a1 + 15) = 1;
            if (v62 != 1)
              sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
LABEL_111:
            v51 = 1220;
            goto LABEL_112;
          }
          v46 = *((unsigned __int16 *)a1 + 6);
          if (*((unsigned __int16 *)a1 + 5) <= v46)
          {
            *((_BYTE *)a1 + 15) = 1;
            goto LABEL_107;
          }
          v47 = *a1;
          v48 = v46 + 1;
          *((_WORD *)a1 + 6) = v46 + 1;
          BYTE8(v83[1]) = *(_BYTE *)(v47 + v46);
          if (*((unsigned __int16 *)a1 + 5) <= (v46 + 1))
          {
            *((_BYTE *)a1 + 15) = 1;
            goto LABEL_108;
          }
          v49 = *a1;
          v50 = v46 + 2;
          *((_WORD *)a1 + 6) = v50;
          BYTE9(v83[1]) = *(_BYTE *)(v49 + v48);
          if (*((unsigned __int16 *)a1 + 5) - v50 <= 1)
          {
            *((_BYTE *)a1 + 15) = 1;
            goto LABEL_109;
          }
          WORD5(v83[1]) = *(_WORD *)(*a1 + v50);
          *((_WORD *)a1 + 6) = v50 + 2;
          if (*((unsigned __int16 *)a1 + 5) - (unsigned __int16)(v50 + 2) <= 3)
          {
            *((_BYTE *)a1 + 15) = 1;
            goto LABEL_110;
          }
          HIDWORD(v83[1]) = *(_DWORD *)(*a1 + (unsigned __int16)(v50 + 2));
          *((_WORD *)a1 + 6) = v50 + 6;
          if (*((unsigned __int16 *)a1 + 5) - (unsigned __int16)(v50 + 6) <= 3)
          {
            *((_BYTE *)a1 + 15) = 1;
            goto LABEL_111;
          }
          LODWORD(v83[2]) = *(_DWORD *)(*a1 + (unsigned __int16)(v50 + 6));
          *((_WORD *)a1 + 6) = v50 + 10;
          if (*((unsigned __int16 *)a1 + 5) - (unsigned __int16)(v50 + 10) < 4)
            goto LABEL_113;
          DWORD1(v83[2]) = *(_DWORD *)(*a1 + (unsigned __int16)(v50 + 10));
          v43 = v50 + 14;
          goto LABEL_124;
        case 7:
          LODWORD(v83[0]) |= 0x40u;
          if (*((_BYTE *)a1 + 14) != 1)
            sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
          if ((v23 & 1) == 0)
          {
            v51 = 1223;
LABEL_112:
            sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", v51, "void SignalMan_RecvConfigReq(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
            goto LABEL_113;
          }
          v30 = *((unsigned __int16 *)a1 + 6);
          if (*((unsigned __int16 *)a1 + 5) - (int)v30 < 2)
            goto LABEL_113;
          WORD4(v83[2]) = *(_WORD *)(*a1 + v30);
LABEL_81:
          v43 = v30 + 2;
          goto LABEL_124;
        default:
          if (v21 < 0)
          {
            if ((v23 & 1) != 0)
            {
              v54 = *((unsigned __int16 *)a1 + 5) - *((unsigned __int16 *)a1 + 6);
            }
            else
            {
              sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1226, "void SignalMan_RecvConfigReq(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
              v54 = 0;
            }
            if (v54 < __len)
            {
LABEL_113:
              *((_BYTE *)a1 + 15) = 1;
            }
            else
            {
              v43 = *((_WORD *)a1 + 6) + __len;
LABEL_124:
              *((_WORD *)a1 + 6) = v43;
            }
          }
          else
          {
            if (!v16)
            {
              v16 = sub_100052DC0(a3 - 4);
              if (!v16)
              {
                if (sub_10005549C())
                {
                  sub_100054530("Unable to allocate buffer for unknown opts");
                  v76 = sub_1000544A0(0x2Fu);
                  if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
                    sub_1006D3928();
                }
                v16 = 0;
                v12 = 104;
                goto LABEL_137;
              }
            }
            if ((unsigned __int16)(a3 - 4) < (unsigned __int16)(v80 + 2 + __len))
            {
              if (sub_10005549C())
              {
                sub_100054530("Bogus length in unknown option - must be corrupt packet");
                v74 = sub_1000544A0(0x2Fu);
                if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
                  sub_1006D3998();
              }
              goto LABEL_136;
            }
            v16[v80] = v17;
            v16[v80 + 1] = __len;
            v25 = v80;
            memmove(&v16[v80 + 2], (const void *)(*a1 + *((unsigned __int16 *)a1 + 6)), __len);
            v80 += __len + 2;
            v26 = (unsigned __int16)(v25 + __len + 2);
            v27 = sub_10005549C();
            if (v26 > 0x5D)
            {
              if (v27)
              {
                sub_100054530("Buffers can not accomedate unknownOptsLen %d, optionLen %d", v26, __len);
                v75 = sub_1000544A0(0x2Fu);
                if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
                  sub_1006CEEC0();
              }
              v12 = 428;
              goto LABEL_137;
            }
            if (v27)
            {
              sub_100054530("Received config request with unknown option (%d), optionLen %d, unknownOptsLen %d", v17, __len, v26);
              v28 = sub_1000544A0(0x2Fu);
              if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
              {
                v63 = sub_100054494();
                *(_DWORD *)buf = 136446466;
                *(_QWORD *)&buf[4] = v63;
                v85 = 1024;
                v86 = 463;
                _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "%{public}s (status=%{bluetooth:OI_STATUS}u)", buf, 0x12u);
              }
            }
            if (*((_BYTE *)a1 + 15))
            {
              sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1261, "void SignalMan_RecvConfigReq(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
              v29 = 0;
            }
            else
            {
              v29 = *((unsigned __int16 *)a1 + 5) - *((unsigned __int16 *)a1 + 6);
            }
            if (v29 >= __len)
              *((_WORD *)a1 + 6) += __len;
            else
              *((_BYTE *)a1 + 15) = 1;
            v15 = v81;
          }
LABEL_114:
          v14 = *((unsigned __int16 *)a1 + 6);
          if (v15 <= v14)
            goto LABEL_134;
          break;
      }
    }
    *((_BYTE *)a1 + 15) = 1;
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1180, "void SignalMan_RecvConfigReq(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
LABEL_30:
    v23 = 0;
    *((_BYTE *)a1 + 15) = 1;
    v21 = v17;
    goto LABEL_31;
  }
  v16 = 0;
LABEL_134:
  if (a3 >= 4)
  {
    if (*((_BYTE *)a1 + 15))
    {
LABEL_136:
      v12 = 411;
      goto LABEL_137;
    }
    if (!v16)
    {
      sub_1001E0CF8(v79, v77, v78, v11 & 1, (uint64_t)v83);
      return;
    }
    *(_QWORD *)buf = 0;
    if (sub_1001DB044(v78, (uint64_t *)buf))
    {
      if (sub_10005549C())
      {
        sub_100054530("cid %d not found", v78);
        v68 = sub_1000544A0(0x2Fu);
        if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
          sub_1006D2728();
      }
    }
    else
    {
      v69 = *(_BYTE **)sub_1001E3CCC(*(int **)buf);
      v70 = sub_1001E3CCC(*(int **)buf);
      sub_1001FF230("aaad", 5u, 0, v69, v77, v71, v72, v73, *(unsigned __int16 *)(v70 + 8));
    }
    goto LABEL_145;
  }
LABEL_137:
  if (sub_10005549C())
  {
    sub_100054530("SignalMan_RecvConfigReq %!", v12);
    v64 = sub_1000544A0(0x2Fu);
    if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  if ((_DWORD)v12 != 428
    || (v65 = sub_100180494(v79 + 48, 0xDu), !(_DWORD)v65)
    || (v66 = v65, !sub_10005549C())
    || (sub_100054530("Failed to forced disconnect %!", v66),
        v67 = sub_1000544A0(0x2Fu),
        !os_log_type_enabled(v67, OS_LOG_TYPE_ERROR)))
  {
    if (!v16)
      return;
    goto LABEL_145;
  }
  sub_1006CEEC0();
  if (v16)
LABEL_145:
    sub_100053298(v16);
}

void sub_100202EA8(uint64_t *a1, unsigned int a2, int a3, uint64_t a4)
{
  int v8;
  uint64_t v9;
  int v10;
  char v11;
  unsigned int v12;
  int v13;
  int v14;
  unsigned int v15;
  _OWORD *v16;
  int v17;
  int v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  NSObject *v24;
  int v25;
  uint64_t v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unsigned __int16 v36;
  unsigned int v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  void *v46;
  NSObject *v47;
  __int16 v48;
  unsigned __int16 v49;
  char v50;
  unsigned int v51;
  uint64_t v52;
  char *v53;
  char *v54;
  char *v55;
  int *v56;
  _OWORD v57[3];
  __int16 v58;
  int v59;
  uint8_t buf[4];
  void *v61;
  __int16 v62;
  int v63;

  v59 = 0;
  v58 = 0;
  memset(v57, 0, 44);
  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1323, "void SignalMan_RecvConfigRsp(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
    v8 = 0;
  }
  else
  {
    v8 = *((unsigned __int16 *)a1 + 5) - *((unsigned __int16 *)a1 + 6);
  }
  if (v8 < a3)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
  if (*((_BYTE *)a1 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
  v9 = *((unsigned __int16 *)a1 + 6);
  v52 = a4;
  v51 = a2;
  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1329, "void SignalMan_RecvConfigRsp(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
    v10 = *((unsigned __int8 *)a1 + 14);
    *((_BYTE *)a1 + 15) = 1;
    if (v10 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
    goto LABEL_14;
  }
  if (*((unsigned __int16 *)a1 + 5) - (int)v9 <= 1)
  {
    *((_BYTE *)a1 + 15) = 1;
LABEL_14:
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1330, "void SignalMan_RecvConfigRsp(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
    v14 = *((unsigned __int8 *)a1 + 14);
    *((_BYTE *)a1 + 15) = 1;
    if (v14 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
    v49 = 0;
    goto LABEL_16;
  }
  v49 = *(_WORD *)(*a1 + v9);
  *((_WORD *)a1 + 6) = v9 + 2;
  if (*((unsigned __int16 *)a1 + 5) - (unsigned __int16)(v9 + 2) <= 1)
  {
    *((_BYTE *)a1 + 15) = 1;
LABEL_16:
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1334, "void SignalMan_RecvConfigRsp(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
    v50 = 0;
    LOWORD(v12) = *((_WORD *)a1 + 6);
    goto LABEL_17;
  }
  v11 = *(_BYTE *)(*a1 + (unsigned __int16)(v9 + 2));
  LOWORD(v12) = v9 + 4;
  *((_WORD *)a1 + 6) = v9 + 4;
  v50 = v11 & 1;
  if (*((unsigned __int16 *)a1 + 5) - (unsigned __int16)(v9 + 4) >= 2)
  {
    v13 = 0;
    v48 = *(_WORD *)(*a1 + (unsigned __int16)(v9 + 4));
    LOWORD(v12) = v9 + 6;
    *((_WORD *)a1 + 6) = v9 + 6;
    goto LABEL_18;
  }
LABEL_17:
  v48 = 0;
  v13 = 1;
  *((_BYTE *)a1 + 15) = 1;
LABEL_18:
  v15 = v9 + a3;
  if ((int)v9 + a3 > (unsigned __int16)v12)
  {
    v16 = 0;
    v53 = 0;
    v54 = 0;
    v55 = 0;
    v56 = 0;
    v17 = 0;
    v18 = 0;
    while (2)
    {
      if (*((_BYTE *)a1 + 15))
        goto LABEL_97;
      if (*((_BYTE *)a1 + 14) != 1)
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
      v19 = *((unsigned __int16 *)a1 + 5);
      if (v19 <= (unsigned __int16)v12)
      {
        *((_BYTE *)a1 + 15) = 1;
        sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1339, "void SignalMan_RecvConfigRsp(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
      }
      else
      {
        v20 = *a1;
        *((_WORD *)a1 + 6) = v12 + 1;
        v17 = *(unsigned __int8 *)(v20 + (unsigned __int16)v12);
        if (v19 > (unsigned __int16)(v12 + 1))
        {
          v21 = *a1;
          *((_WORD *)a1 + 6) = v12 + 2;
          v18 = *(unsigned __int8 *)(v21 + (unsigned __int16)v12 + 1);
          v22 = 1;
LABEL_27:
          switch(v17)
          {
            case 1:
              if (*((_BYTE *)a1 + 14) != 1)
                sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
              if ((v22 & 1) == 0)
              {
                sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1342, "void SignalMan_RecvConfigRsp(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
LABEL_59:
                *((_BYTE *)a1 + 15) = 1;
                goto LABEL_60;
              }
              v23 = *((unsigned __int16 *)a1 + 6);
              if (*((unsigned __int16 *)a1 + 5) - (int)v23 < 2)
                goto LABEL_59;
              HIWORD(v59) = *(_WORD *)(*a1 + v23);
              *((_WORD *)a1 + 6) = v23 + 2;
LABEL_60:
              v55 = (char *)&v59 + 2;
LABEL_90:
              v12 = *((unsigned __int16 *)a1 + 6);
              if (v15 <= v12)
              {
                if (*((_BYTE *)a1 + 15))
                  goto LABEL_97;
                goto LABEL_101;
              }
              continue;
            case 2:
              if (*((_BYTE *)a1 + 14) != 1)
                sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
              if ((v22 & 1) != 0)
              {
                v26 = *((unsigned __int16 *)a1 + 6);
                if (*((unsigned __int16 *)a1 + 5) - (int)v26 >= 2)
                {
                  LOWORD(v59) = *(_WORD *)(*a1 + v26);
                  *((_WORD *)a1 + 6) = v26 + 2;
LABEL_63:
                  v56 = &v59;
                  goto LABEL_90;
                }
              }
              else
              {
                sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1346, "void SignalMan_RecvConfigRsp(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
              }
              *((_BYTE *)a1 + 15) = 1;
              goto LABEL_63;
            case 3:
              if (*((_BYTE *)a1 + 14) != 1)
                sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
              if ((v22 & 1) != 0)
              {
                v27 = *((unsigned __int16 *)a1 + 5);
                v28 = *((unsigned __int16 *)a1 + 6);
                if (v27 > v28)
                {
                  v29 = *a1;
                  *((_WORD *)a1 + 6) = v28 + 1;
                  HIBYTE(v58) = *(_BYTE *)(v29 + v28);
                  v30 = v27 - (v28 + 1);
LABEL_66:
                  if (v30 >= v18 - 1)
                    *((_WORD *)a1 + 6) += v18 - 1;
                  else
                    *((_BYTE *)a1 + 15) = 1;
                  v54 = (char *)&v58 + 1;
                  goto LABEL_90;
                }
              }
              else
              {
                sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1361, "void SignalMan_RecvConfigRsp(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
              }
              *((_BYTE *)a1 + 15) = 1;
              sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1362, "void SignalMan_RecvConfigRsp(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
              v30 = 0;
              goto LABEL_66;
            case 4:
              if (*((_BYTE *)a1 + 14) != 1)
                sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
              if (v22)
              {
                v31 = *((unsigned __int16 *)a1 + 6);
                if (*((unsigned __int16 *)a1 + 5) > v31)
                {
                  v32 = *a1;
                  *((_WORD *)a1 + 6) = v31 + 1;
                  BYTE10(v57[0]) = *(_BYTE *)(v32 + v31);
                  if (*((unsigned __int16 *)a1 + 5) > (v31 + 1))
                  {
                    v33 = *a1;
                    v34 = v31 + 2;
                    *((_WORD *)a1 + 6) = v31 + 2;
                    BYTE11(v57[0]) = *(_BYTE *)(v33 + v31 + 1);
                    if (*((unsigned __int16 *)a1 + 5) > (v31 + 2))
                    {
                      v35 = *a1;
                      v36 = v31 + 3;
                      *((_WORD *)a1 + 6) = v36;
                      BYTE12(v57[0]) = *(_BYTE *)(v35 + v34);
                      if (*((unsigned __int16 *)a1 + 5) - v36 > 1)
                      {
                        HIWORD(v57[0]) = *(_WORD *)(*a1 + v36);
                        *((_WORD *)a1 + 6) = v36 + 2;
                        if (*((unsigned __int16 *)a1 + 5) - (unsigned __int16)(v36 + 2) > 1)
                        {
                          LOWORD(v57[1]) = *(_WORD *)(*a1 + (unsigned __int16)(v36 + 2));
                          *((_WORD *)a1 + 6) = v36 + 4;
                          if (*((unsigned __int16 *)a1 + 5) - (unsigned __int16)(v36 + 4) >= 2)
                          {
                            WORD1(v57[1]) = *(_WORD *)(*a1 + (unsigned __int16)(v36 + 4));
                            *((_WORD *)a1 + 6) = v36 + 6;
LABEL_89:
                            v16 = v57;
                            goto LABEL_90;
                          }
LABEL_88:
                          *((_BYTE *)a1 + 15) = 1;
                          goto LABEL_89;
                        }
                        *((_BYTE *)a1 + 15) = 1;
LABEL_87:
                        sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1356, "void SignalMan_RecvConfigRsp(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
                        goto LABEL_88;
                      }
                      *((_BYTE *)a1 + 15) = 1;
LABEL_86:
                      sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1355, "void SignalMan_RecvConfigRsp(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
                      v45 = *((unsigned __int8 *)a1 + 14);
                      *((_BYTE *)a1 + 15) = 1;
                      if (v45 != 1)
                        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestac"
                                               "k/l2cap/signalman.c");
                      goto LABEL_87;
                    }
                    *((_BYTE *)a1 + 15) = 1;
LABEL_85:
                    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1354, "void SignalMan_RecvConfigRsp(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
                    v44 = *((unsigned __int8 *)a1 + 14);
                    *((_BYTE *)a1 + 15) = 1;
                    if (v44 != 1)
                      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/"
                                             "l2cap/signalman.c");
                    goto LABEL_86;
                  }
                  *((_BYTE *)a1 + 15) = 1;
LABEL_84:
                  sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1353, "void SignalMan_RecvConfigRsp(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
                  v43 = *((unsigned __int8 *)a1 + 14);
                  *((_BYTE *)a1 + 15) = 1;
                  if (v43 != 1)
                    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
                  goto LABEL_85;
                }
                *((_BYTE *)a1 + 15) = 1;
              }
              else
              {
                sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1351, "void SignalMan_RecvConfigRsp(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
                v41 = *((unsigned __int8 *)a1 + 14);
                *((_BYTE *)a1 + 15) = 1;
                if (v41 != 1)
                  sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
              }
              sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1352, "void SignalMan_RecvConfigRsp(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
              v42 = *((unsigned __int8 *)a1 + 14);
              *((_BYTE *)a1 + 15) = 1;
              if (v42 != 1)
                sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
              goto LABEL_84;
            case 5:
              if (*((_BYTE *)a1 + 14) != 1)
                sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
              if ((v22 & 1) != 0)
              {
                v37 = *((unsigned __int16 *)a1 + 5);
                v38 = *((unsigned __int16 *)a1 + 6);
                if (v37 > v38)
                {
                  v39 = *a1;
                  *((_WORD *)a1 + 6) = v38 + 1;
                  LOBYTE(v58) = *(_BYTE *)(v39 + v38);
                  v40 = v37 - (v38 + 1);
LABEL_72:
                  if (v40 >= v18 - 1)
                    *((_WORD *)a1 + 6) += v18 - 1;
                  else
                    *((_BYTE *)a1 + 15) = 1;
                  v53 = (char *)&v58;
                  goto LABEL_90;
                }
              }
              else
              {
                sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1365, "void SignalMan_RecvConfigRsp(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
              }
              *((_BYTE *)a1 + 15) = 1;
              sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1366, "void SignalMan_RecvConfigRsp(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
              v40 = 0;
              goto LABEL_72;
            default:
              if (sub_10005549C())
              {
                sub_100054530("rcvd config rsp with unknown option (%d) len %d, ignoring option", v17, v18);
                v24 = sub_1000544A0(0x2Fu);
                if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
                {
                  v46 = sub_100054494();
                  *(_DWORD *)buf = 136446466;
                  v61 = v46;
                  v62 = 1024;
                  v63 = 0xFFFF;
                  _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "%{public}s (status=%{bluetooth:OI_STATUS}u)", buf, 0x12u);
                }
              }
              if (*((_BYTE *)a1 + 15))
              {
                sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1371, "void SignalMan_RecvConfigRsp(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
                v25 = 0;
              }
              else
              {
                v25 = *((unsigned __int16 *)a1 + 5) - *((unsigned __int16 *)a1 + 6);
              }
              if (v25 >= v18)
                *((_WORD *)a1 + 6) += v18;
              else
                *((_BYTE *)a1 + 15) = 1;
              goto LABEL_90;
          }
        }
      }
      break;
    }
    v22 = 0;
    *((_BYTE *)a1 + 15) = 1;
    goto LABEL_27;
  }
  v54 = 0;
  v55 = 0;
  v56 = 0;
  v53 = 0;
  v16 = 0;
  if (v13)
  {
LABEL_97:
    if (sub_10005549C())
    {
      sub_100054530("SignalMan_RecvConfigRsp - %!", 411);
      v47 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  else
  {
LABEL_101:
    sub_1001E1618(v52, v51, v49, v50, (uint64_t)v55, (uint64_t)v54, (uint64_t)v56, (uint64_t)v16, v53, v48);
  }
}

void sub_100203800(uint64_t a1, uint64_t a2, int a3, _BYTE *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v12;
  unsigned __int16 v13;
  __int16 v14;

  v14 = 771;
  v13 = 0;
  if (*(_BYTE *)(a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1109, "void SignalMan_RecvDisconnectReq(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
    v12 = 0;
  }
  else
  {
    v12 = *(unsigned __int16 *)(a1 + 10) - *(unsigned __int16 *)(a1 + 12);
  }
  if (v12 < a3)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
  if (!sub_1002524E0((uint64_t *)a1, 1u, (uint64_t)&v14, 2u, a5, a6, a7, a8, (uint64_t)&v13))
    sub_1001E19BC(a4, v13, 0, a2);
}

void sub_1002038D4(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v11;
  unsigned __int16 v12;
  __int16 v13;

  v13 = 771;
  if (*(_BYTE *)(a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1129, "void SignalMan_RecvDisconnectRsp(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
    v11 = 0;
  }
  else
  {
    v11 = *(unsigned __int16 *)(a1 + 10) - *(unsigned __int16 *)(a1 + 12);
  }
  if (v11 < a3)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
  v12 = 0;
  if (!sub_1002524E0((uint64_t *)a1, 1u, (uint64_t)&v13, 2u, a5, a6, a7, a8, (uint64_t)&v12))
    sub_1001E1DDC(a4, v12, 0);
}

void sub_1002039A8(uint64_t *a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  int v16;
  __int16 v17;

  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1396, "void SignalMan_RecvEchoReq(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
    v8 = 0;
  }
  else
  {
    v8 = *((unsigned __int16 *)a1 + 5) - *((unsigned __int16 *)a1 + 6);
  }
  if (v8 < (int)a3)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
  v17 = 0;
  v16 = 0;
  if (sub_100182620((uint64_t)a4, (uint64_t)&v16))
  {
    if (sub_10005549C())
    {
      sub_100054530("getBdaddrFromHandle failed");
      v12 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  else if (a3 >= 0x18 && off_1009859E0)
  {
    off_1009859E0(*a1, *((unsigned __int16 *)a1 + 5), a3, a2, a4);
  }
  else
  {
    v13 = *a1;
    v14 = *((unsigned __int16 *)a1 + 6);
    if ((_DWORD)a3 == 5
      && (*(_DWORD *)(v13 + v14) == 1819308097 ? (v15 = *(_BYTE *)(v13 + v14 + 4) == 101) : (v15 = 0), v15))
    {
      sub_1001FF230("d", 9u, 0, a4, a2, v9, v10, v11, (uint64_t)"Apple Computer Inc.");
    }
    else
    {
      sub_1001FF230("d", 9u, 0, a4, a2, v9, v10, v11, v13 + v14);
    }
  }
}

void sub_100203B3C(uint64_t a1, int a2, uint64_t a3)
{
  int v6;
  uint64_t v7;
  void (*v8)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, uint64_t, _QWORD);
  NSObject *v9;

  if (*(_BYTE *)(a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1430, "void SignalMan_RecvEchoRsp(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
    v6 = 0;
  }
  else
  {
    v6 = *(unsigned __int16 *)(a1 + 10) - *(unsigned __int16 *)(a1 + 12);
  }
  if (v6 < (int)a3)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
  v7 = qword_1009859E8;
  if (!qword_1009859E8)
    goto LABEL_13;
  while (*(unsigned __int8 *)(v7 + 153) != a2)
  {
    v7 = *(_QWORD *)(v7 + 192);
    if (!v7)
      goto LABEL_13;
  }
  if (*(_BYTE *)(v7 + 152) == 8)
  {
    v8 = *(void (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, uint64_t, _QWORD))(v7 + 200);
    if (!v8)
    {
      sub_100253460();
      v8 = *(void (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, uint64_t, _QWORD))(v7 + 200);
    }
    v8(v7 + 180, *(_QWORD *)(v7 + 168), *(_QWORD *)(v7 + 208), *(unsigned __int16 *)(v7 + 216), *(_QWORD *)a1 + *(unsigned __int16 *)(a1 + 12), a3, 0);
    sub_10020107C(v7, 0);
  }
  else
  {
LABEL_13:
    if (sub_10005549C())
    {
      sub_100054530("Unexpected Echo Response (id %d)", a2);
      v9 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_1006D3A00();
    }
  }
}

void sub_100203C90(uint64_t a1, char a2, int a3, _BYTE *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  NSObject *v16;
  int v17;
  uint64_t v18;

  v17 = 0;
  if (*(_BYTE *)(a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1457, "void SignalMan_RecvInfoReq(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
    v12 = 0;
  }
  else
  {
    v12 = *(unsigned __int16 *)(a1 + 10) - *(unsigned __int16 *)(a1 + 12);
  }
  if (v12 < a3)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
  if (*(_BYTE *)(a1 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
  if (*(_BYTE *)(a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1459, "void SignalMan_RecvInfoReq(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
    goto LABEL_13;
  }
  v13 = *(unsigned __int16 *)(a1 + 12);
  if (*(unsigned __int16 *)(a1 + 10) - (int)v13 < 2)
  {
LABEL_13:
    *(_BYTE *)(a1 + 15) = 1;
    if (sub_10005549C())
    {
      sub_100054530("SignalMan_RecvInfoReq - %!", 411);
      v15 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return;
  }
  v14 = *(unsigned __int16 *)(*(_QWORD *)a1 + v13);
  *(_WORD *)(a1 + 12) = v13 + 2;
  switch((_DWORD)v14)
  {
    case 3:
      v18 = 0;
      if (sub_1001DBAB4(&v18))
      {
        if (sub_10005549C())
        {
          sub_100054530("Error retreiving the supported fixed channels");
          v16 = sub_1000544A0(0x2Fu);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
      }
      v14 = 3;
      break;
    case 2:
      sub_1001FEEF8((char *)&v17);
      v14 = 2;
      break;
    case 1:
      sub_100252DE8(0x2Fu);
      v14 = 1;
      break;
  }
  sub_1001FF230("aad", 0xBu, 0, a4, a2, a6, a7, a8, v14);
}

void sub_100203EF4(uint64_t *a1, int a2, unsigned int a3, uint64_t a4)
{
  int v8;
  int v9;
  unsigned __int16 v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  unsigned __int16 v15;
  unsigned __int16 v16;
  int v17;
  unsigned __int16 v18;
  int v19;
  uint64_t v20;
  NSObject *v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  NSObject *v26;
  uint64_t v27;

  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1525, "void SignalMan_RecvInfoRsp(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
    v8 = 0;
  }
  else
  {
    v8 = *((unsigned __int16 *)a1 + 5) - *((unsigned __int16 *)a1 + 6);
  }
  if (v8 < (int)a3)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
  if (a3 <= 3)
    sub_100253460();
  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1528, "void SignalMan_RecvInfoRsp(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
    v9 = 0;
  }
  else
  {
    v9 = *((unsigned __int16 *)a1 + 5) - *((unsigned __int16 *)a1 + 6);
  }
  v10 = a3 - 4;
  if (a3 < 4 || v9 < (int)a3)
  {
    if (sub_10005549C())
    {
      if (*((_BYTE *)a1 + 15))
      {
        sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1529, "void SignalMan_RecvInfoRsp(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
        v12 = 0;
      }
      else
      {
        v12 = *((unsigned __int16 *)a1 + 5) - *((unsigned __int16 *)a1 + 6);
      }
      sub_100054530("Invalid RecvInfoRsp input: cmdLen %d, NumReadBytesAvail %d.  Disconecting physical link.", a3, v12);
      v21 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    sub_10018070C(a4 + 48);
    return;
  }
  if (*((_BYTE *)a1 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1534, "void SignalMan_RecvInfoRsp(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
    v11 = *((unsigned __int8 *)a1 + 14);
    *((_BYTE *)a1 + 15) = 1;
    if (v11 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
    goto LABEL_28;
  }
  v13 = *((unsigned __int16 *)a1 + 6);
  if (*((unsigned __int16 *)a1 + 5) - (int)v13 <= 1)
  {
    *((_BYTE *)a1 + 15) = 1;
LABEL_28:
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1535, "void SignalMan_RecvInfoRsp(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
    v15 = 0;
    v14 = *a1;
    v16 = *((_WORD *)a1 + 6);
    goto LABEL_29;
  }
  v14 = *a1;
  v15 = *(_WORD *)(*a1 + v13);
  v16 = v13 + 2;
  *((_WORD *)a1 + 6) = v13 + 2;
  if (*((unsigned __int16 *)a1 + 5) - (unsigned __int16)(v13 + 2) < 2)
  {
LABEL_29:
    *((_BYTE *)a1 + 15) = 1;
    v20 = v14 + v16;
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1540, "void SignalMan_RecvInfoRsp(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
    v22 = 0;
    goto LABEL_30;
  }
  v17 = *(unsigned __int16 *)(v14 + (unsigned __int16)(v13 + 2));
  v18 = v13 + 4;
  *((_WORD *)a1 + 6) = v13 + 4;
  if (!v17)
  {
    v20 = v14 + v18;
    v22 = *((unsigned __int16 *)a1 + 5) - v18;
LABEL_30:
    v17 = 0;
    if (v22 >= v10)
    {
      *((_WORD *)a1 + 6) += v10;
      v19 = 1;
    }
    else
    {
      v19 = 1;
      *((_BYTE *)a1 + 15) = 1;
    }
    goto LABEL_33;
  }
  v19 = 0;
  v10 = 0;
  v20 = 0;
LABEL_33:
  v23 = qword_1009859E8;
  if (!qword_1009859E8)
    goto LABEL_42;
  while (*(unsigned __int8 *)(v23 + 153) != a2)
  {
    v23 = *(_QWORD *)(v23 + 192);
    if (!v23)
      goto LABEL_42;
  }
  if (*(_BYTE *)(v23 + 152) == 10)
  {
    sub_100049F6C(*(unsigned int *)(v23 + 176));
    if (!*(_QWORD *)(v23 + 208))
      sub_100253460();
    if (*((_BYTE *)a1 + 15))
    {
      v24 = v23;
      v25 = 411;
    }
    else
    {
      if (v19)
        v27 = 0;
      else
        v27 = (v17 + 470);
      (*(void (**)(uint64_t, _QWORD, _QWORD, uint64_t, _QWORD, uint64_t))(v23 + 208))(v23 + 180, *(_QWORD *)(v23 + 168), v15, v20, v10, v27);
      v24 = v23;
      v25 = 0;
    }
    sub_10020107C(v24, v25);
  }
  else
  {
LABEL_42:
    if (sub_10005549C())
    {
      sub_100054530("Unexpected Info Response (id %d)", a2);
      v26 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        sub_1006D3A00();
    }
  }
}

uint64_t sub_1002042A8(uint64_t a1, char a2, int a3, _BYTE *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v12;
  int v13;
  NSObject *v14;
  int v15;
  int v16;

  if (*(_BYTE *)(a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1572, "void SignalMan_RecvCreateChannelReq(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
    v12 = 0;
  }
  else
  {
    v12 = *(unsigned __int16 *)(a1 + 10) - *(unsigned __int16 *)(a1 + 12);
  }
  if (v12 < a3)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
  if (a3 == 5)
  {
    if (*(_BYTE *)(a1 + 14) != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
    if (*(_BYTE *)(a1 + 15))
    {
      sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1575, "void SignalMan_RecvCreateChannelReq(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
      v13 = *(unsigned __int8 *)(a1 + 14);
      *(_BYTE *)(a1 + 15) = 1;
      if (v13 != 1)
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
      goto LABEL_18;
    }
    v15 = *(unsigned __int16 *)(a1 + 12);
    if (*(unsigned __int16 *)(a1 + 10) - v15 <= 1)
    {
      *(_BYTE *)(a1 + 15) = 1;
LABEL_18:
      sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1576, "void SignalMan_RecvCreateChannelReq(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
      v16 = *(unsigned __int8 *)(a1 + 14);
      *(_BYTE *)(a1 + 15) = 1;
      if (v16 != 1)
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
      goto LABEL_19;
    }
    *(_WORD *)(a1 + 12) = v15 + 2;
    if (*(unsigned __int16 *)(a1 + 10) - (unsigned __int16)(v15 + 2) <= 1)
    {
      *(_BYTE *)(a1 + 15) = 1;
LABEL_19:
      sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1577, "void SignalMan_RecvCreateChannelReq(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
      goto LABEL_20;
    }
    *(_WORD *)(a1 + 12) = v15 + 4;
    if (*(unsigned __int16 *)(a1 + 10) <= (unsigned __int16)(v15 + 4))
    {
LABEL_20:
      *(_BYTE *)(a1 + 15) = 1;
      return sub_1001FF230("ad", 1u, 0, a4, a2, a6, a7, a8, 0);
    }
    *(_WORD *)(a1 + 12) = v15 + 5;
  }
  else if (sub_10005549C())
  {
    sub_100054530("Wrong command size for channel creation command");
    v14 = sub_1000544A0(0x2Fu);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  return sub_1001FF230("ad", 1u, 0, a4, a2, a6, a7, a8, 0);
}

void sub_1002044DC(uint64_t a1, int a2, int a3)
{
  int v6;
  int v7;
  NSObject *v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;

  if (*(_BYTE *)(a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1604, "void SignalMan_RecvCreateChannelRsp(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
    v6 = 0;
  }
  else
  {
    v6 = *(unsigned __int16 *)(a1 + 10) - *(unsigned __int16 *)(a1 + 12);
  }
  if (v6 < a3)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
  if (a3 != 8)
  {
    if (sub_10005549C())
    {
      sub_100054530("Wrong command size for channel creation response");
      v8 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    goto LABEL_23;
  }
  if (*(_BYTE *)(a1 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
  if (*(_BYTE *)(a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1607, "void SignalMan_RecvCreateChannelRsp(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
    v7 = *(unsigned __int8 *)(a1 + 14);
    *(_BYTE *)(a1 + 15) = 1;
    if (v7 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
    goto LABEL_19;
  }
  v9 = *(unsigned __int16 *)(a1 + 12);
  if (*(unsigned __int16 *)(a1 + 10) - v9 <= 1)
  {
    *(_BYTE *)(a1 + 15) = 1;
LABEL_19:
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1608, "void SignalMan_RecvCreateChannelRsp(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
    v10 = *(unsigned __int8 *)(a1 + 14);
    *(_BYTE *)(a1 + 15) = 1;
    if (v10 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
    goto LABEL_20;
  }
  *(_WORD *)(a1 + 12) = v9 + 2;
  if (*(unsigned __int16 *)(a1 + 10) - (unsigned __int16)(v9 + 2) <= 1)
  {
    *(_BYTE *)(a1 + 15) = 1;
LABEL_20:
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1609, "void SignalMan_RecvCreateChannelRsp(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
    v11 = *(unsigned __int8 *)(a1 + 14);
    *(_BYTE *)(a1 + 15) = 1;
    if (v11 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
    goto LABEL_21;
  }
  *(_WORD *)(a1 + 12) = v9 + 4;
  if (*(unsigned __int16 *)(a1 + 10) - (unsigned __int16)(v9 + 4) <= 1)
  {
    *(_BYTE *)(a1 + 15) = 1;
LABEL_21:
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1610, "void SignalMan_RecvCreateChannelRsp(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
    goto LABEL_22;
  }
  *(_WORD *)(a1 + 12) = v9 + 6;
  if (*(unsigned __int16 *)(a1 + 10) - (unsigned __int16)(v9 + 6) < 2)
  {
LABEL_22:
    *(_BYTE *)(a1 + 15) = 1;
    goto LABEL_23;
  }
  *(_WORD *)(a1 + 12) = v9 + 8;
LABEL_23:
  v12 = qword_1009859E8;
  if (!qword_1009859E8)
    goto LABEL_30;
  while (*(unsigned __int8 *)(v12 + 153) != a2)
  {
    v12 = *(_QWORD *)(v12 + 192);
    if (!v12)
      goto LABEL_30;
  }
  if (*(_BYTE *)(v12 + 152) == 12)
  {
    sub_100049F6C(*(unsigned int *)(v12 + 176));
    if (*(_BYTE *)(a1 + 15))
      v13 = 411;
    else
      v13 = 0;
    sub_10020107C(v12, v13);
  }
  else
  {
LABEL_30:
    if (sub_10005549C())
    {
      sub_100054530("Unexpected create channel Response (id %d)", a2);
      v14 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        sub_1006D3A00();
    }
  }
}

uint64_t sub_1002047EC(uint64_t a1, char a2, int a3, _BYTE *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v12;
  int v13;
  NSObject *v14;
  int v15;

  if (*(_BYTE *)(a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1643, "void SignalMan_RecvMoveChannelReq(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
    v12 = 0;
  }
  else
  {
    v12 = *(unsigned __int16 *)(a1 + 10) - *(unsigned __int16 *)(a1 + 12);
  }
  if (v12 < a3)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
  if (a3 == 3)
  {
    if (*(_BYTE *)(a1 + 14) != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
    if (*(_BYTE *)(a1 + 15))
    {
      sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1646, "void SignalMan_RecvMoveChannelReq(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
      v13 = *(unsigned __int8 *)(a1 + 14);
      *(_BYTE *)(a1 + 15) = 1;
      if (v13 != 1)
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
      goto LABEL_17;
    }
    v15 = *(unsigned __int16 *)(a1 + 12);
    if (*(unsigned __int16 *)(a1 + 10) - v15 <= 1)
    {
      *(_BYTE *)(a1 + 15) = 1;
LABEL_17:
      sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1647, "void SignalMan_RecvMoveChannelReq(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
      goto LABEL_18;
    }
    *(_WORD *)(a1 + 12) = v15 + 2;
    if (*(unsigned __int16 *)(a1 + 10) <= (unsigned __int16)(v15 + 2))
    {
LABEL_18:
      *(_BYTE *)(a1 + 15) = 1;
      return sub_1001FF230("ad", 1u, 0, a4, a2, a6, a7, a8, 0);
    }
    *(_WORD *)(a1 + 12) = v15 + 3;
  }
  else if (sub_10005549C())
  {
    sub_100054530("Wrong command size for channel move command");
    v14 = sub_1000544A0(0x2Fu);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  return sub_1001FF230("ad", 1u, 0, a4, a2, a6, a7, a8, 0);
}

void sub_1002049B8(uint64_t a1, int a2, int a3)
{
  int v6;
  int v7;
  NSObject *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;

  if (*(_BYTE *)(a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1667, "void SignalMan_RecvMoveChannelRsp(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
    v6 = 0;
  }
  else
  {
    v6 = *(unsigned __int16 *)(a1 + 10) - *(unsigned __int16 *)(a1 + 12);
  }
  if (v6 < a3)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
  if (a3 != 4)
  {
    if (sub_10005549C())
    {
      sub_100054530("Wrong command size for channel move response");
      v8 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    goto LABEL_19;
  }
  if (*(_BYTE *)(a1 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
  if (*(_BYTE *)(a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1670, "void SignalMan_RecvMoveChannelRsp(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
    v7 = *(unsigned __int8 *)(a1 + 14);
    *(_BYTE *)(a1 + 15) = 1;
    if (v7 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
    goto LABEL_17;
  }
  v9 = *(unsigned __int16 *)(a1 + 12);
  if (*(unsigned __int16 *)(a1 + 10) - v9 <= 1)
  {
    *(_BYTE *)(a1 + 15) = 1;
LABEL_17:
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1671, "void SignalMan_RecvMoveChannelRsp(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
    goto LABEL_18;
  }
  *(_WORD *)(a1 + 12) = v9 + 2;
  if (*(unsigned __int16 *)(a1 + 10) - (unsigned __int16)(v9 + 2) < 2)
  {
LABEL_18:
    *(_BYTE *)(a1 + 15) = 1;
    goto LABEL_19;
  }
  *(_WORD *)(a1 + 12) = v9 + 4;
LABEL_19:
  v10 = qword_1009859E8;
  if (!qword_1009859E8)
    goto LABEL_26;
  while (*(unsigned __int8 *)(v10 + 153) != a2)
  {
    v10 = *(_QWORD *)(v10 + 192);
    if (!v10)
      goto LABEL_26;
  }
  if (*(_BYTE *)(v10 + 152) == 14)
  {
    sub_100049F6C(*(unsigned int *)(v10 + 176));
    if (*(_BYTE *)(a1 + 15))
      v11 = 411;
    else
      v11 = 0;
    sub_10020107C(v10, v11);
  }
  else
  {
LABEL_26:
    if (sub_10005549C())
    {
      sub_100054530("Unexpected create channel Response (id %d)", a2);
      v12 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        sub_1006D3A00();
    }
  }
}

uint64_t sub_100204BF8(uint64_t a1, char a2, int a3, _BYTE *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v12;
  int v13;
  NSObject *v14;
  int v15;

  if (*(_BYTE *)(a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1703, "void SignalMan_RecvMoveChannelCfm(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
    v12 = 0;
  }
  else
  {
    v12 = *(unsigned __int16 *)(a1 + 10) - *(unsigned __int16 *)(a1 + 12);
  }
  if (v12 < a3)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
  if (a3 == 4)
  {
    if (*(_BYTE *)(a1 + 14) != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
    if (*(_BYTE *)(a1 + 15))
    {
      sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1705, "void SignalMan_RecvMoveChannelCfm(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
      v13 = *(unsigned __int8 *)(a1 + 14);
      *(_BYTE *)(a1 + 15) = 1;
      if (v13 != 1)
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
      goto LABEL_17;
    }
    v15 = *(unsigned __int16 *)(a1 + 12);
    if (*(unsigned __int16 *)(a1 + 10) - v15 <= 1)
    {
      *(_BYTE *)(a1 + 15) = 1;
LABEL_17:
      sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1706, "void SignalMan_RecvMoveChannelCfm(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
      goto LABEL_18;
    }
    *(_WORD *)(a1 + 12) = v15 + 2;
    if (*(unsigned __int16 *)(a1 + 10) - (unsigned __int16)(v15 + 2) < 2)
    {
LABEL_18:
      *(_BYTE *)(a1 + 15) = 1;
      return sub_1001FF230("ad", 1u, 0, a4, a2, a6, a7, a8, 0);
    }
    *(_WORD *)(a1 + 12) = v15 + 4;
  }
  else if (sub_10005549C())
  {
    sub_100054530("Wrong command size for channel move confirmation");
    v14 = sub_1000544A0(0x2Fu);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  return sub_1001FF230("ad", 1u, 0, a4, a2, a6, a7, a8, 0);
}

void sub_100204DC8(uint64_t a1, int a2, int a3)
{
  int v6;
  NSObject *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;

  if (*(_BYTE *)(a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1723, "void SignalMan_RecvMoveChannelCfmRsp(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
    v6 = 0;
  }
  else
  {
    v6 = *(unsigned __int16 *)(a1 + 10) - *(unsigned __int16 *)(a1 + 12);
  }
  if (v6 < a3)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
  if (a3 != 2)
  {
    if (sub_10005549C())
    {
      sub_100054530("Wrong command size for channel move response");
      v7 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    goto LABEL_15;
  }
  if (*(_BYTE *)(a1 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c");
  if (*(_BYTE *)(a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/l2cap/signalman.c", 1726, "void SignalMan_RecvMoveChannelCfmRsp(OI_BYTE_STREAM *, uint8_t, uint16_t, OI_HCI_CONNECTION_HANDLE)");
LABEL_14:
    *(_BYTE *)(a1 + 15) = 1;
    goto LABEL_15;
  }
  v8 = *(unsigned __int16 *)(a1 + 12);
  if (*(unsigned __int16 *)(a1 + 10) - v8 < 2)
    goto LABEL_14;
  *(_WORD *)(a1 + 12) = v8 + 2;
LABEL_15:
  v9 = qword_1009859E8;
  if (!qword_1009859E8)
    goto LABEL_22;
  while (*(unsigned __int8 *)(v9 + 153) != a2)
  {
    v9 = *(_QWORD *)(v9 + 192);
    if (!v9)
      goto LABEL_22;
  }
  if (*(_BYTE *)(v9 + 152) == 16)
  {
    sub_100049F6C(*(unsigned int *)(v9 + 176));
    if (*(_BYTE *)(a1 + 15))
      v10 = 411;
    else
      v10 = 0;
    sub_10020107C(v9, v10);
  }
  else
  {
LABEL_22:
    if (sub_10005549C())
    {
      sub_100054530("Unexpected move channel Confirmation Response (id %d)", a2);
      v11 = sub_1000544A0(0x2Fu);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        sub_1006D3A00();
    }
  }
}

uint64_t sub_100204FE0()
{
  return byte_1009859F0;
}

void sub_100204FEC(int a1)
{
  const char *v2;
  NSObject *v3;
  unsigned int v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  void *v17;
  uint8_t buf[4];
  void *v19;
  __int16 v20;
  int v21;

  if (sub_10005549C())
  {
    v2 = "incoming connection";
    if (a1)
      v2 = "address change";
    sub_100054530("Advertising stopped due to %s", v2);
    v3 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v19 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  byte_1009859F1 = 0;
  v4 = byte_100989BC0;
  if (byte_100989BC0)
  {
    v5 = &byte_100986705;
    v6 = byte_100989BC0;
    do
    {
      *v5 = 0;
      v5 += 3368;
      --v6;
    }
    while (v6);
    if (byte_100989BC1)
    {
      v7 = sub_10004C9BC(207, 0);
      if ((_DWORD)v7)
      {
        v8 = v7;
        if (sub_10005549C())
        {
          sub_100054530("Could not stop the LE advertising OI_HCI_CMD_LE_SetExtendedAdvertisingEnable returned %!", v8, 0, 0, 0, 0);
          v9 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
      }
    }
    else
    {
      v13 = a1 ^ 1u;
      if (v4 > v13)
      {
        do
        {
          v14 = sub_1001F99EC();
          if ((_DWORD)v14)
          {
            v15 = v14;
            if (sub_10005549C())
            {
              sub_100054530("Could not stop the LE advertising for instance %d with status %!, but moving forward !", byte_100989BC2[v13], v15);
              v16 = sub_1000544A0(0x42u);
              if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
              {
                v17 = sub_100054494();
                *(_DWORD *)buf = 136446466;
                v19 = v17;
                v20 = 1024;
                v21 = 0xFFFF;
                _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "%{public}s (status=%{bluetooth:OI_STATUS}u)", buf, 0x12u);
              }
            }
          }
          ++v13;
        }
        while (v13 < byte_100989BC0);
      }
    }
    sub_1002052FC(0);
  }
  else
  {
    if (a1)
    {
      if (!byte_100986705)
        return;
      v10 = sub_10004C9BC(170, sub_100205638);
      if (!(_DWORD)v10)
      {
        byte_100986705 = 3;
        return;
      }
      v11 = v10;
      if (sub_10005549C())
      {
        sub_100054530("Could not stop the LE advertising : %!", v11);
        v12 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
    }
    else
    {
      byte_100986705 = 0;
    }
    sub_100205638(0);
  }
}

void sub_1002052FC(uint64_t a1)
{
  uint64_t v2;
  char *v3;
  uint64_t v4;
  unint64_t v5;
  _BYTE *v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  void *v10;
  unint64_t v11;
  char *v12;
  NSObject *v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  NSObject *v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  uint8_t buf[4];
  void *v23;
  __int16 v24;
  int v25;

  if (byte_100989BC1)
  {
    v2 = byte_100989BC0;
    if (byte_100989BC0)
    {
      v3 = &byte_100986705;
      do
      {
        *v3 = 0;
        v3 += 3368;
        --v2;
      }
      while (v2);
    }
  }
  else
  {
    v4 = byte_100989BCC;
    BYTE5(qword_1009859F8[421 * byte_100989BCC + 417]) = 0;
    if ((int)v4 + 1 < byte_100989BC0)
    {
      v5 = v4 + 1;
      v6 = (char *)&qword_1009859F8[421 * v4 + 838] + 5;
      do
      {
        if (*v6 == 2)
        {
          byte_100989BCC = v5;
          v7 = sub_1001F99EC();
          if (!(_DWORD)v7)
            return;
          v8 = v7;
          if (sub_10005549C())
          {
            sub_100054530("Could not stop the LE advertising : %!", v8);
            v9 = sub_1000544A0(0x42u);
            if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
            {
              v10 = sub_100054494();
              *(_DWORD *)buf = 136446466;
              v23 = v10;
              v24 = 1024;
              v25 = 0xFFFF;
              _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%{public}s (status=%{bluetooth:OI_STATUS}u)", buf, 0x12u);
            }
          }
        }
        *v6 = 0;
        ++v5;
        v6 += 3368;
      }
      while (v5 < byte_100989BC0);
    }
  }
  if (byte_1009859F0)
  {
    v11 = 0;
    v12 = &byte_100986705;
    do
    {
      if (*v12)
      {
        sub_100253460();
        if (*v12)
        {
          if (sub_10005549C())
          {
            sub_100054530("instance=%d state=%d instead of 0", v20, v21);
            v13 = sub_1000544A0(0x42u);
            if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
            {
              v14 = sub_100054494();
              *(_DWORD *)buf = 136446466;
              v23 = v14;
              v24 = 1024;
              v25 = 0xFFFF;
              _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%{public}s (status=%{bluetooth:OI_STATUS}u)", buf, 0x12u);
            }
          }
          *v12 = 0;
        }
      }
      ++v11;
      v12 += 3368;
    }
    while (v11 < byte_1009859F0);
  }
  if ((byte_1009859F1 & 1) != 0)
  {
    v15 = sub_100208DC8();
    if (!(_DWORD)v15)
      return;
    v16 = v15;
    if (sub_10005549C())
    {
      sub_100054530("Failed to restart advertising : %!", v16);
      v17 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    byte_100986705 = 0;
    v18 = v16;
    v19 = 0;
  }
  else
  {
    byte_100986705 = 0;
    v18 = a1;
    v19 = 1;
  }
  sub_1002088E4(v18, v19, 0);
}

void sub_100205638(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int8 v10[8];

  byte_100986705 = 0;
  if (byte_1009859F1 == 1)
  {
    *(_DWORD *)&v10[3] = 0;
    *(_DWORD *)v10 = 0;
    sub_100073B84((uint64_t)v10);
    v8 = byte_100985A14;
    v9 = byte_100985A15;
    v7 = dword_100985A0D;
    v5 = byte_100985A0C;
    v6 = v10[0];
    v4 = (unsigned __int16)word_100985A0A;
    v1 = sub_10004C9BC(166, sub_100206088);
    if ((_DWORD)v1)
    {
      v2 = v1;
      if (sub_10005549C())
      {
        sub_100054530("Failed to restart advertising : %!", v2, v4, v5, v6, v7, (char *)&dword_100985A0D + 1, v8, v9);
        v3 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      sub_1002088E4(v2, 0, 0);
    }
  }
  else
  {
    sub_1002088E4(a1, 1, 0);
  }
}

uint64_t sub_10020573C(uint64_t a1, uint64_t a2, int a3, int a4, unsigned int a5, unsigned __int8 *a6, int a7, unsigned int a8, unsigned __int16 a9, const void *a10, char a11, unsigned __int16 a12, const void *a13, char a14, unsigned __int8 a15, int *a16, char a17, char a18, char a19, char a20,char a21,char a22,char a23,uint64_t a24)
{
  NSObject *v32;
  NSObject *v33;
  uint64_t v34;
  NSObject *v36;
  unsigned int v37;
  unsigned int v38;
  NSObject *v39;
  NSObject *v40;
  NSObject *v41;
  NSObject *v42;
  NSObject *v43;
  NSObject *v44;
  NSObject *v45;
  NSObject *v46;
  NSObject *v47;
  NSObject *v48;
  uint64_t *v49;
  int v50;
  uint64_t *v51;
  _DWORD *v52;
  BOOL v53;
  _BYTE *v54;
  unsigned int v55;
  uint64_t *v56;
  void *v57;
  uint64_t *v58;
  void *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  __int16 v67;
  NSObject *v68;
  NSObject *v69;
  _DWORD v70[2];
  uint8_t buf[4];
  void *v72;

  *(_DWORD *)((char *)v70 + 3) = 0;
  v70[0] = 0;
  if (sub_10005549C())
  {
    sub_100054530("StartAdvertising tech=%d handle=%d", byte_100989BC1, a15);
    v32 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v72 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if (!a1)
    return 101;
  if (a15 && !byte_100989BC0)
  {
    if (sub_10005549C())
    {
      sub_100054530("We're doing legacy advertising, why did we try to set handle to %d", a15);
      v33 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    sub_100253460();
    return 101;
  }
  if (sub_10022524C())
  {
    if (sub_10005549C())
    {
      sub_100054530("We are busy rotating our address");
      v36 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 4073;
  }
  byte_100989BCC = a15;
  if (byte_100989BC0)
    v37 = a15;
  else
    v37 = 0;
  if (BYTE5(qword_1009859F8[421 * v37 + 417]))
  {
    if (sub_10005549C())
    {
      v38 = byte_100989BC0 ? byte_100989BCC : 0;
      sub_100054530("LE Advertising already in progress (handle:%d state:%d).", byte_100989BCC, BYTE5(qword_1009859F8[421 * v38 + 417]));
      v39 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 118;
  }
  if ((a3 - 16385) <= 0xFFFFC01E)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("Invalid advertising interval parameters : %d", a3);
    v40 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
      return 101;
    goto LABEL_68;
  }
  if ((a4 - 16385) <= 0xFFFFC01E)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("Invalid advertising interval parameters : %d", a4);
    v41 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
      return 101;
    goto LABEL_68;
  }
  if (a5 >= 4)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("Invalid advertising type parameters : %d", a5);
    v42 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
      return 101;
    goto LABEL_68;
  }
  if (a5 == 1 && !a6)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("Address can't be NULL");
    v43 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
      return 101;
    goto LABEL_68;
  }
  if (a5 == 1 && *a6 >= 2u)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("Invalid address type parameters : %d", *a6);
    v46 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
      return 101;
LABEL_68:
    sub_1006CE7A4();
    return 101;
  }
  if ((a7 - 8) <= 0xFFFFFFF8)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("Invalid advertising map parameters : %d", a7);
    v44 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
      return 101;
    goto LABEL_68;
  }
  if (a8 >= 4)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("Invalid advertising filter parameters : %d", a8);
    v45 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
      return 101;
    goto LABEL_68;
  }
  if (a9 && !a10)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("Invalid advertising data length parameters : %d", a9);
    v47 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
      return 101;
    goto LABEL_68;
  }
  if (a12 && !a13)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("Invalid scan data length parameters : %d", a9);
    v48 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
      return 101;
    goto LABEL_68;
  }
  if (a16 && (a15 & 0xFB) != 0)
  {
    v49 = &qword_1009859F8[421 * a15];
    v50 = *a16;
    *(_DWORD *)((char *)v49 + 3345) = *(int *)((char *)a16 + 3);
    *(_DWORD *)((char *)v49 + 3342) = v50;
    *((_BYTE *)v49 + 3349) = 1;
  }
  else
  {
    v51 = &qword_1009859F8[421 * a15];
    *((_BYTE *)v51 + 3349) = 1;
    v52 = (_DWORD *)((char *)&unk_100989BCD + 8 * a15 - a15);
    v53 = *v52 == dword_100989BF0 && *(_DWORD *)((char *)v52 + 3) == *(int *)((char *)&dword_100989BF0 + 3);
    v54 = (char *)v51 + 3342;
    if (v53)
    {
      if ((a15 & 0xFB) != 0)
      {
        *v54 = 1;
        arc4random_buf((char *)&qword_1009859F8[421 * a15 + 417] + 7, 6uLL);
        HIBYTE(qword_1009859F8[421 * byte_100989BCC + 417]) &= 0x3Fu;
      }
      else
      {
        sub_10022467C(0, (uint64_t)v54);
      }
    }
    else
    {
      *(_DWORD *)v54 = *v52;
      *(_DWORD *)((char *)v51 + 3345) = *(_DWORD *)((char *)v52 + 3);
    }
  }
  if (byte_100989BC0)
  {
    v55 = byte_100989BCC;
    v56 = &qword_1009859F8[421 * byte_100989BCC];
    *v56 = a1;
    v56[1] = a2;
    *((_WORD *)v56 + 8) = a3;
    *((_WORD *)v56 + 9) = a4;
    *((_BYTE *)v56 + 20) = a5;
    *((_BYTE *)v56 + 28) = a7;
    *((_BYTE *)v56 + 29) = a8;
    *((_WORD *)v56 + 15) = a9;
    *((_BYTE *)v56 + 1684) = a11;
    *((_BYTE *)v56 + 3340) = a14;
    *((_WORD *)v56 + 841) = 0;
    *((_WORD *)v56 + 1669) = 0;
    *((_BYTE *)v56 + 3350) = a17;
    *((_BYTE *)v56 + 3351) = a18;
    *((_BYTE *)v56 + 3352) = a19;
    *((_BYTE *)v56 + 3353) = a20;
    *((_BYTE *)v56 + 3354) = a21;
    *((_BYTE *)v56 + 3355) = a22;
    *((_BYTE *)v56 + 3356) = a23;
    v57 = v56 + 4;
    v56[420] = a24;
    bzero(v56 + 4, 0x672uLL);
    if (a10)
    {
      memmove(v57, a10, a9);
      v55 = byte_100989BCC;
    }
    v58 = &qword_1009859F8[421 * v55];
    *((_WORD *)v58 + 843) = a12;
    v59 = v58 + 211;
    bzero(v58 + 211, 0x672uLL);
    if (a13)
      memmove(v59, a13, a12);
    v34 = sub_100208DC8();
  }
  else
  {
    sub_100073B84((uint64_t)v70);
    qword_1009859F8[0] = a1;
    qword_100985A00 = a2;
    word_100985A08 = a3;
    word_100985A0A = a4;
    byte_100985A0C = a5;
    if (a5 == 1)
    {
      v66 = *(_DWORD *)a6;
      v67 = *((_WORD *)a6 + 2);
      byte_100985A13 = a6[6];
      word_100985A11 = v67;
      dword_100985A0D = v66;
    }
    else
    {
      *(int *)((char *)&dword_100985A0D + 3) = 0;
      dword_100985A0D = 0;
    }
    byte_100985A14 = a7;
    byte_100985A15 = a8;
    word_100985A16 = a9;
    byte_10098608C = a11;
    byte_100986704 = a14;
    word_10098608A = 0;
    word_100986702 = 0;
    qword_100985A18[0] = 0;
    qword_100985A18[2] = 0;
    qword_100985A18[1] = 0;
    *(_QWORD *)((char *)&qword_100985A18[2] + 7) = 0;
    if (a10)
      __memmove_chk(qword_100985A18, a10, a9, 16808);
    word_10098608E = a12;
    qword_100986090[0] = 0;
    qword_100986090[2] = 0;
    qword_100986090[1] = 0;
    *(_QWORD *)((char *)&qword_100986090[2] + 7) = 0;
    if (a13)
      __memmove_chk(qword_100986090, a13, a12, 15152);
    v34 = sub_10004C9BC(166, (uint64_t (*)())sub_100206088, v60, v61, v62, v63, v64, v65, (unsigned __int16)word_100985A08);
    byte_100986705 = 1;
  }
  if (byte_100989BF7 && (++dword_100989BC8, !(dword_100989BC8 % byte_100989BF7)))
  {
    if (sub_10005549C())
    {
      sub_100054530("Faking OI_BUSY_FAIL now");
      v68 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    v34 = 118;
  }
  else if (!(_DWORD)v34)
  {
    return v34;
  }
  if (sub_10005549C())
  {
    sub_100054530("Could not start a LE advertising %!", v34);
    v69 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  return v34;
}

void sub_100206088(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;

  v1 = a1;
  if ((_DWORD)a1 || (v1 = sub_10004C9BC(168, sub_100208BB4), (_DWORD)v1))
  {
    if (sub_10005549C())
    {
      sub_100054530("advertisingParametersCb Could not start advertising : %!", v1);
      v2 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    byte_100986705 = 0;
    sub_1002088E4(v1, 0, 0);
  }
}

uint64_t sub_100206134()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  NSObject *v12;
  uint64_t v13;
  char *i;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  char v20;
  uint8_t buf[4];
  void *v23;

  if (sub_10005549C())
  {
    sub_100054530("StopAdvertising tech=%d", byte_100989BC1);
    v0 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v23 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if (sub_10022524C())
  {
    if (sub_10005549C())
    {
      sub_100054530("We are busy rotating our address");
      v7 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 4073;
  }
  v9 = byte_100989BC0;
  if (byte_100989BC0)
  {
    if (byte_100989BC1)
    {
      v10 = sub_10004C9BC(207, (uint64_t (*)())sub_1002052FC, v1, v2, v3, v4, v5, v6, 0);
      if ((_DWORD)v10)
      {
        v8 = v10;
        if (!sub_10005549C())
          return v8;
        sub_100054530("Could not stop the LE advertising OI_HCI_CMD_LE_SetExtendedAdvertisingEnable returned %!", v8, 0, 0, 0, 0);
        v11 = sub_1000544A0(0x42u);
        if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          return v8;
LABEL_14:
        sub_1006CE7A4();
        return v8;
      }
      v15 = byte_100989BC0;
      if (byte_100989BC0)
      {
        v16 = &byte_100986705;
        do
        {
          *v16 = 3;
          v16 += 3368;
          --v15;
        }
        while (v15);
      }
      return 0;
    }
    v13 = 0;
    for (i = &byte_100986705; *i != 2; i += 3368)
    {
      *i = 0;
      if (v9 == ++v13)
        return 0;
    }
    byte_100989BCC = v13;
    v17 = sub_1001F99EC();
    if ((_DWORD)v17)
    {
      v18 = v17;
      if (sub_10005549C())
      {
        sub_100054530("Could not stop the LE advertising : %!, resetting its state to idle", v18);
        v19 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      v20 = 0;
    }
    else
    {
      v20 = 3;
    }
    v8 = 0;
    *i = v20;
  }
  else
  {
    if (byte_100986705 != 2)
      return 0;
    v8 = sub_10004C9BC(170, (uint64_t (*)())sub_100205638, v1, v2, v3, v4, v5, v6, 0);
    if (!(_DWORD)v8)
    {
      byte_100986705 = 3;
      return v8;
    }
    if (sub_10005549C())
    {
      sub_100054530("Could not stop the LE advertising : %!", v8);
      v12 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        goto LABEL_14;
    }
  }
  return v8;
}

uint64_t sub_100206434(int a1)
{
  uint64_t result;

  if (byte_100986705 != 2 || (byte_1009859F1 & 1) != 0 || a1 && byte_100985A15 != 3)
    return 0;
  result = sub_100206134();
  if (!(_DWORD)result)
    byte_1009859F1 = 1;
  return result;
}

BOOL sub_100206494()
{
  return byte_100986705 == 2 && byte_100985A0C < 2u;
}

void sub_1002064B4()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  void *v16;
  uint8_t buf[4];
  void *v18;
  __int16 v19;
  int v20;

  if (sub_10005549C())
  {
    sub_100054530("Halting advertising and resetting states");
    v6 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v18 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  byte_1009859F1 = 0;
  v7 = byte_100989BC0;
  if (byte_100989BC0)
  {
    v8 = qword_1009859F8;
    do
    {
      *((_BYTE *)v8 + 3341) = 0;
      *v8 = 0;
      v8 += 421;
      --v7;
    }
    while (v7);
    if (byte_100989BC1)
    {
      v9 = sub_10004C9BC(207, 0, v0, v1, v2, v3, v4, v5, 0);
      if ((_DWORD)v9)
      {
        v10 = v9;
        if (sub_10005549C())
        {
          sub_100054530("Could not stop the LE advertising OI_HCI_CMD_LE_SetExtendedAdvertisingEnable returned %!", v10, 0, 0, 0, 0);
          v11 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
      }
    }
    else
    {
      v12 = 0;
      do
      {
        v13 = sub_1001F99EC();
        if ((_DWORD)v13)
        {
          v14 = v13;
          if (sub_10005549C())
          {
            sub_100054530("Could not stop the LE advertising for instance %d with status %!, but moving forward !", byte_100989BC2[v12], v14);
            v15 = sub_1000544A0(0x42u);
            if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
            {
              v16 = sub_100054494();
              *(_DWORD *)buf = 136446466;
              v18 = v16;
              v19 = 1024;
              v20 = 0xFFFF;
              _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%{public}s (status=%{bluetooth:OI_STATUS}u)", buf, 0x12u);
            }
          }
        }
        ++v12;
      }
      while (v12 < byte_100989BC0);
    }
  }
  byte_100989BCC = 0;
  bzero(qword_1009859F8, 0x41C8uLL);
}

void sub_100206720()
{
  bzero(&qword_1009859F8, 0x41C8uLL);
}

char *sub_100206730(unsigned int a1)
{
  return (char *)&unk_100989BCD + 8 * a1 - a1;
}

uint64_t sub_100206744(_DWORD *a1, unsigned int a2, uint64_t a3)
{
  _DWORD *v3;
  int v4;
  uint64_t v5;
  NSObject *v6;
  NSObject *v8;
  char *v9;

  if (byte_100989BC0 <= a2)
    return 120;
  v3 = (_DWORD *)((char *)&unk_100989BCD + 8 * a2 - a2);
  v4 = *a1;
  *(_DWORD *)((char *)v3 + 3) = *(_DWORD *)((char *)a1 + 3);
  *v3 = v4;
  if (byte_100989BC1)
  {
    v9 = (char *)a1 + 1;
    v5 = sub_10004C9BC(203, a3);
    if ((_DWORD)v5)
    {
      if (sub_10005549C())
      {
        sub_100054530("OI_HCI_CMD_LE_SetAdvertisingSetRandomAddress returned %!", v5, v9);
        v6 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
LABEL_6:
          sub_1006CE7A4();
      }
    }
  }
  else
  {
    v5 = sub_1001F9A74();
    if ((_DWORD)v5)
    {
      if (sub_10005549C())
      {
        sub_100054530("BT_VSC_UpdateMultipleAdvInstanceAddress returned %!", v5);
        v8 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
          goto LABEL_6;
      }
    }
  }
  return v5;
}

uint64_t sub_100206870(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v3;
  NSObject *v4;

  v3 = 101;
  if (a2 <= 2 && a3 <= 2)
  {
    v3 = sub_1001F6488();
    if ((_DWORD)v3)
    {
      if (sub_10005549C())
      {
        sub_100054530("BT_VSC_SetAdvPhyOptions returned %!", v3);
        v4 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
    }
  }
  return v3;
}

uint64_t sub_100206904(_DWORD *a1, uint64_t a2)
{
  return sub_100206744(a1, 0, a2);
}

uint64_t sub_100206910()
{
  return byte_100989BC0;
}

uint64_t sub_10020691C(unsigned int a1)
{
  if (byte_100989BC0 <= a1)
    return 0;
  else
    return byte_100989BC2[a1];
}

uint64_t sub_100206944(uint64_t (*a1)(_QWORD, _QWORD, _QWORD))
{
  NSObject *v1;
  uint64_t v2;
  uint64_t v5;
  uint64_t i;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  const void *v16[2];
  int v17;

  if (off_100989BF8)
  {
    if (sub_10005549C())
    {
      sub_100054530("Already initializing");
      v1 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 408;
  }
  if (byte_100989BC0)
    return 140;
  bzero(qword_1009859F8, 0x41C8uLL);
  off_100989BF8 = a1;
  if (byte_100989BC1 == 1)
  {
    v5 = byte_1009859F0;
    byte_100989BC0 = byte_1009859F0;
    __memset_chk(&unk_100989BCD, 0, 7 * byte_1009859F0, 35);
    if (v5)
    {
      for (i = 0; i != v5; ++i)
        byte_100989BC2[i] = i;
    }
    sub_10022467C(0, (uint64_t)&unk_100989BE9);
    if (!sub_10004C9BC(208, (uint64_t (*)())sub_100206B18, v7, v8, v9, v10, v11, v12, v15))
      return 0;
    sub_100253460();
    v17 = 105;
    v16[1] = &v17;
    v16[0] = (const void *)4;
    v13 = sub_10004A9EC((uint64_t)sub_100206C24, v16, 0, 0);
    if (!(_DWORD)v13)
      return 105;
    v2 = v13;
    if (sub_10005549C())
    {
      sub_100054530("Could not register dispatchReadRemoteVersionInformation");
      v14 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return v2;
  }
  return sub_1001F9744();
}

void sub_100206B18(int a1, unsigned int a2)
{
  NSObject *v2;
  NSObject *v3;
  const void *v4[2];
  int v5;

  v5 = a1;
  if (a1)
    a2 = (unsigned __int16)word_100989C02;
  else
    word_100989C02 = a2;
  if (a2 >= 0x673)
  {
    sub_100253460();
    if ((unsigned __int16)word_100989C02 >= 0x673u)
    {
      if (sub_10005549C())
      {
        sub_100054530("fControllerMaxExtendedAdvertisingPayloadSize=%d", (unsigned __int16)word_100989C02);
        v2 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      word_100989C02 = 1650;
    }
  }
  v4[1] = &v5;
  v4[0] = (const void *)4;
  if (sub_10004A9EC((uint64_t)sub_100206C24, v4, 0, 0) && sub_10005549C())
  {
    sub_100054530("Could not register dispatchReadRemoteVersionInformation");
    v3 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
}

uint64_t sub_100206C24(uint64_t a1)
{
  uint64_t result;

  result = off_100989BF8(**(unsigned int **)(a1 + 8), byte_100989BC2, byte_100989BC0);
  off_100989BF8 = 0;
  return result;
}

uint64_t sub_100206C64(uint64_t a1, char a2)
{
  uint64_t result;
  char v3;
  unsigned __int8 v4;
  _DWORD v5[2];

  if ((_DWORD)a1)
  {
    result = off_100989BF8(a1, byte_100989BC2, byte_100989BC0);
    off_100989BF8 = 0;
  }
  else
  {
    v3 = byte_100989BC0;
    byte_100989BC2[byte_100989BC0] = a2;
    v4 = v3 + 1;
    byte_100989BC0 = v4;
    if (byte_1009859F0 == v4)
    {
      __memset_chk(&unk_100989BCD, 0, 7 * v4, 35);
      sub_10022467C(0, (uint64_t)&unk_100989BE9);
      sub_10022467C(0, (uint64_t)&unk_100989BCD);
      return off_100989BF8(0, byte_100989BC2, byte_100989BC0);
    }
    else
    {
      *(_DWORD *)((char *)v5 + 3) = 0;
      v5[0] = 1;
      arc4random_buf((char *)v5 + 1, 6uLL);
      BYTE1(v5[0]) &= 0x3Fu;
      return sub_1001F9744();
    }
  }
  return result;
}

uint64_t sub_100206D7C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t result;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  void *v16;
  uint64_t v17;
  uint8_t buf[4];
  void *v19;
  __int16 v20;
  int v21;

  if (!byte_100989BC0)
    return 103;
  if (byte_100989BC1)
  {
    v8 = sub_10004C9BC(211, nullsub_103, a3, a4, a5, a6, a7, a8, v17);
    if ((_DWORD)v8)
    {
      v9 = v8;
      if (sub_10005549C())
      {
        sub_100054530("OI_HCI_CMD_LE_ClearAdvertisingSets returned %!", v9);
        v10 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
    }
  }
  else if (byte_1009859F0)
  {
    v12 = 0;
    do
    {
      v13 = sub_1001F97CC();
      if ((_DWORD)v13)
      {
        v14 = v13;
        if (sub_10005549C())
        {
          sub_100054530("BT_VSC_RemoveMultipleAdvInstance returned %!", v14);
          v15 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            v16 = sub_100054494();
            *(_DWORD *)buf = 136446466;
            v19 = v16;
            v20 = 1024;
            v21 = 0xFFFF;
            _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%{public}s (status=%{bluetooth:OI_STATUS}u)", buf, 0x12u);
          }
        }
      }
      ++v12;
    }
    while (v12 < byte_1009859F0);
  }
  result = 0;
  byte_100989BC0 = 0;
  off_100989BF8 = 0;
  return result;
}

BOOL sub_100206F4C()
{
  return byte_100986705 == 3 || byte_100986705 == 0;
}

uint64_t sub_100206F64(uint64_t result)
{
  byte_100989BC1 = result;
  return result;
}

uint64_t sub_100206F70(uint64_t result)
{
  byte_100989C00 = result;
  if ((_DWORD)result)
    byte_100989BC1 = 1;
  return result;
}

uint64_t sub_100206F8C(uint64_t result)
{
  byte_1009859F0 = result;
  return result;
}

uint64_t sub_100206F98()
{
  return (unsigned __int16)word_100989C02;
}

BOOL sub_100206FA4()
{
  uint64_t v0;
  BOOL v1;
  unsigned __int8 *i;
  NSObject *v3;
  uint8_t buf[4];
  void *v6;

  if (byte_100989BC0)
  {
    v0 = 0;
    v1 = 0;
    for (i = (unsigned __int8 *)&byte_100986705; (*i | 2) != 3; i += 3368)
    {
      v1 = ++v0 >= (unint64_t)byte_100989BC0;
      if (byte_100989BC0 == v0)
        return 1;
    }
    if (sub_10005549C())
    {
      sub_100054530("ADV instance %d is in state %d", byte_100989BC2[v0], *i);
      v3 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v6 = sub_100054494();
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
  }
  else
  {
    return 1;
  }
  return v1;
}

BOOL sub_1002070C8()
{
  NSObject *v0;
  uint64_t v1;
  char v2;
  int v3;
  int v5;
  void *v6;

  if (sub_10005549C())
  {
    sub_100054530("LE_isPeriodicAdvStarting");
    v0 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
    {
      v5 = 136446210;
      v6 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, " %{public}s", (uint8_t *)&v5, 0xCu);
    }
  }
  v1 = 0;
  v2 = 1;
  do
  {
    v3 = dword_100989C28[420 * v1];
    if ((v2 & 1) == 0)
      break;
    v2 = 0;
    v1 = 1;
  }
  while (v3 != 1);
  return v3 == 1;
}

BOOL sub_1002071B8(int a1)
{
  NSObject *v2;
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  _BOOL8 result;
  uint8_t buf[4];
  void *v9;

  if (sub_10005549C())
  {
    sub_100054530("LE_isPeriodicAdvCtxInUse advHandle=%d", a1);
    v2 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v9 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  v3 = 0;
  v4 = 1;
  do
  {
    while (1)
    {
      v5 = v4;
      if (BYTE2(dword_100989C28[420 * v3 + 1]) == a1)
        break;
      v4 = 0;
      result = 0;
      v3 = 1;
      if ((v5 & 1) == 0)
        return result;
    }
    v6 = dword_100989C28[420 * v3];
    result = v6 == 2;
    if (v6 == 2)
      break;
    v4 = 0;
    v3 = 1;
  }
  while (((v5 ^ 1) & 1) == 0);
  return result;
}

_DWORD *sub_1002072DC()
{
  NSObject *v0;
  uint64_t v1;
  char v2;
  _DWORD *v3;
  char v4;
  NSObject *v5;
  int v7;
  void *v8;

  if (sub_10005549C())
  {
    sub_100054530("LE_AllocatePeriodicAdvCtx");
    v0 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
    {
      v7 = 136446210;
      v8 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, " %{public}s", (uint8_t *)&v7, 0xCu);
    }
  }
  v1 = 0;
  v2 = 1;
  do
  {
    v3 = &dword_100989C28[420 * v1];
    if (!*v3)
    {
      bzero(v3, 0x690uLL);
      return v3;
    }
    v4 = v2;
    v2 = 0;
    v1 = 1;
  }
  while ((v4 & 1) != 0);
  if (sub_10005549C())
  {
    sub_100054530("LE_AllocatePeriodicAdvCtx there is no free periodic advertisng parameter.");
    v5 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  return 0;
}

uint64_t sub_10020741C(uint64_t (*a1)(_QWORD, _QWORD), uint64_t (*a2)(_QWORD, _QWORD))
{
  NSObject *v4;
  int v6;
  void *v7;

  if (sub_10005549C())
  {
    sub_100054530("LE_InitPeriodicAdvertising");
    v4 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v6 = 136446210;
      v7 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, " %{public}s", (uint8_t *)&v6, 0xCu);
    }
  }
  byte_100989C10 = 0;
  off_100989C18 = a1;
  off_100989C20 = a2;
  bzero(dword_100989C28, 0xD20uLL);
  return 0;
}

void sub_100207510()
{
  NSObject *v0;
  uint64_t v1;
  char v2;
  char v3;
  _DWORD *v4;
  unsigned __int8 *v5;
  int v6;
  NSObject *v7;
  void *v8;
  uint8_t buf[4];
  void *v10;
  __int16 v11;
  int v12;

  if (sub_10005549C())
  {
    sub_100054530("LE_TerminatePeriodicAdvertising");
    v0 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v10 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if (sub_1002076DC())
  {
    v1 = 0;
    v2 = 1;
    do
    {
      v3 = v2;
      if ((dword_100989C28[420 * v1] - 1) <= 1)
      {
        v4 = &dword_100989C28[420 * v1];
        v6 = *((unsigned __int8 *)v4 + 6);
        v5 = (unsigned __int8 *)v4 + 6;
        if (sub_1002077A4(v6, 1))
        {
          if (sub_10005549C())
          {
            sub_100054530("Failed to stop periodic advertising advHandle %x", *v5);
            v7 = sub_1000544A0(0x42u);
            if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
            {
              v8 = sub_100054494();
              *(_DWORD *)buf = 136446466;
              v10 = v8;
              v11 = 1024;
              v12 = 0xFFFF;
              _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "%{public}s (status=%{bluetooth:OI_STATUS}u)", buf, 0x12u);
            }
          }
        }
      }
      v2 = 0;
      v1 = 1;
    }
    while ((v3 & 1) != 0);
  }
}

uint64_t sub_1002076DC()
{
  NSObject *v0;
  uint8_t buf[4];
  void *v3;

  if (sub_10005549C())
  {
    sub_100054530("LE_ReturnNumPeriodicAdvStarted numPeriodicAdvStarted=%d", byte_100989C10);
    v0 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v3 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  return byte_100989C10;
}

uint64_t sub_1002077A4(int a1, char a2)
{
  uint64_t v4;
  char v5;
  char v6;
  NSObject *v7;
  _DWORD *v8;
  NSObject *v9;
  NSObject *v10;
  void *v11;
  uint64_t v12;
  char v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  NSObject *v21;
  void *v22;
  uint64_t result;
  NSObject *v24;
  NSObject *v25;
  NSObject *v26;
  NSObject *v27;
  uint8_t buf[4];
  void *v29;

  v4 = 0;
  v5 = 1;
  do
  {
    v6 = v5;
    if (BYTE2(dword_100989C28[420 * v4 + 1]) == a1)
    {
      v8 = &dword_100989C28[420 * v4];
      goto LABEL_9;
    }
    v5 = 0;
    v4 = 1;
  }
  while ((v6 & 1) != 0);
  if (sub_10005549C())
  {
    sub_100054530("LE_GetPeriodicAdvCtxByAdvHandle cannot find the context advHandle=%d.", a1);
    v7 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  v8 = 0;
LABEL_9:
  if (sub_10005549C())
  {
    sub_100054530("LE_StopPeriodicAdvertising advHandle=%d", a1);
    v9 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v29 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if ((a2 & 1) == 0)
  {
    if (sub_10005549C())
    {
      sub_100054530("LE_isPeriodicAdvStopping");
      v10 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        v11 = sub_100054494();
        *(_DWORD *)buf = 136446210;
        v29 = v11;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
    v12 = 0;
    v13 = 1;
    do
    {
      v14 = dword_100989C28[420 * v12];
      if ((v13 & 1) == 0)
        break;
      v13 = 0;
      v12 = 1;
    }
    while (v14 != 3);
    if (v14 == 3)
    {
      if (!sub_10005549C())
        return 117;
      sub_100054530("LE_StopPeriodicAdvertising pending stop command");
      v25 = sub_1000544A0(0x42u);
      if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        return 117;
      goto LABEL_41;
    }
  }
  if (v8)
  {
    if (off_100989C20)
    {
      if (*v8 == 2)
      {
        if (sub_10005549C())
        {
          sub_100054530("Stopping Periodic Advertising");
          v21 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
          {
            v22 = sub_100054494();
            *(_DWORD *)buf = 136446210;
            v29 = v22;
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
          }
        }
        result = sub_10004C9BC(214, (uint64_t (*)())sub_100207F78, v15, v16, v17, v18, v19, v20, 0);
        if (!(_DWORD)result)
          *v8 = 3;
        return result;
      }
      if (!sub_10005549C())
        return 117;
      sub_100054530("No LE Periodic Advertising in progress.");
      v27 = sub_1000544A0(0x42u);
      if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        return 117;
LABEL_41:
      sub_1006CE7A4();
      return 117;
    }
    if (sub_10005549C())
    {
      sub_100054530("Invalid periodic advertising parameters no periodicAdvStoppedCb");
      v26 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 114;
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("LE_StopPeriodicAdvertising invalid advHandle=%d", a1);
      v24 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 120;
  }
}

uint64_t sub_100207B74(unsigned __int8 *a1)
{
  NSObject *v2;
  NSObject *v3;
  uint64_t v4;
  unsigned int v5;
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  NSObject *v11;
  _DWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _DWORD *v19;
  size_t v20;
  NSObject *v21;
  NSObject *v22;
  uint8_t buf[4];
  void *v24;

  if (sub_10005549C())
  {
    sub_100054530("LE_StartPeriodicAdvertising advHandle=%d", *a1);
    v2 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v24 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if (sub_1002070C8())
  {
    if (!sub_10005549C())
      return 117;
    sub_100054530("LE_StartPeriodicAdvertising pending start command");
    v3 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      return 117;
    goto LABEL_7;
  }
  if (off_100989C18)
  {
    v5 = *a1;
    if (v5 >= 0xF0)
    {
      if (!sub_10005549C())
        return 101;
      sub_100054530("Invalid periodic advertising parameters advHandle: %x", *a1);
      v6 = sub_1000544A0(0x42u);
      if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        return 101;
      goto LABEL_25;
    }
    if (*((unsigned __int16 *)a1 + 1) <= 5u)
    {
      if (!sub_10005549C())
        return 101;
      sub_100054530("Invalid periodic advertising parameters periodicAdvInterval: %x", *((unsigned __int16 *)a1 + 1));
      v8 = sub_1000544A0(0x42u);
      if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        return 101;
      goto LABEL_25;
    }
    if ((a1[4] & 0xBF) != 0)
    {
      if (!sub_10005549C())
        return 101;
      sub_100054530("Invalid periodic advertising parameters periodicAdvProperty: %x", a1[4]);
      v9 = sub_1000544A0(0x42u);
      if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        return 101;
LABEL_25:
      sub_1006CE7A4();
      return 101;
    }
    if (sub_1002071B8(v5))
    {
      if (!sub_10005549C())
        return 117;
      sub_100054530("LE_StartPeriodicAdvertising advHandle=%d is already started", *a1);
      v11 = sub_1000544A0(0x42u);
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        return 117;
LABEL_7:
      sub_1006CE7A4();
      return 117;
    }
    v12 = sub_1002072DC();
    if (v12)
    {
      v19 = v12;
      *((_BYTE *)v12 + 6) = *a1;
      *((_WORD *)v12 + 4) = *((_WORD *)a1 + 1);
      *((_BYTE *)v12 + 10) = a1[4];
      v20 = *((unsigned __int16 *)a1 + 3);
      if (*((_WORD *)a1 + 3))
      {
        memmove((char *)v12 + 14, a1 + 8, v20);
        *((_WORD *)v19 + 6) = *((_WORD *)a1 + 3);
        *((_WORD *)v19 + 832) = 0;
      }
      v4 = sub_100207F10((unsigned __int8 *)v19, v13, v20, v14, v15, v16, v17, v18);
      if ((_DWORD)v4)
      {
        if (sub_10005549C())
        {
          sub_100054530("Could not start the LE periodic advertising %!", v4);
          v21 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
      }
    }
    else
    {
      if (sub_10005549C())
      {
        sub_100054530("LE_StartPeriodicAdvertising No resource");
        v22 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return 104;
    }
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("Invalid periodic advertising parameters no periodicAdvStartedCb");
      v7 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 114;
  }
  return v4;
}

uint64_t sub_100207F10(unsigned __int8 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;

  v9 = sub_10004C9BC(212, (uint64_t (*)())sub_100209D2C, a3, a4, a5, a6, a7, a8, a1[6]);
  if ((_DWORD)v9)
    sub_100209A98(a1);
  else
    *(_DWORD *)a1 = 1;
  return v9;
}

void sub_100207F78(uint64_t a1)
{
  uint64_t v2;
  char v3;
  unsigned __int8 *v4;
  char v5;
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  void *v9;
  NSObject *v10;
  uint8_t buf[4];
  void *v12;

  v2 = 0;
  v3 = 1;
  while (1)
  {
    v4 = (unsigned __int8 *)&dword_100989C28[420 * v2];
    if (*(_DWORD *)v4 == 3)
      break;
    v5 = v3;
    v3 = 0;
    v2 = 1;
    if ((v5 & 1) == 0)
    {
      if (sub_10005549C())
      {
        sub_100054530("LE_GetPeriodicAdvCtxStopping cannot find the context");
        v6 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      sub_100253460();
      v4 = 0;
      break;
    }
  }
  if (sub_10005549C())
  {
    sub_100054530("Periodic advertising stopped %! advHandle=%d", a1, v4[6]);
    v7 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v12 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  *(_DWORD *)v4 = 0;
  --byte_100989C10;
  if (sub_10005549C())
  {
    sub_100054530("notifyPeriodicAdvStoppped status=%d advHandle=%d", a1, v4[6]);
    v8 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = sub_100054494();
      *(_DWORD *)buf = 136446210;
      v12 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  sub_100209A98(v4);
  if (off_100989C20)
  {
    off_100989C20(a1, v4[6]);
  }
  else if (sub_10005549C())
  {
    sub_100054530("Could not find a callback, might be a problem ?");
    v10 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
}

uint64_t sub_1002081B0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  char v3;
  char v4;
  char *v5;
  _BYTE *v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  void *v10;
  uint8_t buf[4];
  void *v13;
  __int16 v14;
  int v15;

  if (sub_10005549C())
  {
    sub_100054530("LE_RefreshPeriodicAdvRandomAddress");
    v0 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v13 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  v1 = 0;
  v2 = 0;
  v3 = 1;
  do
  {
    v4 = v3;
    if (dword_100989C28[420 * v1] == 2)
    {
      v5 = (char *)&dword_100989C28[420 * v1];
      v5[4] = 1;
      v6 = v5 + 4;
      v7 = sub_10004C9BC(214, sub_100208398);
      if ((_DWORD)v7)
      {
        v8 = v7;
        *v6 = 0;
        if (sub_10005549C())
        {
          sub_100054530("Fail to refresh random address for periodic advertising advHandle=%d", v6[2]);
          v9 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          {
            v10 = sub_100054494();
            *(_DWORD *)buf = 136446466;
            v13 = v10;
            v14 = 1024;
            v15 = 0xFFFF;
            _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%{public}s (status=%{bluetooth:OI_STATUS}u)", buf, 0x12u);
          }
        }
        v2 = v8;
      }
    }
    v3 = 0;
    v1 = 1;
  }
  while ((v4 & 1) != 0);
  return v2;
}

void sub_100208398(uint64_t a1)
{
  unsigned __int8 *v2;
  NSObject *v3;
  NSObject *v4;
  NSObject *v5;
  uint8_t buf[4];
  void *v7;

  v2 = (unsigned __int8 *)sub_100209C9C();
  if (!v2)
    sub_100253460();
  if (sub_10005549C())
  {
    sub_100054530("Periodic advertising started %! advHandle=%d addressChanged=%d", a1, v2[6], v2[4]);
    v3 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v7 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if (v2[4])
  {
    if ((_DWORD)a1 && sub_10005549C())
    {
      sub_100054530("Fail to refresh random address for periodic advertising advHandle=%d", v2[6]);
      v4 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    v2[4] = 0;
  }
  else
  {
    if ((_DWORD)a1)
    {
      if (sub_10005549C())
      {
        sub_100054530("Could not start advertising : %!", a1);
        v5 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
    }
    else
    {
      *(_DWORD *)v2 = 2;
      ++byte_100989C10;
    }
    sub_100209B64(a1, v2);
  }
}

uint64_t sub_100208548(uint64_t result)
{
  byte_100989C08 = result;
  return result;
}

uint64_t sub_100208554()
{
  NSObject *v0;
  uint8_t buf[4];
  void *v3;

  if (sub_10005549C())
  {
    sub_100054530("LE_GetPeriodicAdvertisingEnabled enabled=%d", byte_100989C08);
    v0 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v3 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  return byte_100989C08;
}

void sub_10020861C(char a1)
{
  NSObject *v1;
  uint8_t buf[4];
  void *v3;

  byte_100989BF7 = a1;
  if (sub_10005549C())
  {
    sub_100054530("Invoking fake OI_BUSY_FAIL every %d attempts", byte_100989BF7);
    v1 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v3 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
}

void sub_1002086E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;

  sub_100253320((uint64_t)"LE_Advertising:\n", a2, a3, a4, a5, a6, a7, a8, v109);
  sub_100253320((uint64_t)"gNumOfAdvHandles=%d gInitMultiAdvCb=%x currentHandle=%d tech=%d extendedAdvertisingEnabled=%d gMaxControllerSupportedAdvertisingPacketSize=%d", v8, v9, v10, v11, v12, v13, v14, byte_100989BC0);
  if (byte_100989BC0)
  {
    v22 = 0;
    v23 = (char *)&unk_100989BCE;
    v24 = &qword_1009859F8;
    do
    {
      sub_100253320((uint64_t)"advertisingParams for instance %d :", v15, v16, v17, v18, v19, v20, v21, v22);
      sub_100253320((uint64_t)"\tintervalMin=%d intervalMax=%d type=%d channelMap=%d state=%d", v25, v26, v27, v28, v29, v30, v31, *((unsigned __int16 *)v24 + 8));
      sub_100253320((uint64_t)"\tdata:%@", v32, v33, v34, v35, v36, v37, v38, (uint64_t)(v24 + 4));
      sub_100253320((uint64_t)"\tscanRsp:%@", v39, v40, v41, v42, v43, v44, v45, (uint64_t)(v24 + 211));
      sub_100253320((uint64_t)"\taddress: %: type:%d", v46, v47, v48, v49, v50, v51, v52, (uint64_t)v23);
      sub_100253320((uint64_t)"\tprimaryPHY:%d", v53, v54, v55, v56, v57, v58, v59, *((unsigned __int8 *)v24 + 3350));
      sub_100253320((uint64_t)"\tsecondaryPHY:%d", v60, v61, v62, v63, v64, v65, v66, *((unsigned __int8 *)v24 + 3351));
      sub_100253320((uint64_t)"\tprimaryPhyOptions:%d", v67, v68, v69, v70, v71, v72, v73, *((unsigned __int8 *)v24 + 3352));
      sub_100253320((uint64_t)"\tsecondaryPhyOptions:%d", v74, v75, v76, v77, v78, v79, v80, *((unsigned __int8 *)v24 + 3353));
      sub_100253320((uint64_t)"\tuseDecisionBasedAdvPayload:%d", v81, v82, v83, v84, v85, v86, v87, *((unsigned __int8 *)v24 + 3354));
      sub_100253320((uint64_t)"\tDBAFDecisionTypeFlags:%d", v88, v89, v90, v91, v92, v93, v94, *((unsigned __int8 *)v24 + 3355));
      sub_100253320((uint64_t)"\tDBAFDecisionDataLength:%d", v95, v96, v97, v98, v99, v100, v101, *((unsigned __int8 *)v24 + 3356));
      sub_100253320((uint64_t)"\tDBAFDecisionData:%s", v102, v103, v104, v105, v106, v107, v108, v24[420]);
      ++v22;
      v23 += 7;
      v24 += 421;
    }
    while (v22 < byte_100989BC0);
  }
}

void sub_1002088E4(uint64_t a1, int a2, unsigned int a3)
{
  uint64_t v4;
  void (*v5)(uint64_t, uint64_t);
  int v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t *v11;
  NSObject *v12;
  void *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  NSObject *v17;
  void *v18;
  uint64_t v19;
  uint8_t buf[4];
  void *v21;
  __int16 v22;
  int v23;

  v4 = a1;
  v5 = 0;
  v19 = qword_100985A00;
  v6 = byte_1009859F1;
  v7 = 0x1FFFFFFFFFFFF7C7uLL;
  do
  {
    if (qword_1009859F8[v7 + 2105])
      v5 = (void (*)(uint64_t, uint64_t))qword_1009859F8[v7 + 2105];
    v7 += 421;
  }
  while (v7 * 8);
  if ((_DWORD)a1)
  {
    if (byte_100989BC0)
    {
      if (byte_100989BC1)
      {
        v8 = sub_10004C9BC(207, 0);
        if ((_DWORD)v8)
        {
          v9 = v8;
          if (sub_10005549C())
          {
            sub_100054530("Could not stop the LE advertising OI_HCI_CMD_LE_SetExtendedAdvertisingEnable returned %!", v9, 0, 0, 0, 0);
            v10 = sub_1000544A0(0x42u);
            if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
              sub_1006CE7A4();
          }
        }
      }
      else
      {
        v14 = 0;
        do
        {
          v15 = sub_1001F99EC();
          if ((_DWORD)v15)
          {
            v16 = v15;
            if (sub_10005549C())
            {
              sub_100054530("Could not stop the LE advertising BT_VSC_SetMultipleAdvInstanceEnable returned  %!", v16);
              v17 = sub_1000544A0(0x42u);
              if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
              {
                v18 = sub_100054494();
                *(_DWORD *)buf = 136446466;
                v21 = v18;
                v22 = 1024;
                v23 = 0xFFFF;
                _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "%{public}s (status=%{bluetooth:OI_STATUS}u)", buf, 0x12u);
              }
            }
          }
          ++v14;
        }
        while (v14 < byte_100989BC0);
      }
    }
  }
  else if (!a2)
  {
    goto LABEL_14;
  }
  byte_100989BCC = 0;
  v11 = &qword_1009859F8[421 * a3];
  bzero(v11 + 4, 0x672uLL);
  bzero(v11 + 211, 0x672uLL);
  *((_WORD *)v11 + 843) = 0;
  *((_WORD *)v11 + 15) = 0;
  *((_BYTE *)v11 + 3341) = 0;
LABEL_14:
  byte_1009859F1 = 0;
  if (v5)
  {
    if (sub_10022524C())
    {
      if (sub_10005549C())
      {
        sub_100054530("Stopped due to address change, recovering silentRestartSequence=%d", v6);
        v12 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          v13 = sub_100054494();
          *(_DWORD *)buf = 136446210;
          v21 = v13;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
        }
      }
      v4 = 4073;
    }
    if ((v6 & 1) == 0)
      v5(v4, v19);
  }
}

void sub_100208BB4(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;

  v1 = a1;
  if ((_DWORD)a1)
  {
LABEL_2:
    if (sub_10005549C())
    {
      sub_100054530("advertisingDataCb Could not start advertising : %!");
      v2 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    byte_100986705 = 0;
    sub_1002088E4(v1, 0, 0);
    return;
  }
  if (word_10098608E)
  {
    v1 = sub_10004C9BC(169, sub_100208C9C);
    if (!(_DWORD)v1)
      return;
    goto LABEL_2;
  }
  if (sub_10004C9BC(169, sub_100208C9C))
    sub_100208C9C(0);
}

void sub_100208C9C(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;

  v1 = a1;
  if ((_DWORD)a1 || (v1 = sub_10004C9BC(170, sub_100208D40), (_DWORD)v1))
  {
    if (sub_10005549C())
    {
      sub_100054530("scanResponseDataCb Could not start advertising : %!", v1);
      v2 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    byte_100986705 = 0;
    sub_1002088E4(v1, 0, 0);
  }
}

void sub_100208D40(uint64_t a1)
{
  NSObject *v2;

  if ((_DWORD)a1)
  {
    if (sub_10005549C())
    {
      sub_100054530("advertiseStart Could not start advertising : %!", a1);
      v2 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  byte_100986705 = 2;
  sub_1002088E4(a1, 0, 0);
}

uint64_t sub_100208DC8()
{
  unsigned int v0;
  unsigned int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  v0 = byte_100989BCC;
  if (!byte_100989BC1)
  {
    v11 = sub_1001F9854();
    if ((_DWORD)v11)
      return v11;
LABEL_21:
    v11 = 0;
    BYTE5(qword_1009859F8[421 * byte_100989BCC + 417]) = 1;
    return v11;
  }
  if (byte_100989BCC == 4)
  {
    if (byte_100988EAC)
      v1 = 64;
    else
      v1 = 65;
    if (byte_100989BB2)
      v2 = v1 | 0x80;
    else
      v2 = v1;
    v0 = &dword_100000004;
  }
  else
  {
    v2 = 19;
    switch(BYTE4(qword_1009859F8[421 * byte_100989BCC + 2]))
    {
      case 0:
        break;
      case 1:
        v2 = 21;
        break;
      case 2:
        v2 = 18;
        break;
      case 3:
        v2 = 16;
        break;
      default:
        v2 = 0;
        break;
    }
  }
  v3 = (uint64_t)&qword_1009859F8[421 * v0];
  v4 = *(unsigned __int16 *)(v3 + 16);
  v5 = *(unsigned __int16 *)(v3 + 18);
  v6 = *(unsigned __int8 *)(v3 + 28);
  v7 = *(unsigned __int8 *)(v3 + 3342);
  v8 = *(unsigned __int8 *)(v3 + 29);
  if (*(unsigned __int8 *)(v3 + 3350) <= 1u)
    v9 = 1;
  else
    v9 = *(unsigned __int8 *)(v3 + 3350);
  LODWORD(v3) = *(unsigned __int8 *)(v3 + 3351);
  if ((_DWORD)v3)
    v3 = v3;
  else
    v3 = 2;
  v23 = byte_100989BCC;
  v22 = v3;
  v20 = v8;
  v19 = dword_100985A0D;
  v17 = v6;
  v18 = v7;
  v15 = v4;
  v16 = v5;
  v14 = v2;
  v21 = v9;
  v10 = sub_10004C9BC(204, sub_100209248);
  if (!(_DWORD)v10)
    goto LABEL_21;
  v11 = v10;
  if (sub_10005549C())
  {
    sub_100054530("OI_HCI_CMD_LE_SetExtendedAdvertisingParameters returned %!", v11, v14, v15, v16, v17, v18, v19, (char *)&dword_100985A0D + 1, v20, 127, v21, 0, v22, v23, 0);
    v12 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  return v11;
}

void sub_100208FB8(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  unsigned int v3;
  BOOL v4;
  NSObject *v5;
  uint64_t *v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint8_t buf[4];
  void *v14;

  v1 = a1;
  if ((_DWORD)a1)
  {
LABEL_2:
    if (sub_10005549C())
    {
      sub_100054530("setMultipleAdvParamsCompleteCb Could not start advertising : %!", v1);
      v2 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    v3 = byte_100989BCC;
    BYTE5(qword_1009859F8[421 * byte_100989BCC + 417]) = 0;
    sub_1002088E4(v1, 0, v3);
    return;
  }
  if (!HIWORD(qword_1009859F8[421 * byte_100989BCC + 3])
    || (byte_100989BCC == 4 ? (v4 = BYTE4(qword_1009859F8[421 * byte_100989BCC + 210]) == 0) : (v4 = 0),
        v4))
  {
    sub_10020939C(0);
    return;
  }
  if (!byte_100989BC1)
  {
    if (HIWORD(qword_1009859F8[421 * byte_100989BCC + 3]) >= 0x20u)
      sub_100253460();
    v9 = sub_1001F98DC();
LABEL_26:
    v1 = v9;
    if (!(_DWORD)v9)
      return;
    goto LABEL_2;
  }
  if (!BYTE2(qword_1009859F8[421 * byte_100989BCC + 419]))
  {
    v9 = sub_100209544();
    goto LABEL_26;
  }
  if (sub_10005549C())
  {
    sub_100054530("We are using DBAF! Sending Decision Ind Data instead.");
    v5 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      v14 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, " %{public}s", buf, 0xCu);
    }
  }
  v6 = &qword_1009859F8[421 * byte_100989BCC];
  v11 = *((unsigned __int8 *)v6 + 3356);
  v12 = v6[420];
  v10 = *((unsigned __int8 *)v6 + 3355);
  v7 = sub_10004C9BC(257, sub_1002099D4);
  if ((_DWORD)v7)
  {
    v1 = v7;
    if (sub_10005549C())
    {
      sub_100054530("OI_HCI_CMD_LE_SetDecisionDataCommand returned %!", v1, v10, v11, v12);
      v8 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    goto LABEL_2;
  }
}

void sub_100209248(uint64_t a1, uint64_t a2)
{
  char v2;
  uint64_t v4;
  uint64_t v5;
  int v6;
  unsigned __int8 v7;
  char *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t *v11;
  unsigned int v12;
  uint64_t v13;

  v2 = a2;
  sub_100225214(a2, byte_100989BCC);
  v4 = byte_100989BCC;
  if (!byte_100989BCC)
  {
    v5 = (unsigned __int16)word_100985A16;
    if (word_100985A16)
    {
      v6 = 0;
      v7 = 0;
      do
      {
        if ((unsigned __int16)word_100985A16 - 2 > v6
          && *((_BYTE *)&qword_1009859F8[4] + v7) == 2
          && *((_BYTE *)&qword_1009859F8[4] + (v6 + 1)) == 10)
        {
          v9 = (v6 + 2);
          goto LABEL_10;
        }
        v6 = ++v7;
      }
      while (v7 < (unsigned __int16)word_100985A16);
      if ((unsigned __int16)word_100985A16 > 0x1Bu)
        goto LABEL_11;
    }
    word_100985A16 += 3;
    v8 = (char *)&unk_100985A18 + v5;
    *v8 = 2;
    v9 = v5 + 2;
    v8[1] = 10;
LABEL_10:
    *((_BYTE *)&qword_1009859F8[4] + v9) = v2;
  }
LABEL_11:
  v10 = &qword_1009859F8[421 * v4];
  if (*((_BYTE *)v10 + 3352))
  {
    if ((_DWORD)a1)
    {
LABEL_13:
      sub_100208FB8(a1);
      return;
    }
    v12 = BYTE1(qword_1009859F8[421 * v4 + 419]);
  }
  else
  {
    if ((_DWORD)a1)
      goto LABEL_13;
    v11 = &qword_1009859F8[421 * v4];
    v12 = *((unsigned __int8 *)v11 + 3353);
    if (!*((_BYTE *)v11 + 3353))
      goto LABEL_13;
  }
  v13 = sub_100206870(byte_100989BC2[v4], *((unsigned __int8 *)v10 + 3352), v12);
  if ((_DWORD)v13)
    sub_100209A24(v13);
}

void sub_10020939C(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  unsigned int v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v7;

  v1 = a1;
  if (!(_DWORD)a1)
  {
    if (!HIWORD(qword_1009859F8[421 * byte_100989BCC + 210]) || byte_100989BCC)
      goto LABEL_20;
    if (byte_100989BC1)
    {
      v7 = HIWORD(qword_1009859F8[421 * byte_100989BCC + 210]);
      v4 = sub_10004C9BC(206, sub_100209658);
      if (!(_DWORD)v4)
        return;
      v1 = v4;
      if (sub_10005549C())
      {
        sub_100054530("OI_HCI_CMD_LE_SetExtendedScanResponseData returned %!", v1, 3, 1, v7, &unk_100986090);
        v5 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
    }
    else
    {
      v1 = sub_1001F9964();
    }
    if (HIWORD(qword_1009859F8[421 * byte_100989BCC + 210]) && (_DWORD)v1 != 0)
    {
LABEL_20:
      sub_100209658(0);
      return;
    }
    if (!(_DWORD)v1)
      return;
  }
  if (sub_10005549C())
  {
    sub_100054530("setMultipleAdvertisingDataCompleteCb Could not start advertising : %!", v1);
    v2 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  v3 = byte_100989BCC;
  BYTE5(qword_1009859F8[421 * byte_100989BCC + 417]) = 0;
  sub_1002088E4(v1, 0, v3);
}

uint64_t sub_100209544()
{
  uint64_t *v0;
  uint64_t v1;
  unsigned int v2;
  BOOL v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v10;
  uint64_t v11;

  v0 = &qword_1009859F8[421 * byte_100989BCC];
  v1 = *((unsigned __int16 *)v0 + 841);
  v2 = (unsigned __int16)(*((_WORD *)v0 + 15) - v1);
  v3 = v2 > 0xFB;
  if (v2 >= 0xFB)
    v4 = 251;
  else
    v4 = (unsigned __int16)(*((_WORD *)v0 + 15) - v1);
  LODWORD(v5) = 2 * (v2 < 0xFC);
  if (v3)
    v6 = 1;
  else
    v6 = 3;
  if (*((_WORD *)v0 + 841))
    v5 = v5;
  else
    v5 = v6;
  v11 = (uint64_t)v0 + v1 + 32;
  v10 = v5;
  v7 = sub_10004C9BC(205, sub_1002099D8);
  if ((_DWORD)v7)
  {
    if (sub_10005549C())
    {
      sub_100054530("OI_HCI_CMD_LE_SetExtendedAdvertisingData returned %!", v7, v10, 1, v4, v11);
      v8 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  else
  {
    WORD1(qword_1009859F8[421 * byte_100989BCC + 210]) += v4;
  }
  return v7;
}

void sub_100209658(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  unsigned int v3;
  int *v4;
  _DWORD *v5;
  int v6;
  int v7;
  uint64_t v9;
  NSObject *v10;

  v1 = a1;
  if ((_DWORD)a1)
  {
LABEL_2:
    if (sub_10005549C())
    {
      sub_100054530("setMultipleAdvertisingScanRspDataCompleteCb Could not start advertising : %!", v1);
      v2 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    v3 = byte_100989BCC;
    BYTE5(qword_1009859F8[421 * byte_100989BCC + 417]) = 0;
    sub_1002088E4(v1, 0, v3);
    return;
  }
  v4 = (int *)((char *)&unk_100989BCD + 8 * byte_100989BCC - byte_100989BCC);
  v5 = (_DWORD *)((char *)&qword_1009859F8[421 * byte_100989BCC + 417] + 6);
  v6 = *v4;
  v7 = *(int *)((char *)v4 + 3);
  if (v6 == *v5 && v7 == *(_DWORD *)((char *)&qword_1009859F8[421 * byte_100989BCC + 418] + 1))
  {
    sub_1002097A0();
    return;
  }
  v9 = sub_100206744(v5, byte_100989BCC, (uint64_t)sub_1002097A0);
  if ((_DWORD)v9)
  {
    v1 = v9;
    if (sub_10005549C())
    {
      sub_100054530("LE_UpdateMultiAdvertisingSetAddress returned %!", v1);
      v10 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    goto LABEL_2;
  }
}

void sub_1002097A0()
{
  uint64_t v0;
  _DWORD *v1;
  _DWORD *v2;
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  unsigned int v7;
  char v8;
  __int16 v9;
  char v10;

  v0 = byte_100989BCC;
  v1 = (_DWORD *)((char *)&unk_100989BCD + 8 * byte_100989BCC - byte_100989BCC);
  v2 = (_DWORD *)((char *)&qword_1009859F8[421 * byte_100989BCC + 417] + 6);
  *v1 = *v2;
  *(_DWORD *)((char *)v1 + 3) = *(_DWORD *)((char *)v2 + 3);
  if (byte_100989BC1)
  {
    v10 = 0;
    v9 = 0;
    v8 = byte_100989BC2[v0];
    v3 = sub_10004C9BC(207, sub_100209930);
    if (!(_DWORD)v3)
      return;
    v4 = v3;
    if (sub_10005549C())
    {
      sub_100054530("Failed to start advertising OI_HCI_CMD_LE_SetExtendedAdvertisingEnable returned %!", v4, 1, &v8, &v9, &v10);
      v5 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  else
  {
    v4 = sub_1001F99EC();
    if (!(_DWORD)v4)
      return;
  }
  if (sub_10005549C())
  {
    sub_100054530("setAdvertisingSetAddressBeforeEnablingCB Could not start advertising : %!", v4);
    v6 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  v7 = byte_100989BCC;
  BYTE5(qword_1009859F8[421 * byte_100989BCC + 417]) = 0;
  sub_1002088E4(v4, 0, v7);
}

void sub_100209930(uint64_t a1)
{
  NSObject *v2;

  if ((_DWORD)a1)
  {
    if (sub_10005549C())
    {
      sub_100054530("multipleAdvStartCb Could not start advertising : %!", a1);
      v2 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  else
  {
    BYTE5(qword_1009859F8[421 * byte_100989BCC + 417]) = 2;
  }
  sub_1002088E4(a1, 0, byte_100989BCC);
}

void sub_1002099D8(uint64_t a1)
{
  if ((_DWORD)a1
    || HIWORD(qword_1009859F8[421 * byte_100989BCC + 3]) == WORD1(qword_1009859F8[421
                                                                                                 * byte_100989BCC
                                                                                                 + 210])
    || (a1 = sub_100209544(), (_DWORD)a1))
  {
    sub_10020939C(a1);
  }
}

void sub_100209A24(uint64_t a1)
{
  NSObject *v2;

  if ((_DWORD)a1)
  {
    if (sub_10005549C())
    {
      sub_100054530("Could not setAdvPhyOptions: %!", a1);
      v2 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  sub_100208FB8(0);
}

void sub_100209A98(void *a1)
{
  NSObject *v2;
  int v3;
  void *v4;

  if (sub_10005549C())
  {
    sub_100054530("LE_FreePeriodicAdvCtx");
    v2 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      v3 = 136446210;
      v4 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, " %{public}s", (uint8_t *)&v3, 0xCu);
    }
  }
  if (a1)
    bzero(a1, 0x690uLL);
}

void sub_100209B64(uint64_t a1, unsigned __int8 *a2)
{
  NSObject *v4;
  NSObject *v5;
  uint8_t buf[4];
  void *v7;

  if (sub_10005549C())
  {
    sub_100054530("notifyPeriodicAdvStarted status=%d advHandle=%d", a1, a2[6]);
    v4 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v7 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if ((_DWORD)a1)
    sub_100209A98(a2);
  if (off_100989C18)
  {
    off_100989C18(a1, a2[6]);
  }
  else if (sub_10005549C())
  {
    sub_100054530("Could not find a callback, might be a problem ?");
    v5 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
}

_DWORD *sub_100209C9C()
{
  uint64_t v0;
  char i;
  _DWORD *result;
  char v3;
  NSObject *v4;

  v0 = 0;
  for (i = 1; ; i = 0)
  {
    result = (_DWORD *)((char *)&unk_100989C28 + 1680 * v0);
    if (*result == 1)
      break;
    v3 = i;
    v0 = 1;
    if ((v3 & 1) == 0)
    {
      if (sub_10005549C())
      {
        sub_100054530("LE_GetPeriodicAdvCtxStarting cannot find the context");
        v4 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return 0;
    }
  }
  return result;
}

void sub_100209D2C(uint64_t a1)
{
  unsigned __int8 *v2;
  NSObject *v3;
  NSObject *v4;
  NSObject *v5;
  void *v6;
  uint8_t buf[4];
  void *v8;

  v2 = (unsigned __int8 *)sub_100209C9C();
  if (!v2)
    sub_100253460();
  if (sub_10005549C())
  {
    sub_100054530("setPeriodicAdvParamsCompleteCb status %! ", a1);
    v3 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v8 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if ((_DWORD)a1)
  {
LABEL_7:
    if (sub_10005549C())
    {
      sub_100054530("Could not start periodic advertising : %!", a1);
      v4 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    *(_DWORD *)v2 = 0;
    sub_100209B64(a1, v2);
    return;
  }
  if (*((_WORD *)v2 + 6))
  {
    a1 = sub_10020A098((uint64_t)v2);
    if (!(_DWORD)a1)
      return;
    goto LABEL_7;
  }
  if (sub_10005549C())
  {
    sub_100054530("Periodic advertising data size is 0, skip setting data for adv instance %d", v2[6]);
    v5 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = sub_100054494();
      *(_DWORD *)buf = 136446210;
      v8 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  sub_100209F00(0, v2);
}

void sub_100209F00(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  uint8_t buf[4];
  void *v16;

  if (sub_10005549C())
  {
    sub_100054530("Set Periodic Advertising Data Complete %! advHandle=%d", a1, a2[6]);
    v10 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v16 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if (!(_DWORD)a1)
  {
    v14 = a2[6];
    v12 = sub_10004C9BC(214, (uint64_t (*)())sub_100208398, v4, v5, v6, v7, v8, v9, 1);
    if (!(_DWORD)v12)
      return;
    a1 = v12;
    if (sub_10005549C())
    {
      sub_100054530("Failed to start advertising OI_HCI_CMD_LE_SetPeriodicAdvertisingEnable returned %!", a1, v14);
      v13 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  if (sub_10005549C())
  {
    sub_100054530("Could not start peirodic advertising : %!", a1);
    v11 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  *(_DWORD *)a2 = 0;
  sub_100209B64(a1, a2);
}

uint64_t sub_10020A098(uint64_t a1)
{
  unsigned __int16 v2;
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v16;
  uint8_t buf[4];
  void *v18;

  v2 = *(_WORD *)(a1 + 12) - *(_WORD *)(a1 + 1664);
  if (v2 >= 0xFCu)
    v3 = 252;
  else
    v3 = v2;
  if (v2 > 0xFCu)
    v4 = 1;
  else
    v4 = 3;
  if (*(_WORD *)(a1 + 1664))
    v5 = 2 * (v2 < 0xFDu);
  else
    v5 = v4;
  if ((sub_10005549C() & 1) != 0)
  {
    sub_100054530("setPeriodicAdvDataPacket operation:%d dataLeft:%d totalDataLen:%d dataLengthThisPacket:%d position:%d", v5, v2, *(unsigned __int16 *)(a1 + 12), v3, *(unsigned __int16 *)(a1 + 1664));
    v12 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v18 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  v16 = a1 + 6 + *(unsigned __int16 *)(a1 + 1664) + 8;
  v13 = sub_10004C9BC(213, (uint64_t (*)())sub_10020A234, v6, v7, v8, v9, v10, v11, *(unsigned __int8 *)(a1 + 6));
  if ((_DWORD)v13)
  {
    if (sub_10005549C())
    {
      sub_100054530("OI_HCI_CMD_LE_SetPeriodicAdvertisingData returned %!", v13, v5, v3, v16);
      v14 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  else
  {
    *(_WORD *)(a1 + 1664) += v3;
  }
  return v13;
}

void sub_10020A234(uint64_t a1)
{
  unsigned __int8 *v2;
  int v3;
  int v4;
  NSObject *v5;
  uint8_t buf[4];
  void *v7;

  v2 = (unsigned __int8 *)sub_100209C9C();
  if (!v2)
    sub_100253460();
  v3 = *((unsigned __int16 *)v2 + 6);
  v4 = *((unsigned __int16 *)v2 + 832);
  if (sub_10005549C())
  {
    sub_100054530("setPeriodicAdvDataPacketCompleteCb dataLeft:%d status:%!", (unsigned __int16)(v3 - v4), a1);
    v5 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v7 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if ((_DWORD)a1 || v3 == v4 || (a1 = sub_10020A098(v2), (_DWORD)a1))
    sub_100209F00(a1, v2);
}

uint64_t sub_10020A34C()
{
  uint64_t result;

  if (qword_10098A960)
    return qword_10098A960();
  return result;
}

uint64_t sub_10020A360()
{
  uint64_t result;

  if (off_10098A970)
    return off_10098A970();
  return result;
}

uint64_t sub_10020A374()
{
  uint64_t result;

  if (off_10098A968)
    return off_10098A968();
  return result;
}

uint64_t sub_10020A388()
{
  uint64_t v0;
  uint64_t v1;
  NSObject *v2;
  uint64_t v3;
  NSObject *v4;
  NSObject *v5;
  unsigned __int16 *v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  uint8_t buf[4];
  void *v13;

  xmmword_10098A980 = 0u;
  unk_10098A990 = 0u;
  qword_10098A9A0 = 0;
  sub_10022D270((__n128 *)off_10091EF28);
  if ((_DWORD)v0)
  {
    v1 = v0;
    if (sub_10005549C())
    {
      sub_100054530("Failed to add state callbacks : %!", v1);
      v2 = sub_1000544A0(0x44u);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
LABEL_4:
        sub_1006CE7A4();
    }
  }
  else
  {
    v3 = sub_10021F6A8((uint64_t)off_10091EF40);
    if ((_DWORD)v3)
    {
      v1 = v3;
      if (sub_10005549C())
      {
        sub_100054530("Failed to add GAP connections callbacks : %!", v1);
        v4 = sub_1000544A0(0x44u);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
          goto LABEL_4;
      }
    }
    else
    {
      dword_10098A9A8 = 0;
      qword_10098A9B0 = 0;
      v1 = sub_1001DC46C(4, 3, 16, 3u, (uint64_t *)&xmmword_10098A980, (uint64_t)sub_10020BDA4);
      if ((_DWORD)v1 || !(_QWORD)xmmword_10098A980)
      {
        if (sub_10005549C())
        {
          sub_100054530("Could not register the l2cap : %!", v1);
          v5 = sub_1000544A0(0x44u);
          if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
      }
      else
      {
        *(_WORD *)sub_1001E40C4(xmmword_10098A980) = 527;
        *(_WORD *)(sub_1001E40C4(xmmword_10098A980) + 2) = -1;
      }
      if (sub_10005549C())
      {
        v6 = (unsigned __int16 *)sub_1001E40C4(xmmword_10098A980);
        sub_100054530("ATT L2CAP channel MTU: %d", *v6);
        v7 = sub_1000544A0(0x44u);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446210;
          v13 = sub_100054494();
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
        }
      }
      qword_10098A9B8 = (uint64_t)sub_100251288(0, (uint64_t)sub_10020DF00);
      v8 = sub_100114B00();
      if ((_DWORD)v8)
      {
        v9 = v8;
        if (sub_10005549C())
        {
          sub_100054530("ATT classic registration failed with %!", v9);
          v10 = sub_1000544A0(0x44u);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
      }
    }
  }
  return v1;
}

void sub_10020A634()
{
  _QWORD *v0;
  _QWORD *v1;
  void *v2;

  if ((_QWORD)xmmword_10098A980)
    sub_1001DC658(xmmword_10098A980);
  v0 = (_QWORD *)*((_QWORD *)&xmmword_10098A980 + 1);
  if (*((_QWORD *)&xmmword_10098A980 + 1))
  {
    do
    {
      v1 = (_QWORD *)v0[10];
      v2 = (void *)v0[6];
      if (v2)
        sub_100053298(v2);
      if (off_10098A978)
        off_10098A978(v0);
      sub_100053298(v0);
      v0 = v1;
    }
    while (v1);
  }
  sub_10022D328(off_10091EF28);
  sub_10021F838((uint64_t)off_10091EF40);
  qword_10098A9A0 = 0;
  xmmword_10098A980 = 0u;
  unk_10098A990 = 0u;
  if (qword_10098A9B8)
    sub_1002512C0((_QWORD *)qword_10098A9B8);
  off_10098A9C0 = 0;
  dword_10098A9A8 = 0;
  qword_10098A9B0 = 0;
}

uint64_t sub_10020A6F8(void *a1)
{
  uint64_t result;

  if (off_10098A9C0)
    return 119;
  result = 0;
  off_10098A9C0 = a1;
  return result;
}

uint64_t sub_10020A71C(void *a1, uint64_t a2)
{
  uint64_t result;

  if (!a1)
    return 101;
  if (off_10098A998)
    return 119;
  result = 0;
  off_10098A998 = a1;
  qword_10098A9A0 = a2;
  return result;
}

void *sub_10020A754(void *result)
{
  if (off_10098A998 == result)
  {
    off_10098A998 = 0;
    qword_10098A9A0 = 0;
  }
  return result;
}

uint64_t (*sub_10020A778(_QWORD *a1))(void)
{
  _QWORD *v1;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  void *ptr;

  v1 = (_QWORD *)*((_QWORD *)&xmmword_10098A980 + 1);
  if (!*((_QWORD *)&xmmword_10098A980 + 1))
    return 0;
  v3 = (_QWORD *)*((_QWORD *)&xmmword_10098A980 + 1);
  while (v3 != a1)
  {
    v3 = (_QWORD *)v3[10];
    if (!v3)
      return 0;
  }
  v4 = a1[11];
  if (v4)
    *(_QWORD *)(v4 + 80) = a1[10];
  v5 = a1[10];
  if (v5)
    *(_QWORD *)(v5 + 88) = v4;
  if (v1 == a1)
    *((_QWORD *)&xmmword_10098A980 + 1) = v5;
  v6 = (void *)a1[6];
  if (v6)
    sub_100053298(v6);
  v7 = *((unsigned int *)a1 + 15);
  if ((_DWORD)v7)
    sub_100049F6C(v7);
  if (off_10098A978)
    off_10098A978(a1);
  v8 = (void *)sub_100251684(qword_10098A9B8);
  for (ptr = v8; ptr; v8 = ptr)
  {
    while (1)
    {
      v9 = sub_1002516A8((uint64_t)v8);
      if (v9)
        break;
LABEL_25:
      sub_1002516FC(qword_10098A9B8, ptr, 1);
      v8 = (void *)sub_100251684(qword_10098A9B8);
      ptr = v8;
      if (!v8)
        goto LABEL_26;
    }
    if (*a1 == *(_QWORD *)v9)
    {
      if (!*(_BYTE *)(v9 + 16))
        sub_10020A910();
      goto LABEL_25;
    }
    sub_10025168C((uint64_t)&ptr);
  }
LABEL_26:
  if (*a1 != qword_10098A9B0)
  {
LABEL_29:
    sub_100053298(a1);
    return 0;
  }
  v15 = 0;
  v10 = sub_1001DB044(4u, &v15);
  if (!(_DWORD)v10)
  {
    v11 = v15;
    *(_QWORD *)(v15 + 8) = 0;
    *(_QWORD *)(v11 + 16) = 0;
    *(_WORD *)(v11 + 24) = 0;
    sub_10020A968();
    goto LABEL_29;
  }
  v13 = v10;
  if (sub_10005549C())
  {
    sub_100054530("_LE_ATT_RemoveATTSession %!", v13);
    v14 = sub_1000544A0(0x44u);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  sub_100112D60(v13);
  return sub_10020A910();
}

uint64_t (*sub_10020A910())(void)
{
  int v0;
  uint64_t (*result)(void);

  v0 = dword_10098A9A8;
  if (dword_10098A9A8 <= 0)
  {
    sub_100253460();
    v0 = dword_10098A9A8;
  }
  dword_10098A9A8 = v0 - 1;
  result = off_10098A9C0;
  if (v0 == 1 && off_10098A9C0 != 0)
    return (uint64_t (*)(void))off_10098A9C0();
  return result;
}

void sub_10020A968()
{
  _QWORD *v0;
  _QWORD *v1;
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;

  qword_10098A9B0 = 0;
  do
  {
    v0 = (_QWORD *)sub_100251574(qword_10098A9B8, 0);
    if (!v0)
      break;
    v1 = v0;
    if (!*v0)
    {
      if (sub_10005549C())
      {
        sub_100054530("LE_ATT_WriteCfm - Packet handle NULL");
        v2 = sub_1000544A0(0x44u);
        if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
          sub_1006D2C38();
      }
    }
    v3 = sub_10020B150((__int128 *)*v1, v1[1]);
    v4 = v3;
    if ((_DWORD)v3 != 412)
    {
      if ((_DWORD)v3)
      {
        if (sub_10005549C())
        {
          sub_100054530("LE_ATT_WriteCfm - Write Failed:%!", v4);
          v5 = sub_1000544A0(0x44u);
          if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
            sub_1006D2C38();
        }
      }
      else
      {
        qword_10098A9B0 = *v1;
      }
    }
    if (!*((_BYTE *)v1 + 16))
      sub_10020A910();
    sub_100253F14(v1[1]);
    sub_100053298(v1);
  }
  while ((_DWORD)v4);
  if (!qword_10098A9B0)
    sub_10020F474();
}

uint64_t sub_10020AAFC(uint64_t a1, uint64_t a2, __int16 a3)
{
  uint64_t v3;
  _WORD *v4;
  NSObject *v5;

  v3 = a1;
  *(_QWORD *)a1 = a2;
  *(_WORD *)(a1 + 18) = a3;
  *(_WORD *)(a1 + 64) = 0;
  v4 = sub_10020EE68(a2, a3);
  *(_QWORD *)(v3 + 72) = v4;
  if (!v4)
  {
    if (sub_10005549C())
    {
      sub_100054530("Failed to allocate ATT DB Session");
      v5 = sub_1000544A0(0x44u);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 0;
  }
  return v3;
}

_BYTE *sub_10020AB80(uint64_t a1, char a2)
{
  NSObject *v4;
  _BYTE *result;
  int v6;
  __int16 v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;

  if (sub_10020AC84(a1))
  {
    if (!sub_10005549C())
      return 0;
    sub_100054530("Already have a session ATT");
    v4 = sub_1000544A0(0x44u);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      return 0;
    goto LABEL_4;
  }
  result = sub_100114588(0x68uLL);
  if (!result)
  {
    if (!sub_10005549C())
      return 0;
    sub_100054530("Failed to allocate the bearer");
    v10 = sub_1000544A0(0x44u);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      return 0;
LABEL_4:
    sub_1006CE7A4();
    return 0;
  }
  result[66] = a2;
  v6 = *(_DWORD *)a1;
  v7 = *(_WORD *)(a1 + 4);
  *((_QWORD *)result + 10) = 0;
  *((_WORD *)result + 6) = v7;
  *((_DWORD *)result + 2) = v6;
  v8 = *((_QWORD *)&xmmword_10098A980 + 1);
  if (*((_QWORD *)&xmmword_10098A980 + 1))
  {
    do
    {
      v9 = v8;
      v8 = *(_QWORD *)(v8 + 80);
    }
    while (v8);
    *((_QWORD *)result + 11) = v9;
    *(_QWORD *)(v9 + 80) = result;
  }
  else
  {
    *((_QWORD *)&xmmword_10098A980 + 1) = result;
    *((_QWORD *)result + 10) = 0;
    *((_QWORD *)result + 11) = 0;
  }
  return result;
}

uint64_t sub_10020AC84(uint64_t a1)
{
  uint64_t result;

  for (result = *((_QWORD *)&xmmword_10098A980 + 1); result; result = *(_QWORD *)(result + 80))
  {
    if (*(_DWORD *)(result + 8) == *(_DWORD *)a1 && *(unsigned __int16 *)(result + 12) == *(unsigned __int16 *)(a1 + 4))
      break;
  }
  return result;
}

uint64_t sub_10020ACBC(uint64_t a1, char a2)
{
  _QWORD *v4;
  _BYTE *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;

  v4 = (_QWORD *)*((_QWORD *)&xmmword_10098A980 + 1);
  if (*((_QWORD *)&xmmword_10098A980 + 1))
  {
    while (*v4 != a1)
    {
      v4 = (_QWORD *)v4[10];
      if (!v4)
        goto LABEL_4;
    }
    if (!sub_10005549C())
      return 0;
    sub_100054530("Already have a session ATT");
    v9 = sub_1000544A0(0x44u);
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      return 0;
LABEL_13:
    sub_1006CE7A4();
    return 0;
  }
LABEL_4:
  sub_1001F37D8(a1);
  sub_10021301C(a1);
  v5 = sub_100114588(0x68uLL);
  if (!v5)
  {
    if (!sub_10005549C())
      return 0;
    sub_100054530("Failed to allocate the bearer");
    v10 = sub_1000544A0(0x44u);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      return 0;
    goto LABEL_13;
  }
  v5[66] = a2;
  v6 = *(_DWORD *)(a1 + 49);
  *((_WORD *)v5 + 6) = *(_WORD *)(a1 + 53);
  *((_DWORD *)v5 + 2) = v6;
  LOBYTE(v6) = *(_BYTE *)(a1 + 48);
  *((_QWORD *)v5 + 10) = 0;
  v5[14] = v6;
  v7 = *((_QWORD *)&xmmword_10098A980 + 1);
  if (*((_QWORD *)&xmmword_10098A980 + 1))
  {
    do
    {
      v8 = v7;
      v7 = *(_QWORD *)(v7 + 80);
    }
    while (v7);
    *((_QWORD *)v5 + 11) = v8;
    *(_QWORD *)(v8 + 80) = v5;
  }
  else
  {
    *((_QWORD *)&xmmword_10098A980 + 1) = v5;
    *((_QWORD *)v5 + 10) = 0;
    *((_QWORD *)v5 + 11) = 0;
  }
  return sub_10020AAFC((uint64_t)v5, a1, 23);
}

_QWORD *sub_10020AE08(uint64_t a1)
{
  _QWORD *result;

  result = (_QWORD *)*((_QWORD *)&xmmword_10098A980 + 1);
  if (*((_QWORD *)&xmmword_10098A980 + 1))
  {
    do
    {
      if (*result == a1)
        break;
      result = (_QWORD *)result[10];
    }
    while (result);
  }
  return result;
}

uint64_t sub_10020AE30(unsigned __int16 *a1)
{
  uint64_t *v1;

  v1 = (uint64_t *)*((_QWORD *)&xmmword_10098A980 + 1);
  if (!*((_QWORD *)&xmmword_10098A980 + 1))
    return 149;
  while ((unsigned __int16 *)*v1 != a1)
  {
    v1 = (uint64_t *)v1[10];
    if (!v1)
      return 149;
  }
  if (v1[9])
  {
    sub_10020F14C(a1);
    a1 = (unsigned __int16 *)*v1;
  }
  if (!a1)
  {
    sub_100253460();
    a1 = (unsigned __int16 *)*v1;
  }
  if (sub_10019AC00((uint64_t)a1))
    sub_100213108(*v1);
  sub_10020A778(v1);
  return 0;
}

uint64_t sub_10020AEA8(int a1)
{
  uint64_t result;

  for (result = *((_QWORD *)&xmmword_10098A980 + 1); result; result = *(_QWORD *)(result + 80))
  {
    if (*(unsigned __int16 *)(result + 16) == a1)
      break;
  }
  return result;
}

uint64_t sub_10020AED0(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = 0;
  if (a1)
  {
    v2 = *((_QWORD *)&xmmword_10098A980 + 1);
    if (*((_QWORD *)&xmmword_10098A980 + 1))
    {
      while (v2 != a1)
      {
        v2 = *(_QWORD *)(v2 + 80);
        if (!v2)
          return 0;
      }
      return *(unsigned __int16 *)(a1 + 18);
    }
  }
  return v1;
}

uint64_t sub_10020AF08(uint64_t result, __int16 a2)
{
  uint64_t v2;

  if (result)
  {
    v2 = *((_QWORD *)&xmmword_10098A980 + 1);
    if (*((_QWORD *)&xmmword_10098A980 + 1))
    {
      while (v2 != result)
      {
        v2 = *(_QWORD *)(v2 + 80);
        if (!v2)
          return result;
      }
      *(_WORD *)(result + 18) = a2;
    }
  }
  return result;
}

uint64_t sub_10020AF34(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = 0;
  if (a1)
  {
    v2 = *((_QWORD *)&xmmword_10098A980 + 1);
    if (*((_QWORD *)&xmmword_10098A980 + 1))
    {
      while (v2 != a1)
      {
        v2 = *(_QWORD *)(v2 + 80);
        if (!v2)
          return 0;
      }
      return *(_QWORD *)(a1 + 72);
    }
  }
  return v1;
}

uint64_t sub_10020AF6C(__int128 *a1, uint64_t a2, unsigned int a3, BOOL *a4)
{
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  NSObject *v14;

  if (!qword_10098A9B0)
  {
    v9 = sub_10020B150(a1, a2);
    if ((_DWORD)v9 != 412)
    {
      v8 = v9;
      if (!(_DWORD)v9)
      {
        qword_10098A9B0 = (uint64_t)a1;
        if (!a4)
          return v8;
        goto LABEL_28;
      }
      if (sub_10005549C())
      {
        sub_100054530("Wrote ATT MBUF - Write Failed:%! reliable:%d _queuedNonReliablePackets:%d", v8, a3, dword_10098A9A8);
        v14 = sub_1000544A0(0x44u);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          sub_1006CEEC0();
          if (!a4)
            return v8;
          goto LABEL_28;
        }
      }
      goto LABEL_27;
    }
    if (qword_10098A9B0)
      sub_100253460();
LABEL_26:
    v8 = 0;
LABEL_27:
    if (!a4)
      return v8;
LABEL_28:
    *a4 = qword_10098A9B0 == 0;
    return v8;
  }
  if ((a3 & 1) == 0 && dword_10098A9A8 > 31)
  {
    v8 = 4001;
    if (!a4)
      return v8;
    goto LABEL_28;
  }
  v10 = sub_100052DC0(0x18uLL);
  if (!v10)
  {
    v8 = 106;
    if (!a4)
      return v8;
    goto LABEL_28;
  }
  v11 = v10;
  *v10 = a1;
  *((_BYTE *)v10 + 16) = a3;
  v12 = sub_100253D90(v10 + 1, a2, 0);
  if (!(_DWORD)v12)
  {
    sub_10025142C(qword_10098A9B8, (uint64_t)v11, 8);
    if ((a3 & 1) == 0)
    {
      v8 = 0;
      ++dword_10098A9A8;
      if (!a4)
        return v8;
      goto LABEL_28;
    }
    goto LABEL_26;
  }
  v8 = v12;
  if (sub_10005549C())
  {
    sub_100054530("Wrote ATT MBUF - OI_MBUF_Copy Failed:%!", v8);
    v13 = sub_1000544A0(0x44u);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  sub_100053298(v11);
  if (a4)
    goto LABEL_28;
  return v8;
}

uint64_t sub_10020B150(__int128 *a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  unsigned int v6;
  unsigned int v8;

  if (sub_10019AB28((uint64_t)a1))
  {
    v4 = *((_QWORD *)&xmmword_10098A980 + 1);
    if (*((_QWORD *)&xmmword_10098A980 + 1))
    {
      while (*(__int128 **)v4 != a1)
      {
        v4 = *(_QWORD *)(v4 + 80);
        if (!v4)
          goto LABEL_5;
      }
      v8 = *(unsigned __int16 *)(v4 + 16);
      if (!*(_WORD *)(v4 + 16))
        sub_100253460();
      v6 = v8;
      return sub_1001DBC18((uint64_t)sub_10020DF34, v6, a1, a2, 1);
    }
LABEL_5:
    if (sub_10005549C())
    {
      sub_100054530("Can not find classic session in ATT WriteBuf");
      v5 = sub_1000544A0(0x44u);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    return 4202;
  }
  if (!sub_10019AC00((uint64_t)a1))
    return 4202;
  v6 = 4;
  return sub_1001DBC18((uint64_t)sub_10020DF34, v6, a1, a2, 1);
}

uint64_t sub_10020B234(_QWORD *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t result;
  __int16 v7;
  _QWORD *v8;
  _BYTE *v9;
  _QWORD *v10;
  NSObject *v11;

  if (!a1)
  {
    sub_100253460();
    return 101;
  }
  v5 = a1 + 3;
  if (a1[3])
    return 118;
  v7 = a3;
  if (a3 < 0x17)
    return 101;
  if (*((_WORD *)a1 + 9) != 23)
    return 146;
  *((_BYTE *)a1 + 56) = 1;
  a1[3] = a2;
  a1[4] = a4;
  *((_WORD *)a1 + 20) = 3;
  v8 = (_QWORD *)*((_QWORD *)&xmmword_10098A980 + 1);
  if (!*((_QWORD *)&xmmword_10098A980 + 1))
  {
LABEL_12:
    result = 142;
    goto LABEL_13;
  }
  while (v8 != a1)
  {
    v8 = (_QWORD *)v8[10];
    if (!v8)
      goto LABEL_12;
  }
  v9 = sub_100114588(3uLL);
  a1[6] = v9;
  if (!v9)
  {
    result = 106;
    goto LABEL_13;
  }
  *v9 = 2;
  *(_WORD *)(a1[6] + 1) = v7;
  result = sub_10020B38C((uint64_t)a1);
  if ((_DWORD)result)
  {
LABEL_13:
    *v5 = 0;
    v5[1] = 0;
    *((_WORD *)v5 + 8) = 0;
    return result;
  }
  v10 = sub_10020E2D8(*a1);
  if (v10)
  {
    sub_10020E820((uint64_t)v10, 1, 0);
    return 0;
  }
  result = sub_10005549C();
  if ((_DWORD)result)
  {
    sub_100054530("Couldn't find server session for connection 0x%08x - can't change MTU!", *a1);
    v11 = sub_1000544A0(0x44u);
    result = os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
    {
      sub_1006CE7A4();
      return 0;
    }
  }
  return result;
}

uint64_t sub_10020B38C(uint64_t a1)
{
  __int128 *v2;
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  const void *v8[2];
  _OWORD v9[7];
  uint64_t v10;

  v10 = a1;
  if (!a1)
    return 4002;
  v2 = *(__int128 **)a1;
  if (!v2)
    return 0;
  memset(v9, 0, sizeof(v9));
  if (*((_BYTE *)v2 + 2) != 4)
    goto LABEL_7;
  if (!sub_10019AC00((uint64_t)v2))
  {
    if (!sub_10005549C())
      return 4003;
    sub_100054530("Not valid LE connection handle");
    v5 = sub_1000544A0(0x44u);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      return 4003;
    goto LABEL_23;
  }
  v2 = *(__int128 **)a1;
  if (*(_QWORD *)a1)
  {
LABEL_7:
    if (*((_BYTE *)v2 + 2) || sub_10019AB28((uint64_t)v2))
      goto LABEL_8;
    if (!sub_10005549C())
      return 4003;
    sub_100054530("Not valid ACL connection handle");
    v6 = sub_1000544A0(0x44u);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      return 4003;
LABEL_23:
    sub_1006CE7A4();
    return 4003;
  }
LABEL_8:
  v3 = sub_1000532A8((uint64_t)v9, 1u);
  if (!(_DWORD)v3)
  {
    v3 = sub_10005336C((unsigned __int8 *)v9, *(char **)(a1 + 48), *(unsigned __int16 *)(a1 + 40), 2u);
    if (!(_DWORD)v3)
    {
      v4 = sub_10020AF6C(*(__int128 **)a1, (uint64_t)v9, *(unsigned __int8 *)(a1 + 56), 0);
      if ((_DWORD)v4 == 412 || (v3 = v4, !(_DWORD)v4))
      {
        if (*(_BYTE *)(a1 + 56))
        {
          v8[1] = &v10;
          v8[0] = (const void *)8;
          sub_10004A9EC((uint64_t)sub_10020DF38, v8, (unsigned __int16)dword_10097A8C0, (int *)(a1 + 60));
        }
        v3 = 0;
      }
    }
  }
  sub_100253FD8((uint64_t)v9);
  return v3;
}

uint64_t sub_10020B534(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  void *v10;
  void *v11;

  if (!a1)
  {
    sub_100253460();
    return 101;
  }
  v5 = a1 + 24;
  if (*(_QWORD *)(a1 + 24))
    return 118;
  if (*(unsigned __int16 *)(a3 + 3) <= (unsigned __int16)(*(_WORD *)(a3 + 1) - 1))
    return 101;
  *(_BYTE *)(a1 + 56) = 1;
  *(_QWORD *)(a1 + 24) = a2;
  *(_QWORD *)(a1 + 32) = a4;
  *(_WORD *)(a1 + 40) = 5;
  v8 = *((_QWORD *)&xmmword_10098A980 + 1);
  if (!*((_QWORD *)&xmmword_10098A980 + 1))
    goto LABEL_13;
  while (v8 != a1)
  {
    v8 = *(_QWORD *)(v8 + 80);
    if (!v8)
      goto LABEL_13;
  }
  if (*(unsigned __int16 *)(a1 + 18) >= 5u)
  {
    v11 = sub_100114588(5uLL);
    *(_QWORD *)(a1 + 48) = v11;
    if (v11)
    {
      memmove(v11, (const void *)a3, *(unsigned __int16 *)(a1 + 40));
      v6 = sub_10020B38C(a1);
      if (!(_DWORD)v6)
        return v6;
    }
    else
    {
      v6 = 106;
    }
  }
  else
  {
LABEL_13:
    v6 = 142;
  }
  v10 = *(void **)(a1 + 48);
  if (v10)
    sub_100053298(v10);
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)v5 = 0;
  *(_QWORD *)(v5 + 8) = 0;
  *(_WORD *)(v5 + 16) = 0;
  return v6;
}

uint64_t sub_10020B630(uint64_t a1, uint64_t a2, __int16 a3, __int16 a4, unsigned int a5, const void *a6, unsigned int a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  __int16 v11;
  uint64_t v16;
  char *v18;
  void *v19;

  if (!a1)
  {
    sub_100253460();
    return 101;
  }
  v9 = a1 + 24;
  if (*(_QWORD *)(a1 + 24))
    return 118;
  v11 = a5;
  if (a5 <= (unsigned __int16)(a4 - 1))
    return 101;
  *(_BYTE *)(a1 + 56) = 1;
  *(_QWORD *)(a1 + 24) = a2;
  *(_QWORD *)(a1 + 32) = a8;
  *(_WORD *)(a1 + 40) = a7 + 7;
  v16 = *((_QWORD *)&xmmword_10098A980 + 1);
  if (*((_QWORD *)&xmmword_10098A980 + 1))
  {
    while (v16 != a1)
    {
      v16 = *(_QWORD *)(v16 + 80);
      if (!v16)
        goto LABEL_13;
    }
    LODWORD(v16) = *(unsigned __int16 *)(a1 + 18);
  }
LABEL_13:
  if (v16 >= (unsigned __int16)(a7 + 7))
  {
    v18 = (char *)sub_100114588((unsigned __int16)(a7 + 7));
    *(_QWORD *)(a1 + 48) = v18;
    if (v18)
    {
      *v18 = 6;
      *(_WORD *)(v18 + 1) = a4;
      *(_WORD *)(v18 + 3) = v11;
      *(_WORD *)(v18 + 5) = a3;
      memmove((void *)(*(_QWORD *)(a1 + 48) + 7), a6, a7);
      v10 = sub_10020B38C(a1);
      if (!(_DWORD)v10)
        return v10;
    }
    else
    {
      v10 = 106;
    }
  }
  else
  {
    v10 = 142;
  }
  v19 = *(void **)(a1 + 48);
  if (v19)
    sub_100053298(v19);
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)v9 = 0;
  *(_QWORD *)(v9 + 8) = 0;
  *(_WORD *)(v9 + 16) = 0;
  return v10;
}

uint64_t sub_10020B760(uint64_t a1, uint64_t a2, int *a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  __int128 *v8;
  size_t v9;
  uint64_t v10;
  void *v12;
  _BYTE *v13;
  int v14;
  __int128 v15;
  int v16;

  if (!a1)
  {
    sub_100253460();
    return 101;
  }
  v5 = a1 + 24;
  if (*(_QWORD *)(a1 + 24))
    return 118;
  if (*(unsigned __int16 *)((char *)a3 + 3) <= (unsigned __int16)(*(_WORD *)((char *)a3 + 1) - 1))
    return 101;
  *(_BYTE *)(a1 + 56) = 1;
  *(_QWORD *)(a1 + 24) = a2;
  *(_QWORD *)(a1 + 32) = a4;
  v8 = (__int128 *)((char *)a3 + 5);
  v9 = *((unsigned __int8 *)a3 + 5) + 5;
  *(_WORD *)(a1 + 40) = v9;
  v10 = *((_QWORD *)&xmmword_10098A980 + 1);
  if (!*((_QWORD *)&xmmword_10098A980 + 1))
    goto LABEL_13;
  while (v10 != a1)
  {
    v10 = *(_QWORD *)(v10 + 80);
    if (!v10)
      goto LABEL_13;
  }
  if (*(unsigned __int16 *)(a1 + 18) >= v9)
  {
    v13 = sub_100114588(v9);
    *(_QWORD *)(a1 + 48) = v13;
    if (v13)
    {
      v14 = *a3;
      v13[4] = *((_BYTE *)a3 + 4);
      *(_DWORD *)v13 = v14;
      v15 = *v8;
      v16 = *(int *)((char *)a3 + 21);
      sub_100072C50((_BYTE *)(*(_QWORD *)(a1 + 48) + 5), (unsigned __int8 *)&v15, 1);
      v6 = sub_10020B38C(a1);
      if (!(_DWORD)v6)
        return v6;
    }
    else
    {
      v6 = 106;
    }
  }
  else
  {
LABEL_13:
    v6 = 142;
  }
  v12 = *(void **)(a1 + 48);
  if (v12)
    sub_100053298(v12);
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)v5 = 0;
  *(_QWORD *)(v5 + 8) = 0;
  *(_WORD *)(v5 + 16) = 0;
  return v6;
}

uint64_t sub_10020B8BC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  void *v9;
  void *v11;

  if (!a1)
  {
    sub_100253460();
    return 101;
  }
  v5 = a1 + 24;
  if (*(_QWORD *)(a1 + 24))
    return 118;
  if (!*(_WORD *)(a3 + 1))
    return 101;
  *(_BYTE *)(a1 + 56) = 1;
  *(_QWORD *)(a1 + 24) = a2;
  *(_QWORD *)(a1 + 32) = a4;
  *(_WORD *)(a1 + 40) = 3;
  v8 = *((_QWORD *)&xmmword_10098A980 + 1);
  if (!*((_QWORD *)&xmmword_10098A980 + 1))
    goto LABEL_12;
  while (v8 != a1)
  {
    v8 = *(_QWORD *)(v8 + 80);
    if (!v8)
      goto LABEL_12;
  }
  if (*(unsigned __int16 *)(a1 + 18) >= 3u)
  {
    v11 = sub_100114588(3uLL);
    *(_QWORD *)(a1 + 48) = v11;
    if (v11)
    {
      memmove(v11, (const void *)a3, *(unsigned __int16 *)(a1 + 40));
      v6 = sub_10020B38C(a1);
      if (!(_DWORD)v6)
        return v6;
    }
    else
    {
      v6 = 106;
    }
  }
  else
  {
LABEL_12:
    v6 = 142;
  }
  v9 = *(void **)(a1 + 48);
  if (v9)
    sub_100053298(v9);
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)v5 = 0;
  *(_QWORD *)(v5 + 8) = 0;
  *(_WORD *)(v5 + 16) = 0;
  return v6;
}

uint64_t sub_10020B9A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  void *v9;
  void *v11;

  if (!a1)
  {
    sub_100253460();
    return 101;
  }
  v5 = a1 + 24;
  if (*(_QWORD *)(a1 + 24))
    return 118;
  if (!*(_WORD *)(a3 + 1))
    return 101;
  *(_BYTE *)(a1 + 56) = 1;
  *(_QWORD *)(a1 + 24) = a2;
  *(_QWORD *)(a1 + 32) = a4;
  *(_WORD *)(a1 + 40) = 5;
  v8 = *((_QWORD *)&xmmword_10098A980 + 1);
  if (!*((_QWORD *)&xmmword_10098A980 + 1))
    goto LABEL_12;
  while (v8 != a1)
  {
    v8 = *(_QWORD *)(v8 + 80);
    if (!v8)
      goto LABEL_12;
  }
  if (*(unsigned __int16 *)(a1 + 18) >= 5u)
  {
    v11 = sub_100114588(5uLL);
    *(_QWORD *)(a1 + 48) = v11;
    if (v11)
    {
      memmove(v11, (const void *)a3, *(unsigned __int16 *)(a1 + 40));
      v6 = sub_10020B38C(a1);
      if (!(_DWORD)v6)
        return v6;
    }
    else
    {
      v6 = 106;
    }
  }
  else
  {
LABEL_12:
    v6 = 142;
  }
  v9 = *(void **)(a1 + 48);
  if (v9)
    sub_100053298(v9);
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)v5 = 0;
  *(_QWORD *)(v5 + 8) = 0;
  *(_WORD *)(v5 + 16) = 0;
  return v6;
}

uint64_t sub_10020BA94(uint64_t a1, uint64_t a2, __int16 *a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v9;
  size_t v10;
  uint64_t v11;
  void *v12;
  _BYTE *v14;
  __int16 v15;

  if (!a1)
  {
    sub_100253460();
    return 101;
  }
  v5 = a1 + 24;
  if (*(_QWORD *)(a1 + 24))
    return 118;
  if (!*(__int16 *)((char *)a3 + 1))
    return 101;
  *(_BYTE *)(a1 + 56) = a2 != 0;
  *(_QWORD *)(a1 + 24) = a2;
  *(_QWORD *)(a1 + 32) = a4;
  v9 = *(unsigned __int16 *)((char *)a3 + 3);
  if (v9 > 0xFFFC)
    goto LABEL_13;
  v10 = v9 + 3;
  *(_WORD *)(a1 + 40) = v9 + 3;
  v11 = *((_QWORD *)&xmmword_10098A980 + 1);
  if (!*((_QWORD *)&xmmword_10098A980 + 1))
    goto LABEL_13;
  while (v11 != a1)
  {
    v11 = *(_QWORD *)(v11 + 80);
    if (!v11)
      goto LABEL_13;
  }
  if (*(unsigned __int16 *)(a1 + 18) < v10)
  {
LABEL_13:
    v6 = 142;
    goto LABEL_14;
  }
  v14 = sub_100114588(v10);
  *(_QWORD *)(a1 + 48) = v14;
  if (!v14)
  {
    v6 = 106;
    goto LABEL_14;
  }
  v15 = *a3;
  v14[2] = *((_BYTE *)a3 + 2);
  *(_WORD *)v14 = v15;
  memmove((void *)(*(_QWORD *)(a1 + 48) + 3), *(const void **)((char *)a3 + 5), *(unsigned __int16 *)((char *)a3 + 3));
  v6 = sub_10020B38C(a1);
  if ((_DWORD)v6)
  {
LABEL_14:
    v12 = *(void **)(a1 + 48);
    if (v12)
      sub_100053298(v12);
    *(_QWORD *)(a1 + 48) = 0;
    *(_QWORD *)v5 = 0;
    *(_QWORD *)(v5 + 8) = 0;
    *(_WORD *)(v5 + 16) = 0;
    return v6;
  }
  if (a2)
    return 0;
  if (!dword_10098A9A8 && off_10098A9C0)
    off_10098A9C0();
  sub_100053298(*(void **)(a1 + 48));
  v6 = 0;
  *(_QWORD *)(a1 + 48) = 0;
  return v6;
}

uint64_t sub_10020BBE4(uint64_t a1, uint64_t a2, int *a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  unsigned __int16 v8;
  uint64_t v9;
  _BYTE *v10;
  int v11;
  void *v12;

  if (!a1)
  {
    sub_100253460();
    return 101;
  }
  v5 = a1 + 24;
  if (*(_QWORD *)(a1 + 24))
    return 118;
  if (!*(_WORD *)((char *)a3 + 1))
    return 101;
  *(_BYTE *)(a1 + 56) = 1;
  *(_QWORD *)(a1 + 24) = a2;
  *(_QWORD *)(a1 + 32) = a4;
  v8 = *(_WORD *)((char *)a3 + 5) + 5;
  *(_WORD *)(a1 + 40) = v8;
  v9 = *((_QWORD *)&xmmword_10098A980 + 1);
  if (*((_QWORD *)&xmmword_10098A980 + 1))
  {
    while (v9 != a1)
    {
      v9 = *(_QWORD *)(v9 + 80);
      if (!v9)
        goto LABEL_12;
    }
    LODWORD(v9) = *(unsigned __int16 *)(a1 + 18);
  }
LABEL_12:
  if (v9 >= v8)
  {
    v10 = sub_100114588(v8);
    *(_QWORD *)(a1 + 48) = v10;
    if (v10)
    {
      v11 = *a3;
      v10[4] = *((_BYTE *)a3 + 4);
      *(_DWORD *)v10 = v11;
      memmove((void *)(*(_QWORD *)(a1 + 48) + 5), *(const void **)((char *)a3 + 7), *(unsigned __int16 *)((char *)a3 + 5));
      v6 = sub_10020B38C(a1);
      if (!(_DWORD)v6)
        return v6;
    }
    else
    {
      v6 = 106;
    }
  }
  else
  {
    v6 = 142;
  }
  v12 = *(void **)(a1 + 48);
  if (v12)
    sub_100053298(v12);
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)v5 = 0;
  *(_QWORD *)(v5 + 8) = 0;
  *(_WORD *)(v5 + 16) = 0;
  return v6;
}

uint64_t sub_10020BCEC(uint64_t a1, uint64_t a2, char a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  _BYTE *v8;
  void *v9;

  if (a1)
  {
    v5 = a1 + 24;
    if (!*(_QWORD *)(a1 + 24))
    {
      *(_BYTE *)(a1 + 56) = 1;
      *(_QWORD *)(a1 + 24) = a2;
      *(_QWORD *)(a1 + 32) = a4;
      *(_WORD *)(a1 + 40) = 2;
      v8 = sub_100114588(2uLL);
      *(_QWORD *)(a1 + 48) = v8;
      if (v8)
      {
        *v8 = 24;
        *(_BYTE *)(*(_QWORD *)(a1 + 48) + 1) = a3;
        v6 = sub_10020B38C(a1);
        if (!(_DWORD)v6)
          return v6;
        v9 = *(void **)(a1 + 48);
        if (v9)
          sub_100053298(v9);
        *(_QWORD *)(a1 + 48) = 0;
        *(_QWORD *)v5 = 0;
        *(_QWORD *)(v5 + 8) = 0;
      }
      else
      {
        *(_QWORD *)v5 = 0;
        *(_QWORD *)(v5 + 8) = 0;
        v6 = 106;
      }
      *(_WORD *)(v5 + 16) = 0;
      return v6;
    }
    return 118;
  }
  else
  {
    sub_100253460();
    return 101;
  }
}

void sub_10020BDA4(uint64_t a1, unsigned __int8 *a2, size_t a3, uint64_t a4)
{
  int v8;
  int v9;
  _QWORD *v10;
  NSObject *v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;
  _BYTE *v16;
  unsigned __int16 v17;
  void (*v18)(_QWORD *, uint64_t, uint64_t, uint64_t);
  int v19;
  int v20;
  unsigned int v21;
  int v22;
  int v23;
  NSObject *v24;
  _QWORD *v25;
  _BYTE *v26;
  unsigned __int16 v27;
  void (*v28)(_QWORD *, uint64_t, void *, _QWORD, uint64_t);
  int v29;
  NSObject *v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  _BYTE *v34;
  unsigned __int16 v35;
  _BYTE *v36;
  void (*v37)(_QWORD *, uint64_t, void *, _QWORD, uint64_t, uint64_t);
  unsigned int v38;
  NSObject *v39;
  uint64_t v40;
  _QWORD *v41;
  uint64_t v42;
  _BYTE *v43;
  NSObject *v44;
  _BYTE *v45;
  NSObject *v46;
  _BYTE *v47;
  _BYTE *v48;
  unsigned int v49;
  NSObject *v50;
  unsigned __int8 *v51;
  int v52;
  BOOL v53;
  unsigned __int16 v54;
  void (*v55)(_QWORD *, _QWORD, _QWORD);
  NSObject *v56;
  _BYTE *v57;
  NSObject *v58;
  _BYTE *v59;
  unsigned __int16 v60;
  NSObject *v61;
  NSObject *v62;
  NSObject *v63;
  NSObject *v64;
  NSObject *v65;
  NSObject *v66;
  NSObject *v67;
  NSObject *v68;
  NSObject *v69;
  NSObject *v70;
  NSObject *v71;
  uint64_t v72;
  _QWORD *v73;
  uint64_t v74;
  uint64_t v75;
  unsigned __int8 *v76;
  int v77;
  int v78;
  NSObject *v79;
  NSObject *v80;
  unsigned __int8 *v81;
  uint64_t v82;
  unsigned int v83;
  NSObject *v84;
  unsigned __int8 *v85;
  NSObject *v86;
  unsigned __int8 *v87;
  _QWORD *v88;
  NSObject *v89;
  uint64_t v90;
  char *v91;
  void *v92;
  int v93;
  unsigned __int8 *v94;
  char *v95;
  uint64_t v96;
  __int16 v97;
  __int128 v98;
  void *v99;
  void *v100;
  uint64_t v101;
  _QWORD *v102;
  unsigned __int8 *v103;
  __int16 v104;
  void *v105;
  uint64_t v106;
  _WORD *v107;
  unsigned __int8 *v108;
  __int16 v109;
  __int16 v110;
  void (*v111)(_QWORD *, uint64_t, unsigned __int8 *, _QWORD, _QWORD);
  void (*v112)(_QWORD *, _QWORD, unsigned __int8 *, _QWORD, _QWORD);
  void (*v113)(_QWORD *, uint64_t, _QWORD, _QWORD, unsigned __int8 *, _QWORD, _QWORD);
  unsigned __int16 v114;
  __int128 v115;
  int v116;

  if (!a1)
    goto LABEL_15;
  v8 = *(unsigned __int8 *)(a1 + 2);
  if (v8 == 4)
  {
    if (!sub_10019AC00(a1))
      goto LABEL_15;
    v8 = *(unsigned __int8 *)(a1 + 2);
  }
  if (!v8 && !sub_10019AB28(a1))
  {
LABEL_15:
    if (!sub_10005549C())
      return;
    sub_100054530("ATT error : not transport handle");
    v11 = sub_1000544A0(0x44u);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      return;
LABEL_149:
    sub_1006CE7A4();
    return;
  }
  if (!a2 || !(_DWORD)a3)
  {
    if (!sub_10005549C())
      return;
    sub_100054530("Invalid packet size.");
    v12 = sub_1000544A0(0x44u);
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      return;
    goto LABEL_149;
  }
  if (sub_10020E2D8(a1))
  {
    v9 = *a2;
    switch(*a2)
    {
      case 1u:
      case 3u:
      case 5u:
      case 7u:
      case 9u:
      case 0xBu:
      case 0xDu:
      case 0xFu:
      case 0x11u:
      case 0x13u:
      case 0x17u:
      case 0x19u:
        v10 = (_QWORD *)*((_QWORD *)&xmmword_10098A980 + 1);
        if (!*((_QWORD *)&xmmword_10098A980 + 1))
          return;
        break;
      case 2u:
      case 4u:
      case 6u:
      case 8u:
      case 0xAu:
      case 0xCu:
      case 0xEu:
      case 0x10u:
      case 0x12u:
      case 0x16u:
      case 0x18u:
        goto LABEL_29;
      case 0x14u:
      case 0x15u:
      case 0x1Au:
      case 0x1Cu:
        goto LABEL_30;
      case 0x1Bu:
        if (off_10098A998)
          off_10098A998(a1, *(unsigned __int16 *)(a2 + 1), a2 + 3, (unsigned __int16)(a3 - 3), a4, qword_10098A9A0);
        return;
      case 0x1Du:
        sub_10020CF7C((__int128 *)a1, (unsigned __int16 *)(a2 + 1), (unsigned __int16)(a3 - 1), a4);
        return;
      case 0x1Eu:
        sub_10020F8BC(a1);
        return;
      default:
        if (v9 == 82 || v9 == 210)
        {
LABEL_29:
          sub_10020F928((__int128 *)a1, a2, a3, a4);
        }
        else
        {
LABEL_30:
          if (sub_10005549C())
          {
            sub_100054530("Received unknown opcode 0x%x", v9);
            v14 = sub_1000544A0(0x44u);
            if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
              sub_1006CE7A4();
          }
          sub_10020D040(a1, v9);
        }
        return;
    }
    while (*v10 != a1)
    {
      v10 = (_QWORD *)v10[10];
      if (!v10)
        return;
    }
    switch(*a2)
    {
      case 1u:
        sub_10020D41C((uint64_t)v10, a2 + 1, (unsigned __int16)(a3 - 1));
        return;
      case 3u:
        v16 = (_BYTE *)v10[6];
        if (v16 && *v16 == 2)
        {
          v17 = a3 - 1;
          v18 = (void (*)(_QWORD *, uint64_t, uint64_t, uint64_t))v10[3];
          v19 = v16[1];
          v20 = v16[2];
          sub_100049F6C(*((unsigned int *)v10 + 15));
          *((_DWORD *)v10 + 15) = 0;
          sub_100053298((void *)v10[6]);
          v10[6] = 0;
          v10[3] = 0;
          if (v17 != 2)
          {
            if (sub_10005549C())
            {
              sub_100054530("Invalid MTU payload size %d.", v17);
              v71 = sub_1000544A0(0x44u);
              if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
                sub_1006CE7A4();
            }
            v72 = v10[4];
            v73 = v10;
            v74 = 4005;
            v75 = 0;
            goto LABEL_194;
          }
          v21 = *(unsigned __int16 *)(a2 + 1);
          if (v21 <= 0x17)
            v21 = 23;
          if ((v19 | (v20 << 8)) >= v21)
            v22 = v21;
          else
            v22 = v19 | (v20 << 8);
          LOWORD(v115) = v22;
          v23 = *((unsigned __int16 *)v10 + 9);
          if (v23 != 23 && v22 != v23)
          {
            if (sub_10005549C())
            {
              sub_100054530("The negotiated MTU is different from a previously negotiated one: %u != %u", *((unsigned __int16 *)v10 + 9), v22);
              v24 = sub_1000544A0(0x44u);
              if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
                sub_1006CE7A4();
            }
          }
          v25 = (_QWORD *)*((_QWORD *)&xmmword_10098A980 + 1);
          if (*((_QWORD *)&xmmword_10098A980 + 1))
          {
            while (v25 != v10)
            {
              v25 = (_QWORD *)v25[10];
              if (!v25)
                goto LABEL_187;
            }
            *((_WORD *)v10 + 9) = v22;
          }
LABEL_187:
          v88 = sub_10020E2D8(*v10);
          if (v88)
          {
            sub_10020E820((uint64_t)v88, 0, &v115);
            if (!v18)
              return;
            goto LABEL_193;
          }
          if (!sub_10005549C()
            || (sub_100054530("Couldn't find server session for connection 0x%08x - can't change MTU!", *v10),
                v89 = sub_1000544A0(0x44u),
                !os_log_type_enabled(v89, OS_LOG_TYPE_ERROR)))
          {
            if (!v18)
              return;
            goto LABEL_193;
          }
          sub_1006CE7A4();
          if (v18)
          {
LABEL_193:
            v75 = (unsigned __int16)v115;
            v72 = v10[4];
            v73 = v10;
            v74 = 0;
LABEL_194:
            v18(v73, v74, v75, v72);
            return;
          }
        }
        else if (sub_10005549C())
        {
          sub_100054530("No MTU request matching this response. Ignoring.");
          v62 = sub_1000544A0(0x44u);
          if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
            goto LABEL_149;
        }
        return;
      case 5u:
        v26 = (_BYTE *)v10[6];
        if (v26 && *v26 == 4)
        {
          v27 = a3 - 1;
          v28 = (void (*)(_QWORD *, uint64_t, void *, _QWORD, uint64_t))v10[3];
          sub_100049F6C(*((unsigned int *)v10 + 15));
          *((_DWORD *)v10 + 15) = 0;
          sub_100053298((void *)v10[6]);
          v10[6] = 0;
          v10[3] = 0;
          v29 = v27;
          if (v27 <= 4u)
          {
            if (sub_10005549C())
            {
              sub_100054530("Invalid find information payload size %d.", v27);
              v30 = sub_1000544A0(0x44u);
              if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
                sub_1006CE7A4();
            }
            v31 = v10[4];
            v32 = v10;
            v33 = 4006;
LABEL_163:
            v28(v32, v33, 0, 0, v31);
            return;
          }
          v76 = a2 + 1;
          v77 = a2[1];
          if (v77 == 1)
            v78 = 2;
          else
            v78 = 16 * (v77 == 2);
          if (!v78 || (v29 - 1) % (v78 + 2))
          {
            if (sub_10005549C())
            {
              sub_100054530("Invalid find information payload size %d (uuidSize == %u).", v29, v78);
              v79 = sub_1000544A0(0x44u);
              if (os_log_type_enabled(v79, OS_LOG_TYPE_ERROR))
                sub_1006CE7A4();
            }
            v31 = v10[4];
            v32 = v10;
            v33 = 4007;
            goto LABEL_163;
          }
          v90 = (unsigned __int16)((v29 - 1) / (v78 + 2));
          v114 = (v29 - 1) / (v78 + 2);
          v91 = (char *)sub_100052DC0(24 * v114);
          v92 = v91;
          if (v91)
          {
            if ((_DWORD)v90)
            {
              v93 = 0;
              v94 = a2 + 3;
              v95 = v91;
              do
              {
                v96 = (unsigned __int16)v93 & 0xFFFE | 1;
                v97 = v76[(v93 & 0xFFFE) + 2];
                *(_WORD *)v95 = v97 << 8;
                *(_WORD *)v95 = v76[v96] | (unsigned __int16)(v97 << 8);
                sub_10005F660((int8x16_t *)&v94[v96], v78, 1, (uint64_t)&v115);
                v98 = v115;
                *((_DWORD *)v95 + 5) = v116;
                *(_OWORD *)(v95 + 4) = v98;
                v95 += 24;
                v93 += v78 + 2;
                --v90;
              }
              while (v90);
            }
          }
          else
          {
            v114 = 0;
          }
          if (v28)
            v28(v10, 0, v92, v114, v10[4]);
          sub_100053298(v92);
        }
        else if (sub_10005549C())
        {
          sub_100054530("No Find information request matching this response. Ignoring.");
          v63 = sub_1000544A0(0x44u);
          if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
            goto LABEL_149;
        }
        return;
      case 7u:
        v34 = (_BYTE *)v10[6];
        if (v34 && *v34 == 6)
        {
          v35 = a3 - 1;
          v111 = (void (*)(_QWORD *, uint64_t, unsigned __int8 *, _QWORD, _QWORD))v10[3];
          sub_100049F6C(*((unsigned int *)v10 + 15));
          *((_DWORD *)v10 + 15) = 0;
          sub_100053298((void *)v10[6]);
          v10[6] = 0;
          v10[3] = 0;
          if (v35 < 4u || (v35 & 3) != 0)
          {
            if (sub_10005549C())
            {
              sub_100054530("Invalid find by type value payload size %d.", v35);
              v80 = sub_1000544A0(0x44u);
              if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR))
                sub_1006CE7A4();
            }
            v111(v10, 4022, 0, 0, v10[4]);
          }
          else
          {
            v111(v10, 0, a2 + 1, v35 >> 2, v10[4]);
          }
        }
        else if (sub_10005549C())
        {
          sub_100054530("No Find by type value request matching this response. Ignoring.");
          v64 = sub_1000544A0(0x44u);
          if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
            goto LABEL_149;
        }
        return;
      case 9u:
        v36 = (_BYTE *)v10[6];
        if (v36 && *v36 == 8)
        {
          v37 = (void (*)(_QWORD *, uint64_t, void *, _QWORD, uint64_t, uint64_t))v10[3];
          sub_100049F6C(*((unsigned int *)v10 + 15));
          *((_DWORD *)v10 + 15) = 0;
          sub_100053298((void *)v10[6]);
          v10[6] = 0;
          v10[3] = 0;
          v38 = (unsigned __int16)(a3 - 1);
          if (v38 <= 2)
          {
            if (sub_10005549C())
            {
              sub_100054530("Invalid read by type payload size %d.", v38);
              v39 = sub_1000544A0(0x44u);
              if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
                sub_1006CE7A4();
            }
            v40 = v10[4];
            v41 = v10;
            v42 = 4008;
            goto LABEL_180;
          }
          v81 = a2 + 1;
          v82 = a2[1];
          if (v82 < 2 || (v83 = (v38 - 1) / v82, (v38 - 1) % v82))
          {
            if (sub_10005549C())
            {
              sub_100054530("Invalid read by type payload size %d.", v38);
              v84 = sub_1000544A0(0x44u);
              if (os_log_type_enabled(v84, OS_LOG_TYPE_ERROR))
                sub_1006CE7A4();
            }
            v40 = v10[4];
            v41 = v10;
            v42 = 4009;
            goto LABEL_180;
          }
          v99 = sub_100052DC0(16 * (unsigned __int16)((v38 - 1) / v82));
          v100 = v99;
          if (!v99)
            goto LABEL_210;
          if ((_WORD)v83)
          {
            v101 = 0;
            v102 = v99;
            do
            {
              v103 = &v81[(unsigned __int16)(v101 * v82 + 1)];
              v104 = v103[1];
              *(_WORD *)v102 = v104 << 8;
              *(_WORD *)v102 = *v103 | (unsigned __int16)(v104 << 8);
              v102[1] = v103 + 2;
              ++v101;
              v102 += 2;
            }
            while ((unsigned __int16)v83 != v101);
          }
          goto LABEL_211;
        }
        if (sub_10005549C())
        {
          sub_100054530("No read by type request matching this response. Ignoring.");
          v65 = sub_1000544A0(0x44u);
          if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
            goto LABEL_149;
        }
        return;
      case 0xBu:
        v43 = (_BYTE *)v10[6];
        if (v43 && *v43 == 10)
          goto LABEL_89;
        if (sub_10005549C())
        {
          sub_100054530("No read request matching this response. Ignoring.");
          v44 = sub_1000544A0(0x44u);
          if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
            goto LABEL_149;
        }
        return;
      case 0xDu:
        v45 = (_BYTE *)v10[6];
        if (v45 && *v45 == 12)
          goto LABEL_89;
        if (sub_10005549C())
        {
          sub_100054530("No read blob request matching this response. Ignoring.");
          v46 = sub_1000544A0(0x44u);
          if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
            goto LABEL_149;
        }
        return;
      case 0xFu:
        v47 = (_BYTE *)v10[6];
        if (v47 && *v47 == 14)
        {
LABEL_89:
          v112 = (void (*)(_QWORD *, _QWORD, unsigned __int8 *, _QWORD, _QWORD))v10[3];
          sub_100049F6C(*((unsigned int *)v10 + 15));
          *((_DWORD *)v10 + 15) = 0;
          sub_100053298((void *)v10[6]);
          v10[6] = 0;
          v10[3] = 0;
          if (v112)
            v112(v10, 0, a2 + 1, (unsigned __int16)(a3 - 1), v10[4]);
        }
        else if (sub_10005549C())
        {
          sub_100054530("No read blob request matching this response. Ignoring.");
          v66 = sub_1000544A0(0x44u);
          if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
            goto LABEL_149;
        }
        return;
      case 0x11u:
        v48 = (_BYTE *)v10[6];
        if (v48 && *v48 == 16)
        {
          v37 = (void (*)(_QWORD *, uint64_t, void *, _QWORD, uint64_t, uint64_t))v10[3];
          sub_100049F6C(*((unsigned int *)v10 + 15));
          *((_DWORD *)v10 + 15) = 0;
          sub_100053298((void *)v10[6]);
          v10[6] = 0;
          v10[3] = 0;
          v49 = (unsigned __int16)(a3 - 1);
          if (v49 <= 4)
          {
            if (sub_10005549C())
            {
              sub_100054530("Invalid read by group type payload size %d.", v49);
              v50 = sub_1000544A0(0x44u);
              if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
                sub_1006CE7A4();
            }
            v40 = v10[4];
            v41 = v10;
            v42 = 4010;
LABEL_180:
            v37(v41, v42, 0, 0, 0, v40);
            return;
          }
          v85 = a2 + 1;
          v82 = a2[1];
          if (v82 < 4 || (v83 = (v49 - 1) / v82, (v49 - 1) % v82))
          {
            if (sub_10005549C())
            {
              sub_100054530("Invalid read by group type payload size %d.", v49);
              v86 = sub_1000544A0(0x44u);
              if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR))
                sub_1006CE7A4();
            }
            v40 = v10[4];
            v41 = v10;
            v42 = 4011;
            goto LABEL_180;
          }
          v105 = sub_100052DC0(16 * (unsigned __int16)((v49 - 1) / v82));
          v100 = v105;
          if (v105)
          {
            if ((_WORD)v83)
            {
              v106 = 0;
              v107 = v105;
              do
              {
                v108 = &v85[(unsigned __int16)(v106 * v82 + 1)];
                v109 = v108[1];
                *v107 = v109 << 8;
                *v107 = *v108 | (unsigned __int16)(v109 << 8);
                v110 = v108[3];
                v107[1] = v110 << 8;
                v107[1] = v108[2] | (unsigned __int16)(v110 << 8);
                *((_QWORD *)v107 + 1) = v108 + 4;
                ++v106;
                v107 += 8;
              }
              while ((unsigned __int16)v83 != v106);
            }
          }
          else
          {
LABEL_210:
            v82 = 0;
            LOWORD(v83) = 0;
          }
LABEL_211:
          if (v37)
            v37(v10, 0, v100, (unsigned __int16)v83, v82, v10[4]);
          sub_100053298(v100);
        }
        else if (sub_10005549C())
        {
          sub_100054530("No read blob request matching this response. Ignoring.");
          v67 = sub_1000544A0(0x44u);
          if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
            goto LABEL_149;
        }
        return;
      case 0x13u:
        v51 = (unsigned __int8 *)v10[6];
        if (v51 && ((v52 = *v51, v52 != 210) ? (v53 = v52 == 18) : (v53 = 1), v53))
        {
          v54 = a3 - 1;
          v55 = (void (*)(_QWORD *, _QWORD, _QWORD))v10[3];
          sub_100049F6C(*((unsigned int *)v10 + 15));
          *((_DWORD *)v10 + 15) = 0;
          sub_100053298((void *)v10[6]);
          v10[6] = 0;
          v10[3] = 0;
          if (!v54)
            goto LABEL_121;
          if (!sub_10005549C())
            goto LABEL_121;
          sub_100054530("Invalid Write response length %d.", v54);
          v56 = sub_1000544A0(0x44u);
          if (!os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
            goto LABEL_121;
          sub_1006CE7A4();
          if (v55)
            goto LABEL_122;
        }
        else if (sub_10005549C())
        {
          sub_100054530("No read blob request matching this response. Ignoring.");
          v70 = sub_1000544A0(0x44u);
          if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR))
            goto LABEL_149;
        }
        return;
      case 0x17u:
        v57 = (_BYTE *)v10[6];
        if (v57 && *v57 == 22)
        {
          v113 = (void (*)(_QWORD *, uint64_t, _QWORD, _QWORD, unsigned __int8 *, _QWORD, _QWORD))v10[3];
          sub_100049F6C(*((unsigned int *)v10 + 15));
          *((_DWORD *)v10 + 15) = 0;
          sub_100053298((void *)v10[6]);
          v10[6] = 0;
          v10[3] = 0;
          if ((unsigned __int16)(a3 - 1) > 3u)
          {
            if (v113)
            {
              if ((unsigned __int16)(a3 - 1) == 4)
                v87 = 0;
              else
                v87 = a2 + 5;
              v113(v10, 0, *(unsigned __int16 *)(a2 + 1), *(unsigned __int16 *)(a2 + 3), v87, (unsigned __int16)(a3 - 5), v10[4]);
            }
          }
          else
          {
            if (sub_10005549C())
            {
              sub_100054530("Invalid prepare write response length %d.", (unsigned __int16)(a3 - 1));
              v58 = sub_1000544A0(0x44u);
              if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
                sub_1006CE7A4();
            }
            v113(v10, 4012, 0, 0, 0, 0, v10[4]);
          }
        }
        else if (sub_10005549C())
        {
          sub_100054530("No read blob request matching this response. Ignoring.");
          v68 = sub_1000544A0(0x44u);
          if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
            goto LABEL_149;
        }
        return;
      case 0x19u:
        v59 = (_BYTE *)v10[6];
        if (v59 && *v59 == 24)
        {
          v60 = a3 - 1;
          v55 = (void (*)(_QWORD *, _QWORD, _QWORD))v10[3];
          sub_100049F6C(*((unsigned int *)v10 + 15));
          *((_DWORD *)v10 + 15) = 0;
          sub_100053298((void *)v10[6]);
          v10[6] = 0;
          v10[3] = 0;
          if (!v60
            || !sub_10005549C()
            || (sub_100054530("Invalid execute write response length %d.", v60),
                v61 = sub_1000544A0(0x44u),
                !os_log_type_enabled(v61, OS_LOG_TYPE_ERROR)))
          {
LABEL_121:
            if (!v55)
              return;
            goto LABEL_122;
          }
          sub_1006CE7A4();
          if (v55)
          {
LABEL_122:
            v55(v10, 0, v10[4]);
            return;
          }
        }
        else if (sub_10005549C())
        {
          sub_100054530("No read blob request matching this response. Ignoring.");
          v69 = sub_1000544A0(0x44u);
          if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
            goto LABEL_149;
        }
        break;
      default:
        if (sub_10005549C())
        {
          sub_100054530("Unknown opcode 0x%x", v9);
          v15 = sub_1000544A0(0x44u);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
            goto LABEL_23;
        }
        return;
    }
  }
  else if (sub_10005549C())
  {
    sub_100054530("Invalid handle, there is no active session associated with the handle.");
    v13 = sub_1000544A0(0x44u);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
LABEL_23:
      sub_1006CE7A4();
  }
}

void sub_10020CF7C(__int128 *a1, unsigned __int16 *a2, unsigned int a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  _OWORD v7[7];
  char v8;
  uint64_t v9;
  uint64_t v10;

  if (a2 && a3 >= 2)
  {
    v9 = v4;
    v10 = v5;
    if (off_10098A998)
      off_10098A998(a1, *a2, a2 + 1, (unsigned __int16)(a3 - 2), a4, qword_10098A9A0);
    v8 = 0;
    memset(v7, 0, sizeof(v7));
    if (!sub_1000532A8((uint64_t)v7, 1u))
    {
      v8 = 30;
      if (!sub_10005336C((unsigned __int8 *)v7, &v8, 1uLL, 0))
        sub_10020AF6C(a1, (uint64_t)v7, 1u, 0);
    }
    sub_100253FD8((uint64_t)v7);
  }
}

void sub_10020D040(uint64_t a1, char a2)
{
  uint64_t v2;
  void *v3;
  void *v4;
  _BYTE __src[2];
  __int16 v6;
  char v7;

  __src[0] = 1;
  __src[1] = a2;
  v6 = 0;
  v7 = 6;
  v2 = *((_QWORD *)&xmmword_10098A980 + 1);
  if (*((_QWORD *)&xmmword_10098A980 + 1))
  {
    while (*(_QWORD *)v2 != a1)
    {
      v2 = *(_QWORD *)(v2 + 80);
      if (!v2)
        return;
    }
    *(_QWORD *)(v2 + 24) = 0;
    *(_BYTE *)(v2 + 56) = 0;
    *(_QWORD *)(v2 + 32) = 0;
    *(_WORD *)(v2 + 40) = 5;
    v3 = sub_100114588(5uLL);
    *(_QWORD *)(v2 + 48) = v3;
    if (v3)
    {
      memmove(v3, __src, *(unsigned __int16 *)(v2 + 40));
      if (!sub_10020B38C(v2))
        return;
      v4 = *(void **)(v2 + 48);
      if (v4)
        sub_100053298(v4);
    }
    *(_QWORD *)(v2 + 48) = 0;
    *(_QWORD *)(v2 + 24) = 0;
    *(_QWORD *)(v2 + 32) = 0;
    *(_WORD *)(v2 + 40) = 0;
  }
}

uint64_t sub_10020D0F4(uint64_t a1)
{
  unsigned __int16 v2;
  unsigned __int16 v3;
  uint64_t v4;
  NSObject *v5;
  __int16 v6;
  NSObject *v7;
  const char *v8;
  NSObject *v9;
  uint8_t buf[4];
  void *v12;

  if (sub_10019AC00(a1))
  {
    if (!a1)
      sub_100253460();
    if (*(_WORD *)(a1 + 86))
      v2 = 625 * *(_WORD *)(a1 + 86);
    else
      v2 = 7500;
    if (*(_BYTE *)(a1 + 70))
    {
      v3 = 0;
      v4 = 527;
    }
    else
    {
      v6 = sub_10021597C(*(unsigned __int16 *)(a1 + 108), *(unsigned __int16 *)(a1 + 104), v2, *(_DWORD *)(a1 + 144), *(_DWORD *)(a1 + 148));
      if (v6)
      {
        v3 = v6 - 4;
      }
      else
      {
        if (sub_10005549C())
        {
          sub_100054530("Calculated MTU is zero for rx %d, tx %d, and CE %d us, probe %d", *(unsigned __int16 *)(a1 + 108), *(unsigned __int16 *)(a1 + 104), v2, *(_DWORD *)(a1 + 136));
          v7 = sub_1000544A0(0x44u);
          if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
            sub_1006CEEC0();
        }
        v3 = 527;
      }
      if (v3 >= 0x20Fu)
        v4 = 527;
      else
        v4 = v3;
    }
    if (sub_10005549C())
    {
      v8 = "peripheral";
      if (!*(_BYTE *)(a1 + 70))
        v8 = "central";
      sub_100054530("ATT %s MTU %d (calculated %d): for rx %d bytes, tx %d bytes, ce %d us, probestate %d", v8, v4, v3, *(unsigned __int16 *)(a1 + 108), *(unsigned __int16 *)(a1 + 104), v2, *(_DWORD *)(a1 + 136));
      v9 = sub_1000544A0(0x44u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v12 = sub_100054494();
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("Invalid LE Handle");
      v5 = sub_1000544A0(0x44u);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 0;
  }
  return v4;
}

__n128 sub_10020D314(uint64_t a1)
{
  __n128 result;
  __int128 v3;

  if (!a1)
    sub_100253460();
  result.n128_u64[0] = (unint64_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqzq_s64(*(int64x2_t *)&qword_10098A960), (int32x4_t)vceqzq_s64(*(int64x2_t *)&off_10098A970))));
  result.n128_u16[0] = vmaxv_u16((uint16x4_t)result.n128_u64[0]);
  if ((result.n128_u8[0] & 1) != 0)
    sub_100253460();
  if (a1)
  {
    result = *(__n128 *)a1;
    v3 = *(_OWORD *)(a1 + 16);
    *(_OWORD *)&qword_10098A960 = *(_OWORD *)a1;
    *(_OWORD *)&off_10098A970 = v3;
  }
  return result;
}

double sub_10020D374()
{
  double result;

  result = 0.0;
  *(_OWORD *)&qword_10098A960 = 0u;
  *(_OWORD *)&off_10098A970 = 0u;
  return result;
}

void sub_10020D38C(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4;
  _BYTE *v5;
  int v6;

  v4 = sub_10020AC84(a1 + 1);
  if (v4)
  {
    *(_BYTE *)(v4 + 65) = 1;
    if (*(_BYTE *)(v4 + 64))
    {
      *(_BYTE *)(v4 + 64) = 0;
      v5 = *(_BYTE **)(v4 + 48);
      if (v5)
      {
        if (*(_WORD *)(v4 + 40))
        {
          if (a3 != 4832 && a3)
          {
            v6 = 251658240;
            LOBYTE(v6) = *v5;
            sub_10020D41C(v4, (unsigned __int8 *)&v6, 4);
          }
          else
          {
            sub_10020B38C(v4);
          }
        }
      }
    }
  }
}

void sub_10020D41C(uint64_t a1, unsigned __int8 *a2, int a3)
{
  void (*v4)(uint64_t, unint64_t, _QWORD, _QWORD);
  unint64_t v6;
  unsigned __int8 *v7;
  int v8;
  void *v9;
  NSObject *v10;
  int v11;
  void (*v12)(uint64_t, unint64_t, _QWORD, _QWORD);

  v4 = *(void (**)(uint64_t, unint64_t, _QWORD, _QWORD))(a1 + 24);
  if (v4)
  {
    if (a3 == 4)
    {
      v6 = a2[3];
      v7 = *(unsigned __int8 **)(a1 + 48);
      if (v7)
      {
        v8 = *a2;
        if (*v7 == v8)
        {
          v12 = v4;
          if (((v6 < 0x10) & (0x9120u >> v6)) == 0
            || *(_BYTE *)(a1 + 65)
            || (v11 = sub_10020D658((uint64_t *)a1, v6), v11 != 4804) && v11)
          {
            sub_100049F6C(*(unsigned int *)(a1 + 60));
            *(_DWORD *)(a1 + 60) = 0;
            *(_QWORD *)(a1 + 24) = 0;
            v9 = *(void **)(a1 + 48);
            if (v9)
              sub_100053298(v9);
            *(_QWORD *)(a1 + 48) = 0;
            switch(v8)
            {
              case 2:
                v12(a1, v6, 0, *(_QWORD *)(a1 + 32));
                break;
              case 3:
              case 5:
              case 7:
              case 9:
              case 11:
              case 13:
              case 15:
              case 17:
              case 19:
              case 20:
              case 21:
              case 23:
                return;
              case 4:
              case 6:
              case 10:
              case 12:
              case 14:
                ((void (*)(uint64_t, unint64_t, _QWORD, _QWORD, _QWORD))v12)(a1, v6, 0, 0, *(_QWORD *)(a1 + 32));
                break;
              case 8:
              case 16:
                ((void (*)(uint64_t, unint64_t, _QWORD, _QWORD, _QWORD, _QWORD))v12)(a1, v6, 0, 0, 0, *(_QWORD *)(a1 + 32));
                break;
              case 18:
              case 24:
                goto LABEL_20;
              case 22:
                ((void (*)(uint64_t, unint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))v12)(a1, v6, 0, 0, 0, 0, *(_QWORD *)(a1 + 32));
                break;
              default:
                if (v8 == 210)
LABEL_20:
                  ((void (*)(uint64_t, unint64_t, _QWORD))v12)(a1, v6, *(_QWORD *)(a1 + 32));
                break;
            }
          }
          else
          {
            *(_BYTE *)(a1 + 64) = 1;
            sub_100049F6C(*(unsigned int *)(a1 + 60));
          }
        }
      }
    }
    else if (sub_10005549C())
    {
      sub_100054530("Invalid error payload size %d.", a3);
      v10 = sub_1000544A0(0x44u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
}

uint64_t sub_10020D658(uint64_t *a1, int a2)
{
  uint64_t result;
  NSObject *v5;
  int v6;
  void *v7;

  if ((sub_10022DAE0(*a1) & 1) == 0)
  {
    if (a2 <= 11)
    {
      if (a2 == 5)
        return sub_1002380C4(*a1, 1);
      if (a2 != 8)
        return 4004;
      if (!sub_10005549C())
        return sub_1002380C4(*a1, 1);
      sub_100054530("GATT is Asking to pair due to LE_ATT_ERROR_INSUFFICIENT_AUTHORIZATION");
      v5 = sub_1000544A0(0x44u);
      if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        return sub_1002380C4(*a1, 1);
      goto LABEL_24;
    }
    if (a2 != 12)
    {
      if (a2 != 15)
        return 4004;
      if (!sub_10005549C())
        return sub_1002380C4(*a1, 1);
      sub_100054530("GATT is Asking to pair due to LE_ATT_ERROR_INSUFFICIENT_ENCRYPTION");
      v5 = sub_1000544A0(0x44u);
      if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        return sub_1002380C4(*a1, 1);
      goto LABEL_24;
    }
    return 1424;
  }
  if ((sub_10022D980(*a1) & 1) == 0)
  {
    if (a2 > 11)
    {
      if (a2 == 12)
        return 1424;
      if (a2 != 15)
        return 4004;
    }
    else if (a2 != 5)
    {
      if (a2 != 8)
        return 4004;
      if (!sub_10005549C())
        return sub_1002380C4(*a1, 1);
      sub_100054530("GATT is Asking to pair due to LE_ATT_ERROR_INSUFFICIENT_AUTHORIZATION");
      v5 = sub_1000544A0(0x44u);
      if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        return sub_1002380C4(*a1, 1);
      goto LABEL_24;
    }
    return sub_10022D834(*a1);
  }
  if ((sub_10022DA04(*a1) & 1) == 0)
  {
    if (a2 <= 11)
    {
      if (a2 != 5)
      {
        if (a2 == 8)
        {
          if (!sub_10005549C())
            return sub_1002380C4(*a1, 1);
          sub_100054530("GATT is Asking to pair due to LE_ATT_ERROR_INSUFFICIENT_AUTHORIZATION");
          v5 = sub_1000544A0(0x44u);
          if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
            return sub_1002380C4(*a1, 1);
          goto LABEL_24;
        }
        return 4004;
      }
      if (!sub_10005549C())
        return sub_1002380C4(*a1, 1);
      sub_100054530("GATT is Asking to pair due to LE_ATT_ERROR_INSUFFICIENT_AUTHENTICATION");
      v5 = sub_1000544A0(0x44u);
      if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        return sub_1002380C4(*a1, 1);
LABEL_24:
      v6 = 136446210;
      v7 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, " %{public}s", (uint8_t *)&v6, 0xCu);
      return sub_1002380C4(*a1, 1);
    }
    if (a2 == 12)
      return sub_10020D9FC(a1);
    if (a2 != 15)
      return 4004;
    return 1424;
  }
  result = 1424;
  if (a2 > 11)
  {
    if (a2 == 15)
      return result;
    if (a2 != 12)
      return 4004;
    return sub_10020D9FC(a1);
  }
  if (a2 != 5 && a2 != 8)
    return 4004;
  return result;
}

uint64_t sub_10020D9FC(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  NSObject *v5;
  NSObject *v6;
  void *v7;
  char v9;
  uint8_t buf[4];
  void *v11;

  v9 = 0;
  v2 = sub_10022DB64(*a1, &v9);
  if ((_DWORD)v2)
  {
    v3 = v2;
    if (sub_10005549C())
    {
      sub_100054530("Failed to retrieve LTK size : %!.", v3);
      v4 = sub_1000544A0(0x44u);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  else if (v9 == 16)
  {
    if (sub_10005549C())
    {
      sub_100054530("Already using max key size. Erroring out.");
      v5 = sub_1000544A0(0x44u);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 1424;
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("GATT is Asking to pair due to short encryption link");
      v6 = sub_1000544A0(0x44u);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        v7 = sub_100054494();
        *(_DWORD *)buf = 136446210;
        v11 = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
    return sub_1002380C4(*a1, 1);
  }
  return v3;
}

void sub_10020DB7C(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  unsigned __int16 **v5;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  NSObject *v11;

  if ((_DWORD)a3 != 702)
  {
    if ((_DWORD)a3 || !sub_10019AC00((uint64_t)a2))
    {
      if (sub_10005549C())
      {
        if (a2)
          v8 = *a2;
        else
          v8 = 0;
        sub_100054530("GATT connection notification from lmHandle 0x%x (%x) with status %!", v8, a2, a3);
        v9 = sub_1000544A0(0x44u);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          sub_1006CEEC0();
      }
    }
    else
    {
      v5 = (unsigned __int16 **)*((_QWORD *)&xmmword_10098A980 + 1);
      if (*((_QWORD *)&xmmword_10098A980 + 1))
      {
        while (*v5 != a2)
        {
          v5 = (unsigned __int16 **)v5[10];
          if (!v5)
            goto LABEL_7;
        }
        if (!sub_10005549C())
          goto LABEL_22;
        sub_100054530("ATT already has a bearer for this !");
        v10 = sub_1000544A0(0x44u);
        if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
          goto LABEL_22;
LABEL_21:
        sub_1006CE7A4();
LABEL_22:
        sub_100253460();
        return;
      }
LABEL_7:
      v6 = sub_100221568((uint64_t)a2);
      v7 = sub_10020ACBC((uint64_t)a2, !v6);
      if (!v7)
      {
        if (!sub_10005549C())
          goto LABEL_22;
        sub_100054530("ATT failed to create session");
        v11 = sub_1000544A0(0x44u);
        if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          goto LABEL_22;
        goto LABEL_21;
      }
      if (qword_10098A960)
        qword_10098A960(a2, v7, 0);
    }
  }
}

void sub_10020DCF8(unsigned __int16 *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;

  if (a1)
  {
    v4 = sub_10020AE30(a1);
    if ((_DWORD)v4)
    {
      v5 = v4;
      if (sub_10005549C())
      {
        sub_100054530("ATT Session destroy failed with %!", v5);
        v6 = sub_1000544A0(0x44u);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
          sub_1006CEEC0();
      }
    }
    if (off_10098A968)
      off_10098A968(a1, a2);
  }
  else if (sub_10005549C())
  {
    sub_100054530("_GATT_LE_DisconnectedCB lmhandle 0x%x (0x%x) is not valid with reason %!", 0, 0, a2);
    v7 = sub_1000544A0(0x44u);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
}

void sub_10020DDE0(unsigned __int16 *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  int v7;
  uint64_t v8;

  if (!sub_10019AC00((uint64_t)a1))
    sub_100253460();
  if ((_DWORD)a2)
  {
    if (sub_10005549C())
    {
      if (a1)
        v4 = *a1;
      else
        v4 = 0;
      sub_100054530("GATT ready notification from lmHandle 0x%x (%x) with error %!", v4, a1, a2);
      v6 = sub_1000544A0(0x44u);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  else
  {
    if (a1)
      sub_10020F55C((uint64_t)a1);
    if (off_10098A970)
    {
      v5 = *((_QWORD *)&xmmword_10098A980 + 1);
      if (*((_QWORD *)&xmmword_10098A980 + 1))
      {
        while (*(unsigned __int16 **)v5 != a1)
        {
          v5 = *(_QWORD *)(v5 + 80);
          if (!v5)
            goto LABEL_13;
        }
        v7 = *(unsigned __int8 *)(v5 + 66);
        v8 = sub_10020D0F4((uint64_t)a1);
        if (off_10098A970)
          ((void (*)(unsigned __int16 *, BOOL, uint64_t, _QWORD))off_10098A970)(a1, v7 != 0, v8, 0);
      }
      else
      {
LABEL_13:
        sub_100253460();
      }
    }
  }
}

void sub_10020DF00(_QWORD *ptr)
{
  uint64_t v2;

  if (ptr)
  {
    v2 = ptr[1];
    if (v2)
      sub_100253F14(v2);
    sub_100053298(ptr);
  }
}

void sub_10020DF38(uint64_t a1)
{
  uint64_t *v1;
  uint64_t *v2;
  BOOL v3;
  NSObject *v4;
  uint64_t v5;
  int v6;
  NSObject *v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  NSObject *v11;
  char v12;
  int v13;
  __int16 v14;

  v1 = **(uint64_t ***)(a1 + 8);
  v2 = (uint64_t *)*((_QWORD *)&xmmword_10098A980 + 1);
  if (v1)
    v3 = *((_QWORD *)&xmmword_10098A980 + 1) == 0;
  else
    v3 = 1;
  if (v3)
  {
LABEL_7:
    if (!sub_10005549C())
      return;
    sub_100054530("Bearer is not valid");
    v4 = sub_1000544A0(0x44u);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      return;
    goto LABEL_9;
  }
  while (v2 != v1)
  {
    v2 = (uint64_t *)v2[10];
    if (!v2)
      goto LABEL_7;
  }
  v5 = *v1;
  v6 = sub_10005549C();
  if (!v5)
  {
    if (!v6)
      return;
    sub_100054530("Bearer handle is not valid");
    v9 = sub_1000544A0(0x44u);
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      return;
LABEL_9:
    sub_1006CE7A4();
    return;
  }
  if (v6)
  {
    sub_100054530("Timeout waiting for ATT response, forcing a disconnect.");
    v7 = sub_1000544A0(0x44u);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  v13 = *((_DWORD *)v1 + 2);
  v14 = *((_WORD *)v1 + 6);
  v12 = *((_BYTE *)v1 + 14);
  if (*v1)
  {
    if (*(_BYTE *)(*v1 + 2))
    {
      if (*(_BYTE *)(*v1 + 2) != 4)
        return;
      v8 = sub_100223EA0(&v12);
    }
    else
    {
      v8 = sub_100115684(((unint64_t)*((unsigned __int8 *)v1 + 8) << 40) | ((unint64_t)*((unsigned __int8 *)v1 + 9) << 32) | ((unint64_t)*((unsigned __int8 *)v1 + 10) << 24) | ((unint64_t)*((unsigned __int8 *)v1 + 11) << 16) | ((unint64_t)*((unsigned __int8 *)v1 + 12) << 8) | *((unsigned __int8 *)v1 + 13));
    }
    v10 = v8;
    if ((_DWORD)v8)
    {
      if (sub_10005549C())
      {
        sub_100054530("ATT disconnect timedout with status %!", v10);
        v11 = sub_1000544A0(0x44u);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
    }
  }
}

uint64_t sub_10020E0FC()
{
  _BYTE *v0;
  _BYTE *v1;
  uint64_t result;
  NSObject *v3;

  v0 = sub_100114588(0x10uLL);
  *((_QWORD *)&xmmword_10098A9F0 + 1) = v0;
  if (v0)
  {
    v1 = v0;
    result = 0;
    *v1 = 1;
    word_10098AA00 = 1;
    LOBYTE(xmmword_10098A9E0) = 1;
    LOBYTE(xmmword_10098A9F0) = 1;
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("Failed to allocate zero-index handle!");
      v3 = sub_1000544A0(0x44u);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 4013;
  }
  return result;
}

double sub_10020E194()
{
  double result;

  result = 0.0;
  xmmword_10098AA10 = 0u;
  *(_OWORD *)&qword_10098AA20 = 0u;
  xmmword_10098A9F0 = 0u;
  *(_OWORD *)&word_10098AA00 = 0u;
  xmmword_10098A9E0 = 0u;
  xmmword_10098AA40 = 0u;
  xmmword_10098AA50 = 0u;
  xmmword_10098AA60 = 0u;
  off_10098AA70 = 0;
  dword_10098AA78 = 0;
  return result;
}

__n128 sub_10020E1CC(uint64_t a1)
{
  __n128 result;
  __int128 v2;
  __int128 v3;

  result.n128_u64[0] = (unint64_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vuzp1q_s32((int32x4_t)vceqzq_s64((int64x2_t)xmmword_10098AA40), (int32x4_t)vceqzq_s64((int64x2_t)xmmword_10098AA50))));
  result.n128_u16[0] = vmaxv_u16((uint16x4_t)result.n128_u64[0]);
  if ((result.n128_u8[0] & 1) == 0 && *(_QWORD *)a1 && *(_QWORD *)(a1 + 8) && *(_QWORD *)(a1 + 16))
  {
    if (*(_QWORD *)(a1 + 24))
    {
      result = *(__n128 *)a1;
      v2 = *(_OWORD *)(a1 + 16);
      v3 = *(_OWORD *)(a1 + 32);
      off_10098AA70 = *(_UNKNOWN **)(a1 + 48);
      xmmword_10098AA50 = v2;
      xmmword_10098AA60 = v3;
      xmmword_10098AA40 = (__int128)result;
    }
  }
  return result;
}

uint64_t sub_10020E244(unsigned __int16 *a1)
{
  unsigned __int16 **v2;
  unsigned __int16 *v3;
  uint64_t result;
  NSObject *v6;

  v2 = (unsigned __int16 **)&xmmword_10098A9E0 + 1;
  do
  {
    v3 = *v2;
    v2 = (unsigned __int16 **)(*v2 + 12);
  }
  while (v3 != a1 && v3 != 0);
  if (v3)
    return a1[4];
  result = sub_10005549C();
  if ((_DWORD)result)
  {
    sub_100054530("Couldn't find active session %p!", a1);
    v6 = sub_1000544A0(0x44u);
    result = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
    {
      sub_1006CE7A4();
      return 0;
    }
  }
  return result;
}

_QWORD *sub_10020E2D8(uint64_t a1)
{
  _QWORD *result;

  result = (_QWORD *)*((_QWORD *)&xmmword_10098A9E0 + 1);
  if (*((_QWORD *)&xmmword_10098A9E0 + 1))
  {
    do
    {
      if (*result == a1)
        break;
      result = (_QWORD *)result[3];
    }
    while (result);
  }
  return result;
}

uint64_t sub_10020E300(unsigned int a1, uint64_t a2, unsigned int a3)
{
  NSObject *v6;
  uint64_t result;
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  void *v12;
  unsigned __int8 *v13;
  uint64_t v14;
  unint64_t v15;
  unsigned __int8 *v16;
  int v17;
  NSObject *v20;
  void *v21;
  const void *v22;
  NSObject *v23;
  NSObject *v24;

  if (!*(_QWORD *)(a2 + 32))
    sub_100253460();
  if (a3 >= 0x201)
  {
    if (sub_10005549C())
    {
      sub_100054530("Number of requested handles (%d) exceeds maximum allowed (%d)", a3, 512);
      v6 = sub_1000544A0(0x44u);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 4016;
  }
  if (a1)
    v8 = *(unsigned __int16 *)(*(_QWORD *)(*((_QWORD *)&xmmword_10098A9F0 + 1) + 16 * a1 + 8) + 24);
  else
    v8 = 0xFFFF;
  v9 = (unsigned __int16)word_10098AA00;
  v10 = a1 + 1;
  if (a1 + 1 < (unsigned __int16)word_10098AA00 && v8 > a1)
  {
    v12 = (void *)*((_QWORD *)&xmmword_10098A9F0 + 1);
    do
    {
      v13 = (unsigned __int8 *)(*((_QWORD *)&xmmword_10098A9F0 + 1) + 16 * v10);
      LODWORD(v14) = *v13;
      if ((_DWORD)v14 == 2)
      {
        LODWORD(v15) = *(unsigned __int16 *)(*((_QWORD *)v13 + 1) + 24);
      }
      else if (*v13)
      {
        LODWORD(v15) = v10;
      }
      else
      {
        if (a3 && v10 < (unsigned __int16)word_10098AA00)
        {
          LODWORD(v15) = v10;
          if (v10 <= v8)
          {
            v14 = 0;
            v16 = (unsigned __int8 *)(*((_QWORD *)&xmmword_10098A9F0 + 1) + 16 * v10);
            while (1)
            {
              v15 = v10 + v14;
              v17 = *v16;
              v16 += 16;
              if (v17)
                break;
              if (++v14 + (unint64_t)v10 >= (unsigned __int16)word_10098AA00
                || v15 >= v8
                || v14 >= a3)
              {
                LODWORD(v15) = v10 + v14;
                break;
              }
            }
          }
        }
        else
        {
          LODWORD(v15) = v10;
        }
        if ((_DWORD)v14 == a3)
        {
          *v13 = 2;
          LOWORD(v9) = v10;
          goto LABEL_48;
        }
      }
      v10 = v15 + 1;
    }
    while ((int)v15 + 1 < (unsigned __int16)word_10098AA00 && v15 < v8);
  }
  if (a1)
  {
    if (!sub_10005549C())
      goto LABEL_53;
    sub_100054530("No room for %d attributes in group [0x%04x -> 0x%04x]", a3 + 1, a1, v8);
    v20 = sub_1000544A0(0x44u);
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      goto LABEL_53;
    goto LABEL_52;
  }
  v21 = sub_100114588(16 * ((unsigned __int16)word_10098AA00 + a3) + 16);
  if (v21)
  {
    v12 = v21;
    v22 = (const void *)*((_QWORD *)&xmmword_10098A9F0 + 1);
    if (!*((_QWORD *)&xmmword_10098A9F0 + 1))
    {
      sub_100253460();
      v22 = (const void *)*((_QWORD *)&xmmword_10098A9F0 + 1);
    }
    memmove(v12, v22, 16 * (unsigned __int16)word_10098AA00);
    sub_100053298(*((void **)&xmmword_10098A9F0 + 1));
    *((_QWORD *)&xmmword_10098A9F0 + 1) = v12;
    word_10098AA00 += a3 + 1;
    *((_BYTE *)v12 + 16 * v9) = 2;
LABEL_48:
    if ((_WORD)v9)
    {
      result = 0;
      *((_QWORD *)v12 + 2 * (unsigned __int16)v9 + 1) = a2;
      *(_WORD *)a2 = v9;
      *(_WORD *)(a2 + 24) = v9 + a3;
      return result;
    }
    goto LABEL_53;
  }
  if (sub_10005549C())
  {
    sub_100054530("Failed to allocate new handle map of size %d", a3 + (unsigned __int16)word_10098AA00 + 1);
    v23 = sub_1000544A0(0x44u);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
LABEL_52:
      sub_1006CE7A4();
  }
LABEL_53:
  if (sub_10005549C())
  {
    sub_100054530("Can't add attribute to parent handle 0x%04x, with 0x%04x extra handles", a1, a3);
    v24 = sub_1000544A0(0x44u);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  return 4017;
}

void sub_10020E604(unsigned int a1, int a2)
{
  uint64_t v2;
  unsigned __int16 *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;
  void *v9;

  v2 = *((_QWORD *)&xmmword_10098A9F0 + 1);
  if (*(_BYTE *)(*((_QWORD *)&xmmword_10098A9F0 + 1) + 16 * a1) == 2)
  {
    v3 = *(unsigned __int16 **)(*((_QWORD *)&xmmword_10098A9F0 + 1) + 16 * a1 + 8);
    v4 = v3[12];
    v5 = *v3;
    if (v5 <= v4)
    {
      v7 = 16 * v5;
      v8 = v4 - v5 + 1;
      do
      {
        *(_BYTE *)(v2 + v7) = 3;
        if (a2)
        {
          v9 = *(void **)(v2 + v7 + 8);
          if (v9)
          {
            sub_100053298(v9);
            v2 = *((_QWORD *)&xmmword_10098A9F0 + 1);
          }
        }
        *(_QWORD *)(v2 + v7 + 8) = 0;
        v7 += 16;
        --v8;
      }
      while (v8);
    }
    if ((unsigned __int16)word_10098AA00 - 1 == (_DWORD)v4)
      sub_10020E6CC();
  }
}

void sub_10020E6CC()
{
  unsigned __int16 v0;
  int v1;
  unsigned __int16 v2;
  unsigned __int8 *v3;
  int v4;
  int v5;
  unsigned __int16 v6;
  char *v8;
  char *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;

  v0 = word_10098AA00;
  if (word_10098AA00)
  {
    v1 = (unsigned __int16)word_10098AA00 - 1;
    if (word_10098AA00 == 1)
    {
LABEL_10:
      v6 = 0;
      v0 = 1;
    }
    else
    {
      v2 = word_10098AA00 - 1;
      v3 = (unsigned __int8 *)(*((_QWORD *)&xmmword_10098A9F0 + 1) + 16 * (unsigned __int16)v1);
      while (1)
      {
        v5 = *v3;
        v3 -= 16;
        v4 = v5;
        v6 = v2;
        if (v5 != 3 && v4 != 0)
          break;
        --v2;
        v0 = v6;
        if (!v2)
          goto LABEL_10;
      }
    }
    if (v1 > v6)
    {
      v8 = (char *)sub_100114588(16 * v0);
      if (v8)
      {
        v9 = v8;
        memmove(v8, *((const void **)&xmmword_10098A9F0 + 1), 16 * v0);
        sub_100053298(*((void **)&xmmword_10098A9F0 + 1));
        *((_QWORD *)&xmmword_10098A9F0 + 1) = v9;
        word_10098AA00 = v0;
        if (v6)
        {
          v10 = v9 + 24;
          v11 = v6;
          do
          {
            if (*((_BYTE *)v10 - 8) == 2)
            {
              v12 = *v10;
              if (*v10)
              {
                if (*(unsigned __int16 *)(v12 + 24) > v6)
                  *(_WORD *)(v12 + 24) = v6;
              }
            }
            v10 += 2;
            --v11;
          }
          while (v11);
        }
      }
      else if (sub_10005549C())
      {
        sub_100054530("Failed to allocate new handle map of size %d", v0);
        v13 = sub_1000544A0(0x44u);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
    }
  }
}

void sub_10020E820(uint64_t a1, int a2, _WORD *a3)
{
  _QWORD *v5;
  uint64_t v6;
  NSObject *v8;

  v5 = (_QWORD *)&xmmword_10098A9E0 + 1;
  do
  {
    v6 = *v5;
    v5 = (_QWORD *)(*v5 + 24);
  }
  while (v6 != a1 && v6 != 0);
  if (v6)
  {
    if (a2)
    {
      if (*(_BYTE *)(a1 + 16))
        sub_100253460();
      *(_BYTE *)(a1 + 16) = 1;
    }
    else
    {
      if (!a3)
        sub_100253460();
      *(_BYTE *)(a1 + 16) = 0;
      *(_WORD *)(a1 + 8) = *a3;
      (*(&xmmword_10098AA50 + 1))(a1);
    }
  }
  else if (sub_10005549C())
  {
    sub_100054530("Couldn't find active session %p!", (const void *)a1);
    v8 = sub_1000544A0(0x44u);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
}

uint64_t sub_10020E8F8(uint64_t a1, __int16 a2, int a3, const void *a4, int a5)
{
  _QWORD *v10;
  uint64_t v11;
  uint64_t v13;
  NSObject *v14;
  char *v16;
  void *v17;
  char v18;
  NSObject *v19;
  const char *v20;
  NSObject *v21;
  NSObject *v22;
  const void *v23[2];
  BOOL v24;

  v24 = 0;
  v10 = (_QWORD *)&xmmword_10098A9E0 + 1;
  do
  {
    v11 = *v10;
    v10 = (_QWORD *)(*v10 + 24);
  }
  while (v11 != a1 && v11 != 0);
  if (v11)
  {
    if ((_BYTE)xmmword_10098A9F0)
    {
      if (*(_BYTE *)(a1 + 16))
      {
        return 146;
      }
      else
      {
        v16 = (char *)sub_100114588(*(unsigned __int16 *)(a1 + 8));
        if (v16)
        {
          v17 = v16;
          if (a3)
            v18 = 27;
          else
            v18 = 29;
          *v16 = v18;
          *(_WORD *)(v16 + 1) = a2;
          if (*(unsigned __int16 *)(a1 + 8) - 3 < a5)
            LOWORD(a5) = *(_WORD *)(a1 + 8) - 3;
          memmove(v16 + 3, a4, (unsigned __int16)a5);
          if ((a3 & 1) == 0 && *(_DWORD *)(a1 + 12) && (sub_100253460(), *(_DWORD *)(a1 + 12)))
          {
            if (sub_10005549C())
            {
              sub_100054530("Session 0x%x already has an outstanding indication!", a1);
              v19 = sub_1000544A0(0x44u);
              if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
                sub_1006CE7A4();
            }
            sub_100053298(v17);
            return 4020;
          }
          else
          {
            v13 = sub_10020EBA4(*(__int128 **)a1, (char *)v17, (unsigned __int16)(a5 + 3), &v24);
            sub_100053298(v17);
            if ((_DWORD)v13)
            {
              if (sub_10005549C())
              {
                v20 = "indication";
                if (a3)
                  v20 = "notification";
                sub_100054530("Failed to send %s for session 0x%x with result %!", v20, a1, v13);
                v21 = sub_1000544A0(0x44u);
                if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
                  sub_1006CE7A4();
              }
            }
            else
            {
              LOBYTE(xmmword_10098A9F0) = v24;
              if ((a3 & 1) == 0)
              {
                v23[1] = (const void *)a1;
                v23[0] = (const void *)8;
                sub_10004A9EC((uint64_t)sub_10020EC50, v23, (unsigned __int16)dword_10097A8C0, (int *)(a1 + 12));
              }
              return 0;
            }
          }
        }
        else
        {
          if (sub_10005549C())
          {
            sub_100054530("Failed to allocate memory for update");
            v22 = sub_1000544A0(0x44u);
            if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
              sub_1006CE7A4();
          }
          return 4019;
        }
      }
    }
    else
    {
      return 410;
    }
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("Couldn't find active session %p!", (const void *)a1);
      v14 = sub_1000544A0(0x44u);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 4018;
  }
  return v13;
}

uint64_t sub_10020EBA4(__int128 *a1, char *a2, size_t a3, BOOL *a4)
{
  uint64_t v8;
  unsigned int v9;
  _OWORD v11[7];

  memset(v11, 0, sizeof(v11));
  v8 = sub_1000532A8((uint64_t)v11, 1u);
  if (!(_DWORD)v8)
  {
    v8 = sub_10005336C((unsigned __int8 *)v11, a2, a3, 2u);
    if (!(_DWORD)v8)
    {
      v9 = sub_10020AF6C(a1, (uint64_t)v11, 1u, a4);
      if (v9 == 412)
        v8 = 0;
      else
        v8 = v9;
    }
  }
  sub_100253FD8((uint64_t)v11);
  return v8;
}

void sub_10020EC50(uint64_t a1)
{
  _QWORD *v1;
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  _BOOL4 v7;
  NSObject *v8;
  _DWORD v9[2];

  v1 = (_QWORD *)*((_QWORD *)&xmmword_10098A9E0 + 1);
  if (!*((_QWORD *)&xmmword_10098A9E0 + 1))
    return;
  v2 = **(_QWORD **)(a1 + 8);
  while (*v1 != v2)
  {
    v1 = (_QWORD *)v1[3];
    if (!v1)
      return;
  }
  if (!sub_10005549C()
    || (sub_100054530("Timed out waiting for indication response - disconnecting!"),
        v3 = sub_1000544A0(0x44u),
        !os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)))
  {
    if (v2)
      goto LABEL_9;
LABEL_22:
    if ((sub_10005549C() & 1) != 0)
    {
      v7 = 0;
LABEL_24:
      sub_100054530("Invalid transport %d in Indication Response Timeout Handler", v7);
      v8 = sub_1000544A0(0x44u);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
LABEL_26:
    sub_100253460();
    return;
  }
  sub_1006CE7A4();
  if (!v2)
    goto LABEL_22;
LABEL_9:
  if (!*(_BYTE *)(v2 + 2))
  {
    v5 = sub_100115684(((unint64_t)*(unsigned __int8 *)(v2 + 48) << 40) | ((unint64_t)*(unsigned __int8 *)(v2 + 49) << 32) | ((unint64_t)*(unsigned __int8 *)(v2 + 50) << 24) | ((unint64_t)*(unsigned __int8 *)(v2 + 51) << 16) | ((unint64_t)*(unsigned __int8 *)(v2 + 52) << 8) | *(unsigned __int8 *)(v2 + 53));
    goto LABEL_14;
  }
  if (*(_BYTE *)(v2 + 2) != 4)
  {
    if (sub_10005549C())
    {
      v7 = *(unsigned __int8 *)(v2 + 2) == 4;
      goto LABEL_24;
    }
    goto LABEL_26;
  }
  *(_DWORD *)((char *)v9 + 3) = 0;
  v9[0] = 0;
  v4 = 0;
  if (!sub_1002214B4(v2, (uint64_t)v9, 0))
  {
    *(_DWORD *)(v2 + 132) = 6;
    *(_DWORD *)(v2 + 140) = 4541;
    v5 = sub_100223EA0(v9);
LABEL_14:
    v4 = v5;
  }
  if ((_DWORD)v4 && sub_10005549C())
  {
    sub_100054530("ATT disconnect failure during Indication response with status %!", v4);
    v6 = sub_1000544A0(0x44u);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
}

uint64_t sub_10020EE18()
{
  uint64_t v0;
  uint64_t result;
  unsigned __int8 *v2;
  int v3;
  int v4;
  BOOL v5;

  v0 = (unsigned __int16)word_10098AA00;
  if ((unsigned __int16)word_10098AA00 >= 0x100uLL)
  {
    LOBYTE(result) = 0;
    v2 = (unsigned __int8 *)*((_QWORD *)&xmmword_10098A9F0 + 1);
    do
    {
      v4 = *v2;
      v2 += 16;
      v3 = v4;
      if ((result & 1) != 0)
      {
        result = 1;
        if (v3 == 2)
          return result;
      }
      else
      {
        if (v3)
          v5 = v3 == 3;
        else
          v5 = 1;
        LOBYTE(result) = v5;
      }
      --v0;
    }
    while (v0);
  }
  return 0;
}

_WORD *sub_10020EE68(uint64_t a1, __int16 a2)
{
  _WORD *v4;
  _WORD *v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;

  v4 = sub_100114588(0x28uLL);
  v5 = v4;
  if (v4)
  {
    v6 = *((_QWORD *)&xmmword_10098A9E0 + 1);
    *(_QWORD *)v4 = a1;
    v4[4] = a2;
    sub_1001F37D8(a1);
    while (v6)
    {
      v7 = v6;
      v6 = *(_QWORD *)(v6 + 24);
      if (!v6)
      {
        *(_QWORD *)(v7 + 24) = v5;
        *((_QWORD *)v5 + 4) = v7;
        goto LABEL_10;
      }
    }
    *((_QWORD *)&xmmword_10098A9E0 + 1) = v5;
LABEL_10:
    sub_10020EF30(a1, 1);
  }
  else if (sub_10005549C())
  {
    sub_100054530("Failed to allocate new DB session!");
    v8 = sub_1000544A0(0x44u);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  return v5;
}

void sub_10020EF30(uint64_t a1, int a2)
{
  unsigned __int16 v2;
  BOOL v3;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unsigned __int16 v9;
  _QWORD *v10;
  uint64_t v11;
  char *v12;
  char *v13;
  unsigned int v14;
  char *v15;
  uint64_t v16;
  unint64_t v17;
  unsigned __int16 v18;
  char *v19;
  int v20;
  char *v21;
  __int128 v22;
  NSObject *v23;
  NSObject *v24;

  v2 = word_10098AA28;
  if (word_10098AA28)
    v3 = *((_QWORD *)&xmmword_10098AA10 + 1) == 0;
  else
    v3 = 0;
  if (v3)
  {
    v6 = 0;
    v7 = qword_10098AA20;
    v8 = 1;
    v9 = word_10098AA28;
    do
    {
      v10 = (_QWORD *)(v7 + v6);
      if (!a1 || *v10 == a1)
      {
        if (a2)
          sub_10020F928(*(__int128 **)(v7 + v6), *(unsigned __int8 **)(v7 + v6 + 8), *(unsigned __int16 *)(v7 + v6 + 16), 0);
        sub_100053298(*(void **)(v7 + v6 + 8));
        *v10 = 0;
        v10[1] = 0;
        v10[2] = 0;
        --v9;
        v2 = word_10098AA28;
        v11 = *((_QWORD *)&xmmword_10098AA10 + 1);
        v7 = qword_10098AA20;
      }
      else
      {
        v11 = 0;
      }
      if (v8 >= v2)
        break;
      v6 += 24;
      ++v8;
    }
    while (!v11);
    if (v9 != v2)
    {
      if (!v9)
      {
        v13 = 0;
        v15 = (char *)qword_10098AA20;
        goto LABEL_26;
      }
      v12 = (char *)sub_100114588(24 * v9);
      if (v12)
      {
        v13 = v12;
        v14 = (unsigned __int16)word_10098AA28;
        v15 = (char *)qword_10098AA20;
        if (word_10098AA28)
        {
          v16 = 0;
          v17 = 0;
          v18 = 0;
          do
          {
            v19 = &v15[v16];
            if (*(_QWORD *)&v15[v16])
            {
              if (v18 >= v9)
              {
                if (sub_10005549C())
                {
                  sub_100054530("Not enough allocation to update stalled request");
                  v24 = sub_1000544A0(0x44u);
                  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
                    sub_1006CE7A4();
                }
                sub_100053298(v13);
                return;
              }
              v20 = v18++;
              v21 = &v13[24 * v20];
              v22 = *(_OWORD *)v19;
              *((_QWORD *)v21 + 2) = *((_QWORD *)v19 + 2);
              *(_OWORD *)v21 = v22;
              v15 = (char *)qword_10098AA20;
              v14 = (unsigned __int16)word_10098AA28;
            }
            ++v17;
            v16 += 24;
          }
          while (v17 < v14);
        }
LABEL_26:
        sub_100053298(v15);
        qword_10098AA20 = (uint64_t)v13;
        word_10098AA28 = v9;
        return;
      }
      if (sub_10005549C())
      {
        sub_100054530("Failed to allocate room for updated stall queue");
        v23 = sub_1000544A0(0x44u);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
    }
  }
}

void sub_10020F14C(unsigned __int16 *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v2 = *((_QWORD *)&xmmword_10098A9E0 + 1);
  v3 = sub_10020F254(a1);
  if (v3)
    sub_10020F348(v3);
  if (v2)
  {
    while (*(unsigned __int16 **)v2 != a1)
    {
      v2 = *(_QWORD *)(v2 + 24);
      if (!v2)
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    if (sub_10005549C())
    {
      sub_100054530("Failed to find the DB session to destroy!");
      v2 = sub_1000544A0(0x44u);
      if (os_log_type_enabled((os_log_t)v2, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    sub_100253460();
    __break(1u);
  }
  v4 = *(unsigned int *)(v2 + 12);
  if ((_DWORD)v4)
  {
    sub_100049F6C(v4);
    xmmword_10098AA50(v2);
  }
  if (xmmword_10098AA60)
    xmmword_10098AA60(0, v2, 0, 0, 0);
  sub_10020EF30((uint64_t)a1, 0);
  v6 = *(_QWORD *)(v2 + 24);
  v5 = *(_QWORD *)(v2 + 32);
  if (!v5)
  {
    *((_QWORD *)&xmmword_10098A9E0 + 1) = *(_QWORD *)(v2 + 24);
    if (!v6)
      goto LABEL_17;
    goto LABEL_16;
  }
  *(_QWORD *)(v5 + 24) = v6;
  v6 = *(_QWORD *)(v2 + 24);
  if (v6)
LABEL_16:
    *(_QWORD *)(v6 + 32) = v5;
LABEL_17:
  sub_100053298((void *)v2);
}

uint64_t sub_10020F254(unsigned __int16 *a1)
{
  uint64_t v1;
  uint64_t result;
  unsigned __int16 **v4;
  NSObject *v5;
  NSObject *v6;

  v1 = (unsigned __int16)xmmword_10098AA10;
  if (!(_WORD)xmmword_10098AA10)
    return 0;
  result = qword_10098AA08;
  if (!qword_10098AA08)
  {
    if (!sub_10005549C())
      return 0;
    sub_100054530("findResponseByHCIHandle response is NULL lmHandle=%d", *a1);
    v5 = sub_1000544A0(0x44u);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      return 0;
    goto LABEL_12;
  }
  while (1)
  {
    v4 = *(unsigned __int16 ***)(result + 24);
    if (!v4)
      break;
    if (*v4 == a1)
      return result;
    result += 72;
    if (!--v1)
      return 0;
  }
  if (sub_10005549C())
  {
    sub_100054530("findResponseByHCIHandle session is NULL lmHandle=%d", *a1);
    v6 = sub_1000544A0(0x44u);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
LABEL_12:
      sub_1006CE7A4();
  }
  return 0;
}

void sub_10020F348(uint64_t a1)
{
  uint64_t v2;
  size_t v3;
  uint64_t i;
  unsigned __int16 v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  uint64_t v10;

  if ((_WORD)xmmword_10098AA10)
  {
    v2 = 0;
    v3 = 72 * (unsigned __int16)(xmmword_10098AA10 - 1);
    for (i = 72; qword_10098AA08 + i - 72 != a1; i += 72)
    {
      ++v2;
      v3 -= 72;
      if ((unsigned __int16)xmmword_10098AA10 == v2)
        return;
    }
    v5 = xmmword_10098AA10 - 1;
    if ((_WORD)xmmword_10098AA10 == 1)
    {
      v7 = 0;
    }
    else
    {
      v6 = sub_100114588(72 * (unsigned __int16)(xmmword_10098AA10 - 1));
      v7 = v6;
      if ((_WORD)v2)
        memmove(v6, (const void *)qword_10098AA08, i - 72);
      if (v5 > (unsigned __int16)v2)
        memmove(v7, (const void *)(qword_10098AA08 + i), v3);
    }
    v8 = *(void **)(a1 + 56);
    if (v8)
      sub_100053298(v8);
    v9 = *(void **)(a1 + 40);
    if (v9)
      sub_100053298(v9);
    v10 = *(unsigned int *)(a1 + 16);
    if ((_DWORD)v10)
      sub_100049F6C(v10);
    sub_100053298((void *)qword_10098AA08);
    qword_10098AA08 = (uint64_t)v7;
    LOWORD(xmmword_10098AA10) = v5;
  }
}

uint64_t sub_10020F474()
{
  LOBYTE(xmmword_10098A9F0) = 1;
  return (*((uint64_t (**)(_QWORD))&xmmword_10098AA50 + 1))(0);
}

void sub_10020F490(int a1)
{
  NSObject *v2;
  uint8_t buf[4];
  void *v4;

  if (sub_10005549C())
  {
    sub_100054530("Overriding ATT MTU to %d", a1);
    v2 = sub_1000544A0(0x44u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v4 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  word_10098AA7C = a1;
}

uint64_t sub_10020F55C(uint64_t a1)
{
  uint64_t i;
  NSObject *v3;
  NSObject *v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  int v10;
  NSObject *v11;
  NSObject *v12;
  uint64_t v13;
  NSObject *v14;
  _BYTE v16[3];
  uint8_t buf[4];
  void *v18;

  v16[2] = 0;
  *(_WORD *)v16 = 3;
  for (i = *((_QWORD *)&xmmword_10098A9E0 + 1); i; i = *(_QWORD *)(i + 24))
  {
    if (*(_QWORD *)i == a1)
      break;
  }
  if (!a1
    && sub_10005549C()
    && (sub_100054530("LE ATT DB Handle MTU Change Request null hci handle"),
        v3 = sub_1000544A0(0x44u),
        os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)))
  {
    sub_1006CEEC0();
    if (i)
      goto LABEL_12;
  }
  else if (i)
  {
    goto LABEL_12;
  }
  if (sub_10005549C())
  {
    sub_100054530("LE ATT DB Handle MTU Change Request session not found");
    v4 = sub_1000544A0(0x44u);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  sub_100253460();
LABEL_12:
  v5 = *(unsigned __int16 *)(i + 18);
  if (!*(_WORD *)(i + 18))
  {
    v7 = 0;
    if (!sub_10005549C())
      return v7;
    sub_100054530("No pending ATT MTU requests");
    v8 = sub_1000544A0(0x44u);
    v7 = 0;
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      return v7;
    *(_DWORD *)buf = 136446210;
    v18 = sub_100054494();
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    return 0;
  }
  *(_WORD *)(i + 18) = 0;
  if (a1 && !*(_BYTE *)(a1 + 2))
  {
    v6 = *(unsigned __int16 *)(i + 8);
  }
  else
  {
    v6 = (unsigned __int16)word_10098AA7C;
    if (!word_10098AA7C)
      v6 = sub_10020D0F4(a1);
  }
  if (v5 >= v6)
    v9 = v6;
  else
    v9 = v5;
  v10 = *(unsigned __int16 *)(i + 8);
  if (v10 != 23 && (_DWORD)v9 != v10)
  {
    if (sub_10005549C())
    {
      sub_100054530("The negotiated MTU is different from a previously negotiated one: %u != %u", *(unsigned __int16 *)(i + 8), v9);
      v11 = sub_1000544A0(0x44u);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  *(_WORD *)&v16[1] = v9;
  if (sub_10005549C())
  {
    sub_100054530("MTU response: desiredMTU %d, remoteMTU %d", v6, v5);
    v12 = sub_1000544A0(0x44u);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v18 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if (sub_10020EBA4((__int128 *)a1, v16, 3uLL, 0))
  {
    *(_DWORD *)buf = 513;
    LOBYTE(v18) = 17;
    return sub_10020EBA4((__int128 *)a1, (char *)buf, 5uLL, 0);
  }
  *(_WORD *)(i + 8) = v9;
  v13 = sub_1002265D0(a1, v9);
  if (!(_DWORD)v13)
  {
    if (off_10098AA70)
      off_10098AA70(i, v9);
    return 0;
  }
  v7 = v13;
  if (sub_10005549C())
  {
    sub_100054530("ATT DB failed to set GATT MTU");
    v14 = sub_1000544A0(0x44u);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v7;
}

uint64_t sub_10020F8BC(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;

  v1 = *((_QWORD *)&xmmword_10098A9E0 + 1);
  if (!*((_QWORD *)&xmmword_10098A9E0 + 1))
    return 4202;
  while (*(_QWORD *)v1 != a1)
  {
    v1 = *(_QWORD *)(v1 + 24);
    if (!v1)
      return 4202;
  }
  v3 = *(unsigned int *)(v1 + 12);
  if (!(_DWORD)v3)
    return 4203;
  sub_100049F6C(v3);
  *(_DWORD *)(v1 + 12) = 0;
  xmmword_10098AA50(v1);
  return 0;
}

void sub_10020F928(__int128 *a1, unsigned __int8 *a2, size_t size, char a4)
{
  unsigned int v5;
  int v8;
  __int128 **v9;
  NSObject *v10;
  int v11;
  uint64_t v12;
  __int128 **v13;
  void *v14;
  void *v15;
  char *v16;
  uint64_t v17;
  char *v18;
  NSObject *v19;
  uint64_t v20;
  unsigned int *v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  NSObject *v25;
  NSObject *v26;
  NSObject *v27;
  int v28;
  NSObject *v29;

  if (a1)
  {
    v5 = size;
    v8 = *((unsigned __int8 *)a1 + 2);
    if (v8 == 4)
    {
      if (!sub_10019AC00((uint64_t)a1))
        return;
      v8 = *((unsigned __int8 *)a1 + 2);
    }
    if ((v8 || sub_10019AB28((uint64_t)a1)) && a2 && v5)
    {
      if ((_BYTE)xmmword_10098A9E0)
      {
        if ((*a2 | 0x80) == 0xD2 || (v20 = sub_10020F254((unsigned __int16 *)a1)) == 0)
        {
          v9 = (__int128 **)*((_QWORD *)&xmmword_10098A9E0 + 1);
          if (*((_QWORD *)&xmmword_10098A9E0 + 1))
          {
            while (*v9 != a1)
            {
              v9 = (__int128 **)v9[3];
              if (!v9)
                goto LABEL_14;
            }
          }
          else
          {
LABEL_14:
            if (sub_10005549C())
            {
              sub_100054530("Couldn't find active session for ATT Request lmHandle 0x%x request %d", *(unsigned __int16 *)a1, *a2);
              v10 = sub_1000544A0(0x44u);
              if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
                sub_1006CE7A4();
            }
            sub_100253460();
          }
          v11 = *a2;
          if (!*((_QWORD *)&xmmword_10098AA10 + 1))
          {
            v23 = 4201;
            switch(*a2)
            {
              case 2u:
                v24 = sub_10020FDDC((uint64_t)a1, (uint64_t)a2, v5);
                goto LABEL_56;
              case 3u:
              case 5u:
              case 7u:
              case 9u:
              case 0xBu:
              case 0xDu:
              case 0xFu:
              case 0x11u:
              case 0x13u:
              case 0x14u:
              case 0x15u:
              case 0x17u:
              case 0x19u:
              case 0x1Au:
              case 0x1Bu:
              case 0x1Cu:
              case 0x1Du:
                goto LABEL_62;
              case 4u:
                v24 = sub_10020FFDC(a1, (char *)a2, v5);
                goto LABEL_56;
              case 6u:
                v24 = sub_100210330(a1, a2, v5, a4);
                goto LABEL_56;
              case 8u:
              case 0x10u:
                v24 = sub_100210668(a1, a2, v5, a4);
                goto LABEL_56;
              case 0xAu:
              case 0xCu:
                v24 = sub_100210B10(a1, a2, v5, a4);
                goto LABEL_56;
              case 0xEu:
                v24 = sub_100210E80(a1, a2, v5, a4);
                goto LABEL_56;
              case 0x12u:
              case 0x16u:
                goto LABEL_46;
              case 0x18u:
                v24 = sub_10021192C(a1, (char *)a2, v5);
                goto LABEL_56;
              case 0x1Eu:
                v24 = sub_10020F8BC((uint64_t)a1);
                goto LABEL_56;
              default:
                if (v11 != 82)
                  goto LABEL_62;
LABEL_46:
                v24 = sub_100211270(a1, a2, v5);
LABEL_56:
                v23 = v24;
                if ((int)v24 > 4309)
                {
                  if ((_DWORD)v24 == 4310)
                    return;
                  v28 = 4540;
                }
                else
                {
                  if (!(_DWORD)v24)
                    return;
                  v28 = 4300;
                }
                if ((_DWORD)v24 == v28)
                  return;
LABEL_62:
                if (sub_10005549C())
                {
                  sub_100054530("LE_ATT_DB_ProcessClientRequest opcode 0x%x failed with %!", *a2, v23);
                  v29 = sub_1000544A0(0x44u);
                  if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
                    goto LABEL_64;
                }
                return;
            }
          }
          if ((v11 | 0x80) != 0xD2)
          {
            v12 = (unsigned __int16)word_10098AA28;
            if (!word_10098AA28)
            {
LABEL_24:
              v14 = sub_100052DC0(v5);
              if (v14)
              {
                v15 = v14;
                memmove(v14, a2, v5);
                v16 = (char *)sub_100114588(24 * (unsigned __int16)word_10098AA28 + 24);
                if (v16)
                {
                  v17 = (uint64_t)v16;
                  v18 = &v16[24 * (unsigned __int16)word_10098AA28];
                  *(_QWORD *)v18 = a1;
                  *((_QWORD *)v18 + 1) = v15;
                  *((_WORD *)v18 + 8) = v5;
                  *(_DWORD *)(v18 + 18) = 0;
                  *((_WORD *)v18 + 11) = 0;
                  if (qword_10098AA20)
                  {
                    memmove(v16, (const void *)qword_10098AA20, 24 * (unsigned __int16)word_10098AA28);
                    sub_100053298((void *)qword_10098AA20);
                  }
                  qword_10098AA20 = v17;
                  ++word_10098AA28;
                  return;
                }
                if (!sub_10005549C())
                  return;
                sub_100054530("Failed to add new request to stall queue");
                v27 = sub_1000544A0(0x44u);
                if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
                  return;
              }
              else
              {
                if (!sub_10005549C())
                  return;
                sub_100054530("Failed to backup stalled request");
                v26 = sub_1000544A0(0x44u);
                if (!os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
                  return;
              }
LABEL_64:
              sub_1006CE7A4();
              return;
            }
            v13 = (__int128 **)qword_10098AA20;
            while (*v13 != a1)
            {
              v13 += 3;
              if (!--v12)
                goto LABEL_24;
            }
            if (sub_10005549C())
            {
              sub_100054530("Ignoring request as connection 0x%x already has one in the stall queue", (_DWORD)a1);
              v25 = sub_1000544A0(0x44u);
              if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
                goto LABEL_64;
            }
          }
        }
        else
        {
          v21 = (unsigned int *)v20;
          if (sub_10005549C())
          {
            sub_100054530("Ignoring request [%@] as connection 0x%x is already pending transaction %d", a2, v5, a1, *v21);
            v22 = sub_1000544A0(0x44u);
            if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
              goto LABEL_64;
          }
        }
      }
      else if (sub_10005549C())
      {
        sub_100054530("Ignoring request as ATT database is not initialized!");
        v19 = sub_1000544A0(0x44u);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          goto LABEL_64;
      }
    }
  }
}

uint64_t sub_10020FDDC(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6;
  NSObject *v7;
  unsigned int v8;
  NSObject *v9;
  char v10;
  uint64_t result;
  int v12;
  NSObject *v13;
  _BOOL4 v14;
  uint8_t buf[4];
  void *v16;

  v6 = *((_QWORD *)&xmmword_10098A9E0 + 1);
  if (*((_QWORD *)&xmmword_10098A9E0 + 1))
  {
    while (*(_QWORD *)v6 != a1)
    {
      v6 = *(_QWORD *)(v6 + 24);
      if (!v6)
        goto LABEL_4;
    }
  }
  else
  {
LABEL_4:
    if (sub_10005549C())
    {
      sub_100054530("LE ATT DB Handle MTU Change Request session not found");
      v7 = sub_1000544A0(0x44u);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    sub_100253460();
    v6 = 0;
  }
  if (a3 != 3)
  {
    *(_DWORD *)buf = 513;
    v10 = 4;
LABEL_15:
    LOBYTE(v16) = v10;
    return sub_10020EBA4((__int128 *)a1, (char *)buf, 5uLL, 0);
  }
  v8 = *(unsigned __int16 *)(a2 + 1);
  *(_WORD *)(v6 + 18) = v8;
  if (v8 <= 0x16)
  {
    if (sub_10005549C())
    {
      sub_100054530("Invalid requested MTU %d", *(unsigned __int16 *)(v6 + 18));
      v9 = sub_1000544A0(0x44u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    *(_DWORD *)buf = 513;
    v10 = 17;
    goto LABEL_15;
  }
  if (*(_DWORD *)(a1 + 132) == 7)
    return sub_10020F55C(a1);
  v12 = sub_10005549C();
  result = 0;
  if (v12)
  {
    sub_100054530("Peer asked for MTU:%d while link is not ready, waiting for link to be ready", *(unsigned __int16 *)(v6 + 18));
    v13 = sub_1000544A0(0x44u);
    v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (v14)
    {
      *(_DWORD *)buf = 136446210;
      v16 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      return 0;
    }
  }
  return result;
}

uint64_t sub_10020FFDC(__int128 *a1, char *a2, unsigned int a3)
{
  uint64_t i;
  NSObject *v5;
  char v6;
  char v7;
  unint64_t v8;
  unint64_t v9;
  _BYTE *v10;
  void *v11;
  int v12;
  unsigned __int16 v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  int v18;
  int v19;
  char v20;
  uint64_t v21;
  int v22;
  NSObject *v23;
  uint64_t result;
  uint64_t v25;
  NSObject *v26;
  char v27;
  int v28;
  char v29;

  for (i = *((_QWORD *)&xmmword_10098A9E0 + 1); i; i = *(_QWORD *)(i + 24))
  {
    if (*(__int128 **)i == a1)
      break;
  }
  if (a3 <= 4)
  {
    if (sub_10005549C())
    {
      sub_100054530("Could not unpack Find Information Request");
      v5 = sub_1000544A0(0x44u);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    v28 = 1025;
    v6 = 4;
    goto LABEL_33;
  }
  v7 = *a2;
  v8 = *(unsigned __int16 *)(a2 + 1);
  v9 = *(unsigned __int16 *)(a2 + 3);
  if (v9 <= (unsigned __int16)(v8 - 1))
  {
    if (sub_10005549C())
    {
      sub_100054530("Invalid handle(s) (0x%04x, 0x%04x) for Find Information Request", v8, v9);
      v23 = sub_1000544A0(0x44u);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    v6 = 1;
    LOBYTE(v28) = 1;
    BYTE1(v28) = v7;
    HIWORD(v28) = v8;
    goto LABEL_33;
  }
  v10 = sub_100114588(*(unsigned __int16 *)(i + 8));
  if (!v10)
  {
    LOBYTE(v28) = 1;
    BYTE1(v28) = v7;
    HIWORD(v28) = v8;
    v6 = 17;
    goto LABEL_33;
  }
  v11 = v10;
  v27 = v7;
  v12 = *(unsigned __int16 *)(i + 8);
  *v10 = 5;
  if (v8 > v9
    || (v13 = word_10098AA00, v8 >= (unsigned __int16)word_10098AA00))
  {
LABEL_27:
    sub_100053298(v11);
    LOBYTE(v28) = 1;
    BYTE1(v28) = v27;
    HIWORD(v28) = v8;
    v6 = 10;
LABEL_33:
    v29 = v6;
    return sub_10020EBA4(a1, (char *)&v28, 5uLL, 0);
  }
  v14 = 0;
  v15 = *((_QWORD *)&xmmword_10098A9F0 + 1);
  v16 = 16 * v8;
  v17 = v8;
  v18 = 1;
  do
  {
    if (*(_BYTE *)(v15 + v16) == 2)
    {
      v19 = *(unsigned __int8 *)(*(_QWORD *)(v15 + v16 + 8) + 4);
      if (v14)
      {
        if (v14 != v19)
          goto LABEL_35;
      }
      else
      {
        if (v19 == 2)
          v20 = 1;
        else
          v20 = 2;
        v21 = (unsigned __int16)v18++;
        *((_BYTE *)v11 + v21) = v20;
        v14 = v19;
      }
      if (v12 - (unsigned __int16)v18 < v14 + 2)
        goto LABEL_35;
      *((_BYTE *)v11 + (unsigned __int16)v18) = v17;
      *((_BYTE *)v11 + (unsigned __int16)(v18 + 1)) = BYTE1(v17);
      v22 = v18 + 2;
      sub_100072C50((_BYTE *)v11 + (unsigned __int16)(v18 + 2), (unsigned __int8 *)(*(_QWORD *)(*((_QWORD *)&xmmword_10098A9F0 + 1) + v16 + 8) + 4), 1);
      v18 = v22 + v14;
      v13 = word_10098AA00;
      v15 = *((_QWORD *)&xmmword_10098A9F0 + 1);
    }
    if (v17 >= v9)
      break;
    ++v17;
    v16 += 16;
  }
  while (v17 < v13);
  if ((unsigned __int16)v18 == 1)
    goto LABEL_27;
LABEL_35:
  if (!sub_10020EBA4(a1, (char *)v11, (unsigned __int16)v18, 0))
  {
    sub_100053298(v11);
    return 0;
  }
  LOBYTE(v28) = 1;
  BYTE1(v28) = v27;
  HIWORD(v28) = v8;
  v29 = 17;
  v25 = sub_10020EBA4(a1, (char *)&v28, 5uLL, 0);
  sub_100053298(v11);
  result = 0;
  if ((_DWORD)v25)
  {
    if ((_DWORD)v25 != 412)
    {
      result = sub_10005549C();
      if ((_DWORD)result)
      {
        sub_100054530("ATT Send status %!", v25);
        v26 = sub_1000544A0(0x44u);
        result = os_log_type_enabled(v26, OS_LOG_TYPE_ERROR);
        if ((_DWORD)result)
        {
          sub_1006CEEC0();
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t sub_100210330(__int128 *a1, _DWORD *a2, unsigned int a3, char a4)
{
  uint64_t i;
  NSObject *v9;
  char v10;
  __int16 v11;
  _BYTE *v12;
  int v13;
  int v14;
  void *v15;
  NSObject *v16;
  void *v18;
  uint64_t v19;
  NSObject *v20;
  _OWORD v21[4];
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  void *ptr[2];
  __int128 v26;
  uint64_t v27;
  _BYTE v28[7];
  char *v29;
  __int16 v30;

  v30 = 0;
  v29 = 0;
  v27 = 0;
  *(_OWORD *)ptr = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  LODWORD(v23) = dword_10098AA78;
  for (i = *((_QWORD *)&xmmword_10098A9E0 + 1); i; i = *(_QWORD *)(i + 24))
  {
    if (*(__int128 **)i == a1)
      break;
  }
  *((_QWORD *)&v24 + 1) = i;
  if (a3 <= 6)
  {
    if (sub_10005549C())
    {
      sub_100054530("Could not unpack Find By Type Value Request");
      v9 = sub_1000544A0(0x44u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    LODWORD(v21[0]) = 1537;
    v10 = 4;
    goto LABEL_9;
  }
  *(_DWORD *)v28 = *a2;
  *(_DWORD *)&v28[3] = *(_DWORD *)((char *)a2 + 3);
  v11 = *(_WORD *)&v28[1];
  if (*(unsigned __int16 *)&v28[3] <= (unsigned __int16)(*(_WORD *)&v28[1] - 1))
  {
    if (sub_10005549C())
    {
      sub_100054530("Invalid handle(s) (0x%04x, 0x%04x) for Find By Type Value Request", *(unsigned __int16 *)&v28[1], *(unsigned __int16 *)&v28[3]);
      v16 = sub_1000544A0(0x44u);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    LOBYTE(v21[0]) = 1;
    BYTE1(v21[0]) = v28[0];
    WORD1(v21[0]) = *(_WORD *)&v28[1];
    BYTE4(v21[0]) = 1;
    return sub_10020EBA4(a1, (char *)v21, 5uLL, 0);
  }
  if (a3 != 7)
  {
    v29 = (char *)a2 + 7;
    v30 = a3 - 7;
  }
  v12 = sub_100114588(*(unsigned __int16 *)(i + 8));
  ptr[1] = v12;
  if (!v12)
  {
    LOBYTE(v21[0]) = 1;
    BYTE1(v21[0]) = v28[0];
    WORD1(v21[0]) = *(_WORD *)&v28[1];
    v10 = 17;
LABEL_9:
    BYTE4(v21[0]) = v10;
    return sub_10020EBA4(a1, (char *)v21, 5uLL, 0);
  }
  LOWORD(v26) = *(_WORD *)(i + 8);
  WORD1(v26) = 1;
  *v12 = 7;
  v13 = sub_100211BE8((uint64_t)v28, (unsigned int *)&v23, a4);
  v14 = v13;
  if (v13 == 240)
  {
    *((_QWORD *)&v23 + 1) = sub_100211E14;
    v18 = sub_100052DC0(a3);
    *((_QWORD *)&v26 + 1) = v18;
    LOWORD(v27) = a3;
    if (v18)
    {
      memmove(v18, a2, a3);
      v21[2] = *(_OWORD *)ptr;
      v21[3] = v26;
      v22 = v27;
      v21[0] = v23;
      v21[1] = v24;
      sub_100212068(v21);
      return 4540;
    }
    goto LABEL_27;
  }
  if (v13)
  {
    LOBYTE(v21[0]) = 1;
    BYTE1(v21[0]) = v28[0];
    WORD1(v21[0]) = v11;
    BYTE4(v21[0]) = v13;
LABEL_28:
    v19 = sub_10020EBA4(a1, (char *)v21, 5uLL, 0);
    sub_100053298(ptr[1]);
    if ((_DWORD)v19)
    {
      if ((_DWORD)v19 != 412)
      {
        if (sub_10005549C())
        {
          sub_100054530("ATT Send status %!", v19);
          v20 = sub_1000544A0(0x44u);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
            sub_1006CEEC0();
        }
      }
    }
    goto LABEL_33;
  }
  v15 = ptr[1];
  if (sub_10020EBA4(a1, (char *)ptr[1], WORD1(v26), 0))
  {
LABEL_27:
    LOBYTE(v21[0]) = 1;
    BYTE1(v21[0]) = v28[0];
    WORD1(v21[0]) = v11;
    BYTE4(v21[0]) = 17;
    goto LABEL_28;
  }
  sub_100053298(v15);
LABEL_33:
  if (v14)
    return (v14 + 4300);
  else
    return 0;
}

uint64_t sub_100210668(__int128 *a1, unsigned __int8 *a2, unsigned int a3, char a4)
{
  int v7;
  uint64_t i;
  unsigned int v9;
  unsigned int v10;
  int v11;
  int v12;
  uint64_t (*v13)(_BYTE *);
  _BYTE *v14;
  char v15;
  int v16;
  void *v17;
  uint64_t result;
  const char *v19;
  NSObject *v20;
  char v21;
  char v22;
  const char *v23;
  NSObject *v24;
  NSObject *v25;
  int v26;
  uint64_t v27;
  NSObject *v28;
  NSObject *v29;
  __int128 v31;
  __int128 v32;
  void *ptr[2];
  __int128 v34;
  uint64_t v35;
  _BYTE v36[32];
  __int128 v37;
  __int128 v38;
  uint64_t v39;
  int v40;
  __int16 v41;
  _BYTE v42[14];
  _QWORD v43[2];

  v7 = *a2;
  v35 = 0;
  *(_OWORD *)ptr = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  LODWORD(v31) = dword_10098AA78;
  for (i = *((_QWORD *)&xmmword_10098A9E0 + 1); i; i = *(_QWORD *)(i + 24))
  {
    if (*(__int128 **)i == a1)
      break;
  }
  *((_QWORD *)&v32 + 1) = i;
  if (a3 != 7 && a3 != 21)
  {
    if (sub_10005549C())
    {
      v19 = "Type";
      if (v7 == 16)
        v19 = "Group Type";
      sub_100054530("Could not unpack Read By %s Request", v19);
      v20 = sub_1000544A0(0x44u);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    v21 = *a2;
    v36[0] = 1;
    v36[1] = v21;
    *(_WORD *)&v36[2] = 0;
    v22 = 4;
    goto LABEL_40;
  }
  v9 = *(unsigned __int16 *)(a2 + 1);
  v10 = *(unsigned __int16 *)(a2 + 3);
  sub_10005F660((int8x16_t *)(a2 + 5), (a3 - 5), 1, (uint64_t)v36);
  v11 = *(_DWORD *)v36;
  v12 = *(unsigned __int16 *)&v36[4];
  v43[0] = *(_QWORD *)&v36[6];
  *(_QWORD *)((char *)v43 + 6) = *(_QWORD *)&v36[12];
  if (v10 <= (unsigned __int16)(v9 - 1))
  {
    if (sub_10005549C())
    {
      v23 = "Type";
      if (v7 == 16)
        v23 = "Group Type";
      sub_100054530("Invalid handle(s) (0x%04x, 0x%04x) for Read By %s Request", v9, v10, v23);
      v24 = sub_1000544A0(0x44u);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    v22 = 1;
    v36[0] = 1;
    v36[1] = v7;
    *(_WORD *)&v36[2] = v9;
    goto LABEL_40;
  }
  if (v7 == 16)
  {
    v13 = (uint64_t (*)(_BYTE *))xmmword_10098AA40;
    if (!(_QWORD)xmmword_10098AA40)
    {
      sub_100253460();
      v13 = (uint64_t (*)(_BYTE *))xmmword_10098AA40;
    }
    *(_DWORD *)v36 = v11;
    *(_WORD *)&v36[4] = v12;
    *(_QWORD *)&v36[6] = v43[0];
    *(_QWORD *)&v36[12] = *(_QWORD *)((char *)v43 + 6);
    if ((v13(v36) & 1) == 0)
    {
      if (sub_10005549C())
      {
        sub_100054530("Invalid grouping type 0x%x for Read By Group Type Request", v12);
        v25 = sub_1000544A0(0x44u);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      *(_WORD *)v36 = 4097;
      *(_WORD *)&v36[2] = v9;
      v22 = 16;
      goto LABEL_40;
    }
  }
  if (!i)
  {
    if (sub_10005549C())
    {
      sub_100054530("Couldn't find active session for lmHandle 0x%x, Read By Type Request failed", *(unsigned __int16 *)a1);
      v29 = sub_1000544A0(0x44u);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  LOWORD(ptr[0]) = v9;
  v14 = sub_100114588(*(unsigned __int16 *)(i + 8));
  ptr[1] = v14;
  if (!v14)
  {
    v36[0] = 1;
    v36[1] = v7;
    *(_WORD *)&v36[2] = v9;
    v22 = 17;
LABEL_40:
    v36[4] = v22;
    return sub_10020EBA4(a1, v36, 5uLL, 0);
  }
  LOWORD(v34) = *(_WORD *)(i + 8);
  if (v7 == 16)
    v15 = 17;
  else
    v15 = 9;
  WORD1(v34) = 1;
  *v14 = v15;
  v40 = v11;
  v41 = v12;
  *(_QWORD *)v42 = v43[0];
  *(_QWORD *)&v42[6] = *(_QWORD *)((char *)v43 + 6);
  v16 = sub_100212244(v7, v9, v10, (unsigned __int8 *)&v40, 0, (unsigned int *)&v31, a4);
  if (v16 == 240)
  {
    *((_QWORD *)&v31 + 1) = sub_10021245C;
    v17 = sub_100052DC0(a3);
    *((_QWORD *)&v34 + 1) = v17;
    LOWORD(v35) = a3;
    if (v17)
    {
      memmove(v17, a2, a3);
      v37 = *(_OWORD *)ptr;
      v38 = v34;
      v39 = v35;
      *(_OWORD *)v36 = v31;
      *(_OWORD *)&v36[16] = v32;
      sub_100212068(v36);
      return 4540;
    }
    v36[0] = 1;
    v36[1] = v7;
    *(_WORD *)&v36[2] = ptr[0];
    v36[4] = 17;
    v27 = sub_10020EBA4(a1, v36, 5uLL, 0);
    sub_100053298(ptr[1]);
    result = 4540;
    if ((_DWORD)v27 && (_DWORD)v27 != 412)
    {
      if (sub_10005549C())
      {
        sub_100054530("ATT Send status %!", v27);
        v28 = sub_1000544A0(0x44u);
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
          sub_1006CEEC0();
      }
      return 4540;
    }
  }
  else
  {
    v26 = sub_100212714(*a2, (uint64_t)&v31, v16);
    sub_100053298(ptr[1]);
    if (v26)
      return (v26 + 4300);
    else
      return 0;
  }
  return result;
}

uint64_t sub_100210B10(__int128 *a1, unsigned __int8 *a2, unsigned int a3, char a4)
{
  int v8;
  uint64_t i;
  int v10;
  uint64_t v11;
  NSObject *v12;
  char v13;
  const char *v14;
  NSObject *v15;
  unsigned __int8 v16;
  uint64_t result;
  _BYTE *v18;
  char v19;
  int v20;
  void *v21;
  int v22;
  uint64_t v23;
  NSObject *v24;
  _OWORD v25[4];
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  void *ptr[2];
  __int128 v30;
  uint64_t v31;
  _DWORD v32[2];

  v8 = *a2;
  memset(v32, 0, 5);
  v31 = 0;
  *(_OWORD *)ptr = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  LODWORD(v27) = dword_10098AA78;
  for (i = *((_QWORD *)&xmmword_10098A9E0 + 1); i; i = *(_QWORD *)(i + 24))
  {
    if (*(__int128 **)i == a1)
      break;
  }
  *((_QWORD *)&v28 + 1) = i;
  if (v8 == 12)
    v10 = 5;
  else
    v10 = 3;
  if (v10 != a3)
  {
    if (sub_10005549C())
    {
      v14 = "Read";
      if (v8 == 12)
        v14 = "Read Blob";
      sub_100054530("Could not unpack %s Request", v14);
      v15 = sub_1000544A0(0x44u);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    v16 = *a2;
    LOBYTE(v25[0]) = 1;
    BYTE1(v25[0]) = v16;
    WORD1(v25[0]) = 0;
    v13 = 4;
    goto LABEL_23;
  }
  if (v8 == 12)
    v11 = 5;
  else
    v11 = 3;
  __memmove_chk(v32, a2, v11, 5);
  if (v8 == 12 && *(unsigned __int16 *)((char *)v32 + 3) >= 0x201u)
  {
    if (sub_10005549C())
    {
      sub_100054530("Invalid offset (%u) for Read By Group Type Request", *(unsigned __int16 *)((char *)v32 + 3));
      v12 = sub_1000544A0(0x44u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    LOBYTE(v25[0]) = 1;
    BYTE1(v25[0]) = v32[0];
    WORD1(v25[0]) = *(_WORD *)((char *)v32 + 1);
    v13 = 7;
    goto LABEL_23;
  }
  v18 = sub_100114588(*(unsigned __int16 *)(i + 8));
  ptr[1] = v18;
  if (!v18)
  {
    LOBYTE(v25[0]) = 1;
    BYTE1(v25[0]) = v32[0];
    WORD1(v25[0]) = *(_WORD *)((char *)v32 + 1);
    v13 = 17;
LABEL_23:
    BYTE4(v25[0]) = v13;
    return sub_10020EBA4(a1, (char *)v25, 5uLL, 0);
  }
  LOWORD(v30) = *(_WORD *)(i + 8);
  if (v8 == 12)
    v19 = 13;
  else
    v19 = 11;
  WORD1(v30) = 1;
  *v18 = v19;
  v20 = sub_100212244(LOBYTE(v32[0]), *(unsigned __int16 *)((char *)v32 + 1), *(unsigned __int16 *)((char *)v32 + 1), 0, *(unsigned __int16 *)((char *)v32 + 3), (unsigned int *)&v27, a4);
  if (v20 == 240)
  {
    *((_QWORD *)&v27 + 1) = sub_10021245C;
    v21 = sub_100052DC0(a3);
    *((_QWORD *)&v30 + 1) = v21;
    LOWORD(v31) = a3;
    if (v21)
    {
      memmove(v21, a2, a3);
      v25[2] = *(_OWORD *)ptr;
      v25[3] = v30;
      v26 = v31;
      v25[0] = v27;
      v25[1] = v28;
      sub_100212068(v25);
      return 4540;
    }
    LOBYTE(v25[0]) = 1;
    BYTE1(v25[0]) = v32[0];
    WORD1(v25[0]) = *(_WORD *)((char *)v32 + 1);
    BYTE4(v25[0]) = 17;
    v23 = sub_10020EBA4(a1, (char *)v25, 5uLL, 0);
    sub_100053298(ptr[1]);
    result = 4540;
    if ((_DWORD)v23 && (_DWORD)v23 != 412)
    {
      if (sub_10005549C())
      {
        sub_100054530("ATT Send status %!", v23);
        v24 = sub_1000544A0(0x44u);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          sub_1006CEEC0();
      }
      return 4540;
    }
  }
  else
  {
    v22 = sub_100212714(*a2, (uint64_t)&v27, v20);
    sub_100053298(ptr[1]);
    if (v22)
      return (v22 + 4300);
    else
      return 0;
  }
  return result;
}

uint64_t sub_100210E80(__int128 *a1, unsigned __int8 *a2, unsigned int a3, char a4)
{
  uint64_t i;
  unsigned int v7;
  unsigned int v8;
  unsigned __int8 *v9;
  unsigned int v10;
  uint64_t v11;
  int v12;
  _BYTE *v13;
  uint64_t v14;
  int v15;
  NSObject *v16;
  char v17;
  uint64_t result;
  NSObject *v19;
  char v20;
  NSObject *v21;
  void *v22;
  void *v23;
  int v24;
  uint64_t v25;
  NSObject *v26;
  unsigned int v27;
  int v30;
  _OWORD v31[4];
  uint64_t v32;
  __int128 v33;
  __int128 v34;
  void *ptr[2];
  __int128 v36;
  uint64_t v37;

  v37 = 0;
  *(_OWORD *)ptr = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  LODWORD(v33) = dword_10098AA78;
  for (i = *((_QWORD *)&xmmword_10098A9E0 + 1); i; i = *(_QWORD *)(i + 24))
  {
    if (*(__int128 **)i == a1)
      break;
  }
  *((_QWORD *)&v34 + 1) = i;
  if (a3 < 5 || (v7 = a3 - 1, ((a3 - 1) & 1) != 0))
  {
    if (sub_10005549C())
    {
      sub_100054530("Could not unpack Read Multiple Request");
      v16 = sub_1000544A0(0x44u);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    LODWORD(v31[0]) = 3585;
    v17 = 4;
LABEL_20:
    BYTE4(v31[0]) = v17;
    return sub_10020EBA4(a1, (char *)v31, 5uLL, 0);
  }
  else
  {
    v8 = 0;
    v9 = a2 + 1;
    v30 = *a2;
    v27 = v7 >> 1;
    v10 = (unsigned __int16)(v7 >> 1);
    do
    {
      v11 = *(unsigned __int16 *)&v9[2 * v8];
      if (v11 >= (unsigned __int16)word_10098AA00
        || *(_BYTE *)(*((_QWORD *)&xmmword_10098A9F0 + 1) + 16 * v11) != 2)
      {
        if (sub_10005549C())
        {
          sub_100054530("Handle 0x%04x is invalid!", v11);
          v19 = sub_1000544A0(0x44u);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
        v17 = 1;
        LOBYTE(v31[0]) = 1;
        BYTE1(v31[0]) = v30;
        WORD1(v31[0]) = v11;
        goto LABEL_20;
      }
      v12 = sub_100212808((uint64_t)a1, *(unsigned __int8 *)(*(_QWORD *)(*((_QWORD *)&xmmword_10098A9F0 + 1) + 16 * v11 + 8) + 26), 1);
      if (v12)
      {
        v20 = v12;
        if (sub_10005549C())
        {
          sub_100054530("Handle 0x%04x does not have read permissions!", v11);
          v21 = sub_1000544A0(0x44u);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
        LOBYTE(v31[0]) = 1;
        BYTE1(v31[0]) = v30;
        WORD1(v31[0]) = v11;
        BYTE4(v31[0]) = v20;
        return sub_10020EBA4(a1, (char *)v31, 5uLL, 0);
      }
      ++v8;
    }
    while (v8 < v10);
    v13 = sub_100114588(*(unsigned __int16 *)(i + 8));
    ptr[1] = v13;
    if (!v13)
    {
      LOBYTE(v31[0]) = 1;
      BYTE1(v31[0]) = v30;
      WORD1(v31[0]) = 0;
      v17 = 17;
      goto LABEL_20;
    }
    v14 = 0;
    LOWORD(v36) = *(_WORD *)(i + 8);
    WORD1(v36) = 1;
    *v13 = 15;
    while (1)
    {
      LOWORD(ptr[0]) = *(_WORD *)&a2[v14 + 1];
      v15 = sub_100212244(v30, LOWORD(ptr[0]), LOWORD(ptr[0]), 0, 0, (unsigned int *)&v33, a4);
      if (v15)
        break;
      v14 += 2;
      if (2 * v27 == v14)
        goto LABEL_35;
    }
    if (v15 == 240)
    {
      *((_QWORD *)&v33 + 1) = sub_10021245C;
      v22 = sub_100052DC0(a3);
      *((_QWORD *)&v36 + 1) = v22;
      LOWORD(v37) = a3;
      if (v22)
      {
        memmove(v22, a2, a3);
        v31[2] = *(_OWORD *)ptr;
        v31[3] = v36;
        v32 = v37;
        v31[0] = v33;
        v31[1] = v34;
        sub_100212068(v31);
        return 4540;
      }
      LOBYTE(v31[0]) = 1;
      BYTE1(v31[0]) = v30;
      WORD1(v31[0]) = ptr[0];
      BYTE4(v31[0]) = 17;
      v25 = sub_10020EBA4(a1, (char *)v31, 5uLL, 0);
      sub_100053298(ptr[1]);
      result = 4540;
      if ((_DWORD)v25 && (_DWORD)v25 != 412)
      {
        if (sub_10005549C())
        {
          sub_100054530("ATT Send status %!", v25);
          v26 = sub_1000544A0(0x44u);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
            sub_1006CEEC0();
        }
        return 4540;
      }
    }
    else
    {
LABEL_35:
      v23 = ptr[1];
      v24 = sub_100212714(*a2, (uint64_t)&v33, v15);
      sub_100053298(v23);
      if (v24)
        return (v24 + 4300);
      else
        return 0;
    }
  }
  return result;
}

uint64_t sub_100211270(__int128 *a1, unsigned __int8 *a2, unsigned int a3)
{
  int v6;
  uint64_t i;
  unsigned int v8;
  const char *v9;
  const char *v10;
  _BOOL4 v11;
  _BOOL4 v13;
  uint64_t v14;
  __int16 v15;
  unsigned int v16;
  unsigned __int16 v17;
  NSObject *v18;
  char v19;
  NSObject *v20;
  NSObject *v22;
  char *v23;
  char *v24;
  __int16 v25;
  char v26;
  size_t v27;
  char *v28;
  NSObject *v29;
  int v30;
  __int16 v31;
  uint64_t v32;
  uint64_t v33;
  BOOL v34;
  BOOL v35;
  BOOL v36;
  uint64_t v37;
  int v38;
  uint64_t (*v39)(uint64_t);
  char *v40;
  unsigned __int8 v41;
  uint64_t v42;
  __int16 v43;
  __int16 v44;
  void *v45;
  void *v46;
  NSObject *v47;
  unsigned __int8 *v48;
  __int16 v49;
  __int16 v50;
  unsigned int v51;
  __int16 v52;
  char *ptr;
  char *ptra;
  uint64_t v55;
  _QWORD v56[4];
  __int16 v57;
  int v58;
  __int16 v59;
  char *v60;
  __int16 v61;
  __int16 v62;
  int v63;
  void *v64;
  __int16 v65;
  int v66;
  __int16 v67;

  v6 = *a2;
  for (i = *((_QWORD *)&xmmword_10098A9E0 + 1); i; i = *(_QWORD *)(i + 24))
  {
    if (*(__int128 **)i == a1)
      break;
  }
  v8 = dword_10098AA78;
  if (v6 == 82)
  {
    v11 = 0;
    v10 = "Write Command";
  }
  else
  {
    v9 = "Prepare Write Request";
    if (v6 == 18)
      v9 = "Write Request";
    if (v6 == 210)
      v10 = "Signed Write Command";
    else
      v10 = v9;
    v11 = v6 == 210;
    if (a3 <= 0xE && v6 == 210)
      goto LABEL_31;
  }
  v13 = a3 < 5 && v6 == 22;
  if (a3 < 3 || v13)
  {
LABEL_31:
    if (sub_10005549C())
    {
      sub_100054530("Could not unpack %s", v10);
      v20 = sub_1000544A0(0x44u);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    if ((v6 | 4) != 0x16)
      return 4021;
    LODWORD(v56[0]) = 1;
    v19 = 4;
LABEL_38:
    BYTE4(v56[0]) = v19;
    return sub_10020EBA4(a1, (char *)v56, 5uLL, 0);
  }
  v14 = *(unsigned __int16 *)(a2 + 1);
  if (v6 == 22)
  {
    v15 = 5;
    if (!v11)
      goto LABEL_24;
    goto LABEL_37;
  }
  v15 = 3;
  if (v11)
  {
LABEL_37:
    LOBYTE(v56[0]) = 1;
    BYTE1(v56[0]) = v6;
    WORD1(v56[0]) = v14;
    v19 = 6;
    goto LABEL_38;
  }
LABEL_24:
  if (!*(_WORD *)(a2 + 1))
  {
    if (sub_10005549C())
    {
      sub_100054530("Invalid handle (0x%04x) for %s", 0, v10);
      v22 = sub_1000544A0(0x44u);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    if ((v6 | 4) == 0x16)
    {
      v19 = 1;
      LOBYTE(v56[0]) = 1;
      BYTE1(v56[0]) = v6;
      WORD1(v56[0]) = 0;
      goto LABEL_38;
    }
    return 4021;
  }
  v55 = *(unsigned __int16 *)(a2 + 1);
  if (v6 == 22)
  {
    v16 = *(unsigned __int16 *)(i + 8);
    v17 = a3 - v15;
    if ((int)(v16 - 5) < (unsigned __int16)(a3 - v15))
    {
      if (sub_10005549C())
      {
        sub_100054530("Prepare Write sent with ValueLength=%d which is larger than allowed (ATT_MTU-5=%d)", v17, *(unsigned __int16 *)(i + 8) - 5);
        v18 = sub_1000544A0(0x44u);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      LOWORD(v56[0]) = 5633;
      WORD1(v56[0]) = v55;
      v19 = 13;
      goto LABEL_38;
    }
  }
  else
  {
    if (v6 != 18)
    {
      v27 = 0;
      v25 = 0;
      v24 = 0;
      v31 = 0;
      goto LABEL_60;
    }
    v16 = *(unsigned __int16 *)(i + 8);
  }
  v23 = (char *)sub_100114588(v16);
  if (!v23)
  {
    LOBYTE(v56[0]) = 1;
    BYTE1(v56[0]) = v6;
    WORD1(v56[0]) = v55;
    v19 = 17;
    goto LABEL_38;
  }
  v24 = v23;
  v25 = *(_WORD *)(i + 8);
  if (*a2 == 18)
    v26 = 19;
  else
    v26 = 23;
  *v23 = v26;
  v8 = dword_10098AA78;
  v27 = 1;
  v14 = v55;
  if (v6 == 22 && !(_QWORD)xmmword_10098AA60)
  {
    v28 = v23;
    if (sub_10005549C())
    {
      sub_100054530("No callback provided to handle Prepare Writes!");
      v29 = sub_1000544A0(0x44u);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    v30 = 6;
    LOWORD(v14) = v55;
LABEL_81:
    LOBYTE(v56[0]) = 1;
    BYTE1(v56[0]) = v6;
    WORD1(v56[0]) = v14;
    BYTE4(v56[0]) = v30;
    v42 = sub_10020EBA4(a1, (char *)v56, 5uLL, 0);
    v24 = v28;
    goto LABEL_85;
  }
  v31 = v55;
LABEL_60:
  if (v14 < (unsigned __int16)word_10098AA00
    && *(_BYTE *)(*((_QWORD *)&xmmword_10098A9F0 + 1) + 16 * v14) == 2
    && (v32 = *(_QWORD *)(*((_QWORD *)&xmmword_10098A9F0 + 1) + 16 * v14 + 8)) != 0)
  {
    v49 = v31;
    v50 = v25;
    v51 = v27;
    ptr = v24;
    if (*((_QWORD *)&xmmword_10098AA60 + 1))
    {
      v48 = (unsigned __int8 *)(v32 + 4);
      v33 = *(_QWORD *)(*((_QWORD *)&xmmword_10098A9F0 + 1) + 16 * v14 + 8);
      v34 = sub_100072DF0((unsigned __int8 *)(v32 + 4), (unsigned __int8 *)&xmmword_10073B24C);
      v32 = v33;
      if (!v34)
      {
        v35 = sub_100072DF0(v48, (unsigned __int8 *)&xmmword_10073B260);
        v32 = v33;
        if (!v35)
        {
          v36 = sub_100072DF0(v48, (unsigned __int8 *)&xmmword_10073B274);
          v32 = v33;
          if (!v36)
          {
            (*((void (**)(uint64_t, uint64_t))&xmmword_10098AA60 + 1))(v33, i);
            v32 = v33;
          }
        }
      }
    }
    v37 = v32;
    v38 = sub_100212808(*(_QWORD *)i, *(unsigned __int8 *)(v32 + 26), 0);
    LOWORD(v14) = v55;
    v24 = ptr;
    v25 = v50;
    v27 = v51;
    v31 = v49;
    if (!v38)
    {
      v39 = *(uint64_t (**)(uint64_t))(v37 + 40);
      if (v39)
      {
        v38 = v39(v37);
        v31 = v49;
        v25 = v50;
        v27 = v51;
        v24 = ptr;
        LOWORD(v14) = v55;
      }
      else
      {
        v38 = 3;
      }
    }
  }
  else
  {
    v38 = 1;
  }
  if ((v6 | 4) == 0x16)
  {
    if (v38 != 240)
    {
      v30 = v38;
      if (!v38)
      {
        v40 = v24;
        v30 = sub_10020EBA4(a1, v24, v27, 0);
        if (v30)
        {
          LOBYTE(v56[0]) = 1;
          BYTE1(v56[0]) = v6;
          WORD1(v56[0]) = v55;
          BYTE4(v56[0]) = 17;
          v41 = sub_10020EBA4(a1, (char *)v56, 5uLL, 0);
          v42 = 0;
          v30 = v41;
        }
        else
        {
          v42 = 0;
        }
        v24 = v40;
        goto LABEL_85;
      }
      v28 = v24;
      goto LABEL_81;
    }
    v43 = v31;
    v52 = v27;
    v44 = v25;
    ptra = v24;
    v45 = sub_100052DC0(a3);
    if (v45)
    {
      v46 = v45;
      memmove(v45, a2, a3);
      v56[0] = v8;
      v56[1] = sub_100212B24;
      v56[2] = 0;
      v56[3] = i;
      v57 = v43;
      v58 = 0;
      v59 = 0;
      v60 = ptra;
      v61 = v44;
      v62 = v52;
      v63 = 0;
      v64 = v46;
      v65 = a3;
      v66 = 0;
      v67 = 0;
      sub_100212068(v56);
      return 4540;
    }
    LOBYTE(v56[0]) = 1;
    BYTE1(v56[0]) = v6;
    WORD1(v56[0]) = v55;
    BYTE4(v56[0]) = 17;
    v42 = sub_10020EBA4(a1, (char *)v56, 5uLL, 0);
    v30 = 240;
    v24 = ptra;
  }
  else
  {
    v42 = 0;
    v30 = v38;
  }
LABEL_85:
  if (v24)
    sub_100053298(v24);
  if ((_DWORD)v42)
  {
    if ((_DWORD)v42 != 412)
    {
      if (sub_10005549C())
      {
        sub_100054530("ATT Send status %!", v42);
        v47 = sub_1000544A0(0x44u);
        if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
          sub_1006CEEC0();
      }
    }
  }
  if (v30)
    return (v30 + 4300);
  else
    return 0;
}

uint64_t sub_10021192C(__int128 *a1, char *a2, int a3)
{
  __int128 **v5;
  _QWORD *v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  unsigned __int8 v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t result;
  NSObject *v14;
  char v15;
  uint64_t v16;
  NSObject *v17;
  NSObject *v18;
  const void *v19[2];
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;

  v24 = 0;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  LODWORD(v20) = dword_10098AA78;
  v5 = (__int128 **)*((_QWORD *)&xmmword_10098A9E0 + 1);
  if (*((_QWORD *)&xmmword_10098A9E0 + 1))
  {
    do
    {
      if (*v5 == a1)
        break;
      v5 = (__int128 **)v5[3];
    }
    while (v5);
  }
  *((_QWORD *)&v21 + 1) = v5;
  if (a3 != 2)
  {
    LODWORD(v19[0]) = 6145;
    BYTE4(v19[0]) = 4;
    return sub_10020EBA4(a1, (char *)v19, 5uLL, 0);
  }
  if (xmmword_10098AA60)
  {
    xmmword_10098AA60();
    v19[0] = 0;
    if (*((_QWORD *)&xmmword_10098AA10 + 1))
      sub_100253460();
    v6 = sub_100052DC0(0x48uLL);
    *((_QWORD *)&xmmword_10098AA10 + 1) = v6;
    if (!v6)
    {
      if (sub_10005549C())
      {
        sub_100054530("Failed to backup Execute Write Request");
        v18 = sub_1000544A0(0x44u);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return 17;
    }
    *(_OWORD *)v6 = v20;
    v7 = v21;
    v8 = v22;
    v9 = v23;
    v6[8] = v24;
    *((_OWORD *)v6 + 2) = v8;
    *((_OWORD *)v6 + 3) = v9;
    *((_OWORD *)v6 + 1) = v7;
    v19[1] = &v20;
    LOWORD(v19[0]) = 4;
    v10 = sub_10004A9EC((uint64_t)sub_100212D04, v19, 100, (int *)(*((_QWORD *)&xmmword_10098AA10 + 1) + 16));
    v11 = v10;
    if (v10)
    {
      if (sub_10005549C())
      {
        sub_100054530("Failed to create dispatch timer for execute write with result %!", v11);
        v12 = sub_1000544A0(0x44u);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      sub_100053298(*((void **)&xmmword_10098AA10 + 1));
      *((_QWORD *)&xmmword_10098AA10 + 1) = 0;
      return 17;
    }
    result = 0;
    ++dword_10098AA78;
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("No callback provided to handle Execute Writes");
      v14 = sub_1000544A0(0x44u);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    v15 = *a2;
    LOBYTE(v19[0]) = 1;
    BYTE1(v19[0]) = v15;
    WORD1(v19[0]) = 0;
    BYTE4(v19[0]) = 6;
    v16 = sub_10020EBA4(a1, (char *)v19, 5uLL, 0);
    result = 4306;
    if ((_DWORD)v16 && (_DWORD)v16 != 412)
    {
      if (sub_10005549C())
      {
        sub_100054530("ATT Send status %!", v16);
        v17 = sub_1000544A0(0x44u);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          sub_1006CEEC0();
      }
      return 4306;
    }
  }
  return result;
}

uint64_t sub_100211BE8(uint64_t a1, unsigned int *a2, char a3)
{
  unint64_t v4;
  BOOL v6;
  uint64_t v8;
  char *v9;
  void *v10;
  void *v11;
  uint64_t v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v26;
  int v28;
  unsigned __int16 __n;
  _QWORD __n_2[2];
  int v31;

  __n_2[1] = 0;
  v31 = 0;
  __n_2[0] = 2;
  WORD2(__n_2[0]) = *(_WORD *)(a1 + 5);
  v4 = *(unsigned __int16 *)(a1 + 1);
  if (*(_WORD *)(a1 + 1))
  {
    v6 = v4 > *(unsigned __int16 *)(a1 + 3) || v4 >= (unsigned __int16)word_10098AA00;
    if (!v6)
    {
      v8 = 16 * v4;
      do
      {
        if (*(_BYTE *)(*((_QWORD *)&xmmword_10098A9F0 + 1) + v8) == 2)
        {
          if (*((unsigned __int16 *)a2 + 24) - *((unsigned __int16 *)a2 + 25) < 4)
            return 0;
          v9 = *(char **)(*((_QWORD *)&xmmword_10098A9F0 + 1) + v8 + 8);
          if (sub_100072DF0((unsigned __int8 *)v9 + 4, (unsigned __int8 *)__n_2))
          {
            *((_WORD *)a2 + 16) = v4;
            if (!*(_QWORD *)(a1 + 7))
              goto LABEL_17;
            v10 = sub_100052DC0(0x200uLL);
            __n = 0;
            if (!v10)
              return 17;
            v11 = v10;
            LOBYTE(v28) = a3;
            v12 = (*((uint64_t (**)(char *, _QWORD, void *, uint64_t, unsigned __int16 *, _QWORD, _QWORD, void (*)(int, int, void *, size_t), int))v9
                   + 4))(v9, 0, v10, 512, &__n, *a2, *((_QWORD *)a2 + 3), sub_100211E14, v28);
            if ((_DWORD)v12)
            {
              v26 = v12;
              sub_100053298(v11);
              return v26;
            }
            if (__n == *(unsigned __int16 *)(a1 + 15) && !memcmp(v11, *(const void **)(a1 + 7), __n))
            {
              sub_100053298(v11);
LABEL_17:
              v13 = *v9;
              v14 = *((_QWORD *)a2 + 5);
              v15 = *((unsigned __int16 *)a2 + 25);
              *((_WORD *)a2 + 25) = v15 + 1;
              *(_BYTE *)(v14 + v15) = v13;
              v16 = v9[1];
              v17 = *((_QWORD *)a2 + 5);
              v18 = *((unsigned __int16 *)a2 + 25);
              *((_WORD *)a2 + 25) = v18 + 1;
              *(_BYTE *)(v17 + v18) = v16;
              v19 = v9[24];
              v20 = *((_QWORD *)a2 + 5);
              v21 = *((unsigned __int16 *)a2 + 25);
              *((_WORD *)a2 + 25) = v21 + 1;
              *(_BYTE *)(v20 + v21) = v19;
              v22 = v9[25];
              v23 = *((_QWORD *)a2 + 5);
              v24 = *((unsigned __int16 *)a2 + 25);
              *((_WORD *)a2 + 25) = v24 + 1;
              *(_BYTE *)(v23 + v24) = v22;
              goto LABEL_18;
            }
            sub_100053298(v11);
          }
        }
LABEL_18:
        v6 = v4++ >= *(unsigned __int16 *)(a1 + 3);
        v8 += 16;
      }
      while (!v6 && v4 < (unsigned __int16)word_10098AA00);
    }
  }
  if (*((_WORD *)a2 + 25) == 1)
    return 10;
  else
    return 0;
}

void sub_100211E14(int a1, int a2, void *__s1, size_t __n)
{
  uint64_t v4;
  unsigned int v5;
  uint64_t i;
  _DWORD *v9;
  unsigned int v10;
  NSObject *v11;
  __int128 *v12;
  char *v13;
  char v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  __int16 v25;
  int v26;
  __int128 *v27;
  _BYTE v28[7];
  char *v29;
  __int16 v30;
  char v31;
  char v32;
  __int16 v33;
  char v34;

  v4 = (unsigned __int16)xmmword_10098AA10;
  if ((_WORD)xmmword_10098AA10)
  {
    v5 = __n;
    for (i = qword_10098AA08; *(_DWORD *)i != a1; i += 72)
    {
      if (!--v4)
        return;
    }
    v9 = *(_DWORD **)(i + 56);
    if (!v9 || (v10 = *(unsigned __int16 *)(i + 64), v10 <= 7))
    {
      sub_100253460();
      v9 = *(_DWORD **)(i + 56);
      LOWORD(v10) = *(_WORD *)(i + 64);
    }
    *(_DWORD *)v28 = *v9;
    *(_DWORD *)&v28[3] = *(_DWORD *)((char *)v9 + 3);
    v29 = (char *)v9 + 7;
    v30 = v10 - 7;
    if (a2)
    {
      if (sub_10005549C())
      {
        sub_100054530("Failed to read value at attribute handle 0x%04x with result %d", *(unsigned __int16 *)(i + 32), a2);
        v11 = sub_1000544A0(0x44u);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      v12 = **(__int128 ***)(i + 24);
      v31 = 1;
      v32 = v28[0];
      v33 = *(_WORD *)&v28[1];
      v34 = a2;
      goto LABEL_14;
    }
    if (v5 == (unsigned __int16)(v10 - 7) && !memcmp(__s1, (char *)v9 + 7, v5))
    {
      v13 = *(char **)(*((_QWORD *)&xmmword_10098A9F0 + 1) + 16 * *(unsigned __int16 *)(i + 32) + 8);
      v14 = *v13;
      v15 = *(_QWORD *)(i + 40);
      v16 = *(unsigned __int16 *)(i + 50);
      *(_WORD *)(i + 50) = v16 + 1;
      *(_BYTE *)(v15 + v16) = v14;
      v17 = v13[1];
      v18 = *(_QWORD *)(i + 40);
      v19 = *(unsigned __int16 *)(i + 50);
      *(_WORD *)(i + 50) = v19 + 1;
      *(_BYTE *)(v18 + v19) = v17;
      v20 = v13[24];
      v21 = *(_QWORD *)(i + 40);
      v22 = *(unsigned __int16 *)(i + 50);
      *(_WORD *)(i + 50) = v22 + 1;
      *(_BYTE *)(v21 + v22) = v20;
      LOBYTE(v13) = v13[25];
      v23 = *(_QWORD *)(i + 40);
      v24 = *(unsigned __int16 *)(i + 50);
      *(_WORD *)(i + 50) = v24 + 1;
      *(_BYTE *)(v23 + v24) = (_BYTE)v13;
    }
    v25 = *(_WORD *)(i + 32) + 1;
    *(_WORD *)&v28[1] = v25;
    v26 = sub_100211BE8(v28, i, 0);
    if (v26 != 240)
    {
      if (v26)
      {
        v27 = **(__int128 ***)(i + 24);
        v31 = 1;
        v32 = v28[0];
        v33 = v25;
        v34 = v26;
        v12 = v27;
      }
      else
      {
        if (!sub_10020EBA4(**(__int128 ***)(i + 24), *(char **)(i + 40), *(unsigned __int16 *)(i + 50), 0))goto LABEL_15;
        v12 = **(__int128 ***)(i + 24);
        v31 = 1;
        v32 = v28[0];
        v33 = v25;
        v34 = 17;
      }
LABEL_14:
      sub_10020EBA4(v12, &v31, 5uLL, 0);
LABEL_15:
      sub_10020F348(i);
    }
  }
}

void sub_100212068(_QWORD *a1)
{
  char *v2;
  void *v3;
  char *v4;
  uint64_t v5;
  __int128 v6;
  __int128 v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  const void *v11[2];

  v2 = (char *)sub_100114588(72 * (unsigned __int16)xmmword_10098AA10 + 72);
  if (v2)
  {
    v3 = v2;
    v11[0] = 0;
    v4 = &v2[72 * (unsigned __int16)xmmword_10098AA10];
    *(_OWORD *)v4 = *(_OWORD *)a1;
    v5 = a1[8];
    v7 = *((_OWORD *)a1 + 2);
    v6 = *((_OWORD *)a1 + 3);
    *((_OWORD *)v4 + 1) = *((_OWORD *)a1 + 1);
    *((_OWORD *)v4 + 2) = v7;
    *((_OWORD *)v4 + 3) = v6;
    *((_QWORD *)v4 + 8) = v5;
    v11[1] = a1;
    LOWORD(v11[0]) = 4;
    v8 = sub_10004A9EC((uint64_t)sub_1002121B8, v11, 100, (int *)&v2[72 * (unsigned __int16)xmmword_10098AA10 + 16]);
    if ((_DWORD)v8)
    {
      v9 = v8;
      if (sub_10005549C())
      {
        sub_100054530("Failed to create dispatch timer for async response with result %!", v9);
        v10 = sub_1000544A0(0x44u);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      sub_100053298(v3);
    }
    else
    {
      if (qword_10098AA08)
      {
        memmove(v3, (const void *)qword_10098AA08, 72 * (unsigned __int16)xmmword_10098AA10);
        sub_100053298((void *)qword_10098AA08);
      }
      qword_10098AA08 = (uint64_t)v3;
      LOWORD(xmmword_10098AA10) = xmmword_10098AA10 + 1;
      ++dword_10098AA78;
    }
  }
}

uint64_t sub_1002121B8(uint64_t result)
{
  uint64_t v1;
  unsigned int *i;
  void (*v3)(uint64_t);

  v1 = (unsigned __int16)xmmword_10098AA10;
  if ((_WORD)xmmword_10098AA10)
  {
    result = **(unsigned int **)(result + 8);
    for (i = (unsigned int *)qword_10098AA08; *i != (_DWORD)result; i += 18)
    {
      if (!--v1)
        return result;
    }
    i[4] = 0;
    v3 = (void (*)(uint64_t))*((_QWORD *)&xmmword_10098AA40 + 1);
    if (!*((_QWORD *)&xmmword_10098AA40 + 1))
    {
      sub_100253460();
      v3 = (void (*)(uint64_t))*((_QWORD *)&xmmword_10098AA40 + 1);
      result = *i;
    }
    v3(result);
    return (*((uint64_t (**)(_QWORD, uint64_t, _QWORD, _QWORD))i + 1))(*i, 241, 0, 0);
  }
  return result;
}

uint64_t sub_100212244(int a1, unsigned int a2, unsigned int a3, unsigned __int8 *a4, unsigned int a5, unsigned int *a6, char a7)
{
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  void *v16;
  uint64_t v17;
  int v19;
  unsigned __int16 v23;

  if (a1 == 8
    || a1 == 16
    || (v9 = 1, a2)
    && (unsigned __int16)word_10098AA00 > a2
    && *(_BYTE *)(*((_QWORD *)&xmmword_10098A9F0 + 1) + 16 * a2) == 2)
  {
    v9 = 0;
    if (a2 - 1 < a3 && (unsigned __int16)word_10098AA00 > a2)
    {
      v10 = a2;
      v11 = 16 * a2;
      v12 = a3;
      while (1)
      {
        *((_WORD *)a6 + 16) = v10;
        if (*(_BYTE *)(*((_QWORD *)&xmmword_10098A9F0 + 1) + v11) == 2)
        {
          v13 = *(_QWORD *)(*((_QWORD *)&xmmword_10098A9F0 + 1) + v11 + 8);
          v23 = 0;
          if (!a4 || sub_100072DF0((unsigned __int8 *)(v13 + 4), a4))
          {
            if (*((_QWORD *)&xmmword_10098AA60 + 1)
              && !sub_100072DF0((unsigned __int8 *)(v13 + 4), (unsigned __int8 *)&xmmword_10073B24C)
              && !sub_100072DF0((unsigned __int8 *)(v13 + 4), (unsigned __int8 *)&xmmword_10073B260)
              && !sub_100072DF0((unsigned __int8 *)(v13 + 4), (unsigned __int8 *)&xmmword_10073B274))
            {
              (*((void (**)(uint64_t, _QWORD))&xmmword_10098AA60 + 1))(v13, *((_QWORD *)a6 + 3));
            }
            v14 = sub_100212808(**((_QWORD **)a6 + 3), *(unsigned __int8 *)(v13 + 26), 1);
            if ((_DWORD)v14)
              return v14;
            v15 = sub_100052DC0(0x200uLL);
            if (!v15)
              return 17;
            v16 = v15;
            LOBYTE(v19) = a7;
            v17 = (*(uint64_t (**)(uint64_t, _QWORD, void *, uint64_t, unsigned __int16 *, _QWORD, _QWORD, void (*)(int, int, void *, int), int))(v13 + 32))(v13, a5, v15, 512, &v23, *a6, *((_QWORD *)a6 + 3), sub_10021245C, v19);
            if ((_DWORD)v17 || (v17 = sub_100212978(a1, (char *)v13, v16, v23, (uint64_t)a6), (_DWORD)v17))
            {
              v9 = v17;
              sub_100053298(v16);
              return v9;
            }
            sub_100053298(v16);
          }
        }
        v9 = 0;
        if (v10 < v12)
        {
          ++v10;
          v11 += 16;
          if (v10 < (unsigned __int16)word_10098AA00)
            continue;
        }
        return v9;
      }
    }
  }
  return v9;
}

void sub_10021245C(int a1, int a2, void *a3, int a4)
{
  uint64_t v4;
  uint64_t i;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  int v16;
  int v17;
  unsigned int v18;
  uint64_t v19;
  int v20;
  unsigned __int16 v21;
  __int128 v22;
  int v23;
  __int128 v24;
  int v25;

  v4 = (unsigned __int16)xmmword_10098AA10;
  if (!(_WORD)xmmword_10098AA10)
    return;
  for (i = qword_10098AA08; *(_DWORD *)i != a1; i += 72)
  {
    if (!--v4)
      return;
  }
  v8 = **(unsigned __int8 **)(i + 56);
  v9 = *(unsigned __int16 *)(i + 32);
  if (v9 >= (unsigned __int16)word_10098AA00
    || (v10 = *(char **)(*((_QWORD *)&xmmword_10098A9F0 + 1) + 16 * v9 + 8)) == 0)
  {
    if (sub_10005549C())
    {
      sub_100054530("Attribute handle 0x%04x is no longer available for transaction ID %d", *(unsigned __int16 *)(i + 32), a1);
      v14 = sub_1000544A0(0x44u);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    a2 = 14;
    goto LABEL_21;
  }
  if (a2 || (a2 = sub_100212978(**(unsigned __int8 **)(i + 56), v10, a3, a4, i)) != 0)
  {
LABEL_21:
    sub_100212714(v8, i, a2);
    sub_10020F348(i);
    return;
  }
  a2 = 0;
  switch((int)v8)
  {
    case 8:
    case 16:
      v11 = *(_QWORD *)(i + 56);
      if (!v11 || (v12 = *(unsigned __int16 *)(i + 64), v12 <= 5))
      {
        sub_100253460();
        v11 = *(_QWORD *)(i + 56);
        LOBYTE(v12) = *(_BYTE *)(i + 64);
      }
      v24 = 0uLL;
      v25 = 0;
      v13 = *(unsigned __int16 *)(v11 + 3);
      sub_10005F660((int8x16_t *)(v11 + 5), (v12 - 5), 1, (uint64_t)&v24);
      v22 = v24;
      v23 = v25;
      a2 = sub_100212244(v8, (unsigned __int16)(*(_WORD *)(i + 32) + 1), v13, &v22, 0, i, 0);
      goto LABEL_15;
    case 10:
    case 12:
      goto LABEL_21;
    default:
      v15 = *(_QWORD *)(i + 56);
      if (!v15 || (v16 = *(unsigned __int16 *)(i + 64), v16 <= 1))
      {
        sub_100253460();
        v16 = *(unsigned __int16 *)(i + 64);
        v15 = *(_QWORD *)(i + 56);
      }
      v17 = v16 - 1;
      if (v16 < 1)
        v17 = v16;
      v18 = v17 >> 1;
      v19 = v15 + 1;
      if (v16 < 3)
      {
        LOWORD(v20) = 0;
        goto LABEL_34;
      }
      LOWORD(v20) = 0;
      break;
  }
  while (*(unsigned __int16 *)(v19 + 2 * (unsigned __int16)v20) != *(unsigned __int16 *)(i + 32))
  {
    LOWORD(v20) = v20 + 1;
    if ((unsigned __int16)v20 >= (unsigned __int16)v18)
    {
      v20 = v17 >> 1;
      break;
    }
  }
LABEL_34:
  v21 = v20 + 1;
  if (v18 <= (unsigned __int16)(v20 + 1))
  {
    a2 = 0;
    goto LABEL_21;
  }
  while (1)
  {
    *(_WORD *)(i + 32) = *(_WORD *)(v19 + 2 * v21);
    a2 = sub_100212244(v8, *(unsigned __int16 *)(v19 + 2 * v21), *(unsigned __int16 *)(v19 + 2 * v21), 0, 0, i, 0);
    if (a2)
      break;
    if (v18 <= ++v21)
      goto LABEL_21;
  }
LABEL_15:
  if (a2 != 240)
    goto LABEL_21;
}

uint64_t sub_100212714(int a1, uint64_t a2, int a3)
{
  char v4;
  uint64_t result;
  __int16 v8;
  __int128 *v9;
  char *v10;
  __int16 v11;
  _BYTE v12[2];
  __int16 v13;
  char v14;
  _BYTE v15[2];
  __int16 v16;
  char v17;

  v4 = a1;
  if ((a1 == 16 || a1 == 8) && a3 == 0)
  {
    if (*(_WORD *)(a2 + 50) != 1)
      goto LABEL_16;
    LOBYTE(a3) = 10;
  }
  else if (!a3 || a3 == 243)
  {
    goto LABEL_16;
  }
  if (a1 != 16 && a1 != 8 || *(unsigned __int16 *)(a2 + 50) < 2u)
  {
    v11 = *(_WORD *)(a2 + 32);
    v9 = **(__int128 ***)(a2 + 24);
    v15[0] = 1;
    v15[1] = v4;
    v16 = v11;
    v17 = a3;
    v10 = v15;
    goto LABEL_19;
  }
LABEL_16:
  LOBYTE(result) = sub_10020EBA4(**(__int128 ***)(a2 + 24), *(char **)(a2 + 40), *(unsigned __int16 *)(a2 + 50), 0);
  if ((_BYTE)result)
  {
    v8 = *(_WORD *)(a2 + 32);
    v9 = **(__int128 ***)(a2 + 24);
    v12[0] = 1;
    v12[1] = v4;
    v13 = v8;
    v14 = 17;
    v10 = v12;
LABEL_19:
    LOBYTE(result) = sub_10020EBA4(v9, v10, 5uLL, 0);
  }
  return result;
}

uint64_t sub_100212808(uint64_t a1, int a2, int a3)
{
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  NSObject *v10;
  char v11;

  v11 = 0;
  if ((a2 & 0x15) == 0 && (a3 & 1) != 0)
    return 2;
  if ((a2 & 0x2A) == 0 && !a3)
    return 3;
  if (a3)
    v5 = 20;
  else
    v5 = 40;
  if ((v5 & a2) == 0)
    return 0;
  v6 = a2 & 0x30;
  v7 = a2 & 0xC;
  if (!a1)
    goto LABEL_33;
  if (*(_BYTE *)(a1 + 2) == 4)
  {
    v8 = sub_10022DAE0(a1);
    v9 = sub_10022D980(a1);
    v11 = sub_10022DA04(a1);
    goto LABEL_20;
  }
  if (*(_BYTE *)(a1 + 2))
  {
LABEL_33:
    if (sub_10005549C())
    {
      sub_100054530("Invalid physical link at permission check");
      v10 = sub_1000544A0(0x44u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    v8 = 0;
    v9 = 0;
  }
  else
  {
    v8 = sub_10024B810(a1, &v11);
    v9 = sub_10024B768(a1);
  }
LABEL_20:
  if (v6 | v7 && !v8 && !v9)
    return 5;
  if ((v9 & 1) != 0)
  {
    if (v7 && !v11)
      return 5;
  }
  else if (v6 | v7)
  {
    return 15;
  }
  return 0;
}

uint64_t sub_100212978(int a1, char *a2, void *__src, int a4, uint64_t a5)
{
  unsigned __int16 v6;
  int v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  int v12;
  uint64_t v14;
  char v15;
  char v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  uint64_t v23;
  uint64_t v24;
  unsigned __int16 v25;

  v6 = 0;
  switch(a1)
  {
    case 8:
      v9 = *(unsigned __int16 *)(a5 + 48);
      if (v9 >= 0x101)
        v6 = 253;
      else
        v6 = v9 - 4;
      v7 = 2;
      goto LABEL_16;
    case 10:
    case 12:
    case 14:
      v6 = *(_WORD *)(a5 + 48) - 1;
      goto LABEL_3;
    case 16:
      v10 = *(unsigned __int16 *)(a5 + 48);
      if (v10 >= 0x101)
        v6 = 251;
      else
        v6 = v10 - 6;
      v7 = 4;
      goto LABEL_16;
    default:
LABEL_3:
      v7 = 0;
      if (a1 == 16 || a1 == 8)
      {
LABEL_16:
        if (a4 >= v6)
          v8 = v6;
        else
          v8 = a4;
        v11 = *(unsigned __int16 *)(a5 + 50);
        v12 = v7 + v8;
        if (*(unsigned __int16 *)(a5 + 48) - (int)v11 < v7 + v8)
          return -13;
        v14 = *(_QWORD *)(a5 + 40);
        if (v11 >= 2 && *(_BYTE *)(v14 + 1))
        {
          if (v12 != *(unsigned __int8 *)(v14 + 1))
            return 13;
        }
        else
        {
          *(_WORD *)(a5 + 50) = v11 + 1;
          *(_BYTE *)(v14 + v11) = v12;
          v14 = *(_QWORD *)(a5 + 40);
          LODWORD(v11) = *(unsigned __int16 *)(a5 + 50);
        }
        v15 = *a2;
        *(_WORD *)(a5 + 50) = v11 + 1;
        *(_BYTE *)(v14 + v11) = v15;
        v16 = a2[1];
        v17 = *(_QWORD *)(a5 + 40);
        v18 = *(unsigned __int16 *)(a5 + 50);
        *(_WORD *)(a5 + 50) = v18 + 1;
        *(_BYTE *)(v17 + v18) = v16;
        if (a1 == 16)
        {
          v19 = a2[24];
          v20 = *(_QWORD *)(a5 + 40);
          v21 = *(unsigned __int16 *)(a5 + 50);
          *(_WORD *)(a5 + 50) = v21 + 1;
          *(_BYTE *)(v20 + v21) = v19;
          v22 = a2[25];
          v23 = *(_QWORD *)(a5 + 40);
          v24 = *(unsigned __int16 *)(a5 + 50);
          *(_WORD *)(a5 + 50) = v24 + 1;
          *(_BYTE *)(v23 + v24) = v22;
        }
      }
      else if (*(unsigned __int16 *)(a5 + 48) - *(unsigned __int16 *)(a5 + 50) >= a4)
      {
        LOWORD(v8) = a4;
      }
      else
      {
        LOWORD(v8) = *(_WORD *)(a5 + 48) - *(_WORD *)(a5 + 50);
      }
      memmove((void *)(*(_QWORD *)(a5 + 40) + *(unsigned __int16 *)(a5 + 50)), __src, (unsigned __int16)v8);
      v25 = *(_WORD *)(a5 + 50) + v8;
      *(_WORD *)(a5 + 50) = v25;
      if (*(unsigned __int16 *)(a5 + 48) == v25)
        return -13;
      else
        return 0;
  }
}

void sub_100212B24(int a1, int a2)
{
  uint64_t v2;
  uint64_t i;
  unsigned __int8 *v5;
  int v6;
  size_t v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  __int16 v11;
  __int128 *v12;
  char *v13;
  __int16 v14;
  _BYTE v15[2];
  __int16 v16;
  char v17;
  _BYTE v18[2];
  __int16 v19;
  char v20;

  v2 = (unsigned __int16)xmmword_10098AA10;
  if ((_WORD)xmmword_10098AA10)
  {
    for (i = qword_10098AA08; *(_DWORD *)i != a1; i += 72)
    {
      if (!--v2)
        return;
    }
    v5 = *(unsigned __int8 **)(i + 56);
    v6 = *v5;
    if (v6 == 22)
    {
      v7 = *(unsigned __int16 *)(i + 64) - 1;
      v8 = *(unsigned __int16 *)(i + 50);
      if ((int)v7 > *(unsigned __int16 *)(i + 48) - (int)v8)
      {
        if (sub_10005549C())
        {
          sub_100054530("Write rejected: response->responseBuffer buffer space (%d) is too small for response->context (%d).", *(unsigned __int16 *)(*(_QWORD *)(i + 24) + 8) - *(unsigned __int16 *)(i + 50), *(unsigned __int16 *)(i + 64) - 1);
          v9 = sub_1000544A0(0x44u);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
        a2 = 245;
        goto LABEL_14;
      }
      memmove((void *)(*(_QWORD *)(i + 40) + v8), v5 + 1, v7);
      *(_WORD *)(i + 50) = *(_WORD *)(i + 64) + *(_WORD *)(i + 50) - 1;
    }
    if (!a2)
    {
      if (!sub_10020EBA4(**(__int128 ***)(i + 24), *(char **)(i + 40), *(unsigned __int16 *)(i + 50), 0))goto LABEL_19;
      v14 = *(_WORD *)(i + 32);
      v12 = **(__int128 ***)(i + 24);
      v15[0] = 1;
      v15[1] = v6;
      v16 = v14;
      v17 = 17;
      v13 = v15;
LABEL_18:
      sub_10020EBA4(v12, v13, 5uLL, 0);
LABEL_19:
      sub_10020F348(i);
      return;
    }
LABEL_14:
    if (sub_10005549C())
    {
      sub_100054530("Failed to write value to attribute handle 0x%04x with result %d", *(unsigned __int16 *)(i + 32), a2);
      v10 = sub_1000544A0(0x44u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    v11 = *(_WORD *)(i + 32);
    v12 = **(__int128 ***)(i + 24);
    v18[0] = 1;
    v18[1] = v6;
    v19 = v11;
    v20 = a2;
    v13 = v18;
    goto LABEL_18;
  }
}

uint64_t sub_100212D04(uint64_t result)
{
  unsigned int *v1;
  void (*v2)(uint64_t);

  v1 = (unsigned int *)*((_QWORD *)&xmmword_10098AA10 + 1);
  if (*((_QWORD *)&xmmword_10098AA10 + 1))
  {
    result = **(unsigned int **)(result + 8);
    if (**((_DWORD **)&xmmword_10098AA10 + 1) == (_DWORD)result)
    {
      *(_DWORD *)(*((_QWORD *)&xmmword_10098AA10 + 1) + 16) = 0;
      v2 = (void (*)(uint64_t))*((_QWORD *)&xmmword_10098AA40 + 1);
      if (!*((_QWORD *)&xmmword_10098AA40 + 1))
      {
        sub_100253460();
        v2 = (void (*)(uint64_t))*((_QWORD *)&xmmword_10098AA40 + 1);
        result = *v1;
      }
      v2(result);
      return sub_100212D74(*v1, 241, 0);
    }
  }
  return result;
}

uint64_t sub_100212D74(uint64_t result, int a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v5;
  _QWORD *v6;
  NSObject *v7;
  __int128 *v8;
  char *v9;
  char v10;
  int v11;
  char v12;
  _WORD v13[2];
  char v14;

  v3 = *((_QWORD *)&xmmword_10098AA10 + 1);
  if (*((_QWORD *)&xmmword_10098AA10 + 1) && **((_DWORD **)&xmmword_10098AA10 + 1) == (_DWORD)result)
  {
    if (a2)
    {
      if (word_10098AA00)
      {
        v5 = 0;
        v6 = (_QWORD *)(*((_QWORD *)&xmmword_10098A9F0 + 1) + 8);
        while (*((_BYTE *)v6 - 8) != 2 || *v6 != a3)
        {
          v6 += 2;
          if ((unsigned __int16)word_10098AA00 == ++v5)
            goto LABEL_9;
        }
      }
      else
      {
LABEL_9:
        LOWORD(v5) = 0;
      }
      if (sub_10005549C())
      {
        sub_100054530("Execute write failed at attribute handle 0x%04x with result %d", *(unsigned __int16 *)(v3 + 32), a2);
        v7 = sub_1000544A0(0x44u);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      v8 = **(__int128 ***)(v3 + 24);
      v13[0] = 6145;
      v13[1] = v5;
      v14 = a2;
      v9 = (char *)v13;
    }
    else
    {
      v10 = 25;
      if (!sub_10020EBA4(**(__int128 ***)(*((_QWORD *)&xmmword_10098AA10 + 1) + 24), &v10, 1uLL, 0))
      {
LABEL_17:
        sub_100053298(*((void **)&xmmword_10098AA10 + 1));
        *((_QWORD *)&xmmword_10098AA10 + 1) = 0;
        return sub_10020EF30(0, 1);
      }
      v8 = **(__int128 ***)(v3 + 24);
      v11 = 6145;
      v12 = 17;
      v9 = (char *)&v11;
    }
    sub_10020EBA4(v8, v9, 5uLL, 0);
    goto LABEL_17;
  }
  return result;
}

const char *sub_100212EDC(unsigned int a1)
{
  if (a1 > 7)
    return "unknown";
  else
    return off_10091EFB0[a1];
}

void sub_100212F00()
{
  NSObject *v0;
  int v1;
  void *v2;

  if (sub_10005549C())
  {
    sub_100054530("Resetting LE_Connection state");
    v0 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
    {
      v1 = 136446210;
      v2 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, " %{public}s", (uint8_t *)&v1, 0xCu);
    }
  }
  byte_10098AA80 = 0;
  byte_10098AAA4 = 0;
  byte_10098AA81 = 0;
  byte_10098AAA8 = 0;
  qword_10098AA94 = 0;
  *(_QWORD *)&word_10098AA9C = 0;
  qword_10098AA8C = 0;
}

void sub_100212FE8()
{
  byte_10098AA80 = 0;
  byte_10098AAA4 = 0;
  byte_10098AA81 = 0;
  byte_10098AAA8 = 0;
  qword_10098AA94 = 0;
  *(_QWORD *)&word_10098AA9C = 0;
  qword_10098AA8C = 0;
}

void sub_10021301C(uint64_t a1)
{
  unsigned int *v2;
  NSObject *v3;
  unsigned int v4;
  NSObject *v5;

  if (!sub_10019AC00(a1))
    sub_100253460();
  if (sub_10019AC00(a1))
  {
    v2 = (unsigned int *)(a1 + 204);
    if (*(int *)(a1 + 204) <= 254)
    {
      do
        v4 = __ldxr(v2);
      while (__stxr(v4 + 1, v2));
    }
    else
    {
      if (sub_10005549C())
      {
        sub_100054530("Reached max connection retain count. Not incrementing ref count");
        v3 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      if (*(int *)(a1 + 148) <= 254)
        sub_100253460();
    }
  }
  else if (sub_10005549C())
  {
    sub_100054530("This command is only available to LE devices.");
    v5 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
}

void sub_100213108(uint64_t a1)
{
  int v2;
  unsigned int *v3;
  NSObject *v4;
  NSObject *v5;
  unsigned int v6;

  if (!sub_10019AC00(a1))
    sub_100253460();
  if (sub_10019AC00(a1))
  {
    v3 = (unsigned int *)(a1 + 204);
    v2 = *(_DWORD *)(a1 + 204);
    if (v2 < 255)
    {
      if (v2 <= 0)
        sub_100253460();
      do
        v6 = __ldxr(v3);
      while (__stxr(v6 - 1, v3));
    }
    else
    {
      if (sub_10005549C())
      {
        sub_100054530("Reached max connection retain count. Not decrementing ref count");
        v4 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      if (*(int *)(a1 + 148) <= 254)
        sub_100253460();
    }
  }
  else if (sub_10005549C())
  {
    sub_100054530("LE connection is invalid, can't decrement");
    v5 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
}

uint64_t sub_1002131FC(unsigned __int8 *a1, uint64_t a2, uint64_t a3, unsigned int a4, _WORD *a5, unsigned int a6, _WORD *a7, uint64_t a8, unsigned __int8 a9)
{
  NSObject *v9;
  uint64_t v10;
  NSObject *v11;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  NSObject *v25;
  NSObject *v26;
  double v27;
  unsigned int v28;
  NSObject *v29;
  uint64_t v30;
  uint64_t v31;
  NSObject *v32;
  NSObject *v33;
  double v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  uint64_t v44;
  NSObject *v45;
  __int16 v46;
  unsigned __int8 v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  unsigned __int8 *v51;
  uint8_t *v52;
  _WORD *v53;
  uint8_t *v54;
  _WORD *v55;
  _WORD *v56;
  uint64_t v57;
  int *v58;
  NSObject *log;
  uint8_t *v60;
  _WORD *v61;
  _WORD *v62;
  int v63;
  __int16 v64;
  _WORD v65[3];
  _WORD v66[3];
  _WORD v67[3];
  _WORD v68[3];
  _WORD v69[3];
  uint8_t buf[4];
  void *v71;

  if (byte_10098AA80 == 1)
  {
    if (sub_10005549C())
    {
      sub_100054530("Cannot connect to device, pending attempt already in progress.");
      v9 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 1309;
  }
  if (byte_10098AA81 == 1)
  {
    if (sub_10005549C())
    {
      sub_100054530("Cannot connect to device, pending cancel connection already in progress.");
      v11 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 1319;
  }
  if ((a9 & a8) != 0xFF && !byte_10098AA82)
  {
    if (sub_10005549C())
    {
      sub_100054530("Cannot connect to device, V2 command not supported.");
      v20 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 152;
  }
  if (sub_10019AFA0(a1))
  {
    if (sub_10005549C())
    {
      sub_100054530("Already connected to this address.");
      v21 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 133;
  }
  if ((a8 + 16) <= 0xEu)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("Invalid advertising handle %x", a8);
    v22 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      return 101;
    goto LABEL_56;
  }
  if ((char)a9 <= -2)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("Invalid subevent %x", a9);
    v23 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      return 101;
    goto LABEL_56;
  }
  if ((a2 - 16385) <= 0xFFFFC002)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("Invalid scan interval %d", a2);
    v24 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      return 101;
    goto LABEL_56;
  }
  if ((a3 - 16385) <= 0xFFFFC002)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("Invalid scan window %d", a3);
    v25 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      return 101;
    goto LABEL_56;
  }
  if (a5 >= 0x1F5)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("Invalid connection latency %d", (_DWORD)a5);
    v26 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      return 101;
    goto LABEL_56;
  }
  v27 = (double)a4 / 1.25;
  v28 = (int)v27;
  if ((unsigned __int16)((int)v27 - 3201) <= 0xF384u)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("Invalid connection interval %dms", a4);
    v29 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      return 101;
    goto LABEL_56;
  }
  if (v28 - 8 <= 8)
    v30 = 8;
  else
    v30 = (unsigned __int16)(v28 - 8);
  LODWORD(v31) = (3 * (_DWORD)a5 + 3) * v28;
  if (v31 >= 0x259)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("Connection latency (%d) and connection interval (%d ms) are in a range taht will cause issues", (_DWORD)a5, a4 + 10);
    v32 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      return 101;
    goto LABEL_56;
  }
  if (((_DWORD)a7 - 8) <= 0xFFFFFFF8)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("Invalid initPHYs %x", (_DWORD)a7);
    v33 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
      return 101;
LABEL_56:
    sub_1006CE7A4();
    return 101;
  }
  v60 = (uint8_t *)(int)v27;
  v61 = (_WORD *)v30;
  v35 = (double)v28 * 1.25;
  if (v31 <= (104858 * ((5 * (unsigned __int16)(int)v35) & 0x7FFFu)) >> 19)
    LOWORD(v31) = (unsigned __int16)((104858 * ((5 * (unsigned __int16)(int)v35) & 0x7FFFu)) >> 16) >> 3;
  if ((unsigned __int16)v31 >= 0x258u)
    v31 = 600;
  else
    v31 = (unsigned __int16)v31;
  v62 = (_WORD *)v31;
  sub_100073B84((uint64_t)&dword_10098AA83);
  if (sub_10005549C())
  {
    v43 = (_BYTE)dword_10098AA83 ? "Random" : "Public";
    sub_100054530("Connecting with interval:%dms-%dms, latency=%d, timeout=%dms, initPHYs=%x connectingAddress=%s:%:, advHandle=%x subevent=%x", ((double)v61 * 1.25), v35, a5, 2 * ((5 * (_WORD)v62) & 0x7FFF), a7, v43, (char *)&dword_10098AA83 + 1, a8, a9);
    log = sub_1000544A0(0x42u);
    if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v71 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  *(_WORD *)buf = a2;
  *(_WORD *)&buf[2] = a2;
  LOWORD(v71) = a2;
  v69[0] = a3;
  v69[1] = a3;
  v69[2] = a3;
  v68[0] = (_WORD)v61;
  v68[1] = (_WORD)v61;
  v68[2] = (_WORD)v61;
  v67[0] = (_WORD)v60;
  v67[1] = (_WORD)v60;
  v67[2] = (_WORD)v60;
  v66[0] = (_WORD)a5;
  v66[1] = (_WORD)a5;
  v66[2] = (_WORD)a5;
  v65[0] = (_WORD)v62;
  v65[1] = (_WORD)v62;
  v65[2] = (_WORD)v62;
  v64 = 2;
  v63 = 131074;
  if (byte_10098AA82)
  {
    v57 = (uint64_t)v67;
    v58 = (int *)v66;
    v55 = v69;
    v56 = v68;
    v53 = a7;
    v54 = buf;
    v51 = (unsigned __int8 *)*a1;
    v52 = a1 + 1;
    v49 = 0;
    v50 = dword_10098AA83;
    v48 = a9;
    v44 = sub_100196768(0x100u, v36, v37, v38, v39, v40, v41, v42, a8);
  }
  else if (byte_10098AA8A)
  {
    v57 = (uint64_t)v65;
    v58 = &v63;
    v55 = v67;
    v56 = v66;
    v53 = v69;
    v54 = (uint8_t *)v68;
    v51 = (unsigned __int8 *)a7;
    v52 = buf;
    v49 = *a1;
    v50 = (unint64_t)(a1 + 1);
    v48 = dword_10098AA83;
    v44 = sub_100196768(0xD9u, v36, v37, v38, v39, v40, v41, v42, 0);
  }
  else
  {
    v57 = 2;
    v58 = (int *)a6;
    v55 = a5;
    v56 = v62;
    v54 = v60;
    v52 = (uint8_t *)dword_10098AA83;
    v53 = v61;
    v50 = *a1;
    v51 = a1 + 1;
    v48 = a3;
    v49 = 0;
    v44 = sub_100196768(0xADu, v36, v37, v38, v39, v40, v41, v42, a2);
  }
  v10 = v44;
  if ((_DWORD)v44)
  {
    if (sub_10005549C())
    {
      sub_100054530("Could not connect to device %!", v10, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58);
      v45 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  else
  {
    byte_10098AA80 = 1;
    LOBYTE(qword_10098AA8C) = 1;
    v46 = *((_WORD *)a1 + 2);
    v47 = a1[6];
    *(_DWORD *)((char *)&qword_10098AA8C + 3) = *(_DWORD *)a1;
    BYTE1(qword_10098AA94) = v47;
    *(_WORD *)((char *)&qword_10098AA8C + 7) = v46;
    WORD1(qword_10098AA94) = a2;
    WORD2(qword_10098AA94) = a3;
    HIWORD(qword_10098AA94) = a4;
    word_10098AA9C = (__int16)a5;
    word_10098AA9E = (__int16)v62;
    word_10098AAA0 = a6;
    byte_10098AAA2 = (char)a7;
    BYTE1(qword_10098AA8C) = a8;
    BYTE2(qword_10098AA8C) = a9;
  }
  return v10;
}

uint64_t sub_100213A24(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, _WORD *a5, unsigned int a6, int *a7, uint64_t a8, unsigned __int8 a9, unsigned __int8 a10)
{
  NSObject *v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v20;
  _DWORD *v21;
  unint64_t v22;
  NSObject *v23;
  NSObject *v24;
  NSObject *v25;
  NSObject *v26;
  NSObject *v27;
  NSObject *v28;
  NSObject *v29;
  unsigned int v30;
  unsigned int v31;
  void *v32;
  unsigned int v33;
  NSObject *v34;
  NSObject *v35;
  NSObject *v36;
  double v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char *v46;
  NSObject *v47;
  void *v48;
  unsigned __int8 v49;
  __int16 v50;
  NSObject *v51;
  uint64_t v53;
  NSObject *v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  int *v58;
  uint8_t *v59;
  unint64_t v60;
  uint8_t *v61;
  _WORD *v62;
  _WORD *v63;
  uint64_t v64;
  int *v65;
  _WORD *v66;
  NSObject *log;
  unsigned __int16 loga;
  __int16 v70;
  int v71;
  __int16 v72;
  _WORD v73[3];
  _WORD v74[3];
  _WORD v75[3];
  _WORD v76[3];
  _WORD v77[3];
  unsigned int v78;
  int v79;
  __int16 v80;
  uint8_t buf[4];
  void *v82;

  v80 = 0;
  v79 = 0;
  if (byte_10098AA80 == 1)
  {
    if (sub_10005549C())
    {
      sub_100054530("Cannot connect to device, pending attempt already in progress.");
      v10 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 1309;
  }
  if (byte_10098AA81 == 1)
  {
    if (sub_10005549C())
    {
      sub_100054530("Cannot connect to device, pending cancel connection already in progress.");
      v12 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 1319;
  }
  if ((a10 & a9) != 0xFF && byte_10098AA82 == 0)
  {
    if (sub_10005549C())
    {
      sub_100054530("Cannot connect to device, V2 command not supported.");
      v24 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 152;
  }
  v78 = 0;
  v20 = sub_10023A58C(&v78);
  if (!v78)
  {
LABEL_19:
    if ((a9 + 16) <= 0xEu)
    {
      if (!sub_10005549C())
        return 101;
      sub_100054530("Invalid advertising handle %x", a9);
      v23 = sub_1000544A0(0x42u);
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        return 101;
      goto LABEL_83;
    }
    if ((char)a10 <= -2)
    {
      if (!sub_10005549C())
        return 101;
      sub_100054530("Invalid subevent %x", a10);
      v25 = sub_1000544A0(0x42u);
      if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        return 101;
      goto LABEL_83;
    }
    if ((a1 - 16385) <= 0xFFFFC002)
    {
      if (!sub_10005549C())
        return 101;
      sub_100054530("Invalid scan interval %d", a1);
      v27 = sub_1000544A0(0x42u);
      if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        return 101;
      goto LABEL_83;
    }
    if ((a2 - 16385) <= 0xFFFFC002)
    {
      if (!sub_10005549C())
        return 101;
      sub_100054530("Invalid scan window %d", a2);
      v28 = sub_1000544A0(0x42u);
      if (!os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        return 101;
      goto LABEL_83;
    }
    if (a5 >= 0x1F5)
    {
      if (!sub_10005549C())
        return 101;
      sub_100054530("Invalid connection latency %d", (_DWORD)a5);
      v29 = sub_1000544A0(0x42u);
      if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        return 101;
      goto LABEL_83;
    }
    v30 = a3;
    if (a4 <= (unsigned __int16)(a3 - 1))
    {
      if (!a3 || a4 != a3 && a4)
      {
        if (!sub_10005549C())
          return 101;
        sub_100054530("Invalid min/max connection interval %d/%d", a3, a4);
        v35 = sub_1000544A0(0x42u);
        if (!os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
          return 101;
        goto LABEL_83;
      }
      v37 = (double)a3 / 1.25;
      v31 = (int)v37;
      if (((int)v37 - 6) >= 0xC7B)
      {
        if (!sub_10005549C())
          return 101;
        sub_100054530("Invalid connection interval %dms", a3);
        v51 = sub_1000544A0(0x42u);
        if (!os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
          return 101;
        goto LABEL_83;
      }
      if (v31 < 0xC78)
      {
        if (v31 > 0xE)
        {
          LOWORD(a4) = v31 + 8;
          LOWORD(v31) = v31 - 8;
        }
        else
        {
          LOWORD(a4) = v31 + 16;
        }
      }
      else
      {
        a4 = (int)v37;
        LOWORD(v31) = v31 - 16;
      }
    }
    else
    {
      LOWORD(v31) = a3;
      v30 = (a4 + a3) >> 1;
      if (sub_10005549C())
      {
        sub_100054530("overriding min/max connection intervals to %d-%dms (%dms)", a3, a4, v30);
        log = sub_1000544A0(0x42u);
        if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
        {
          v32 = sub_100054494();
          *(_DWORD *)buf = 136446210;
          v82 = v32;
          _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
        }
      }
    }
    v33 = (3 * (_DWORD)a5 + 3) * (unsigned __int16)a4;
    if (v33 < 0x259)
    {
      if (((_DWORD)a7 - 8) > 0xFFFFFFF8)
      {
        loga = v31;
        v70 = v30;
        if (v33 <= (104858 * ((5 * (unsigned __int16)(int)((double)v30 * 1.25)) & 0x7FFFu)) >> 19)
          LOWORD(v33) = (unsigned __int16)((104858 * ((5 * (unsigned __int16)(int)((double)v30 * 1.25)) & 0x7FFFu)) >> 16) >> 3;
        if ((unsigned __int16)v33 >= 0x258u)
          v38 = 600;
        else
          v38 = (unsigned __int16)v33;
        sub_100073B84((uint64_t)&dword_10098AA83);
        if (sub_10005549C())
        {
          v46 = (_BYTE)dword_10098AA83 ? "Random" : "Public";
          sub_100054530("Connecting with interval:%dms-%dms, latency=%d, timeout=%dms, initPHYs=%x connectingAddress=%s:%:, advHandle=%x subevent=%x", ((double)loga * 1.25), ((double)(unsigned __int16)a4 * 1.25), a5, 2 * ((5 * (_WORD)v38) & 0x7FFF), a7, v46, (char *)&dword_10098AA83 + 1, a9, a10);
          v47 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
          {
            v48 = sub_100054494();
            *(_DWORD *)buf = 136446210;
            v82 = v48;
            _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
          }
        }
        *(_WORD *)buf = a1;
        *(_WORD *)&buf[2] = a1;
        LOWORD(v82) = a1;
        v77[0] = a2;
        v77[1] = a2;
        v77[2] = a2;
        v76[0] = loga;
        v76[1] = loga;
        v76[2] = loga;
        v75[0] = a4;
        v75[1] = a4;
        v75[2] = a4;
        v74[0] = (_WORD)a5;
        v74[1] = (_WORD)a5;
        v74[2] = (_WORD)a5;
        v73[0] = v38;
        v73[1] = v38;
        v73[2] = v38;
        v72 = 2;
        v71 = 131074;
        v66 = (_WORD *)v38;
        if (byte_10098AA82)
        {
          v64 = (uint64_t)v75;
          v65 = (int *)v74;
          v62 = v77;
          v63 = v76;
          v60 = (unint64_t)a7;
          v61 = buf;
          v58 = 0;
          v59 = (uint8_t *)&v79;
          v56 = 1;
          v57 = dword_10098AA83;
          v49 = a9;
          v55 = a10;
          v11 = sub_100196768(0x100u, v39, v40, v41, v42, v43, v44, v45, a9);
          v50 = v70;
        }
        else
        {
          v50 = v70;
          v49 = a9;
          if (byte_10098AA8A)
          {
            v64 = (uint64_t)v73;
            v65 = &v71;
            v62 = v75;
            v63 = v74;
            v60 = (unint64_t)v77;
            v61 = (uint8_t *)v76;
            v58 = a7;
            v59 = buf;
            v56 = 0;
            v57 = (unint64_t)&v79;
            v55 = dword_10098AA83;
            v53 = sub_100196768(0xD9u, v39, v40, v41, v42, v43, v44, v45, 1);
          }
          else
          {
            v58 = &v79;
            v59 = (uint8_t *)dword_10098AA83;
            v56 = 1;
            v57 = 0;
            v55 = a2;
            v64 = 2;
            v65 = (int *)a6;
            v62 = a5;
            v63 = v66;
            v60 = loga;
            v61 = (uint8_t *)(unsigned __int16)a4;
            v53 = sub_100196768(0xADu, v39, v40, v41, v42, v43, v44, v45, a1);
          }
          v11 = v53;
        }
        if ((_DWORD)v11)
        {
          if (sub_10005549C())
          {
            sub_100054530("Could not start auto-connect : %!", v11, v55, v56, v57, v58, v59, v60, v61, v62, v63, v64, v65);
            v54 = sub_1000544A0(0x42u);
            if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
              sub_1006CE7A4();
          }
        }
        else
        {
          byte_10098AA80 = 1;
          LOBYTE(qword_10098AA8C) = 0;
          WORD1(qword_10098AA94) = a1;
          WORD2(qword_10098AA94) = a2;
          HIWORD(qword_10098AA94) = v50;
          word_10098AA9C = (__int16)a5;
          word_10098AA9E = (__int16)v66;
          word_10098AAA0 = a6;
          byte_10098AAA2 = (char)a7;
          BYTE1(qword_10098AA8C) = v49;
          BYTE2(qword_10098AA8C) = a10;
        }
        return v11;
      }
      if (!sub_10005549C())
        return 101;
      sub_100054530("Invalid initPHYs %x", (_DWORD)a7);
      v36 = sub_1000544A0(0x42u);
      if (!os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
        return 101;
    }
    else
    {
      if (!sub_10005549C())
        return 101;
      sub_100054530("Connection latency (%d) and connection interval (%d ms) are in a range taht will cause issues", (_DWORD)a5, v30 + 10);
      v34 = sub_1000544A0(0x42u);
      if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        return 101;
    }
LABEL_83:
    sub_1006CE7A4();
    return 101;
  }
  v21 = (_DWORD *)v20;
  v22 = 0;
  while (!sub_10019AFA0(v21))
  {
    ++v22;
    v21 = (_DWORD *)((char *)v21 + 7);
    if (v22 >= v78)
      goto LABEL_19;
  }
  if (sub_10005549C())
  {
    sub_100054530("Already connected to this address.");
    v26 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  return 133;
}

uint64_t sub_10021437C()
{
  return byte_10098AA80;
}

BOOL sub_100214388(int a1, int a2)
{
  if (byte_10098AA80 != 1)
    return 0;
  return WORD1(qword_10098AA94) == a1 && WORD2(qword_10098AA94) == a2;
}

uint64_t sub_1002143C0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  float v14;
  NSObject *v15;
  uint64_t v17;

  if (sub_10019AC00(a1))
  {
    if (*(_BYTE *)(a1 + 124) == 7)
    {
      return 0;
    }
    else
    {
      v17 = a2;
      v13 = sub_100196768(5u, v4, v5, v6, v7, v8, v9, v10, a1);
      v11 = sub_1001A1F70(a1, v13);
      if ((_DWORD)v11)
      {
        if (sub_10005549C())
        {
          sub_100054530("Could not disconnect LE device %!", v11, v17);
          v15 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
      }
      else
      {
        *(_BYTE *)(a1 + 124) = 7;
      }
      sub_10019C61C(a1, v14);
    }
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("This handle is not a LE connection.");
      v12 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 1310;
  }
  return v11;
}

uint64_t sub_1002144CC(char a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  NSObject *v9;
  uint64_t v11;
  uint64_t v12;

  if ((byte_10098AA80 & 1) != 0)
  {
    if (byte_10098AA81 != 1 || (a1 & 1) != 0)
    {
      byte_10098AAA4 = a1;
      v8 = sub_10004C9BC(174, (uint64_t (*)())sub_1002145BC, a3, a4, a5, a6, a7, a8, v11);
      if ((_DWORD)v8)
      {
        if (sub_10005549C())
        {
          sub_100054530("Failed to cancel a connection : %!", v8);
          v9 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
      }
      else
      {
        byte_10098AA81 = 1;
      }
    }
    else
    {
      v8 = 0;
      byte_10098AAA4 = 0;
    }
  }
  else
  {
    v12 = 0;
    while (sub_10019C2D0(&v12))
    {
      if (*(_DWORD *)(v12 + 132) != 7)
        return 1302;
    }
    return 1301;
  }
  return v8;
}

void sub_1002145BC(uint64_t a1)
{
  uint64_t v1;
  int v2;
  NSObject *v3;
  NSObject *v4;
  int v5;
  __int128 buf;

  v1 = a1;
  v5 = a1;
  v2 = byte_10098AAA4;
  if (sub_10005549C())
  {
    sub_100054530("connectionCancelCb lConnectionInProgress %d, lRestartConnectionInProgress %d, lCancelConnectionInProgress %d lCancelConnectionDeferInProgress %d - %!", byte_10098AA80, byte_10098AAA4, byte_10098AA81, byte_10098AAA8, v1);
    v3 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 136446210;
      *(_QWORD *)((char *)&buf + 4) = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, " %{public}s", (uint8_t *)&buf, 0xCu);
    }
  }
  if ((_DWORD)v1 == 712)
  {
    if (byte_10098AA81 == 1 && (byte_10098AAA8 & 1) == 0)
    {
      *((_QWORD *)&buf + 1) = &v5;
      *(_QWORD *)&buf = 4;
      byte_10098AAA8 = 1;
      sub_10004A9EC((uint64_t)sub_100218B64, (const void **)&buf, 1, 0);
      return;
    }
    byte_10098AA81 = 0;
    byte_10098AAA8 = 0;
    byte_10098AA80 = 0;
    v1 = 712;
  }
  else
  {
    byte_10098AA81 = 0;
    byte_10098AAA8 = 0;
    if ((_DWORD)v1 == 702)
    {
      if ((byte_10098AA80 & 1) == 0)
        sub_100253460();
      byte_10098AA80 = 0;
      if (byte_10098AAA4)
      {
        if ((_BYTE)qword_10098AA8C)
          sub_1002131FC((unsigned __int8 *)&qword_10098AA8C + 3, WORD1(qword_10098AA94), WORD2(qword_10098AA94), HIWORD(qword_10098AA94), (_WORD *)(unsigned __int16)word_10098AA9C, (unsigned __int16)word_10098AAA0, (_WORD *)byte_10098AAA2, BYTE1(qword_10098AA8C), BYTE2(qword_10098AA8C));
        else
          sub_100213A24(WORD1(qword_10098AA94), WORD2(qword_10098AA94), HIWORD(qword_10098AA94), 0, (_WORD *)(unsigned __int16)word_10098AA9C, (unsigned __int16)word_10098AAA0, (int *)byte_10098AAA2, 0, BYTE1(qword_10098AA8C), BYTE2(qword_10098AA8C));
      }
      else if ((_BYTE)qword_10098AA8C)
      {
        v1 = 0;
        LOBYTE(qword_10098AA8C) = 0;
        goto LABEL_25;
      }
    }
    else
    {
      if ((_DWORD)v1)
      {
        if (sub_10005549C())
        {
          sub_100054530("Unexpected error code %! for connection cancel.", v1);
          v4 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
            sub_1006CEEC0();
        }
        goto LABEL_25;
      }
      if ((byte_10098AA80 & 1) == 0)
        sub_100253460();
    }
    v1 = 0;
  }
LABEL_25:
  byte_10098AAA4 = 0;
  if (!v2)
    sub_100220958(v1);
}

uint64_t sub_10021483C()
{
  return byte_10098AA81;
}

uint64_t sub_100214848(char a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v8;

  if ((a1 & 1) == 0 && (byte_10098AA80 == 1 ? (v8 = byte_10098AAA4 == 0) : (v8 = 0), v8))
    return sub_1002144CC(1, a2, a3, a4, a5, a6, a7, a8);
  else
    return 0;
}

BOOL sub_100214878(unsigned int a1)
{
  _BOOL8 result;
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  unsigned __int16 *v6;

  v6 = 0;
  for (result = sub_10019C2D0((uint64_t *)&v6); result; result = sub_10019C2D0((uint64_t *)&v6))
  {
    if (v6[52] > 0x1Bu || v6[54] >= 0x1Cu)
    {
      v3 = sub_10021497C(v6, a1);
      if ((_DWORD)v3)
      {
        v4 = v3;
        if ((_DWORD)v3 != 4000)
        {
          if (sub_10005549C())
          {
            sub_100054530("ClassicSynchronousConfigChanged LE scaling completed with error %!", v4);
            v5 = sub_1000544A0(0x42u);
            if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
              sub_1006D2C38();
          }
        }
      }
    }
  }
  return result;
}

uint64_t sub_10021497C(unsigned __int16 *a1, unsigned int a2)
{
  unsigned __int16 v3;
  unsigned __int16 v4;
  unsigned int v5;
  unsigned __int16 v6;
  int v7;
  int v8;
  int v9;
  int v10;
  NSObject *v11;
  void *v12;
  unsigned int v13;
  unsigned __int16 v14;
  unsigned __int16 v15;
  unint64_t v16;
  char v17;
  NSObject *v18;
  void *v19;
  unsigned __int16 v20;
  unsigned __int16 v21;
  int v22;
  int v23;
  int v24;
  char v25;
  unsigned int v26;
  int v27;
  char v28;
  unsigned int v29;
  uint64_t v30;
  NSObject *v31;
  void *v32;
  unsigned __int16 v33;
  NSObject *v34;
  void *v35;
  int v36;
  int v37;
  __int16 v38;
  __int16 v39;
  unsigned __int16 v40;
  int v41;
  unsigned __int8 v42;
  unsigned int v43;
  NSObject *v45;
  NSObject *v46;
  void *v47;
  unsigned int v48;
  void *v50;
  char v51;
  int v52;
  unsigned int v53;
  unsigned __int16 v54;
  BOOL v55;
  unsigned __int16 v56;
  unsigned int v57;
  NSObject *v58;
  void *v59;
  char v60;
  unsigned int v61;
  unsigned int v62;
  unsigned int v63;
  NSObject *v64;
  void *v65;
  uint64_t v66;
  const char *v67;
  uint64_t v68;
  uint64_t v69;
  int v70;
  const char *v71;
  const char *v72;
  uint64_t v73;
  uint64_t v74;
  NSObject *v75;
  void *v76;
  NSObject *v78;
  void *v79;
  unsigned int v80;
  unsigned int v81;
  unsigned int v82;
  uint64_t v84;
  char v85;
  unsigned __int16 *v86;
  unsigned __int16 *v87;
  unsigned __int16 v88;
  uint8_t buf[4];
  void *v90;

  v88 = a1[54];
  v3 = a1[43];
  v84 = a1[57];
  v87 = 0;
  if (sub_10019C4B4((uint64_t *)&v87))
  {
    v85 = 0;
    v4 = 0;
    do
    {
      v5 = *((unsigned __int8 *)v87 + 60);
      if (*((_BYTE *)v87 + 60) && !*((_BYTE *)v87 + 56))
      {
        if (v5 <= 6)
          v6 = 2500;
        else
          v6 = 625 * v5 - 1250;
        if (v5 <= 0xC)
        {
          if (sub_10005549C())
          {
            v7 = *a1;
            v8 = *v87;
            v9 = *((unsigned __int8 *)v87 + 60);
            v10 = sub_100186224();
            sub_100054530("LE_ScaleDataLength lmHandle 0x%x SCO found voicelmHandle 0x%x _ceClassicAllowance %d interval %d piconets %d", v7, v8, v6, v9, v10);
            v11 = sub_1000544A0(0x42u);
            if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
            {
              v12 = sub_100054494();
              *(_DWORD *)buf = 136446210;
              v90 = v12;
              _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
            }
            v85 = 1;
          }
          else
          {
            v85 = 1;
          }
        }
        v13 = sub_100186224();
        v14 = v6 - 625;
        if (v13 <= 1)
          v14 = v6;
        if (v4 <= v14)
          v4 = v14;
      }
    }
    while (sub_10019C4B4((uint64_t *)&v87));
  }
  else
  {
    v4 = 0;
    v85 = 0;
  }
  v15 = 625 * v3;
  v86 = 0;
  v17 = 0;
  while (sub_10019C2D0((uint64_t *)&v86))
  {
    if (*((_BYTE *)v86 + 124) != 7 && *((_BYTE *)v86 + 128))
    {
      if (sub_10005549C())
      {
        sub_100054530("LE_ScaleDataLength lmHandle 0x%x LEA streaming found voicelmHandle 0x%x", *a1, *v86);
        v18 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          v19 = sub_100054494();
          *(_DWORD *)buf = 136446210;
          v90 = v19;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
        }
      }
      v17 = 1;
    }
  }
  v20 = 625 * v3;
  if (v4 < v15)
    v20 = v4;
  if (v4)
    v21 = v20;
  else
    v21 = 625 * v3;
  v22 = *((_DWORD *)a1 + 36);
  v23 = *((_DWORD *)a1 + 37);
  if (v23 == 2)
  {
    v24 = 360;
    v25 = 2;
  }
  else if (v23 == 3)
  {
    v24 = 1276;
    v25 = 6;
  }
  else
  {
    v24 = 412;
    v25 = 3;
  }
  v26 = a1[54];
  if (v22 == 2)
  {
    v27 = 60;
    v28 = 2;
  }
  else if (v22 == 3)
  {
    v27 = 976;
    v28 = 6;
  }
  else
  {
    v27 = 112;
    v28 = 3;
  }
  if (v24 + v27 + (a1[52] << v25) + (v26 << v28) > v21 || *((_BYTE *)a1 + 265) || *((_BYTE *)a1 + 266))
  {
    if (a1[56] <= v26)
      v29 = a1[54];
    else
      v29 = a1[56];
    LOWORD(v16) = a1[40];
    v30 = sub_1002156CC(v29, &v88, v21, (int)((double)v16 * 1.25), 1, v22, v23);
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("lmHandle 0x%x CE %d is larger than calculated symmetric pair, do not scale", *a1, v21);
      v46 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
      {
        v47 = sub_100054494();
        *(_DWORD *)buf = 136446210;
        v90 = v47;
        _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
    v30 = a1[52];
    v88 = a1[54];
  }
  if (*((_BYTE *)a1 + 70) == 1 && a1[57] == v4 && (v30 > a1[52] || v88 > a1[54]))
  {
    if (sub_10005549C())
    {
      sub_100054530("Peripheral optimal[tx %d, rx %d] is larger than connection[tx %d, rx %d], scaling down lmHandle 0x%x ", v30, v88, a1[52], a1[54], *a1);
      v31 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        v32 = sub_100054494();
        *(_DWORD *)buf = 136446210;
        v90 = v32;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
    if (v30 >= a1[52])
      v30 = a1[52];
    else
      v30 = v30;
    v33 = v88;
    if (v88 >= a1[54])
      v33 = a1[54];
    v88 = v33;
  }
  a1[57] = v4;
  if (word_10098AAA6)
  {
    if (sub_10005549C())
    {
      sub_100054530("EDL: Tx length override to %d", (unsigned __int16)word_10098AAA6);
      v34 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        v35 = sub_100054494();
        *(_DWORD *)buf = 136446210;
        v90 = v35;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
    v36 = (unsigned __int16)word_10098AAA6;
    v30 = (unsigned __int16)word_10098AAA6;
  }
  else
  {
    v36 = 0;
  }
  v37 = *((_DWORD *)a1 + 36);
  v38 = 4 * v30 + 60;
  if (v30 <= 0x42)
    v38 = 328;
  if (v30 <= 0x1A)
    v39 = 328;
  else
    v39 = 8 * v30 + 112;
  if (v37 != 1)
    v39 = ((_WORD)v30 << 6) + 976;
  if (v37 == 2)
    v40 = v38;
  else
    v40 = v39;
  if ((v17 & 1) != 0)
    LOBYTE(v41) = 28;
  else
    LOBYTE(v41) = byte_10097A8B0;
  if ((v17 & 1) != 0)
    v42 = 63;
  else
    v42 = byte_10097A8B1;
  if (v36 || !((v4 != 0) & v85 | v17 & 1) || !*((_BYTE *)a1 + 32))
    goto LABEL_116;
  if (v37 == 2)
  {
    v48 = 4 * v42 + 60;
    if (v42 <= 0x42u)
      v48 = 328;
    if (v48 >= v40 && v30 <= v42)
      goto LABEL_116;
    v82 = v48;
    v80 = v42;
    if (!sub_10005549C()
      || (sub_100054530("LE_ScaleDataLength Capping Tx with 2M for lmHandle 0x%x ceClassicAllowance %d txTime %d >= %d optimalTxBytes %d Cap txTime and optimalTxBytes rxPhy %d", *a1, v4, v40, v82, v30, *((_DWORD *)a1 + 36)), v45 = sub_1000544A0(0x42u), !os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT)))
    {
LABEL_115:
      v51 = 1;
      v30 = v80;
      goto LABEL_117;
    }
LABEL_114:
    v50 = sub_100054494();
    *(_DWORD *)buf = 136446210;
    v90 = v50;
    _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    goto LABEL_115;
  }
  if (v37 == 1)
  {
    v43 = 8 * v41 + 112;
    if (v41 <= 0x1Au)
      v43 = 328;
    if (v43 < v40 || v30 > v41)
    {
      v81 = v43;
      v80 = v41;
      if (!sub_10005549C())
        goto LABEL_115;
      sub_100054530("LE_ScaleDataLength Capping Tx with 1M for lmHandle 0x%x ceClassicAllowance %d txTime %d >= %d optimalTxBytes %d Cap txTime and optimalTxBytes rxPhy %d", *a1, v4, v40, v81, v30, *((_DWORD *)a1 + 36));
      v45 = sub_1000544A0(0x42u);
      if (!os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
        goto LABEL_115;
      goto LABEL_114;
    }
  }
LABEL_116:
  v51 = 0;
LABEL_117:
  *((_BYTE *)a1 + 266) = v51;
  v52 = *((_DWORD *)a1 + 37);
  if (v52 == 2)
  {
    v53 = v88;
    v54 = 4 * v88 + 60;
    v55 = v88 > 0x42u;
  }
  else
  {
    if (v52 != 1)
    {
      v53 = v88;
      v56 = (v88 << 6) + 976;
      goto LABEL_125;
    }
    v53 = v88;
    v54 = 8 * v88 + 112;
    v55 = v88 > 0x1Au;
  }
  if (v55)
    v56 = v54;
  else
    v56 = 328;
LABEL_125:
  if (!((v4 != 0) & v85 | v17 & 1) || !*((_BYTE *)a1 + 32))
    goto LABEL_143;
  if (v52 != 2)
  {
    if (v52 == 1)
    {
      v41 = v41;
      v57 = v41 <= 0x1Au ? 328 : 8 * v41 + 112;
      if (v57 < v56 || v53 > v41)
      {
        if (sub_10005549C())
        {
          sub_100054530("LE_ScaleDataLength Capping Rx with 1M for lmHandle 0x%x ceClassicAllowance %d rxTime %d >= %d optimalRxBytes %d Cap rxTime and optimalRxBytes txPhy %d", *a1, v4, v56, v57, v88, *((_DWORD *)a1 + 37));
          v58 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
          {
            v59 = sub_100054494();
            *(_DWORD *)buf = 136446210;
            v90 = v59;
            _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
          }
        }
        v88 = v41;
        v60 = 1;
        goto LABEL_144;
      }
    }
LABEL_143:
    v60 = 0;
    v41 = v53;
    goto LABEL_144;
  }
  v41 = v42;
  if (v42 <= 0x42u)
    v61 = 328;
  else
    v61 = 4 * v42 + 60;
  if (v61 >= v56 && v53 <= v42)
    goto LABEL_143;
  if (sub_10005549C())
  {
    sub_100054530("LE_ScaleDataLength Capping Rx with 2M for lmHandle 0x%x ceClassicAllowance %d rxTime %d >= %d optimalRxBytes %d Cap rxTime and optimalRxBytes txPhy %d", *a1, v4, v56, v61, v88, *((_DWORD *)a1 + 37));
    v78 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
    {
      v79 = sub_100054494();
      *(_DWORD *)buf = 136446210;
      v90 = v79;
      _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  v88 = v42;
  v60 = 1;
LABEL_144:
  *((_BYTE *)a1 + 265) = v60;
  v62 = a1[40];
  v63 = 8 * sub_10021597C(v41, v30, v21, *((_DWORD *)a1 + 36), *((_DWORD *)a1 + 37));
  if (v63)
    v63 = v63 * (0x3E8u / (int)((double)v62 * 1.25)) / 0x3E8;
  *((_DWORD *)a1 + 53) = v63;
  *((_DWORD *)a1 + 54) = sub_10021597C(v88, v30, v15, *((_DWORD *)a1 + 36), *((_DWORD *)a1 + 37));
  sub_1000EE2A0(a1);
  if ((_DWORD)v30 == a1[52] && v88 == a1[54])
  {
    if (sub_10005549C())
    {
      sub_100054530("Tx length is already at best-fit, exiting");
      v64 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
      {
        v65 = sub_100054494();
        *(_DWORD *)buf = 136446210;
        v90 = v65;
        _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
    v66 = 4000;
  }
  else
  {
    v66 = sub_1001F5FDC((uint64_t)a1);
  }
  if (sub_10005549C())
  {
    if (a2 > 7)
      v67 = "UNKNOWN";
    else
      v67 = off_10091EF70[a2];
    v68 = v88;
    v69 = a1[56];
    v70 = *((_DWORD *)a1 + 34);
    v71 = "unknown";
    if (v70 == 1)
      v71 = "complete";
    if (v70)
      v72 = v71;
    else
      v72 = "idle";
    v73 = *((unsigned int *)a1 + 53);
    v74 = sub_100186224();
    sub_100054530("Reason %s Selected %d with optimal [tx %d, rx %d], all-time rx %d,  CE %d, calc-CE %d, tput %d, classic-alw [%d -> %d], probe: %s, piconets %d, status %!. Current: tx[%d, %d] rx[%d, %d] lmHandle 0x%x ", v67, v30, v30, v68, v69, v21, v21, v73, v84, v4, v72, v74, v66, a1[52], a1[53], a1[54], a1[55],
      *a1);
    v75 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
    {
      v76 = sub_100054494();
      *(_DWORD *)buf = 136446210;
      v90 = v76;
      _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  return v66;
}

void sub_10021555C(unsigned __int16 *a1, unsigned int a2)
{
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  unsigned __int16 *v9;

  if (a2 - 5 >= 3)
  {
    if (sub_10005549C())
    {
      sub_100054530("LE_LEAConfigChanged Unexpected reason %d", a2);
      v8 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  else
  {
    v9 = 0;
    while (sub_10019C2D0((uint64_t *)&v9))
    {
      if ((v9[52] > 0x1Bu || v9[54] >= 0x1Cu) && v9 != a1 && *((_BYTE *)v9 + 127) == 0)
      {
        v5 = sub_10021497C(v9, a2);
        if ((_DWORD)v5)
        {
          v6 = v5;
          if ((_DWORD)v5 != 4000)
          {
            if (sub_10005549C())
            {
              sub_100054530("LE_LEAConfigChanged LE scaling completed with error %!", v6);
              v7 = sub_1000544A0(0x42u);
              if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
                sub_1006D2C38();
            }
          }
        }
      }
    }
  }
}

uint64_t sub_1002156CC(unsigned int a1, unsigned __int16 *a2, unsigned int a3, unsigned int a4, uint64_t a5, int a6, int a7)
{
  const char *v10;
  NSObject *v11;
  unsigned int v12;
  unsigned __int16 v13;
  int v14;
  unsigned __int16 v15;
  unsigned __int16 v16;
  unsigned __int16 v17;
  uint64_t v18;
  unsigned __int16 v19;
  unsigned int v20;
  char v21;
  NSObject *v22;
  void *v23;
  uint8_t buf[4];
  void *v30;

  if (sub_10005549C())
  {
    v10 = "dynamic";
    if ((_DWORD)a5)
      v10 = "static";
    sub_100054530("Finding bestfit for %s-rx %d, ce %d, interval %d", v10, a1, a3, a4);
    v11 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v30 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  v12 = 0;
  v13 = 251;
  v14 = 23;
  v15 = a1;
  v16 = 251;
  do
  {
    if (v16 >= a1)
      v17 = a1;
    else
      v17 = v16;
    v18 = a5;
    if ((_DWORD)a5)
      v19 = v17;
    else
      v19 = v16;
    v20 = 8 * sub_10021597C(v19, v16, a3, a6, a7);
    if (v20)
      v20 = v20 * (0x3E8 / a4) / 0x3E8;
    if (v20 > v12)
    {
      v12 = v20;
      v13 = v16;
      v15 = v19;
    }
    if (v16 == 251)
      v16 = 240;
    else
      v16 -= 10;
    --v14;
    a5 = v18;
  }
  while (v14);
  if (a2)
    *a2 = v15;
  if (a1 >= v15)
    v21 = v18;
  else
    v21 = 0;
  if ((v21 & 1) == 0 && (_DWORD)v18)
    sub_100253460();
  if (sub_10005549C())
  {
    sub_100054530("Optimal length is [tx %d, rx %d] yielding %d kbps", v13, v15, v12);
    v22 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      v23 = sub_100054494();
      *(_DWORD *)buf = 136446210;
      v30 = v23;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  return v13;
}

unint64_t sub_10021591C(int a1, int a2, unsigned int a3, unsigned int a4, int a5, int a6)
{
  int v7;

  v7 = 8 * sub_10021597C(a1, a2, a3, a5, a6);
  if (v7)
    return v7 * (0x3E8 / a4) / 0x3E8uLL;
  else
    return 0;
}

uint64_t sub_100215970(uint64_t result)
{
  word_10098AAA6 = result;
  return result;
}

uint64_t sub_10021597C(int a1, int a2, unsigned int a3, int a4, int a5)
{
  char v7;
  int v8;
  int v9;
  int v10;
  int v11;
  char v12;
  int v13;
  int v14;
  int v15;
  int v16;
  unsigned int v17;
  uint64_t v18;
  NSObject *v19;
  unsigned int v21;
  int v23;
  uint8_t buf[4];
  void *v25;

  if (a5 == 3)
    v7 = 6;
  else
    v7 = 3;
  if (a5 == 3)
    v8 = 976;
  else
    v8 = 112;
  if (a5 == 2)
  {
    v7 = 2;
    v9 = 60;
  }
  else
  {
    v9 = v8;
  }
  v10 = (a2 << v7) + v9;
  if (a4 == 3)
    v11 = 720;
  else
    v11 = 80;
  if (a4 == 3)
    v12 = 6;
  else
    v12 = 3;
  if (a4 == 3)
    v13 = 976;
  else
    v13 = 112;
  if (a4 == 2)
    v14 = 44;
  else
    v14 = v11;
  if (a4 == 2)
  {
    v12 = 2;
    v15 = 60;
  }
  else
  {
    v15 = v13;
  }
  v16 = v10 + v14 + 300;
  v17 = v10 + (a1 << v12) + v15 + 300;
  if (v17 <= a3)
  {
    if (a2 == 27 && a1 == 27)
      v21 = v10 + (a1 << v12) + v15 + 300;
    else
      v21 = v10 + v14 + 300;
    return a3 / v21 * a2;
  }
  else
  {
    if (!sub_10005549C())
      return 27;
    v23 = a2;
    v18 = 27;
    sub_100054530("CE length is smaller than one pair of max Tx/Rx. BytesPerInterval %d: # pkts %d, asym %d us, sym %d us, totalTime %d, remainder %d. Input: tx %d, ce %d", 27, 0, v16, v17, 0, 0, v23, a3);
    v19 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v25 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      return 27;
    }
  }
  return v18;
}

void sub_100215B0C(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;
  uint8_t buf[4];
  void *v5;

  if (sub_10005549C())
  {
    sub_100054530("_setTxDataLengthExtendedCB %!", a1);
    v2 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v5 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if ((_DWORD)a1 && sub_10005549C())
  {
    sub_100054530("Set data length extended error status %!", a1);
    v3 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
}

uint64_t sub_100215C14(uint64_t a1, uint64_t a2, int a3, unsigned int a4, unsigned int a5, int a6, int a7, int a8, unsigned __int16 a9)
{
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  NSObject *v22;
  unint64_t v23;
  unint64_t v24;
  int v25;
  NSObject *v26;
  void *v27;
  NSObject *v28;
  void *v29;
  uint64_t result;
  NSObject *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  NSObject *v38;
  void *v39;
  uint8_t buf[4];
  void *v41;

  if (a1 && sub_10019AC00(a1))
  {
    if (a3)
    {
      if (sub_10005549C())
      {
        sub_100054530("new connection parameters interval %dms-%dms, timeout=%dms, CE %d-%d latency=%d", (int)((double)a4 * 1.25), (int)((double)a5 * 1.25), 10 * a7, a8, a9, a6);
        v22 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446210;
          v41 = sub_100054494();
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
        }
      }
      if (sub_10005549C())
      {
        LOWORD(v23) = *(_WORD *)(a1 + 90);
        *(double *)&v24 = (double)v23 * 1.25;
        v25 = (int)*(double *)&v24;
        LOWORD(v24) = *(_WORD *)(a1 + 92);
        sub_100054530("current connection params interval %dms-%dms, timeout=%dms, CE %d-%d latency=%d", v25, (int)((double)v24 * 1.25), 10 * *(unsigned __int16 *)(a1 + 84), *(unsigned __int16 *)(a1 + 88), *(unsigned __int16 *)(a1 + 86), *(unsigned __int16 *)(a1 + 82));
        v26 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          v27 = sub_100054494();
          *(_DWORD *)buf = 136446210;
          v41 = v27;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
        }
      }
      if (*(unsigned __int16 *)(a1 + 88) == a8
        && *(unsigned __int16 *)(a1 + 86) == a9
        && *(unsigned __int16 *)(a1 + 92) == a5
        && *(unsigned __int16 *)(a1 + 90) == a4
        && *(unsigned __int16 *)(a1 + 84) == a7
        && *(unsigned __int16 *)(a1 + 82) == a6)
      {
        if (sub_10005549C())
        {
          sub_100054530("Ignoring request to update parameters since we are already configured for the same values");
          v28 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
          {
            v29 = sub_100054494();
            *(_DWORD *)buf = 136446210;
            v41 = v29;
            _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
          }
        }
        return 4170;
      }
      else
      {
        if (sub_10005549C())
        {
          sub_100054530("Sending parameters to controller");
          v38 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
          {
            v39 = sub_100054494();
            *(_DWORD *)buf = 136446210;
            v41 = v39;
            _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
          }
        }
        result = sub_10004C9BC(192, (uint64_t (*)())sub_100215FE8, v32, v33, v34, v35, v36, v37, a1);
        if (!(_DWORD)result)
        {
          if (*(unsigned __int16 *)(a1 + 86) != a9)
            *(_WORD *)(a1 + 96) = a9;
          result = 0;
          *(_WORD *)(a1 + 98) = a8;
          *(_WORD *)(a1 + 100) = a5;
          *(_WORD *)(a1 + 102) = a4;
          *(_BYTE *)(a1 + 153) = 1;
        }
      }
    }
    else
    {
      return sub_10004C9BC(193, (uint64_t (*)())sub_100216054, v16, v17, v18, v19, v20, v21, a1);
    }
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("Connection handle is invalid.");
      v31 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 1310;
  }
  return result;
}

void sub_100215FE8(uint64_t a1)
{
  NSObject *v2;

  if ((_DWORD)a1 && sub_10005549C())
  {
    sub_100054530("LE Remote Connection Parameter Request Reply HCI command failed with result %!", a1);
    v2 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
}

void sub_100216054(uint64_t a1)
{
  NSObject *v2;

  if ((_DWORD)a1 && sub_10005549C())
  {
    sub_100054530("LE Remote Connection Parameter Request Negative Reply HCI command failed with result %!", a1);
    v2 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
}

uint64_t sub_1002160C0(uint64_t a1, unsigned int a2, unsigned int a3, int a4, int a5, int a6, int a7)
{
  NSObject *v14;
  uint64_t result;
  NSObject *v16;
  NSObject *v17;
  NSObject *v18;
  unint64_t v19;
  unint64_t v20;
  int v21;
  unint64_t v22;
  int v23;
  NSObject *v24;
  void *v25;
  NSObject *v26;
  void *v27;
  unsigned int v28;
  NSObject *v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  NSObject *v38;
  void *v39;
  uint8_t buf[4];
  void *v41;

  if (a1 && sub_10019AC00(a1))
  {
    if (*(_BYTE *)(a1 + 70) == 1)
    {
      if (sub_10005549C())
      {
        sub_100054530("Can't send a connection update as a peripheral.");
        v14 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return 132;
    }
    else if (a2 <= a3 && 10 * a5 >= a3)
    {
      if (sub_10005549C())
      {
        sub_100054530("new connection parameters interval %dms-%dms, timeout=%dms, CE %d-%d latency=%d", (int)((double)a2 * 1.25), (int)((double)a3 * 1.25), 10 * a5, a6, a7, a4);
        v18 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446210;
          v41 = sub_100054494();
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
        }
      }
      if (sub_10005549C())
      {
        LOWORD(v19) = *(_WORD *)(a1 + 90);
        *(double *)&v20 = (double)v19 * 1.25;
        v21 = (int)*(double *)&v20;
        LOWORD(v20) = *(_WORD *)(a1 + 92);
        *(double *)&v22 = (double)v20 * 1.25;
        v23 = (int)*(double *)&v22;
        LOWORD(v22) = *(_WORD *)(a1 + 80);
        sub_100054530("current connection params interval %dms-%dms, timeout=%dms, CE %d-%d latency=%d connectionInterval:%dms", v21, v23, 10 * *(unsigned __int16 *)(a1 + 84), *(unsigned __int16 *)(a1 + 88), *(unsigned __int16 *)(a1 + 86), *(unsigned __int16 *)(a1 + 82), (int)((double)v22 * 1.25));
        v24 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          v25 = sub_100054494();
          *(_DWORD *)buf = 136446210;
          v41 = v25;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
        }
      }
      if (*(_BYTE *)(a1 + 153))
      {
        if (sub_10005549C())
        {
          sub_100054530("Controller connection update pending, saving: interval %dms-%dms, timeout=%dms, CE %d-%d", (int)((double)a2 * 1.25), (int)((double)a3 * 1.25), 10 * a5, a6, a7);
          v26 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
          {
            v27 = sub_100054494();
            *(_DWORD *)buf = 136446210;
            v41 = v27;
            _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
          }
        }
        result = 0;
        *(_WORD *)(a1 + 154) = a2;
        *(_WORD *)(a1 + 156) = a3;
        *(_WORD *)(a1 + 158) = a4;
        *(_WORD *)(a1 + 160) = a5;
        *(_WORD *)(a1 + 162) = a6;
        *(_WORD *)(a1 + 164) = a7;
      }
      else if (*(unsigned __int16 *)(a1 + 88) == a6
             && *(unsigned __int16 *)(a1 + 86) == a7
             && (*(unsigned __int16 *)(a1 + 92) == a3 && *(unsigned __int16 *)(a1 + 90) == a2
              || (v28 = *(unsigned __int16 *)(a1 + 80), v28 >= a2) && v28 <= a3)
             && *(unsigned __int16 *)(a1 + 84) == a5
             && *(unsigned __int16 *)(a1 + 82) == a4)
      {
        if (sub_10005549C())
        {
          sub_100054530("Ignoring request to update parameters since we are already configured for the same values, and current CI is within range");
          v29 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
          {
            v30 = sub_100054494();
            *(_DWORD *)buf = 136446210;
            v41 = v30;
            _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
          }
        }
        return 4170;
      }
      else
      {
        if (sub_10005549C())
        {
          sub_100054530("Sending parameters to controller");
          v38 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
          {
            v39 = sub_100054494();
            *(_DWORD *)buf = 136446210;
            v41 = v39;
            _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
          }
        }
        if (*(unsigned __int16 *)(a1 + 86) != a7)
          *(_WORD *)(a1 + 96) = a7;
        *(_WORD *)(a1 + 98) = a6;
        *(_WORD *)(a1 + 100) = a3;
        *(_WORD *)(a1 + 102) = a2;
        result = sub_100196768(0xB3u, v31, v32, v33, v34, v35, v36, v37, a1);
        if (!(_DWORD)result)
          *(_BYTE *)(a1 + 153) = 1;
      }
    }
    else
    {
      if (sub_10005549C())
      {
        sub_100054530("Max interval should not be lower than min or larger than timeout");
        v17 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return 101;
    }
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("Connection handle is invalid.");
      v16 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 1310;
  }
  return result;
}

uint64_t sub_1002165FC(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5, int a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t result;
  NSObject *v20;
  NSObject *v21;

  if (a1 && sub_10019AC00(a1))
  {
    if (*(_BYTE *)(a1 + 290))
    {
      result = 718;
      if (a2 - 501 >= 0xFFFFFE0C
        && a3 - 501 >= 0xFFFFFE0C
        && a2 <= a3
        && a4 <= 0x1F3
        && a5 <= 0x1F3
        && a5 <= a3
        && (a6 - 3201) >= 0xFFFFF389)
      {
        result = sub_100196768(0xFBu, v12, v13, v14, v15, v16, v17, v18, a1);
        if (!(_DWORD)result)
          *(_BYTE *)(a1 + 153) = 1;
      }
    }
    else
    {
      if (sub_10005549C())
      {
        sub_100054530("Remote device does not support connection subrating.");
        v21 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return 1330;
    }
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("Connection handle is invalid");
      v20 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 1310;
  }
  return result;
}

uint64_t sub_100216754(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_100196768(0x17u, a2, a3, a4, a5, a6, a7, a8, a1);
}

uint64_t sub_100216778(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_100196768(0xB6u, a2, a3, a4, a5, a6, a7, a8, a1);
}

uint64_t sub_10021679C(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  __int128 *v10;

  v10 = sub_10019ACEC(a2);
  *((_WORD *)v10 + 141) = a3;
  *((_WORD *)v10 + 142) = a4;
  *((_WORD *)v10 + 143) = a5;
  *((_WORD *)v10 + 144) = a6;
  return sub_100220A58((uint64_t)v10, a3, a4, a5, a6);
}

void sub_1002167F4(uint64_t a1, int a2, int a3, unsigned __int8 *a4, _DWORD *a5, unsigned int a6, unsigned __int16 a7, unsigned __int16 a8, char a9, __int16 a10, unsigned __int8 a11)
{
  unsigned int v19;
  uint64_t v21;
  BOOL v22;
  char v23;
  BOOL v24;
  char v25;
  NSObject *v26;
  unsigned __int8 *v27;
  unsigned __int16 *v28;
  uint64_t v29;
  NSObject *v30;
  void *v31;
  uint64_t v32;
  unsigned __int16 *v33;
  NSObject *v34;
  int v35;
  int v36;
  void *v37;
  unsigned __int16 *v38;
  unsigned __int16 *v39;
  int v40;
  NSObject *v41;
  unsigned int v42;
  _DWORD *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  NSObject *v51;
  void *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  NSObject *v56;
  float v57;
  NSObject *v58;
  __int128 *v59;
  NSObject *v60;
  NSObject *v61;
  NSObject *v62;
  uint64_t v63;
  char v64;
  char v65;
  _DWORD v66[2];
  uint8_t buf[4];
  void *v68;

  v19 = sub_100049F2C(a1);
  if (v19 == 769 && a1 > 0x64)
    v21 = a1;
  else
    v21 = v19;
  if (byte_10098AAA4)
    v22 = (_DWORD)v21 == 0;
  else
    v22 = 1;
  if (!v22)
  {
    sub_1002145BC(2);
    return;
  }
  v23 = byte_10098AA80;
  memset(v66, 0, 7);
  if (a3)
    v24 = (_DWORD)v21 == 0;
  else
    v24 = 0;
  v25 = v24;
  if (!v24)
  {
    byte_10098AA80 = 0;
    byte_10098AAA4 = 0;
    LOBYTE(qword_10098AA8C) = 0;
    if ((_DWORD)v21)
    {
      switch((int)v21)
      {
        case 702:
        case 712:
          goto LABEL_25;
        case 703:
        case 704:
        case 705:
        case 706:
        case 707:
        case 708:
        case 710:
          goto LABEL_90;
        case 709:
        case 713:
          if (sub_10005549C())
          {
            sub_100054530("LE Connection Complete with result %!. Lets tell the upper layer about this.", a1);
            v26 = sub_1000544A0(0x42u);
            if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
              sub_1006CEEC0();
          }
          sub_10019C9E8();
LABEL_25:
          v27 = a4;
          v28 = 0;
          v29 = v21;
          break;
        case 711:
          v59 = sub_10019ACEC(a2);
          if (v59)
          {
            v28 = (unsigned __int16 *)v59;
            v27 = a4;
          }
          else
          {
            if (sub_10005549C())
            {
              sub_100054530("%s connection with %: failed with result %!", "Outgoing", a4 + 1, 711);
              v60 = sub_1000544A0(0x42u);
              if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
                sub_1006CE7A4();
            }
            v27 = a4;
            v28 = 0;
          }
          v29 = 711;
          break;
        default:
          if ((_DWORD)v21 != 766)
            goto LABEL_90;
          if (sub_10005549C())
          {
            sub_100054530("LE Connection Complete %: failed with result %!", a4 + 1, 766);
            v58 = sub_1000544A0(0x42u);
            if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
              sub_1006CE7A4();
          }
          v27 = a4;
          v28 = 0;
          v29 = 766;
          break;
      }
LABEL_72:
      sub_10021F88C(v27, v28, v29, a11);
      sub_10019C914();
      return;
    }
  }
  v64 = v23;
  if (sub_10019ACEC(a2))
  {
    if (sub_10005549C())
    {
      sub_100054530("We already have that LM handle(%x).... This is bad.", a2);
      v61 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    sub_10019C914();
    sub_100112D60(133);
LABEL_90:
    if (sub_10005549C())
    {
      sub_100054530("Unexpected status %! in LE Connection Complete", a1);
      v62 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    v63 = sub_100112D60(a1);
    sub_100216FB8(v63);
    return;
  }
  if (a5)
  {
    v66[0] = *a5;
    *(_DWORD *)((char *)v66 + 3) = *(_DWORD *)((char *)a5 + 3);
    if (sub_10005549C())
    {
      sub_100054530("Using controller resolved address device %: to %:", a4 + 1, (char *)v66 + 1);
      v30 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        v31 = sub_100054494();
        *(_DWORD *)buf = 136446210;
        v68 = v31;
LABEL_31:
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
  }
  else
  {
    if (*a4 != 1 || (a4[1] & 0xC0) != 0x40 || (v65 = 0, sub_100054280(a4, (uint64_t)v66, &v65)) || !v65)
    {
      v35 = 0;
      v36 = 0;
      goto LABEL_46;
    }
    if (sub_10005549C())
    {
      sub_100054530("Resolved device %: to %:", a4 + 1, (char *)v66 + 1);
      v30 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        v37 = sub_100054494();
        *(_DWORD *)buf = 136446210;
        v68 = v37;
        goto LABEL_31;
      }
    }
  }
  v32 = sub_10019AFA0(v66);
  if (v32)
  {
    v33 = (unsigned __int16 *)v32;
    if (sub_10005549C())
    {
      sub_100054530("%: is already connected (previous handle=%p lmHandle=%x randomAddress=%:)", (char *)v66 + 1, v33, *v33, a4 + 1);
      v34 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    v35 = 1;
    v36 = 1;
  }
  else
  {
    v36 = 0;
    v35 = 1;
  }
LABEL_46:
  v38 = (unsigned __int16 *)sub_10019B6A0((int *)a4);
  if (!v38)
  {
    if (sub_10005549C())
    {
      sub_100054530("Could not create connection for address %:", a4 + 1);
      v41 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return;
  }
  v39 = v38;
  sub_10004AD30((uint64_t)(v38 + 160));
  *v39 = a2;
  *((_BYTE *)v39 + 124) = 3;
  v39[40] = a6;
  v39[41] = a7;
  v39[42] = a8;
  *((_BYTE *)v39 + 118) = a9;
  *((_BYTE *)v39 + 70) = v25;
  *((_QWORD *)v39 + 13) = 0x148001B0148001BLL;
  *((_DWORD *)v39 + 33) = 0;
  *((_QWORD *)v39 + 18) = 0x100000001;
  if ((v64 & 1) != 0)
  {
    v40 = (unsigned __int16)word_10098AAA0;
    v39[43] = word_10098AAA0;
    if (!v40)
      goto LABEL_54;
  }
  else
  {
    LOWORD(v40) = v39[43];
    if (!(_WORD)v40)
    {
LABEL_54:
      LOWORD(v40) = 12;
      v39[43] = 12;
    }
  }
  v42 = 8 * sub_10021597C(27, 27, (unsigned __int16)(625 * v40), 1, 1);
  if (v42)
    v42 = v42 * (0x3E8u / (int)((double)a6 * 1.25)) / 0x3E8;
  *((_DWORD *)v39 + 53) = v42;
  *((_DWORD *)v39 + 54) = sub_10021597C(v39[54], v39[52], (unsigned __int16)(625 * v39[43]), *((_DWORD *)v39 + 36), *((_DWORD *)v39 + 37));
  *((_BYTE *)v39 + 24) = 0;
  *((_DWORD *)v39 + 5) = 0;
  v43 = (_DWORD *)((char *)v39 + 63);
  if (*((_BYTE *)v39 + 70))
  {
    sub_100073B84((uint64_t)v43);
    if (v36)
      goto LABEL_59;
  }
  else
  {
    *v43 = dword_10098AA83;
    *(unsigned __int16 *)((char *)v39 + 67) = word_10098AA87;
    *((_BYTE *)v39 + 69) = byte_10098AA89;
    if (v36)
    {
LABEL_59:
      if (sub_10005549C())
      {
        sub_100054530("Disconnecting duplicate lmHandle=0x%x", *v39);
        v51 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
        {
          v52 = sub_100054494();
          *(_DWORD *)buf = 136446210;
          v68 = v52;
          _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
        }
      }
      *((_BYTE *)v39 + 124) = 0;
      v53 = sub_100196768(5u, v44, v45, v46, v47, v48, v49, v50, (uint64_t)v39);
      v54 = sub_1001A1F70((uint64_t)v39, v53);
      if ((_DWORD)v54)
      {
        v55 = v54;
        if (sub_10005549C())
        {
          sub_100054530("Could not disconnect LE device %!", v55, 19);
          v56 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
      }
      else
      {
        *((_BYTE *)v39 + 124) = 7;
      }
      v27 = (unsigned __int8 *)(v39 + 24);
      v28 = v39;
      v29 = 157;
      goto LABEL_72;
    }
  }
  *((_BYTE *)v39 + 55) = v35;
  if (v35)
  {
    *((_DWORD *)v39 + 14) = v66[0];
    v39[30] = v66[1];
    *((_BYTE *)v39 + 62) = BYTE2(v66[1]);
  }
  sub_10021F88C((unsigned __int8 *)v39 + 48, v39, 0, a11);
  *((_BYTE *)v39 + 124) = 0;
  sub_10019C61C((uint64_t)v39, v57);
}

void sub_100216FB8(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  __int128 *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  NSObject *v14;
  __int16 v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  NSObject *v20;
  unsigned int v21;
  unsigned int v22;
  NSObject *v23;
  float v24;

  v9 = sub_10019ACEC(a2);
  if (v9)
  {
    v10 = (uint64_t)v9;
    *((_WORD *)v9 + 40) = a3;
    *((_WORD *)v9 + 41) = a4;
    *((_WORD *)v9 + 42) = a5;
    *((_BYTE *)v9 + 153) = 0;
    v11 = sub_100049F2C(a1);
    if ((_DWORD)v11)
    {
      v12 = v11;
      if (sub_10005549C())
      {
        sub_100054530("Connection Update Completed with error %!", v12);
        v13 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
          sub_1006CEEC0();
      }
      if ((v12 - 708) > 0x36 || ((1 << (v12 + 60)) & 0x40000004004801) == 0)
        sub_100253460();
    }
    else
    {
      v15 = *(_WORD *)(v10 + 96);
      if (v15)
      {
        *(_WORD *)(v10 + 86) = v15;
        *(_WORD *)(v10 + 96) = 0;
        v16 = *(unsigned __int16 *)(v10 + 104);
        if (v16 <= 0x1B && (v17 = *(unsigned __int16 *)(v10 + 108), v17 < 0x1C))
        {
          v21 = *(unsigned __int16 *)(v10 + 80);
          v22 = 8
              * sub_10021597C(v17, v16, (unsigned __int16)(625 * v15), *(_DWORD *)(v10 + 144), *(_DWORD *)(v10 + 148));
          if (v22)
            v22 = v22 * (0x3E8u / (int)((double)v21 * 1.25)) / 0x3E8;
          *(_DWORD *)(v10 + 212) = v22;
          *(_DWORD *)(v10 + 216) = sub_10021597C(*(unsigned __int16 *)(v10 + 108), *(unsigned __int16 *)(v10 + 104), (unsigned __int16)(625 * *(_WORD *)(v10 + 86)), *(_DWORD *)(v10 + 144), *(_DWORD *)(v10 + 148));
        }
        else
        {
          v18 = sub_10021497C((unsigned __int16 *)v10, 2u);
          if ((_DWORD)v18)
          {
            v19 = v18;
            if ((_DWORD)v18 != 4000)
            {
              if (sub_10005549C())
              {
                sub_100054530("Connection Update Completed with error %!", v19);
                v20 = sub_1000544A0(0x42u);
                if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
                  sub_1006CEEC0();
              }
            }
          }
        }
      }
      if (*(_WORD *)(v10 + 98))
      {
        *(_WORD *)(v10 + 88) = *(_WORD *)(v10 + 98);
        *(_WORD *)(v10 + 98) = 0;
      }
      if (*(_WORD *)(v10 + 100))
      {
        *(_WORD *)(v10 + 92) = *(_WORD *)(v10 + 100);
        *(_WORD *)(v10 + 100) = 0;
      }
      if (*(_WORD *)(v10 + 102))
      {
        *(_WORD *)(v10 + 90) = *(_WORD *)(v10 + 102);
        *(_WORD *)(v10 + 102) = 0;
      }
    }
    if (*(_WORD *)(v10 + 160))
    {
      sub_1002160C0(v10, *(unsigned __int16 *)(v10 + 154), *(unsigned __int16 *)(v10 + 156), *(unsigned __int16 *)(v10 + 158), *(unsigned __int16 *)(v10 + 160), *(unsigned __int16 *)(v10 + 162), *(unsigned __int16 *)(v10 + 164));
      if ((_DWORD)a1 && sub_10005549C())
      {
        sub_100054530("Error executing pending connection update with %!", a1);
        v23 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          sub_1006CEEC0();
      }
      *(_DWORD *)(v10 + 162) = 0;
      *(_QWORD *)(v10 + 154) = 0;
    }
    sub_1002209C0(v10, a3, a4, a5, *(unsigned __int16 *)(v10 + 86));
    sub_10019C61C(v10, v24);
  }
  else if (sub_10005549C())
  {
    sub_100054530("We are not tracking this LM handle...");
    v14 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
}

void sub_1002172A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v9;
  NSObject *v10;

  if (a2)
  {
    if (!sub_10019AC00(a2))
      sub_100253460();
    v9 = *(_DWORD *)(a2 + 204);
    sub_10011D940(*(_WORD *)a2 & 0xFFF);
    sub_1001DC7B0(a2, a3);
    sub_1002207AC(a2, a3, a4, a5);
    if (v9)
    {
      if (!*(_DWORD *)(a2 + 204))
        sub_10019B934((unsigned __int16 *)a2);
    }
    sub_1001111F8(a2);
  }
  else if (sub_10005549C())
  {
    sub_100054530("OI_HCIEventHandler_DisconnectionComplete no connection handle: reason %! ignoring", a3);
    v10 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
}

void sub_10021739C(uint64_t a1, int a2, _QWORD *a3)
{
  __int128 *v6;
  uint64_t v7;
  NSObject *v8;
  NSObject *v9;

  v6 = sub_10019ACEC(a2);
  v7 = (uint64_t)v6;
  if ((_DWORD)a1)
  {
    if (sub_10005549C())
    {
      sub_100054530("Remote used features error: %!", a1);
      v8 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
LABEL_9:
    sub_100220D84(a1, v7, (char *)(v7 + 170));
    return;
  }
  if (a3)
  {
    if (v6)
      goto LABEL_7;
  }
  else
  {
    sub_100253460();
    if (v7)
    {
LABEL_7:
      *(_QWORD *)(v7 + 170) = *a3;
      if (sub_1001F4E24() == 11)
        *(_BYTE *)(v7 + 170) &= ~0x20u;
      goto LABEL_9;
    }
  }
  if (sub_10005549C())
  {
    sub_100054530("Invaid LM handle %x from LE_RemoteUsedFeatures", a2);
    v9 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
}

uint64_t sub_1002174AC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  NSObject *v14;
  uint8_t buf[4];
  void *v17;

  if (!a1 || !sub_10019AC00(a1))
    return 149;
  if (sub_10005549C())
  {
    sub_100054530("Setting Connection Data Length to Tx %d bytes and %d us", a2, a3);
    v12 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v17 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  v13 = sub_10004C9BC(194, (uint64_t (*)())sub_1002175FC, v6, v7, v8, v9, v10, v11, a1);
  if ((_DWORD)v13)
  {
    if (sub_10005549C())
    {
      sub_100054530("Set Data Length failed with status %!", v13, a2, a3);
      v14 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  return v13;
}

void sub_1002175FC(uint64_t a1, unsigned __int16 *a2)
{
  NSObject *v4;

  if ((_DWORD)a1)
  {
    if (sub_10005549C())
    {
      sub_100054530("Write data length complete with %!, triggering changed", a1);
      v4 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    sub_1002177B4(*a2, a2[52], a2[53], a2[54], a2[55]);
  }
}

void sub_100217684(uint64_t a1, int a2, int a3, uint64_t a4)
{
  NSObject *v5;
  int v6;
  int v7;
  void *v8;

  if (a3 && !*(_BYTE *)(a1 + 152))
  {
    v6 = 4;
  }
  else
  {
    if (!a2)
      return;
    if (*(_DWORD *)(a1 + 136) == 1)
    {
      if (!*(_BYTE *)(a1 + 125) || !*(_BYTE *)(a1 + 316))
      {
        sub_10021F4FC(a1, a4);
        return;
      }
      if (sub_10005549C())
      {
        sub_100054530("FastLEConnection:pendingAuth and fastLEConnectEnabled, waiting for encryption started");
        v5 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          v7 = 136446210;
          v8 = sub_100054494();
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, " %{public}s", (uint8_t *)&v7, 0xCu);
        }
      }
      v6 = 5;
    }
    else
    {
      v6 = 3;
    }
  }
  *(_DWORD *)(a1 + 132) = v6;
}

void sub_1002177B4(int a1, int a2, int a3, unsigned int a4, int a5)
{
  __int128 *v10;
  uint64_t v11;
  unsigned int v12;
  const char *v13;
  uint64_t v14;
  const char *v15;
  const char *v16;
  int v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  NSObject *v21;
  NSObject *v22;
  int v23;
  uint8_t buf[4];
  void *v25;

  v10 = sub_10019ACEC(a1);
  if (v10)
  {
    v11 = (uint64_t)v10;
    if (sub_10019AC00((uint64_t)v10))
    {
      v12 = *(unsigned __int16 *)(v11 + 112);
      if (v12 <= a4)
        LOWORD(v12) = a4;
      *(_WORD *)(v11 + 112) = v12;
      if (sub_10005549C())
      {
        v13 = "peripheral";
        if (!*(_BYTE *)(v11 + 70))
          v13 = "central";
        v14 = *(int *)(v11 + 132);
        v15 = "unknown";
        v16 = "unknown";
        if (v14 <= 7)
          v16 = off_10091EFB0[v14];
        v17 = *(_DWORD *)(v11 + 136);
        if (v17 == 1)
          v15 = "complete";
        if (!v17)
          v15 = "idle";
        sub_100054530("Data Length Changed for %s lmhandle %x: Tx [%d -> %d, %d], Rx [%d -> %d, %d], ready-state: %s, mfgrName 0x%x, probe: %s, phy-ready %d", v13, a1, *(unsigned __int16 *)(v11 + 104), a2, a3, *(unsigned __int16 *)(v11 + 108), a4, a5, v16, *(unsigned __int16 *)(v11 + 20), v15, *(unsigned __int8 *)(v11 + 152));
        v18 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446210;
          v25 = sub_100054494();
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
        }
      }
      if (*(unsigned __int16 *)(v11 + 104) != a2
        || *(unsigned __int16 *)(v11 + 106) != a3
        || *(unsigned __int16 *)(v11 + 108) != a4
        || *(unsigned __int16 *)(v11 + 110) != a5)
      {
        *(_WORD *)(v11 + 104) = a2;
        *(_WORD *)(v11 + 106) = a3;
        *(_WORD *)(v11 + 108) = a4;
        *(_WORD *)(v11 + 110) = a5;
        v19 = sub_10021497C((unsigned __int16 *)v11, 3u);
        v20 = v19;
        if (!(_DWORD)v19)
        {
LABEL_31:
          if (*(_DWORD *)(v11 + 132) == 3 && *(_DWORD *)(v11 + 136) == 1)
          {
            if (sub_100182948() && (*(_BYTE *)(v11 + 171) & 1) != 0)
              v23 = sub_100192EC4() ^ 1;
            else
              v23 = 0;
            if (v23 | *(unsigned __int8 *)(v11 + 316))
              sub_100217684(v11, 1, 1, v20);
            else
              sub_10021F4FC(v11, v20);
          }
          return;
        }
        if ((_DWORD)v19 != 4000)
        {
          if (sub_10005549C())
          {
            sub_100054530("Scaling Data Length completed with error %!", v20);
            v22 = sub_1000544A0(0x42u);
            if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
              sub_1006CEEC0();
          }
          goto LABEL_31;
        }
      }
      if (!*(_DWORD *)(v11 + 136))
        sub_100217AA4(v11);
      v20 = 0;
      goto LABEL_31;
    }
  }
  if (sub_10005549C())
  {
    sub_100054530("Invalid LM handle %x", a1);
    v21 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
}

void sub_100217AA4(uint64_t a1)
{
  int v2;
  const char *v3;
  const char *v4;
  NSObject *v5;
  uint8_t buf[4];
  void *v7;

  if (sub_10005549C())
  {
    v2 = *(_DWORD *)(a1 + 136);
    v3 = "unknown";
    if (v2 == 1)
      v3 = "complete";
    if (v2)
      v4 = v3;
    else
      v4 = "idle";
    sub_100054530("Updating Probe-State: %s -> %s", v4, "complete");
    v5 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v7 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  *(_DWORD *)(a1 + 136) = 1;
}

void sub_100217B98(uint64_t a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  NSObject *v8;
  NSObject *v9;
  int v10;
  NSObject *v11;
  uint64_t v12;
  char *v13;
  NSObject *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  NSObject *v19;
  void *v20;
  uint8_t buf[4];
  void *v22;

  v5 = a3;
  if ((a3 - 1) >= 3)
    sub_100253460();
  if ((a4 - 1) >= 3)
    sub_100253460();
  if (a2)
  {
    *((_BYTE *)a2 + 152) = 1;
    if ((_DWORD)a1)
    {
      if (sub_10005549C())
      {
        sub_100054530("Phy update returned status %! and lmhandle 0x%4x", a1, *a2);
        v8 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
          sub_1006CEEC0();
      }
      if ((_DWORD)a1 == 42 || (_DWORD)a1 == 35)
      {
        if (sub_10005549C())
        {
          sub_100054530("Transaction collision occured, default to 1M PHY and continue as success");
          v9 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136446210;
            v22 = sub_100054494();
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
          }
        }
        a1 = 0;
      }
      v5 = 1;
      a4 = 1;
    }
    if ((a2[85] & 0x20) != 0)
      v10 = sub_100182938();
    else
      v10 = 0;
    *((_DWORD *)a2 + 36) = a4;
    *((_DWORD *)a2 + 37) = v5;
    if (sub_10005549C())
    {
      v12 = *((int *)a2 + 33);
      v13 = v12 > 7 ? "unknown" : off_10091EFB0[v12];
      sub_100054530("PhyUpdateComplete: status %!, lmhandle 0x%4x, txPhy 0x%4x, rxPhy 0x%4x, readystate %s", a1, *a2, v5, a4, v13);
      v14 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        v15 = sub_100054494();
        *(_DWORD *)buf = 136446210;
        v22 = v15;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
    if (*((_DWORD *)a2 + 33) == 4)
    {
      v16 = sub_10021497C(a2, 4u);
      if ((_DWORD)v16
        && (v17 = v16, (_DWORD)v16 != 4000)
        && sub_10005549C()
        && (sub_100054530("PhyUpdateComplete LE scaling completed with error %!", v17),
            v18 = sub_1000544A0(0x42u),
            os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)))
      {
        sub_1006CEEC0();
        if (v10)
          goto LABEL_35;
      }
      else if (v10)
      {
LABEL_35:
        sub_100217684((uint64_t)a2, 1, 1, a1);
        return;
      }
      if (*((_BYTE *)a2 + 125) && *((_BYTE *)a2 + 316))
      {
        if (sub_10005549C())
        {
          sub_100054530("FastLEConnection:pendingAuth and fastLEConnectEnabled, waiting for encryption started");
          v19 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            v20 = sub_100054494();
            *(_DWORD *)buf = 136446210;
            v22 = v20;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
          }
        }
        *((_DWORD *)a2 + 33) = 5;
      }
      else
      {
        sub_10021F4FC((uint64_t)a2, a1);
      }
    }
  }
  else if (sub_10005549C())
  {
    sub_100054530("Connection handle invalid for phy update %p, status %!", 0, a1);
    v11 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
}

__n128 sub_100217F24(uint64_t a1, _OWORD *a2)
{
  __int128 v2;
  __int128 v3;
  __n128 result;
  _OWORD v5[5];

  v2 = a2[3];
  v5[2] = a2[2];
  v5[3] = v2;
  v5[4] = a2[4];
  v3 = a2[1];
  v5[0] = *a2;
  v5[1] = v3;
  sub_1002255F4(a1, (unsigned __int16 **)v5);
  return result;
}

void sub_100217F88(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  int v14[2];

  if ((_DWORD)a4)
  {
    v10 = a4;
    v11 = (unint64_t *)a5;
    do
    {
      *(int *)((char *)v14 + 3) = 0;
      v14[0] = 0;
      v12 = *v11++;
      v13 = sub_1000746A4(v12);
      v14[0] = v13;
      BYTE2(v14[1]) = BYTE6(v13);
      LOWORD(v14[1]) = WORD2(v13);
      sub_10023A5A4(v14);
      --v10;
    }
    while (v10);
    if ((byte_10098AA80 & 1) == 0)
      byte_10098AA80 = 1;
  }
  sub_100225A9C(a1, a2, a3, a4, a5);
}

void sub_100218040(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  NSObject *v10;

  if ((_DWORD)a1)
  {
    if (sub_10005549C())
    {
      sub_100054530("LE_ReadRemoteVersionInformationComplete with error %!", a1);
      v10 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  else
  {
    if (!sub_10019AC00(a2))
      sub_100253460();
    *(_BYTE *)(a2 + 24) = a3;
    *(_WORD *)(a2 + 20) = a4;
    *(_WORD *)(a2 + 22) = a5;
  }
  sub_100220AF0(a1, a2, a3, a4, a5);
}

BOOL sub_100218100(unsigned __int16 *a1, int a2, int a3, int a4)
{
  _BOOL8 result;

  result = sub_10019AC00((uint64_t)a1);
  if (result)
    return a1[40] == a2 && a1[44] == a3 && a1[43] == a4;
  return result;
}

uint64_t sub_100218164(_WORD *a1, _WORD *a2, _WORD *a3, _WORD *a4, _WORD *a5, _WORD *a6, _WORD *a7, _WORD *a8)
{
  uint64_t result;

  if (!sub_10019AC00((uint64_t)a1))
    return 101;
  if (a2)
    *a2 = a1[40];
  if (a3)
    *a3 = a1[41];
  if (a4)
    *a4 = a1[44];
  if (a5)
    *a5 = a1[43];
  if (a6)
    *a6 = a1[42];
  if (a7)
    *a7 = a1[45];
  result = 0;
  if (a8)
    *a8 = a1[46];
  return result;
}

uint64_t sub_10021821C()
{
  int v0;
  uint64_t result;
  BOOL v2;

  v0 = (unsigned __int16)word_10097A8B2;
  result = (unsigned __int16)word_10097A8B2;
  if (word_10097A8B2 != word_10097A8B6)
  {
    sub_100253460();
    result = (unsigned __int16)word_10097A8B2;
    v0 = (unsigned __int16)word_10097A8B6;
  }
  if ((_DWORD)result)
    v2 = v0 == 0;
  else
    v2 = 1;
  if (v2)
  {
    sub_100253460();
    return (unsigned __int16)word_10097A8B2;
  }
  return result;
}

uint64_t sub_100218270(int a1, int a2, unsigned int a3, int a4)
{
  const char *v8;
  NSObject *v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v20;
  uint8_t buf[4];
  void *v22;

  if (sub_1001F4E24() == 11)
  {
    word_10097A8B2 = 27;
    word_10097A8B4 = 328;
    word_10097A8B6 = 27;
    word_10097A8B8 = 328;
  }
  if (sub_10005549C())
  {
    v8 = (BYTE4(xmmword_100998F78) & 0x20) != 0 ? "supported" : "not supported";
    sub_100054530("Local EDL %s; TxOctets %d, TxTime %d, RxOctets %d, RxTime %d\n", v8, a1, a2, a3, a4);
    v9 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v22 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if (a1 != a3)
    sub_100253460();
  if ((a1 - 27) >= 0xE1)
    sub_100253460();
  if (a2 != a4)
    sub_100253460();
  word_10097A8B2 = a1;
  word_10097A8B4 = a2;
  word_10097A8B6 = a3;
  word_10097A8B8 = a4;
  if ((BYTE4(xmmword_100998F78) & 0x20) == 0)
    return 0;
  v11 = sub_1002156CC(a3, 0, 0x1D4Cu, 0x1Eu, 0, 1, 1);
  word_10097A8BA = v11;
  v20 = (unsigned __int16)(8 * v11 + 112) & 0xFFF8;
  v10 = sub_10004C9BC(196, (uint64_t (*)())sub_1002184B0, v12, v13, v14, v15, v16, v17, v11);
  if ((_DWORD)v10)
  {
    if (sub_10005549C())
    {
      sub_100054530("Write Suggested default failed with %!", v10, v20);
      v18 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  return v10;
}

void sub_1002184B0(uint64_t a1)
{
  NSObject *v2;

  if ((_DWORD)a1 && sub_10005549C())
  {
    sub_100054530("Write Suggested default failed with %!", a1);
    v2 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
}

uint64_t sub_10021851C(uint64_t result)
{
  byte_10098AA8A = result;
  return result;
}

uint64_t sub_100218528(uint64_t result)
{
  byte_10098AA82 = result;
  return result;
}

uint64_t sub_100218534(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  NSObject *v17;
  uint64_t v18;
  NSObject *v19;
  uint8_t buf[4];
  void *v22;

  if (!a1 || !sub_10019AC00(a1))
    return 149;
  if (sub_10005549C())
  {
    sub_100054530("Set PHY allPhys=%x txPhys=%x rxPhys=%x phyOptions=%x", a2, a3, a4, a5);
    v17 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v22 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  v18 = sub_100196768(0xC8u, v10, v11, v12, v13, v14, v15, v16, a1);
  if ((_DWORD)v18)
  {
    if (sub_10005549C())
    {
      sub_100054530("Set PHY failed with status %!", v18, a2, a3, a4, a5);
      v19 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  return v18;
}

void sub_10021869C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;

  sub_100253320((uint64_t)"LE_Connection:\n", a2, a3, a4, a5, a6, a7, a8, v51);
  sub_100253320((uint64_t)"lConnectionInProgress:%x lCancelConnectionInProgress:%x lRestartConnectionInProgress:%x\n", v8, v9, v10, v11, v12, v13, v14, byte_10098AA80);
  if ((_BYTE)dword_10098AA83)
    v22 = "Random";
  else
    v22 = "Public";
  sub_100253320((uint64_t)"gLocalConnectableAddress.Type:%s gLocalConnectableAddress.address:%:", v15, v16, v17, v18, v19, v20, v21, (uint64_t)v22);
  sub_100253320((uint64_t)"ConnectionInProgressStruct: directed: address:%: scanInterval:%x scanWin:%x connectionInt:%x ConnectionLatency:%x supervisionTO:%x CELen:%x initPHYs:%x advHandle:%x subevent:%x\n", v23, v24, v25, v26, v27, v28, v29, qword_10098AA8C);
  sub_100253320((uint64_t)"Local EDL support: maxTxOctets %d, maxTxTime %d, maxRxOctets %d, maxRxTime %d\n\n", v30, v31, v32, v33, v34, v35, v36, (unsigned __int16)word_10097A8B2);
  sub_100253320((uint64_t)"gEnableExtendedCreateConnectionCommand:%d", v37, v38, v39, v40, v41, v42, v43, byte_10098AA8A);
  sub_100253320((uint64_t)"gEnableExtendedCreateConnectionCommandV2:%d", v44, v45, v46, v47, v48, v49, v50, byte_10098AA82);
}

void sub_1002187DC(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  char v9;

  v8 = a2;
  if (a1)
  {
    v9 = a1;
    sub_100253320((uint64_t)"LE_SetCappedLength for 1M: %d -> %d", a2, a3, a4, a5, a6, a7, a8, byte_10097A8B0);
    byte_10097A8B0 = v9;
  }
  if (v8)
  {
    sub_100253320((uint64_t)"LE_SetCappedLength for 2M: %d -> %d", a2, a3, a4, a5, a6, a7, a8, byte_10097A8B1);
    byte_10097A8B1 = v8;
  }
}

uint64_t sub_100218854(char a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t result;
  char i;
  char v7;
  char *v8;
  uint64_t v9;

  result = 0;
  for (i = 1; ; i = 0)
  {
    v7 = i;
    v8 = (char *)&unk_10098AAB0 + 32 * result;
    if (!v8[2])
      break;
    v9 = *((_QWORD *)v8 + 1);
    if (!v9)
      break;
    if (v9 == a2)
      return result;
    result = 1;
    if ((v7 & 1) == 0)
      return 0xFFFFFFFFLL;
  }
  v8[2] = 1;
  *((_QWORD *)v8 + 1) = a2;
  *((_QWORD *)v8 + 2) = a3;
  v8[1] = a1;
  *((_DWORD *)v8 + 6) = a4;
  return result;
}

uint64_t sub_1002188B8(uint64_t result)
{
  if ((_DWORD)result == 1)
    byte_10098AAD2 = 0;
  return result;
}

uint64_t sub_1002188CC(uint64_t result, __int16 a2, char a3, char a4, char a5, char a6, char a7)
{
  uint64_t v12;
  uint64_t v13;
  char v14;
  char v15;
  char *v16;
  _BYTE *v17;
  int v18;
  uint64_t (*v19)(uint64_t);
  char *v20;
  uint64_t *v21;
  uint64_t v23;

  v12 = result;
  v13 = 0;
  v23 = 0;
  v14 = 1;
  do
  {
    v15 = v14;
    v16 = (char *)&unk_10098AAB0 + 32 * v13;
    v18 = v16[2];
    v17 = v16 + 2;
    if (v18)
    {
      v19 = (uint64_t (*)(uint64_t))*((_QWORD *)&unk_10098AAB0 + 4 * v13 + 1);
      if (v19)
      {
        v20 = (char *)&unk_10098AAB0 + 32 * v13;
        if (*((_QWORD *)v20 + 2))
          v21 = (uint64_t *)*((_QWORD *)v20 + 2);
        else
          v21 = &v23;
        *((_BYTE *)v21 + 3) = a3;
        *(_WORD *)v21 = a2;
        *((_BYTE *)v21 + 2) = v12;
        *((_BYTE *)v21 + 4) = a4;
        *((_BYTE *)v21 + 5) = a5;
        *((_BYTE *)v21 + 6) = a6;
        *((_BYTE *)v21 + 7) = a7;
        result = v19(v12);
        if (v20[1])
          *v17 = 0;
      }
    }
    v14 = 0;
    v13 = 1;
  }
  while ((v15 & 1) != 0);
  return result;
}

void sub_1002189AC(int a1, uint64_t a2, unsigned int a3, __int16 a4, char a5, char a6, char a7, char a8, char a9, char a10, char a11, char a12, __int16 a13, __int16 a14, __int16 a15, __int16 a16, __int16 a17, char a18)
{
  __int128 *v26;
  NSObject *v27;
  __int128 *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  NSObject *v36;

  v26 = sub_10019ACEC(a1);
  if ((_DWORD)a2)
  {
    if (sub_10005549C())
    {
      sub_100054530("CS read remote supported capabilities error: %!", a2);
      v27 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
LABEL_10:
        sub_1006CEEC0();
    }
  }
  else
  {
    v28 = v26;
    if (v26 && sub_10019AC00((uint64_t)v26))
    {
      *((_BYTE *)v28 + 292) = a3;
      *((_WORD *)v28 + 147) = a4;
      *((_BYTE *)v28 + 296) = a5;
      *((_BYTE *)v28 + 297) = a6;
      *((_BYTE *)v28 + 298) = a7;
      *((_BYTE *)v28 + 299) = a8;
      *((_BYTE *)v28 + 300) = a9;
      *((_BYTE *)v28 + 301) = a10;
      *((_BYTE *)v28 + 302) = a11;
      *((_BYTE *)v28 + 303) = a12;
      *((_WORD *)v28 + 152) = a13;
      *((_WORD *)v28 + 153) = a14;
      *((_WORD *)v28 + 154) = a15;
      *((_WORD *)v28 + 155) = a16;
      *((_WORD *)v28 + 156) = a17;
      *((_BYTE *)v28 + 314) = a18;
      sub_100253320((uint64_t)"Channel Sounding numConfigSupported: %d maxProceduresSupported: %d numAntennasSupported: %d rolesSupported: %d modes_Supported: %d rttCapability: %d rttCoarseN: %d rttSoundingN: %d rttRandomPayloadN: %d csSyncPHYsSupported: %d subfeaturesSupported: %d tIP1TimesSupported: %d tIP2TimesSupported: %d tFcsTimesSupported: %d tPMTimesSupported: %d tSWTimesSupported: %d ", v29, v30, v31, v32, v33, v34, v35, a3);
      return;
    }
    if (sub_10005549C())
    {
      sub_100054530("Invaid LM handle %x from CS read remote supported capabilities", a1);
      v36 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
        goto LABEL_10;
    }
  }
}

uint64_t sub_100218B64(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  uint8_t buf[4];
  void *v5;

  v1 = **(unsigned int **)(a1 + 8);
  if (sub_10005549C())
  {
    sub_100054530("_connectionCancelDefer lConnectionInProgress %d, lRestartConnectionInProgress %d, lCancelConnectionInProgress %d lCancelConnectionDeferInProgress %d - %!", byte_10098AA80, byte_10098AAA4, byte_10098AA81, byte_10098AAA8, v1);
    v2 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v5 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  return sub_1002145BC(v1);
}

void sub_100218C58(uint64_t *a1, unsigned __int8 a2)
{
  int v2;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned __int16 v8;
  unsigned __int16 v9;
  int v10;
  unsigned __int16 v11;
  __int16 v13;
  NSObject *v14;
  NSObject *v15;
  NSObject *v16;
  NSObject *v17;
  NSObject *v18;
  NSObject *v19;
  unsigned int v20;
  uint64_t v21;
  unsigned __int16 v22;
  unsigned __int16 v23;
  unsigned __int8 *v24;
  __int16 v25;
  __int16 v26;
  NSObject *v27;
  NSObject *v28;
  NSObject *v29;
  NSObject *v30;
  unsigned __int8 v31;
  int v32;
  __int16 v33;

  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 49, "void LE_HCIEventHandler_ConnectionComplete(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t, _Bool)");
    v2 = 0;
    goto LABEL_14;
  }
  v4 = *((unsigned __int16 *)a1 + 5);
  v5 = *((unsigned __int16 *)a1 + 6);
  v2 = v4 - v5;
  v33 = 0;
  v32 = 0;
  if (v4 - (_DWORD)v5 != 18)
  {
LABEL_14:
    if (sub_10005549C())
    {
      sub_100054530("Invalid connection complete event packet size : %d, expecting %d", v2, 18);
      v15 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return;
  }
  if (*((_BYTE *)a1 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
  if (v4 <= v5)
  {
    *((_BYTE *)a1 + 15) = 1;
    if (!sub_10005549C())
      return;
    sub_100054530("Could not get the status of the LE connection complete event");
    v16 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      return;
LABEL_29:
    sub_1006CE7A4();
    return;
  }
  v6 = *a1;
  *((_WORD *)a1 + 6) = v5 + 1;
  if ((int)(v4 - (v5 + 1)) <= 1)
  {
    *((_BYTE *)a1 + 15) = 1;
    if (!sub_10005549C())
      return;
    sub_100054530("Could not get the connection handle of the LE connection complete event");
    v17 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      return;
    goto LABEL_29;
  }
  v7 = *(unsigned __int8 *)(v6 + v5);
  v8 = *(_WORD *)(v6 + v5 + 1);
  *((_WORD *)a1 + 6) = v5 + 3;
  if (v4 <= (unsigned __int16)(v5 + 3))
  {
    *((_BYTE *)a1 + 15) = 1;
    if (!sub_10005549C())
      return;
    sub_100054530("Could not get the connection role of the LE connection complete event");
    v18 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      return;
    goto LABEL_29;
  }
  v9 = v5 + 4;
  *((_WORD *)a1 + 6) = v5 + 4;
  if (v4 <= (unsigned __int16)(v5 + 4))
  {
    *((_BYTE *)a1 + 15) = 1;
    if (!sub_10005549C())
      return;
    sub_100054530("Could not get the peer address type of the LE connection complete event");
    v19 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      return;
    goto LABEL_29;
  }
  v10 = *(unsigned __int8 *)(v6 + (unsigned __int16)(v5 + 3));
  v11 = v5 + 5;
  *((_WORD *)a1 + 6) = v11;
  v31 = *(_BYTE *)(v6 + v9);
  if ((int)(v4 - v11) <= 5)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
  sub_10004C878((uint64_t)&v32, v6 + v11, 6uLL);
  v13 = *((_WORD *)a1 + 6);
  *((_WORD *)a1 + 6) = v13 + 6;
  if (*((_BYTE *)a1 + 15))
  {
    if (!sub_10005549C())
      return;
    sub_100054530("Could not get the peer address of the LE connection complete event");
    v14 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      return;
    goto LABEL_47;
  }
  if (*((_BYTE *)a1 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
  v20 = *((unsigned __int16 *)a1 + 5);
  if ((int)(v20 - (unsigned __int16)(v13 + 6)) <= 1)
  {
    *((_BYTE *)a1 + 15) = 1;
    if (!sub_10005549C())
      return;
    sub_100054530("Could not get the connection interval of the LE connection complete event");
    v27 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      return;
LABEL_47:
    sub_1006CE7A4();
    return;
  }
  v21 = *a1;
  v22 = *(_WORD *)(*a1 + (unsigned __int16)(v13 + 6));
  *((_WORD *)a1 + 6) = v13 + 8;
  if ((int)(v20 - (unsigned __int16)(v13 + 8)) <= 1)
  {
    *((_BYTE *)a1 + 15) = 1;
    if (!sub_10005549C())
      return;
    sub_100054530("Could not get the connection latency  of the LE connection complete event");
    v28 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      return;
    goto LABEL_47;
  }
  v23 = *(_WORD *)(v21 + (unsigned __int16)(v13 + 8));
  *((_WORD *)a1 + 6) = v13 + 10;
  if ((int)(v20 - (unsigned __int16)(v13 + 10)) <= 1)
  {
    *((_BYTE *)a1 + 15) = 1;
    if (!sub_10005549C())
      return;
    sub_100054530("Could not get the supervision timeout of the LE connection complete event");
    v29 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      return;
    goto LABEL_47;
  }
  v24 = (unsigned __int8 *)(v21 + (unsigned __int16)(v13 + 10));
  v25 = *v24;
  v26 = v24[1];
  *((_WORD *)a1 + 6) = v13 + 12;
  if (v20 > (unsigned __int16)(v13 + 12))
  {
    *((_WORD *)a1 + 6) = v13 + 13;
    sub_1002167F4(v7, v8, v10, &v31, 0, v22, v23, v25 | (v26 << 8), *(_BYTE *)(v21 + (unsigned __int16)(v13 + 12)), 0xFFFF, a2);
    return;
  }
  *((_BYTE *)a1 + 15) = 1;
  if (sub_10005549C())
  {
    sub_100054530("Could not get the central clock accuracy of the LE connection complete event");
    v30 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      goto LABEL_47;
  }
}

void sub_10021914C(uint64_t *a1, char a2)
{
  int v2;
  unsigned int v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  int v8;
  int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __int16 v15;
  uint64_t v16;
  uint64_t v17;
  size_t v18;
  void *v19;
  uint64_t v20;
  int v21;
  BOOL v22;
  _BYTE *v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  char *v27;
  _BYTE *v28;
  char v29;
  uint64_t v30;
  uint64_t v31;
  NSObject *v32;
  NSObject *v33;
  NSObject *v34;
  NSObject *v35;
  NSObject *v36;
  NSObject *v37;
  NSObject *v38;
  NSObject *v39;
  __int128 v40;
  void *ptr[2];
  _OWORD v42[3];

  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 94, "void LE_HCIEventHandler_AdvertisingReport(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t, _Bool)");
    v2 = 0;
LABEL_4:
    if (!sub_10005549C())
      return;
    sub_100054530("Not enough data in the packet : %d, expecting at least %d", v2, 10);
    v6 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      return;
    goto LABEL_6;
  }
  v4 = *((unsigned __int16 *)a1 + 5);
  v5 = *((unsigned __int16 *)a1 + 6);
  v2 = v4 - v5;
  *(_OWORD *)ptr = 0u;
  memset(v42, 0, sizeof(v42));
  v40 = 0u;
  if (v4 - v5 <= 9)
    goto LABEL_4;
  if (*((_BYTE *)a1 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
  if (v4 <= v5)
  {
    *((_BYTE *)a1 + 15) = 1;
    if (!sub_10005549C())
      return;
    sub_100054530("Could not get the number of reports of the LE advertising report event");
    v32 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      return;
LABEL_6:
    sub_1006CE7A4();
    return;
  }
  v7 = *a1;
  *((_WORD *)a1 + 6) = v5 + 1;
  v8 = *(unsigned __int8 *)(v7 + v5);
  BYTE1(ptr[1]) = a2;
  if (!v8)
    return;
  v9 = 0;
  while (1)
  {
    if (*((_BYTE *)a1 + 14) != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    if (*((_BYTE *)a1 + 15))
    {
      sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 111, "void LE_HCIEventHandler_AdvertisingReport(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t, _Bool)");
LABEL_45:
      *((_BYTE *)a1 + 15) = 1;
      if (!sub_10005549C())
        return;
      sub_100054530("Could not get the event type of the LE advertising report event");
      v33 = sub_1000544A0(0x42u);
      if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
        return;
      goto LABEL_67;
    }
    v10 = *((unsigned __int16 *)a1 + 5);
    v11 = *((unsigned __int16 *)a1 + 6);
    if (v10 <= v11)
      goto LABEL_45;
    v12 = *a1;
    v13 = v11 + 1;
    *((_WORD *)a1 + 6) = v11 + 1;
    LOBYTE(v40) = *(_BYTE *)(v12 + v11);
    if (v10 <= (int)v11 + 1)
      break;
    v14 = v11 + 2;
    *((_WORD *)a1 + 6) = v14;
    BYTE1(v40) = *(_BYTE *)(v12 + v13);
    if ((int)(v10 - v14) <= 5)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    sub_10004C878((uint64_t)&v40 + 2, v12 + v14, 6uLL);
    v15 = *((_WORD *)a1 + 6);
    *((_WORD *)a1 + 6) = v15 + 6;
    if (*((_BYTE *)a1 + 15))
    {
      if (!sub_10005549C())
        return;
      sub_100054530("Could not get the address of the LE advertising report event");
      v35 = sub_1000544A0(0x42u);
      if (!os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        return;
      goto LABEL_67;
    }
    if (*((_BYTE *)a1 + 14) != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    if (*((unsigned __int16 *)a1 + 5) <= (unsigned __int16)(v15 + 6))
    {
      *((_BYTE *)a1 + 15) = 1;
      if (!sub_10005549C())
        return;
      sub_100054530("Could not get the dataLength of the LE advertising report event");
      v36 = sub_1000544A0(0x42u);
      if (!os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
        return;
      goto LABEL_67;
    }
    v16 = *a1;
    *((_WORD *)a1 + 6) = v15 + 7;
    v17 = (unsigned __int16)(v15 + 6);
    v18 = *(unsigned __int8 *)(v16 + v17);
    WORD4(v40) = *(unsigned __int8 *)(v16 + v17);
    if (v18 >= 0x20)
    {
      if (!sub_10005549C())
        return;
      sub_100054530("Too many info bytes in the LE advertising report event.");
      v37 = sub_1000544A0(0x42u);
      if (!os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
        return;
      goto LABEL_67;
    }
    v19 = sub_100052DC0(v18);
    ptr[0] = v19;
    v20 = WORD4(v40);
    v21 = *((unsigned __int8 *)a1 + 14);
    if (v19)
      v22 = WORD4(v40) == 0;
    else
      v22 = 1;
    if (!v22)
    {
      if (v21 != 1)
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
      v23 = v19;
      v24 = *a1;
      v25 = *((unsigned __int16 *)a1 + 6);
      if (*((_BYTE *)a1 + 15))
      {
        sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 125, "void LE_HCIEventHandler_AdvertisingReport(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t, _Bool)");
        v26 = 0;
      }
      else
      {
        v26 = *((unsigned __int16 *)a1 + 5) - (_DWORD)v25;
      }
      if (v26 < WORD4(v40))
      {
        *((_BYTE *)a1 + 15) = 1;
LABEL_65:
        if (!sub_10005549C())
          return;
        sub_100054530("Could not get the dataLength of the LE advertising report event");
        v39 = sub_1000544A0(0x42u);
        if (!os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
          return;
LABEL_67:
        sub_1006CE7A4();
        return;
      }
      v27 = (char *)(v24 + v25);
      v28 = &v23[v20];
      do
      {
        v29 = *v27++;
        *v23++ = v29;
      }
      while (v23 < v28);
      *((_WORD *)a1 + 6) += WORD4(v40);
      if (*((_BYTE *)a1 + 15))
        goto LABEL_65;
      v21 = *((unsigned __int8 *)a1 + 14);
    }
    if (v21 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    if (*((_BYTE *)a1 + 15))
    {
      sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 128, "void LE_HCIEventHandler_AdvertisingReport(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t, _Bool)");
LABEL_61:
      *((_BYTE *)a1 + 15) = 1;
      if (!sub_10005549C())
        return;
      sub_100054530("Could not get the rssi of the LE advertising report event");
      v38 = sub_1000544A0(0x42u);
      if (!os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
        return;
      goto LABEL_67;
    }
    v30 = *((unsigned __int16 *)a1 + 6);
    if (*((unsigned __int16 *)a1 + 5) <= v30)
      goto LABEL_61;
    v31 = *a1;
    *((_WORD *)a1 + 6) = v30 + 1;
    LOBYTE(ptr[1]) = *(_BYTE *)(v31 + v30);
    if (BYTE1(v40) >= 2u)
      BYTE1(v40) -= 2;
    BYTE12(v42[0]) = 0;
    *(_DWORD *)((char *)v42 + 15) = 256;
    sub_100053D00((unsigned __int16 *)&v40);
    sub_100053298(ptr[0]);
    if (++v9 == v8)
      return;
  }
  *((_BYTE *)a1 + 15) = 1;
  if (sub_10005549C())
  {
    sub_100054530("Could not get the address type of the LE advertising report event");
    v34 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
      goto LABEL_67;
  }
}

void sub_100219720(uint64_t *a1)
{
  int v1;
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned __int16 v6;
  unsigned __int16 v7;
  unsigned __int8 *v8;
  int v9;
  int v10;
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;
  NSObject *v16;
  NSObject *v17;

  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 160, "void LE_HCIEventHandler_ConnectionUpdateComplete(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v1 = 0;
  }
  else
  {
    v2 = *((unsigned __int16 *)a1 + 5);
    v3 = *((unsigned __int16 *)a1 + 6);
    v1 = v2 - v3;
    if (v2 - (_DWORD)v3 == 9)
    {
      if (*((_BYTE *)a1 + 14) != 1)
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
      if (v2 <= v3)
      {
        *((_BYTE *)a1 + 15) = 1;
        if (sub_10005549C())
        {
          sub_100054530("Could not get the status of the LE connection update event");
          v13 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
            goto LABEL_13;
        }
      }
      else
      {
        v4 = *a1;
        *((_WORD *)a1 + 6) = v3 + 1;
        if ((int)(v2 - (v3 + 1)) <= 1)
        {
          *((_BYTE *)a1 + 15) = 1;
          if (sub_10005549C())
          {
            sub_100054530("Could not get the connection handle of the LE connection update event");
            v14 = sub_1000544A0(0x42u);
            if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
              goto LABEL_13;
          }
        }
        else
        {
          v5 = *(unsigned __int8 *)(v4 + v3);
          v6 = *(_WORD *)(v4 + v3 + 1);
          *((_WORD *)a1 + 6) = v3 + 3;
          if ((int)(v2 - (unsigned __int16)(v3 + 3)) <= 1)
          {
            *((_BYTE *)a1 + 15) = 1;
            if (sub_10005549C())
            {
              sub_100054530("Could not get the connection interval of the LE connection update event");
              v15 = sub_1000544A0(0x42u);
              if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
                goto LABEL_13;
            }
          }
          else
          {
            v7 = *(_WORD *)(v4 + (unsigned __int16)(v3 + 3));
            *((_WORD *)a1 + 6) = v3 + 5;
            if ((int)(v2 - (unsigned __int16)(v3 + 5)) <= 1)
            {
              *((_BYTE *)a1 + 15) = 1;
              if (sub_10005549C())
              {
                sub_100054530("Could not get the connection latency  of the LE connection update event");
                v16 = sub_1000544A0(0x42u);
                if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
                  goto LABEL_13;
              }
            }
            else
            {
              v8 = (unsigned __int8 *)(v4 + (unsigned __int16)(v3 + 5));
              v9 = *v8;
              v10 = v8[1];
              *((_WORD *)a1 + 6) = v3 + 7;
              if ((int)(v2 - (unsigned __int16)(v3 + 7)) > 1)
              {
                v11 = *(unsigned __int16 *)(v4 + (unsigned __int16)(v3 + 7));
                *((_WORD *)a1 + 6) = v3 + 9;
                sub_100216FB8(v5, v6, v7, v9 | (v10 << 8), v11);
                return;
              }
              *((_BYTE *)a1 + 15) = 1;
              if (sub_10005549C())
              {
                sub_100054530("Could not get the supervision timeout of the LE connection update event");
                v17 = sub_1000544A0(0x42u);
                if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
                  goto LABEL_13;
              }
            }
          }
        }
      }
      return;
    }
  }
  if (sub_10005549C())
  {
    sub_100054530("Not enough data in the connection update packet : %d expecting at least %d", v1, 9);
    v12 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
LABEL_13:
      sub_1006CE7A4();
  }
}

void sub_1002199F8(uint64_t *a1)
{
  int v1;
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  unsigned __int16 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  NSObject *v12;
  NSObject *v13;
  uint64_t v14;

  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 194, "void LE_HCIEventHandler_ReadRemoteUsedFeatures(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v1 = 0;
    goto LABEL_11;
  }
  v2 = *((unsigned __int16 *)a1 + 5);
  v3 = *((unsigned __int16 *)a1 + 6);
  v1 = v2 - v3;
  v14 = 0;
  if (v2 - (_DWORD)v3 != 11)
  {
LABEL_11:
    if (sub_10005549C())
    {
      sub_100054530("Not enough data in the feature packet : %d expecting at least %d", v1, 11);
      v10 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return;
  }
  if (*((_BYTE *)a1 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
  if (v2 <= v3)
  {
    *((_BYTE *)a1 + 15) = 1;
    if (!sub_10005549C())
      return;
    sub_100054530("Could not get the status of the read remote used features event");
    v11 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      return;
LABEL_23:
    sub_1006CE7A4();
    return;
  }
  v4 = *a1;
  *((_WORD *)a1 + 6) = v3 + 1;
  if ((int)(v2 - (v3 + 1)) <= 1)
  {
    *((_BYTE *)a1 + 15) = 1;
    if (!sub_10005549C())
      return;
    sub_100054530("Could not get the connection handle of the read remote used features event");
    v12 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      return;
    goto LABEL_23;
  }
  v5 = *(unsigned __int8 *)(v4 + v3);
  v6 = *(_WORD *)(v4 + v3 + 1);
  *((_WORD *)a1 + 6) = v3 + 3;
  if ((int)(v2 - (unsigned __int16)(v3 + 3)) >= 8)
  {
    v7 = 0;
    v8 = v4 + (unsigned __int16)(v3 + 3);
    do
    {
      *((_BYTE *)&v14 + v7) = *(_BYTE *)(v8 + v7);
      ++v7;
    }
    while (v7 != 8);
    *((_WORD *)a1 + 6) = v3 + 11;
    v9 = sub_100049F2C(v5);
    sub_10021739C(v9, v6, &v14);
    return;
  }
  *((_BYTE *)a1 + 15) = 1;
  if (sub_10005549C())
  {
    sub_100054530("Could not get the features of the read remote used features event");
    v13 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      goto LABEL_23;
  }
}

void sub_100219C48(uint64_t *a1)
{
  int v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  unsigned __int16 v5;
  uint64_t i;
  uint64_t v7;
  NSObject *v8;
  NSObject *v9;
  NSObject *v10;
  uint64_t v11;

  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 218, "void LE_HCIEventHandler_LongTermKeyRequest(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v1 = 0;
  }
  else
  {
    v2 = *((unsigned __int16 *)a1 + 5);
    v3 = *((unsigned __int16 *)a1 + 6);
    v1 = v2 - v3;
    v11 = 0;
    if (v2 - (_DWORD)v3 == 12)
    {
      if (*((_BYTE *)a1 + 14) != 1)
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
      v4 = *a1;
      v5 = *(_WORD *)(*a1 + v3);
      *((_WORD *)a1 + 6) = v3 + 2;
      if (v2 - (unsigned __int16)(v3 + 2) < 8)
      {
        *((_BYTE *)a1 + 15) = 1;
        if (sub_10005549C())
        {
          sub_100054530("Could not get the random number of the long term key request event");
          v9 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
            goto LABEL_12;
        }
      }
      else
      {
        for (i = 0; i != 8; ++i)
          *((_BYTE *)&v11 + i) = *(_BYTE *)(v4 + (unsigned __int16)(v3 + 2) + i);
        *((_WORD *)a1 + 6) = v3 + 10;
        if (v2 - (unsigned __int16)(v3 + 10) <= 1)
        {
          *((_BYTE *)a1 + 15) = 1;
          if (sub_10005549C())
          {
            sub_100054530("Could not get the encryption diversifier of the long term key request event");
            v10 = sub_1000544A0(0x42u);
            if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
              sub_1006CE7A4();
          }
        }
        else
        {
          v7 = *(unsigned __int16 *)(v4 + (unsigned __int16)(v3 + 10));
          *((_WORD *)a1 + 6) = v3 + 12;
          sub_10022C16C(v5, &v11, v7);
        }
      }
      return;
    }
  }
  if (sub_10005549C())
  {
    sub_100054530("Not enough data in the long term key request packet : %d expecting at least %d", v1, 12);
    v8 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
LABEL_12:
      sub_1006CE7A4();
  }
}

void sub_100219E44(uint64_t a1)
{
  int v1;
  int v2;
  uint64_t v3;
  int v4;
  NSObject *v5;
  NSObject *v6;

  if (*(_BYTE *)(a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 243, "void LE_HCIEventHandler_RemoteConnectionParameterRequest(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t, _Bool)");
    v1 = 0;
  }
  else
  {
    v2 = *(unsigned __int16 *)(a1 + 10);
    v3 = *(unsigned __int16 *)(a1 + 12);
    v1 = v2 - v3;
    if (v2 - (_DWORD)v3 == 10)
    {
      if (*(_BYTE *)(a1 + 14) != 1)
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
      v4 = *(unsigned __int16 *)(*(_QWORD *)a1 + v3);
      *(_WORD *)(a1 + 12) = v3 + 2;
      if (v2 - (unsigned __int16)(v3 + 2) <= 1)
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
      *(_WORD *)(a1 + 12) = v3 + 4;
      if (v2 - (unsigned __int16)(v3 + 4) <= 1)
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
      *(_WORD *)(a1 + 12) = v3 + 6;
      if (v2 - (unsigned __int16)(v3 + 6) <= 1)
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
      *(_WORD *)(a1 + 12) = v3 + 8;
      if (v2 - (unsigned __int16)(v3 + 8) <= 1)
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
      *(_WORD *)(a1 + 12) = v3 + 10;
      if (sub_10019ACEC(v4))
      {
        sub_100221680();
        return;
      }
      if (sub_10005549C())
      {
        sub_100054530("LE_HCIEventHandler_RemoteConnectionParameterRequest: Invalid connectionHandle for lmHandle 0x%2x", v4);
        v6 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
          goto LABEL_13;
      }
      return;
    }
  }
  if (sub_10005549C())
  {
    sub_100054530("Not enough data in the Remote Connection Parameter Request message: %d expecting at least %d", v1, 10);
    v5 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
LABEL_13:
      sub_1006CE7A4();
  }
}

void sub_10021A094(uint64_t *a1)
{
  int v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  unsigned __int16 v5;
  unsigned __int16 v6;
  unsigned __int16 v7;
  unsigned __int8 *v8;
  int v9;
  int v10;
  int v11;
  NSObject *v12;

  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 277, "void _HCIEventHandler_DataLengthChanged(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v1 = 0;
    goto LABEL_10;
  }
  v2 = *((unsigned __int16 *)a1 + 5);
  v3 = *((unsigned __int16 *)a1 + 6);
  v1 = v2 - v3;
  if (v2 - (_DWORD)v3 != 10)
  {
LABEL_10:
    if (sub_10005549C())
    {
      sub_100054530("Not enough data for data length changed: %d expecting at least %d", v1, 10);
      v12 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return;
  }
  if (*((_BYTE *)a1 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
  v4 = *a1;
  v5 = *(_WORD *)(*a1 + v3);
  *((_WORD *)a1 + 6) = v3 + 2;
  if (v2 - (unsigned __int16)(v3 + 2) <= 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
  v6 = *(_WORD *)(v4 + (unsigned __int16)(v3 + 2));
  *((_WORD *)a1 + 6) = v3 + 4;
  if (v2 - (unsigned __int16)(v3 + 4) <= 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
  v7 = *(_WORD *)(v4 + (unsigned __int16)(v3 + 4));
  *((_WORD *)a1 + 6) = v3 + 6;
  if (v2 - (unsigned __int16)(v3 + 6) <= 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
  v8 = (unsigned __int8 *)(v4 + (unsigned __int16)(v3 + 6));
  v9 = *v8;
  v10 = v8[1];
  *((_WORD *)a1 + 6) = v3 + 8;
  if (v2 - (unsigned __int16)(v3 + 8) <= 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
  v11 = *(unsigned __int16 *)(v4 + (unsigned __int16)(v3 + 8));
  *((_WORD *)a1 + 6) = v3 + 10;
  sub_1002177B4(v5, v6, v7, v9 | (v10 << 8), v11);
}

void sub_10021A260(uint64_t *a1)
{
  int v1;
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned __int16 v6;
  uint64_t v7;
  uint64_t v8;
  __int128 *v9;
  NSObject *v10;

  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 297, "void _HCIEventHandler_PhyUpdateComplete(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v1 = 0;
    goto LABEL_10;
  }
  v2 = *((unsigned __int16 *)a1 + 5);
  v3 = *((unsigned __int16 *)a1 + 6);
  v1 = v2 - v3;
  if (v2 - (_DWORD)v3 != 5)
  {
LABEL_10:
    if (sub_10005549C())
    {
      sub_100054530("Not enough data for phy update complete: %d expecting at least 6", v1);
      v10 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return;
  }
  if (v2 <= v3 || *((_BYTE *)a1 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
  v4 = *a1;
  *((_WORD *)a1 + 6) = v3 + 1;
  if ((int)(v2 - (v3 + 1)) <= 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
  v5 = *(unsigned __int8 *)(v4 + v3);
  v6 = *(_WORD *)(v4 + v3 + 1);
  *((_WORD *)a1 + 6) = v3 + 3;
  if (v2 <= (unsigned __int16)(v3 + 3))
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
  *((_WORD *)a1 + 6) = v3 + 4;
  if (v2 <= (unsigned __int16)(v3 + 4))
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
  v7 = *(unsigned __int8 *)(v4 + (unsigned __int16)(v3 + 3));
  *((_WORD *)a1 + 6) = v3 + 5;
  v8 = *(unsigned __int8 *)(v4 + (unsigned __int16)(v3 + 4));
  v9 = sub_10019ACEC(v6);
  sub_100217B98(v5, (unsigned __int16 *)v9, v7, v8);
}

void sub_10021A414(uint64_t *a1)
{
  int v1;
  unsigned int v2;
  int v3;
  uint64_t v4;
  unsigned int v5;
  NSObject *v6;
  NSObject *v7;
  uint8_t buf[4];
  void *v9;

  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 317, "void _HCIEventHandler_ChannelSelectionAlgorithm(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v1 = 0;
    goto LABEL_11;
  }
  v2 = *((unsigned __int16 *)a1 + 5);
  v3 = *((unsigned __int16 *)a1 + 6);
  v1 = v2 - v3;
  if (v2 - v3 != 3)
  {
LABEL_11:
    if (sub_10005549C())
    {
      sub_100054530("Not enough data for phy update complete: %d expecting at least 3", v1);
      v7 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return;
  }
  if (*((_BYTE *)a1 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
  *((_WORD *)a1 + 6) = v3 + 2;
  if (v2 <= (unsigned __int16)(v3 + 2))
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
  v4 = *a1;
  *((_WORD *)a1 + 6) = v3 + 3;
  v5 = *(unsigned __int8 *)(v4 + (unsigned __int16)(v3 + 2));
  if (v5 >= 2)
    sub_100253460();
  if (sub_10005549C())
  {
    sub_100054530("LE channel Selection algorithm %d", v5);
    v6 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v9 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
}

void sub_10021A5C0(uint64_t *a1)
{
  int v1;
  unsigned int v2;
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;

  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 470, "void _HCIEventHandler_AdvertisingSetTerminated(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v1 = 0;
  }
  else
  {
    v2 = *((unsigned __int16 *)a1 + 5);
    v3 = *((unsigned __int16 *)a1 + 6);
    v1 = v2 - v3;
    if (v2 - v3 > 4)
    {
      if (*((_BYTE *)a1 + 14) != 1)
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
      if (v2 <= v3)
      {
        *((_BYTE *)a1 + 15) = 1;
        if (sub_10005549C())
        {
          sub_100054530("Could not get the status of the LE advertising set terminated event");
          v12 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
            goto LABEL_6;
        }
      }
      else
      {
        v5 = *a1;
        *((_WORD *)a1 + 6) = v3 + 1;
        if (v2 <= (unsigned __int16)(v3 + 1))
        {
          *((_BYTE *)a1 + 15) = 1;
          if (sub_10005549C())
          {
            sub_100054530("Could not get the advertising handle of the LE advertising set terminated event");
            v13 = sub_1000544A0(0x42u);
            if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
              goto LABEL_6;
          }
        }
        else
        {
          v6 = *(unsigned __int8 *)(v5 + v3);
          v7 = v3 + 2;
          *((_WORD *)a1 + 6) = v3 + 2;
          if ((int)(v2 - (v3 + 2)) <= 1)
          {
            *((_BYTE *)a1 + 15) = 1;
            if (sub_10005549C())
            {
              sub_100054530("Could not get the connection handle of the LE advertising set terminated event");
              v14 = sub_1000544A0(0x42u);
              if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
                goto LABEL_6;
            }
          }
          else
          {
            v8 = *(unsigned __int8 *)(v5 + v3 + 1);
            v9 = v5 + v7;
            v10 = *(unsigned __int8 *)(v5 + v7);
            v11 = *(unsigned __int8 *)(v9 + 1);
            *((_WORD *)a1 + 6) = v3 + 4;
            if (v2 > (unsigned __int16)(v3 + 4))
            {
              *((_WORD *)a1 + 6) = v3 + 5;
              sub_10019ACEC(v10 | (v11 << 8));
              nullsub_90(v6, v8);
              return;
            }
            *((_BYTE *)a1 + 15) = 1;
            if (sub_10005549C())
            {
              sub_100054530("Could not get the number of advertising events of the LE advertising set terminated event");
              v15 = sub_1000544A0(0x42u);
              if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
                goto LABEL_6;
            }
          }
        }
      }
      return;
    }
  }
  if (sub_10005549C())
  {
    sub_100054530("Not enough data in the packet : %d, expecting at least %d", v1, 10);
    v4 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
LABEL_6:
      sub_1006CE7A4();
  }
}

void sub_10021A844(int a1, uint64_t *a2, unsigned __int8 a3)
{
  int v6;
  NSObject *v7;
  NSObject *v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int16 v13;
  unsigned __int16 v14;
  int v15;
  unsigned __int16 v16;
  __int16 v17;
  NSObject *v18;
  NSObject *v19;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  int v23;
  unsigned __int16 v24;
  __int16 v25;
  NSObject *v26;
  unsigned int v27;
  uint64_t v28;
  unsigned __int16 v29;
  unsigned __int16 v30;
  unsigned __int16 v31;
  char v32;
  __int16 v33;
  NSObject *v34;
  NSObject *v35;
  NSObject *v36;
  NSObject *v37;
  int v38;
  NSObject *v39;
  unsigned __int8 *v40;
  unsigned __int8 *v41;
  NSObject *v42;
  _DWORD v43[2];
  unsigned __int8 v44[8];

  if (*((_BYTE *)a2 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 630, "void _HCIEventHandler_EnhancedConnectionComplete(uint8_t, OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t, _Bool)");
    v6 = 0;
  }
  else
  {
    v6 = *((unsigned __int16 *)a2 + 5) - *((unsigned __int16 *)a2 + 6);
  }
  *(_DWORD *)&v44[3] = 0;
  *(_DWORD *)v44 = 0;
  *(_DWORD *)((char *)v43 + 3) = 0;
  v43[0] = 0;
  if (a1 != 1 || v6 == 30)
  {
    if (a1 == 2 && v6 != 33)
    {
      if (sub_10005549C())
      {
        sub_100054530("Invalid enhanced connection complete V2 event packet size : %d, expecting %d", v6, 33);
        v8 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
          goto LABEL_38;
      }
      return;
    }
    if (*((_BYTE *)a2 + 14) != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    if (*((_BYTE *)a2 + 15))
    {
      sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 654, "void _HCIEventHandler_EnhancedConnectionComplete(uint8_t, OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t, _Bool)");
LABEL_26:
      *((_BYTE *)a2 + 15) = 1;
      if (sub_10005549C())
      {
        sub_100054530("Could not get the status of the LE enhanced connection complete event");
        v19 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return;
    }
    v9 = *((unsigned __int16 *)a2 + 5);
    v10 = *((unsigned __int16 *)a2 + 6);
    if (v9 <= v10)
      goto LABEL_26;
    v11 = *a2;
    *((_WORD *)a2 + 6) = v10 + 1;
    if ((int)(v9 - (v10 + 1)) <= 1)
    {
      *((_BYTE *)a2 + 15) = 1;
      if (sub_10005549C())
      {
        sub_100054530("Could not get the connection handle of the LE enhanced connection complete event");
        v20 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          goto LABEL_38;
      }
      return;
    }
    v12 = *(unsigned __int8 *)(v11 + v10);
    v13 = *(_WORD *)(v11 + v10 + 1);
    *((_WORD *)a2 + 6) = v10 + 3;
    if (v9 <= (unsigned __int16)(v10 + 3))
    {
      *((_BYTE *)a2 + 15) = 1;
      if (sub_10005549C())
      {
        sub_100054530("Could not get the connection role of the LE enhanced connection complete event");
        v21 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          goto LABEL_38;
      }
      return;
    }
    v14 = v10 + 4;
    *((_WORD *)a2 + 6) = v10 + 4;
    if (v9 <= (unsigned __int16)(v10 + 4))
    {
      *((_BYTE *)a2 + 15) = 1;
      if (sub_10005549C())
      {
        sub_100054530("Could not get the peer address type of the LE enhanced connection complete event");
        v22 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          goto LABEL_38;
      }
      return;
    }
    v15 = *(unsigned __int8 *)(v11 + (unsigned __int16)(v10 + 3));
    v16 = v10 + 5;
    *((_WORD *)a2 + 6) = v16;
    v44[0] = *(_BYTE *)(v11 + v14);
    if ((int)(v9 - v16) <= 5)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    sub_10004C878((uint64_t)&v44[1], v11 + v16, 6uLL);
    v17 = *((_WORD *)a2 + 6);
    *((_WORD *)a2 + 6) = v17 + 6;
    if (*((_BYTE *)a2 + 15))
    {
      if (sub_10005549C())
      {
        sub_100054530("Could not get the peer address of the LE enhanced connection complete event");
        v18 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return;
    }
    v23 = *((unsigned __int16 *)a2 + 5);
    if (v23 - (unsigned __int16)(v17 + 6) <= 5)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    v24 = v17 + 12;
    *((_WORD *)a2 + 6) = v24;
    if (v23 - v24 <= 5 || *((_BYTE *)a2 + 14) != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    sub_10004C878((uint64_t)v43 + 1, *a2 + v24, 6uLL);
    v25 = *((_WORD *)a2 + 6);
    *((_WORD *)a2 + 6) = v25 + 6;
    if (*((_BYTE *)a2 + 15))
    {
      if (!sub_10005549C())
        return;
      sub_100054530("Could not get the peer address of the LE enhanced connection complete event");
      v26 = sub_1000544A0(0x42u);
      if (!os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        return;
      goto LABEL_84;
    }
    LOBYTE(v43[0]) = 1;
    if (*((_BYTE *)a2 + 14) != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    v27 = *((unsigned __int16 *)a2 + 5);
    if ((int)(v27 - (unsigned __int16)(v25 + 6)) <= 1)
    {
      *((_BYTE *)a2 + 15) = 1;
      if (!sub_10005549C())
        return;
      sub_100054530("Could not get the connection interval of the LE enhanced connection complete event");
      v34 = sub_1000544A0(0x42u);
      if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        return;
    }
    else
    {
      v28 = *a2;
      v29 = *(_WORD *)(*a2 + (unsigned __int16)(v25 + 6));
      *((_WORD *)a2 + 6) = v25 + 8;
      if ((int)(v27 - (unsigned __int16)(v25 + 8)) <= 1)
      {
        *((_BYTE *)a2 + 15) = 1;
        if (!sub_10005549C())
          return;
        sub_100054530("Could not get the connection latency  of the LE enhanced connection complete event");
        v35 = sub_1000544A0(0x42u);
        if (!os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
          return;
      }
      else
      {
        v30 = *(_WORD *)(v28 + (unsigned __int16)(v25 + 8));
        *((_WORD *)a2 + 6) = v25 + 10;
        if ((int)(v27 - (unsigned __int16)(v25 + 10)) <= 1)
        {
          *((_BYTE *)a2 + 15) = 1;
          if (!sub_10005549C())
            return;
          sub_100054530("Could not get the supervision timeout of the LE enhanced connection complete event");
          v36 = sub_1000544A0(0x42u);
          if (!os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
            return;
        }
        else
        {
          v31 = *(_WORD *)(v28 + (unsigned __int16)(v25 + 10));
          *((_WORD *)a2 + 6) = v25 + 12;
          if (v27 <= (unsigned __int16)(v25 + 12))
          {
            *((_BYTE *)a2 + 15) = 1;
            if (!sub_10005549C())
              return;
            sub_100054530("Could not get the central clock accuracy of the LE enhanced connection complete event");
            v37 = sub_1000544A0(0x42u);
            if (!os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
              return;
          }
          else
          {
            *((_WORD *)a2 + 6) = v25 + 13;
            v32 = *(_BYTE *)(v28 + (unsigned __int16)(v25 + 12));
            if (a1 != 2)
            {
              v33 = -1;
              goto LABEL_68;
            }
            if (v27 <= (unsigned __int16)(v25 + 13))
            {
              *((_BYTE *)a2 + 15) = 1;
              if (!sub_10005549C())
                return;
              sub_100054530("Could not get the advertising handle of the LE enhanced connection complete V2 event");
              v39 = sub_1000544A0(0x42u);
              if (!os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
                return;
            }
            else
            {
              *((_WORD *)a2 + 6) = v25 + 14;
              if ((int)(v27 - (unsigned __int16)(v25 + 14)) >= 2)
              {
                v33 = *(_WORD *)(v28 + (unsigned __int16)(v25 + 14));
                *((_WORD *)a2 + 6) = v25 + 16;
LABEL_68:
                v38 = v44[0] & 0xFE;
                if (v44[0] == 3)
                {
                  v44[0] = 1;
                }
                else if (v44[0] == 2)
                {
                  v44[0] = 0;
                }
                if (v38 == 2)
                  v40 = (unsigned __int8 *)v43;
                else
                  v40 = v44;
                if (v38 == 2)
                  v41 = v44;
                else
                  v41 = 0;
                sub_1002167F4(v12, v13, v15, v40, v41, v29, v30, v31, v32, v33, a3);
                return;
              }
              *((_BYTE *)a2 + 15) = 1;
              if (!sub_10005549C())
                return;
              sub_100054530("Could not get the sync handle of the LE enhanced connection complete V2 event");
              v42 = sub_1000544A0(0x42u);
              if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
                return;
            }
          }
        }
      }
    }
LABEL_84:
    sub_1006CE7A4();
    return;
  }
  if (sub_10005549C())
  {
    sub_100054530("Invalid enhanced connection complete event packet size : %d, expecting %d", v6, 30);
    v7 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
LABEL_38:
      sub_1006CE7A4();
  }
}

void sub_10021AFB8(int a1, uint64_t *a2)
{
  int v4;
  NSObject *v5;
  NSObject *v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unsigned __int16 v11;
  unsigned __int16 v12;
  __int16 v13;
  NSObject *v14;
  NSObject *v15;
  NSObject *v16;
  NSObject *v17;
  NSObject *v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  NSObject *v25;
  NSObject *v26;
  NSObject *v27;
  NSObject *v28;
  _QWORD v29[3];

  if (*((_BYTE *)a2 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 728, "void _HCIEventHandler_PeriodicAdvSyncEstablished(uint8_t, OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v4 = 0;
  }
  else
  {
    v4 = *((unsigned __int16 *)a2 + 5) - *((unsigned __int16 *)a2 + 6);
  }
  memset(v29, 0, 20);
  if (a1 != 1 || v4 == 15)
  {
    if (a1 == 2 && v4 != 19)
    {
      if (sub_10005549C())
      {
        sub_100054530("Invalid periodic advertising sync established V2 event packet size : %d, expecting %d", v4, 19);
        v6 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
          goto LABEL_38;
      }
      return;
    }
    if (*((_BYTE *)a2 + 14) != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    if (*((_BYTE *)a2 + 15))
    {
      sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 737, "void _HCIEventHandler_PeriodicAdvSyncEstablished(uint8_t, OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
LABEL_26:
      *((_BYTE *)a2 + 15) = 1;
      if (sub_10005549C())
      {
        sub_100054530("Could not get the status of the LE periodic advertising sync established event");
        v15 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return;
    }
    v7 = *((unsigned __int16 *)a2 + 5);
    v8 = *((unsigned __int16 *)a2 + 6);
    if (v7 <= v8)
      goto LABEL_26;
    v9 = *a2;
    *((_WORD *)a2 + 6) = v8 + 1;
    if ((int)(v7 - (v8 + 1)) <= 1)
    {
      *((_BYTE *)a2 + 15) = 1;
      if (sub_10005549C())
      {
        sub_100054530("Could not get the sync handle of the LE periodic advertising sync established event");
        v16 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          goto LABEL_38;
      }
      return;
    }
    v10 = *(unsigned __int8 *)(v9 + v8);
    LOWORD(v29[0]) = *(_WORD *)(v9 + v8 + 1);
    *((_WORD *)a2 + 6) = v8 + 3;
    if (v7 <= (unsigned __int16)(v8 + 3))
    {
      *((_BYTE *)a2 + 15) = 1;
      if (sub_10005549C())
      {
        sub_100054530("Could not get the SID of the LE periodic advertising sync established event");
        v17 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          goto LABEL_38;
      }
      return;
    }
    v11 = v8 + 4;
    *((_WORD *)a2 + 6) = v8 + 4;
    BYTE2(v29[0]) = *(_BYTE *)(v9 + (unsigned __int16)(v8 + 3));
    if (v7 <= (unsigned __int16)(v8 + 4))
    {
      *((_BYTE *)a2 + 15) = 1;
      if (sub_10005549C())
      {
        sub_100054530("Could not get the advertiser address type of the LE periodic advertising sync established event");
        v18 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          goto LABEL_38;
      }
      return;
    }
    v12 = v8 + 5;
    *((_WORD *)a2 + 6) = v12;
    BYTE3(v29[0]) = *(_BYTE *)(v9 + v11);
    if ((int)(v7 - v12) <= 5)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    sub_10004C878((uint64_t)v29 + 4, v9 + v12, 6uLL);
    v13 = *((_WORD *)a2 + 6);
    *((_WORD *)a2 + 6) = v13 + 6;
    if (*((_BYTE *)a2 + 15))
    {
      if (!sub_10005549C())
        return;
      sub_100054530("Could not get the advertiser address of the LE periodic advertising sync established event");
      v14 = sub_1000544A0(0x42u);
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        return;
      goto LABEL_70;
    }
    if (*((_BYTE *)a2 + 14) != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    v19 = *((unsigned __int16 *)a2 + 5);
    if (v19 <= (unsigned __int16)(v13 + 6))
    {
      *((_BYTE *)a2 + 15) = 1;
      if (!sub_10005549C())
        return;
      sub_100054530("Could not get the PHY of the LE periodic advertising sync established event");
      v22 = sub_1000544A0(0x42u);
      if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        return;
    }
    else
    {
      v20 = *a2;
      *((_WORD *)a2 + 6) = v13 + 7;
      BYTE2(v29[1]) = *(_BYTE *)(v20 + (unsigned __int16)(v13 + 6));
      if ((int)(v19 - (unsigned __int16)(v13 + 7)) <= 1)
      {
        *((_BYTE *)a2 + 15) = 1;
        if (!sub_10005549C())
          return;
        sub_100054530("Could not get the periodic advertsing interval of the LE periodic advertising sync established event");
        v23 = sub_1000544A0(0x42u);
        if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          return;
      }
      else
      {
        WORD2(v29[1]) = *(_WORD *)(v20 + (unsigned __int16)(v13 + 7));
        *((_WORD *)a2 + 6) = v13 + 9;
        if (v19 <= (unsigned __int16)(v13 + 9))
        {
          *((_BYTE *)a2 + 15) = 1;
          if (!sub_10005549C())
            return;
          sub_100054530("Could not get the central clock accuracy of the LE periodic advertising sync established event");
          v24 = sub_1000544A0(0x42u);
          if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
            return;
        }
        else
        {
          *((_WORD *)a2 + 6) = v13 + 10;
          BYTE6(v29[1]) = *(_BYTE *)(v20 + (unsigned __int16)(v13 + 9));
          *(_DWORD *)((char *)&v29[1] + 7) = 0;
          if (a1 != 2)
          {
LABEL_49:
            v21 = sub_100049F2C(v10);
            sub_100111250((uint64_t)v29, v21);
            return;
          }
          if (v19 <= (unsigned __int16)(v13 + 10))
          {
            *((_BYTE *)a2 + 15) = 1;
            if (!sub_10005549C())
              return;
            sub_100054530("Could not get Number_Subevents of LE periodic advertising sync transfer received event");
            v25 = sub_1000544A0(0x42u);
            if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
              return;
          }
          else
          {
            *((_WORD *)a2 + 6) = v13 + 11;
            HIBYTE(v29[1]) = *(_BYTE *)(v20 + (unsigned __int16)(v13 + 10));
            if (v19 <= (unsigned __int16)(v13 + 11))
            {
              *((_BYTE *)a2 + 15) = 1;
              if (!sub_10005549C())
                return;
              sub_100054530("Could not get Subevent_Interval of LE periodic advertising sync transfer received event");
              v26 = sub_1000544A0(0x42u);
              if (!os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
                return;
            }
            else
            {
              *((_WORD *)a2 + 6) = v13 + 12;
              LOBYTE(v29[2]) = *(_BYTE *)(v20 + (unsigned __int16)(v13 + 11));
              if (v19 <= (unsigned __int16)(v13 + 12))
              {
                *((_BYTE *)a2 + 15) = 1;
                if (!sub_10005549C())
                  return;
                sub_100054530("Could not get Response_Slot_Delay of LE periodic advertising sync transfer received event");
                v27 = sub_1000544A0(0x42u);
                if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
                  return;
              }
              else
              {
                *((_WORD *)a2 + 6) = v13 + 13;
                BYTE1(v29[2]) = *(_BYTE *)(v20 + (unsigned __int16)(v13 + 12));
                if (v19 > (unsigned __int16)(v13 + 13))
                {
                  *((_WORD *)a2 + 6) = v13 + 14;
                  BYTE2(v29[2]) = *(_BYTE *)(v20 + (unsigned __int16)(v13 + 13));
                  goto LABEL_49;
                }
                *((_BYTE *)a2 + 15) = 1;
                if (!sub_10005549C())
                  return;
                sub_100054530("Could not get Response_Slot_Spacing of LE periodic advertising sync transfer received event");
                v28 = sub_1000544A0(0x42u);
                if (!os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
                  return;
              }
            }
          }
        }
      }
    }
LABEL_70:
    sub_1006CE7A4();
    return;
  }
  if (sub_10005549C())
  {
    sub_100054530("Invalid periodic advertising sync established event packet size : %d, expecting %d", v4, 15);
    v5 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
LABEL_38:
      sub_1006CE7A4();
  }
}

void sub_10021B64C(int a1, uint64_t *a2)
{
  unsigned int v4;
  NSObject *v5;
  NSObject *v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int16 v10;
  char v11;
  char v12;
  unsigned __int16 v13;
  char v14;
  unsigned __int8 *v15;
  __int16 v16;
  __int16 v17;
  unsigned __int16 v18;
  __int16 v19;
  unsigned __int16 v20;
  char v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  NSObject *v25;
  uint64_t v26;
  char v27;
  uint64_t v28;
  NSObject *v29;
  NSObject *v30;
  NSObject *v31;
  NSObject *v32;
  NSObject *v33;
  _BYTE *v34;
  _BYTE *v35;
  int v36;
  NSObject *v37;
  uint64_t v38;
  NSObject *v39;
  uint64_t v40;
  uint64_t v41;
  unsigned __int16 v42;
  char v43;
  char v44;
  char v45;
  char v46;
  __int16 v47;
  char v48;
  char v49;
  char v50;
  int v51;
  char v52;
  _BYTE *v53;

  if (*((_BYTE *)a2 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 785, "void _HCIEventHandler_PeriodicAdvReport(uint8_t, OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v4 = 0;
  }
  else
  {
    v4 = *((unsigned __int16 *)a2 + 5) - *((unsigned __int16 *)a2 + 6);
  }
  if (a1 != 1 || v4 > 6)
  {
    if (a1 == 2 && v4 <= 9)
    {
      if (sub_10005549C())
      {
        sub_100054530("Invalid periodic advertising report V2 event packet size : %d, expecting at least %d", v4, 10);
        v6 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
          goto LABEL_56;
      }
      return;
    }
    if (*((_BYTE *)a2 + 14) != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    if (*((_BYTE *)a2 + 15))
    {
      sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 793, "void _HCIEventHandler_PeriodicAdvReport(uint8_t, OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
LABEL_25:
      *((_BYTE *)a2 + 15) = 1;
      if (sub_10005549C())
      {
        sub_100054530("Could not get the sync handle of the LE periodic advertising report event");
        v22 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return;
    }
    v7 = *((unsigned __int16 *)a2 + 5);
    v8 = *((unsigned __int16 *)a2 + 6);
    if ((int)(v7 - v8) <= 1)
      goto LABEL_25;
    v9 = *a2;
    v10 = *(_WORD *)(*a2 + v8);
    *((_WORD *)a2 + 6) = v8 + 2;
    if (v7 <= (unsigned __int16)(v8 + 2))
    {
      *((_BYTE *)a2 + 15) = 1;
      if (sub_10005549C())
      {
        sub_100054530("Could not get the TX power of the LE periodic advertising report event");
        v23 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          goto LABEL_56;
      }
      return;
    }
    *((_WORD *)a2 + 6) = v8 + 3;
    if (v7 <= (unsigned __int16)(v8 + 3))
    {
      *((_BYTE *)a2 + 15) = 1;
      if (sub_10005549C())
      {
        sub_100054530("Could not get the RSSI of the LE periodic advertising report event");
        v24 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          goto LABEL_56;
      }
      return;
    }
    v11 = *(_BYTE *)(v9 + (unsigned __int16)(v8 + 2));
    *((_WORD *)a2 + 6) = v8 + 4;
    if (v7 <= (unsigned __int16)(v8 + 4))
    {
      *((_BYTE *)a2 + 15) = 1;
      if (sub_10005549C())
      {
        sub_100054530("Could not get the CTE Type of the LE periodic advertising report event");
        v25 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          goto LABEL_56;
      }
      return;
    }
    v12 = *(_BYTE *)(v9 + (unsigned __int16)(v8 + 3));
    v13 = v8 + 5;
    *((_WORD *)a2 + 6) = v8 + 5;
    v14 = *(_BYTE *)(v9 + (unsigned __int16)(v8 + 4));
    if (a1 == 2)
    {
      if ((int)(v7 - v13) <= 1)
      {
        *((_BYTE *)a2 + 15) = 1;
        if (sub_10005549C())
        {
          sub_100054530("Could not get the periodic event counter of the LE periodic advertising report event");
          v31 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
            goto LABEL_56;
        }
        return;
      }
      v15 = (unsigned __int8 *)(v9 + v13);
      v16 = *v15;
      v17 = v15[1];
      v18 = v8 + 7;
      *((_WORD *)a2 + 6) = v8 + 7;
      if (v7 <= (unsigned __int16)(v8 + 7))
      {
        *((_BYTE *)a2 + 15) = 1;
        if (sub_10005549C())
        {
          sub_100054530("Could not get the subevent of the LE periodic advertising report event");
          v33 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
            goto LABEL_56;
        }
        return;
      }
      v19 = v16 | (v17 << 8);
      v20 = v8 + 8;
      *((_WORD *)a2 + 6) = v20;
      v21 = *(_BYTE *)(v9 + v18);
    }
    else
    {
      v19 = 0;
      v21 = 0;
      v20 = v8 + 5;
    }
    if (v7 <= v20)
    {
      *((_BYTE *)a2 + 15) = 1;
      if (sub_10005549C())
      {
        sub_100054530("Could not get the data status of the LE periodic advertising report event");
        v30 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
          goto LABEL_56;
      }
      return;
    }
    v26 = v20 + 1;
    *((_WORD *)a2 + 6) = v20 + 1;
    if (v7 <= (unsigned __int16)(v20 + 1))
    {
      *((_BYTE *)a2 + 15) = 1;
      if (sub_10005549C())
      {
        sub_100054530("Could not get the data length of the LE periodic advertising report event");
        v32 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
          goto LABEL_56;
      }
      return;
    }
    v27 = *(_BYTE *)(v9 + v20);
    *((_WORD *)a2 + 6) = v20 + 2;
    v28 = *(unsigned __int8 *)(v9 + v26);
    if (v28 >= 0xF8)
    {
      if (sub_10005549C())
      {
        sub_100054530("Too many data bytes in the LE extended advertising report event.");
        v29 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
          goto LABEL_56;
      }
      return;
    }
    if (*(_BYTE *)(v9 + v26))
    {
      v34 = sub_100052DC0(*(unsigned __int8 *)(v9 + v26));
      if (v34)
      {
        if (*((_BYTE *)a2 + 14) != 1)
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
        v35 = v34;
        v40 = *((unsigned __int16 *)a2 + 6);
        v41 = *a2;
        if (*((_BYTE *)a2 + 15))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 820, "void _HCIEventHandler_PeriodicAdvReport(uint8_t, OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
          v36 = 0;
        }
        else
        {
          v36 = *((unsigned __int16 *)a2 + 5) - *((unsigned __int16 *)a2 + 6);
        }
        if (v36 < (int)v28)
        {
          *((_BYTE *)a2 + 15) = 1;
          goto LABEL_74;
        }
        v38 = 0;
        do
        {
          v35[v38] = *(_BYTE *)(v41 + v40 + v38);
          ++v38;
        }
        while (&v35[v38] < &v35[v28]);
        *((_WORD *)a2 + 6) += v28;
        if (*((_BYTE *)a2 + 15))
        {
LABEL_74:
          if (sub_10005549C())
          {
            sub_100054530("Could not get the data of the LE periodic advertising report event");
            v39 = sub_1000544A0(0x42u);
            if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
              sub_1006CE7A4();
          }
          goto LABEL_77;
        }
LABEL_66:
        v42 = v10;
        v43 = v11;
        v44 = v12;
        v45 = v14;
        v46 = 0;
        v47 = v19;
        v48 = v21;
        v49 = v27;
        v50 = v28;
        v51 = 0;
        v52 = 0;
        v53 = v35;
        sub_100111858(&v42);
        if (!v35)
          return;
LABEL_77:
        sub_100053298(v35);
        return;
      }
      if (sub_10005549C())
      {
        sub_100054530("Could not allocate memory for the LE periodic advertising report event");
        v37 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
    }
    v35 = 0;
    goto LABEL_66;
  }
  if (sub_10005549C())
  {
    sub_100054530("Invalid periodic advertising report event packet size : %d, expecting at least %d", v4, 7);
    v5 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
LABEL_56:
      sub_1006CE7A4();
  }
}

void sub_10021BCC8(uint64_t a1)
{
  int v1;
  uint64_t v2;
  __int16 v3;
  int v4;
  NSObject *v5;

  if (*(_BYTE *)(a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 845, "void _HCIEventHandler_PeriodicAdvSyncLost(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v1 = 0;
    goto LABEL_6;
  }
  v2 = *(unsigned __int16 *)(a1 + 12);
  v1 = *(unsigned __int16 *)(a1 + 10) - (_DWORD)v2;
  if (v1 != 2)
  {
LABEL_6:
    if (sub_10005549C())
    {
      sub_100054530("Invalid periodic advertising sync established event packet size : %d, expecting %d", v1, 2);
      v5 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return;
  }
  if (*(_BYTE *)(a1 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
  v3 = v2 + 2;
  v4 = *(unsigned __int16 *)(*(_QWORD *)a1 + v2);
  *(_WORD *)(a1 + 12) = v3;
  sub_1001117EC(v4);
}

void sub_10021BDB4(int a1, uint64_t *a2)
{
  int v4;
  NSObject *v5;
  NSObject *v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unsigned __int16 v11;
  __int16 v12;
  __int16 v13;
  unsigned __int16 v14;
  char v15;
  unsigned __int16 v16;
  __int16 v17;
  NSObject *v18;
  NSObject *v19;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  unsigned int v25;
  uint64_t v26;
  int v27;
  __int16 v28;
  char v29;
  char v30;
  char v31;
  NSObject *v32;
  NSObject *v33;
  NSObject *v34;
  __int128 *v35;
  uint64_t v36;
  NSObject *v37;
  NSObject *v38;
  NSObject *v39;
  NSObject *v40;
  char v41;
  char v42;
  int v43;
  int v44[2];

  if (*((_BYTE *)a2 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 860, "void _HCIEventHandler_PeriodicAdvertisingSyncTransferReceived(uint8_t, OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v4 = 0;
  }
  else
  {
    v4 = *((unsigned __int16 *)a2 + 5) - *((unsigned __int16 *)a2 + 6);
  }
  *(int *)((char *)v44 + 3) = 0;
  v44[0] = 0;
  if (a1 != 1 || v4 == 19)
  {
    if (a1 == 1 && v4 != 23)
    {
      if (sub_10005549C())
      {
        sub_100054530("Invalid periodic advertising sync transfer received event packet size : %d, expecting ", v4);
        v6 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
          goto LABEL_46;
      }
      return;
    }
    if (*((_BYTE *)a2 + 14) != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    if (*((_BYTE *)a2 + 15))
    {
      sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 883, "void _HCIEventHandler_PeriodicAdvertisingSyncTransferReceived(uint8_t, OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
LABEL_28:
      *((_BYTE *)a2 + 15) = 1;
      if (sub_10005549C())
      {
        sub_100054530("Could not get status of LE periodic advertising sync transfer received event");
        v19 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return;
    }
    v7 = *((unsigned __int16 *)a2 + 5);
    v8 = *((unsigned __int16 *)a2 + 6);
    if (v7 <= v8)
      goto LABEL_28;
    v9 = *a2;
    *((_WORD *)a2 + 6) = v8 + 1;
    if ((int)(v7 - (v8 + 1)) <= 1)
    {
      *((_BYTE *)a2 + 15) = 1;
      if (sub_10005549C())
      {
        sub_100054530("Could not get connection_handle of LE periodic advertising sync transfer received event");
        v20 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          goto LABEL_46;
      }
      return;
    }
    v10 = *(unsigned __int8 *)(v9 + v8);
    v11 = *(_WORD *)(v9 + v8 + 1);
    *((_WORD *)a2 + 6) = v8 + 3;
    if ((int)(v7 - (unsigned __int16)(v8 + 3)) <= 1)
    {
      *((_BYTE *)a2 + 15) = 1;
      if (sub_10005549C())
      {
        sub_100054530("Could not get service_data of LE periodic advertising sync transfer received event");
        v21 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          goto LABEL_46;
      }
      return;
    }
    v12 = *(_WORD *)(v9 + (unsigned __int16)(v8 + 3));
    *((_WORD *)a2 + 6) = v8 + 5;
    if ((int)(v7 - (unsigned __int16)(v8 + 5)) <= 1)
    {
      *((_BYTE *)a2 + 15) = 1;
      if (sub_10005549C())
      {
        sub_100054530("Could not get sync_handle of LE periodic advertising sync transfer received event");
        v22 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          goto LABEL_46;
      }
      return;
    }
    v13 = *(_WORD *)(v9 + (unsigned __int16)(v8 + 5));
    *((_WORD *)a2 + 6) = v8 + 7;
    if (v7 <= (unsigned __int16)(v8 + 7))
    {
      *((_BYTE *)a2 + 15) = 1;
      if (sub_10005549C())
      {
        sub_100054530("Could not get advertising_SID of LE periodic advertising sync transfer received event");
        v23 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          goto LABEL_46;
      }
      return;
    }
    v14 = v8 + 8;
    *((_WORD *)a2 + 6) = v8 + 8;
    if (v7 <= (unsigned __int16)(v8 + 8))
    {
      *((_BYTE *)a2 + 15) = 1;
      if (sub_10005549C())
      {
        sub_100054530("Could not get advertiser address_type of LE periodic advertising sync transfer received event");
        v24 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          goto LABEL_46;
      }
      return;
    }
    v15 = *(_BYTE *)(v9 + (unsigned __int16)(v8 + 7));
    v16 = v8 + 9;
    *((_WORD *)a2 + 6) = v16;
    LOBYTE(v44[0]) = *(_BYTE *)(v9 + v14);
    if ((int)(v7 - v16) <= 5)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    sub_10004C878((uint64_t)v44 + 1, v9 + v16, 6uLL);
    v17 = *((_WORD *)a2 + 6);
    *((_WORD *)a2 + 6) = v17 + 6;
    if (*((_BYTE *)a2 + 15))
    {
      if (!sub_10005549C())
        return;
      sub_100054530("Could not get advertiser address of LE periodic advertising sync transfer received event");
      v18 = sub_1000544A0(0x42u);
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        return;
      goto LABEL_79;
    }
    if (*((_BYTE *)a2 + 14) != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    v25 = *((unsigned __int16 *)a2 + 5);
    if (v25 <= (unsigned __int16)(v17 + 6))
    {
      *((_BYTE *)a2 + 15) = 1;
      if (!sub_10005549C())
        return;
      sub_100054530("Could not get advertiser_PHY of LE periodic advertising sync transfer received event");
      v32 = sub_1000544A0(0x42u);
      if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
        return;
    }
    else
    {
      v26 = *a2;
      *((_WORD *)a2 + 6) = v17 + 7;
      if ((int)(v25 - (unsigned __int16)(v17 + 7)) <= 1)
      {
        *((_BYTE *)a2 + 15) = 1;
        if (!sub_10005549C())
          return;
        sub_100054530("Could not get Periodic_Advertising_Interval of LE periodic advertising sync transfer received event");
        v33 = sub_1000544A0(0x42u);
        if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
          return;
      }
      else
      {
        v27 = *(unsigned __int8 *)(v26 + (unsigned __int16)(v17 + 6));
        v28 = *(_WORD *)(v26 + (unsigned __int16)(v17 + 7));
        *((_WORD *)a2 + 6) = v17 + 9;
        if (v25 <= (unsigned __int16)(v17 + 9))
        {
          *((_BYTE *)a2 + 15) = 1;
          if (!sub_10005549C())
            return;
          sub_100054530("Could not get Advertiser_Clock_Accuracy of LE periodic advertising sync transfer received event");
          v34 = sub_1000544A0(0x42u);
          if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
            return;
        }
        else
        {
          v43 = v27;
          *((_WORD *)a2 + 6) = v17 + 10;
          v29 = *(_BYTE *)(v26 + (unsigned __int16)(v17 + 9));
          if (a1 != 2)
          {
            v41 = 0;
            v42 = 0;
            v30 = 0;
            v31 = 0;
            goto LABEL_67;
          }
          if (v25 <= (unsigned __int16)(v17 + 10))
          {
            *((_BYTE *)a2 + 15) = 1;
            if (!sub_10005549C())
              return;
            sub_100054530("Could not get Number_Subevents of LE periodic advertising sync transfer received event");
            v37 = sub_1000544A0(0x42u);
            if (!os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
              return;
          }
          else
          {
            *((_WORD *)a2 + 6) = v17 + 11;
            if (v25 <= (unsigned __int16)(v17 + 11))
            {
              *((_BYTE *)a2 + 15) = 1;
              if (!sub_10005549C())
                return;
              sub_100054530("Could not get Subevent_Interval of LE periodic advertising sync transfer received event");
              v38 = sub_1000544A0(0x42u);
              if (!os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
                return;
            }
            else
            {
              v42 = *(_BYTE *)(v26 + (unsigned __int16)(v17 + 10));
              *((_WORD *)a2 + 6) = v17 + 12;
              if (v25 <= (unsigned __int16)(v17 + 12))
              {
                *((_BYTE *)a2 + 15) = 1;
                if (!sub_10005549C())
                  return;
                sub_100054530("Could not get Response_Slot_Delay of LE periodic advertising sync transfer received event");
                v39 = sub_1000544A0(0x42u);
                if (!os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
                  return;
              }
              else
              {
                v41 = *(_BYTE *)(v26 + (unsigned __int16)(v17 + 11));
                *((_WORD *)a2 + 6) = v17 + 13;
                if (v25 > (unsigned __int16)(v17 + 13))
                {
                  v30 = *(_BYTE *)(v26 + (unsigned __int16)(v17 + 12));
                  *((_WORD *)a2 + 6) = v17 + 14;
                  v31 = *(_BYTE *)(v26 + (unsigned __int16)(v17 + 13));
LABEL_67:
                  v35 = sub_10019ACEC(v11);
                  v36 = sub_100049F2C(v10);
                  sub_1001118CC(v36, (uint64_t)v35, v12, v13, v15, v44, v43, v28, v29, v42, v41, v30, v31);
                  return;
                }
                *((_BYTE *)a2 + 15) = 1;
                if (!sub_10005549C())
                  return;
                sub_100054530("Could not get Response_Slot_Spacing of LE periodic advertising sync transfer received event");
                v40 = sub_1000544A0(0x42u);
                if (!os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
                  return;
              }
            }
          }
        }
      }
    }
LABEL_79:
    sub_1006CE7A4();
    return;
  }
  if (sub_10005549C())
  {
    sub_100054530("Invalid periodic advertising sync transfer received event packet size : %d, expecting ", v4);
    v5 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
LABEL_46:
      sub_1006CE7A4();
  }
}

void sub_10021C554(uint64_t *a1)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned __int16 v6;
  char v7;
  char v8;
  char v9;
  char v10;
  char v11;
  __int16 v12;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;
  NSObject *v16;
  NSObject *v17;
  NSObject *v18;
  NSObject *v19;

  if (*((_BYTE *)a1 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 936, "void _HCIEventHandler_TransmitPowerReport(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
  }
  else
  {
    v2 = *((unsigned __int16 *)a1 + 5);
    v3 = *((unsigned __int16 *)a1 + 6);
    if (v2 > v3)
    {
      v4 = *a1;
      *((_WORD *)a1 + 6) = v3 + 1;
      if ((int)(v2 - (v3 + 1)) <= 1)
      {
        *((_BYTE *)a1 + 15) = 1;
        if (sub_10005549C())
        {
          sub_100054530("Could not get connection_handle of tx power report  event");
          v14 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
            goto LABEL_15;
        }
      }
      else
      {
        v5 = *(unsigned __int8 *)(v4 + v3);
        v6 = *(_WORD *)(v4 + v3 + 1);
        *((_WORD *)a1 + 6) = v3 + 3;
        if (v2 <= (unsigned __int16)(v3 + 3))
        {
          *((_BYTE *)a1 + 15) = 1;
          if (sub_10005549C())
          {
            sub_100054530("Could not get reason of tx power report  event");
            v15 = sub_1000544A0(0x42u);
            if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
              goto LABEL_15;
          }
        }
        else
        {
          *((_WORD *)a1 + 6) = v3 + 4;
          if (v2 <= (unsigned __int16)(v3 + 4))
          {
            *((_BYTE *)a1 + 15) = 1;
            if (sub_10005549C())
            {
              sub_100054530("Could not get phy of tx power report  event");
              v16 = sub_1000544A0(0x42u);
              if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
                goto LABEL_15;
            }
          }
          else
          {
            v7 = *(_BYTE *)(v4 + (unsigned __int16)(v3 + 3));
            *((_WORD *)a1 + 6) = v3 + 5;
            if (v2 <= (unsigned __int16)(v3 + 5))
            {
              *((_BYTE *)a1 + 15) = 1;
              if (sub_10005549C())
              {
                sub_100054530("Could not get TX_Power_Level of tx power report  event");
                v17 = sub_1000544A0(0x42u);
                if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
                  goto LABEL_15;
              }
            }
            else
            {
              v8 = *(_BYTE *)(v4 + (unsigned __int16)(v3 + 4));
              *((_WORD *)a1 + 6) = v3 + 6;
              if (v2 <= (unsigned __int16)(v3 + 6))
              {
                *((_BYTE *)a1 + 15) = 1;
                if (sub_10005549C())
                {
                  sub_100054530("Could not get TX_Power_Level_Flag of tx power report  event");
                  v18 = sub_1000544A0(0x42u);
                  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
                    goto LABEL_15;
                }
              }
              else
              {
                v9 = *(_BYTE *)(v4 + (unsigned __int16)(v3 + 5));
                *((_WORD *)a1 + 6) = v3 + 7;
                if (v2 <= (unsigned __int16)(v3 + 7))
                {
                  *((_BYTE *)a1 + 15) = 1;
                  if (sub_10005549C())
                  {
                    sub_100054530("Could not get delta of tx power report  event");
                    v19 = sub_1000544A0(0x42u);
                    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
                      goto LABEL_15;
                  }
                }
                else
                {
                  v10 = *(_BYTE *)(v4 + (unsigned __int16)(v3 + 6));
                  *((_WORD *)a1 + 6) = v3 + 8;
                  v11 = *(_BYTE *)(v4 + (unsigned __int16)(v3 + 7));
                  v12 = v6;
                  if (sub_10019ACEC(v6))
                    sub_1002188CC(v5, v12, v7, v8, v9, v10, v11);
                }
              }
            }
          }
        }
      }
      return;
    }
  }
  *((_BYTE *)a1 + 15) = 1;
  if (sub_10005549C())
  {
    sub_100054530("Could not get status tx power report  event");
    v13 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
LABEL_15:
      sub_1006CE7A4();
  }
}

void sub_10021C8BC(uint64_t *a1)
{
  int v1;
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  unsigned __int16 v5;
  unsigned int v6;
  unsigned int v7;
  __int16 v8;
  char v9;
  char v10;
  char v11;
  char v12;
  char v13;
  char v14;
  char v15;
  char v16;
  __int16 v17;
  __int16 v18;
  __int16 v19;
  __int16 v20;
  unsigned __int8 *v21;
  __int16 v22;
  __int16 v23;
  __int16 v24;
  char v25;
  uint64_t v26;
  NSObject *v27;
  NSObject *v28;
  char v29;
  char v30;
  unsigned int v31;
  char v32;
  char v33;
  char v34;
  char v35;

  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1334, "void LE_HCIEventHandler_CsReadRemoteSupportedCapabilities(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v1 = 0;
  }
  else
  {
    v2 = *((unsigned __int16 *)a1 + 5);
    v3 = *((unsigned __int16 *)a1 + 6);
    v1 = v2 - v3;
    if (v2 - (_DWORD)v3 == 25)
    {
      if (*((_BYTE *)a1 + 14) != 1)
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
      v4 = *a1;
      v5 = *(_WORD *)(*a1 + v3);
      *((_WORD *)a1 + 6) = v3 + 2;
      if (v2 <= (unsigned __int16)(v3 + 2))
      {
        *((_BYTE *)a1 + 15) = 1;
        if (sub_10005549C())
        {
          sub_100054530("Could not get the status of the read remote used features event");
          v28 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
            goto LABEL_25;
        }
      }
      else
      {
        *((_WORD *)a1 + 6) = v3 + 3;
        if (v2 <= (unsigned __int16)(v3 + 3))
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
        v6 = *(unsigned __int8 *)(v4 + (unsigned __int16)(v3 + 2));
        *((_WORD *)a1 + 6) = v3 + 4;
        if ((int)(v2 - (unsigned __int16)(v3 + 4)) <= 1)
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
        v7 = *(unsigned __int8 *)(v4 + (unsigned __int16)(v3 + 3));
        v8 = *(_WORD *)(v4 + (unsigned __int16)(v3 + 4));
        *((_WORD *)a1 + 6) = v3 + 6;
        if (v2 <= (unsigned __int16)(v3 + 6))
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
        *((_WORD *)a1 + 6) = v3 + 7;
        if (v2 <= (unsigned __int16)(v3 + 7))
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
        v9 = *(_BYTE *)(v4 + (unsigned __int16)(v3 + 6));
        *((_WORD *)a1 + 6) = v3 + 8;
        if (v2 <= (unsigned __int16)(v3 + 8))
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
        v10 = *(_BYTE *)(v4 + (unsigned __int16)(v3 + 7));
        *((_WORD *)a1 + 6) = v3 + 9;
        if (v2 <= (unsigned __int16)(v3 + 9))
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
        v11 = *(_BYTE *)(v4 + (unsigned __int16)(v3 + 8));
        *((_WORD *)a1 + 6) = v3 + 10;
        if (v2 <= (unsigned __int16)(v3 + 10))
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
        v12 = *(_BYTE *)(v4 + (unsigned __int16)(v3 + 9));
        *((_WORD *)a1 + 6) = v3 + 11;
        if (v2 <= (unsigned __int16)(v3 + 11))
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
        v13 = *(_BYTE *)(v4 + (unsigned __int16)(v3 + 10));
        *((_WORD *)a1 + 6) = v3 + 12;
        if (v2 <= (unsigned __int16)(v3 + 12))
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
        v14 = *(_BYTE *)(v4 + (unsigned __int16)(v3 + 11));
        *((_WORD *)a1 + 6) = v3 + 13;
        if (v2 <= (unsigned __int16)(v3 + 13))
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
        v15 = *(_BYTE *)(v4 + (unsigned __int16)(v3 + 12));
        *((_WORD *)a1 + 6) = v3 + 14;
        if ((int)(v2 - (unsigned __int16)(v3 + 14)) <= 1)
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
        v16 = *(_BYTE *)(v4 + (unsigned __int16)(v3 + 13));
        v17 = *(_WORD *)(v4 + (unsigned __int16)(v3 + 14));
        *((_WORD *)a1 + 6) = v3 + 16;
        if ((int)(v2 - (unsigned __int16)(v3 + 16)) <= 1)
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
        v18 = *(_WORD *)(v4 + (unsigned __int16)(v3 + 16));
        *((_WORD *)a1 + 6) = v3 + 18;
        if ((int)(v2 - (unsigned __int16)(v3 + 18)) <= 1)
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
        v19 = *(_WORD *)(v4 + (unsigned __int16)(v3 + 18));
        *((_WORD *)a1 + 6) = v3 + 20;
        if ((int)(v2 - (unsigned __int16)(v3 + 20)) <= 1)
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
        v20 = *(_WORD *)(v4 + (unsigned __int16)(v3 + 20));
        *((_WORD *)a1 + 6) = v3 + 22;
        if ((int)(v2 - (unsigned __int16)(v3 + 22)) <= 1)
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
        v29 = v14;
        v30 = v13;
        v34 = v11;
        v35 = v12;
        v32 = v9;
        v33 = v10;
        v31 = v7;
        v21 = (unsigned __int8 *)(v4 + (unsigned __int16)(v3 + 22));
        v22 = *v21;
        v23 = v21[1];
        *((_WORD *)a1 + 6) = v3 + 24;
        if (v2 <= (unsigned __int16)(v3 + 24))
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
        v24 = v22 | (v23 << 8);
        *((_WORD *)a1 + 6) = v3 + 25;
        v25 = *(_BYTE *)(v4 + (unsigned __int16)(v3 + 24));
        v26 = sub_100049F2C(v6);
        sub_1002189AC(v5, v26, v31, v8, v32, v33, v34, v35, v30, v29, v15, v16, v17, v18, v19, v20, v24, v25);
      }
      return;
    }
  }
  if (sub_10005549C())
  {
    sub_100054530("Not enough data in the capabilites packet : %d expecting at least %d", v1, 25);
    v27 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
LABEL_25:
      sub_1006CE7A4();
  }
}

void sub_10021CD98(uint64_t *a1)
{
  int v1;
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  unsigned __int16 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  __int128 *v11;
  _OWORD v12[4];
  uint64_t v13;

  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1386, "void LE_HCIEventHandler_CsReadRemoteFaeTable(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v1 = 0;
  }
  else
  {
    v2 = *((unsigned __int16 *)a1 + 5);
    v3 = *((unsigned __int16 *)a1 + 6);
    v1 = v2 - v3;
    v13 = 0;
    memset(v12, 0, sizeof(v12));
    if (v2 - (_DWORD)v3 == 75)
    {
      if (*((_BYTE *)a1 + 14) != 1)
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
      v4 = *a1;
      v5 = *(_WORD *)(*a1 + v3);
      *((_WORD *)a1 + 6) = v3 + 2;
      if (v2 <= (unsigned __int16)(v3 + 2))
      {
        *((_BYTE *)a1 + 15) = 1;
        if (sub_10005549C())
        {
          sub_100054530("Could not get the status of the read remote used features event");
          v10 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
            goto LABEL_12;
        }
      }
      else
      {
        *((_WORD *)a1 + 6) = v3 + 3;
        v6 = *(unsigned __int8 *)(v4 + (unsigned __int16)(v3 + 2));
        if ((int)(v2 - (unsigned __int16)(v3 + 3)) < 72)
        {
          *((_BYTE *)a1 + 15) = 1;
        }
        else
        {
          v7 = 0;
          v8 = v4 + (unsigned __int16)(v3 + 3);
          do
          {
            *((_BYTE *)v12 + v7) = *(_BYTE *)(v8 + v7);
            ++v7;
          }
          while (v7 != 72);
          *((_WORD *)a1 + 6) = v3 + 75;
        }
        v11 = sub_10019ACEC(v5);
        sub_100221088(v6, (uint64_t)v11, (uint64_t)v12);
      }
      return;
    }
  }
  if (sub_10005549C())
  {
    sub_100054530("Not enough data in the capabilites packet : %d expecting at least %d", v1, 74);
    v9 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
LABEL_12:
      sub_1006CE7A4();
  }
}

void sub_10021CF6C(uint64_t *a1)
{
  int v1;
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  unsigned __int8 *v5;
  int v6;
  int v7;
  uint64_t v8;
  __int128 *v9;
  NSObject *v10;
  NSObject *v11;

  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1409, "void LE_HCIEventHandler_CsSecurityEnable(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v1 = 0;
  }
  else
  {
    v2 = *((unsigned __int16 *)a1 + 5);
    v3 = *((unsigned __int16 *)a1 + 6);
    v1 = v2 - v3;
    if (v2 - (_DWORD)v3 == 3)
    {
      if (*((_BYTE *)a1 + 14) != 1)
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
      v4 = *a1;
      v5 = (unsigned __int8 *)(*a1 + v3);
      v6 = *v5;
      v7 = v5[1];
      *((_WORD *)a1 + 6) = v3 + 2;
      if (v2 > (unsigned __int16)(v3 + 2))
      {
        *((_WORD *)a1 + 6) = v3 + 3;
        v8 = *(unsigned __int8 *)(v4 + (unsigned __int16)(v3 + 2));
        v9 = sub_10019ACEC(v6 | (v7 << 8));
        sub_100221108(v8, (uint64_t)v9);
        return;
      }
      *((_BYTE *)a1 + 15) = 1;
      if (sub_10005549C())
      {
        sub_100054530("Could not get the status of the read remote used features event");
        v11 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          goto LABEL_9;
      }
      return;
    }
  }
  if (sub_10005549C())
  {
    sub_100054530("Not enough data for security enable complete event : %d expecting at least %d", v1, 4);
    v10 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
LABEL_9:
      sub_1006CE7A4();
  }
}

void sub_10021D0D0(uint64_t *a1)
{
  int v1;
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  unsigned __int16 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  char v18;
  uint64_t v19;
  char v20;
  uint64_t v21;
  char v22;
  NSObject *v23;
  NSObject *v24;
  unsigned __int16 v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  __int128 *v32;
  __int16 v33;
  unsigned int v34;

  if (!*((_BYTE *)a1 + 15))
  {
    v3 = *((unsigned __int16 *)a1 + 5);
    v4 = *((unsigned __int16 *)a1 + 6);
    v1 = v3 - v4;
    if (v3 - (_DWORD)v4 != 74)
      goto LABEL_16;
    if (*((_BYTE *)a1 + 14) != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    v5 = *a1;
    v6 = *(_WORD *)(*a1 + v4);
    *((_WORD *)a1 + 6) = v4 + 2;
    if (v3 <= (unsigned __int16)(v4 + 2))
    {
      *((_BYTE *)a1 + 15) = 1;
      sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1453, "void LE_HCIEventHandler_CsProcedureEnable(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    }
    else
    {
      *((_WORD *)a1 + 6) = v4 + 3;
      if (v3 > (unsigned __int16)(v4 + 3))
      {
        v7 = *(unsigned __int8 *)(v5 + (unsigned __int16)(v4 + 2));
        *((_WORD *)a1 + 6) = v4 + 4;
        v8 = *(unsigned __int8 *)(v5 + (unsigned __int16)(v4 + 3));
        if (v3 <= (unsigned __int16)(v4 + 4))
        {
          v25 = v6;
          *((_BYTE *)a1 + 15) = 1;
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1456, "void LE_HCIEventHandler_CsProcedureEnable(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
          v26 = *((unsigned __int8 *)a1 + 14);
          *((_BYTE *)a1 + 15) = 1;
          if (v26 != 1)
            sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
          v9 = 0;
        }
        else
        {
          *((_WORD *)a1 + 6) = v4 + 5;
          v9 = *(unsigned __int8 *)(v5 + (unsigned __int16)(v4 + 4));
          if (v3 > (unsigned __int16)(v4 + 5))
          {
            *((_WORD *)a1 + 6) = v4 + 6;
            v10 = *(unsigned __int8 *)(v5 + (unsigned __int16)(v4 + 5));
            if (*((unsigned __int16 *)a1 + 5) > (unsigned __int16)(v4 + 6))
            {
              v11 = *a1;
              *((_WORD *)a1 + 6) = v4 + 7;
              v12 = *(unsigned __int8 *)(v11 + (unsigned __int16)(v4 + 6));
              if (*((unsigned __int16 *)a1 + 5) > (unsigned __int16)(v4 + 7))
              {
                v13 = *a1;
                *((_WORD *)a1 + 6) = v4 + 8;
                v14 = *(unsigned __int8 *)(v13 + (unsigned __int16)(v4 + 7));
                if (*((unsigned __int16 *)a1 + 5) > (unsigned __int16)(v4 + 8))
                {
                  v15 = *a1;
                  *((_WORD *)a1 + 6) = v4 + 9;
                  v16 = *(unsigned __int8 *)(v15 + (unsigned __int16)(v4 + 8));
                  if (*((unsigned __int16 *)a1 + 5) > (unsigned __int16)(v4 + 9))
                  {
                    v17 = *a1;
                    *((_WORD *)a1 + 6) = v4 + 10;
                    v18 = *(_BYTE *)(v17 + (unsigned __int16)(v4 + 9));
                    v34 = v16;
                    if (*((unsigned __int16 *)a1 + 5) > (unsigned __int16)(v4 + 10))
                    {
                      v19 = *a1;
                      *((_WORD *)a1 + 6) = v4 + 11;
                      v20 = *(_BYTE *)(v19 + (unsigned __int16)(v4 + 10));
                      if (*((unsigned __int16 *)a1 + 5) > (unsigned __int16)(v4 + 11))
                      {
                        v21 = *a1;
                        *((_WORD *)a1 + 6) = v4 + 12;
                        v22 = *(_BYTE *)(v21 + (unsigned __int16)(v4 + 11));
LABEL_39:
                        v32 = sub_10019ACEC(v6);
                        HIBYTE(v33) = v20;
                        LOBYTE(v33) = v18;
                        sub_100221180(v8, (uint64_t)v32, v7, v9, v10, v12, v14, v34, v33, v22);
                        return;
                      }
LABEL_38:
                      v22 = 0;
                      *((_BYTE *)a1 + 15) = 1;
                      goto LABEL_39;
                    }
                    v25 = v6;
                    *((_BYTE *)a1 + 15) = 1;
LABEL_37:
                    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1462, "void LE_HCIEventHandler_CsProcedureEnable(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
                    v20 = 0;
                    v6 = v25;
                    goto LABEL_38;
                  }
                  v25 = v6;
                  *((_BYTE *)a1 + 15) = 1;
LABEL_35:
                  sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1461, "void LE_HCIEventHandler_CsProcedureEnable(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
                  v31 = *((unsigned __int8 *)a1 + 14);
                  *((_BYTE *)a1 + 15) = 1;
                  if (v31 != 1)
                    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
                  v34 = v16;
                  v18 = 0;
                  goto LABEL_37;
                }
                v25 = v6;
                *((_BYTE *)a1 + 15) = 1;
LABEL_33:
                sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1460, "void LE_HCIEventHandler_CsProcedureEnable(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
                v30 = *((unsigned __int8 *)a1 + 14);
                *((_BYTE *)a1 + 15) = 1;
                if (v30 != 1)
                  sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
                v16 = 0;
                goto LABEL_35;
              }
              v25 = v6;
              *((_BYTE *)a1 + 15) = 1;
LABEL_31:
              sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1459, "void LE_HCIEventHandler_CsProcedureEnable(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
              v29 = *((unsigned __int8 *)a1 + 14);
              *((_BYTE *)a1 + 15) = 1;
              if (v29 != 1)
                sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
              v14 = 0;
              goto LABEL_33;
            }
            v25 = v6;
            *((_BYTE *)a1 + 15) = 1;
LABEL_29:
            sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1458, "void LE_HCIEventHandler_CsProcedureEnable(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
            v28 = *((unsigned __int8 *)a1 + 14);
            *((_BYTE *)a1 + 15) = 1;
            if (v28 != 1)
              sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
            v12 = 0;
            goto LABEL_31;
          }
          v25 = v6;
          *((_BYTE *)a1 + 15) = 1;
        }
        sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1457, "void LE_HCIEventHandler_CsProcedureEnable(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
        v27 = *((unsigned __int8 *)a1 + 14);
        *((_BYTE *)a1 + 15) = 1;
        if (v27 != 1)
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
        v10 = 0;
        goto LABEL_29;
      }
    }
    *((_BYTE *)a1 + 15) = 1;
    if (sub_10005549C())
    {
      sub_100054530("Could not get the status of the read remote used features event");
      v24 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        goto LABEL_18;
    }
    return;
  }
  sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1430, "void LE_HCIEventHandler_CsProcedureEnable(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
  v1 = 0;
LABEL_16:
  if (sub_10005549C())
  {
    sub_100054530("Not enough data in the capabilites packet : %d expecting at least %d", v1, 74);
    v23 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
LABEL_18:
      sub_1006CE7A4();
  }
}

void sub_10021D5E0(uint64_t *a1)
{
  uint64_t v2;
  int v3;
  __int128 *v4;
  uint64_t v5;
  int v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  unsigned int v24;
  unsigned __int16 v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  unsigned __int16 v38;
  char *v39;
  _BYTE *v40;
  char v41;
  uint64_t v42;
  int v43;
  char *v44;
  _BYTE *v45;
  char v46;
  unsigned __int16 v47;
  unsigned __int8 *v48;
  __int16 v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  char *v53;
  _BYTE *v54;
  char v55;
  char *v56;
  _BYTE *v57;
  char v58;
  unsigned int v59;
  unsigned int v60;
  unsigned int v61;
  unsigned int v62;
  _OWORD v63[10];
  _OWORD v64[10];
  _OWORD v65[10];
  _OWORD v66[10];

  memset(v66, 0, sizeof(v66));
  memset(v65, 0, sizeof(v65));
  memset(v64, 0, sizeof(v64));
  memset(v63, 0, sizeof(v63));
  if (*((_BYTE *)a1 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1491, "void LE_HCIEventHandler_CsSubEventResult(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    goto LABEL_9;
  }
  v2 = *((unsigned __int16 *)a1 + 6);
  if (*((unsigned __int16 *)a1 + 5) - (int)v2 <= 1)
  {
LABEL_9:
    *((_BYTE *)a1 + 15) = 1;
    if (sub_10005549C())
    {
      sub_100054530("Could not get the connection handle of the read remote used features event");
      v7 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return;
  }
  v3 = *(unsigned __int16 *)(*a1 + v2);
  *((_WORD *)a1 + 6) = v2 + 2;
  v4 = sub_10019ACEC(v3);
  if (*((_BYTE *)a1 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
  v5 = (uint64_t)v4;
  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1494, "void LE_HCIEventHandler_CsSubEventResult(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v6 = *((unsigned __int8 *)a1 + 14);
    *((_BYTE *)a1 + 15) = 1;
    if (v6 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    goto LABEL_23;
  }
  v8 = *((unsigned __int16 *)a1 + 6);
  if (*((unsigned __int16 *)a1 + 5) <= v8)
  {
    *((_BYTE *)a1 + 15) = 1;
LABEL_23:
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1495, "void LE_HCIEventHandler_CsSubEventResult(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v28 = *((unsigned __int8 *)a1 + 14);
    *((_BYTE *)a1 + 15) = 1;
    if (v28 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    v10 = 0;
    goto LABEL_25;
  }
  v9 = *a1;
  *((_WORD *)a1 + 6) = v8 + 1;
  v10 = *(unsigned __int8 *)(v9 + v8);
  if (*((unsigned __int16 *)a1 + 5) - ((int)v8 + 1) <= 1)
  {
    *((_BYTE *)a1 + 15) = 1;
LABEL_25:
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1496, "void LE_HCIEventHandler_CsSubEventResult(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v29 = *((unsigned __int8 *)a1 + 14);
    *((_BYTE *)a1 + 15) = 1;
    if (v29 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    v11 = 0;
    goto LABEL_27;
  }
  v11 = *(unsigned __int8 *)(*a1 + v8 + 1);
  *((_WORD *)a1 + 6) = v8 + 3;
  if (*((unsigned __int16 *)a1 + 5) - (unsigned __int16)(v8 + 3) <= 1)
  {
    *((_BYTE *)a1 + 15) = 1;
LABEL_27:
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1497, "void LE_HCIEventHandler_CsSubEventResult(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v30 = *((unsigned __int8 *)a1 + 14);
    *((_BYTE *)a1 + 15) = 1;
    if (v30 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    v12 = 0;
    goto LABEL_29;
  }
  v12 = *(unsigned __int8 *)(*a1 + (unsigned __int16)(v8 + 3));
  *((_WORD *)a1 + 6) = v8 + 5;
  if (*((unsigned __int16 *)a1 + 5) <= (unsigned __int16)(v8 + 5))
  {
    *((_BYTE *)a1 + 15) = 1;
LABEL_29:
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1498, "void LE_HCIEventHandler_CsSubEventResult(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v31 = *((unsigned __int8 *)a1 + 14);
    *((_BYTE *)a1 + 15) = 1;
    if (v31 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    v14 = 0;
    goto LABEL_31;
  }
  v13 = *a1;
  *((_WORD *)a1 + 6) = v8 + 6;
  v14 = *(unsigned __int8 *)(v13 + (unsigned __int16)(v8 + 5));
  if (*((unsigned __int16 *)a1 + 5) <= (unsigned __int16)(v8 + 6))
  {
    *((_BYTE *)a1 + 15) = 1;
LABEL_31:
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1499, "void LE_HCIEventHandler_CsSubEventResult(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v32 = *((unsigned __int8 *)a1 + 14);
    *((_BYTE *)a1 + 15) = 1;
    if (v32 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    v16 = 0;
    goto LABEL_33;
  }
  v15 = *a1;
  *((_WORD *)a1 + 6) = v8 + 7;
  v16 = *(unsigned __int8 *)(v15 + (unsigned __int16)(v8 + 6));
  if (*((unsigned __int16 *)a1 + 5) <= (unsigned __int16)(v8 + 7))
  {
    *((_BYTE *)a1 + 15) = 1;
LABEL_33:
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1500, "void LE_HCIEventHandler_CsSubEventResult(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v33 = *((unsigned __int8 *)a1 + 14);
    *((_BYTE *)a1 + 15) = 1;
    if (v33 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    v18 = 0;
    goto LABEL_35;
  }
  v17 = *a1;
  *((_WORD *)a1 + 6) = v8 + 8;
  v18 = *(unsigned __int8 *)(v17 + (unsigned __int16)(v8 + 7));
  if (*((unsigned __int16 *)a1 + 5) <= (unsigned __int16)(v8 + 8))
  {
    *((_BYTE *)a1 + 15) = 1;
LABEL_35:
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1501, "void LE_HCIEventHandler_CsSubEventResult(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v34 = *((unsigned __int8 *)a1 + 14);
    *((_BYTE *)a1 + 15) = 1;
    if (v34 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    v61 = v16;
    v62 = v14;
    v59 = v11;
    v60 = v12;
    v20 = 0;
    goto LABEL_37;
  }
  v19 = *a1;
  *((_WORD *)a1 + 6) = v8 + 9;
  v20 = *(unsigned __int8 *)(v19 + (unsigned __int16)(v8 + 8));
  v61 = v16;
  v62 = v14;
  v59 = v11;
  v60 = v12;
  if (*((unsigned __int16 *)a1 + 5) <= (unsigned __int16)(v8 + 9))
  {
    *((_BYTE *)a1 + 15) = 1;
LABEL_37:
    v23 = v20;
    v24 = v18;
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1503, "void LE_HCIEventHandler_CsSubEventResult(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    LODWORD(v22) = 0;
    goto LABEL_38;
  }
  v21 = *a1;
  *((_WORD *)a1 + 6) = v8 + 10;
  v22 = *(unsigned __int8 *)(v21 + (unsigned __int16)(v8 + 9));
  if (*((unsigned __int16 *)a1 + 5) - (unsigned __int16)(v8 + 10) >= (int)v22)
  {
    if (*(_BYTE *)(v21 + (unsigned __int16)(v8 + 9)))
    {
      v23 = v20;
      v24 = v18;
      v56 = (char *)(v21 + (unsigned __int16)(v8 + 10));
      v57 = v66;
      do
      {
        v58 = *v56++;
        *v57++ = v58;
      }
      while (v57 < (_BYTE *)v66 + v22);
      v26 = v22;
      v35 = v22;
      goto LABEL_39;
    }
    v23 = v20;
    v24 = v18;
LABEL_38:
    v26 = 0;
    v35 = 0;
LABEL_39:
    v27 = v22;
    v25 = *((_WORD *)a1 + 6) + v22;
    *((_WORD *)a1 + 6) = v25;
    v22 = v35;
    goto LABEL_40;
  }
  v23 = v20;
  v24 = v18;
  *((_BYTE *)a1 + 15) = 1;
  v25 = *((_WORD *)a1 + 6);
  v26 = v22;
  v27 = v22;
LABEL_40:
  if (*((_BYTE *)a1 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
  v36 = *a1;
  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1504, "void LE_HCIEventHandler_CsSubEventResult(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v37 = 0;
  }
  else
  {
    v37 = *((unsigned __int16 *)a1 + 5) - v25;
  }
  if (v37 >= v26)
  {
    if (v27)
    {
      v39 = (char *)(v36 + v25);
      v40 = v65;
      do
      {
        v41 = *v39++;
        *v40++ = v41;
      }
      while (v40 < (_BYTE *)v65 + v22);
    }
    v38 = *((_WORD *)a1 + 6) + v27;
    *((_WORD *)a1 + 6) = v38;
  }
  else
  {
    *((_BYTE *)a1 + 15) = 1;
    v38 = *((_WORD *)a1 + 6);
  }
  if (*((_BYTE *)a1 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
  v42 = *a1;
  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1505, "void LE_HCIEventHandler_CsSubEventResult(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v43 = 0;
  }
  else
  {
    v43 = *((unsigned __int16 *)a1 + 5) - v38;
  }
  if (v43 >= v26)
  {
    if (v27)
    {
      v44 = (char *)(v42 + v38);
      v45 = v64;
      do
      {
        v46 = *v44++;
        *v45++ = v46;
      }
      while (v45 < (_BYTE *)v64 + v22);
    }
    *((_WORD *)a1 + 6) += v27;
  }
  else
  {
    *((_BYTE *)a1 + 15) = 1;
  }
  v47 = 0;
  if (v27)
  {
    v48 = (unsigned __int8 *)v64;
    do
    {
      v49 = *v48++;
      v47 += v49;
      --v22;
    }
    while (v22);
  }
  if (*((_BYTE *)a1 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
  v50 = *a1;
  v51 = *((unsigned __int16 *)a1 + 6);
  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1510, "void LE_HCIEventHandler_CsSubEventResult(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v52 = 0;
  }
  else
  {
    v52 = *((unsigned __int16 *)a1 + 5) - (_DWORD)v51;
  }
  if (v52 >= v47)
  {
    if (v47)
    {
      v53 = (char *)(v50 + v51);
      v54 = v63;
      do
      {
        v55 = *v53++;
        *v54++ = v55;
      }
      while (v54 < (_BYTE *)v63 + v47);
    }
    *((_WORD *)a1 + 6) += v47;
  }
  else
  {
    *((_BYTE *)a1 + 15) = 1;
  }
  sub_100221254(v5, v10, v59, v60, v62, v61, v24, v23, v27, (uint64_t)v66, (uint64_t)v65, (uint64_t)v64, (uint64_t)v63);
}

void sub_10021DE28(uint64_t *a1)
{
  uint64_t v2;
  int v3;
  __int128 *v4;
  __int128 *v5;
  int v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned __int16 v18;
  int v19;
  uint64_t v20;
  int v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  unsigned __int16 v28;
  char *v29;
  _BYTE *v30;
  char v31;
  uint64_t v32;
  int v33;
  unsigned __int16 v34;
  char *v35;
  _BYTE *v36;
  char v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char *v45;
  _BYTE *v46;
  char v47;
  char *v48;
  _BYTE *v49;
  char v50;
  unsigned int v51;
  _OWORD v52[10];
  _OWORD v53[10];
  _OWORD v54[10];
  _OWORD v55[10];

  memset(v55, 0, sizeof(v55));
  memset(v54, 0, sizeof(v54));
  memset(v53, 0, sizeof(v53));
  memset(v52, 0, sizeof(v52));
  if (*((_BYTE *)a1 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1530, "void LE_HCIEventHandler_CsSubEventResultContinue(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    goto LABEL_9;
  }
  v2 = *((unsigned __int16 *)a1 + 6);
  if (*((unsigned __int16 *)a1 + 5) - (int)v2 <= 1)
  {
LABEL_9:
    *((_BYTE *)a1 + 15) = 1;
    if (sub_10005549C())
    {
      sub_100054530("Could not get the connection handle of the read remote used features event");
      v7 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return;
  }
  v3 = *(unsigned __int16 *)(*a1 + v2);
  *((_WORD *)a1 + 6) = v2 + 2;
  v4 = sub_10019ACEC(v3);
  if (*((_BYTE *)a1 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
  v5 = v4;
  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1533, "void LE_HCIEventHandler_CsSubEventResultContinue(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v6 = *((unsigned __int8 *)a1 + 14);
    *((_BYTE *)a1 + 15) = 1;
    if (v6 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    goto LABEL_20;
  }
  v8 = *((unsigned __int16 *)a1 + 6);
  if (*((unsigned __int16 *)a1 + 5) <= v8)
  {
    *((_BYTE *)a1 + 15) = 1;
LABEL_20:
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1534, "void LE_HCIEventHandler_CsSubEventResultContinue(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v21 = *((unsigned __int8 *)a1 + 14);
    *((_BYTE *)a1 + 15) = 1;
    if (v21 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    v10 = 0;
    goto LABEL_22;
  }
  v9 = *a1;
  *((_WORD *)a1 + 6) = v8 + 1;
  v10 = *(unsigned __int8 *)(v9 + v8);
  if (*((unsigned __int16 *)a1 + 5) <= (v8 + 1))
  {
    *((_BYTE *)a1 + 15) = 1;
LABEL_22:
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1535, "void LE_HCIEventHandler_CsSubEventResultContinue(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v22 = *((unsigned __int8 *)a1 + 14);
    *((_BYTE *)a1 + 15) = 1;
    if (v22 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    v12 = 0;
    goto LABEL_24;
  }
  v11 = *a1;
  *((_WORD *)a1 + 6) = v8 + 2;
  v12 = *(unsigned __int8 *)(v11 + v8 + 1);
  if (*((unsigned __int16 *)a1 + 5) <= (v8 + 2))
  {
    *((_BYTE *)a1 + 15) = 1;
LABEL_24:
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1536, "void LE_HCIEventHandler_CsSubEventResultContinue(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v23 = *((unsigned __int8 *)a1 + 14);
    *((_BYTE *)a1 + 15) = 1;
    if (v23 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    v14 = 0;
    goto LABEL_26;
  }
  v13 = *a1;
  *((_WORD *)a1 + 6) = v8 + 3;
  v14 = *(unsigned __int8 *)(v13 + v8 + 2);
  if (*((unsigned __int16 *)a1 + 5) <= (v8 + 3))
  {
    *((_BYTE *)a1 + 15) = 1;
LABEL_26:
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1537, "void LE_HCIEventHandler_CsSubEventResultContinue(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v24 = *((unsigned __int8 *)a1 + 14);
    *((_BYTE *)a1 + 15) = 1;
    if (v24 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    v51 = 0;
    goto LABEL_28;
  }
  v15 = *a1;
  *((_WORD *)a1 + 6) = v8 + 4;
  v51 = *(unsigned __int8 *)(v15 + v8 + 3);
  if (*((unsigned __int16 *)a1 + 5) <= (v8 + 4))
  {
    *((_BYTE *)a1 + 15) = 1;
LABEL_28:
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1539, "void LE_HCIEventHandler_CsSubEventResultContinue(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v17 = 0;
    goto LABEL_29;
  }
  v16 = *a1;
  *((_WORD *)a1 + 6) = v8 + 5;
  v17 = *(unsigned __int8 *)(v16 + v8 + 4);
  if (*((unsigned __int16 *)a1 + 5) - ((int)v8 + 5) >= (int)v17)
  {
    if (*(_BYTE *)(v16 + v8 + 4))
    {
      v48 = (char *)(v16 + v8 + 5);
      v49 = v55;
      do
      {
        v50 = *v48++;
        *v49++ = v50;
      }
      while (v49 < (_BYTE *)v55 + v17);
      v19 = v17;
      v25 = v17;
      goto LABEL_30;
    }
LABEL_29:
    v19 = 0;
    v25 = 0;
LABEL_30:
    v20 = v17;
    v18 = *((_WORD *)a1 + 6) + v17;
    *((_WORD *)a1 + 6) = v18;
    v17 = v25;
    goto LABEL_31;
  }
  *((_BYTE *)a1 + 15) = 1;
  v18 = *((_WORD *)a1 + 6);
  v19 = v17;
  v20 = v17;
LABEL_31:
  if (*((_BYTE *)a1 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
  v26 = *a1;
  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1540, "void LE_HCIEventHandler_CsSubEventResultContinue(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v27 = 0;
  }
  else
  {
    v27 = *((unsigned __int16 *)a1 + 5) - v18;
  }
  if (v27 >= v19)
  {
    if ((_DWORD)v20)
    {
      v29 = (char *)(v26 + v18);
      v30 = v54;
      do
      {
        v31 = *v29++;
        *v30++ = v31;
      }
      while (v30 < (_BYTE *)v54 + v17);
    }
    v28 = *((_WORD *)a1 + 6) + v20;
    *((_WORD *)a1 + 6) = v28;
  }
  else
  {
    *((_BYTE *)a1 + 15) = 1;
    v28 = *((_WORD *)a1 + 6);
  }
  if (*((_BYTE *)a1 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
  v32 = *a1;
  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1541, "void LE_HCIEventHandler_CsSubEventResultContinue(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v33 = 0;
  }
  else
  {
    v33 = *((unsigned __int16 *)a1 + 5) - v28;
  }
  if (v33 >= v19)
  {
    if ((_DWORD)v20)
    {
      v35 = (char *)(v32 + v28);
      v36 = v53;
      do
      {
        v37 = *v35++;
        *v36++ = v37;
      }
      while (v36 < (_BYTE *)v53 + v17);
    }
    v34 = *((_WORD *)a1 + 6) + v20;
    *((_WORD *)a1 + 6) = v34;
  }
  else
  {
    *((_BYTE *)a1 + 15) = 1;
    v34 = *((_WORD *)a1 + 6);
  }
  if (*((_BYTE *)a1 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
  v38 = *a1;
  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1542, "void LE_HCIEventHandler_CsSubEventResultContinue(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v39 = 0;
  }
  else
  {
    v39 = *((unsigned __int16 *)a1 + 5) - v34;
  }
  if (v39 >= v19)
  {
    v40 = (uint64_t)v5;
    v41 = v10;
    v42 = v12;
    v43 = v14;
    v44 = v51;
    if ((_DWORD)v20)
    {
      v45 = (char *)(v38 + v34);
      v46 = v52;
      do
      {
        v47 = *v45++;
        *v46++ = v47;
      }
      while (v46 < (_BYTE *)v52 + v17);
    }
    *((_WORD *)a1 + 6) += v20;
  }
  else
  {
    *((_BYTE *)a1 + 15) = 1;
    v40 = (uint64_t)v5;
    v41 = v10;
    v42 = v12;
    v43 = v14;
    v44 = v51;
  }
  sub_100221320(v40, v41, v42, v43, v44, v20, (uint64_t)v55, (uint64_t)v54, (uint64_t)v53, (uint64_t)v52);
}

void sub_10021E4C0(uint64_t *a1)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned __int16 v6;
  unsigned __int16 v7;
  unsigned __int16 v8;
  unsigned __int16 v9;
  unsigned __int16 v10;
  int v11;
  int v12;
  int v13;
  int v14;
  NSObject *v15;

  if (*((_BYTE *)a1 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1315, "void _HCIEventHandler_SubrateChange(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v2 = *((unsigned __int8 *)a1 + 14);
    *((_BYTE *)a1 + 15) = 1;
    if (v2 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    goto LABEL_13;
  }
  v3 = *((unsigned __int16 *)a1 + 6);
  if (*((unsigned __int16 *)a1 + 5) <= v3)
  {
    *((_BYTE *)a1 + 15) = 1;
LABEL_13:
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1316, "void _HCIEventHandler_SubrateChange(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v11 = *((unsigned __int8 *)a1 + 14);
    *((_BYTE *)a1 + 15) = 1;
    if (v11 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    v5 = 0;
    goto LABEL_15;
  }
  v4 = *a1;
  *((_WORD *)a1 + 6) = v3 + 1;
  v5 = *(unsigned __int8 *)(v4 + v3);
  if (*((unsigned __int16 *)a1 + 5) - ((int)v3 + 1) <= 1)
  {
    *((_BYTE *)a1 + 15) = 1;
LABEL_15:
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1317, "void _HCIEventHandler_SubrateChange(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v12 = *((unsigned __int8 *)a1 + 14);
    *((_BYTE *)a1 + 15) = 1;
    if (v12 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    v6 = 0;
    goto LABEL_17;
  }
  v6 = *(_WORD *)(*a1 + v3 + 1);
  *((_WORD *)a1 + 6) = v3 + 3;
  if (*((unsigned __int16 *)a1 + 5) - (unsigned __int16)(v3 + 3) <= 1)
  {
    *((_BYTE *)a1 + 15) = 1;
LABEL_17:
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1318, "void _HCIEventHandler_SubrateChange(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v13 = *((unsigned __int8 *)a1 + 14);
    *((_BYTE *)a1 + 15) = 1;
    if (v13 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    v7 = 0;
    goto LABEL_19;
  }
  v7 = *(_WORD *)(*a1 + (unsigned __int16)(v3 + 3));
  *((_WORD *)a1 + 6) = v3 + 5;
  if (*((unsigned __int16 *)a1 + 5) - (unsigned __int16)(v3 + 5) <= 1)
  {
    *((_BYTE *)a1 + 15) = 1;
LABEL_19:
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1319, "void _HCIEventHandler_SubrateChange(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v14 = *((unsigned __int8 *)a1 + 14);
    *((_BYTE *)a1 + 15) = 1;
    if (v14 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
    v8 = 0;
    goto LABEL_21;
  }
  v8 = *(_WORD *)(*a1 + (unsigned __int16)(v3 + 5));
  *((_WORD *)a1 + 6) = v3 + 7;
  if (*((unsigned __int16 *)a1 + 5) - (unsigned __int16)(v3 + 7) <= 1)
  {
    *((_BYTE *)a1 + 15) = 1;
LABEL_21:
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 1320, "void _HCIEventHandler_SubrateChange(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t)");
    v9 = 0;
    goto LABEL_22;
  }
  v9 = *(_WORD *)(*a1 + (unsigned __int16)(v3 + 7));
  *((_WORD *)a1 + 6) = v3 + 9;
  if (*((unsigned __int16 *)a1 + 5) - (unsigned __int16)(v3 + 9) >= 2)
  {
    v10 = *(_WORD *)(*a1 + (unsigned __int16)(v3 + 9));
    *((_WORD *)a1 + 6) = v3 + 11;
    goto LABEL_23;
  }
LABEL_22:
  v10 = 0;
  *((_BYTE *)a1 + 15) = 1;
LABEL_23:
  if (sub_10019ACEC(v6))
  {
    sub_10021679C(v5, v6, v7, v8, v9, v10);
  }
  else if (sub_10005549C())
  {
    sub_100054530("LE_HCIEventHandler_RemoteConnectionParameterRequest: Invalid connectionHandle for lmHandle 0x%2x", v6);
    v15 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
}

void sub_10021E84C(uint64_t *a1)
{
  int v1;
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  NSObject *v10;

  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 507, "void _HCIEventHandler_PeriodicAdvSubeventDataReq(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t, _Bool)");
    v1 = 0;
  }
  else
  {
    v2 = *((unsigned __int16 *)a1 + 5);
    v3 = *((unsigned __int16 *)a1 + 6);
    v1 = v2 - v3;
    if (v2 - (_DWORD)v3 == 3)
    {
      if (*((_BYTE *)a1 + 14) != 1)
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
      if (v2 <= v3)
      {
        *((_BYTE *)a1 + 15) = 1;
        if (sub_10005549C())
        {
          sub_100054530("Could not get the advertising handle of the LE Periodic Advertising Subevent Data Request event");
          v8 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
            goto LABEL_11;
        }
      }
      else
      {
        v4 = *a1;
        *((_WORD *)a1 + 6) = v3 + 1;
        if (v2 <= (int)v3 + 1)
        {
          *((_BYTE *)a1 + 15) = 1;
          if (sub_10005549C())
          {
            sub_100054530("Could not get the subevent start of the LE Periodic Advertising Subevent Data Request event");
            v9 = sub_1000544A0(0x42u);
            if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
              goto LABEL_11;
          }
        }
        else
        {
          v5 = *(unsigned __int8 *)(v4 + v3);
          *((_WORD *)a1 + 6) = v3 + 2;
          if (v2 > (int)v3 + 2)
          {
            v6 = *(unsigned __int8 *)(v4 + v3 + 1);
            *((_WORD *)a1 + 6) = v3 + 3;
            nullsub_90(v5, v6);
            return;
          }
          *((_BYTE *)a1 + 15) = 1;
          if (sub_10005549C())
          {
            sub_100054530("Could not get the subevent data count of the LE Periodic Advertising Subevent Data Request event");
            v10 = sub_1000544A0(0x42u);
            if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
              goto LABEL_11;
          }
        }
      }
      return;
    }
  }
  if (sub_10005549C())
  {
    sub_100054530("Invalid Periodic Advertising Subevent Data Request event packet size : %d, expecting %d", v1, 3);
    v7 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
LABEL_11:
      sub_1006CE7A4();
  }
}

void sub_10021EA40(uint64_t *a1)
{
  int v1;
  unsigned int v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  unsigned int v10;
  unsigned int v11;
  void *v12;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;
  NSObject *v16;
  NSObject *v17;
  NSObject *v18;
  NSObject *v19;
  NSObject *v20;
  unsigned int v21;

  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 553, "void _HCIEventHandler_PeriodicAdvResponseReport(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t, _Bool)");
    v1 = 0;
  }
  else
  {
    v3 = *((unsigned __int16 *)a1 + 5);
    v4 = *((unsigned __int16 *)a1 + 6);
    v1 = v3 - v4;
    if (v3 - v4 > 0xA)
    {
      if (*((_BYTE *)a1 + 14) != 1)
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
      if (v3 <= v4)
      {
        *((_BYTE *)a1 + 15) = 1;
        if (sub_10005549C())
        {
          sub_100054530("Could not get the advertising handle of the LE Periodic Advertising Response Report event");
          v13 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
            goto LABEL_6;
        }
      }
      else
      {
        v6 = *a1;
        *((_WORD *)a1 + 6) = v4 + 1;
        if (v3 <= (int)v4 + 1)
        {
          *((_BYTE *)a1 + 15) = 1;
          if (sub_10005549C())
          {
            sub_100054530("Could not get the subevent of the LE Periodic Advertising Response Report event");
            v14 = sub_1000544A0(0x42u);
            if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
              goto LABEL_6;
          }
        }
        else
        {
          v7 = *(unsigned __int8 *)(v6 + v4);
          *((_WORD *)a1 + 6) = v4 + 2;
          if (v3 <= (int)v4 + 2)
          {
            *((_BYTE *)a1 + 15) = 1;
            if (sub_10005549C())
            {
              sub_100054530("Could not get the txStatus of the LE Periodic Advertising Response Report event");
              v15 = sub_1000544A0(0x42u);
              if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
                goto LABEL_6;
            }
          }
          else
          {
            v21 = *(unsigned __int8 *)(v6 + v4 + 1);
            v8 = v4 + 3;
            *((_WORD *)a1 + 6) = v4 + 3;
            if (v3 <= (int)v4 + 3)
            {
              *((_BYTE *)a1 + 15) = 1;
              if (sub_10005549C())
              {
                sub_100054530("Could not get the number of responses of the LE Periodic Advertising Response Report event");
                v16 = sub_1000544A0(0x42u);
                if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
                  goto LABEL_6;
              }
            }
            else
            {
              *((_WORD *)a1 + 6) = v4 + 4;
              if (*(_BYTE *)(v6 + v8))
              {
                v9 = *(unsigned __int8 *)(v6 + v8);
                while (1)
                {
                  if (*((_BYTE *)a1 + 14) != 1)
                    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c");
                  if (*((_BYTE *)a1 + 15))
                    break;
                  v10 = *((unsigned __int16 *)a1 + 5);
                  v11 = *((unsigned __int16 *)a1 + 6);
                  if (v10 <= v11)
                    goto LABEL_37;
                  *((_WORD *)a1 + 6) = v11 + 1;
                  if (v10 <= v11 + 1)
                  {
                    *((_BYTE *)a1 + 15) = 1;
                    if (!sub_10005549C())
                      return;
                    sub_100054530("Could not get the address type of the LE advertising report event");
                    v18 = sub_1000544A0(0x42u);
                    if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
                      return;
                    goto LABEL_6;
                  }
                  *((_WORD *)a1 + 6) = v11 + 2;
                  if (v10 <= v11 + 2)
                  {
                    *((_BYTE *)a1 + 15) = 1;
                    if (!sub_10005549C())
                      return;
                    sub_100054530("Could not get the address of the LE advertising report event");
                    v19 = sub_1000544A0(0x42u);
                    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
                      return;
                    goto LABEL_6;
                  }
                  *((_WORD *)a1 + 6) = v11 + 3;
                  if (v10 <= v11 + 3)
                  {
                    *((_BYTE *)a1 + 15) = 1;
                    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 588, "void _HCIEventHandler_PeriodicAdvResponseReport(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t, _Bool)");
LABEL_47:
                    *((_BYTE *)a1 + 15) = 1;
                    if (!sub_10005549C())
                      return;
                    sub_100054530("Could not get the dataLength of the LE advertising report event");
                    v20 = sub_1000544A0(0x42u);
                    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
                      return;
                    goto LABEL_6;
                  }
                  *((_WORD *)a1 + 6) = v11 + 4;
                  if (v10 <= v11 + 4)
                    goto LABEL_47;
                  *((_WORD *)a1 + 6) = v11 + 5;
                  v12 = sub_100052DC0(0);
                  nullsub_90(v7, v21);
                  sub_100053298(v12);
                  if (!--v9)
                    return;
                }
                sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LE_Events.c", 581, "void _HCIEventHandler_PeriodicAdvResponseReport(OI_BYTE_STREAM *, const HCI_EVENT_DESCRIPTOR *, uint8_t, _Bool)");
LABEL_37:
                *((_BYTE *)a1 + 15) = 1;
                if (!sub_10005549C())
                  return;
                sub_100054530("Could not get the event type of the LE advertising report event");
                v17 = sub_1000544A0(0x42u);
                if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
                  return;
                goto LABEL_6;
              }
            }
          }
        }
      }
      return;
    }
  }
  if (sub_10005549C())
  {
    sub_100054530("Not enough data in the packet : %d, expecting at least %d", v1, 11);
    v5 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
LABEL_6:
      sub_1006CE7A4();
  }
}

void sub_10021EEE8(int a1, uint64_t a2, unsigned __int8 *a3)
{
  NSObject *v5;
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;

  if (a1 > 8258)
  {
    if (a1 > 8317)
    {
      if (a1 == 8318)
      {
        if ((_DWORD)a2)
        {
          if (sub_10005549C())
          {
            sub_100054530("Failed to send connection subrating command: %!", a2);
            v8 = sub_1000544A0(0x42u);
            if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
              goto LABEL_34;
          }
        }
        return;
      }
      if (a1 != 8325)
        goto LABEL_32;
    }
    else if (a1 != 8259)
    {
      if (a1 == 8260)
      {
        if ((_DWORD)a2)
          sub_100111580();
        return;
      }
      goto LABEL_32;
    }
LABEL_22:
    sub_1002167F4(a2, 0, 0, a3, 0, 0, 0, 0, 0, 0xFFFF, 0);
    return;
  }
  if (a1 > 8213)
  {
    if (a1 == 8214)
    {
      if ((_DWORD)a2)
      {
        if (sub_10005549C())
        {
          sub_100054530("Failed to send remote used features: %!", a2);
          v7 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
            goto LABEL_34;
        }
      }
      return;
    }
    if (a1 == 8242)
    {
      if ((_DWORD)a2)
      {
        if (sub_10005549C())
        {
          sub_100054530("Failed to send set phy: %!", a2);
          v6 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
            goto LABEL_34;
        }
      }
      return;
    }
    goto LABEL_32;
  }
  if (a1 == 8205)
    goto LABEL_22;
  if (a1 != 8211)
  {
LABEL_32:
    if (sub_10005549C())
    {
      sub_100054530("Unknown LE event code 0x%x", a1);
      v9 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        goto LABEL_34;
    }
    return;
  }
  if ((_DWORD)a2)
  {
    if (sub_10005549C())
    {
      sub_100054530("Failed to send connection update : %!", a2);
      v5 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
LABEL_34:
        sub_1006CEEC0();
    }
  }
}

void sub_10021F13C(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  NSObject *v5;
  _DWORD *v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  uint8_t buf[4];
  void *v12;

  if (!a1 || !*(_BYTE *)(a1 + 125))
    return;
  if ((int)a2 <= 760)
  {
    if (!(_DWORD)a2)
    {
      if (*(_BYTE *)(a1 + 55))
        v6 = (_DWORD *)(a1 + 56);
      else
        v6 = (_DWORD *)(a1 + 48);
      if (sub_1002307DC(v6) && *(_DWORD *)(a1 + 132))
        goto LABEL_35;
      goto LABEL_21;
    }
    if ((_DWORD)a2 != 634)
    {
      if ((_DWORD)a2 == 706)
      {
        if (sub_10005549C())
        {
          sub_100054530("Encryption failed, peer removed keys, keepConnectedAfterFailedInitialEncryption=%d", *(unsigned __int8 *)(a1 + 264));
          v4 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
            sub_1006CEEC0();
        }
        if (!*(_BYTE *)(a1 + 264))
        {
          *(_DWORD *)(a1 + 132) = 6;
          *(_DWORD *)(a1 + 140) = 4833;
          sub_10021F3D0(a1);
          return;
        }
      }
      goto LABEL_21;
    }
LABEL_13:
    if (sub_10005549C())
    {
      sub_100054530("Encryption failed due to %!, aborting connection notifications, waiting for disconnection event", a2);
      v5 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    return;
  }
  if ((a2 - 761) <= 1)
    goto LABEL_13;
LABEL_21:
  *(_BYTE *)(a1 + 125) = 0;
  if (*(_BYTE *)(a1 + 316))
  {
    if (*(_DWORD *)(a1 + 132) == 5)
      sub_10021F4FC(a1, a2);
LABEL_35:
    if (*(_DWORD *)(a1 + 132) == 5)
      sub_10021F4FC(a1, 0);
    return;
  }
  if (*(_BYTE *)(a1 + 70))
  {
    if (sub_10005549C())
    {
      sub_100054530("FastLEConnection:Skipping LE_GAP_ReadRemoteVersionInformation on encryptionStartedCb");
      v7 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v12 = sub_100054494();
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
    goto LABEL_35;
  }
  v8 = sub_10021F46C(a1);
  if (!(_DWORD)v8)
  {
    *(_BYTE *)(a1 + 126) = 1;
    if (*(_DWORD *)(a1 + 132) != 6)
      *(_DWORD *)(a1 + 132) = 1;
    goto LABEL_35;
  }
  v9 = v8;
  if (sub_10005549C())
  {
    sub_100054530("LE_GAP_ReadRemoteVersionInformation failed %!", v9);
    v10 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  *(_DWORD *)(a1 + 132) = 5;
}

uint64_t sub_10021F3D0(uint64_t a1)
{
  NSObject *v3;

  if (!dword_100999250)
    return 103;
  if (a1 && sub_10019AC00(a1))
    return sub_1002143C0(a1, 19);
  if (sub_10005549C())
  {
    sub_100054530("This handle is not a LE connection.");
    v3 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  return 1310;
}

uint64_t sub_10021F46C(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t result;
  const void *v10[2];
  uint64_t v11;

  v11 = a1;
  if (!a1)
    return 1310;
  v1 = a1;
  if (!sub_10019AC00(a1))
    return 1310;
  if (dword_10098EDE4)
  {
    v10[1] = &v11;
    v10[0] = (const void *)8;
    result = sub_10004A9EC((uint64_t)sub_100224050, v10, (unsigned __int16)((dword_10098EDE4 + 99) / 0x64u), 0);
    if (!(_DWORD)result)
      return result;
    v1 = v11;
  }
  return sub_100216754(v1, v2, v3, v4, v5, v6, v7, v8);
}

void sub_10021F4FC(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  void *v5;
  const char *v6;
  NSObject *v7;
  unsigned int v8;
  unint64_t v9;
  void (*v10)(uint64_t, _QWORD, _QWORD);
  uint64_t v11;
  uint8_t buf[4];
  void *v13;

  if (a1 && !(_DWORD)a2)
  {
    v11 = 0;
    sub_10004AD30((uint64_t)&v11);
    *(_DWORD *)(a1 + 328) = sub_100258A4C((int *)(a1 + 320), (int *)&v11);
    if (sub_10005549C())
    {
      sub_100054530("LinkReady took %llums from connectionComplete", *(unsigned int *)(a1 + 328));
      v4 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        v5 = sub_100054494();
        *(_DWORD *)buf = 136446210;
        v13 = v5;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
    goto LABEL_12;
  }
  if (!(_DWORD)a2)
  {
LABEL_12:
    v8 = (unsigned __int16)word_10098AAF0;
    if (word_10098AAF0)
    {
      v9 = 0;
      do
      {
        v10 = *(void (**)(uint64_t, _QWORD, _QWORD))(qword_10098AAF8[v9] + 40);
        if (v10)
        {
          v10(a1, 0, *(unsigned __int8 *)(a1 + 316));
          v8 = (unsigned __int16)word_10098AAF0;
        }
        ++v9;
      }
      while (v9 < v8);
    }
    goto LABEL_17;
  }
  if ((_DWORD)a2 != 719 && *(_BYTE *)(a1 + 124) != 7)
  {
    if (sub_10005549C())
    {
      v6 = sub_10019C5F4(*(unsigned __int8 *)(a1 + 124));
      sub_100054530("GAP LinkReadyCB error with status %! during %s, not-disconnecting", a2, v6);
      v7 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
LABEL_17:
  *(_DWORD *)(a1 + 132) = 7;
  *(_BYTE *)(a1 + 316) = 0;
}

uint64_t sub_10021F6A8(uint64_t a1)
{
  __int16 v1;
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  unsigned __int8 v5;

  v1 = word_10098AAF0;
  v2 = (unsigned __int16)word_10098AAF0;
  if (word_10098AAF0)
  {
    if (word_10098AAF0 == 8)
    {
      if (sub_10005549C())
      {
        sub_100054530("Can't add anymore callbacks.");
        v3 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return 4050;
    }
    else
    {
      v5 = 0;
      while (qword_10098AAF8[v5] != a1)
      {
        if ((unsigned __int16)word_10098AAF0 <= ++v5)
        {
          v2 = v5;
          goto LABEL_11;
        }
      }
      return 0;
    }
  }
  else
  {
LABEL_11:
    v4 = 0;
    qword_10098AAF8[v2] = a1;
    word_10098AAF0 = v1 + 1;
  }
  return v4;
}

uint64_t sub_10021F770(uint64_t a1)
{
  __int16 v1;
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  unsigned __int8 v5;

  v1 = word_10098AB38;
  v2 = (unsigned __int16)word_10098AB38;
  if (word_10098AB38)
  {
    if (word_10098AB38 == 8)
    {
      if (sub_10005549C())
      {
        sub_100054530("Can't add anymore callbacks.");
        v3 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return 4050;
    }
    else
    {
      v5 = 0;
      while (qword_10098AB40[v5] != a1)
      {
        if ((unsigned __int16)word_10098AB38 <= ++v5)
        {
          v2 = v5;
          goto LABEL_11;
        }
      }
      return 0;
    }
  }
  else
  {
LABEL_11:
    v4 = 0;
    qword_10098AB40[v2] = a1;
    word_10098AB38 = v1 + 1;
  }
  return v4;
}

uint64_t sub_10021F838(uint64_t result)
{
  unsigned __int8 v1;
  unsigned __int16 v2;
  uint64_t v3;

  if (word_10098AAF0)
  {
    v1 = 0;
    while (qword_10098AAF8[v1] != result)
    {
      if ((unsigned __int16)word_10098AAF0 <= ++v1)
        return result;
    }
    v3 = qword_10098AAF8[(unsigned __int16)--word_10098AAF0];
    v2 = word_10098AAF0;
    qword_10098AAF8[v1] = v3;
    qword_10098AAF8[v2] = 0;
  }
  return result;
}

void sub_10021F88C(unsigned __int8 *a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4)
{
  NSObject *v8;
  unsigned __int8 *v9;
  unint64_t v10;
  char *v11;
  NSObject *v12;
  void *v13;
  uint64_t v14;
  NSObject *v15;
  void *v16;
  int v17;
  NSObject *v18;
  unsigned __int16 v19;
  unsigned __int8 v20;
  void (*v21)(unsigned __int8 *, unsigned __int16 *, uint64_t, uint64_t, _BOOL8);
  _BOOL8 v22;
  NSObject *v23;
  void *v24;
  uint64_t v25;
  uint64_t v26;
  NSObject *v27;
  NSObject *v28;
  uint8_t buf[16];
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  int v35;

  if (byte_10098AB80 == 1)
  {
    if (sub_10005549C())
    {
      sub_100054530("Connection complete, we need to update our own address now");
      v8 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = sub_100054494();
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
    sub_10021FDB8();
  }
  if (a2)
  {
    if (*((_BYTE *)a2 + 55))
      v9 = (unsigned __int8 *)(a2 + 28);
    else
      v9 = a1;
    v10 = ((unint64_t)v9[1] << 40) | ((unint64_t)v9[2] << 32) | ((unint64_t)v9[3] << 24) | ((unint64_t)v9[4] << 16) | ((unint64_t)v9[5] << 8) | v9[6] | ((unint64_t)*v9 << 48);
    if (sub_1002201B0(v10))
    {
      if (sub_10005549C())
      {
        v11 = *a1 ? "Random" : "Public";
        sub_100054530("FastLEConnection:LE_GAP_IsFastLeConnectionEnabledForAddress enabled for %s:%:", v11, a1 + 1);
        v12 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          v13 = sub_100054494();
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = v13;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
        }
      }
      *((_BYTE *)a2 + 316) = 1;
      *((_BYTE *)a2 + 317) = sub_100220368(v10);
      *((_BYTE *)a2 + 318) = sub_100220554(v10);
    }
    if (*((_BYTE *)a2 + 55))
    {
      v35 = 0;
      v33 = 0u;
      v34 = 0u;
      v31 = 0u;
      v32 = 0u;
      *(_OWORD *)buf = 0u;
      v30 = 0u;
      *(_DWORD *)&buf[1] = *(_DWORD *)((char *)a2 + 49);
      *(_WORD *)&buf[5] = *(unsigned __int16 *)((char *)a2 + 53);
      buf[7] = *((_BYTE *)a2 + 56);
      *(_DWORD *)&buf[8] = *(_DWORD *)((char *)a2 + 57);
      *(_WORD *)&buf[12] = *(unsigned __int16 *)((char *)a2 + 61);
      sub_10011D7FC(buf, 14);
      a1 = (unsigned __int8 *)(a2 + 28);
    }
    if (!(_DWORD)a3)
    {
      if (*((_BYTE *)a2 + 70) == 1)
      {
        byte_10098AC39 &= 0xFCu;
        sub_100204FEC(0);
      }
      else if (*((_BYTE *)a2 + 316))
      {
        if (sub_10005549C())
        {
          sub_100054530("FastLEConnection:Skipping startLinkEncryption, pendingAuth=%d", *((unsigned __int8 *)a2 + 317));
          v15 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            v16 = sub_100054494();
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = v16;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
          }
        }
        *((_BYTE *)a2 + 125) = *((_BYTE *)a2 + 317);
      }
      else
      {
        if (!sub_100220740((uint64_t)a2))
        {
          v17 = 1;
          *((_BYTE *)a2 + 125) = 1;
          goto LABEL_37;
        }
        if (sub_10005549C())
        {
          sub_100054530("Encryption start fails with status %!", 0);
          v28 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
            sub_1006CEEC0();
        }
      }
      v17 = 1;
      goto LABEL_37;
    }
  }
  if ((_DWORD)a3 != 702 && sub_10005549C())
  {
    v14 = a2 ? *a2 : 0;
    sub_100054530("GAP_ConnectionCompleteCallback with error stats %! on lm 0x%x", a3, v14);
    v18 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  v17 = 0;
LABEL_37:
  v19 = word_10098AAF0;
  if (word_10098AAF0)
  {
    v20 = 0;
    do
    {
      v21 = *(void (**)(unsigned __int8 *, unsigned __int16 *, uint64_t, uint64_t, _BOOL8))qword_10098AAF8[v20];
      if (v21)
      {
        if (a2)
          v22 = *((_BYTE *)a2 + 316) != 0;
        else
          v22 = 0;
        v21(a1, a2, a3, a4, v22);
        v19 = word_10098AAF0;
      }
      ++v20;
    }
    while (v19 > v20);
  }
  if (v17 && *((_BYTE *)a2 + 70) == 1)
  {
    if (*((_DWORD *)a2 + 33))
      sub_100253460();
    if (*((_BYTE *)a2 + 316))
    {
      if (sub_10005549C())
      {
        sub_100054530("FastLEConnection:Skipping LE_GAP_ReadRemoteVersionInformation");
        v23 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          v24 = sub_100054494();
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = v24;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
        }
      }
    }
    else
    {
      v25 = sub_10021F46C((uint64_t)a2);
      if ((_DWORD)v25)
      {
        v26 = v25;
        if (sub_10005549C())
        {
          sub_100054530("LE_GAP_ReadRemoteVersionInformation failed %!", v26);
          v27 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
            sub_1006CEEC0();
        }
        sub_10021F4FC((uint64_t)a2, v26);
      }
      else
      {
        *((_DWORD *)a2 + 33) = 1;
      }
    }
  }
}

void sub_10021FDB8()
{
  int v0;
  unsigned int v1;
  unint64_t v2;
  int v3;
  int v4;
  int v5;
  int v6;
  _BOOL4 v7;
  NSObject *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  void *v14;
  NSObject *v15;
  void *v16;
  uint64_t v17;
  uint8_t buf[4];
  void *v19;

  if (byte_10098EDF4 == 1)
  {
    *(_WORD *)buf = 0;
    v0 = sub_10025391C(dword_10098EDF0, buf);
    v1 = 100 * *(unsigned __int16 *)buf;
    if (v0)
      v1 = 0;
    v2 = (9162597 * (unint64_t)v1) >> 39;
    v3 = (unsigned __int16)(((8589935 * (unint64_t)v1) >> 33)
                          - 60
                          * ((unsigned __int16)((17477 * (((8589935 * (unint64_t)v1) >> 32) >> 1)) >> 16) >> 4));
  }
  else
  {
    v3 = 0;
    LODWORD(v2) = 0;
  }
  if (sub_10005549C())
  {
    v4 = byte_10098EDE0;
    v5 = byte_10098EDE1;
    v6 = sub_10021437C();
    v7 = sub_10022B8CC();
    sub_100054530("refreshing PrivateAddressTimer gPrivateMode=%d gOverrideLocalAddress=%d IsConnectionInProgress=%d IsScanInProgress=%d gHoldStableAddress=%d gHoldStableAddressCount=%d gLeHoldStablePrivateAddressTimer=%d Hold Time Remaining=%d:%d", v4, v5, v6, v7, byte_10098EDF4, (unsigned __int16)word_10098EDF6, dword_10098EDF0, v2, v3);
    v8 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = sub_100054494();
      *(_DWORD *)buf = 136446210;
      v19 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  sub_100223450();
  byte_10098EDF4 = 0;
  word_10098EDF6 = 0;
  sub_1002261B8();
  if (!byte_10098EDE0 && (byte_10098EDE1 & 1) == 0)
  {
    if (sub_100206FA4())
    {
      if (byte_10098EDFA)
      {
LABEL_13:
        byte_10098EDF8 = 0;
        v10 = sub_1002241E8(byte_10098EDAD);
        if ((_DWORD)v10)
        {
          v11 = v10;
          if (sub_10005549C())
          {
            sub_100054530("createAddress with type %d failed with stats %! in refreshLePrivateAddress", byte_10098EDAD, v11);
            v12 = sub_1000544A0(0x42u);
            if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
              sub_1006CE7A4();
          }
        }
        sub_10022353C((int *)((char *)&dword_10098EDAE[2 * byte_10098EDAD] - byte_10098EDAD), 1);
        return;
      }
      if ((sub_10021437C() & 1) == 0 && !sub_10022B8CC())
      {
        if (!byte_10098EDFA)
        {
          byte_10098AB80 = 0;
          byte_10098EDFB = 0;
          dword_10098EDFC = 0;
          word_10098EE00 = 0;
        }
        goto LABEL_13;
      }
      if ((byte_10098AB80 & 1) == 0 && (byte_10098EDFB & 1) == 0)
        sub_1001132AC((uint64_t)&dword_10098EDFC);
      if (sub_10021437C())
        byte_10098AB80 = 1;
      if (sub_10022B8CC())
        byte_10098EDFB = 1;
      v17 = 0;
      sub_1001132AC((uint64_t)&v17);
      if (sub_10005549C())
      {
        sub_100054530("Busy with a connection/scan, can't update an address right now (gRefreshLocalAddressOnConnectionComplete=%d gRefreshLocalAddressOnScanComplete=%d). Address refresh deferral for %d seconds", byte_10098AB80, byte_10098EDFB, v17 - dword_10098EDFC);
        v15 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          v16 = sub_100054494();
          *(_DWORD *)buf = 136446210;
          v19 = v16;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
        }
      }
    }
    else
    {
      if (sub_10005549C())
      {
        sub_100054530("Advertising is starting/stopping, wait with the address change until we're settled");
        v13 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          v14 = sub_100054494();
          *(_DWORD *)buf = 136446210;
          v19 = v14;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
        }
      }
      byte_10098EDF8 = 1;
    }
    sub_100226000();
  }
}

BOOL sub_1002201B0(unint64_t a1)
{
  _BOOL8 v1;
  NSObject *v2;
  unint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  NSObject *v9;
  void *v10;
  int v11;
  __int16 v12;
  char v13;
  uint8_t buf[4];
  void *v15;

  if ((a1 & 0xFFFFFFFFFFFFLL) == 0)
  {
    if (sub_10005549C())
    {
      sub_100054530("FastLeConnection:LE_GAP_IsFastLeConnectionEnabledForAddress compare with zero address");
      v2 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 0;
  }
  if (!byte_10098EE18)
    return 0;
  if (qword_10098EE20 != a1)
  {
    v4 = 0;
    v5 = &qword_10098EE30;
    while (byte_10098EE18 - 1 != v4)
    {
      v6 = *v5;
      v5 += 2;
      ++v4;
      if (v6 == a1)
      {
        v1 = v4 < byte_10098EE18;
        goto LABEL_14;
      }
    }
    return 0;
  }
  v1 = 1;
LABEL_14:
  v13 = a1;
  v7 = (a1 << 32) & 0xFF0000000000 | (a1 << 48) | (a1 << 16) & 0xFF00000000 | a1 & 0xFF000000 | (a1 >> 16) & 0xFF0000 | WORD2(a1) & 0xFF00 | BYTE6(a1);
  v12 = ((a1 << 32) & 0xFF0000000000 | (a1 << 48) | (a1 << 16) & 0xFFFFFFFFFFLL) >> 32;
  v11 = a1 & 0xFF000000 | (a1 >> 16) & 0xFF0000 | WORD2(a1) & 0xFF00 | BYTE6(a1);
  if (sub_10005549C())
  {
    v8 = "Random";
    if (!(_BYTE)v7)
      v8 = "Public";
    sub_100054530("FastLeConnection:LE_GAP_IsFastLeConnectionEnabledForAddress for %s:%: enabled", v8, (char *)&v11 + 1);
    v9 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      v10 = sub_100054494();
      *(_DWORD *)buf = 136446210;
      v15 = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  return v1;
}

uint64_t sub_100220368(unint64_t a1)
{
  unsigned int v1;
  unint64_t v2;
  _BOOL4 v3;
  uint64_t result;
  NSObject *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  NSObject *v10;
  void *v11;
  uint64_t v12;
  uint8_t buf[4];
  void *v14;

  if ((a1 & 0xFFFFFFFFFFFFLL) != 0)
  {
    v1 = byte_10098EE18;
    if (byte_10098EE18)
    {
      if (qword_10098EE20[0] == a1)
      {
        v2 = 0;
        v3 = 1;
LABEL_12:
        BYTE6(v12) = a1;
        v8 = (a1 << 32) & 0xFF0000000000 | (a1 << 48) | (a1 << 16) & 0xFF00000000 | a1 & 0xFF000000 | (a1 >> 16) & 0xFF0000 | WORD2(a1) & 0xFF00 | BYTE6(a1);
        WORD2(v12) = ((a1 << 32) & 0xFF0000000000 | (a1 << 48) | (a1 << 16) & 0xFFFFFFFFFFLL) >> 32;
        LODWORD(v12) = a1 & 0xFF000000 | (a1 >> 16) & 0xFF0000 | WORD2(a1) & 0xFF00 | BYTE6(a1);
        if (sub_10005549C())
        {
          v9 = "Random";
          if (!(_BYTE)v8)
            v9 = "Public";
          sub_100054530("FastLeConnection:LE_GAP_IsFastLeConnectionEncryptionExpectedForAddress for %s:%: pending:%d", v9, (char *)&v12 + 1, LOBYTE(qword_10098EE20[2 * v2 + 1]), v12);
          v10 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
          {
            v11 = sub_100054494();
            *(_DWORD *)buf = 136446210;
            v14 = v11;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
          }
        }
        v1 = LOBYTE(qword_10098EE20[2 * v2 + 1]) != 0;
        return v3 & v1;
      }
      v2 = 0;
      v6 = &qword_10098EE30;
      while (byte_10098EE18 - 1 != v2)
      {
        v7 = *v6;
        v6 += 2;
        ++v2;
        if (v7 == a1)
        {
          v3 = v2 < byte_10098EE18;
          goto LABEL_12;
        }
      }
    }
    v3 = 0;
    return v3 & v1;
  }
  result = sub_10005549C();
  if ((_DWORD)result)
  {
    sub_100054530("FastLeConnection:LE_GAP_IsFastLeConnectionEncryptionExpectedForAddress compare with zero address");
    v5 = sub_1000544A0(0x42u);
    result = os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
    {
      sub_1006CE7A4();
      return 0;
    }
  }
  return result;
}

uint64_t sub_100220554(unint64_t a1)
{
  unsigned int v1;
  unint64_t v2;
  _BOOL4 v3;
  uint64_t result;
  NSObject *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  NSObject *v10;
  void *v11;
  uint64_t v12;
  uint8_t buf[4];
  void *v14;

  if ((a1 & 0xFFFFFFFFFFFFLL) != 0)
  {
    v1 = byte_10098EE18;
    if (byte_10098EE18)
    {
      if (qword_10098EE20[0] == a1)
      {
        v2 = 0;
        v3 = 1;
LABEL_12:
        BYTE6(v12) = a1;
        v8 = (a1 << 32) & 0xFF0000000000 | (a1 << 48) | (a1 << 16) & 0xFF00000000 | a1 & 0xFF000000 | (a1 >> 16) & 0xFF0000 | WORD2(a1) & 0xFF00 | BYTE6(a1);
        WORD2(v12) = ((a1 << 32) & 0xFF0000000000 | (a1 << 48) | (a1 << 16) & 0xFFFFFFFFFFLL) >> 32;
        LODWORD(v12) = a1 & 0xFF000000 | (a1 >> 16) & 0xFF0000 | WORD2(a1) & 0xFF00 | BYTE6(a1);
        if (sub_10005549C())
        {
          v9 = "Random";
          if (!(_BYTE)v8)
            v9 = "Public";
          sub_100054530("FastLeConnection:LE_GAP_IsFastLeConnectionEncryptionFakeEvent for %s:%: fakeEncryptionEvent:%d", v9, (char *)&v12 + 1, BYTE1(qword_10098EE20[2 * v2 + 1]), v12);
          v10 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
          {
            v11 = sub_100054494();
            *(_DWORD *)buf = 136446210;
            v14 = v11;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
          }
        }
        v1 = BYTE1(qword_10098EE20[2 * v2 + 1]) != 0;
        return v3 & v1;
      }
      v2 = 0;
      v6 = &qword_10098EE30;
      while (byte_10098EE18 - 1 != v2)
      {
        v7 = *v6;
        v6 += 2;
        ++v2;
        if (v7 == a1)
        {
          v3 = v2 < byte_10098EE18;
          goto LABEL_12;
        }
      }
    }
    v3 = 0;
    return v3 & v1;
  }
  result = sub_10005549C();
  if ((_DWORD)result)
  {
    sub_100054530("FastLeConnection:LE_GAP_IsFastLeConnectionEncryptionFakeEvent compare with zero address");
    v5 = sub_1000544A0(0x42u);
    result = os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
    {
      sub_1006CE7A4();
      return 0;
    }
  }
  return result;
}

uint64_t sub_100220740(uint64_t a1)
{
  uint64_t result;
  const void *v2[2];
  uint64_t v3;

  v3 = a1;
  if (dword_10098EDE4)
  {
    v2[1] = &v3;
    v2[0] = (const void *)8;
    result = sub_10004A9EC((uint64_t)sub_100225BB4, v2, (unsigned __int16)((dword_10098EDE4 + 99) / 0x64u), 0);
    if (!(_DWORD)result)
      return result;
    a1 = v3;
  }
  return sub_10022D834(a1);
}

void sub_1002207AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 v11;
  void (*v12)(uint64_t, uint64_t, uint64_t, uint64_t);
  uint8_t buf[4];
  void *v14;

  if (!a1)
    sub_100253460();
  if (*(_DWORD *)(a1 + 140) && *(_DWORD *)(a1 + 132) == 6)
  {
    if (sub_10005549C())
    {
      sub_100054530("Link disconnected readyStateReason:%!, readyStatus:LE_READY_DISCONNECTING, overriding", *(unsigned int *)(a1 + 140));
      v8 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v14 = sub_100054494();
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
    a2 = *(unsigned int *)(a1 + 140);
  }
  if (mach_continuous_time() <= a4)
  {
    v10 = 0;
  }
  else
  {
    v9 = mach_continuous_time();
    v10 = UpTicksToMilliseconds(v9 - a4);
  }
  if (word_10098AAF0)
  {
    v11 = 0;
    do
    {
      v12 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(qword_10098AAF8[v11] + 8);
      if (v12)
      {
        v12(a1, a2, a3, v10);
        if (*(_BYTE *)(a1 + 127))
          sub_10021555C((unsigned __int16 *)a1, 7u);
      }
      ++v11;
    }
    while ((unsigned __int16)word_10098AAF0 > v11);
  }
  if (off_10098AB88)
  {
    if (!sub_10019C27C())
    {
      off_10098AB88();
      off_10098AB88 = 0;
    }
  }
}

uint64_t sub_100220958(uint64_t result)
{
  unsigned __int16 v1;
  uint64_t v2;
  unsigned __int8 v3;
  uint64_t (*v4)(uint64_t);

  v1 = word_10098AAF0;
  if (word_10098AAF0)
  {
    v2 = result;
    v3 = 0;
    do
    {
      v4 = *(uint64_t (**)(uint64_t))(qword_10098AAF8[v3] + 16);
      if (v4)
      {
        result = v4(v2);
        v1 = word_10098AAF0;
      }
      ++v3;
    }
    while (v1 > v3);
  }
  return result;
}

uint64_t sub_1002209C0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unsigned __int16 v5;
  uint64_t v10;
  unsigned __int8 v11;
  uint64_t (*v12)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);

  v5 = word_10098AAF0;
  if (word_10098AAF0)
  {
    v10 = result;
    v11 = 0;
    do
    {
      v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(qword_10098AAF8[v11] + 24);
      if (v12)
      {
        result = v12(v10, a2, a3, a4, a5);
        v5 = word_10098AAF0;
      }
      ++v11;
    }
    while (v5 > v11);
  }
  return result;
}

uint64_t sub_100220A58(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unsigned __int16 v5;
  uint64_t v10;
  unsigned __int8 v11;
  uint64_t (*v12)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);

  v5 = word_10098AAF0;
  if (word_10098AAF0)
  {
    v10 = result;
    v11 = 0;
    do
    {
      v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(qword_10098AAF8[v11] + 32);
      if (v12)
      {
        result = v12(v10, a2, a3, a4, a5);
        v5 = word_10098AAF0;
      }
      ++v11;
    }
    while (v5 > v11);
  }
  return result;
}

void sub_100220AF0(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  NSObject *v18;
  NSObject *v19;
  uint64_t v20;
  NSObject *v21;
  void *v22;
  int v23;
  uint64_t v24;
  NSObject *v25;
  uint8_t buf[4];
  void *v27;

  if (sub_10005549C())
  {
    v17 = sub_100212EDC(*(_DWORD *)(a2 + 132));
    sub_100054530("ReadRemoteVersionInformationCB LMPVersion=%d mfgName=%d LMPSubVersion=%d status %!, ready: %s, role %d", a3, a4, a5, a1, v17, *(unsigned __int8 *)(a2 + 70));
    v18 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v27 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if (!(_DWORD)a1)
  {
    if (*(_DWORD *)(a2 + 132) != 1)
      sub_100253460();
    *(_DWORD *)(a2 + 132) = 5;
    if (a3 <= 6)
    {
      v20 = 0;
      *(_BYTE *)(a2 + 126) = 0;
LABEL_21:
      sub_10021F4FC(a2, v20);
      return;
    }
    if (*(_BYTE *)(a2 + 70) && (BYTE4(xmmword_100998F78) & 8) == 0)
      goto LABEL_17;
    if (*(_BYTE *)(a2 + 316))
    {
      *(_DWORD *)(a2 + 132) = 2;
      v20 = 0;
      if (sub_10005549C())
      {
        sub_100054530("FastLEConnection:LE_GAP_ReadRemoteVersionInformationCompleteCallback skipping LE_ReadRemoteUsedFeatures due to FastLEConnection");
        v21 = sub_1000544A0(0x42u);
        v20 = 0;
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          v22 = sub_100054494();
          *(_DWORD *)buf = 136446210;
          v27 = v22;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
LABEL_17:
          v20 = 0;
        }
      }
    }
    else
    {
      v24 = sub_100216778(a2, v10, v11, v12, v13, v14, v15, v16);
      if (!(_DWORD)v24)
      {
        *(_DWORD *)(a2 + 132) = 2;
        *(_BYTE *)(a2 + 126) = 0;
        return;
      }
      v20 = v24;
      if (sub_10005549C())
      {
        sub_100054530("ReadRemoteUsedFeatures failed %!", v20);
        v25 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          sub_1006CEEC0();
      }
    }
    v23 = *(_DWORD *)(a2 + 132);
    *(_BYTE *)(a2 + 126) = 0;
    if (v23 != 5)
      return;
    goto LABEL_21;
  }
  if (sub_10005549C())
  {
    sub_100054530("ReadRemoteVersionInformationCB %!, waiting for disconnection event", a1);
    v19 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
}

void sub_100220D84(uint64_t a1, uint64_t a2, char *a3)
{
  char v6;
  unsigned int v7;
  NSObject *v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  int v12;
  int v13;
  const char *v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  unsigned int v19;
  const char *v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  NSObject *v24;
  uint8_t buf[4];
  void *v26;

  v6 = *a3;
  v7 = a3[1];
  *(_BYTE *)(a2 + 290) = (a3[4] & 0x60) != 0;
  if ((_DWORD)a1 && *(_DWORD *)(a2 + 140) == 5300)
  {
    if (sub_10005549C())
    {
      sub_100054530("ReadRemoteUsedFeaturesCB %!, waiting for disconnection event", a1);
      v8 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    return;
  }
  if (*(_DWORD *)(a2 + 132) != 2)
    sub_100253460();
  if ((_DWORD)a1)
  {
    if ((_DWORD)a1 == 726)
      v9 = 0;
    else
      v9 = a1;
    sub_10021F4FC(a2, v9);
    return;
  }
  v10 = v6 & 0x20;
  v11 = v7 & 1;
  if ((v7 & 1) == 0 || !sub_100182948())
  {
    v12 = 0;
    if ((v6 & 0x20) != 0)
      goto LABEL_16;
LABEL_18:
    v13 = 0;
    goto LABEL_19;
  }
  v12 = sub_100192EC4() ^ 1;
  if ((v6 & 0x20) == 0)
    goto LABEL_18;
LABEL_16:
  v13 = sub_100182938();
LABEL_19:
  if (sub_10005549C())
  {
    v14 = sub_100212EDC(*(_DWORD *)(a2 + 132));
    v15 = v10 >> 5;
    v16 = sub_100182938();
    v17 = sub_100182948();
    v18 = (v7 >> 6) & 1;
    v19 = sub_100182958();
    v20 = "yes";
    if (!*(_BYTE *)(a2 + 152))
      v20 = "no";
    sub_100054530("Remote Features: %@ , handle %x, ready: %s, EDL [remote %d, local %d], 2M [remote %d, local %d], ChanSel2 [remote %d, local %d] PHYReady:%s, SupportsSubrating: %d", a3, 8, a2, v14, v15, v16, v11, v17, v18, v19, v20, *(unsigned __int8 *)(a2 + 290));
    v21 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v26 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if ((v12 | v13) == 1 && (((v12 | v13 ^ 1) & 1) != 0 || *(_DWORD *)(a2 + 136) != 1))
  {
    if (!*(_BYTE *)(a2 + 152))
    {
      sub_100217684(a2, v13, v12, 0);
      return;
    }
    v22 = sub_10021497C((unsigned __int16 *)a2, 4u);
    if ((_DWORD)v22)
    {
      v23 = v22;
      if ((_DWORD)v22 != 4000)
      {
        if (sub_10005549C())
        {
          sub_100054530("PhyUpdateComplete LE scaling completed with error %!", v23);
          v24 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
            sub_1006CEEC0();
        }
      }
    }
  }
  sub_10021F4FC(a2, 0);
}

uint64_t sub_100221088(uint64_t result, uint64_t a2, uint64_t a3)
{
  unsigned __int16 v3;
  uint64_t v6;
  unsigned __int8 v7;
  uint64_t (*v8)(uint64_t, uint64_t, uint64_t);

  v3 = word_10098AB38;
  if (word_10098AB38)
  {
    v6 = result;
    v7 = 0;
    do
    {
      v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))**((_QWORD **)&unk_10098AB40 + v7);
      if (v8)
      {
        result = v8(v6, a2, a3);
        v3 = word_10098AB38;
      }
      ++v7;
    }
    while (v3 > v7);
  }
  return result;
}

uint64_t sub_100221108(uint64_t result, uint64_t a2)
{
  unsigned __int16 v2;
  uint64_t v4;
  unsigned __int8 v5;
  uint64_t (*v6)(uint64_t, uint64_t);

  v2 = word_10098AB38;
  if (word_10098AB38)
  {
    v4 = result;
    v5 = 0;
    do
    {
      v6 = *(uint64_t (**)(uint64_t, uint64_t))(qword_10098AB40[v5] + 8);
      if (v6)
      {
        result = v6(v4, a2);
        v2 = word_10098AB38;
      }
      ++v5;
    }
    while (v2 > v5);
  }
  return result;
}

uint64_t sub_100221180(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, unsigned int a7, unsigned int a8, __int16 a9, char a10)
{
  unsigned __int16 v10;
  uint64_t v15;
  unsigned __int8 v16;
  uint64_t (*v17)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, uint64_t);
  uint64_t v18;

  HIDWORD(v18) = a6;
  v10 = word_10098AB38;
  if (word_10098AB38)
  {
    v15 = result;
    v16 = 0;
    do
    {
      v17 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, uint64_t))(qword_10098AB40[v16] + 16);
      if (v17)
      {
        BYTE2(v18) = a10;
        LOWORD(v18) = a9;
        result = v17(v15, a2, a3, a4, a5, HIDWORD(v18), a7, a8, v18);
        v10 = word_10098AB38;
      }
      ++v16;
    }
    while (v10 > v16);
  }
  return result;
}

uint64_t sub_100221254(uint64_t result, uint64_t a2, uint64_t a3, unsigned int a4, unsigned int a5, unsigned int a6, unsigned int a7, unsigned int a8, char a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  unsigned __int16 v13;
  uint64_t v16;
  unsigned __int8 v17;
  uint64_t (*v18)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, int, uint64_t, uint64_t, uint64_t, uint64_t);
  int v19;

  v13 = word_10098AB38;
  if (word_10098AB38)
  {
    v16 = result;
    v17 = 0;
    do
    {
      v18 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, int, uint64_t, uint64_t, uint64_t, uint64_t))(qword_10098AB40[v17] + 24);
      if (v18)
      {
        LOBYTE(v19) = a9;
        result = v18(v16, a2, a3, a4, a5, a6, a7, a8, v19, a10, a11, a12, a13);
        v13 = word_10098AB38;
      }
      ++v17;
    }
    while (v13 > v17);
  }
  return result;
}

uint64_t sub_100221320(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  unsigned __int16 v10;
  uint64_t v16;
  unsigned __int8 v17;
  uint64_t v18;

  v10 = word_10098AB38;
  if (word_10098AB38)
  {
    v16 = result;
    v17 = 0;
    do
    {
      v18 = qword_10098AB40[v17];
      if (*(_QWORD *)(v18 + 24))
      {
        result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v18 + 32))(v16, a2, a3, a4, a5, a6, a7, a8, a9, a10);
        v10 = word_10098AB38;
      }
      ++v17;
    }
    while (v10 > v17);
  }
  return result;
}

uint64_t sub_1002213E8(uint64_t a1, _WORD *a2)
{
  uint64_t result;

  if (!a2)
    return 101;
  if (!dword_100999250)
    return 103;
  if (!sub_10019AC00(a1))
    return 4051;
  result = 0;
  *a2 = *(_WORD *)(a1 + 80);
  return result;
}

uint64_t sub_100221448(uint64_t a1, __int16 *a2)
{
  uint64_t result;
  __int16 v5;

  if (!a2)
    return 101;
  if (!dword_100999250)
    return 103;
  if (!sub_10019AC00(a1))
    return 149;
  result = 0;
  v5 = *(_WORD *)(a1 + 86);
  if (!v5)
    v5 = 12;
  *a2 = v5;
  return result;
}

uint64_t sub_1002214B4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  int v7;
  __int16 v8;
  uint64_t result;
  int v10;
  __int16 v11;

  if (!dword_100999250)
    return 103;
  if (!sub_10019AC00(a1))
    return 4052;
  v6 = a1 + 48;
  if (a3)
  {
    if (*(_BYTE *)(a1 + 55))
    {
      v7 = *(_DWORD *)(a1 + 56);
      v8 = *(_WORD *)(a1 + 60);
      *(_BYTE *)(a3 + 6) = *(_BYTE *)(a1 + 62);
      *(_WORD *)(a3 + 4) = v8;
      *(_DWORD *)a3 = v7;
    }
    else
    {
      *(_DWORD *)(a3 + 3) = 0;
      *(_DWORD *)a3 = 0;
    }
  }
  else if (*(_BYTE *)(a1 + 55))
  {
    v6 = a1 + 56;
  }
  result = 0;
  v10 = *(_DWORD *)v6;
  v11 = *(_WORD *)(v6 + 4);
  *(_BYTE *)(a2 + 6) = *(_BYTE *)(v6 + 6);
  *(_WORD *)(a2 + 4) = v11;
  *(_DWORD *)a2 = v10;
  return result;
}

BOOL sub_100221568(uint64_t a1)
{
  _BOOL8 result;

  result = 0;
  if (a1 && dword_100999250)
  {
    result = sub_10019AC00(a1);
    if (result)
      return *(_BYTE *)(a1 + 70) == 1;
  }
  return result;
}

uint64_t sub_1002215B4(uint64_t a1)
{
  uint64_t result;

  result = 0;
  if (a1 && dword_100999250)
  {
    result = sub_10019AC00(a1);
    if ((_DWORD)result)
      return *(unsigned __int16 *)(a1 + 80);
  }
  return result;
}

uint64_t sub_1002215F8(uint64_t a1)
{
  uint64_t result;

  result = 0;
  if (a1 && dword_100999250)
  {
    result = sub_10019AC00(a1);
    if ((_DWORD)result)
      return *(unsigned __int16 *)(a1 + 82);
  }
  return result;
}

uint64_t sub_10022163C(uint64_t a1)
{
  uint64_t result;

  result = 0;
  if (a1 && dword_100999250)
  {
    result = sub_10019AC00(a1);
    if ((_DWORD)result)
      return *(unsigned __int16 *)(a1 + 84);
  }
  return result;
}

uint64_t sub_100221680()
{
  if (!off_10098AB90)
    return 121;
  off_10098AB90();
  return 0;
}

uint64_t sub_1002216AC(__int128 *a1, uint64_t a2, int a3, unsigned int a4, unsigned int a5, int a6, int a7, int a8, unsigned __int16 a9, int a10)
{
  NSObject *v19;
  NSObject *v20;

  if (!dword_100999250)
    return 103;
  if (a1 && sub_10019AC00((uint64_t)a1))
  {
    if (a10 == 1)
    {
      return sub_100215C14((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8, a9);
    }
    else if (a10)
    {
      if (sub_10005549C())
      {
        sub_100054530("Invalid LE Connection Parameter Request Origin type: %d", a10);
        v20 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return 101;
    }
    else
    {
      return sub_10022E73C(a1, a2, a3 ^ 1u, a4, a5, a6, a7, a8, a9);
    }
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("This handle is not a LE connection.");
      v19 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 1310;
  }
}

uint64_t sub_100221860(uint64_t a1)
{
  __int16 v1;
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  unsigned __int8 v5;

  v1 = word_10098AB98;
  v2 = (unsigned __int16)word_10098AB98;
  if (word_10098AB98)
  {
    if (word_10098AB98 == 8)
    {
      if (sub_10005549C())
      {
        sub_100054530("Can't add anymore callbacks.");
        v3 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return 4053;
    }
    else
    {
      v5 = 0;
      while (qword_10098ABA0[v5] != a1)
      {
        if ((unsigned __int16)word_10098AB98 <= ++v5)
        {
          v2 = v5;
          goto LABEL_11;
        }
      }
      return 0;
    }
  }
  else
  {
LABEL_11:
    v4 = 0;
    qword_10098ABA0[v2] = a1;
    word_10098AB98 = v1 + 1;
  }
  return v4;
}

uint64_t sub_100221928(uint64_t result)
{
  unsigned __int8 v1;
  unsigned __int16 v2;
  uint64_t v3;

  if (word_10098AB98)
  {
    v1 = 0;
    while (qword_10098ABA0[v1] != result)
    {
      if ((unsigned __int16)word_10098AB98 <= ++v1)
        return result;
    }
    v3 = qword_10098ABA0[(unsigned __int16)--word_10098AB98];
    v2 = word_10098AB98;
    qword_10098ABA0[v1] = v3;
    qword_10098ABA0[v2] = 0;
  }
  return result;
}

void sub_10022197C()
{
  unsigned __int8 v0;
  uint64_t v1;
  void (*v2)(void);

  if (word_10098AB98)
  {
    v0 = 0;
    do
    {
      v1 = v0;
      v2 = (void (*)(void))qword_10098ABA0[v0];
      if (v2 || (sub_100253460(), (v2 = (void (*)(void))qword_10098ABA0[v1]) != 0))
        v2();
      v0 = v1 + 1;
    }
    while ((unsigned __int16)word_10098AB98 > (v1 + 1));
  }
}

uint64_t sub_1002219E0(uint64_t a1)
{
  __int16 v1;
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  unsigned __int8 v5;

  v1 = word_10098ABE0;
  v2 = (unsigned __int16)word_10098ABE0;
  if (word_10098ABE0)
  {
    if (word_10098ABE0 == 8)
    {
      if (sub_10005549C())
      {
        sub_100054530("Can't add anymore callbacks.");
        v3 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return 4053;
    }
    else
    {
      v5 = 0;
      while (qword_10098ABE8[v5] != a1)
      {
        if ((unsigned __int16)word_10098ABE0 <= ++v5)
        {
          v2 = v5;
          goto LABEL_11;
        }
      }
      return 0;
    }
  }
  else
  {
LABEL_11:
    v4 = 0;
    qword_10098ABE8[v2] = a1;
    word_10098ABE0 = v1 + 1;
  }
  return v4;
}

void sub_100221AA8()
{
  unsigned __int8 v0;
  uint64_t v1;
  void (*v2)(void);

  if (word_10098ABE0)
  {
    v0 = 0;
    do
    {
      v1 = v0;
      v2 = (void (*)(void))qword_10098ABE8[v0];
      if (v2 || (sub_100253460(), (v2 = (void (*)(void))qword_10098ABE8[v1]) != 0))
        v2();
      v0 = v1 + 1;
    }
    while ((unsigned __int16)word_10098ABE0 > (v1 + 1));
  }
}

uint64_t sub_100221B0C(uint64_t (*a1)(void))
{
  uint64_t result;

  if (off_10098AB90)
  {
    if (off_10098AB90 == a1)
      return 0;
    else
      return 119;
  }
  else
  {
    result = 0;
    off_10098AB90 = a1;
  }
  return result;
}

uint64_t sub_100221B38(void *a1)
{
  uint64_t result;

  if (off_10098AC28)
  {
    if (off_10098AC28 == a1)
      return 0;
    else
      return 119;
  }
  else
  {
    result = 0;
    off_10098AC28 = a1;
  }
  return result;
}

uint64_t *sub_100221B64(uint64_t *result)
{
  qword_10098AC30 = *result;
  return result;
}

uint64_t sub_100221B74(int a1)
{
  NSObject *v2;
  uint64_t result;

  if (!dword_100999250)
    return 103;
  if ((byte_10098AC38 & a1) != 0)
  {
    if (sub_10005549C())
    {
      sub_100054530("LE Role 0x%x already set.", a1);
      v2 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 4054;
  }
  else
  {
    result = 0;
    byte_10098AC38 |= a1;
  }
  return result;
}

uint64_t sub_100221C18(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  unsigned int v9;
  _BOOL4 v10;
  _BOOL4 v11;
  int v12;
  int v13;
  uint64_t result;
  NSObject *v15;

  if (!dword_100999250)
    return 103;
  v8 = a1;
  v9 = byte_10098AC38;
  if ((byte_10098AC38 & a1) != 0)
  {
    byte_10098AC38 &= ~(_BYTE)a1;
    v10 = (v9 & ~(_BYTE)a1 & 0xA) == 0 && (v9 & 0xA) != 0;
    v11 = (v9 & ~(_BYTE)a1 & 8) == 0;
    v12 = (v9 & ~(_BYTE)a1 & 5) == 0 && (v9 & 5) != 0;
    if ((v9 & 4) != 0 && (v9 & ~(_BYTE)a1 & 4) == 0)
    {
      a1 = sub_100206494();
      v12 |= a1;
    }
    v13 = v11 & (v9 >> 3);
    if (v10)
    {
      a1 = sub_100072F80();
      if (!v13)
      {
LABEL_14:
        if (!v12)
          return 0;
        goto LABEL_22;
      }
    }
    else if (!v13)
    {
      goto LABEL_14;
    }
    sub_100221D2C(a1, a2, a3, a4, a5, a6, a7, a8);
    if (v12)
LABEL_22:
      sub_100221D68(0);
    return 0;
  }
  result = sub_10005549C();
  if ((_DWORD)result)
  {
    sub_100054530("LE Role 0x%x not set.", v8);
    v15 = sub_1000544A0(0x42u);
    result = os_log_type_enabled(v15, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
    {
      sub_1006CE7A4();
      return 0;
    }
  }
  return result;
}

uint64_t sub_100221D2C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;

  v8 = sub_1002144CC(0, a2, a3, a4, a5, a6, a7, a8);
  if (sub_10002825C() && (_DWORD)v8 == 1302)
    sub_10019C914();
  return v8;
}

uint64_t sub_100221D68(int a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;

  if (!dword_100999250)
    return 103;
  if (dword_10098ED9C)
  {
    sub_100049F6C(dword_10098ED9C);
    dword_10098ED9C = 0;
  }
  byte_10098AC39 &= 0xFCu;
  byte_10098ED88 = sub_100206910();
  byte_10098ED98 = 0;
  if (!a1)
    return sub_100206134();
  v2 = sub_10005549C();
  if ((_DWORD)v2)
  {
    sub_100054530("LE_GAP_StopAdvertising Force stop");
    v10 = sub_1000544A0(0x42u);
    v2 = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
    if ((_DWORD)v2)
      sub_1006CE7A4();
  }
  sub_100222BC0(v2, v3, v4, v5, v6, v7, v8, v9);
  byte_10098ED88 = 0;
  off_10098ED90 = 0;
  sub_1002064B4();
  return 0;
}

void sub_100221E3C(uint64_t a1)
{
  NSObject *v2;
  uint8_t buf[4];
  void *v4;

  if (sub_10005549C())
  {
    sub_100054530("LE_GAP_ConfigureAppleADVTypePowerAssertionMask mask:%llu", a1);
    v2 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v4 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  qword_100999108 = a1;
}

uint64_t sub_100221F04(uint64_t a1, unint64_t a2, uint64_t (*a3)(void))
{
  uint64_t result;
  unint64_t v7;
  int v8;
  unint64_t v9;
  int v10;
  unint64_t v11;
  int v12;

  result = 162;
  if (a1 && a2)
  {
    if (!a3)
      return 101;
    if (a2 < 3)
      return 0;
    v7 = 2;
    do
    {
      if (*(_BYTE *)(a1 + v7) == 1)
      {
        if ((v7 + 16) >= a2)
          return 162;
        v8 = 0;
        LODWORD(v9) = v7 + 1;
        v10 = 16;
      }
      else
      {
        v9 = (v7 + 1);
        if (v9 >= a2)
          return 162;
        v10 = *(_BYTE *)(a1 + v9) & 0x1F;
        if (v10 == 31)
        {
          v11 = (v7 + 2);
          if (v11 >= a2)
            return 162;
          v10 = *(unsigned __int8 *)(a1 + v11) + 31;
          v8 = 2;
        }
        else
        {
          v8 = 1;
        }
        if ((v10 + v7 + v8) > a2)
          return 162;
      }
      v12 = a3();
      result = 0;
      v7 = (v9 + v10 + v8);
    }
    while (v7 < a2 && v12);
  }
  return result;
}

uint64_t sub_100222020(_BYTE *a1, uint64_t a2, unsigned __int8 *a3, uint64_t (*a4)(_QWORD, _QWORD), uint64_t a5)
{
  NSObject *v10;
  uint64_t v11;
  NSObject *v12;
  int v13;
  unsigned int v14;
  NSObject *v15;
  int v16;
  NSObject *v17;
  unsigned int v18;
  char v20;
  char v21;
  NSObject *v22;
  NSObject *v23;
  char v24;
  uint64_t (*v25)(_QWORD, _QWORD);
  void (*v26)(uint64_t, uint64_t);
  _BYTE *v27;
  int v28;
  int v29;
  _BYTE *v30;
  int *v31;
  uint64_t v32;
  NSObject *v33;
  NSObject *v34;
  NSObject *v35;
  NSObject *v36;
  NSObject *v37;
  NSObject *v38;
  NSObject *v39;
  unsigned __int16 v40;
  unsigned __int16 v41;
  _BYTE __dst[1650];
  _BYTE v43[1650];

  v41 = 0;
  bzero(v43, 0x672uLL);
  v40 = 0;
  bzero(__dst, 0x672uLL);
  if (!a1)
    sub_100253460();
  if (!dword_100999250)
    return 103;
  if (!(_DWORD)a2)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("You must specify at least numOfInstances>=1");
    v12 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      return 101;
LABEL_22:
    sub_1006CE7A4();
    return 101;
  }
  if (a2 >= 6)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("numOfInstances can not be greater than %d", 5);
    v10 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      return 101;
    goto LABEL_22;
  }
  v13 = sub_100206910();
  if (a2 >= 2 && !v13)
  {
    if (!sub_10005549C())
      return 101;
    v14 = sub_100206910();
    sub_100054530("numOfInstances can not be greater than 1, using regular advertising", v14);
    v15 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      return 101;
    goto LABEL_22;
  }
  if (sub_100206910() && sub_100206910() < a2)
  {
    if (!sub_10005549C())
      return 101;
    v16 = sub_100206910();
    sub_100054530("numOfInstances can not be greater than %d", v16);
    v17 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      return 101;
    goto LABEL_22;
  }
  __memmove_chk(&unk_10098AC60, a1, 3336 * a2, 16680);
  if (a4)
  {
    v18 = 0;
    byte_10098ED88 = 0;
  }
  else
  {
    v18 = byte_10098ED88;
  }
  if (v18 < a2)
  {
    while (*(unsigned __int16 *)&a1[3336 * v18 + 2] >= 0x4000u)
    {
      LOBYTE(v18) = v18 + 1;
      byte_10098ED88 = v18;
      v11 = 101;
      if (a2 <= v18)
        return v11;
    }
  }
  if ((_DWORD)a2 == v18)
    return 101;
  if ((_BYTE)v18)
  {
    v20 = byte_10098AC38;
LABEL_35:
    if ((v20 & 1) != 0)
    {
      v24 = byte_10098AC39 & 0xFC;
    }
    else
    {
      if (*a1)
        v21 = 1;
      else
        v21 = 2;
      if ((v20 & 4) == 0)
      {
        if (sub_10005549C())
        {
          sub_100054530("Role should be broadcaster to enable discoverable states.");
          v22 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
        return 4055;
      }
      v24 = byte_10098AC39 & 0xFC | v21;
    }
    byte_10098AC39 = v24;
    v11 = sub_100222764((uint64_t)&a1[3336 * v18], (uint64_t)v43, &v41, __dst, &v40, v18);
    if (!(_DWORD)v11)
    {
      if (a4)
      {
        if (a2 <= 1)
          v25 = 0;
        else
          v25 = a4;
        off_10098ED90 = v25;
      }
      byte_10098ED98 = 1;
      if (a2 <= 1)
        v26 = (void (*)(uint64_t, uint64_t))a4;
      else
        v26 = sub_1002229C4;
      v27 = &a1[3336 * byte_10098ED88];
      v28 = *((unsigned __int16 *)v27 + 1);
      v29 = v28;
      if (!*((_WORD *)v27 + 1))
      {
        if (a1[3336 * byte_10098ED88])
          v28 = 400;
        else
          v28 = 2048;
        if (a1[3336 * byte_10098ED88])
          v29 = 800;
        else
          v29 = 4096;
      }
      v30 = &a1[3336 * byte_10098ED88];
      if (v30[3317])
        v31 = (int *)(v30 + 3310);
      else
        v31 = 0;
      v32 = sub_10020573C((uint64_t)v26, a5, v28, v29, v30[1], a3, 7, 0, v41, v43, v30[3319], v40, __dst, v30[3320], byte_10098ED88, v31, *(_DWORD *)(v30 + 3321), BYTE1(*(_DWORD *)(v30 + 3321)), BYTE2(*(_DWORD *)(v30 + 3321)),
              HIBYTE(*(_DWORD *)(v30 + 3321)),
              *(_WORD *)(v30 + 3325),
              HIBYTE(*(_WORD *)(v30 + 3325)),
              v30[3327],
              *((_QWORD *)v30 + 416));
      if ((_DWORD)v32)
      {
        v11 = v32;
        if (sub_10005549C())
        {
          sub_100054530("LE_StartAdvertising failed with status %! currentAdvHandle=%d gMultiAdvCompleteCb=%p numOfInstances=%d ", v11, byte_10098ED88, off_10098ED90, a2);
          v33 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
            sub_1006CEEC0();
        }
      }
      else
      {
        if (a1[3336 * byte_10098ED88])
        {
          v11 = sub_10004A9EC((uint64_t)sub_100222BA4, 0, 300, &dword_10098ED9C);
          if ((_DWORD)v11)
          {
            if (sub_10005549C())
            {
              sub_100054530("Could not register callback, status:%!", v11);
              v39 = sub_1000544A0(0x42u);
              if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
                sub_1006CE7A4();
            }
          }
        }
        else
        {
          v11 = 0;
        }
        ++byte_10098ED88;
      }
    }
  }
  else
  {
    switch(a1[1])
    {
      case 0:
        if ((qword_10098AC30 & 4) != 0)
          goto LABEL_87;
        if (!sub_10005549C())
          return 1330;
        sub_100054530("Device does not support direct advertising.");
        v23 = sub_1000544A0(0x42u);
        if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          return 1330;
        goto LABEL_85;
      case 1:
        if ((qword_10098AC30 & 8) != 0)
          goto LABEL_87;
        if (sub_10005549C())
        {
          sub_100054530("Device does not support connectable advertising.");
          v34 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
            goto LABEL_85;
        }
        return 1330;
      case 2:
        if ((qword_10098AC30 & 2) != 0)
          goto LABEL_87;
        if (sub_10005549C())
        {
          sub_100054530("Device does not support discoverable advertising.");
          v35 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
            goto LABEL_85;
        }
        return 1330;
      case 3:
        if ((qword_10098AC30 & 1) != 0)
          goto LABEL_87;
        if (sub_10005549C())
        {
          sub_100054530("Device does not support non-connectable advertising.");
          v36 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
LABEL_85:
            sub_1006CE7A4();
        }
        return 1330;
      default:
LABEL_87:
        v20 = byte_10098AC38;
        if ((byte_10098AC38 & 5) != 0)
        {
          if (a1[1] > 1u || (byte_10098AC38 & 5) != 1)
            goto LABEL_35;
          if (sub_10005549C())
          {
            sub_100054530("We can't be connectable in Broadcaster mode.");
            v37 = sub_1000544A0(0x42u);
            if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
              sub_1006CE7A4();
          }
          v11 = 4061;
        }
        else
        {
          if (sub_10005549C())
          {
            sub_100054530("We can only advertise in Peripheral or Broadcaster mode.");
            v38 = sub_1000544A0(0x42u);
            if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
              sub_1006CE7A4();
          }
          v11 = 132;
        }
        break;
    }
  }
  return v11;
}

uint64_t sub_100222764(uint64_t a1, uint64_t a2, _WORD *a3, void *__dst, _WORD *a5, unsigned int a6)
{
  unsigned int v11;
  NSObject *v12;
  char v13;
  char v14;
  uint64_t v15;
  size_t v16;
  unsigned int v17;
  NSObject *v18;
  size_t v19;
  unsigned int v20;
  NSObject *v21;
  uint64_t result;
  __int16 v23;

  if (!a2 || !a3 || !__dst || !a5)
  {
    if (sub_10005549C())
    {
      sub_100054530("createAdvertisingData: Unexpected <null> pointer parameters");
      v12 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 101;
  }
  if (*(_BYTE *)(a1 + 3318))
  {
    v11 = 0;
    goto LABEL_22;
  }
  v11 = 0;
  if (a6 <= 4 && ((1 << a6) & 0x13) != 0)
  {
    if (*(unsigned __int16 *)(a1 + 1656) > 0x1Cu)
    {
      v11 = 0;
      if (a6)
        goto LABEL_22;
    }
    else
    {
      *(_WORD *)a2 = 258;
      v13 = byte_10098AC39;
      if (a6)
        v13 = byte_10098AC39 | 2;
      *(_BYTE *)(a2 + 2) = v13;
      v11 = 3;
      if (a6)
        goto LABEL_22;
    }
    if (*(unsigned __int16 *)(a1 + 1656) > 0x19u)
      goto LABEL_22;
    if (*(_BYTE *)(a1 + 4))
    {
      *(_WORD *)(a2 + v11) = 2562;
      v14 = *(_BYTE *)(a1 + 4);
LABEL_21:
      v15 = a2 + v11;
      v11 += 3;
      *(_BYTE *)(v15 + 2) = v14;
      goto LABEL_22;
    }
    v14 = dword_10098EDA8;
    if ((_BYTE)dword_10098EDA8 && dword_10098EDA8 != 127)
    {
      *(_WORD *)(a2 + v11) = 2562;
      goto LABEL_21;
    }
  }
LABEL_22:
  v16 = *(unsigned __int16 *)(a1 + 1656);
  if (*(_WORD *)(a1 + 1656))
  {
    if (a6 == 4)
      v17 = 1650;
    else
      v17 = 31;
    if (v16 + v11 > v17)
    {
      if (!sub_10005549C())
        goto LABEL_39;
      sub_100054530("Not enough room in ADV packet. (currently length=%d)", *(unsigned __int16 *)(a1 + 1656));
      v18 = sub_1000544A0(0x42u);
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        goto LABEL_39;
      goto LABEL_38;
    }
    memmove((void *)(a2 + v11), (const void *)(a1 + 5), v16);
    LOWORD(v11) = *(_WORD *)(a1 + 1656) + v11;
  }
  v19 = *(unsigned __int16 *)(a1 + 3308);
  if (*(_WORD *)(a1 + 3308))
  {
    if (a6 == 4)
      v20 = 1650;
    else
      v20 = 31;
    if (v20 < v19)
    {
      if (!sub_10005549C())
        goto LABEL_39;
      sub_100054530("Not enough room in SCN_RSP packet.");
      v21 = sub_1000544A0(0x42u);
      if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        goto LABEL_39;
LABEL_38:
      sub_1006CE7A4();
LABEL_39:
      sub_100253460();
      return 101;
    }
    memmove(__dst, (const void *)(a1 + 1658), v19);
    v23 = *(_WORD *)(a1 + 3308);
  }
  else
  {
    v23 = 0;
  }
  result = 0;
  *a3 = v11;
  *a5 = v23;
  return result;
}

void sub_1002229C4(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  NSObject *v5;
  NSObject *v6;
  uint64_t v7;
  uint8_t buf[4];
  void *v9;

  if ((_DWORD)a1 && (_DWORD)a1 != 4073)
  {
    if (sub_10005549C())
    {
      sub_100054530("failed to start advertising instance %d with status %! . Abort ! Abort ! Abort !", byte_10098ED88, a1);
      v5 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    if (byte_10098ED88 >= 2u)
    {
      byte_10098ED88 = sub_100206910();
      sub_100221D68(0);
      sub_100206720();
    }
    off_10098ED90(a1, a2);
  }
  else
  {
    v4 = byte_10098ED88;
    if (v4 >= sub_100206910() || sub_100206F4C())
    {
      off_10098ED90(a1, a2);
      byte_10098ED88 = 0;
    }
    else
    {
      v7 = sub_100206910();
      if (sub_100222020(&unk_10098AC60, v7, 0, 0, 0) != 101)
        return;
      byte_10098ED88 = 0;
      off_10098ED90(0, a2);
    }
  }
  if (byte_10098EDF8 == 1)
  {
    if (sub_10005549C())
    {
      sub_100054530("Advertising settled, need to rotate our address now");
      v6 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v9 = sub_100054494();
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
    sub_10021FDB8();
    byte_10098EDF8 = 0;
  }
}

uint64_t sub_100222BA4()
{
  uint64_t result;

  result = sub_100206134();
  dword_10098ED9C = 0;
  return result;
}

void sub_100222BC0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;

  sub_100253320((uint64_t)"LE_GAP:\n", a2, a3, a4, a5, a6, a7, a8, v96);
  sub_100253320((uint64_t)"gOverrideLocalAddress:%d gPrivateMode:%d gLePrivateAddressTimer:%d gHoldStableAddress=%d gLeHoldStablePrivateAddressTimer=%d callCount=%d\n", v8, v9, v10, v11, v12, v13, v14, byte_10098EDE1);
  sub_100253320((uint64_t)"gNoAddressRotationWhileScanningOrConnecting=%d gRefreshLocalAddressOnConnectionComplete=%d gRefreshLocalAddressOnScanComplete=%d gAddressRefreshFirstDeferral=%ld.%d\n", v15, v16, v17, v18, v19, v20, v21, byte_10098AB80);
  sub_100253320((uint64_t)"gRefreshLocalAddressOnAdvertisingSettled=%d", v22, v23, v24, v25, v26, v27, v28, byte_10098EDF8);
  sub_100253320((uint64_t)"supportedStates:%@ ADFlags:%x LeRoles:%x LeCurrentAddressType:%x discoveryType:%x\n", v29, v30, v31, v32, v33, v34, v35, (uint64_t)&qword_10098AC30);
  sub_100253320((uint64_t)"gPeripheralPrivacyFlagEnabled:%x gLeBondable:%x gAutoAddressRefresh:%x\n", v36, v37, v38, v39, v40, v41, v42, byte_10098EDE2);
  sub_100253320((uint64_t)"gPrivateAddressRotateInterval=%d gPrivateAddressRotateIntervalOverride=%d\n\n", v43, v44, v45, v46, v47, v48, v49, 6000);
  sub_100253320((uint64_t)"gAddressRotationInProgress=%d", v50, v51, v52, v53, v54, v55, v56, byte_10098EDF9);
  sub_100253320((uint64_t)"gFastLeConnectionMaxSlots=%d gFastLeConnectionUsedSlots=%d MAX_FAST_LE_CONNECTION_LIST_SIZE=%d", v57, v58, v59, v60, v61, v62, v63, byte_10098EE18);
  sub_100253320((uint64_t)"Advertising TX Power:\n", v64, v65, v66, v67, v68, v69, v70, v97);
  v71 = sub_100204FE0();
  if ((_DWORD)v71)
  {
    v79 = 0;
    do
    {
      sub_100253320((uint64_t)"\tInstance:%d power:%d\n", v72, v73, v74, v75, v76, v77, v78, v79++);
      v71 = sub_100204FE0();
    }
    while (v79 < v71);
  }
  sub_10021869C(v71, v72, v73, v74, v75, v76, v77, v78);
  sub_1002086E4(v80, v81, v82, v83, v84, v85, v86, v87);
  sub_10022BABC(v88, v89, v90, v91, v92, v93, v94, v95);
}

void sub_100222DA8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NSObject *v6;
  int v7;
  void *v8;

  if (sub_10005549C())
  {
    sub_100054530("_initMultipleAdvertisingLocalCB");
    v6 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v7 = 136446210;
      v8 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, " %{public}s", (uint8_t *)&v7, 0xCu);
    }
  }
  if (!(_DWORD)a1)
    sub_100222E9C();
  if (off_10098EDA0)
    off_10098EDA0(a1, a2, a3);
  off_10098EDA0 = 0;
}

void sub_100222E9C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  byte_10098EDE2 = byte_10098EDAD != 0;
  sub_10022353C((int *)((char *)&dword_10098EDAE[2 * byte_10098EDAD] - byte_10098EDAD), 1);
  if (!byte_10098EDAD)
  {
    sub_100214848(0, v0, v1, v2, v3, v4, v5, v6);
    sub_100206434(0);
    sub_10022B8FC(0);
  }
}

uint64_t sub_100222F0C(unsigned int a1, char a2, int a3, uint64_t (*a4)(_QWORD, _QWORD, _QWORD))
{
  uint64_t v4;
  uint64_t v7;
  NSObject *v8;
  NSObject *v10;
  NSObject *v11;

  byte_10098ED88 = 0;
  off_10098ED90 = 0;
  byte_10098ED98 = 0;
  dword_10098EDA8 = 2139062143;
  byte_10098EDAC = 127;
  if (a1 >= 5)
  {
    sub_100253460();
    return 4062;
  }
  byte_10098EDAD = a1;
  byte_10097A8BC = a2;
  bzero(&unk_10098AC60, 0x4128uLL);
  v7 = sub_1002230E8();
  if ((_DWORD)v7)
  {
    v4 = v7;
    if (sub_10005549C())
    {
      sub_100054530("LE_GAP_GenerateAddress failed with status %!", v4);
      v8 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
LABEL_7:
        sub_1006CE7A4();
    }
  }
  else
  {
    off_10098EDA0 = a4;
    if (a3)
    {
      v4 = sub_100206944((uint64_t (*)(_QWORD, _QWORD, _QWORD))sub_100222DA8);
      if ((_DWORD)v4)
      {
        if (sub_10005549C())
        {
          sub_100054530("LE_InitMultipleAdvertising failed with status %!", v4);
          v10 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
            goto LABEL_7;
        }
      }
    }
    else
    {
      sub_100222E9C();
      off_10098EDD8 = a4;
      if (!a4)
        return 0;
      v4 = sub_10004A9EC((uint64_t)sub_100223190, 0, 0, 0);
      if ((_DWORD)v4)
      {
        if (sub_10005549C())
        {
          sub_100054530("Could not register LE GAP Init Callback timer, status:%!", v4);
          v11 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
        return 4062;
      }
    }
  }
  return v4;
}

uint64_t sub_1002230E8()
{
  uint64_t v0;
  NSObject *v1;

  if (!dword_100999250)
    return 103;
  if (byte_10098EDAD != 3)
    return 0;
  v0 = sub_1002241E8(3);
  if ((_DWORD)v0)
  {
    if (sub_10005549C())
    {
      sub_100054530("creaetAddress with address type %d failed with error %! in LE_GAP_GenerateAddress", byte_10098EDAD, v0);
      v1 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  return v0;
}

uint64_t sub_100223190()
{
  return off_10098EDD8(0, 0, 0);
}

uint64_t sub_1002231A8(unint64_t a1)
{
  NSObject *v1;
  uint64_t result;
  char *v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  int v7;
  char *v8;
  NSObject *v9;
  int v10;
  NSObject *v11;
  _BOOL4 v12;
  NSObject *v13;
  uint8_t buf[4];
  void *v15;

  if (byte_10098EDE0)
  {
    if (sub_10005549C())
    {
      sub_100054530("Cannot override local address while in private mode");
      v1 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 408;
  }
  if (!a1)
  {
    byte_10098EDE1 = 0;
    sub_10021FDB8();
    v10 = sub_10005549C();
    result = 0;
    if (!v10)
      return result;
    sub_100054530("Going back to self rotating address");
    v11 = sub_1000544A0(0x42u);
    v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v12)
      return result;
    *(_DWORD *)buf = 136446210;
    v15 = sub_100054494();
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    return 0;
  }
  if ((a1 & 0xFF000000000000) != 0)
  {
    sub_100223450();
    byte_10098EDE1 = 1;
    v4 = (char *)&dword_10098EDAE[2 * byte_10098EDAD] - byte_10098EDAD;
    v4[6] = a1;
    *((_WORD *)v4 + 2) = ((a1 << 16) & 0xFF00000000 | ((unint64_t)BYTE1(a1) << 40)) >> 32;
    *(_DWORD *)v4 = a1 & 0xFF000000 | (a1 >> 16) & 0xFF0000 | WORD2(a1) & 0xFF00 | BYTE6(a1);
    if (sub_10005549C())
    {
      v5 = (unsigned __int8 *)&dword_10098EDAE[2 * byte_10098EDAD] - byte_10098EDAD;
      v7 = *v5;
      v6 = v5 + 1;
      v8 = v7 ? "Random" : "Public";
      sub_100054530("Overriding address to %s:%:", v8, v6);
      v9 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v15 = sub_100054494();
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
    sub_10022353C((int *)((char *)&dword_10098EDAE[2 * byte_10098EDAD] - byte_10098EDAD), 0);
    return 0;
  }
  if (sub_10005549C())
  {
    sub_100054530("Cannot set local public address !");
    v13 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  return 101;
}

void sub_100223450()
{
  NSObject *v0;
  uint8_t buf[4];
  void *v2;

  if (sub_10005549C())
  {
    sub_100054530("Canceling PrivateAddressTimer gPrivateMode=%d gOverrideLocalAddress=%d gHoldStableAddress=%d", byte_10098EDE0, byte_10098EDE1, byte_10098EDF4);
    v0 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v2 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if (dword_10098EDEC)
  {
    sub_100049F6C(dword_10098EDEC);
    dword_10098EDEC = 0;
  }
}

void sub_10022353C(_DWORD *a1, int a2)
{
  NSObject *v4;
  NSObject *v5;
  void *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  void *v12;
  __int128 *v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;
  NSObject *v20;
  __int16 v21;
  char v22;
  int v23;
  __int16 v24;
  char v25;
  int v26;
  __int16 v27;
  _BYTE buf[24];

  if (sub_10005549C())
  {
    sub_100054530("_refreshLeAddressHelper gNeedToStopAdvertisingWhenAddressChanges=%d gOverrideLocalAddress:%d gHoldStableAddress=%d callCount=%d gLeHoldStablePrivateAddressTimer=%d gLeCurrentAddress=%d gLeNonConnectableAddressType=%d", byte_10098ED98, byte_10098EDE1, byte_10098EDF4, (unsigned __int16)word_10098EDF6, dword_10098EDF0, byte_10098EDAD, byte_10097A8BD);
    v4 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  byte_10098EDF9 = 1;
  if (byte_10098ED98 == 1)
  {
    byte_10098ED98 = 0;
    sub_100204FEC(1);
  }
  sub_100221AA8();
  if (!sub_100206910() || !a2)
    goto LABEL_18;
  if (*(_BYTE *)a1 == 1)
  {
    sub_100206904(a1, 0);
    sub_100206744(a1, 4u, 0);
  }
  v27 = 0;
  v26 = 0;
  v25 = 1;
  arc4random_buf(&v26, 6uLL);
  LOBYTE(v26) = v26 & 0x3F;
  if (!byte_10097A8BE)
    goto LABEL_18;
  if (byte_10097A8BD == 3)
  {
    if (sub_10005549C())
    {
      sub_100054530("_refreshLeAddressHelper Non Connectable leRandomAddressPrivateResolvable");
      v11 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        v12 = sub_100054494();
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = v12;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
    v13 = sub_100239028();
    v24 = 0;
    v23 = 0;
    *(_WORD *)&buf[5] = 0;
    *(_DWORD *)&buf[1] = 0;
    buf[0] = 1;
    do
    {
      arc4random_buf(&buf[1], 3uLL);
      v14 = *(unsigned __int16 *)&buf[1] == (unsigned __int16)v23 && buf[3] == BYTE2(v23);
    }
    while (v14 || !(*(unsigned __int16 *)&buf[1] ^ 0xFF | buf[3]));
    buf[1] = buf[1] & 0x3F | 0x40;
    v15 = sub_100237408((__int16 *)&buf[1], 1);
    if ((_DWORD)v15)
    {
      v16 = v15;
      if (sub_10005549C())
      {
        sub_100054530("Failed to generate a non connectable random address with status %! for address %:, falling back to non resolvable", v16, &buf[1]);
        v17 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          sub_1006CEEC0();
      }
    }
    else
    {
      v22 = 0;
      v21 = 0;
      v18 = sub_10018489C(v13, (__int16 *)&buf[1], (uint64_t)&v21);
      if (!(_DWORD)v18)
      {
        v7 = buf;
LABEL_17:
        sub_100206744(v7, 1u, 0);
        goto LABEL_18;
      }
      v19 = v18;
      if (sub_10005549C())
      {
        sub_100054530("Failed to resolve the non connectable random address with status %! for address %:, falling back to non resolvable", v19, &buf[1]);
        v20 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          sub_1006CEEC0();
      }
    }
    sub_100206744(&v25, 1u, 0);
    return;
  }
  if (byte_10097A8BD == 2)
  {
    if (sub_10005549C())
    {
      sub_100054530("_refreshLeAddressHelper Non Connectable leRandomAddressPrivateNonResolvable");
      v5 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        v6 = sub_100054494();
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = v6;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
    v7 = &v25;
    goto LABEL_17;
  }
LABEL_18:
  if (sub_1002076DC())
    sub_1002081B0();
  if (*(_BYTE *)a1)
  {
    sub_10004C9BC(165, sub_100225FE0);
  }
  else
  {
    v8 = sub_10004A9EC((uint64_t)sub_100225FC0, 0, 0, 0);
    if ((_DWORD)v8)
    {
      v9 = v8;
      if (sub_10005549C())
      {
        sub_100054530("Failed to register a fake GAPAddressTypeChangedCB status:%!", v9);
        v10 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      sub_100223450();
      sub_100226000();
      byte_10098EDF9 = 0;
      sub_10022197C();
    }
  }
  sub_10019C914();
}

uint64_t sub_1002239DC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v10;
  void *v11;

  if (sub_10005549C())
  {
    sub_100054530("LE_GAP_TerminateAdvertising");
    v0 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
    {
      v10 = 136446210;
      v11 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, " %{public}s", (uint8_t *)&v10, 0xCu);
    }
  }
  sub_100221D68(0);
  byte_10098ED88 = 0;
  off_10098ED90 = 0;
  byte_10098EDAD = 0;
  sub_100206720();
  return sub_100206D7C(v1, v2, v3, v4, v5, v6, v7, v8);
}

uint64_t sub_100223ABC(unsigned int a1, unsigned int a2, int *a3, uint64_t a4, unsigned int a5, unsigned int a6, unsigned __int8 a7, unsigned __int8 a8)
{
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  NSObject *v22;
  NSObject *v23;

  if (!dword_100999250)
    return 103;
  if ((qword_10098AC30 & 0x40) != 0)
  {
    if ((byte_10098AC38 & 8) != 0)
    {
      if (sub_10023A580())
      {
        if (a1)
          v19 = a1;
        else
          v19 = 204;
        if (a2)
          v20 = a2;
        else
          v20 = 108;
        if (a5)
          v21 = a5;
        else
          v21 = 20;
        v9 = sub_100213A24(v19, v20, v21, a6, 0, 0xCu, a3, a4, a7, a8);
        if ((_DWORD)v9)
        {
          if (sub_10005549C())
          {
            sub_100054530("Could not start auto-connect : %!", v9);
            v22 = sub_1000544A0(0x42u);
            if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
              sub_1006CE7A4();
          }
        }
      }
      else
      {
        if (sub_10005549C())
        {
          sub_100054530("There are no devices in the filter accept list. Can't trigger auto-connection.");
          v23 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
        return 4066;
      }
    }
    else
    {
      if (sub_10005549C())
      {
        sub_100054530("We can only be in auto connection mode in Central role.");
        v10 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return 4065;
    }
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("Device does not support incoming connections.");
      v8 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 1330;
  }
  return v9;
}

uint64_t sub_100223CB8(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5, int a6, int a7)
{
  NSObject *v15;

  if (!dword_100999250)
    return 103;
  if (a1 && sub_10019AC00((uint64_t)a1))
  {
    if (a1[70] == 1)
      return sub_10022E940(a1, a2, a3, a4, a5);
    else
      return sub_1002160C0((uint64_t)a1, a2, a3, a4, a5, a6, a7);
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("This handle is not a LE connection.");
      v15 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 1310;
  }
}

uint64_t sub_100223DC8(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5, int a6)
{
  NSObject *v13;

  if (!dword_100999250)
    return 103;
  if (a1 && sub_10019AC00(a1))
    return sub_1002165FC(a1, a2, a3, a4, a5, a6);
  if (sub_10005549C())
  {
    sub_100054530("This handle is not a LE connection.");
    v13 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  return 1310;
}

uint64_t sub_100223EA0(_DWORD *a1)
{
  uint64_t v1;

  if (!dword_100999250)
    return 103;
  v1 = sub_10019AFA0(a1);
  return sub_10021F3D0(v1);
}

uint64_t sub_100223ED0(uint64_t (*a1)(void))
{
  uint64_t v2;
  NSObject *v3;
  void *v4;
  uint64_t v6;
  uint8_t buf[4];
  void *v8;
  __int16 v9;
  int v10;

  v6 = 0;
  if (!dword_100999250)
    return 103;
  while (sub_10019C2D0(&v6))
  {
    if (*(_BYTE *)(v6 + 124) != 7)
    {
      if (sub_10021F3D0(v6) && sub_10005549C())
      {
        if (*(_BYTE *)(v6 + 55))
          v2 = v6 + 57;
        else
          v2 = v6 + 49;
        sub_100054530("Failed to disconnect handle %x (address %:)", v6, v2);
        v3 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        {
          v4 = sub_100054494();
          *(_DWORD *)buf = 136446466;
          v8 = v4;
          v9 = 1024;
          v10 = 0xFFFF;
          _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "%{public}s (status=%{bluetooth:OI_STATUS}u)", buf, 0x12u);
        }
      }
      off_10098AB88 = a1;
    }
  }
  if (off_10098AB88)
    return 0;
  else
    return 122;
}

uint64_t sub_100224050(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_100216754(**(_QWORD **)(a1 + 8), a2, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_100224060(char a1)
{
  uint64_t result;

  if (!dword_100999250)
    return 103;
  result = 0;
  byte_10098EDE8 = a1;
  return result;
}

uint64_t sub_10022408C()
{
  return byte_10098EDE8;
}

uint64_t sub_100224098(uint64_t a1, int a2)
{
  NSObject *v4;
  NSObject *v6;
  int v7;
  void *v8;

  if (!dword_100999250)
    return 103;
  if ((byte_10098AC38 & 0xC) != 0)
  {
    if (sub_10005549C())
    {
      sub_100054530("LE_GAP is Asking to pair... because someone called StartBonding.");
      v4 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        v7 = 136446210;
        v8 = sub_100054494();
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, " %{public}s", (uint8_t *)&v7, 0xCu);
      }
    }
    return sub_1002380C4(a1, a2);
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("We can only pair in Central or peripheral role.");
      v6 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 4068;
  }
}

uint64_t sub_1002241E0()
{
  return 152;
}

uint64_t sub_1002241E8(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  __int128 *v5;
  uint64_t v6;
  NSObject *v7;
  __int16 v9;
  char v10;

  switch((int)a1)
  {
    case 0:
      v2 = 0;
      LOBYTE(dword_10098EDAE[0]) = 0;
      *(int *)((char *)dword_10098EDAE + 1) = xmmword_100998F58;
      *(__int16 *)((char *)&word_10098EDB2 + 1) = WORD2(xmmword_100998F58);
      break;
    case 1:
      byte_10098EDB5 = 1;
      arc4random_buf(&byte_10098EDB6, 6uLL);
      v2 = 0;
      byte_10098EDB6 |= 0xC0u;
      break;
    case 2:
      byte_10098EDBC = 1;
      while (1)
      {
        do
          arc4random_buf(&dword_10098EDBD, 6uLL);
        while (!(dword_10098EDBD | (unsigned __int16)word_10098EDC1));
        if (dword_10098EDBD ^ 0xFF | (unsigned __int16)word_10098EDC1)
        {
          if (dword_10098EDBD != (_DWORD)xmmword_100998F58
            || (unsigned __int16)word_10098EDC1 != WORD2(xmmword_100998F58))
          {
            break;
          }
        }
      }
      v2 = 0;
      LOBYTE(dword_10098EDBD) = dword_10098EDBD & 0x3F;
      break;
    case 3:
      v5 = sub_100239024();
      byte_10098EDC3 = 1;
      do
      {
        do
          arc4random_buf(&word_10098EDC4, 3uLL);
        while (!((unsigned __int16)word_10098EDC4 | byte_10098EDC6));
      }
      while (!((unsigned __int16)word_10098EDC4 ^ 0xFF | byte_10098EDC6));
      LOBYTE(word_10098EDC4) = word_10098EDC4 & 0x3F | 0x40;
      v6 = sub_100237408(&word_10098EDC4, 0);
      if ((_DWORD)v6)
      {
        v2 = v6;
        if (sub_10005549C())
        {
          sub_100054530("Failed to generate a random address with status %! for address %:", v2, &word_10098EDC4);
          v7 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
            sub_1006CEEC0();
        }
      }
      else
      {
        v10 = 0;
        v9 = 0;
        v2 = sub_10018489C(v5, &word_10098EDC4, (uint64_t)&v9);
        if ((_DWORD)v2)
          goto LABEL_4;
      }
      break;
    default:
      sub_100253460();
      v2 = 4069;
LABEL_4:
      if (sub_10005549C())
      {
        sub_100054530("Could not generate a new address of type %d with status %!.", a1, v2);
        v3 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      break;
  }
  return v2;
}

void sub_100224440(int a1)
{
  NSObject *v2;
  uint8_t buf[4];
  void *v4;

  if (sub_10005549C())
  {
    sub_100054530("EnablePrivateMode:%d", a1);
    v2 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v4 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  byte_10098EDE0 = a1;
  if ((a1 & 1) == 0)
    sub_10021FDB8();
}

uint64_t sub_100224514(unsigned int a1, char a2)
{
  if (!dword_100999250)
    return 103;
  if (a1 < 5 && a1)
  {
    byte_10097A8BD = a1;
    byte_10097A8BE = a2;
    sub_10022353C((int *)((char *)&dword_10098EDAE[2 * byte_10098EDAD] - byte_10098EDAD), 1);
    return 0;
  }
  else
  {
    sub_100253460();
    return 4071;
  }
}

uint64_t sub_100224588()
{
  unsigned int v0;
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (!dword_100999250)
    return 103;
  v0 = byte_10098EDAD;
  byte_10098EDE2 = byte_10098EDAD != 0;
  if (byte_10098EDAD == 3)
  {
    v1 = sub_1002241E8(3);
    if ((_DWORD)v1)
    {
      v2 = v1;
      if (sub_10005549C())
      {
        sub_100054530("createAddress with type %d failed with status %! in LE_GAP_RefreshAddress", byte_10098EDAD, v2);
        v3 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return v2;
    }
    v0 = byte_10098EDAD;
  }
  sub_10022353C((int *)((char *)&dword_10098EDAE[2 * v0] - v0), 1);
  if (!byte_10098EDAD)
  {
    sub_100214848(0, v4, v5, v6, v7, v8, v9, v10);
    sub_100206434(0);
    sub_10022B8FC(0);
  }
  return 0;
}

char *sub_10022467C(unsigned int a1, uint64_t a2)
{
  char *result;
  int v4;
  __int16 v5;

  if (a1)
    result = sub_100206730(a1);
  else
    result = (char *)&dword_10098EDAE[2 * byte_10098EDAD] - byte_10098EDAD;
  v4 = *(_DWORD *)result;
  v5 = *((_WORD *)result + 2);
  *(_BYTE *)(a2 + 6) = result[6];
  *(_WORD *)(a2 + 4) = v5;
  *(_DWORD *)a2 = v4;
  return result;
}

uint64_t sub_1002246D4(uint64_t result)
{
  int v1;
  __int16 v2;

  v1 = dword_10098EDAE[0];
  v2 = word_10098EDB2;
  *(_BYTE *)(result + 6) = byte_10098EDB4;
  *(_WORD *)(result + 4) = v2;
  *(_DWORD *)result = v1;
  return result;
}

uint64_t sub_1002246F8()
{
  uint64_t result;
  BOOL v1;
  char v2;

  if (!BYTE9(xmmword_100998F98))
    return 0;
  if (dword_100999250)
    return 140;
  LOBYTE(dword_10098EDAE[0]) = 0;
  *(int *)((char *)dword_10098EDAE + 1) = xmmword_100998F58;
  *(__int16 *)((char *)&word_10098EDB2 + 1) = WORD2(xmmword_100998F58);
  sub_1002241E8(2);
  byte_10098EDB5 = 1;
  arc4random_buf(&byte_10098EDB6, 6uLL);
  byte_10098EDB6 |= 0xC0u;
  byte_10098EDAD = 0;
  dword_10098EDEC = 0;
  dword_10098EDF0 = 0;
  if (BYTE8(xmmword_100998F98))
    v1 = BYTE9(xmmword_100998F98) == 0;
  else
    v1 = 1;
  if (v1)
    v2 = 4;
  else
    v2 = 24;
  byte_10098AC39 |= v2;
  sub_10022F944((uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))sub_100221680);
  sub_10022D270((__n128 *)off_10091EFF0);
  sub_10022B984();
  result = 0;
  dword_100999250 = 1;
  off_10098AB88 = 0;
  byte_10098EDE0 = 0;
  byte_10098EDE1 = 0;
  byte_10098EDF4 = 0;
  word_10098EDF6 = 0;
  byte_10098EDF8 = 0;
  byte_10098EDF9 = 0;
  if (!byte_10098EDFA)
  {
    result = 0;
    byte_10098AB80 = 0;
    byte_10098EDFB = 0;
    dword_10098EDFC = 0;
    word_10098EE00 = 0;
  }
  return result;
}

uint64_t sub_10022485C(unsigned int a1, unsigned __int16 a2)
{
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  NSObject *v11;
  void *v12;
  unsigned __int16 v13;
  uint8_t buf[4];
  void *v15;

  if (dword_10098EDF0)
    sub_1002261B8();
  v13 = 0;
  v4 = sub_10025391C(dword_10098EDEC, &v13);
  if ((_DWORD)v4)
  {
    v5 = v4;
    if (!sub_10005549C())
      goto LABEL_7;
    sub_100054530("Failed to read timeout value for private address refresh timer, status:%! gHoldStableAddress:%d gHoldStableAddressCount:%d ", v5, byte_10098EDF4, (unsigned __int16)word_10098EDF6);
    v6 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      goto LABEL_7;
    goto LABEL_6;
  }
  if (v13 >= a1)
  {
    v5 = sub_10004A9EC((uint64_t)sub_100224AE4, 0, a2, &dword_10098EDF0);
    if ((_DWORD)v5)
    {
      if (!sub_10005549C())
        goto LABEL_7;
      sub_100054530("Failed to register resetLeHoldStablePrivateAddress, status:%! gHoldStableAddress:%d gHoldStableAddressCount:%d ", v5, byte_10098EDF4, (unsigned __int16)word_10098EDF6);
      v10 = sub_1000544A0(0x42u);
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        goto LABEL_7;
LABEL_6:
      sub_1006CE7A4();
LABEL_7:
      sub_1002261B8();
      word_10098EDF6 = 0;
      byte_10098EDF4 = 0;
      return v5;
    }
  }
  else
  {
    v8 = sub_100253854(dword_10098EDEC, a2);
    if ((_DWORD)v8)
    {
      v5 = v8;
      if (!sub_10005549C())
        goto LABEL_7;
      sub_100054530("Failed to update private address refresh timer, status:%! gHoldStableAddress:%d gHoldStableAddressCount:%d", v5, byte_10098EDF4, (unsigned __int16)word_10098EDF6);
      v9 = sub_1000544A0(0x42u);
      if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        goto LABEL_7;
      goto LABEL_6;
    }
    ++word_10098EDF6;
    v5 = 116;
  }
  byte_10098EDF4 = 1;
  if (sub_10005549C())
  {
    sub_100054530("EnableHoldStableAddress: gHoldStableAddressCount=%d gLeHoldStablePrivateAddressTimer=%d gLePrivateAddressTimer=%d", (unsigned __int16)word_10098EDF6, dword_10098EDF0, dword_10098EDEC);
    v11 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      v12 = sub_100054494();
      *(_DWORD *)buf = 136446210;
      v15 = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  return v5;
}

void sub_100224AE4()
{
  const char *v0;
  NSObject *v1;
  uint8_t buf[4];
  void *v3;

  if (sub_10005549C())
  {
    if (dword_10098EDEC)
      v0 = "true";
    else
      v0 = "false";
    sub_100054530("LeHoldStablePrivateAddress expired:%d PrivateAddressTimer active:%s", (unsigned __int16)word_10098EDF6, v0);
    v1 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v3 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  sub_1002261B8();
  byte_10098EDF4 = 0;
  word_10098EDF6 = 0;
}

uint64_t sub_100224BD8(_DWORD *a1)
{
  uint64_t result;
  unsigned __int16 v3;

  v3 = 0;
  result = sub_10025391C(dword_10098EDEC, &v3);
  if (!(_DWORD)result)
    *a1 = 100 * v3;
  return result;
}

_BYTE *sub_100224C24(_BYTE *result, _BYTE *a2, _BYTE *a3, _WORD *a4, _DWORD *a5, _DWORD *a6)
{
  *result = byte_10098EDF4;
  *a2 = byte_10098EDE1;
  *a3 = byte_10098EDE0;
  *a4 = word_10098EDF6;
  *a5 = dword_10098EDEC;
  *a6 = dword_10098EDF0;
  return result;
}

uint64_t sub_100224C70(uint64_t result)
{
  word_10098EE04 = 10 * result;
  return result;
}

uint64_t sub_100224C84(uint64_t result)
{
  byte_10098EDFA = result;
  return result;
}

uint64_t sub_100224C90()
{
  NSObject *v0;
  uint64_t result;
  int v2;
  void *v3;

  if (!BYTE9(xmmword_100998F98))
    return 0;
  if (!dword_100999250)
    return 103;
  sub_100223450();
  sub_1002261B8();
  qword_10098AC30 = 0;
  sub_10022D328(off_10091EFF0);
  sub_1001DD900();
  sub_1001F3590();
  byte_10098AC39 = 0;
  byte_10098AC38 = 0;
  byte_10098EDAD = 0;
  byte_10098AC58 = 0;
  off_10098AB88 = 0;
  off_10098AC48 = 0;
  off_10098AC50 = 0;
  qword_10098AC40 = 0;
  byte_10098AB80 = 0;
  byte_10098EDFB = 0;
  byte_10098EDF8 = 0;
  byte_10098EDE0 = 0;
  byte_10098EDE1 = 0;
  byte_10098EDF4 = 0;
  word_10098EDF6 = 0;
  byte_10098EDF9 = 0;
  sub_100224E6C();
  sub_1002239DC();
  sub_10023A664();
  sub_100111F8C();
  sub_100239CF0();
  sub_10022FCE0();
  sub_10022BA1C();
  sub_100212FE8();
  sub_100111AF4();
  if (dword_10098EE08)
  {
    if (sub_10005549C())
    {
      sub_100054530("Canceling power assertion");
      v0 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
      {
        v2 = 136446210;
        v3 = sub_100054494();
        _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, " %{public}s", (uint8_t *)&v2, 0xCu);
      }
    }
    sub_100049F6C(dword_10098EE08);
    dword_10098EE08 = 0;
    qword_10098EE10 = 0;
    sub_100114138();
  }
  result = 0;
  dword_100999250 = 0;
  return result;
}

uint64_t sub_100224E6C()
{
  uint64_t result;

  result = sub_100208554();
  if ((_DWORD)result)
  {
    if (sub_1002076DC())
      sub_100207510();
    return sub_10020741C(0, 0);
  }
  return result;
}

uint64_t sub_100224EA0(uint64_t (*a1)(_QWORD, _QWORD), uint64_t (*a2)(_QWORD, _QWORD))
{
  uint64_t v4;
  NSObject *v5;

  if (!sub_100208554())
    return 0;
  v4 = sub_10020741C(a1, a2);
  if ((_DWORD)v4)
  {
    if (sub_10005549C())
    {
      sub_100054530("LE_InitPeriodicAdvertising failed with status %!", v4);
      v5 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  return v4;
}

uint64_t sub_100224F30(unsigned __int8 *a1)
{
  unsigned int v2;
  uint64_t v3;
  NSObject *v4;
  NSObject *v5;
  NSObject *v6;

  if (!dword_100999250)
    return 103;
  if ((sub_100208554() & 1) != 0)
  {
    v2 = *a1;
    if (v2 >= sub_100206910())
    {
      if (sub_10005549C())
      {
        sub_100054530("Invalid advHandle=%d", *a1);
        v6 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return 101;
    }
    else
    {
      v3 = sub_100207B74(a1);
      if ((_DWORD)v3)
      {
        if (sub_10005549C())
        {
          sub_100054530("LE_StartPeriodicAdvertising failed with status %! advHandle=%d ", v3, *a1);
          v4 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
            sub_1006CEEC0();
        }
      }
    }
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("LE GAP Periodic Advertising is not enabled");
      v5 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 117;
  }
  return v3;
}

uint64_t sub_100225074(unsigned int a1)
{
  uint64_t v2;
  NSObject *v3;
  NSObject *v4;
  NSObject *v5;

  if (!dword_100999250)
    return 103;
  if ((sub_100208554() & 1) == 0)
  {
    if (!sub_10005549C())
      return 117;
    sub_100054530("LE GAP Periodic Advertising is not enabled");
    v4 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      return 117;
LABEL_14:
    sub_1006CE7A4();
    return 117;
  }
  if (!sub_1002076DC())
  {
    if (!sub_10005549C())
      return 117;
    sub_100054530("LE_GAP_StopPeriodicAdvertising there is no active periodic advertising set.");
    v5 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      return 117;
    goto LABEL_14;
  }
  v2 = sub_1002077A4(a1, 0);
  if ((_DWORD)v2)
  {
    if (sub_10005549C())
    {
      sub_100054530("LE_StopPeriodicAdvertising failed with status %! advHandle=%d ", v2, a1);
      v3 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  return v2;
}

void sub_1002251A4(int a1)
{
  NSObject *v2;

  if (sub_10005549C())
  {
    sub_100054530("LE_GAP_SetForceConnectionDelay Overriding Encryption and remote version information delay to %d", a1);
    v2 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  dword_10098EDE4 = a1;
}

uint64_t sub_100225214(uint64_t result, unsigned int a2)
{
  *((_BYTE *)&dword_10098EDA8 + a2) = result;
  return result;
}

BOOL sub_100225224()
{
  BOOL v0;

  if (dword_100999250)
    v0 = BYTE9(xmmword_100998F98) == 0;
  else
    v0 = 1;
  return !v0;
}

uint64_t sub_10022524C()
{
  const char *v0;
  NSObject *v1;
  uint8_t buf[4];
  void *v4;

  if (sub_10005549C())
  {
    if (byte_10098EDF9)
      v0 = "YES";
    else
      v0 = "NO";
    sub_100054530("Address rotation in progress:%s", v0);
    v1 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v4 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  return byte_10098EDF9;
}

void sub_10022532C(int a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (a1)
  {
    dword_100999250 = 0;
    v1 = sub_1002239DC();
    sub_10023A440(v1, v2, v3, v4, v5, v6, v7, v8);
    sub_10022BA1C();
    sub_100212F00();
  }
  else
  {
    dword_100999250 = 1;
  }
}

unint64_t sub_100225368(unint64_t a1)
{
  return bswap64(a1) >> 16;
}

uint64_t sub_100225374(uint64_t result)
{
  byte_10098EE18 = result;
  return result;
}

uint64_t sub_100225380(unint64_t a1, char a2, char a3, char a4)
{
  uint64_t v4;
  unsigned __int8 v5;
  uint64_t *v6;
  unsigned __int8 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v11;
  char v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  const char *v17;
  NSObject *v18;
  void *v19;
  uint64_t v21;
  uint8_t buf[4];
  void *v23;

  if ((a1 & 0xFFFFFFFFFFFFLL) != 0)
  {
    if (byte_10098EE18)
    {
      v4 = 0;
      v5 = byte_10098EE18 + 1;
      v6 = qword_10098EE20;
      v7 = byte_10098EE18 + 1;
      do
      {
        v9 = *v6;
        v6 += 2;
        v8 = v9;
        if (v7 >= byte_10098EE18 && v8 == 0)
          v7 = v4;
        if (v8 == a1)
          v5 = v4;
        ++v4;
      }
      while (byte_10098EE18 != v4);
      if ((a3 & 1) != 0)
        goto LABEL_14;
    }
    else
    {
      v7 = 1;
      v5 = 1;
      if ((a3 & 1) != 0)
      {
LABEL_14:
        if (byte_10098EE18 <= v7)
        {
          v14 = 106;
          goto LABEL_29;
        }
        if (byte_10098EE18 <= v5)
        {
          v11 = &qword_10098EE20[2 * v7];
          *v11 = a1;
          *((_BYTE *)v11 + 8) = a2;
          *((_BYTE *)v11 + 9) = a4;
          v12 = byte_10098EE19 + 1;
LABEL_25:
          v14 = 0;
          byte_10098EE19 = v12;
          goto LABEL_29;
        }
        goto LABEL_28;
      }
    }
    if (byte_10098EE18 <= v5)
    {
      v14 = 101;
      goto LABEL_29;
    }
    v15 = &qword_10098EE20[2 * v5];
    *v15 = 0;
    *((_WORD *)v15 + 4) = 0;
    if (byte_10098EE19)
    {
      v12 = byte_10098EE19 - 1;
      goto LABEL_25;
    }
LABEL_28:
    v14 = 0;
LABEL_29:
    BYTE6(v21) = a1;
    v16 = (a1 << 32) & 0xFF0000000000 | (a1 << 48) | (a1 << 16) & 0xFF00000000 | a1 & 0xFF000000 | (a1 >> 16) & 0xFF0000 | WORD2(a1) & 0xFF00 | BYTE6(a1);
    WORD2(v21) = ((a1 << 32) & 0xFF0000000000 | (a1 << 48) | (a1 << 16) & 0xFFFFFFFFFFLL) >> 32;
    LODWORD(v21) = a1 & 0xFF000000 | (a1 >> 16) & 0xFF0000 | WORD2(a1) & 0xFF00 | BYTE6(a1);
    if (sub_10005549C())
    {
      v17 = "Random";
      if (!(_BYTE)v16)
        v17 = "Public";
      sub_100054530("FastLeConnection:LE_GAP_EnableFastLeConnectionForAddress %s:%: freeLocation:%d existingLocation:%d gFastLeConnectionMaxSlots:%d gFastLeConnectionUsedSlots:%d ret:%d", v17, (char *)&v21 + 1, v7, v5, byte_10098EE18, byte_10098EE19, v14, v21);
      v18 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        v19 = sub_100054494();
        *(_DWORD *)buf = 136446210;
        v23 = v19;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
    return v14;
  }
  if (sub_10005549C())
  {
    sub_100054530("FastLeConnection:LE_GAP_IsFastLeConnectionEncryptionFakeEvent compare with zero address");
    v13 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  return 101;
}

void sub_1002255F4(uint64_t a1, unsigned __int16 **a2)
{
  NSObject *v4;
  NSObject *v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  void *v12;
  uint64_t v13;
  NSObject *v14;
  NSObject *v15;
  uint8_t buf[4];
  void *v17;

  if (sub_10005549C())
  {
    sub_100054530("FastLEConnection:LE_GAP_FastLEConnectionReady status:%d role:%d address:%d localResolvableAddr:%d, peerResolvableAddr:%d interval:%d latency:%d timeout:%d centralClockAccuracy:%d LMPVersion:%d mfgr:%d LMPSubversion:%d featuresLength:%d txPHY:%d rxPHY:%d maxTxOctets:%d maxTxTime:%d maxRxOctets:%d maxRxTime:%d instantValue:%d", a1, *((unsigned __int8 *)a2 + 8), *((_OWORD *)a2 + 1), a2[3], a2[4], *((unsigned __int16 *)a2 + 20), *((unsigned __int16 *)a2 + 21), *((unsigned __int16 *)a2 + 22), *((unsigned __int8 *)a2 + 46), *((unsigned __int8 *)a2 + 47), *((unsigned __int16 *)a2 + 24), *((unsigned __int16 *)a2 + 25), *((unsigned __int8 *)a2 + 60), *((unsigned __int8 *)a2 + 61), *((unsigned __int8 *)a2 + 62), *((unsigned __int16 *)a2 + 32),
      *((unsigned __int16 *)a2 + 33),
      *((unsigned __int16 *)a2 + 34),
      *((unsigned __int16 *)a2 + 35),
      *((unsigned __int16 *)a2 + 36));
    v4 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v17 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if ((_DWORD)a1)
  {
    if (sub_10005549C())
    {
      sub_100054530("FastLEConnection:LE_GAP_FastLEConnectionReady Fast LE Connection not succesful status:%d fastLEConnectEnabled:%d", a1, *((unsigned __int8 *)*a2 + 316));
      v5 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        v6 = sub_100054494();
        *(_DWORD *)buf = 136446210;
        v17 = v6;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
    if (*((_BYTE *)*a2 + 316))
    {
      *((_BYTE *)*a2 + 316) = 0;
      v7 = (uint64_t)*a2;
      if (*((_BYTE *)*a2 + 70))
      {
        v8 = sub_10021F46C(v7);
        if ((_DWORD)v8)
        {
          v9 = v8;
          if (sub_10005549C())
          {
            sub_100054530("FastLEConnection:LE_GAP_ReadRemoteVersionInformation failed %!", v9);
            v10 = sub_1000544A0(0x42u);
            if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
              sub_1006CEEC0();
          }
          sub_10021F4FC((uint64_t)*a2, v9);
        }
        else
        {
          *((_DWORD *)*a2 + 33) = 1;
        }
      }
      else if (sub_100220740(v7))
      {
        if (sub_10005549C())
        {
          sub_100054530("FastLEConnection:Encryption start fails with status %!", a1);
          v14 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
            sub_1006CEEC0();
        }
      }
      else
      {
        *((_BYTE *)*a2 + 125) = 1;
      }
    }
  }
  else
  {
    if (!sub_10019AC00((uint64_t)*a2))
      sub_100253460();
    if (*((_BYTE *)*a2 + 316) || (sub_100253460(), *((_BYTE *)*a2 + 316)))
    {
      if (sub_10005549C())
      {
        sub_100054530("FastLEConnection:LE_GAP_FastLEConnectionReady Setting up connection fastLEConnectEncryptionPending:%d fastLEConnectionFakeEncryptEvent:%d", *((unsigned __int8 *)*a2 + 317), *((unsigned __int8 *)*a2 + 318));
        v11 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          v12 = sub_100054494();
          *(_DWORD *)buf = 136446210;
          v17 = v12;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
        }
      }
      (*a2)[40] = *((_WORD *)a2 + 20);
      (*a2)[41] = *((_WORD *)a2 + 21);
      (*a2)[42] = *((_WORD *)a2 + 22);
      *((_BYTE *)*a2 + 118) = *((_BYTE *)a2 + 46);
      *((_BYTE *)*a2 + 125) = *((_BYTE *)*a2 + 317);
      v13 = (uint64_t)*a2;
      if (*((_BYTE *)*a2 + 125))
      {
        *(_BYTE *)(v13 + 167) = 16;
        *((_BYTE *)*a2 + 169) = 1;
        v13 = (uint64_t)*a2;
        if (*((_BYTE *)*a2 + 318))
        {
          sub_10022BE78(0, v13, 1);
          v13 = (uint64_t)*a2;
        }
      }
      *(_DWORD *)(v13 + 132) = 1;
      *((_BYTE *)*a2 + 126) = 1;
      sub_100218040(0, (uint64_t)*a2, *((unsigned __int8 *)a2 + 47), *((unsigned __int16 *)a2 + 24), *((unsigned __int16 *)a2 + 25));
      *((_DWORD *)*a2 + 33) = 2;
      sub_10021739C(0, **a2, (unsigned __int16 **)((char *)a2 + 52));
      *((_DWORD *)*a2 + 33) = 3;
      *((_DWORD *)*a2 + 34) = 0;
      sub_1002177B4(**a2, *((unsigned __int16 *)a2 + 32), *((unsigned __int16 *)a2 + 33), *((unsigned __int16 *)a2 + 34), *((unsigned __int16 *)a2 + 35));
      *((_DWORD *)*a2 + 33) = 4;
      sub_100217B98(0, *a2, *((unsigned __int8 *)a2 + 61), *((unsigned __int8 *)a2 + 62));
    }
    else
    {
      if (sub_10005549C())
      {
        sub_100054530("FastLEConnection:LE_GAP_FastLEConnectionReady for invalid address %llu", a2[2]);
        v15 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      sub_100253460();
    }
  }
}

void sub_100225A9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  NSObject *v10;
  uint8_t buf[4];
  void *v12;

  if (sub_10005549C())
  {
    sub_100054530("AutoReconnect: state:%d scan:%d / %d ms numOfAddr:%d", a1, a2, a3, a4);
    v10 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v12 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if (off_10098AC28)
    off_10098AC28(a1, a2, a3, a4, a5);
}

uint64_t sub_100225BB4(uint64_t a1)
{
  return sub_10022D834(**(_QWORD **)(a1 + 8));
}

uint64_t sub_100225BC0(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, unsigned __int8 *a5)
{
  NSObject *v7;
  unsigned int v12;
  unsigned __int8 v13;
  uint64_t v14;
  NSObject *v15;
  __int128 v16;
  int v17;

  if (a2 % a3)
  {
    if (sub_10005549C())
    {
      sub_100054530("Invalid UUID list length: (%u %% %u) != 0", a2, a3);
      v7 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 4056;
  }
  if (a2)
  {
    v12 = 0;
    v13 = *a5;
    while (v13 < 0x7Du)
    {
      v14 = a4 + 20 * v13;
      sub_10005F660((int8x16_t *)(a1 + v12), a3, 1, (uint64_t)&v16);
      *(_OWORD *)v14 = v16;
      *(_DWORD *)(v14 + 16) = v17;
      v13 = *a5 + 1;
      *a5 = v13;
      v12 = (v12 + a3);
      if (v12 >= a2)
        return 0;
    }
    if (sub_10005549C())
    {
      sub_100054530("Invalid index %u for UUIDs in parseADUuids", *a5);
      v15 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 4056;
  }
  return 0;
}

uint64_t sub_100225D40(int8x16_t *a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  unsigned __int8 v5;
  NSObject *v7;
  unsigned __int8 *v9;
  NSObject *v10;
  NSObject *v11;
  uint64_t v13;
  NSObject *v14;
  uint64_t result;
  unsigned __int8 v16;
  __int128 v17;
  int v18;

  v5 = a2 - a3;
  if (a2 < a3)
  {
    if (!sub_10005549C())
      return 4057;
    sub_100054530("Invalid service data length: %d < %d (UUID size=%d)", a2, a3, a3);
    v7 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      return 4057;
    goto LABEL_12;
  }
  if (!a4)
  {
    if (!sub_10005549C())
      return 4057;
    sub_100054530("Invalid parsedData for parseADServiceData");
    v11 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      return 4057;
LABEL_12:
    sub_1006CE7A4();
    return 4057;
  }
  v9 = (unsigned __int8 *)(a4 + 5632);
  if (*(unsigned __int8 *)(a4 + 5632) >= 0xAuLL)
  {
    if (!sub_10005549C())
      return 4057;
    sub_100054530("Invalid parsedData nbServiceData %u for parseADServiceData", *v9);
    v10 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      return 4057;
    goto LABEL_12;
  }
  v13 = a4 + 56 * *(unsigned __int8 *)(a4 + 5632);
  sub_10005F660(a1, a3, 1, (uint64_t)&v17);
  *(_OWORD *)(v13 + 5072) = v17;
  *(_DWORD *)(v13 + 5088) = v18;
  if (v5 >= 0x20u)
  {
    if (sub_10005549C())
    {
      sub_100054530("Invalid size %d for serviceData in parseADServiceData", v5);
      v14 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 4057;
  }
  memmove((void *)(a4 + 5072 + 56 * *v9 + 20), &a1->i8[a3], v5);
  result = 0;
  v16 = *v9;
  *(_WORD *)(a4 + 5072 + 56 * *v9 + 52) = v5;
  *v9 = v16 + 1;
  return result;
}

void sub_100225F5C()
{
  uint64_t v0;

  dword_10098EE08 = 0;
  v0 = sub_100113398();
  if (v0 - qword_10098EE10 < 0x3E8)
    sub_10004A9EC((uint64_t)sub_100225F5C, 0, (unsigned __int16)(1099 - (v0 - qword_10098EE10)) / 0x64u, &dword_10098EE08);
  else
    sub_100114138();
}

void sub_100225FC0()
{
  sub_100223450();
  sub_100226000();
  byte_10098EDF9 = 0;
  sub_10022197C();
}

void sub_100225FE0()
{
  sub_100223450();
  sub_100226000();
  byte_10098EDF9 = 0;
  sub_10022197C();
}

void sub_100226000()
{
  unsigned int v0;
  uint32_t v1;
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  uint8_t buf[4];
  void *v7;

  LOWORD(v0) = word_10098EE04;
  if (!word_10098EE04)
  {
    v1 = arc4random();
    v0 = v1 - 6000 * ((unsigned __int16)v1 / 0x1770u) + 6000;
  }
  if (sub_10005549C())
  {
    sub_100054530("Registering PrivateAddressTimer gPrivateMode=%d gOverrideLocalAddress=%d gLePrivateAddressTimer=%d gLeCurrentAddress=%d gAutoAddressRefresh=%d gPrivateAddressRotateInterval=%d gPrivateAddressRotateIntervalOverride=%d nextRandomAddressChange=%d seconds gHoldStableAddress=%d", byte_10098EDE0, byte_10098EDE1, dword_10098EDEC, byte_10098EDAD, byte_10097A8BC, 6000, (unsigned __int16)word_10098EE04, (unsigned __int16)v0 / 0xAu, byte_10098EDF4);
    v2 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v7 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if (byte_10097A8BC)
  {
    v3 = sub_10004A9EC((uint64_t)sub_10021FDB8, 0, (unsigned __int16)v0, &dword_10098EDEC);
    if ((_DWORD)v3)
    {
      v4 = v3;
      if (sub_10005549C())
      {
        sub_100054530("Failed to register a private address refresh timer, status:%!", v4);
        v5 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
    }
  }
}

void sub_1002261B8()
{
  NSObject *v0;
  uint8_t buf[4];
  void *v2;

  if (sub_10005549C())
  {
    sub_100054530("Canceling LeHoldStablePrivateAddressTimer [%d]", (unsigned __int16)word_10098EDF6);
    v0 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v2 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if (dword_10098EDF0)
  {
    sub_100049F6C(dword_10098EDF0);
    dword_10098EDF0 = 0;
  }
}

_QWORD *sub_100226290()
{
  _QWORD *result;
  _QWORD *v1;

  sub_10020D374();
  sub_10020A634();
  result = (_QWORD *)qword_10098F020;
  if (qword_10098F020)
  {
    do
    {
      v1 = (_QWORD *)result[12];
      sub_100053298(result);
      result = v1;
    }
    while (v1);
  }
  qword_10098F020 = 0;
  return result;
}

uint64_t sub_1002262D0()
{
  uint64_t v0;
  NSObject *v1;

  v0 = sub_10020A388();
  if ((_DWORD)v0)
  {
    if (sub_10005549C())
    {
      sub_100054530("ATT initialization failed with status %!", v0);
      v1 = sub_1000544A0(0x45u);
      if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  else
  {
    sub_10020D314((uint64_t)off_10091F008);
  }
  return v0;
}

uint64_t sub_100226350(uint64_t a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t result;
  NSObject *v4;

  v1 = sub_10020AE08(a1);
  v2 = qword_10098F020;
  if (qword_10098F020)
  {
    while (*(_QWORD **)v2 != v1)
    {
      v2 = *(_QWORD *)(v2 + 96);
      if (!v2)
        goto LABEL_4;
    }
    return *(unsigned __int16 *)(v2 + 8);
  }
  else
  {
LABEL_4:
    result = sub_10005549C();
    if ((_DWORD)result)
    {
      sub_100054530("Could not find GATT session with HCI handle");
      v4 = sub_1000544A0(0x45u);
      result = os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
      if ((_DWORD)result)
      {
        sub_1006CE7A4();
        return 0;
      }
    }
  }
  return result;
}

uint64_t sub_1002263D4(uint64_t a1, uint64_t a2)
{
  _QWORD *v3;
  int v4;
  _WORD *v5;
  __int16 v6;
  uint64_t v7;
  NSObject *v8;

  v3 = sub_1002264A8(a1);
  if (v3)
  {
    LOWORD(v4) = *((_WORD *)v3 + 4);
  }
  else
  {
    v5 = sub_100052DC0(0x70uLL);
    if (v5)
    {
      *(_QWORD *)v5 = a2;
      v6 = word_10098F028;
      v4 = (unsigned __int16)word_10098F028++ + 1;
      v5[4] = v4;
      if ((v4 & 0x10000) != 0)
      {
        word_10098F028 = v6 + 2;
        v5[4] = v6 + 2;
        LOWORD(v4) = 1;
      }
      *((_QWORD *)v5 + 10) = 0;
      v5[44] = 0;
      *((_QWORD *)v5 + 2) = 0;
      *((_QWORD *)v5 + 3) = 0;
      v7 = qword_10098F020;
      *((_QWORD *)v5 + 12) = qword_10098F020;
      *((_QWORD *)v5 + 13) = 0;
      if (v7)
        *(_QWORD *)(v7 + 104) = v5;
      qword_10098F020 = (uint64_t)v5;
    }
    else
    {
      if (sub_10005549C())
      {
        sub_100054530("Failed to allocate a session.");
        v8 = sub_1000544A0(0x45u);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      LOWORD(v4) = 0;
    }
  }
  return (unsigned __int16)v4;
}

_QWORD *sub_1002264A8(uint64_t a1)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;

  v1 = sub_10020AE08(a1);
  v2 = 0;
  if (v1)
  {
    v3 = (_QWORD *)qword_10098F020;
    if (qword_10098F020)
    {
      while ((_QWORD *)*v3 != v1)
      {
        v3 = (_QWORD *)v3[12];
        if (!v3)
          return 0;
      }
      return v3;
    }
  }
  return (_QWORD *)v2;
}

uint64_t sub_1002264F4(int a1, _WORD *a2)
{
  uint64_t *v3;
  int v4;
  __int16 v5;
  uint64_t result;

  v3 = (uint64_t *)sub_100226540(a1);
  if (!v3)
    return 101;
  v4 = sub_10020AED0(*v3);
  if (!v4)
    return 4100;
  v5 = v4;
  result = 0;
  *a2 = v5;
  return result;
}

uint64_t sub_100226540(int a1)
{
  uint64_t result;
  NSObject *v3;

  result = qword_10098F020;
  if (qword_10098F020)
  {
    while (*(unsigned __int16 *)(result + 8) != a1)
    {
      result = *(_QWORD *)(result + 96);
      if (!result)
        goto LABEL_4;
    }
  }
  else
  {
LABEL_4:
    if (sub_10005549C())
    {
      sub_100054530("Could not find session with handle %x", a1);
      v3 = sub_1000544A0(0x45u);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 0;
  }
  return result;
}

uint64_t sub_1002265D0(uint64_t a1, __int16 a2)
{
  uint64_t *v3;

  v3 = sub_1002264A8(a1);
  if (!v3)
    return 101;
  sub_10020AF08(*v3, a2);
  return 0;
}

uint64_t sub_10022660C(int a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t result;

  v7 = sub_100226540(a1);
  result = 101;
  if (v7 && a2)
  {
    if (*(_QWORD *)(v7 + 16))
    {
      return 118;
    }
    else
    {
      result = sub_10020B234(*(_QWORD **)v7, (uint64_t)sub_10022667C, a3, v7);
      if (!(_DWORD)result)
      {
        *(_QWORD *)(v7 + 16) = a2;
        *(_QWORD *)(v7 + 24) = a4;
      }
    }
  }
  return result;
}

uint64_t sub_10022667C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t (*v8)(uint64_t, uint64_t, uint64_t);

  if (!(_DWORD)a2)
    sub_10020AF08(a1, a3);
  v8 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a4 + 16);
  v7 = *(_QWORD *)(a4 + 24);
  *(_QWORD *)(a4 + 16) = 0;
  return v8(a2, a3, v7);
}

uint64_t sub_1002266C4(int a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t result;
  int v7[10];

  v5 = (uint64_t *)sub_100226540(a1);
  *(_OWORD *)v7 = xmmword_10073B69C;
  *(_OWORD *)((char *)&v7[2] + 1) = *(__int128 *)((char *)&xmmword_10073B69C + 9);
  result = 101;
  if (v5 && a2)
  {
    if (v5[2])
    {
      return 118;
    }
    else
    {
      result = sub_10020B760(*v5, (uint64_t)sub_100226790, v7, (uint64_t)v5);
      if (!(_DWORD)result)
      {
        v5[2] = a2;
        v5[3] = a3;
        v5[4] = 0;
        v5[5] = 0;
        v5[6] = 0xFFFF000100000000;
        v5[7] = 0;
        v5[8] = 0;
        v5[9] = 0;
      }
    }
  }
  return result;
}

void sub_100226790(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5, uint64_t a6)
{
  uint64_t v7;
  char *v11;
  int v12;
  int8x16_t **v13;
  char *v14;
  uint64_t v15;
  int v16;
  char *v17;
  char *v18;
  int8x16_t *v19;
  int v20;
  __int128 v21;
  const void *v22;
  uint64_t v23;
  NSObject *v24;
  unsigned __int16 v25;
  uint64_t v26;
  void (*v27)(uint64_t, _QWORD, _QWORD, uint64_t);
  void *v28;
  void *__dst;
  unsigned int v30;
  _BYTE v31[21];
  int v32;

  if ((_DWORD)a2 != 10)
  {
    v7 = a2;
    if ((_DWORD)a2)
    {
      if (sub_10005549C())
      {
        sub_100054530("Received error response for services discovery: %d", v7);
        v24 = sub_1000544A0(0x45u);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      goto LABEL_26;
    }
    v30 = *(unsigned __int16 *)(a6 + 54);
    v11 = (char *)sub_100052DC0(24 * (*(unsigned __int16 *)(a6 + 88) + (unint64_t)a4));
    __dst = v11;
    v12 = 0;
    if (a4)
    {
      v13 = (int8x16_t **)(a3 + 8);
      v14 = v11;
      v15 = a4;
      while (1)
      {
        v16 = *(unsigned __int16 *)(a6 + 88);
        v17 = &v14[24 * *(unsigned __int16 *)(a6 + 88)];
        *(_DWORD *)v17 = *((_DWORD *)v13 - 2);
        if (a5 == 20)
          break;
        if (a5 == 6)
        {
          v18 = &v14[24 * v16];
          v19 = *v13;
          v20 = 2;
LABEL_9:
          sub_10005F660(v19, v20, 1, (uint64_t)v31);
          v21 = *(_OWORD *)v31;
          *((_DWORD *)v18 + 5) = *(_DWORD *)&v31[16];
          *(_OWORD *)(v18 + 4) = v21;
        }
        if (*((unsigned __int16 *)v17 + 1) <= (unsigned __int16)v12)
          v12 = (unsigned __int16)v12;
        else
          v12 = *((unsigned __int16 *)v17 + 1);
        v13 += 2;
        v14 += 24;
        if (!--v15)
          goto LABEL_14;
      }
      v18 = &v14[24 * v16];
      v19 = *v13;
      v20 = 16;
      goto LABEL_9;
    }
LABEL_14:
    v22 = *(const void **)(a6 + 80);
    v23 = *(unsigned __int16 *)(a6 + 88);
    if (v22)
    {
      memmove(__dst, v22, 24 * v23);
      sub_100053298(*(void **)(a6 + 80));
      LOWORD(v23) = *(_WORD *)(a6 + 88);
    }
    *(_QWORD *)(a6 + 80) = __dst;
    *(_WORD *)(a6 + 88) = v23 + a4;
    if (v12)
      v25 = v12;
    else
      v25 = -1;
    if (v30 > v25)
    {
      v31[0] = 16;
      *(_WORD *)&v31[1] = v25 + 1;
      *(_WORD *)&v31[3] = v30;
      v32 = 0;
      *(_OWORD *)&v31[5] = xmmword_10073B24C;
      v7 = sub_10020B760(*(_QWORD *)a6, (uint64_t)sub_100226790, (int *)v31, a6);
      if (!(_DWORD)v7)
        return;
      goto LABEL_26;
    }
  }
  v7 = 0;
LABEL_26:
  v27 = *(void (**)(uint64_t, _QWORD, _QWORD, uint64_t))(a6 + 16);
  v26 = *(_QWORD *)(a6 + 24);
  *(_QWORD *)(a6 + 16) = 0;
  v27(v7, *(_QWORD *)(a6 + 80), *(unsigned __int16 *)(a6 + 88), v26);
  v28 = *(void **)(a6 + 80);
  if (v28)
    sub_100053298(v28);
  *(_QWORD *)(a6 + 80) = 0;
  *(_WORD *)(a6 + 88) = 0;
}

double sub_1002269E4(int a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  size_t v10;
  double result;
  __int128 v12;
  int v13;

  v7 = sub_100226540(a1);
  v12 = *(_OWORD *)a3;
  v13 = *((_DWORD *)a3 + 4);
  __chkstk_darwin(v7, *a3);
  v9 = (char *)&v12 - v8;
  bzero((char *)&v12 - v8, v10);
  if (v7 && a2 && !*(_QWORD *)(v7 + 16))
  {
    sub_100072C50(v9, a3, 1);
    if (!sub_10020B630(*(_QWORD *)v7, (uint64_t)sub_100226B14, 10240, 1, 0xFFFFu, v9, *a3, v7))
    {
      *(_QWORD *)(v7 + 16) = a2;
      *(_QWORD *)(v7 + 24) = a4;
      result = *(double *)&v12;
      *(_OWORD *)(v7 + 32) = v12;
      *(_DWORD *)(v7 + 48) = v13;
      *(_DWORD *)(v7 + 52) = -65535;
      *(_QWORD *)(v7 + 64) = 0;
      *(_QWORD *)(v7 + 72) = 0;
      *(_QWORD *)(v7 + 56) = 0;
    }
  }
  return result;
}

void sub_100226B14(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  uint64_t v6;
  __int128 v9;
  char *v10;
  void *v11;
  unsigned int v12;
  unsigned __int16 *v13;
  char *v14;
  uint64_t v15;
  char *v16;
  unsigned int v17;
  unsigned int v18;
  const void *v19;
  unsigned __int16 v20;
  uint64_t v21;
  _BYTE *v22;
  size_t v23;
  NSObject *v24;
  uint64_t v25;
  void (*v26)(uint64_t, _QWORD, _QWORD, uint64_t);
  void *v27;
  __int128 v28;
  int v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;

  if ((_DWORD)a2 != 10)
  {
    v6 = a2;
    if ((_DWORD)a2)
    {
      if (sub_10005549C())
      {
        sub_100054530("Received error response for services matching UUID discovery: %d", v6);
        v24 = sub_1000544A0(0x45u);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      goto LABEL_21;
    }
    v9 = *(_OWORD *)(a5 + 48);
    v30 = *(_OWORD *)(a5 + 32);
    v31 = v9;
    v32 = *(_OWORD *)(a5 + 64);
    v28 = v30;
    v29 = *(_DWORD *)(a5 + 48);
    v10 = (char *)sub_100052DC0(24 * (*(unsigned __int16 *)(a5 + 88) + (unint64_t)a4));
    v11 = v10;
    v12 = 0;
    if (a4)
    {
      v13 = (unsigned __int16 *)(a3 + 2);
      v14 = v10;
      v15 = a4;
      do
      {
        v16 = &v14[24 * *(unsigned __int16 *)(a5 + 88)];
        *(_WORD *)v16 = *(v13 - 1);
        v18 = *v13;
        v13 += 2;
        v17 = v18;
        *((_WORD *)v16 + 1) = v18;
        *((_DWORD *)v16 + 5) = v29;
        *(_OWORD *)(v16 + 4) = v28;
        if (v18 <= (unsigned __int16)v12)
          v12 = (unsigned __int16)v12;
        else
          v12 = v17;
        v14 += 24;
        --v15;
      }
      while (v15);
    }
    v19 = *(const void **)(a5 + 80);
    if (v19)
    {
      memmove(v10, v19, 24 * *(unsigned __int16 *)(a5 + 88));
      sub_100053298(*(void **)(a5 + 80));
    }
    *(_QWORD *)(a5 + 80) = v11;
    *(_WORD *)(a5 + 88) += a4;
    if (v12)
      v20 = v12;
    else
      v20 = -1;
    if (WORD3(v31) > v20)
    {
      __chkstk_darwin(v10, v30);
      v22 = (char *)&v28 - v21;
      bzero((char *)&v28 - v21, v23);
      sub_100072C50(v22, (unsigned __int8 *)&v30, 1);
      v6 = sub_10020B630(*(_QWORD *)a5, (uint64_t)sub_100226B14, 10240, v20 + 1, 0xFFFFu, v22, v30, a5);
      if (!(_DWORD)v6)
        return;
      goto LABEL_21;
    }
  }
  v6 = 0;
LABEL_21:
  v26 = *(void (**)(uint64_t, _QWORD, _QWORD, uint64_t))(a5 + 16);
  v25 = *(_QWORD *)(a5 + 24);
  *(_QWORD *)(a5 + 16) = 0;
  v26(v6, *(_QWORD *)(a5 + 80), *(unsigned __int16 *)(a5 + 88), v25);
  v27 = *(void **)(a5 + 80);
  if (v27)
    sub_100053298(v27);
  *(_QWORD *)(a5 + 80) = 0;
  *(_WORD *)(a5 + 88) = 0;
}

uint64_t sub_100226D60(int a1, uint64_t a2, __int16 a3, __int16 a4, uint64_t a5)
{
  uint64_t v9;
  uint64_t result;
  char v11;
  __int16 v12;
  __int16 v13;
  __int128 v14;
  int v15;

  v9 = sub_100226540(a1);
  v11 = 8;
  v12 = a3;
  v13 = a4;
  v15 = 0;
  v14 = xmmword_10073B274;
  result = 101;
  if (v9 && a2)
  {
    if (*(_QWORD *)(v9 + 16))
    {
      return 118;
    }
    else
    {
      result = sub_10020B760(*(_QWORD *)v9, (uint64_t)sub_100226E4C, (int *)&v11, v9);
      if (!(_DWORD)result)
      {
        *(_QWORD *)(v9 + 16) = a2;
        *(_QWORD *)(v9 + 24) = a5;
        *(_QWORD *)(v9 + 32) = 0;
        *(_QWORD *)(v9 + 40) = 0;
        *(_DWORD *)(v9 + 48) = 0;
        *(_WORD *)(v9 + 52) = a3;
        *(_WORD *)(v9 + 54) = a4;
        *(_QWORD *)(v9 + 64) = 0;
        *(_QWORD *)(v9 + 72) = 0;
        *(_QWORD *)(v9 + 56) = 0;
      }
    }
  }
  return result;
}

void sub_100226E4C(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5, uint64_t a6)
{
  uint64_t v7;
  char *v11;
  int v12;
  _WORD **v13;
  char *v14;
  uint64_t i;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  _WORD *v19;
  char *v20;
  char *v21;
  int8x16_t *v22;
  int v23;
  __int128 v24;
  const void *v25;
  uint64_t v26;
  NSObject *v27;
  unsigned __int16 v28;
  uint64_t v29;
  void (*v30)(uint64_t, _QWORD, _QWORD, uint64_t);
  void *v31;
  void *__dst;
  unsigned int v33;
  _BYTE v34[21];
  int v35;

  if ((_DWORD)a2 == 10)
  {
    if (sub_100228BE4(a6))
      return;
  }
  else
  {
    v7 = a2;
    if ((_DWORD)a2)
    {
      if (sub_10005549C())
      {
        sub_100054530("Received error response for included services discovery: %d", v7);
        v27 = sub_1000544A0(0x45u);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      goto LABEL_30;
    }
    v33 = *(unsigned __int16 *)(a6 + 54);
    v11 = (char *)sub_100052DC0(28 * (*(unsigned __int16 *)(a6 + 88) + (unint64_t)a4));
    __dst = v11;
    v12 = 0;
    if (a4)
    {
      v13 = (_WORD **)(a3 + 8);
      v14 = v11;
      for (i = a4; i; --i)
      {
        v16 = *(unsigned __int16 *)(a6 + 88);
        v17 = 28 * v16;
        v18 = &v14[28 * v16];
        *(_WORD *)v18 = *((_WORD *)v13 - 4);
        v19 = *v13;
        *((_WORD *)v18 + 1) = **v13;
        *((_WORD *)v18 + 2) = v19[1];
        if (a5 == 22)
        {
          v21 = &v14[28 * v16];
          v22 = (int8x16_t *)(v19 + 2);
          v23 = 16;
        }
        else
        {
          if (a5 != 8)
          {
            if (a5 == 6)
            {
              v20 = &v14[28 * v16];
              v20[8] = 0;
              *((_WORD *)v20 + 6) = 0;
            }
            goto LABEL_12;
          }
          v21 = &v14[28 * v16];
          v22 = (int8x16_t *)(v19 + 2);
          v23 = 2;
        }
        sub_10005F660(v22, v23, 1, (uint64_t)v34);
        v24 = *(_OWORD *)v34;
        *((_DWORD *)v21 + 6) = *(_DWORD *)&v34[16];
        *(_OWORD *)(v21 + 8) = v24;
LABEL_12:
        if (*(unsigned __int16 *)&v14[v17] <= (unsigned __int16)v12)
          v12 = (unsigned __int16)v12;
        else
          v12 = *(unsigned __int16 *)&v14[v17];
        v14 += 28;
        v13 += 2;
      }
    }
    v25 = *(const void **)(a6 + 80);
    v26 = *(unsigned __int16 *)(a6 + 88);
    if (v25)
    {
      memmove(__dst, v25, 28 * v26);
      sub_100053298(*(void **)(a6 + 80));
      LOWORD(v26) = *(_WORD *)(a6 + 88);
    }
    *(_QWORD *)(a6 + 80) = __dst;
    *(_WORD *)(a6 + 88) = v26 + a4;
    if (v12)
      v28 = v12;
    else
      v28 = -1;
    if (v33 > v28)
    {
      v34[0] = 8;
      *(_WORD *)&v34[1] = v28 + 1;
      *(_WORD *)&v34[3] = v33;
      v35 = 0;
      *(_OWORD *)&v34[5] = xmmword_10073B274;
      v7 = sub_10020B760(*(_QWORD *)a6, (uint64_t)sub_100226E4C, (int *)v34, a6);
      if (!(_DWORD)v7)
        return;
      goto LABEL_30;
    }
  }
  v7 = 0;
LABEL_30:
  v30 = *(void (**)(uint64_t, _QWORD, _QWORD, uint64_t))(a6 + 16);
  v29 = *(_QWORD *)(a6 + 24);
  *(_QWORD *)(a6 + 16) = 0;
  v30(v7, *(_QWORD *)(a6 + 80), *(unsigned __int16 *)(a6 + 88), v29);
  v31 = *(void **)(a6 + 80);
  if (v31)
    sub_100053298(v31);
  *(_QWORD *)(a6 + 80) = 0;
  *(_WORD *)(a6 + 88) = 0;
}

uint64_t sub_1002270E4(int a1, uint64_t a2, __int16 a3, __int16 a4, uint64_t a5)
{
  uint64_t v9;
  uint64_t result;
  char v11;
  __int16 v12;
  __int16 v13;
  __int128 v14;
  int v15;

  v9 = sub_100226540(a1);
  v11 = 8;
  v12 = a3;
  v13 = a4;
  v15 = 0;
  v14 = xmmword_10073B288;
  result = 101;
  if (v9 && a2)
  {
    if (*(_QWORD *)(v9 + 16))
    {
      return 118;
    }
    else
    {
      result = sub_10020B760(*(_QWORD *)v9, (uint64_t)sub_1002271D0, (int *)&v11, v9);
      if (!(_DWORD)result)
      {
        *(_QWORD *)(v9 + 16) = a2;
        *(_QWORD *)(v9 + 24) = a5;
        *(_QWORD *)(v9 + 32) = 0;
        *(_QWORD *)(v9 + 40) = 0;
        *(_DWORD *)(v9 + 48) = 0;
        *(_WORD *)(v9 + 52) = a3;
        *(_WORD *)(v9 + 54) = a4;
        *(_QWORD *)(v9 + 64) = 0;
        *(_QWORD *)(v9 + 72) = 0;
        *(_QWORD *)(v9 + 56) = 0;
      }
    }
  }
  return result;
}

void sub_1002271D0(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5, uint64_t a6)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char *v10;
  unsigned __int16 v11;
  int v12;
  char **v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  unsigned __int16 *v18;
  char *v19;
  int8x16_t *v20;
  int v21;
  __int128 v22;
  NSObject *v23;
  const void *v24;
  uint64_t v25;
  unsigned __int16 v26;
  uint64_t v27;
  void (*v28)(uint64_t, _QWORD, _QWORD, uint64_t);
  void *v29;
  int v31;
  uint64_t v32;
  _BYTE v34[21];
  int v35;
  __int128 v36;
  int v37;

  v6 = a6;
  if ((_DWORD)a2 != 10)
  {
    v7 = a2;
    if ((_DWORD)a2)
    {
      if (sub_10005549C())
      {
        sub_100054530("Received error response for characteristics discovery: %d", v7);
        v23 = sub_1000544A0(0x45u);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      goto LABEL_31;
    }
    LODWORD(v8) = a4;
    v31 = *(unsigned __int16 *)(a6 + 54);
    v36 = *(_OWORD *)(a6 + 32);
    v37 = *(_DWORD *)(a6 + 48);
    v10 = (char *)sub_100052DC0(28 * (*(unsigned __int16 *)(a6 + 88) + (unint64_t)a4));
    if ((_DWORD)v8)
    {
      v11 = 0;
      LOWORD(v12) = 0;
      v13 = (char **)(a3 + 8);
      v8 = v8;
      v32 = v6;
      while (1)
      {
        v14 = v10;
        v15 = &v10[28 * *(unsigned __int16 *)(v6 + 88)];
        v16 = &v15[28 * v11];
        *(_WORD *)v16 = *((_WORD *)v13 - 4);
        v17 = *v13;
        v16[2] = **v13;
        *((_WORD *)v16 + 2) = *(_WORD *)(v17 + 1);
        v18 = (unsigned __int16 *)(v16 + 4);
        if (a5 == 21)
        {
          v19 = &v15[28 * v11];
          v20 = (int8x16_t *)(v17 + 3);
          v21 = 16;
        }
        else
        {
          if (a5 != 7)
            goto LABEL_10;
          v19 = &v15[28 * v11];
          v20 = (int8x16_t *)(v17 + 3);
          v21 = 2;
        }
        sub_10005F660(v20, v21, 1, (uint64_t)v34);
        v22 = *(_OWORD *)v34;
        *((_DWORD *)v19 + 6) = *(_DWORD *)&v34[16];
        *(_OWORD *)(v19 + 8) = v22;
        v6 = v32;
LABEL_10:
        if (!(_BYTE)v36 || sub_100072DF0((unsigned __int8 *)&v36, (unsigned __int8 *)&v15[28 * v11 + 8]))
          ++v11;
        if (*v18 <= (unsigned __int16)v12)
          v12 = (unsigned __int16)v12;
        else
          v12 = *v18;
        v13 += 2;
        --v8;
        v10 = v14;
        if (!v8)
          goto LABEL_22;
      }
    }
    v12 = 0;
    v11 = 0;
LABEL_22:
    v24 = *(const void **)(v6 + 80);
    v25 = *(unsigned __int16 *)(v6 + 88);
    if (v24)
    {
      memmove(v10, v24, 28 * v25);
      sub_100053298(*(void **)(v6 + 80));
      LOWORD(v25) = *(_WORD *)(v6 + 88);
    }
    *(_QWORD *)(v6 + 80) = v10;
    *(_WORD *)(v6 + 88) = v25 + v11;
    if (v12)
      v26 = v12;
    else
      v26 = -1;
    if (v31 - 1 > v26)
    {
      v34[0] = 8;
      *(_WORD *)&v34[1] = v26 + 1;
      *(_WORD *)&v34[3] = v31;
      v35 = 0;
      *(_OWORD *)&v34[5] = xmmword_10073B288;
      v7 = sub_10020B760(a1, (uint64_t)sub_1002271D0, (int *)v34, v6);
      if (!(_DWORD)v7)
        return;
      goto LABEL_31;
    }
  }
  v7 = 0;
LABEL_31:
  v28 = *(void (**)(uint64_t, _QWORD, _QWORD, uint64_t))(v6 + 16);
  v27 = *(_QWORD *)(v6 + 24);
  *(_QWORD *)(v6 + 16) = 0;
  v28(v7, *(_QWORD *)(v6 + 80), *(unsigned __int16 *)(v6 + 88), v27);
  v29 = *(void **)(v6 + 80);
  if (v29)
    sub_100053298(v29);
  *(_QWORD *)(v6 + 80) = 0;
  *(_WORD *)(v6 + 88) = 0;
}

__n128 sub_100227488(int a1, uint64_t a2, __n128 *a3, __int16 a4, __int16 a5, uint64_t a6)
{
  uint64_t v11;
  __n128 result;
  __n128 v13;
  unsigned __int32 v14;
  char v15;
  __int16 v16;
  __int16 v17;
  __int128 v18;
  int v19;

  v11 = sub_100226540(a1);
  v15 = 8;
  v16 = a4;
  v17 = a5;
  v19 = 0;
  v18 = xmmword_10073B288;
  result = *a3;
  v13 = *a3;
  v14 = a3[1].n128_u32[0];
  if (v11
    && a2
    && !*(_QWORD *)(v11 + 16)
    && !sub_10020B760(*(_QWORD *)v11, (uint64_t)sub_1002271D0, (int *)&v15, v11))
  {
    *(_QWORD *)(v11 + 16) = a2;
    *(_QWORD *)(v11 + 24) = a6;
    result = v13;
    *(__n128 *)(v11 + 32) = v13;
    *(_DWORD *)(v11 + 48) = v14;
    *(_WORD *)(v11 + 52) = a4;
    *(_WORD *)(v11 + 54) = a5;
    *(_QWORD *)(v11 + 64) = 0;
    *(_QWORD *)(v11 + 72) = 0;
    *(_QWORD *)(v11 + 56) = 0;
  }
  return result;
}

uint64_t sub_100227590(int a1, uint64_t a2, __int16 a3, __int16 a4, uint64_t a5)
{
  uint64_t v9;
  uint64_t result;
  char v11;
  __int16 v12;
  __int16 v13;

  v9 = sub_100226540(a1);
  v11 = 4;
  v12 = a3;
  v13 = a4;
  result = 101;
  if (v9 && a2)
  {
    if (*(_QWORD *)(v9 + 16))
    {
      return 118;
    }
    else
    {
      result = sub_10020B534(*(_QWORD *)v9, (uint64_t)sub_10022763C, (uint64_t)&v11, v9);
      if (!(_DWORD)result)
      {
        *(_QWORD *)(v9 + 16) = a2;
        *(_QWORD *)(v9 + 24) = a5;
        *(_QWORD *)(v9 + 32) = 0;
        *(_QWORD *)(v9 + 40) = 0;
        *(_DWORD *)(v9 + 48) = 0;
        *(_WORD *)(v9 + 52) = a3;
        *(_WORD *)(v9 + 54) = a4;
        *(_QWORD *)(v9 + 64) = 0;
        *(_QWORD *)(v9 + 72) = 0;
        *(_QWORD *)(v9 + 56) = 0;
      }
    }
  }
  return result;
}

void sub_10022763C(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  uint64_t v6;
  unsigned int v9;
  char *v10;
  void *v11;
  unsigned int v12;
  __int128 *v13;
  char *v14;
  uint64_t v15;
  char *v16;
  unsigned int v17;
  __int128 v18;
  const void *v19;
  unsigned __int16 v20;
  NSObject *v21;
  uint64_t v22;
  void (*v23)(uint64_t, _QWORD, _QWORD, uint64_t);
  void *v24;
  char v25;
  __int16 v26;
  __int16 v27;

  if ((_DWORD)a2 != 10)
  {
    v6 = a2;
    if ((_DWORD)a2)
    {
      if (sub_10005549C())
      {
        sub_100054530("Received error response for descriptors discovery: %u", v6);
        v21 = sub_1000544A0(0x45u);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      goto LABEL_21;
    }
    v9 = *(unsigned __int16 *)(a5 + 54);
    v10 = (char *)sub_100052DC0(40 * (*(unsigned __int16 *)(a5 + 88) + (unint64_t)a4));
    v11 = v10;
    v12 = 0;
    if (a4)
    {
      v13 = (__int128 *)(a3 + 4);
      v14 = v10;
      v15 = a4;
      do
      {
        v16 = &v14[40 * *(unsigned __int16 *)(a5 + 88)];
        v17 = *((unsigned __int16 *)v13 - 2);
        *(_WORD *)v16 = v17;
        v18 = *v13;
        *((_DWORD *)v16 + 5) = *((_DWORD *)v13 + 4);
        *(_OWORD *)(v16 + 4) = v18;
        *((_QWORD *)v16 + 3) = 0;
        *((_WORD *)v16 + 16) = 0;
        if (v17 <= (unsigned __int16)v12)
          v12 = (unsigned __int16)v12;
        else
          v12 = v17;
        v14 += 40;
        v13 = (__int128 *)((char *)v13 + 24);
        --v15;
      }
      while (v15);
    }
    v19 = *(const void **)(a5 + 80);
    if (v19)
    {
      memmove(v10, v19, 40 * *(unsigned __int16 *)(a5 + 88));
      sub_100053298(*(void **)(a5 + 80));
    }
    *(_QWORD *)(a5 + 80) = v11;
    *(_WORD *)(a5 + 88) += a4;
    if (v12)
      v20 = v12;
    else
      v20 = -1;
    if (v9 > v20)
    {
      v25 = 4;
      v26 = v20 + 1;
      v27 = v9;
      v6 = sub_10020B534(*(_QWORD *)a5, (uint64_t)sub_10022763C, (uint64_t)&v25, a5);
      if (!(_DWORD)v6)
        return;
      goto LABEL_21;
    }
  }
  v6 = 0;
LABEL_21:
  v23 = *(void (**)(uint64_t, _QWORD, _QWORD, uint64_t))(a5 + 16);
  v22 = *(_QWORD *)(a5 + 24);
  *(_QWORD *)(a5 + 16) = 0;
  v23(v6, *(_QWORD *)(a5 + 80), *(unsigned __int16 *)(a5 + 88), v22);
  v24 = *(void **)(a5 + 80);
  if (v24)
    sub_100053298(v24);
  *(_QWORD *)(a5 + 80) = 0;
  *(_WORD *)(a5 + 88) = 0;
}

uint64_t sub_1002277F4(int a1, uint64_t a2, __int16 a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t result;
  char v9;
  __int16 v10;

  v7 = sub_100226540(a1);
  v9 = 10;
  v10 = a3;
  result = 101;
  if (v7 && a2)
  {
    if (*(_QWORD *)(v7 + 16))
    {
      return 118;
    }
    else
    {
      result = sub_10020B8BC(*(_QWORD *)v7, (uint64_t)sub_100227894, (uint64_t)&v9, v7);
      if (!(_DWORD)result)
      {
        *(_QWORD *)(v7 + 16) = a2;
        *(_QWORD *)(v7 + 24) = a4;
        *(_QWORD *)(v7 + 32) = 0;
        *(_QWORD *)(v7 + 40) = 0;
        *(_DWORD *)(v7 + 48) = 0;
        *(_WORD *)(v7 + 52) = a3;
        *(_QWORD *)(v7 + 54) = 0;
        *(_QWORD *)(v7 + 70) = 0;
        *(_QWORD *)(v7 + 62) = 0;
        *(_WORD *)(v7 + 78) = 0;
      }
    }
  }
  return result;
}

void sub_100227894(uint64_t a1, uint64_t a2, const void *a3, unsigned int a4, uint64_t a5)
{
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  void (*v9)(uint64_t, _QWORD, _QWORD, uint64_t);
  __int16 v12;
  int v13;
  size_t v14;
  char *v15;
  const void *v16;
  unsigned __int16 v17;
  int v18;
  uint64_t v19;
  void (*v20)(_QWORD, _QWORD, _QWORD, uint64_t);
  void *v21;
  char v22;
  __int16 v23;
  __int16 v24;

  if ((_DWORD)a2)
  {
    v6 = a2;
    if (sub_10005549C())
    {
      sub_100054530("LE_GATT_Handle_ReadLongCharacteristicValueResponse Received error response for characteristic read: %u", v6);
      v7 = sub_1000544A0(0x45u);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  else
  {
    v12 = *(_WORD *)(a5 + 52);
    v13 = *(unsigned __int16 *)(a5 + 56);
    v14 = a4;
    v15 = (char *)sub_100052DC0(*(unsigned __int16 *)(a5 + 88) + (unint64_t)a4);
    memmove(&v15[*(unsigned __int16 *)(a5 + 88)], a3, v14);
    v16 = *(const void **)(a5 + 80);
    if (v16)
    {
      memmove(v15, v16, *(unsigned __int16 *)(a5 + 88));
      sub_100053298(*(void **)(a5 + 80));
    }
    *(_QWORD *)(a5 + 80) = v15;
    v17 = *(_WORD *)(a5 + 88) + a4;
    *(_WORD *)(a5 + 88) = v17;
    v18 = sub_10020AED0(*(_QWORD *)a5);
    if (!v17 || v13 + v17 > 0x1FF || v18 - 1 > (int)a4)
    {
      v20 = *(void (**)(_QWORD, _QWORD, _QWORD, uint64_t))(a5 + 16);
      v19 = *(_QWORD *)(a5 + 24);
      *(_QWORD *)(a5 + 16) = 0;
      v20(0, *(_QWORD *)(a5 + 80), *(unsigned __int16 *)(a5 + 88), v19);
      goto LABEL_12;
    }
    v22 = 12;
    v23 = v12;
    v24 = v13 + v17;
    v6 = sub_10020B9A8(*(_QWORD *)a5, (uint64_t)sub_100227894, (uint64_t)&v22, a5);
    if (!(_DWORD)v6)
      return;
  }
  v9 = *(void (**)(uint64_t, _QWORD, _QWORD, uint64_t))(a5 + 16);
  v8 = *(_QWORD *)(a5 + 24);
  *(_QWORD *)(a5 + 16) = 0;
  v9(v6, 0, 0, v8);
LABEL_12:
  v21 = *(void **)(a5 + 80);
  if (v21)
    sub_100053298(v21);
  *(_QWORD *)(a5 + 80) = 0;
  *(_WORD *)(a5 + 88) = 0;
}

uint64_t sub_100227A20(int a1, uint64_t a2, __int128 *a3, __int16 a4, unsigned int a5, __int16 a6, uint64_t a7)
{
  uint64_t *v13;
  uint64_t *v14;
  uint64_t v15;
  NSObject *v17;
  __int128 v18;
  int v19;
  char v20;
  __int16 v21;
  __int16 v22;
  __int128 v23;
  int v24;

  v13 = (uint64_t *)sub_100226540(a1);
  v20 = 8;
  v21 = a4;
  v22 = a5;
  v23 = *a3;
  v24 = *((_DWORD *)a3 + 4);
  v18 = *a3;
  v19 = *((_DWORD *)a3 + 4);
  if (a5 <= (unsigned __int16)(a4 - 1))
    return 101;
  v14 = v13;
  v15 = 101;
  if (v13 && a2)
  {
    if (v13[2])
    {
      return 118;
    }
    else
    {
      v15 = sub_10020B760(*v13, (uint64_t)sub_100227B98, (int *)&v20, (uint64_t)v13);
      if ((_DWORD)v15)
      {
        if (sub_10005549C())
        {
          sub_100054530("Failed to send discover all services request for bearer 0x%x %!", v14, v15);
          v17 = sub_1000544A0(0x45u);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
      }
      else
      {
        v14[2] = a2;
        v14[3] = a7;
        *((_OWORD *)v14 + 2) = v18;
        *((_DWORD *)v14 + 12) = v19;
        *((_WORD *)v14 + 26) = a4;
        *((_WORD *)v14 + 27) = a5;
        v14[7] = 0;
        v14[8] = 0;
        *((_WORD *)v14 + 36) = 0;
        *((_WORD *)v14 + 37) = a6;
        *((_DWORD *)v14 + 19) = 0;
      }
    }
  }
  return v15;
}

void sub_100227B98(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5, uint64_t a6)
{
  uint64_t *v9;
  uint64_t v10;
  void (*v12)(uint64_t, uint64_t, uint64_t, uint64_t);
  unsigned int v13;
  uint64_t v14;
  unsigned int v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  NSObject *v20;
  void *v21;
  char v22;
  __int16 v23;
  __int16 v24;
  __int128 v25;
  int v26;

  v9 = &qword_10098F020;
  do
  {
    v10 = *v9;
    v9 = (uint64_t *)(*v9 + 96);
  }
  while (v10 != a6 && v10 != 0);
  if (v10)
  {
    v12 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a6 + 16);
    if ((_DWORD)a2 == 10)
    {
      if (!v12)
        return;
      *(_QWORD *)(a6 + 16) = 0;
      v17 = *(_QWORD *)(a6 + 80);
      v14 = *(unsigned __int16 *)(a6 + 88);
      v18 = *(_QWORD *)(a6 + 24);
      v19 = 10;
    }
    else if ((_DWORD)a2)
    {
      if (sub_10005549C()
        && (sub_100054530("Received error response for read value %d", a2),
            v20 = sub_1000544A0(0x45u),
            os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)))
      {
        sub_1006CE7A4();
        if (!v12)
          return;
      }
      else if (!v12)
      {
        return;
      }
      *(_QWORD *)(a6 + 16) = 0;
      v18 = *(_QWORD *)(a6 + 24);
      v19 = a2;
      v17 = 0;
      v14 = 0;
    }
    else
    {
      v13 = sub_100229068(a6, a3, a4, a5);
      v14 = *(unsigned __int16 *)(a6 + 88);
      if (v14 >= *(unsigned __int16 *)(a6 + 74)
        || v13 == 0xFFFF
        || (v15 = *(unsigned __int16 *)(a6 + 54), v13 >= v15))
      {
        if (!v12)
          return;
        *(_QWORD *)(a6 + 16) = 0;
        v17 = *(_QWORD *)(a6 + 80);
      }
      else
      {
        v22 = 8;
        v23 = v13 + 1;
        v24 = v15;
        v25 = *(_OWORD *)(a6 + 32);
        v26 = *(_DWORD *)(a6 + 48);
        if (!sub_10020B760(a1, (uint64_t)sub_100227B98, (int *)&v22, a6))
          return;
        if (sub_10005549C()
          && (sub_100054530("Failed to send read characteristics value request for bearer 0x%x", a1),
              v16 = sub_1000544A0(0x45u),
              os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)))
        {
          sub_1006CE7A4();
          if (!v12)
            return;
        }
        else if (!v12)
        {
          return;
        }
        *(_QWORD *)(a6 + 16) = 0;
        v17 = *(_QWORD *)(a6 + 80);
        v14 = *(unsigned __int16 *)(a6 + 88);
      }
      v18 = *(_QWORD *)(a6 + 24);
      v19 = 0;
    }
    v12(v19, v17, v14, v18);
    v21 = *(void **)(a6 + 80);
    if (v21)
      sub_100053298(v21);
    *(_QWORD *)(a6 + 80) = 0;
    *(_WORD *)(a6 + 88) = 0;
  }
}

uint64_t sub_100227DB0(int a1, uint64_t a2, __int16 a3, __int16 a4, uint64_t a5)
{
  uint64_t v9;
  uint64_t result;
  char v11;
  __int16 v12;
  __int16 v13;

  v9 = sub_100226540(a1);
  v11 = 12;
  v12 = a3;
  v13 = a4;
  result = 101;
  if (v9 && a2)
  {
    if (*(_QWORD *)(v9 + 16))
    {
      return 118;
    }
    else
    {
      result = sub_10020B9A8(*(_QWORD *)v9, (uint64_t)sub_100227894, (uint64_t)&v11, v9);
      if (!(_DWORD)result)
      {
        *(_QWORD *)(v9 + 16) = a2;
        *(_QWORD *)(v9 + 24) = a5;
        *(_QWORD *)(v9 + 32) = 0;
        *(_QWORD *)(v9 + 40) = 0;
        *(_DWORD *)(v9 + 48) = 0;
        *(_WORD *)(v9 + 52) = a3;
        *(_WORD *)(v9 + 54) = 0;
        *(_WORD *)(v9 + 56) = a4;
        *(_QWORD *)(v9 + 66) = 0;
        *(_QWORD *)(v9 + 58) = 0;
        *(_QWORD *)(v9 + 72) = 0;
      }
    }
  }
  return result;
}

uint64_t sub_100227E64(int a1, uint64_t a2, __int16 a3, uint64_t a4, __int16 a5, uint64_t a6)
{
  uint64_t *v11;
  char v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v16;
  void (*v17)(uint64_t, uint64_t, uint64_t);
  NSObject *v18;
  char v19;
  __int16 v20;
  __int16 v21;
  uint64_t v22;

  v11 = (uint64_t *)sub_100226540(a1);
  if (a2)
    v12 = 18;
  else
    v12 = 82;
  v19 = v12;
  v20 = a3;
  v21 = a5;
  v22 = a4;
  if (!v11)
    return 101;
  v13 = (uint64_t)v11;
  if (v11[2])
    return 118;
  v16 = *v11;
  if (a2)
    v17 = sub_100227F60;
  else
    v17 = 0;
  v14 = sub_10020BA94(v16, (uint64_t)v17, (__int16 *)&v19, v13);
  if ((_DWORD)v14)
  {
    if (sub_10005549C())
    {
      sub_100054530("Failed to write request for bearer 0x%x %!", v13, v14);
      v18 = sub_1000544A0(0x45u);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  else
  {
    *(_QWORD *)(v13 + 16) = a2;
    *(_QWORD *)(v13 + 24) = a6;
  }
  return v14;
}

void sub_100227F60(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t v6;
  void (*v8)(uint64_t, _QWORD);
  NSObject *v9;

  v5 = &qword_10098F020;
  do
  {
    v6 = *v5;
    v5 = (uint64_t *)(*v5 + 96);
  }
  while (v6 != a3 && v6 != 0);
  if (v6)
  {
    v8 = *(void (**)(uint64_t, _QWORD))(a3 + 16);
    *(_QWORD *)(a3 + 16) = 0;
    if ((_DWORD)a2
      && sub_10005549C()
      && (sub_100054530("Received error response for write value %d", a2),
          v9 = sub_1000544A0(0x45u),
          os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)))
    {
      sub_1006CE7A4();
      if (!v8)
        return;
    }
    else if (!v8)
    {
      return;
    }
    v8(a2, *(_QWORD *)(a3 + 24));
  }
}

uint64_t sub_100228014(int a1, uint64_t a2, __int16 a3, __int16 a4, const void *a5, unsigned int a6, uint64_t a7)
{
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v17;
  NSObject *v18;
  void *v19;
  char v20;
  __int16 v21;
  __int16 v22;
  __int16 v23;
  const void *v24;

  v13 = (uint64_t *)sub_100226540(a1);
  v20 = 22;
  v21 = a3;
  v22 = a4;
  v23 = a6;
  v14 = 101;
  v24 = a5;
  if (v13 && a2)
  {
    v15 = (uint64_t)v13;
    if (v13[2])
    {
      return 118;
    }
    else
    {
      if (a6 + 5 > sub_10020AED0(*v13))
        v23 = sub_10020AED0(*(_QWORD *)v15) - 5;
      v17 = sub_10020BBE4(*(_QWORD *)v15, (uint64_t)sub_100228178, (int *)&v20, v15);
      if ((_DWORD)v17)
      {
        v14 = v17;
        if (sub_10005549C())
        {
          sub_100054530("Failed to write request for bearer 0x%x %!", v15, v14);
          v18 = sub_1000544A0(0x45u);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
      }
      else
      {
        *(_QWORD *)(v15 + 16) = a2;
        *(_QWORD *)(v15 + 24) = a7;
        *(_QWORD *)(v15 + 32) = 0;
        *(_QWORD *)(v15 + 40) = 0;
        *(_DWORD *)(v15 + 48) = 0;
        *(_WORD *)(v15 + 52) = a3;
        *(_WORD *)(v15 + 54) = 0;
        *(_WORD *)(v15 + 56) = a4;
        *(_QWORD *)(v15 + 66) = 0;
        *(_QWORD *)(v15 + 72) = 0;
        *(_QWORD *)(v15 + 58) = 0;
        *(_WORD *)(v15 + 72) = a6;
        v19 = sub_100052DC0(a6);
        *(_QWORD *)(v15 + 64) = v19;
        if (v19)
          memmove(v19, a5, a6);
        return 0;
      }
    }
  }
  return v14;
}

void sub_100228178(int a1, uint64_t a2, int a3, int a4, void *__s2, size_t __n, uint64_t *a7)
{
  uint64_t *v10;
  uint64_t *v11;
  uint64_t v13;
  void (*v14)(uint64_t, uint64_t);
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  unsigned __int16 v23;
  unsigned int v24;
  uint64_t v25;
  NSObject *v26;
  uint64_t v27;
  uint64_t v28;
  NSObject *v29;
  NSObject *v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  NSObject *v34;
  uint64_t v35;
  NSObject *v36;
  __int16 v37;
  unsigned int v38;
  uint64_t v39;
  NSObject *v40;
  void *v41;
  char v42;
  __int16 v43;
  __int16 v44;
  __int16 v45;
  uint64_t v46;

  v10 = &qword_10098F020;
  do
  {
    v11 = (uint64_t *)*v10;
    v10 = (uint64_t *)(*v10 + 96);
  }
  while (v11 != a7 && v11 != 0);
  if (!v11)
    return;
  v13 = *a7;
  *(_BYTE *)(*a7 + 96) = a2;
  v14 = (void (*)(uint64_t, uint64_t))a7[2];
  if ((_DWORD)a2)
  {
    if (sub_10005549C())
    {
      sub_100054530("Received error response %d for write long value - canceling execution", a2);
      v15 = sub_1000544A0(0x45u);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    v16 = sub_10020BCEC(*a7, (uint64_t)sub_1002291E8, 0, (uint64_t)a7);
    if ((_DWORD)v16)
    {
      v17 = v16;
      if (!sub_10005549C()
        || (sub_100054530("Failed to execute write request %!", v17),
            v18 = sub_1000544A0(0x45u),
            !os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)))
      {
        if (!v14)
          goto LABEL_18;
        goto LABEL_16;
      }
      sub_1006CE7A4();
      if (v14)
      {
LABEL_16:
        a7[2] = 0;
        v19 = a7[3];
        v20 = a2;
LABEL_17:
        v14(v20, v19);
      }
LABEL_18:
      v21 = (void *)a7[8];
      if (v21)
      {
        sub_100053298(v21);
        a7[8] = 0;
      }
      return;
    }
    return;
  }
  if (*((unsigned __int16 *)a7 + 26) != a3)
  {
    if (sub_10005549C()
      && (sub_100054530("Invalid handle, got 0x%x, expecting 0x%x", a3, *((unsigned __int16 *)a7 + 26)),
          v30 = sub_1000544A0(0x45u),
          os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)))
    {
      sub_1006CE7A4();
      if (!v14)
      {
LABEL_34:
        v31 = (void *)a7[8];
        if (v31)
          sub_100053298(v31);
        return;
      }
    }
    else if (!v14)
    {
      goto LABEL_34;
    }
    a7[2] = 0;
    v14(1, a7[3]);
    goto LABEL_34;
  }
  v22 = *((unsigned __int16 *)a7 + 27);
  v23 = v22 + __n;
  v24 = *((unsigned __int16 *)a7 + 36);
  if ((int)v22 + (int)__n <= v24)
  {
    v25 = a7[8];
    if (!memcmp((const void *)(v25 + v22), __s2, __n))
    {
      *((_WORD *)a7 + 27) = v23;
      if (v23 == v24)
      {
        v32 = sub_10020BCEC(v13, (uint64_t)sub_100229250, 1, (uint64_t)a7);
        if (!(_DWORD)v32)
          return;
        v33 = v32;
        if (!sub_10005549C())
          goto LABEL_58;
        sub_100054530("Failed to execute write request %!", v33);
        v34 = sub_1000544A0(0x45u);
        if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
          goto LABEL_58;
      }
      else
      {
        if (v23 <= v24)
        {
          v37 = *((_WORD *)a7 + 28);
          v42 = 22;
          v43 = a3;
          v44 = v37 + v23;
          v45 = v24 - v23;
          v46 = v25 + v23;
          v38 = sub_10020AED0(v13);
          if ((unsigned __int16)(v24 - v23) + 5 > v38)
            v45 = sub_10020AED0(*a7) - 5;
          v39 = sub_10020BBE4(*a7, (uint64_t)sub_100228178, (int *)&v42, (uint64_t)a7);
          if (!(_DWORD)v39)
            return;
          v33 = v39;
          if (sub_10005549C())
          {
            sub_100054530("Failed to prepare write request %!", v33);
            v40 = sub_1000544A0(0x45u);
            if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
              sub_1006CE7A4();
          }
LABEL_58:
          v41 = (void *)a7[8];
          if (v41)
          {
            sub_100053298(v41);
            a7[8] = 0;
          }
          if (v14)
          {
            a7[2] = 0;
            v14(v33, a7[3]);
          }
          return;
        }
        *(_BYTE *)(v13 + 96) = 13;
        v35 = sub_10020BCEC(v13, (uint64_t)sub_1002291E8, 0, (uint64_t)a7);
        if (!(_DWORD)v35)
          return;
        v33 = v35;
        if (!sub_10005549C())
          goto LABEL_58;
        sub_100054530("Failed to execute write request %!", v33);
        v36 = sub_1000544A0(0x45u);
        if (!os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
          goto LABEL_58;
      }
      sub_1006CE7A4();
      goto LABEL_58;
    }
  }
  *(_BYTE *)(v13 + 96) = 4;
  if (sub_10005549C())
  {
    sub_100054530("Data doesn't match.");
    v26 = sub_1000544A0(0x45u);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  v27 = sub_10020BCEC(*a7, (uint64_t)sub_1002291E8, 0, (uint64_t)a7);
  if (!(_DWORD)v27)
  {
    if (v14)
    {
      a7[2] = 0;
      v19 = a7[3];
      v20 = 0;
      goto LABEL_17;
    }
    goto LABEL_18;
  }
  v28 = v27;
  if (sub_10005549C())
  {
    sub_100054530("Failed to execute write request %!", v28);
    v29 = sub_1000544A0(0x45u);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
}

uint64_t sub_1002285EC(int a1, uint64_t a2, __int16 a3, uint64_t a4, __int16 a5, uint64_t a6)
{
  uint64_t *v11;
  uint64_t v12;
  uint64_t *v13;
  NSObject *v15;
  char v16;
  __int16 v17;
  __int16 v18;
  uint64_t v19;

  v11 = (uint64_t *)sub_100226540(a1);
  v16 = 18;
  v17 = a3;
  v18 = a5;
  v19 = a4;
  v12 = 101;
  if (v11 && a2)
  {
    v13 = v11;
    if (v11[2])
    {
      return 118;
    }
    else
    {
      v12 = sub_10020BA94(*v11, (uint64_t)sub_100227F60, (__int16 *)&v16, (uint64_t)v11);
      if ((_DWORD)v12)
      {
        if (sub_10005549C())
        {
          sub_100054530("Failed to write characteristic descriptor %: %!", v13, v12);
          v15 = sub_1000544A0(0x45u);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
      }
      else
      {
        v13[2] = a2;
        v13[3] = a6;
      }
    }
  }
  return v12;
}

__n128 sub_1002286D4(__n128 *a1)
{
  __n128 result;

  if (!a1)
    sub_100253460();
  if (xmmword_10098F030 != 0)
    sub_100253460();
  if (a1)
  {
    result = *a1;
    off_10098F040 = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD))a1[1].n128_u64[0];
    xmmword_10098F030 = (__int128)result;
  }
  return result;
}

void sub_100228724()
{
  xmmword_10098F030 = 0uLL;
  off_10098F040 = 0;
}

uint64_t sub_100228738(uint64_t result)
{
  dword_10097A8C0 = result;
  return result;
}

void sub_100228744(unsigned __int16 *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  void (*v9)(unsigned __int16 *, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  uint8_t buf[4];
  void *v15;

  if (sub_10005549C())
  {
    v6 = a1 ? *a1 : 0;
    sub_100054530("_GATT_LE_ConnectCompleteCB notification from lmHandle 0x%x with status %!", v6, a3);
    v7 = sub_1000544A0(0x45u);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v15 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  v8 = sub_1002263D4((uint64_t)a1, a2);
  if ((_DWORD)v8)
  {
    v9 = (void (*)(unsigned __int16 *, uint64_t, uint64_t, uint64_t, uint64_t))xmmword_10098F030;
    if ((_QWORD)xmmword_10098F030)
    {
      v10 = v8;
      v11 = sub_10020AF34(a2);
      v12 = 1;
      if (a1)
      {
        if (*((_BYTE *)a1 + 2) == 4)
          v12 = 2;
        else
          v12 = 1;
      }
      v9(a1, v10, v11, v12, a3);
    }
  }
  else if (sub_10005549C())
  {
    sub_100054530("Failed to create LE GATT session ");
    v13 = sub_1000544A0(0x45u);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
}

void sub_1002288C0(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  NSObject *v5;
  uint8_t buf[4];
  void *v7;

  if (sub_10005549C())
  {
    sub_100054530("_GATT_LE_DisconnectedCB on handle %p with reason %!", a1, a2);
    v4 = sub_1000544A0(0x45u);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v7 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if (a1)
  {
    if (*((_QWORD *)&xmmword_10098F030 + 1))
      (*((void (**)(uint64_t, uint64_t))&xmmword_10098F030 + 1))(a1, a2);
  }
  else if (sub_10005549C())
  {
    sub_100054530("_GATT_LE_DisconnectedCB handle is not valid with reason %!", a2);
    v5 = sub_1000544A0(0x45u);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
}

void sub_1002289F0(unsigned __int16 *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  NSObject *v11;
  uint8_t buf[4];
  void *v13;

  if (sub_10005549C())
  {
    v8 = a1 ? *a1 : 0;
    sub_100054530("_GATT_LE_LinkReadyCB notification from lmHandle 0x%x with status %!", v8, a4);
    v9 = sub_1000544A0(0x45u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v13 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if ((_DWORD)a4)
  {
    if (sub_10005549C())
    {
      if (a1)
        v10 = *a1;
      else
        v10 = 0;
      sub_100054530("GATT ready notification from lmHandle 0x%x (%x) with error %!", v10, a1, a4);
      v11 = sub_1000544A0(0x45u);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  else if (off_10098F040)
  {
    off_10098F040(a1, a2, a3, 0);
  }
}

void sub_100228B5C(uint64_t a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  void *v5;

  v1 = (_QWORD *)qword_10098F020;
  if (qword_10098F020)
  {
    while (1)
    {
      v2 = v1[12];
      if (*v1 == a1)
        break;
      v1 = (_QWORD *)v1[12];
      if (!v2)
        return;
    }
    if (v2)
      *(_QWORD *)(v2 + 104) = v1[13];
    v3 = v1[13];
    if (v3)
      v4 = (uint64_t *)(v3 + 96);
    else
      v4 = &qword_10098F020;
    *v4 = v2;
    v5 = (void *)v1[10];
    if (v5)
      sub_100053298(v5);
    v1[10] = 0;
    *((_WORD *)v1 + 44) = 0;
    sub_100053298(v1);
  }
}

BOOL sub_100228BE4(uint64_t a1)
{
  unint64_t v1;
  void (*v3)(void);
  uint64_t v4;
  unint64_t v5;
  unsigned __int8 *v6;
  int v7;
  _BOOL8 v8;
  __int16 v9;
  char v11;
  __int16 v12;

  v1 = *(unsigned __int16 *)(a1 + 88);
  if (!*(_WORD *)(a1 + 88))
    return 0;
  v3 = *(void (**)(void))(a1 + 16);
  v4 = *(_QWORD *)(a1 + 80);
  if (*(_BYTE *)(v4 + 8))
  {
    v5 = 0;
    v6 = (unsigned __int8 *)(v4 + 36);
    while (v1 - 1 != v5)
    {
      v7 = *v6;
      v6 += 28;
      ++v5;
      if (!v7)
      {
        v8 = v5 < v1;
        goto LABEL_9;
      }
    }
    return 0;
  }
  v5 = 0;
  v8 = 1;
LABEL_9:
  v9 = *(_WORD *)(v4 + 28 * v5 + 2);
  v11 = 10;
  v12 = v9;
  if (sub_10020B8BC(*(_QWORD *)a1, (uint64_t)sub_100228CD8, (uint64_t)&v11, a1))
  {
    if (v3)
    {
      *(_QWORD *)(a1 + 16) = 0;
      v3();
    }
  }
  else
  {
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 40) = 0;
    *(_DWORD *)(a1 + 48) = 0;
    *(_WORD *)(a1 + 52) = v9;
    *(_WORD *)(a1 + 54) = v5;
    *(_QWORD *)(a1 + 64) = 0;
    *(_QWORD *)(a1 + 72) = 0;
    *(_QWORD *)(a1 + 56) = 0;
  }
  return v8;
}

void sub_100228CD8(uint64_t a1, uint64_t a2, int8x16_t *a3, int a4, uint64_t a5)
{
  uint64_t *v8;
  uint64_t v9;
  void (*v11)(uint64_t, uint64_t, uint64_t, uint64_t);
  unsigned __int16 *v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  NSObject *v19;
  uint64_t v20;
  void *v21;
  NSObject *v22;
  void *v23;
  NSObject *v24;
  NSObject *v25;
  NSObject *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  __int128 v30;
  NSObject *v31;
  __int128 v32;
  int v33;

  v8 = &qword_10098F020;
  do
  {
    v9 = *v8;
    v8 = (uint64_t *)(*v8 + 96);
  }
  while (v9 != a5 && v9 != 0);
  if (!v9)
    return;
  v11 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a5 + 16);
  if ((_DWORD)a2 == 10)
  {
    if ((sub_100228BE4(a5) & 1) == 0 && v11)
    {
      v12 = (unsigned __int16 *)(a5 + 88);
      v20 = *(unsigned __int16 *)(a5 + 88);
      *(_QWORD *)(a5 + 16) = 0;
      v11(0, *(_QWORD *)(a5 + 80), v20, *(_QWORD *)(a5 + 24));
      v21 = *(void **)(a5 + 80);
      if (!v21)
        goto LABEL_38;
      goto LABEL_37;
    }
    return;
  }
  if ((_DWORD)a2)
  {
    if (sub_10005549C()
      && (sub_100054530("Received error response for included service discovery 0x%x", a2),
          v22 = sub_1000544A0(0x45u),
          os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)))
    {
      sub_1006CE7A4();
      if (!v11)
        return;
    }
    else if (!v11)
    {
      return;
    }
    *(_QWORD *)(a5 + 16) = 0;
    v11(a2, 0, 0, *(_QWORD *)(a5 + 24));
    v23 = *(void **)(a5 + 80);
    if (v23)
      sub_100053298(v23);
    *(_QWORD *)(a5 + 80) = 0;
    v12 = (unsigned __int16 *)(a5 + 88);
    goto LABEL_39;
  }
  v12 = (unsigned __int16 *)(a5 + 88);
  v13 = *(unsigned __int16 *)(a5 + 54);
  if (*(unsigned __int16 *)(a5 + 88) <= v13)
  {
    if (!sub_10005549C())
      goto LABEL_32;
    sub_100054530("Invalid position %d / %d", v13, *v12);
    v24 = sub_1000544A0(0x45u);
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      goto LABEL_32;
    goto LABEL_31;
  }
  v14 = *(unsigned __int16 *)(a5 + 52);
  v15 = *(_QWORD *)(a5 + 80);
  if (*(unsigned __int16 *)(v15 + 28 * *(unsigned __int16 *)(a5 + 54) + 2) != v14)
  {
    if (!sub_10005549C())
      goto LABEL_32;
    sub_100054530("Handles don't match 0x%x 0x%x", v14, *(unsigned __int16 *)(*(_QWORD *)(a5 + 80) + 28 * v13 + 2));
    v25 = sub_1000544A0(0x45u);
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      goto LABEL_32;
    goto LABEL_31;
  }
  v16 = v15 + 28 * *(unsigned __int16 *)(a5 + 54);
  v18 = *(unsigned __int8 *)(v16 + 8);
  v17 = v16 + 8;
  if (!v18)
  {
    if (a4 == 2 || a4 == 16)
    {
      sub_10005F660(a3, a4, 1, (uint64_t)&v32);
      v30 = v32;
      *(_DWORD *)(v17 + 16) = v33;
      *(_OWORD *)v17 = v30;
      goto LABEL_44;
    }
    if (!sub_10005549C()
      || (sub_100054530("Invalid length %d", a4),
          v31 = sub_1000544A0(0x45u),
          !os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)))
    {
LABEL_32:
      if (sub_10005549C()
        && (sub_100054530("Error parsing the read response"),
            v26 = sub_1000544A0(0x45u),
            os_log_type_enabled(v26, OS_LOG_TYPE_ERROR)))
      {
        sub_1006CE7A4();
        if (!v11)
          return;
      }
      else if (!v11)
      {
        return;
      }
      *(_QWORD *)(a5 + 16) = 0;
      v27 = *(_QWORD *)(a5 + 24);
      v28 = 0;
      v29 = 0;
LABEL_36:
      v11(0, v28, v29, v27);
      v21 = *(void **)(a5 + 80);
      if (!v21)
      {
LABEL_38:
        *(_QWORD *)(a5 + 80) = 0;
LABEL_39:
        *v12 = 0;
        return;
      }
LABEL_37:
      sub_100053298(v21);
      goto LABEL_38;
    }
LABEL_31:
    sub_1006CE7A4();
    goto LABEL_32;
  }
  if (sub_10005549C())
  {
    sub_100054530("UUID length is not 0 (%d) !", *(unsigned __int8 *)(*(_QWORD *)(a5 + 80) + 28 * v13 + 8));
    v19 = sub_1000544A0(0x45u);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
LABEL_44:
  if ((sub_100228BE4(a5) & 1) == 0 && v11)
  {
    *(_QWORD *)(a5 + 16) = 0;
    v28 = *(_QWORD *)(a5 + 80);
    v29 = *(unsigned __int16 *)(a5 + 88);
    v27 = *(_QWORD *)(a5 + 24);
    goto LABEL_36;
  }
}

uint64_t sub_100229068(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  uint64_t v8;
  size_t v9;
  uint64_t v10;
  char *v11;
  size_t v12;
  const void **v13;
  uint64_t v14;
  _WORD *v15;
  uint64_t v16;
  const void *v17;
  void *v18;
  char *v19;
  uint64_t v21;

  v8 = a3;
  v9 = 260 * a3;
  __chkstk_darwin(a1, a2);
  v11 = (char *)&v21 - v10;
  bzero((char *)&v21 - v10, v9);
  if (a3)
  {
    v12 = a4 - 2;
    v13 = (const void **)(a2 + 8);
    v14 = v8;
    v15 = v11;
    do
    {
      v16 = *((unsigned __int16 *)v13 - 4);
      *v15 = v16;
      v15[129] = v12;
      v17 = *v13;
      v13 += 2;
      memmove(v15 + 1, v17, v12);
      v15 += 130;
      --v14;
    }
    while (v14);
    if (!a1)
      return v16;
  }
  else
  {
    v16 = 0xFFFFLL;
    if (!a1)
      return v16;
  }
  v18 = *(void **)(a1 + 80);
  v19 = (char *)sub_100052DC0(260 * (*(unsigned __int16 *)(a1 + 88) + v8));
  *(_QWORD *)(a1 + 80) = v19;
  if (!v19)
    return 0xFFFFLL;
  if (v18)
  {
    memmove(v19, v18, 260 * *(unsigned __int16 *)(a1 + 88));
    sub_100053298(v18);
    v19 = *(char **)(a1 + 80);
  }
  memmove(&v19[260 * *(unsigned __int16 *)(a1 + 88)], v11, v9);
  *(_WORD *)(a1 + 88) += a3;
  return v16;
}

void sub_1002291E8(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t *v4;
  _QWORD *v5;
  void (*v7)(_QWORD, _QWORD);
  void *v8;

  v4 = &qword_10098F020;
  do
  {
    v5 = (_QWORD *)*v4;
    v4 = (uint64_t *)(*v4 + 96);
  }
  while (v5 != a3 && v5 != 0);
  if (v5)
  {
    v7 = (void (*)(_QWORD, _QWORD))a3[2];
    a3[2] = 0;
    if (v7)
      v7(*(unsigned __int8 *)(*a3 + 96), a3[3]);
    v8 = (void *)a3[8];
    if (v8)
    {
      sub_100053298(v8);
      a3[8] = 0;
    }
  }
}

void sub_100229250(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t *v4;
  _QWORD *v5;
  void (*v7)(uint64_t, _QWORD);
  void *v8;

  v4 = &qword_10098F020;
  do
  {
    v5 = (_QWORD *)*v4;
    v4 = (uint64_t *)(*v4 + 96);
  }
  while (v5 != a3 && v5 != 0);
  if (v5)
  {
    v7 = (void (*)(uint64_t, _QWORD))a3[2];
    a3[2] = 0;
    if (v7)
      v7(a2, a3[3]);
    v8 = (void *)a3[8];
    if (v8)
      sub_100053298(v8);
  }
}

const char *sub_1002292BC(char a1)
{
  if ((a1 + 1) > 0xBu)
    return "UNKNOWN";
  else
    return off_10091F028[(char)(a1 + 1)];
}

void sub_1002292EC(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  int v3;
  __int16 v4;

  v4 = 0;
  v3 = 0;
  if (sub_100182620(a2, (uint64_t)&v3))
  {
    if (sub_10005549C())
    {
      sub_100054530("Could not get address");
      v2 = sub_1000544A0(0x55u);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  else
  {
    sub_10022936C((uint64_t)&v3);
  }
}

void sub_10022936C(uint64_t a1)
{
  uint64_t i;
  uint64_t *v3;
  int v4;
  int v5;
  uint64_t v7;

  for (i = 0; i != 294; i += 42)
  {
    v3 = &qword_10098F048[i];
    if (LOBYTE(qword_10098F048[i + 2]))
    {
      v4 = *(_DWORD *)((char *)v3 + 17);
      v5 = *(unsigned __int16 *)((char *)v3 + 21);
      if (*(_DWORD *)a1 == v4 && *(unsigned __int16 *)(a1 + 4) == v5)
      {
        v7 = LODWORD(qword_10098F048[i + 3]);
        if ((_DWORD)v7)
          sub_100049F6C(v7);
        *(_OWORD *)&qword_10098F048[i + 40] = 0u;
        *(_OWORD *)&qword_10098F048[i + 42] = 0u;
        *(_OWORD *)&qword_10098F048[i + 36] = 0u;
        *(_OWORD *)&qword_10098F048[i + 38] = 0u;
        *(_OWORD *)&qword_10098F048[i + 32] = 0u;
        *(_OWORD *)&qword_10098F048[i + 34] = 0u;
        *(_OWORD *)&qword_10098F048[i + 28] = 0u;
        *(_OWORD *)&qword_10098F048[i + 30] = 0u;
        *(_OWORD *)&qword_10098F048[i + 24] = 0u;
        *(_OWORD *)&qword_10098F048[i + 26] = 0u;
        *(_OWORD *)&qword_10098F048[i + 20] = 0u;
        *(_OWORD *)&qword_10098F048[i + 22] = 0u;
        *(_OWORD *)&qword_10098F048[i + 16] = 0u;
        *(_OWORD *)&qword_10098F048[i + 18] = 0u;
        *(_OWORD *)&qword_10098F048[i + 12] = 0u;
        *(_OWORD *)&qword_10098F048[i + 14] = 0u;
        *(_OWORD *)&qword_10098F048[i + 8] = 0u;
        *(_OWORD *)&qword_10098F048[i + 10] = 0u;
        *(_OWORD *)&qword_10098F048[i + 4] = 0u;
        *(_OWORD *)&qword_10098F048[i + 6] = 0u;
        *(_OWORD *)&qword_10098F048[i + 2] = 0u;
      }
    }
  }
}

uint64_t sub_100229414(uint64_t a1)
{
  qword_10098F048 = a1;
  return 0;
}

uint64_t sub_100229424(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t v4;
  int v5;

  v3 = sub_100229494(a1);
  v4 = 0;
  if (v3 && byte_10098F988)
  {
    if (*((unsigned __int8 *)v3 + 7) == 240)
    {
      v5 = *(_DWORD *)((char *)v3 + 1);
      *(_WORD *)(a2 + 4) = *(_WORD *)((char *)v3 + 5);
      *(_DWORD *)a2 = v5;
      *(_DWORD *)(a2 + 24) = 5;
      *(_OWORD *)(a2 + 6) = *(_OWORD *)((char *)v3 + 12);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return v4;
}

uint64_t *sub_100229494(uint64_t a1)
{
  uint64_t v1;
  uint64_t *v2;
  int v3;
  int v4;

  v1 = 0;
  while (1)
  {
    v2 = &qword_10098F048[v1];
    if (LOBYTE(qword_10098F048[v1 + 2]))
    {
      v3 = *(_DWORD *)((char *)v2 + 17);
      v4 = *(unsigned __int16 *)((char *)v2 + 21);
      if (*(_DWORD *)a1 == v3 && *(unsigned __int16 *)(a1 + 4) == v4)
        break;
    }
    v1 += 42;
    if (v1 == 294)
      return 0;
  }
  return &qword_10098F048[v1 + 2];
}

BOOL sub_1002294E8(uint64_t a1)
{
  unint64_t v3;
  uint64_t v4;
  BOOL v5;
  _BOOL4 v6;
  uint64_t *v7;
  unsigned int v8;
  _BOOL8 v9;
  unsigned __int8 v10;
  const char *v11;
  const char *v12;
  const char *v13;
  NSObject *v14;
  uint8_t buf[4];
  void *v17;

  if (!byte_10098F988)
  {
LABEL_14:
    v6 = 0;
LABEL_20:
    v9 = 0;
    v10 = 0;
    goto LABEL_21;
  }
  if (*(_DWORD *)a1 != *(_DWORD *)qword_10098F990
    || *(unsigned __int16 *)(a1 + 4) != *(unsigned __int16 *)(qword_10098F990 + 4))
  {
    v3 = 0;
    v4 = qword_10098F990 + 44;
    while (byte_10098F988 - 1 != v3)
    {
      v5 = *(_DWORD *)a1 == *(_DWORD *)v4 && *(unsigned __int16 *)(a1 + 4) == *(unsigned __int16 *)(v4 + 4);
      v4 += 44;
      ++v3;
      if (v5)
      {
        v6 = v3 < byte_10098F988;
        goto LABEL_16;
      }
    }
    goto LABEL_14;
  }
  v6 = 1;
LABEL_16:
  v7 = sub_1002296B0(a1);
  if (!v7)
    goto LABEL_20;
  v8 = (*((_BYTE *)v7 + 7) - 1);
  v9 = v8 < 0xEF;
  if (v8 >= 0xEF)
    v10 = 0;
  else
    v10 = *((_BYTE *)v7 + 7);
LABEL_21:
  if (sub_10005549C())
  {
    if (v9)
      v11 = "";
    else
      v11 = "Not";
    if (v6)
      v12 = "Yes";
    else
      v12 = "No";
    v13 = sub_100229764(v10);
    sub_100054530("%s delaying security enforcement for Address=%: keys available ? %s pairing state :(%s)%d", v11, a1, v12, v13, v10);
    v14 = sub_1000544A0(0x55u);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v17 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  return v9;
}

uint64_t *sub_1002296B0(uint64_t a1)
{
  uint64_t *result;
  uint64_t i;
  uint64_t *v4;
  NSObject *v5;
  int v6;
  __int16 v7;

  result = sub_100229494(a1);
  if (!result)
  {
    for (i = 0; i != 294; i += 42)
    {
      v4 = &qword_10098F048[i];
      if (!LOBYTE(qword_10098F048[i + 2]))
      {
        v6 = *(_DWORD *)a1;
        v7 = *(_WORD *)(a1 + 4);
        *((_BYTE *)v4 + 16) = 1;
        result = v4 + 2;
        *(_WORD *)((char *)result + 5) = v7;
        *(_DWORD *)((char *)result + 1) = v6;
        return result;
      }
    }
    if (sub_10005549C())
    {
      sub_100054530("No magic pairing slot available to allocate for address %:", a1);
      v5 = sub_1000544A0(0x55u);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 0;
  }
  return result;
}

const char *sub_100229764(int a1)
{
  const char *result;
  const char *v4;

  result = "STATE_IDLE";
  switch(a1)
  {
    case 0:
      return result;
    case 1:
      result = "STATE_CHANNEL_FOUND";
      break;
    case 2:
      result = "STATE_SENT_HINT";
      break;
    case 3:
      result = "STATE_SENT_AES_SIV";
      break;
    default:
      v4 = "STATE_ERROR";
      if (a1 != 255)
        v4 = "UNKNOWN";
      if (a1 == 240)
        result = "STATE_SUCCESS";
      else
        result = v4;
      break;
  }
  return result;
}

void sub_1002297E4(uint64_t a1)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;

  v2 = sub_10019AEA4(a1);
  sub_1001F37D8(v2);
  v3 = sub_1002296B0(a1);
  if (v3)
  {
    v4 = (uint64_t)v3;
    if (!*((_BYTE *)v3 + 7))
    {
      sub_10022983C(a1, 1);
      sub_1002298B8(v4);
    }
  }
}

void sub_10022983C(uint64_t a1, char a2)
{
  uint64_t *v4;
  NSObject *v5;

  v4 = sub_100229494(a1);
  if (v4)
  {
    *((_BYTE *)v4 + 7) = a2;
  }
  else if (sub_10005549C())
  {
    sub_100054530(" %: does not have a magic pairing device entry", a1);
    v5 = sub_1000544A0(0x55u);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
}

void sub_1002298B8(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  _DWORD *v5;
  uint64_t v6;
  NSObject *v8;
  NSObject *v9;
  __int128 *v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  NSObject *v14;
  uint64_t v15;
  _BYTE v16[21];
  int v17;
  __int128 v18;
  int v19;
  int v20;
  __int16 v21;

  if (*(unsigned __int8 *)(a1 + 7) - 2 > 0xEE)
  {
    v3 = byte_10098F988;
    if (byte_10098F988)
    {
      v4 = 0;
      *(_BYTE *)(a1 + 269) = 0;
      v5 = (_DWORD *)(a1 + 1);
      v6 = qword_10098F990;
      while (*v5 != *(_DWORD *)v6 || *(unsigned __int16 *)(a1 + 5) != *(unsigned __int16 *)(v6 + 4))
      {
        ++v4;
        v6 += 44;
        if (v3 == v4)
        {
          if (sub_10005549C())
          {
            sub_100054530("No hint for device %:. Aborting", a1 + 1);
            v8 = sub_1000544A0(0x55u);
            if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
              sub_1006CE7A4();
          }
          goto LABEL_19;
        }
      }
      *(_BYTE *)(a1 + 269) = v4;
      v10 = (__int128 *)(a1 + 28);
      arc4random_buf((void *)(a1 + 28), 0x10uLL);
      arc4random_buf((void *)(a1 + 270), 0x10uLL);
      *(_QWORD *)v16 = 6;
      *(_QWORD *)&v16[8] = a1 + 1;
      v11 = sub_10004A9EC((uint64_t)sub_10022AC38, (const void **)v16, 25, (int *)(a1 + 8));
      if ((_DWORD)v11)
      {
        v12 = v11;
        if (sub_10005549C())
        {
          sub_100054530("Could not register timeout for magic pairing operation ret=%!", v12);
          v13 = sub_1000544A0(0x55u);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
      }
      if (*(unsigned __int8 *)(a1 + 7) >= 2u)
      {
        if (sub_10005549C())
        {
          sub_100054530("Invalid state %d trying to send address: %:", *(unsigned __int8 *)(a1 + 7), a1 + 1);
          v14 = sub_1000544A0(0x55u);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
      }
      v21 = 0;
      *(_DWORD *)v16 = 268439555;
      v16[4] = 0;
      v15 = qword_10098F990 + 44 * *(unsigned __int8 *)(a1 + 269);
      *(_OWORD *)&v16[5] = *(_OWORD *)(v15 + 6);
      v17 = 1048608;
      v18 = *v10;
      v19 = 262400;
      v20 = *(_DWORD *)(v15 + 40);
      if (!sub_10022A8C4(a1 + 1, 1u, v16, 0x33uLL))
        sub_10022983C(a1 + 1, 2);
    }
    else
    {
      if (sub_10005549C())
      {
        sub_100054530("No MagicPairing table found");
        v9 = sub_1000544A0(0x55u);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          sub_1006CEE54();
      }
      v5 = (_DWORD *)(a1 + 1);
LABEL_19:
      sub_10022983C((uint64_t)v5, 255);
      if (*(_BYTE *)(a1 + 334))
        sub_10022A7C4((uint64_t)v5, 8);
      *(_BYTE *)(a1 + 334) = 0;
    }
  }
  else if (sub_10005549C())
  {
    sub_100054530("MagicPairing is currently in progress (%x) with device %:", *(unsigned __int8 *)(a1 + 7), a1 + 1);
    v2 = sub_1000544A0(0x55u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1006CEE54();
  }
}

uint64_t sub_100229BC8(uint64_t a1, char a2)
{
  qword_10098F990 = a1;
  byte_10098F988 = a2;
  return 0;
}

uint64_t sub_100229BE0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD v6[2];

  v6[0] = 0;
  v6[1] = 0;
  v4 = ccaes_ecb_encrypt_mode();
  if (ccecb_one_shot(v4, 16, a1, 1, v6, a2))
    return 154;
  else
    return 0;
}

uint64_t sub_100229C64()
{
  uint64_t v0;
  uint64_t v1;
  NSObject *v2;
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;

  v0 = sub_1001DC46C(48, 1, 8, 7u, &qword_10098F050, (uint64_t)sub_100229E44);
  if ((_DWORD)v0)
  {
    v1 = v0;
    if (sub_10005549C())
    {
      sub_100054530("OI_ChanMan_AllocateFixedChannel returned %!", v1);
      v2 = sub_1000544A0(0x55u);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
LABEL_16:
        sub_1006CE7A4();
    }
  }
  else
  {
    **(_WORD **)(qword_10098F050 + 120) = 100;
    v3 = sub_10024BE08(nullsub_105);
    if ((_DWORD)v3)
    {
      v1 = v3;
      if (sub_10005549C())
      {
        sub_100054530("OI_SECMGR_RegisterAuditCb returned %!", v1);
        v4 = sub_1000544A0(0x55u);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
          goto LABEL_16;
      }
    }
    else
    {
      v5 = sub_1001E2984((uint64_t)sub_1002297E4, 48);
      if ((_DWORD)v5)
      {
        v1 = v5;
        if (sub_10005549C())
        {
          sub_100054530("OI_ConnectMan_Register_FixedChannelInfo_callback returned %!", v1);
          v6 = sub_1000544A0(0x55u);
          if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
            goto LABEL_16;
        }
      }
      else
      {
        v1 = sub_100182288((uint64_t)&unk_10097A8C8);
        if (!(_DWORD)v1)
        {
          bzero(qword_10098F048, 0x940uLL);
          byte_10098F988 = 0;
          qword_10098F990 = 0;
          return v1;
        }
        if (sub_10005549C())
        {
          sub_100054530("OI_DEVMGR_EXTRA_Register_Connect_CB returned %!", v1);
          v7 = sub_1000544A0(0x55u);
          if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
            goto LABEL_16;
        }
      }
    }
  }
  return v1;
}

__n128 sub_100229E44(uint64_t a1, unsigned __int8 *a2, unsigned int a3)
{
  unsigned __int16 v3;
  __n128 result;
  int v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t *v11;
  char *v12;
  unsigned __int8 *v13;
  int v14;
  uint64_t v15;
  unsigned __int16 v16;
  int v17;
  int v18;
  void *v19;
  int v20;
  int v21;
  int v22;
  unsigned __int8 *v23;
  int v24;
  int v25;
  int v26;
  NSObject *v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  NSObject *v31;
  const char *v32;
  NSObject *v33;
  void *v34;
  NSObject *v35;
  uint64_t v36;
  NSObject *v37;
  __int128 *v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;
  uint64_t v42;
  NSObject *v43;
  NSObject *v44;
  uint64_t v45;
  size_t v46;
  _OWORD *v47;
  int v48;
  int v49;
  NSObject *v50;
  NSObject *v51;
  NSObject *v53;
  _BOOL4 v55;
  uint64_t v56;
  _OWORD *v57;
  __int128 v58;
  __int128 v59;
  NSObject *v60;
  int v61;
  int v62;
  __int16 v63;
  uint8_t buf[112];
  __int128 v65;
  __int128 v66;
  _BYTE v67[28];

  v3 = a3 - 2;
  if (a3 < 2)
    return result;
  v63 = 0;
  v62 = 0;
  if (sub_100182620(a1, (uint64_t)&v62))
    return result;
  v7 = *a2;
  switch(*a2)
  {
    case 1u:
      v8 = sub_10019AEA4((uint64_t)&v62);
      sub_1001F37D8(v8);
      v9 = sub_100229494((uint64_t)&v62);
      if (!v9)
        sub_100253460();
      *(_WORD *)buf = 384;
      buf[2] = 104;
      memset(&buf[3], 0, 105);
      sub_10022A8C4((uint64_t)v9 + 1, 2u, (char *)buf, 0x6CuLL);
      return result;
    case 2u:
      v12 = (char *)sub_100229494((uint64_t)&v62);
      if (!v12)
      {
        if (sub_10005549C())
        {
          sub_100054530(" %: does not have a magic pairing device entry", &v62);
          v35 = sub_1000544A0(0x55u);
          if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
        v36 = 8;
        goto LABEL_71;
      }
      if (!v3)
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/magicPairing/B"
                               "T_MagicPairing.c");
      v13 = a2 + 2;
      v14 = a2[2];
      if (v14 != 2)
      {
        if (sub_10005549C())
        {
          sub_100054530("Invalid number of paramerter = %d", v14);
          v37 = sub_1000544A0(0x55u);
          if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
        v36 = 3;
        goto LABEL_71;
      }
      v15 = (uint64_t)v12;
      v16 = a3 - 3;
      v17 = v3 - 53;
      v18 = v3 - 3;
      v19 = v12 + 168;
      v20 = 2;
      v21 = 1;
      do
      {
        if (v16 <= (unsigned __int16)v21)
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/magicPairing"
                                 "/BT_MagicPairing.c");
        if (v16 <= (unsigned __int16)(v21 + 2))
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/magicPairing"
                                 "/BT_MagicPairing.c");
        v22 = *(unsigned __int16 *)&v13[(unsigned __int16)v21];
        v23 = &v13[(unsigned __int16)(v21 + 2)];
        v24 = *v23;
        v25 = v24 | (v23[1] << 8);
        v26 = v21 + 4;
        if (v22 == 128)
        {
          if (v25 != 54)
          {
            if (sub_10005549C())
            {
              sub_100054530("ERROR AES_SIV key length mismatch, please file a sysdiagnose from all cloud paired devices");
              v44 = sub_1000544A0(0x55u);
              if (os_log_type_enabled(v44, OS_LOG_TYPE_FAULT))
                sub_1006D3AE4(v44);
            }
            goto LABEL_70;
          }
          if (v17 <= (unsigned __int16)v26)
            sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/magicPairi"
                                   "ng/BT_MagicPairing.c");
          v12 = (char *)memmove(v19, &v13[(unsigned __int16)v26], 0x36uLL);
          v21 += 58;
          *(_BYTE *)(v15 + 268) = v24;
        }
        else if (v22 == 256)
        {
          if (v25 != 4)
            sub_100253460();
          if (v18 <= (unsigned __int16)v26)
            sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/magicPairi"
                                   "ng/BT_MagicPairing.c");
          *(_DWORD *)(v15 + 164) = *(_DWORD *)&v13[(unsigned __int16)(v21 + 4)];
          v21 += 8;
        }
        else
        {
          if (sub_10005549C())
          {
            sub_100054530("Invalid opcode %x", v61);
            v27 = sub_1000544A0(0x55u);
            if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
            {
              v28 = sub_100054494();
              *(_DWORD *)buf = 136446466;
              *(_QWORD *)&buf[4] = v28;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = 0xFFFF;
              _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "%{public}s (status=%{bluetooth:OI_STATUS}u)", buf, 0x12u);
            }
          }
          sub_10022A7C4((uint64_t)&v62, 3);
          v21 = v26;
        }
        --v20;
      }
      while ((_BYTE)v20);
      v38 = (__int128 *)(qword_10098F990 + 44 * *(unsigned __int8 *)(v15 + 269));
      v40 = *v38;
      v39 = v38[1];
      *(_OWORD *)&v67[12] = *(__int128 *)((char *)v38 + 28);
      v66 = v40;
      *(_OWORD *)v67 = v39;
      if (*(_DWORD *)&v67[24] < *(_DWORD *)(v15 + 164))
      {
        while (1)
        {
          v65 = 0uLL;
          *(_QWORD *)buf = 0;
          *(_QWORD *)&buf[8] = 0;
          v41 = ccaes_ecb_encrypt_mode(v12);
          v12 = (char *)ccecb_one_shot(v41, 16, &v67[6], 1, buf, &v65);
          if ((_DWORD)v12)
            break;
          *(_OWORD *)&v67[6] = v65;
          if (++*(_DWORD *)&v67[24] >= *(_DWORD *)(v15 + 164))
            goto LABEL_56;
        }
        if (sub_10005549C())
        {
          sub_100054530("Error generating RatchetAccKey: %!", 154);
          v51 = sub_1000544A0(0x55u);
          if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
LABEL_69:
            sub_1006CE7A4();
        }
        goto LABEL_70;
      }
LABEL_56:
      v42 = ccaes_ecb_encrypt_mode(v12);
      memset(&buf[32], 0, 68);
      qmemcpy(buf, "bt_aessivauthentbt_aessivencrypt", 32);
      if (ccecb_one_shot(v42, 16, &v67[6], 2, buf, v15 + 302))
      {
        if (sub_10005549C())
        {
          sub_100054530("Error generating AES_SIV");
          v43 = sub_1000544A0(0x55u);
          if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
            goto LABEL_69;
        }
LABEL_70:
        v36 = 1;
LABEL_71:
        sub_10022A7C4((uint64_t)&v62, v36);
        return result;
      }
      v45 = ccaes_siv_decrypt_mode();
      v46 = (unsigned __int16)ccsiv_plaintext_size(v45, *(unsigned __int8 *)(v15 + 268));
      v47 = sub_100052DC0(v46);
      bzero(v47, v46);
      v48 = ccsiv_one_shot(v45, 32, v15 + 302, 0, 0, 0, 0, 54, v19, v47);
      if (v48)
      {
        v49 = v48;
        if (sub_10005549C())
        {
          sub_100054530("ccsiv_one_shot returned %d", v49);
          v50 = sub_1000544A0(0x55u);
          if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
        goto LABEL_77;
      }
      *(_OWORD *)(v15 + 286) = *v47;
      if (*((_QWORD *)v47 + 2) != *(_QWORD *)(v15 + 28) || *((_QWORD *)v47 + 3) != *(_QWORD *)(v15 + 36))
      {
LABEL_77:
        sub_100053298(v47);
LABEL_78:
        if (sub_10005549C())
        {
          sub_100054530("Remote keys verification failed, sending error");
          v53 = sub_1000544A0(0x55u);
          if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
        v36 = 7;
        goto LABEL_71;
      }
      v55 = *((_DWORD *)v47 + 8) != *(_DWORD *)(v15 + 1)
         || *((unsigned __int16 *)v47 + 18) != *(unsigned __int16 *)(v15 + 5);
      sub_100053298(v47);
      if (v55)
        goto LABEL_78;
      if (!sub_10022ACBC(v15))
      {
        if (sub_10005549C())
        {
          sub_100054530("Error generating AES_SIV");
          v60 = sub_1000544A0(0x55u);
          if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
            goto LABEL_69;
        }
        goto LABEL_70;
      }
      v57 = (_OWORD *)(qword_10098F990 + 44 * *(unsigned __int8 *)(v15 + 269));
      v58 = *(_OWORD *)&v67[12];
      v59 = *(_OWORD *)v67;
      *v57 = v66;
      v57[1] = v59;
      *(_OWORD *)((char *)v57 + 28) = v58;
      sub_10022AE50(v15, v56);
      return result;
    case 3u:
      v29 = 0;
      goto LABEL_44;
    case 4u:
      return result;
    default:
      if (v7 == 255)
      {
        if (a3 < 3)
          v30 = 1;
        else
          v30 = a2[2];
        if (sub_10005549C())
        {
          v32 = sub_1002292BC(v30);
          sub_100054530("Received status %s(%d) from device %:", v32, v30, &v62);
          v33 = sub_1000544A0(0x55u);
          if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
          {
            v34 = sub_100054494();
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = v34;
            _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
          }
        }
        v29 = v30;
        goto LABEL_44;
      }
      if (v7 != 240)
      {
        if (sub_10005549C())
        {
          sub_100054530("Received unknown opcode %x", *a2);
          v31 = sub_1000544A0(0x55u);
          if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
        v29 = 3;
LABEL_44:
        sub_10022AA20((uint64_t)&v62, v29);
        return result;
      }
      v10 = sub_10019AEA4((uint64_t)&v62);
      sub_1001F37D8(v10);
      v11 = sub_1002296B0((uint64_t)&v62);
      if (v11)
      {
        *((_BYTE *)v11 + 334) = 1;
        sub_1002298B8((uint64_t)v11);
      }
      return result;
  }
}

uint64_t sub_10022A6A4(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8;

  if (a4 < 0x10)
    return 101;
  v8 = ccaes_ecb_decrypt_mode();
  if (ccecb_one_shot(v8, 16, a1, 1, a2, a3))
    return 154;
  else
    return 0;
}

uint64_t sub_10022A708(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8;

  if (a4 < 0x10)
    return 101;
  v8 = ccaes_ecb_encrypt_mode();
  if (ccecb_one_shot(v8, 16, a1, 1, a2, a3))
    return 154;
  else
    return 0;
}

uint64_t sub_10022A76C()
{
  uint64_t v0;

  qword_10098F048[0] = 0;
  sub_1001E29E4((uint64_t)sub_1002297E4);
  if (qword_10098F050)
    sub_1001DC658(qword_10098F050);
  v0 = &dword_100000010 + 1;
  do
  {
    sub_10022936C((uint64_t)qword_10098F048 + v0);
    v0 += 336;
  }
  while (v0 != 2369);
  return 0;
}

void sub_10022A7C4(uint64_t a1, uint64_t a2)
{
  const char *v4;
  NSObject *v5;
  char v6;
  uint8_t buf[4];
  void *v8;

  v6 = a2;
  if (sub_10005549C())
  {
    v4 = sub_1002292BC(a2);
    sub_100054530("Sending status %s(%d) to device %:", v4, a2, a1);
    v5 = sub_1000544A0(0x55u);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v8 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  sub_10022A8C4(a1, 0xFFu, &v6, 1uLL);
  sub_10022AA20(a1, a2);
}

uint64_t sub_10022A8C4(uint64_t a1, unsigned int a2, char *a3, size_t a4)
{
  int v7;
  uint64_t result;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  _OWORD v14[7];
  char v15[2];
  __int128 *v16;

  v16 = 0;
  v15[0] = a2;
  v15[1] = 1;
  v7 = sub_100182588(a1, (uint64_t *)&v16);
  result = 101;
  if (v7 || !v16)
    return result;
  memset(&v14[1], 0, 96);
  if (a3)
    v9 = 2;
  else
    v9 = 1;
  v14[0] = 0uLL;
  v10 = sub_1000532A8((uint64_t)v14, v9);
  if ((_DWORD)v10)
  {
    v11 = v10;
LABEL_10:
    if (sub_10005549C())
    {
      sub_100054530("Failed to send PDU %u: %!", a2, v11);
      v13 = sub_1000544A0(0x55u);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return v11;
  }
  v12 = sub_10005336C((unsigned __int8 *)v14, v15, 2uLL, 0);
  if ((_DWORD)v12)
  {
    v11 = v12;
    sub_100253FD8((uint64_t)v14);
    goto LABEL_10;
  }
  if (!a3 || (v11 = sub_10005336C((unsigned __int8 *)v14, a3, a4, 2u), !(_DWORD)v11))
    v11 = sub_1001DBC18(0, 0x30u, v16, (uint64_t)v14, 1);
  sub_100253FD8((uint64_t)v14);
  result = 0;
  if ((_DWORD)v11 && (_DWORD)v11 != 412)
    goto LABEL_10;
  return result;
}

void sub_10022AA20(uint64_t a1, uint64_t a2)
{
  uint64_t *v4;
  uint64_t *v5;
  const char *v6;
  int v7;
  const char *v8;
  NSObject *v9;
  uint64_t v10;
  char v11;
  void (*v12)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, char *, _QWORD);
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t i;
  uint64_t v20;
  _QWORD v21[2];
  _QWORD v22[2];
  uint8_t buf[24];

  v4 = sub_100229494(a1);
  if (v4)
  {
    v5 = v4;
    if (sub_10005549C())
    {
      v6 = sub_1002292BC(a2);
      v7 = *((unsigned __int8 *)v5 + 7);
      v8 = sub_100229764(v7);
      sub_100054530("MP Complete Pairing with status:%s(%d) state:(%s)%d", v6, a2, v8, v7);
      v9 = sub_1000544A0(0x55u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = sub_100054494();
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
    v10 = *((unsigned int *)v5 + 2);
    if ((_DWORD)v10)
    {
      sub_100049F6C(v10);
      *((_DWORD *)v5 + 2) = 0;
    }
    if ((_DWORD)a2)
      v11 = -1;
    else
      v11 = -16;
    *((_BYTE *)v5 + 7) = v11;
    if ((_DWORD)a2)
    {
      if (!qword_10098F048[0])
        goto LABEL_20;
      v12 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, char *, _QWORD))qword_10098F048[0];
      if (!*(_QWORD *)qword_10098F048[0])
        goto LABEL_20;
      v13 = a1;
      v14 = a2;
      v15 = 0;
      v16 = 0;
      v17 = 0;
      v18 = 0;
    }
    else
    {
      *(_OWORD *)buf = 0uLL;
      v22[0] = 0;
      v22[1] = 0;
      v21[0] = 0;
      v21[1] = 0;
      sub_100004F50((char *)v5 + 270, 0x10uLL, (char *)v5 + 286, 0x10u, buf, 0x10u);
      sub_100004F50((char *)v5 + 286, 0x10uLL, v21, 0x10u, v22, 0x10u);
      for (i = 0; i != 16; ++i)
        *((_BYTE *)v5 + i + 12) = *((_BYTE *)v22 + i) ^ buf[i];
      if (!qword_10098F048[0])
        goto LABEL_20;
      v12 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, char *, _QWORD))qword_10098F048[0];
      if (!*(_QWORD *)qword_10098F048[0])
        goto LABEL_20;
      v20 = qword_10098F990 + 44 * *((unsigned __int8 *)v5 + 269);
      v15 = v20 + 6;
      v16 = v20 + 22;
      v17 = *(unsigned int *)(v20 + 40);
      v18 = (char *)v5 + 12;
      v13 = a1;
      v14 = 0;
    }
    v12(v13, v14, v15, v16, v17, v18, 0);
LABEL_20:
    sub_10022936C(a1);
  }
}

void sub_10022AC38(uint64_t a1)
{
  NSObject *v2;
  int *v3;
  __int16 v4;
  int v5;
  __int16 v6;

  if (sub_10005549C())
  {
    sub_100054530("BT MagicPairing timeout.");
    v2 = sub_1000544A0(0x55u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  v3 = *(int **)(a1 + 8);
  v4 = *((_WORD *)v3 + 2);
  v5 = *v3;
  v6 = v4;
  sub_10022A7C4((uint64_t)&v5, 6);
}

BOOL sub_10022ACBC(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  __int128 v4;
  size_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  int v9;
  NSObject *v10;
  size_t v11;
  _OWORD v13[6];
  int v14;

  v2 = ccaes_siv_encrypt_mode();
  v3 = qword_10098F990 + 44 * *(unsigned __int8 *)(a1 + 269);
  v4 = *(_OWORD *)(a1 + 270);
  v13[0] = *(_OWORD *)(a1 + 28);
  v13[1] = v4;
  memset(&v13[4], 0, 32);
  v14 = 0;
  v13[2] = *(_OWORD *)(a1 + 286);
  v13[3] = *(_OWORD *)(v3 + 6);
  v5 = ccsiv_ciphertext_size(v2, 64);
  __chkstk_darwin(v5, v6);
  v8 = (char *)v13 - v7;
  bzero((char *)v13 - v7, v5);
  v9 = ccsiv_one_shot(v2, 32, a1 + 302, 0, 0, 0, 0, 64, v13, v8);
  if (v9)
  {
    if (sub_10005549C())
    {
      sub_100054530("ccsiv_one_shot returned %d", v9);
      v10 = sub_1000544A0(0x55u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  else
  {
    *(_BYTE *)(a1 + 144) = v5;
    if (v5 >= 0x64)
      v11 = 100;
    else
      v11 = v5;
    memmove((void *)(a1 + 44), v8, v11);
  }
  return v9 == 0;
}

void sub_10022AE50(uint64_t a1, uint64_t a2)
{
  size_t v3;
  uint64_t v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;

  v3 = *(unsigned __int8 *)(a1 + 144);
  __chkstk_darwin(a1, a2);
  v5 = (char *)&v7 - v4;
  bzero((char *)&v7 - v4, v3 + 5);
  *(_WORD *)v5 = -32767;
  v5[2] = 0;
  *(_WORD *)(v5 + 3) = v3;
  memmove(v5 + 5, (const void *)(a1 + 44), v3);
  v6 = a1 + 1;
  if (sub_10022A8C4(v6, 3u, v5, (v3 + 5)))
    sub_10022AA20(v6, 1);
}

uint64_t sub_10022AF50()
{
  uint64_t v0;
  NSObject *v1;

  v0 = sub_10020E0FC();
  if ((_DWORD)v0)
  {
    if (sub_10005549C())
    {
      sub_100054530("Failed to create init ATT database with result %!", v0);
      v1 = sub_1000544A0(0x45u);
      if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  return v0;
}

uint64_t sub_10022AFC8(uint64_t a1, int a2, unsigned __int8 *a3, unsigned int a4)
{
  int v8;
  __int128 *v10;
  __int128 v12;

  if (!a1)
    sub_100253460();
  v8 = *a3;
  if (v8 != 16 && v8 != 2)
    return 146;
  if (a2)
    v10 = &xmmword_10073B24C;
  else
    v10 = &xmmword_10073B260;
  *(_OWORD *)(a1 + 4) = *v10;
  *(_DWORD *)(a1 + 20) = *((_DWORD *)v10 + 4);
  *(_QWORD *)(a1 + 32) = sub_10022B080;
  *(_QWORD *)(a1 + 40) = 0;
  *(_BYTE *)(a1 + 26) = 1;
  v12 = *(_OWORD *)a3;
  *(_DWORD *)(a1 + 64) = *((_DWORD *)a3 + 4);
  *(_OWORD *)(a1 + 48) = v12;
  return sub_10020E300(0, a1, a4);
}

uint64_t sub_10022B080(uint64_t a1, unsigned int a2, void *a3, int a4, _WORD *a5)
{
  unsigned int v6;
  BOOL v7;
  int v8;
  _QWORD v12[2];

  v6 = *(unsigned __int8 *)(a1 + 48);
  v7 = v6 >= a2;
  v8 = v6 - a2;
  if (!v7)
    return 7;
  v12[0] = 0;
  v12[1] = 0;
  if (v8 >= a4)
    LOWORD(v8) = a4;
  *a5 = v8;
  sub_100072C50(v12, (unsigned __int8 *)(a1 + 48), 1);
  memmove(a3, (char *)v12 + a2, (unsigned __int16)*a5);
  return 0;
}

void sub_10022B12C(unsigned __int16 *a1)
{
  if (a1)
    sub_10020E604(*a1, 0);
  else
    sub_100253460();
}

uint64_t sub_10022B140(uint64_t a1, unsigned int a2, uint64_t a3)
{
  int v3;
  int v5;

  v3 = *(unsigned __int8 *)(a3 + 48);
  if (v3 != 16 && v3 != 2)
    return 146;
  *(_DWORD *)(a1 + 20) = 0;
  *(_OWORD *)(a1 + 4) = xmmword_10073B274;
  *(_QWORD *)(a1 + 32) = sub_10022B1BC;
  *(_QWORD *)(a1 + 40) = 0;
  *(_BYTE *)(a1 + 26) = 1;
  *(_WORD *)(a1 + 48) = *(_WORD *)a3;
  *(_WORD *)(a1 + 50) = *(_WORD *)(a3 + 24);
  v5 = *(_DWORD *)(a3 + 64);
  *(_OWORD *)(a1 + 52) = *(_OWORD *)(a3 + 48);
  *(_DWORD *)(a1 + 68) = v5;
  return sub_10020E300(a2, a1, 0);
}

uint64_t sub_10022B1BC(uint64_t a1, unsigned int a2, void *__dst, int a4, unsigned __int16 *a5)
{
  int v6;
  unsigned int v7;
  int v8;
  unsigned __int16 v13;
  int v14;
  __int16 v15;

  v6 = *(unsigned __int8 *)(a1 + 52);
  if (v6 == 2)
    v7 = 6;
  else
    v7 = 4;
  v8 = v7 - a2;
  if (v7 < a2)
    return 7;
  v15 = 0;
  v14 = *(_DWORD *)(a1 + 48);
  if (v6 == 2)
    sub_100072C50(&v15, (unsigned __int8 *)(a1 + 52), 1);
  if (v8 >= a4)
    v13 = a4;
  else
    v13 = v8;
  *a5 = v13;
  memmove(__dst, (char *)&v14 + a2, v13);
  return 0;
}

uint64_t sub_10022B268(unsigned int a1, unsigned __int16 *a2, char a3, unsigned int a4, uint64_t a5, unsigned __int8 *a6, uint64_t a7, uint64_t a8)
{
  int v8;
  NSObject *v15;
  uint64_t result;
  NSObject *v17;
  __int128 v18;
  __int128 v19;

  v8 = *a6;
  if (v8 != 16 && v8 != 2)
    return 146;
  if ((a3 & 2) == 0 || a7)
  {
    if ((a3 & 0x4C) == 0 || a8)
    {
      *(_OWORD *)(a2 + 2) = xmmword_10073B288;
      *((_DWORD *)a2 + 5) = 0;
      *((_QWORD *)a2 + 4) = sub_10022B400;
      *((_QWORD *)a2 + 5) = 0;
      *((_BYTE *)a2 + 26) = 1;
      *((_BYTE *)a2 + 48) = a3;
      v18 = *(_OWORD *)a6;
      *((_DWORD *)a2 + 17) = *((_DWORD *)a6 + 4);
      *(_OWORD *)(a2 + 26) = v18;
      if (sub_10020E300(a1, (uint64_t)a2, a4))
      {
        return 4105;
      }
      else
      {
        v19 = *(_OWORD *)a6;
        *(_DWORD *)(a5 + 20) = *((_DWORD *)a6 + 4);
        *(_OWORD *)(a5 + 4) = v19;
        *(_QWORD *)(a5 + 32) = a7;
        *(_QWORD *)(a5 + 40) = a8;
        result = sub_10020E300(*a2, a5, 0);
        if ((_DWORD)result)
        {
          sub_10020E604(*a2, 0);
          return 4106;
        }
        else
        {
          a2[25] = *(_WORD *)a5;
        }
      }
    }
    else
    {
      if (sub_10005549C())
      {
        sub_100054530("Set callback required since characteristic is writable.");
        v17 = sub_1000544A0(0x45u);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return 4104;
    }
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("Get callback required since characteristic is readable");
      v15 = sub_1000544A0(0x45u);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 4103;
  }
  return result;
}

uint64_t sub_10022B400(uint64_t a1, unsigned int a2, void *a3, int a4, _WORD *a5)
{
  unsigned int v6;
  int v7;
  char v11;
  __int16 v12;
  _QWORD v13[2];

  v6 = *(unsigned __int8 *)(a1 + 52) + 3;
  v7 = v6 - a2;
  if (v6 < a2)
    return 7;
  v13[0] = 0;
  v13[1] = 0;
  v11 = *(_BYTE *)(a1 + 48);
  v12 = *(_WORD *)(a1 + 50);
  if (v7 >= a4)
    LOWORD(v7) = a4;
  *a5 = v7;
  sub_100072C50(v13, (unsigned __int8 *)(a1 + 52), 1);
  memmove(a3, &v11 + a2, (unsigned __int16)*a5);
  return 0;
}

uint64_t sub_10022B4C4(uint64_t a1, unsigned int a2, char a3, unsigned __int8 *a4, uint64_t (*a5)(uint64_t a1, unsigned int a2, void *a3, signed int a4, _WORD *a5), uint64_t a6)
{
  int v6;
  __int128 v14;

  v6 = *a4;
  if (v6 != 16 && v6 != 2)
    return 146;
  v14 = *(_OWORD *)a4;
  *(_DWORD *)(a1 + 20) = *((_DWORD *)a4 + 4);
  *(_OWORD *)(a1 + 4) = v14;
  if (sub_100072DF0(a4, (unsigned __int8 *)&xmmword_10073B29C)
    || sub_100072DF0(a4, (unsigned __int8 *)&xmmword_10073B2EC))
  {
    a6 = 0;
  }
  else
  {
    if (sub_100072DF0(a4, (unsigned __int8 *)&xmmword_10073B2B0))
    {
      a5 = sub_10022B5D8;
      goto LABEL_10;
    }
    if (sub_100072DF0(a4, (unsigned __int8 *)&xmmword_10073B2C4)
      || sub_100072DF0(a4, (unsigned __int8 *)&xmmword_10073B2D8))
    {
      a3 |= 3u;
      goto LABEL_10;
    }
  }
  a5 = sub_10022B5D8;
  a3 = 1;
LABEL_10:
  *(_BYTE *)(a1 + 26) = a3;
  *(_QWORD *)(a1 + 32) = a5;
  *(_QWORD *)(a1 + 40) = a6;
  return sub_10020E300(a2, a1, 0);
}

uint64_t sub_10022B5D8(uint64_t a1, unsigned int a2, void *a3, signed int a4, _WORD *a5)
{
  unsigned __int8 *v10;
  size_t v11;
  __int16 *v12;
  char *v13;
  unsigned int v14;
  BOOL v15;
  signed int v16;
  _WORD v18[2];
  char v19;
  __int16 v20;
  __int16 v21;

  v10 = (unsigned __int8 *)(a1 + 4);
  if (!sub_100072DF0((unsigned __int8 *)(a1 + 4), (unsigned __int8 *)&xmmword_10073B29C))
  {
    if (sub_100072DF0(v10, (unsigned __int8 *)&xmmword_10073B2EC))
    {
      v18[0] = *(_WORD *)(a1 + 48);
      v19 = *(_BYTE *)(a1 + 52);
      if (a2 <= 7)
      {
        v18[1] = *(_WORD *)(a1 + 50);
        v20 = *(_WORD *)(a1 + 54);
        if ((int)(7 - a2) >= a4)
          v11 = a4;
        else
          v11 = 7 - a2;
        *a5 = v11;
        v12 = v18;
        goto LABEL_13;
      }
    }
    else
    {
      sub_100072DF0(v10, (unsigned __int8 *)&xmmword_10073B2B0);
      v14 = *(unsigned __int16 *)(a1 + 56);
      v15 = v14 >= a2;
      v16 = v14 - a2;
      if (v15)
      {
        if (v16 >= a4)
          LOWORD(v16) = a4;
        *a5 = v16;
        v13 = (char *)(*(_QWORD *)(a1 + 48) + a2);
        v11 = (unsigned __int16)v16;
        goto LABEL_19;
      }
    }
    return 7;
  }
  if (a2 > 2)
    return 7;
  v21 = *(_WORD *)(a1 + 48);
  if ((int)(2 - a2) >= a4)
    v11 = a4;
  else
    v11 = 2 - a2;
  *a5 = v11;
  v12 = &v21;
LABEL_13:
  v13 = (char *)v12 + a2;
LABEL_19:
  memmove(a3, v13, v11);
  return 0;
}

uint64_t sub_10022B704(uint64_t a1, unsigned __int8 *a2, int a3, const void *a4, int a5)
{
  NSObject *v10;
  NSObject *v12;
  NSObject *v13;

  if (sub_100072DF0(a2 + 4, (unsigned __int8 *)&xmmword_10073B288))
  {
    if (a3)
    {
      if ((a2[48] & 0x10) == 0)
      {
        if (sub_10005549C())
        {
          sub_100054530("Can't send notification to characteristic without notify property!");
          v10 = sub_1000544A0(0x45u);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
        return 4108;
      }
      return sub_10020E8F8(a1, *((_WORD *)a2 + 25), a3, a4, a5);
    }
    if ((a2[48] & 0x20) != 0)
      return sub_10020E8F8(a1, *((_WORD *)a2 + 25), a3, a4, a5);
    if (sub_10005549C())
    {
      sub_100054530("Can't send indication to characteristic without indicate property!");
      v13 = sub_1000544A0(0x45u);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 4109;
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("Attribute handle 0x%x is not a characteristic!", *(unsigned __int16 *)a2);
      v12 = sub_1000544A0(0x45u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 4107;
  }
}

double sub_10022B874@<D0>(unsigned int a1@<W0>, int a2@<W1>, _OWORD *a3@<X8>)
{
  int *v3;
  int v4;
  int v5;
  __int128 v6;
  __int128 v7;
  double result;
  __int128 v9;

  if (a1 <= 3)
  {
    v3 = (int *)&xmmword_10098F998 + a2;
    if (a1 == 1)
    {
      v4 = *v3;
    }
    else
    {
      v5 = v3[12];
      v3 += 12;
      v4 = v5;
    }
    if (v4 != -1)
      *v3 = v4 + 1;
  }
  v6 = unk_10098F9C8;
  a3[2] = xmmword_10098F9B8;
  a3[3] = v6;
  v7 = unk_10098F9E8;
  a3[4] = xmmword_10098F9D8;
  a3[5] = v7;
  result = *(double *)&xmmword_10098F998;
  v9 = unk_10098F9A8;
  *a3 = xmmword_10098F998;
  a3[1] = v9;
  return result;
}

BOOL sub_10022B8CC()
{
  return memcmp(&unk_10098F9F8, &unk_10073B708, 0x40uLL) != 0;
}

uint64_t sub_10022B8FC(int a1)
{
  uint64_t result;

  result = memcmp(&qword_10098F9F8, &unk_10073B708, 0x40uLL);
  if ((_DWORD)result)
  {
    if ((byte_10098FA47 & 1) != 0 || a1 && BYTE13(xmmword_10098FA18) != 1 || (byte_10098FA40 & 1) != 0)
    {
      return 0;
    }
    else
    {
      result = sub_100072F80();
      if (!(_DWORD)result)
        byte_10098FA47 = 1;
    }
  }
  return result;
}

uint64_t sub_10022B978(uint64_t result)
{
  byte_10098FA46 = result;
  return result;
}

void sub_10022B984()
{
  xmmword_10098FA18 = 0u;
  *(_OWORD *)&byte_10098FA28 = 0u;
  *(_OWORD *)&qword_10098F9F8 = 0u;
  *(_OWORD *)&qword_10098FA08 = 0u;
  if (!qword_10098FA38)
    qword_10098FA38 = (uint64_t)sub_100251288(0, 0);
}

uint64_t sub_10022B9CC(uint64_t result)
{
  byte_10098FA45 = result;
  return result;
}

uint64_t sub_10022B9D8(uint64_t result)
{
  byte_10098FA49 = result;
  return result;
}

uint64_t sub_10022B9E4(uint64_t result)
{
  byte_10098FA44 = result;
  byte_10098FA4A = 0;
  return result;
}

uint64_t sub_10022B9F8(uint64_t result)
{
  byte_10098FA43 = result;
  return result;
}

uint64_t sub_10022BA04(uint64_t result)
{
  byte_10098FA48 = result;
  return result;
}

uint64_t sub_10022BA10(uint64_t result)
{
  byte_10098FA4B = result;
  return result;
}

void sub_10022BA1C()
{
  uint64_t v0;
  void **v1;

  xmmword_10098FA18 = 0u;
  *(_OWORD *)&byte_10098FA28 = 0u;
  *(_OWORD *)&qword_10098F9F8 = 0u;
  *(_OWORD *)&qword_10098FA08 = 0u;
  byte_10098FA47 = 0;
  byte_10098FA40 = 0;
  byte_10098FA42 = 0;
  v0 = qword_10098FA38;
  if (qword_10098FA38)
  {
    while (sub_100056080(v0))
    {
      v1 = (void **)sub_10025155C(qword_10098FA38);
      sub_100251574(qword_10098FA38, 0);
      sub_100053298(v1[2]);
      sub_100053298(v1);
      v0 = qword_10098FA38;
    }
  }
  sub_1002512C0((_QWORD *)qword_10098FA38);
  qword_10098FA38 = 0;
}

uint64_t sub_10022BAB0(uint64_t result)
{
  byte_10098FA41 = result;
  return result;
}

void sub_10022BABC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  const char *v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t i;

  sub_100253320((uint64_t)"LE_Scanning:\n", a2, a3, a4, a5, a6, a7, a8, v47);
  sub_100253320((uint64_t)"lRestartScanInProgress=%d lStopInProgress=%d lStartInProgress=%d", v9, v10, v11, v12, v13, v14, v15, byte_10098FA47);
  if (!memcmp(&qword_10098F9F8, &unk_10073B708, 0x40uLL))
  {
    sub_100253320((uint64_t)"No scan in progress\n", v16, v17, v18, v19, v20, v21, v22, v48);
  }
  else
  {
    sub_100253320((uint64_t)"Current Scan Parameters: leScanType:%d leScanInterval:0x%x leScanWindow:0x%x scanningFilterPolicy:%d filterDuplicates:%d\n", v16, v17, v18, v19, v20, v21, v22, xmmword_10098FA18);
    if (qword_10098F9F8)
      v30 = "";
    else
      v30 = "not ";
    sub_100253320((uint64_t)"scanStartedCb:%sset deviceFoundCb:%sset scanFinishedCb:%sset\n", v23, v24, v25, v26, v27, v28, v29, (uint64_t)v30);
  }
  if (byte_10098FA46)
  {
    sub_100253320((uint64_t)"Incomplete advertising packets:\n", v31, v32, v33, v34, v35, v36, v37, v49);
    if (qword_10098FA38)
    {
      if (sub_100056080(qword_10098FA38))
      {
        v38 = sub_100251684(qword_10098FA38);
        for (i = v38; i; v38 = i)
        {
          v39 = sub_1002516A8(v38);
          if (*(_BYTE *)(v39 + 1))
            v45 = "Public";
          else
            v45 = "Random";
          v46 = v8 & 0xFFFF000000000000;
          v8 = v8 & 0xFFFF000000000000 | *(unsigned int *)(v39 + 2) | ((unint64_t)*(unsigned __int16 *)(v39 + 6) << 32);
          sub_100253320((uint64_t)" %s %: responseType:%d dataLen:%d rssi:%d eventType:%d dataStatus:%d primaryPHY:%d secPHY:%d SID:%d txPower:%d periodicInterval:%d\n", *(unsigned __int16 *)(v39 + 34), v46, v40, v41, v42, v43, v44, (uint64_t)v45);
          sub_10025168C((uint64_t)&i);
        }
      }
    }
  }
}

void sub_10022BC8C(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  void (*v5)(uint64_t, uint64_t);
  NSObject *v6;

  if ((_DWORD)a1)
  {
    v5 = (void (*)(uint64_t, uint64_t))qword_10098FA08;
    v4 = qword_10098FA10;
    if (sub_10005549C())
    {
      sub_100054530("Reset scan in LE_Scan: %! for location %d", a1, a2);
      v6 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    xmmword_10098FA18 = 0u;
    *(_OWORD *)&byte_10098FA28 = 0u;
    *(_OWORD *)&qword_10098F9F8 = 0u;
    *(_OWORD *)&qword_10098FA08 = 0u;
    byte_10098FA42 = 0;
    if (v5)
      v5(a1, v4);
    else
      sub_100253460();
  }
}

void sub_10022BD48(uint64_t a1)
{
  uint64_t v1;
  void (*v2)(uint64_t, uint64_t);
  NSObject *v4;

  v2 = (void (*)(uint64_t, uint64_t))qword_10098FA08;
  v1 = qword_10098FA10;
  byte_10098FA42 = 0;
  if ((_DWORD)a1)
  {
    if (sub_10005549C())
    {
      sub_100054530("Could not start LE scan callback: %!", a1);
      v4 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    xmmword_10098FA18 = 0u;
    *(_OWORD *)&byte_10098FA28 = 0u;
    *(_OWORD *)&qword_10098F9F8 = 0u;
    *(_OWORD *)&qword_10098FA08 = 0u;
    if (v2)
      v2(a1, v1);
    else
      sub_100253460();
  }
  else if (qword_10098F9F8)
  {
    qword_10098F9F8(0, qword_10098FA10);
  }
}

uint64_t sub_10022BE24(uint64_t result)
{
  qword_10098FA50 = result;
  return result;
}

uint64_t sub_10022BE30()
{
  return qword_10098FA50;
}

uint64_t sub_10022BE3C(uint64_t a1, char a2)
{
  uint64_t result;

  if (!sub_10019AC00(a1))
    return 414;
  result = 0;
  *(_BYTE *)(a1 + 233) = a2 ^ 1;
  return result;
}

void sub_10022BE78(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NSObject *v6;
  NSObject *v7;
  __int16 v8;
  uint64_t v9;
  void (**v10)(uint64_t, uint64_t, uint64_t, uint64_t);

  if (sub_10019AC00(a2))
  {
    if ((_DWORD)a1)
    {
      if (sub_10005549C())
      {
        sub_100054530("Failed to encrypt connection %!.", a1);
        v6 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      *(_BYTE *)(a2 + 167) = 0;
      if ((_DWORD)a1 == 708)
      {
        *(_DWORD *)(a2 + 132) = 6;
        *(_DWORD *)(a2 + 140) = 4834;
      }
      *(_BYTE *)(a2 + 166) = (_DWORD)a3 != 0;
    }
    else
    {
      *(_BYTE *)(a2 + 166) = (_DWORD)a3 != 0;
      *(_BYTE *)(a2 + 168) = *(_BYTE *)(a2 + 169);
      *(_BYTE *)(a2 + 208) = 1;
    }
    sub_1002364F4(a2, a1, (_DWORD)a3 != 0);
    v8 = xmmword_10098FAA0;
    if ((__int16)xmmword_10098FAA0 >= 1)
    {
      v9 = 0;
      v10 = (void (**)(uint64_t, uint64_t, uint64_t, uint64_t))&xmmword_10098FAA0 + 1;
      do
      {
        if (*v10)
        {
          (*v10)(a2, a1, a3, qword_10098FA78);
          v8 = xmmword_10098FAA0;
        }
        ++v9;
        v10 += 3;
      }
      while (v9 < v8);
    }
    sub_10023654C(a2, a1, a3 != 0);
  }
  else if (sub_10005549C())
  {
    sub_100054530("This handle is not a LE connection.");
    v7 = sub_1000544A0(0x43u);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
}

void sub_10022C00C(uint64_t a1, _BYTE *a2)
{
  NSObject *v4;
  NSObject *v5;
  __int16 v6;
  uint64_t v7;
  char *v8;

  if (sub_10019AC00((uint64_t)a2))
  {
    if ((_DWORD)a1)
    {
      if (sub_10005549C())
      {
        sub_100054530("Failed to refresh connection %!.", a1);
        v4 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      a2[166] = 0;
    }
    else
    {
      a2[166] = 1;
      a2[168] = a2[169];
      sub_1002364F4((uint64_t)a2, 0, 1);
      v6 = xmmword_10098FAA0;
      if ((__int16)xmmword_10098FAA0 >= 1)
      {
        v7 = 0;
        v8 = (char *)&xmmword_10098FAA0 + 8;
        do
        {
          if (*(_QWORD *)v8)
          {
            (*(void (**)(_BYTE *, _QWORD, uint64_t, uint64_t))v8)(a2, 0, 1, qword_10098FA78);
            v6 = xmmword_10098FAA0;
          }
          ++v7;
          v8 += 24;
        }
        while (v7 < v6);
      }
      sub_10023654C((uint64_t)a2, 0, 1);
    }
  }
  else if (sub_10005549C())
  {
    sub_100054530("This handle is not a LE connection.");
    v5 = sub_1000544A0(0x43u);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
}

void sub_10022C16C(int a1, _QWORD *a2, uint64_t a3)
{
  __int128 *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  NSObject *v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  NSObject *v23;
  const void *v24[2];
  char v25;
  __int128 *v26;
  __int128 v27;
  uint64_t v28;

  v28 = 0;
  v27 = 0uLL;
  v25 = 0;
  v5 = sub_10019ACEC(a1);
  v26 = v5;
  if (v5)
  {
    v6 = (uint64_t)v5;
    if (sub_10019AC00((uint64_t)v5))
    {
      if (!(_DWORD)a3 && *a2 == v28 && sub_1002307DC((_DWORD *)(v6 + 48)))
      {
        if (sub_1002371D4(v6, &v27, &v25))
        {
          if (!sub_10004C9BC(186, (uint64_t (*)())sub_10022C3C4, v7, v8, v9, v10, v11, v12, v6))
          {
            *(_BYTE *)(v6 + 169) = v25;
            *(_BYTE *)(v6 + 166) = 2;
          }
        }
        else
        {
          if (sub_10005549C())
          {
            sub_100054530("Rejecting key request");
            v23 = sub_1000544A0(0x43u);
            if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
              sub_1006CE7A4();
          }
          sub_10004C9BC(187, 0, v17, v18, v19, v20, v21, v22, v6);
        }
      }
      else if (unk_10098FA60)
      {
        if (*(_BYTE *)(v6 + 55))
          v14 = v6 + 56;
        else
          v14 = v6 + 48;
        unk_10098FA60(v14, a2, a3, qword_10098FA78);
        v24[1] = &v26;
        v24[0] = (const void *)8;
        if (sub_10004A9EC((uint64_t)sub_10022C3FC, v24, 5000, (int *)(v6 + 184)))
        {
          if (sub_10005549C())
          {
            sub_100054530("Failed to set key request timeout CB");
            v15 = sub_1000544A0(0x43u);
            if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
              sub_1006CE7A4();
          }
        }
      }
      else if (sub_10005549C())
      {
        sub_100054530("No callbacks, ignoring request");
        v16 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
    }
    else if (sub_10005549C())
    {
      sub_100054530("This handle is not a LE connection, ignoring");
      v13 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
}

BOOL sub_10022C3C4(_BOOL8 result, uint64_t a2)
{
  if (result && a2)
  {
    result = sub_10019AC00(a2);
    if (result)
    {
      *(_BYTE *)(a2 + 166) = 0;
      *(_BYTE *)(a2 + 169) = 0;
    }
  }
  return result;
}

void sub_10022C3FC(uint64_t a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;

  v1 = *(uint64_t **)(a1 + 8);
  v2 = *v1;
  if (*v1 && sub_10019AC00(*v1))
  {
    *(_DWORD *)(v2 + 184) = 0;
    if (sub_10005549C())
    {
      sub_100054530("Timeout waiting for the response - we rejected the request for Key length");
      v9 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    sub_10004C9BC(187, 0, v3, v4, v5, v6, v7, v8, v2);
  }
  else if (sub_10005549C())
  {
    sub_100054530("This handle is not a LE connection.");
    v10 = sub_1000544A0(0x43u);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
}

uint64_t sub_10022C4CC(_DWORD *a1, uint64_t *a2, __int16 a3, unsigned int a4, char a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  NSObject *v23;
  _DWORD *v24;
  NSObject *v25;
  const void *v27[2];
  uint64_t v28;
  _QWORD v29[2];

  v29[0] = 0;
  v29[1] = 0;
  if (!a1)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("Invalid address");
    v20 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      return 101;
LABEL_20:
    sub_1006CE7A4();
    return 101;
  }
  if (!a2)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("randomNumber cannot be NULL");
    v21 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      return 101;
    goto LABEL_20;
  }
  v9 = sub_10019AFA0(a1);
  v28 = v9;
  if (!v9)
    return 122;
  v10 = v9;
  if (!sub_10019AC00(v9))
  {
    if (sub_10005549C())
    {
      sub_100054530("This handle is not a LE connection, ignoring");
      v22 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 122;
  }
  v11 = *(unsigned int *)(v10 + 184);
  if ((_DWORD)v11)
  {
    sub_100049F6C(v11);
    *(_DWORD *)(v10 + 184) = 0;
  }
  if (!a4)
  {
    if (sub_10005549C())
    {
      sub_100054530("Keysize=0 - no key present");
      v23 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    v12 = 0;
    goto LABEL_30;
  }
  if ((a5 & 0xFE) != 2)
  {
    v12 = sub_100237304(a2, a3, v29);
    if ((_DWORD)v12)
      return v12;
    v24 = (_DWORD *)(*(_BYTE *)(v10 + 55) ? v10 + 56 : v10 + 48);
    if (!sub_10022C8EC(v24, (uint64_t)v29, a4, a5))
      return v12;
LABEL_30:
    sub_10004C9BC(187, 0, v13, v14, v15, v16, v17, v18, v10);
    return v12;
  }
  if (off_10098FA68)
  {
    v27[1] = &v28;
    v27[0] = (const void *)8;
    v12 = sub_10004A9EC((uint64_t)sub_10022C7C8, v27, 0, 0);
    if (!(_DWORD)v12)
    {
      *(_BYTE *)(v28 + 166) = 3;
      return v12;
    }
    if (sub_10005549C())
    {
      sub_100054530("OI_Dispatch_RegisterTimedFunc failed to set key len request timeout %!", v12);
      v19 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    v10 = v28;
    goto LABEL_30;
  }
  if (sub_10005549C())
  {
    sub_100054530("No callbacks, ignoring request");
    v25 = sub_1000544A0(0x43u);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  return 0;
}

void sub_10022C7C8(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  NSObject *v3;
  uint64_t v4;
  const void *v5[2];
  uint64_t v6;

  v1 = **(_QWORD **)(a1 + 8);
  v6 = v1;
  if (off_10098FA68)
  {
    v5[0] = 0;
    if (v1 && sub_10019AC00(v1))
    {
      v5[1] = &v6;
      LOWORD(v5[0]) = 8;
      if (sub_10004A9EC((uint64_t)sub_10022E4D4, v5, 5000, (int *)(v1 + 180)))
      {
        if (sub_10005549C())
        {
          sub_100054530("Failed to set key request timeout CB");
          v2 = sub_1000544A0(0x43u);
          if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
      }
      else
      {
        if (*(_BYTE *)(v6 + 55))
          v4 = v6 + 56;
        else
          v4 = v6 + 48;
        off_10098FA68(v4, qword_10098FA78);
      }
    }
    else if (sub_10005549C())
    {
      sub_100054530("This handle is not a LE connection.");
      v3 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
}

uint64_t sub_10022C8EC(_DWORD *a1, uint64_t a2, unsigned int a3, char a4)
{
  uint64_t v7;
  _BYTE *v8;
  NSObject *v9;
  NSObject *v10;
  NSObject *v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  NSObject *v21;
  _QWORD v22[2];

  v22[0] = 0;
  v22[1] = 0;
  if (!a1)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("Invalid address");
    v10 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      return 101;
LABEL_18:
    sub_1006CE7A4();
    return 101;
  }
  if (!a2)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("Invalid *key specified");
    v13 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      return 101;
    goto LABEL_18;
  }
  v7 = sub_10019AFA0(a1);
  if (v7 && (v8 = (_BYTE *)v7, sub_10019AC00(v7)))
  {
    if (a3 - 17 <= 0xFFFFFFEF)
    {
      if (!sub_10005549C())
        return 101;
      sub_100054530("LTK length is too big : %d.", a3);
      v9 = sub_1000544A0(0x43u);
      if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        return 101;
      goto LABEL_18;
    }
    __memmove_chk(v22, a2, a3, 16);
    v12 = sub_10004C9BC(186, (uint64_t (*)())sub_10022C3C4, v15, v16, v17, v18, v19, v20, (uint64_t)v8);
    if ((_DWORD)v12)
    {
      if (sub_10005549C())
      {
        sub_100054530("Could not send long term key response %!.", v12, v22);
        v21 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      v8[167] = 0;
    }
    else
    {
      v8[167] = a3;
      v8[169] = a4;
      v8[166] = 2;
    }
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("This handle is not a LE connection.");
      v11 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 1310;
  }
  return v12;
}

uint64_t sub_10022CB28()
{
  byte_10098FB68 = 0;
  xmmword_10098FB69 = 0u;
  unk_10098FB79 = 0u;
  xmmword_10098FB89 = 0u;
  unk_10098FB99 = 0u;
  xmmword_10098FBA9 = 0u;
  unk_10098FBB9 = 0u;
  xmmword_10098FBC9 = 0u;
  unk_10098FBD9 = 0u;
  xmmword_10098FBE9 = 0u;
  unk_10098FBF9 = 0u;
  xmmword_10098FC09 = 0u;
  dword_10098FC19 = 0;
  return 0;
}

uint64_t sub_10022CB60(int *a1, char a2)
{
  uint64_t v2;
  unsigned __int8 v3;
  __int128 *v4;
  int v5;
  uint64_t v8;
  char *v9;
  int v10;
  uint64_t v11;
  int *v12;
  int v13;
  int v14;
  NSObject *v16;

  if (a1)
  {
    if ((a2 & 1) != 0)
    {
      v2 = 0;
      v3 = 20;
      v4 = &xmmword_10098FB69;
      do
      {
        v5 = *((unsigned __int8 *)v4 + 7);
        if (*((_BYTE *)v4 + 7))
        {
          if (*(_DWORD *)v4 == *a1 && *(_DWORD *)((char *)v4 + 3) == *(int *)((char *)a1 + 3))
          {
            if (*((_BYTE *)v4 + 8))
              return 0;
            *((_BYTE *)v4 + 8) = 1;
          }
        }
        if (v3 == 20 && v5 == 0)
          v3 = v2;
        ++v2;
        v4 = (__int128 *)((char *)v4 + 9);
      }
      while (v2 != 20);
      if (v3 > 0x13u)
      {
        if (sub_10005549C())
        {
          sub_100054530("Could not find a free slot for this device (DB FULL). Aborting.");
          v16 = sub_1000544A0(0x43u);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
        return 104;
      }
      else
      {
        v8 = 0;
        v9 = (char *)&xmmword_10098FB69 + 9 * v3;
        v9[7] = 1;
        v10 = *a1;
        *(_DWORD *)(v9 + 3) = *(int *)((char *)a1 + 3);
        *(_DWORD *)v9 = v10;
        v9[8] = 1;
      }
    }
    else
    {
      v11 = 0;
      while (1)
      {
        v12 = (int *)((char *)&xmmword_10098FB69 + v11);
        if (*((_BYTE *)&xmmword_10098FB69 + v11 + 7))
        {
          v13 = *v12;
          v14 = *(int *)((char *)v12 + 3);
          if (v13 == *a1 && v14 == *(int *)((char *)a1 + 3))
            break;
        }
        v11 += 9;
        if (v11 == 180)
          return 120;
      }
      v8 = 0;
      *((_BYTE *)&xmmword_10098FB69 + v11 + 7) = 0;
    }
  }
  else
  {
    v8 = 0;
    byte_10098FB68 = a2;
  }
  return v8;
}

BOOL sub_10022CCE0(_DWORD *a1, _DWORD *a2)
{
  NSObject *v3;
  char *v4;
  uint64_t v5;
  int *v6;
  int v8;
  int v9;

  if (a1)
  {
    if (byte_10098FB68)
      return 1;
    v5 = 0;
    while (1)
    {
      v6 = (int *)((char *)&xmmword_10098FB69 + v5);
      if (*((_BYTE *)&xmmword_10098FB69 + v5 + 7))
      {
        if (*v6 == *a1 && *(int *)((char *)v6 + 3) == *(_DWORD *)((char *)a1 + 3))
          break;
        if (a2)
        {
          v8 = *v6;
          v9 = *(int *)((char *)v6 + 3);
          if (v8 == *a2 && v9 == *(_DWORD *)((char *)a2 + 3))
            break;
        }
      }
      v5 += 9;
      if (v5 == 180)
        return 0;
    }
    v4 = (char *)&xmmword_10098FB69 + v5 + 8;
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("Invalid address, checking global OOB flag");
      v3 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    v4 = &byte_10098FB68;
  }
  return *v4 != 0;
}

uint64_t sub_10022CDD8(_OWORD *a1, int a2, int a3, char a4, char a5)
{
  BOOL v5;
  NSObject *v7;
  NSObject *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;

  v11 = *(_OWORD *)off_10091F088;
  v12 = *(_OWORD *)&off_10091F098;
  LODWORD(xmmword_100999254) = 1;
  if (BYTE9(xmmword_100998F98))
  {
    if (unk_10098FA60)
      v5 = 0;
    else
      v5 = off_10098FA68 == 0;
    if (v5 && off_10098FA70 == 0)
    {
      v10 = a1[1];
      *(_OWORD *)&unk_10098FA60 = *a1;
      *(_OWORD *)&off_10098FA70 = v10;
      return sub_100237D7C((uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))sub_10022CF5C, (uint64_t)&v11, (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD))sub_10022CF78, a2, a3, a4, a5);
    }
    else
    {
      if (sub_10005549C())
      {
        sub_100054530("Someone is already listening for LE security events.", v11, v12);
        v7 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return 119;
    }
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("LE not supported, can't register SMP.", v11, v12);
      v9 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 147;
  }
}

uint64_t sub_10022CF08(uint64_t result, uint64_t a2)
{
  if (unk_10098FA80)
    return unk_10098FA80(result, a2, qword_10098FA98);
  return result;
}

uint64_t sub_10022CF24(uint64_t result)
{
  if (off_10098FA88)
    return off_10098FA88(result, qword_10098FA98);
  return result;
}

uint64_t sub_10022CF40(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  if (off_10098FA90)
    return off_10098FA90(a1, a2, a3, qword_10098FA98);
  else
    return sub_1002305D8(a1);
}

uint64_t sub_10022CF5C(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (off_10098FA70)
    return off_10098FA70(result, a2, a3, a4, qword_10098FA78);
  return result;
}

uint64_t sub_10022CF78(uint64_t result, uint64_t a2, uint64_t a3)
{
  __int16 v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t (*v9)(uint64_t, uint64_t, uint64_t, uint64_t);

  v3 = xmmword_10098FAA0;
  if ((__int16)xmmword_10098FAA0 >= 1)
  {
    v6 = result;
    v7 = 0;
    v8 = &qword_10098FAB8;
    do
    {
      v9 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))*(v8 - 1);
      if (v9)
      {
        result = v9(v6, a2, a3, *v8);
        v3 = xmmword_10098FAA0;
      }
      ++v7;
      v8 += 3;
    }
    while (v7 < v3);
  }
  return result;
}

uint64_t sub_10022CFF8(uint64_t a1)
{
  NSObject *v1;
  uint64_t result;

  if (!BYTE9(xmmword_100998F98))
    return 0;
  if (unk_10098FA60 == *(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))a1
    && off_10098FA68 == *(uint64_t (**)(_QWORD, _QWORD))(a1 + 8)
    && off_10098FA70 == *(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(a1 + 16))
  {
    result = sub_100237F4C();
    if (!(_DWORD)result)
    {
      qword_10098FB60 = 0;
      xmmword_10098FB40 = 0u;
      unk_10098FB50 = 0u;
      xmmword_10098FB20 = 0u;
      unk_10098FB30 = 0u;
      xmmword_10098FB00 = 0u;
      unk_10098FB10 = 0u;
      xmmword_10098FAE0 = 0u;
      unk_10098FAF0 = 0u;
      xmmword_10098FAC0 = 0u;
      unk_10098FAD0 = 0u;
      xmmword_10098FAA0 = 0u;
      *(_OWORD *)&qword_10098FAB0 = 0u;
      *(_OWORD *)&unk_10098FA80 = 0u;
      *(_OWORD *)&off_10098FA90 = 0u;
      *(_OWORD *)&unk_10098FA60 = 0u;
      *(_OWORD *)&off_10098FA70 = 0u;
    }
    qword_10098FC20 = 0;
    word_10098FC28 = 0;
    LODWORD(xmmword_100999254) = 0;
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("You need to unregister the correct callbacks");
      v1 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 101;
  }
  return result;
}

__n128 sub_10022D100(uint64_t a1)
{
  BOOL v1;
  __n128 result;
  NSObject *v4;
  __int128 v5;

  if (BYTE9(xmmword_100998F98))
  {
    if (unk_10098FA80)
      v1 = 0;
    else
      v1 = off_10098FA88 == 0;
    if (v1 && off_10098FA90 == 0)
    {
      result = *(__n128 *)a1;
      v5 = *(_OWORD *)(a1 + 16);
      *(_OWORD *)&unk_10098FA80 = *(_OWORD *)a1;
      *(_OWORD *)&off_10098FA90 = v5;
    }
    else if (sub_10005549C())
    {
      sub_100054530("Someone is already listening for LE pairing events.");
      v4 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  return result;
}

double sub_10022D1A8(uint64_t a1)
{
  double result;
  NSObject *v2;

  if (BYTE9(xmmword_100998F98))
  {
    if (unk_10098FA80 == *(uint64_t (**)(_QWORD, _QWORD, _QWORD))a1
      && off_10098FA88 == *(uint64_t (**)(_QWORD, _QWORD))(a1 + 8)
      && off_10098FA90 == *(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(a1 + 16))
    {
      result = 0.0;
      *(_OWORD *)&unk_10098FA80 = 0u;
      *(_OWORD *)&off_10098FA90 = 0u;
    }
    else if (sub_10005549C())
    {
      sub_100054530("You need to unregister the correct callbacks");
      v2 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  return result;
}

__n128 sub_10022D270(__n128 *a1)
{
  __int16 v1;
  __n128 result;
  NSObject *v3;
  char *v4;

  if (BYTE9(xmmword_100998F98))
  {
    v1 = xmmword_10098FAA0;
    if ((__int16)xmmword_10098FAA0 < 8)
    {
      v4 = (char *)&unk_10098FA60 + 24 * (__int16)xmmword_10098FAA0;
      result = *a1;
      *(__n128 *)(v4 + 72) = *a1;
      *((_QWORD *)v4 + 11) = a1[1].n128_u64[0];
      LOWORD(xmmword_10098FAA0) = v1 + 1;
    }
    else if (sub_10005549C())
    {
      sub_100054530("Too many callbacks registered.");
      v3 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  return result;
}

uint64_t sub_10022D328(_QWORD *a1)
{
  __int16 v1;
  char *v2;
  uint64_t *v3;
  NSObject *v4;
  uint64_t result;
  NSObject *v6;
  int v7;
  char *v8;
  __int128 v9;

  if (!BYTE9(xmmword_100998F98))
    return 0;
  v1 = xmmword_10098FAA0;
  if (!(_WORD)xmmword_10098FAA0)
  {
    result = sub_10005549C();
    if (!(_DWORD)result)
      return result;
    sub_100054530("No callbacks registered.");
    v6 = sub_1000544A0(0x43u);
    result = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    sub_1006CE7A4();
    return 0;
  }
  if ((__int16)xmmword_10098FAA0 < 1)
  {
LABEL_8:
    if (sub_10005549C())
    {
      sub_100054530("You need to unregister the correct callbacks");
      v4 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 101;
  }
  else
  {
    v2 = 0;
    v3 = &qword_10098FAB0;
    while (*(v3 - 1) == *a1 && *v3 == a1[1])
    {
      ++v2;
      v3 += 3;
      if ((char *)(unsigned __int16)xmmword_10098FAA0 == v2)
        goto LABEL_8;
    }
    if ((__int16)xmmword_10098FAA0 - 1 > (int)v2)
    {
      v7 = (int)v2;
      do
      {
        v8 = (char *)&xmmword_10098FAA0 + 24 * (__int16)v7 + 8;
        v2 = (char *)&xmmword_10098FAA0 + 24 * (int)v2 + 8;
        v9 = *(_OWORD *)(v2 + 24);
        *((_QWORD *)v8 + 2) = *((_QWORD *)v2 + 5);
        *(_OWORD *)v8 = v9;
        LODWORD(v2) = (__int16)++v7;
      }
      while ((__int16)xmmword_10098FAA0 - 1 > (__int16)v7);
      v1 = xmmword_10098FAA0;
    }
    result = 0;
    LOWORD(xmmword_10098FAA0) = v1 - 1;
  }
  return result;
}

uint64_t sub_10022D498(_BYTE *a1, uint64_t a2, unsigned int a3, uint64_t a4, unsigned int a5, char a6)
{
  uint64_t v12;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  NSObject *v25;
  _QWORD v26[2];

  v26[0] = 0;
  v26[1] = 0;
  if (!a2)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("*randomNumber cannot be NULL");
    v13 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      return 101;
LABEL_16:
    sub_1006CE7A4();
    return 101;
  }
  if (!a4)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("*key cannot be NULL");
    v15 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      return 101;
    goto LABEL_16;
  }
  if (a1 && sub_10019AC00((uint64_t)a1))
  {
    if (a1[166] == 2)
      return 118;
    if (a5 >= 0x11)
    {
      if (!sub_10005549C())
        return 101;
      sub_100054530("LTK length is too big : %d.", a5);
      v17 = sub_1000544A0(0x43u);
      if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        return 101;
      goto LABEL_16;
    }
    __memmove_chk(v26, a4, a5, 16);
    a1[167] = a5;
    v12 = sub_100196768(0xB9u, v18, v19, v20, v21, v22, v23, v24, (uint64_t)a1);
    if ((_DWORD)v12)
    {
      if (sub_10005549C())
      {
        sub_100054530("Could not start the encryption on the LE link %!.", v12, a2, a3, v26);
        v25 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
    }
    else
    {
      a1[166] = 2;
      a1[169] = a6;
    }
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("This handle is not a LE connection.");
      v14 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 1310;
  }
  return v12;
}

uint64_t sub_10022D6EC(_BYTE *a1, uint64_t a2)
{
  NSObject *v5;
  NSObject *v6;
  NSObject *v7;

  if (!a2)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("*keys cannot be NULL");
    v6 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      return 101;
    goto LABEL_12;
  }
  if (a1 && sub_10019AC00((uint64_t)a1))
  {
    if (a1[166] == 2)
      return 118;
    if ((~*(unsigned __int16 *)(a2 + 80) & 7) == 0)
      return sub_10022D498(a1, a2 + 20, *(unsigned __int16 *)(a2 + 18), a2, *(unsigned __int8 *)(a2 + 16), *(_BYTE *)(a2 + 17));
    if (!sub_10005549C())
      return 101;
    sub_100054530("Missing keys");
    v7 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      return 101;
LABEL_12:
    sub_1006CE7A4();
    return 101;
  }
  if (sub_10005549C())
  {
    sub_100054530("This handle is not a LE connection.");
    v5 = sub_1000544A0(0x43u);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  return 1310;
}

uint64_t sub_10022D834(uint64_t a1)
{
  uint64_t result;
  NSObject *v3;
  NSObject *v4;
  NSObject *v5;
  const void *v6[2];
  uint64_t v7;

  v7 = a1;
  if (a1 && sub_10019AC00(a1))
  {
    if (*(_BYTE *)(a1 + 166) == 2)
      return 118;
    if (!off_10098FA68)
    {
      if (sub_10005549C())
      {
        sub_100054530("No callbacks defined");
        v5 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return 101;
    }
    v6[1] = &v7;
    v6[0] = (const void *)8;
    result = sub_10004A9EC((uint64_t)sub_10022C7C8, v6, 0, 0);
    if ((_DWORD)result)
    {
      if (sub_10005549C())
      {
        sub_100054530("Failed to send key request callback");
        v4 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return 101;
    }
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("This handle is not a LE connection.");
      v3 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 1310;
  }
  return result;
}

uint64_t sub_10022D980(uint64_t a1)
{
  uint64_t result;
  NSObject *v3;

  if (sub_10019AC00(a1))
    return *(unsigned __int8 *)(a1 + 166) == 1;
  result = sub_10005549C();
  if ((_DWORD)result)
  {
    sub_100054530("Invalid LE connection handle 0x%x", a1);
    v3 = sub_1000544A0(0x43u);
    result = os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
    {
      sub_1006CE7A4();
      return 0;
    }
  }
  return result;
}

uint64_t sub_10022DA04(uint64_t a1)
{
  uint64_t result;
  NSObject *v3;
  NSObject *v4;

  if (sub_10019AC00(a1))
  {
    if (*(_BYTE *)(a1 + 166) != 1)
      return 0;
    if (off_10098FA68)
      return (*(_BYTE *)(a1 + 168) & 0xFD) == 1;
    result = sub_10005549C();
    if ((_DWORD)result)
    {
      sub_100054530("No callbacks defined");
      v4 = sub_1000544A0(0x43u);
      result = os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
      if ((_DWORD)result)
      {
LABEL_7:
        sub_1006CE7A4();
        return 0;
      }
    }
  }
  else
  {
    result = sub_10005549C();
    if ((_DWORD)result)
    {
      sub_100054530("Invalid LE connection handle 0x%x", a1);
      v3 = sub_1000544A0(0x43u);
      result = os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
      if ((_DWORD)result)
        goto LABEL_7;
    }
  }
  return result;
}

uint64_t sub_10022DAE0(uint64_t a1)
{
  uint64_t result;
  NSObject *v3;

  if (sub_10019AC00(a1))
    return *(_BYTE *)(a1 + 208) != 0;
  result = sub_10005549C();
  if ((_DWORD)result)
  {
    sub_100054530("Invalid LE connection handle 0x%x", a1);
    v3 = sub_1000544A0(0x43u);
    result = os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
    {
      sub_1006CE7A4();
      return 0;
    }
  }
  return result;
}

uint64_t sub_10022DB64(uint64_t a1, _BYTE *a2)
{
  uint64_t result;
  NSObject *v5;

  if (sub_10019AC00(a1))
  {
    if (*(_BYTE *)(a1 + 166) == 1)
    {
      if (a2)
      {
        result = 0;
        *a2 = *(_BYTE *)(a1 + 167);
      }
      else
      {
        sub_100253460();
        return 101;
      }
    }
    else
    {
      return 4802;
    }
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("Invalid LE connection handle 0x%x", a1);
      v5 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 1310;
  }
  return result;
}

uint64_t sub_10022DC10(void *a1, _BYTE *a2, uint64_t a3)
{
  char v3;
  NSObject *v5;
  NSObject *v6;

  if (!a2)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("*ltkType cannot be NULL");
    v5 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      return 101;
LABEL_12:
    sub_1006CE7A4();
    return 101;
  }
  if (!a3)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("*keys cannot be NULL");
    v6 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      return 101;
    goto LABEL_12;
  }
  if ((*(_WORD *)(a3 + 80) & 8) == 0)
    return 102;
  v3 = *(_BYTE *)(a3 + 45);
  if ((v3 & 0xFE) != 2)
    return 102;
  *a2 = v3;
  return sub_1001ED8E4((const void *)(a3 + 28), *(unsigned __int8 *)(a3 + 44), a1, *(unsigned __int8 *)(a3 + 79) == 2);
}

BOOL sub_10022DD00(uint64_t a1, __int128 *a2)
{
  _BOOL8 result;
  __int16 v5;
  char v6;

  result = 0;
  v6 = 0;
  v5 = 0;
  if (a1 && a2)
    return *(_BYTE *)a1 == 1
        && (*(_BYTE *)(a1 + 1) & 0x40) != 0
        && !sub_10018489C(a2, (__int16 *)(a1 + 1), (uint64_t)&v5)
        && v5 == *(_WORD *)(a1 + 4)
        && v6 == *(_BYTE *)(a1 + 6);
  return result;
}

uint64_t sub_10022DD88(_DWORD *a1)
{
  uint64_t v1;
  uint64_t i;
  BOOL v3;

  v1 = (unsigned __int16)word_10098FC28;
  if (!word_10098FC28)
    return 0;
  for (i = qword_10098FC20; ; i += 24)
  {
    v3 = *a1 == *(_DWORD *)i && *(_DWORD *)((char *)a1 + 3) == *(_DWORD *)(i + 3);
    if (v3 && !*(_BYTE *)(i + 23))
      break;
    if (!--v1)
      return 0;
  }
  return i + 7;
}

uint64_t sub_10022DDDC(_DWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _DWORD *v8;
  NSObject *v9;
  NSObject *v10;
  NSObject *v11;
  NSObject *v13;
  _DWORD *v14;
  const void *v15[2];

  if (!a1)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("Invalid address");
    v10 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      return 101;
LABEL_16:
    sub_1006CE7A4();
    return 101;
  }
  if (!a2)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("*keys cannot be NULL");
    v11 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      return 101;
    goto LABEL_16;
  }
  v4 = sub_10019AFA0(a1);
  if (v4)
  {
    v5 = v4;
    v6 = *(unsigned int *)(v4 + 180);
    if ((_DWORD)v6)
    {
      sub_100049F6C(v6);
      *(_DWORD *)(v5 + 180) = 0;
    }
    v7 = sub_10023252C((_BYTE *)v5, a2);
    if ((_DWORD)v7)
    {
      v15[0] = 0;
      v8 = sub_100052DC0(0x10uLL);
      v14 = v8;
      *(_QWORD *)v8 = v5;
      v8[2] = 4803;
      v15[1] = &v14;
      LOWORD(v15[0]) = 8;
      if (sub_10004A9EC((uint64_t)sub_10022DFA4, v15, 0, 0))
      {
        if (sub_10005549C())
        {
          sub_100054530("Failed to send the encryption failed callback");
          v9 = sub_1000544A0(0x43u);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
        return 101;
      }
    }
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("Connection to %: is no longer valid. Ignoring.", (char *)a1 + 1);
      v13 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 122;
  }
  return v7;
}

void sub_10022DFA4(uint64_t a1)
{
  uint64_t **v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  __int16 v5;
  unint64_t v6;
  void (**v7)(void);
  NSObject *v8;

  v1 = *(uint64_t ***)(a1 + 8);
  v2 = *v1;
  v3 = **v1;
  if (v3 && sub_10019AC00(v3))
  {
    v4 = *(unsigned int *)(*v2 + 180);
    if ((_DWORD)v4)
    {
      sub_100049F6C(v4);
      *(_DWORD *)(*v2 + 180) = 0;
    }
    v5 = xmmword_10098FAA0;
    if ((_WORD)xmmword_10098FAA0)
    {
      v6 = 0;
      v7 = (void (**)(void))&xmmword_10098FAA0 + 1;
      do
      {
        if (*v7)
        {
          (*v7)();
          v5 = xmmword_10098FAA0;
        }
        ++v6;
        v7 += 3;
      }
      while (v6 < v5);
    }
    sub_100053298(v2);
  }
  else if (sub_10005549C())
  {
    sub_100054530("This handle is not a LE connection.");
    v8 = sub_1000544A0(0x43u);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
}

uint64_t sub_10022E0A4(_DWORD *a1, int a2, uint64_t a3)
{
  uint64_t v5;
  NSObject *v7;
  NSObject *v8;

  if (!a1)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("Invalid address");
    v7 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      return 101;
    goto LABEL_9;
  }
  if (a3)
  {
    v5 = sub_10019AFA0(a1);
    return sub_100232744(v5, a2, a3);
  }
  if (sub_10005549C())
  {
    sub_100054530("*keys cannot be NULL");
    v8 = sub_1000544A0(0x43u);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
LABEL_9:
      sub_1006CE7A4();
  }
  return 101;
}

uint64_t sub_10022E168(_DWORD *a1, int a2, unsigned __int8 a3)
{
  uint64_t v5;
  NSObject *v7;

  if (a1)
  {
    v5 = sub_10019AFA0(a1);
    return sub_100231A2C(v5, a2, a3);
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("Invalid address");
      v7 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 101;
  }
}

uint64_t sub_10022E1E8(int *a1, _OWORD *a2, char a3)
{
  unsigned int v6;
  uint64_t v7;
  _DWORD *v8;
  NSObject *v10;
  char *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  __int128 v17;
  char *v18;
  int v19;
  __int16 v20;

  v6 = (unsigned __int16)word_10098FC28;
  if (word_10098FC28)
  {
    v7 = 0;
    v8 = (_DWORD *)qword_10098FC20;
    while (*v8 != *a1 || *(_DWORD *)((char *)v8 + 3) != *(int *)((char *)a1 + 3))
    {
      ++v7;
      v8 += 6;
      if ((unsigned __int16)word_10098FC28 == v7)
        goto LABEL_13;
    }
    if (sub_10005549C())
    {
      sub_100054530("Found a dup instance of  %: at index %d, trying to remove it.", (char *)a1 + 1, v7);
      v10 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    sub_10022E354(a1);
    v6 = (unsigned __int16)word_10098FC28;
  }
LABEL_13:
  v11 = (char *)sub_100052DC0(24 * v6 + 24);
  v12 = (uint64_t)v11;
  v13 = (unsigned __int16)word_10098FC28;
  if (word_10098FC28)
  {
    v14 = qword_10098FC20;
    v15 = (unsigned __int16)word_10098FC28;
    v16 = v11;
    do
    {
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = *(_QWORD *)(v14 + 16);
      *(_OWORD *)v16 = v17;
      v16 += 24;
      v14 += 24;
      --v15;
    }
    while (v15);
  }
  v18 = &v11[24 * v13];
  *(_OWORD *)(v18 + 7) = *a2;
  v19 = *a1;
  v20 = *((_WORD *)a1 + 2);
  v18[6] = *((_BYTE *)a1 + 6);
  *((_WORD *)v18 + 2) = v20;
  *(_DWORD *)v18 = v19;
  v18[23] = a3;
  if (qword_10098FC20)
    sub_100053298((void *)qword_10098FC20);
  qword_10098FC20 = v12;
  word_10098FC28 = v13 + 1;
  return 0;
}

uint64_t sub_10022E354(_DWORD *a1)
{
  uint64_t v2;
  _DWORD *i;
  uint64_t result;
  char *v6;
  unint64_t v7;
  void *v8;
  unsigned __int16 v9;
  unint64_t v10;
  uint64_t v11;
  __int128 v13;
  char *v14;

  if (!word_10098FC28)
    return 120;
  v2 = 0;
  for (i = (_DWORD *)qword_10098FC20; *i != *a1 || *(_DWORD *)((char *)i + 3) != *(_DWORD *)((char *)a1 + 3); i += 6)
  {
    if ((unsigned __int16)word_10098FC28 == ++v2)
      return 120;
  }
  if ((unsigned __int16)word_10098FC28 == (unsigned __int16)v2)
    return 120;
  if ((unsigned __int16)word_10098FC28 <= 1u)
  {
    v9 = 0;
    v6 = 0;
    v8 = (void *)qword_10098FC20;
  }
  else
  {
    v6 = (char *)sub_100052DC0(24 * ((unsigned __int16)word_10098FC28 - 1));
    v7 = (unsigned __int16)word_10098FC28;
    v8 = (void *)qword_10098FC20;
    if ((unsigned __int16)word_10098FC28 < 2u)
    {
      v9 = 0;
      if (!qword_10098FC20)
        goto LABEL_25;
      goto LABEL_24;
    }
    v9 = 0;
    v10 = 1;
    v11 = qword_10098FC20;
    do
    {
      if (*(_DWORD *)v11 != *a1 || *(_DWORD *)(v11 + 3) != *(_DWORD *)((char *)a1 + 3))
      {
        v13 = *(_OWORD *)v11;
        v14 = &v6[24 * v9];
        *((_QWORD *)v14 + 2) = *(_QWORD *)(v11 + 16);
        *(_OWORD *)v14 = v13;
        ++v9;
      }
      if (v10 >= v7)
        break;
      v11 += 24;
      ++v10;
    }
    while ((int)v7 - 1 > v9);
  }
  if (v8)
LABEL_24:
    sub_100053298(v8);
LABEL_25:
  result = 0;
  qword_10098FC20 = (uint64_t)v6;
  word_10098FC28 = v9;
  return result;
}

void sub_10022E4A0()
{
  if (qword_10098FC20)
    sub_100053298((void *)qword_10098FC20);
  qword_10098FC20 = 0;
  word_10098FC28 = 0;
}

void sub_10022E4D4(uint64_t a1)
{
  uint64_t *v1;
  uint64_t v2;
  _DWORD *v3;
  NSObject *v4;
  NSObject *v5;
  _DWORD *v6;
  const void *v7[2];

  v1 = *(uint64_t **)(a1 + 8);
  v2 = *v1;
  if (*v1 && sub_10019AC00(*v1))
  {
    v7[0] = 0;
    v3 = sub_100052DC0(0x10uLL);
    v6 = v3;
    *(_QWORD *)v3 = v2;
    v3[2] = 4807;
    v7[1] = &v6;
    LOWORD(v7[0]) = 8;
    if (sub_10004A9EC((uint64_t)sub_10022DFA4, v7, 0, 0) && sub_10005549C())
    {
      sub_100054530("Failed to send the encryption failed callback");
      v4 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  else if (sub_10005549C())
  {
    sub_100054530("This handle is not a LE connection.");
    v5 = sub_1000544A0(0x43u);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
}

uint64_t sub_10022E5D4(__int128 *a1, char a2, char a3)
{
  void *v4;
  void *v5;
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  char v11[2];
  __int16 v12;
  char v13;
  char v14;

  v11[0] = 1;
  v11[1] = a2;
  v12 = 2;
  v13 = a3;
  v14 = 0;
  if (sub_10019AC00((uint64_t)a1))
  {
    v4 = sub_100254200(v11, 6uLL, 0);
    if (v4)
    {
      v5 = v4;
      v6 = sub_1001DBC18(0, 5u, a1, (uint64_t)v4, 0);
      if ((_DWORD)v6)
      {
        if (sub_10005549C())
        {
          sub_100054530("Could not write the to SMP channel for handle 0x%x", (_DWORD)a1);
          v7 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
      }
      sub_100254090(v5);
    }
    else
    {
      if (sub_10005549C())
      {
        sub_100054530("Unable to allocate buffer for LE Signal transmit.");
        v9 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return 104;
    }
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("This command is only available to LE devices.");
      v8 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 4120;
  }
  return v6;
}

uint64_t sub_10022E73C(__int128 *a1, char a2, int a3, unsigned int a4, unsigned int a5, int a6, int a7, int a8, unsigned __int16 a9)
{
  NSObject *v16;
  void *v17;
  void *v18;
  uint64_t v19;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  char v24[2];
  __int16 v25;
  __int16 v26;

  v24[0] = 19;
  v24[1] = a2;
  v25 = 2;
  v26 = a3;
  if (sub_10019AC00((uint64_t)a1))
  {
    if (!a3 && sub_1002160C0((uint64_t)a1, a4, a5, a6, a7, a8, a9))
    {
      if (sub_10005549C())
      {
        sub_100054530("Failed to update connection parameters.");
        v16 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      v26 = 1;
    }
    v17 = sub_100254200(v24, 6uLL, 0);
    if (v17)
    {
      v18 = v17;
      v19 = sub_1001DBC18(0, 5u, a1, (uint64_t)v17, 0);
      if ((_DWORD)v19)
      {
        if (sub_10005549C())
        {
          sub_100054530("Could not write the to LE signal channel for handle 0x%x", (_DWORD)a1);
          v20 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
      }
      sub_100254090(v18);
    }
    else
    {
      if (sub_10005549C())
      {
        sub_100054530("Unable to allocate buffer for LE Signal transmit.");
        v22 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return 104;
    }
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("This command is only available to LE devices.");
      v21 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 4121;
  }
  return v19;
}

uint64_t sub_10022E940(_BYTE *a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  char v5;
  NSObject *v7;
  NSObject *v8;
  uint64_t v9;
  NSObject *v11;
  NSObject *v13;
  NSObject *v15;
  double v16;
  unsigned int v17;
  NSObject *v18;
  NSObject *v19;
  double v20;
  NSObject *v21;
  NSObject *v22;
  NSObject *v24;
  int v25;
  NSObject *v26;
  NSObject *v27;
  void *v29;
  void *v30;
  NSObject *v31;
  NSObject *v32;
  char v33[2];
  __int16 v34;
  __int16 v35;
  __int16 v36;
  __int16 v37;
  __int16 v38;

  v33[0] = 18;
  v5 = byte_10097A8E0++;
  v33[1] = v5;
  v34 = 8;
  v35 = a2;
  v36 = a3;
  v37 = a4;
  v38 = a5;
  if (a1[70] != 1)
  {
    if (sub_10005549C())
    {
      sub_100054530("Connection is not peripheral.");
      v8 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 132;
  }
  if ((unsigned __int16)(a2 - 3201) <= 0xF384u)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("Invalid min interval 0x%x.", a2);
    v7 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      return 101;
    goto LABEL_50;
  }
  if ((unsigned __int16)(a3 - 3201) <= 0xF384u)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("Invalid max interval : 0x%x.", a3);
    v11 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      return 101;
    goto LABEL_50;
  }
  if (a4 >= 0x1F5)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("Invalid peripheral latency %d.", a4);
    v13 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      return 101;
    goto LABEL_50;
  }
  if (a5 - 3201 <= 0xFFFFF388)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("Invalid supervision timeout : 0x%x.", a5);
    v15 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      return 101;
    goto LABEL_50;
  }
  if (a3 <= a2)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("Invalid interval range : 0x%x - 0x%x.", a2, a3);
    v19 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      return 101;
LABEL_50:
    sub_1006CE7A4();
    return 101;
  }
  v16 = (double)a3 * 1.25;
  v17 = a4 + 1;
  if (v16 * (double)(int)(a4 + 1) > 6000.0)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("Requesting an interval / latency combination that would provide a poor user experience (more than 6seconds syncups.)");
    v18 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      return 101;
    goto LABEL_50;
  }
  v20 = (double)a2 * 1.25;
  if (v20 < 10.0)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("Requesting a min interval smaller than 10 ms. Let's refuse and not drain the battery...");
    v21 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      return 101;
    goto LABEL_50;
  }
  if (-(v20 - (double)a3 * 1.25) < 10.0)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("Intervals should be %d ms apart - refusing.", 10);
    v22 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      return 101;
    goto LABEL_50;
  }
  if (a4 >= 5 && (sub_1000F4170(a1) & 1) == 0)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("Requesting a peripheral latency more than 4 so we drain our battery and they don't - refusing.");
    v27 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      return 101;
    goto LABEL_50;
  }
  if (a5 >= 0x709)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("Requesting for a timeout of more than 18 seconds, this is not very user friendly - refusing.");
    v24 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      return 101;
    goto LABEL_50;
  }
  v25 = 10 * a5;
  if (v16 * (double)(int)(3 * v17) > (double)v25)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("Requesting for a timeout(%dms) / latency(%d) / maxInterval(%dms) that would cause link timeouts under bad conditions. - refusing.", v25, a4, LODWORD(v16));
    v26 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      return 101;
    goto LABEL_50;
  }
  v29 = sub_100254200(v33, 0xCuLL, 0);
  if (v29)
  {
    v30 = v29;
    v9 = sub_1001DBC18(0, 5u, (__int128 *)a1, (uint64_t)v29, 0);
    if ((_DWORD)v9)
    {
      if (sub_10005549C())
      {
        sub_100054530("Could not write the to LE signal channel for handle 0x%x", (_DWORD)a1);
        v31 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
    }
    sub_100254090(v30);
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("Unable to allocate buffer for LE Signal transmit.");
      v32 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 104;
  }
  return v9;
}

uint64_t sub_10022EEE0(__int128 *a1, char a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7)
{
  void *v8;
  void *v9;
  uint64_t v10;
  NSObject *v11;
  NSObject *v12;
  NSObject *v13;
  char v15[2];
  __int16 v16;
  __int16 v17;
  __int16 v18;
  __int16 v19;
  __int16 v20;
  __int16 v21;

  v15[0] = 21;
  v15[1] = a2;
  v16 = 10;
  v17 = a3;
  v18 = a4;
  v19 = a5;
  v20 = a6;
  v21 = a7;
  if (sub_10019AC00((uint64_t)a1))
  {
    v8 = sub_100254200(v15, 0xEuLL, 0);
    if (v8)
    {
      v9 = v8;
      v10 = sub_1001DBC18(0, 5u, a1, (uint64_t)v8, 0);
      if ((_DWORD)v10)
      {
        if (sub_10005549C())
        {
          sub_100054530("Could not write the to LE signal channel for handle 0x%x", (_DWORD)a1);
          v11 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
      }
      sub_100254090(v9);
    }
    else
    {
      if (sub_10005549C())
      {
        sub_100054530("Unable to allocate buffer for LE Signal transmit.");
        v13 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return 104;
    }
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("This command is only available to LE devices.");
      v12 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 4122;
  }
  return v10;
}

uint64_t sub_10022F0A8(__int128 *a1, char a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7)
{
  void *v8;
  void *v9;
  uint64_t v10;
  NSObject *v11;
  NSObject *v12;
  NSObject *v13;
  char v15[2];
  __int16 v16;
  __int16 v17;
  __int16 v18;
  __int16 v19;
  __int16 v20;
  __int16 v21;

  v15[0] = 20;
  v15[1] = a2;
  v16 = 10;
  v17 = a3;
  v18 = a4;
  v19 = a5;
  v20 = a6;
  v21 = a7;
  if (sub_10019AC00((uint64_t)a1))
  {
    v8 = sub_100254200(v15, 0xEuLL, 0);
    if (v8)
    {
      v9 = v8;
      v10 = sub_1001DBC18(0, 5u, a1, (uint64_t)v8, 0);
      if ((_DWORD)v10)
      {
        if (sub_10005549C())
        {
          sub_100054530("Could not write the to LE signal channel for handle 0x%x", (_DWORD)a1);
          v11 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
      }
      sub_100254090(v9);
    }
    else
    {
      if (sub_10005549C())
      {
        sub_100054530("Unable to allocate buffer for LE Signal transmit.");
        v13 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return 104;
    }
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("This command is only available to LE devices.");
      v12 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 4123;
  }
  return v10;
}

uint64_t sub_10022F270(__int128 *a1, char a2, __int16 a3, __int16 a4)
{
  void *v5;
  void *v6;
  uint64_t v7;
  NSObject *v8;
  NSObject *v9;
  NSObject *v10;
  int v12;
  __int16 v13;
  __int16 v14;

  v12 = 262166;
  BYTE1(v12) = a2;
  v13 = a3;
  v14 = a4;
  if (sub_10019AC00((uint64_t)a1))
  {
    v5 = sub_100254200((char *)&v12, 8uLL, 0);
    if (v5)
    {
      v6 = v5;
      v7 = sub_1001DBC18(0, 5u, a1, (uint64_t)v5, 0);
      if ((_DWORD)v7)
      {
        if (sub_10005549C())
        {
          sub_100054530("Could not write the to LE signal channel for handle 0x%x", (_DWORD)a1);
          v8 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
      }
      sub_100254090(v6);
    }
    else
    {
      if (sub_10005549C())
      {
        sub_100054530("Unable to allocate buffer for LE Signal transmit.");
        v10 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return 104;
    }
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("This command is only available to LE devices.");
      v9 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 4124;
  }
  return v7;
}

uint64_t sub_10022F410(__int128 *a1, int a2, unsigned int a3, __int16 a4, unsigned int a5, char a6)
{
  int v7;
  _BYTE *v8;
  int *v9;
  unsigned int v10;
  void *v11;
  void *v12;
  uint64_t v13;
  NSObject *v14;
  NSObject *v15;
  NSObject *v16;
  char v18[4];
  __int16 v19;
  int v20;

  v18[0] = 1;
  v18[1] = a6;
  v18[3] = 0;
  v19 = a2;
  v20 = 0;
  if (a2 == 1)
  {
    v9 = &v20;
    v8 = (char *)&v20 + 1;
    v10 = a3 >> 8;
    v7 = 2;
  }
  else
  {
    v7 = 0;
    if (a2 != 2)
      goto LABEL_6;
    v8 = (char *)&v20 + 3;
    v9 = (int *)((char *)&v20 + 2);
    LOWORD(v20) = a4;
    v10 = a5 >> 8;
    v7 = 4;
    LOBYTE(a3) = a5;
  }
  *(_BYTE *)v9 = a3;
  *v8 = v10;
LABEL_6:
  v18[2] = v7 + 2;
  if (sub_10019AC00((uint64_t)a1))
  {
    v11 = sub_100254200(v18, (v7 + 6), 0);
    if (v11)
    {
      v12 = v11;
      v13 = sub_1001DBC18(0, 5u, a1, (uint64_t)v11, 0);
      if ((_DWORD)v13)
      {
        if (sub_10005549C())
        {
          sub_100054530("Could not write the to LE signal channel for handle 0x%x", (_DWORD)a1);
          v14 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
      }
      sub_100254090(v12);
    }
    else
    {
      if (sub_10005549C())
      {
        sub_100054530("Unable to allocate buffer for LE Signal transmit.");
        v16 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return 104;
    }
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("This command is only available to LE devices.");
      v15 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 4125;
  }
  return v13;
}

uint64_t sub_10022F604(__int128 *a1, char a2, __int16 a3, __int16 a4)
{
  void *v5;
  void *v6;
  uint64_t v7;
  NSObject *v8;
  NSObject *v9;
  NSObject *v10;
  int v12;
  __int16 v13;
  __int16 v14;

  v12 = 262150;
  BYTE1(v12) = a2;
  v13 = a4;
  v14 = a3;
  if (sub_10019AC00((uint64_t)a1))
  {
    v5 = sub_100254200((char *)&v12, 8uLL, 0);
    if (v5)
    {
      v6 = v5;
      v7 = sub_1001DBC18(0, 5u, a1, (uint64_t)v5, 0);
      if ((_DWORD)v7)
      {
        if (sub_10005549C())
        {
          sub_100054530("Could not write the to LE signal channel for handle 0x%x", (_DWORD)a1);
          v8 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
      }
      sub_100254090(v6);
    }
    else
    {
      if (sub_10005549C())
      {
        sub_100054530("Unable to allocate buffer for LE Signal transmit.");
        v10 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return 104;
    }
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("This command is only available to LE devices.");
      v9 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 4126;
  }
  return v7;
}

uint64_t sub_10022F7A4(__int128 *a1, char a2, __int16 a3, __int16 a4)
{
  void *v5;
  void *v6;
  uint64_t v7;
  NSObject *v8;
  NSObject *v9;
  NSObject *v10;
  int v12;
  __int16 v13;
  __int16 v14;

  v12 = 262151;
  BYTE1(v12) = a2;
  v13 = a3;
  v14 = a4;
  if (sub_10019AC00((uint64_t)a1))
  {
    v5 = sub_100254200((char *)&v12, 8uLL, 0);
    if (v5)
    {
      v6 = v5;
      v7 = sub_1001DBC18(0, 5u, a1, (uint64_t)v5, 0);
      if ((_DWORD)v7)
      {
        if (sub_10005549C())
        {
          sub_100054530("Could not write the to LE signal channel for handle 0x%x", (_DWORD)a1);
          v8 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
      }
      sub_100254090(v6);
    }
    else
    {
      if (sub_10005549C())
      {
        sub_100054530("Unable to allocate buffer for LE Signal transmit.");
        v10 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return 104;
    }
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("This command is only available to LE devices.");
      v9 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 4127;
  }
  return v7;
}

uint64_t sub_10022F944(uint64_t (*a1)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))
{
  uint64_t v1;
  NSObject *v2;

  qword_10098FC30 = 0;
  off_10098FC38 = a1;
  v1 = sub_1001DC46C(5, 2, 6, 3u, &qword_10098FC30, (uint64_t)sub_10022FA14);
  if ((_DWORD)v1 || !qword_10098FC30)
  {
    if (sub_10005549C())
    {
      sub_100054530("Could not register the LE signal channel : %!", v1);
      v2 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  else
  {
    *(_WORD *)sub_1001E40C4(qword_10098FC30) = 23;
    *(_WORD *)(sub_1001E40C4(qword_10098FC30) + 2) = -1;
  }
  return v1;
}

void sub_10022FA14(__int128 *a1, unsigned __int16 *a2, unsigned int a3, uint64_t a4)
{
  NSObject *v8;
  NSObject *v9;
  NSObject *v10;
  int v11;
  char v12;
  int v13;
  NSObject *v14;
  NSObject *v15;

  if (sub_10019AC00((uint64_t)a1))
  {
    if (a2)
    {
      if (a3 > 3)
      {
        v11 = a2[1];
        if (a3 - 4 == v11)
        {
          v12 = *((_BYTE *)a2 + 1);
          v13 = *(unsigned __int8 *)a2;
          switch(*(_BYTE *)a2)
          {
            case 6:
              sub_1002304BC(a1, *((_BYTE *)a2 + 1), a2 + 2, v11);
              break;
            case 7:
              sub_100230548((uint64_t)a1, *((unsigned __int8 *)a2 + 1), a2 + 2, v11);
              break;
            case 8:
            case 9:
            case 0xA:
            case 0xB:
            case 0xC:
            case 0xD:
            case 0xE:
            case 0xF:
            case 0x10:
            case 0x11:
              goto LABEL_20;
            case 0x12:
              sub_10022FD68((uint64_t)a1, *((unsigned __int8 *)a2 + 1), a2 + 2, v11, a4);
              break;
            case 0x13:
              return;
            case 0x14:
              sub_10023029C((uint64_t)a1, *((unsigned __int8 *)a2 + 1), a2 + 2, v11, a4);
              break;
            case 0x15:
              sub_10023033C((uint64_t)a1, *((unsigned __int8 *)a2 + 1), (uint64_t)(a2 + 2), v11);
              break;
            case 0x16:
              sub_1002303D8((uint64_t)a1, a2 + 2, a2[1]);
              break;
            default:
              if (v13 != 1)
              {
LABEL_20:
                if (sub_10005549C())
                {
                  sub_100054530("LE Signaling channel error : invalid opcode %d", v13);
                  v15 = sub_1000544A0(0x42u);
                  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
                    sub_1006CE7A4();
                }
                sub_10022E5D4(a1, v12, 0);
              }
              break;
          }
        }
        else if (sub_10005549C())
        {
          sub_100054530("LE Signaling channel error : corrupted packet size");
          v14 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
            goto LABEL_18;
        }
      }
      else if (sub_10005549C())
      {
        sub_100054530("LE Signaling channel error : invalid packet size");
        v8 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
LABEL_18:
          sub_1006CE7A4();
      }
    }
    else if (sub_10005549C())
    {
      sub_100054530("LE Signaling channel error : invalid data on");
      v10 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        goto LABEL_18;
    }
  }
  else if (sub_10005549C())
  {
    sub_100054530("LE Signaling channel error : not a LE handle.");
    v9 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      goto LABEL_18;
  }
}

uint64_t sub_10022FCE0()
{
  uint64_t v0;
  NSObject *v1;

  v0 = sub_1001DC658(qword_10098FC30);
  if ((_DWORD)v0)
  {
    if (sub_10005549C())
    {
      sub_100054530("Could not de-register the LE signal channel : %!", v0);
      v1 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  qword_10098FC30 = 0;
  return v0;
}

void sub_10022FD68(uint64_t a1, uint64_t a2, unsigned __int16 *a3, int a4, uint64_t a5)
{
  char v5;
  NSObject *v7;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  NSObject *v14;
  NSObject *v15;
  NSObject *v16;
  NSObject *v17;
  NSObject *v18;
  NSObject *v19;
  double v20;
  NSObject *v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  NSObject *v25;
  NSObject *v26;

  v5 = a2;
  if (*(_BYTE *)(a1 + 70) == 1)
  {
    if (sub_10005549C())
    {
      sub_100054530("This command should only be received if we are central.");
      v7 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    sub_10022E5D4((__int128 *)a1, v5, 0);
    return;
  }
  if (a4 == 8)
  {
    v9 = *a3;
    v10 = a3[1];
    v11 = a3[2];
    v12 = a3[3];
    if (off_10098FC38)
    {
      v13 = off_10098FC38(a1, a2, *a3, v10, v11, v12, 0, a5);
      if (!v13)
        return;
      if (v13 != 121)
        goto LABEL_57;
    }
    if ((unsigned __int16)(v9 - 3201) > 0xF384u)
    {
      if ((unsigned __int16)(v10 - 3201) > 0xF384u)
      {
        if (v9 <= v10)
        {
          if (v11 < 0x1F5)
          {
            if ((unsigned __int16)(v12 - 3201) > 0xF388u)
            {
              v20 = (double)v10 * 1.25;
              if (v20 * (double)((int)v11 + 1) <= 2000.0)
              {
                if ((double)v9 * 1.25 >= 10.0)
                {
                  if ((double)(int)(v10 - v9) * 1.25 >= 10.0)
                  {
                    if (v11 < 5)
                    {
                      if (v12 < 0x259)
                      {
                        if (v20 * (double)(3 * ((int)v11 + 1)) <= (double)(10 * (int)v12))
                        {
                          sub_10022E73C((__int128 *)a1, v5, 0, v9, v10, v11, v12, 0, 0);
                          return;
                        }
                        if (!sub_10005549C())
                          goto LABEL_57;
                        sub_100054530("Remote sides asks for a timeout(%dms) / latency(%d) / maxInterval(%dms) that would cause link timeouts under bad conditions. - refusing.", 10 * v12, v11, COERCE_UNSIGNED_INT64((double)v10 * 1.25));
                        v26 = sub_1000544A0(0x42u);
                        if (!os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
                          goto LABEL_57;
                      }
                      else
                      {
                        if (!sub_10005549C())
                          goto LABEL_57;
                        sub_100054530("Remote sides asks for a timeout of more than 6 seconds, this is not very user friendly - refusing.");
                        v25 = sub_1000544A0(0x42u);
                        if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
                          goto LABEL_57;
                      }
                    }
                    else
                    {
                      if (!sub_10005549C())
                        goto LABEL_57;
                      sub_100054530("Remote side wants a peripheral latency more than 4 so we drain our battery and they don't - refusing.");
                      v24 = sub_1000544A0(0x42u);
                      if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
                        goto LABEL_57;
                    }
                  }
                  else
                  {
                    if (!sub_10005549C())
                      goto LABEL_57;
                    sub_100054530("Intervals should be %d ms apart - refusing.", 10);
                    v23 = sub_1000544A0(0x42u);
                    if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
                      goto LABEL_57;
                  }
                }
                else
                {
                  if (!sub_10005549C())
                    goto LABEL_57;
                  sub_100054530("Remote side wants a min interval smaller than 20 ms. Let's refuse and not drain the battery...");
                  v22 = sub_1000544A0(0x42u);
                  if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
                    goto LABEL_57;
                }
              }
              else
              {
                if (!sub_10005549C())
                  goto LABEL_57;
                sub_100054530("Remote side wants an interval / latency combination that would provide a poor user experience (more than 2seconds syncups.)");
                v21 = sub_1000544A0(0x42u);
                if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
                  goto LABEL_57;
              }
            }
            else
            {
              if (!sub_10005549C())
                goto LABEL_57;
              sub_100054530("Invalid timeout multiplier %d.", v12);
              v19 = sub_1000544A0(0x42u);
              if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
                goto LABEL_57;
            }
          }
          else
          {
            if (!sub_10005549C())
              goto LABEL_57;
            sub_100054530("Invalid peripheral latency %d.", v11);
            v18 = sub_1000544A0(0x42u);
            if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
              goto LABEL_57;
          }
        }
        else
        {
          if (!sub_10005549C())
            goto LABEL_57;
          sub_100054530("Maximum interval is smaller than minimum interval : %d > %d.", v9, v10);
          v17 = sub_1000544A0(0x42u);
          if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
            goto LABEL_57;
        }
      }
      else
      {
        if (!sub_10005549C())
          goto LABEL_57;
        sub_100054530("Invalid maximum interval %d.", v10);
        v16 = sub_1000544A0(0x42u);
        if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          goto LABEL_57;
      }
    }
    else
    {
      if (!sub_10005549C())
        goto LABEL_57;
      sub_100054530("Invalid minimum interval %d.", v9);
      v14 = sub_1000544A0(0x42u);
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        goto LABEL_57;
    }
    sub_1006CE7A4();
LABEL_57:
    sub_10022E73C((__int128 *)a1, v5, 1, 0, 0, 0, 0, 0, 0);
    return;
  }
  if (sub_10005549C())
  {
    sub_100054530("Invalid size in parameter update request : %d", a4);
    v15 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
}

void sub_10023029C(uint64_t a1, uint64_t a2, unsigned __int16 *a3, int a4, uint64_t a5)
{
  NSObject *v6;

  if (a4 == 10)
  {
    sub_1001E204C(a1, *a3, a3[1], a3[2], a3[3], a3[4], a2, a5);
  }
  else if (sub_10005549C())
  {
    sub_100054530("Invalid size in LE Connection Oriented L2CAP Channel connection request : %d", a4);
    v6 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
}

void sub_10023033C(uint64_t a1, int a2, uint64_t a3, int a4)
{
  NSObject *v5;

  if (a4 == 10)
  {
    sub_1001E2494(a1, *(_WORD *)a3, *(unsigned __int16 *)(a3 + 2), *(unsigned __int16 *)(a3 + 4), *(unsigned __int16 *)(a3 + 6), *(unsigned __int16 *)(a3 + 8), a2);
  }
  else if (sub_10005549C())
  {
    sub_100054530("Invalid size in LE Connection Oriented L2CAP Channel connection response : %d", a4);
    v5 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
}

void sub_1002303D8(uint64_t a1, unsigned __int16 *a2, int a3)
{
  int v3;
  int v4;
  NSObject *v6;
  NSObject *v7;
  uint64_t v8;

  v8 = 0;
  if (a3 == 4)
  {
    v3 = *((unsigned __int8 *)a2 + 2);
    v4 = *((unsigned __int8 *)a2 + 3);
    sub_1001DB410(*a2, a1, &v8);
    if (v8)
    {
      sub_1001D8118(v8, v3 | (v4 << 8));
    }
    else if (sub_10005549C())
    {
      sub_100054530("Credits for an invalid channel CID");
      v7 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  else if (sub_10005549C())
  {
    sub_100054530("Invalid size in LEConnection Oriented L2CAP Channel connection Flow Credit : %d", a3);
    v6 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
}

void sub_1002304BC(__int128 *a1, char a2, unsigned __int16 *a3, int a4)
{
  NSObject *v5;

  if (a4 == 4)
  {
    sub_1001E1BD4(a1, *a3, a3[1], a2);
  }
  else if (sub_10005549C())
  {
    sub_100054530("Invalid size in Disconnect request : %d", a4);
    v5 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
}

void sub_100230548(uint64_t a1, uint64_t a2, unsigned __int16 *a3, int a4)
{
  NSObject *v5;

  if (a4 == 4)
  {
    sub_1001E1F20(a1, a3[1], *a3);
  }
  else if (sub_10005549C())
  {
    sub_100054530("Invalid size in Disconnect response : %d", a4);
    v5 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
}

uint64_t sub_1002305D8(_DWORD *a1)
{
  uint64_t v1;
  __int128 *v2;
  uint64_t v3;
  unint64_t v4;
  char v5;
  NSObject *v7;
  NSObject *v8;

  v1 = sub_10019AFA0(a1);
  if (!v1)
    return 122;
  v2 = (__int128 *)v1;
  if (!sub_10019AC00(v1))
  {
    if (sub_10005549C())
    {
      sub_100054530("This command is only available to LE devices.");
      v7 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 122;
  }
  v3 = sub_1001EE0AC((uint64_t)v2);
  if (v3)
  {
    v4 = *(unsigned int *)(v3 + 52);
    if (v4 >= 6)
      v5 = 8;
    else
      v5 = 0x20C01010108uLL >> (8 * v4);
    return sub_1002306D8(v2, v5 & 0xF, (char *)v3);
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("This device is not in a pairing state.");
      v8 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 4806;
  }
}

uint64_t sub_1002306D8(__int128 *a1, int a2, char *a3)
{
  char v4;
  char v5;
  uint64_t v6;
  uint64_t v7;
  __int16 v9;

  v4 = a2;
  v9 = 5;
  if (a2 == 240)
    v5 = 8;
  else
    v5 = a2;
  HIBYTE(v9) = v5;
  v6 = sub_1001EE0F4(a1, (char *)&v9, 2uLL, 0);
  if (a3)
  {
    v7 = sub_1001EE568(v4);
    sub_1001EDD30(a3, v7, 1);
  }
  return v6;
}

uint64_t sub_100230754(uint64_t result)
{
  uint64_t v1;
  NSObject *v2;

  if (result)
  {
    v1 = result;
    if (sub_10019AC00(result))
    {
      result = sub_1001EE0AC(v1);
      if (result)
        return *(_BYTE *)(result + 8) != 0;
    }
    else
    {
      result = sub_10005549C();
      if ((_DWORD)result)
      {
        sub_100054530("This command is only available to LE devices.");
        v2 = sub_1000544A0(0x43u);
        result = os_log_type_enabled(v2, OS_LOG_TYPE_ERROR);
        if ((_DWORD)result)
        {
          sub_1006CE7A4();
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t sub_1002307DC(_DWORD *a1)
{
  uint64_t v1;

  v1 = sub_10019AFA0(a1);
  return sub_100230754(v1);
}

uint64_t sub_1002307F0(_DWORD *a1, unsigned int a2)
{
  __int128 v3;

  HIDWORD(v3) = 0;
  *(_QWORD *)((char *)&v3 + 4) = 0;
  if (a2 > 0xF423F)
    return 101;
  LOWORD(v3) = a2;
  WORD1(v3) = BYTE2(a2);
  return sub_100230874(a1, &v3);
}

uint64_t sub_100230874(_DWORD *a1, _OWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  NSObject *v16;
  NSObject *v17;
  NSObject *v18;
  uint64_t v19;
  NSObject *v20;
  NSObject *v21;
  NSObject *v23;
  _OWORD *v24;
  _OWORD *v25;
  uint64_t v26;
  NSObject *v27;
  __int128 v28;
  __int128 v29;
  char v30;
  _BYTE __s1[65];

  v3 = sub_10019AFA0(a1);
  if (!v3)
    return 122;
  v4 = v3;
  v5 = sub_1001EE0AC(v3);
  if (!v5)
    return 4806;
  v12 = v5;
  *(_BYTE *)(v5 + 490) = 1;
  if ((*(_BYTE *)(v5 + 72) & *(_BYTE *)(v5 + 80) & 8) != 0)
  {
    switch(*(_BYTE *)(v5 + 16))
    {
      case 1:
        if (*(_BYTE *)(*(_QWORD *)v5 + 70))
        {
          memset(__s1, 0, 64);
          if (!memcmp(__s1, (const void *)(v5 + 312), 0x40uLL))
            return 0;
          v19 = sub_100230FF0(v12);
          if (!(_DWORD)v19)
            return 0;
          v13 = v19;
          if (sub_10005549C())
          {
            sub_100054530("recvdSMPDeferredJustWorksNumComparPublicKey failed %!", v13);
            v20 = sub_1000544A0(0x43u);
            if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
              sub_1006CEEC0();
          }
          goto LABEL_37;
        }
        v30 = 96;
        v24 = (_OWORD *)(v5 + 152);
        v25 = (_OWORD *)(v5 + 216);
        v26 = sub_1001859C0((_OWORD *)(v5 + 152), (_OWORD *)(v5 + 216), (uint64_t)&v30, v6, v7, v8, v9, v10);
        if ((_DWORD)v26)
        {
          v13 = v26;
          *(_OWORD *)(v12 + 184) = 0u;
          *(_OWORD *)(v12 + 200) = 0u;
          *v24 = 0u;
          *(_OWORD *)(v12 + 168) = 0u;
          *v25 = 0u;
          *(_OWORD *)(v12 + 232) = 0u;
          *(_OWORD *)(v12 + 248) = 0u;
          *(_OWORD *)(v12 + 264) = 0u;
          *(_OWORD *)(v12 + 280) = 0u;
          *(_OWORD *)(v12 + 296) = 0u;
        }
        else
        {
          sub_1001EE5A0(v12, 33);
          __s1[0] = 12;
          v28 = *(_OWORD *)(v12 + 168);
          *(_OWORD *)&__s1[1] = *v24;
          *(_OWORD *)&__s1[17] = v28;
          v29 = *(_OWORD *)(v12 + 200);
          *(_OWORD *)&__s1[33] = *(_OWORD *)(v12 + 184);
          *(_OWORD *)&__s1[49] = v29;
          return sub_1001EE0F4(*(__int128 **)v12, __s1, 0x41uLL, 1);
        }
        return v13;
      case 2:
      case 3:
      case 4:
        *(_OWORD *)(v5 + 425) = *a2;
        *(_OWORD *)(v5 + 441) = *a2;
        v13 = sub_10023122C(v5);
        if ((_DWORD)v13)
        {
          if (!sub_10005549C())
            goto LABEL_37;
          sub_100054530("smpDoOneLeSecuredConnectionPasskeyAuthItteration failed %!", v13);
          v14 = sub_1000544A0(0x43u);
          if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
            goto LABEL_37;
          break;
        }
        return v13;
      case 5:
        if (!sub_10005549C())
          goto LABEL_36;
        sub_100054530("Wrong API for OOB");
        v21 = sub_1000544A0(0x43u);
        if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          goto LABEL_36;
        goto LABEL_35;
      case 6:
        if (*(_BYTE *)(*(_QWORD *)v5 + 70))
        {
          if (!*(_BYTE *)(v5 + 491))
            return 0;
          v13 = sub_100230DFC((__int128 *)v4);
          if (!(_DWORD)v13)
            return v13;
          if (!sub_10005549C())
            goto LABEL_37;
          sub_100054530("recvdSMPDeferredDHKeyCheck Failed %!", v13);
          v23 = sub_1000544A0(0x43u);
          if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
            goto LABEL_37;
        }
        else
        {
          v13 = sub_100230D24((__int128 **)v5);
          if (!(_DWORD)v13)
            return v13;
          if (!sub_10005549C())
            goto LABEL_37;
          sub_100054530("Failed to send DHKey value with status %!", v13);
          v27 = sub_1000544A0(0x43u);
          if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
            goto LABEL_37;
        }
        break;
      default:
        if (sub_10005549C())
        {
          sub_100054530("wrong API for STKGENMethod=%d", *(unsigned __int8 *)(v12 + 16));
          v18 = sub_1000544A0(0x43u);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
LABEL_35:
            sub_1006CE7A4();
        }
LABEL_36:
        v13 = 4800;
        goto LABEL_37;
    }
LABEL_52:
    sub_1006CEEC0();
LABEL_37:
    sub_1002306D8((__int128 *)v4, 8, (char *)v12);
    return v13;
  }
  if (*(_BYTE *)(v5 + 16) != 1 && *(_OWORD *)(v5 + 17) == 0)
  {
    v11 = *a2;
    *(_OWORD *)(v5 + 17) = *a2;
  }
  v15 = sub_1002314D4(v5, 0, (void *)(v5 + 88), *(uint8x8_t *)&v11);
  if ((_DWORD)v15)
  {
    v13 = v15;
    if (!sub_10005549C())
      goto LABEL_37;
    sub_100054530("Could not generate confirmation value with status %!", v13);
    v16 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      goto LABEL_37;
    goto LABEL_52;
  }
  if (*(_BYTE *)(v4 + 70) && *(_DWORD *)(v12 + 84) != 1)
  {
    v13 = 0;
    *(_DWORD *)(v12 + 84) = 2;
    return v13;
  }
  v13 = sub_100231670(v4, (_QWORD *)(v12 + 88));
  if ((_DWORD)v13)
  {
    if (!sub_10005549C())
      goto LABEL_37;
    sub_100054530("Could not send pairing confirmation to handle 0x%x with status %!", v4, v13);
    v17 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      goto LABEL_37;
    goto LABEL_52;
  }
  return v13;
}

uint64_t sub_100230D24(__int128 **a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  __int128 v6;
  char v7;
  __int128 v8;

  v6 = 0uLL;
  v2 = sub_10023928C(a1, &v6, 1);
  if ((_DWORD)v2)
  {
    v3 = v2;
    if (sub_10005549C())
    {
      sub_100054530("smpAuthenticationStage2 failed %!", v3);
      v4 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  else
  {
    v7 = 13;
    v8 = v6;
    return sub_1001EE0F4(*a1, &v7, 0x11uLL, 1);
  }
  return v3;
}

uint64_t sub_100230DFC(__int128 *a1)
{
  _BYTE *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  char v12;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v15 = 0;
  v16 = 0;
  v2 = (_BYTE *)sub_1001EE0AC((uint64_t)a1);
  v3 = (uint64_t)v2;
  if (!v2)
  {
    if (sub_10005549C())
    {
      sub_100054530("Could not find associated pairing data.");
      v10 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    v9 = 0;
    goto LABEL_27;
  }
  v4 = sub_10023928C(v2, &v15, 0);
  if ((_DWORD)v4)
  {
    v5 = v4;
    if (sub_10005549C())
    {
      sub_100054530("smpAuthenticationStage2 failed %!", v5);
      v6 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  if (v15 != *(_QWORD *)(v3 + 492) || v16 != *(_QWORD *)(v3 + 500))
  {
    if (sub_10005549C())
    {
      sub_100054530("DHKey failed to match.");
      v8 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    sub_1002306D8(a1, 11, (char *)v3);
    return 0;
  }
  if (*(_BYTE *)(v3 + 424))
    sub_1001EE5A0(v3, 41);
  if (*(_BYTE *)(*(_QWORD *)v3 + 70) == 1)
  {
    v11 = sub_100230D24((__int128 **)v3);
  }
  else
  {
    v14 = 0;
    if (*(_BYTE *)(v3 + 16) == 1)
      v12 = 2;
    else
      v12 = 3;
    v11 = sub_10022D498(a1, (uint64_t)&v14, 0, v3 + 524, 0x10u, v12);
  }
  v9 = v11;
  if ((_DWORD)v11)
LABEL_27:
    sub_1002306D8(a1, 8, (char *)v3);
  return v9;
}

uint64_t sub_100230FF0(uint64_t a1)
{
  __int128 *v2;
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  void *v6;
  __int128 v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  NSObject *v13;
  _OWORD v14[2];
  _BYTE v15[33];
  __int128 v16;
  __int128 v17;

  sub_1001EE4C0((uint64_t *)a1);
  v2 = *(__int128 **)a1;
  if (*(_BYTE *)(*(_QWORD *)a1 + 70) == 1)
  {
    v15[0] = 12;
    *(_OWORD *)&v15[1] = *(_OWORD *)(a1 + 152);
    *(_OWORD *)&v15[17] = *(_OWORD *)(a1 + 168);
    v16 = *(_OWORD *)(a1 + 184);
    v17 = *(_OWORD *)(a1 + 200);
    v3 = sub_1001EE0F4(v2, v15, 0x41uLL, 1);
    if ((_DWORD)v3)
    {
      v4 = v3;
      if (sub_10005549C())
      {
        sub_100054530("smpSendPairingPublicKey failed %!", v4);
        v5 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
          sub_1006CEEC0();
      }
      return v4;
    }
    sub_1001EE5A0(a1, 34);
    v6 = (void *)(a1 + 473);
  }
  else
  {
    v6 = (void *)(a1 + 457);
  }
  arc4random_buf(v6, 0x10uLL);
  *(_QWORD *)(a1 + 433) = 0;
  *(_QWORD *)(a1 + 425) = 0;
  *(_QWORD *)(a1 + 449) = 0;
  *(_QWORD *)(a1 + 441) = 0;
  if (*(_BYTE *)(*(_QWORD *)a1 + 70))
  {
    v7 = *(_OWORD *)(a1 + 328);
    *(_OWORD *)v15 = *(_OWORD *)(a1 + 312);
    *(_OWORD *)&v15[16] = v7;
    v8 = *(_OWORD *)(a1 + 168);
    v14[0] = *(_OWORD *)(a1 + 152);
    v14[1] = v8;
    v9 = sub_100184FB4(v14, v15, (__int128 *)(a1 + 473), 0, (void *)(a1 + 88));
    if ((_DWORD)v9)
    {
      v10 = v9;
      if (sub_10005549C())
      {
        sub_100054530("Failed to generate confirmation value %!", v10);
        v11 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          sub_1006CEEC0();
      }
      return 4825;
    }
    else
    {
      sub_1001EE4C0((uint64_t *)a1);
      v4 = sub_100231670(*(_QWORD *)a1, (_QWORD *)(a1 + 88));
      if ((_DWORD)v4)
      {
        if (sub_10005549C())
        {
          sub_100054530("Failed to send confirmation value %!", v4);
          v13 = sub_1000544A0(0x43u);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
            sub_1006CEEC0();
        }
      }
    }
  }
  else
  {
    sub_1001EE5A0(a1, 35);
    return 0;
  }
  return v4;
}

uint64_t sub_10023122C(uint64_t a1)
{
  _QWORD *v2;
  __int128 *v3;
  __int128 *v4;
  unsigned int v5;
  char v6;
  __int128 v7;
  __int128 v8;
  char v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  unsigned int v13;
  char v14;
  __int128 v15;
  __int128 v16;
  char v17;
  uint64_t v18;
  NSObject *v19;
  BOOL v20;
  uint64_t v21;
  NSObject *v22;
  NSObject *v23;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;

  v2 = (_QWORD *)(a1 + 88);
  v3 = (__int128 *)(a1 + 312);
  v4 = (__int128 *)(a1 + 152);
  if (*(_BYTE *)(*(_QWORD *)a1 + 70))
  {
    v5 = *(_DWORD *)(a1 + 441);
    arc4random_buf((void *)(a1 + 473), 0x10uLL);
    v6 = *(_BYTE *)(a1 + 489);
    v7 = v3[1];
    v27 = *v3;
    v28 = v7;
    v8 = v4[1];
    v25 = *v4;
    v26 = v8;
    if (((v5 >> v6) & 1) != 0)
      v9 = -127;
    else
      v9 = 0x80;
    v10 = sub_100184FB4(&v25, &v27, (__int128 *)(a1 + 473), v9, v2);
    if ((_DWORD)v10)
    {
      v11 = v10;
      if (sub_10005549C())
      {
        sub_100054530("Failed to generate confirmation value C %!", v11);
        v12 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
LABEL_29:
          sub_1006CEEC0();
      }
    }
    else
    {
      sub_1001EE5A0(a1, 34);
      if (*(_BYTE *)(a1 + 490)
        && (!*(_QWORD *)(a1 + 104) ? (v20 = *(_QWORD *)(a1 + 112) == 0) : (v20 = 0),
            !v20 && (v21 = sub_10023906C((uint64_t *)a1), (_DWORD)v21)))
      {
        v11 = v21;
        if (sub_10005549C())
        {
          sub_100054530("recvdSMPDoSecuredConnectionPasskeySendCai failed %!", v11);
          v22 = sub_1000544A0(0x43u);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
            goto LABEL_29;
        }
      }
      else
      {
        return 0;
      }
    }
  }
  else
  {
    v13 = *(_DWORD *)(a1 + 425);
    arc4random_buf((void *)(a1 + 457), 0x10uLL);
    v14 = *(_BYTE *)(a1 + 489);
    v15 = v3[1];
    v25 = *v3;
    v26 = v15;
    v16 = v4[1];
    v27 = *v4;
    v28 = v16;
    if (((v13 >> v14) & 1) != 0)
      v17 = -127;
    else
      v17 = 0x80;
    v18 = sub_100184FB4(&v27, &v25, (__int128 *)(a1 + 457), v17, v2);
    if ((_DWORD)v18)
    {
      v11 = v18;
      if (sub_10005549C())
      {
        sub_100054530("Failed to generate confirmation value C %!", v11);
        v19 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          goto LABEL_29;
      }
    }
    else
    {
      sub_1001EE5A0(a1, 35);
      v11 = sub_100231670(*(_QWORD *)a1, v2);
      if ((_DWORD)v11)
      {
        if (sub_10005549C())
        {
          sub_100054530("smpSendPairingConfirmation failed %!", v11);
          v23 = sub_1000544A0(0x43u);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
            goto LABEL_29;
        }
      }
    }
  }
  return v11;
}

uint64_t sub_1002314D4(uint64_t a1, int a2, void *a3, uint8x8_t a4)
{
  __int8 *v4;
  __int32 *v5;
  __int32 *v6;
  int16x8_t v7;
  __int8 *v8;
  __int8 *v9;
  __int8 *v10;
  __int8 *v11;
  int16x8_t v12;
  __int8 v13;
  __int8 v14;
  __int8 v15;
  int8x16_t v17;
  int8x16_t v18;

  v18 = 0uLL;
  v17 = 0uLL;
  v4 = *(__int8 **)a1;
  v5 = (__int32 *)(a1 + 579);
  v6 = (__int32 *)(a1 + 586);
  if (*(_BYTE *)(*(_QWORD *)a1 + 70))
  {
    v18.i8[0] = v4[48];
    v18.i8[1] = v4[63];
    *(__int32 *)((char *)v18.i32 + 2) = *v5;
    *(__int32 *)((char *)&v18.i32[1] + 1) = *(_DWORD *)(a1 + 582);
    *(__int32 *)((char *)&v18.i32[2] + 1) = *v6;
    v18.i32[3] = *(_DWORD *)(a1 + 589);
    a4.i32[0] = *(_DWORD *)(v4 + 66);
    v7 = (int16x8_t)vmovl_u8(a4);
    *(int16x4_t *)v7.i8 = vrev64_s16(*(int16x4_t *)v7.i8);
    v17.i32[0] = vmovn_s16(v7).u32[0];
    v17.i8[4] = v4[65];
    v17.i8[5] = v4[64];
    v8 = v4 + 49;
    v17.i8[6] = v4[54];
    v17.i8[7] = v4[53];
    v9 = v4 + 52;
    v10 = v4 + 51;
    v11 = v4 + 50;
  }
  else
  {
    v18.i8[0] = v4[63];
    v18.i8[1] = v4[48];
    *(__int32 *)((char *)v18.i32 + 2) = *v5;
    *(__int32 *)((char *)&v18.i32[1] + 1) = *(_DWORD *)(a1 + 582);
    *(__int32 *)((char *)&v18.i32[2] + 1) = *v6;
    v18.i32[3] = *(_DWORD *)(a1 + 589);
    a4.i32[0] = *(_DWORD *)(v4 + 51);
    v12 = (int16x8_t)vmovl_u8(a4);
    *(int16x4_t *)v12.i8 = vrev64_s16(*(int16x4_t *)v12.i8);
    v17.i32[0] = vmovn_s16(v12).u32[0];
    v17.i8[4] = v4[50];
    v17.i8[5] = v4[49];
    v8 = v4 + 64;
    v17.i8[6] = v4[69];
    v17.i8[7] = v4[68];
    v9 = v4 + 67;
    v10 = v4 + 66;
    v11 = v4 + 65;
  }
  v13 = *v8;
  v14 = *v11;
  v15 = *v10;
  v17.i8[8] = *v9;
  v17.i8[9] = v15;
  v17.i8[10] = v14;
  v17.i8[11] = v13;
  return sub_100184A2C((__int128 *)(a1 + 17), &v18, &v17, (int8x16_t *)(a1 + 136), (int8x16_t *)(a1 + 120), a2, a3);
}

uint64_t sub_100231670(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  const char *v6;
  NSObject *v7;
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  char v14;
  const char *v15;
  NSObject *v16;
  const char *v17;
  NSObject *v18;
  const char *v19;
  NSObject *v20;
  NSObject *v22;
  char v23;
  __int128 v24;

  if (byte_10098FC91)
  {
    *a2 = 0;
    a2[1] = 0;
  }
  v23 = 3;
  v24 = *(_OWORD *)a2;
  if (sub_10019AC00(a1))
  {
    v3 = sub_1001EE0AC(a1);
    if (v3)
    {
      v4 = v3;
      v5 = *(unsigned __int8 *)(a1 + 70);
      if ((*(_BYTE *)(v3 + 72) & *(_BYTE *)(v3 + 80) & 8) != 0)
      {
        if (v5 != 1)
        {
LABEL_9:
          if (!v5 && !sub_1001EE68C(v4, 35))
          {
            if (!sub_10005549C())
              return 4823;
            v6 = sub_1001EE594();
            sub_100054530("Central connection should be in SMP_STATE_PAIRING_SCONFIRM to send this command, current state is %s.", v6);
            v7 = sub_1000544A0(0x43u);
            if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
              return 4823;
            goto LABEL_44;
          }
LABEL_26:
          v11 = sub_1001EE0F4(*(__int128 **)v4, &v23, 0x11uLL, 1);
          if ((_DWORD)v11)
          {
            v9 = v11;
            sub_1001EDD30((char *)v4, v11, 1);
            return v9;
          }
          if ((*(_BYTE *)(v4 + 72) & *(_BYTE *)(v4 + 80) & 8) != 0)
          {
            v12 = *(unsigned __int8 *)(v4 + 16);
            switch(v12)
            {
              case 6:
                goto LABEL_32;
              case 5:
                if (sub_10005549C())
                {
                  sub_100054530("Should not be here !");
                  v22 = sub_1000544A0(0x43u);
                  if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
                    sub_1006CE7A4();
                }
                sub_1001EDD30((char *)v4, 408, 1);
                return 0;
              case 1:
LABEL_32:
                v13 = v4;
                v14 = 36;
LABEL_55:
                sub_1001EE5A0(v13, v14);
                return 0;
            }
            if (*(_BYTE *)(*(_QWORD *)v4 + 70) == 1)
              v14 = 36;
            else
              v14 = 35;
          }
          else if (*(_BYTE *)(a1 + 70))
          {
            v14 = 35;
          }
          else
          {
            v14 = 34;
          }
          v13 = v4;
          goto LABEL_55;
        }
        if (sub_1001EE68C(v3, 34))
        {
          v5 = *(unsigned __int8 *)(a1 + 70);
          goto LABEL_9;
        }
        if (!sub_10005549C())
          return 4823;
        v15 = sub_1001EE594();
        sub_100054530("Peripheral connection should be in SMP_STATE_PAIRING_MPUBLICK to send this command, current state is %s.", v15);
        v16 = sub_1000544A0(0x43u);
        if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          return 4823;
      }
      else
      {
        if (!*(_BYTE *)(a1 + 70))
        {
          if (!sub_1001EE68C(v3, 18))
          {
            if (!sub_10005549C())
              return 4823;
            v19 = sub_1001EE594();
            sub_100054530("Central connection should be in SMP_STATE_PAIRING_RESP to send this command, current state is %s.", v19);
            v20 = sub_1000544A0(0x43u);
            if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
              return 4823;
            goto LABEL_44;
          }
          v5 = *(unsigned __int8 *)(a1 + 70);
        }
        if (v5 != 1 || sub_1001EE68C(v4, 34))
          goto LABEL_26;
        if (!sub_10005549C())
          return 4823;
        v17 = sub_1001EE594();
        sub_100054530("Peripheral connection should be in SMP_STATE_PAIRING_MCONFIRM to send this command, current state is %s.", v17);
        v18 = sub_1000544A0(0x43u);
        if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          return 4823;
      }
    }
    else
    {
      if (!sub_10005549C())
        return 4823;
      sub_100054530("This device is not in a pairing state.");
      v10 = sub_1000544A0(0x43u);
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        return 4823;
    }
LABEL_44:
    sub_1006CE7A4();
    return 4823;
  }
  if (sub_10005549C())
  {
    sub_100054530("This command is only available to LE devices.");
    v8 = sub_1000544A0(0x43u);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  return 4820;
}

uint64_t sub_100231A2C(uint64_t a1, int a2, unsigned __int8 a3)
{
  char v3;
  char v4;
  char v5;
  char v6;
  char v7;
  char v8;
  uint64_t v12;
  char *v13;
  _DWORD *v14;
  BOOL v15;
  char v16;
  NSObject *v17;
  NSObject *v18;
  uint64_t result;
  NSObject *v20;
  unsigned __int8 v21;
  char v22;
  NSObject *v23;
  void *v24;
  NSObject *v25;
  void *v26;
  uint8_t v27;
  uint8_t v28;
  char v29;
  char v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  NSObject *v34;
  NSObject *v35;
  const char *v36;
  NSObject *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  int v45;
  int v46;
  char v47;
  uint8_t buf[4];
  void *v49;

  v3 = byte_10097A8E1;
  if (byte_10097A8E1 == 255)
    v3 = 11;
  if (byte_10097A8E2 == 255)
    v4 = 11;
  else
    v4 = byte_10097A8E2;
  v5 = v3 & 0xF7;
  v6 = v4 & 0xF7;
  if (byte_10098FC40)
    v7 = v3 & 0xF7;
  else
    v7 = v3;
  if (byte_10098FC40)
    v8 = v4 & 0xF7;
  else
    v8 = v4;
  if (!a1 || !sub_10019AC00(a1))
  {
    if (!sub_10005549C())
      return 4820;
    sub_100054530("This handle is not a LE connection.");
    v18 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      return 4820;
LABEL_34:
    sub_1006CE7A4();
    return 4820;
  }
  v12 = sub_1001EE0AC(a1);
  if (!v12)
  {
    if (!sub_10005549C())
      return 4820;
    sub_100054530("There is no security request for this connection. Ignoring reply.");
    v20 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      return 4820;
    goto LABEL_34;
  }
  v13 = (char *)v12;
  *(_BYTE *)(v12 + 72) = a3;
  if (!a2)
  {
LABEL_73:
    sub_1002306D8((__int128 *)a1, 8, v13);
    return 0;
  }
  if (*(_BYTE *)(a1 + 55))
    v14 = (_DWORD *)(a1 + 56);
  else
    v14 = 0;
  v15 = sub_10022CCE0((_DWORD *)(a1 + 48), v14);
  v16 = v13[80];
  if ((v16 & 4) != 0 && byte_10097A8E3 != 3)
    v13[72] |= 4u;
  if ((v16 & 8) != 0 && byte_10098FC41)
  {
    v13[72] |= 8u;
    if ((byte_10098FC42 & 1) == 0 && (v16 & 0x20) != 0 && !*(_BYTE *)(a1 + 232) && (v7 & 8) != 0)
    {
      if (sub_10005549C())
      {
        sub_100054530("Sending CT2=1");
        v17 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446210;
          v49 = sub_100054494();
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
        }
      }
      a3 |= 0x20u;
    }
  }
  else
  {
    a3 &= ~0x20u;
    v7 = v5;
    v8 = v6;
  }
  if (*(_BYTE *)(a1 + 232))
    v21 = a3 & 0xDF;
  else
    v21 = a3;
  if (*(_BYTE *)(a1 + 232))
  {
    v7 = v5;
    v22 = v6;
  }
  else
  {
    v22 = v8;
  }
  if (byte_10098FC43 == 1 && (v21 & 0x20) == 0)
  {
    if (sub_10005549C())
    {
      sub_100054530("Force sending CT2=1");
      v23 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        v24 = sub_100054494();
        *(_DWORD *)buf = 136446210;
        v49 = v24;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
    v21 |= 0x20u;
  }
  v13[73] = v15;
  v13[76] &= v7;
  v13[74] &= v22;
  v13[72] |= byte_10098FC44 | v21;
  if (sub_10005549C())
  {
    sub_100054530("authReq=%x expectedKeys=%x requestedKeys=%x", v21, v13[74], v13[76]);
    v25 = sub_1000544A0(0x43u);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      v26 = sub_100054494();
      *(_DWORD *)buf = 136446210;
      v49 = v26;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  v27 = v13[73];
  v28 = v13[72];
  v29 = v13[74];
  v30 = v13[76];
  buf[0] = 2;
  buf[1] = byte_10097A8E3;
  buf[2] = v27;
  buf[3] = v28;
  LOBYTE(v49) = 16;
  BYTE1(v49) = v29;
  BYTE2(v49) = v30;
  if (!sub_10019AC00(a1))
  {
    if (!sub_10005549C())
      goto LABEL_73;
    sub_100054530("This command is only available to LE devices.");
    v34 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
      goto LABEL_73;
    goto LABEL_72;
  }
  if (*(_BYTE *)(a1 + 70) != 1)
  {
    if (!sub_10005549C())
      goto LABEL_73;
    sub_100054530("You cannot send this command when central.");
    v35 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      goto LABEL_73;
    goto LABEL_72;
  }
  v31 = sub_1001EE0AC(a1);
  if (!v31)
  {
    if ((sub_10005549C() & 1) == 0)
      goto LABEL_73;
    v36 = "NULL";
    goto LABEL_71;
  }
  v32 = v31;
  if (!sub_1001EE68C(v31, 17))
  {
    if (!sub_10005549C())
      goto LABEL_73;
    v36 = sub_1001EE594();
LABEL_71:
    sub_100054530("Invalid pairing state for handle 0x%x : %s", a1, v36);
    v37 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
      goto LABEL_73;
LABEL_72:
    sub_1006CE7A4();
    goto LABEL_73;
  }
  v33 = sub_1001EE0F4(*(__int128 **)v32, (char *)buf, 7uLL, 1);
  if ((_DWORD)v33)
  {
    sub_1001EDD30((char *)v32, v33, 1);
    goto LABEL_73;
  }
  sub_1001EE5A0(v32, 18);
  *(_DWORD *)(v32 + 586) = *(_DWORD *)buf;
  *(_WORD *)(v32 + 590) = (_WORD)v49;
  *(_BYTE *)(v32 + 592) = BYTE2(v49);
  v44 = v13[72];
  v45 = v13[80];
  v46 = v13[73];
  if ((v44 & v45 & 8) != 0)
  {
    if (v46 == 1)
      goto LABEL_79;
  }
  else if (v46 != 1)
  {
    goto LABEL_80;
  }
  if (v13[79] == 1)
  {
LABEL_79:
    v47 = 5;
    goto LABEL_83;
  }
LABEL_80:
  if (((v45 | v44) & 4) != 0)
    v47 = sub_100232008(v13[78], byte_10097A8E3, (v44 & v45 & 8) != 0);
  else
    v47 = 1;
LABEL_83:
  v13[16] = v47;
  result = sub_100232120((uint64_t)v13, 0, v38, v39, v40, v41, v42, v43);
  if ((_DWORD)result)
    goto LABEL_73;
  return result;
}

uint64_t sub_100232008(int a1, unsigned int a2, int a3)
{
  unint64_t v3;
  BOOL v4;

  switch(a1)
  {
    case 0:
      if (a2 >= 5)
        goto LABEL_14;
      v3 = 0x201020101uLL >> (8 * a2);
      break;
    case 1:
      LOBYTE(v3) = 1;
      switch(a2)
      {
        case 0u:
        case 3u:
          return v3;
        case 1u:
          if (a3)
            LOBYTE(v3) = 6;
          else
            LOBYTE(v3) = 1;
          break;
        case 2u:
          goto LABEL_16;
        case 4u:
          goto LABEL_17;
        default:
          goto LABEL_14;
      }
      break;
    case 2:
      if (a2 >= 5)
        goto LABEL_14;
      v3 = 0x301040303uLL >> (8 * a2);
      break;
    case 3:
      if (a2 >= 5)
        goto LABEL_14;
LABEL_13:
      LOBYTE(v3) = 1;
      break;
    case 4:
      LOBYTE(v3) = 3;
      switch(a2)
      {
        case 0u:
          return v3;
        case 1u:
          v4 = a3 == 0;
          LOBYTE(v3) = 3;
          goto LABEL_18;
        case 2u:
LABEL_16:
          LOBYTE(v3) = 2;
          return v3;
        case 3u:
          goto LABEL_13;
        case 4u:
LABEL_17:
          v4 = a3 == 0;
          LOBYTE(v3) = 2;
LABEL_18:
          if (!v4)
            LOBYTE(v3) = 6;
          break;
        default:
          goto LABEL_14;
      }
      break;
    default:
LABEL_14:
      sub_100253460();
      LOBYTE(v3) = 1;
      break;
  }
  return v3;
}

uint64_t sub_100232120(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v9;
  int v11;
  int v12;
  unsigned int v13;
  char v14;
  NSObject *v15;
  int v16;
  int v17;
  _OWORD *v18;
  uint64_t result;
  NSObject *v20;
  __int128 v21;
  __int128 v22;
  char v23;
  _BYTE __buf[17];
  __int128 v25;
  __int128 v26;
  __int128 v27;

  v9 = *(_BYTE *)(a1 + 80) & *(_BYTE *)(a1 + 72);
  if ((v9 & 8) == 0)
  {
    *(_BYTE *)(a1 + 74) &= ~8u;
    *(_BYTE *)(a1 + 76) &= ~8u;
    arc4random_buf((void *)(a1 + 120), 0x10uLL);
    if (off_1009990F0)
    {
      v11 = *(unsigned __int8 *)(a1 + 16);
      if (v11 != 1)
      {
        if (a2)
          v12 = 2;
        else
          v12 = 3;
        if (v11 == v12)
        {
          *(_DWORD *)__buf = 0;
          *(_DWORD *)(a1 + 52) = 1;
          arc4random_buf(__buf, 4uLL);
          v13 = *(_DWORD *)__buf % 0xF423Fu + 1;
          *(_WORD *)(a1 + 33) = v13;
          *(_WORD *)(a1 + 35) = BYTE2(v13);
LABEL_35:
          sub_1002390F8(*(_QWORD *)a1);
          return 0;
        }
        if (v11 == 5)
          v17 = 3;
        else
          v17 = 2;
LABEL_34:
        *(_DWORD *)(a1 + 52) = v17;
        goto LABEL_35;
      }
LABEL_23:
      *(_DWORD *)(a1 + 52) = 0;
      goto LABEL_35;
    }
    return 4824;
  }
  v23 = 96;
  *(_BYTE *)(a1 + 77) |= 1u;
  *(_BYTE *)(a1 + 75) |= 1u;
  if ((*(_BYTE *)(a1 + 76) & 8) != 0)
  {
    v14 = *(_BYTE *)(a1 + 74);
    *(_BYTE *)(a1 + 594) = (v14 & 8) != 0;
    if ((v9 & 0x20) != 0 && (v14 & 8) != 0)
    {
      if (sub_10005549C())
      {
        sub_100054530("Both sides set CT2=1, will use H7");
        v15 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__buf = 136446210;
          *(_QWORD *)&__buf[4] = sub_100054494();
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, " %{public}s", __buf, 0xCu);
        }
      }
      *(_BYTE *)(a1 + 593) = 1;
    }
  }
  else
  {
    *(_BYTE *)(a1 + 594) = 0;
  }
  if (*(_BYTE *)(*(_QWORD *)a1 + 70) == 1)
    sub_1001EE5A0(a1, 32);
  v16 = *(unsigned __int8 *)(a1 + 16);
  if (v16 == 1)
    goto LABEL_23;
  if (v16 == 5)
  {
    if (off_1009990F0)
    {
      v17 = 5;
      goto LABEL_34;
    }
    if (sub_10005549C())
    {
      sub_100054530("Cannot do OOB if there is no PAIRING_DISPLAY callback registered");
      v20 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 4824;
  }
  if (*(_BYTE *)(*(_QWORD *)a1 + 70) == 1)
    return 0;
  v18 = (_OWORD *)(a1 + 152);
  result = sub_1001859C0((_OWORD *)(a1 + 152), (_OWORD *)(a1 + 216), (uint64_t)&v23, a4, a5, a6, a7, a8);
  if ((_DWORD)result)
  {
    *(_OWORD *)(a1 + 184) = 0u;
    *(_OWORD *)(a1 + 200) = 0u;
    *v18 = 0u;
    *(_OWORD *)(a1 + 168) = 0u;
    *(_OWORD *)(a1 + 216) = 0u;
    *(_OWORD *)(a1 + 232) = 0u;
    *(_OWORD *)(a1 + 248) = 0u;
    *(_OWORD *)(a1 + 264) = 0u;
    *(_OWORD *)(a1 + 280) = 0u;
    *(_OWORD *)(a1 + 296) = 0u;
  }
  else
  {
    sub_1001EE5A0(a1, 33);
    __buf[0] = 12;
    v21 = *(_OWORD *)(a1 + 168);
    *(_OWORD *)&__buf[1] = *v18;
    v25 = v21;
    v22 = *(_OWORD *)(a1 + 200);
    v26 = *(_OWORD *)(a1 + 184);
    v27 = v22;
    return sub_1001EE0F4(*(__int128 **)a1, __buf, 0x41uLL, 1);
  }
  return result;
}

uint64_t sub_100232438(const void *a1, unsigned int a2)
{
  uint64_t result;
  NSObject *v5;
  _QWORD v6[2];
  __int128 __s2;

  if (a2 < 0x10)
    return 1;
  __s2 = xmmword_10073B7C0;
  v6[0] = 0;
  v6[1] = 0;
  sub_10004C878((uint64_t)v6, (uint64_t)&__s2, 0x10uLL);
  if (memcmp(a1, &__s2, a2))
  {
    if (memcmp(a1, v6, a2))
      return 1;
  }
  result = sub_10005549C();
  if ((_DWORD)result)
  {
    sub_100054530("Peer device is using a debug LTK, aborting pairing");
    v5 = sub_1000544A0(0x43u);
    result = os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
    {
      sub_1006CE7A4();
      return 0;
    }
  }
  return result;
}

uint64_t sub_10023252C(_BYTE *a1, uint64_t a2)
{
  _DWORD *v4;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  int v10;
  uint64_t v11;

  if (!a2)
  {
    if (sub_10005549C())
    {
      sub_100054530("Invalid keys structure.");
      v8 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 101;
  }
  if (!a1 || !sub_10019AC00((uint64_t)a1))
  {
    if (sub_10005549C())
    {
      sub_100054530("This handle is not a LE connection.");
      v7 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 4820;
  }
  a1[264] = *(_BYTE *)(a2 + 82);
  if (a1[166] == 3)
  {
    if (a1[55])
      v4 = a1 + 56;
    else
      v4 = a1 + 48;
    v5 = sub_10022C8EC(v4, a2 + 28, *(unsigned __int8 *)(a2 + 44), *(_BYTE *)(a2 + 45));
    if ((_DWORD)v5 && sub_10005549C())
    {
      sub_100054530("LE_LongTermKeyReply failed %!", v5);
      v6 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    return v5;
  }
  v10 = *(unsigned __int16 *)(a2 + 80);
  if ((v10 & 8) != 0 && (*(_BYTE *)(a2 + 45) & 0xFE) == 2)
  {
    v11 = 0;
    a1[208] = 1;
    return sub_10022D498(a1, (uint64_t)&v11, 0, a2 + 28, *(unsigned __int8 *)(a2 + 44), *(_BYTE *)(a2 + 45));
  }
  if ((~v10 & 7) != 0)
    return 101;
  a1[208] = 1;
  return sub_10022D498(a1, a2 + 20, *(unsigned __int16 *)(a2 + 18), a2, *(unsigned __int8 *)(a2 + 16), *(_BYTE *)(a2 + 17));
}

uint64_t sub_100232744(uint64_t a1, int a2, uint64_t a3)
{
  char v3;
  char v4;
  unsigned __int8 v5;
  unsigned __int8 v6;
  unsigned __int8 v7;
  unsigned __int8 v8;
  uint64_t v12;
  char *v13;
  uint64_t result;
  _DWORD *v15;
  char v16;
  int v17;
  int v18;
  int v19;
  unsigned __int8 v20;
  NSObject *v21;
  NSObject *v22;
  NSObject *v23;
  unsigned __int8 v24;
  unsigned __int8 v25;
  NSObject *v26;
  void *v27;
  __int128 *v28;
  int v29;
  int v30;
  uint8_t buf[4];
  void *v32;

  v3 = byte_10097A8E1;
  if (byte_10097A8E1 == 255)
    v3 = 11;
  if (byte_10097A8E2 == 255)
    v4 = 11;
  else
    v4 = byte_10097A8E2;
  v5 = v3 & 0xF7;
  v6 = v4 & 0xF7;
  if (byte_10098FC40)
    v7 = v3 & 0xF7;
  else
    v7 = v3;
  if (byte_10098FC40)
    v8 = v4 & 0xF7;
  else
    v8 = v4;
  if (!a1 || !sub_10019AC00(a1))
  {
    if (!sub_10005549C())
      return 4820;
    sub_100054530("This handle is not a LE connection.");
    v22 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      return 4820;
LABEL_33:
    sub_1006CE7A4();
    return 4820;
  }
  v12 = sub_1001EE0AC(a1);
  if (!v12)
  {
    if (!sub_10005549C())
      return 4820;
    sub_100054530("There is no security request for this connection. Ignoring reply.");
    v23 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      return 4820;
    goto LABEL_33;
  }
  v13 = (char *)v12;
  if (!a2)
    goto LABEL_53;
  if (!a3 || (result = sub_10022D6EC((_BYTE *)a1, a3), (_DWORD)result))
  {
    if (*(_BYTE *)(a1 + 55))
      v15 = (_DWORD *)(a1 + 56);
    else
      v15 = 0;
    v16 = sub_10022CCE0((_DWORD *)(a1 + 48), v15);
    v17 = v13[80] & 4;
    v18 = byte_10098FC44;
    v19 = v17 | v18 | sub_10022408C();
    if ((v13[80] & 8) != 0 && byte_10098FC41)
    {
      v20 = v19 | 8;
      if ((byte_10098FC42 & 1) == 0 && (v13[80] & 0x20) != 0 && !*(_BYTE *)(a1 + 232) && (v7 & 8) != 0)
      {
        if (sub_10005549C())
        {
          sub_100054530("Sending CT2=1");
          v21 = sub_1000544A0(0x43u);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136446210;
            v32 = sub_100054494();
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
          }
        }
        v20 = v19 | 0x28;
      }
    }
    else
    {
      v20 = v19 & 0xDF;
      v7 = v5;
      v8 = v6;
    }
    if (*(_BYTE *)(a1 + 232))
      v24 = v20 & 0xDF;
    else
      v24 = v20;
    if (*(_BYTE *)(a1 + 232))
    {
      v7 = v5;
      v25 = v6;
    }
    else
    {
      v25 = v8;
    }
    if (sub_10005549C())
    {
      sub_100054530("authReq=%x expectedKeys=%x requestedKeys=%x", v24, v7, v25);
      v26 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        v27 = sub_100054494();
        *(_DWORD *)buf = 136446210;
        v32 = v27;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
    if (byte_10098FC45)
    {
      v28 = (__int128 *)a1;
      v29 = 3;
LABEL_54:
      sub_1002306D8(v28, v29, v13);
      return 0;
    }
    v30 = sub_100232AA4(a1, byte_10097A8E3, v16, v24, v7, v25);
    result = 0;
    if (v30)
    {
      if (v30 != 4804)
      {
LABEL_53:
        v28 = (__int128 *)a1;
        v29 = 8;
        goto LABEL_54;
      }
    }
  }
  return result;
}

uint64_t sub_100232AA4(uint64_t a1, char a2, char a3, char a4, char a5, char a6)
{
  NSObject *v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v13;
  _BYTE *v14;
  const char *v15;
  NSObject *v16;
  NSObject *v17;
  int v18;
  __int16 v19;
  char v20;

  LOBYTE(v18) = 1;
  BYTE1(v18) = a2;
  BYTE2(v18) = a3;
  HIBYTE(v18) = a4;
  LOBYTE(v19) = 16;
  HIBYTE(v19) = a5;
  v20 = a6;
  if (sub_10019AC00(a1))
  {
    if (*(_BYTE *)(a1 + 70))
    {
      if (sub_10005549C())
      {
        sub_100054530("You cannot send this command when peripheral.");
        v9 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return 4821;
    }
    v13 = sub_1001EE0AC(a1);
    if (v13)
    {
      v14 = (_BYTE *)v13;
      if (*(unsigned __int8 *)(v13 + 8) >= 0x11u)
      {
        if (sub_10005549C())
        {
          v15 = sub_1001EE594();
          sub_100054530("Cannot ask for pairing, device is already in state %s.", v15);
          v16 = sub_1000544A0(0x43u);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
            sub_1006CEEC0();
        }
        return 4804;
      }
LABEL_19:
      v14[72] = a4;
      v14[73] = a3;
      v10 = sub_1001EE0F4(*(__int128 **)v14, (char *)&v18, 7uLL, 1);
      if ((_DWORD)v10)
      {
        sub_1001EDD30(v14, v10, 1);
      }
      else
      {
        sub_1001EE5A0((uint64_t)v14, 17);
        *(_DWORD *)(v14 + 579) = v18;
        *(_WORD *)(v14 + 583) = v19;
        v14[585] = v20;
      }
      return v10;
    }
    v14 = sub_1001EE3C4(a1);
    if (v14)
      goto LABEL_19;
    if (sub_10005549C())
    {
      sub_100054530("Could not allocate a pairing record for handle 0x%x", a1);
      v17 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    return 104;
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("Invalid connection handle.");
      v11 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 4820;
  }
}

void sub_100232CCC(_BYTE *a1, int *a2, int a3)
{
  char v6;
  char v7;
  char v8;
  char v9;
  uint64_t *v10;
  char *v11;
  int v12;
  const char *v13;
  NSObject *v14;
  NSObject *v15;
  NSObject *v16;
  NSObject *v17;
  NSObject *v18;
  NSObject *v19;
  NSObject *v20;
  NSObject *v21;
  unsigned int v22;
  unsigned int v23;
  char v24;
  char v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  NSObject *v29;
  NSObject *v30;
  NSObject *v31;
  _DWORD *v32;
  __int128 buf;

  v32 = a1;
  v6 = byte_10097A8E1;
  if (byte_10097A8E1 == 255)
    v6 = 11;
  if (byte_10097A8E2 == 255)
    v7 = 11;
  else
    v7 = byte_10097A8E2;
  if (byte_10098FC40)
    v8 = v6 & 0xF7;
  else
    v8 = v6;
  if (byte_10098FC40)
    v9 = v7 & 0xF7;
  else
    v9 = v7;
  v10 = (uint64_t *)sub_1001EE0AC((uint64_t)a1);
  v11 = (char *)v10;
  v12 = byte_10098FC90;
  if (byte_10098FC90)
    goto LABEL_51;
  if (a3 != 6)
  {
    if (!sub_10005549C())
      goto LABEL_50;
    sub_100054530("Invalid Pairing Request size %d.", a3);
    v15 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      goto LABEL_50;
LABEL_69:
    sub_1006CE7A4();
LABEL_50:
    v12 = 8;
    goto LABEL_51;
  }
  if (!a1[70])
  {
    if (!sub_10005549C())
      goto LABEL_50;
    sub_100054530("This command should only be received if we are peripheral.");
    v16 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      goto LABEL_50;
    goto LABEL_69;
  }
  if (v10)
  {
    sub_1001EE4C0(v10);
    if (!sub_1001EE68C((uint64_t)v11, 16) && !v11[9])
    {
      if (!sub_10005549C())
        goto LABEL_50;
      v13 = sub_1001EE594();
      sub_100054530("Received pairing request from central, but we had already a previous non-encrypted entry in state %s.", v13);
      v14 = sub_1000544A0(0x43u);
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        goto LABEL_50;
      goto LABEL_69;
    }
  }
  else
  {
    v11 = sub_1001EE3C4((uint64_t)a1);
    if (!v11)
    {
      if (sub_10005549C())
      {
        sub_100054530("Could not allocate new device...");
        v21 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      v11 = 0;
      goto LABEL_50;
    }
  }
  sub_1001EE460((uint64_t)v11, *(_BYTE *)a2, *((_BYTE *)a2 + 1), *((_BYTE *)a2 + 2), *((unsigned __int8 *)a2 + 3), *((_BYTE *)a2 + 4), *((_BYTE *)a2 + 5));
  if (v11[78] >= 5u)
  {
    if (sub_10005549C())
    {
      sub_100054530("Invalid remote IOCaps %d.", v11[78]);
      v17 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    goto LABEL_32;
  }
  if (v11[79] >= 2u)
  {
    if (!sub_10005549C())
      goto LABEL_50;
    sub_100054530("Invalid OOB flags %d.", v11[79]);
    v18 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      goto LABEL_50;
    goto LABEL_69;
  }
  if ((v11[80] & 0xC2) != 0)
  {
    if (sub_10005549C())
    {
      sub_100054530("Invalid authentication requirements 0x%x.", v11[80]);
      v19 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  if (v11[81] - 17 <= 0xFFFFFFF5)
  {
    if (sub_10005549C())
    {
      sub_100054530("Invalid maximum encryption size %d", v11[81]);
      v20 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    v12 = 6;
    goto LABEL_51;
  }
  v22 = v11[82];
  if (v22 > 0xF || (v23 = v11[83], v23 >= 0x10))
  {
    if (!sub_10005549C())
      goto LABEL_50;
    sub_100054530("Invalid key distribution parameters initiator:0x%x, responder:0xx", v11[82]);
    v30 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      goto LABEL_50;
    goto LABEL_69;
  }
  if (byte_10098FC45 && (v11[80] & 8) == 0)
  {
LABEL_32:
    v12 = 3;
LABEL_51:
    sub_1002306D8((__int128 *)a1, v12, v11);
    return;
  }
  v24 = v22 & v9;
  if (byte_10097A8E1 != -1)
    v24 = byte_10097A8E1;
  v11[74] = v24;
  v11[75] = 0;
  v25 = v23 & v8;
  if (byte_10097A8E2 != 255)
    v25 = byte_10097A8E2;
  v11[76] = v25;
  v11[77] = 0;
  sub_1001EE5A0((uint64_t)v11, 17);
  v11[579] = 1;
  v26 = *a2;
  *((_WORD *)v11 + 292) = *((_WORD *)a2 + 2);
  *((_DWORD *)v11 + 145) = v26;
  if (off_1009990E8)
  {
    if (v32[33] == 7)
    {
      *((_QWORD *)&buf + 1) = &v32;
      *(_QWORD *)&buf = 8;
      v27 = sub_10004A9EC((uint64_t)sub_100237A60, (const void **)&buf, 0, 0);
      if ((_DWORD)v27)
      {
        v28 = v27;
        if (sub_10005549C())
        {
          sub_100054530("Could not dispatch pairing request with status %!.", v28);
          v29 = sub_1000544A0(0x43u);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
            sub_1006CEEC0();
        }
      }
    }
    else if (sub_10005549C())
    {
      sub_100054530("Got Pairing Request before link is ready for handle %p, lets handle this when the link is actually ready. Link state is %d", v32, v32[33]);
      v31 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 136446210;
        *(_QWORD *)((char *)&buf + 4) = sub_100054494();
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, " %{public}s", (uint8_t *)&buf, 0xCu);
      }
    }
  }
}

uint64_t sub_100233260(uint64_t a1, int *a2, int a3)
{
  uint64_t *v6;
  uint64_t v7;
  int v8;
  NSObject *v9;
  NSObject *v10;
  NSObject *v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;
  NSObject *v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  int v27;
  NSObject *v28;
  uint64_t result;
  char v30;
  int v31;

  v6 = (uint64_t *)sub_1001EE0AC(a1);
  v7 = (uint64_t)v6;
  if (!v6)
  {
    if (!sub_10005549C())
      goto LABEL_46;
    sub_100054530("Pairing response with no pairing request for handle %d.", a1);
    v10 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      goto LABEL_46;
LABEL_45:
    sub_1006CE7A4();
LABEL_46:
    v8 = 8;
    return sub_1002306D8((__int128 *)a1, v8, (char *)v7);
  }
  v8 = byte_10098FC90;
  if (byte_10098FC90)
    return sub_1002306D8((__int128 *)a1, v8, (char *)v7);
  if (a3 != 6)
  {
    if (!sub_10005549C())
      goto LABEL_46;
    sub_100054530("Invalid Pairing Response size %d.", a3);
    v11 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      goto LABEL_46;
    goto LABEL_45;
  }
  sub_1001EE4C0(v6);
  if (*(_BYTE *)(a1 + 70) == 1)
  {
    if (!sub_10005549C())
      goto LABEL_46;
    sub_100054530("This command should only be received if we are central.");
    v9 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      goto LABEL_46;
    goto LABEL_45;
  }
  if (!sub_1001EE68C(v7, 17))
  {
    if (!sub_10005549C())
      goto LABEL_46;
    sub_100054530("Pairing response was received without a pairing request for handle %d.", a1);
    v13 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      goto LABEL_46;
    goto LABEL_45;
  }
  sub_1001EE460(v7, *(_BYTE *)a2, *((_BYTE *)a2 + 1), *((_BYTE *)a2 + 2), *((unsigned __int8 *)a2 + 3), *((_BYTE *)a2 + 4), *((_BYTE *)a2 + 5));
  if (*(unsigned __int8 *)(v7 + 78) >= 5u)
  {
    if (sub_10005549C())
    {
      sub_100054530("Invalid remote IOCaps %d.", *(unsigned __int8 *)(v7 + 78));
      v12 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    goto LABEL_19;
  }
  if (*(unsigned __int8 *)(v7 + 79) >= 2u)
  {
    if (!sub_10005549C())
      goto LABEL_46;
    sub_100054530("Invalid OOB flags %d.", *(unsigned __int8 *)(v7 + 79));
    v14 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      goto LABEL_46;
    goto LABEL_45;
  }
  if ((*(_BYTE *)(v7 + 80) & 0xC2) != 0)
  {
    if (sub_10005549C())
    {
      sub_100054530("Invalid authentication requirements 0x%x.", *(unsigned __int8 *)(v7 + 80));
      v15 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  if (*(unsigned __int8 *)(v7 + 81) - 17 <= 0xFFFFFFF5)
  {
    if (sub_10005549C())
    {
      sub_100054530("Invalid maximum encryption size %d", *(unsigned __int8 *)(v7 + 81));
      v16 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    v8 = 6;
    return sub_1002306D8((__int128 *)a1, v8, (char *)v7);
  }
  v17 = *(unsigned __int8 *)(v7 + 82);
  if (v17 > 0xF || (v18 = *(unsigned __int8 *)(v7 + 83), v18 >= 0x10))
  {
    if (!sub_10005549C())
      goto LABEL_46;
    sub_100054530("Invalid key distribution parameters initiator:0x%x, responder:0xx", *(unsigned __int8 *)(v7 + 82));
    v28 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      goto LABEL_46;
    goto LABEL_45;
  }
  *(_BYTE *)(v7 + 76) = v17 & 0xB;
  *(_BYTE *)(v7 + 75) = 0;
  *(_BYTE *)(v7 + 74) = v18 & 0xB;
  *(_BYTE *)(v7 + 77) = 0;
  sub_1001EE5A0(v7, 18);
  v25 = *(unsigned __int8 *)(v7 + 72);
  v26 = *(unsigned __int8 *)(v7 + 80);
  if (byte_10098FC45 && (v25 & v26 & 8) == 0)
  {
LABEL_19:
    v8 = 3;
    return sub_1002306D8((__int128 *)a1, v8, (char *)v7);
  }
  v27 = *(unsigned __int8 *)(v7 + 73);
  if ((v25 & v26 & 8) != 0)
  {
    if (v27 == 1)
      goto LABEL_50;
  }
  else if (v27 != 1)
  {
    goto LABEL_51;
  }
  if (*(_BYTE *)(v7 + 79) == 1)
  {
LABEL_50:
    v30 = 5;
    goto LABEL_54;
  }
LABEL_51:
  if (((v26 | v25) & 4) != 0)
    v30 = sub_100232008(byte_10097A8E3, *(unsigned __int8 *)(v7 + 78), (v25 & v26 & 8) != 0);
  else
    v30 = 1;
LABEL_54:
  *(_BYTE *)(v7 + 16) = v30;
  *(_BYTE *)(v7 + 586) = 2;
  v31 = *a2;
  *(_WORD *)(v7 + 591) = *((_WORD *)a2 + 2);
  *(_DWORD *)(v7 + 587) = v31;
  result = sub_100232120(v7, 1, v19, v20, v21, v22, v23, v24);
  if ((_DWORD)result)
    goto LABEL_46;
  return result;
}

void sub_1002336B0(uint64_t a1, _OWORD *a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  char v8;
  uint64_t *v9;
  int v10;
  int v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;
  int v15;
  NSObject *v16;
  NSObject *v17;
  const char *v18;
  NSObject *v19;
  NSObject *v20;
  uint64_t v22;
  uint64_t v23;
  NSObject *v24;
  const char *v25;
  NSObject *v26;
  const char *v27;
  NSObject *v28;
  uint64_t v29;
  uint64_t v30;
  NSObject *v31;
  const char *v32;
  NSObject *v33;
  uint64_t v34;
  uint64_t v35;
  NSObject *v36;

  v6 = sub_1001EE0AC(a1);
  v7 = v6;
  if (!v6)
  {
    if (!sub_10005549C())
      goto LABEL_23;
    sub_100054530("Could not find associated pairing data.");
    v13 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      goto LABEL_23;
    goto LABEL_22;
  }
  if (a3 != 16)
  {
    if (!sub_10005549C())
      goto LABEL_23;
    sub_100054530("Invalid Pairing Confirmation size %d", a3);
    v14 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      goto LABEL_23;
    goto LABEL_22;
  }
  v8 = *(_BYTE *)(v6 + 72) & *(_BYTE *)(v6 + 80);
  v9 = (uint64_t *)sub_1001EE0AC(a1);
  v7 = (uint64_t)v9;
  if ((v8 & 8) == 0)
  {
    if (v9)
    {
      sub_1001EE4C0(v9);
      v15 = *(unsigned __int8 *)(a1 + 70);
      if (v15 == 1)
      {
        if (!sub_1001EE68C(v7, 18))
        {
          if (!sub_10005549C())
            goto LABEL_23;
          v25 = sub_1001EE594();
          sub_100054530("Device was not in the proper state. State is %s.", v25);
          v26 = sub_1000544A0(0x43u);
          if (!os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
            goto LABEL_23;
          goto LABEL_22;
        }
        v15 = *(unsigned __int8 *)(a1 + 70);
      }
      if (v15 || sub_1001EE68C(v7, 34))
      {
        *(_OWORD *)(v7 + 104) = *a2;
        if (*(_BYTE *)(a1 + 70) == 1)
        {
          sub_1001EE5A0(v7, 34);
          if (*(_DWORD *)(v7 + 84) != 2)
          {
            *(_DWORD *)(v7 + 84) = 1;
            return;
          }
          if (sub_100231670(a1, (_QWORD *)(v7 + 88)))
            goto LABEL_23;
        }
        else
        {
          sub_1001EE5A0(v7, 35);
          if (sub_1002393C4(a1, (__int128 *)(v7 + 120)))
            goto LABEL_23;
        }
        return;
      }
      if (!sub_10005549C())
        goto LABEL_23;
      v32 = sub_1001EE594();
      sub_100054530("Device was not in the proper state. State is %s.", v32);
      v33 = sub_1000544A0(0x43u);
      if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
        goto LABEL_23;
    }
    else
    {
      if (!sub_10005549C())
        goto LABEL_23;
      sub_100054530("Could not find associated pairing data.");
      v17 = sub_1000544A0(0x43u);
      if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        goto LABEL_23;
    }
LABEL_22:
    sub_1006CE7A4();
LABEL_23:
    sub_1002306D8((__int128 *)a1, 8, (char *)v7);
    return;
  }
  if (!v9)
  {
    if (!sub_10005549C())
      goto LABEL_23;
    sub_100054530("Could not find associated pairing data.");
    v16 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      goto LABEL_23;
    goto LABEL_22;
  }
  sub_1001EE4C0(v9);
  v10 = *(unsigned __int8 *)(a1 + 70);
  if (v10 == 1)
  {
    if (sub_1001EE68C(v7, 34))
    {
      v10 = *(unsigned __int8 *)(a1 + 70);
      goto LABEL_8;
    }
    if (!sub_10005549C())
      goto LABEL_23;
    v18 = sub_1001EE594();
    sub_100054530("Device was not in the proper state. State is %s.", v18);
    v19 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      goto LABEL_23;
    goto LABEL_22;
  }
LABEL_8:
  if (!v10 && !sub_1001EE68C(v7, 35))
  {
    if (!sub_10005549C())
      goto LABEL_23;
    v27 = sub_1001EE594();
    sub_100054530("Device was not in the proper state. State is %s.", v27);
    v28 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      goto LABEL_23;
    goto LABEL_22;
  }
  *(_OWORD *)(v7 + 104) = *a2;
  v11 = *(unsigned __int8 *)(v7 + 16);
  switch(v11)
  {
    case 6:
      goto LABEL_13;
    case 5:
      if (!sub_10005549C())
        goto LABEL_23;
      sub_100054530("Should not be here !");
      v20 = sub_1000544A0(0x43u);
      if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        goto LABEL_23;
      goto LABEL_22;
    case 1:
LABEL_13:
      if (*(_BYTE *)(a1 + 70))
      {
        if (!sub_10005549C())
          goto LABEL_23;
        sub_100054530("At this point, peripheral should not get a confirmation value");
        v12 = sub_1000544A0(0x43u);
        if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          goto LABEL_23;
        goto LABEL_22;
      }
      v29 = sub_1002393C4(a1, (__int128 *)(v7 + 457));
      if ((_DWORD)v29)
      {
        v30 = v29;
        if (!sub_10005549C())
          goto LABEL_23;
        sub_100054530("Failed to send pairing random to peripheral %!", v30);
        v31 = sub_1000544A0(0x43u);
        if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
          goto LABEL_23;
        goto LABEL_76;
      }
LABEL_77:
      sub_1001EE5A0(v7, 37);
      return;
  }
  *(_OWORD *)(v7 + 104) = *a2;
  if (!*(_BYTE *)(a1 + 70))
  {
    v34 = sub_1002393C4(*(_QWORD *)v7, (__int128 *)(v7 + 457));
    if (!(_DWORD)v34)
      goto LABEL_77;
    v35 = v34;
    if (!sub_10005549C())
      goto LABEL_23;
    sub_100054530("smpSendPairingRandom failed %!", v35);
    v36 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
      goto LABEL_23;
LABEL_76:
    sub_1006CEEC0();
    goto LABEL_23;
  }
  if (*(_BYTE *)(v7 + 490))
  {
    if (*(_QWORD *)(v7 + 104) || *(_QWORD *)(v7 + 112) != 0)
    {
      v22 = sub_10023906C((uint64_t *)v7);
      if ((_DWORD)v22)
      {
        v23 = v22;
        if (!sub_10005549C())
          goto LABEL_23;
        sub_100054530("recvdSMPDoSecuredConnectionPasskeySendCai failed %!", v23);
        v24 = sub_1000544A0(0x43u);
        if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          goto LABEL_23;
        goto LABEL_76;
      }
    }
  }
}

void sub_100233C84(__int128 *a1, _OWORD *a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  int v9;
  _OWORD *v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  NSObject *v14;
  __int128 *v15;
  int v16;
  uint64_t *v17;
  int v18;
  char v19;
  uint8x8_t v20;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  const char *v25;
  NSObject *v26;
  uint64_t v27;
  NSObject *v28;
  NSObject *v29;
  __int128 v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  NSObject *v35;
  const char *v36;
  NSObject *v37;
  const char *v38;
  NSObject *v39;
  const char *v40;
  NSObject *v41;
  uint64_t v42;
  uint64_t v43;
  NSObject *v44;
  unsigned int v45;
  char v46;
  __int128 v47;
  __int128 v48;
  char v49;
  uint64_t v50;
  uint64_t v51;
  NSObject *v52;
  __int128 v53;
  __int128 v54;
  uint64_t v55;
  uint64_t v56;
  NSObject *v57;
  _QWORD *v58;
  uint64_t *v59;
  uint64_t v60;
  uint64_t v61;
  NSObject *v62;
  __int128 v63;
  __int128 v64;
  uint64_t v65;
  uint64_t v66;
  NSObject *v67;
  unsigned int v68;
  char v69;
  __int128 v70;
  __int128 v71;
  char v72;
  uint64_t v73;
  uint64_t v74;
  NSObject *v75;
  NSObject *v77;
  NSObject *v79;
  uint64_t v80;
  NSObject *v82;
  __int128 v83;
  __int128 v84;
  uint64_t v85;
  uint64_t v86;
  NSObject *v87;
  uint64_t v88;
  uint64_t v89;
  NSObject *v90;
  unsigned int v91;
  uint64_t v92;
  uint64_t v93;
  NSObject *v94;
  unsigned int v95;
  uint64_t v96;
  uint64_t v97;
  NSObject *v98;
  unsigned int v99;
  uint64_t v100;
  uint64_t v101;
  NSObject *v102;
  uint64_t v103;
  char v104;
  uint64_t v105;
  uint64_t v106;
  NSObject *v107;
  unsigned int v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;

  v6 = sub_1001EE0AC((uint64_t)a1);
  v7 = v6;
  if (!v6)
  {
    if (!sub_10005549C())
      goto LABEL_22;
    sub_100054530("Could not find associated pairing data.");
    v13 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      goto LABEL_22;
    goto LABEL_21;
  }
  if (a3 != 16)
  {
    if (!sub_10005549C())
      goto LABEL_22;
    sub_100054530("Invalid Pairing Random size %d", a3);
    v14 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      goto LABEL_22;
    goto LABEL_21;
  }
  if ((*(_BYTE *)(v6 + 72) & *(_BYTE *)(v6 + 80) & 8) == 0)
  {
    v113 = 0uLL;
    *(_QWORD *)&v111 = 0;
    v17 = (uint64_t *)sub_1001EE0AC((uint64_t)a1);
    v7 = (uint64_t)v17;
    if (v17)
    {
      sub_1001EE4C0(v17);
      v18 = *((unsigned __int8 *)a1 + 70);
      if (v18 == 1)
      {
        if (!sub_1001EE68C(v7, 35))
        {
          if (!sub_10005549C())
            goto LABEL_22;
          v36 = sub_1001EE594();
          sub_100054530("Initiator device was not in the proper state. State is %s.", v36);
          v37 = sub_1000544A0(0x43u);
          if (!os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
            goto LABEL_22;
          goto LABEL_21;
        }
        v18 = *((unsigned __int8 *)a1 + 70);
      }
      if (v18 || sub_1001EE68C(v7, 36))
      {
        *(_OWORD *)(v7 + 136) = *a2;
        if (*((_BYTE *)a1 + 70) == 1)
          v19 = 36;
        else
          v19 = 37;
        sub_1001EE5A0(v7, v19);
        if (sub_1002314D4(v7, 1, &v113, v20))
          goto LABEL_22;
        if ((_QWORD)v113 == *(_QWORD *)(v7 + 104) && *((_QWORD *)&v113 + 1) == *(_QWORD *)(v7 + 112))
        {
          if (*((_BYTE *)a1 + 70) == 1 && sub_1002393C4((uint64_t)a1, (__int128 *)(v7 + 120)))
            goto LABEL_22;
          sub_1001EE5A0(v7, 40);
          v58 = (_QWORD *)(v7 + 120);
          if (*((_BYTE *)a1 + 70))
          {
            v59 = (uint64_t *)(v7 + 120);
            v58 = (_QWORD *)(v7 + 136);
          }
          else
          {
            v59 = (uint64_t *)(v7 + 136);
          }
          if (sub_100184CD4((__int128 *)(v7 + 17), v59, v58, (void *)(v7 + 56)))
            goto LABEL_22;
          v80 = *(unsigned __int8 *)(v7 + 81);
          if (v80 != 16)
            bzero((void *)(v7 + 56 + v80), 16 - v80);
          sub_1001EE5A0(v7, 41);
          if (!*((_BYTE *)a1 + 70))
          {
            if (sub_10022D498(a1, (uint64_t)&v111, 0, v7 + 56, 0x10u, *(_BYTE *)(v7 + 16) != 1))
              goto LABEL_22;
          }
          return;
        }
        if (sub_10005549C())
        {
          sub_100054530("The confirmation value does not match.");
          v22 = sub_1000544A0(0x43u);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
LABEL_42:
        v15 = a1;
        v16 = 4;
        goto LABEL_23;
      }
      if (!sub_10005549C())
        goto LABEL_22;
      v40 = sub_1001EE594();
      sub_100054530("Responder device was not in the proper state. State is %s.", v40);
      v41 = sub_1000544A0(0x43u);
      if (!os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
        goto LABEL_22;
    }
    else
    {
      if (!sub_10005549C())
        goto LABEL_22;
      sub_100054530("Could not find associated pairing data.");
      v24 = sub_1000544A0(0x43u);
      if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        goto LABEL_22;
    }
LABEL_21:
    sub_1006CE7A4();
LABEL_22:
    v15 = a1;
    v16 = 8;
LABEL_23:
    sub_1002306D8(v15, v16, (char *)v7);
    return;
  }
  v111 = 0u;
  v112 = 0u;
  v109 = 0u;
  v110 = 0u;
  v8 = (uint64_t *)sub_1001EE0AC((uint64_t)a1);
  v7 = (uint64_t)v8;
  if (!v8)
  {
    if (!sub_10005549C())
      goto LABEL_22;
    sub_100054530("Could not find associated pairing data.");
    v23 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      goto LABEL_22;
    goto LABEL_21;
  }
  sub_1001EE4C0(v8);
  v9 = *((unsigned __int8 *)a1 + 70);
  if (v9 != 1)
    goto LABEL_8;
  if (!sub_1001EE68C(v7, 36))
  {
    if (!sub_10005549C())
      goto LABEL_22;
    v25 = sub_1001EE594();
    sub_100054530("Initiator device was not in the proper state. State is %s.", v25);
    v26 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      goto LABEL_22;
    goto LABEL_21;
  }
  v9 = *((unsigned __int8 *)a1 + 70);
LABEL_8:
  if (v9)
    goto LABEL_11;
  if (!sub_1001EE68C(v7, 37))
  {
    if (!sub_10005549C())
      goto LABEL_22;
    v38 = sub_1001EE594();
    sub_100054530("Initiator device was not in the proper state. State is %s.", v38);
    v39 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
      goto LABEL_22;
    goto LABEL_21;
  }
  v9 = *((unsigned __int8 *)a1 + 70);
LABEL_11:
  if (v9 == 1)
    v10 = (_OWORD *)(v7 + 457);
  else
    v10 = (_OWORD *)(v7 + 473);
  *v10 = *a2;
  v113 = 0u;
  v114 = 0u;
  v11 = *(_QWORD *)v7 + 63;
  if (*(_BYTE *)(*(_QWORD *)v7 + 70))
  {
    v12 = *(_QWORD *)v7 + 48;
  }
  else
  {
    v12 = *(_QWORD *)v7 + 63;
    v11 = *(_QWORD *)v7 + 48;
  }
  v27 = sub_100185110((_OWORD *)(v7 + 376), (_OWORD *)(v7 + 457), (_OWORD *)(v7 + 473), 1651797093, v12, v11, (char *)&v113, 32);
  if ((_DWORD)v27)
  {
    if (sub_10005549C())
    {
      sub_100054530("Failed to generate LTK %!", v27);
      v28 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    if (!sub_10005549C())
      goto LABEL_22;
    sub_100054530("smpCalculateLtkAndMacKey Failed %!", v27);
    v29 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      goto LABEL_22;
LABEL_103:
    sub_1006CEEC0();
    goto LABEL_22;
  }
  v30 = v114;
  *(_OWORD *)(v7 + 408) = v113;
  *(_OWORD *)(v7 + 524) = v30;
  v31 = *(unsigned __int8 *)(v7 + 81);
  if (v31 != 16)
    bzero((void *)(v7 + 524 + v31), 16 - v31);
  *(_BYTE *)(v7 + 424) = 1;
  v32 = *(unsigned __int8 *)(v7 + 16);
  if (v32 != 6)
  {
    if (v32 == 5)
    {
      if (*((_BYTE *)a1 + 70) != 1)
      {
        sub_1001EE5A0(v7, 39);
        v60 = sub_100230D24((__int128 **)v7);
        if ((_DWORD)v60)
        {
          v61 = v60;
          if (!sub_10005549C())
            goto LABEL_22;
          sub_100054530("Failed to send DHKey value with status %!", v61);
          v62 = sub_1000544A0(0x43u);
          if (!os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
            goto LABEL_22;
          goto LABEL_103;
        }
        return;
      }
      v42 = sub_1002393C4((uint64_t)a1, (__int128 *)(v7 + 473));
      if ((_DWORD)v42)
      {
        v43 = v42;
        if (!sub_10005549C())
          goto LABEL_22;
        sub_100054530("Failed to send Nb to central with status %!", v43);
        v44 = sub_1000544A0(0x43u);
        if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
          goto LABEL_22;
        goto LABEL_103;
      }
    }
    else
    {
      if (v32 == 1)
        goto LABEL_65;
      if (!*((_BYTE *)a1 + 70))
      {
        v113 = 0uLL;
        v68 = *(unsigned __int8 *)(v7 + 441) | (*(unsigned __int8 *)(v7 + 426) << 8) | (*(unsigned __int8 *)(v7 + 427) << 16) | (*(unsigned __int8 *)(v7 + 428) << 24);
        v69 = *(_BYTE *)(v7 + 489);
        v70 = *(_OWORD *)(v7 + 328);
        v109 = *(_OWORD *)(v7 + 312);
        v110 = v70;
        v71 = *(_OWORD *)(v7 + 168);
        v111 = *(_OWORD *)(v7 + 152);
        v112 = v71;
        if (((v68 >> v69) & 1) != 0)
          v72 = -127;
        else
          v72 = 0x80;
        v73 = sub_100184FB4(&v109, &v111, (__int128 *)(v7 + 473), v72, &v113);
        if ((_DWORD)v73)
        {
          v74 = v73;
          if (!sub_10005549C())
            goto LABEL_22;
          sub_100054530("Failed to generate confirmation value %!", v74);
          v75 = sub_1000544A0(0x43u);
          if (!os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
            goto LABEL_22;
        }
        else
        {
          if ((_QWORD)v113 != *(_QWORD *)(v7 + 104) || *((_QWORD *)&v113 + 1) != *(_QWORD *)(v7 + 112))
          {
            if (!sub_10005549C())
              goto LABEL_42;
            sub_100054530("pairing confirmation does not match %!", 0);
            v82 = sub_1000544A0(0x43u);
            if (!os_log_type_enabled(v82, OS_LOG_TYPE_ERROR))
              goto LABEL_42;
LABEL_143:
            sub_1006CE7A4();
            goto LABEL_42;
          }
          *(_QWORD *)(v7 + 104) = 0;
          *(_QWORD *)(v7 + 112) = 0;
          v95 = ++*(_BYTE *)(v7 + 489);
          if (v95 > 0x13)
          {
            sub_1001EE5A0(v7, 39);
            v105 = sub_100230D24((__int128 **)v7);
            if (!(_DWORD)v105)
              return;
            v106 = v105;
            if (!sub_10005549C())
              goto LABEL_22;
            sub_100054530("Failed to send DHKey value with status %!", v106);
            v107 = sub_1000544A0(0x43u);
            if (!os_log_type_enabled(v107, OS_LOG_TYPE_ERROR))
              goto LABEL_22;
          }
          else
          {
            v96 = sub_10023122C(v7);
            if (!(_DWORD)v96)
            {
              v103 = v7;
              v104 = 35;
              goto LABEL_170;
            }
            v97 = v96;
            if (!sub_10005549C())
              goto LABEL_22;
            sub_100054530("smpDoOneLeSecuredConnectionPasskeyAuthItteration returned %!", v97);
            v98 = sub_1000544A0(0x43u);
            if (!os_log_type_enabled(v98, OS_LOG_TYPE_ERROR))
              goto LABEL_22;
          }
        }
LABEL_178:
        sub_1006CEEC0();
        goto LABEL_22;
      }
      v113 = 0uLL;
      v45 = *(_DWORD *)(v7 + 441);
      v46 = *(_BYTE *)(v7 + 489);
      v47 = *(_OWORD *)(v7 + 328);
      v111 = *(_OWORD *)(v7 + 312);
      v112 = v47;
      v48 = *(_OWORD *)(v7 + 168);
      v109 = *(_OWORD *)(v7 + 152);
      v110 = v48;
      if (((v45 >> v46) & 1) != 0)
        v49 = -127;
      else
        v49 = 0x80;
      v50 = sub_100184FB4(&v111, &v109, (__int128 *)(v7 + 457), v49, &v113);
      if ((_DWORD)v50)
      {
        v51 = v50;
        if (!sub_10005549C())
          goto LABEL_22;
        sub_100054530("Failed to generate confirmation value %!", v51);
        v52 = sub_1000544A0(0x43u);
        if (!os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
          goto LABEL_22;
        goto LABEL_178;
      }
      if ((_QWORD)v113 != *(_QWORD *)(v7 + 104) || *((_QWORD *)&v113 + 1) != *(_QWORD *)(v7 + 112))
      {
        if (!sub_10005549C())
          goto LABEL_42;
        sub_100054530("pairing confirmation does not match %!", 0);
        v79 = sub_1000544A0(0x43u);
        if (!os_log_type_enabled(v79, OS_LOG_TYPE_ERROR))
          goto LABEL_42;
        goto LABEL_143;
      }
      *(_QWORD *)(v7 + 104) = 0;
      *(_QWORD *)(v7 + 112) = 0;
      v88 = sub_1002393C4(*(_QWORD *)v7, (__int128 *)(v7 + 473));
      if ((_DWORD)v88)
      {
        v89 = v88;
        if (!sub_10005549C())
          goto LABEL_22;
        sub_100054530("smpSendPairingRandom failed %!", v89);
        v90 = sub_1000544A0(0x43u);
        if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR))
          goto LABEL_22;
        goto LABEL_178;
      }
      v99 = ++*(_BYTE *)(v7 + 489);
      if (v99 <= 0x13)
      {
        v100 = sub_10023122C(v7);
        if ((_DWORD)v100)
        {
          v101 = v100;
          if (!sub_10005549C())
            goto LABEL_22;
          sub_100054530("smpDoOneLeSecuredConnectionPasskeyAuthItteration returned %!", v101);
          v102 = sub_1000544A0(0x43u);
          if (!os_log_type_enabled(v102, OS_LOG_TYPE_ERROR))
            goto LABEL_22;
          goto LABEL_178;
        }
        v103 = v7;
        v104 = 34;
LABEL_170:
        sub_1001EE5A0(v103, v104);
        return;
      }
    }
    v103 = v7;
    v104 = 38;
    goto LABEL_170;
  }
LABEL_65:
  if (*((_BYTE *)a1 + 70) == 1)
  {
    v33 = sub_1002393C4((uint64_t)a1, (__int128 *)(v7 + 473));
    if ((_DWORD)v33)
    {
      v34 = v33;
      if (!sub_10005549C())
        goto LABEL_22;
      sub_100054530("Failed to send Nb to central with status %!", v34);
      v35 = sub_1000544A0(0x43u);
      if (!os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        goto LABEL_22;
      goto LABEL_103;
    }
    sub_1001EE5A0(v7, 38);
    if (*(_BYTE *)(v7 + 16) == 6)
    {
      LODWORD(v113) = 0;
      v63 = *(_OWORD *)(v7 + 328);
      v111 = *(_OWORD *)(v7 + 312);
      v112 = v63;
      v64 = *(_OWORD *)(v7 + 168);
      v109 = *(_OWORD *)(v7 + 152);
      v110 = v64;
      sub_10018559C(&v111, &v109, (__int128 *)(v7 + 457), (__int128 *)(v7 + 473), &v113);
      if ((_DWORD)v65)
      {
        v66 = v65;
        if (!sub_10005549C())
          goto LABEL_22;
        sub_100054530("Failed to generate vb with status %!", v66);
        v67 = sub_1000544A0(0x43u);
        if (!os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
          goto LABEL_22;
        goto LABEL_178;
      }
      if (!off_1009990F0)
      {
        v15 = a1;
        v16 = 12;
        goto LABEL_23;
      }
      v91 = v113 % 0xF4240;
      LODWORD(v113) = v113 % 0xF4240;
LABEL_173:
      *(_WORD *)(v7 + 33) = v91;
      *(_BYTE *)(v7 + 35) = BYTE2(v91);
      *(_BYTE *)(v7 + 36) = 0;
      *(_DWORD *)(v7 + 52) = 4;
      sub_1002390F8(*(_QWORD *)v7);
      return;
    }
    return;
  }
  v113 = 0uLL;
  v53 = *(_OWORD *)(v7 + 168);
  v111 = *(_OWORD *)(v7 + 152);
  v112 = v53;
  v54 = *(_OWORD *)(v7 + 328);
  v109 = *(_OWORD *)(v7 + 312);
  v110 = v54;
  v55 = sub_100184FB4(&v109, &v111, (__int128 *)(v7 + 473), 0, &v113);
  if ((_DWORD)v55)
  {
    v56 = v55;
    if (!sub_10005549C())
      goto LABEL_22;
    sub_100054530("Failed to generate confirmation value Cb with status %!", v56);
    v57 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
      goto LABEL_22;
    goto LABEL_178;
  }
  if ((_QWORD)v113 != *(_QWORD *)(v7 + 104) || *((_QWORD *)&v113 + 1) != *(_QWORD *)(v7 + 112))
  {
    if (!sub_10005549C())
      goto LABEL_42;
    sub_100054530("Mismatch in Confirm calculations");
    v77 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v77, OS_LOG_TYPE_ERROR))
      goto LABEL_42;
    goto LABEL_143;
  }
  sub_1001EE5A0(v7, 39);
  if (*(_BYTE *)(v7 + 16) == 6)
  {
    v108 = 0;
    v83 = *(_OWORD *)(v7 + 168);
    v111 = *(_OWORD *)(v7 + 152);
    v112 = v83;
    v84 = *(_OWORD *)(v7 + 328);
    v109 = *(_OWORD *)(v7 + 312);
    v110 = v84;
    sub_10018559C(&v111, &v109, (__int128 *)(v7 + 457), (__int128 *)(v7 + 473), &v108);
    if ((_DWORD)v85)
    {
      v86 = v85;
      if (sub_10005549C())
      {
        sub_100054530("Failed to generate vb with status %!", v86);
        v87 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v87, OS_LOG_TYPE_ERROR))
          sub_1006CEEC0();
      }
      goto LABEL_22;
    }
    if (!off_1009990F0)
    {
      v15 = a1;
      v16 = 5;
      goto LABEL_23;
    }
    v91 = v108 % 0xF4240;
    v108 %= 0xF4240u;
    goto LABEL_173;
  }
  v92 = sub_100230D24((__int128 **)v7);
  if ((_DWORD)v92)
  {
    v93 = v92;
    if (!sub_10005549C())
      goto LABEL_22;
    sub_100054530("Failed to send DHKey value with status %!", v93);
    v94 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
      goto LABEL_22;
    goto LABEL_178;
  }
}

void sub_100234A84(uint64_t a1, unsigned __int8 *a2, int a3)
{
  uint64_t *v5;
  char *v6;
  int v7;
  NSObject *v8;
  NSObject *v9;
  NSObject *v10;
  uint64_t v11;

  v5 = (uint64_t *)sub_1001EE0AC(a1);
  if (v5)
  {
    v6 = (char *)v5;
    sub_1001EE4C0(v5);
    if (a3 == 1)
    {
      v7 = *a2;
    }
    else
    {
      if (sub_10005549C())
      {
        sub_100054530("Invalid Pairing Failed size %d", a3);
        v9 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      v7 = 8;
    }
    if (sub_10005549C())
    {
      sub_100054530("Peer sent Pairing Failed with reason=%d", v7);
      v10 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    v11 = sub_1001EE568(v7);
    sub_1001EDD30(v6, v11, 1);
  }
  else if (sub_10005549C())
  {
    sub_100054530("Could not find associated pairing data.");
    v8 = sub_1000544A0(0x43u);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
}

__n128 sub_100234BBC(uint64_t a1, __n128 *a2, int a3)
{
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  char v8;
  NSObject *v10;
  NSObject *v11;
  __n128 result;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;
  const char *v16;
  NSObject *v17;

  if (a3 != 16)
  {
    if (!sub_10005549C())
      goto LABEL_14;
    sub_100054530("Invalid Encrypt Information size %d", a3);
    v10 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      goto LABEL_14;
LABEL_13:
    sub_1006CE7A4();
LABEL_14:
    v6 = 0;
LABEL_15:
    sub_1002306D8((__int128 *)a1, 8, (char *)v6);
    return result;
  }
  v5 = (uint64_t *)sub_1001EE0AC(a1);
  if (!v5)
  {
    if (!sub_10005549C())
      goto LABEL_14;
    sub_100054530("Could not find associated pairing data.");
    v11 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      goto LABEL_14;
    goto LABEL_13;
  }
  v6 = (uint64_t)v5;
  sub_1001EE4C0(v5);
  if (!*(_BYTE *)(v6 + 9))
  {
    if (!sub_10005549C())
      goto LABEL_15;
    sub_100054530("The link is not encrypted, dumping LTK");
    v13 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      goto LABEL_15;
LABEL_19:
    sub_1006CE7A4();
    goto LABEL_15;
  }
  if ((*(unsigned __int8 *)(v6 + 75) | 8) != 8)
  {
    if (sub_10005549C())
    {
      sub_100054530("We got LTK after some other keys.");
      v14 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    goto LABEL_25;
  }
  if (!*(_BYTE *)(a1 + 70))
  {
    v7 = v6;
    v8 = 66;
    goto LABEL_24;
  }
  if (!sub_1001EE68C(v6, 67))
  {
    if (!sub_10005549C())
      goto LABEL_15;
    v16 = sub_1001EE594();
    sub_100054530("Central is sending keys before we are (state is %s).", v16);
    v17 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      goto LABEL_15;
    goto LABEL_19;
  }
  v7 = v6;
  v8 = 64;
LABEL_24:
  sub_1001EE5A0(v7, v8);
LABEL_25:
  if ((*(_BYTE *)(v6 + 74) & 1) != 0)
  {
    if ((sub_100232438(a2, *(unsigned __int8 *)(v6 + 81)) & 1) == 0)
      *(_BYTE *)(v6 + 612) = 1;
    result = *a2;
    *(__n128 *)(v6 + 508) = *a2;
  }
  else if (sub_10005549C())
  {
    sub_100054530("We were not expecting LTK...");
    v15 = sub_1000544A0(0x43u);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  return result;
}

void sub_100234E28(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t *v5;
  uint64_t v6;
  int v7;
  NSObject *v8;
  NSObject *v10;
  NSObject *v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;
  uint64_t v16;
  BOOL v17;

  if (a3 != 10)
  {
    if (!sub_10005549C())
      goto LABEL_19;
    sub_100054530("Invalid Central Identification size %d", a3);
    v10 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      goto LABEL_19;
LABEL_18:
    sub_1006CE7A4();
LABEL_19:
    v6 = 0;
    goto LABEL_20;
  }
  v5 = (uint64_t *)sub_1001EE0AC(a1);
  if (!v5)
  {
    if (!sub_10005549C())
      goto LABEL_19;
    sub_100054530("Could not find associated pairing data.");
    v11 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      goto LABEL_19;
    goto LABEL_18;
  }
  v6 = (uint64_t)v5;
  sub_1001EE4C0(v5);
  if (!*(_BYTE *)(v6 + 9))
  {
    if (!sub_10005549C())
      goto LABEL_20;
    sub_100054530("The link is not encrypted, dumping EDIV/Rand");
    v12 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      goto LABEL_20;
LABEL_12:
    sub_1006CE7A4();
LABEL_20:
    sub_1002306D8((__int128 *)a1, 8, (char *)v6);
    return;
  }
  if ((*(unsigned __int8 *)(v6 + 75) | 8) == 8)
  {
    v7 = *(unsigned __int8 *)(a1 + 70);
    if (v7 == 1)
    {
      if (!sub_1001EE68C(v6, 64))
        goto LABEL_10;
      v7 = *(unsigned __int8 *)(a1 + 70);
    }
    if (!v7 && !sub_1001EE68C(v6, 66))
    {
LABEL_10:
      if (!sub_10005549C())
        goto LABEL_20;
      sub_100054530("We got a EDIV/RAND without a LTK.");
      v8 = sub_1000544A0(0x43u);
      if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        goto LABEL_20;
      goto LABEL_12;
    }
  }
  else if (sub_10005549C())
  {
    sub_100054530("We got EDIV/RAND after some other keys.");
    v13 = sub_1000544A0(0x43u);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  if ((*(_BYTE *)(v6 + 74) & 1) == 0)
  {
    if (!sub_10005549C())
      goto LABEL_38;
    sub_100054530("We were not expecting LTK...");
    v14 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      goto LABEL_38;
    goto LABEL_30;
  }
  *(_BYTE *)(v6 + 75) |= 1u;
  *(_WORD *)(v6 + 542) = *(_WORD *)a2;
  *(_QWORD *)(v6 + 546) = *(_QWORD *)(a2 + 2);
  v17 = *(_BYTE *)(v6 + 16) != 1;
  if (!*(_BYTE *)(v6 + 612))
  {
    if (unk_1009990D8 && (*(_BYTE *)(v6 + 80) & 1) != 0)
    {
      v16 = a1 + 48;
      unk_1009990D8(v16, 0, v6 + 508, 16, 0);
      unk_1009990D8(v16, 1, v6 + 81, 1, 0);
      unk_1009990D8(v16, 2, &v17, 1, 0);
      unk_1009990D8(v16, 3, v6 + 542, 2, 0);
      unk_1009990D8(v16, 4, v6 + 546, 8, 0);
    }
    goto LABEL_38;
  }
  if (sub_10005549C())
  {
    sub_100054530("Compromised device, dropping keys");
    v15 = sub_1000544A0(0x43u);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
LABEL_30:
      sub_1006CE7A4();
  }
LABEL_38:
  sub_1002396C4((char *)v6);
}

__n128 sub_100235198(uint64_t a1, __n128 *a2, int a3)
{
  uint64_t *v5;
  uint64_t v6;
  char v7;
  NSObject *v9;
  NSObject *v10;
  __n128 result;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;

  if (a3 != 16)
  {
    if (!sub_10005549C())
      goto LABEL_14;
    sub_100054530("Invalid Identity Information size %d", a3);
    v9 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      goto LABEL_14;
LABEL_13:
    sub_1006CE7A4();
LABEL_14:
    v6 = 0;
LABEL_15:
    sub_1002306D8((__int128 *)a1, 8, (char *)v6);
    return result;
  }
  v5 = (uint64_t *)sub_1001EE0AC(a1);
  if (!v5)
  {
    if (!sub_10005549C())
      goto LABEL_14;
    sub_100054530("Could not find associated pairing data.");
    v10 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      goto LABEL_14;
    goto LABEL_13;
  }
  v6 = (uint64_t)v5;
  sub_1001EE4C0(v5);
  if (!*(_BYTE *)(v6 + 9))
  {
    if (!sub_10005549C())
      goto LABEL_15;
    sub_100054530("The link is not encrypted, dumping IRK");
    v12 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      goto LABEL_15;
LABEL_19:
    sub_1006CE7A4();
    goto LABEL_15;
  }
  if (*(_BYTE *)(v6 + 75))
    goto LABEL_22;
  if (!*(_BYTE *)(a1 + 70))
  {
    v7 = 66;
    goto LABEL_21;
  }
  if (!sub_1001EE68C(v6, 67))
  {
    if (!sub_10005549C())
      goto LABEL_15;
    sub_100054530("Central is sending keys before we are ...");
    v14 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      goto LABEL_15;
    goto LABEL_19;
  }
  v7 = 64;
LABEL_21:
  sub_1001EE5A0(v6, v7);
LABEL_22:
  if ((*(_BYTE *)(v6 + 74) & 2) != 0)
  {
    result = *a2;
    *(__n128 *)(v6 + 562) = *a2;
  }
  else if (sub_10005549C())
  {
    sub_100054530("We were not expecting IRK...");
    v13 = sub_1000544A0(0x43u);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  return result;
}

void sub_100235394(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t *v5;
  uint64_t v6;
  int v7;
  NSObject *v8;
  NSObject *v10;
  NSObject *v11;
  int v12;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;
  BOOL v16;
  _QWORD *v17;
  _QWORD *v18;
  BOOL v19;
  NSObject *v20;
  NSObject *v21;
  uint64_t v22;
  NSObject *v23;
  _BYTE v24[7];

  if (a3 != 7)
  {
    if (!sub_10005549C())
      goto LABEL_20;
    sub_100054530("Invalid Identity Address Information size %d", a3);
    v10 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      goto LABEL_20;
LABEL_19:
    sub_1006CE7A4();
LABEL_20:
    v6 = 0;
    goto LABEL_21;
  }
  v5 = (uint64_t *)sub_1001EE0AC(a1);
  if (!v5)
  {
    if (!sub_10005549C())
      goto LABEL_20;
    sub_100054530("Could not find associated pairing data.");
    v11 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      goto LABEL_20;
    goto LABEL_19;
  }
  v6 = (uint64_t)v5;
  sub_1001EE4C0(v5);
  if (!*(_BYTE *)(v6 + 9))
  {
    if (!sub_10005549C())
      goto LABEL_21;
    sub_100054530("The link is not encrypted, dumping Remote address");
    v13 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      goto LABEL_21;
LABEL_25:
    sub_1006CE7A4();
    goto LABEL_21;
  }
  if (*(_BYTE *)(v6 + 75))
    goto LABEL_10;
  v7 = *(unsigned __int8 *)(a1 + 70);
  if (v7 == 1)
  {
    if (!sub_1001EE68C(v6, 64))
      goto LABEL_33;
    v7 = *(unsigned __int8 *)(a1 + 70);
  }
  if (!v7 && !sub_1001EE68C(v6, 66))
  {
LABEL_33:
    if (!sub_10005549C())
      goto LABEL_21;
    sub_100054530("We got an address without IRK.");
    v15 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      goto LABEL_21;
    goto LABEL_25;
  }
LABEL_10:
  if ((*(_BYTE *)(v6 + 74) & 2) == 0)
  {
    if (!sub_10005549C())
      goto LABEL_32;
    sub_100054530("We were not expecting address info...");
    v8 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      goto LABEL_32;
    goto LABEL_13;
  }
  *(_BYTE *)(v6 + 75) |= 2u;
  if (!*(_BYTE *)(v6 + 612))
  {
    if (!unk_1009990D8 || (*(_BYTE *)(v6 + 80) & 1) == 0)
      goto LABEL_32;
    v24[0] = *(_BYTE *)a2;
    *(_DWORD *)&v24[1] = *(_DWORD *)(a2 + 1);
    *(_WORD *)&v24[5] = *(_WORD *)(a2 + 5);
    sub_1001ED8B0(&v24[1], 6);
    if (v24[0] && (v24[0] != 1 || v24[1] <= 0xBFu))
    {
      if (!sub_10005549C())
        goto LABEL_21;
      sub_100054530("We got a remote address (%:) that is neither public nor static!", &v24[1]);
      v21 = sub_1000544A0(0x43u);
      if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        goto LABEL_21;
      goto LABEL_54;
    }
    if (*(_DWORD *)v24)
      v16 = 0;
    else
      v16 = *(unsigned __int16 *)&v24[4] == 0;
    if (!v16)
    {
      *(_BYTE *)(a1 + 55) = 1;
      *(_DWORD *)(a1 + 56) = *(_DWORD *)v24;
      *(_DWORD *)(a1 + 59) = *(_DWORD *)&v24[3];
      v17 = (_QWORD *)sub_10022DD88(v24);
      if (!v17
        || ((v18 = v17, *v17 == *(_QWORD *)(v6 + 562)) ? (v19 = v17[1] == *(_QWORD *)(v6 + 570)) : (v19 = 0), v19))
      {
        v22 = a1 + 48;
        unk_1009990D8(v22, 10, v6 + 562, 16, 0);
        unk_1009990D8(v22, 11, v24, 7, 0);
        goto LABEL_32;
      }
      if (sub_10005549C())
      {
        sub_100054530("device %: is already paired, with a different irk (old:%@ new %@). Unpair first and then restart pairing.", a1 + 57, v18, 16, v6 + 562, 16);
        v20 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      v12 = 240;
LABEL_22:
      sub_1002306D8((__int128 *)a1, v12, (char *)v6);
      return;
    }
    if (sub_10005549C())
    {
      sub_100054530("Identity address cannot be all 0.");
      v23 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
LABEL_54:
        sub_1006CE7A4();
    }
LABEL_21:
    v12 = 8;
    goto LABEL_22;
  }
  if (!sub_10005549C())
    goto LABEL_32;
  sub_100054530("Compromised device, dropping keys");
  v14 = sub_1000544A0(0x43u);
  if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    goto LABEL_32;
LABEL_13:
  sub_1006CE7A4();
LABEL_32:
  sub_1002396C4((char *)v6);
}

void sub_1002357D4(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t *v4;
  char *v5;
  char v6;
  NSObject *v8;
  NSObject *v9;
  NSObject *v10;
  NSObject *v11;
  NSObject *v12;

  if (a3 != 16)
  {
    if (!sub_10005549C())
      goto LABEL_14;
    sub_100054530("Invalid Signing Information size %d", a3);
    v8 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      goto LABEL_14;
LABEL_13:
    sub_1006CE7A4();
LABEL_14:
    v5 = 0;
    goto LABEL_15;
  }
  v4 = (uint64_t *)sub_1001EE0AC(a1);
  if (!v4)
  {
    if (!sub_10005549C())
      goto LABEL_14;
    sub_100054530("Could not find associated pairing data.");
    v9 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      goto LABEL_14;
    goto LABEL_13;
  }
  v5 = (char *)v4;
  sub_1001EE4C0(v4);
  if (!v5[9])
  {
    if (!sub_10005549C())
      goto LABEL_15;
    sub_100054530("The link is not encrypted.");
    v10 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      goto LABEL_15;
    goto LABEL_18;
  }
  if (!v5[75])
  {
    if (!*(_BYTE *)(a1 + 70))
    {
      v6 = 66;
      goto LABEL_20;
    }
    if (sub_1001EE68C((uint64_t)v5, 67))
    {
      v6 = 64;
LABEL_20:
      sub_1001EE5A0((uint64_t)v5, v6);
      goto LABEL_21;
    }
    if (sub_10005549C())
    {
      sub_100054530("Central is sending keys before we are ...");
      v12 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
LABEL_18:
        sub_1006CE7A4();
    }
LABEL_15:
    sub_1002306D8((__int128 *)a1, 8, v5);
    return;
  }
LABEL_21:
  if ((v5[74] & 4) != 0)
  {
    v5[75] |= 4u;
  }
  else if (sub_10005549C())
  {
    sub_100054530("We were not expecting CSRK...");
    v11 = sub_1000544A0(0x43u);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  sub_1002396C4(v5);
}

void sub_1002359D4(uint64_t a1, char *a2, int a3)
{
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  char v10;
  _BYTE *v11;
  _BYTE *v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  NSObject *v16;
  __int128 buf;

  if (xmmword_10098FC56 == 0 || xmmword_10098FC76 == 0)
  {
    if (!sub_10005549C())
      goto LABEL_10;
    sub_100054530("Root keys are not set, can't pair.");
    v7 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      goto LABEL_10;
    goto LABEL_9;
  }
  if (!sub_1001EE0AC(a1))
  {
    if (a3 == 1)
    {
      if (*(_BYTE *)(a1 + 166) == 2)
      {
        if (sub_10005549C())
        {
          sub_100054530("There is already an encryption in progress on this link, ignoring this request");
          v8 = sub_1000544A0(0x43u);
          if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
            goto LABEL_6;
        }
      }
      else
      {
        v10 = *a2;
        v11 = sub_1001EE3C4(a1);
        v12 = v11;
        if (v11)
        {
          v11[80] = v10;
          sub_1001EE5A0((uint64_t)v11, 16);
        }
        if (*(_DWORD *)(a1 + 132) == 7)
        {
          *((_QWORD *)&buf + 1) = v12;
          *(_QWORD *)&buf = 8;
          v13 = sub_10004A9EC((uint64_t)sub_10023796C, (const void **)&buf, 0, 0);
          if ((_DWORD)v13)
          {
            v14 = v13;
            if (sub_10005549C())
            {
              sub_100054530("Could not dispatch SecurityRequest CB with status %!.", v14);
              v15 = sub_1000544A0(0x43u);
              if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
                sub_1006CEEC0();
            }
          }
        }
        else if (sub_10005549C())
        {
          sub_100054530("Got Security request before link is ready for handle %p, lets handle this when the link is actually ready. Link state is %d", (const void *)a1, *(_DWORD *)(a1 + 132));
          v16 = sub_1000544A0(0x43u);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 136446210;
            *(_QWORD *)((char *)&buf + 4) = sub_100054494();
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, " %{public}s", (uint8_t *)&buf, 0xCu);
          }
        }
      }
      return;
    }
    if (!sub_10005549C()
      || (sub_100054530("Invalid Security Request size %d", a3),
          v9 = sub_1000544A0(0x43u),
          !os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)))
    {
LABEL_10:
      LOWORD(buf) = 2053;
      sub_1001EE0F4((__int128 *)a1, (char *)&buf, 2uLL, 0);
      return;
    }
LABEL_9:
    sub_1006CE7A4();
    goto LABEL_10;
  }
  if (sub_10005549C())
  {
    sub_100054530("There is already a pairing request for this connection. Ignoring request.");
    v6 = sub_1000544A0(0x43u);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
LABEL_6:
      sub_1006CE7A4();
  }
}

void sub_100235CB4(uint64_t a1, __int128 *a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  NSObject *v23;
  int v24;
  __int128 *v25;
  const char *v26;
  NSObject *v27;
  const char *v28;
  NSObject *v29;
  uint64_t v30;
  uint64_t v31;
  NSObject *v32;
  uint64_t v33;
  uint64_t v34;
  NSObject *v35;
  int v36;
  __int128 v37;
  __int128 v38;
  uint64_t v39;
  uint64_t v40;
  NSObject *v41;
  NSObject *v42;
  uint64_t v43;
  uint64_t v44;
  NSObject *v45;
  unsigned int v46;
  char v47;
  char v48;
  _OWORD __s2[6];
  _BYTE __buf[17];
  __int128 v51;
  __int128 v52;
  __int128 v53;

  v48 = 96;
  memset(__s2, 0, sizeof(__s2));
  v6 = sub_1001EE0AC(a1);
  v12 = v6;
  if (!v6)
  {
    if (!sub_10005549C())
      goto LABEL_63;
    sub_100054530("Could not find associated pairing data.");
    v20 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      goto LABEL_63;
    goto LABEL_39;
  }
  if (a3 != 64)
  {
    if (!sub_10005549C())
      goto LABEL_63;
    sub_100054530("Invalid pairing public key size %d", a3);
    v21 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      goto LABEL_63;
    goto LABEL_39;
  }
  if ((*(_BYTE *)(v6 + 72) & *(_BYTE *)(v6 + 80) & 8) == 0)
  {
    if (!sub_10005549C())
      goto LABEL_63;
    sub_100054530("Both devices should be using secured connection to get this PDU.");
    v22 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      goto LABEL_63;
    goto LABEL_39;
  }
  v13 = *(unsigned __int8 *)(a1 + 70);
  if (!*(_BYTE *)(a1 + 70))
  {
    if (sub_1001EE68C(v6, 33))
    {
      v13 = *(unsigned __int8 *)(a1 + 70);
      goto LABEL_7;
    }
    if (!sub_10005549C())
      goto LABEL_63;
    v28 = sub_1001EE594();
    sub_100054530("Central connection should be in SMP_STATE_PAIRING_SPUBLICK to send this command, current state is %s.", v28);
    v29 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      goto LABEL_63;
LABEL_39:
    sub_1006CE7A4();
LABEL_63:
    sub_1002306D8((__int128 *)a1, 8, (char *)v12);
    return;
  }
LABEL_7:
  if (v13 == 1 && !sub_1001EE68C(v12, 32))
  {
    if (!sub_10005549C())
      goto LABEL_63;
    v26 = sub_1001EE594();
    sub_100054530("Peripheral connection should be in SMP_STATE_PAIRING_MPUBLICK to send this command, current state is %s.", v26);
    v27 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      goto LABEL_63;
    goto LABEL_39;
  }
  v14 = *a2;
  v15 = a2[1];
  v16 = a2[3];
  *(_OWORD *)(v12 + 344) = a2[2];
  *(_OWORD *)(v12 + 360) = v16;
  *(_OWORD *)(v12 + 312) = v14;
  *(_OWORD *)(v12 + 328) = v15;
  if (*(_BYTE *)(*(_QWORD *)v12 + 70) == 1 && *(_BYTE *)(v12 + 16) != 5)
  {
    v30 = sub_1001859C0((_OWORD *)(v12 + 152), (_OWORD *)(v12 + 216), (uint64_t)&v48, v7, v8, v9, v10, v11);
    if ((_DWORD)v30)
    {
      v31 = v30;
      if (!sub_10005549C())
        goto LABEL_63;
      sub_100054530("LE_ReadLocalPublicKey failed %!", v31);
      v32 = sub_1000544A0(0x43u);
      if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
        goto LABEL_63;
    }
    else
    {
      v36 = *(unsigned __int8 *)(v12 + 16);
      if (v36 == 1)
        goto LABEL_11;
      if (v36 == 6)
        goto LABEL_11;
      __buf[0] = 12;
      v37 = *(_OWORD *)(v12 + 168);
      *(_OWORD *)&__buf[1] = *(_OWORD *)(v12 + 152);
      v51 = v37;
      v38 = *(_OWORD *)(v12 + 200);
      v52 = *(_OWORD *)(v12 + 184);
      v53 = v38;
      v39 = sub_1001EE0F4(*(__int128 **)v12, __buf, 0x41uLL, 1);
      if (!(_DWORD)v39)
        goto LABEL_11;
      v40 = v39;
      if (!sub_10005549C())
        goto LABEL_63;
      sub_100054530("smpSendPairingPublicKey failed %!", v40);
      v41 = sub_1000544A0(0x43u);
      if (!os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
        goto LABEL_63;
    }
LABEL_62:
    sub_1006CEEC0();
    goto LABEL_63;
  }
LABEL_11:
  if (!memcmp((const void *)(v12 + 312), __s2, 0x40uLL) || !memcmp((const void *)(v12 + 216), __s2, 0x60uLL))
  {
    if (sub_10005549C())
    {
      sub_100054530("Invalid all zeros public key or all zeros private key");
      v23 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  else
  {
    v17 = sub_100185B44((const void *)(v12 + 312), 0x40u, (const void *)(v12 + 216), 0x60u, (void *)(v12 + 376));
    if ((_DWORD)v17)
    {
      v18 = v17;
      if (!sub_10005549C())
        goto LABEL_63;
      sub_100054530("DHKey generation failed %!", v18);
      v19 = sub_1000544A0(0x43u);
      if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        goto LABEL_63;
      goto LABEL_62;
    }
  }
  v24 = *(unsigned __int8 *)(v12 + 16);
  switch(*(_BYTE *)(v12 + 16))
  {
    case 1:
    case 6:
      if (v24 != 6 && !*(_BYTE *)(v12 + 490))
        return;
      v33 = sub_100230FF0(v12);
      if (!(_DWORD)v33)
        return;
      v34 = v33;
      if (sub_10005549C())
      {
        sub_100054530("recvdSMPDeferredJustWorksNumComparPublicKey failed %!", v34);
        v35 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
          goto LABEL_62;
      }
      goto LABEL_63;
    case 2:
    case 3:
    case 4:
      *(_DWORD *)__buf = 0;
      v25 = *(__int128 **)v12;
      if (*(_BYTE *)(*(_QWORD *)v12 + 70))
      {
        if (*(_BYTE *)(*(_QWORD *)v12 + 70) != 1 || v24 != 3)
          goto LABEL_33;
      }
      else if (v24 != 2)
      {
LABEL_33:
        *(_DWORD *)(v12 + 52) = 2;
        goto LABEL_67;
      }
      arc4random_buf(__buf, 4uLL);
      v46 = *(_DWORD *)__buf % 0xF423Fu + 1;
      *(_DWORD *)__buf = v46;
      *(_WORD *)(v12 + 33) = v46;
      *(_BYTE *)(v12 + 35) = BYTE2(v46);
      *(_BYTE *)(v12 + 36) = 0;
      *(_DWORD *)(v12 + 52) = 1;
      v25 = *(__int128 **)v12;
LABEL_67:
      if (*((_BYTE *)v25 + 70))
        v47 = 34;
      else
        v47 = 35;
      sub_1001EE5A0(v12, v47);
      sub_1002390F8(*(_QWORD *)v12);
      return;
    case 5:
      v43 = sub_100238B40(v12);
      if (!(_DWORD)v43)
        return;
      v44 = v43;
      if (sub_10005549C())
      {
        sub_100054530("recvdSMPDeferredOOBPublicKey failed %!", v44);
        v45 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
          goto LABEL_62;
      }
      goto LABEL_63;
    default:
      if (sub_10005549C())
      {
        sub_100054530("Don't know what to do now");
        v42 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      goto LABEL_63;
  }
}

uint64_t sub_1002362C0(uint64_t a1, _OWORD *a2, int a3)
{
  uint64_t result;
  uint64_t v7;
  int v8;
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  NSObject *v12;
  const char *v13;
  NSObject *v14;
  const char *v15;
  NSObject *v16;

  result = sub_1001EE0AC(a1);
  v7 = result;
  if (!result)
  {
    if (!sub_10005549C())
      return sub_1002306D8((__int128 *)a1, 8, (char *)v7);
    sub_100054530("Could not find associated pairing data.");
    v11 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      return sub_1002306D8((__int128 *)a1, 8, (char *)v7);
    goto LABEL_20;
  }
  if (a3 != 16)
  {
    if (!sub_10005549C())
      return sub_1002306D8((__int128 *)a1, 8, (char *)v7);
    sub_100054530("Invalid pairing DHKey check size %d", a3);
    v12 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      return sub_1002306D8((__int128 *)a1, 8, (char *)v7);
    goto LABEL_20;
  }
  v8 = *(unsigned __int8 *)(a1 + 70);
  if (!*(_BYTE *)(a1 + 70))
  {
    result = sub_1001EE68C(result, 39);
    if ((result & 1) != 0)
    {
      v8 = *(unsigned __int8 *)(a1 + 70);
      goto LABEL_6;
    }
    if (!sub_10005549C())
      return sub_1002306D8((__int128 *)a1, 8, (char *)v7);
    v15 = sub_1001EE594();
    sub_100054530("Central connection should be in SMP_STATE_PAIRING_SDHKEY to send this command, current state is %s.", v15);
    v16 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      return sub_1002306D8((__int128 *)a1, 8, (char *)v7);
LABEL_20:
    sub_1006CE7A4();
    return sub_1002306D8((__int128 *)a1, 8, (char *)v7);
  }
LABEL_6:
  if (v8 == 1)
  {
    result = sub_1001EE68C(v7, 38);
    if ((result & 1) == 0)
    {
      if (!sub_10005549C())
        return sub_1002306D8((__int128 *)a1, 8, (char *)v7);
      v13 = sub_1001EE594();
      sub_100054530("Peripheral connection should be in SMP_STATE_PAIRING_MDHKEY to send this command, current state is %s.", v13);
      v14 = sub_1000544A0(0x43u);
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        return sub_1002306D8((__int128 *)a1, 8, (char *)v7);
      goto LABEL_20;
    }
  }
  *(_OWORD *)(v7 + 492) = *a2;
  *(_BYTE *)(v7 + 491) = 1;
  if (*(_BYTE *)(*(_QWORD *)v7 + 70) != 1 || *(_BYTE *)(v7 + 16) != 6 || *(_BYTE *)(v7 + 490))
  {
    result = sub_100230DFC((__int128 *)a1);
    if ((_DWORD)result)
    {
      v9 = result;
      if (sub_10005549C())
      {
        sub_100054530("recvdSMPDeferredDHKeyCheck Failed %! ", v9);
        v10 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
          sub_1006CEEC0();
      }
      return sub_1002306D8((__int128 *)a1, 8, (char *)v7);
    }
  }
  return result;
}

uint64_t sub_1002364F4(uint64_t a1, int a2, char a3)
{
  uint64_t v6;
  uint64_t result;

  if (!sub_10019AC00(a1))
    sub_100253460();
  v6 = sub_1001EE0AC(a1);
  result = sub_1001EE0AC(a1);
  if (!a2)
  {
    if (result)
      *(_BYTE *)(v6 + 9) = a3;
  }
  return result;
}

void sub_10023654C(uint64_t a1, int a2, int a3)
{
  char v6;
  char v7;
  unsigned __int8 v8;
  unsigned __int8 v9;
  unsigned __int8 v10;
  unsigned __int8 v11;
  char *v12;
  char *v13;
  NSObject *v14;
  char v15;
  int v16;
  int v17;
  int v18;
  unsigned __int8 v19;
  NSObject *v20;
  _DWORD *v21;
  char v22;
  NSObject *v23;
  void *v24;
  char v25;
  uint8_t buf[4];
  void *v27;

  v6 = byte_10097A8E1;
  if (byte_10097A8E1 == 255)
    v6 = 11;
  if (byte_10097A8E2 == 255)
    v7 = 11;
  else
    v7 = byte_10097A8E2;
  v8 = v6 & 0xF7;
  v9 = v7 & 0xF7;
  if (byte_10098FC40)
    v10 = v6 & 0xF7;
  else
    v10 = v6;
  if (byte_10098FC40)
    v11 = v7 & 0xF7;
  else
    v11 = v7;
  if (!sub_10019AC00(a1))
    sub_100253460();
  v12 = (char *)sub_1001EE0AC(a1);
  if (v12)
  {
    v13 = v12;
    if (a2)
    {
      if (sub_1001EE68C((uint64_t)v12, 16) && !*(_BYTE *)(a1 + 70))
      {
        v16 = v13[80] & 4;
        v17 = byte_10098FC44;
        v18 = v16 | v17 | sub_10022408C();
        if ((v13[80] & 8) != 0)
        {
          if ((v10 & 8) != 0 && (v13[80] & 0x20) != 0 && (byte_10098FC42 & 1) == 0)
          {
            if (sub_10005549C())
            {
              sub_100054530("Sending CT2=1");
              v20 = sub_1000544A0(0x43u);
              if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136446210;
                v27 = sub_100054494();
                _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
              }
            }
          }
          v19 = v18 | 0x28;
        }
        else
        {
          v19 = v18 & 0xDF;
          v10 = v8;
          v11 = v9;
        }
        if (*(_BYTE *)(a1 + 55))
          v21 = (_DWORD *)(a1 + 56);
        else
          v21 = 0;
        v22 = sub_10022CCE0((_DWORD *)(a1 + 48), v21);
        if (sub_10005549C())
        {
          sub_100054530("authReq=%x expectedKeys=%x requestedKeys=%x", v19, v10, v11);
          v23 = sub_1000544A0(0x43u);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
          {
            v24 = sub_100054494();
            *(_DWORD *)buf = 136446210;
            v27 = v24;
            _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
          }
        }
        sub_100232AA4(a1, byte_10097A8E3, v22, v19, v10, v11);
      }
      else
      {
        if (sub_10005549C())
        {
          sub_100054530("Could not encrypt the link.");
          v14 = sub_1000544A0(0x43u);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
        sub_1001EDD30(v13, 4802, 1);
      }
    }
    else
    {
      *(_BYTE *)(*(_QWORD *)v12 + 167) = v12[81];
      if (sub_1001EE68C((uint64_t)v12, 16) && !*(_BYTE *)(a1 + 70))
      {
        sub_1001EDD30(v13, 0, 0);
        return;
      }
      if (a3)
      {
        sub_1001EE5A0((uint64_t)v13, 42);
        if (*(_BYTE *)(a1 + 70))
        {
          if (*(_BYTE *)(a1 + 70) != 1)
            return;
          sub_100236968((uint64_t)v13);
          sub_100236ADC((uint64_t)v13);
          v15 = (v13[72] & v13[80] & 8) != 0 ? -10 : -9;
          if ((v15 & v13[74] & 0xF7) != (v15 & v13[75] & 0xF7)
            && (v15 & v13[74]) != 0)
          {
            return;
          }
        }
        else
        {
          if ((v13[72] & v13[80] & 8) != 0)
            v25 = -10;
          else
            v25 = -9;
          if ((v25 & v13[74] & 0xF7) != (v25 & v13[75] & 0xF7)
            && (v25 & v13[74]) != 0)
          {
            return;
          }
          sub_100236968((uint64_t)v13);
          sub_100236ADC((uint64_t)v13);
        }
        sub_1001EDD30(v13, 0, 1);
      }
    }
  }
}

void sub_100236968(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  __int16 v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  __int16 v10;

  if ((*(_BYTE *)(a1 + 72) & *(_BYTE *)(a1 + 80) & 8) != 0)
  {
    sub_1001EE5A0(a1, 128);
    return;
  }
  v10 = 0;
  arc4random_buf((void *)(a1 + 540), 2uLL);
  arc4random_buf((void *)(a1 + 554), 8uLL);
  v2 = sub_1001847A4(&xmmword_10098FC46, (uint64_t *)(a1 + 554), &v10);
  if ((_DWORD)v2)
  {
    v3 = v2;
    if (sub_10005549C())
    {
      sub_100054530("Could not generate DIV %!", v3);
      v4 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
LABEL_6:
        sub_1006CEEC0();
    }
  }
  else
  {
    v5 = *(_WORD *)(a1 + 540);
    *(_WORD *)(a1 + 544) = v5 ^ v10;
    v6 = sub_100184E88(&xmmword_10098FC56, v5, 0, (void *)(a1 + 524));
    if ((_DWORD)v6)
    {
      v7 = v6;
      if (sub_10005549C())
      {
        sub_100054530("Could not generate LTK %!", v7);
        v8 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
          goto LABEL_6;
      }
    }
    else
    {
      v9 = *(unsigned __int8 *)(a1 + 81);
      if (v9 != 16)
        bzero((void *)(a1 + 524 + v9), 16 - v9);
      sub_1001EE5A0(a1, 128);
    }
  }
}

void sub_100236ADC(uint64_t a1)
{
  NSObject *v2;
  char v3;
  char v4;
  unsigned __int8 v5;
  int v6;
  NSObject *v7;
  void *v8;
  NSObject *v9;
  int v10;
  int v11;
  unsigned int v12;
  BOOL v13;
  BOOL v14;
  BOOL v15;
  int v16;
  unint64_t v17;
  uint8x8_t v18;
  int16x8_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  int8x16_t v23;
  uint64x2_t v24;
  NSObject *v25;
  char v26;
  NSObject *v27;
  NSObject *v28;
  NSObject *v29;
  unsigned __int8 v30;
  _DWORD v31[2];
  _BYTE buf[17];

  if (!sub_1001EE68C(a1, 128))
  {
    if (sub_10005549C())
    {
      sub_100054530("SMP State is not GENERATED.");
      v2 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  if (*(_BYTE *)(*(_QWORD *)a1 + 70))
    v3 = 66;
  else
    v3 = 64;
  sub_1001EE5A0(a1, v3);
  if ((*(_BYTE *)(a1 + 72) & *(_BYTE *)(a1 + 80) & 8) != 0)
  {
    if ((*(_BYTE *)(a1 + 80) & 1) != 0 && unk_1009990D8)
    {
      if (*(_BYTE *)(a1 + 16) == 1)
        v4 = 2;
      else
        v4 = 3;
      LOBYTE(v31[0]) = v4;
      unk_1009990D8(*(_QWORD *)a1 + 48, 5, a1 + 524, 16, 0);
      unk_1009990D8(*(_QWORD *)a1 + 48, 7, v31, 1, 0);
      unk_1009990D8(*(_QWORD *)a1 + 48, 6, a1 + 81, 1, 0);
      if (*(_BYTE *)(a1 + 594))
      {
        if (*(_BYTE *)(a1 + 593))
          v5 = 2;
        else
          v5 = 1;
      }
      else
      {
        v5 = 0;
      }
      v30 = v5;
      if (sub_10005549C())
      {
        sub_100054530("deriveLKLTK=%d useH7=%d", v5, *(unsigned __int8 *)(a1 + 593));
        v7 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          v8 = sub_100054494();
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = v8;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
        }
      }
      if (v5)
        unk_1009990D8(*(_QWORD *)a1 + 48, 16, &v30, 1, 0);
      goto LABEL_30;
    }
  }
  else if ((*(_BYTE *)(a1 + 76) & 1) != 0 && (*(_BYTE *)(a1 + 77) & 1) == 0)
  {
    buf[0] = 6;
    *(_OWORD *)&buf[1] = *(_OWORD *)(a1 + 524);
    if (*(_BYTE *)(a1 + 9))
    {
      v6 = sub_1001EE0F4(*(__int128 **)a1, buf, 0x11uLL, 1);
      if (!v6)
      {
        buf[0] = 7;
        *(_WORD *)&buf[1] = *(_WORD *)(a1 + 544);
        *(_QWORD *)&buf[3] = *(_QWORD *)(a1 + 554);
        if (*(_BYTE *)(a1 + 9))
        {
          v6 = sub_1001EE0F4(*(__int128 **)a1, buf, 0xBuLL, 1);
        }
        else
        {
          if (sub_10005549C())
          {
            sub_100054530("This link is not encrypted, cannot send EDIV/RAND.");
            v28 = sub_1000544A0(0x43u);
            if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
              sub_1006CE7A4();
          }
          v6 = 4802;
        }
      }
      if (!*(_BYTE *)(a1 + 612))
      {
        if (!v6 && (*(_BYTE *)(a1 + 80) & 1) != 0 && unk_1009990D8)
        {
          buf[0] = *(_BYTE *)(a1 + 16) != 1;
          unk_1009990D8(*(_QWORD *)a1 + 48, 6, a1 + 81, 1, 0);
          unk_1009990D8(*(_QWORD *)a1 + 48, 7, buf, 1, 0);
          unk_1009990D8(*(_QWORD *)a1 + 48, 8, a1 + 544, 2, 0);
          unk_1009990D8(*(_QWORD *)a1 + 48, 9, a1 + 554, 8, 0);
        }
        goto LABEL_30;
      }
    }
    else
    {
      if (sub_10005549C())
      {
        sub_100054530("This link is not encrypted, cannot send LTK.");
        v27 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      if (!*(_BYTE *)(a1 + 612))
        goto LABEL_30;
    }
    if (sub_10005549C())
    {
      sub_100054530("Compromised device, dropping keys");
      v29 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
LABEL_30:
    *(_BYTE *)(a1 + 77) |= 1u;
  }
  if ((*(_BYTE *)(a1 + 76) & 2) != 0 && (*(_BYTE *)(a1 + 77) & 2) == 0)
  {
    buf[0] = 8;
    buf[1] = *(_BYTE *)sub_1001EDCF0();
    buf[2] = *((_BYTE *)sub_1001EDCF0() + 1);
    buf[3] = *((_BYTE *)sub_1001EDCF0() + 2);
    buf[4] = *((_BYTE *)sub_1001EDCF0() + 3);
    buf[5] = *((_BYTE *)sub_1001EDCF0() + 4);
    buf[6] = *((_BYTE *)sub_1001EDCF0() + 5);
    buf[7] = *((_BYTE *)sub_1001EDCF0() + 6);
    buf[8] = *((_BYTE *)sub_1001EDCF0() + 7);
    buf[9] = *((_BYTE *)sub_1001EDCF0() + 8);
    buf[10] = *((_BYTE *)sub_1001EDCF0() + 9);
    buf[11] = *((_BYTE *)sub_1001EDCF0() + 10);
    buf[12] = *((_BYTE *)sub_1001EDCF0() + 11);
    buf[13] = *((_BYTE *)sub_1001EDCF0() + 12);
    buf[14] = *((_BYTE *)sub_1001EDCF0() + 13);
    buf[15] = *((_BYTE *)sub_1001EDCF0() + 14);
    buf[16] = *((_BYTE *)sub_1001EDCF0() + 15);
    if (*(_BYTE *)(a1 + 9))
    {
      sub_1001EE0F4(*(__int128 **)a1, buf, 0x11uLL, 1);
    }
    else if (sub_10005549C())
    {
      sub_100054530("This link is not encrypted, cannot send IRK.");
      v9 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    v10 = *(_DWORD *)(*(_QWORD *)a1 + 236);
    if (v10 == 1)
    {
      v11 = 0;
    }
    else if (v10 || (*(_BYTE *)(a1 + 76) & 8) != 0 && (*(_BYTE *)(a1 + 74) & 8) != 0)
    {
      v11 = 1;
    }
    else
    {
      v11 = sub_1000F3970(*(_QWORD *)a1);
    }
    memset(v31, 0, 7);
    sub_100073B84((uint64_t)v31);
    if (LOBYTE(v31[0])
      && ((v12 = *(unsigned __int8 *)(*(_QWORD *)a1 + 24), *(_WORD *)(*(_QWORD *)a1 + 20) == 13)
        ? (v13 = v12 >= 0xB)
        : (v13 = 1),
          v13 ? (v14 = v12 >= 0xA) : (v14 = 0),
          v14 ? (v15 = byte_10097A8E4 == 0) : (v15 = 0),
          !v15 ? (v16 = 1) : (v16 = v11),
          v16 != 1))
    {
      v22 = sub_10022BE30();
      v17 = sub_1000746A4(v22);
      v31[0] = v17;
      BYTE2(v31[1]) = BYTE6(v17);
      LOWORD(v31[1]) = WORD2(v17);
      v23.i64[0] = 0xFFFFFFFFFFFFFFLL;
      v23.i64[1] = 0xFFFFFFFFFFFFFFLL;
      v24 = (uint64x2_t)vandq_s8((int8x16_t)vdupq_n_s64(v17), v23);
      v19 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v24, (uint64x2_t)xmmword_10073B7B0), (int32x4_t)vshlq_u64(v24, (uint64x2_t)xmmword_10073B7A0));
      *(int16x4_t *)v19.i8 = vmovn_s32((int32x4_t)v19);
      v20 = v17 >> 16;
      v21 = v17 >> 8;
    }
    else
    {
      sub_1002246D4((uint64_t)v31);
      LOBYTE(v17) = v31[0];
      v18.i32[0] = *(_DWORD *)((char *)v31 + 3);
      v19 = (int16x8_t)vmovl_u8(v18);
      *(int16x4_t *)v19.i8 = vrev64_s16(*(int16x4_t *)v19.i8);
      LOBYTE(v20) = BYTE2(v31[0]);
      LOBYTE(v21) = BYTE1(v31[0]);
    }
    buf[0] = 9;
    buf[1] = v17;
    *(_DWORD *)&buf[2] = vmovn_s16(v19).u32[0];
    buf[6] = v20;
    buf[7] = v21;
    if (*(_BYTE *)(a1 + 9))
    {
      sub_1001EE0F4(*(__int128 **)a1, buf, 8uLL, 1);
    }
    else if (sub_10005549C())
    {
      sub_100054530("This link is not encrypted, cannot send address.");
      v25 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    *(_BYTE *)(a1 + 77) |= 2u;
  }
  if (*(_BYTE *)(*(_QWORD *)a1 + 70))
    v26 = 67;
  else
    v26 = 65;
  sub_1001EE5A0(a1, v26);
}

uint64_t sub_1002371D4(uint64_t a1, _OWORD *a2, _BYTE *a3)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  char v9;
  __int128 v10;
  uint64_t result;
  NSObject *v12;
  NSObject *v13;

  if (!sub_10019AC00(a1))
    sub_100253460();
  v6 = sub_1001EE0AC(a1);
  if (v6)
  {
    v7 = v6;
    if (sub_1001EE68C(v6, 41))
    {
      v8 = *(unsigned __int8 *)(v7 + 16);
      if ((*(_BYTE *)(v7 + 72) & *(_BYTE *)(v7 + 80) & 8) != 0)
      {
        if (v8 == 1)
          v9 = 2;
        else
          v9 = 3;
        *a3 = v9;
        if (!a2)
          return 1;
        v10 = *(_OWORD *)(v7 + 524);
      }
      else
      {
        *a3 = v8 != 1;
        if (!a2)
          return 1;
        v10 = *(_OWORD *)(v7 + 56);
      }
      *a2 = v10;
      return 1;
    }
    result = sub_10005549C();
    if ((_DWORD)result)
    {
      sub_100054530("STK not generated for handle 0x%x", a1);
      v13 = sub_1000544A0(0x43u);
      result = os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
      if ((_DWORD)result)
      {
LABEL_16:
        sub_1006CE7A4();
        return 0;
      }
    }
  }
  else
  {
    result = sub_10005549C();
    if ((_DWORD)result)
    {
      sub_100054530("There is no pairing data for this connection.");
      v12 = sub_1000544A0(0x43u);
      result = os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
      if ((_DWORD)result)
        goto LABEL_16;
    }
  }
  return result;
}

uint64_t sub_100237304(uint64_t *a1, __int16 a2, void *a3)
{
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  __int16 v10;

  v10 = 0;
  v5 = sub_1001847A4(&xmmword_10098FC46, a1, &v10);
  if ((_DWORD)v5)
  {
    v6 = v5;
    if (sub_10005549C())
    {
      sub_100054530("Could not generate DIV %!", v6);
      v7 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
LABEL_8:
        sub_1006CEEC0();
    }
  }
  else
  {
    v6 = sub_100184E88(&xmmword_10098FC56, v10 ^ a2, 0, a3);
    if ((_DWORD)v6)
    {
      if (sub_10005549C())
      {
        sub_100054530("Could not generate LTK %!", v6);
        v8 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
          goto LABEL_8;
      }
    }
  }
  return v6;
}

uint64_t sub_100237408(__int16 *a1, int a2)
{
  __int128 *v4;
  NSObject *v5;
  uint64_t v6;
  __int128 *v7;
  const char *v8;
  NSObject *v9;
  NSObject *v10;
  uint8_t buf[4];
  void *v13;

  if ((unsigned __int16)*a1 | *((unsigned __int8 *)a1 + 2))
  {
    if (a2)
      v4 = sub_1001EDCFC();
    else
      v4 = sub_1001EDCF0();
    v7 = v4;
    if (*v4 == 0)
    {
      if (sub_10005549C())
      {
        sub_100054530("Cannot generate local random address when the IRK is set to 0's");
        v10 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return 103;
    }
    else
    {
      v6 = sub_10018489C(v4, a1, (uint64_t)a1 + 3);
      if (sub_10002825C() && sub_10005549C())
      {
        v8 = "Primary";
        if (a2)
          v8 = "Secondary";
        sub_100054530("******* GENERATING RANDOM ADDRESS WITH %s IRK:%@ address:%@ AH result:%d", v8, v7, 16, a1, 6, v6);
        v9 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446210;
          v13 = sub_100054494();
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
        }
      }
    }
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("Cannot generate local random address when the address bytes are set to 0's");
      v5 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 101;
  }
  return v6;
}

void sub_1002375DC(_BYTE *a1, uint64_t a2)
{
  NSObject *v3;
  uint64_t v5;
  char *v6;
  NSObject *v7;
  const char *v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  const char *v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  NSObject *v17;
  const char *v18;
  NSObject *v19;
  _BYTE *v20;
  __int128 buf;

  v20 = a1;
  if ((_DWORD)a2)
  {
    if (sub_10005549C())
    {
      sub_100054530("Link ready CB with status %!(%d).", a2, a2);
      v3 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
LABEL_31:
        sub_1006CE7A4();
    }
  }
  else
  {
    v5 = sub_1001EE0AC((uint64_t)a1);
    if (v5)
    {
      v6 = (char *)v5;
      if (a1[166] == 1)
      {
        if (sub_10005549C())
        {
          sub_100054530("Connection %p is already encrypted, lets drop this pairing data", a1);
          v7 = sub_1000544A0(0x43u);
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 136446210;
            *(_QWORD *)((char *)&buf + 4) = sub_100054494();
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, " %{public}s", (uint8_t *)&buf, 0xCu);
          }
        }
        sub_1001EDD30(v6, 0, 0);
      }
      else if (sub_1001EE68C(v5, 16))
      {
        if (sub_10005549C())
        {
          v8 = sub_1001EE594();
          sub_100054530("continue deferred handling of incoming Security Request from device %: (%s)", a1 + 49, v8);
          v9 = sub_1000544A0(0x43u);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 136446210;
            *(_QWORD *)((char *)&buf + 4) = sub_100054494();
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, " %{public}s", (uint8_t *)&buf, 0xCu);
          }
        }
        *((_QWORD *)&buf + 1) = v6;
        *(_QWORD *)&buf = 8;
        v10 = sub_10004A9EC((uint64_t)sub_10023796C, (const void **)&buf, 5, 0);
        if ((_DWORD)v10)
        {
          v11 = v10;
          if (sub_10005549C())
          {
            sub_100054530("Could not dispatch SecurityRequest CB with status %!.", v11);
            v12 = sub_1000544A0(0x43u);
            if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
              sub_1006CEEC0();
          }
        }
      }
      else if (sub_1001EE68C((uint64_t)v6, 17))
      {
        if (sub_10005549C())
        {
          v13 = sub_1001EE594();
          sub_100054530("continue deferred handling of incoming Pairing Request from device %: (%s)", a1 + 49, v13);
          v14 = sub_1000544A0(0x43u);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 136446210;
            *(_QWORD *)((char *)&buf + 4) = sub_100054494();
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, " %{public}s", (uint8_t *)&buf, 0xCu);
          }
        }
        *((_QWORD *)&buf + 1) = &v20;
        *(_QWORD *)&buf = 8;
        v15 = sub_10004A9EC((uint64_t)sub_100237A60, (const void **)&buf, 5, 0);
        if ((_DWORD)v15)
        {
          v16 = v15;
          if (sub_10005549C())
          {
            sub_100054530("Could not dispatch pairing request with status %!.", v16);
            v17 = sub_1000544A0(0x43u);
            if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
              sub_1006CEEC0();
          }
        }
      }
      else if (sub_100230754((uint64_t)a1))
      {
        if (sub_10005549C())
        {
          v18 = sub_1001EE594();
          sub_100054530("Device %: is in state %s, but its not supposed to be in this state", a1 + 49, v18);
          v19 = sub_1000544A0(0x43u);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
            goto LABEL_31;
        }
      }
    }
  }
}

void sub_10023796C(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  unsigned int v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;

  v1 = **(_QWORD **)(a1 + 8);
  if (!sub_10019AC00(v1))
  {
    if (!sub_10005549C())
      return;
    sub_100054530("Handle is not valid anymore.");
    v5 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      return;
LABEL_13:
    sub_1006CE7A4();
    return;
  }
  v2 = sub_1001EE0AC(v1);
  if (!v2)
  {
    if (!sub_10005549C())
      return;
    sub_100054530("There is no pairing data for connection");
    v6 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      return;
    goto LABEL_13;
  }
  if (off_1009990E0)
  {
    v3 = *(unsigned __int8 *)(v2 + 80);
    if (*(_BYTE *)(v1 + 55))
      v4 = v1 + 56;
    else
      v4 = v1 + 48;
    off_1009990E0(v4, (v3 >> 2) & 1, 0);
  }
}

void sub_100237A60(uint64_t a1)
{
  uint64_t *v1;
  uint64_t v2;
  NSObject *v3;
  NSObject *v4;

  v1 = *(uint64_t **)(a1 + 8);
  v2 = *v1;
  if (*v1 && sub_10019AC00(*v1))
  {
    if (sub_1001EE0AC(v2))
    {
      if (off_1009990E8)
        off_1009990E8(v2 + 48, 0);
      return;
    }
    if (sub_10005549C())
    {
      sub_100054530("There is no security request for this connection. Ignoring reply.");
      v4 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
LABEL_8:
        sub_1006CE7A4();
    }
  }
  else if (sub_10005549C())
  {
    sub_100054530("This handle is not a LE connection.");
    v3 = sub_1000544A0(0x43u);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      goto LABEL_8;
  }
}

void sub_100237B40(uint64_t a1, uint64_t a2)
{
  char *v3;

  v3 = (char *)sub_1001EE0AC(a1);
  if (v3)
    sub_1001EDD30(v3, a2, 1);
}

uint64_t sub_100237B78(uint64_t a1)
{
  char *v2;
  uint64_t result;

  if (!sub_10019AC00(a1))
    return 122;
  v2 = *(char **)(a1 + 240);
  if (v2)
    sub_1001EDD30(v2, 122, 1);
  result = *(unsigned int *)(a1 + 180);
  if ((_DWORD)result)
  {
    sub_100049F6C(result);
    result = 0;
    *(_DWORD *)(a1 + 180) = 0;
  }
  return result;
}

void sub_100237BCC(__int128 *a1)
{
  int v2;
  NSObject *v3;
  NSObject *v4;
  int v5;
  void *v6;

  v2 = sub_10005549C();
  if (a1)
  {
    if (v2)
    {
      sub_100054530("MUC - save IRK and update RSA adv instance");
      v3 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        v5 = 136446210;
        v6 = sub_100054494();
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, " %{public}s", (uint8_t *)&v5, 0xCu);
      }
    }
    xmmword_10098FC66 = *a1;
  }
  else
  {
    if (v2)
    {
      sub_100054530("MUC - reset IRK");
      v4 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        v5 = 136446210;
        v6 = sub_100054494();
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, " %{public}s", (uint8_t *)&v5, 0xCu);
      }
    }
    xmmword_10098FC66 = 0uLL;
  }
}

uint64_t sub_100237D0C(__int128 *a1, __n128 *a2, __int128 *a3, __int128 *a4, __n128 *a5)
{
  xmmword_10098FC76 = *a1;
  sub_1001EDD08(a2);
  sub_1001EDD1C(a5);
  xmmword_10098FC56 = *a3;
  xmmword_10098FC46 = *a4;
  return 0;
}

uint64_t sub_100237D7C(uint64_t (*a1)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD), uint64_t a2, uint64_t (*a3)(_QWORD, _QWORD, _QWORD, _QWORD), int a4, int a5, char a6, char a7)
{
  uint64_t v14;
  BOOL v15;
  NSObject *v16;

  if (qword_10098FC88)
    sub_100253460();
  byte_10097A8E3 = sub_100237ECC(a4, a5);
  unk_1009990D8 = a1;
  *(_OWORD *)&off_1009990E0 = *(_OWORD *)a2;
  off_1009990F0 = *(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(a2 + 16);
  unk_1009990F8 = a3;
  v14 = sub_1001DC46C(6, 2, 8, 8u, &qword_10098FC88, (uint64_t)sub_1001EDF20);
  if ((_DWORD)v14)
    v15 = 1;
  else
    v15 = qword_10098FC88 == 0;
  if (v15)
  {
    if (sub_10005549C())
    {
      sub_100054530("Could not register the LE SecurityManager : %!", v14);
      v16 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  else
  {
    *(_WORD *)sub_1001E40C4(qword_10098FC88) = 65;
    byte_10098FC41 = a6;
    byte_10098FC45 = a7;
    *(_WORD *)(sub_1001E40C4(qword_10098FC88) + 2) = -1;
    sub_10021F6A8((uint64_t)&unk_10091F120);
  }
  return v14;
}

uint64_t sub_100237ECC(int a1, int a2)
{
  switch(a1)
  {
    case 3:
      if (a2 == 16)
        return 2;
      if (a2 == 32)
        return 4;
      goto LABEL_13;
    case 2:
      if (a2 != 16)
      {
        if (a2 == 32)
          return 1;
        goto LABEL_13;
      }
      break;
    case 1:
      if (a2 != 16)
      {
        if (a2 == 32)
          return 0;
        goto LABEL_13;
      }
      break;
    default:
LABEL_13:
      sub_100253460();
      return 3;
  }
  return 3;
}

uint64_t sub_100237F4C()
{
  uint64_t v0;
  NSObject *v1;

  sub_10021F838((uint64_t)&unk_10091F120);
  v0 = sub_1001DC658(qword_10098FC88);
  if ((_DWORD)v0)
  {
    if (sub_10005549C())
    {
      sub_100054530("Could not de-register the LE SecurityManager : %!", v0);
      v1 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  else
  {
    qword_10098FC88 = 0;
    *(_OWORD *)&unk_1009990D8 = 0u;
    *(_OWORD *)&off_1009990E8 = 0u;
    *(_OWORD *)&unk_1009990F8 = 0u;
    byte_10097A8E3 = 3;
    sub_1001EDD08(&xmmword_10073B788);
    sub_1001EDD1C(&xmmword_10073B788);
    xmmword_10098FC46 = 0uLL;
    xmmword_10098FC56 = 0uLL;
    xmmword_10098FC76 = 0uLL;
  }
  return v0;
}

uint64_t sub_100238034()
{
  NSObject *v1;

  if (xmmword_10098FC56 != 0 && xmmword_10098FC76 != 0)
    return 0;
  if (sub_10005549C())
  {
    sub_100054530("Root keys are not set, can't pair.");
    v1 = sub_1000544A0(0x43u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  sub_100253460();
  return 4826;
}

uint64_t sub_1002380C4(uint64_t a1, int a2)
{
  char v4;
  char v5;
  unsigned __int8 v6;
  unsigned __int8 v7;
  unsigned __int8 v8;
  unsigned __int8 v9;
  NSObject *v10;
  uint64_t v11;
  NSObject *v12;
  unsigned __int8 v14;
  unsigned __int8 v15;
  int v16;
  int v17;
  int v18;
  NSObject *v19;
  void *v20;
  int v21;
  unsigned __int8 v22;
  int v23;
  _DWORD *v24;
  char v25;
  NSObject *v26;
  void *v27;
  uint64_t v28;
  char *v29;
  const char *v30;
  NSObject *v31;
  NSObject *v32;
  NSObject *v33;
  NSObject *v34;
  uint8_t buf[4];
  void *v36;

  v4 = byte_10097A8E1;
  if (byte_10097A8E1 == 255)
    v4 = 11;
  if (byte_10097A8E2 == 255)
    v5 = 11;
  else
    v5 = byte_10097A8E2;
  v6 = v4 & 0xF7;
  v7 = v5 & 0xF7;
  if (byte_10098FC40)
    v8 = v4 & 0xF7;
  else
    v8 = v4;
  if (byte_10098FC40)
    v9 = v5 & 0xF7;
  else
    v9 = v5;
  if (sub_10005549C())
  {
    sub_100054530("StartPairing was called");
    v10 = sub_1000544A0(0x43u);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v36 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  v11 = sub_100238034();
  if ((_DWORD)v11)
    return v11;
  if (!sub_10019AC00(a1))
  {
    if (!sub_10005549C())
      return 4820;
    sub_100054530("Connection handle is not a LE handle...");
    v12 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      return 4820;
LABEL_21:
    sub_1006CE7A4();
    return 4820;
  }
  if (*(_BYTE *)(a1 + 233))
    return 4837;
  v14 = v6;
  v15 = v7;
  if (a2)
    v16 = 4;
  else
    v16 = 0;
  v17 = v16 | sub_10022408C();
  if (byte_10098FC41)
  {
    if (*(unsigned __int8 *)(a1 + 24) > 7u
      || (v18 = *(unsigned __int16 *)(a1 + 20), v18 != 2) && v18 != 90 && v18 != 13
      || *(_BYTE *)(a1 + 70) == 1)
    {
      if ((byte_10098FC42 & 1) != 0 || *(_BYTE *)(a1 + 232) || (v8 & 8) == 0)
      {
        v17 |= 8u;
      }
      else
      {
        if (sub_10005549C())
        {
          sub_100054530("Sending CT2=1");
          v19 = sub_1000544A0(0x43u);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            v20 = sub_100054494();
            *(_DWORD *)buf = 136446210;
            v36 = v20;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
          }
        }
        v17 |= 0x28u;
      }
      v14 = v8;
      v15 = v9;
    }
  }
  if (*(_BYTE *)(a1 + 232))
    v21 = v17 & 0x1F;
  else
    v21 = v17;
  if (*(_BYTE *)(a1 + 232))
    v22 = v6;
  else
    v22 = v14;
  if (!*(_BYTE *)(a1 + 232))
    v7 = v15;
  v23 = v21 | byte_10098FC44;
  if (*(_BYTE *)(a1 + 55))
    v24 = (_DWORD *)(a1 + 56);
  else
    v24 = 0;
  v25 = sub_10022CCE0((_DWORD *)(a1 + 48), v24);
  if (sub_10005549C())
  {
    sub_100054530("authReq=%x localKeyDist=%x localKeyReq=%x", v23, v22, v7);
    v26 = sub_1000544A0(0x43u);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      v27 = sub_100054494();
      *(_DWORD *)buf = 136446210;
      v36 = v27;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if (*(_BYTE *)(a1 + 70) != 1)
    return sub_100232AA4(a1, byte_10097A8E3, v25, v23, v22, v7);
  buf[0] = 11;
  buf[1] = v23;
  if (!sub_10019AC00(a1))
  {
    if (!sub_10005549C())
      return 4820;
    sub_100054530("This command is only available to LE devices.");
    v32 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      return 4820;
    goto LABEL_21;
  }
  if (*(_BYTE *)(a1 + 70))
  {
    v28 = sub_1001EE0AC(a1);
    if (v28)
    {
      v29 = (char *)v28;
      if (!sub_1001EE68C(v28, 0))
      {
        if (sub_10005549C())
        {
          v30 = sub_1001EE594();
          sub_100054530("Cannot send a security request, device is in state %s.", v30);
          v31 = sub_1000544A0(0x43u);
          if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
            sub_1006CEEC0();
        }
        return 4804;
      }
LABEL_74:
      v29[72] = v23;
      v29[73] = v25;
      v11 = sub_1001EE0F4(*(__int128 **)v29, (char *)buf, 2uLL, 0);
      if ((_DWORD)v11)
        sub_1001EDD30(v29, v11, 1);
      else
        sub_1001EE5A0((uint64_t)v29, 16);
      return v11;
    }
    v29 = sub_1001EE3C4(a1);
    if (v29)
      goto LABEL_74;
    if (sub_10005549C())
    {
      sub_100054530("Could not allocate a pairing record for handle 0x%x", a1);
      v34 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    return 104;
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("You cannot send this command when central.");
      v33 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 4822;
  }
}

uint64_t sub_100238600(_OWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _OWORD *v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  __int128 v15;
  NSObject *v16;
  char v17;
  _OWORD v18[2];

  v17 = 96;
  if (a1)
  {
    v9 = a1 + 2;
    v10 = sub_1001859C0(a1 + 2, a1 + 6, (uint64_t)&v17, a4, a5, a6, a7, a8);
    if ((_DWORD)v10)
    {
      v11 = v10;
      if (sub_10005549C())
      {
        sub_100054530("Failed to generate public/private key %!", v11);
        v12 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
LABEL_5:
          sub_1006CEEC0();
      }
    }
    else
    {
      arc4random_buf(a1, 0x10uLL);
      v15 = v9[1];
      v18[0] = *v9;
      v18[1] = v15;
      v11 = sub_100184FB4(v18, v18, a1, 0, a1 + 1);
      if ((_DWORD)v11)
      {
        if (sub_10005549C())
        {
          sub_100054530("Failed to generate confirmation value C with status %!", v11);
          v16 = sub_1000544A0(0x43u);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
            goto LABEL_5;
        }
      }
    }
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("Must provide storage for OOB Bundle and private key");
      v13 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 101;
  }
  return v11;
}

uint64_t sub_100238788(_DWORD *a1, _OWORD *a2, _OWORD *a3, _OWORD *a4)
{
  uint64_t v7;
  __int128 *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  _OWORD *v19;
  _OWORD *v20;
  __int128 *v21;
  uint64_t v22;
  NSObject *v23;
  NSObject *v24;
  _OWORD *v26;
  uint64_t v27;
  NSObject *v28;
  NSObject *v29;
  void *v30;
  uint64_t v31;
  _QWORD *v32;
  __int128 v33;
  __int128 *v34;
  uint64_t v35;
  NSObject *v36;
  char v37;
  _BYTE v38[33];
  __int128 v39;
  __int128 v40;

  v7 = sub_10019AFA0(a1);
  if (!v7)
    return 122;
  v8 = (__int128 *)v7;
  v9 = sub_1001EE0AC(v7);
  if (!v9)
    return 4806;
  v15 = (char *)v9;
  if ((*(_BYTE *)(v9 + 72) & *(_BYTE *)(v9 + 80) & 8) == 0 || *(_BYTE *)(v9 + 16) != 5)
  {
    if (sub_10005549C())
    {
      sub_100054530("This API can only be called on LE Secured Connection OOB Pairing.");
      v24 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    v22 = 408;
    goto LABEL_27;
  }
  if (a4)
  {
    v16 = a4[2];
    v17 = a4[3];
    v18 = a4[4];
    *(_OWORD *)(v9 + 200) = a4[5];
    *(_OWORD *)(v9 + 184) = v18;
    *(_OWORD *)(v9 + 168) = v17;
    *(_OWORD *)(v9 + 152) = v16;
    memmove((void *)(v9 + 216), a4 + 6, 0x60uLL);
    if (*(_BYTE *)(*(_QWORD *)v15 + 70) == 1)
      v19 = v15 + 441;
    else
      v19 = v15 + 425;
    *v19 = *a4;
    *(_OWORD *)(v15 + 88) = a4[1];
  }
  else
  {
    v37 = 96;
    v26 = (_OWORD *)(v9 + 152);
    v27 = sub_1001859C0((_OWORD *)(v9 + 152), (_OWORD *)(v9 + 216), (uint64_t)&v37, v10, v11, v12, v13, v14);
    if ((_DWORD)v27)
    {
      v22 = v27;
      if (!sub_10005549C())
        goto LABEL_27;
      sub_100054530("Failed to generate public/private key %!", v22);
      v28 = sub_1000544A0(0x43u);
      if (!os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        goto LABEL_27;
      goto LABEL_50;
    }
    if (*(_BYTE *)(*(_QWORD *)v15 + 70) == 1)
      v30 = v15 + 441;
    else
      v30 = v15 + 425;
    arc4random_buf(v30, 0x10uLL);
    v31 = *(_QWORD *)v15;
    if (*(_BYTE *)(*(_QWORD *)v15 + 70) == 1)
      v32 = v15 + 425;
    else
      v32 = v15 + 441;
    *v32 = 0;
    v32[1] = 0;
    v33 = *(_OWORD *)(v15 + 168);
    *(_OWORD *)v38 = *v26;
    *(_OWORD *)&v38[16] = v33;
    if (*(_BYTE *)(v31 + 70) == 1)
      v34 = (__int128 *)(v15 + 441);
    else
      v34 = (__int128 *)(v15 + 425);
    v35 = sub_100184FB4(v38, v38, v34, 0, v15 + 88);
    if ((_DWORD)v35)
    {
      v22 = v35;
      if (!sub_10005549C())
        goto LABEL_27;
      sub_100054530("Failed to generate confirmation value C with status %!", v22);
      v36 = sub_1000544A0(0x43u);
      if (!os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
        goto LABEL_27;
      goto LABEL_50;
    }
  }
  if (a2)
  {
    if (*(_BYTE *)(*(_QWORD *)v15 + 70) == 1)
      v20 = v15 + 425;
    else
      v20 = v15 + 441;
    *v20 = *a2;
  }
  if (a3)
    *(_OWORD *)(v15 + 104) = *a3;
  v15[490] = 1;
  v21 = *(__int128 **)v15;
  if (!*(_BYTE *)(*(_QWORD *)v15 + 70))
  {
    v38[0] = 12;
    *(_OWORD *)&v38[1] = *(_OWORD *)(v15 + 152);
    *(_OWORD *)&v38[17] = *(_OWORD *)(v15 + 168);
    v39 = *(_OWORD *)(v15 + 184);
    v40 = *(_OWORD *)(v15 + 200);
    v22 = sub_1001EE0F4(v21, v38, 0x41uLL, 1);
    if (!(_DWORD)v22)
    {
      sub_1001EE5A0((uint64_t)v15, 33);
      return v22;
    }
    if (!sub_10005549C())
      goto LABEL_27;
    sub_100054530("Failed to send public keys %!", v22);
    v29 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      goto LABEL_27;
LABEL_50:
    sub_1006CEEC0();
LABEL_27:
    sub_1002306D8(v8, 8, v15);
    return v22;
  }
  sub_1001EE5A0((uint64_t)v15, 32);
  v22 = sub_100238B40((uint64_t)v15);
  if ((_DWORD)v22)
  {
    if (!sub_10005549C())
      goto LABEL_27;
    sub_100054530("recvdSMPDeferredOOBPublicKey failed %!", v22);
    v23 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      goto LABEL_27;
    goto LABEL_50;
  }
  return v22;
}

uint64_t sub_100238B40(uint64_t a1)
{
  __int128 *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  char v13;
  uint64_t v15;
  NSObject *v16;
  BOOL v17;
  uint64_t v18;
  int v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  BOOL v23;
  __int128 v24;
  __int128 *v25;
  NSObject *v26;
  uint64_t v27;
  NSObject *v28;
  _QWORD *v29;
  void *v30;
  char v31;
  NSObject *v32;
  NSObject *v34;
  char v35;
  uint64_t v36;
  uint64_t v37;
  _OWORD __s2[4];
  _BYTE v39[33];
  __int128 v40;
  __int128 v41;

  memset(__s2, 0, sizeof(__s2));
  v35 = 96;
  sub_1001EE4C0((uint64_t *)a1);
  if (!*(_BYTE *)(a1 + 490) || !memcmp((const void *)(a1 + 312), __s2, 0x40uLL))
  {
    if (*(_BYTE *)(*(_QWORD *)a1 + 70) == 1)
      v13 = 32;
    else
      v13 = 33;
    sub_1001EE5A0(a1, v13);
    return 0;
  }
  v2 = *(__int128 **)a1;
  if (*(_BYTE *)(*(_QWORD *)a1 + 70) != 1)
    goto LABEL_15;
  if (!memcmp((const void *)(a1 + 152), __s2, 0x40uLL))
  {
    v27 = sub_1001859C0((_OWORD *)(a1 + 152), (_OWORD *)(a1 + 216), (uint64_t)&v35, v3, v4, v5, v6, v7);
    if ((_DWORD)v27)
    {
      v11 = v27;
      if (sub_10005549C())
      {
        sub_100054530("LE_ReadLocalPublicKey failed %!", v11);
        v28 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
          goto LABEL_55;
      }
      return v11;
    }
    v2 = *(__int128 **)a1;
  }
  v39[0] = 12;
  v8 = *(_OWORD *)(a1 + 168);
  *(_OWORD *)&v39[1] = *(_OWORD *)(a1 + 152);
  *(_OWORD *)&v39[17] = v8;
  v9 = *(_OWORD *)(a1 + 200);
  v40 = *(_OWORD *)(a1 + 184);
  v41 = v9;
  v10 = sub_1001EE0F4(v2, v39, 0x41uLL, 1);
  if (!(_DWORD)v10)
  {
LABEL_15:
    v15 = sub_100185B44((const void *)(a1 + 312), 0x40u, (const void *)(a1 + 216), 0x60u, (void *)(a1 + 376));
    if ((_DWORD)v15)
    {
      v11 = v15;
      if (sub_10005549C())
      {
        sub_100054530("DHKey generation failed %!", v11);
        v16 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          goto LABEL_55;
      }
      return v11;
    }
    sub_1001EE4C0((uint64_t *)a1);
    v17 = *(_QWORD *)(a1 + 104) == *(_QWORD *)&__s2[0] && *(_QWORD *)(a1 + 112) == *((_QWORD *)&__s2[0] + 1);
    v18 = *(_QWORD *)a1;
    v19 = *(unsigned __int8 *)(*(_QWORD *)a1 + 70);
    if (v17
      || (*(_BYTE *)(*(_QWORD *)a1 + 70) ? (v20 = (uint64_t *)(a1 + 425)) : (v20 = (uint64_t *)(a1 + 441)),
          (v22 = *v20, v21 = v20[1], v22 == *(_QWORD *)&__s2[0]) ? (v23 = v21 == *((_QWORD *)&__s2[0] + 1)) : (v23 = 0),
          v23))
    {
      if (*(_BYTE *)(*(_QWORD *)a1 + 70))
        v29 = (_QWORD *)(a1 + 425);
      else
        v29 = (_QWORD *)(a1 + 441);
    }
    else
    {
      v36 = 0;
      v37 = 0;
      v24 = *(_OWORD *)(a1 + 328);
      *(_OWORD *)v39 = *(_OWORD *)(a1 + 312);
      *(_OWORD *)&v39[16] = v24;
      if (v19 == 1)
        v25 = (__int128 *)(a1 + 425);
      else
        v25 = (__int128 *)(a1 + 441);
      v11 = sub_100184FB4(v39, v39, v25, 0, &v36);
      if ((_DWORD)v11)
      {
        if (sub_10005549C())
        {
          sub_100054530("Failed to calculate remote C value with status %!", v11);
          v26 = sub_1000544A0(0x43u);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
            goto LABEL_55;
        }
        return v11;
      }
      if (*(_QWORD *)(a1 + 104) != v36 || *(_QWORD *)(a1 + 112) != v37)
      {
        if (sub_10005549C())
        {
          sub_100054530("Received and calculated remote C values do not match");
          v34 = sub_1000544A0(0x43u);
          if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
        sub_1002306D8(*(__int128 **)a1, 4, (char *)a1);
        return v11;
      }
      v18 = *(_QWORD *)a1;
      if (*(_BYTE *)(a1 + 79))
        goto LABEL_45;
      if (*(_BYTE *)(v18 + 70) == 1)
        v29 = (_QWORD *)(a1 + 441);
      else
        v29 = (_QWORD *)(a1 + 425);
    }
    *v29 = 0;
    v29[1] = 0;
LABEL_45:
    if (*(_BYTE *)(v18 + 70) == 1)
      v30 = (void *)(a1 + 473);
    else
      v30 = (void *)(a1 + 457);
    arc4random_buf(v30, 0x10uLL);
    if (*(_BYTE *)(*(_QWORD *)a1 + 70))
      v31 = 36;
    else
      v31 = 35;
    sub_1001EE5A0(a1, v31);
    if (!*(_BYTE *)(*(_QWORD *)a1 + 70))
    {
      v11 = sub_1002393C4(*(_QWORD *)a1, (__int128 *)(a1 + 457));
      if (!(_DWORD)v11)
      {
        sub_1001EE5A0(a1, 37);
        return v11;
      }
      if (sub_10005549C())
      {
        sub_100054530("Failed to send pairing random to peripheral %!", v11);
        v32 = sub_1000544A0(0x43u);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
          goto LABEL_55;
      }
      return v11;
    }
    return 0;
  }
  v11 = v10;
  if (sub_10005549C())
  {
    sub_100054530("smpSendPairingPublicKey failed %!", v11);
    v12 = sub_1000544A0(0x43u);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
LABEL_55:
      sub_1006CEEC0();
  }
  return v11;
}

uint64_t sub_100238F84(_DWORD *a1, _BYTE *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;

  v3 = sub_10019AFA0(a1);
  if (!v3)
    return 122;
  v4 = sub_1001EE0AC(v3);
  if (!v4)
    return 4806;
  v5 = v4;
  result = 0;
  *a2 = *(_BYTE *)(v5 + 80);
  return result;
}

uint64_t sub_100238FD0(uint64_t result)
{
  byte_10097A8E1 = result;
  return result;
}

uint64_t sub_100238FDC(uint64_t result)
{
  byte_10097A8E4 = result;
  return result;
}

uint64_t sub_100238FE8(uint64_t result)
{
  byte_10097A8E2 = result;
  return result;
}

uint64_t sub_100238FF4(uint64_t result)
{
  byte_100994BB8 = result;
  return result;
}

void sub_100239004()
{
  byte_10098FC42 = 1;
}

void sub_100239014()
{
  byte_10098FC43 = 1;
}

void sub_10023902C()
{
  byte_10098FC40 = 1;
}

BOOL sub_10023903C(_BOOL8 result, char a2)
{
  uint64_t v3;

  if (result)
  {
    v3 = result;
    result = sub_10019AC00(result);
    if (result)
      *(_BYTE *)(v3 + 232) = a2;
  }
  return result;
}

uint64_t sub_10023906C(uint64_t *a1)
{
  uint64_t v2;
  NSObject *v3;

  v2 = sub_100231670(*a1, a1 + 11);
  if ((_DWORD)v2)
  {
    if (sub_10005549C())
    {
      sub_100054530("smpSendPairingConfirmation failed %!", v2);
      v3 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  else
  {
    sub_1001EE5A0((uint64_t)a1, 36);
  }
  return v2;
}

void sub_1002390F8(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  const void *v4[2];
  uint64_t v5;

  v4[1] = &v5;
  v5 = a1;
  v4[0] = (const void *)8;
  v1 = sub_10004A9EC((uint64_t)sub_100239190, v4, 0, 0);
  if ((_DWORD)v1)
  {
    v2 = v1;
    if (sub_10005549C())
    {
      sub_100054530("Could not dispatch dispatchPairingDisplay CB with status %!.", v2);
      v3 = sub_1000544A0(0x43u);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
}

void sub_100239190(uint64_t a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;

  v1 = *(uint64_t **)(a1 + 8);
  v2 = *v1;
  if (!*v1 || !sub_10019AC00(*v1))
  {
    if (!sub_10005549C())
      return;
    sub_100054530("This handle is not a LE connection.");
    v5 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      return;
LABEL_10:
    sub_1006CE7A4();
    return;
  }
  v3 = sub_1001EE0AC(v2);
  if (!v3)
  {
    if (!sub_10005549C())
      return;
    sub_100054530("There is no security request for this connection. Ignoring reply.");
    v6 = sub_1000544A0(0x43u);
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      return;
    goto LABEL_10;
  }
  if (off_1009990F0)
  {
    v4 = v2 + 48;
    if (*(_BYTE *)(v2 + 55))
      v4 = v2 + 56;
    off_1009990F0(v4, *(unsigned int *)(v3 + 52), v3 + 33, 0);
  }
}

uint64_t sub_10023928C(_BYTE *a1, void *a2, int a3)
{
  char *v3;
  uint64_t v4;
  uint64_t v5;
  char v6;
  char v7;
  char *v9;
  uint64_t v10;
  __int128 *v11;
  __int128 *v12;
  __int128 *v13;
  NSObject *v14;
  __int128 *v16;
  char *v17;
  __int16 v18;
  char v19;

  v3 = a1 + 78;
  v4 = 80;
  if (a3)
    v4 = 72;
  v5 = 79;
  if (a3)
  {
    v5 = 73;
    v3 = &byte_10097A8E3;
  }
  v6 = *v3;
  v7 = a1[v5];
  LOBYTE(v18) = a1[v4];
  HIBYTE(v18) = v7;
  v19 = v6;
  if (a1[424])
  {
    v9 = (char *)(*(_QWORD *)a1 + 48);
    v10 = *(_QWORD *)a1 + 63;
    if (*(_BYTE *)(*(_QWORD *)a1 + 70))
    {
      if (a3)
      {
        v11 = (__int128 *)(a1 + 473);
        v12 = (__int128 *)(a1 + 457);
        v13 = (__int128 *)(a1 + 425);
LABEL_15:
        v16 = (__int128 *)(a1 + 408);
        v17 = (char *)v10;
LABEL_19:
        sub_1001853C4(v16, v11, v12, v13, &v18, v17, v9, a2);
        return 0;
      }
      v11 = (__int128 *)(a1 + 457);
      v12 = (__int128 *)(a1 + 473);
      v13 = (__int128 *)(a1 + 441);
    }
    else
    {
      if (a3)
      {
        v11 = (__int128 *)(a1 + 457);
        v12 = (__int128 *)(a1 + 473);
        v13 = (__int128 *)(a1 + 441);
        goto LABEL_15;
      }
      v11 = (__int128 *)(a1 + 473);
      v12 = (__int128 *)(a1 + 457);
      v13 = (__int128 *)(a1 + 425);
    }
    v16 = (__int128 *)(a1 + 408);
    v17 = v9;
    v9 = (char *)v10;
    goto LABEL_19;
  }
  if (sub_10005549C())
  {
    sub_100054530("LTK And MacKey are not generated, we have a problem.");
    v14 = sub_1000544A0(0x43u);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  return 4824;
}

uint64_t sub_1002393C4(uint64_t a1, __int128 *a2)
{
  uint64_t v3;
  __int128 **v4;
  int v5;
  const char *v6;
  NSObject *v7;
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  char v11;
  const char *v12;
  NSObject *v13;
  const char *v14;
  NSObject *v15;
  const char *v16;
  NSObject *v17;
  char v19;
  __int128 v20;

  v19 = 4;
  v20 = *a2;
  if (sub_10019AC00(a1))
  {
    v3 = sub_1001EE0AC(a1);
    if (v3)
    {
      v4 = (__int128 **)v3;
      v5 = *(unsigned __int8 *)(a1 + 70);
      if ((*(_BYTE *)(v3 + 72) & *(_BYTE *)(v3 + 80) & 8) != 0)
      {
        if (v5 != 1)
        {
LABEL_7:
          if (!v5 && !sub_1001EE68C((uint64_t)v4, 35))
          {
            if (!sub_10005549C())
              return 4823;
            v6 = sub_1001EE594();
            sub_100054530("Central connection should be in SMP_STATE_PAIRING_SCONFIRM to send this command, current state is %s.", v6);
            v7 = sub_1000544A0(0x43u);
            if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
              return 4823;
            goto LABEL_38;
          }
          goto LABEL_24;
        }
        if (sub_1001EE68C(v3, 36))
        {
          v5 = *(unsigned __int8 *)(a1 + 70);
          goto LABEL_7;
        }
        if (!sub_10005549C())
          return 4823;
        v12 = sub_1001EE594();
        sub_100054530("Peripheral connection should be in SMP_STATE_PAIRING_MRAND to send this command, current state is %s.", v12);
        v13 = sub_1000544A0(0x43u);
        if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
          return 4823;
      }
      else
      {
        if (!*(_BYTE *)(a1 + 70))
        {
          if (!sub_1001EE68C(v3, 35))
          {
            if (!sub_10005549C())
              return 4823;
            v16 = sub_1001EE594();
            sub_100054530("Central connection should be in SMP_STATE_PAIRING_SCONFIRM to send this command, current state is %s.", v16);
            v17 = sub_1000544A0(0x43u);
            if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
              return 4823;
            goto LABEL_38;
          }
          v5 = *(unsigned __int8 *)(a1 + 70);
        }
        if (v5 != 1 || sub_1001EE68C((uint64_t)v4, 36))
        {
LABEL_24:
          v9 = sub_1001EE0F4(*v4, &v19, 0x11uLL, 1);
          if ((_DWORD)v9)
          {
            sub_1001EDD30((char *)v4, v9, 1);
          }
          else
          {
            if (*(_BYTE *)(a1 + 70))
              v11 = 37;
            else
              v11 = 36;
            sub_1001EE5A0((uint64_t)v4, v11);
          }
          return v9;
        }
        if (!sub_10005549C())
          return 4823;
        v14 = sub_1001EE594();
        sub_100054530("Peripheral connection should be in SMP_STATE_PAIRING_MRAND to send this command, current state is %s.", v14);
        v15 = sub_1000544A0(0x43u);
        if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          return 4823;
      }
    }
    else
    {
      if (!sub_10005549C())
        return 4823;
      sub_100054530("This device is not in a pairing state.");
      v10 = sub_1000544A0(0x43u);
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        return 4823;
    }
LABEL_38:
    sub_1006CE7A4();
    return 4823;
  }
  if (sub_10005549C())
  {
    sub_100054530("This command is only available to LE devices.");
    v8 = sub_1000544A0(0x43u);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  return 4820;
}

void sub_1002396C4(char *a1)
{
  char v1;

  if ((a1[72] & a1[80] & 8) != 0)
    v1 = -10;
  else
    v1 = -9;
  if ((v1 & a1[74] & 0xF7) == (v1 & a1[75] & 0xF7)
    || (v1 & a1[74]) == 0)
  {
    if (*(_BYTE *)(*(_QWORD *)a1 + 70))
    {
      sub_1001EE5A0((uint64_t)a1, 65);
    }
    else
    {
      sub_1001EE5A0((uint64_t)a1, 67);
      sub_100236968((uint64_t)a1);
      sub_100236ADC((uint64_t)a1);
    }
    sub_1001EDD30(a1, 0, 1);
  }
}

uint64_t sub_100239774(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  NSObject *v9;
  uint64_t v10;
  NSObject *v12;

  if ((_BYTE)qword_10098FC98 || (qword_10098FC98 & 0x100) != 0)
    return 118;
  v8 = a1;
  if (a1 < 0x28)
  {
    v10 = sub_10004C9BC(189, (uint64_t (*)())sub_100239888, a3, a4, a5, a6, a7, a8, a1);
    if ((_DWORD)v10)
    {
      if (sub_10005549C())
      {
        sub_100054530("Failed to start RX LE test %!", v10);
        v12 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
    }
    else
    {
      BYTE2(qword_10098FC98) = v8;
      LOBYTE(qword_10098FC98) = 1;
    }
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("Invalid test frequency %d", v8);
      v9 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 101;
  }
  return v10;
}

void sub_100239888(uint64_t a1)
{
  NSObject *v2;

  if ((_DWORD)a1)
  {
    if (sub_10005549C())
    {
      sub_100054530("Could not start RX test %!", a1);
      v2 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  else
  {
    BYTE1(qword_10098FC98) |= 1u;
  }
  LOBYTE(qword_10098FC98) = 0;
}

uint64_t sub_10023990C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  NSObject *v9;
  uint64_t v10;
  int v12;
  NSObject *v13;
  int v14;
  NSObject *v15;
  NSObject *v16;

  if ((_BYTE)qword_10098FC98 || (qword_10098FC98 & 0x200) != 0)
    return 118;
  v8 = a1;
  if (a1 >= 0x28)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("Invalid test frequency %d", v8);
    v9 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      return 101;
    goto LABEL_16;
  }
  v12 = a2;
  if (a2 >= 0x26)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("Invalid payload length %d", v12);
    v13 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      return 101;
    goto LABEL_16;
  }
  v14 = a3;
  if (a3 >= 8)
  {
    if (!sub_10005549C())
      return 101;
    sub_100054530("Invalid payload type %d", v14);
    v15 = sub_1000544A0(0x42u);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      return 101;
LABEL_16:
    sub_1006CE7A4();
    return 101;
  }
  v10 = sub_10004C9BC(190, (uint64_t (*)())sub_100239ADC, a3, a4, a5, a6, a7, a8, a1);
  if ((_DWORD)v10)
  {
    if (sub_10005549C())
    {
      sub_100054530("Failed to start TX LE test %!", v10, a2, a3);
      v16 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  else
  {
    BYTE3(qword_10098FC98) = v8;
    BYTE4(qword_10098FC98) = v12;
    BYTE5(qword_10098FC98) = v14;
    LOBYTE(qword_10098FC98) = 1;
  }
  return v10;
}

void sub_100239ADC(uint64_t a1)
{
  NSObject *v2;

  if ((_DWORD)a1)
  {
    if (sub_10005549C())
    {
      sub_100054530("Could not start TX test %!", a1);
      v2 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  else
  {
    BYTE1(qword_10098FC98) |= 2u;
  }
  LOBYTE(qword_10098FC98) = 0;
}

uint64_t sub_100239B60(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  uint64_t v13;

  if (BYTE1(qword_10098FC98))
  {
    v9 = sub_10004C9BC(191, (uint64_t (*)())sub_100239C4C, a3, a4, a5, a6, a7, a8, v13);
    if ((_DWORD)v9)
    {
      if (sub_10005549C())
      {
        sub_100054530("Failed to stop LE test %!", v9);
        v10 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
    }
    else
    {
      LOBYTE(qword_10098FC98) = 1;
      off_10098FCA0 = a1;
    }
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("No test started");
      v11 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 114;
  }
  return v9;
}

void sub_100239C4C(uint64_t a1, uint64_t a2)
{
  void (*v4)(uint64_t, uint64_t);
  NSObject *v5;

  v4 = (void (*)(uint64_t, uint64_t))off_10098FCA0;
  if ((_DWORD)a1)
  {
    if (sub_10005549C())
    {
      sub_100054530("Could not stop the test %!", a1);
      v5 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  else
  {
    qword_10098FC98 = 0;
    off_10098FCA0 = 0;
  }
  LOBYTE(qword_10098FC98) = 0;
  if (v4)
    v4(a1, a2);
}

void sub_100239CF0()
{
  qword_10098FC98 = 0;
  off_10098FCA0 = 0;
}

uint64_t sub_100239D00(uint64_t a1)
{
  __int16 v1;
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  unsigned __int8 v5;

  v1 = word_10098FCA8;
  v2 = (unsigned __int16)word_10098FCA8;
  if (word_10098FCA8)
  {
    if (word_10098FCA8 == 8)
    {
      if (sub_10005549C())
      {
        sub_100054530("Can't add anymore callbacks.");
        v3 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return 4150;
    }
    else
    {
      v5 = 0;
      while (qword_10098FCB0[v5] != a1)
      {
        if ((unsigned __int16)word_10098FCA8 <= ++v5)
        {
          v2 = v5;
          goto LABEL_11;
        }
      }
      return 0;
    }
  }
  else
  {
LABEL_11:
    v4 = 0;
    qword_10098FCB0[v2] = a1;
    word_10098FCA8 = v1 + 1;
  }
  return v4;
}

uint64_t sub_100239DC8(unsigned __int8 *a1)
{
  uint64_t v2;
  NSObject *v3;
  _DWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _DWORD *v12;
  uint64_t v13;
  NSObject *v14;
  int v15;
  __int16 v16;
  int v17;

  if (!*((_QWORD *)&xmmword_10098FCF0 + 1))
    return 118;
  if ((unsigned __int16)xmmword_10098FCF0 <= BYTE2(xmmword_10098FCF0))
  {
    if (sub_10005549C())
    {
      sub_100054530("No room in filter accept list %d (+%d pending)/%d.", BYTE2(xmmword_10098FCF0), (unsigned __int16)xmmword_10098FCF0, v17);
      v3 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 104;
  }
  else if (sub_100239F68(a1))
  {
    return 4152;
  }
  else
  {
    v5 = sub_100052DC0(0x10uLL);
    if (v5)
    {
      v12 = v5;
      v13 = sub_10004C9BC(177, (uint64_t (*)())sub_100239FEC, v6, v7, v8, v9, v10, v11, *a1);
      if ((_DWORD)v13)
      {
        v2 = v13;
        if (sub_10005549C())
        {
          sub_100054530("Could not add device to filter accept list %!", v2, a1 + 1);
          v14 = sub_1000544A0(0x42u);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
        sub_100053298(v12);
      }
      else
      {
        v15 = *(_DWORD *)a1;
        v16 = *((_WORD *)a1 + 2);
        *((_BYTE *)v12 + 6) = a1[6];
        *((_WORD *)v12 + 2) = v16;
        *v12 = v15;
        *((_QWORD *)v12 + 1) = 0;
        if (qword_10098FD08)
        {
          *(_QWORD *)(qword_10098FD08 + 8) = v12;
          qword_10098FD08 = (uint64_t)v12;
        }
        v2 = 0;
        if (!qword_10098FD00)
        {
          qword_10098FD00 = (uint64_t)v12;
          qword_10098FD08 = (uint64_t)v12;
        }
      }
    }
    else
    {
      return 106;
    }
  }
  return v2;
}

BOOL sub_100239F68(_DWORD *a1)
{
  _DWORD *v2;
  uint64_t v3;
  unint64_t v4;
  BOOL v5;

  if (!BYTE2(xmmword_10098FCF0))
    return 0;
  if (**((_DWORD **)&xmmword_10098FCF0 + 1) == *a1
    && *(_DWORD *)(*((_QWORD *)&xmmword_10098FCF0 + 1) + 3) == *(_DWORD *)((char *)a1 + 3))
  {
    return 1;
  }
  v2 = (_DWORD *)(*((_QWORD *)&xmmword_10098FCF0 + 1) + 7);
  v3 = 1;
  do
  {
    v4 = v3;
    if (BYTE2(xmmword_10098FCF0) == v3)
      break;
    v5 = *v2 == *a1 && *(_DWORD *)((char *)v2 + 3) == *(_DWORD *)((char *)a1 + 3);
    ++v3;
    v2 = (_DWORD *)((char *)v2 + 7);
  }
  while (!v5);
  return v4 < BYTE2(xmmword_10098FCF0);
}

uint64_t sub_100239FEC(uint64_t a1)
{
  uint64_t v1;
  char v2;
  uint64_t v3;
  int v4;
  __int16 v5;
  unsigned int v6;
  unint64_t v7;
  uint64_t v8;
  void (*v9)(uint64_t, _QWORD);
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v19;

  if ((_DWORD)a1)
  {
    if (sub_10005549C())
    {
      sub_100054530("Error adding device to filter accept list %!", a1);
      v19 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        sub_1006CEE54();
    }
    sub_1001131F8(a1, "Filter Accept List add error");
  }
  v1 = qword_10098FD00;
  if (qword_10098FD00 || (sub_100253460(), (v1 = qword_10098FD00) != 0))
  {
    v2 = BYTE2(xmmword_10098FCF0);
    v3 = *((_QWORD *)&xmmword_10098FCF0 + 1) - BYTE2(xmmword_10098FCF0) + 8 * BYTE2(xmmword_10098FCF0);
    v4 = *(_DWORD *)v1;
    v5 = *(_WORD *)(v1 + 4);
    *(_BYTE *)(v3 + 6) = *(_BYTE *)(v1 + 6);
    *(_WORD *)(v3 + 4) = v5;
    *(_DWORD *)v3 = v4;
    BYTE2(xmmword_10098FCF0) = v2 + 1;
  }
  v6 = (unsigned __int16)word_10098FCA8;
  if (word_10098FCA8)
  {
    v7 = 0;
    v8 = qword_10098FD00;
    do
    {
      v9 = *(void (**)(uint64_t, _QWORD))qword_10098FCB0[v7];
      if (v9)
        v10 = v8 == 0;
      else
        v10 = 1;
      if (!v10)
      {
        v9(v8, 0);
        v8 = qword_10098FD00;
        v6 = (unsigned __int16)word_10098FCA8;
      }
      ++v7;
    }
    while (v7 < v6);
  }
  sub_10023A694();
  sub_100214848(1, v11, v12, v13, v14, v15, v16, v17);
  sub_100206434(1);
  return sub_10022B8FC(1);
}

uint64_t sub_10023A124(unsigned __int8 *a1)
{
  _DWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _DWORD *v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  int v13;
  __int16 v14;

  if (!*((_QWORD *)&xmmword_10098FCF0 + 1))
    return 118;
  if (!sub_100239F68(a1))
    return 4151;
  v2 = sub_100052DC0(0x10uLL);
  if (!v2)
    return 106;
  v9 = v2;
  v10 = sub_10004C9BC(178, (uint64_t (*)())sub_10023A258, v3, v4, v5, v6, v7, v8, *a1);
  if ((_DWORD)v10)
  {
    v11 = v10;
    if (sub_10005549C())
    {
      sub_100054530("Could not remove device from filter accept list %!", v11, a1 + 1);
      v12 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    sub_100053298(v9);
  }
  else
  {
    v13 = *(_DWORD *)a1;
    v14 = *((_WORD *)a1 + 2);
    *((_BYTE *)v9 + 6) = a1[6];
    *((_WORD *)v9 + 2) = v14;
    *v9 = v13;
    *((_QWORD *)v9 + 1) = 0;
    if (qword_10098FD08)
    {
      *(_QWORD *)(qword_10098FD08 + 8) = v9;
      qword_10098FD08 = (uint64_t)v9;
    }
    v11 = 0;
    if (!qword_10098FD00)
    {
      qword_10098FD00 = (uint64_t)v9;
      qword_10098FD08 = (uint64_t)v9;
    }
  }
  return v11;
}

uint64_t sub_10023A258(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  NSObject *v5;
  unsigned __int8 v6;
  uint64_t v7;
  int v8;
  __int16 v9;
  _DWORD *v10;
  unsigned int v11;
  unint64_t v12;
  uint64_t v13;
  void (*v14)(uint64_t, _QWORD);
  BOOL v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  NSObject *v24;

  if ((_DWORD)a1)
  {
    if (sub_10005549C())
    {
      sub_100054530("Error removing device from filter accept list %!", a1);
      v24 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        sub_1006CEE54();
    }
    sub_1001131F8(a1, "Filter Accept List remove error");
  }
  if (!qword_10098FD00)
    sub_100253460();
  if (BYTE2(xmmword_10098FCF0))
  {
    v1 = 0;
    v2 = *((_QWORD *)&xmmword_10098FCF0 + 1);
    while (1)
    {
      v3 = *((_QWORD *)&xmmword_10098FCF0 + 1) + v1;
      if (*(_DWORD *)(*((_QWORD *)&xmmword_10098FCF0 + 1) + v1) == *(_DWORD *)qword_10098FD00
        && *(_DWORD *)(*((_QWORD *)&xmmword_10098FCF0 + 1) + v1 + 3) == *(_DWORD *)(qword_10098FD00 + 3))
      {
        break;
      }
      v1 += 7;
      if (7 * BYTE2(xmmword_10098FCF0) == v1)
        goto LABEL_11;
    }
    v6 = --BYTE2(xmmword_10098FCF0);
    if (7 * BYTE2(xmmword_10098FCF0) != (_DWORD)v1)
    {
      v7 = *((_QWORD *)&xmmword_10098FCF0 + 1) - BYTE2(xmmword_10098FCF0) + 8 * BYTE2(xmmword_10098FCF0);
      v8 = *(_DWORD *)v7;
      v9 = *(_WORD *)(v7 + 4);
      *(_BYTE *)(v3 + 6) = *(_BYTE *)(v7 + 6);
      *(_WORD *)(v3 + 4) = v9;
      *(_DWORD *)v3 = v8;
      v2 = *((_QWORD *)&xmmword_10098FCF0 + 1);
      v6 = BYTE2(xmmword_10098FCF0);
    }
    v10 = (_DWORD *)(v2 - v6 + 8 * v6);
    *(_DWORD *)((char *)v10 + 3) = 0;
    *v10 = 0;
  }
  else
  {
LABEL_11:
    if (sub_10005549C())
    {
      sub_100054530("Device is not in the list anymore");
      v5 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  v11 = (unsigned __int16)word_10098FCA8;
  if (word_10098FCA8)
  {
    v12 = 0;
    v13 = qword_10098FD00;
    do
    {
      v14 = *(void (**)(uint64_t, _QWORD))(qword_10098FCB0[v12] + 8);
      if (v14)
        v15 = v13 == 0;
      else
        v15 = 1;
      if (!v15)
      {
        v14(v13, 0);
        v13 = qword_10098FD00;
        v11 = (unsigned __int16)word_10098FCA8;
      }
      ++v12;
    }
    while (v12 < v11);
  }
  sub_10023A694();
  sub_100214848(1, v16, v17, v18, v19, v20, v21, v22);
  sub_100206434(1);
  return sub_10022B8FC(1);
}

uint64_t sub_10023A440(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  NSObject *v9;
  uint64_t v11;

  if (!*((_QWORD *)&xmmword_10098FCF0 + 1))
    return 118;
  v8 = sub_10004C9BC(176, (uint64_t (*)())sub_10023A4D0, a3, a4, a5, a6, a7, a8, v11);
  if ((_DWORD)v8)
  {
    if (sub_10005549C())
    {
      sub_100054530("Could not remove device from filter accept list %!", v8);
      v9 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  return v8;
}

uint64_t sub_10023A4D0(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v9;

  if ((_DWORD)a1)
  {
    if (sub_10005549C())
    {
      sub_100054530("Error clearing filter accept list %!", a1);
      v9 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_1006CEE54();
    }
    sub_1001131F8(a1, "Filter Accept List clear error");
  }
  bzero(*((void **)&xmmword_10098FCF0 + 1), 7 * (unsigned __int16)xmmword_10098FCF0);
  BYTE2(xmmword_10098FCF0) = 0;
  sub_100214848(1, v1, v2, v3, v4, v5, v6, v7);
  sub_100206434(1);
  return sub_10022B8FC(1);
}

uint64_t sub_10023A580()
{
  return (unsigned __int16)xmmword_10098FCF0;
}

uint64_t sub_10023A58C(_DWORD *a1)
{
  *a1 = BYTE2(xmmword_10098FCF0);
  return *((_QWORD *)&xmmword_10098FCF0 + 1);
}

uint64_t sub_10023A5A4(int *a1)
{
  uint64_t result;
  char v3;
  uint64_t v4;
  int v5;
  __int16 v6;

  if (sub_100239F68(a1))
    return 4152;
  result = 0;
  v3 = BYTE2(xmmword_10098FCF0);
  v4 = *((_QWORD *)&xmmword_10098FCF0 + 1) - BYTE2(xmmword_10098FCF0) + 8 * BYTE2(xmmword_10098FCF0);
  v5 = *a1;
  v6 = *((_WORD *)a1 + 2);
  *(_BYTE *)(v4 + 6) = *((_BYTE *)a1 + 6);
  *(_WORD *)(v4 + 4) = v6;
  *(_DWORD *)v4 = v5;
  BYTE2(xmmword_10098FCF0) = v3 + 1;
  return result;
}

void *sub_10023A60C(unsigned int a1)
{
  void *result;

  LOWORD(xmmword_10098FCF0) = a1;
  if (*((_QWORD *)&xmmword_10098FCF0 + 1))
    sub_100053298(*((void **)&xmmword_10098FCF0 + 1));
  result = sub_100052DC0(7 * a1);
  *((_QWORD *)&xmmword_10098FCF0 + 1) = result;
  BYTE2(xmmword_10098FCF0) = 0;
  qword_10098FD08 = 0;
  qword_10098FD00 = 0;
  return result;
}

double sub_10023A664()
{
  double result;

  if (*((_QWORD *)&xmmword_10098FCF0 + 1))
    sub_100053298(*((void **)&xmmword_10098FCF0 + 1));
  result = 0.0;
  xmmword_10098FCF0 = 0u;
  *(_OWORD *)&qword_10098FD00 = 0u;
  return result;
}

void sub_10023A694()
{
  uint64_t v0;

  if (qword_10098FD00)
  {
    v0 = *(_QWORD *)(qword_10098FD00 + 8);
    sub_100053298((void *)qword_10098FD00);
    qword_10098FD00 = v0;
    if (!v0)
      qword_10098FD08 = 0;
  }
  else
  {
    sub_100253460();
  }
}

uint64_t sub_10023A6DC(uint64_t a1)
{
  uint64_t v1;
  uint64_t *v4;
  uint64_t v5;

  if (qword_10098FD10)
    return 119;
  v4 = (uint64_t *)sub_100052DC0(0x18uLL);
  qword_10098FD10 = (uint64_t)v4;
  if (!v4)
    return 106;
  v1 = sub_1001DC46C(42, 2, 10, 0xAu, v4, (uint64_t)sub_10023A7B8);
  if ((_DWORD)v1)
  {
    sub_100053298((void *)qword_10098FD10);
    qword_10098FD10 = 0;
    return v1;
  }
  if (!sub_1001DC46C(43, 2, 10, 0xAu, (uint64_t *)(qword_10098FD10 + 8), (uint64_t)sub_10023AA84))
  {
    v1 = 0;
    *(_QWORD *)(qword_10098FD10 + 16) = a1;
    return v1;
  }
  v5 = sub_1001DC658(*(_QWORD *)qword_10098FD10);
  sub_100053298((void *)qword_10098FD10);
  qword_10098FD10 = 0;
  return v5;
}

void sub_10023A7B8(__int128 *a1, _BYTE *a2, int a3)
{
  int v4;
  int v5;
  void (*v6)(__int128 *);
  int v7;
  NSObject *v8;
  NSObject *v9;
  _BYTE *v10;
  __int16 v11;
  __int16 v12;
  int v13;
  char v14[3];

  if (!a2 || !a3)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
  v10 = a2;
  v11 = a3;
  v12 = a3;
  v13 = 65537;
  v4 = *a2;
  switch(*a2)
  {
    case 1:
      v5 = sub_10023B664((uint64_t)a1, (uint64_t)&v10);
      goto LABEL_32;
    case 2:
      v5 = sub_10023B95C((uint64_t)a1, (uint64_t *)&v10);
      goto LABEL_32;
    case 3:
      v5 = sub_10023BB78((uint64_t)a1, (uint64_t *)&v10);
      goto LABEL_32;
    case 4:
      v5 = sub_10023BDC0((uint64_t)a1, (uint64_t)&v10);
      goto LABEL_32;
    case 5:
      v5 = sub_10023BEC4((uint64_t)a1, (uint64_t *)&v10);
      goto LABEL_32;
    case 6:
      v6 = *(void (**)(__int128 *))(*(_QWORD *)(qword_10098FD10 + 16) + 40);
      if (v6)
        goto LABEL_24;
      v7 = 3;
      goto LABEL_33;
    case 7:
      v5 = sub_10023C030((uint64_t)a1, (uint64_t)&v10);
      goto LABEL_32;
    case 8:
      sub_10023C0C0((uint64_t)a1, (uint64_t *)&v10);
      return;
    case 9:
      v6 = *(void (**)(__int128 *))(*(_QWORD *)(qword_10098FD10 + 16) + 64);
LABEL_24:
      v6(a1);
      return;
    case 0xA:
      v5 = sub_10023C210((uint64_t)a1, (uint64_t *)&v10);
      goto LABEL_32;
    case 0xC:
      v5 = sub_10023C304((uint64_t)a1, (uint64_t *)&v10);
      goto LABEL_32;
    case 0xD:
      (*(void (**)(__int128 *))(*(_QWORD *)(qword_10098FD10 + 16) + 88))(a1);
      return;
    case 0xE:
      v5 = sub_10023C45C((uint64_t)a1, (uint64_t *)&v10);
      goto LABEL_32;
    case 0xF:
      v5 = sub_10023C554((uint64_t)a1, (uint64_t *)&v10);
      goto LABEL_32;
    case 0x10:
      v5 = sub_10023C6B4((uint64_t)a1, (uint64_t *)&v10);
      goto LABEL_32;
    case 0x11:
      v5 = sub_10023C850((uint64_t)a1, (uint64_t *)&v10);
      goto LABEL_32;
    case 0x12:
      v5 = sub_10023C948((uint64_t)a1, (uint64_t *)&v10);
      goto LABEL_32;
    case 0x13:
      v5 = sub_10023CBA4((uint64_t)a1, (uint64_t)&v10);
      goto LABEL_32;
    case 0x14:
      v5 = sub_10023CD9C((uint64_t)a1, (uint64_t)&v10);
      goto LABEL_32;
    case 0x15:
      v5 = sub_10023CF94((uint64_t)a1, (uint64_t)&v10);
      goto LABEL_32;
    case 0x16:
      v5 = sub_10023D140((uint64_t)a1, (uint64_t *)&v10);
LABEL_32:
      v7 = v5;
      if (v5)
        goto LABEL_33;
      return;
    default:
      if (sub_10005549C())
      {
        sub_100054530("Unhandled opcode: %u", v4);
        v8 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      v7 = 1;
LABEL_33:
      if (sub_10005549C())
      {
        sub_100054530("Sending error %u", v7);
        v9 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      v14[0] = v4;
      v14[1] = v7;
      v14[2] = 0;
      sub_10023AB88(a1, 8u, v14, 3uLL);
      return;
  }
}

uint64_t sub_10023AA84()
{
  uint64_t (*v0)(void);
  uint64_t result;

  v0 = *(uint64_t (**)(void))(*(_QWORD *)(qword_10098FD10 + 16) + 96);
  if (v0)
    return v0();
  return result;
}

uint64_t sub_10023AAA0()
{
  uint64_t result;

  if (!qword_10098FD10)
    return 121;
  result = sub_1001DC658(*(_QWORD *)(qword_10098FD10 + 8));
  if (!(_DWORD)result)
  {
    result = sub_1001DC658(*(_QWORD *)qword_10098FD10);
    if (!(_DWORD)result)
    {
      sub_100053298((void *)qword_10098FD10);
      result = 0;
      qword_10098FD10 = 0;
    }
  }
  return result;
}

uint64_t sub_10023AAF8(__int128 *a1, __int16 a2, __int16 a3, __int16 a4, __int16 a5)
{
  int v6;
  __int16 v7;
  __int16 v8;
  __int16 v9;
  __int16 v10;

  v6 = 1346454860;
  v7 = a2;
  v8 = a3;
  v9 = a4;
  v10 = a5;
  return sub_10023AB88(a1, 1u, (char *)&v6, 0xCuLL);
}

uint64_t sub_10023AB88(__int128 *a1, unsigned __int8 a2, char *a3, size_t a4)
{
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t result;
  _OWORD v13[7];
  unsigned __int8 v14;

  v14 = a2;
  if (!a1)
  {
    v9 = 1310;
    goto LABEL_10;
  }
  memset(&v13[1], 0, 96);
  if (a3)
    v7 = 2;
  else
    v7 = 1;
  v13[0] = 0uLL;
  v8 = sub_1000532A8((uint64_t)v13, v7);
  if ((_DWORD)v8)
  {
    v9 = v8;
LABEL_10:
    if (sub_10005549C())
    {
      sub_100054530("Failed to send PDU %u: %!", v14, v9);
      v11 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return v9;
  }
  v10 = sub_10005336C((unsigned __int8 *)v13, (char *)&v14, 1uLL, 0);
  if ((_DWORD)v10)
  {
    v9 = v10;
    sub_100253FD8((uint64_t)v13);
    goto LABEL_10;
  }
  if (!a3 || (v9 = sub_10005336C((unsigned __int8 *)v13, a3, a4, 2u), !(_DWORD)v9))
    v9 = sub_1001DBC18(0, 0x2Au, a1, (uint64_t)v13, 1);
  sub_100253FD8((uint64_t)v13);
  result = 0;
  if ((_DWORD)v9 && (_DWORD)v9 != 412)
    goto LABEL_10;
  return result;
}

uint64_t sub_10023ACC8(__int128 *a1, char a2, char a3, char a4, char a5)
{
  char v6[4];

  v6[0] = a2;
  v6[1] = a3;
  v6[2] = a4;
  v6[3] = a5;
  return sub_10023AB88(a1, 3u, v6, 4uLL);
}

uint64_t sub_10023AD00(uint64_t a1, int a2, int a3, __int16 a4, char a5)
{
  size_t v6;
  uint64_t v7;
  int v9;

  v9 = a4;
  BYTE1(v9) = HIBYTE(a4);
  BYTE2(v9) = a3 == 2;
  *(_WORD *)(a1 + 127) = 257;
  *(_BYTE *)(a1 + 129) = a5;
  if (a2)
    v6 = 4;
  else
    v6 = 2;
  v7 = sub_10023AB88((__int128 *)a1, 5u, (char *)&v9, v6);
  if (!(_DWORD)v7)
    sub_10021555C((unsigned __int16 *)a1, 5u);
  return v7;
}

uint64_t sub_10023AD80(uint64_t a1)
{
  uint64_t v2;

  v2 = sub_10023AB88((__int128 *)a1, 6u, 0, 0);
  if (!(_DWORD)v2)
  {
    *(_BYTE *)(a1 + 128) = 0;
    sub_10021555C((unsigned __int16 *)a1, 6u);
  }
  return v2;
}

uint64_t sub_10023ADC8(__int128 *a1, char *a2, unsigned __int8 a3)
{
  return sub_10023AB88(a1, 7u, a2, a3);
}

uint64_t sub_10023ADDC(__int128 *a1, char a2, __int16 a3)
{
  char v4;
  __int16 v5;

  v4 = a2;
  v5 = a3;
  return sub_10023AB88(a1, 8u, &v4, 3uLL);
}

uint64_t sub_10023AE14(__int128 *a1, char a2)
{
  char v3;

  v3 = a2;
  return sub_10023AB88(a1, 0xAu, &v3, 1uLL);
}

uint64_t sub_10023AE40(__int128 *a1, uint64_t a2, char a3)
{
  char v6[8];

  *(_DWORD *)&v6[3] = 0;
  *(_DWORD *)v6 = 0;
  sub_10004C878((uint64_t)v6, a2, 6uLL);
  v6[6] = a3;
  return sub_10023AB88(a1, 0x10u, v6, 7uLL);
}

uint64_t sub_10023AE94(__int128 *a1, uint64_t a2, __int16 a3, uint64_t *a4)
{
  uint64_t v8;
  uint64_t v9;

  v8 = 0;
  v9 = 0;
  sub_10004C878((uint64_t)&v8, a2, 6uLL);
  HIWORD(v8) = a3;
  v9 = *a4;
  return sub_10023AB88(a1, 0x12u, (char *)&v8, 0x10uLL);
}

uint64_t sub_10023AF24(__int128 *a1, uint64_t a2, _OWORD *a3)
{
  char v6[24];

  memset(v6, 0, 22);
  sub_10004C878((uint64_t)v6, a2, 6uLL);
  *(_OWORD *)&v6[6] = *a3;
  return sub_10023AB88(a1, 0x13u, v6, 0x16uLL);
}

uint64_t sub_10023AFA8(__int128 *a1, uint64_t a2, _OWORD *a3)
{
  char v6[24];

  memset(v6, 0, 22);
  sub_10004C878((uint64_t)v6, a2, 6uLL);
  *(_OWORD *)&v6[6] = *a3;
  return sub_10023AB88(a1, 0x14u, v6, 0x16uLL);
}

BOOL sub_10023B02C(unsigned int a1)
{
  unsigned int v2;
  int v3;
  NSObject *v4;

  v2 = 10 - sub_1001F16BC(43);
  if (v2 < a1)
  {
    if (sub_10005549C())
    {
      v3 = sub_1001F16BC(43);
      sub_100054530("LEA Queue full: request buffers %d, queue-size %d", a1, v3);
      v4 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_1006CEE54();
    }
  }
  sub_1001F0880();
  return v2 >= a1;
}

uint64_t sub_10023B0CC(__int128 *a1, char *a2, size_t a3, char a4, int a5)
{
  int v9;
  _BOOL4 v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  _OWORD v15[7];
  char v16;

  v16 = a4;
  if (a5)
    v9 = 412;
  else
    v9 = 625;
  if (sub_1001F4E24())
  {
    v10 = sub_1001F4E24() < 0x7D0;
    if (a1)
      goto LABEL_6;
LABEL_13:
    v11 = 1310;
    goto LABEL_17;
  }
  v10 = 0;
  if (!a1)
    goto LABEL_13;
LABEL_6:
  memset(v15, 0, sizeof(v15));
  v11 = sub_1000532A8((uint64_t)v15, 2u);
  if (!(_DWORD)v11)
  {
    v11 = sub_10005336C((unsigned __int8 *)v15, a2, a3, 2u);
    if (!(_DWORD)v11)
    {
      if (!v10 || (v11 = sub_10005336C((unsigned __int8 *)v15, &v16, 1uLL, 0), !(_DWORD)v11))
      {
        if (a5)
          v12 = sub_1001DBC18(0, 0x2Bu, a1, (uint64_t)v15, 1);
        else
          v12 = sub_1001A0BC8(a1, (uint64_t)v15, WORD2(v15[0]));
        v11 = v12;
      }
    }
    sub_100253FD8((uint64_t)v15);
  }
LABEL_17:
  if ((_DWORD)v11 != v9)
  {
    if ((_DWORD)v11)
    {
      if (sub_10005549C())
      {
        sub_100054530("Failed to send audio: %!", v11);
        v13 = sub_1000544A0(0x42u);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
    }
  }
  return v11;
}

void sub_10023B244()
{
  sub_1001F16F8(0x2Bu);
}

uint64_t sub_10023B24C(uint64_t a1, unsigned int a2, int a3)
{
  int v3;

  if (!a1)
    return 1310;
  if (a3 == 2)
    v3 = 4;
  else
    v3 = 2;
  return sub_1002160C0(a1, a2, a2, 0, 300, v3, v3);
}

BOOL sub_10023B27C(unsigned __int16 *a1, int a2, int a3)
{
  int v3;

  if (a3 == 2)
    v3 = 4;
  else
    v3 = 2;
  return sub_100218100(a1, a2, v3, v3);
}

uint64_t sub_10023B294(uint64_t a1)
{
  NSObject *v2;
  int v4;
  void *v5;

  if (!a1 || !sub_10019AC00(a1))
    return 1310;
  if (*(_DWORD *)(a1 + 132) <= 4u)
  {
    if (sub_10005549C())
    {
      sub_100054530("Disconnecting LEA device before it is ready, tell the upper layer we failed");
      v2 = sub_1000544A0(0x42u);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
        v4 = 136446210;
        v5 = sub_100054494();
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, " %{public}s", (uint8_t *)&v4, 0xCu);
      }
    }
    *(_DWORD *)(a1 + 132) = 6;
    *(_DWORD *)(a1 + 140) = 5300;
  }
  return sub_1002143C0(a1, 19);
}

uint64_t sub_10023B38C(uint64_t a1)
{
  uint64_t result;

  result = sub_10022D980(a1);
  if ((_DWORD)result)
    return sub_10022D834(a1);
  return result;
}

uint64_t sub_10023B3C0(uint64_t a1)
{
  int v2;
  int v3;
  unsigned int v5;
  int v6;
  unsigned int v7;
  int v8;
  NSObject *v9;
  uint8_t buf[4];
  void *v11;

  if (!a1 || !sub_10019AC00(a1))
    return 1310;
  v2 = *(_DWORD *)(a1 + 148);
  if (v2 == 2)
  {
    v3 = 60;
  }
  else if (v2 == 1)
  {
    if (*(unsigned __int16 *)(a1 + 104) <= 0x3Cu && *(unsigned __int16 *)(a1 + 108) <= 0x3Cu)
      return 0;
    v3 = 40;
  }
  else
  {
    v3 = 0;
  }
  v5 = *(unsigned __int16 *)(a1 + 104);
  if (v5 == v3 && *(unsigned __int16 *)(a1 + 108) == v3 || v5 <= 0x1B && *(unsigned __int16 *)(a1 + 108) < 0x1Cu)
    return 0;
  v6 = 8 * v3 + 112;
  if (v2 != 1)
    v6 = 0;
  if (v2 == 2)
    v7 = 4 * v3 + 60;
  else
    v7 = v6;
  if (v7 <= 0x148)
    v8 = 328;
  else
    v8 = v7;
  if (sub_10005549C())
  {
    sub_100054530("LEA set data length %dB %dus", v3, v8);
    v9 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v11 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  return sub_1001F5FDC(a1);
}

void sub_10023B55C(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;
  uint8_t buf[4];
  void *v5;

  if (sub_10005549C())
  {
    sub_100054530("LEA setTxDataLengthExtendedCB %!", a1);
    v2 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v5 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if ((_DWORD)a1 && sub_10005549C())
  {
    sub_100054530("Set data length extended error status %!", a1);
    v3 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      sub_1006CEE54();
  }
}

uint64_t sub_10023B664(uint64_t a1, uint64_t a2)
{
  int v3;
  uint64_t v4;
  unsigned int v5;
  unsigned __int16 v6;
  unsigned __int16 v7;
  unsigned __int16 v8;
  unsigned int v9;
  unsigned __int8 *v10;
  int v11;
  int v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  NSObject *v17;

  if (*(_BYTE *)(a2 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
  if (*(_BYTE *)(a2 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 48, "uint8_t LEA_RecvVersion(OI_HCI_CONNECTION_HANDLE, OI_BYTE_STREAM *)");
    v3 = *(unsigned __int8 *)(a2 + 14);
    *(_BYTE *)(a2 + 15) = 1;
    if (v3 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    goto LABEL_14;
  }
  v4 = *(unsigned __int16 *)(a2 + 12);
  if (*(unsigned __int16 *)(a2 + 10) - (int)v4 <= 3)
  {
    *(_BYTE *)(a2 + 15) = 1;
LABEL_14:
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 49, "uint8_t LEA_RecvVersion(OI_HCI_CONNECTION_HANDLE, OI_BYTE_STREAM *)");
    v14 = *(unsigned __int8 *)(a2 + 14);
    *(_BYTE *)(a2 + 15) = 1;
    if (v14 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    goto LABEL_15;
  }
  v5 = *(_DWORD *)(*(_QWORD *)a2 + v4);
  *(_WORD *)(a2 + 12) = v4 + 4;
  if (*(unsigned __int16 *)(a2 + 10) - (unsigned __int16)(v4 + 4) <= 1)
  {
    *(_BYTE *)(a2 + 15) = 1;
LABEL_15:
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 50, "uint8_t LEA_RecvVersion(OI_HCI_CONNECTION_HANDLE, OI_BYTE_STREAM *)");
    v15 = *(unsigned __int8 *)(a2 + 14);
    *(_BYTE *)(a2 + 15) = 1;
    if (v15 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    goto LABEL_16;
  }
  v6 = *(_WORD *)(*(_QWORD *)a2 + (unsigned __int16)(v4 + 4));
  *(_WORD *)(a2 + 12) = v4 + 6;
  if (*(unsigned __int16 *)(a2 + 10) - (unsigned __int16)(v4 + 6) <= 1)
  {
    *(_BYTE *)(a2 + 15) = 1;
LABEL_16:
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 51, "uint8_t LEA_RecvVersion(OI_HCI_CONNECTION_HANDLE, OI_BYTE_STREAM *)");
    v16 = *(unsigned __int8 *)(a2 + 14);
    *(_BYTE *)(a2 + 15) = 1;
    if (v16 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    goto LABEL_17;
  }
  v7 = *(_WORD *)(*(_QWORD *)a2 + (unsigned __int16)(v4 + 6));
  *(_WORD *)(a2 + 12) = v4 + 8;
  if (*(unsigned __int16 *)(a2 + 10) - (unsigned __int16)(v4 + 8) <= 1)
  {
    *(_BYTE *)(a2 + 15) = 1;
LABEL_17:
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 52, "uint8_t LEA_RecvVersion(OI_HCI_CONNECTION_HANDLE, OI_BYTE_STREAM *)");
    goto LABEL_18;
  }
  v8 = *(_WORD *)(*(_QWORD *)a2 + (unsigned __int16)(v4 + 8));
  *(_WORD *)(a2 + 12) = v4 + 10;
  if (*(unsigned __int16 *)(a2 + 10) - (unsigned __int16)(v4 + 10) <= 1)
  {
LABEL_18:
    *(_BYTE *)(a2 + 15) = 1;
    goto LABEL_19;
  }
  v9 = bswap32(v5);
  v10 = (unsigned __int8 *)(*(_QWORD *)a2 + (unsigned __int16)(v4 + 10));
  v11 = *v10;
  v12 = v10[1];
  *(_WORD *)(a2 + 12) = v4 + 12;
  if (v9 == 1279607120 && (unsigned __int16)(v6 - 1) <= 1u)
  {
    (**(void (***)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))(qword_10098FD10 + 16))(a1, v6, v7, v8, v11 | (v12 << 8));
    return 0;
  }
LABEL_19:
  v13 = 2;
  if (sub_10005549C())
  {
    sub_100054530("Failed to read version");
    v17 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
    return 2;
  }
  return v13;
}

uint64_t sub_10023B95C(uint64_t a1, uint64_t *a2)
{
  unsigned __int8 v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  size_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  char *v12;
  char *v13;
  char v14;
  BOOL v15;
  NSObject *v16;
  uint64_t v18;

  if (!*(_QWORD *)(*(_QWORD *)(qword_10098FD10 + 16) + 8))
    return 3;
  if (*((_BYTE *)a2 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 69, "uint16_t LEA_RecvSupportedCodecList(OI_HCI_CONNECTION_HANDLE, OI_BYTE_STREAM *)");
    v4 = 0;
  }
  else
  {
    v4 = *((_BYTE *)a2 + 10) - *((_BYTE *)a2 + 12);
  }
  __chkstk_darwin(a1, v4);
  v7 = (char *)&v18 - v6;
  bzero((char *)&v18 - v6, v8);
  if (*((_BYTE *)a2 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
  v9 = *a2;
  v10 = *((unsigned __int16 *)a2 + 6);
  if (*((_BYTE *)a2 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 72, "uint16_t LEA_RecvSupportedCodecList(OI_HCI_CONNECTION_HANDLE, OI_BYTE_STREAM *)");
    v11 = 0;
  }
  else
  {
    v11 = *((unsigned __int16 *)a2 + 5) - (_DWORD)v10;
  }
  if (v11 >= v4)
  {
    if (v4)
    {
      v12 = (char *)(v9 + v10);
      v13 = v7;
      do
      {
        v14 = *v12++;
        *v13++ = v14;
      }
      while (v13 < &v7[v4]);
    }
    *((_WORD *)a2 + 6) += v4;
    if (*((_BYTE *)a2 + 15))
      v15 = 1;
    else
      v15 = v4 == 0;
    if (!v15)
    {
      (*(void (**)(uint64_t, char *, _QWORD))(*(_QWORD *)(qword_10098FD10 + 16) + 8))(a1, v7, v4);
      return 0;
    }
  }
  else
  {
    *((_BYTE *)a2 + 15) = 1;
  }
  v5 = 2;
  if (sub_10005549C())
  {
    sub_100054530("Failed to read supported codec list");
    v16 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
    return 2;
  }
  return v5;
}

uint64_t sub_10023BB78(uint64_t a1, uint64_t *a2)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  NSObject *v15;

  if (!*(_QWORD *)(*(_QWORD *)(qword_10098FD10 + 16) + 16))
    return 3;
  if (*((_BYTE *)a2 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
  if (*((_BYTE *)a2 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 97, "uint16_t LEA_RecvSelectCodec(OI_HCI_CONNECTION_HANDLE, OI_BYTE_STREAM *)");
    v3 = *((unsigned __int8 *)a2 + 14);
    *((_BYTE *)a2 + 15) = 1;
    if (v3 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    goto LABEL_13;
  }
  v5 = *((unsigned __int16 *)a2 + 6);
  if (*((unsigned __int16 *)a2 + 5) <= v5)
  {
    *((_BYTE *)a2 + 15) = 1;
LABEL_13:
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 98, "uint16_t LEA_RecvSelectCodec(OI_HCI_CONNECTION_HANDLE, OI_BYTE_STREAM *)");
    v13 = *((unsigned __int8 *)a2 + 14);
    *((_BYTE *)a2 + 15) = 1;
    if (v13 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    goto LABEL_14;
  }
  v6 = *a2;
  *((_WORD *)a2 + 6) = v5 + 1;
  if (*((unsigned __int16 *)a2 + 5) <= (v5 + 1))
  {
    *((_BYTE *)a2 + 15) = 1;
LABEL_14:
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 99, "uint16_t LEA_RecvSelectCodec(OI_HCI_CONNECTION_HANDLE, OI_BYTE_STREAM *)");
    v14 = *((unsigned __int8 *)a2 + 14);
    *((_BYTE *)a2 + 15) = 1;
    if (v14 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    goto LABEL_15;
  }
  v7 = *(unsigned __int8 *)(v6 + v5);
  v8 = *a2;
  *((_WORD *)a2 + 6) = v5 + 2;
  if (*((unsigned __int16 *)a2 + 5) > (v5 + 2))
  {
    v9 = *(unsigned __int8 *)(v8 + v5 + 1);
    v10 = *a2;
    *((_WORD *)a2 + 6) = v5 + 3;
    if (*((unsigned __int16 *)a2 + 5) > (v5 + 3))
    {
      v11 = *(unsigned __int8 *)(v10 + v5 + 2);
      v12 = *a2;
      *((_WORD *)a2 + 6) = v5 + 4;
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)(qword_10098FD10 + 16) + 16))(a1, v7, v9, v11, *(unsigned __int8 *)(v12 + v5 + 3));
      return 0;
    }
    goto LABEL_16;
  }
  *((_BYTE *)a2 + 15) = 1;
LABEL_15:
  sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 100, "uint16_t LEA_RecvSelectCodec(OI_HCI_CONNECTION_HANDLE, OI_BYTE_STREAM *)");
LABEL_16:
  *((_BYTE *)a2 + 15) = 1;
  v4 = 2;
  if (sub_10005549C())
  {
    sub_100054530("Failed to read select codec");
    v15 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
    return 2;
  }
  return v4;
}

uint64_t sub_10023BDC0(uint64_t a1, uint64_t a2)
{
  void (*v2)(uint64_t, uint64_t);
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;

  v2 = *(void (**)(uint64_t, uint64_t))(*(_QWORD *)(qword_10098FD10 + 16) + 24);
  if (!v2)
    return 3;
  if (*(_BYTE *)(a2 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
  if (*(_BYTE *)(a2 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 122, "uint16_t LEA_RecvCodecReady(OI_HCI_CONNECTION_HANDLE, OI_BYTE_STREAM *)");
  }
  else
  {
    v5 = *(unsigned __int16 *)(a2 + 12);
    if (*(unsigned __int16 *)(a2 + 10) - (int)v5 >= 2)
    {
      v6 = *(unsigned __int16 *)(*(_QWORD *)a2 + v5);
      *(_WORD *)(a2 + 12) = v5 + 2;
      v2(a1, v6);
      return 0;
    }
  }
  *(_BYTE *)(a2 + 15) = 1;
  v4 = 2;
  if (sub_10005549C())
  {
    sub_100054530("Failed to read codec ready");
    v7 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
    return 2;
  }
  return v4;
}

uint64_t sub_10023BEC4(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  unsigned __int16 v8;
  unsigned __int16 v9;
  NSObject *v10;

  if (!*(_QWORD *)(*(_QWORD *)(qword_10098FD10 + 16) + 32))
    return 3;
  if (*((_BYTE *)a2 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
  if (*((_BYTE *)a2 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 145, "uint16_t LEA_RecvStartStream(OI_HCI_CONNECTION_HANDLE, OI_BYTE_STREAM *)");
  }
  else
  {
    v5 = *((unsigned __int16 *)a2 + 5);
    v6 = *((unsigned __int16 *)a2 + 6);
    if (v5 - (int)v6 >= 2)
    {
      v7 = *a2;
      v8 = *(_WORD *)(*a2 + v6);
      *((_WORD *)a2 + 6) = v6 + 2;
      if (v5 - (unsigned __int16)(v6 + 2) >= 2)
      {
        v9 = *(_WORD *)(v7 + (unsigned __int16)(v6 + 2));
        *((_WORD *)a2 + 6) = v6 + 4;
LABEL_15:
        (*(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)(qword_10098FD10 + 16) + 32))(a1, v8, v9);
        return 0;
      }
LABEL_14:
      v9 = 0;
      goto LABEL_15;
    }
  }
  *((_BYTE *)a2 + 15) = 1;
  sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 146, "uint16_t LEA_RecvStartStream(OI_HCI_CONNECTION_HANDLE, OI_BYTE_STREAM *)");
  v8 = *((unsigned __int8 *)a2 + 15);
  if (!*((_BYTE *)a2 + 15))
    goto LABEL_14;
  v4 = 2;
  if (sub_10005549C())
  {
    sub_100054530("Failed to read start stream");
    v10 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
    return 2;
  }
  return v4;
}

uint64_t sub_10023C030(uint64_t a1, uint64_t a2)
{
  void (*v2)(uint64_t, uint64_t, _QWORD);
  uint64_t v4;
  uint64_t v5;
  unsigned __int16 v6;

  v2 = *(void (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)(qword_10098FD10 + 16) + 48);
  if (!v2)
    return 3;
  v4 = *(unsigned __int16 *)(a2 + 12);
  v5 = *(_QWORD *)a2 + v4;
  if (*(_BYTE *)(a2 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 181, "uint16_t LEA_RecvPassthrough(OI_HCI_CONNECTION_HANDLE, OI_BYTE_STREAM *)");
    v6 = 0;
  }
  else
  {
    v6 = *(_WORD *)(a2 + 10) - v4;
  }
  v2(a1, v5, v6);
  return 0;
}

void sub_10023C0C0(uint64_t a1, uint64_t *a2)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;

  if (*((_BYTE *)a2 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
  if (*((_BYTE *)a2 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 194, "void LEA_RecvError(OI_HCI_CONNECTION_HANDLE, OI_BYTE_STREAM *)");
    v3 = *((unsigned __int8 *)a2 + 14);
    *((_BYTE *)a2 + 15) = 1;
    if (v3 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    goto LABEL_9;
  }
  v4 = *((unsigned __int16 *)a2 + 6);
  if (*((unsigned __int16 *)a2 + 5) <= v4)
  {
    *((_BYTE *)a2 + 15) = 1;
LABEL_9:
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 195, "void LEA_RecvError(OI_HCI_CONNECTION_HANDLE, OI_BYTE_STREAM *)");
    goto LABEL_10;
  }
  v5 = *a2;
  *((_WORD *)a2 + 6) = v4 + 1;
  if (*((unsigned __int16 *)a2 + 5) - ((int)v4 + 1) >= 2)
  {
    v6 = *(unsigned __int8 *)(v5 + v4);
    v7 = *(unsigned __int16 *)(*a2 + v4 + 1);
    *((_WORD *)a2 + 6) = v4 + 3;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(qword_10098FD10 + 16) + 56))(a1, v6, v7);
    return;
  }
LABEL_10:
  *((_BYTE *)a2 + 15) = 1;
  if (sub_10005549C())
  {
    sub_100054530("Failed to read error");
    v8 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
}

uint64_t sub_10023C210(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;

  if (*((_BYTE *)a2 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
  if (*((_BYTE *)a2 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 216, "uint16_t LEA_RecvSetVolume(OI_HCI_CONNECTION_HANDLE, OI_BYTE_STREAM *)");
  }
  else
  {
    v3 = *((unsigned __int16 *)a2 + 6);
    if (*((unsigned __int16 *)a2 + 5) > v3)
    {
      v4 = *a2;
      *((_WORD *)a2 + 6) = v3 + 1;
      (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)(qword_10098FD10 + 16) + 72))(a1, *(unsigned __int8 *)(v4 + v3));
      return 0;
    }
  }
  *((_BYTE *)a2 + 15) = 1;
  v5 = 2;
  if (sub_10005549C())
  {
    sub_100054530("Failed to read set volume");
    v6 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
    return 2;
  }
  return v5;
}

uint64_t sub_10023C304(uint64_t a1, uint64_t *a2)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;

  if (*((_BYTE *)a2 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
  if (*((_BYTE *)a2 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 234, "uint16_t LEA_RecvCapabilities(OI_HCI_CONNECTION_HANDLE, OI_BYTE_STREAM *)");
    v3 = *((unsigned __int8 *)a2 + 14);
    *((_BYTE *)a2 + 15) = 1;
    if (v3 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    goto LABEL_9;
  }
  v4 = *((unsigned __int16 *)a2 + 6);
  if (*((unsigned __int16 *)a2 + 5) <= v4)
  {
    *((_BYTE *)a2 + 15) = 1;
LABEL_9:
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 235, "uint16_t LEA_RecvCapabilities(OI_HCI_CONNECTION_HANDLE, OI_BYTE_STREAM *)");
    goto LABEL_10;
  }
  v5 = *a2;
  *((_WORD *)a2 + 6) = v4 + 1;
  if (*((unsigned __int16 *)a2 + 5) > (v4 + 1))
  {
    v6 = *(unsigned __int8 *)(v5 + v4);
    v7 = *a2;
    *((_WORD *)a2 + 6) = v4 + 2;
    (*(void (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)(qword_10098FD10 + 16) + 80))(a1, v6, *(unsigned __int8 *)(v7 + v4 + 1));
    return 0;
  }
LABEL_10:
  *((_BYTE *)a2 + 15) = 1;
  v8 = 2;
  if (sub_10005549C())
  {
    sub_100054530("Failed to read capabilities");
    v9 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
    return 2;
  }
  return v8;
}

uint64_t sub_10023C45C(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  void (*v5)(uint64_t, _QWORD);
  uint64_t v6;
  NSObject *v7;

  if (*((_BYTE *)a2 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
  if (*((_BYTE *)a2 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 262, "uint16_t LEA_RecvStateNoti(OI_HCI_CONNECTION_HANDLE, OI_BYTE_STREAM *)");
LABEL_7:
    *((_BYTE *)a2 + 15) = 1;
    goto LABEL_8;
  }
  v3 = *((unsigned __int16 *)a2 + 6);
  if (*((unsigned __int16 *)a2 + 5) <= v3)
    goto LABEL_7;
  v4 = *a2;
  *((_WORD *)a2 + 6) = v3 + 1;
  v5 = *(void (**)(uint64_t, _QWORD))(*(_QWORD *)(qword_10098FD10 + 16) + 104);
  if (v5)
  {
    v5(a1, *(unsigned __int8 *)(v4 + v3));
    return 0;
  }
LABEL_8:
  v6 = 2;
  if (sub_10005549C())
  {
    sub_100054530("Failed to read State Notification");
    v7 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
    return 2;
  }
  return v6;
}

uint64_t sub_10023C554(uint64_t a1, uint64_t *a2)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v7;
  uint64_t v8;
  void (*v9)(uint64_t, _QWORD, _QWORD);
  uint64_t v10;
  NSObject *v11;

  if (*((_BYTE *)a2 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
  if (*((_BYTE *)a2 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 279, "uint16_t LEA_RecvLinkQualityNoti(OI_HCI_CONNECTION_HANDLE, OI_BYTE_STREAM *)");
    v3 = *((unsigned __int8 *)a2 + 14);
    *((_BYTE *)a2 + 15) = 1;
    if (v3 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    goto LABEL_10;
  }
  v4 = *((unsigned __int16 *)a2 + 6);
  if (*((unsigned __int16 *)a2 + 5) <= v4)
  {
    *((_BYTE *)a2 + 15) = 1;
LABEL_10:
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 280, "uint16_t LEA_RecvLinkQualityNoti(OI_HCI_CONNECTION_HANDLE, OI_BYTE_STREAM *)");
    goto LABEL_11;
  }
  v5 = *a2;
  v6 = v4 + 1;
  *((_WORD *)a2 + 6) = v4 + 1;
  if (*((unsigned __int16 *)a2 + 5) <= (v4 + 1))
  {
LABEL_11:
    *((_BYTE *)a2 + 15) = 1;
    goto LABEL_12;
  }
  v7 = *(_BYTE *)(v5 + v4);
  v8 = *a2;
  *((_WORD *)a2 + 6) = v4 + 2;
  v9 = *(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)(qword_10098FD10 + 16) + 112);
  if (v9)
  {
    v9(a1, v7, *(unsigned __int8 *)(v8 + v6));
    return 0;
  }
LABEL_12:
  v10 = 2;
  if (sub_10005549C())
  {
    sub_100054530("Failed to read LinkQuality Notification");
    v11 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
    return 2;
  }
  return v10;
}

uint64_t sub_10023C6B4(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void (*v7)(uint64_t, int *, _QWORD);
  uint64_t v8;
  NSObject *v9;
  int v11;
  __int16 v12;

  if (*((_BYTE *)a2 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
  v12 = 0;
  v11 = 0;
  if (*((_BYTE *)a2 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 297, "uint16_t LEA_RecvBondingStatus(OI_HCI_CONNECTION_HANDLE, OI_BYTE_STREAM *)");
  }
  else
  {
    v4 = *((unsigned __int16 *)a2 + 6);
    if (*((unsigned __int16 *)a2 + 5) - (int)v4 >= 6)
    {
      sub_10004C878((uint64_t)&v11, *a2 + v4, 6uLL);
      *((_WORD *)a2 + 6) += 6;
      goto LABEL_7;
    }
  }
  *((_BYTE *)a2 + 15) = 1;
LABEL_7:
  if (*((_BYTE *)a2 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
  if (*((_BYTE *)a2 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 298, "uint16_t LEA_RecvBondingStatus(OI_HCI_CONNECTION_HANDLE, OI_BYTE_STREAM *)");
LABEL_13:
    *((_BYTE *)a2 + 15) = 1;
    goto LABEL_14;
  }
  v5 = *((unsigned __int16 *)a2 + 6);
  if (*((unsigned __int16 *)a2 + 5) <= v5)
    goto LABEL_13;
  v6 = *a2;
  *((_WORD *)a2 + 6) = v5 + 1;
  v7 = *(void (**)(uint64_t, int *, _QWORD))(*(_QWORD *)(qword_10098FD10 + 16) + 136);
  if (v7)
  {
    v7(a1, &v11, *(unsigned __int8 *)(v6 + v5));
    return 0;
  }
LABEL_14:
  v8 = 2;
  if (sub_10005549C())
  {
    sub_100054530("Failed to read Bonding Status");
    v9 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
    return 2;
  }
  return v8;
}

uint64_t sub_10023C850(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  void (*v5)(uint64_t, _QWORD);
  uint64_t v6;
  NSObject *v7;

  if (*((_BYTE *)a2 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
  if (*((_BYTE *)a2 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 314, "uint16_t LEA_RecvBondingStatusRes(OI_HCI_CONNECTION_HANDLE, OI_BYTE_STREAM *)");
LABEL_7:
    *((_BYTE *)a2 + 15) = 1;
    goto LABEL_8;
  }
  v3 = *((unsigned __int16 *)a2 + 6);
  if (*((unsigned __int16 *)a2 + 5) <= v3)
    goto LABEL_7;
  v4 = *a2;
  *((_WORD *)a2 + 6) = v3 + 1;
  v5 = *(void (**)(uint64_t, _QWORD))(*(_QWORD *)(qword_10098FD10 + 16) + 120);
  if (v5)
  {
    v5(a1, *(unsigned __int8 *)(v4 + v3));
    return 0;
  }
LABEL_8:
  v6 = 2;
  if (sub_10005549C())
  {
    sub_100054530("Failed to read Bonding Status Response");
    v7 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
    return 2;
  }
  return v6;
}

uint64_t sub_10023C948(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  unsigned __int16 v8;
  uint64_t v9;
  uint64_t v10;
  void (*v11)(uint64_t, int *, _QWORD, uint64_t *);
  uint64_t v12;
  NSObject *v13;
  int v15;
  __int16 v16;
  uint64_t v17;

  if (*((_BYTE *)a2 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
  v16 = 0;
  v15 = 0;
  v17 = 0;
  if (*((_BYTE *)a2 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 332, "uint16_t LEA_RecvCentralID(OI_HCI_CONNECTION_HANDLE, OI_BYTE_STREAM *)");
  }
  else
  {
    v4 = *((unsigned __int16 *)a2 + 6);
    if (*((unsigned __int16 *)a2 + 5) - (int)v4 >= 6)
    {
      sub_10004C878((uint64_t)&v15, *a2 + v4, 6uLL);
      *((_WORD *)a2 + 6) += 6;
      goto LABEL_7;
    }
  }
  *((_BYTE *)a2 + 15) = 1;
LABEL_7:
  if (*((_BYTE *)a2 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
  if (*((_BYTE *)a2 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 333, "uint16_t LEA_RecvCentralID(OI_HCI_CONNECTION_HANDLE, OI_BYTE_STREAM *)");
    v5 = *((unsigned __int8 *)a2 + 14);
    *((_BYTE *)a2 + 15) = 1;
    if (v5 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
    goto LABEL_18;
  }
  v6 = *((unsigned __int16 *)a2 + 6);
  if (*((unsigned __int16 *)a2 + 5) - (int)v6 <= 1)
  {
    *((_BYTE *)a2 + 15) = 1;
LABEL_18:
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 334, "uint16_t LEA_RecvCentralID(OI_HCI_CONNECTION_HANDLE, OI_BYTE_STREAM *)");
    goto LABEL_19;
  }
  v7 = *a2;
  v8 = *(_WORD *)(*a2 + v6);
  *((_WORD *)a2 + 6) = v6 + 2;
  if (*((unsigned __int16 *)a2 + 5) - (unsigned __int16)(v6 + 2) < 8)
  {
LABEL_19:
    *((_BYTE *)a2 + 15) = 1;
    goto LABEL_20;
  }
  v9 = 0;
  v10 = v7 + (unsigned __int16)(v6 + 2);
  do
  {
    *((_BYTE *)&v17 + v9) = *(_BYTE *)(v10 + v9);
    ++v9;
  }
  while (v9 != 8);
  *((_WORD *)a2 + 6) = v6 + 10;
  v11 = *(void (**)(uint64_t, int *, _QWORD, uint64_t *))(*(_QWORD *)(qword_10098FD10 + 16) + 144);
  if (v11)
  {
    v11(a1, &v15, v8, &v17);
    return 0;
  }
LABEL_20:
  v12 = 2;
  if (sub_10005549C())
  {
    sub_100054530("Failed to read Central ID");
    v13 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
    return 2;
  }
  return v12;
}

uint64_t sub_10023CBA4(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  __int16 v5;
  uint64_t v6;
  uint64_t v7;
  void (*v8)(uint64_t, uint64_t *, uint64_t *);
  uint64_t v9;
  NSObject *v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  if (*(_BYTE *)(a2 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
  WORD2(v12) = 0;
  LODWORD(v12) = 0;
  v13 = 0;
  v14 = 0;
  if (*(_BYTE *)(a2 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 351, "uint16_t LEA_RecvIDInfo(OI_HCI_CONNECTION_HANDLE, OI_BYTE_STREAM *)");
    LOWORD(v4) = *(_WORD *)(a2 + 12);
  }
  else
  {
    v4 = *(unsigned __int16 *)(a2 + 12);
    if (*(unsigned __int16 *)(a2 + 10) - (int)v4 >= 6)
    {
      sub_10004C878((uint64_t)&v12, *(_QWORD *)a2 + v4, 6uLL);
      LOWORD(v4) = *(_WORD *)(a2 + 12) + 6;
      *(_WORD *)(a2 + 12) = v4;
      goto LABEL_7;
    }
  }
  *(_BYTE *)(a2 + 15) = 1;
LABEL_7:
  if (*(_BYTE *)(a2 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
  if (*(_BYTE *)(a2 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 352, "uint16_t LEA_RecvIDInfo(OI_HCI_CONNECTION_HANDLE, OI_BYTE_STREAM *)");
LABEL_15:
    *(_BYTE *)(a2 + 15) = 1;
    goto LABEL_16;
  }
  v5 = v4;
  if (*(unsigned __int16 *)(a2 + 10) - (unsigned __int16)v4 < 16)
    goto LABEL_15;
  v6 = 0;
  v7 = *(_QWORD *)a2 + (unsigned __int16)v4;
  do
  {
    *((_BYTE *)&v13 + v6) = *(_BYTE *)(v7 + v6);
    ++v6;
  }
  while (v6 != 16);
  *(_WORD *)(a2 + 12) = v5 + 16;
  v8 = *(void (**)(uint64_t, uint64_t *, uint64_t *))(*(_QWORD *)(qword_10098FD10 + 16) + 152);
  if (v8)
  {
    v8(a1, &v12, &v13);
    return 0;
  }
LABEL_16:
  v9 = 2;
  if (sub_10005549C())
  {
    sub_100054530("Failed to read ID info", v12, v13, v14);
    v10 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
    return 2;
  }
  return v9;
}

uint64_t sub_10023CD9C(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  __int16 v5;
  uint64_t v6;
  uint64_t v7;
  void (*v8)(uint64_t, uint64_t *, uint64_t *);
  uint64_t v9;
  NSObject *v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  if (*(_BYTE *)(a2 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
  WORD2(v12) = 0;
  LODWORD(v12) = 0;
  v13 = 0;
  v14 = 0;
  if (*(_BYTE *)(a2 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 369, "uint16_t LEA_RecvEncryptionInfo(OI_HCI_CONNECTION_HANDLE, OI_BYTE_STREAM *)");
    LOWORD(v4) = *(_WORD *)(a2 + 12);
  }
  else
  {
    v4 = *(unsigned __int16 *)(a2 + 12);
    if (*(unsigned __int16 *)(a2 + 10) - (int)v4 >= 6)
    {
      sub_10004C878((uint64_t)&v12, *(_QWORD *)a2 + v4, 6uLL);
      LOWORD(v4) = *(_WORD *)(a2 + 12) + 6;
      *(_WORD *)(a2 + 12) = v4;
      goto LABEL_7;
    }
  }
  *(_BYTE *)(a2 + 15) = 1;
LABEL_7:
  if (*(_BYTE *)(a2 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
  if (*(_BYTE *)(a2 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 370, "uint16_t LEA_RecvEncryptionInfo(OI_HCI_CONNECTION_HANDLE, OI_BYTE_STREAM *)");
LABEL_15:
    *(_BYTE *)(a2 + 15) = 1;
    goto LABEL_16;
  }
  v5 = v4;
  if (*(unsigned __int16 *)(a2 + 10) - (unsigned __int16)v4 < 16)
    goto LABEL_15;
  v6 = 0;
  v7 = *(_QWORD *)a2 + (unsigned __int16)v4;
  do
  {
    *((_BYTE *)&v13 + v6) = *(_BYTE *)(v7 + v6);
    ++v6;
  }
  while (v6 != 16);
  *(_WORD *)(a2 + 12) = v5 + 16;
  v8 = *(void (**)(uint64_t, uint64_t *, uint64_t *))(*(_QWORD *)(qword_10098FD10 + 16) + 160);
  if (v8)
  {
    v8(a1, &v12, &v13);
    return 0;
  }
LABEL_16:
  v9 = 2;
  if (sub_10005549C())
  {
    sub_100054530("Failed to read Encryption Info", v12, v13, v14);
    v10 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
    return 2;
  }
  return v9;
}

uint64_t sub_10023CF94(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  unsigned __int8 *v6;
  int v7;
  int v8;
  void (*v9)(uint64_t, int *, _QWORD);
  uint64_t v10;
  NSObject *v11;
  int v13;
  __int16 v14;

  if (*(_BYTE *)(a2 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
  v14 = 0;
  v13 = 0;
  if (*(_BYTE *)(a2 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 387, "uint16_t LEA_RecvDisconnect(OI_HCI_CONNECTION_HANDLE, OI_BYTE_STREAM *)");
  }
  else
  {
    v4 = *(unsigned __int16 *)(a2 + 12);
    if (*(unsigned __int16 *)(a2 + 10) - (int)v4 >= 6)
    {
      sub_10004C878((uint64_t)&v13, *(_QWORD *)a2 + v4, 6uLL);
      *(_WORD *)(a2 + 12) += 6;
      goto LABEL_7;
    }
  }
  *(_BYTE *)(a2 + 15) = 1;
LABEL_7:
  if (*(_BYTE *)(a2 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
  if (*(_BYTE *)(a2 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 388, "uint16_t LEA_RecvDisconnect(OI_HCI_CONNECTION_HANDLE, OI_BYTE_STREAM *)");
LABEL_13:
    *(_BYTE *)(a2 + 15) = 1;
    goto LABEL_14;
  }
  v5 = *(unsigned __int16 *)(a2 + 12);
  if (*(unsigned __int16 *)(a2 + 10) - (int)v5 <= 1)
    goto LABEL_13;
  v6 = (unsigned __int8 *)(*(_QWORD *)a2 + v5);
  v7 = *v6;
  v8 = v6[1];
  *(_WORD *)(a2 + 12) = v5 + 2;
  v9 = *(void (**)(uint64_t, int *, _QWORD))(*(_QWORD *)(qword_10098FD10 + 16) + 168);
  if (v9)
  {
    v9(a1, &v13, v7 | (v8 << 8));
    return 0;
  }
LABEL_14:
  v10 = 2;
  if (sub_10005549C())
  {
    sub_100054530("Failed to read Disconnect");
    v11 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
    return 2;
  }
  return v10;
}

uint64_t sub_10023D140(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  void (*v5)(uint64_t, _QWORD);
  uint64_t v6;
  NSObject *v7;

  if (*((_BYTE *)a2 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c");
  if (*((_BYTE *)a2 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/le/LEA.c", 404, "uint16_t LEA_RecvSiri(OI_HCI_CONNECTION_HANDLE, OI_BYTE_STREAM *)");
LABEL_7:
    *((_BYTE *)a2 + 15) = 1;
    goto LABEL_8;
  }
  v3 = *((unsigned __int16 *)a2 + 6);
  if (*((unsigned __int16 *)a2 + 5) <= v3)
    goto LABEL_7;
  v4 = *a2;
  *((_WORD *)a2 + 6) = v3 + 1;
  v5 = *(void (**)(uint64_t, _QWORD))(*(_QWORD *)(qword_10098FD10 + 16) + 128);
  if (v5)
  {
    v5(a1, *(unsigned __int8 *)(v4 + v3));
    return 0;
  }
LABEL_8:
  v6 = 2;
  if (sub_10005549C())
  {
    sub_100054530("Failed to read Siri");
    v7 = sub_1000544A0(0x42u);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
    return 2;
  }
  return v6;
}

uint64_t sub_10023D238(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  uint64_t v5;

  if (!a1)
    sub_100253460();
  if (a2 == 1 || a2 >= 0x3E)
    sub_100253460();
  if (*(_BYTE *)qword_100999110)
  {
    v4 = 0;
    v5 = qword_10098FD18 - 88;
    while (1)
    {
      v5 += 88;
      if (v5 == a1)
        break;
      if (*(unsigned __int8 *)qword_100999110 == ++v4)
        goto LABEL_10;
    }
    return (unsigned __int16)(a2 | ((_WORD)v4 << 8));
  }
  else
  {
LABEL_10:
    sub_100253460();
    return 0;
  }
}

uint64_t sub_10023D2C0(uint64_t a1, int a2, _QWORD *a3)
{
  _QWORD *v6;
  uint64_t result;

  if (a1)
  {
    if (a3)
      goto LABEL_3;
  }
  else
  {
    sub_100253460();
    if (a3)
      goto LABEL_3;
  }
  sub_100253460();
LABEL_3:
  if (!dword_100999210)
    return 408;
  v6 = (_QWORD *)(a1 + 16);
  while (1)
  {
    v6 = (_QWORD *)*v6;
    if (!v6 || v6 == (_QWORD *)(a1 + 16))
      break;
    if (*((unsigned __int8 *)v6 - 134) == a2)
    {
      result = 0;
      *a3 = v6 - 18;
      return result;
    }
  }
  return 912;
}

uint64_t sub_10023D354(uint64_t a1, unsigned int a2, _QWORD *a3)
{
  uint64_t result;
  uint64_t v4;
  unsigned __int16 *i;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;

  if (a2 < 2)
    return 121;
  v4 = *(unsigned __int8 *)(qword_100999110 + 1);
  if (!*(_BYTE *)(qword_100999110 + 1))
    return 121;
  for (i = (unsigned __int16 *)(qword_10098FD28 + 24); *((unsigned __int8 *)i + 2) != a2 >> 1; i += 28)
  {
    if (!--v4)
      return 121;
  }
  result = sub_10023D418(a1, a2, a3);
  if (!(_DWORD)result)
  {
    v8 = *a3;
    *(_BYTE *)(v8 + 20) = 1;
    *(_QWORD *)(v8 + 40) = *((_QWORD *)i - 1);
    v9 = *a3;
    *(_WORD *)(*a3 + 160) = i[8];
    v10 = *i;
    if (v10 >= *(unsigned __int16 *)(a1 + 4))
      LOWORD(v10) = *(_WORD *)(a1 + 4);
    *(_WORD *)(v9 + 16) = v10;
    *(_QWORD *)(v9 + 48) = *((_QWORD *)i + 3);
  }
  return result;
}

uint64_t sub_10023D418(uint64_t a1, unsigned int a2, _QWORD *a3)
{
  _QWORD *v6;
  uint64_t result;
  _BYTE *v9;
  _BYTE *v10;

  if (!a1)
    sub_100253460();
  if (!dword_100999210)
    return 408;
  v6 = (_QWORD *)(a1 + 16);
  while (1)
  {
    v6 = (_QWORD *)*v6;
    if (!v6 || v6 == (_QWORD *)(a1 + 16))
      break;
    if (*((unsigned __int8 *)v6 - 134) == a2)
      return 911;
  }
  v9 = sub_100114588(0xA8uLL);
  if (!v9)
    return 106;
  v10 = v9;
  v9[20] = 0;
  *((_WORD *)v9 + 4) = sub_10023D238(a1, a2);
  *((_QWORD *)v10 + 16) = a1;
  v10[10] = a2;
  *((_QWORD *)v10 + 11) = 0;
  *((_WORD *)v10 + 8) = 127;
  *((_WORD *)v10 + 6) = 140;
  *((_QWORD *)v10 + 13) = 0;
  *((_WORD *)v10 + 81) = 0;
  *(_QWORD *)(v10 + 22) = 50544511;
  *(_DWORD *)(v10 + 30) = 16847633;
  *((_DWORD *)v10 + 14) = 0;
  sub_100253C88((_QWORD *)v10 + 18, a1 + 16);
  result = 0;
  *a3 = v10;
  return result;
}

void sub_10023D518(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;

  if (!a1)
    sub_100253460();
  v2 = *(_QWORD *)(a1 + 128);
  if (!v2)
  {
    sub_100253460();
    v2 = *(_QWORD *)(a1 + 128);
  }
  if (*(unsigned __int8 *)(v2 + 81) == *(unsigned __int8 *)(a1 + 10) && *(_QWORD *)(v2 + 72))
    sub_1001F3A20(*(unsigned __int16 *)(v2 + 2));
  if (*(_BYTE *)(a1 + 96))
  {
    *(_BYTE *)(a1 + 96) = 0;
    v3 = *(_QWORD *)(a1 + 88);
    if (v3)
    {
      *(_QWORD *)(a1 + 88) = 0;
      (*(void (**)(_QWORD, uint64_t, uint64_t))(a1 + 80))(*(unsigned __int16 *)(a1 + 8), v3, 143);
    }
  }
  v4 = *(_QWORD *)(a1 + 128);
  v7 = *(_QWORD **)(v4 + 56);
  v6 = (_QWORD *)(v4 + 56);
  v5 = v7;
  if (v7 != v6)
  {
    do
    {
      v8 = (_QWORD *)*v5;
      if (*((unsigned __int8 *)v5 - 7) == *(unsigned __int8 *)(a1 + 10))
      {
        sub_100253C9C(v5);
        sub_100254090((void *)*(v5 - 2));
        if (*((_BYTE *)v5 - 8))
          sub_10023F884(a1, 143);
        sub_100053298(v5 - 2);
      }
      v5 = v8;
    }
    while (v8 != v6);
  }
}

void sub_10023D5F8(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t v5;

  if (!a1)
    sub_100253460();
  v4 = *(_QWORD *)(a1 + 128);
  if (!v4)
  {
    sub_100253460();
    v4 = *(_QWORD *)(a1 + 128);
  }
  sub_100254F2C(*(_DWORD *)(a1 + 56));
  sub_100253C9C((_QWORD *)(a1 + 144));
  v5 = *(unsigned int *)(a1 + 136);
  if ((_DWORD)v5)
  {
    sub_100049F6C(v5);
    *(_DWORD *)(a1 + 136) = 0;
  }
  sub_10023D518(a1);
  sub_1002406D8(a1);
  if (a2 && *(_QWORD *)(v4 + 16) == v4 + 16)
    sub_10023D690((unsigned __int8 *)v4, 0, *(unsigned int *)(a1 + 164));
  sub_100053298((void *)a1);
}

uint64_t sub_10023D690(unsigned __int8 *a1, int a2, uint64_t a3)
{
  NSObject *v6;
  int v7;
  uint64_t v8;
  uint8_t buf[4];
  void *v11;

  if (!a1)
    sub_100253460();
  if (sub_10005549C())
  {
    sub_100054530("Shutting down session to %:", a1 + 6);
    v6 = sub_1000544A0(0x32u);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v11 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  v7 = *a1;
  if (!a2)
  {
    if (v7 != 9)
    {
      *a1 = 9;
      v8 = sub_100240C20(67, (uint64_t)a1, 0);
      goto LABEL_12;
    }
    return 116;
  }
  if (v7 == 10)
    return 116;
  *a1 = 10;
  v8 = sub_1001DEB7C(*((unsigned __int16 *)a1 + 1), a3);
LABEL_12:
  if ((_DWORD)v8)
    sub_10023D93C((uint64_t)a1, v8, 1);
  return 0;
}

uint64_t sub_10023D7D4(int a1)
{
  uint64_t v1;
  uint64_t result;
  NSObject *v4;

  if (!dword_100999210)
  {
    if (sub_10005549C())
    {
      sub_100054530("OI_Rfcomm_GetSessionByCID");
      v4 = sub_1000544A0(0x32u);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_1006D3010();
    }
    return 0;
  }
  v1 = *(unsigned __int8 *)qword_100999110;
  if (!*(_BYTE *)qword_100999110)
    return 0;
  for (result = qword_10098FD18; !*(_BYTE *)result || *(unsigned __int16 *)(result + 2) != a1; result += 88)
  {
    if (!--v1)
      return 0;
  }
  return result;
}

uint64_t sub_10023D880(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;
  NSObject *v5;

  if (!dword_100999210)
  {
    if (sub_10005549C())
    {
      sub_100054530("OI_Rfcomm_GetSessionByAddr");
      v5 = sub_1000544A0(0x32u);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_1006D3010();
    }
    return 0;
  }
  v1 = *(unsigned __int8 *)qword_100999110;
  if (!*(_BYTE *)qword_100999110)
    return 0;
  for (result = qword_10098FD18; ; result += 88)
  {
    if (*(_BYTE *)result)
    {
      if (*(_DWORD *)a1 == *(_DWORD *)(result + 6)
        && *(unsigned __int16 *)(a1 + 4) == *(unsigned __int16 *)(result + 10))
      {
        break;
      }
    }
    if (!--v1)
      return 0;
  }
  return result;
}

void sub_10023D93C(uint64_t a1, uint64_t a2, char a3)
{
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __int16 v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  void *v20;
  unsigned __int16 *v21;
  void (*v22)(_QWORD, uint64_t);
  void (*v23)(_QWORD, _QWORD, uint64_t);
  char v24;
  int v25;
  uint8_t buf[4];
  void *v28;
  __int16 v29;
  int v30;

  if (!a1)
    sub_100253460();
  if (!*(_BYTE *)a1)
    sub_100253460();
  sub_100242434(a1);
  sub_10024245C(a1);
  sub_100240A74(a1);
  v5 = (_QWORD *)(a1 + 16);
  v6 = *(_QWORD **)(a1 + 16);
  if (v6 == (_QWORD *)(a1 + 16))
  {
LABEL_30:
    *(_BYTE *)a1 = 0;
    sub_100242434(a1);
    sub_10024245C(a1);
    sub_100240A74(a1);
    sub_10023DDB0();
    v21 = (unsigned __int16 *)qword_10098FD20;
    if (qword_10098FD20)
    {
      do
      {
        v22 = (void (*)(_QWORD, uint64_t))*((_QWORD *)v21 + 3);
        if (v22)
        {
          v22(*v21, a2);
        }
        else
        {
          v23 = (void (*)(_QWORD, _QWORD, uint64_t))*((_QWORD *)v21 + 2);
          if (v23)
            v23(*v21, 0, a2);
        }
        v21 = *(unsigned __int16 **)(qword_10098FD20 + 32);
        sub_100053298((void *)qword_10098FD20);
        qword_10098FD20 = (uint64_t)v21;
      }
      while (v21);
    }
    qword_10098FD20 = 0;
    return;
  }
  v24 = 0;
  v25 = *(char *)(a1 + 82);
  v7 = (_QWORD *)(a1 + 16);
  do
  {
    while (1)
    {
      v8 = v6 - 18;
      *((_DWORD *)v6 + 5) = a2;
      v9 = *((unsigned __int8 *)v6 - 131);
      if (v9 > 1 || (a3 & 1) != 0 || *((_BYTE *)v6 - 124) || (v25 & 0x80000000) == 0)
        break;
      *(_WORD *)((char *)v6 - 131) = 0;
      *(v6 - 7) = 0;
      v24 = 1;
      *((_BYTE *)v6 - 111) = 1;
      *((_WORD *)v6 - 63) = 0;
      *((_DWORD *)v6 - 22) = 0;
      sub_1002406D8((uint64_t)(v6 - 18));
      v7 = (_QWORD *)*v7;
      v6 = (_QWORD *)*v7;
      if ((_QWORD *)*v7 == v5)
        goto LABEL_29;
    }
    if (v9 - 5 >= 4)
    {
      if (v9 == 9)
      {
        sub_10023D5F8(v6 - 18, 0);
        goto LABEL_24;
      }
      v11 = 0;
      *((_BYTE *)v6 - 131) = 9;
      v10 = *(v6 - 9);
    }
    else
    {
      *((_BYTE *)v6 - 131) = 9;
      sub_10023D518((uint64_t)(v6 - 18));
      v10 = 0;
      v11 = *(_QWORD *)*(v6 - 13);
    }
    v12 = *(v6 - 18);
    v13 = *(unsigned __int16 *)(a1 + 10);
    v14 = *(unsigned int *)(a1 + 6);
    v15 = *((_WORD *)v6 - 68);
    sub_10023D5F8(v8, 0);
    v16 = (char *)sub_100052DC0(0x28uLL);
    if (v16)
    {
      *(_WORD *)v16 = v15;
      *(_DWORD *)(v16 + 2) = v14;
      *((_WORD *)v16 + 3) = (v14 | (unint64_t)(v13 << 32)) >> 32;
      *((_QWORD *)v16 + 1) = v12;
      *((_QWORD *)v16 + 2) = v10;
      *((_QWORD *)v16 + 3) = v11;
      *((_QWORD *)v16 + 4) = 0;
      v17 = qword_10098FD20;
      if (qword_10098FD20)
      {
        do
        {
          v18 = v17;
          v17 = *(_QWORD *)(v17 + 32);
        }
        while (v17);
        *(_QWORD *)(v18 + 32) = v16;
      }
      else
      {
        qword_10098FD20 = (uint64_t)v16;
      }
    }
    else
    {
      sub_100253460();
      if ((sub_10005549C() & 1) != 0)
      {
        sub_100054530("Alloc RFCOMM link cache failed!");
        v19 = sub_1000544A0(0x32u);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        {
          v20 = sub_100054494();
          *(_DWORD *)buf = 136446466;
          v28 = v20;
          v29 = 1024;
          v30 = 104;
          _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "%{public}s (status=%{bluetooth:OI_STATUS}u)", buf, 0x12u);
        }
      }
    }
LABEL_24:
    v6 = (_QWORD *)*v5;
    v7 = (_QWORD *)(a1 + 16);
  }
  while ((_QWORD *)*v5 != v5);
  if ((v24 & 1) == 0)
    goto LABEL_30;
LABEL_29:
  ++*(_BYTE *)(a1 + 82);
  *(_BYTE *)a1 = 1;
  sub_10023DC60(a1, *(unsigned __int16 *)(a1 + 4));
}

uint64_t sub_10023DC60(uint64_t a1, unsigned int a2)
{
  __int16 v4;
  unsigned __int16 v5;
  __int16 v6;
  uint64_t v7;
  NSObject *v8;
  __int16 v10;
  int v11;
  __int16 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v13 = 0;
  v14 = 0;
  v15 = 0;
  sub_100252DE8(0x28u);
  v11 = 327745535;
  v12 = 776;
  if (a2 <= 0x7F)
    v4 = 5;
  else
    v4 = 6;
  v5 = v4 + a2;
  v10 = v5;
  if (v5 > 0x80u)
  {
    if (*(unsigned __int16 *)(sub_100252DE8(0x28u) + 8) >= v5)
      goto LABEL_9;
    v6 = *(_WORD *)(sub_100252DE8(0x28u) + 8);
  }
  else
  {
    v6 = 128;
  }
  v10 = v6;
LABEL_9:
  *(_BYTE *)(a1 + 12) = 1;
  *(_QWORD *)(a1 + 32) = 0;
  v7 = sub_1001DD1A8((uint64_t)sub_10023F768, (uint64_t)sub_10023FDE4, (uint64_t)sub_10023F6E0, 3u, a1 + 6, (uint64_t)&v10, (_WORD *)(a1 + 2), (uint64_t)&unk_10073B7F0);
  if ((_DWORD)v7)
  {
    if (sub_10005549C())
    {
      sub_100054530("L2CAP_CreateConnection failed with result %!", v7);
      v8 = sub_1000544A0(0x32u);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    sub_10023D93C(a1, v7, 1);
  }
  else
  {
    *(_BYTE *)a1 = 2;
  }
  return v7;
}

void sub_10023DDB0()
{
  _DWORD *v0;

  v0 = (_DWORD *)qword_10098FD30;
  if (qword_10098FD30 || (sub_100253460(), (v0 = (_DWORD *)qword_10098FD30) != 0))
  {
    if ((*v0)-- == 1)
      sub_10023EAFC();
  }
}

uint64_t sub_10023DDFC(uint64_t a1, __int16 a2, uint64_t *a3)
{
  uint64_t result;
  uint64_t v7;
  __int16 v8;
  uint64_t v9;

  v9 = 0;
  result = sub_10023DE64(a1, &v9);
  if (!(_DWORD)result)
  {
    v7 = v9;
    v8 = *(_WORD *)(a1 + 4);
    *(_DWORD *)(v9 + 6) = *(_DWORD *)a1;
    *(_WORD *)(v7 + 10) = v8;
    *(_BYTE *)(v7 + 12) = 0;
    *(_QWORD *)(v7 + 32) = 0;
    *(_WORD *)(v7 + 2) = a2;
    *a3 = v7;
  }
  return result;
}

uint64_t sub_10023DE64(uint64_t a1, uint64_t *a2)
{
  unint64_t v3;
  uint64_t v4;
  unsigned __int8 *v5;
  int v6;
  int v7;
  int v8;
  unint64_t v10;
  uint64_t i;
  uint64_t result;

  if (!dword_100999210)
    return 408;
  if (!*(_BYTE *)qword_100999110)
    return 104;
  v3 = 0;
  v4 = qword_10098FD18;
  v5 = (unsigned __int8 *)qword_10098FD18;
  do
  {
    *a2 = v4;
    v6 = *v5;
    v5 += 88;
    if (v6)
    {
      v7 = *(_DWORD *)(v4 + 6);
      v8 = *(unsigned __int16 *)(v4 + 10);
      if (*(_DWORD *)a1 == v7 && *(unsigned __int16 *)(a1 + 4) == v8)
        return 909;
    }
    ++v3;
    v10 = *(unsigned __int8 *)qword_100999110;
    v4 = (uint64_t)v5;
  }
  while (v3 < v10);
  if (!*(_BYTE *)qword_100999110)
    return 104;
  for (i = qword_10098FD18; *(_BYTE *)i; i += 88)
  {
    if (!--v10)
      return 104;
  }
  *(_OWORD *)i = 0u;
  *(_QWORD *)(i + 80) = 0;
  *(_OWORD *)(i + 48) = 0u;
  *(_OWORD *)(i + 64) = 0u;
  *(_OWORD *)(i + 16) = 0u;
  *(_OWORD *)(i + 32) = 0u;
  *(_BYTE *)i = 1;
  *(_WORD *)(i + 44) = 257;
  sub_100253C6C((_QWORD *)(i + 56));
  sub_100253C6C((_QWORD *)(i + 16));
  result = 0;
  *(_BYTE *)(i + 82) = 0;
  *a2 = i;
  ++*(_DWORD *)qword_10098FD30;
  return result;
}

uint64_t sub_10023DF88(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  unsigned int v6;
  uint64_t v7;

  if (!a1)
    sub_100253460();
  if (*(_BYTE *)(a1 + 13))
    sub_100253460();
  v2 = sub_1002405E4(a1);
  if ((_DWORD)v2)
  {
    v3 = v2;
    if (sub_10005549C())
    {
      sub_100054530("DLCI: %d", *(unsigned __int8 *)(a1 + 10));
      v4 = sub_1000544A0(0x32u);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_1006D17C4();
    }
    return v3;
  }
  else
  {
    v6 = *(unsigned __int16 *)(a1 + 16);
    v7 = *(_QWORD *)(a1 + 128);
    if (v6 >= *(unsigned __int16 *)(v7 + 4))
      LOWORD(v6) = *(_WORD *)(v7 + 4);
    *(_WORD *)(a1 + 16) = v6;
    return sub_10025495C((uint64_t)sub_10023E060, v7 + 6, *(__int128 **)(a1 + 48), (int *)(a1 + 56), 0);
  }
}

void sub_10023E060(int a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;
  NSObject *v6;

  v4 = sub_10023F588(a1);
  if (v4)
  {
    v5 = v4;
    if ((_DWORD)a2
      || (a2 = sub_1002424AC(v4[16], 1, *((unsigned __int8 *)v4 + 10), 0, *((_WORD *)v4 + 8), *((_BYTE *)v4 + 14)),
          (_DWORD)a2))
    {
      if (sub_10005549C())
      {
        sub_100054530("connection failed");
        v6 = sub_1000544A0(0x32u);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
          sub_1006D17C4();
      }
      *((_DWORD *)v5 + 41) = a2;
      ((void (*)(_QWORD, _QWORD, uint64_t))v5[9])(*((unsigned __int16 *)v5 + 4), 0, a2);
      sub_10023D5F8(v5, 1);
    }
  }
  else
  {
    sub_100254F2C(a1);
  }
}

uint64_t sub_10023E138()
{
  uint64_t v0;
  uint64_t result;
  unsigned __int16 *v2;
  unsigned int v3;
  unsigned int v4;

  v0 = *(unsigned __int8 *)(qword_100999110 + 1);
  if (!*(_BYTE *)(qword_100999110 + 1))
    return 0;
  LOWORD(result) = 0;
  v2 = (unsigned __int16 *)(qword_10098FD28 + 24);
  do
  {
    v4 = *v2;
    v2 += 28;
    v3 = v4;
    if (v4 <= (unsigned __int16)result)
      result = (unsigned __int16)result;
    else
      result = v3;
    --v0;
  }
  while (v0);
  return result;
}

uint64_t sub_10023E17C(uint64_t a1, int a2)
{
  uint64_t v2;
  unsigned __int8 *i;

  if (!a2)
    return 121;
  v2 = *(unsigned __int8 *)(qword_100999110 + 1);
  if (!*(_BYTE *)(qword_100999110 + 1))
    return 121;
  for (i = (unsigned __int8 *)(qword_10098FD28 + 26); *i != a2; i += 56)
  {
    if (!--v2)
      return 121;
  }
  (*(void (**)(void))(i - 18))();
  return 0;
}

uint64_t sub_10023E1E0(unsigned int a1, _QWORD *a2)
{
  _BYTE *v2;
  uint64_t result;

  if (!dword_100999210)
    return 408;
  if (a1 >> 8 >= *(unsigned __int8 *)qword_100999110)
    return 916;
  v2 = (_BYTE *)(qword_10098FD18 + 88 * (a1 >> 8));
  if (!*v2)
    return 916;
  result = sub_10023D2C0((uint64_t)v2, a1, a2);
  if (!(_DWORD)result)
  {
    if (*(_BYTE *)(*a2 + 13) == 9)
      return 927;
    else
      return 0;
  }
  return result;
}

uint64_t sub_10023E274(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, _BYTE *a5, uint64_t a6)
{
  BOOL v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  unsigned int v20;
  NSObject *v21;

  if (dword_100999210 || (v14 = sub_10023E410(), !(_DWORD)v14))
  {
    ++*(_DWORD *)qword_10098FD30;
    v13 = a4 < a3 && a4 != 0;
    v14 = 101;
    if (a3 && !v13 && a1 && a2)
    {
      v15 = *(unsigned __int8 *)(qword_100999110 + 1);
      if (*(_BYTE *)(qword_100999110 + 1))
      {
        v16 = 0;
        v17 = 0;
        v18 = qword_10098FD28;
        do
        {
          if (*(_BYTE *)(v18 + 26))
          {
            v16 |= 1 << *(_BYTE *)(v18 + 26);
          }
          else if (!v17)
          {
            *(_WORD *)(v18 + 24) = a3;
            v17 = v18;
          }
          v18 += 56;
          --v15;
        }
        while (v15);
        if (v17)
        {
          v19 = *a5;
          if ((v19 - 1) >= 0x1E)
            v20 = 1;
          else
            v20 = *a5;
          do
          {
            if (((v16 >> v20) & 1) == 0)
            {
              v14 = 0;
              *(_QWORD *)(v17 + 8) = a1;
              *(_QWORD *)(v17 + 16) = a2;
              *(_WORD *)(v17 + 24) = a3;
              *(_WORD *)(v17 + 40) = a4 / a3;
              *(_QWORD *)(v17 + 48) = a6;
              *(_BYTE *)(v17 + 26) = v20;
              *a5 = v20;
              return v14;
            }
            v20 = v20 % 0x1E + 1;
          }
          while (v20 != v19);
          if (sub_10005549C())
          {
            sub_100054530("No free channel numbers");
            v21 = sub_1000544A0(0x32u);
            if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
              sub_1006D3B60();
          }
        }
      }
      v14 = 104;
    }
    sub_10023DDB0();
  }
  return v14;
}

uint64_t sub_10023E410()
{
  unsigned __int8 *v0;
  _DWORD *v1;
  uint64_t v2;

  if (dword_100999210)
    sub_100253460();
  v0 = (unsigned __int8 *)sub_100252DE8(0x32u);
  qword_100999110 = (uint64_t)v0;
  if (!v0)
  {
    sub_100253460();
    v0 = (unsigned __int8 *)qword_100999110;
    if (!qword_100999110)
      return 127;
  }
  qword_10098FD20 = 0;
  qword_10098FD18 = 0;
  qword_10098FD28 = 0;
  qword_10098FD30 = 0;
  qword_10098FD18 = (uint64_t)sub_100114588(88 * *v0);
  if (!qword_10098FD18
    || (qword_10098FD28 = (uint64_t)sub_100114588(56 * *(unsigned __int8 *)(qword_100999110 + 1))) == 0)
  {
    v2 = 106;
LABEL_11:
    if (qword_10098FD30)
    {
      sub_100053298((void *)qword_10098FD30);
      qword_10098FD30 = 0;
    }
    goto LABEL_15;
  }
  v1 = sub_100114588(4uLL);
  qword_10098FD30 = (uint64_t)v1;
  if (v1)
  {
    *v1 = 0;
    v2 = sub_1001E3870(3, (uint64_t)sub_10023FC44);
    if (!(_DWORD)v2)
    {
      dword_100999210 = 1;
      return v2;
    }
    goto LABEL_11;
  }
  v2 = 106;
LABEL_15:
  if (qword_10098FD28)
  {
    sub_100053298((void *)qword_10098FD28);
    qword_10098FD28 = 0;
  }
  if (qword_10098FD18)
  {
    sub_100053298((void *)qword_10098FD18);
    qword_10098FD18 = 0;
  }
  return v2;
}

uint64_t sub_10023E540(int a1)
{
  uint64_t v2;
  _BYTE *i;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *j;
  _QWORD *v8;

  if (!dword_100999210)
    return 408;
  if ((a1 - 31) < 0xFFFFFFE2)
    return 101;
  v2 = *(unsigned __int8 *)(qword_100999110 + 1);
  if (!*(_BYTE *)(qword_100999110 + 1))
    return 120;
  for (i = (_BYTE *)(qword_10098FD28 + 26); *i != a1; i += 56)
  {
    if (!--v2)
      return 120;
  }
  if (*(_BYTE *)qword_100999110)
  {
    v4 = 0;
    do
    {
      if (*(_BYTE *)(qword_10098FD18 + 88 * v4))
      {
        v5 = qword_10098FD18 + 88 * v4;
        v8 = *(_QWORD **)(v5 + 16);
        v6 = (_QWORD *)(v5 + 16);
        for (j = v8; j && j != v6; j = (_QWORD *)*j)
        {
          if (*((_BYTE *)j - 124) && *((_BYTE *)j - 131) != 9 && a1 == *((unsigned __int8 *)j - 134) >> 1)
            return 141;
        }
      }
      ++v4;
    }
    while (v4 != *(unsigned __int8 *)qword_100999110);
  }
  *i = 0;
  *((_WORD *)i - 1) = 0;
  sub_10023DDB0();
  return 0;
}

uint64_t sub_10023E63C(uint64_t a1, unsigned int a2, uint64_t a3)
{
  return sub_10023E644(a1, a2, a3, 1);
}

uint64_t sub_10023E644(uint64_t a1, unsigned int a2, uint64_t a3, int a4)
{
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  BOOL v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;

  if (!dword_100999210)
    return 408;
  if (!a1 || !a3)
  {
    sub_100253460();
    return 101;
  }
  if (*(_BYTE *)(a3 + 1) || *(_WORD *)(a3 + 6))
    sub_100253460();
  v8 = *(unsigned __int16 *)(a3 + 4);
  if (!*(_WORD *)(a3 + 4))
    return 101;
  v16 = 0;
  v9 = sub_10023E1E0(a2, &v16);
  if (!(_DWORD)v9)
  {
    v10 = v16;
    if (*(_QWORD *)(v16 + 88))
    {
      return 901;
    }
    else
    {
      v12 = *(unsigned __int16 *)(v16 + 16);
      if (v8 <= v12 || a4)
      {
        *(_QWORD *)(v16 + 80) = a1;
        *(_QWORD *)(v10 + 88) = a3;
        sub_100254518(a3, v12);
        v13 = sub_10024058C(v16);
        v14 = v16;
        if (v13)
        {
          *(_BYTE *)(v16 + 96) = 0;
          v9 = sub_100240EEC(*(_QWORD *)(v14 + 128), *(unsigned __int8 *)(v14 + 10), a3, 0, 1);
          if ((_DWORD)v9)
          {
            if (sub_10005549C())
            {
              sub_100054530("DLCI: %d", *(unsigned __int8 *)(v16 + 10));
              v15 = sub_1000544A0(0x32u);
              if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
                sub_1006D17C4();
            }
            *(_QWORD *)(v16 + 88) = 0;
          }
        }
        else
        {
          v9 = 0;
          *(_BYTE *)(v16 + 96) = 1;
        }
      }
      else
      {
        return 918;
      }
    }
  }
  return v9;
}

uint64_t sub_10023E7BC(uint64_t a1, unsigned int a2, char *a3, size_t a4, int a5, int a6)
{
  uint64_t v7;
  void *v10;
  void *v11;

  if (!dword_100999210)
    return 408;
  if (a1)
  {
    v7 = 101;
    if (a3 && (_DWORD)a4)
    {
      v10 = sub_100254200(a3, a4, a6);
      if (v10)
      {
        v11 = v10;
        *((_QWORD *)v10 + 1) = a1;
        v7 = sub_10023E644((uint64_t)sub_10023F668, a2, (uint64_t)v10, a5);
        if ((_DWORD)v7)
          sub_100254090(v11);
      }
      else
      {
        return 106;
      }
    }
  }
  else
  {
    sub_100253460();
    return 101;
  }
  return v7;
}

uint64_t sub_10023E874(uint64_t a1, unsigned int a2, char *a3, size_t a4)
{
  return sub_10023E7BC(a1, a2, a3, a4, 0, 0);
}

uint64_t sub_10023E880(uint64_t a1, unsigned int a2, char *a3, size_t a4)
{
  return sub_10023E7BC(a1, a2, a3, a4, 1, 2);
}

uint64_t sub_10023E88C(uint64_t a1, _QWORD *a2, uint64_t a3, char a4, unsigned int a5, unsigned int a6, _WORD *a7, uint64_t a8)
{
  BOOL v17;
  uint64_t v18;
  uint64_t v20;
  unsigned int v21;
  _BYTE *v22;
  _BYTE *v23;
  uint64_t v24;
  uint64_t v25;
  __int16 v26;
  int v27;
  uint64_t v28;
  NSObject *v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;

  v32 = 0;
  if (!dword_100999210)
  {
    v18 = sub_10023E410();
    if ((_DWORD)v18)
      return v18;
  }
  if (!a2)
    goto LABEL_19;
  if (!a2[1])
  {
    sub_100253460();
    if (!a2[1])
      return 101;
  }
  if (!*a2)
  {
    sub_100253460();
    if (!*a2)
      return 101;
  }
  if (!a1 || !a3)
  {
LABEL_19:
    sub_100253460();
    return 101;
  }
  v31 = *(_DWORD *)qword_10098FD30;
  v17 = a6 < a5 && a6 != 0;
  v18 = 101;
  if (!a5 || v17)
    goto LABEL_33;
  if ((a4 - 31) < 0xE2u)
  {
    v18 = 910;
    goto LABEL_33;
  }
  v33 = sub_10023D880(a3);
  v20 = v33;
  v30 = v33;
  if (!v33)
  {
    v18 = sub_10023DE64(a3, &v33);
    if ((_DWORD)v18)
      goto LABEL_33;
    v26 = *(_WORD *)(a3 + 4);
    v27 = *(_DWORD *)a3;
    v28 = v33;
    *(_DWORD *)(v33 + 6) = v27;
    *(_WORD *)(v28 + 10) = v26;
    v18 = sub_10023DC60(v28, a5);
    if ((_DWORD)v18)
      goto LABEL_33;
    v20 = v28;
  }
  v21 = (*(unsigned __int8 *)(v20 + 12) | (2 * (a4 & 0x7F))) ^ 1;
  v22 = (_BYTE *)v20;
  v18 = sub_10023D418(v20, v21, &v32);
  if ((_DWORD)v18)
  {
LABEL_33:
    if (sub_10005549C())
    {
      sub_100054530("OI_RFCOMM_Connect failed");
      v29 = sub_1000544A0(0x32u);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        sub_1006D17C4();
    }
    if (dword_100999210)
    {
      if (*(_DWORD *)qword_10098FD30 <= v31)
      {
        if (!*(_DWORD *)qword_10098FD30)
          sub_10023EAFC();
      }
      else
      {
        sub_10023DDB0();
      }
    }
    return v18;
  }
  v23 = v22;
  v24 = v32;
  *(_QWORD *)(v32 + 72) = a1;
  *(_QWORD *)(v24 + 40) = a2;
  *(_WORD *)(v24 + 16) = a5;
  if (a7)
    *a7 = *(_WORD *)(v24 + 8);
  *(_WORD *)(v24 + 160) = a6 / a5;
  *(_QWORD *)(v24 + 48) = a8;
  if (!v30 || *v23 != 7)
    return 0;
  v25 = sub_10023DF88(v24);
  v18 = v25;
  if ((_DWORD)v25)
  {
    *(_DWORD *)(v24 + 164) = v25;
    sub_10023D5F8(v24, 1);
  }
  return v18;
}

void sub_10023EAFC()
{
  uint64_t v0;
  uint64_t v1;

  if (dword_100999210 != 1)
    sub_100253460();
  v0 = sub_1001E3A38(3);
  if ((_DWORD)v0)
  {
    v1 = sub_100112D60(v0);
    sub_10023EB7C(v1);
  }
  else
  {
    if (qword_10098FD30)
    {
      sub_100053298((void *)qword_10098FD30);
      qword_10098FD30 = 0;
    }
    if (qword_10098FD28)
    {
      sub_100053298((void *)qword_10098FD28);
      qword_10098FD28 = 0;
    }
    if (qword_10098FD18)
    {
      sub_100053298((void *)qword_10098FD18);
      qword_10098FD18 = 0;
    }
    dword_100999210 = 0;
  }
}

uint64_t sub_10023EB7C(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;

  v12 = 0;
  if (!dword_100999210)
    return 408;
  if (!a1 && a3)
  {
    sub_100253460();
    return 101;
  }
  v6 = sub_10023E1E0(a2, &v12);
  if ((_DWORD)v6)
  {
    v5 = v6;
    if (sub_10005549C())
    {
      sub_100054530("OI_RFCOMM_Accept - linkhandle %d not found", v12);
      v7 = sub_1000544A0(0x32u);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_1006D17C4();
    }
    return v5;
  }
  v8 = v12;
  if (*(_BYTE *)(v12 + 13) != 3)
    return 408;
  *(_QWORD *)(v12 + 72) = a1;
  v9 = *(_QWORD *)(v8 + 128);
  if (a3)
    return sub_10025495C((uint64_t)sub_10023ECC4, v9 + 6, *(__int128 **)(v8 + 48), (int *)(v8 + 56), 1);
  v5 = sub_100240C20(15, v9, *(unsigned __int8 *)(v8 + 10));
  v11 = v12;
  if ((_DWORD)v5)
  {
    *(_DWORD *)(v12 + 164) = v5;
    sub_10023D5F8(v11, 1);
  }
  else
  {
    if (!v12)
    {
      sub_100253460();
      v11 = v12;
    }
    v5 = 0;
    *(_BYTE *)(v11 + 13) = 9;
  }
  return v5;
}

void sub_10023ECC4(unsigned int a1, uint64_t a2, int a3)
{
  _QWORD *v6;
  uint64_t v7;
  const char *v8;
  NSObject *v9;
  int v10;
  int v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;

  v6 = sub_10023F588(a1);
  if (!v6)
  {
    sub_100254F2C(a1);
    return;
  }
  v7 = (uint64_t)v6;
  if (!(_DWORD)a2)
  {
    v13 = sub_100240C20(99, v6[16], *((unsigned __int8 *)v6 + 10));
    if (!(_DWORD)v13)
    {
      *(_BYTE *)(v7 + 13) = 4;
      sub_10024283C(*(_QWORD *)(v7 + 128), 1, *(_BYTE *)(v7 + 10), *(_BYTE *)(v7 + 12), 0);
      return;
    }
    v14 = v13;
    if (sub_10005549C())
    {
      sub_100054530("connection failed");
      v15 = sub_1000544A0(0x32u);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        sub_1006D17C4();
    }
    *(_BYTE *)(v7 + 13) = 9;
    *(_DWORD *)(v7 + 164) = v14;
    (*(void (**)(_QWORD, _QWORD, uint64_t))(v7 + 72))(*(unsigned __int16 *)(v7 + 8), 0, v14);
    goto LABEL_19;
  }
  if (sub_10005549C())
  {
    v8 = "";
    if (a3)
      v8 = "Security failure, ";
    sub_100054530("Policy enforcement failed, %s disconnecting ", v8);
    v9 = sub_1000544A0(0x32u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      sub_1006D17C4();
  }
  *(_BYTE *)(v7 + 13) = 9;
  *(_DWORD *)(v7 + 164) = a2;
  (*(void (**)(_QWORD, _QWORD, uint64_t))(v7 + 72))(*(unsigned __int16 *)(v7 + 8), 0, a2);
  v10 = sub_100240C20(15, *(_QWORD *)(v7 + 128), *(unsigned __int8 *)(v7 + 10));
  if (v10)
  {
    v11 = v10;
    if (sub_10005549C())
    {
      sub_100054530("send DM failed");
      v12 = sub_1000544A0(0x32u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        sub_1006D17C4();
    }
    *(_DWORD *)(v7 + 164) = v11;
LABEL_19:
    sub_10023D5F8(v7, 1);
  }
}

uint64_t sub_10023EEBC(unsigned int a1, int a2)
{
  unsigned __int8 v2;
  _BYTE *v3;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;

  if (!dword_100999210)
    return 408;
  v2 = a1;
  v7 = 0;
  if (a1 >> 8 >= *(unsigned __int8 *)qword_100999110)
    return 916;
  v3 = (_BYTE *)(qword_10098FD18 + 88 * (a1 >> 8));
  if (!*v3)
    return 916;
  result = sub_10023D2C0((uint64_t)v3, a1, &v7);
  if (!(_DWORD)result)
  {
    if (*(unsigned __int8 *)(v7 + 13) - 6 >= 4)
    {
      *(_DWORD *)(v7 + 164) = a2;
      result = sub_100240C20(67, (uint64_t)v3, v2);
      if (!(_DWORD)result)
      {
        v6 = v7;
        if (!v7)
        {
          sub_100253460();
          v6 = v7;
        }
        result = 0;
        *(_BYTE *)(v6 + 13) = 6;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_10023EFA4(unsigned int a1, uint64_t a2)
{
  uint64_t result;
  _QWORD *v4;

  if (!dword_100999210)
    return 408;
  v4 = 0;
  result = sub_10023E1E0(a1, &v4);
  if ((_DWORD)result)
    return 120;
  *v4 = a2;
  return result;
}

uint64_t sub_10023F000(unsigned int a1, uint64_t a2)
{
  uint64_t result;
  unsigned __int16 *v5;
  uint64_t v6;
  uint64_t v7;
  unsigned __int16 *v8;
  int v9;
  uint64_t v10;

  v10 = 0;
  result = sub_10023E1E0(a1, &v10);
  if (!(_DWORD)result)
  {
    v6 = v10;
    if (!v10)
    {
      sub_100253460();
      v6 = v10;
    }
    v7 = *(_QWORD *)(v6 + 128);
    if (v7)
      goto LABEL_12;
    sub_100253460();
LABEL_11:
    v7 = *(_QWORD *)(v10 + 128);
LABEL_12:
    v8 = (unsigned __int16 *)(v7 + 6);
    goto LABEL_13;
  }
  if ((_DWORD)result == 927)
    goto LABEL_11;
  v5 = (unsigned __int16 *)qword_10098FD20;
  if (!qword_10098FD20)
    return result;
  while (*v5 != a1)
  {
    v5 = (unsigned __int16 *)*((_QWORD *)v5 + 4);
    if (!v5)
      return result;
  }
  v8 = v5 + 1;
LABEL_13:
  result = 0;
  v9 = *(_DWORD *)v8;
  *(_WORD *)(a2 + 4) = v8[2];
  *(_DWORD *)a2 = v9;
  return result;
}

uint64_t sub_10023F0A8(uint64_t a1, uint64_t a2, uint64_t a3, char a4, unsigned int a5, unsigned int a6, _WORD *a7, _WORD *a8, uint64_t a9, int a10)
{
  uint64_t v18;
  uint64_t v19;
  NSObject *v20;
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  uint64_t v24;
  __int16 v25;
  unsigned __int16 v26;
  uint64_t v27;
  NSObject *v28;
  unsigned int v29;
  uint64_t v30;
  NSObject *v31;
  uint64_t v32;
  unsigned __int16 v34;
  int v35;
  __int16 v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;

  v40 = 0;
  v41 = 0;
  if (!dword_100999210)
  {
    v19 = sub_10023E410();
    if ((_DWORD)v19)
      return v19;
  }
  v18 = sub_10023DE64(a3, &v41);
  if ((_DWORD)v18)
  {
    v19 = v18;
    if (sub_10005549C())
    {
      sub_100054530("OI_RFCOMM_createChannelForFastConnect Allocate Session failed");
      v20 = sub_1000544A0(0x32u);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        sub_1006D17C4();
    }
    return v19;
  }
  v21 = v41;
  v22 = *(_WORD *)(a3 + 4);
  v23 = v41;
  *(_DWORD *)(v41 + 6) = *(_DWORD *)a3;
  v24 = v23 + 6;
  *(_WORD *)(v21 + 10) = v22;
  *(_QWORD *)(v21 + 32) = 0;
  sub_100252DE8(0x28u);
  if (a5 <= 0x7F)
    v25 = 5;
  else
    v25 = 6;
  v26 = v25 + a5;
  if ((unsigned __int16)(v25 + a5) >= 0x81u)
  {
    if (*(unsigned __int16 *)(sub_100252DE8(0x28u) + 8) < v26)
      v26 = *(_WORD *)(sub_100252DE8(0x28u) + 8);
  }
  else
  {
    v26 = 128;
  }
  v34 = v26;
  v35 = 327745535;
  v36 = 776;
  v38 = 0;
  v39 = 0;
  v37 = 0;
  v27 = sub_1001DC9B8(3, (uint64_t)&v34, v24, (uint64_t)sub_10023F768, (uint64_t)sub_10023FDE4, (uint64_t)sub_10023F6E0, (_WORD *)(v21 + 2), (uint64_t)&unk_10073B7F0);
  if ((_DWORD)v27)
  {
    v19 = v27;
    *(_BYTE *)v21 = 0;
    if (!sub_10005549C())
      return v19;
    sub_100054530("OI_RFCOMM_createChannelForFastConnect create L2CAP channel failed");
    v28 = sub_1000544A0(0x32u);
    if (!os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      return v19;
    goto LABEL_18;
  }
  *a8 = *(_WORD *)(v21 + 2);
  *(_BYTE *)(v21 + 12) = a10 != 0;
  v29 = (2 * a4);
  if (a10)
    v30 = sub_10023D418(v21, v29, &v40);
  else
    v30 = sub_10023D354(v21, v29, &v40);
  v19 = v30;
  *(_BYTE *)(v21 + 12) = a10 != 0;
  if ((_DWORD)v30)
  {
    *(_BYTE *)v21 = 0;
    if (!sub_10005549C())
      return v19;
    sub_100054530("OI_RFCOMM_createChannelForFastConnect allocate link failed");
    v31 = sub_1000544A0(0x32u);
    if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      return v19;
LABEL_18:
    sub_1006D17C4();
    return v19;
  }
  v32 = v40;
  *(_QWORD *)(v40 + 72) = a1;
  *(_QWORD *)(v32 + 40) = a2;
  *(_WORD *)(v32 + 16) = a5;
  if (a7)
    *a7 = *(_WORD *)(v32 + 8);
  *(_WORD *)(v32 + 160) = a6 / a5;
  *(_QWORD *)(v32 + 48) = a9;
  v19 = sub_1002405E4(v32);
  *(_BYTE *)v21 = 7;
  return v19;
}

void sub_10023F358(uint64_t a1, unsigned int a2)
{
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  __int16 v8;
  NSObject *v9;
  int *v10;

  v10 = 0;
  if (sub_1001DB044(a2, (uint64_t *)&v10))
  {
    if (sub_10005549C())
    {
      sub_100054530("OI_RFCOMM_FastConnectSetSessionMaxFrameSize L2CAP signal channel not found");
      v3 = sub_1000544A0(0x32u);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
LABEL_14:
        sub_1006CEEC0();
    }
  }
  else
  {
    v4 = sub_10023D880(a1);
    if (v4)
    {
      v5 = v4;
      v6 = *(unsigned __int16 *)(sub_1001E3CCC(v10) + 32);
      v7 = *(unsigned __int16 *)(sub_1001E3CCC(v10) + 36);
      if (v6 < v7)
        v7 = v6;
      if (v7 >= 0x85)
        v8 = -6;
      else
        v8 = -5;
      *(_WORD *)(v5 + 4) = v8 + v7;
    }
    else if (sub_10005549C())
    {
      sub_100054530("OI_RFCOMM_FastConnectSetSessionMaxFrameSize Session not found");
      v9 = sub_1000544A0(0x32u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        goto LABEL_14;
    }
  }
}

void sub_10023F45C(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  _BYTE *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;

  v4 = sub_10023D880(a1);
  v13 = 0;
  if (v4)
  {
    v5 = (_BYTE *)v4;
    v6 = v4 + 16;
    v7 = (_QWORD *)(v4 + 16);
    do
    {
      v8 = (_QWORD *)*v7;
      if (*v7 == v6)
        break;
      *((_BYTE *)v8 - 131) = 0;
      sub_10023D5F8((uint64_t)(v8 - 18), 0);
      v7 = (_QWORD *)*v7;
    }
    while (v7);
    *v5 = 0;
    sub_100242434((uint64_t)v5);
    sub_10024245C((uint64_t)v5);
    sub_100240A74((uint64_t)v5);
    sub_10023DDB0();
    v9 = (_QWORD *)qword_10098FD20;
    if (qword_10098FD20)
    {
      do
      {
        v10 = v9[4];
        sub_100053298(v9);
        qword_10098FD20 = v10;
        v9 = (_QWORD *)v10;
      }
      while (v10);
    }
    qword_10098FD20 = 0;
  }
  if (a2 && !sub_1001DB044(a2, &v13) && v13)
  {
    sub_1001DC658(v13);
    v11 = sub_10019AEA4(a1);
    if (v11)
    {
      sub_100186150(v11);
    }
    else if (sub_10005549C())
    {
      sub_100054530("OI_RFCOMM_destroyChannelForFastConnect NULL Handle");
      v12 = sub_1000544A0(0x32u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
}

_QWORD *sub_10023F588(int a1)
{
  uint64_t v1;
  _QWORD *v2;
  NSObject *v4;

  if (dword_100999210)
  {
    if (*(_BYTE *)qword_100999110)
    {
      v1 = 0;
      do
      {
        if (qword_10098FD18 && *(_BYTE *)(qword_10098FD18 + 88 * v1))
        {
          v2 = (_QWORD *)(qword_10098FD18 + 88 * v1 + 16);
          while (1)
          {
            v2 = (_QWORD *)*v2;
            if (!v2 || v2 == (_QWORD *)(qword_10098FD18 + 88 * v1 + 16))
              break;
            if (*((_DWORD *)v2 - 22) == a1)
              return v2 - 18;
          }
        }
        ++v1;
      }
      while (v1 != *(unsigned __int8 *)qword_100999110);
    }
  }
  else if (sub_10005549C())
  {
    sub_100054530("OI_GetLinkByPolicyHandle");
    v4 = sub_1000544A0(0x32u);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      sub_1006D3010();
  }
  return 0;
}

uint64_t sub_10023F668(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t (*v6)(uint64_t, uint64_t, _QWORD, uint64_t);
  unsigned __int16 v8;
  uint64_t v9;

  if (!a2)
    sub_100253460();
  v6 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(a2 + 8);
  if (!v6)
  {
    sub_100253460();
    v6 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(a2 + 8);
  }
  v9 = 0;
  v8 = 0;
  sub_100254128((void **)a2, &v9, &v8);
  return v6(a1, v9, v8, a3);
}

void sub_10023F6E0(int a1, uint64_t a2, uint64_t a3)
{
  NSObject *v3;

  if (dword_100999210)
  {
    sub_10024120C(a1, a2, a3);
  }
  else if (sub_10005549C())
  {
    sub_100054530("%!", 103);
    v3 = sub_1000544A0(0x32u);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
}

void sub_10023F768(int a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  _BYTE *v7;
  uint64_t v8;
  NSObject *v9;
  unsigned int v10;
  __int16 v11;
  char v12;

  if (dword_100999210)
  {
    v7 = (_BYTE *)sub_10023D7D4(a1);
    if (!v7)
      return;
    v8 = (uint64_t)v7;
    if ((*v7 & 0xFE) != 2)
      sub_100253460();
    if ((_DWORD)a4)
    {
      sub_10023D93C(v8, a4, 0);
      return;
    }
    if (a3 >= a2)
      v10 = a2;
    else
      v10 = a3;
    if (v10 >= 0x85)
      v11 = -6;
    else
      v11 = -5;
    *(_WORD *)(v8 + 4) = v11 + v10;
    if (*(_BYTE *)v8 == 2)
    {
      if (sub_100240C20(47, v8, 0))
        return;
      v12 = 5;
    }
    else
    {
      v12 = 4;
    }
    *(_BYTE *)v8 = v12;
  }
  else if (sub_10005549C())
  {
    sub_100054530("%!", 103);
    v9 = sub_1000544A0(0x32u);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
}

uint64_t sub_10023F884(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a1 + 88);
  *(_QWORD *)(a1 + 88) = 0;
  sub_1002540B4(v4);
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(a1 + 80))(*(unsigned __int16 *)(a1 + 8), v4, a2);
}

void sub_10023F8CC(int a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  NSObject *v15;
  uint64_t v16;
  void **v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;
  int v25;
  void (*v26)(uint64_t, _QWORD, uint64_t);
  uint64_t v27;
  uint64_t v28;

  v4 = a4;
  v28 = 0;
  if (!(_DWORD)a4
    || !sub_10005549C()
    || (sub_100054530("RFCOMM Write failed %!", v4),
        v7 = sub_1000544A0(0x32u),
        !os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)))
  {
    if (a2)
      goto LABEL_6;
    goto LABEL_5;
  }
  sub_1006CE7A4();
  if (!a2)
LABEL_5:
    sub_100253460();
LABEL_6:
  v8 = sub_10023D7D4(a1);
  if (v8)
  {
    v9 = v8;
    if (*(void **)(v8 + 72) != a2)
      sub_100253460();
    *(_QWORD *)(v9 + 72) = 0;
    sub_100254090(a2);
    v10 = *(unsigned __int8 *)(v9 + 80);
    v11 = *(unsigned __int8 *)(v9 + 81);
    if (!*(_BYTE *)(v9 + 80))
      goto LABEL_19;
    v12 = sub_10023D2C0(v9, *(unsigned __int8 *)(v9 + 81), &v28);
    if ((_DWORD)v12)
    {
      v13 = v12;
      if (sub_10005549C())
      {
        sub_100054530("%! (%d)", v13, v11);
        v14 = sub_1000544A0(0x32u);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return;
    }
    if ((_DWORD)v4)
      goto LABEL_19;
    if (!sub_100254564(*(_QWORD *)(v28 + 88), *(unsigned __int16 *)(v28 + 16)))
    {
      v4 = 0;
LABEL_19:
      if (*(_QWORD *)(v9 + 56) != v9 + 56)
      {
        v16 = sub_100253D1C((_QWORD **)(v9 + 56));
        v17 = (void **)(v16 - 16);
        if (sub_1001DBC18((uint64_t)sub_10023F8CC, *(unsigned __int16 *)(v9 + 2), 0, *(_QWORD *)(v16 - 16), 0))
        {
          sub_100254090(*v17);
          if (sub_10005549C())
          {
            sub_100054530("Write failed");
            v18 = sub_1000544A0(0x32u);
            if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
              sub_1006CE7A4();
          }
        }
        else
        {
          *(_WORD *)(v9 + 80) = *(_WORD *)(v16 - 8);
          *(_QWORD *)(v9 + 72) = *(_QWORD *)(v16 - 16);
        }
        sub_100053298(v17);
      }
      if (v10)
      {
        v19 = v28;
        if (!v28)
        {
          sub_100253460();
          v19 = v28;
        }
        v20 = *(_QWORD *)(v19 + 88);
        *(_QWORD *)(v19 + 88) = 0;
        sub_1002540B4(v20);
        (*(void (**)(_QWORD, uint64_t, uint64_t))(v19 + 80))(*(unsigned __int16 *)(v19 + 8), v20, v4);
      }
      else if ((_DWORD)v11 && !sub_10023D2C0(v9, v11, &v28))
      {
        v21 = v28;
        v22 = *(unsigned __int8 *)(v28 + 11);
        *(_BYTE *)(v28 + 11) = 0;
        if (v22 == 15)
        {
          v25 = *(unsigned __int8 *)(v21 + 13);
          if (v25 != 6 && v25 != 9)
          {
            sub_100253460();
            v25 = *(unsigned __int8 *)(v21 + 13);
          }
          if (v25 == 9)
            sub_10023D5F8(v21, 1);
        }
        else if (v22 == 99)
        {
          v23 = *(unsigned __int8 *)(v21 + 13);
          if (v23 == 8)
          {
            v26 = *(void (**)(uint64_t, _QWORD, uint64_t))(v21 + 72);
            v27 = *(unsigned __int16 *)(v21 + 8);
            sub_10023D5F8(v21, 0);
            v26(v27, 0, 927);
          }
          else if (v23 == 7)
          {
            *(_DWORD *)(v21 + 164) = 927;
            sub_100240BCC(v21, 0);
          }
        }
      }
      return;
    }
    if (!sub_10024058C(v28))
    {
      *(_BYTE *)(v28 + 96) = 1;
      return;
    }
    v24 = sub_100240EEC(v9, v11, *(_QWORD *)(v28 + 88), 0, 1);
    if ((_DWORD)v24)
    {
      v4 = v24;
      if ((_DWORD)v24 == 410)
      {
        sub_100253460();
        v4 = 410;
      }
      goto LABEL_19;
    }
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("RFCOMM session has gone away - freeing orphaned MBUF %lx", a2);
      v15 = sub_1000544A0(0x32u);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    sub_100254090(a2);
  }
}

void sub_10023FC44(uint64_t a1, uint64_t a2, unsigned int a3)
{
  unsigned int v5;
  __int128 *v6;
  int v7;
  NSObject *v8;
  _BYTE *v9;
  unsigned int v10;
  __int16 v11;
  __int16 v12;
  __int16 v13;
  __int128 v14;
  __int128 v15;
  _BYTE *v16;

  if (dword_100999210)
  {
    v16 = (_BYTE *)sub_10023D880(a2);
    if (v16 || sub_10023DDFC(a2, a3, (uint64_t *)&v16))
    {
      v5 = a3;
      v6 = 0;
      v7 = 0;
LABEL_5:
      sub_1001DDCAC((uint64_t)sub_10023F768, (uint64_t)sub_10023FDE4, (uint64_t)sub_10023F6E0, v5, (uint64_t)v6, v7, (uint64_t)&unk_10073B7F0);
      return;
    }
    v9 = v16;
    if (!v16)
    {
      sub_100253460();
      v9 = v16;
    }
    *v9 = 3;
    v14 = 0u;
    v15 = 0u;
    sub_100252DE8(0x28u);
    *(_DWORD *)((char *)&v14 + 2) = 327745535;
    WORD3(v14) = 776;
    WORD6(v14) = 0;
    BYTE8(v15) = 0;
    v10 = sub_10023E138();
    v11 = sub_10023E138();
    if (v10 <= 0x7F)
      v12 = 5;
    else
      v12 = 6;
    LOWORD(v14) = v11 + v12;
    if ((unsigned __int16)(v11 + v12) > 0x80u)
    {
      if (*(unsigned __int16 *)(sub_100252DE8(0x28u) + 8) >= (unsigned __int16)(v11 + v12))
      {
LABEL_20:
        v6 = &v14;
        v5 = a3;
        v7 = 1;
        goto LABEL_5;
      }
      v13 = *(_WORD *)(sub_100252DE8(0x28u) + 8);
    }
    else
    {
      v13 = 128;
    }
    LOWORD(v14) = v13;
    goto LABEL_20;
  }
  if (sub_10005549C())
  {
    sub_100054530("%!", 103);
    v8 = sub_1000544A0(0x32u);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
}

void sub_10023FDE4(int a1, uint64_t a2)
{
  NSObject *v4;
  unsigned __int8 *v5;
  NSObject *v6;
  uint8_t buf[4];
  void *v8;

  if (sub_10005549C())
  {
    sub_100054530("RFCOMM's L2CAP link disconnected result = %!", a2);
    v4 = sub_1000544A0(0x32u);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v8 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if (dword_100999210)
  {
    v5 = (unsigned __int8 *)sub_10023D7D4(a1);
    if (v5)
      sub_10023D93C(v5, a2, *v5 == 10);
  }
  else if (sub_10005549C())
  {
    sub_100054530("%!", 103);
    v6 = sub_1000544A0(0x32u);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
}

uint64_t sub_10023FF2C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  uint64_t result;
  uint64_t v21;
  uint64_t v22;

  sub_100253320((uint64_t)"BTVirtualTransportRegisterCBs\n", a2, a3, a4, a5, a6, a7, a8, v21);
  if (a1
    && *(_QWORD *)a1
    && (v16 = *(void **)(a1 + 8)) != 0
    && (v17 = *(void **)(a1 + 16)) != 0
    && (v18 = *(void **)(a1 + 24)) != 0
    && (v19 = *(void **)(a1 + 32)) != 0)
  {
    result = 0;
    off_10098FD38 = *(_UNKNOWN **)a1;
    off_10098FD40 = v16;
    off_10098FD48 = v17;
    off_10098FD50 = v18;
    off_10098FD58 = v19;
  }
  else
  {
    sub_100253320((uint64_t)"BTVirtualTransportRegisterCBs invalid cbs\n", v9, v10, v11, v12, v13, v14, v15, v22);
    return 114;
  }
  return result;
}

uint64_t sub_10023FFC0()
{
  if (qword_10098FD60 != -1)
    dispatch_once(&qword_10098FD60, &stru_10091F170);
  if (qword_10098FD68)
    return 0;
  else
    return 114;
}

void sub_10024000C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  __int16 v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  _BYTE *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _BYTE *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;

  v8 = a3;
  v9 = a2;
  if (!off_10098FD50)
    sub_100253460();
  sub_100253320((uint64_t)"BTVirtual transport send packet type: 0x%x\n", a2, a3, a4, a5, a6, a7, a8, a1);
  if ((_DWORD)a1 == 1)
  {
    v18 = 3;
    v19 = &qword_10098FD78;
  }
  else
  {
    if ((_DWORD)a1 != 2)
    {
      sub_100253320((uint64_t)"Virtual transport default packet type: 0x%x\n", v11, v12, v13, v14, v15, v16, v17, a1);
      return;
    }
    v18 = 4;
    v19 = &qword_10098FD88;
  }
  v20 = *v19;
  v21 = v18;
  v22 = malloc_type_malloc(v18 + (unint64_t)v8, 0x5F94FA6AuLL);
  if (!v22)
    sub_1006D3BDC(0, v23, v24, v25, v26, v27, v28, v29);
  v30 = v22;
  *(_WORD *)v22 = v9;
  v22[2] = v8;
  if ((_DWORD)a1 == 2)
    v22[3] = BYTE1(v8);
  if (v8)
    sub_100053868(&v22[v21]);
  else
    sub_10004A104();
  sub_100253320((uint64_t)"BTVirtual transport send packet type: 0x%x 0x%x\n", v31, v32, v33, v34, v35, v36, v37, a1);
  v45 = 0;
  if ((off_10098FD50(v20, v30, v21 + v8, &v45, 0xFFFFFFFFLL, sub_100240550) & 1) == 0
    && (byte_10098FD70 & 1) == 0)
  {
    sub_100253320((uint64_t)"Virtual transport write failed: type %u\n", v38, v39, v40, v41, v42, v43, v44, a1);
    __break(1u);
  }
}

uint64_t sub_100240188()
{
  return 0;
}

void sub_100240190(id a1)
{
  NSObject *v1;

  v1 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_DEFAULT, 0);
  qword_10098FD68 = (uint64_t)dispatch_queue_create("com.apple.bluetoothd.virtual-event", v1);
}

uint64_t sub_1002401C8()
{
  return 0;
}

uint64_t sub_1002401D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  uint64_t result;
  char v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;

  sub_100253320((uint64_t)"BTVirtual transport init", a2, a3, a4, a5, a6, a7, a8, v29);
  if (off_10098FD38)
    v15 = off_10098FD40 == 0;
  else
    v15 = 1;
  if (v15 || off_10098FD48 == 0 || off_10098FD50 == 0 || off_10098FD58 == 0)
  {
    sub_100253320((uint64_t)"BTVirtual transport init failed, callbacks error", v8, v9, v10, v11, v12, v13, v14, v29);
    return 633;
  }
  else
  {
    v34 = 0;
    v32 = 0u;
    v33 = 0u;
    v30 = 0u;
    v31 = 0u;
    v29 = 0u;
    byte_10098FD70 = 0;
    off_10098FD38(&v29);
    LODWORD(v29) = 2;
    DWORD2(v30) = 5000;
    LODWORD(v31) = v31 | 0xC;
    *(_QWORD *)((char *)&v31 + 4) = 0x10200000020;
    LODWORD(v34) = 25;
    *(_QWORD *)&v30 = &stru_10091F1B0;
    *(_QWORD *)&v32 = &stru_10091F1F0;
    *((_QWORD *)&v32 + 1) = &stru_10091F230;
    v20 = off_10098FD40(&v29, &qword_10098FD78);
    v28 = v20;
    result = 0;
    if ((v28 & 1) == 0)
      sub_1006D3BF4(0, v21, v22, v23, v24, v25, v26, v27);
  }
  return result;
}

void sub_1002402E8(id a1, int a2, void *a3, void *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  sub_100253320((uint64_t)"BTVirtual transport HCI got status %u with args %p and %p", *(uint64_t *)&a2, (uint64_t)a3, (uint64_t)a4, v4, v5, v6, v7, *(uint64_t *)&a2);
}

void sub_100240314(id a1, int a2, void *a3, unsigned int a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned __int16 v8;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD v34[2];

  v8 = a4;
  sub_100253320((uint64_t)"BTVirtual readCompletionBlock: %d\n", *(uint64_t *)&a2, (uint64_t)a3, *(uint64_t *)&a4, v4, v5, v6, v7, *(uint64_t *)&a2);
  sub_100253320((uint64_t)"BTVirtual handle_read type %u, status 0x%x, size %d\n", v11, v12, v13, v14, v15, v16, v17, 4);
  if (!a2)
  {
    if ((byte_10098FD70 & 1) == 0)
    {
      if ((byte_10098FD80 & 1) == 0)
      {
        v34[1] = 0;
        v34[0] = mach_continuous_time();
        v25 = sub_100047A1C(4, (unsigned __int8 *)a3, v8);
        sub_100253320((uint64_t)"BTVirtual handle_read OI_HCIIfc_DataReceived\n", v26, v27, v28, v29, v30, v31, v32, v33);
        sub_100047AB0(4, (unsigned __int8 *)a3, v25, (uint64_t)v34);
        if (!a3)
          return;
LABEL_8:
        free(a3);
        return;
      }
      sub_100253320((uint64_t)"BTVirtual handle_read OI_SNIFF_LogReceive\n", v18, v19, v20, v21, v22, v23, v24, v33);
      sub_10004A360();
    }
    if (!a3)
      return;
    goto LABEL_8;
  }
  if ((byte_10098FD70 & 1) == 0)
    sub_100253320((uint64_t)"Virtual read failed: type %u, status 0x%x\n", v18, v19, v20, v21, v22, v23, v24, 4);
}

void sub_100240418(id a1, int a2, void *a3, unsigned int a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (a2)
  {
    if ((byte_10098FD70 & 1) == 0)
    {
      sub_100253320((uint64_t)"Virtual transport HCI write failed: 0x%x\n", *(uint64_t *)&a2, (uint64_t)a3, *(uint64_t *)&a4, v4, v5, v6, v7, *(uint64_t *)&a2);
      __break(1u);
    }
  }
}

void sub_100240454(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;

  sub_100253320((uint64_t)"BTVirtual transport free\n", a2, a3, a4, a5, a6, a7, a8, v33);
  if (off_10098FD58)
    v8 = off_10098FD48 == 0;
  else
    v8 = 1;
  if (!v8)
  {
    if (off_10098FD58(qword_10098FD78))
    {
      v9 = off_10098FD48(&qword_10098FD78);
      if ((v9 & 1) == 0)
        sub_1006D3C40(v9, v10, v11, v12, v13, v14, v15, v16);
    }
    if (off_10098FD58(qword_10098FD88))
    {
      v17 = off_10098FD48(&qword_10098FD88);
      if ((v17 & 1) == 0)
        sub_1006D3C28(v17, v18, v19, v20, v21, v22, v23, v24);
    }
    if (off_10098FD58(qword_10098FD90))
    {
      v25 = off_10098FD48(&qword_10098FD90);
      if ((v25 & 1) == 0)
        sub_1006D3C10(v25, v26, v27, v28, v29, v30, v31, v32);
    }
  }
}

uint64_t sub_100240514()
{
  return 0;
}

uint64_t sub_10024051C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t vars0;

  sub_100253320((uint64_t)"BTVirtual transport terminate\n", a2, a3, a4, a5, a6, a7, a8, vars0);
  v8 = sub_1000478A0();
  sub_100240454(v8, v9, v10, v11, v12, v13, v14, v15);
  sub_1000477B8();
  return 0;
}

uint64_t sub_100240548()
{
  return 2594;
}

void sub_100240550(void *a1)
{
  if (a1)
    free(a1);
}

uint64_t sub_10024055C()
{
  return 0;
}

uint64_t sub_100240564()
{
  return 0;
}

void sub_10024056C()
{
  byte_10098FD70 = 1;
}

void sub_10024057C()
{
  byte_10098FD80 = 1;
}

BOOL sub_10024058C(uint64_t a1)
{
  uint64_t v2;

  if (!a1)
    sub_100253460();
  v2 = *(_QWORD *)(a1 + 128);
  if (!*(_BYTE *)(v2 + 44))
    return *(_BYTE *)(a1 + 32) && *(_BYTE *)(v2 + 45);
  return *(_WORD *)(a1 + 18) != 0;
}

uint64_t sub_1002405E4(uint64_t a1)
{
  unsigned int v2;
  _BYTE *v3;
  void *v4;
  uint64_t v5;
  unint64_t v6;
  void *v7;
  char *v8;
  char *v9;
  uint64_t result;
  uint64_t v11;

  if (!a1)
    sub_100253460();
  v2 = *(unsigned __int16 *)(a1 + 160);
  if (!*(_WORD *)(a1 + 160))
  {
    result = 0;
    *(_BYTE *)(a1 + 162) = 0;
    goto LABEL_13;
  }
  if (v2 >= 0xFF)
    v2 = 255;
  *(_BYTE *)(a1 + 162) = v2;
  v3 = (_BYTE *)(a1 + 162);
  *(_BYTE *)(a1 + 163) = 0;
  v4 = sub_100052DC0(24 * v2);
  *(_QWORD *)(a1 + 104) = v4;
  if (v4)
  {
    if (*v3)
    {
      v5 = 0;
      v6 = 0;
      while (1)
      {
        v7 = sub_100052DC0(*(unsigned __int16 *)(a1 + 16));
        v8 = *(char **)(a1 + 104);
        v9 = &v8[v5];
        *(_QWORD *)v9 = v7;
        *((_WORD *)v9 + 4) = 0;
        if (!v7)
          break;
        ++v6;
        v5 += 24;
        if (v6 >= *v3)
          goto LABEL_11;
      }
      if (v6)
      {
        v11 = 0;
        do
        {
          sub_100053298(*(void **)(*(_QWORD *)(a1 + 104) + v11));
          v11 += 24;
          --v6;
        }
        while (v6);
        v8 = *(char **)(a1 + 104);
      }
      sub_100053298(v8);
      result = 106;
      goto LABEL_14;
    }
LABEL_11:
    result = 0;
LABEL_13:
    v3 = (_BYTE *)(a1 + 14);
LABEL_14:
    *v3 = 0;
    return result;
  }
  return 106;
}

uint64_t sub_1002406D8(uint64_t a1)
{
  uint64_t v2;
  int v3;
  int v4;
  NSObject *v5;
  uint64_t v6;
  unint64_t v7;

  if (!a1)
    sub_100253460();
  if (*(_BYTE *)(a1 + 162))
  {
    v2 = sub_1002407D4(a1);
    if (v2)
    {
      v3 = 0;
      v4 = 0;
      do
      {
        v4 += *(unsigned __int16 *)(v2 + 8);
        v2 = sub_1002407D4(a1);
        --v3;
      }
      while (v2);
      if (v3)
      {
        if (sub_10005549C())
        {
          sub_100054530("%d rcv packets discarded (%d bytes total)", -v3, v4);
          v5 = sub_1000544A0(0x32u);
          if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
      }
    }
    if (*(_BYTE *)(a1 + 162))
    {
      v6 = 0;
      v7 = 0;
      do
      {
        sub_100053298(*(void **)(*(_QWORD *)(a1 + 104) + v6));
        ++v7;
        v6 += 24;
      }
      while (v7 < *(unsigned __int8 *)(a1 + 162));
      if (*(_BYTE *)(a1 + 162))
      {
        sub_100053298(*(void **)(a1 + 104));
        *(_QWORD *)(a1 + 104) = 0;
        *(_WORD *)(a1 + 162) = 0;
      }
    }
  }
  return 0;
}

uint64_t sub_1002407D4(uint64_t a1)
{
  uint64_t result;

  if (!a1)
    sub_100253460();
  result = *(_QWORD *)(a1 + 112);
  if (result)
  {
    *(_QWORD *)(a1 + 112) = *(_QWORD *)(result + 16);
    if (result == *(_QWORD *)(a1 + 120))
      *(_QWORD *)(a1 + 120) = 0;
    --*(_BYTE *)(a1 + 163);
  }
  return result;
}

uint64_t sub_100240824(uint64_t a1, const void *a2, unsigned int a3)
{
  unsigned int v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;

  if (!a1)
    sub_100253460();
  v6 = *(unsigned __int16 *)(a1 + 16);
  if (v6 >= a3)
  {
    if (!a3)
      return 0;
  }
  else
  {
    sub_100253460();
    v6 = *(unsigned __int16 *)(a1 + 16);
  }
  if (v6 < a3)
  {
    if (sub_10005549C())
    {
      sub_100054530("Received RFCOMM packet with larger payload size %d than set on link (%d)", a3, *(unsigned __int16 *)(a1 + 16));
      v7 = sub_1000544A0(0x32u);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 104;
  }
  if (!*(_BYTE *)(a1 + 162))
    return 104;
  v8 = 0;
  v9 = *(_QWORD *)(a1 + 104);
  while (1)
  {
    v10 = v9 + v8;
    if (!*(_WORD *)(v9 + v8 + 8))
      break;
    v8 += 24;
    if (24 * *(unsigned __int8 *)(a1 + 162) == v8)
      return 104;
  }
  *(_WORD *)(v10 + 8) = a3;
  memmove(*(void **)v10, a2, a3);
  v12 = *(_QWORD *)(a1 + 104);
  if (!v12)
    sub_100253460();
  v13 = v12 + v8;
  v14 = (_QWORD *)(a1 + 112);
  if (*(_QWORD *)(a1 + 112))
    v14 = (_QWORD *)(*(_QWORD *)(a1 + 120) + 16);
  result = 0;
  *v14 = v13;
  *(_QWORD *)(v12 + v8 + 16) = 0;
  *(_QWORD *)(a1 + 120) = v13;
  ++*(_BYTE *)(a1 + 163);
  return result;
}

uint64_t sub_100240964(uint64_t a1, unsigned int a2)
{
  uint64_t result;

  if (!a1)
    sub_100253460();
  if (!*(_BYTE *)(*(_QWORD *)(a1 + 128) + 44))
    sub_100253460();
  if (*(unsigned __int8 *)(a1 + 14) + a2 >= 0x100)
    sub_100253460();
  result = sub_1002410F4(*(_QWORD *)(a1 + 128), *(unsigned __int8 *)(a1 + 10), 0, 0, a2);
  if (!(_DWORD)result)
    *(_BYTE *)(a1 + 14) += a2;
  return result;
}

uint64_t sub_1002409D8(uint64_t a1)
{
  uint64_t result;

  if (!a1)
    sub_100253460();
  result = sub_10024058C(a1);
  if ((_DWORD)result && *(_BYTE *)(a1 + 96))
  {
    result = sub_100240EEC(*(_QWORD *)(a1 + 128), *(unsigned __int8 *)(a1 + 10), *(_QWORD *)(a1 + 88), 0, 1);
    if (!(_DWORD)result)
      *(_BYTE *)(a1 + 96) = 0;
  }
  return result;
}

void sub_100240A30(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *i;
  _QWORD *v4;

  if (!a1)
    sub_100253460();
  v4 = *(_QWORD **)(a1 + 16);
  v2 = (_QWORD *)(a1 + 16);
  for (i = v4; i && i != v2; i = (_QWORD *)*i)
    sub_1002409D8((uint64_t)(i - 18));
}

void sub_100240A74(uint64_t a1)
{
  if (!a1)
    sub_100253460();
  sub_100049F6C(*(unsigned int *)(a1 + 40));
}

uint64_t sub_100240A9C(uint64_t a1, int a2)
{
  int *v3;
  uint64_t v4;
  NSObject *v5;
  const void *v7[2];
  uint64_t v8;

  v8 = a1;
  v7[0] = 0;
  v3 = (int *)(a1 + 40);
  sub_100049F6C(*(unsigned int *)(a1 + 40));
  v7[1] = &v8;
  LOWORD(v7[0]) = 8;
  v4 = sub_10004A9EC((uint64_t)sub_100240B4C, v7, a2, v3);
  if ((_DWORD)v4)
  {
    if (sub_10005549C())
    {
      sub_100054530("Error registering session shutdown dispatch - %!", v4);
      v5 = sub_1000544A0(0x32u);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  return v4;
}

void sub_100240B4C(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;

  v1 = sub_10023D690(**(_QWORD **)(a1 + 8), 1, 930);
  if ((_DWORD)v1)
  {
    v2 = v1;
    if (sub_10005549C())
    {
      sub_100054530("RFCOMM session shutdown failed - %!", v2);
      v3 = sub_1000544A0(0x32u);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
}

uint64_t sub_100240BCC(uint64_t a1, uint64_t a2)
{
  if (!a1)
    sub_100253460();
  *(_BYTE *)(a1 + 13) = 9;
  sub_10023D518(a1);
  (**(void (***)(_QWORD, _QWORD))(a1 + 40))(*(unsigned __int16 *)(a1 + 8), *(unsigned int *)(a1 + 164));
  return sub_10023D5F8(a1, a2);
}

uint64_t sub_100240C20(int a1, uint64_t a2, uint64_t a3)
{
  int v6;
  int v7;
  char v9;
  void *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  uint64_t v19;
  char v20[2];
  __int16 v21;

  if (((a1 - 47) > 0x34 || ((1 << (a1 - 47)) & 0x10000000100001) == 0) && a1 != 15)
    sub_100253460();
  if (*(_BYTE *)(a2 + 12))
    v6 = 67;
  else
    v6 = 99;
  if (*(_BYTE *)(a2 + 12))
    v7 = 47;
  else
    v7 = 15;
  if (v7 == a1 || v6 == a1)
    v9 = 3;
  else
    v9 = 1;
  v21 = 1;
  v20[0] = v9 | (4 * a3);
  v20[1] = a1 | 0x10;
  HIBYTE(v21) = sub_100242234(v20, 3);
  v10 = sub_100254200(v20, 4uLL, 0);
  if (!v10)
    return 106;
  v11 = v10;
  v12 = sub_100240DE4(a2, a3, v10, 0);
  if (!(_DWORD)v12)
  {
    v19 = 0;
    if ((_DWORD)a3)
    {
      v15 = sub_10023D2C0(a2, a3, &v19);
      if ((_DWORD)v15)
        return v15;
      v16 = v19;
      *(_BYTE *)(v19 + 11) = a1;
      if (a1 == 47)
      {
        v17 = 2;
      }
      else
      {
        if (a1 != 67)
          return 0;
        v17 = 6;
      }
      *(_BYTE *)(v16 + 13) = v17;
    }
    else if (a1 != 47 && a1 != 67)
    {
      return 0;
    }
    sub_1002422EC(a2);
    return 0;
  }
  v13 = v12;
  if (sub_10005549C())
  {
    sub_100054530("%! (%d)", v13, a3);
    v14 = sub_1000544A0(0x32u);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  sub_100254090(v11);
  return v13;
}

uint64_t sub_100240DE4(uint64_t a1, char a2, uint64_t a3, char a4)
{
  int v8;
  _BYTE *v9;
  uint64_t v10;
  _QWORD *v11;
  void *v12;
  _QWORD *v13;

  if (!a1)
    sub_100253460();
  v8 = sub_1001DBC18((uint64_t)sub_10023F8CC, *(unsigned __int16 *)(a1 + 2), 0, a3, 0);
  if (!v8)
  {
    v10 = 0;
    *(_BYTE *)(a1 + 80) = a4;
    *(_BYTE *)(a1 + 81) = a2;
    *(_QWORD *)(a1 + 72) = a3;
    return v10;
  }
  if (v8 == 410)
  {
    v9 = sub_100052DC0(0x20uLL);
    if (v9)
    {
      *(_QWORD *)v9 = a3;
      v9[8] = a4;
      v9[9] = a2;
      sub_100253C88((_QWORD *)v9 + 2, a1 + 56);
      return 0;
    }
    return 106;
  }
  v11 = sub_100052DC0(0x20uLL);
  if (!v11)
    return 106;
  v12 = v11;
  *v11 = a3;
  *((_BYTE *)v11 + 8) = a4;
  v13 = v11 + 2;
  *((_BYTE *)v11 + 9) = a2;
  sub_100253C88(v11 + 2, a1 + 56);
  v10 = sub_100240A9C(a1, 0);
  if ((_DWORD)v10)
  {
    sub_100253C9C(v13);
    sub_100053298(v12);
  }
  return v10;
}

uint64_t sub_100240EEC(uint64_t a1, int a2, uint64_t a3, unsigned int a4, char a5)
{
  unsigned int v10;
  size_t v11;
  unsigned __int8 *v12;
  unsigned __int8 *v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  __int16 v17;
  uint64_t v19;
  char v20;
  int v21;
  char v22;

  if (a1)
  {
    if (a3)
      goto LABEL_3;
  }
  else
  {
    sub_100253460();
    if (a3)
      goto LABEL_3;
  }
  sub_100253460();
LABEL_3:
  v22 = 0;
  v21 = 0;
  v19 = 0;
  v10 = *(unsigned __int16 *)(a3 + 4);
  v11 = sub_100241068(a1, a2, v10, a4, &v21);
  v20 = sub_100242234((char *)&v21, 2);
  v12 = (unsigned __int8 *)sub_100253D54(3u);
  if (!v12)
    return 106;
  v13 = v12;
  sub_10005336C(v12, (char *)&v21, v11, 0);
  sub_10025444C(v13, a3);
  sub_10005336C(v13, &v20, 1uLL, 0);
  if (*(_BYTE *)(a1 + 44) && a2 && v10)
  {
    v14 = sub_10023D2C0(a1, a2, &v19);
    if ((_DWORD)v14)
    {
LABEL_14:
      sub_100254090(v13);
      return v14;
    }
    v15 = v19;
    v16 = *(unsigned __int8 *)(v19 + 14);
    if (v16 + a4 >= 0x100)
    {
      sub_100253460();
      v15 = v19;
      LOBYTE(v16) = *(_BYTE *)(v19 + 14);
    }
    *(_BYTE *)(v15 + 14) = v16 + a4;
    v17 = *(_WORD *)(v15 + 18);
    if (!v17)
    {
      sub_100253460();
      v15 = v19;
      v17 = *(_WORD *)(v19 + 18);
    }
    *(_WORD *)(v15 + 18) = v17 - 1;
  }
  v14 = sub_100240DE4(a1, a2, (uint64_t)v13, a5);
  if ((_DWORD)v14)
    goto LABEL_14;
  return v14;
}

uint64_t sub_100241068(uint64_t a1, char a2, unsigned int a3, unsigned int a4, _BYTE *a5)
{
  char v5;
  char v6;
  uint64_t result;
  uint64_t v8;

  if (*(_BYTE *)(a1 + 12))
    v5 = 3;
  else
    v5 = 1;
  *a5 = v5 | (4 * a2);
  v6 = 2 * a3;
  if (a4)
  {
    a5[1] = -1;
    if (a3 < 0x80)
    {
      a5[2] = v6 | 1;
LABEL_11:
      result = 4;
      v8 = 3;
      goto LABEL_12;
    }
    a5[2] = v6;
    a5[3] = a3 >> 7;
    result = 5;
    v8 = 4;
  }
  else
  {
    a5[1] = -17;
    if (a3 >= 0x80)
    {
      a5[2] = v6;
      a4 = a3 >> 7;
      goto LABEL_11;
    }
    LOBYTE(a4) = v6 | 1;
    result = 3;
    v8 = 2;
  }
LABEL_12:
  a5[v8] = a4;
  return result;
}

uint64_t sub_1002410F4(uint64_t a1, uint64_t a2, char *a3, size_t a4, unsigned int a5)
{
  char *v10;
  unsigned __int8 *v11;
  size_t v12;
  uint64_t v13;
  int v15;
  char v16;
  char v17;

  if ((_DWORD)a2 && (_DWORD)a4)
    sub_100253460();
  v10 = sub_100253D54(3u);
  if (!v10)
    return 106;
  v11 = (unsigned __int8 *)v10;
  v17 = 0;
  v15 = 0;
  v16 = 0;
  v12 = sub_100241068(a1, a2, a4, a5, &v15);
  v13 = sub_10005336C(v11, (char *)&v15, v12, 0);
  if ((_DWORD)v13
    || (v13 = sub_10005336C(v11, a3, a4, 0), (_DWORD)v13)
    || (v17 = sub_100242234((char *)&v15, 2), v13 = sub_10005336C(v11, &v17, 1uLL, 0), (_DWORD)v13)
    || (v13 = sub_100240DE4(a1, a2, v11, 0), (_DWORD)v13))
  {
    sub_100254090(v11);
  }
  return v13;
}

void sub_10024120C(int a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  NSObject *v6;
  unsigned __int8 *v7;
  int v8;
  unsigned int v9;
  NSObject *v11;
  int16x8_t v12;
  NSObject *v13;

  v5 = sub_10023D7D4(a1);
  if (!v5)
    return;
  if (a3 > 3)
  {
    v7 = (unsigned __int8 *)v5;
    v8 = *(unsigned __int8 *)(a2 + 1);
    v9 = v8 & 0xFFFFFFEF;
    if ((v8 & 0xFFFFFFEF) - 47 > 0x34 || ((1 << ((v8 & 0xEFu) - 47)) & 0x10000000100001) == 0)
    {
      if (v9 == 239)
      {
        if (sub_1002422B8(*(_BYTE *)a2, v8, *(unsigned __int8 *)(a2 + (a3 - 1))))
        {
          if (sub_10005549C())
          {
            sub_100054530("UIH FCS Error: %@", a2, a3);
            v13 = sub_1000544A0(0x32u);
            if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
              goto LABEL_24;
          }
        }
        else
        {
          sub_100241D48(v7, (unsigned __int8 *)a2, a3, v12);
        }
        return;
      }
      if (v9 != 15)
        return;
    }
    if (sub_100242278(*(_BYTE *)a2, v8, *(_BYTE *)(a2 + 2), *(unsigned __int8 *)(a2 + (a3 - 1))))
    {
      if (sub_10005549C())
      {
        sub_100054530("FCS Error: %@", a2, a3);
        v11 = sub_1000544A0(0x32u);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          goto LABEL_24;
      }
    }
    else if (v9 > 0x42u)
    {
      if (v9 == 67)
      {
        sub_1002418B4(v7, (unsigned __int8 *)a2);
      }
      else if (v9 == 99)
      {
        sub_100241608(v7, (unsigned __int8 *)a2);
      }
    }
    else if (v9 == 15)
    {
      sub_100241B18(v7, (unsigned __int8 *)a2);
    }
    else if (v9 == 47)
    {
      sub_100241440(v7, (unsigned __int8 *)a2);
    }
  }
  else if (sub_10005549C())
  {
    sub_100054530("OI_Rfcomm_ReceiveFrame invalid frame length=%d", a3);
    v6 = sub_1000544A0(0x32u);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
LABEL_24:
      sub_1006CE7A4();
  }
}

unsigned __int8 *sub_100241440(unsigned __int8 *result, unsigned __int8 *a2)
{
  unsigned int v2;
  _BYTE *v3;
  unsigned int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;

  v2 = *a2;
  if ((v2 & 1) != 0 && (a2[1] & 0x10) != 0)
  {
    v3 = result;
    if (result[12])
    {
      if ((v2 & 2) != 0)
        return result;
    }
    else if ((v2 & 2) == 0)
    {
      return result;
    }
    v11 = 0;
    v4 = v2 >> 2;
    v5 = *result;
    if (v5 != 7)
    {
      if (v5 == 4 && v2 <= 3)
      {
        result = (unsigned __int8 *)sub_100240C20(99, (uint64_t)result, v2 >> 2);
        if (!(_DWORD)result)
          *v3 = 7;
        return result;
      }
      return (unsigned __int8 *)sub_100240C20(15, (uint64_t)v3, v2 >> 2);
    }
    if (v2 > 0xF7 || v4 == 1)
    {
      if (sub_10005549C())
      {
        sub_100054530("%! (%d)", 912, v2 >> 2);
        v9 = sub_1000544A0(0x32u);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return (unsigned __int8 *)sub_100240C20(15, (uint64_t)v3, v2 >> 2);
    }
    if (sub_10023D2C0((uint64_t)result, v2 >> 2, &v11))
    {
      v6 = sub_10023D354((uint64_t)v3, v2 >> 2, &v11);
      if ((_DWORD)v6)
      {
        v7 = v6;
        if (sub_10005549C())
        {
          sub_100054530("%! (%d)", v7, 0);
          v8 = sub_1000544A0(0x32u);
          if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
        return (unsigned __int8 *)sub_100240C20(15, (uint64_t)v3, v2 >> 2);
      }
      v10 = v11;
      if (!v11)
      {
        sub_100253460();
        v10 = v11;
      }
    }
    else
    {
      v10 = v11;
      if (*(_BYTE *)(v11 + 13) == 6)
        return (unsigned __int8 *)sub_100240C20(15, (uint64_t)v3, v2 >> 2);
    }
    *(_BYTE *)(v10 + 13) = 3;
    *(_BYTE *)(v10 + 10) = v4;
    result = (unsigned __int8 *)sub_10023E17C((uint64_t)(v3 + 6), v2 >> 3);
    if (!(_DWORD)result)
      return result;
    *(_DWORD *)(v11 + 164) = 921;
    sub_10023D5F8();
    return (unsigned __int8 *)sub_100240C20(15, (uint64_t)v3, v2 >> 2);
  }
  return result;
}

void sub_100241608(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned int v4;
  uint64_t v5;
  int v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  uint64_t v10;
  int v11;
  unsigned __int8 *v12;
  BOOL v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  NSObject *v17;
  NSObject *v18;
  NSObject *v19;
  uint64_t v20;

  sub_100242434((uint64_t)a1);
  v4 = *a2;
  if ((v4 & 1) == 0 || (a2[1] & 0x10) == 0)
    return;
  if (a1[12])
  {
    if ((v4 & 2) == 0)
      return;
  }
  else if ((v4 & 2) != 0)
  {
    return;
  }
  v20 = 0;
  v5 = v4 >> 2;
  v6 = *a1;
  if (v6 == 9)
  {
    if (v4 <= 3)
    {
      v14 = sub_1001DEB7C(*((unsigned __int16 *)a1 + 1), 560);
      if ((_DWORD)v14)
        sub_10023D93C(a1, v14, 1);
      else
        *a1 = 10;
      return;
    }
    if (sub_10023D2C0((uint64_t)a1, v4 >> 2, &v20))
    {
      if (!sub_10005549C())
        return;
      sub_100054530("%! (%d)", 912, v5);
      v17 = sub_1000544A0(0x32u);
      if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        return;
LABEL_43:
      sub_1006CE7A4();
      return;
    }
    v15 = v20;
    goto LABEL_39;
  }
  if (v6 != 7)
  {
    if (v6 == 5 && v4 <= 3)
    {
      *a1 = 7;
      v9 = (unsigned __int8 *)*((_QWORD *)a1 + 2);
      v7 = a1 + 16;
      v8 = v9;
      if (v9)
      {
        if (v8 != v7)
        {
          do
          {
            v20 = (uint64_t)(v8 - 144);
            v10 = sub_10023DF88((uint64_t)(v8 - 144));
            if ((_DWORD)v10)
            {
              v11 = v10;
              v12 = (unsigned __int8 *)*((_QWORD *)v8 + 1);
              (*((void (**)(_QWORD, _QWORD, uint64_t))v8 - 9))(*((unsigned __int16 *)v8 - 68), 0, v10);
              *((_DWORD *)v8 + 5) = v11;
              sub_10023D5F8(v8 - 144, 1);
              v8 = v12;
            }
            v8 = *(unsigned __int8 **)v8;
            if (v8)
              v13 = v8 == v7;
            else
              v13 = 1;
          }
          while (!v13);
        }
      }
    }
    return;
  }
  if ((_DWORD)v5 == 1 || (v4 + 8) <= 0xBu)
  {
    if (sub_10005549C())
    {
      sub_100054530("%! (%d)", 101, v5);
      v18 = sub_1000544A0(0x32u);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return;
  }
  if (sub_10023D2C0((uint64_t)a1, v5, &v20))
    return;
  v15 = v20;
  v16 = *(unsigned __int8 *)(v20 + 13);
  if (v16 == 6)
  {
LABEL_39:
    sub_100240BCC(v15, 1);
    return;
  }
  if (v16 == 2)
  {
    *(_BYTE *)(v20 + 13) = 4;
    sub_10024283C((uint64_t)a1, 1, v5, *(_BYTE *)(v15 + 12), 0);
    return;
  }
  if (sub_10005549C())
  {
    sub_100054530("%! (%d)", 408, *(unsigned __int8 *)(v20 + 13));
    v19 = sub_1000544A0(0x32u);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      goto LABEL_43;
  }
}

void sub_1002418B4(_BYTE *a1, unsigned __int8 *a2)
{
  unsigned int v2;
  uint64_t v4;
  uint64_t v5;
  int v6;
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  NSObject *v13;
  uint64_t v14;
  void (*v15)(uint64_t, _QWORD, uint64_t);
  uint64_t v16;
  uint64_t v17;

  v2 = *a2;
  if ((v2 & 1) == 0 || (a2[1] & 0x10) == 0)
    return;
  v17 = 0;
  if (!a1[12])
  {
    if ((v2 & 2) != 0)
      goto LABEL_6;
LABEL_16:
    if (!sub_10005549C())
      return;
    sub_100054530("%! (%d)", 917, 0);
    v7 = sub_1000544A0(0x32u);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      return;
LABEL_18:
    sub_1006CE7A4();
    return;
  }
  if ((v2 & 2) != 0)
    goto LABEL_16;
LABEL_6:
  v4 = v2 >> 2;
  if (v2 > 0xF7 || (_DWORD)v4 == 1)
  {
    if (!sub_10005549C())
      return;
    sub_100054530("%! (%d)", 920, v4);
    v8 = sub_1000544A0(0x32u);
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      return;
    goto LABEL_18;
  }
  if (*a1 != 7)
  {
LABEL_14:
    sub_100240C20(99, (uint64_t)a1, v4);
    return;
  }
  if (v2 <= 3)
  {
    v5 = sub_100252DE8(0x32u);
    if (*(_WORD *)(v5 + 10))
      v6 = *(unsigned __int16 *)(v5 + 10);
    else
      v6 = 30;
    *a1 = 8;
    sub_100240A9C((uint64_t)a1, v6);
    goto LABEL_14;
  }
  if (sub_10023D2C0((uint64_t)a1, v2 >> 2, &v17))
  {
    if (sub_10005549C())
    {
      sub_100054530("DLCI %d not found", v4);
      v9 = sub_1000544A0(0x32u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  else
  {
    v10 = sub_100240C20(99, (uint64_t)a1, v4);
    v11 = v17;
    v12 = *(unsigned __int8 *)(v17 + 13);
    if (v12 != 6)
    {
      if (v12 == 5)
      {
        *(_BYTE *)(v17 + 13) = 7;
        if ((_DWORD)v10)
        {
          if (sub_10005549C())
          {
            sub_100054530("RFCOMM send command failed with result : %!", v10);
            v13 = sub_1000544A0(0x32u);
            if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
              sub_1006CE7A4();
          }
          v14 = v17;
          *(_DWORD *)(v17 + 164) = 933;
          sub_100240BCC(v14, 0);
        }
      }
      else
      {
        v15 = *(void (**)(uint64_t, _QWORD, uint64_t))(v17 + 72);
        if (v15)
        {
          *(_BYTE *)(v17 + 13) = 8;
          if ((_DWORD)v10)
          {
            v16 = *(unsigned __int16 *)(v11 + 8);
            sub_10023D5F8(v11, 0);
            v15(v16, 0, 927);
          }
        }
      }
    }
  }
}

void sub_100241B18(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned int v2;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  int v8;
  NSObject *v9;
  uint64_t v10;
  void (*v11)(_QWORD, _QWORD, uint64_t);
  int v12;
  NSObject *v13;
  uint64_t v14;

  v2 = *a2;
  if ((v2 & 1) != 0)
  {
    if (a1[12])
    {
      if ((v2 & 2) == 0)
        return;
    }
    else if ((v2 & 2) != 0)
    {
      return;
    }
    v14 = 0;
    v5 = sub_10023D2C0((uint64_t)a1, v2 >> 2, &v14);
    if ((_DWORD)v5)
    {
      v6 = v5;
      if (sub_10005549C())
      {
        sub_100054530("%! (%d)", v6, v2 >> 2);
        v7 = sub_1000544A0(0x32u);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
LABEL_33:
          sub_1006CE7A4();
      }
    }
    else if ((a2[1] & 0x10) != 0 || (*(unsigned __int8 *)(v14 + 13) | 4) != 6)
    {
      v8 = *a1;
      if (v8 == 7)
      {
        if (v2 >> 2 != 1 && (v2 + 8) >= 0xCu)
        {
          if ((*(unsigned __int8 *)(v14 + 13) | 4) == 6)
            sub_100242434((uint64_t)a1);
          else
            sub_10024245C((uint64_t)a1);
          v10 = v14;
          switch(*(_BYTE *)(v14 + 13))
          {
            case 0:
            case 1:
            case 2:
              v11 = *(void (**)(_QWORD, _QWORD, uint64_t))(v14 + 72);
              if (v11)
              {
                *(_DWORD *)(v14 + 164) = 934;
                v11(*(unsigned __int16 *)(v10 + 8), 0, 913);
                sub_10023D5F8(v14, 1);
              }
              else if (sub_10005549C())
              {
                sub_100054530("Received unsolicited remote reject, ignore");
                v13 = sub_1000544A0(0x32u);
                if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
                  goto LABEL_33;
              }
              return;
            case 3:
            case 4:
            case 5:
              v12 = 934;
              goto LABEL_28;
            case 6:
            case 9:
              goto LABEL_29;
            case 7:
            case 8:
              v12 = 927;
LABEL_28:
              *(_DWORD *)(v14 + 164) = v12;
LABEL_29:
              sub_100240BCC(v10, 1);
              break;
            default:
              return;
          }
        }
      }
      else
      {
        if (v8 == 5)
        {
          sub_100242434((uint64_t)a1);
          sub_10023D690(a1, 0, 929);
          return;
        }
        if (sub_10005549C())
        {
          sub_100054530("Unexpected DM received");
          v9 = sub_1000544A0(0x32u);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
            goto LABEL_33;
        }
      }
    }
  }
}

void sub_100241D48(_BYTE *a1, unsigned __int8 *a2, int a3, int16x8_t a4)
{
  unsigned int v4;
  NSObject *v5;
  NSObject *v7;
  NSObject *v8;
  unsigned int v9;
  uint64_t v10;
  unsigned int v11;
  unsigned __int8 v12;
  unsigned int v13;
  uint64_t v14;
  unsigned __int8 *v15;
  NSObject *v16;
  NSObject *v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  NSObject *v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  NSObject *v25;
  NSObject *v26;
  unsigned int v27;
  unsigned __int8 v28;
  uint64_t v29;
  uint64_t v30;
  NSObject *v31;
  uint64_t v32;

  v32 = 0;
  v4 = *a2;
  if ((v4 & 1) != 0)
  {
    if (a1[12])
    {
      if ((v4 & 2) != 0)
      {
        if (sub_10005549C())
        {
          sub_100054530("%! (%d)", 917, 0);
          v7 = sub_1000544A0(0x32u);
          if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
            goto LABEL_35;
        }
        return;
      }
    }
    else if ((v4 & 2) == 0)
    {
      if (sub_10005549C())
      {
        sub_100054530("%! (%d)", 917, 0);
        v8 = sub_1000544A0(0x32u);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
          goto LABEL_35;
      }
      return;
    }
    v9 = a2[2];
    if ((v9 & 1) != 0)
    {
      v10 = v9 >> 1;
      v11 = 3;
    }
    else
    {
      v10 = (unsigned __int16)(v9 | (a2[3] << 8)) >> 1;
      v11 = 4;
    }
    v12 = a2[1];
    if ((v12 & 0x10) != 0)
    {
      if (!a1[44])
      {
        if (sub_10005549C())
        {
          sub_100054530("%! (%d)", 917, 0);
          v17 = sub_1000544A0(0x32u);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
            goto LABEL_35;
        }
        return;
      }
      v13 = a2[v11++];
    }
    else
    {
      v13 = 0;
    }
    if ((_DWORD)v10 + v11 + 1 != a3)
    {
      if (sub_10005549C())
      {
        sub_100054530("%! (%d)", 917, 0);
        v16 = sub_1000544A0(0x32u);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          goto LABEL_35;
      }
      return;
    }
    if (*a1 != 7)
      return;
    v14 = v4 >> 2;
    if (v4 > 0xF7 || (_DWORD)v14 == 1)
    {
      if (sub_10005549C())
      {
        sub_100054530("%! (%d)", 917, v14);
        v18 = sub_1000544A0(0x32u);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          goto LABEL_35;
      }
      return;
    }
    v15 = &a2[v11];
    if (v4 <= 3)
    {
      sub_100242A44((uint64_t)a1, (char *)&a2[v11], v10, a4);
      return;
    }
    v19 = sub_10023D2C0((uint64_t)a1, v4 >> 2, &v32);
    if ((_DWORD)v19)
    {
      v20 = v19;
      if (!sub_10005549C())
        return;
      sub_100054530("%! (%d)", v20, v14);
      v21 = sub_1000544A0(0x32u);
      if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        return;
      goto LABEL_39;
    }
    if (a1[44])
    {
      if ((v12 & 0x10) != 0 && v13)
      {
        v22 = v32;
        v23 = *(unsigned __int16 *)(v32 + 18);
        if ((v23 ^ 0xFFFFu) <= v13)
        {
          if (sub_10005549C())
          {
            sub_100054530("%! (%d)", 922, v14);
            v25 = sub_1000544A0(0x32u);
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
              sub_1006CE7A4();
          }
          sub_10023EEBC(*(unsigned __int16 *)(v32 + 8), 922);
          return;
        }
        *(_WORD *)(v32 + 18) = v23 + v13;
        if (!v23)
          sub_1002409D8(v22);
      }
      v24 = v32;
      if (!(_DWORD)v10)
      {
        if (*(_BYTE *)(v32 + 33) || !a1[44])
          return;
        goto LABEL_66;
      }
      if (*(_BYTE *)(v32 + 14))
      {
        --*(_BYTE *)(v32 + 14);
      }
      else if (sub_10005549C())
      {
        sub_100054530("Received data when remote credits = 0!");
        v26 = sub_1000544A0(0x32u);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
    }
    v24 = v32;
    if (*(_BYTE *)(v32 + 33))
    {
      if (!(_DWORD)v10)
        return;
      if (a1[44])
      {
        v27 = *(unsigned __int8 *)(v32 + 14);
        if (v27 <= *(unsigned __int8 *)(qword_100999110 + 2))
        {
          if (*(_BYTE *)(v32 + 162))
            v28 = *(_BYTE *)(v32 + 162) - (v27 + *(_BYTE *)(v32 + 163));
          else
            v28 = ~(_BYTE)v27;
          if (sub_100240964(v32, v28))
            return;
          v24 = v32;
        }
      }
LABEL_75:
      (*(void (**)(_QWORD, unsigned __int8 *, uint64_t))(*(_QWORD *)(v24 + 40) + 8))(*(unsigned __int16 *)(v24 + 8), v15, v10);
      return;
    }
    if (!a1[44])
    {
      if (!(_DWORD)v10)
        return;
      goto LABEL_75;
    }
LABEL_66:
    v29 = sub_100240824(v24, v15, v10);
    if (!(_DWORD)v29)
      return;
    v30 = v29;
    if (!sub_10005549C())
      return;
    sub_100054530("Save received packet failed in Receive_UIH %! (%d)", v30, v14);
    v31 = sub_1000544A0(0x32u);
    if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      return;
LABEL_39:
    sub_1006CE7A4();
    return;
  }
  if (sub_10005549C())
  {
    sub_100054530("%! (%d)", 917, 0);
    v5 = sub_1000544A0(0x32u);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
LABEL_35:
      sub_1006CE7A4();
  }
}

uint64_t sub_100242234(char *a1, int a2)
{
  char v2;
  char v3;

  if ((_BYTE)a2)
  {
    v2 = -1;
    do
    {
      v3 = *a1++;
      --a2;
      v2 = byte_10073B82A[(v3 ^ v2)];
    }
    while ((_BYTE)a2);
    return ~v2;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_100242278(char a1, char a2, char a3, int a4)
{
  if ((byte_10073B82A[(byte_10073B82A[(byte_10073B82A[~a1] ^ a2)] ^ a3)] ^ a4) == 0xFF)
    return 0;
  else
    return 255;
}

uint64_t sub_1002422B8(char a1, char a2, int a3)
{
  if ((byte_10073B82A[(byte_10073B82A[~a1] ^ a2)] ^ a3) == 0xFF)
    return 0;
  else
    return 255;
}

uint64_t sub_1002422EC(uint64_t a1)
{
  int *v1;
  const void *v3[2];
  uint64_t v4;

  v4 = a1;
  v3[0] = 0;
  v1 = (int *)(a1 + 32);
  sub_100049F6C(*(unsigned int *)(a1 + 32));
  v3[1] = &v4;
  LOWORD(v3[0]) = 8;
  return sub_10004A9EC((uint64_t)sub_100242354, v3, *(unsigned __int16 *)(qword_100999110 + 4), v1);
}

uint64_t sub_100242354(uint64_t a1)
{
  NSObject *v2;

  if (sub_10005549C())
  {
    sub_100054530("Timeout occurred");
    v2 = sub_1000544A0(0x32u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1006CEF28(v2);
  }
  return sub_10023D690(**(_QWORD **)(a1 + 8), 1, 931);
}

uint64_t sub_1002423C4(uint64_t a1)
{
  const void *v3[2];
  uint64_t v4;

  v4 = a1;
  if (!a1)
    sub_100253460();
  v3[0] = 0;
  sub_100049F6C(*(unsigned int *)(a1 + 36));
  v3[1] = &v4;
  LOWORD(v3[0]) = 8;
  return sub_10004A9EC((uint64_t)sub_100242354, v3, *(unsigned __int16 *)(qword_100999110 + 8), (int *)(a1 + 36));
}

void sub_100242434(uint64_t a1)
{
  if (!a1)
    sub_100253460();
  sub_100049F6C(*(unsigned int *)(a1 + 32));
}

void sub_10024245C(uint64_t a1)
{
  if (!a1)
    sub_100253460();
  sub_100049F6C(*(unsigned int *)(a1 + 36));
}

uint64_t sub_100242484(uint64_t a1)
{
  if (!a1)
    sub_100253460();
  return sub_1002539B8(*(_DWORD *)(a1 + 36));
}

uint64_t sub_1002424AC(uint64_t a1, int a2, unsigned int a3, unsigned __int8 a4, __int16 a5, char a6)
{
  char v12;
  char v13;
  char v14;
  char v15;
  uint64_t v16;
  uint64_t v18;
  _WORD v19[5];

  if (!a1)
    sub_100253460();
  if (a2)
    v12 = -125;
  else
    v12 = -127;
  LOBYTE(v19[0]) = v12;
  HIBYTE(v19[0]) = 17;
  if (a3 >= 0x40)
    sub_100253460();
  memset((char *)&v19[1] + 1, 0, 7);
  LOBYTE(v19[1]) = a3;
  if (a2)
    v13 = -16;
  else
    v13 = -32;
  if (*(_BYTE *)(a1 + 44))
    v14 = v13;
  else
    v14 = 0;
  if (*(_BYTE *)(a1 + 44))
    v15 = a6;
  else
    v15 = 0;
  HIBYTE(v19[1]) = v14;
  v19[2] = a4;
  v19[3] = a5;
  LOBYTE(v19[4]) = 0;
  HIBYTE(v19[4]) = v15;
  if (a2)
    sub_1002423C4(a1);
  v18 = 0;
  v16 = sub_1002410F4(a1, 0, (char *)v19, 0xAuLL, 0);
  if (!(_DWORD)v16)
  {
    v16 = sub_10023D2C0(a1, a3, &v18);
    if ((_DWORD)v16)
      sub_100253460();
    if (!*(_BYTE *)(v18 + 13))
      *(_BYTE *)(v18 + 13) = 1;
  }
  return v16;
}

uint64_t sub_100242610(uint64_t a1, int a2, uint64_t a3, unsigned int a4)
{
  char v8;
  NSObject *v10;
  char v11[2];
  _BYTE v12[254];

  if (!a1)
    sub_100253460();
  memset(v12, 0, sizeof(v12));
  if ((a4 & 0x80) != 0)
  {
    if (sub_10005549C())
    {
      sub_100054530("OI_RfcommMux_TEST invalid size=%d", a4);
      v10 = sub_1000544A0(0x32u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 114;
  }
  else
  {
    if (a2)
      v8 = 35;
    else
      v8 = 33;
    v11[0] = v8;
    v11[1] = (2 * a4) | 1;
    __memmove_chk(v12, a3, a4, 254);
    if (a2)
      sub_1002423C4(a1);
    return sub_1002410F4(a1, 0, v11, a4 + 2, 0);
  }
}

uint64_t sub_10024275C(uint64_t a1, int a2)
{
  char v4;
  char v6[2];

  if (!a1)
    sub_100253460();
  if (a2)
    v4 = -93;
  else
    v4 = -95;
  v6[0] = v4;
  v6[1] = 1;
  if (a2)
    sub_1002423C4(a1);
  return sub_1002410F4(a1, 0, v6, 2uLL, 0);
}

uint64_t sub_1002427CC(uint64_t a1, int a2)
{
  char v4;
  char v6[2];

  if (!a1)
    sub_100253460();
  if (a2)
    v4 = 99;
  else
    v4 = 97;
  v6[0] = v4;
  v6[1] = 1;
  if (a2)
    sub_1002423C4(a1);
  return sub_1002410F4(a1, 0, v6, 2uLL, 0);
}

uint64_t sub_10024283C(uint64_t a1, int a2, char a3, char a4, int a5)
{
  char v6;
  size_t v7;
  char v8;
  char v10[4];
  char v11;

  v11 = 0;
  if (a2)
    v6 = -29;
  else
    v6 = -31;
  v10[0] = v6;
  if (a5)
  {
    v11 = (16 * a5) | 3;
    v7 = 5;
    v8 = 7;
  }
  else
  {
    a4 |= 1u;
    v7 = 4;
    v8 = 5;
  }
  v10[1] = v8;
  v10[3] = a4;
  v10[2] = (4 * a3) | 3;
  if (a2)
    sub_1002423C4(a1);
  return sub_1002410F4(a1, 0, v10, v7, 0);
}

uint64_t sub_1002428D8(uint64_t a1, int a2, char a3, uint64_t a4)
{
  char v5;
  int v7;
  unsigned int v8;
  int v9;
  int v10;
  _WORD v11[5];

  memset((char *)&v11[1] + 1, 0, 7);
  if (a2)
    v5 = -109;
  else
    v5 = -111;
  LOBYTE(v11[0]) = v5;
  LOBYTE(v11[1]) = (4 * a3) | 3;
  if (a4)
  {
    if (*(unsigned __int8 *)(a4 + 2) > 8u)
      return 903;
    HIBYTE(v11[1]) = *(_BYTE *)(a4 + 2);
    v8 = *(unsigned __int8 *)(a4 + 3);
    if (v8 > 3)
      return 904;
    v9 = *(unsigned __int8 *)(a4 + 4);
    if ((v9 | 4) != 4)
      return 905;
    v10 = *(unsigned __int8 *)(a4 + 5);
    if ((v10 | 8) != 8)
      return 906;
    if (((*(_BYTE *)(a4 + 6) >> 4) | (16 * *(_BYTE *)(a4 + 6))) > 3u)
      return 907;
    LOBYTE(v11[2]) = *(_BYTE *)(a4 + 6) | v10 | v9 | v8;
    if (*(unsigned __int8 *)(a4 + 7) > 0x20u)
      return 908;
    HIBYTE(v11[2]) = *(_BYTE *)(a4 + 7);
    v11[3] = *(_WORD *)(a4 + 8);
    v11[4] = *(_WORD *)a4;
    v7 = 8;
  }
  else
  {
    v7 = 1;
  }
  HIBYTE(v11[0]) = (2 * v7) | 1;
  if (a2)
    sub_1002423C4(a1);
  return sub_1002410F4(a1, 0, (char *)v11, v7 | 2u, 0);
}

void sub_100242A44(uint64_t a1, char *a2, int a3, int16x8_t a4)
{
  char v5;
  int v6;
  uint64_t v7;
  unint64_t v8;
  NSObject *v10;
  void (*v11)(uint64_t, char *, uint64_t);
  unsigned int v12;
  uint64_t v13;
  char v14;
  unsigned int v15;
  char v16;
  unsigned __int16 v17;
  __int16 v18;
  uint64_t v19;
  uint64_t v20;
  NSObject *v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  NSObject *v25;
  uint64_t v26;
  uint64_t v27;
  NSObject *v28;
  char v29;
  uint64_t v30;
  NSObject *v31;
  NSObject *v32;
  NSObject *v33;
  NSObject *v34;
  uint64_t v35;
  uint64_t v36;
  NSObject *v37;
  NSObject *v38;
  NSObject *v39;
  NSObject *v40;
  uint64_t v41;
  unsigned int v42;
  unsigned int v43;
  unsigned __int8 v44;
  NSObject *v45;
  uint64_t v46;
  uint64_t v47;
  NSObject *v48;
  NSObject *v49;
  char v50;
  uint64_t v51;
  uint64_t v52;
  NSObject *v53;
  uint64_t v54;
  int v55;
  NSObject *v56;
  uint64_t v57;
  void (*v58)(_QWORD, _QWORD, uint64_t);
  uint64_t v59;
  uint64_t v60;
  NSObject *v61;
  uint64_t v62;
  __int16 v63;
  uint64_t v64;
  unsigned int v65;
  unsigned __int8 v66;
  char v67;
  NSObject *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  NSObject *v72;
  void (*v73)(_QWORD, uint64_t *);
  __int16 v74;
  uint64_t v75;
  uint64_t v76;
  NSObject *v77;
  void (*v78)(_QWORD, _QWORD);
  uint64_t v79;
  uint64_t v80;
  NSObject *v81;
  void (*v82)(_QWORD, _QWORD, uint64_t);
  void (*v83)(_QWORD, _QWORD, _QWORD);
  uint64_t v84;
  uint64_t v85;
  NSObject *v86;
  uint64_t v87;
  uint64_t v88;
  NSObject *v89;
  uint64_t v90;
  __int16 v91;
  uint64_t v92;
  uint64_t v93;
  __int16 v94;

  v5 = *a2;
  v6 = *a2 & 0xFC;
  v7 = a2[1] >> 1;
  if ((_DWORD)v7 + 2 != a3)
  {
    if (sub_10005549C())
    {
      sub_100054530("Invalid RFCOMM packet received, command (%d), force disconnect the link", v5 & 0xFC);
      v10 = sub_1000544A0(0x32u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    sub_10018070C(a1 + 6);
    return;
  }
  HIDWORD(v8) = *a2 & 0xFC;
  LODWORD(v8) = v6 - 16;
  switch((v8 >> 4))
  {
    case 0u:
      if ((_DWORD)v7 == 1)
      {
        sub_100242484(a1);
      }
      else if (sub_10005549C())
      {
        sub_100054530("%! (%d)", 917, 0);
        v31 = sub_1000544A0(0x32u);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
          goto LABEL_107;
      }
      return;
    case 1u:
      if (v6 != 32)
      {
        sub_100253460();
        v5 = *a2;
      }
      if ((v5 & 2) != 0)
      {
        sub_100242610(a1, 0, (uint64_t)(a2 + 2), v7);
      }
      else
      {
        sub_10024245C(a1);
        v11 = *(void (**)(uint64_t, char *, uint64_t))(a1 + 48);
        if (v11)
        {
          v11(a1 + 6, a2 + 2, v7);
          *(_QWORD *)(a1 + 48) = 0;
        }
        else if (sub_10005549C())
        {
          sub_100054530("Mux_ReceiveTEST, receive response but no outstanding command, ignoring");
          v45 = sub_1000544A0(0x32u);
          if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
            goto LABEL_107;
        }
      }
      return;
    case 4u:
      v93 = 0;
      if ((_DWORD)v7 == 2)
      {
        v12 = a2[2];
        v13 = v12 >> 2;
        if (v12 > 0xF7 || (_DWORD)v13 == 1)
        {
          if (sub_10005549C())
          {
            sub_100054530("%! (%d)", 917, v12 >> 2);
            v39 = sub_1000544A0(0x32u);
            if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
              goto LABEL_107;
          }
        }
        else if ((v5 & 2) != 0)
        {
          v50 = a2[3];
          v51 = sub_10023D2C0(a1, v12 >> 2, &v93);
          if ((_DWORD)v51)
          {
            v52 = v51;
            if (!sub_10005549C())
              goto LABEL_79;
            sub_100054530("%! (%d)", v52, v12 >> 2);
            v53 = sub_1000544A0(0x32u);
            if (!os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
              goto LABEL_79;
            goto LABEL_111;
          }
          LOWORD(v90) = 1361;
          BYTE2(v90) = v12 | 3;
          BYTE3(v90) = v50;
          sub_1002410F4(a1, 0, (char *)&v90, 4uLL, 0);
          v78 = *(void (**)(_QWORD, _QWORD))(*(_QWORD *)(v93 + 40) + 16);
          if (v78)
            v78(*(unsigned __int16 *)(v93 + 8), v50 & 0xF);
        }
        else
        {
          sub_10024245C(a1);
        }
      }
      else if (sub_10005549C())
      {
        sub_100054530("%! (%d)", 917, 0);
        v32 = sub_1000544A0(0x32u);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
          goto LABEL_107;
      }
      return;
    case 5u:
      if (!a1)
      {
        sub_100253460();
        v5 = *a2;
      }
      if ((v5 & 2) == 0)
        goto LABEL_52;
      sub_1002427CC(a1, 0);
      if (!*(_BYTE *)(a1 + 44))
        *(_BYTE *)(a1 + 45) = 0;
      return;
    case 7u:
      if (!a1)
        sub_100253460();
      v93 = 0;
      if ((_DWORD)v7 == 8)
      {
        v13 = a2[2] & 0x3F;
        if ((_DWORD)v13 == 1 || v13 >= 0x3E)
        {
          if (sub_10005549C())
          {
            sub_100054530("%! (%d)", 917, v13);
            v40 = sub_1000544A0(0x32u);
            if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
              goto LABEL_107;
          }
        }
        else
        {
          v14 = *a2;
          v15 = a2[3];
          v16 = a2[4];
          v17 = *((_WORD *)a2 + 3);
          v18 = a2[9] & 7;
          v19 = sub_10023D2C0(a1, v13, &v93);
          if ((_DWORD)v19)
          {
            if ((v14 & 2) == 0)
            {
              v20 = v19;
              if (sub_10005549C())
              {
                sub_100054530("%! (%d)", v20, v13);
                v21 = sub_1000544A0(0x32u);
                if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
                  sub_1006CE7A4();
              }
              return;
            }
            v59 = sub_10023D354(a1, v13, &v93);
            if ((_DWORD)v59)
            {
              v60 = v59;
              if (sub_10005549C())
              {
                sub_100054530("%! (%d)", v60, v13);
                v61 = sub_1000544A0(0x32u);
                if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
LABEL_111:
                  sub_1006CE7A4();
              }
              goto LABEL_79;
            }
          }
          else if ((v14 & 2) == 0)
          {
            if (*(_BYTE *)(v93 + 13) != 1)
              return;
            sub_10024245C(a1);
            v55 = (v15 & 0xF0) == 224;
            *(_BYTE *)(a1 + 44) = v55;
            if (*(unsigned __int16 *)(v93 + 16) >= v17)
            {
              *(_WORD *)(v93 + 16) = v17;
            }
            else
            {
              if (sub_10005549C())
              {
                sub_100054530("%! (%d)", 917, v13);
                v56 = sub_1000544A0(0x32u);
                if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
                  sub_1006CE7A4();
              }
              if (sub_100240C20(67, a1, v13))
                return;
              v57 = v93;
              *(_DWORD *)(v93 + 164) = 918;
              v58 = *(void (**)(_QWORD, _QWORD, uint64_t))(v57 + 72);
              if (v58)
              {
                v58(0, 0, 918);
                v57 = v93;
              }
              sub_10023D5F8(v57, 1);
              v55 = *(unsigned __int8 *)(a1 + 44);
            }
            if (v55)
              *(_WORD *)(v93 + 18) = v18;
            if (!sub_100240C20(47, a1, v13))
            {
              v88 = v93;
              if (!v93)
              {
                sub_100253460();
                v88 = v93;
              }
              *(_BYTE *)(v88 + 13) = 2;
            }
            return;
          }
          v62 = v93;
          if (*(_BYTE *)(v93 + 13))
          {
            v63 = v17;
            v64 = a1;
            v65 = v13;
            v66 = v16 & 0x3F;
            v67 = 0;
          }
          else
          {
            if (*(unsigned __int16 *)(v93 + 16) >= v17)
              *(_WORD *)(v93 + 16) = v17;
            if (v15 >= 0xF0)
            {
              *(_BYTE *)(a1 + 44) = 1;
              *(_WORD *)(v62 + 18) = v18;
              v84 = sub_1002405E4(v62);
              if ((_DWORD)v84)
              {
                v85 = v84;
                if (sub_10005549C())
                {
                  sub_100054530("%! (%d)", v85, v13);
                  v86 = sub_1000544A0(0x32u);
                  if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR))
                    sub_1006CE7A4();
                }
                v87 = v93;
                if (!v93)
                {
                  sub_100253460();
                  v87 = v93;
                }
                *(_BYTE *)(v87 + 13) = 9;
                goto LABEL_79;
              }
              v62 = v93;
              v67 = *(_BYTE *)(v93 + 14);
            }
            else
            {
              v67 = 0;
              *(_BYTE *)(a1 + 44) = 0;
              *(_BYTE *)(v62 + 14) = 0;
            }
            v63 = *(_WORD *)(v62 + 16);
            v64 = a1;
            v65 = v13;
            v66 = v16 & 0x3F;
          }
          sub_1002424AC(v64, 0, v65, v66, v63, v67);
        }
      }
      else if (sub_10005549C())
      {
        sub_100054530("Mux_ReceivePN invalid cmdLen=%d, shall be=%d", v7, 8);
        v33 = sub_1000544A0(0x32u);
        if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
          goto LABEL_107;
      }
      return;
    case 8u:
      v94 = 0;
      v92 = 0;
      v93 = 0;
      v22 = a2[2];
      v13 = v22 >> 2;
      if (v22 > 0xF7 || (_DWORD)v13 == 1)
      {
        if (sub_10005549C())
        {
          sub_100054530("%! (%d)", 917, v13);
          v34 = sub_1000544A0(0x32u);
          if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
            goto LABEL_107;
        }
        return;
      }
      if ((_DWORD)v7 == 8)
      {
        BYTE2(v93) = a2[3];
        *(int8x8_t *)a4.i8 = vand_s8((int8x8_t)vdup_n_s16(a2[4]), (int8x8_t)0x30000800040003);
        *(_DWORD *)((char *)&v93 + 3) = vmovn_s16(a4).u32[0];
        HIBYTE(v93) = a2[5] & 0x3F;
        v94 = *((_WORD *)a2 + 3);
        LOWORD(v93) = *((_WORD *)a2 + 4);
        v46 = sub_10023D2C0(a1, v13, &v92);
        if ((_DWORD)v46)
        {
          if ((v5 & 2) == 0)
          {
            v47 = v46;
            if (!sub_10005549C())
              return;
            sub_100054530("%! (%d)", v47, v13);
            v48 = sub_1000544A0(0x32u);
            if (!os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
              return;
            goto LABEL_209;
          }
          v70 = sub_10023D354(a1, v13, &v92);
          if ((_DWORD)v70)
          {
            v71 = v70;
            if (sub_10005549C())
            {
              sub_100054530("%! (%d)", v71, v13);
              v72 = sub_1000544A0(0x32u);
              if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
                sub_1006CE7A4();
            }
            goto LABEL_79;
          }
        }
        else if ((v5 & 2) == 0)
        {
          if (*(_QWORD *)(v92 + 64))
          {
            sub_10024245C(a1);
            v69 = v92;
            *(_QWORD *)(v92 + 22) = v93;
            *(_WORD *)(v69 + 30) = v94;
            (*(void (**)(_QWORD, uint64_t *))(v69 + 64))(*(unsigned __int16 *)(v69 + 8), &v93);
            return;
          }
          if (sub_10005549C())
          {
            sub_100054530("Mux_ReceiveRPN, unsolicited response, ignoring");
            v89 = sub_1000544A0(0x32u);
            if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR))
              goto LABEL_209;
          }
          return;
        }
        v73 = *(void (**)(_QWORD, uint64_t *))(*(_QWORD *)(v92 + 40) + 32);
        if (v73)
          v73(*(unsigned __int16 *)(v92 + 8), &v93);
        v74 = v93;
        if ((v93 & 1) != 0)
        {
          *(_BYTE *)(v92 + 24) = BYTE2(v93);
          if ((v74 & 2) == 0)
          {
LABEL_146:
            if ((v74 & 4) == 0)
              goto LABEL_147;
            goto LABEL_174;
          }
        }
        else if ((v93 & 2) == 0)
        {
          goto LABEL_146;
        }
        *(_BYTE *)(v92 + 25) = BYTE3(v93);
        if ((v74 & 4) == 0)
        {
LABEL_147:
          if ((v74 & 8) == 0)
            goto LABEL_148;
          goto LABEL_175;
        }
LABEL_174:
        *(_BYTE *)(v92 + 26) = BYTE4(v93);
        if ((v74 & 8) == 0)
        {
LABEL_148:
          if ((v74 & 0x10) == 0)
            goto LABEL_149;
          goto LABEL_176;
        }
LABEL_175:
        *(_BYTE *)(v92 + 27) = BYTE5(v93);
        if ((v74 & 0x10) == 0)
        {
LABEL_149:
          if ((v74 & 0x20) == 0)
            goto LABEL_150;
          goto LABEL_177;
        }
LABEL_176:
        *(_BYTE *)(v92 + 28) = BYTE6(v93);
        if ((v74 & 0x20) == 0)
        {
LABEL_150:
          if ((v74 & 0x40) == 0)
            goto LABEL_151;
          goto LABEL_178;
        }
LABEL_177:
        *(_BYTE *)(v92 + 30) = v94;
        if ((v74 & 0x40) == 0)
        {
LABEL_151:
          if ((v74 & 0x100) == 0)
            goto LABEL_152;
          goto LABEL_179;
        }
LABEL_178:
        *(_BYTE *)(v92 + 31) = HIBYTE(v94);
        if ((v74 & 0x100) == 0)
        {
LABEL_152:
          if ((v74 & 0x200) == 0)
            goto LABEL_153;
          goto LABEL_180;
        }
LABEL_179:
        *(_BYTE *)(v92 + 29) = *(_BYTE *)(v92 + 29) & 0xFE | HIBYTE(v93) & 1;
        if ((v74 & 0x200) == 0)
        {
LABEL_153:
          if ((v74 & 0x400) == 0)
            goto LABEL_154;
          goto LABEL_181;
        }
LABEL_180:
        *(_BYTE *)(v92 + 29) = *(_BYTE *)(v92 + 29) & 0xFD | HIBYTE(v93) & 2;
        if ((v74 & 0x400) == 0)
        {
LABEL_154:
          if ((v74 & 0x800) == 0)
            goto LABEL_155;
          goto LABEL_182;
        }
LABEL_181:
        *(_BYTE *)(v92 + 29) = *(_BYTE *)(v92 + 29) & 0xFB | HIBYTE(v93) & 4;
        if ((v74 & 0x800) == 0)
        {
LABEL_155:
          if ((v74 & 0x1000) == 0)
            goto LABEL_156;
          goto LABEL_183;
        }
LABEL_182:
        *(_BYTE *)(v92 + 29) = *(_BYTE *)(v92 + 29) & 0xF7 | HIBYTE(v93) & 8;
        if ((v74 & 0x1000) == 0)
        {
LABEL_156:
          if ((v74 & 0x2000) == 0)
          {
LABEL_158:
            v75 = sub_1002428D8(a1, 0, v13, (uint64_t)&v93);
            if (!(_DWORD)v75)
              return;
            v76 = v75;
            if (!sub_10005549C())
              return;
            sub_100054530("%! (%d)", v76, 0);
            v77 = sub_1000544A0(0x32u);
            if (!os_log_type_enabled(v77, OS_LOG_TYPE_ERROR))
              return;
            goto LABEL_209;
          }
LABEL_157:
          *(_BYTE *)(v92 + 29) = *(_BYTE *)(v92 + 29) & 0xDF | HIBYTE(v93) & 0x20;
          goto LABEL_158;
        }
LABEL_183:
        *(_BYTE *)(v92 + 29) = *(_BYTE *)(v92 + 29) & 0xEF | HIBYTE(v93) & 0x10;
        if ((v74 & 0x2000) == 0)
          goto LABEL_158;
        goto LABEL_157;
      }
      if ((_DWORD)v7 == 1)
      {
        v23 = sub_10023D2C0(a1, v22 >> 2, &v92);
        if ((_DWORD)v23)
        {
          v24 = v23;
          if (sub_10005549C())
          {
            sub_100054530("Receive RPN with result %! on DLCI %d", v24, v13);
            v25 = sub_1000544A0(0x32u);
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
              sub_1006CE7A4();
          }
          v90 = 50806655;
          v91 = 4881;
          if ((v5 & 2) != 0)
          {
            v26 = sub_1002428D8(a1, 0, v13, (uint64_t)&v90);
            if ((_DWORD)v26)
            {
              v27 = v26;
              if (sub_10005549C())
              {
                sub_100054530("%! (%d)", v27, v13);
                v28 = sub_1000544A0(0x32u);
                if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
                  sub_1006CE7A4();
              }
            }
          }
          return;
        }
        if ((v5 & 2) != 0)
        {
          v79 = sub_1002428D8(a1, 0, v13, v92 + 22);
          if (!(_DWORD)v79)
            return;
          v80 = v79;
          if (!sub_10005549C())
            return;
          sub_100054530("%! (%d)", v80, v13);
          v81 = sub_1000544A0(0x32u);
          if (!os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
            return;
        }
        else
        {
          if (!sub_10005549C())
            return;
          sub_100054530("Mux_ReceiveRPN, command is parameter report but C/R bit is not set, ignoring");
          v68 = sub_1000544A0(0x32u);
          if (!os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
            return;
        }
LABEL_209:
        sub_1006CE7A4();
        return;
      }
      if (sub_10005549C())
      {
        sub_100054530("%! (%d)", 917, v13);
        v49 = sub_1000544A0(0x32u);
        if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
          goto LABEL_107;
      }
      return;
    case 9u:
      if (!a1)
      {
        sub_100253460();
        v5 = *a2;
      }
      if ((v5 & 2) != 0)
      {
        sub_10024275C(a1, 0);
        if (!*(_BYTE *)(a1 + 44))
        {
          *(_BYTE *)(a1 + 45) = 1;
          sub_100240A30(a1);
        }
      }
      else
      {
LABEL_52:
        sub_10024245C(a1);
      }
      return;
    case 0xDu:
      if (!a1)
        sub_100253460();
      v93 = 0;
      v13 = a2[2] >> 2;
      v29 = a2[3];
      if ((_DWORD)v7 == 2)
      {
        v30 = 0;
      }
      else
      {
        if ((_DWORD)v7 != 3)
        {
          if (sub_10005549C())
          {
            sub_100054530("%! (%d)", 917, v13);
            v38 = sub_1000544A0(0x32u);
            if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
LABEL_107:
              sub_1006CE7A4();
          }
          return;
        }
        v30 = ((char)(a2[4] << 6) >> 7) & (a2[4] >> 4);
      }
      v35 = sub_10023D2C0(a1, v13, &v93);
      if ((_DWORD)v35)
      {
        v36 = v35;
        if (sub_10005549C())
        {
          sub_100054530("%! (%d)", v36, v13);
          v37 = sub_1000544A0(0x32u);
          if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
        if ((*a2 & 2) != 0)
LABEL_79:
          sub_100240C20(15, a1, v13);
        return;
      }
      if ((*a2 & 2) != 0)
      {
        sub_10024283C(a1, 0, v13, v29, v30);
        v54 = v93;
        if (!*(_BYTE *)(a1 + 44))
        {
          if ((v29 & 2) != 0)
          {
            *(_BYTE *)(v93 + 32) = 0;
          }
          else
          {
            *(_BYTE *)(v93 + 32) = 1;
            sub_1002409D8(v54);
            v54 = v93;
          }
        }
        v82 = *(void (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)(v54 + 40) + 24);
        if (v82)
          v82(*(unsigned __int16 *)(v54 + 8), v29 & 0xCE, v30);
        return;
      }
      sub_10024245C(a1);
      v41 = v93;
      if (*(_BYTE *)(v93 + 13) != 4)
        return;
      *(_BYTE *)(v93 + 13) = 5;
      if (!*(_BYTE *)(a1 + 44))
        goto LABEL_191;
      v42 = *(unsigned __int8 *)(v41 + 162);
      if (*(_BYTE *)(v41 + 162))
      {
        v43 = *(unsigned __int8 *)(v41 + 14);
        if (v42 < v43)
        {
          sub_100253460();
          v41 = v93;
          LOBYTE(v42) = *(_BYTE *)(v93 + 162);
          LOBYTE(v43) = *(_BYTE *)(v93 + 14);
        }
        v44 = v42 - v43 - *(_BYTE *)(v41 + 163);
        if (!v44)
        {
LABEL_191:
          v83 = *(void (**)(_QWORD, _QWORD, _QWORD))(v41 + 72);
          if (v83)
          {
            v83(*(unsigned __int16 *)(v41 + 8), *(unsigned __int16 *)(v41 + 16), 0);
            *(_QWORD *)(v93 + 72) = 0;
          }
          return;
        }
      }
      else
      {
        v44 = -1;
      }
      if (sub_100240964(v41, v44))
        return;
      v41 = v93;
      goto LABEL_191;
    default:
      LOWORD(v93) = 785;
      BYTE2(v93) = v5 & 0xFE;
      sub_1002410F4(a1, 0, (char *)&v93, 3uLL, 0);
      return;
  }
}

uint64_t sub_100243990(int a1, char a2, unsigned int a3, __int16 a4, int a5)
{
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t result;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;

  v9 = sub_10023D7D4(a1);
  if (!v9)
    return 114;
  v19 = 0;
  v10 = 2 * (a2 & 0x7Fu);
  if (v10 >= 0x3E)
  {
    if (sub_10005549C())
    {
      sub_100054530("%! (%d)", 917, v10);
      v11 = sub_1000544A0(0x32u);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 114;
  }
  v12 = v9;
  if (sub_10023D2C0(v9, v10, &v19))
  {
    if (!sub_10005549C())
      return 114;
    sub_100054530("Could not find link for DLCI (%d)", v10);
    v13 = sub_1000544A0(0x32u);
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      return 114;
    goto LABEL_9;
  }
  v14 = v19;
  if (*(_BYTE *)(v19 + 13))
    return 114;
  if (*(unsigned __int16 *)(v19 + 16) >= a3)
    *(_WORD *)(v19 + 16) = a3;
  if (a5)
  {
    *(_BYTE *)(v12 + 44) = 1;
    *(_WORD *)(v14 + 18) = a4;
    v16 = sub_1002405E4(v14);
    if ((_DWORD)v16)
    {
      v17 = v16;
      if (!sub_10005549C())
        return 114;
      sub_100054530("%! (%d)", v17, v10);
      v18 = sub_1000544A0(0x32u);
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        return 114;
LABEL_9:
      sub_1006CE7A4();
      return 114;
    }
    v14 = v19;
  }
  else
  {
    LOBYTE(a4) = 0;
    *(_BYTE *)(v12 + 44) = 0;
  }
  result = 0;
  *(_BYTE *)(v14 + 14) = a4;
  *(_BYTE *)(v14 + 13) = 5;
  return result;
}

uint64_t sub_100243B30(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6;
  _QWORD *v8;
  uint64_t v9;

  if (!a1 || !a3)
  {
    sub_100253460();
    return 101;
  }
  if (!*(_DWORD *)(a1 + 8) && !*(_QWORD *)(a1 + 16))
  {
    sub_100253460();
    if (!*(_DWORD *)(a1 + 8) && !*(_QWORD *)(a1 + 16))
      return 101;
  }
  if (dword_100999214)
    return 924;
  v8 = sub_100052DC0(0x18uLL);
  qword_10098FD98 = (uint64_t)v8;
  if (!v8)
    return 106;
  v8[1] = a1;
  v8[2] = a3;
  *(_DWORD *)(a1 + 172) = 0;
  *(_BYTE *)(a1 + 24) = 0;
  *(_BYTE *)(v8[1] + 64) = 0;
  v9 = v8[1];
  *(_DWORD *)(v9 + 166) = 0;
  *(_DWORD *)v8 = a2;
  *((_BYTE *)v8 + 4) = 0;
  v6 = sub_1002443D4((uint64_t)sub_100243C30, (uint64_t)sub_100243DD0, v9);
  if ((_DWORD)v6)
  {
    if (qword_10098FD98)
    {
      sub_100053298((void *)qword_10098FD98);
      qword_10098FD98 = 0;
    }
  }
  else
  {
    dword_100999214 = 1;
  }
  return v6;
}

uint64_t sub_100243C30(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  __int16 v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  _QWORD v8[2];
  _QWORD v9[2];
  __int128 v10;
  __int128 v11;

  if ((_DWORD)a1 == 834)
  {
    v4 = *(_QWORD *)(qword_10098FD98 + 8);
    v1 = 834;
    return sub_1002442F8(v4, v1);
  }
  v1 = a1;
  if ((_DWORD)a1)
  {
    v5 = qword_10098FD98;
    if ((*(_DWORD *)qword_10098FD98)--)
    {
      result = sub_1002443D4((uint64_t)sub_100243C30, (uint64_t)sub_100243DD0, *(_QWORD *)(v5 + 8));
      if (!(_DWORD)result)
        return result;
      v1 = result;
      v5 = qword_10098FD98;
    }
    v4 = *(_QWORD *)(v5 + 8);
    return sub_1002442F8(v4, v1);
  }
  v10 = 0u;
  v11 = 0u;
  v9[0] = 0;
  v8[0] = 0;
  LOBYTE(v10) = 3;
  WORD1(v10) = 2;
  DWORD2(v10) = 3;
  v2 = *(_QWORD *)(qword_10098FD98 + 8);
  if (*(_DWORD *)(v2 + 8))
  {
    DWORD2(v11) = *(_DWORD *)(v2 + 8);
    v3 = 4;
  }
  else
  {
    *((_QWORD *)&v11 + 1) = *(_QWORD *)(v2 + 16);
    v3 = 16;
  }
  LOBYTE(v11) = 3;
  WORD1(v11) = v3;
  LOBYTE(v9[0]) = 6;
  WORD1(v9[0]) = 2;
  v9[1] = &v10;
  LOBYTE(v8[0]) = 6;
  WORD1(v8[0]) = 6;
  v8[1] = &unk_10073B948;
  result = sub_100245200((uint64_t)sub_100243E0C, (unsigned __int8 *)v9, (unsigned __int8 *)v8);
  if ((_DWORD)result)
  {
    *(_DWORD *)(*(_QWORD *)(qword_10098FD98 + 8) + 172) = result;
    return sub_1002442C8();
  }
  return result;
}

uint64_t sub_100243DD0()
{
  uint64_t v0;
  uint64_t v1;

  v0 = *(_QWORD *)(qword_10098FD98 + 8);
  v1 = *(unsigned int *)(v0 + 172);
  if (!(_DWORD)v1)
  {
    if (*(_BYTE *)(v0 + 164) && *(_BYTE *)(qword_10098FD98 + 4))
    {
      v1 = 0;
    }
    else
    {
      v1 = 923;
      *(_DWORD *)(v0 + 172) = 923;
    }
  }
  return sub_1002442F8(v0, v1);
}

uint64_t sub_100243E0C(uint64_t a1, int a2, int a3)
{
  uint64_t result;
  unint64_t v4;
  uint64_t v5;
  unsigned __int16 *v6;
  unsigned int v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  void *v15;
  int v16;
  size_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  size_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  NSObject *v34;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint8_t buf[24];

  if (a3)
  {
    *(_DWORD *)(*(_QWORD *)(qword_10098FD98 + 8) + 172) = a3;
    return sub_1002442C8();
  }
  if (*(_WORD *)(a1 + 2))
  {
    v4 = 0;
    v36 = a1;
    while (1)
    {
      v5 = *(_QWORD *)(a1 + 8) + 16 * v4;
      v7 = *(unsigned __int16 *)(v5 + 2);
      v6 = (unsigned __int16 *)(v5 + 2);
      if (v7 >= 2)
      {
        v8 = 0;
        v9 = (_QWORD *)(*(_QWORD *)(a1 + 8) + 16 * v4 + 8);
        do
        {
          v10 = *v9 + 16 * v8;
          v37 = 0;
          v38 = 0;
          v11 = *(_DWORD *)(v10 + 8);
          if (v11 > 255)
          {
            switch(v11)
            {
              case 512:
                *(_WORD *)(*(_QWORD *)(qword_10098FD98 + 8) + 166) = *(_DWORD *)(v10 + 24);
                break;
              case 257:
                v26 = *(unsigned __int8 *)(v10 + 16);
                if (v26 == 8 || v26 == 4)
                {
                  if (*(unsigned __int16 *)(v10 + 18) >= 0x63u)
                    v28 = 99;
                  else
                    v28 = *(unsigned __int16 *)(v10 + 18);
                  memmove((void *)(*(_QWORD *)(qword_10098FD98 + 8) + 64), *(const void **)(v10 + 24), v28);
                  *(_BYTE *)(*(_QWORD *)(qword_10098FD98 + 8) + v28 + 64) = 0;
                }
                break;
              case 256:
                v16 = *(unsigned __int8 *)(v10 + 16);
                if (v16 == 8 || v16 == 4)
                {
                  if (*(unsigned __int16 *)(v10 + 18) >= 0x27u)
                    v18 = 39;
                  else
                    v18 = *(unsigned __int16 *)(v10 + 18);
                  memmove((void *)(*(_QWORD *)(qword_10098FD98 + 8) + 24), *(const void **)(v10 + 24), v18);
                  *(_BYTE *)(*(_QWORD *)(qword_10098FD98 + 8) + v18 + 24) = 0;
                }
                break;
            }
          }
          else if (v11 == 1)
          {
            if ((*(_BYTE *)(v10 + 16) & 0xFE) == 6)
            {
              v19 = *(_QWORD *)(qword_10098FD98 + 8);
              v20 = *(_DWORD *)(v19 + 8);
              LOBYTE(v37) = 3;
              if (v20)
              {
                WORD1(v37) = 4;
                LODWORD(v38) = v20;
              }
              else
              {
                WORD1(v37) = 16;
                v38 = *(_QWORD *)(v19 + 16);
              }
              if (*(_WORD *)(v10 + 18))
              {
                v29 = 0;
                v30 = 0;
                while (!sub_10017C904(*(_QWORD *)(v10 + 24) + v29, (uint64_t)&v37))
                {
                  ++v30;
                  v29 += 16;
                  if (v30 >= *(unsigned __int16 *)(v10 + 18))
                    goto LABEL_61;
                }
                *(_BYTE *)(qword_10098FD98 + 4) = 1;
              }
            }
          }
          else if (v11 == 4)
          {
            if ((*(_BYTE *)(v10 + 16) & 0xFE) == 6 && *(_WORD *)(v10 + 18))
            {
              v21 = 0;
              v22 = 0;
              do
              {
                v23 = *(_QWORD *)(v10 + 24);
                *(_OWORD *)buf = xmmword_10073B9B0;
                if ((*(_BYTE *)(v23 + v21) & 0xFE) == 6)
                {
                  v24 = v23 + v21;
                  if (*(_WORD *)(v23 + v21 + 2))
                  {
                    if (sub_10017C904(*(_QWORD *)(v24 + 8), (uint64_t)buf))
                    {
                      v25 = *(_QWORD *)(v24 + 8);
                      if (*(_BYTE *)(v25 + 16) == 1 && *(_WORD *)(v25 + 18) == 1)
                        *(_BYTE *)(*(_QWORD *)(qword_10098FD98 + 8) + 164) = *(_DWORD *)(v25 + 24);
                    }
                  }
                }
                ++v22;
                v21 += 16;
              }
              while (v22 < *(unsigned __int16 *)(v10 + 18));
            }
          }
          else if (v11 == 9 && (*(_BYTE *)(v10 + 16) & 0xFE) == 6)
          {
            v12 = *(_QWORD *)(v10 + 24);
            if ((*(_BYTE *)v12 & 0xFE) == 6)
            {
              v13 = *(_QWORD *)(v12 + 8);
              if (*(unsigned __int16 *)(v13 + 2) >= 2u && *(_BYTE *)(v13 + 16) == 1)
              {
                *(_WORD *)(*(_QWORD *)(qword_10098FD98 + 8) + 168) = *(_DWORD *)(v13 + 24);
                if (sub_10005549C())
                {
                  sub_100054530("Profile Version: %x", *(unsigned __int16 *)(*(_QWORD *)(qword_10098FD98 + 8) + 168));
                  v14 = sub_1000544A0(0x33u);
                  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
                  {
                    v15 = sub_100054494();
                    *(_DWORD *)buf = 136446210;
                    *(_QWORD *)&buf[4] = v15;
                    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
                  }
                }
              }
            }
          }
LABEL_61:
          v8 += 2;
        }
        while ((v8 | 1uLL) < *v6);
      }
      v31 = qword_10098FD98;
      v32 = *(_QWORD *)(qword_10098FD98 + 8);
      if (*(_BYTE *)(v32 + 164))
      {
        if (*(_BYTE *)(qword_10098FD98 + 4))
          break;
      }
      *(_BYTE *)(v32 + 164) = 0;
      *(_BYTE *)(v32 + 24) = 0;
      *(_BYTE *)(*(_QWORD *)(v31 + 8) + 64) = 0;
      ++v4;
      a1 = v36;
      if (v4 >= *(unsigned __int16 *)(v36 + 2))
        goto LABEL_65;
    }
    sub_100245524();
    return sub_1002442C8();
  }
LABEL_65:
  if (!a2)
  {
    v33 = 923;
    goto LABEL_69;
  }
  result = sub_1002454C8();
  v33 = result;
  if ((_DWORD)result)
  {
LABEL_69:
    if (sub_10005549C())
    {
      sub_100054530("OI_SDP_ContinueCurrentReq returned %!", v33);
      v34 = sub_1000544A0(0x33u);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        sub_1006CEF28(v34);
    }
    *(_DWORD *)(*(_QWORD *)(qword_10098FD98 + 8) + 172) = v33;
    return sub_1002442C8();
  }
  return result;
}

uint64_t sub_1002442C8()
{
  uint64_t result;

  result = sub_100244A44();
  if ((_DWORD)result)
    return sub_1002442F8(*(_QWORD *)(qword_10098FD98 + 8), result);
  return result;
}

uint64_t sub_1002442F8(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t (*v6)(uint64_t, uint64_t);

  v4 = (_QWORD *)qword_10098FD98;
  if (*(_QWORD *)(qword_10098FD98 + 8) != a1)
  {
    sub_100253460();
    v4 = (_QWORD *)qword_10098FD98;
  }
  v6 = (uint64_t (*)(uint64_t, uint64_t))v4[2];
  sub_100053298(v4);
  qword_10098FD98 = 0;
  dword_100999214 = 0;
  return v6(a1, a2);
}

uint64_t sub_10024436C(unsigned int a1, _WORD *a2)
{
  unsigned int v3;
  _QWORD v4[2];

  v3 = 0;
  v4[0] = 262147;
  v4[1] = a1;
  if (sub_100246A18((uint64_t)v4, 1u, a2, &v3, 0))
    return 0;
  else
    return v3;
}

void sub_1002443C4()
{
  byte_10098FDA0 = 1;
}

uint64_t sub_1002443D4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  NSObject *v8;
  _WORD *v9;
  unsigned int v10;
  __int16 v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  __int128 v15;

  if ((_DWORD)xmmword_100999218)
    return 821;
  if (!*(_WORD *)(sub_100252DE8(0x34u) + 2))
    sub_100253460();
  if (!*(_WORD *)sub_100252DE8(0x34u))
    sub_100253460();
  if ((_DWORD)xmmword_100999218)
  {
    v3 = 140;
LABEL_10:
    if (sub_10005549C())
    {
      sub_100054530("SDP client init failed %!", v3);
      v8 = sub_1000544A0(0x34u);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_1006D2728();
    }
    return v3;
  }
  v9 = sub_100114588(0x60uLL);
  qword_10098FDA8 = (uint64_t)v9;
  if (!v9)
  {
    v3 = 106;
    goto LABEL_10;
  }
  if (byte_10098FDA0 == 1)
  {
    v10 = 1024;
    v9[44] = 1024;
    LODWORD(xmmword_100999218) = 1;
    v14 = 0u;
    v15 = 0u;
    WORD2(v14) = 5000;
    LODWORD(v14) = -64512;
  }
  else
  {
    v10 = (unsigned __int16)v9[44];
    LODWORD(xmmword_100999218) = 1;
    v15 = 0uLL;
    *((_QWORD *)&v14 + 1) = 0;
    *(_DWORD *)((char *)&v14 + 2) = 327745535;
    if (!v10)
      v10 = *(unsigned __int16 *)sub_100252DE8(0x34u);
    LOWORD(v14) = v10;
    if (v10 <= 0x80)
    {
      v11 = 128;
      goto LABEL_23;
    }
  }
  if (v10 <= *(unsigned __int16 *)(sub_100252DE8(0x28u) + 8))
    goto LABEL_24;
  v11 = *(_WORD *)(sub_100252DE8(0x28u) + 8);
LABEL_23:
  LOWORD(v14) = v11;
LABEL_24:
  WORD3(v14) = 772;
  WORD6(v14) = 0;
  BYTE8(v15) = 0;
  v12 = sub_1001DD1A8((uint64_t)sub_1002445DC, (uint64_t)sub_100244784, (uint64_t)sub_100244788, 1u, a3, (uint64_t)&v14, (_WORD *)(qword_10098FDA8 + 4), (uint64_t)&unk_10073B9C0);
  if ((_DWORD)v12)
  {
    v3 = v12;
    sub_100244998();
  }
  else
  {
    v13 = qword_10098FDA8;
    *(_DWORD *)qword_10098FDA8 = 0;
    *(_QWORD *)(v13 + 72) = a2;
    *(_QWORD *)(v13 + 80) = a1;
    if (off_10098FDB0)
      off_10098FDB0(1);
    return 0;
  }
  return v3;
}

void sub_1002445DC(int a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  NSObject *v5;
  uint64_t v6;
  NSObject *v7;
  __int16 v8;
  uint64_t v10;
  int v11;
  unsigned __int16 *v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  void (*v16)(uint64_t);

  if ((_DWORD)xmmword_100999218 && !*(_DWORD *)qword_10098FDA8)
  {
    v6 = a4;
    if ((_DWORD)a4)
    {
      if (sub_10005549C())
      {
        sub_100054530("SDP client connect failed %!", v6);
        v7 = sub_1000544A0(0x34u);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
          sub_1006D2728();
      }
      if (off_10098FDB0)
        off_10098FDB0(0);
    }
    else
    {
      v8 = a3;
      if (*(unsigned __int16 *)(sub_100252DE8(0x34u) + 2) < a3)
        v8 = *(_WORD *)(sub_100252DE8(0x34u) + 2);
      v10 = qword_10098FDA8;
      *(_WORD *)(qword_10098FDA8 + 12) = v8;
      v11 = *(unsigned __int16 *)(v10 + 88);
      if (!v11)
      {
        v12 = (unsigned __int16 *)sub_100252DE8(0x34u);
        LOWORD(v11) = a2;
        if (*v12 < a2)
          LOWORD(v11) = *(_WORD *)sub_100252DE8(0x34u);
      }
      v13 = qword_10098FDA8;
      *(_WORD *)(qword_10098FDA8 + 14) = v11;
      *(_DWORD *)v13 = 1;
      v14 = sub_100052DC0(*(unsigned __int16 *)(v13 + 12));
      v15 = qword_10098FDA8;
      *(_QWORD *)(qword_10098FDA8 + 24) = v14;
      if (v14)
      {
        (*(void (**)(_QWORD))(v15 + 80))(0);
        return;
      }
      v6 = 106;
    }
    v16 = *(void (**)(uint64_t))(qword_10098FDA8 + 80);
    sub_100244998();
    v16(v6);
  }
  else if (sub_10005549C())
  {
    sub_100054530("Spurious connect complete callback CID = %d", a1);
    v5 = sub_1000544A0(0x34u);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      sub_1006D37D8();
  }
}

void sub_100244788(int a1, char *a2, unsigned int a3)
{
  uint64_t v5;
  NSObject *v7;
  NSObject *v8;
  int v9;
  unsigned int v10;
  int v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  char *v17;
  uint64_t v18;

  v17 = 0;
  v18 = 0;
  if (*(unsigned __int16 *)(qword_10098FDA8 + 4) == a1)
  {
    sub_100049F6C(*(unsigned int *)(qword_10098FDA8 + 8));
    if (*(_DWORD *)qword_10098FDA8 == 2)
    {
      if (a3 < 5)
      {
        v5 = 804;
LABEL_35:
        sub_100245F68(v5);
        return;
      }
      if (!a2)
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
      v17 = a2;
      LOWORD(v18) = a3;
      WORD1(v18) = a3;
      v9 = *a2;
      v10 = bswap32(*(unsigned __int16 *)(a2 + 1));
      HIDWORD(v18) = 65539;
      if (*(unsigned __int16 *)(qword_10098FDA8 + 68) != HIWORD(v10))
      {
        v5 = 830;
        goto LABEL_35;
      }
      v11 = a2[4];
      v12 = a2[3];
      WORD2(v18) = 5;
      if (v9 != *(unsigned __int8 *)(qword_10098FDA8 + 32))
      {
        if (v9 == 1)
        {
          if (a3 - 7 > 0xFFFFFFFD)
          {
            HIBYTE(v18) = 1;
            v14 = 800;
          }
          else
          {
            v13 = __rev16(*(unsigned __int16 *)(a2 + 5));
            WORD2(v18) = 7;
            v14 = v13 + 800;
          }
          if (v14 >= 0x327)
            v5 = 807;
          else
            v5 = v14;
        }
        else
        {
          v5 = 831;
        }
        goto LABEL_35;
      }
      if ((v11 | (v12 << 8)) < a3 - 5)
      {
        v5 = 829;
        goto LABEL_35;
      }
      v15 = *(unsigned __int8 *)(qword_10098FDA8 + 32);
      if (v15 == 7 || v15 == 5)
      {
        v5 = sub_1002457E4((uint64_t)&v17);
      }
      else if (v15 == 3)
      {
        v5 = sub_1002455EC((uint64_t *)&v17);
      }
      else
      {
        sub_100253460();
        v5 = 0;
      }
      if ((_DWORD)v5)
        goto LABEL_35;
    }
    else if (sub_10005549C())
    {
      sub_100054530("SDP client not expecting data at this time");
      v8 = sub_1000544A0(0x34u);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_1006D38B8();
    }
  }
  else if (sub_10005549C())
  {
    sub_100054530("ReceivedResponseCB no server corresponds to CID = %x", a1);
    v7 = sub_1000544A0(0x34u);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      sub_1006D37D8();
  }
}

void sub_100244998()
{
  void **v0;
  uint64_t v1;

  v0 = (void **)qword_10098FDA8;
  if (*(_DWORD *)(qword_10098FDA8 + 8))
  {
    sub_100049F6C(*(unsigned int *)(qword_10098FDA8 + 8));
    v1 = qword_10098FDA8;
    *(_DWORD *)(qword_10098FDA8 + 8) = 0;
    sub_1001DEB7C(*(unsigned __int16 *)(v1 + 4), 436);
    v0 = (void **)qword_10098FDA8;
  }
  if (v0[3])
  {
    sub_100053298(v0[3]);
    v0 = (void **)qword_10098FDA8;
    *(_QWORD *)(qword_10098FDA8 + 24) = 0;
  }
  if (v0[5])
  {
    sub_100053298(v0[5]);
    v0 = (void **)qword_10098FDA8;
    *(_QWORD *)(qword_10098FDA8 + 40) = 0;
  }
  if (v0[7])
  {
    sub_100053298(v0[7]);
    v0 = (void **)qword_10098FDA8;
    *(_QWORD *)(qword_10098FDA8 + 56) = 0;
  }
  sub_100053298(v0);
  qword_10098FDA8 = 0;
  byte_10098FDA0 = 0;
  LODWORD(xmmword_100999218) = 0;
}

uint64_t sub_100244A44()
{
  uint64_t v0;
  uint64_t v1;
  _DWORD *v2;

  if (!(_DWORD)xmmword_100999218)
    return 810;
  v0 = qword_10098FDA8;
  if (*(_DWORD *)qword_10098FDA8 == 3)
    return 810;
  if (off_10098FDB0)
  {
    off_10098FDB0(0);
    v0 = qword_10098FDA8;
  }
  v1 = sub_1001DEB7C(*(unsigned __int16 *)(v0 + 4), 436);
  if ((_DWORD)v1)
  {
    sub_100244AE0(*(unsigned __int16 *)(qword_10098FDA8 + 4));
  }
  else
  {
    sub_100049F6C(*(unsigned int *)(qword_10098FDA8 + 8));
    v2 = (_DWORD *)qword_10098FDA8;
    *(_DWORD *)(qword_10098FDA8 + 8) = 0;
    *v2 = 3;
  }
  return v1;
}

uint64_t sub_100244AE0(uint64_t result)
{
  int v1;
  NSObject *v2;
  uint64_t (*v3)(void);

  if ((_DWORD)xmmword_100999218)
  {
    v1 = result;
    if (off_10098FDB0)
      off_10098FDB0(0);
    if (*(unsigned __int16 *)(qword_10098FDA8 + 4) != v1 && sub_10005549C())
    {
      sub_100054530("No SDP connection for CID %d", v1);
      v2 = sub_1000544A0(0x34u);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_1006D37D8();
    }
    v3 = *(uint64_t (**)(void))(qword_10098FDA8 + 72);
    sub_100244998();
    return v3();
  }
  return result;
}

uint64_t sub_100244B90(uint64_t a1, unsigned int a2, unsigned __int8 *a3)
{
  uint64_t v3;
  int v4;
  int v10;
  unsigned __int16 v11;
  void *v12;
  uint64_t v13;
  _BYTE *v14;
  unsigned __int16 v15;
  unsigned __int16 v16;
  unsigned __int16 v17;
  uint64_t v18;
  _BYTE *v19;
  unsigned __int16 v20;
  unsigned __int16 v21;
  unsigned __int16 v22;
  __int16 v23;

  if (!(_DWORD)xmmword_100999218)
    return 810;
  v3 = qword_10098FDA8;
  v4 = *(_DWORD *)qword_10098FDA8;
  if (!*(_DWORD *)qword_10098FDA8 || v4 == 3)
    return 810;
  if (v4 == 2)
    return 817;
  if (!a2)
    return 825;
  *(_WORD *)(qword_10098FDA8 + 48) = a2;
  *(_WORD *)(v3 + 50) = 0;
  v10 = sub_10017E4F0(a3);
  if (v10 == 65534)
    return 106;
  v11 = v10 + 24;
  if (*(unsigned __int16 *)(qword_10098FDA8 + 12) < (unsigned __int16)(v10 + 24))
    return 816;
  v12 = sub_100052DC0(4 * a2);
  v13 = qword_10098FDA8;
  *(_QWORD *)(qword_10098FDA8 + 40) = v12;
  if (!v12)
    return 106;
  v14 = *(_BYTE **)(v13 + 24);
  if (!v14 || !v11)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
  v19 = v14;
  v20 = v11;
  v23 = 2;
  v21 = v11;
  *v14 = 2;
  if ((unint64_t)v11 - 5 >= 0xFFFFFFFFFFFFFFFCLL)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
  v22 = 5;
  sub_10017E770((uint64_t)&v19, a3);
  if (HIBYTE(v23))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 1332, "OI_STATUS OI_SDP_SearchReq(OI_SDP_SEARCH_RSP_CB, uint16_t, const OI_DATAELEM *)");
    goto LABEL_33;
  }
  if (v21 - v22 <= 1 || v23 != 2)
LABEL_33:
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
  v19[v22 + 1] = *(_BYTE *)(qword_10098FDA8 + 48);
  v19[v22] = *(_BYTE *)(qword_10098FDA8 + 49);
  v15 = v22;
  v16 = v22 + 2;
  v22 = v16;
  *(_WORD *)(qword_10098FDA8 + 16) = v16;
  if (HIBYTE(v23))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 1341, "OI_STATUS OI_SDP_SearchReq(OI_SDP_SEARCH_RSP_CB, uint16_t, const OI_DATAELEM *)");
    goto LABEL_35;
  }
  if (v21 <= v16 || v23 != 2)
LABEL_35:
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
  v22 = v15 + 3;
  v19[v16] = 0;
  if (v23 == 2)
  {
    v17 = v22;
    v21 = v22;
  }
  else
  {
    v17 = v21;
  }
  LOBYTE(v23) = 15;
  v18 = qword_10098FDA8;
  *(_WORD *)(qword_10098FDA8 + 18) = v17;
  *(_QWORD *)(v18 + 80) = a1;
  *(_BYTE *)(v18 + 32) = 3;
  return sub_100244E58();
}

uint64_t sub_100244E58()
{
  uint64_t v0;
  __int16 v1;
  __int16 v2;
  uint64_t result;

  v0 = qword_10098FDA8;
  v1 = *(_WORD *)(qword_10098FDA8 + 68) + 1;
  *(_WORD *)(qword_10098FDA8 + 68) = v1;
  *(_BYTE *)(*(_QWORD *)(v0 + 24) + 2) = v1;
  *(_BYTE *)(*(_QWORD *)(v0 + 24) + 1) = *(_BYTE *)(v0 + 69);
  v2 = *(_WORD *)(v0 + 18) - 5;
  *(_BYTE *)(*(_QWORD *)(v0 + 24) + 4) = v2;
  *(_BYTE *)(*(_QWORD *)(v0 + 24) + 3) = HIBYTE(v2);
  result = sub_1001DBF20((uint64_t)sub_1002463C0, *(unsigned __int16 *)(v0 + 4), 0, *(char **)(v0 + 24), *(unsigned __int16 *)(v0 + 18));
  if (!(_DWORD)result)
  {
    result = sub_10004A9EC((uint64_t)sub_1002463DC, 0, 70, (int *)(qword_10098FDA8 + 8));
    *(_DWORD *)qword_10098FDA8 = 2;
  }
  return result;
}

uint64_t sub_100244EFC(uint64_t a1, unsigned int a2, unsigned __int8 *a3)
{
  int v3;
  uint64_t result;
  int v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (!(_DWORD)xmmword_100999218)
    return 810;
  v17 = 0;
  v3 = *(_DWORD *)qword_10098FDA8;
  if (!*(_DWORD *)qword_10098FDA8 || v3 == 3)
    return 810;
  if (v3 == 2)
    return 817;
  result = sub_10024515C((uint64_t)a3);
  if (!(_DWORD)result)
  {
    v9 = sub_10017E4F0(a3);
    if (!v9)
      return 106;
    v10 = qword_10098FDA8;
    if (*(unsigned __int16 *)(qword_10098FDA8 + 12) < (unsigned __int16)(v9 + 28))
      return 816;
    v11 = *(_QWORD *)(qword_10098FDA8 + 24);
    if (!v11 || (_WORD)v9 == 0xFFE4)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
    v16 = *(_QWORD *)(qword_10098FDA8 + 24);
    LOWORD(v17) = v9 + 28;
    HIWORD(v17) = 2;
    WORD1(v17) = v9 + 28;
    *(_BYTE *)v11 = 4;
    if ((unint64_t)(unsigned __int16)(v9 + 28) - 5 >= 0xFFFFFFFFFFFFFFFCLL)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
    v12 = (unsigned __int16)(v9 + 28);
    if (v12 <= 8)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
    *(_DWORD *)(v11 + 5) = bswap32(a2);
    if (v12 <= 0xA)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
    *(_BYTE *)(v11 + 10) = *(_BYTE *)(v10 + 14);
    *(_BYTE *)(v11 + 9) = *(_BYTE *)(v10 + 15);
    WORD2(v17) = 11;
    sub_10017E770((uint64_t)&v16, a3);
    v13 = WORD2(v17);
    *(_WORD *)(qword_10098FDA8 + 16) = WORD2(v17);
    if (HIBYTE(v17))
    {
      sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 1485, "OI_STATUS OI_SDP_AttributeReq(OI_SDP_ATTRIBUTE_RSP_CB, OI_SDP_SERVICE_RECORD_HANDLE, const OI_DATAELEM *)");
    }
    else if (WORD1(v17) > v13 && BYTE6(v17) == 2)
    {
      WORD2(v17) = v13 + 1;
      *(_BYTE *)(v16 + v13) = 0;
      if (BYTE6(v17) == 2)
      {
        v14 = WORD2(v17);
        WORD1(v17) = WORD2(v17);
      }
      else
      {
        v14 = WORD1(v17);
      }
      BYTE6(v17) = 15;
      v15 = qword_10098FDA8;
      *(_WORD *)(qword_10098FDA8 + 18) = v14;
      *(_QWORD *)(v15 + 80) = a1;
      *(_BYTE *)(v15 + 32) = 5;
      return sub_100244E58();
    }
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
  }
  return result;
}

uint64_t sub_10024515C(uint64_t a1)
{
  unint64_t v2;
  uint64_t v3;
  int v4;
  unsigned int v5;
  int v6;

  if (!*(_WORD *)(a1 + 2))
    return 0;
  v2 = 0;
  v3 = *(_QWORD *)(a1 + 8);
  v4 = -1;
  while (1)
  {
    if (*(_BYTE *)v3 != 1)
    {
      sub_100253460();
      if (*(_BYTE *)v3 != 1)
        break;
    }
    v5 = (unsigned __int16)*(_DWORD *)(v3 + 8);
    if (*(_WORD *)(v3 + 2) == 2)
      v6 = (unsigned __int16)*(_DWORD *)(v3 + 8);
    else
      v6 = HIWORD(*(_DWORD *)(v3 + 8));
    if (v6 < v4 || v5 < v6)
      return 812;
    ++v2;
    v3 += 16;
    v4 = v5;
    if (v2 >= *(unsigned __int16 *)(a1 + 2))
      return 0;
  }
  return 101;
}

uint64_t sub_100245200(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  int v3;
  uint64_t result;
  int v9;
  __int16 v10;
  int v11;
  _BYTE *v12;
  uint64_t v13;
  unsigned __int16 v14;
  uint64_t v15;
  uint64_t v16;
  unsigned __int16 v17;
  unsigned __int16 v18;
  unsigned __int16 v19;
  __int16 v20;

  if (!(_DWORD)xmmword_100999218)
    return 810;
  v3 = *(_DWORD *)qword_10098FDA8;
  if (!*(_DWORD *)qword_10098FDA8 || v3 == 3)
    return 810;
  if (v3 == 2)
    return 817;
  v9 = sub_10017E4F0(a2);
  if (!v9)
    return 106;
  v10 = v9;
  result = sub_10024515C((uint64_t)a3);
  if ((_DWORD)result)
    return result;
  v11 = sub_10017E4F0(a3);
  if (!v11)
    return 106;
  if (*(unsigned __int16 *)(qword_10098FDA8 + 12) < (unsigned __int16)(v10 + 24 + v11))
    return 816;
  v12 = *(_BYTE **)(qword_10098FDA8 + 24);
  if (!v12 || !(v10 + 24 + (_WORD)v11))
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
  v16 = *(_QWORD *)(qword_10098FDA8 + 24);
  v17 = v10 + 24 + v11;
  v20 = 2;
  v18 = v17;
  *v12 = 6;
  if ((unint64_t)(unsigned __int16)(v10 + 24 + v11) - 5 >= 0xFFFFFFFFFFFFFFFCLL)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
  v19 = 5;
  sub_10017E770((uint64_t)&v16, a2);
  if (HIBYTE(v20))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 1584, "OI_STATUS OI_SDP_SearchAttributeReq(OI_SDP_SEARCH_ATTRIBUTE_RSP_CB, const OI_DATAELEM *, const OI_DATAELEM *)");
    goto LABEL_33;
  }
  if (v18 - v19 <= 1 || v20 != 2)
LABEL_33:
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
  *(_BYTE *)(v16 + v19 + 1) = *(_BYTE *)(qword_10098FDA8 + 14);
  *(_BYTE *)(v16 + v19) = *(_BYTE *)(qword_10098FDA8 + 15);
  v19 += 2;
  sub_10017E770((uint64_t)&v16, a3);
  v13 = v19;
  *(_WORD *)(qword_10098FDA8 + 16) = v19;
  if (HIBYTE(v20))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 1594, "OI_STATUS OI_SDP_SearchAttributeReq(OI_SDP_SEARCH_ATTRIBUTE_RSP_CB, const OI_DATAELEM *, const OI_DATAELEM *)");
    goto LABEL_35;
  }
  if (v18 <= v13 || v20 != 2)
LABEL_35:
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
  v19 = v13 + 1;
  *(_BYTE *)(v16 + v13) = 0;
  if (v20 == 2)
  {
    v14 = v19;
    v18 = v19;
  }
  else
  {
    v14 = v18;
  }
  LOBYTE(v20) = 15;
  v15 = qword_10098FDA8;
  *(_WORD *)(qword_10098FDA8 + 18) = v14;
  *(_QWORD *)(v15 + 80) = a1;
  *(_BYTE *)(v15 + 32) = 7;
  return sub_100244E58();
}

uint64_t sub_1002454C8()
{
  int v0;
  uint64_t result;

  if (!(_DWORD)xmmword_100999218)
    return 810;
  v0 = *(_DWORD *)qword_10098FDA8;
  result = 810;
  if (*(_DWORD *)qword_10098FDA8)
  {
    if (v0 == 2)
    {
      if ((*(unsigned __int8 *)(qword_10098FDA8 + 32) | 2) == 7)
        return sub_100244E58();
    }
    else if (v0 == 3)
    {
      return result;
    }
    return 815;
  }
  return result;
}

uint64_t sub_100245524()
{
  uint64_t v0;
  int v1;
  uint64_t result;
  void *v3;

  if (!(_DWORD)xmmword_100999218)
    return 810;
  v0 = qword_10098FDA8;
  v1 = *(_DWORD *)qword_10098FDA8;
  result = 810;
  if (*(_DWORD *)qword_10098FDA8)
  {
    if (v1 == 2)
    {
      *(_WORD *)(qword_10098FDA8 + 66) = 0;
      v3 = *(void **)(v0 + 56);
      if (v3)
      {
        sub_100053298(v3);
        v0 = qword_10098FDA8;
        *(_QWORD *)(qword_10098FDA8 + 56) = 0;
      }
      result = 0;
      *(_DWORD *)v0 = 1;
    }
    else if (v1 != 3)
    {
      return 815;
    }
  }
  return result;
}

uint64_t sub_1002455A4(void *a1)
{
  uint64_t result;

  if (off_10098FDB0)
  {
    if (off_10098FDB0 == a1)
      return 0;
    else
      return 119;
  }
  else
  {
    result = 0;
    off_10098FDB0 = a1;
  }
  return result;
}

void *sub_1002455D0(void *result)
{
  if (off_10098FDB0 == result)
    off_10098FDB0 = 0;
  return result;
}

uint64_t sub_1002455EC(uint64_t *a1)
{
  int v2;
  uint64_t v3;
  unsigned int v4;
  int v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  unsigned __int16 v9;
  uint64_t result;
  uint64_t v11;
  int v12;
  unsigned __int16 v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  unsigned __int16 v18;

  if (*((_BYTE *)a1 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 1023, "OI_STATUS ServiceRecordResponse(OI_BYTE_STREAM *)");
    v2 = *((unsigned __int8 *)a1 + 14);
    *((_BYTE *)a1 + 15) = 1;
    if (v2 != 1)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
    goto LABEL_10;
  }
  v3 = *((unsigned __int16 *)a1 + 6);
  if (*((unsigned __int16 *)a1 + 5) - (int)v3 <= 1)
  {
    *((_BYTE *)a1 + 15) = 1;
LABEL_10:
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 1024, "OI_STATUS ServiceRecordResponse(OI_BYTE_STREAM *)");
    goto LABEL_11;
  }
  v4 = *(unsigned __int16 *)(*a1 + v3);
  *((_WORD *)a1 + 6) = v3 + 2;
  v5 = *((unsigned __int16 *)a1 + 5);
  if (v5 - (unsigned __int16)(v3 + 2) <= 1)
  {
LABEL_11:
    *((_BYTE *)a1 + 15) = 1;
    return 829;
  }
  v6 = __rev16(v4);
  v7 = *a1;
  v8 = __rev16(*(unsigned __int16 *)(*a1 + (unsigned __int16)(v3 + 2)));
  v9 = v3 + 4;
  *((_WORD *)a1 + 6) = v3 + 4;
  if (v8 > v6)
    return 833;
  v11 = qword_10098FDA8;
  if (!v8)
  {
    v18 = *(_WORD *)(qword_10098FDA8 + 50);
    v12 = *(unsigned __int16 *)(qword_10098FDA8 + 48);
LABEL_20:
    if (v12 == v18 || v6 == v18)
    {
      *(_DWORD *)v11 = 1;
    }
    else
    {
      result = sub_100246038(a1);
      if ((_DWORD)result)
        return result;
      v11 = qword_10098FDA8;
      if (*(_DWORD *)qword_10098FDA8 == 2)
        return sub_100244E58();
    }
    (*(void (**)(_QWORD, _QWORD, _QWORD))(v11 + 80))(*(_QWORD *)(v11 + 40), *(unsigned __int16 *)(v11 + 50), 0);
    sub_100053298(*(void **)(qword_10098FDA8 + 40));
    result = 0;
    *(_QWORD *)(qword_10098FDA8 + 40) = 0;
    return result;
  }
  v12 = *(unsigned __int16 *)(qword_10098FDA8 + 48);
  v13 = *(_WORD *)(qword_10098FDA8 + 50);
  v14 = v5 - 3;
  while (v12 != v13)
  {
    if (v14 <= v9)
      goto LABEL_11;
    v15 = v9;
    v9 += 4;
    LODWORD(v15) = *(_DWORD *)(v7 + v15);
    *((_WORD *)a1 + 6) = v9;
    v16 = bswap32(v15);
    v17 = *(_QWORD *)(v11 + 40);
    v18 = v13 + 1;
    *(_WORD *)(v11 + 50) = v13 + 1;
    *(_DWORD *)(v17 + 4 * v13++) = v16;
    if (!--v8)
      goto LABEL_20;
  }
  return 837;
}

uint64_t sub_1002457E4(uint64_t a1)
{
  unsigned int v2;
  uint64_t v3;
  unsigned int v4;
  unsigned __int16 v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  size_t v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  size_t v15;
  NSObject *v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  unsigned int v22;
  uint64_t v23;
  unsigned __int16 v24;
  uint64_t v25;
  int v26;
  unsigned __int16 v27;
  uint64_t v28;
  _BYTE *v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unsigned int v33;
  unsigned __int16 v34;
  void *v35;
  void *v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  char v41;
  unsigned __int16 v42;
  __int16 v43;
  unsigned __int16 v44;
  uint64_t v45;
  _BYTE *v46;

  v46 = 0;
  v44 = 0;
  v45 = 6;
  if (*(_BYTE *)(a1 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
  v43 = 0;
  if (*(_BYTE *)(a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 753, "OI_STATUS AttributeListResponse(OI_BYTE_STREAM *)");
LABEL_7:
    v6 = 0;
    *(_BYTE *)(a1 + 15) = 1;
    goto LABEL_8;
  }
  v2 = *(unsigned __int16 *)(a1 + 10);
  v3 = *(unsigned __int16 *)(a1 + 12);
  if ((int)(v2 - v3) <= 1)
    goto LABEL_7;
  v4 = *(unsigned __int16 *)(*(_QWORD *)a1 + v3);
  v5 = v3 + 2;
  *(_WORD *)(a1 + 12) = v3 + 2;
  if ((int)(v2 - (unsigned __int16)(v3 + 2)) >= (int)(bswap32(v4) >> 16))
  {
    v11 = __rev16(v4);
    if (v11 > *(unsigned __int16 *)(qword_10098FDA8 + 14))
    {
      v6 = 0;
      v7 = 836;
      goto LABEL_9;
    }
    v12 = (unsigned __int16)(v3 + 2) + (_DWORD)v11;
    if (v12 > v2)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
    *(_WORD *)(a1 + 12) = v12;
    v13 = sub_100246038((uint64_t *)a1);
    if ((_DWORD)v13)
    {
      v7 = v13;
LABEL_19:
      v6 = 0;
      goto LABEL_9;
    }
    if (*(unsigned __int16 *)(a1 + 10) < v5)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
    *(_WORD *)(a1 + 12) = v5;
    if (v12 > *(unsigned __int16 *)(a1 + 8))
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
    *(_WORD *)(a1 + 10) = v12;
    v14 = qword_10098FDA8;
    if (*(_QWORD *)(qword_10098FDA8 + 56))
    {
      v15 = *(unsigned __int16 *)(qword_10098FDA8 + 64) + v11;
      if (v15 >= 0x2801)
      {
        if (sub_10005549C())
        {
          sub_100054530("Accumulated attribute reponse data length exceed the limits");
          v16 = sub_1000544A0(0x34u);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
            sub_1006D2C78();
        }
        v6 = 0;
        goto LABEL_79;
      }
      v17 = (char *)sub_100052DC0(v15);
      v6 = v17;
      if (!v17)
        goto LABEL_79;
      memmove(v17, *(const void **)(qword_10098FDA8 + 56), *(unsigned __int16 *)(qword_10098FDA8 + 64));
      if (*(_BYTE *)(a1 + 14) != 1
        || ((v18 = *(unsigned __int16 *)(qword_10098FDA8 + 64),
             v19 = *(_QWORD *)a1,
             v20 = *(unsigned __int16 *)(a1 + 12),
             !*(_BYTE *)(a1 + 15))
          ? (v21 = *(unsigned __int16 *)(a1 + 10) - (_DWORD)v20)
          : (sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 801, "OI_STATUS AttributeListResponse(OI_BYTE_STREAM *)"), v21 = 0), v21 < (int)v11))
      {
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
      }
      memmove(&v6[v18], (const void *)(v19 + v20), v11);
      *(_WORD *)(a1 + 12) += v11;
      sub_100053298(*(void **)(qword_10098FDA8 + 56));
      v14 = qword_10098FDA8;
      *(_QWORD *)(qword_10098FDA8 + 56) = 0;
      if (!(_DWORD)v15)
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
      v5 = 0;
      *(_QWORD *)a1 = v6;
      *(_WORD *)(a1 + 8) = v15;
      *(_DWORD *)(a1 + 12) = 0x10000;
      *(_WORD *)(a1 + 10) = v15;
    }
    else
    {
      v6 = 0;
    }
    v22 = *(unsigned __int16 *)(v14 + 66);
    if (!*(_WORD *)(v14 + 66))
    {
      v23 = sub_10017EB00(a1, &v43, (_WORD *)(v14 + 66));
      if ((_DWORD)v23)
      {
        v7 = v23;
        if ((_DWORD)v23 != 843)
          goto LABEL_9;
        if (*(unsigned __int16 *)(a1 + 10) < v5)
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
        *(_WORD *)(a1 + 12) = v5;
        v7 = 843;
        v24 = v11;
LABEL_82:
        if (*(_DWORD *)qword_10098FDA8 == 2)
        {
          if (v24)
          {
            v35 = sub_100052DC0(v24);
            *(_QWORD *)(qword_10098FDA8 + 56) = v35;
            if (!v35)
            {
              v7 = 106;
              goto LABEL_9;
            }
            if (*(_BYTE *)(a1 + 14) != 1
              || ((v36 = v35, v37 = *(_QWORD *)a1, v38 = *(unsigned __int16 *)(a1 + 12), !*(_BYTE *)(a1 + 15))
                ? (v39 = *(unsigned __int16 *)(a1 + 10) - (_DWORD)v38)
                : (sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 951, "OI_STATUS AttributeListResponse(OI_BYTE_STREAM *)"), v39 = 0), v39 < v24))
            {
              sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
            }
            memmove(v36, (const void *)(v37 + v38), v24);
            *(_WORD *)(a1 + 12) += v24;
            *(_WORD *)(qword_10098FDA8 + 64) = v24;
          }
        }
        else if (v24)
        {
          goto LABEL_39;
        }
LABEL_94:
        if (v6)
          sub_100053298(v6);
        if (*(_DWORD *)qword_10098FDA8 != 2 || v44 != 0)
        {
          (*(void (**)(uint64_t *, BOOL, uint64_t))(qword_10098FDA8 + 80))(&v45, *(_DWORD *)qword_10098FDA8 == 2, v7);
          sub_10017FAC4((unsigned __int8 *)&v45);
          return 0;
        }
        v7 = sub_100244E58();
        if (!(_DWORD)v7)
          return v7;
        goto LABEL_19;
      }
      LOWORD(v11) = v11 - v43;
      v5 += v43;
      v14 = qword_10098FDA8;
      v22 = *(unsigned __int16 *)(qword_10098FDA8 + 66);
    }
    if (v22 < (unsigned __int16)v11)
    {
LABEL_39:
      v7 = 833;
      goto LABEL_9;
    }
    *(_WORD *)(v14 + 66) = v22 - v11;
    if (*(_BYTE *)(v14 + 32) == 7)
    {
      while (1)
      {
        v42 = 0;
        v25 = sub_10017EB00(a1, &v43, &v42);
        if ((_DWORD)v25)
          break;
        if (*(_BYTE *)(a1 + 15))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 862, "OI_STATUS AttributeListResponse(OI_BYTE_STREAM *)");
          v26 = 0;
        }
        else
        {
          v26 = *(unsigned __int16 *)(a1 + 10) - *(unsigned __int16 *)(a1 + 12);
        }
        if (v26 < v42)
        {
          v7 = 0;
          goto LABEL_62;
        }
        v25 = sub_1002461E8(a1, v42, 0);
        if ((_DWORD)v25)
          break;
        ++v44;
      }
      v7 = v25;
      if ((_DWORD)v25 != 843)
        goto LABEL_9;
    }
    else
    {
      if (*(_BYTE *)(a1 + 15))
      {
        sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 879, "OI_STATUS AttributeListResponse(OI_BYTE_STREAM *)");
        v27 = 0;
      }
      else
      {
        v27 = *(_WORD *)(a1 + 10) - *(_WORD *)(a1 + 12);
      }
      v28 = sub_1002461E8(a1, v27, &v44);
      v7 = v28;
      if ((_DWORD)v28 != 843 && (_DWORD)v28)
        goto LABEL_9;
    }
LABEL_62:
    if ((_DWORD)v7 == 843)
    {
      v7 = 0;
      *(_BYTE *)(a1 + 15) = 0;
    }
    if (*(unsigned __int16 *)(a1 + 10) < v5)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
    *(_WORD *)(a1 + 12) = v5;
    if (!v44)
      goto LABEL_77;
    LOBYTE(v45) = 6;
    WORD1(v45) = 0;
    v29 = sub_100052DC0(16 * v44 + 16);
    v46 = v29;
    if (v29)
    {
      v30 = v44;
      v29[16 * v44] = 33;
      *(_QWORD *)&v46[16 * v30 + 8] = &v45;
      if (v30)
      {
        v31 = 0;
        v32 = 0;
        while (1)
        {
          v41 = 0;
          v42 = 0;
          if (sub_10017E7CC(a1, &v41, (__int16 *)&v42) == 843)
            break;
          v33 = v42;
          if (*(_BYTE *)(a1 + 15))
          {
            sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 920, "OI_STATUS AttributeListResponse(OI_BYTE_STREAM *)");
            v34 = 0;
          }
          else
          {
            v34 = *(_WORD *)(a1 + 10) - *(_WORD *)(a1 + 12);
          }
          if (v33 > v34)
            break;
          if (sub_10017FA1C((uint64_t *)a1, &v46[v31]))
            goto LABEL_39;
          ++WORD1(v45);
          ++v32;
          v31 += 16;
          if (v32 >= v44)
          {
            v7 = 0;
            goto LABEL_77;
          }
        }
        v7 = 0;
        *(_BYTE *)(a1 + 15) = 0;
LABEL_81:
        v24 = *(_WORD *)(a1 + 10) - *(_WORD *)(a1 + 12);
        goto LABEL_82;
      }
LABEL_77:
      if (*(_BYTE *)(a1 + 15))
      {
        sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 937, "OI_STATUS AttributeListResponse(OI_BYTE_STREAM *)");
        goto LABEL_94;
      }
      goto LABEL_81;
    }
LABEL_79:
    v7 = 104;
    goto LABEL_9;
  }
  v6 = 0;
LABEL_8:
  v7 = 829;
LABEL_9:
  v8 = qword_10098FDA8;
  *(_WORD *)(qword_10098FDA8 + 66) = 0;
  v9 = *(void **)(v8 + 56);
  if (v9)
  {
    sub_100053298(v9);
    *(_QWORD *)(qword_10098FDA8 + 56) = 0;
  }
  sub_10017FAC4((unsigned __int8 *)&v45);
  if (v6)
    sub_100053298(v6);
  return v7;
}

void sub_100245F68(uint64_t a1)
{
  NSObject *v2;
  int v3;
  uint64_t v4;
  void *v5;

  if (sub_10005549C())
  {
    sub_100054530("SDP CleanupAndReportError %!", a1);
    v2 = sub_1000544A0(0x34u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1006D2728();
  }
  v3 = *(unsigned __int8 *)(qword_10098FDA8 + 32);
  if (v3 == 7 || v3 == 5 || v3 == 3)
    (*(void (**)(_QWORD, _QWORD, uint64_t))(qword_10098FDA8 + 80))(0, 0, a1);
  else
    sub_100253460();
  v4 = qword_10098FDA8;
  *(_DWORD *)qword_10098FDA8 = 1;
  *(_WORD *)(v4 + 66) = 0;
  v5 = *(void **)(v4 + 56);
  if (v5)
  {
    sub_100053298(v5);
    *(_QWORD *)(qword_10098FDA8 + 56) = 0;
  }
}

uint64_t sub_100246038(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  _BYTE *v13;
  char *v14;
  _BYTE *v15;
  char v16;

  if (*((_BYTE *)a1 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 643, "OI_STATUS UpdateContinuationState(OI_BYTE_STREAM *)");
LABEL_8:
    v6 = 1;
    *((_BYTE *)a1 + 15) = 1;
LABEL_9:
    *(_DWORD *)qword_10098FDA8 = 1;
    goto LABEL_10;
  }
  v2 = *((unsigned __int16 *)a1 + 6);
  if (*((unsigned __int16 *)a1 + 5) <= v2)
    goto LABEL_8;
  v3 = *a1;
  *((_WORD *)a1 + 6) = v2 + 1;
  v4 = *(unsigned __int8 *)(v3 + v2);
  if (!*(_BYTE *)(v3 + v2))
  {
    v6 = 0;
    goto LABEL_9;
  }
  if (v4 > 0x10)
    return 833;
  v7 = qword_10098FDA8;
  *(_BYTE *)(*(_QWORD *)(qword_10098FDA8 + 24) + *(unsigned __int16 *)(qword_10098FDA8 + 16)) = v4;
  if (*((_BYTE *)a1 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
  v8 = *(_QWORD *)(v7 + 24);
  v9 = *(unsigned __int16 *)(v7 + 16);
  v10 = *a1;
  v11 = *((unsigned __int16 *)a1 + 6);
  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 657, "OI_STATUS UpdateContinuationState(OI_BYTE_STREAM *)");
    v12 = 0;
  }
  else
  {
    v12 = *((unsigned __int16 *)a1 + 5) - (_DWORD)v11;
  }
  if (v12 >= (int)v4)
  {
    v13 = (_BYTE *)(v9 + v8 + 1);
    v14 = (char *)(v10 + v11);
    v15 = &v13[v4];
    do
    {
      v16 = *v14++;
      *v13++ = v16;
    }
    while (v13 < v15);
    *((_WORD *)a1 + 6) += v4;
    v6 = *((unsigned __int8 *)a1 + 15);
  }
  else
  {
    v6 = 1;
    *((_BYTE *)a1 + 15) = 1;
  }
  *(_WORD *)(qword_10098FDA8 + 18) = v4 + *(_WORD *)(qword_10098FDA8 + 16) + 1;
LABEL_10:
  if (v6)
    return 829;
  else
    return 0;
}

uint64_t sub_1002461E8(uint64_t a1, int a2, _WORD *a3)
{
  int v4;
  uint64_t result;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  NSObject *v14;
  unsigned __int16 v15;
  char v16;

  if (!a2)
    return 0;
  v4 = a2;
  while (1)
  {
    v16 = 0;
    v15 = 0;
    result = sub_10017E7CC(a1, &v16, (__int16 *)&v15);
    if ((_DWORD)result)
      break;
    if (v15 > (unsigned __int16)v4)
      return 843;
    if (v15 != 3 || v16 != 1)
    {
      if (sub_10005549C())
      {
        sub_100054530("Bad attribute response - expected attribute id");
        v14 = sub_1000544A0(0x34u);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
          sub_1006D3C58();
      }
      return 833;
    }
    if (*(_BYTE *)(a1 + 15))
    {
      sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 702, "OI_STATUS CheckAttributePairs(OI_BYTE_STREAM *, uint16_t, uint16_t *)");
      v8 = 0;
      v9 = v15;
    }
    else
    {
      v8 = *(unsigned __int16 *)(a1 + 10) - *(unsigned __int16 *)(a1 + 12);
      v9 = 3;
    }
    if (v8 < v9)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
    *(_WORD *)(a1 + 12) += v9;
    result = sub_10017E7CC(a1, &v16, (__int16 *)&v15);
    if ((_DWORD)result)
      return result;
    v10 = v4 - 3;
    v11 = v15;
    if (v15 > (unsigned __int16)v10)
      return 843;
    if (*(_BYTE *)(a1 + 15))
    {
      sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c", 712, "OI_STATUS CheckAttributePairs(OI_BYTE_STREAM *, uint16_t, uint16_t *)");
      v12 = 0;
      v11 = v15;
    }
    else
    {
      v12 = *(unsigned __int16 *)(a1 + 10) - *(unsigned __int16 *)(a1 + 12);
    }
    if (v12 < v11)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdp.c");
    *(_WORD *)(a1 + 12) += v11;
    if (a3)
      *a3 += 2;
    v4 = v10 - v11;
    if (!(_WORD)v4)
      return 0;
  }
  return result;
}

void sub_1002463C0(uint64_t a1, uint64_t a2)
{
  if (*(_QWORD *)(qword_10098FDA8 + 24) != a2)
    sub_100253460();
}

void sub_1002463DC()
{
  uint64_t v0;

  if ((_DWORD)xmmword_100999218)
  {
    v0 = qword_10098FDA8;
    if (*(_DWORD *)qword_10098FDA8 == 2)
    {
      sub_100245F68(832);
      v0 = qword_10098FDA8;
    }
    *(_DWORD *)(v0 + 8) = 0;
  }
}

uint64_t sub_100246428()
{
  uint64_t result;
  unsigned __int8 *v1;
  _WORD *v2;
  _WORD *v3;
  const char *v4;
  const char *v5;
  _WORD *v6;
  char *v7;
  char *v8;
  uint64_t v9;

  if (DWORD1(xmmword_100999218))
    return 140;
  qword_10098FDB8 = (uint64_t)sub_100114588(0x80uLL);
  if (!qword_10098FDB8)
    return 106;
  v1 = (unsigned __int8 *)sub_100252DE8(0x28u);
  qword_10098FDD8 = (uint64_t)sub_100114588(32 * *v1);
  word_10098FDD0 = 0;
  byte_10098FDE0 = 0;
  v2 = sub_100114588(0x50uLL);
  if (!v2)
    return 106;
  v3 = v2;
  byte_10098FDC0 = 1;
  word_10098FDC2 = 4;
  dword_10098FDC8 = 0;
  byte_10098FDE8 = 4;
  v4 = sub_10025976C();
  word_10098FDEA = strlen(v4);
  qword_10098FDF0 = (uint64_t)sub_10025976C();
  byte_10098FDF8 = 4;
  v5 = sub_100259778();
  word_10098FDFA = strlen(v5);
  qword_10098FE00 = (uint64_t)sub_100259778();
  v3[12] = 6;
  *((_QWORD *)v3 + 2) = &unk_10091F260;
  *((_BYTE *)v3 + 66) = -1;
  *((_QWORD *)v3 + 7) = 0;
  v3[32] = 0;
  *((_DWORD *)v3 + 13) = 0;
  *((_QWORD *)v3 + 9) = &unk_10073BA00;
  v6 = (_WORD *)qword_10098FDB8;
  *(_QWORD *)(qword_10098FDB8 + 120) = v3;
  *v6 = 0;
  v6[12] = 2;
  v6[24] = 8;
  v6[36] = 6;
  v6[48] = 5;
  v7 = (char *)sub_100114588(0x50uLL);
  if (!v7)
    return 106;
  v8 = v7;
  result = 0;
  *((_DWORD *)v8 + 12) = 1330184192;
  *((_QWORD *)v8 + 2) = &unk_10091F310;
  *((_WORD *)v8 + 12) = 1;
  *((_QWORD *)v8 + 4) = 0;
  *((_WORD *)v8 + 20) = 0;
  *(_QWORD *)(v8 + 52) = 0;
  *(_QWORD *)(v8 + 59) = 0;
  *((_QWORD *)v8 + 9) = &unk_10073BA00;
  v9 = qword_10098FDB8;
  *(_QWORD *)v8 = *(_QWORD *)(qword_10098FDB8 + 120);
  *(_QWORD *)(v9 + 120) = v8;
  byte_10098FDE4 = 1;
  DWORD2(xmmword_100999218) = 1;
  return result;
}

uint64_t sub_1002465CC(uint64_t a1, int *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  int v9;
  _QWORD *v10;
  _QWORD *v11;
  NSObject *v12;

  v4 = sub_100114588(0x50uLL);
  if (!v4)
    return 104;
  v5 = v4;
  v4[2] = *(_QWORD *)a1;
  *((_WORD *)v4 + 12) = *(_WORD *)(a1 + 8);
  v4[4] = *(_QWORD *)(a1 + 16);
  *((_WORD *)v4 + 20) = *(_WORD *)(a1 + 24);
  v4[7] = 0;
  *((_WORD *)v4 + 32) = 0;
  *((_BYTE *)v4 + 66) = -1;
  *((_DWORD *)v4 + 13) = 0;
  v4[9] = &unk_10091F250;
  v6 = *(unsigned __int16 *)(a1 + 8);
  if (!*(_WORD *)(a1 + 8))
    goto LABEL_14;
  v7 = *(_QWORD *)a1 + 16;
  while (*(_WORD *)(v7 - 16) != 1)
  {
    v7 += 24;
    if (!--v6)
      goto LABEL_14;
  }
  if (*(_BYTE *)(v7 - 8) == 6)
  {
    v9 = *(unsigned __int16 *)(*(_QWORD *)v7 + 8) | 0x4F490000;
    v10 = (_QWORD *)(qword_10098FDB8 + 120);
LABEL_10:
    *((_DWORD *)v4 + 12) = v9;
    v11 = v10;
    while (1)
    {
      v11 = (_QWORD *)*v11;
      if (!v11)
        break;
      if (*((_DWORD *)v11 + 12) == v9)
      {
        v9 += 0x10000;
        goto LABEL_10;
      }
    }
    if (a2)
      *a2 = v9;
    result = 0;
    *v5 = *v10;
    *v10 = v5;
    byte_10098FDC0 = 1;
    word_10098FDC2 = 4;
    ++dword_10098FDC8;
  }
  else
  {
LABEL_14:
    if (sub_10005549C())
    {
      sub_100054530("ServiceClassIDList is mandatory in an SDP service record");
      v12 = sub_1000544A0(0x36u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    sub_100053298(v5);
    return 826;
  }
  return result;
}

uint64_t sub_100246750(int a1, char a2)
{
  uint64_t v2;
  uint64_t result;

  v2 = qword_10098FDB8 + 120;
  while (1)
  {
    v2 = *(_QWORD *)v2;
    if (!v2)
      break;
    if (*(_DWORD *)(v2 + 48) == a1)
    {
      if (a1)
      {
        result = 0;
        *(_BYTE *)(v2 + 66) = a2;
        ++*(_DWORD *)(v2 + 52);
        byte_10098FDC0 = 1;
        word_10098FDC2 = 4;
        ++dword_10098FDC8;
        return result;
      }
      return 802;
    }
  }
  return 802;
}

uint64_t sub_1002467B8(int a1)
{
  _DWORD *v1;
  void **v2;
  _QWORD *v3;
  NSObject *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t result;

  if (!a1)
    return 101;
  v1 = 0;
  v2 = (void **)(qword_10098FDB8 + 120);
  do
  {
    v3 = v1;
    v1 = *v2;
    if (!*v2)
      return 802;
    v2 = (void **)*v2;
  }
  while (v1[12] != a1);
  if (*((_WORD *)v1 + 32))
  {
    if (sub_10005549C())
    {
      sub_100054530("Potential memory leak - Attribute list has not been removed");
      v4 = sub_1000544A0(0x36u);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  v5 = (_QWORD *)*((_QWORD *)v1 + 1);
  if (v5)
  {
    do
    {
      v6 = (_QWORD *)*v5;
      sub_100053298(v5);
      v5 = v6;
    }
    while (v6);
  }
  v7 = (_QWORD *)(qword_10098FDB8 + 120);
  if (v3)
    v7 = v3;
  *v7 = *(_QWORD *)v1;
  sub_100053298(v1);
  result = 0;
  byte_10098FDC0 = 1;
  word_10098FDC2 = 4;
  ++dword_10098FDC8;
  return result;
}

uint64_t sub_1002468C0()
{
  return dword_10098FDC8;
}

uint64_t sub_1002468CC(int a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  _QWORD *v6;
  uint8_t buf[4];
  void *v9;

  if (sub_10005549C())
  {
    sub_100054530("Adding SDP Legacy record for service record handle %d", a1);
    v4 = sub_1000544A0(0x36u);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v9 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  v5 = qword_10098FDB8 + 120;
  while (1)
  {
    v5 = *(_QWORD *)v5;
    if (!v5)
      break;
    if (*(_DWORD *)(v5 + 48) == a1)
      goto LABEL_9;
  }
  sub_100253460();
LABEL_9:
  v6 = sub_100114588(0x50uLL);
  v6[2] = *(_QWORD *)a2;
  *((_WORD *)v6 + 12) = *(_WORD *)(a2 + 8);
  v6[4] = *(_QWORD *)(a2 + 16);
  *((_WORD *)v6 + 20) = *(_WORD *)(a2 + 24);
  v6[7] = 0;
  *((_WORD *)v6 + 32) = 0;
  *((_BYTE *)v6 + 66) = -1;
  v6[9] = &unk_10091F250;
  *((_DWORD *)v6 + 12) = a1;
  *((_DWORD *)v6 + 13) = 0;
  *v6 = *(_QWORD *)(v5 + 8);
  *(_QWORD *)(v5 + 8) = v6;
  return 0;
}

uint64_t sub_100246A18(uint64_t a1, unsigned int a2, _WORD *a3, _DWORD *a4, uint64_t a5)
{
  uint64_t *v5;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  int v15;
  BOOL v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t result;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  unsigned int *v29;
  unint64_t v30;
  unsigned int v31;
  const char *v33;
  NSObject *v34;
  int v38;
  uint8_t buf[4];
  void *v40;

  v5 = *(uint64_t **)(qword_10098FDB8 + 120);
  if (v5)
  {
    v8 = 0;
    v9 = a2;
    do
    {
      v38 = v8 + 1;
      if ((unsigned __int16)*a3 <= (unsigned __int16)v8)
      {
        v10 = qword_10098FDB8;
        *(_BYTE *)(qword_10098FDB8 + 8) = 1;
        *(_WORD *)(v10 + 10) = 4;
        *(_DWORD *)(v10 + 16) = *((_DWORD *)v5 + 12);
        *(_BYTE *)(v10 + 32) = 1;
        *(_WORD *)(v10 + 34) = 4;
        *(_DWORD *)(v10 + 40) = *((_DWORD *)v5 + 13);
        *(_BYTE *)(v10 + 56) = 1;
        *(_WORD *)(v10 + 58) = 1;
        *(_DWORD *)(v10 + 64) = *((unsigned __int8 *)v5 + 66);
        *(_OWORD *)(v10 + 80) = unk_100978E00;
        *(_OWORD *)(v10 + 104) = *(_OWORD *)v5[9];
        if (a2)
        {
          v11 = 0;
          if (*(_WORD *)(v10 + 106))
            v12 = 5;
          else
            v12 = 4;
          while (1)
          {
            if (*((_WORD *)v5 + 12))
            {
              v13 = 1;
              v14 = 8;
              do
              {
                v15 = sub_100246D54((unsigned __int8 *)(v5[2] + v14), a1 + 16 * v11);
                if (v13 >= *((unsigned __int16 *)v5 + 12))
                  break;
                v14 += 24;
                ++v13;
              }
              while ((v15 & 1) == 0);
            }
            else
            {
              v15 = 0;
            }
            if (*((_WORD *)v5 + 32))
              v16 = v15 == 0;
            else
              v16 = 0;
            if (v16)
            {
              v17 = 1;
              v18 = 8;
              do
              {
                v15 = sub_100246D54((unsigned __int8 *)(v5[7] + v18), a1 + 16 * v11);
                if (v17 >= *((unsigned __int16 *)v5 + 32))
                  break;
                v18 += 24;
                ++v17;
              }
              while ((v15 & 1) == 0);
            }
            if (!v15)
            {
              v19 = 1;
              v20 = 8;
              do
              {
                v21 = sub_100246D54((unsigned __int8 *)(qword_10098FDB8 + v20), a1 + 16 * v11);
                if (v19 >= v12)
                  break;
                v20 += 24;
                ++v19;
              }
              while (!v21);
              if ((v21 & 1) == 0)
                break;
            }
            if (++v11 == v9)
            {
              v23 = (unsigned __int16)word_10098FDD0;
              if (!word_10098FDD0)
                goto LABEL_49;
              v24 = qword_10098FDD8;
              while (*(_QWORD *)v24 != a5)
              {
                v24 += 32;
                if (!--v23)
                  goto LABEL_49;
              }
              if (!*(_BYTE *)(v24 + 28))
                goto LABEL_49;
              v25 = *((unsigned __int16 *)v5 + 12);
              if (!*((_WORD *)v5 + 12))
                goto LABEL_49;
              v26 = 0;
              LODWORD(v27) = 0;
              v28 = (_QWORD *)(v5[2] + 16);
              do
              {
                if (*((_WORD *)v28 - 8) == 1)
                {
                  LODWORD(v27) = *((unsigned __int16 *)v28 - 3);
                  v26 = *v28;
                }
                v28 += 3;
                --v25;
              }
              while (v25);
              if (!(_DWORD)v27)
              {
LABEL_49:
                result = 0;
                *a4 = *((_DWORD *)v5 + 12);
                *a3 = v38;
                return result;
              }
              v29 = (unsigned int *)(v26 + 8);
              v27 = v27;
              while (1)
              {
                v31 = *v29;
                v29 += 4;
                v30 = v31;
                if (v31 == 4611 || (_DWORD)v30 == 4383)
                  break;
                if (!--v27)
                  goto LABEL_49;
              }
              if (sub_10005549C())
              {
                v33 = sub_100250C9C(v30);
                sub_100054530("Wireless Splitter incoming connection ignore %s profile", v33);
                v34 = sub_1000544A0(0x36u);
                if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 136446210;
                  v40 = sub_100054494();
                  _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
                }
              }
              return 823;
            }
          }
        }
      }
      v5 = (uint64_t *)*v5;
      v8 = v38;
    }
    while (v5);
  }
  return 823;
}

uint64_t sub_100246D54(unsigned __int8 *a1, uint64_t a2)
{
  int v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t result;

  v4 = *a1;
  if ((v4 - 6) >= 2)
  {
    if (v4 == 3)
      return sub_10017C904((uint64_t)a1, a2);
    return 0;
  }
  if (!*((_WORD *)a1 + 1))
    return 0;
  v5 = 0;
  v6 = *((_QWORD *)a1 + 1);
  do
  {
    result = sub_100246D54(v6, a2);
    if ((_DWORD)result)
      break;
    ++v5;
    v6 += 16;
  }
  while (v5 < *((unsigned __int16 *)a1 + 1));
  return result;
}

_QWORD *sub_100246DE8(uint64_t a1)
{
  uint64_t v1;
  _QWORD *result;

  v1 = (unsigned __int16)word_10098FDD0;
  if (!word_10098FDD0)
    return 0;
  for (result = (_QWORD *)qword_10098FDD8; *result != a1; result += 4)
  {
    if (!--v1)
      return 0;
  }
  return result;
}

void sub_100246E20(char *a1, uint64_t a2)
{
  NSObject *v4;
  unint64_t v5;
  const void **v6;
  char *v7;
  _BOOL4 v8;
  NSObject *v9;
  NSObject *v10;
  void *v11;
  uint64_t v12;
  unsigned __int16 v13;
  _OWORD *v14;
  __int128 v15;
  NSObject *v16;
  void *v17;
  uint8_t buf[4];
  void *v19;

  if (sub_10005549C())
  {
    sub_100054530("%: disconnected with reason %!", a1 + 48, a2);
    v4 = sub_1000544A0(0x36u);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v19 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if (!word_10098FDD0)
  {
LABEL_10:
    if (sub_10005549C())
    {
      sub_100054530("Could not find remote SDP record for handle: %p", a1);
      v9 = sub_1000544A0(0x36u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return;
  }
  if (*(char **)qword_10098FDD8 != a1)
  {
    v5 = 0;
    v6 = (const void **)(qword_10098FDD8 + 32);
    while ((unsigned __int16)word_10098FDD0 - 1 != v5)
    {
      v7 = (char *)*v6;
      v6 += 4;
      ++v5;
      if (v7 == a1)
      {
        v8 = v5 < (unsigned __int16)word_10098FDD0;
        goto LABEL_14;
      }
    }
    goto LABEL_10;
  }
  v5 = 0;
  v8 = 1;
LABEL_14:
  if (sub_10005549C())
  {
    sub_100054530("Deleting remote SDP record at entry %d", (unsigned __int16)v5);
    v10 = sub_1000544A0(0x36u);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      v11 = sub_100054494();
      *(_DWORD *)buf = 136446210;
      v19 = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  v12 = qword_10098FDD8 + 32 * v5;
  *(_WORD *)(v12 + 26) = 0;
  *(_QWORD *)(v12 + 8) = 0;
  *(_QWORD *)(v12 + 16) = 0;
  *(_QWORD *)v12 = 0;
  v13 = --word_10098FDD0;
  if ((unsigned __int16)word_10098FDD0 > (unsigned __int16)v5)
  {
    v14 = (_OWORD *)(v12 + 32);
    do
    {
      v15 = v14[1];
      *(v14 - 2) = *v14;
      *(v14 - 1) = v15;
      LODWORD(v5) = v5 + 1;
      v14 += 2;
    }
    while ((unsigned __int16)v5 < v13);
  }
  if (v8 && sub_10005549C())
  {
    sub_100054530("Deleted Remote SDP Record for %:", a1 + 48);
    v16 = sub_1000544A0(0x36u);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      v17 = sub_100054494();
      *(_DWORD *)buf = 136446210;
      v19 = v17;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
}

void sub_1002470CC(const void *a1, char a2)
{
  uint64_t v3;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  uint8_t buf[4];
  void *v9;

  v3 = (unsigned __int16)word_10098FDD0;
  if (word_10098FDD0)
  {
    v5 = qword_10098FDD8;
    while (*(const void **)v5 != a1)
    {
      v5 += 32;
      if (!--v3)
        goto LABEL_5;
    }
    if (sub_10005549C())
    {
      sub_100054530("Wireless Splitter SDP record for remote device with hci handle: %p already exists, updating it", *(const void **)v5);
      v7 = sub_1000544A0(0x36u);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v9 = sub_100054494();
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
    *(_BYTE *)(v5 + 28) = a2;
  }
  else
  {
LABEL_5:
    if (sub_10005549C())
    {
      sub_100054530("Wireless Splitter SDP record for remote device with hci handle: %p does not exist", a1);
      v6 = sub_1000544A0(0x36u);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v9 = sub_100054494();
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
  }
}

void sub_100247240(const void *a1, char a2)
{
  uint64_t v3;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  uint8_t buf[4];
  void *v9;

  v3 = (unsigned __int16)word_10098FDD0;
  if (word_10098FDD0)
  {
    v5 = qword_10098FDD8;
    while (*(const void **)v5 != a1)
    {
      v5 += 32;
      if (!--v3)
        goto LABEL_5;
    }
    if (sub_10005549C())
    {
      sub_100054530("SDP record for remote device with hci handle: %p already exists, updating requiresLegacyPnPInformation flag in record.", *(const void **)v5);
      v7 = sub_1000544A0(0x36u);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v9 = sub_100054494();
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
    *(_BYTE *)(v5 + 24) = a2;
  }
  else
  {
LABEL_5:
    if (sub_10005549C())
    {
      sub_100054530("SDP record for remote device with hci handle: %p does not exist", a1);
      v6 = sub_1000544A0(0x36u);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v9 = sub_100054494();
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
  }
}

uint64_t sub_1002473B4(const void *a1, int a2, __int16 a3, __int16 a4)
{
  uint64_t v8;
  _WORD *v9;
  NSObject *v10;
  unsigned int v11;
  int v12;
  NSObject *v13;
  uint64_t result;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint8_t buf[4];
  void *v24;

  v8 = (unsigned __int16)word_10098FDD0;
  if (word_10098FDD0)
  {
    v9 = (_WORD *)(qword_10098FDD8 + 14);
    while (*(const void **)(v9 - 7) != a1)
    {
      v9 += 16;
      if (!--v8)
        goto LABEL_5;
    }
    if (sub_10005549C())
    {
      sub_100054530("SDP record for remote device with hci handle: %p already exists, let's update the record", *(const void **)(v9 - 7));
      v18 = sub_1000544A0(0x36u);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v24 = sub_100054494();
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
    result = 0;
    if (a2 > 4381)
    {
      switch(a2)
      {
        case 4382:
          result = 0;
          v9[3] = a3;
          v9[4] = a4;
          break;
        case 4398:
          result = 0;
          v9[1] = a3;
          v9[2] = a4;
          break;
        case 4404:
          result = 0;
          v9[6] = a3;
          break;
      }
    }
    else if ((a2 - 4366) >= 2)
    {
      if (a2 == 4364)
      {
        result = 0;
        *(v9 - 3) = a3;
        *(v9 - 2) = a4;
      }
    }
    else
    {
      result = 0;
      *(v9 - 1) = a3;
      *v9 = a4;
    }
  }
  else
  {
LABEL_5:
    if (sub_10005549C())
    {
      sub_100054530("SDP record for remote device with hci handle: %p does not exist, creating one", a1);
      v10 = sub_1000544A0(0x36u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v24 = sub_100054494();
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
    v11 = (unsigned __int16)word_10098FDD0;
    if (v11 >= *(unsigned __int8 *)sub_100252DE8(0x28u))
      sub_100253460();
    v12 = (unsigned __int16)word_10098FDD0;
    if (v12 == *(unsigned __int8 *)sub_100252DE8(0x28u))
    {
      if (sub_10005549C())
      {
        sub_100054530("No room to add another SDP remote record for connection %p. Total number of SDP remote records : %d", (const void *)(unsigned __int16)word_10098FDD0, v22);
        v13 = sub_1000544A0(0x36u);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
          sub_1006D1FB0(v13);
      }
      return 104;
    }
    else
    {
      v15 = qword_10098FDD8;
      v16 = (unsigned __int16)word_10098FDD0;
      *(_QWORD *)(qword_10098FDD8 + 32 * (unsigned __int16)word_10098FDD0) = a1;
      if (a2 > 4381)
      {
        switch(a2)
        {
          case 4382:
            v20 = v15 + 32 * v16;
            *(_WORD *)(v20 + 20) = a3;
            *(_WORD *)(v20 + 22) = a4;
            break;
          case 4398:
            v21 = v15 + 32 * v16;
            *(_WORD *)(v21 + 16) = a3;
            *(_WORD *)(v21 + 18) = a4;
            break;
          case 4404:
            *(_WORD *)(v15 + 32 * v16 + 26) = a3;
            break;
        }
      }
      else if ((a2 - 4366) >= 2)
      {
        if (a2 == 4364)
        {
          v19 = v15 + 32 * v16;
          *(_WORD *)(v19 + 8) = a3;
          *(_WORD *)(v19 + 10) = a4;
        }
      }
      else
      {
        v17 = v15 + 32 * v16;
        *(_WORD *)(v17 + 12) = a3;
        *(_WORD *)(v17 + 14) = a4;
      }
      result = 0;
      word_10098FDD0 = v16 + 1;
    }
  }
  return result;
}

uint64_t sub_100247708(uint64_t result)
{
  byte_10098FDE0 = result;
  return result;
}

uint64_t sub_100247714(int a1, uint64_t a2, unsigned int a3, unsigned __int16 *a4, __int16 **a5, uint64_t a6)
{
  _WORD *v6;
  unsigned int v7;
  unsigned int v10;
  _QWORD *v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  unsigned __int16 *v21;
  __int16 **v22;
  NSObject *v23;
  unint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t *v28;
  unsigned __int16 *v29;
  uint64_t *v30;
  uint64_t *v31;
  unsigned __int16 *v32;
  unsigned __int16 *v33;
  int v34;
  uint64_t v35;
  int v36;
  unsigned int v37;
  __int16 **v38;
  int v39;
  __int16 *v40;
  uint64_t *v41;
  unsigned __int16 *v42;
  int v43;
  uint64_t v44;
  unsigned __int16 v45;
  _WORD *v46;
  unsigned int v47;
  unsigned int v48;
  uint64_t result;
  char v50;
  unsigned int v51;
  uint64_t v52;
  int *v53;
  int v54;
  int v55;
  NSObject *v56;
  void *v57;
  NSObject *v58;
  void *v59;
  _QWORD *v60;
  _QWORD *v61;
  unsigned __int16 v62;
  uint64_t v63;
  uint64_t v64;
  unsigned int v65;
  char **v66;
  const char *v67;
  __int16 **v68;
  __int16 v69;
  __int16 **v71;
  uint8_t buf[4];
  void *v74;

  v6 = a4;
  v7 = a3;
  v10 = *a4;
  v11 = &unk_10098F000;
  v12 = qword_10098FDB8 + 120;
  if (byte_10098FDE0)
  {
    while (1)
    {
      v12 = *(_QWORD *)v12;
      if (!v12)
        return 802;
      if (*(_DWORD *)(v12 + 48) == a1)
        goto LABEL_28;
    }
  }
  do
  {
    v12 = *(_QWORD *)v12;
    if (!v12)
    {
      if (sub_10005549C())
      {
        sub_100054530("Could not find record for service handle %u", a1);
        v13 = sub_1000544A0(0x36u);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      return 802;
    }
  }
  while (*(_DWORD *)(v12 + 48) != a1);
  v14 = *(unsigned __int16 *)(v12 + 24);
  if (*(_WORD *)(v12 + 24))
  {
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v18 = *(_QWORD *)(v12 + 16) + 16;
    do
    {
      v19 = *(unsigned __int16 *)(v18 - 16);
      if (v19 == 9)
      {
        v17 = *(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)v18 + 8) + 24);
      }
      else if (v19 == 1)
      {
        v16 = *(unsigned __int16 *)(v18 - 6);
        v15 = *(_QWORD *)v18;
      }
      v18 += 24;
      --v14;
    }
    while (v14);
  }
  else
  {
    v17 = 0;
    v16 = 0;
    v15 = 0;
  }
  v20 = (unsigned __int16)word_10098FDD0;
  if (!word_10098FDD0)
  {
LABEL_23:
    v22 = a5;
    if (sub_10005549C())
    {
      sub_100054530("No remote SDP record found for device. Returning SDP record with profile version %x", v17);
      v23 = sub_1000544A0(0x36u);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    a5 = v22;
LABEL_27:
    if (v12)
      goto LABEL_28;
    return 802;
  }
  v21 = (unsigned __int16 *)(qword_10098FDD8 + 16);
  while (*((_QWORD *)v21 - 2) != a6)
  {
    v21 += 16;
    if (!--v20)
      goto LABEL_23;
  }
  if (!v16)
    goto LABEL_27;
  v50 = 0;
  v51 = 0;
  v52 = v16;
  v53 = (int *)(v15 + 8);
  v71 = a5;
  do
  {
    v55 = *v53;
    v53 += 4;
    v54 = v55;
    if (v55 <= 4398)
    {
      switch(v54)
      {
        case 4364:
          v51 = *(v21 - 2);
          if (!*(v21 - 2))
            v51 = *(v21 - 4);
          break;
        case 4367:
          v51 = *(v21 - 4);
          if (!*(v21 - 4))
            v51 = *(v21 - 2);
          break;
        case 4383:
          v51 = v21[2];
          break;
        default:
          goto LABEL_96;
      }
      goto LABEL_95;
    }
    switch(v54)
    {
      case 4399:
        v51 = *v21;
LABEL_95:
        v50 = 1;
        break;
      case 4402:
        v51 = v21[5];
        goto LABEL_95;
      case 4608:
        if (sub_10005549C())
        {
          sub_100054530("Service class ID is OI_UUID_PnPInformation, so check if we need to send legacy PnPInformation record");
          v56 = sub_1000544A0(0x36u);
          if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
          {
            v57 = sub_100054494();
            *(_DWORD *)buf = 136446210;
            v74 = v57;
            _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
          }
        }
        v50 = *((_BYTE *)v21 + 8);
        if (v50)
        {
          if (sub_10005549C())
          {
            sub_100054530("Need to send legacy PnPInformation record to remote");
            v58 = sub_1000544A0(0x36u);
            if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
            {
              v59 = sub_100054494();
              *(_DWORD *)buf = 136446210;
              v74 = v59;
              _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
            }
          }
          v50 = 0;
          v12 = *(_QWORD *)(v12 + 8);
        }
        a5 = v71;
        v6 = a4;
        break;
    }
LABEL_96:
    --v52;
  }
  while (v52);
  v11 = (_QWORD *)&unk_10098F000;
  if (!v51 || v17 <= v51)
  {
    v7 = a3;
    goto LABEL_27;
  }
  if ((v50 & 1) != 0)
  {
    v60 = *(_QWORD **)(v12 + 8);
    if (v60)
    {
      v61 = 0;
      v62 = -1;
      do
      {
        if (*(_WORD *)(v12 + 24))
        {
          v63 = v60[2] + 16;
          v64 = *(unsigned __int16 *)(v12 + 24);
          do
          {
            if (*(_WORD *)(v63 - 16) == 9)
            {
              v65 = *(unsigned __int16 *)(*(_QWORD *)(*(_QWORD *)v63 + 8) + 24);
              if (v65 <= v51)
              {
                if ((int)(v51 - v65) <= v62)
                {
                  v61 = v60;
                  v62 = v51 - v65;
                }
              }
              else if ((int)(v65 - v51) < v62)
              {
                v61 = v60;
                v62 = v65 - v51;
              }
            }
            v63 += 24;
            --v64;
          }
          while (v64);
        }
        v60 = (_QWORD *)*v60;
      }
      while (v60);
    }
    else
    {
      v61 = 0;
    }
    if (v61)
      v12 = (uint64_t)v61;
  }
  v7 = a3;
  if (!v12)
  {
    sub_100253460();
    return 802;
  }
LABEL_28:
  v24 = v7;
  v25 = v11[439];
  *(_BYTE *)(v25 + 8) = 1;
  *(_WORD *)(v25 + 10) = 4;
  *(_DWORD *)(v25 + 16) = *(_DWORD *)(v12 + 48);
  *(_BYTE *)(v25 + 32) = 1;
  *(_WORD *)(v25 + 34) = 4;
  *(_DWORD *)(v25 + 40) = *(_DWORD *)(v12 + 52);
  *(_BYTE *)(v25 + 56) = 1;
  *(_WORD *)(v25 + 58) = 1;
  *(_DWORD *)(v25 + 64) = *(unsigned __int8 *)(v12 + 66);
  *(_OWORD *)(v25 + 80) = unk_100978E00;
  *(_OWORD *)(v25 + 104) = *(_OWORD *)*(_QWORD *)(v12 + 72);
  if (*(_WORD *)(v25 + 106))
    v26 = 5;
  else
    v26 = 4;
  if (!v7)
  {
LABEL_68:
    *a5 = 0;
    *v6 = 0;
    return 826;
  }
  v27 = 0;
  v28 = (uint64_t *)(v12 + 56);
  v29 = (unsigned __int16 *)(v12 + 64);
  v30 = (uint64_t *)(v12 + 32);
  v31 = (uint64_t *)(v12 + 16);
  v32 = (unsigned __int16 *)(v12 + 40);
  v33 = (unsigned __int16 *)(v12 + 24);
  if (byte_10098FDE4)
    v34 = 1330184192;
  else
    v34 = 0;
  while (2)
  {
    if (*(_BYTE *)(a2 + 16 * v27) != 1)
      return 825;
    v35 = a2 + 16 * v27;
    v36 = *(unsigned __int16 *)(v35 + 2);
    if (v36 == 4)
    {
      LODWORD(v38) = *(_DWORD *)(v35 + 8);
      v37 = v38 >> 16;
    }
    else
    {
      if (v36 != 2)
        return 825;
      v37 = *(unsigned __int16 *)(a2 + 16 * v27 + 8);
      LOWORD(v38) = *(_WORD *)(a2 + 16 * v27 + 8);
    }
    if (v10 > (unsigned __int16)v38)
    {
LABEL_67:
      if (++v27 >= v24)
        goto LABEL_68;
      continue;
    }
    break;
  }
  v39 = 0;
  v40 = 0;
  if (v37 <= v10)
    v37 = v10;
  do
  {
    v41 = v31;
    v42 = v33;
    v43 = v26;
    v44 = v25;
    switch(v39)
    {
      case 0:
        goto LABEL_48;
      case 1:
        goto LABEL_46;
      case 2:
        v41 = v30;
        v42 = v32;
        goto LABEL_46;
      case 3:
        v41 = v28;
        v42 = v29;
LABEL_46:
        v44 = *v41;
        v43 = *v42;
        break;
      default:
        break;
    }
    if (v43 >= 1)
    {
LABEL_48:
      v45 = 0;
      while (1)
      {
        v46 = (_WORD *)(v44 + 24 * v45);
        v47 = (unsigned __int16)*v46;
        if (v37 <= v47 && v47 <= (unsigned __int16)v38)
        {
          v40 = (__int16 *)(v44 + 24 * v45);
          LOWORD(v38) = *v46;
          if (v37 == v47)
            break;
        }
        if (v43 <= ++v45)
          goto LABEL_55;
      }
      v40 = (__int16 *)(v44 + 24 * v45);
      LOWORD(v38) = *v46;
    }
LABEL_55:
    ++v39;
  }
  while (v39 != 4);
  if (!v40)
  {
    if (v34 == a1 && v24 == 1 && *(_BYTE *)a2 == 1 && *(_WORD *)(a2 + 2) == 4 && HIWORD(*(_DWORD *)(a2 + 8)) == 1024)
    {
      v48 = (unsigned __int16)*v6;
      if ((unsigned __int16)*(_DWORD *)(a2 + 8) >= v48)
      {
        LODWORD(v38) = v48 <= 0x400 ? 1024 : (unsigned __int16)*v6;
        if (((_DWORD)v38 - 1024) < 0x25)
        {
          v40 = &word_10098FE08;
          word_10098FE08 = (__int16)v38;
          byte_10098FE10 = 6;
          word_10098FE12 = 2;
          qword_10098FE18 = (uint64_t)&byte_10098FE20;
          byte_10098FE20 = 4;
          v66 = &(&off_10091F988)[2 * ((_DWORD)v38 - 1024)];
          v67 = *v66;
          v68 = a5;
          v69 = strlen(*v66);
          a5 = v68;
          word_10098FE22 = v69;
          qword_10098FE28 = (uint64_t)v67;
          byte_10098FE30 = 1;
          word_10098FE32 = 2;
          dword_10098FE38 = *((unsigned __int16 *)v66 + 4);
          goto LABEL_116;
        }
      }
    }
    goto LABEL_67;
  }
  if ((unsigned __int16)*v40 != (unsigned __int16)v38)
  {
    v38 = a5;
    sub_100253460();
    a5 = v38;
    LOWORD(v38) = *v40;
  }
LABEL_116:
  result = 0;
  *a5 = v40;
  *v6 = (_WORD)v38 + 1;
  return result;
}

uint64_t sub_100247E54(uint64_t *a1, char *a2)
{
  char *v2;
  uint64_t v4;
  char v5;
  uint64_t v6;
  uint64_t v7;
  __int16 v8;
  unsigned __int16 v9;
  int v10;
  uint64_t v11;
  int v12;
  __int16 v13;
  uint64_t v14;
  const void *v15;
  int v16;
  char v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  int v24;
  size_t v25;

  v2 = a2;
  if (*a2 == 32)
    v2 = (char *)*((_QWORD *)a2 + 1);
  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1532, "_Bool OI_DataElement_Serialize(OI_BYTE_STREAM *, const OI_DATAELEM *)");
    goto LABEL_77;
  }
  v4 = *((unsigned __int16 *)a1 + 6);
  if (*((unsigned __int16 *)a1 + 5) <= v4 || *((_BYTE *)a1 + 14) != 2)
LABEL_77:
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
  v5 = *v2;
  v6 = *a1;
  *((_WORD *)a1 + 6) = v4 + 1;
  *(_BYTE *)(v6 + v4) = v5;
  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1533, "_Bool OI_DataElement_Serialize(OI_BYTE_STREAM *, const OI_DATAELEM *)");
    goto LABEL_79;
  }
  v7 = *((unsigned __int16 *)a1 + 6);
  if (*((unsigned __int16 *)a1 + 5) - (int)v7 <= 1 || *((_BYTE *)a1 + 14) != 2)
LABEL_79:
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
  *(_BYTE *)(*a1 + v7) = v2[2];
  *(_BYTE *)(*a1 + *((unsigned __int16 *)a1 + 6) + 1) = v2[3];
  v8 = *((_WORD *)a1 + 6);
  v9 = v8 + 2;
  *((_WORD *)a1 + 6) = v8 + 2;
  switch(*v2)
  {
    case 0:
      return 1;
    case 1:
      v10 = *((unsigned __int16 *)v2 + 1);
      if (v10 != 16)
      {
        if (v10 == 8)
        {
          if (*((_BYTE *)a1 + 15))
          {
            sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1542, "_Bool OI_DataElement_Serialize(OI_BYTE_STREAM *, const OI_DATAELEM *)");
            goto LABEL_89;
          }
          v11 = v9;
          if (*((unsigned __int16 *)a1 + 5) - (unint64_t)v9 <= 7 || *((_BYTE *)a1 + 14) != 2)
LABEL_89:
            sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
          goto LABEL_21;
        }
        if (*((_BYTE *)a1 + 15))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1546, "_Bool OI_DataElement_Serialize(OI_BYTE_STREAM *, const OI_DATAELEM *)");
          goto LABEL_95;
        }
        if (*((unsigned __int16 *)a1 + 5) - v9 <= 3 || *((_BYTE *)a1 + 14) != 2)
LABEL_95:
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
LABEL_73:
        *(_BYTE *)(*a1 + v9) = *((_DWORD *)v2 + 2);
        *(_BYTE *)(*a1 + *((unsigned __int16 *)a1 + 6) + 1) = BYTE1(*((_DWORD *)v2 + 2));
        *(_BYTE *)(*a1 + *((unsigned __int16 *)a1 + 6) + 2) = *((_WORD *)v2 + 5);
        *(_BYTE *)(*a1 + *((unsigned __int16 *)a1 + 6) + 3) = v2[11];
        v13 = *((_WORD *)a1 + 6) + 4;
        goto LABEL_74;
      }
      if (*((_BYTE *)a1 + 15))
      {
        sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1544, "_Bool OI_DataElement_Serialize(OI_BYTE_STREAM *, const OI_DATAELEM *)");
        goto LABEL_93;
      }
      if (*((unsigned __int16 *)a1 + 5) - (unint64_t)v9 <= 0xF || *((_BYTE *)a1 + 14) != 2)
LABEL_93:
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
      goto LABEL_69;
    case 2:
      v12 = *((unsigned __int16 *)v2 + 1);
      if (v12 != 16)
      {
        if (v12 == 8)
        {
          if (*((_BYTE *)a1 + 15))
          {
            sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1552, "_Bool OI_DataElement_Serialize(OI_BYTE_STREAM *, const OI_DATAELEM *)");
          }
          else
          {
            v11 = v9;
            if (*((unsigned __int16 *)a1 + 5) - (unint64_t)v9 > 7 && *((_BYTE *)a1 + 14) == 2)
            {
LABEL_21:
              *(_QWORD *)(*a1 + v11) = **((_QWORD **)v2 + 1);
              v13 = *((_WORD *)a1 + 6) + 8;
LABEL_74:
              *((_WORD *)a1 + 6) = v13;
              return 1;
            }
          }
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
        }
        if (*((_BYTE *)a1 + 15))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1556, "_Bool OI_DataElement_Serialize(OI_BYTE_STREAM *, const OI_DATAELEM *)");
        }
        else if (*((unsigned __int16 *)a1 + 5) - v9 > 3 && *((_BYTE *)a1 + 14) == 2)
        {
          goto LABEL_73;
        }
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
      }
      if (*((_BYTE *)a1 + 15))
      {
        sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1554, "_Bool OI_DataElement_Serialize(OI_BYTE_STREAM *, const OI_DATAELEM *)");
      }
      else if (*((unsigned __int16 *)a1 + 5) - (unint64_t)v9 > 0xF && *((_BYTE *)a1 + 14) == 2)
      {
LABEL_69:
        *(_OWORD *)(*a1 + v9) = *(_OWORD *)*((_QWORD *)v2 + 1);
        v13 = *((_WORD *)a1 + 6) + 16;
        goto LABEL_74;
      }
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
    case 3:
      if (*((_WORD *)v2 + 1) != 16)
      {
        if (*((_BYTE *)a1 + 15))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1564, "_Bool OI_DataElement_Serialize(OI_BYTE_STREAM *, const OI_DATAELEM *)");
        }
        else if (*((unsigned __int16 *)a1 + 5) - v9 > 3 && *((_BYTE *)a1 + 14) == 2)
        {
          goto LABEL_73;
        }
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
      }
      if (*((_BYTE *)a1 + 15))
      {
        sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1562, "_Bool OI_DataElement_Serialize(OI_BYTE_STREAM *, const OI_DATAELEM *)");
      }
      else if (*((unsigned __int16 *)a1 + 5) - (unint64_t)(unsigned __int16)(v8 + 2) > 0xF
             && *((_BYTE *)a1 + 14) == 2)
      {
        goto LABEL_69;
      }
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
    case 4:
      v14 = *a1;
      v15 = (const void *)*((_QWORD *)v2 + 1);
      if (*((_BYTE *)a1 + 15))
      {
        sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1569, "_Bool OI_DataElement_Serialize(OI_BYTE_STREAM *, const OI_DATAELEM *)");
        v16 = 0;
      }
      else
      {
        v16 = *((unsigned __int16 *)a1 + 5) - v9;
      }
      v25 = *((unsigned __int16 *)v2 + 1);
      if (v16 < (int)v25 || *((_BYTE *)a1 + 14) != 2)
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
      goto LABEL_57;
    case 5:
      if (*((_BYTE *)a1 + 15))
      {
        sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1573, "_Bool OI_DataElement_Serialize(OI_BYTE_STREAM *, const OI_DATAELEM *)");
        goto LABEL_81;
      }
      if (*((unsigned __int16 *)a1 + 5) <= v9 || *((_BYTE *)a1 + 14) != 2)
LABEL_81:
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
      v17 = v2[8];
      v18 = *a1;
      *((_WORD *)a1 + 6) = v8 + 3;
      *(_BYTE *)(v18 + (unsigned __int16)(v8 + 2)) = v17;
      return 1;
    case 6:
      if (!*((_WORD *)v2 + 1))
        return 1;
      v19 = 0;
      v20 = 0;
      while ((sub_100247E54(a1, *((_QWORD *)v2 + 1) + v19) & 1) != 0)
      {
        ++v20;
        v19 += 16;
        if (v20 >= *((unsigned __int16 *)v2 + 1))
          return 1;
      }
      return 0;
    case 7:
      if (!*((_WORD *)v2 + 1))
        return 1;
      v21 = 0;
      v22 = 0;
      while ((sub_100247E54(a1, *((_QWORD *)v2 + 1) + v21) & 1) != 0)
      {
        ++v22;
        v21 += 16;
        if (v22 >= *((unsigned __int16 *)v2 + 1))
          return 1;
      }
      return 0;
    case 8:
      v14 = *a1;
      v15 = (const void *)*((_QWORD *)v2 + 1);
      if (*((_BYTE *)a1 + 15))
      {
        sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1596, "_Bool OI_DataElement_Serialize(OI_BYTE_STREAM *, const OI_DATAELEM *)");
        v24 = 0;
      }
      else
      {
        v24 = *((unsigned __int16 *)a1 + 5) - v9;
      }
      v25 = *((unsigned __int16 *)v2 + 1);
      if (v24 < (int)v25 || *((_BYTE *)a1 + 14) != 2)
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
LABEL_57:
      memmove((void *)(v14 + v9), v15, v25);
      v13 = *((_WORD *)a1 + 6) + *((_WORD *)v2 + 1);
      goto LABEL_74;
    default:
      return 0;
  }
}

uint64_t sub_100248604(uint64_t a1)
{
  uint64_t v2;
  uint64_t *v3;
  __int16 v4;
  uint64_t v5;
  char *v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  unsigned __int16 v14;
  uint64_t v15;
  unint64_t i;
  int v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  char v22;

  if (!a1)
    return 101;
  if (*(_BYTE *)(a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1612, "OI_STATUS OI_SDPDB_LocalDatabase(OI_BYTE_STREAM *)");
    goto LABEL_54;
  }
  v2 = *(unsigned __int16 *)(a1 + 12);
  if (*(unsigned __int16 *)(a1 + 10) - (int)v2 <= 1 || *(_BYTE *)(a1 + 14) != 2)
LABEL_54:
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
  *(_BYTE *)(*(_QWORD *)a1 + v2) = 0;
  *(_BYTE *)(*(_QWORD *)a1 + *(unsigned __int16 *)(a1 + 12) + 1) = 0;
  *(_WORD *)(a1 + 12) += 2;
  v3 = *(uint64_t **)(qword_10098FDB8 + 120);
  if (!v3)
  {
    LOBYTE(v4) = 0;
    v22 = 0;
LABEL_45:
    result = 0;
    **(_BYTE **)a1 = v4;
    *(_BYTE *)(*(_QWORD *)a1 + 1) = v22;
    return result;
  }
  v4 = 0;
LABEL_7:
  v5 = *((unsigned __int16 *)v3 + 12);
  if (!*((_WORD *)v3 + 12))
    goto LABEL_13;
  v6 = (char *)(v3[2] + 8);
  while (*((_WORD *)v6 - 4) != 1)
  {
    v6 += 24;
    if (!--v5)
      goto LABEL_13;
  }
  result = sub_100247E54((uint64_t *)a1, v6);
  if ((_DWORD)result)
  {
LABEL_13:
    if (*(_BYTE *)(a1 + 15))
    {
      sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1629, "OI_STATUS OI_SDPDB_LocalDatabase(OI_BYTE_STREAM *)");
    }
    else
    {
      v8 = *(unsigned __int16 *)(a1 + 12);
      if (*(unsigned __int16 *)(a1 + 10) - (int)v8 > 1 && *(_BYTE *)(a1 + 14) == 2)
      {
        v9 = 0;
        *(_BYTE *)(*(_QWORD *)a1 + *(unsigned __int16 *)(a1 + 12)) = 0;
        ++v4;
        *(_BYTE *)(*(_QWORD *)a1 + *(unsigned __int16 *)(a1 + 12) + 1) = 0;
        *(_WORD *)(a1 + 12) += 2;
        v10 = qword_10098FDB8;
        *(_BYTE *)(qword_10098FDB8 + 8) = 1;
        *(_WORD *)(v10 + 10) = 4;
        *(_DWORD *)(v10 + 16) = *((_DWORD *)v3 + 12);
        *(_BYTE *)(v10 + 32) = 1;
        *(_WORD *)(v10 + 34) = 4;
        *(_DWORD *)(v10 + 40) = *((_DWORD *)v3 + 13);
        *(_BYTE *)(v10 + 56) = 1;
        *(_WORD *)(v10 + 58) = 1;
        *(_DWORD *)(v10 + 64) = *((unsigned __int8 *)v3 + 66);
        *(_OWORD *)(v10 + 80) = unk_100978E00;
        *(_OWORD *)(v10 + 104) = *(_OWORD *)v3[9];
        if (*(_WORD *)(v10 + 106))
          v11 = 5;
        else
          v11 = 4;
        while (1)
        {
          if (*(_BYTE *)(a1 + 15))
          {
            sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1634, "OI_STATUS OI_SDPDB_LocalDatabase(OI_BYTE_STREAM *)");
LABEL_48:
            sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
          }
          v12 = *(unsigned __int16 *)(a1 + 12);
          if (*(unsigned __int16 *)(a1 + 10) - (int)v12 <= 1 || *(_BYTE *)(a1 + 14) != 2)
            goto LABEL_48;
          v13 = qword_10098FDB8 + v9;
          *(_BYTE *)(*(_QWORD *)a1 + v12) = *(_BYTE *)(qword_10098FDB8 + v9);
          *(_BYTE *)(*(_QWORD *)a1 + *(unsigned __int16 *)(a1 + 12) + 1) = *(_BYTE *)(v13 + 1);
          *(_WORD *)(a1 + 12) += 2;
          if ((sub_100247E54((uint64_t *)a1, (char *)(v13 + 8)) & 1) == 0)
            return 0;
          v9 += 24;
          if (24 * v11 == v9)
          {
            v14 = *((_WORD *)v3 + 12);
            if (v14)
            {
              v15 = 0;
              for (i = 0; i < v14; ++i)
              {
                v17 = *(unsigned __int16 *)(v3[2] + v15);
                if (v17 != 1)
                {
                  if (*(_BYTE *)(a1 + 15))
                  {
                    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1646, "OI_STATUS OI_SDPDB_LocalDatabase(OI_BYTE_STREAM *)");
LABEL_52:
                    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
                  }
                  v18 = *(unsigned __int16 *)(a1 + 12);
                  if (*(unsigned __int16 *)(a1 + 10) - (int)v18 <= 1 || *(_BYTE *)(a1 + 14) != 2)
                    goto LABEL_52;
                  *(_BYTE *)(*(_QWORD *)a1 + v18) = v17;
                  *(_BYTE *)(*(_QWORD *)a1 + *(unsigned __int16 *)(a1 + 12) + 1) = *(_BYTE *)(v3[2] + v15 + 1);
                  *(_WORD *)(a1 + 12) += 2;
                  result = sub_100247E54((uint64_t *)a1, (char *)(v3[2] + v15 + 8));
                  if (!(_DWORD)result)
                    return result;
                  LOWORD(v11) = v11 + 1;
                  v14 = *((_WORD *)v3 + 12);
                }
                v15 += 24;
              }
            }
            if (*((_WORD *)v3 + 32))
            {
              v19 = 0;
              v20 = 0;
              do
              {
                if (*(_BYTE *)(a1 + 15))
                {
                  sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c", 1654, "OI_STATUS OI_SDPDB_LocalDatabase(OI_BYTE_STREAM *)");
LABEL_50:
                  sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
                }
                v21 = *(unsigned __int16 *)(a1 + 12);
                if (*(unsigned __int16 *)(a1 + 10) - (int)v21 <= 1 || *(_BYTE *)(a1 + 14) != 2)
                  goto LABEL_50;
                *(_BYTE *)(*(_QWORD *)a1 + v21) = *(_BYTE *)(v3[7] + v19);
                *(_BYTE *)(*(_QWORD *)a1 + *(unsigned __int16 *)(a1 + 12) + 1) = *(_BYTE *)(v3[7] + v19 + 1);
                *(_WORD *)(a1 + 12) += 2;
                if ((sub_100247E54((uint64_t *)a1, (char *)(v3[7] + v19 + 8)) & 1) == 0)
                  return 0;
                ++v20;
                v19 += 24;
                LOWORD(v11) = v11 + 1;
              }
              while (v20 < *((unsigned __int16 *)v3 + 32));
            }
            *(_WORD *)(*(_QWORD *)a1 + v8) = v11;
            v3 = (uint64_t *)*v3;
            if (!v3)
            {
              v22 = HIBYTE(v4);
              goto LABEL_45;
            }
            goto LABEL_7;
          }
        }
      }
    }
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpdb.c");
  }
  return result;
}

uint64_t sub_100248B0C(uint64_t a1)
{
  NSObject *v2;
  uint64_t result;
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  unsigned int v6;

  if (a1)
  {
    if (sub_10005549C())
    {
      sub_100054530("OI_SDPServer_Init: configuration parameter is deprecated");
      v2 = sub_1000544A0(0x35u);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    sub_100252E2C(a1, 0x35u);
  }
  if (DWORD1(xmmword_100999218))
    return 140;
  v4 = (unsigned __int8 *)sub_100252DE8(0x35u);
  if (!v4)
  {
    sub_100253460();
    return 127;
  }
  v5 = v4;
  v6 = *v4;
  if (!*v4)
    goto LABEL_17;
  if (*((unsigned __int16 *)v4 + 1) <= 0xFu)
  {
    sub_100253460();
    if (*((unsigned __int16 *)v5 + 1) < 0x10u)
      return 101;
    v6 = *v5;
  }
  xmmword_10098FE40 = 0u;
  *(_OWORD *)&qword_10098FE50 = 0u;
  *((_QWORD *)&xmmword_10098FE40 + 1) = sub_100114588(32 * v6);
  if (!*((_QWORD *)&xmmword_10098FE40 + 1))
    return 106;
  *(_QWORD *)&xmmword_10098FE40 = sub_100252DE8(0x35u);
  result = sub_100246428();
  if (!(_DWORD)result)
  {
    result = sub_1001E3870(1, (uint64_t)sub_10024928C);
    if (!(_DWORD)result)
    {
LABEL_17:
      result = 0;
      DWORD1(xmmword_100999218) = 1;
    }
  }
  return result;
}

uint64_t sub_100248C3C(uint64_t a1)
{
  uint64_t result;

  if (!DWORD1(xmmword_100999218))
    return 103;
  result = 0;
  qword_10098FE50 = a1;
  return result;
}

void sub_100248C68(int a1, unsigned int a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  __int16 *v7;
  NSObject *v8;
  unsigned int v9;
  __int16 v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  __int128 v14;
  __int128 v15;
  uint8_t buf[4];
  void *v17;

  v14 = 0u;
  v15 = 0u;
  if (sub_10005549C())
  {
    sub_100054530("SDPSERVER OI_SDPSRV_RespondToStalledIncomingRequest: stalled cid is %u, accept: %d", a2, a1);
    v4 = sub_1000544A0(0x35u);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v17 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  v5 = xmmword_10098FE40;
  v6 = *(unsigned __int8 *)xmmword_10098FE40;
  if (!*(_BYTE *)xmmword_10098FE40)
  {
LABEL_9:
    if (sub_10005549C())
    {
      sub_100054530("stalled sdpclient is NULL");
      v8 = sub_1000544A0(0x35u);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return;
  }
  v7 = (__int16 *)(*((_QWORD *)&xmmword_10098FE40 + 1) + 4);
  while (!*((_BYTE *)v7 - 2) || (unsigned __int16)*(v7 - 2) != a2)
  {
    v7 += 16;
    if (!--v6)
      goto LABEL_9;
  }
  if (a1)
  {
    *((_BYTE *)v7 - 2) = 1;
    v9 = *(unsigned __int16 *)(v5 + 4);
    *v7 = v9;
    if (v9 > 0x80)
    {
      if (v9 <= *(unsigned __int16 *)(sub_100252DE8(0x28u) + 8))
      {
        v10 = *v7;
        goto LABEL_19;
      }
      v10 = *(_WORD *)(sub_100252DE8(0x28u) + 8);
    }
    else
    {
      v10 = 128;
    }
    *v7 = v10;
LABEL_19:
    *((_QWORD *)&v14 + 1) = 0;
    v15 = 0uLL;
    LOWORD(v14) = v10;
    *(_DWORD *)((char *)&v14 + 2) = 327745535;
    WORD3(v14) = 772;
  }
  v11 = sub_1001DDCAC((uint64_t)sub_100248EB0, (uint64_t)sub_100248F40, (uint64_t)sub_100249010, a2, (uint64_t)&v14, a1, (uint64_t)&unk_10073BA80);
  if ((_DWORD)v11)
  {
    v12 = v11;
    if (sub_10005549C())
    {
      sub_100054530("SDPServer: L2CAP failed to complete the connection %!", v12);
      v13 = sub_1000544A0(0x35u);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    *((_BYTE *)v7 - 2) = 0;
  }
}

void sub_100248EB0(uint64_t a1, unsigned int a2, unsigned int a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  _WORD *v6;
  unsigned int v7;

  if (a4)
  {
    sub_100248F40(a1);
  }
  else
  {
    v4 = xmmword_10098FE40;
    v5 = *(unsigned __int8 *)xmmword_10098FE40;
    if (*(_BYTE *)xmmword_10098FE40)
    {
      v6 = (_WORD *)(*((_QWORD *)&xmmword_10098FE40 + 1) + 6);
      while (!*((_BYTE *)v6 - 4) || (unsigned __int16)*(v6 - 3) != (_DWORD)a1)
      {
        v6 += 16;
        if (!--v5)
          goto LABEL_8;
      }
    }
    else
    {
LABEL_8:
      sub_100253460();
      __break(1u);
    }
    if ((unsigned __int16)*(v6 - 1) >= a2)
    {
      v7 = *(unsigned __int16 *)(v4 + 2);
      if (v7 <= a3)
        *v6 = v7;
      else
        *v6 = a3;
    }
    else
    {
      sub_100249580(a1);
    }
  }
}

void sub_100248F40(int a1)
{
  uint64_t v2;
  unsigned __int16 *v3;
  uint64_t v4;
  void (*v5)(unsigned __int16 *);
  void **i;

  LODWORD(v2) = *(unsigned __int8 *)xmmword_10098FE40;
  if (*(_BYTE *)xmmword_10098FE40)
  {
    v3 = (unsigned __int16 *)*((_QWORD *)&xmmword_10098FE40 + 1);
    v4 = *(unsigned __int8 *)xmmword_10098FE40;
    while (!*((_BYTE *)v3 + 2) || *v3 != a1)
    {
      v3 += 16;
      if (!--v4)
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    v3 = 0;
  }
  if (qword_10098FE50)
  {
    v5 = *(void (**)(unsigned __int16 *))(qword_10098FE50 + 8);
    if (v5)
    {
      v5(v3 + 12);
      LODWORD(v2) = *(unsigned __int8 *)xmmword_10098FE40;
    }
  }
  if ((_DWORD)v2)
  {
    v2 = v2;
    for (i = (void **)(*((_QWORD *)&xmmword_10098FE40 + 1) + 16);
          !*((_BYTE *)i - 14) || *((unsigned __int16 *)i - 8) != a1;
          i += 4)
    {
      if (!--v2)
        return;
    }
    *((_BYTE *)i - 14) = 0;
    if (*i)
    {
      sub_100053298(*i);
      *i = 0;
    }
  }
}

void sub_100249010(unsigned int a1, unsigned __int8 *a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  int v8;
  unsigned int v9;
  int v10;
  int v11;
  NSObject *v12;
  int v13;
  void *ptr;
  uint64_t v15;
  unsigned __int8 *v16;
  __int16 v17;
  __int16 v18;
  int v19;

  v3 = *(unsigned __int8 *)xmmword_10098FE40;
  if (!*(_BYTE *)xmmword_10098FE40)
  {
LABEL_6:
    if (sub_10005549C())
    {
      sub_100054530("Client not allocated");
      v6 = sub_1000544A0(0x35u);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
LABEL_8:
        sub_1006CE7A4();
        return;
      }
    }
    return;
  }
  v5 = *((_QWORD *)&xmmword_10098FE40 + 1) + 8;
  while (!*(_BYTE *)(v5 - 6) || *(unsigned __int16 *)(v5 - 8) != a1)
  {
    v5 += 32;
    if (!--v3)
      goto LABEL_6;
  }
  if (*(_QWORD *)(v5 + 8))
  {
    if (sub_10005549C())
    {
      sub_100054530("Client sent overlapping request");
      v7 = sub_1000544A0(0x35u);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        goto LABEL_8;
    }
    return;
  }
  if (a3 < 5)
    return;
  if (!a2)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
  v15 = 0;
  v16 = a2;
  v17 = a3;
  v18 = a3;
  v8 = *a2;
  v9 = bswap32(*(unsigned __int16 *)(a2 + 1)) >> 16;
  v19 = 65541;
  ptr = 0;
  if (a3 - 5 != bswap32(*(unsigned __int16 *)(a2 + 3)) >> 16)
  {
    v11 = 804;
LABEL_25:
    v10 = sub_1002495C8(v11, v9, (uint64_t)&ptr);
    goto LABEL_26;
  }
  if (v8 == 6)
  {
    v10 = sub_10024A1AC(v9, (uint64_t)&v16, (uint64_t)&ptr, *(_WORD *)(v5 - 2), a1);
    goto LABEL_26;
  }
  if (v8 == 4)
  {
    v10 = sub_100249F00(v9, (uint64_t)&v16, (uint64_t)&ptr, *(_WORD *)(v5 - 2), a1);
    goto LABEL_26;
  }
  if (v8 != 2)
  {
    v11 = 803;
    goto LABEL_25;
  }
  v10 = sub_100249858(v9, (uint64_t)&v16, (uint64_t)&ptr, *(unsigned __int16 *)(v5 - 2), a1);
LABEL_26:
  if (v10)
    goto LABEL_39;
  v13 = sub_1001DBF20((uint64_t)sub_10024A4E8, a1, 0, (char *)ptr, WORD1(v15));
  if (!v13)
    return;
  if (v13 != 410)
  {
LABEL_39:
    if (sub_10005549C())
    {
      sub_100054530("IncomingRequest_CB failed");
      v12 = sub_1000544A0(0x35u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        sub_1006CE80C();
    }
    sub_100053298(ptr);
  }
  else
  {
    if (*(_QWORD *)(v5 + 8))
      sub_100253460();
    *(_QWORD *)(v5 + 8) = ptr;
    *(_WORD *)v5 = WORD1(v15);
  }
}

void sub_10024928C(uint64_t a1, int *a2, uint64_t a3)
{
  unsigned int v3;
  uint64_t v4;
  uint64_t v6;
  int v7;
  __int16 v8;
  NSObject *v9;
  int v10;
  NSObject *v11;
  unsigned int v12;
  __int16 v13;
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  __int128 v17;
  __int128 v18;
  uint8_t buf[4];
  void *v20;

  v3 = a3;
  v17 = 0u;
  v18 = 0u;
  v4 = *(unsigned __int8 *)xmmword_10098FE40;
  if (!*(_BYTE *)xmmword_10098FE40)
    goto LABEL_5;
  v6 = *((_QWORD *)&xmmword_10098FE40 + 1);
  while (*(_BYTE *)(v6 + 2))
  {
    v6 += 32;
    if (!--v4)
      goto LABEL_5;
  }
  if (qword_10098FE50 && *(_QWORD *)qword_10098FE50)
  {
    v7 = (*(uint64_t (**)(int *, uint64_t))qword_10098FE50)(a2, a3);
    v8 = *((_WORD *)a2 + 2);
    *(_DWORD *)(v6 + 24) = *a2;
    *(_WORD *)(v6 + 28) = v8;
    if (v7 != 845)
    {
      if (v7 == 847)
      {
        *(_WORD *)v6 = v3;
        *(_BYTE *)(v6 + 2) = 1;
        if (sub_10005549C())
        {
          sub_100054530("Stalled incoming SDP request for cid=%d", v3);
          v9 = sub_1000544A0(0x35u);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136446210;
            v20 = sub_100054494();
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
          }
        }
        return;
      }
LABEL_5:
      sub_1001DDCAC((uint64_t)sub_100248EB0, (uint64_t)sub_100248F40, (uint64_t)sub_100249010, v3, (uint64_t)&v17, 0, (uint64_t)&unk_10073BA80);
      return;
    }
  }
  else
  {
    v10 = *a2;
    *(_WORD *)(v6 + 28) = *((_WORD *)a2 + 2);
    *(_DWORD *)(v6 + 24) = v10;
  }
  if (sub_10005549C())
  {
    sub_100054530("Setting up connection parameters for the server connection");
    v11 = sub_1000544A0(0x35u);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v20 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  *(_WORD *)v6 = v3;
  *(_BYTE *)(v6 + 2) = 1;
  v12 = *(unsigned __int16 *)(xmmword_10098FE40 + 4);
  *(_WORD *)(v6 + 4) = v12;
  if (v12 >= 0x81)
  {
    if (v12 <= *(unsigned __int16 *)(sub_100252DE8(0x28u) + 8))
      goto LABEL_23;
    v13 = *(_WORD *)(sub_100252DE8(0x28u) + 8);
  }
  else
  {
    v13 = 128;
  }
  *(_WORD *)(v6 + 4) = v13;
LABEL_23:
  v17 = 0u;
  v18 = 0u;
  LOWORD(v17) = *(_WORD *)(v6 + 4);
  *(_DWORD *)((char *)&v17 + 2) = 327745535;
  WORD3(v17) = 772;
  BYTE13(v17) = 0;
  v14 = sub_1001DDCAC((uint64_t)sub_100248EB0, (uint64_t)sub_100248F40, (uint64_t)sub_100249010, v3, (uint64_t)&v17, 1, (uint64_t)&unk_10073BA80);
  if ((_DWORD)v14)
  {
    v15 = v14;
    if (sub_10005549C())
    {
      sub_100054530("SDPServer: L2CAP failed to complete the connection %!", v15);
      v16 = sub_1000544A0(0x35u);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    *(_BYTE *)(v6 + 2) = 0;
  }
}

uint64_t sub_100249580(uint64_t result)
{
  uint64_t v1;
  _BYTE *i;

  v1 = *(unsigned __int8 *)xmmword_10098FE40;
  if (*(_BYTE *)xmmword_10098FE40)
  {
    for (i = (_BYTE *)(*((_QWORD *)&xmmword_10098FE40 + 1) + 2);
          !*i || *((unsigned __int16 *)i - 1) != (_DWORD)result;
          i += 32)
    {
      if (!--v1)
        return result;
    }
    return sub_1001DEB7C(result, 436);
  }
  return result;
}

uint64_t sub_1002495C8(int a1, __int16 a2, uint64_t a3)
{
  NSObject *v5;
  __int16 v6;
  _BYTE *v7;
  uint64_t v8;
  unsigned __int16 v9;
  unsigned __int16 v10;
  __int16 v11;
  uint64_t result;

  if ((a1 - 807) > 0xFFFFFFF9)
  {
    v6 = a1 - 800;
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("ComposeErrorResponse, generic error");
      v5 = sub_1000544A0(0x35u);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    v6 = 6;
  }
  v7 = sub_100052DC0(7uLL);
  if (!v7)
    return 106;
  *(_QWORD *)a3 = v7;
  *(_WORD *)(a3 + 8) = 7;
  *(_WORD *)(a3 + 14) = 2;
  *(_DWORD *)(a3 + 10) = 65543;
  *v7 = 1;
  if (*(_BYTE *)(a3 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 655, "OI_STATUS ComposeErrorResponse(OI_STATUS, uint16_t, OI_BYTE_STREAM *)");
    goto LABEL_22;
  }
  v8 = *(unsigned __int16 *)(a3 + 12);
  if (*(unsigned __int16 *)(a3 + 10) - (int)v8 <= 1 || *(_BYTE *)(a3 + 14) != 2)
LABEL_22:
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
  *(_BYTE *)(*(_QWORD *)a3 + v8 + 1) = a2;
  *(_BYTE *)(*(_QWORD *)a3 + *(unsigned __int16 *)(a3 + 12)) = HIBYTE(a2);
  v9 = *(_WORD *)(a3 + 12) + 2;
  *(_WORD *)(a3 + 12) = v9;
  if (*(_BYTE *)(a3 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 656, "OI_STATUS ComposeErrorResponse(OI_STATUS, uint16_t, OI_BYTE_STREAM *)");
    goto LABEL_24;
  }
  if (*(unsigned __int16 *)(a3 + 10) - v9 <= 1 || *(_BYTE *)(a3 + 14) != 2)
LABEL_24:
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
  *(_BYTE *)(*(_QWORD *)a3 + v9 + 1) = 2;
  *(_BYTE *)(*(_QWORD *)a3 + *(unsigned __int16 *)(a3 + 12)) = 0;
  v10 = *(_WORD *)(a3 + 12) + 2;
  *(_WORD *)(a3 + 12) = v10;
  if (*(_BYTE *)(a3 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 657, "OI_STATUS ComposeErrorResponse(OI_STATUS, uint16_t, OI_BYTE_STREAM *)");
    goto LABEL_26;
  }
  if (*(unsigned __int16 *)(a3 + 10) - v10 <= 1 || *(_BYTE *)(a3 + 14) != 2)
LABEL_26:
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
  *(_BYTE *)(*(_QWORD *)a3 + v10 + 1) = v6;
  *(_BYTE *)(*(_QWORD *)a3 + *(unsigned __int16 *)(a3 + 12)) = HIBYTE(v6);
  v11 = *(_WORD *)(a3 + 12) + 2;
  *(_WORD *)(a3 + 12) = v11;
  if (*(_BYTE *)(a3 + 14) == 2)
    *(_WORD *)(a3 + 10) = v11;
  result = 0;
  *(_BYTE *)(a3 + 14) = 15;
  return result;
}

uint64_t sub_100249858(__int16 a1, uint64_t a2, uint64_t a3, int a4, unsigned int a5)
{
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  unsigned __int8 *v13;
  int v14;
  unsigned int v15;
  unsigned __int16 v16;
  uint64_t v17;
  unsigned int v18;
  unsigned __int16 v19;
  __int16 v20;
  unsigned int v21;
  uint64_t v22;
  char v23;
  uint64_t v24;
  NSObject *v25;
  uint64_t v27;
  _BYTE *v28;
  uint64_t v29;
  unsigned __int16 v30;
  uint64_t v31;
  _BYTE *v32;
  unsigned int v33;
  unsigned __int16 v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  int v38;
  uint64_t v39;
  uint64_t v40;

  v39 = 0;
  v40 = 0;
  v37 = 0;
  v38 = 0;
  v36 = 0;
  sub_1001DB520(a5, &v36);
  v9 = sub_10024A5A0((uint64_t *)a2, (uint64_t)&v39);
  if ((_DWORD)v9)
  {
    v10 = v9;
    if (sub_10005549C())
    {
      sub_100054530("SDPServer: ServiceSearchRequest bad UUID list");
      v11 = sub_1000544A0(0x35u);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    goto LABEL_29;
  }
  if (*(_BYTE *)(a2 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
  if (*(_BYTE *)(a2 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 807, "OI_STATUS ServiceSearchRequest(uint16_t, OI_BYTE_STREAM *, OI_BYTE_STREAM *, uint16_t, OI_L2CAP_CID)");
LABEL_27:
    *(_BYTE *)(a2 + 15) = 1;
    goto LABEL_28;
  }
  v12 = *(unsigned __int16 *)(a2 + 12);
  if (*(unsigned __int16 *)(a2 + 10) - (int)v12 <= 1)
    goto LABEL_27;
  v13 = (unsigned __int8 *)(*(_QWORD *)a2 + v12);
  v14 = v13[1];
  v15 = v14 | (*v13 << 8);
  *(_WORD *)(a2 + 12) = v12 + 2;
  if (!v15)
  {
LABEL_28:
    v10 = 803;
LABEL_29:
    if (sub_10005549C())
    {
      sub_100054530("Error response to service search request: %!", v10);
      v25 = sub_1000544A0(0x35u);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    if (*(_QWORD *)a3)
      sub_100053298(*(void **)a3);
    sub_10017FAC4((unsigned __int8 *)&v39);
    return sub_1002495C8(v10, a1, a3);
  }
  v10 = sub_10024A60C((uint64_t *)a2, &v37);
  if ((_DWORD)v10)
    goto LABEL_29;
  v16 = v15 >= (unsigned __int16)((a4 + 262132) >> 2) ? (a4 + 262132) >> 2 : v15;
  v10 = sub_10024A708(a3, (4 * v16 + 4) & 0xFFFC);
  if ((_DWORD)v10)
    goto LABEL_29;
  if (*(_BYTE *)(a3 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 842, "OI_STATUS ServiceSearchRequest(uint16_t, OI_BYTE_STREAM *, OI_BYTE_STREAM *, uint16_t, OI_L2CAP_CID)");
LABEL_62:
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
  }
  v17 = *(unsigned __int16 *)(a3 + 12);
  if ((unint64_t)*(unsigned __int16 *)(a3 + 10) - v17 <= 3)
    goto LABEL_62;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v35 = *(unsigned __int16 *)(a3 + 12);
  *(_WORD *)(a3 + 12) = v17 + 4;
  v21 = (unsigned __int16)v37;
  while (1)
  {
    v22 = sub_100246A18(v40, WORD1(v39), (_WORD *)&v37 + 1, &v38, v36);
    if ((_DWORD)v22)
      break;
    v23 = HIBYTE(v19);
    if (HIWORD(v37) > v21 && v19 < v16)
    {
      if (*(_BYTE *)(a3 + 15))
      {
        sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 862, "OI_STATUS ServiceSearchRequest(uint16_t, OI_BYTE_STREAM *, OI_BYTE_STREAM *, uint16_t, OI_L2CAP_CID)");
LABEL_60:
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
      }
      v24 = *(unsigned __int16 *)(a3 + 12);
      if (*(unsigned __int16 *)(a3 + 10) - (int)v24 <= 3 || *(_BYTE *)(a3 + 14) != 2)
        goto LABEL_60;
      *(_BYTE *)(*(_QWORD *)a3 + v24 + 3) = v38;
      *(_BYTE *)(*(_QWORD *)a3 + *(unsigned __int16 *)(a3 + 12) + 2) = BYTE1(v38);
      *(_BYTE *)(*(_QWORD *)a3 + *(unsigned __int16 *)(a3 + 12) + 1) = BYTE2(v38);
      *(_BYTE *)(*(_QWORD *)a3 + *(unsigned __int16 *)(a3 + 12)) = HIBYTE(v38);
      *(_WORD *)(a3 + 12) += 4;
      ++v19;
      v18 = HIWORD(v37);
      v23 = HIBYTE(v19);
    }
    if (v15 <= (unsigned __int16)++v20)
      goto LABEL_37;
  }
  v10 = v22;
  if ((_DWORD)v22 != 823)
    goto LABEL_29;
  v23 = HIBYTE(v19);
  LOBYTE(v14) = v20;
LABEL_37:
  if (HIWORD(v37) > v18)
  {
    if (*(_BYTE *)(a3 + 15))
    {
      sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 876, "OI_STATUS ServiceSearchRequest(uint16_t, OI_BYTE_STREAM *, OI_BYTE_STREAM *, uint16_t, OI_L2CAP_CID)");
    }
    else
    {
      v27 = *(unsigned __int16 *)(a3 + 12);
      if (*(unsigned __int16 *)(a3 + 10) > v27 && *(_BYTE *)(a3 + 14) == 2)
      {
        v28 = *(_BYTE **)a3;
        *(_WORD *)(a3 + 12) = v27 + 1;
        v28[v27] = 2;
        if (*(_BYTE *)(a3 + 15))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 877, "OI_STATUS ServiceSearchRequest(uint16_t, OI_BYTE_STREAM *, OI_BYTE_STREAM *, uint16_t, OI_L2CAP_CID)");
        }
        else
        {
          v29 = *(unsigned __int16 *)(a3 + 12);
          if (*(unsigned __int16 *)(a3 + 10) - (int)v29 > 1 && *(_BYTE *)(a3 + 14) == 2)
          {
            *(_BYTE *)(*(_QWORD *)a3 + v29 + 1) = v18;
            *(_BYTE *)(*(_QWORD *)a3 + *(unsigned __int16 *)(a3 + 12)) = BYTE1(v18);
            v30 = *(_WORD *)(a3 + 12) + 2;
            *(_WORD *)(a3 + 12) = v30;
            goto LABEL_49;
          }
        }
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
      }
    }
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
  }
  if (*(_BYTE *)(a3 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 879, "OI_STATUS ServiceSearchRequest(uint16_t, OI_BYTE_STREAM *, OI_BYTE_STREAM *, uint16_t, OI_L2CAP_CID)");
    goto LABEL_74;
  }
  v31 = *(unsigned __int16 *)(a3 + 12);
  if (*(unsigned __int16 *)(a3 + 10) <= v31 || *(_BYTE *)(a3 + 14) != 2)
LABEL_74:
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
  v32 = *(_BYTE **)a3;
  *(_WORD *)(a3 + 12) = v31 + 1;
  v32[v31] = 0;
  v30 = *(_WORD *)(a3 + 12);
LABEL_49:
  v33 = *(unsigned __int16 *)(a3 + 10);
  if (v35 > v33)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
  *(_WORD *)(a3 + 12) = v35;
  if (*(_BYTE *)(a3 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 886, "OI_STATUS ServiceSearchRequest(uint16_t, OI_BYTE_STREAM *, OI_BYTE_STREAM *, uint16_t, OI_L2CAP_CID)");
    goto LABEL_65;
  }
  if ((int)(v33 - v35) <= 1 || *(_BYTE *)(a3 + 14) != 2)
LABEL_65:
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
  *(_BYTE *)(*(_QWORD *)a3 + v35 + 1) = v14;
  *(_BYTE *)(*(_QWORD *)a3 + *(unsigned __int16 *)(a3 + 12)) = HIBYTE(v20);
  v34 = *(_WORD *)(a3 + 12) + 2;
  *(_WORD *)(a3 + 12) = v34;
  if (*(_BYTE *)(a3 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 887, "OI_STATUS ServiceSearchRequest(uint16_t, OI_BYTE_STREAM *, OI_BYTE_STREAM *, uint16_t, OI_L2CAP_CID)");
    goto LABEL_67;
  }
  if (*(unsigned __int16 *)(a3 + 10) - v34 <= 1 || *(_BYTE *)(a3 + 14) != 2)
LABEL_67:
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
  *(_BYTE *)(*(_QWORD *)a3 + v34 + 1) = v19;
  *(_BYTE *)(*(_QWORD *)a3 + *(unsigned __int16 *)(a3 + 12)) = v23;
  *(_WORD *)(a3 + 12) += 2;
  if (*(unsigned __int16 *)(a3 + 10) < v30)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
  *(_WORD *)(a3 + 12) = v30;
  sub_10024A7F0(a3, 3, a1);
  sub_10017FAC4((unsigned __int8 *)&v39);
  return 0;
}

uint64_t sub_100249F00(__int16 a1, uint64_t a2, uint64_t a3, __int16 a4, unsigned int a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  unsigned int v13;
  unsigned int v14;
  int v17;
  __int16 v18;
  __int16 v19;
  unsigned __int16 v20;
  uint64_t v21;
  unsigned __int16 v22;
  unsigned __int16 v23;
  __int16 v24;
  __int16 v25;
  _QWORD v26[2];

  v26[0] = 0;
  v26[1] = 0;
  v24 = 0;
  if (*(_BYTE *)(a2 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 1224, "OI_STATUS ServiceAttributeRequest(uint16_t, OI_BYTE_STREAM *, OI_BYTE_STREAM *, uint16_t, OI_L2CAP_CID)");
LABEL_4:
    v10 = 804;
    goto LABEL_5;
  }
  v8 = *(unsigned __int16 *)(a2 + 10);
  v9 = *(unsigned __int16 *)(a2 + 12);
  if ((unint64_t)(v8 - v9) < 6)
    goto LABEL_4;
  if (*(_BYTE *)(a2 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
  if ((int)v8 - (int)v9 <= 3)
  {
    *(_BYTE *)(a2 + 15) = 1;
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 1229, "OI_STATUS ServiceAttributeRequest(uint16_t, OI_BYTE_STREAM *, OI_BYTE_STREAM *, uint16_t, OI_L2CAP_CID)");
    goto LABEL_26;
  }
  v13 = *(_DWORD *)(*(_QWORD *)a2 + v9);
  *(_WORD *)(a2 + 12) = v9 + 4;
  if ((int)(v8 - (unsigned __int16)(v9 + 4)) <= 1)
  {
LABEL_26:
    *(_BYTE *)(a2 + 15) = 1;
    goto LABEL_27;
  }
  v14 = bswap32(*(unsigned __int16 *)(*(_QWORD *)a2 + (unsigned __int16)(v9 + 4))) >> 16;
  *(_WORD *)(a2 + 12) = v9 + 6;
  if (v14 < 7)
  {
LABEL_27:
    v10 = 803;
    goto LABEL_5;
  }
  v10 = sub_10024A9E0((uint64_t *)a2, (uint64_t)v26);
  if ((_DWORD)v10)
    goto LABEL_5;
  v25 = 0;
  v10 = sub_10024A60C((uint64_t *)a2, &v25);
  if ((_DWORD)v10)
    goto LABEL_5;
  v23 = 0;
  v10 = sub_10024AA5C(a3, v14, a4, &v23);
  if ((_DWORD)v10)
    goto LABEL_5;
  v17 = bswap32(v13);
  v18 = v25;
  if (!v25)
  {
    v22 = 0;
    v21 = sub_10024AB3C(v17, (uint64_t)v26, &v22, a5);
    if ((_DWORD)v21)
    {
      v10 = v21;
      goto LABEL_5;
    }
    sub_10024AC30((uint64_t *)a3, v22, &v25);
    v18 = v25;
  }
  v24 = v18;
  v19 = *(_WORD *)(a3 + 12);
  if ((sub_10024AE8C(v17, (uint64_t)v26, &v24, a3, a5) & 1) != 0)
    goto LABEL_22;
  v20 = *(_WORD *)(a3 + 12) - v19 + v18;
  if (!v20)
  {
    sub_100253460();
LABEL_22:
    v20 = 0;
  }
  if (!v24)
  {
    sub_10024AFAC((uint64_t *)a3, v23, v20);
    sub_10024A7F0(a3, 5, a1);
    sub_10017FAC4((unsigned __int8 *)v26);
    return 0;
  }
  v10 = 805;
LABEL_5:
  if (sub_10005549C())
  {
    sub_100054530("Error response to service attribute request: %!", v10);
    v11 = sub_1000544A0(0x35u);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  if (*(_QWORD *)a3)
    sub_100053298(*(void **)a3);
  sub_10017FAC4((unsigned __int8 *)v26);
  return sub_1002495C8(v10, a1, a3);
}

uint64_t sub_10024A1AC(__int16 a1, uint64_t a2, uint64_t a3, __int16 a4, unsigned int a5)
{
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  unsigned __int16 v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;
  unsigned __int16 v17;
  NSObject *v18;
  uint64_t v20;
  __int16 v21;
  unsigned __int16 v22;
  int v23;
  uint64_t v24;
  unsigned __int16 v25;
  unsigned __int16 v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD v30[2];

  v30[0] = 0;
  v30[1] = 0;
  v28 = 0;
  v29 = 0;
  v27 = 0;
  v24 = 0;
  sub_1001DB520(a5, &v24);
  v10 = sub_10024A5A0((uint64_t *)a2, (uint64_t)&v28);
  if ((_DWORD)v10)
    goto LABEL_20;
  if (*(_BYTE *)(a2 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
  if (*(_BYTE *)(a2 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 1371, "OI_STATUS ServiceSearchAttributeRequest(uint16_t, OI_BYTE_STREAM *, OI_BYTE_STREAM *, uint16_t, OI_L2CAP_CID)");
LABEL_18:
    *(_BYTE *)(a2 + 15) = 1;
    goto LABEL_19;
  }
  v11 = *(unsigned __int16 *)(a2 + 12);
  if (*(unsigned __int16 *)(a2 + 10) - (int)v11 <= 1)
    goto LABEL_18;
  v12 = bswap32(*(unsigned __int16 *)(*(_QWORD *)a2 + v11)) >> 16;
  *(_WORD *)(a2 + 12) = v11 + 2;
  if (v12 < 7)
  {
LABEL_19:
    v10 = 803;
    goto LABEL_20;
  }
  v10 = sub_10024A9E0((uint64_t *)a2, (uint64_t)v30);
  if (!(_DWORD)v10)
  {
    v26 = 0;
    v10 = sub_10024A60C((uint64_t *)a2, &v26);
    if (!(_DWORD)v10)
    {
      v25 = 0;
      v10 = sub_10024AA5C(a3, v12, a4, &v25);
      if (!(_DWORD)v10)
      {
        v13 = v26;
        if (!v26)
        {
          v23 = 0;
          v22 = 0;
          HIWORD(v27) = 0;
          while (1)
          {
            v20 = sub_100246A18(v29, WORD1(v28), (_WORD *)&v27 + 1, &v23, v24);
            if ((_DWORD)v20)
              break;
            v16 = sub_10024AB3C(v23, (uint64_t)v30, &v22, a5);
            if ((_DWORD)v16)
            {
LABEL_37:
              v10 = v16;
              goto LABEL_20;
            }
            if (v22 <= 0xFFu)
              v21 = 2;
            else
              v21 = 3;
            v13 += v22 + v21;
          }
          v10 = v20;
          if ((_DWORD)v20 != 823)
            goto LABEL_20;
          sub_10024AC30((uint64_t *)a3, v13, (__int16 *)&v26);
          v13 = v26;
        }
        v27 = v13;
        v14 = *(_WORD *)(a3 + 12);
        do
        {
          v23 = 0;
          v22 = 0;
          v15 = sub_100246A18(v29, WORD1(v28), (_WORD *)&v27 + 1, &v23, v24);
          if ((_DWORD)v15)
          {
            v10 = v15;
            if ((_DWORD)v15 != 823)
              goto LABEL_20;
            goto LABEL_34;
          }
          v16 = sub_10024AB3C(v23, (uint64_t)v30, &v22, a5);
          if ((_DWORD)v16)
            goto LABEL_37;
        }
        while (sub_10024AC30((uint64_t *)a3, v22, (__int16 *)&v27)
             && (sub_10024AE8C(v23, (uint64_t)v30, &v27, a3, a5) & 1) != 0);
        v17 = *(_WORD *)(a3 + 12) - v14 + v13;
        if (v17)
          goto LABEL_35;
        sub_100253460();
LABEL_34:
        v17 = 0;
LABEL_35:
        if (!(_WORD)v27)
        {
          sub_10024AFAC((uint64_t *)a3, v25, v17);
          sub_10024A7F0(a3, 7, a1);
          sub_10017FAC4((unsigned __int8 *)&v28);
          sub_10017FAC4((unsigned __int8 *)v30);
          return 0;
        }
        v10 = 805;
      }
    }
  }
LABEL_20:
  if (sub_10005549C())
  {
    sub_100054530("Error response to service search request: %!", v10);
    v18 = sub_1000544A0(0x35u);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  if (*(_QWORD *)a3)
    sub_100053298(*(void **)a3);
  sub_10017FAC4((unsigned __int8 *)&v28);
  sub_10017FAC4((unsigned __int8 *)v30);
  return sub_1002495C8(v10, a1, a3);
}

void sub_10024A4E8(uint64_t a1, void *ptr, uint64_t a3, int a4)
{
  uint64_t v6;
  unsigned __int16 *v7;
  char *v8;

  v6 = *(unsigned __int8 *)xmmword_10098FE40;
  if (*(_BYTE *)xmmword_10098FE40)
  {
    v7 = (unsigned __int16 *)*((_QWORD *)&xmmword_10098FE40 + 1);
    while (!*((_BYTE *)v7 + 2) || *v7 != (_DWORD)a1)
    {
      v7 += 16;
      if (!--v6)
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    v7 = 0;
  }
  sub_100053298(ptr);
  if (a4 || !v7)
  {
    if (!a4)
      return;
  }
  else
  {
    v8 = (char *)*((_QWORD *)v7 + 2);
    if (!v8)
      return;
    if (!sub_1001DBF20((uint64_t)sub_10024A4E8, a1, 0, v8, v7[4]))
    {
      *((_QWORD *)v7 + 2) = 0;
      return;
    }
  }
  sub_100249580(a1);
}

uint64_t sub_10024A5A0(uint64_t *a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v4;
  unsigned __int8 *v5;
  int v6;

  result = sub_10017FA1C(a1, (unsigned __int8 *)a2);
  if (!(_DWORD)result)
  {
    if (*(_BYTE *)a2 == 6)
    {
      v4 = *(unsigned __int16 *)(a2 + 2);
      if ((v4 - 13) >= 0xFFFFFFF4)
      {
        v5 = *(unsigned __int8 **)(a2 + 8);
        while (1)
        {
          v6 = *v5;
          v5 += 16;
          if (v6 != 3)
            break;
          if (!--v4)
            return 0;
        }
      }
    }
    sub_10017FAC4((unsigned __int8 *)a2);
    return 803;
  }
  return result;
}

uint64_t sub_10024A60C(uint64_t *a1, _WORD *a2)
{
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t result;

  *a2 = 0;
  if (*((_BYTE *)a1 + 14) != 1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
  if (*((_BYTE *)a1 + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 726, "OI_STATUS GetContinuationState(OI_BYTE_STREAM *, uint16_t *)");
LABEL_8:
    *((_BYTE *)a1 + 15) = 1;
    return 804;
  }
  v3 = *((unsigned __int16 *)a1 + 5);
  v4 = *((unsigned __int16 *)a1 + 6);
  if (v3 <= v4)
    goto LABEL_8;
  v5 = *a1;
  v6 = v4 + 1;
  *((_WORD *)a1 + 6) = v4 + 1;
  if (!*(_BYTE *)(v5 + v4)
    || ((v7 = v3 - (unsigned __int16)v6, v7 >= 2)
      ? (*a2 = bswap32(*(unsigned __int16 *)(v5 + v6)) >> 16,
         LOWORD(v6) = *((_WORD *)a1 + 6) + 2,
         *((_WORD *)a1 + 6) = v6)
      : (*((_BYTE *)a1 + 15) = 1),
        *a2 ? (result = 804) : (result = 805),
        *a2 && v7 >= 2))
  {
    if (*((unsigned __int16 *)a1 + 5) == (unsigned __int16)v6)
      return 0;
    else
      return 804;
  }
  return result;
}

uint64_t sub_10024A708(uint64_t a1, __int16 a2)
{
  unsigned __int16 v3;
  void *v4;
  uint64_t result;
  NSObject *v6;

  v3 = a2 + 8;
  v4 = sub_100052DC0((unsigned __int16)(a2 + 8));
  if (v4)
  {
    if (!v3)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
    *(_QWORD *)a1 = v4;
    *(_WORD *)(a1 + 8) = v3;
    *(_DWORD *)(a1 + 12) = 0x20000;
    *(_WORD *)(a1 + 10) = v3;
    if (v3 <= 4u)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
    result = 0;
    *(_WORD *)(a1 + 12) = 5;
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("CreateResponsePDU, OI_Malloc (%d) failed", v3);
      v6 = sub_1000544A0(0x35u);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 806;
  }
  return result;
}

uint64_t sub_10024A7F0(uint64_t result, char a2, __int16 a3)
{
  unsigned int v3;
  _BYTE *v4;
  uint64_t v5;
  unsigned __int16 v6;

  v3 = *(unsigned __int16 *)(result + 12);
  *(_WORD *)(result + 12) = 0;
  if (*(_BYTE *)(result + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 568, "void CloseResponsePDU(OI_BYTE_STREAM *, uint8_t, uint16_t)");
    goto LABEL_15;
  }
  if (!*(_WORD *)(result + 10) || *(_BYTE *)(result + 14) != 2)
LABEL_15:
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
  v4 = *(_BYTE **)result;
  *(_WORD *)(result + 12) = 1;
  *v4 = a2;
  if (*(_BYTE *)(result + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 569, "void CloseResponsePDU(OI_BYTE_STREAM *, uint8_t, uint16_t)");
    goto LABEL_17;
  }
  v5 = *(unsigned __int16 *)(result + 12);
  if (*(unsigned __int16 *)(result + 10) - (int)v5 <= 1 || *(_BYTE *)(result + 14) != 2)
LABEL_17:
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
  *(_BYTE *)(*(_QWORD *)result + v5 + 1) = a3;
  *(_BYTE *)(*(_QWORD *)result + *(unsigned __int16 *)(result + 12)) = HIBYTE(a3);
  v6 = *(_WORD *)(result + 12) + 2;
  *(_WORD *)(result + 12) = v6;
  if (*(_BYTE *)(result + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 570, "void CloseResponsePDU(OI_BYTE_STREAM *, uint8_t, uint16_t)");
    goto LABEL_19;
  }
  if (*(unsigned __int16 *)(result + 10) - v6 <= 1 || *(_BYTE *)(result + 14) != 2)
LABEL_19:
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
  *(_BYTE *)(*(_QWORD *)result + v6 + 1) = v3 - 5;
  *(_BYTE *)(*(_QWORD *)result + *(unsigned __int16 *)(result + 12)) = (unsigned __int16)(v3 - 5) >> 8;
  *(_WORD *)(result + 12) += 2;
  if (v3 > *(unsigned __int16 *)(result + 10))
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
  *(_WORD *)(result + 12) = v3;
  if (*(_BYTE *)(result + 14) == 2)
    *(_WORD *)(result + 10) = v3;
  *(_BYTE *)(result + 14) = 15;
  return result;
}

uint64_t sub_10024A9E0(uint64_t *a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v4;
  unsigned __int16 *i;
  int v6;

  result = sub_10017FA1C(a1, (unsigned __int8 *)a2);
  if (!(_DWORD)result)
  {
    if (*(_BYTE *)a2 == 6)
    {
      v4 = *(unsigned __int16 *)(a2 + 2);
      if (*(_WORD *)(a2 + 2))
      {
        for (i = (unsigned __int16 *)(*(_QWORD *)(a2 + 8) + 2); *((_BYTE *)i - 2) == 1; i += 8)
        {
          v6 = *i;
          if (v6 != 4 && v6 != 2)
            break;
          if (!--v4)
            return 0;
        }
      }
    }
    sub_10017FAC4((unsigned __int8 *)a2);
    return 803;
  }
  return result;
}

uint64_t sub_10024AA5C(uint64_t a1, unsigned int a2, __int16 a3, _WORD *a4)
{
  unsigned int v6;
  __int16 v7;
  uint64_t result;
  uint64_t v9;
  __int16 v10;
  unint64_t v11;

  v6 = (unsigned __int16)(a3 - 8);
  if (v6 >= a2)
    v6 = a2;
  if (v6 >= *(unsigned __int16 *)(xmmword_10098FE40 + 2))
    v7 = *(_WORD *)(xmmword_10098FE40 + 2);
  else
    v7 = v6;
  result = sub_10024A708(a1, v7);
  if (!(_DWORD)result)
  {
    if (*(_BYTE *)(a1 + 15))
    {
      sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 1075, "OI_STATUS OpenAttrResponse(OI_BYTE_STREAM *, uint16_t, uint16_t, uint16_t *)");
    }
    else
    {
      v9 = *(unsigned __int16 *)(a1 + 12);
      if ((unint64_t)*(unsigned __int16 *)(a1 + 10) - v9 > 1)
      {
        v10 = v9 + 2;
        *(_WORD *)(a1 + 12) = v10;
        *a4 = v10;
        v11 = *(unsigned __int16 *)(a1 + 10) - 3;
        if (v11 > *(unsigned __int16 *)(a1 + 8) || v11 < *(unsigned __int16 *)(a1 + 12))
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
        *(_WORD *)(a1 + 10) = v11;
        return result;
      }
    }
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
  }
  return result;
}

uint64_t sub_10024AB3C(int a1, uint64_t a2, _WORD *a3, unsigned int a4)
{
  uint64_t v7;
  int v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v12;
  unsigned __int16 v13;
  unsigned __int8 *v14;

  v14 = 0;
  v13 = 0;
  *a3 = 0;
  v12 = 0;
  sub_1001DB520(a4, &v12);
  while (1)
  {
    v7 = sub_100247714(a1, *(_QWORD *)(a2 + 8), *(unsigned __int16 *)(a2 + 2), &v13, (__int16 **)&v14, v12);
    if ((_DWORD)v7)
      break;
    v8 = sub_10017E4F0(v14 + 8);
    if (!v8)
      return 106;
    *a3 += v8 + 3;
  }
  v9 = v7;
  if ((_DWORD)v7 == 826)
    return 0;
  if (sub_10005549C())
  {
    sub_100054530("Internal SDP error AttributeSearch returned %!", v9);
    v10 = sub_1000544A0(0x35u);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
  return v9;
}

uint64_t sub_10024AC30(uint64_t *a1, unsigned int a2, __int16 *a3)
{
  uint64_t v3;
  int v4;
  __int16 v5;
  __int16 v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v3 = *((unsigned __int16 *)a1 + 6);
  v4 = *((unsigned __int16 *)a1 + 5) - (_DWORD)v3;
  v5 = *a3;
  if (a2 < 0x100)
  {
    if (*a3)
    {
      v6 = v5 - 2;
      goto LABEL_6;
    }
    if ((v4 & 0xFFFE) != 0)
    {
      if (*((_BYTE *)a1 + 15))
      {
        sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 1124, "_Bool PutAttrListHeader(OI_BYTE_STREAM *, uint16_t, uint16_t *)");
      }
      else if (v4 > 0 && *((_BYTE *)a1 + 14) == 2)
      {
        v10 = *a1;
        *((_WORD *)a1 + 6) = v3 + 1;
        *(_BYTE *)(v10 + v3) = 53;
        if (*((_BYTE *)a1 + 15))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 1125, "_Bool PutAttrListHeader(OI_BYTE_STREAM *, uint16_t, uint16_t *)");
        }
        else
        {
          v11 = *((unsigned __int16 *)a1 + 6);
          if (*((unsigned __int16 *)a1 + 5) > v11 && *((_BYTE *)a1 + 14) == 2)
          {
            v12 = *a1;
            *((_WORD *)a1 + 6) = v11 + 1;
            *(_BYTE *)(v12 + v11) = a2;
            return 1;
          }
        }
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
      }
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
    }
  }
  else
  {
    if (*a3)
    {
      v6 = v5 - 3;
LABEL_6:
      *a3 = v6;
      return 1;
    }
    if ((unsigned __int16)(*((_WORD *)a1 + 5) - v3) >= 3u)
    {
      if (*((_BYTE *)a1 + 15))
      {
        sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 1114, "_Bool PutAttrListHeader(OI_BYTE_STREAM *, uint16_t, uint16_t *)");
      }
      else if (v4 > 0 && *((_BYTE *)a1 + 14) == 2)
      {
        v8 = *a1;
        *((_WORD *)a1 + 6) = v3 + 1;
        *(_BYTE *)(v8 + v3) = 54;
        if (*((_BYTE *)a1 + 15))
        {
          sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 1115, "_Bool PutAttrListHeader(OI_BYTE_STREAM *, uint16_t, uint16_t *)");
        }
        else
        {
          v9 = *((unsigned __int16 *)a1 + 6);
          if (*((unsigned __int16 *)a1 + 5) - (int)v9 > 1 && *((_BYTE *)a1 + 14) == 2)
          {
            *(_BYTE *)(*a1 + v9 + 1) = a2;
            *(_BYTE *)(*a1 + *((unsigned __int16 *)a1 + 6)) = BYTE1(a2);
            *((_WORD *)a1 + 6) += 2;
            return 1;
          }
        }
        sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
      }
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
    }
  }
  return 0;
}

uint64_t sub_10024AE8C(int a1, uint64_t a2, _WORD *a3, uint64_t a4, unsigned int a5)
{
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  unsigned __int16 v14;
  __int128 v15;
  unsigned __int8 *v16;

  v16 = 0;
  v15 = xmmword_10073BAB0;
  v14 = 0;
  v13 = 0;
  sub_1001DB520(a5, &v13);
  while (1)
  {
    v9 = sub_100247714(a1, *(_QWORD *)(a2 + 8), *(unsigned __int16 *)(a2 + 2), &v14, (__int16 **)&v16, v13);
    if ((_DWORD)v9)
      break;
    DWORD2(v15) = *(unsigned __int16 *)v16;
    result = sub_10017E794(a4, a3, (unsigned __int8 *)&v15);
    if (!(_DWORD)result)
      return result;
    if (!sub_10017E794(a4, a3, v16 + 8))
      return 0;
  }
  v11 = v9;
  if ((_DWORD)v9 == 826)
    return 1;
  result = sub_10005549C();
  if ((_DWORD)result)
  {
    sub_100054530("Internal SDP error AttributeSearch returned %!", v11);
    v12 = sub_1000544A0(0x35u);
    result = os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
    if ((_DWORD)result)
    {
      sub_1006CE7A4();
      return 0;
    }
  }
  return result;
}

uint64_t *sub_10024AFAC(uint64_t *result, unsigned int a2, int a3)
{
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = a2 - 2;
  v4 = *((unsigned __int16 *)result + 5);
  if (v3 > v4)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
  v5 = *((unsigned __int16 *)result + 6);
  *((_WORD *)result + 6) = v3;
  if (*((_BYTE *)result + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 1163, "void CloseAttrResponse(OI_BYTE_STREAM *, uint16_t, uint16_t)");
    goto LABEL_21;
  }
  if ((int)(v4 - (unsigned __int16)v3) <= 1 || *((_BYTE *)result + 14) != 2)
LABEL_21:
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
  *(_BYTE *)(*result + (unsigned __int16)v3 + 1) = v5 - a2;
  *(_BYTE *)(*result + *((unsigned __int16 *)result + 6)) = (unsigned __int16)(v5 - a2) >> 8;
  *((_WORD *)result + 6) += 2;
  v6 = *((unsigned __int16 *)result + 5);
  if (v5 > v6)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
  *((_WORD *)result + 6) = v5;
  v7 = v6 + 3;
  if (v7 > *((unsigned __int16 *)result + 4))
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
  *((_WORD *)result + 5) = v7;
  if (a3)
  {
    if (*((_BYTE *)result + 15))
    {
      sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 1177, "void CloseAttrResponse(OI_BYTE_STREAM *, uint16_t, uint16_t)");
    }
    else if (v5 < (unsigned __int16)v7 && *((_BYTE *)result + 14) == 2)
    {
      v8 = *result;
      *((_WORD *)result + 6) = v5 + 1;
      *(_BYTE *)(v8 + v5) = 2;
      if (*((_BYTE *)result + 15))
      {
        sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 1178, "void CloseAttrResponse(OI_BYTE_STREAM *, uint16_t, uint16_t)");
      }
      else
      {
        v9 = *((unsigned __int16 *)result + 6);
        if (*((unsigned __int16 *)result + 5) - (int)v9 > 1 && *((_BYTE *)result + 14) == 2)
        {
          *(_BYTE *)(*result + v9 + 1) = a3;
          *(_BYTE *)(*result + *((unsigned __int16 *)result + 6)) = BYTE1(a3);
          *((_WORD *)result + 6) += 2;
          return result;
        }
      }
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
    }
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
  }
  if (*((_BYTE *)result + 15))
  {
    sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c", 1180, "void CloseAttrResponse(OI_BYTE_STREAM *, uint16_t, uint16_t)");
    goto LABEL_29;
  }
  if (v5 >= (unsigned __int16)v7 || *((_BYTE *)result + 14) != 2)
LABEL_29:
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/sdp/sdpserver.c");
  v10 = *result;
  *((_WORD *)result + 6) = v5 + 1;
  *(_BYTE *)(v10 + v5) = 0;
  return result;
}

void sub_10024B250(uint64_t a1)
{
  NSObject *v2;

  if ((_DWORD)a1 && sub_10005549C())
  {
    sub_100054530("Write Secure Connection failed %!", a1);
    v2 = sub_1000544A0(0x37u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
}

uint64_t sub_10024B2BC()
{
  uint64_t v0;
  unsigned __int8 *v1;
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (HIDWORD(xmmword_100999218))
    return 140;
  v1 = (unsigned __int8 *)sub_100252DE8(0x28u);
  v2 = sub_100114588(16 * *v1);
  qword_10098FE60 = (uint64_t)v2;
  if (v2)
    v0 = 0;
  else
    v0 = 106;
  if (v2)
  {
    word_10098FEE8 = 0;
    qword_10098FE70 = 0;
    qword_10098FEC8 = 0;
    off_10098FEE0 = 0;
    dword_10098FEB8 = 3;
    DWORD2(xmmword_10098FE90) = 6;
    dword_10098FE6C = 0;
    byte_10098FE69 = 0;
    if (sub_10018297C() && !byte_10098FE68)
      sub_10004C9BC(140, (uint64_t (*)())sub_10024B250, v3, v4, v5, v6, v7, v8, 1);
    HIDWORD(xmmword_100999218) = 1;
  }
  byte_100999118 = 0;
  return v0;
}

uint64_t sub_10024B3A8(uint64_t a1, BOOL *a2)
{
  uint64_t v3;
  NSObject *v4;
  NSObject *v5;
  uint64_t v7;

  v7 = 0;
  if (a1 && a2)
  {
    v3 = sub_100182588(a1, &v7);
    if ((_DWORD)v3)
    {
      if (sub_10005549C())
      {
        sub_100054530("OI_SECMGR_RemoteSupportSSP: invalid address");
        v4 = sub_1000544A0(0x37u);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
          sub_1006CEEC0();
      }
    }
    else
    {
      *a2 = *(_BYTE *)(v7 + 277) != 0;
    }
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("OI_SECMGR_RemoteSupportSSP: invalid parameters");
      v5 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    return 101;
  }
  return v3;
}

uint64_t sub_10024B488(uint64_t a1, __int16 a2)
{
  uint64_t v3;
  NSObject *v5;

  v3 = sub_10019AEA4(a1);
  if (v3)
  {
    *(_WORD *)(v3 + 274) = 10 * a2;
    sub_10017FF38(v3);
    return 0;
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("Invalid connection");
      v5 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 122;
  }
}

uint64_t sub_10024B508(uint64_t a1, char a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t result;

  if (!a1)
    return 101;
  v3 = sub_10019AEA4(a1);
  if (v3 && (v4 = (unsigned __int16)word_10098FEE8, word_10098FEE8))
  {
    v5 = qword_10098FE60;
    while (*(_QWORD *)v5 != v3)
    {
      v5 += 16;
      if (!--v4)
        goto LABEL_7;
    }
    result = 0;
    *(_BYTE *)(v5 + 13) = a2;
  }
  else
  {
LABEL_7:
    if (sub_10005549C())
    {
      sub_100054530("Device is no longer connected");
      v6 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 122;
  }
  return result;
}

uint64_t sub_10024B5B4(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t result;
  NSObject *v4;

  if (a1 && (v1 = (unsigned __int16)word_10098FEE8, word_10098FEE8))
  {
    v2 = qword_10098FE60;
    while (*(_QWORD *)v2 != a1)
    {
      v2 += 16;
      if (!--v1)
        goto LABEL_6;
    }
    return *(_BYTE *)(v2 + 13) != 0;
  }
  else
  {
LABEL_6:
    result = sub_10005549C();
    if ((_DWORD)result)
    {
      sub_100054530("Device is no longer connected");
      v4 = sub_1000544A0(0x37u);
      result = os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
      if ((_DWORD)result)
      {
        sub_1006CE7A4();
        return 0;
      }
    }
  }
  return result;
}

uint64_t sub_10024B64C(uint64_t result)
{
  byte_10098FE69 = result;
  return result;
}

uint64_t sub_10024B658(uint64_t (*a1)(), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  NSObject *v9;
  uint64_t v11;

  if (a1)
  {
    v8 = sub_10004C9BC(119, a1, a3, a4, a5, a6, a7, a8, v11);
    if ((_DWORD)v8)
    {
      if (sub_10005549C())
      {
        sub_100054530("OI_HCICMD_ReadLocalOOBData %!", v8);
        v9 = sub_1000544A0(0x37u);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          sub_1006CEEC0();
      }
    }
  }
  else
  {
    sub_100253460();
    return 101;
  }
  return v8;
}

uint64_t sub_10024B6E0(uint64_t (*a1)(), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  NSObject *v9;
  uint64_t v11;

  if (a1)
  {
    v8 = sub_10004C9BC(132, a1, a3, a4, a5, a6, a7, a8, v11);
    if ((_DWORD)v8)
    {
      if (sub_10005549C())
      {
        sub_100054530("OI_HCICMD_ReadLocalOOBExtendedData %!", v8);
        v9 = sub_1000544A0(0x37u);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          sub_1006CEEC0();
      }
    }
  }
  else
  {
    sub_100253460();
    return 101;
  }
  return v8;
}

uint64_t sub_10024B768(uint64_t a1)
{
  uint64_t v1;
  _DWORD *v2;
  uint64_t result;
  NSObject *v4;

  v1 = (unsigned __int16)word_10098FEE8;
  if (word_10098FEE8)
  {
    v2 = (_DWORD *)(qword_10098FE60 + 8);
    while (*((_QWORD *)v2 - 1) != a1)
    {
      v2 += 4;
      if (!--v1)
        goto LABEL_5;
    }
    return *v2 == 2;
  }
  else
  {
LABEL_5:
    result = sub_10005549C();
    if ((_DWORD)result)
    {
      sub_100054530("OI_SECMGR_ConnectionIsEncrypted %!", 122);
      v4 = sub_1000544A0(0x37u);
      result = os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
      if ((_DWORD)result)
      {
        sub_1006CEEC0();
        return 0;
      }
    }
  }
  return result;
}

uint64_t sub_10024B810(uint64_t a1, _BYTE *a2)
{
  uint64_t v3;
  uint64_t result;
  _QWORD v6[3];
  int v7;

  memset(v6, 0, sizeof(v6));
  v7 = 0;
  *a2 = 0;
  v3 = a1 + 48;
  if ((sub_100229424(a1 + 48, (uint64_t)v6) & 1) != 0
    || (result = (*(uint64_t (**)(uint64_t, _QWORD *))(qword_10098FE70 + 32))(v3, v6), (_DWORD)result))
  {
    result = 1;
    if (v7 == 8 || v7 == 5)
      *a2 = 1;
  }
  return result;
}

BOOL sub_10024B8B8(uint64_t a1)
{
  if (dword_10098FE6C < 2)
    return 0;
  return *(_DWORD *)(a1 + 48) == dword_10098FE78 && *(unsigned __int16 *)(a1 + 52) == (unsigned __int16)word_10098FE7C;
}

void sub_10024B8F8(uint64_t (*a1)(_QWORD, _QWORD, _QWORD))
{
  if (!a1)
    sub_100253460();
  off_10098FEC0 = a1;
}

uint64_t sub_10024B924(uint64_t a1, uint64_t a2, uint64_t a3, uint8x8_t a4)
{
  BOOL v4;
  uint64_t result;
  NSObject *v6;
  BOOL v10;
  BOOL v11;
  int v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  char v17;
  char v18;
  _QWORD v19[3];
  int v20;

  memset(v19, 0, sizeof(v19));
  v20 = 0;
  if (HIDWORD(xmmword_100999218))
    v4 = dword_10098FE6C == 0;
  else
    v4 = 1;
  if (v4)
  {
    result = sub_10005549C();
    if ((_DWORD)result)
    {
      sub_100054530("!SECMGR_IS_INITIALIZED");
      v6 = sub_1000544A0(0x37u);
      result = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
      if ((_DWORD)result)
      {
        sub_1006CEEC0();
        return 0;
      }
    }
  }
  else
  {
    if (!qword_10098FEC8
      || (*(_QWORD *)(qword_10098FEC8 + 8) ? (v10 = qword_10098FE70 == 0) : (v10 = 1),
          v10 || !*(_QWORD *)(qword_10098FE70 + 32)))
    {
      sub_100253460();
    }
    a4.i32[0] = dword_10098FE78;
    if (vmovn_s16((int16x8_t)vmovl_u8(a4)).u32[0])
      v11 = 0;
    else
      v11 = word_10098FE7C == 0;
    if (v11 && HIBYTE(word_10098FE7C) == 0)
      return 0;
    v13 = (*(uint64_t (**)(uint64_t, uint64_t, int *))(qword_10098FEC8 + 8))(a2, a3, &dword_10098FE78);
    v14 = (unsigned __int16)word_10098FEE8;
    if (word_10098FEE8)
    {
      v15 = qword_10098FE60;
      while (1)
      {
        v16 = *(_QWORD *)v15 != a1;
        if (*(_QWORD *)v15 == a1)
          break;
        v15 += 16;
        if (!--v14)
        {
          v15 = 0;
          break;
        }
      }
    }
    else
    {
      v15 = 0;
      v16 = 1;
    }
    if ((sub_100229424((uint64_t)&dword_10098FE78, (uint64_t)v19) & 1) != 0)
      v17 = 1;
    else
      v17 = (*(uint64_t (**)(int *, _QWORD *))(qword_10098FE70 + 32))(&dword_10098FE78, v19);
    result = v13 != 0;
    if (v13)
      v18 = v16;
    else
      v18 = 1;
    if ((v18 & 1) == 0)
    {
      if (*(_DWORD *)(v15 + 8) == 2)
      {
        if (v20 != 5)
          v17 = 0;
        if ((v17 & 1) != 0)
          return 0;
      }
      return 1;
    }
  }
  return result;
}

uint64_t sub_10024BB28(uint64_t result)
{
  byte_10098FE68 = result;
  return result;
}

uint64_t sub_10024BB34(_QWORD *a1)
{
  uint64_t result;

  if (!a1)
  {
    sub_100253460();
    return 101;
  }
  if (!*a1)
  {
    sub_100253460();
    if (!*a1)
      return 101;
  }
  if (!a1[1])
  {
    sub_100253460();
    if (!a1[1])
      return 101;
  }
  if (!a1[2])
  {
    sub_100253460();
    if (!a1[2])
      return 101;
  }
  if (!a1[3])
  {
    sub_100253460();
    if (!a1[3])
      return 101;
  }
  if (!a1[4])
  {
    sub_100253460();
    if (!a1[4])
      return 101;
  }
  if (!a1[5])
  {
    sub_100253460();
    if (!a1[5])
      return 101;
  }
  if (!a1[6])
  {
    sub_100253460();
    if (!a1[6])
      return 101;
  }
  if (!a1[7])
  {
    sub_100253460();
    if (!a1[7])
      return 101;
  }
  if (!a1[8])
  {
    sub_100253460();
    if (!a1[8])
      return 101;
  }
  if (!a1[9])
  {
    sub_100253460();
    if (!a1[9])
      return 101;
  }
  if (!a1[10])
  {
    sub_100253460();
    if (!a1[10])
      return 101;
  }
  if (!a1[11])
  {
    sub_100253460();
    if (!a1[11])
      return 101;
  }
  if (!a1[13])
  {
    sub_100253460();
    if (!a1[13])
      return 101;
  }
  if (!a1[14])
  {
    sub_100253460();
    if (!a1[14])
      return 101;
  }
  result = 0;
  qword_10098FE70 = (uint64_t)a1;
  if (!dword_10098FE6C)
  {
    if (qword_10098FEC8)
    {
      sub_10024BCA8(1);
      return 0;
    }
  }
  return result;
}

double sub_10024BCA8(int a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  double result;
  const void *v6[2];

  dword_10098FE6C = a1;
  if (a1 == 1 && (dword_100999128 || word_10099912C != 0))
  {
    v6[0] = (const void *)40;
    v6[1] = &qword_100999120;
    v2 = sub_10004AE90((uint64_t)sub_100250498, v6, 0);
    if ((_DWORD)v2)
    {
      v3 = v2;
      if (sub_10005549C())
      {
        sub_100054530("Dispatch registration failed %!", v3);
        v4 = sub_1000544A0(0x37u);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
          sub_1006CEEC0();
      }
      sub_100253460();
    }
    qword_100999140 = 0;
    result = 0.0;
    *(_OWORD *)&qword_100999120 = 0u;
    xmmword_100999130 = 0u;
  }
  return result;
}

uint64_t sub_10024BD84(_QWORD *a1)
{
  BOOL v2;

  if (!a1)
  {
    sub_100253460();
    return 101;
  }
  if (!*a1)
  {
    sub_100253460();
    if (!*a1)
      return 101;
  }
  if (!a1[1])
  {
    sub_100253460();
    if (!a1[1])
      return 101;
  }
  qword_10098FEC8 = (uint64_t)a1;
  if (dword_10098FE6C)
    v2 = 1;
  else
    v2 = qword_10098FE70 == 0;
  if (!v2)
    sub_10024BCA8(1);
  return 0;
}

uint64_t sub_10024BE08(void *a1)
{
  off_10098FEE0 = a1;
  return 0;
}

void sub_10024BE18(uint64_t a1, uint64_t a2)
{
  BOOL v2;
  NSObject *v3;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  NSObject *v11;
  uint64_t v12;

  v12 = 0;
  if (HIDWORD(xmmword_100999218))
    v2 = dword_10098FE6C == 0;
  else
    v2 = 1;
  if (v2)
  {
    if (sub_10005549C())
    {
      sub_100054530("!SECMGR_IS_INITIALIZED");
      v3 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
LABEL_8:
        sub_1006CEEC0();
    }
  }
  else
  {
    v5 = (unsigned __int16)word_10098FEE8;
    if (word_10098FEE8)
    {
      v6 = (_QWORD *)qword_10098FE60;
      while (*v6 != a1)
      {
        v6 += 2;
        if (!--v5)
          goto LABEL_13;
      }
      if (sub_10005549C())
      {
        sub_100054530("OI_SECMGR_ConnectComplete, connection already exists");
        v10 = sub_1000544A0(0x37u);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
          goto LABEL_8;
      }
    }
    else
    {
LABEL_13:
      v7 = sub_10024BFC0(a1, &v12);
      if ((_DWORD)v7)
      {
        v8 = v7;
        if (sub_10005549C())
        {
          sub_100054530("_createSecurityRecord %!", v8);
          v9 = sub_1000544A0(0x37u);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
            sub_1006CEEC0();
        }
      }
      else
      {
        if (a2 >= 3)
        {
          if (sub_10005549C())
          {
            sub_100054530("%! (%d)", 1411, a2);
            v11 = sub_1000544A0(0x37u);
            if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
              sub_1006CEEC0();
          }
          LODWORD(a2) = 0;
        }
        sub_10024C0F0(v12, a2);
      }
    }
  }
}

uint64_t sub_10024BFC0(uint64_t a1, _QWORD *a2)
{
  unsigned int v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  NSObject *v12;

  v4 = (unsigned __int16)word_10098FEE8;
  if (word_10098FEE8)
  {
    v5 = (_QWORD *)qword_10098FE60;
    v6 = (unsigned __int16)word_10098FEE8;
    while (*v5 != a1)
    {
      v5 += 2;
      if (!--v6)
        goto LABEL_8;
    }
    sub_100253460();
    v4 = (unsigned __int16)word_10098FEE8;
LABEL_8:
    if (v4 > *(unsigned __int8 *)sub_100252DE8(0x28u))
      sub_100253460();
  }
  else
  {
    sub_100252DE8(0x28u);
  }
  v7 = (unsigned __int16)word_10098FEE8;
  if (v7 >= *(unsigned __int8 *)sub_100252DE8(0x28u))
  {
    if (sub_10005549C())
    {
      sub_100054530("No room to add another connection %d", (unsigned __int16)word_10098FEE8);
      v12 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    return 104;
  }
  else
  {
    v8 = qword_10098FE60;
    v9 = (unsigned __int16)word_10098FEE8;
    if (a2)
      *a2 = qword_10098FE60 + 16 * (unsigned __int16)word_10098FEE8;
    result = 0;
    v11 = v8 + 16 * v9;
    *(_QWORD *)v11 = a1;
    *(_DWORD *)(v11 + 8) = 0;
    *(_WORD *)(v11 + 12) = 0;
    word_10098FEE8 = v9 + 1;
  }
  return result;
}

void sub_10024C0F0(uint64_t a1, int a2)
{
  if (a1)
  {
    if (a2)
    {
LABEL_3:
      *(_DWORD *)(a1 + 8) = 2;
      sub_10018C8E8(*(_QWORD *)a1, 3);
      return;
    }
  }
  else
  {
    sub_100253460();
    if (a2)
      goto LABEL_3;
  }
  if (*(_DWORD *)(a1 + 8) == 2)
    *(_DWORD *)(a1 + 8) = 1;
}

void sub_10024C150(uint64_t a1, uint64_t a2, __n128 a3)
{
  unsigned int v3;
  BOOL v4;
  NSObject *v5;
  BOOL v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  __n128 *v17;
  char v18;
  int v19;
  void (*v21)(__n128);

  v3 = dword_10098FE6C;
  if (HIDWORD(xmmword_100999218))
    v4 = dword_10098FE6C == 0;
  else
    v4 = 1;
  if (v4)
  {
    if (sub_10005549C())
    {
      sub_100054530("!SECMGR_IS_INITIALIZED");
      v5 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  else
  {
    if (!qword_10098FE70 || !*(_QWORD *)(qword_10098FE70 + 8))
    {
      sub_100253460();
      v3 = dword_10098FE6C;
    }
    if (v3 >= 2)
    {
      if (*(_DWORD *)(a1 + 48) ^ dword_10098FE78 | *(unsigned __int16 *)(a1 + 52) ^ (unsigned __int16)word_10098FE7C)
        v8 = 1;
      else
        v8 = BYTE1(dword_10098FE88) == 0;
      if (!v8)
      {
        *(_WORD *)((char *)&dword_10098FE88 + 1) = 0;
        (*(void (**)(void))(qword_10098FE70 + 8))();
        v3 = dword_10098FE6C;
      }
      if (v3 == 5 && qword_10098FE80 == a1)
      {
        sub_10024C3C8(a2);
      }
      else if (v3 == 2)
      {
        if (qword_10098FE80 == a1 && DWORD2(xmmword_10098FE90) != 4)
          sub_10024C5CC(a2);
      }
      else if (v3 == 3 && qword_10098FE80 == a1 || v3 == 4 && qword_10098FE80 == a1)
      {
        a3.n128_f64[0] = sub_10024BCA8(1);
      }
    }
    v9 = (unsigned __int16)word_10098FEE8;
    if (word_10098FEE8)
    {
      v10 = qword_10098FE60;
      v11 = qword_10098FE60 + 16;
      v12 = (unsigned __int16)(word_10098FEE8 - 1);
      do
      {
        v13 = 0;
        do
        {
          v14 = v13;
          v15 = *(_QWORD *)(v10 + 16 * v13);
        }
        while (v15 != a1 && ++v13 < v9);
        if (v15 != a1)
          break;
        word_10098FEE8 = --v9;
        if (v13 < (unsigned __int16)v9)
        {
          v17 = (__n128 *)(v11 + 16 * v13);
          if (v15 == a1)
            v18 = 2;
          else
            v18 = 1;
          v19 = v12 - v14 - (v18 & 1);
          do
          {
            a3 = *v17;
            v17[-1] = *v17;
            ++v17;
            --v19;
          }
          while (v19);
        }
        --v12;
      }
      while ((_WORD)v9);
    }
    if (*(_DWORD *)(a1 + 48) == dword_100999128 && *(unsigned __int16 *)(a1 + 52) == (unsigned __int16)word_10099912C)
    {
      qword_100999140 = 0;
      a3 = 0uLL;
      *(_OWORD *)&qword_100999120 = 0u;
      xmmword_100999130 = 0u;
    }
    if (qword_10098FE80 == a1)
      qword_10098FE80 = 0;
    v21 = *(void (**)(__n128))(qword_10098FE70 + 96);
    if (v21)
      v21(a3);
  }
}

void sub_10024C3C8(uint64_t a1)
{
  NSObject *v2;
  char *v3;
  NSObject *v4;
  uint64_t v5;
  void (*v6)(uint64_t, _QWORD);
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  uint8_t buf[4];
  void *v11;

  if (sub_10005549C())
  {
    sub_100054530("Enforcement complete with %!", a1);
    v2 = sub_1000544A0(0x37u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v11 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if (dword_10098FE6C != 5)
  {
    sub_100253460();
    if (dword_10098FE6C != 5)
    {
      if (sub_10005549C())
      {
        v3 = dword_10098FE6C > 5 ? "unknown" : off_10091F338[dword_10098FE6C];
        sub_100054530("enforcementFinish - %s state, %!", v3, 105);
        v4 = sub_1000544A0(0x37u);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
          sub_1006CEEC0();
      }
    }
  }
  sub_10024BCA8(1);
  dword_10098FEB8 = 3;
  v5 = qword_10098FE80;
  if (qword_10098FE80)
  {
    if (*(_BYTE *)(qword_10098FE80 + 194))
    {
      *(_BYTE *)(qword_10098FE80 + 194) = 0;
      sub_10018B530(v5);
      v5 = qword_10098FE80;
    }
    if (!*(_DWORD *)(v5 + 148))
    {
      v7 = sub_10017FF38(v5);
      if ((_DWORD)v7)
      {
        v8 = v7;
        if (sub_10005549C())
        {
          sub_100054530("OI_DevMgr_aclActivity failed with %!", v8);
          v9 = sub_1000544A0(0x37u);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
      }
    }
  }
  v6 = (void (*)(uint64_t, _QWORD))off_10098FEB0;
  if (off_10098FEB0 || (sub_100253460(), (v6 = (void (*)(uint64_t, _QWORD))off_10098FEB0) != 0))
    v6(a1, dword_10098FEA0);
}

void sub_10024C5CC(int a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;

  if (dword_10098FE6C != 2)
    sub_100253460();
  if (!HIDWORD(xmmword_10098FE90))
    HIDWORD(xmmword_10098FE90) = a1;
  v2 = sub_10004C9BC(77, sub_100250864);
  if ((_DWORD)v2)
  {
    v3 = v2;
    if (sub_10005549C())
    {
      sub_100054530("OI_HCICMD_WriteAuthenticationEnable %!", v3);
      v4 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    sub_100250864(v3);
  }
}

void sub_10024C67C(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;

  if (sub_10019AB28(a1))
  {
    if (sub_10005549C())
    {
      sub_100054530("AuthenticatedPayloadTimeoutEvent device %: , disconnecting", a1 + 48);
      v2 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    v3 = sub_100180494(a1 + 48, 0x3Du);
    if ((_DWORD)v3)
    {
      v4 = v3;
      if (sub_10005549C())
      {
        sub_100054530("Failed to force-disconnect due to MIC with status %!", v4);
        v5 = sub_1000544A0(0x37u);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
          sub_1006CEEC0();
      }
    }
  }
}

uint64_t sub_10024C748(uint64_t a1, uint64_t a2)
{
  uint64_t (*v4)(uint64_t, uint64_t);
  uint64_t v5;

  if (!qword_10098FE70 || (v4 = *(uint64_t (**)(uint64_t, uint64_t))(qword_10098FE70 + 104)) == 0)
  {
    sub_100253460();
    v4 = *(uint64_t (**)(uint64_t, uint64_t))(qword_10098FE70 + 104);
  }
  if (a2)
    v5 = a2 + 48;
  else
    v5 = 0;
  return v4(a1, v5);
}

void sub_10024C7A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v4;
  NSObject *v5;
  const char *v10;
  NSObject *v11;
  NSObject *v12;
  void *v13;
  NSObject *v14;
  void *v15;
  NSObject *v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  NSObject *v27;
  NSObject *v28;
  NSObject *v29;
  void (*v30)(uint64_t, uint64_t, uint64_t, uint64_t);
  unsigned int v31;
  uint64_t v32;
  _QWORD *v33;
  uint8_t buf[4];
  void *v35;

  v33 = 0;
  if (HIDWORD(xmmword_100999218))
    v4 = dword_10098FE6C == 0;
  else
    v4 = 1;
  if (v4)
  {
    if (!sub_10005549C())
      return;
    sub_100054530("!SECMGR_IS_INITIALIZED");
    v5 = sub_1000544A0(0x37u);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      return;
LABEL_8:
    sub_1006CEEC0();
    return;
  }
  if ((_DWORD)a1 == 702)
    return;
  if (!sub_10019AB28(a2))
  {
    if (!sub_10005549C())
      return;
    sub_100054530("Invalid Handle: 0x%x", a2);
    v28 = sub_1000544A0(0x37u);
    if (!os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      return;
    goto LABEL_8;
  }
  if (sub_10005549C())
  {
    v10 = sub_100253370(a3);
    sub_100054530("HCIEvent EncryptionChange: %s", v10);
    v11 = sub_1000544A0(0x37u);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v35 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if (sub_10005549C())
  {
    sub_100054530("        addr     = %:", a2 + 48);
    v12 = sub_1000544A0(0x37u);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      v13 = sub_100054494();
      *(_DWORD *)buf = 136446210;
      v35 = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if (sub_10005549C())
  {
    sub_100054530("        status   = %!", a1);
    v14 = sub_1000544A0(0x37u);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      v15 = sub_100054494();
      *(_DWORD *)buf = 136446210;
      v35 = v15;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if (sub_10005549C())
  {
    sub_100054530("        key size = %d", a4);
    v16 = sub_1000544A0(0x37u);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      v17 = sub_100054494();
      *(_DWORD *)buf = 136446210;
      v35 = v17;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if (!(_DWORD)a1)
  {
    if (a3 < 3)
    {
      if ((_DWORD)a3)
      {
        v18 = 1;
        goto LABEL_25;
      }
    }
    else if (sub_10005549C())
    {
      sub_100054530("%! (%d)", 1411, a3);
      v29 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  a3 = 0;
  v18 = 2;
LABEL_25:
  if (off_10098FEE0)
    off_10098FEE0(v18, a1, a2 + 48);
  v19 = (unsigned __int16)word_10098FEE8;
  if (word_10098FEE8)
  {
    v20 = (_QWORD *)qword_10098FE60;
    while (*v20 != a2)
    {
      v20 += 2;
      if (!--v19)
        goto LABEL_31;
    }
    v33 = v20;
    sub_10024C0F0((uint64_t)v20, a3);
    v21 = 0;
  }
  else
  {
LABEL_31:
    v21 = sub_10024BFC0(a2, &v33);
    if ((_DWORD)v21)
    {
      if (sub_10005549C())
      {
        sub_100054530("could not create security record %!", v21);
        v27 = sub_1000544A0(0x37u);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
          sub_1006CEEC0();
      }
      a3 = 0;
    }
    else
    {
      sub_10024C0F0((uint64_t)v33, a3);
    }
  }
  if (!qword_10098FE70 || !*(_QWORD *)(qword_10098FE70 + 112))
    sub_100253460();
  if (a2)
  {
    v30 = *(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(qword_10098FE70 + 112);
    if (v30)
      v30(v21, a2 + 48, a3, a4);
  }
  sub_10018C38C(v21, a2, a3, v22, v23, v24, v25, v26);
  if (dword_10098FE6C == 5 && qword_10098FE80 == a2 && dword_10098FEB8 == 2)
  {
    if ((_DWORD)a3)
      v31 = 0;
    else
      v31 = 1414;
    if ((_DWORD)v21)
      v32 = v21;
    else
      v32 = v31;
    sub_10024C3C8(v32);
  }
  if (off_10098FEC0)
    off_10098FEC0(v21, a2, a3);
}

void sub_10024CC70(uint64_t a1, uint64_t a2)
{
  BOOL v2;
  NSObject *v3;

  if (HIDWORD(xmmword_100999218))
    v2 = dword_10098FE6C == 0;
  else
    v2 = 1;
  if (v2)
  {
    if (sub_10005549C())
    {
      sub_100054530("!SECMGR_IS_INITIALIZED");
      v3 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  else if (byte_10098FED0)
  {
    if (*(_DWORD *)(a2 + 48) == dword_10098FED1 && *(unsigned __int16 *)(a2 + 52) == (unsigned __int16)word_10098FED5)
    {
      byte_10098FED0 = 0;
      off_10098FED8(a1, &dword_10098FED1);
    }
  }
}

void sub_10024CD38()
{
  BOOL v0;
  NSObject *v1;

  if (HIDWORD(xmmword_100999218))
    v0 = dword_10098FE6C == 0;
  else
    v0 = 1;
  if (v0 && sub_10005549C())
  {
    sub_100054530("!SECMGR_IS_INITIALIZED");
    v1 = sub_1000544A0(0x37u);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
}

void sub_10024CDB0(int a1, uint64_t a2)
{
  int v4;
  int v5;
  BOOL v6;
  BOOL v7;
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;

  v4 = HIDWORD(xmmword_100999218);
  v5 = dword_10098FE6C;
  if (HIDWORD(xmmword_100999218))
    v6 = dword_10098FE6C == 0;
  else
    v6 = 1;
  if (v6)
  {
    sub_100253460();
    v4 = HIDWORD(xmmword_100999218);
    v5 = dword_10098FE6C;
  }
  if (v4)
    v7 = v5 == 0;
  else
    v7 = 1;
  if (v7)
  {
    if (!sub_10005549C())
      return;
    sub_100054530("!SECMGR_IS_INITIALIZED");
    v8 = sub_1000544A0(0x37u);
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      return;
LABEL_14:
    sub_1006CEEC0();
    return;
  }
  if (!a2)
  {
    sub_100253460();
    if (!sub_10005549C())
      return;
    sub_100054530("OI_STATUS_INVALID_PARAMETERS");
    v10 = sub_1000544A0(0x37u);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      return;
    goto LABEL_14;
  }
  if (a1)
    v9 = 31;
  else
    v9 = 32;
  sub_10004C9BC(v9, sub_10024CECC);
}

void sub_10024CECC(uint64_t a1)
{
  NSObject *v2;

  if ((_DWORD)a1 && sub_10005549C())
  {
    sub_100054530("status %!", a1);
    v2 = sub_1000544A0(0x37u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
}

void sub_10024CF38(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  BOOL v3;
  NSObject *v4;
  BOOL v7;
  NSObject *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;

  v13 = 0;
  v2 = dword_10098FE6C;
  if (HIDWORD(xmmword_100999218))
    v3 = dword_10098FE6C == 0;
  else
    v3 = 1;
  if (v3)
  {
    if (sub_10005549C())
    {
      sub_100054530("!SECMGR_IS_INITIALIZED");
      v4 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  else
  {
    if (!qword_10098FE70 || !*(_QWORD *)(qword_10098FE70 + 56))
    {
      sub_100253460();
      v2 = dword_10098FE6C;
    }
    if (v2 < 2
      || (*(_DWORD *)a1 == dword_10098FE78
        ? (v7 = *(unsigned __int16 *)(a1 + 4) == (unsigned __int16)word_10098FE7C)
        : (v7 = 0),
          !v7))
    {
      if (sub_10005549C())
      {
        sub_100054530("Not actively pairing or enforcing %:", a1);
        v8 = sub_1000544A0(0x37u);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
          sub_1006CEEC0();
      }
LABEL_20:
      sub_10024CDB0(0, a1);
      return;
    }
    v9 = dword_10098FE88;
    v10 = sub_100182588(a1, &v13);
    if (!(_DWORD)v10)
    {
      if (!sub_10024B5B4(v13))
      {
        (*(void (**)(uint64_t, uint64_t, BOOL, _QWORD))(qword_10098FE70 + 56))(a1, a2, v9 != 0, BYTE2(dword_10098FE88));
        return;
      }
      goto LABEL_20;
    }
    v11 = v10;
    if (sub_10005549C())
    {
      sub_100054530("No longer connected %!", v11);
      v12 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
}

void sub_10024D100(int a1, uint64_t a2, uint64_t a3)
{
  int v6;
  int v7;
  BOOL v8;
  BOOL v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  NSObject *v17;

  v6 = HIDWORD(xmmword_100999218);
  v7 = dword_10098FE6C;
  if (HIDWORD(xmmword_100999218))
    v8 = dword_10098FE6C == 0;
  else
    v8 = 1;
  if (v8)
  {
    sub_100253460();
    v6 = HIDWORD(xmmword_100999218);
    v7 = dword_10098FE6C;
  }
  if (v6)
    v9 = v7 == 0;
  else
    v9 = 1;
  if (v9)
  {
    if (sub_10005549C())
    {
      sub_100054530("!SECMGR_IS_INITIALIZED");
      v10 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        goto LABEL_27;
    }
  }
  else if (a2)
  {
    if (a1)
    {
      v11 = sub_10004C9BC(33, sub_10024D2C0);
      if ((_DWORD)v11)
      {
        v12 = v11;
        if (sub_10005549C())
        {
          sub_100054530("OI_HCICMD_UserPasskeyRequestReply %!", v12, a3);
          v13 = sub_1000544A0(0x37u);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
LABEL_27:
            sub_1006CEEC0();
        }
      }
    }
    else
    {
      v15 = sub_10004C9BC(34, sub_10024D2C0);
      if ((_DWORD)v15)
      {
        v16 = v15;
        if (sub_10005549C())
        {
          sub_100054530("OI_HCICMD_UserPasskeyRequestNegativeReply %!", v16);
          v17 = sub_1000544A0(0x37u);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
            goto LABEL_27;
        }
      }
    }
  }
  else
  {
    sub_100253460();
    if (sub_10005549C())
    {
      sub_100054530("OI_STATUS_INVALID_PARAMETERS");
      v14 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        goto LABEL_27;
    }
  }
}

void sub_10024D2C0(uint64_t a1)
{
  NSObject *v2;

  if ((_DWORD)a1 && sub_10005549C())
  {
    sub_100054530("status %!", a1);
    v2 = sub_1000544A0(0x37u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
}

void sub_10024D32C(uint64_t a1)
{
  BOOL v1;
  NSObject *v2;
  uint64_t v4;
  NSObject *v5;

  if (HIDWORD(xmmword_100999218))
    v1 = dword_10098FE6C == 0;
  else
    v1 = 1;
  if (v1)
  {
    if (sub_10005549C())
    {
      sub_100054530("!SECMGR_IS_INITIALIZED");
      v2 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  else
  {
    if (!qword_10098FE70 || !*(_QWORD *)(qword_10098FE70 + 64))
      sub_100253460();
    v4 = sub_10019AEA4(a1);
    if (v4)
    {
      if (sub_10024B5B4(v4))
        sub_10024D100(0, a1, 0);
      else
        (*(void (**)(uint64_t))(qword_10098FE70 + 64))(a1);
    }
    else if (sub_10005549C())
    {
      sub_100054530("Invalid connection");
      v5 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
}

void sub_10024D444(uint64_t a1, uint64_t a2)
{
  BOOL v2;
  NSObject *v3;
  void (*v6)(uint64_t, uint64_t);

  if (HIDWORD(xmmword_100999218))
    v2 = dword_10098FE6C == 0;
  else
    v2 = 1;
  if (v2)
  {
    if (sub_10005549C())
    {
      sub_100054530("!SECMGR_IS_INITIALIZED");
      v3 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  else
  {
    if (!qword_10098FE70 || (v6 = *(void (**)(uint64_t, uint64_t))(qword_10098FE70 + 72)) == 0)
    {
      sub_100253460();
      v6 = *(void (**)(uint64_t, uint64_t))(qword_10098FE70 + 72);
    }
    v6(a1, a2);
  }
}

void sub_10024D504(uint64_t a1, uint64_t a2)
{
  BOOL v2;
  NSObject *v3;
  uint64_t v6;
  NSObject *v7;

  if (HIDWORD(xmmword_100999218))
    v2 = dword_10098FE6C == 0;
  else
    v2 = 1;
  if (v2)
  {
    if (sub_10005549C())
    {
      sub_100054530("!SECMGR_IS_INITIALIZED");
      v3 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  else
  {
    if (!qword_10098FE70 || !*(_QWORD *)(qword_10098FE70 + 80))
      sub_100253460();
    v6 = sub_10019AEA4(a1);
    if (v6)
    {
      if (sub_10024B5B4(v6))
        sub_10024D100(0, a1, 0);
      else
        (*(void (**)(uint64_t, uint64_t))(qword_10098FE70 + 80))(a1, a2);
    }
    else if (sub_10005549C())
    {
      sub_100054530("Invalid connection");
      v7 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
}

void sub_10024D634(uint64_t a1)
{
  BOOL v1;
  NSObject *v2;
  uint64_t v4;
  NSObject *v5;

  if (HIDWORD(xmmword_100999218))
    v1 = dword_10098FE6C == 0;
  else
    v1 = 1;
  if (v1)
  {
    if (sub_10005549C())
    {
      sub_100054530("!SECMGR_IS_INITIALIZED");
      v2 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  else
  {
    if (!qword_10098FE70 || !*(_QWORD *)(qword_10098FE70 + 88))
      sub_100253460();
    v4 = sub_10019AEA4(a1);
    if (v4)
    {
      if (sub_10024B5B4(v4))
        sub_10024D758(0, a1, 0, 0, 0, 0);
      else
        (*(void (**)(uint64_t))(qword_10098FE70 + 88))(a1);
    }
    else if (sub_10005549C())
    {
      sub_100054530("Invalid connection");
      v5 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
}

void sub_10024D758(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v12;
  int v13;
  BOOL v14;
  BOOL v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  NSObject *v23;
  NSObject *v24;

  v12 = HIDWORD(xmmword_100999218);
  v13 = dword_10098FE6C;
  if (HIDWORD(xmmword_100999218))
    v14 = dword_10098FE6C == 0;
  else
    v14 = 1;
  if (v14)
  {
    sub_100253460();
    v12 = HIDWORD(xmmword_100999218);
    v13 = dword_10098FE6C;
  }
  if (v12)
    v15 = v13 == 0;
  else
    v15 = 1;
  if (v15)
  {
    if (sub_10005549C())
    {
      sub_100054530("!SECMGR_IS_INITIALIZED");
      v16 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        goto LABEL_41;
    }
    return;
  }
  if (!a2)
  {
    sub_100253460();
    if (sub_10005549C())
    {
      sub_100054530("OI_STATUS_INVALID_PARAMETERS pAddr %:", 0);
      v20 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        goto LABEL_41;
    }
    return;
  }
  if (!a1)
  {
    v21 = sub_10004C9BC(36, sub_10024D9B8);
    if ((_DWORD)v21)
    {
      v22 = v21;
      if (sub_10005549C())
      {
        sub_100054530("OI_HCICMD_RemoteOOBDataRequestNegativeReply %!", v22);
        v23 = sub_1000544A0(0x37u);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          goto LABEL_41;
      }
    }
    return;
  }
  if (a3)
  {
    if (a4)
      goto LABEL_19;
  }
  else
  {
    sub_100253460();
    if (a4)
    {
LABEL_19:
      if (a5)
        goto LABEL_20;
LABEL_37:
      sub_100253460();
      if (a6)
        goto LABEL_21;
LABEL_38:
      sub_100253460();
      goto LABEL_39;
    }
  }
  sub_100253460();
  if (!a5)
    goto LABEL_37;
LABEL_20:
  if (!a6)
    goto LABEL_38;
LABEL_21:
  if (!a5 || !a3 || !a4)
  {
LABEL_39:
    if (sub_10005549C())
    {
      sub_100054530("oob data %!", 101);
      v24 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        goto LABEL_41;
    }
    return;
  }
  v17 = sub_10004C9BC(39, sub_10024D9B8);
  if ((_DWORD)v17)
  {
    v18 = v17;
    if (sub_10005549C())
    {
      sub_100054530("OI_HCICMD_RemoteOOBDataRequestReply %!", v18, a3, a4, a5, a6);
      v19 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
LABEL_41:
        sub_1006CEEC0();
    }
  }
}

void sub_10024D9B8(uint64_t a1)
{
  NSObject *v2;

  if ((_DWORD)a1 && sub_10005549C())
  {
    sub_100054530("status %!", a1);
    v2 = sub_1000544A0(0x37u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
}

void sub_10024DA24(uint64_t a1)
{
  int v1;
  BOOL v2;
  NSObject *v3;
  unsigned int v5;
  const char *v7;
  NSObject *v9;
  NSObject *v10;
  char *v11;
  NSObject *v12;
  NSObject *v13;

  v1 = dword_10098FE6C;
  if (HIDWORD(xmmword_100999218))
    v2 = dword_10098FE6C == 0;
  else
    v2 = 1;
  if (v2)
  {
    if (sub_10005549C())
    {
      sub_100054530("!SECMGR_IS_INITIALIZED");
      v3 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  else
  {
    if (!qword_10098FE70 || !*(_QWORD *)(qword_10098FE70 + 24) || !*(_QWORD *)qword_10098FE70)
    {
      sub_100253460();
      v1 = dword_10098FE6C;
    }
    v5 = 20;
    switch(v1)
    {
      case 1:
        return;
      case 2:
      case 5:
        if (*(_DWORD *)a1 != dword_10098FE78 || *(unsigned __int16 *)(a1 + 4) != (unsigned __int16)word_10098FE7C)
          goto LABEL_43;
        BYTE1(dword_10098FE88) = 1;
        (*(void (**)(uint64_t))qword_10098FE70)(a1);
        if (dword_10098FE6C != 2)
          goto LABEL_38;
        if (DWORD2(xmmword_10098FE90) == 1)
          goto LABEL_43;
        if (DWORD2(xmmword_10098FE90) == 2)
        {
          DWORD2(xmmword_10098FE90) = 5;
          goto LABEL_38;
        }
        sub_100253460();
        goto LABEL_43;
      case 3:
        if (*(_DWORD *)a1 != dword_10098FE78 || *(unsigned __int16 *)(a1 + 4) != (unsigned __int16)word_10098FE7C)
          goto LABEL_43;
        if (byte_10098FE69 || xmmword_10098FE90 < 2u || xmmword_10098FE90 > 5u)
        {
LABEL_38:
          (*(void (**)(uint64_t))(qword_10098FE70 + 24))(a1);
        }
        else
        {
          if (sub_10005549C())
          {
            sub_100054530("Non-bondable mode, rejecting IO caps request from %:", a1);
            v9 = sub_1000544A0(0x37u);
            if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
              sub_1006CEEC0();
          }
          v5 = 24;
LABEL_43:
          if (sub_10005549C())
          {
            v11 = dword_10098FE6C > 5 ? "unknown" : off_10091F338[dword_10098FE6C];
            sub_100054530("rejecting %: ioCaps request, secmgrState: %s, %!", a1, v11, v5 + 700);
            v12 = sub_1000544A0(0x37u);
            if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
              sub_1006CEEC0();
          }
          if (sub_10005549C())
          {
            sub_100054530("%:", a1);
            v13 = sub_1000544A0(0x37u);
            if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
              sub_1006CEEC0();
          }
          sub_10024DD60(v5, a1, 0, 0);
        }
        break;
      case 4:
        goto LABEL_43;
      default:
        if (sub_10005549C())
        {
          v7 = dword_10098FE6C > 5 ? "unknown" : off_10091F338[dword_10098FE6C];
          sub_100054530("secmgrState %s (%d)", v7, dword_10098FE6C);
          v10 = sub_1000544A0(0x37u);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
            sub_1006CEEC0();
        }
        sub_100253460();
        v5 = 20;
        goto LABEL_43;
    }
  }
}

void sub_10024DD60(unsigned int a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  int v8;
  int v9;
  BOOL v10;
  BOOL v11;
  NSObject *v12;
  int v13;
  char v14;
  NSObject *v15;
  char *v16;
  NSObject *v17;
  unsigned __int8 v18;
  unsigned int (*v19)(void);
  uint64_t v20;
  uint64_t v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  NSObject *v25;

  v8 = HIDWORD(xmmword_100999218);
  v9 = dword_10098FE6C;
  if (HIDWORD(xmmword_100999218))
    v10 = dword_10098FE6C == 0;
  else
    v10 = 1;
  if (v10)
  {
    sub_100253460();
    v9 = dword_10098FE6C;
    v8 = HIDWORD(xmmword_100999218);
  }
  if (v8)
    v11 = v9 == 0;
  else
    v11 = 1;
  if (v11)
  {
    if (sub_10005549C())
    {
      sub_100054530("!SECMGR_IS_INITIALIZED");
      v12 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        goto LABEL_55;
    }
  }
  else
  {
    if (a2)
    {
      v13 = v9 - 1;
      v14 = 0;
      switch(v13)
      {
        case 0:
        case 3:
          goto LABEL_39;
        case 1:
          v14 = 2;
          goto LABEL_39;
        case 2:
          if (a3 == 3 || BYTE1(xmmword_10098FE90) == 3)
          {
            v14 = xmmword_10098FE90 & 0xFE;
            LOBYTE(dword_10098FE88) = 0;
          }
          else if (a3 == 2 || BYTE1(xmmword_10098FE90) == 2)
          {
            v14 = xmmword_10098FE90 | 1;
            LOBYTE(dword_10098FE88) = 1;
          }
          else if (a3 == 1 || BYTE1(xmmword_10098FE90) == 1)
          {
            v14 = xmmword_10098FE90 | 1;
            LOBYTE(dword_10098FE88) = 1;
          }
          else
          {
            v14 = xmmword_10098FE90 & 0xFE;
            LOBYTE(dword_10098FE88) = 0;
          }
          goto LABEL_39;
        case 4:
          v14 = 4;
LABEL_39:
          if (byte_10098FE69)
            v18 = v14;
          else
            v18 = 0;
          if (!qword_10098FEC8 || (v19 = *(unsigned int (**)(void))qword_10098FEC8) == 0)
          {
            sub_100253460();
            v19 = *(unsigned int (**)(void))qword_10098FEC8;
          }
          if (v19() >= 3)
          {
            v18 |= 1u;
            LOBYTE(dword_10098FE88) = 1;
          }
          if (a1)
          {
            v20 = sub_10004C9BC(37, sub_10024E420);
            if (!(_DWORD)v20)
              return;
            v21 = v20;
            if (!sub_10005549C())
              return;
            sub_100054530("OI_HCICMD_IOCapabilityRequestNegativeReply %!", v21, a1);
            v22 = sub_1000544A0(0x37u);
            if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
              return;
          }
          else
          {
            v23 = sub_10004C9BC(30, sub_10024E420);
            if (!(_DWORD)v23)
              return;
            v24 = v23;
            if (!sub_10005549C())
              return;
            sub_100054530("%!", v24, a3, a4, v18);
            v25 = sub_1000544A0(0x37u);
            if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
              return;
          }
          break;
        default:
          if (sub_10005549C())
          {
            v16 = dword_10098FE6C > 5 ? "unknown" : off_10091F338[dword_10098FE6C];
            sub_100054530("secmgrState %s (%d), %!", v16, dword_10098FE6C, 105);
            v17 = sub_1000544A0(0x37u);
            if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
              sub_1006CEEC0();
          }
          sub_100253460();
          return;
      }
      goto LABEL_55;
    }
    sub_100253460();
    if (sub_10005549C())
    {
      sub_100054530("OI_STATUS_INVALID_PARAMETERS");
      v15 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
LABEL_55:
        sub_1006CEEC0();
    }
  }
}

void sub_10024E0C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v4;
  BOOL v5;
  NSObject *v6;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  char v17;
  int v18;
  NSObject *v19;
  NSObject *v20;
  NSObject *v21;
  uint64_t v22;

  v4 = dword_10098FE6C;
  if (HIDWORD(xmmword_100999218))
    v5 = dword_10098FE6C == 0;
  else
    v5 = 1;
  if (v5)
  {
    if (sub_10005549C())
    {
      sub_100054530("!SECMGR_IS_INITIALIZED");
      v6 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  else
  {
    if (!qword_10098FE70 || !*(_QWORD *)(qword_10098FE70 + 16) || !*(_QWORD *)qword_10098FE70)
    {
      sub_100253460();
      v4 = dword_10098FE6C;
    }
    switch(v4)
    {
      case 1:
        v22 = 0;
        v13 = sub_100182588(a1, &v22);
        if ((_DWORD)v13)
        {
          v14 = v13;
          if (sub_10005549C())
          {
            sub_100054530("IoCapsResponse, internal inconsistency for %:, %!", a1, v14);
            v15 = sub_1000544A0(0x37u);
            if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
              sub_1006CEEC0();
          }
          goto LABEL_38;
        }
        dword_10098FE6C = 3;
        v16 = v22;
        v17 = *(_BYTE *)(v22 + 277);
        if (!v17)
        {
          v17 = 1;
          *(_BYTE *)(v22 + 277) = 1;
        }
        v18 = *(_DWORD *)a1;
        word_10098FE7C = *(_WORD *)(a1 + 4);
        dword_10098FE78 = v18;
        qword_10098FE80 = v16;
        *(_WORD *)((char *)&dword_10098FE88 + 1) = 257;
        LOBYTE(dword_10098FE88) = a4 & 1;
        HIBYTE(dword_10098FE88) = v17 & (BYTE8(xmmword_100998F58) > 3u);
        LOBYTE(xmmword_10098FE90) = a4;
        BYTE1(xmmword_10098FE90) = a2;
        (*(void (**)(uint64_t))qword_10098FE70)(a1);
        goto LABEL_33;
      case 2:
      case 5:
        if (*(_DWORD *)a1 != dword_10098FE78 || *(unsigned __int16 *)(a1 + 4) != (unsigned __int16)word_10098FE7C)
          goto LABEL_38;
        if ((a4 & 1) != 0)
          LOBYTE(dword_10098FE88) = 1;
        if (!BYTE1(dword_10098FE88))
          *(_WORD *)((char *)&dword_10098FE88 + 1) = 256;
LABEL_33:
        (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(qword_10098FE70 + 16))(a1, a2, a3, a4);
        break;
      case 3:
      case 4:
        goto LABEL_38;
      default:
        if (sub_10005549C())
        {
          v12 = dword_10098FE6C > 5 ? "unknown" : off_10091F338[dword_10098FE6C];
          sub_100054530("secmgrState %s (%d)", v12, dword_10098FE6C);
          v19 = sub_1000544A0(0x37u);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
            sub_1006CEEC0();
        }
        sub_100253460();
LABEL_38:
        if (sub_10005549C())
        {
          sub_100054530("Ignoring IoCapsResponse event from %:, %!", a1, 1404);
          v20 = sub_1000544A0(0x37u);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
            sub_1006CEEC0();
        }
        if (sub_1001F4E24() == 6 || sub_1001F4E24() == 12)
        {
          if (sub_10005549C())
          {
            sub_100054530("Unexpected IoCapsResponse event. Forcing disconnect from %:, %!", a1, 19);
            v21 = sub_1000544A0(0x37u);
            if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
              sub_1006CEEC0();
          }
          sub_100180494(a1, 0x13u);
        }
        break;
    }
  }
}

void sub_10024E420(uint64_t a1)
{
  NSObject *v2;

  if ((_DWORD)a1 && sub_10005549C())
  {
    sub_100054530("ioCapsReplyCmdCb %!", a1);
    v2 = sub_1000544A0(0x37u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
}

void sub_10024E48C(int a1, uint64_t a2, uint64_t a3)
{
  int v6;
  int v7;
  BOOL v8;
  BOOL v9;
  NSObject *v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  NSObject *v14;

  v6 = HIDWORD(xmmword_100999218);
  v7 = dword_10098FE6C;
  if (HIDWORD(xmmword_100999218))
    v8 = dword_10098FE6C == 0;
  else
    v8 = 1;
  if (v8)
  {
    sub_100253460();
    v6 = HIDWORD(xmmword_100999218);
    v7 = dword_10098FE6C;
  }
  if (v6)
    v9 = v7 == 0;
  else
    v9 = 1;
  if (v9)
  {
    if (!sub_10005549C())
      return;
    sub_100054530("!SECMGR_IS_INITIALIZED");
    v10 = sub_1000544A0(0x37u);
    if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      return;
LABEL_32:
    sub_1006CEEC0();
    return;
  }
  if (!a2)
  {
    sub_100253460();
    if (a3 || (a1 & 1) == 0)
    {
LABEL_25:
      if (!sub_10005549C())
        return;
      sub_100054530("OI_STATUS_INVALID_PARAMETERS");
      v12 = sub_1000544A0(0x37u);
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        return;
      goto LABEL_32;
    }
LABEL_24:
    sub_100253460();
    goto LABEL_25;
  }
  if (!a3 && a1)
    goto LABEL_24;
  if (dword_10098FE6C == 4)
    sub_10024BCA8(1);
  if (a1)
    v11 = 12;
  else
    v11 = 13;
  v13 = sub_10004C9BC(v11, sub_10024E634);
  if ((_DWORD)v13)
  {
    if (sub_10005549C())
    {
      sub_100054530("OI_SECMGR_PinCode %!", v13);
      v14 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        goto LABEL_32;
    }
  }
}

void sub_10024E634(uint64_t a1, uint64_t a2)
{
  NSObject *v4;

  if ((_DWORD)a1 && sub_10005549C())
  {
    sub_100054530("pinCodeRequestReplyCb %:, %!", a2, a1);
    v4 = sub_1000544A0(0x37u);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
}

void sub_10024E6A4(uint64_t a1)
{
  BOOL v1;
  NSObject *v2;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  int v8;
  char *v9;
  NSObject *v12;
  NSObject *v13;
  uint64_t v14;

  v14 = 0;
  if (HIDWORD(xmmword_100999218))
    v1 = dword_10098FE6C == 0;
  else
    v1 = 1;
  if (v1)
  {
    if (sub_10005549C())
    {
      sub_100054530("!SECMGR_IS_INITIALIZED");
      v2 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  else
  {
    if (!qword_10098FE70 || !*(_QWORD *)(qword_10098FE70 + 48))
      sub_100253460();
    if (byte_10098FE69)
    {
      v4 = sub_100182588(a1, &v14);
      if ((_DWORD)v4)
      {
        v5 = v4;
        if (sub_10005549C())
        {
          sub_100054530("OI_DEVMGR_GetAclHandleFromAddr %!", v5);
          v6 = sub_1000544A0(0x37u);
          if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
            sub_1006CEEC0();
        }
      }
      else
      {
        switch(dword_10098FE6C)
        {
          case 0:
          case 3:
          case 4:
            goto LABEL_43;
          case 1:
            dword_10098FE6C = 4;
            v8 = *(_DWORD *)a1;
            word_10098FE7C = *(_WORD *)(a1 + 4);
            dword_10098FE78 = v8;
            qword_10098FE80 = v14;
            dword_10098FE88 = 0;
            break;
          case 2:
            if (*(_DWORD *)a1 == dword_10098FE78 && *(unsigned __int16 *)(a1 + 4) == (unsigned __int16)word_10098FE7C)
            {
              switch(DWORD2(xmmword_10098FE90))
              {
                case 0:
                case 4:
                  goto LABEL_43;
                case 1:
                case 2:
                  DWORD2(xmmword_10098FE90) = 3;
                  goto LABEL_37;
                case 3:
                  goto LABEL_37;
                default:
                  if (sub_10005549C())
                  {
                    sub_100054530("curContext.u.bondingContext.substate %d, %!", DWORD2(xmmword_10098FE90), 105);
                    v13 = sub_1000544A0(0x37u);
                    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
                      sub_1006CEEC0();
                  }
                  sub_10024C5CC(105);
                  goto LABEL_42;
              }
            }
            goto LABEL_43;
          case 5:
            if (*(_DWORD *)a1 != dword_10098FE78 || *(unsigned __int16 *)(a1 + 4) != (unsigned __int16)word_10098FE7C)
              goto LABEL_43;
            break;
          default:
            if (sub_10005549C())
            {
              v9 = dword_10098FE6C > 5 ? "unknown" : off_10091F338[dword_10098FE6C];
              sub_100054530("secmgrState %s (%d), %!", v9, dword_10098FE6C, 105);
              v12 = sub_1000544A0(0x37u);
              if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
                sub_1006CEEC0();
            }
LABEL_42:
            sub_100253460();
            goto LABEL_43;
        }
LABEL_37:
        if ((sub_10024B5B4(v14) & 1) == 0)
        {
          (*(void (**)(uint64_t))(qword_10098FE70 + 48))(a1);
          return;
        }
      }
    }
    else if (sub_10005549C())
    {
      sub_100054530("Non-bondable mode, rejecting pin code request from %:, %!", a1, 1423);
      v7 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
LABEL_43:
    sub_10024E48C(0, a1, 0);
  }
}

void sub_10024E9C8(uint64_t a1)
{
  int v1;
  BOOL v2;
  NSObject *v3;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  _QWORD v13[3];
  unsigned int v14;

  memset(v13, 0, sizeof(v13));
  v14 = 0;
  v1 = dword_10098FE6C;
  if (HIDWORD(xmmword_100999218))
    v2 = dword_10098FE6C == 0;
  else
    v2 = 1;
  if (v2)
  {
    if (sub_10005549C())
    {
      sub_100054530("!SECMGR_IS_INITIALIZED");
      v3 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    return;
  }
  if (!qword_10098FE70 || !*(_QWORD *)(qword_10098FE70 + 32))
  {
    sub_100253460();
    v1 = dword_10098FE6C;
  }
  if (v1 == 2)
  {
    switch(DWORD2(xmmword_10098FE90))
    {
      case 0:
      case 3:
      case 4:
      case 5:
      case 6:
        if (!sub_10005549C())
          goto LABEL_17;
        sub_100054530("curContext.u.bondingContext.substate %d, %!", DWORD2(xmmword_10098FE90), 105);
        v5 = sub_1000544A0(0x37u);
        if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
          goto LABEL_17;
        goto LABEL_16;
      case 1:
        DWORD2(xmmword_10098FE90) = 3;
        break;
      case 2:
        break;
      default:
        if (sub_10005549C())
        {
          sub_100054530("Unknown bonding substate %!", 105);
          v9 = sub_1000544A0(0x37u);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
LABEL_16:
            sub_1006CEEC0();
        }
LABEL_17:
        sub_10024C5CC(105);
        sub_100253460();
        break;
    }
  }
  else if (((sub_100229424(a1, (uint64_t)v13) & 1) != 0
          || (*(unsigned int (**)(uint64_t, _QWORD *))(qword_10098FE70 + 32))(a1, v13))
         && (dword_10098FE6C != 5
          || dword_10098FEB8 != 1
          || sub_10024ECAC(HIBYTE(dword_10098FE88), dword_10098FEA8, v14)))
  {
    v6 = sub_10004C9BC(10, sub_10024EF14);
    if ((_DWORD)v6)
    {
      v7 = v6;
      if (sub_10005549C())
      {
        sub_100054530("OI_HCICMD_LinkKeyRequestReply %!", v7, (char *)v13 + 6);
        v8 = sub_1000544A0(0x37u);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
          goto LABEL_34;
      }
    }
    return;
  }
  v10 = sub_10004C9BC(11, sub_10024EF14);
  if ((_DWORD)v10)
  {
    v11 = v10;
    if (sub_10005549C())
    {
      sub_100054530("OI_HCICMD_LinkKeyRequestNegativeReply %!", v11);
      v12 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
LABEL_34:
        sub_1006CEEC0();
    }
  }
}

uint64_t sub_10024ECAC(int a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  NSObject *v10;
  NSObject *v11;

  if (dword_10098FE6C != 5)
    sub_100253460();
  result = 1;
  switch((int)a2)
  {
    case 0:
      return result;
    case 1:
      if (a1)
      {
        if (a3 > 8)
        {
          result = sub_10005549C();
          if ((_DWORD)result)
          {
            sub_100054530("Unhandled keytype", a3);
            v10 = sub_1000544A0(0x37u);
            result = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
            if ((_DWORD)result)
              goto LABEL_34;
          }
        }
        else if (((1 << a3) & 0x1B8) == 0)
        {
          if (((1 << a3) & 7) != 0)
            goto LABEL_8;
          result = sub_10005549C();
          if ((_DWORD)result)
          {
            sub_100054530("keyTypeIsSufficient %!", 1420);
            v11 = sub_1000544A0(0x37u);
            result = os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
            if ((_DWORD)result)
              goto LABEL_34;
          }
        }
      }
      break;
    case 2:
      result = 0;
      if (a3 <= 8)
      {
        if (((1 << a3) & 0x1B8) != 0)
          goto LABEL_21;
        if (!(_DWORD)a3)
          goto LABEL_28;
        if ((_DWORD)a3 == 6)
        {
          result = sub_10005549C();
          if ((_DWORD)result)
          {
            sub_100054530("keyTypeIsSufficient %!", 1420);
            v8 = sub_1000544A0(0x37u);
            result = os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
            if ((_DWORD)result)
              goto LABEL_34;
          }
        }
      }
      break;
    case 3:
      result = 0;
      if (a3 <= 8)
      {
        if (((1 << a3) & 0x1A8) != 0)
        {
LABEL_21:
          result = 1;
        }
        else if ((_DWORD)a3)
        {
          if ((_DWORD)a3 == 6)
          {
            result = sub_10005549C();
            if ((_DWORD)result)
            {
              sub_100054530("keyTypeIsSufficient %!", 1420);
              v9 = sub_1000544A0(0x37u);
              result = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
              if ((_DWORD)result)
                goto LABEL_34;
            }
          }
        }
        else
        {
LABEL_28:
          result = a1 ^ 1u;
        }
      }
      break;
    default:
      result = sub_10005549C();
      if ((_DWORD)result)
      {
        sub_100054530("Invalid security level %d, %!", a2, 105);
        v7 = sub_1000544A0(0x37u);
        result = os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
        if ((_DWORD)result)
        {
LABEL_34:
          sub_1006CEEC0();
LABEL_8:
          result = 0;
        }
      }
      break;
  }
  return result;
}

void sub_10024EF14(uint64_t a1)
{
  NSObject *v2;

  if ((_DWORD)a1 && sub_10005549C())
  {
    sub_100054530("linkKeyRequestReplyCb %!", a1);
    v2 = sub_1000544A0(0x37u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
}

void sub_10024EF80(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v3;
  NSObject *v4;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v10 = 0;
  if (HIDWORD(xmmword_100999218))
    v3 = dword_10098FE6C == 0;
  else
    v3 = 1;
  if (v3)
  {
    if (sub_10005549C())
    {
      sub_100054530("!SECMGR_IS_INITIALIZED");
      v4 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  else
  {
    if (!*(_QWORD *)(qword_10098FE70 + 40))
      sub_100253460();
    if (sub_100182588(a1, &v10) || (v9 = (unsigned __int16)word_10098FEE8, !word_10098FEE8))
    {
LABEL_12:
      v8 = 0;
    }
    else
    {
      v8 = qword_10098FE60;
      while (*(_QWORD *)v8 != v10)
      {
        v8 += 16;
        if (!--v9)
          goto LABEL_12;
      }
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD))(qword_10098FE70 + 40))(a1, a2, a3, byte_10098FE69);
    if (v8)
    {
      if (*(_DWORD *)(v8 + 8) != 2)
        *(_DWORD *)(v8 + 8) = 1;
    }
  }
}

void sub_10024F0B4(uint64_t a1, uint64_t a2)
{
  BOOL v2;
  NSObject *v3;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  NSObject *v11;
  _QWORD v12[3];
  unsigned int v13;

  if (HIDWORD(xmmword_100999218))
    v2 = dword_10098FE6C == 0;
  else
    v2 = 1;
  if (!v2)
  {
    if (dword_10098FE6C == 2 && qword_10098FE80 == a2)
    {
      if (DWORD2(xmmword_10098FE90) > 6)
        goto LABEL_48;
      if (((1 << SBYTE8(xmmword_10098FE90)) & 0x57) == 0)
      {
        HIDWORD(xmmword_10098FE90) = a1;
        sub_10024F3A0();
        goto LABEL_48;
      }
      if (sub_10005549C())
      {
        sub_100054530("curContext.u.bondingContext.substate %d, %!", DWORD2(xmmword_10098FE90), 105);
        v9 = sub_1000544A0(0x37u);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          sub_1006CEEC0();
      }
      sub_10024C5CC(105);
    }
    else
    {
      if (dword_10098FE6C != 5 || qword_10098FE80 != a2)
        goto LABEL_48;
      if (dword_10098FEB8 == 1)
      {
        if (!qword_10098FE70 || !*(_QWORD *)(qword_10098FE70 + 32))
        {
          sub_100253460();
          if (dword_10098FE6C != 5)
            sub_100253460();
        }
        if (dword_10098FEB8 != 1)
          sub_100253460();
        if ((_DWORD)a1)
        {
          v8 = a1;
        }
        else
        {
          memset(v12, 0, sizeof(v12));
          v13 = 0;
          if (((sub_100229424((uint64_t)&dword_10098FE78, (uint64_t)v12) & 1) != 0
             || (*(unsigned int (**)(int *, _QWORD *))(qword_10098FE70 + 32))(&dword_10098FE78, v12))
            && sub_10024ECAC(HIBYTE(dword_10098FE88), dword_10098FEA8, v13))
          {
            sub_10025058C();
            goto LABEL_48;
          }
          if (sub_10005549C())
          {
            sub_100054530("enforceAuthenticationDone %!", 1419);
            v11 = sub_1000544A0(0x37u);
            if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
              sub_1006CEEC0();
          }
          v8 = 1419;
        }
        sub_10024C3C8(v8);
LABEL_48:
        if (off_10098FEE0)
          off_10098FEE0(0, a1, a2 + 48);
        return;
      }
      if (sub_10005549C())
      {
        sub_100054530("curContext.u.enforceContext.substate %d, %!", dword_10098FEB8, 105);
        v10 = sub_1000544A0(0x37u);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
          sub_1006CEEC0();
      }
      sub_10024C3C8(105);
    }
    sub_100253460();
    goto LABEL_48;
  }
  if (sub_10005549C())
  {
    sub_100054530("!SECMGR_IS_INITIALIZED");
    v3 = sub_1000544A0(0x37u);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
}

void sub_10024F3A0()
{
  uint64_t v0;
  uint64_t v1;
  NSObject *v2;

  if (dword_10098FE6C != 2)
    sub_100253460();
  DWORD2(xmmword_10098FE90) = 4;
  v0 = sub_10018096C(sub_1002507F0, (unsigned __int16 *)qword_10098FE80);
  if ((_DWORD)v0)
  {
    v1 = v0;
    if (sub_10005549C())
    {
      sub_100054530("OI_DevMgr_BondingDisconnect %!", v1);
      v2 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    sub_10024C5CC(v1);
  }
}

void sub_10024F448(uint64_t a1, uint64_t a2, __n128 a3)
{
  unsigned int v3;
  BOOL v4;
  NSObject *v5;
  BOOL v8;
  NSObject *v9;

  v3 = dword_10098FE6C;
  if (HIDWORD(xmmword_100999218))
    v4 = dword_10098FE6C == 0;
  else
    v4 = 1;
  if (v4)
  {
    if (sub_10005549C())
    {
      sub_100054530("!SECMGR_IS_INITIALIZED");
      v5 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  else
  {
    if (!qword_10098FE70 || !*(_QWORD *)(qword_10098FE70 + 8))
    {
      sub_100253460();
      v3 = dword_10098FE6C;
    }
    if (v3 < 2
      || (!(*(_DWORD *)a2 ^ dword_10098FE78 | *(unsigned __int16 *)(a2 + 4) ^ (unsigned __int16)word_10098FE7C)
        ? (v8 = BYTE1(dword_10098FE88) == 0)
        : (v8 = 1),
          v8))
    {
      if (sub_10005549C())
      {
        sub_100054530("SimplePairingComplete %:, %!", a2, 1422);
        v9 = sub_1000544A0(0x37u);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          sub_1006CEEC0();
      }
    }
    else
    {
      *(_WORD *)((char *)&dword_10098FE88 + 1) = 0;
      if (v3 == 3)
        a3.n128_f64[0] = sub_10024BCA8(1);
    }
    (*(void (**)(uint64_t, uint64_t, __n128))(qword_10098FE70 + 8))(a2, a1, a3);
  }
}

uint64_t sub_10024F5A8(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, char a6)
{
  const char *v10;
  NSObject *v11;
  void *v12;
  BOOL v13;
  uint64_t v14;
  char *v15;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  int v20;
  NSObject *v21;
  void *v22;
  BOOL v23;
  NSObject *v24;
  int v25;
  char *v26;
  NSObject *v27;
  NSObject *v28;
  uint64_t v29;
  __int128 v30;
  uint8_t buf[4];
  void *v32;

  *(_QWORD *)&v30 = a3;
  *((_QWORD *)&v30 + 1) = a4;
  v29 = 0;
  if (sub_10005549C())
  {
    v10 = sub_10017CA54((uint64_t)&v30);
    sub_100054530("Enforce policy for %:, %s", a2, v10);
    v11 = sub_1000544A0(0x37u);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      v12 = sub_100054494();
      *(_DWORD *)buf = 136446210;
      v32 = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  if (HIDWORD(xmmword_100999218))
    v13 = dword_10098FE6C == 0;
  else
    v13 = 1;
  if (v13)
    return 103;
  if (qword_10098FEC8 && *(_QWORD *)(qword_10098FEC8 + 8))
  {
    if (!a1)
      goto LABEL_20;
  }
  else
  {
    sub_100253460();
    if (!a1)
    {
LABEL_20:
      sub_100253460();
      return 101;
    }
  }
  if (!a2)
    goto LABEL_20;
  if ((dword_10098FE6C - 2) < 4)
  {
    if (sub_10005549C())
    {
      v15 = dword_10098FE6C > 5 ? "unknown" : off_10091F338[dword_10098FE6C];
      sub_100054530("State:  %s, Input Addr %:, Cur Addr %:, Pending Addr %:", v15, a2, &dword_10098FE78, &dword_100999128);
      v21 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        v22 = sub_100054494();
        *(_DWORD *)buf = 136446210;
        v32 = v22;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
    if (dword_100999128)
      v23 = 0;
    else
      v23 = word_10099912C == 0;
    if (v23)
    {
      v14 = 0;
      qword_100999120 = (uint64_t)a1;
      v25 = *(_DWORD *)a2;
      word_10099912C = *(_WORD *)(a2 + 4);
      dword_100999128 = v25;
      xmmword_100999130 = v30;
      LODWORD(qword_100999140) = a5;
      BYTE4(qword_100999140) = a6;
      return v14;
    }
    if (sub_10005549C())
    {
      sub_100054530("Security Mgr Busy with: Cur Addr %:, Pending Addr %:, Input Addr %:", &dword_10098FE78, &dword_100999128, a2);
      v24 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    v14 = 1404;
    goto LABEL_53;
  }
  if (dword_10098FE6C == 1)
  {
    v14 = sub_100182588(a2, &v29);
    if (!(_DWORD)v14)
    {
      v17 = (unsigned __int16)word_10098FEE8;
      if (word_10098FEE8)
      {
        v18 = (_QWORD *)qword_10098FE60;
        while (*v18 != v29)
        {
          v18 += 2;
          if (!--v17)
            goto LABEL_28;
        }
LABEL_29:
        v19 = qword_10098FEC8;
        if (!qword_10098FEC8 || !*(_QWORD *)(qword_10098FEC8 + 8))
        {
          sub_100253460();
          v19 = qword_10098FEC8;
        }
        v20 = *(_DWORD *)a2;
        word_10098FE7C = *(_WORD *)(a2 + 4);
        dword_10098FE78 = v20;
        qword_10098FE80 = v29;
        LOBYTE(dword_10098FE88) = 0;
        HIBYTE(dword_10098FE88) = *(_BYTE *)(v29 + 277) & (BYTE8(xmmword_100998F58) > 3u);
        xmmword_10098FE90 = v30;
        dword_10098FEA0 = a5;
        byte_10098FEA4 = a6;
        dword_10098FEA8 = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(v19 + 8))(v30, *((_QWORD *)&v30 + 1), a2);
        off_10098FEB0 = a1;
        v14 = sub_10004AE90((uint64_t)sub_10024FA2C, 0, 0);
        if (!(_DWORD)v14)
        {
          dword_10098FE6C = 5;
          dword_10098FEB8 = 0;
          return v14;
        }
        goto LABEL_53;
      }
LABEL_28:
      v14 = sub_10024BFC0(v29, 0);
      if (!(_DWORD)v14)
        goto LABEL_29;
    }
  }
  else
  {
    if (sub_10005549C())
    {
      v26 = dword_10098FE6C > 5 ? "unknown" : off_10091F338[dword_10098FE6C];
      sub_100054530("secmgrState %s (%d), %!", v26, dword_10098FE6C, 105);
      v27 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    sub_100253460();
    v14 = 105;
  }
LABEL_53:
  if (sub_10005549C())
  {
    sub_100054530("Enforce Policy error %!", v14);
    v28 = sub_1000544A0(0x37u);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
  return v14;
}

void sub_10024FA2C()
{
  NSObject *v0;
  const char *v1;
  NSObject *v2;
  char *v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  int *v9;
  NSObject *v10;
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  int v14;
  int v15;
  NSObject *v16;
  int v17;
  uint64_t v18;
  const char *v19;
  uint64_t v20;
  const char *v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  NSObject *v25;
  int v26;
  const char *v27;
  NSObject *v28;
  void *v29;
  int v30;
  uint8_t v31[4];
  void *v32;
  __int128 buf;
  uint64_t v34;
  unsigned int v35;

  if (sub_10005549C())
  {
    sub_100054530("Deferred enforcement request");
    v0 = sub_1000544A0(0x37u);
    if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 136446210;
      *(_QWORD *)((char *)&buf + 4) = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, " %{public}s", (uint8_t *)&buf, 0xCu);
    }
  }
  if (!qword_10098FE70 || !*(_QWORD *)(qword_10098FE70 + 32))
    sub_100253460();
  if (dword_10098FE6C != 5
    && (!qword_10098FE80
     || !sub_10019AB28(qword_10098FE80)
     && !sub_10019ABD0(qword_10098FE80)
     && !sub_10019AC00(qword_10098FE80)
     && !sub_10019AC30(qword_10098FE80)))
  {
    if (!sub_10005549C())
      return;
    sub_100054530("Disconnection happened during enforcement, ignoring (enforcementFinish was already called).");
    v4 = sub_1000544A0(0x37u);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      return;
    goto LABEL_54;
  }
  if (!qword_10098FE80
    || !sub_10019AB28(qword_10098FE80)
    && !sub_10019ABD0(qword_10098FE80)
    && !sub_10019AC00(qword_10098FE80)
    && !sub_10019AC30(qword_10098FE80))
  {
    if (!sub_10005549C())
      return;
    sub_100054530("HCI handle not valid can not enforce request");
    v2 = sub_1000544A0(0x37u);
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      return;
    goto LABEL_54;
  }
  if (!*(_DWORD *)(qword_10098FE80 + 148))
  {
    v5 = sub_10017FF38(qword_10098FE80);
    if ((_DWORD)v5)
    {
      v6 = v5;
      if (sub_10005549C())
      {
        sub_100054530("OI_DevMgr_aclActivity failed with %!", v6);
        v7 = sub_1000544A0(0x37u);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
    }
  }
  if (dword_10098FE6C != 5)
    sub_100253460();
  if (dword_10098FEB8)
    sub_100253460();
  if (!qword_10098FEC8 || !*(_QWORD *)(qword_10098FEC8 + 8))
    sub_100253460();
  if (dword_10098FE6C != 5)
  {
    if (!sub_10005549C())
      return;
    v3 = dword_10098FE6C > 5 ? "unknown" : off_10091F338[dword_10098FE6C];
    sub_100054530("enforcementDeferredRequest - %s, %!", v3, 105);
    v12 = sub_1000544A0(0x37u);
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      return;
LABEL_54:
    sub_1006CEEC0();
    return;
  }
  if (dword_10098FEB8)
  {
    if (sub_10005549C())
    {
      if (dword_10098FEB8 > 3)
        v1 = "unknown";
      else
        v1 = off_10091F3A0[dword_10098FEB8];
      sub_100054530("enforcementDeferredRequest - enforceSubstate %s, %!", v1, 105);
      v13 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    v11 = 105;
    goto LABEL_59;
  }
  v8 = (unsigned __int16)word_10098FEE8;
  if (!word_10098FEE8)
  {
LABEL_48:
    if (sub_10005549C())
    {
      sub_100054530("enforcementDeferredRequest - no connection %!", 1408);
      v10 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    v11 = 1408;
    goto LABEL_59;
  }
  v9 = (int *)(qword_10098FE60 + 8);
  while (*((_QWORD *)v9 - 1) != qword_10098FE80)
  {
    v9 += 4;
    if (!--v8)
      goto LABEL_48;
  }
  if (!byte_10098FEA4 || *(_BYTE *)(qword_10098FE80 + 212))
  {
    buf = 0uLL;
    v35 = 0;
    v34 = 0;
    if ((sub_100229424((uint64_t)&dword_10098FE78, (uint64_t)&buf) & 1) != 0)
      v14 = 1;
    else
      v14 = (*(uint64_t (**)(int *, __int128 *))(qword_10098FE70 + 32))(&dword_10098FE78, &buf);
    v15 = *(_BYTE *)(qword_10098FE80 + 277) & (BYTE8(xmmword_100998F58) > 3u);
    if (sub_10005549C())
    {
      sub_100054530("Deferred security enforcement with linkKeyExists %d, remoteSupportsSSP %d, bothTwoDotOne %d, seclevel %d", v14, *(unsigned __int8 *)(qword_10098FE80 + 277), v15, dword_10098FEA8);
      v16 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v31 = 136446210;
        v32 = sub_100054494();
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, " %{public}s", v31, 0xCu);
      }
    }
    if ((dword_10098FEA8 - 2) < 3)
      goto LABEL_102;
    if (dword_10098FEA8 != 1)
    {
      if (dword_10098FEA8)
      {
        if (sub_10005549C())
        {
          v20 = dword_10098FEA8;
          v21 = sub_10017CA54((uint64_t)&off_10098FE90);
          sub_100054530("%d specified for %s, %!", v20, v21, 1418);
          v22 = sub_1000544A0(0x37u);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
            sub_1006CEEC0();
        }
        v11 = 1418;
        goto LABEL_59;
      }
      goto LABEL_97;
    }
    if ((v15 & 1) != 0)
    {
LABEL_102:
      if (sub_10005549C())
      {
        v17 = dword_10098FEA8;
        v18 = *v9;
        if (v18 > 2)
          v19 = "unknown";
        else
          v19 = off_10091F3E8[v18];
        v26 = sub_10024ECAC(HIBYTE(dword_10098FE88), dword_10098FEA8, v35);
        v27 = "not";
        if (v26)
          v27 = "is";
        sub_100054530("Security level %d: state %s, key %s sufficient", v17, v19, v27);
        v28 = sub_1000544A0(0x37u);
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
        {
          v29 = sub_100054494();
          *(_DWORD *)v31 = 136446210;
          v32 = v29;
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, " %{public}s", v31, 0xCu);
        }
      }
      *((_BYTE *)v9 + 4) = 1;
      if (*v9)
        v30 = v14;
      else
        v30 = 0;
      if (v30 != 1 || !sub_10024ECAC(HIBYTE(dword_10098FE88), dword_10098FEA8, v35))
      {
        sub_1002506C0();
        return;
      }
      if (*v9 != 2)
      {
        sub_10025058C();
        return;
      }
    }
LABEL_97:
    v11 = 0;
LABEL_59:
    sub_10024C3C8(v11);
    return;
  }
  v23 = sub_10004A9EC((uint64_t)sub_10024FA2C, 0, 3, 0);
  if ((_DWORD)v23)
  {
    v24 = v23;
    if (sub_10005549C())
    {
      sub_100054530("enforcementDeferredRequest - Could not register function %!", v24);
      v25 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    sub_100180494((uint64_t)&dword_10098FE78, 5u);
    v11 = 1421;
    goto LABEL_59;
  }
}

void sub_10025013C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  const char *v53;
  const char *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  void *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  const char *v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  unint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  const char *v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;

  if (dword_10098FE6C > 5)
    v9 = "unknown";
  else
    v9 = off_10091F338[dword_10098FE6C];
  sub_100253320((uint64_t)"\nsecmgrState: %s\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)v9);
  v17 = dword_10098FE6C;
  if ((dword_10098FE6C - 2) <= 3)
  {
    sub_100253320((uint64_t)"current context:\n", v10, v11, v12, v13, v14, v15, v16, v131);
    sub_100253320((uint64_t)"   addr:          %:\n", v18, v19, v20, v21, v22, v23, v24, (uint64_t)&dword_10098FE78);
    sub_100253320((uint64_t)"   hciHandle:     0x%x\n", v25, v26, v27, v28, v29, v30, v31, (uint64_t)&qword_10098FE80);
    sub_100253320((uint64_t)"   mitm reqd:     %B\n", v32, v33, v34, v35, v36, v37, v38, (uint64_t)&dword_10098FE88);
    sub_100253320((uint64_t)"   sspInProgress: %B\n", v39, v40, v41, v42, v43, v44, v45, (uint64_t)&dword_10098FE88 + 1);
    sub_100253320((uint64_t)"   isRemoteSSP:   %B\n", v46, v47, v48, v49, v50, v51, v52, (uint64_t)&dword_10098FE88 + 2);
    v17 = dword_10098FE6C;
  }
  switch(v17)
  {
    case 5:
      if (dword_10098FEB8 > 3)
        v54 = "unknown";
      else
        v54 = off_10091F3A0[dword_10098FEB8];
      sub_100253320((uint64_t)"   substate:      %s\n", v10, v11, v12, v13, v14, v15, v16, (uint64_t)v54);
      sub_100253320((uint64_t)"   cookie:        0x%x\n", v70, v71, v72, v73, v74, v75, v76, dword_10098FEA0);
      sub_100253320((uint64_t)"   incomingCnct:  %B\n", v77, v78, v79, v80, v81, v82, v83, byte_10098FEA4);
      if (dword_10098FEA8 > 4)
        v91 = "unknown";
      else
        v91 = off_10091F3C0[dword_10098FEA8];
      sub_100253320((uint64_t)"   secLevel:      %s\n", v84, v85, v86, v87, v88, v89, v90, (uint64_t)v91);
      v69 = off_10098FEB0;
      break;
    case 3:
      sub_100253320((uint64_t)"   authReqs:      %d\n", v10, v11, v12, v13, v14, v15, v16, off_10098FE90);
      goto LABEL_22;
    case 2:
      if (dword_10098FE98 > 6)
        v53 = "unknown";
      else
        v53 = off_10091F368[dword_10098FE98];
      sub_100253320((uint64_t)"   substate:      %s\n", v10, v11, v12, v13, v14, v15, v16, (uint64_t)v53);
      sub_100253320((uint64_t)"   finalStatus:   %!\n", v55, v56, v57, v58, v59, v60, v61, dword_10098FE9C);
      v69 = off_10098FE90;
      break;
    default:
      goto LABEL_22;
  }
  sub_100253320((uint64_t)"   callback:      0x%x\n", v62, v63, v64, v65, v66, v67, v68, (uint64_t)v69);
LABEL_22:
  sub_100253320((uint64_t)"bondable: %B\n", v10, v11, v12, v13, v14, v15, v16, byte_10098FE69);
  sub_100253320((uint64_t)"Connections known to secmgr: %d\n", v92, v93, v94, v95, v96, v97, v98, (unsigned __int16)word_10098FEE8);
  if (word_10098FEE8)
  {
    v106 = 0;
    v107 = 0;
    do
    {
      sub_100253320((uint64_t)"   %: ", v99, v100, v101, v102, v103, v104, v105, *(_QWORD *)(qword_10098FE60 + v106) + 48);
      v115 = *(int *)(qword_10098FE60 + v106 + 8);
      v116 = "unknown";
      if (v115 <= 2)
        v116 = off_10091F3E8[v115];
      sub_100253320((uint64_t)", state %s", v108, v109, v110, v111, v112, v113, v114, (uint64_t)v116);
      if (*(_BYTE *)(qword_10098FE60 + v106 + 13))
        sub_100253320((uint64_t)", auto-rejecting", v117, v118, v119, v120, v121, v122, v123, v132);
      sub_100253320((uint64_t)"\n", v117, v118, v119, v120, v121, v122, v123, v132);
      ++v107;
      v106 += 16;
    }
    while (v107 < (unsigned __int16)word_10098FEE8);
  }
  sub_100253320((uint64_t)"Pending Enforcement Req: %:, cb %x, cookie %x, incoming %d\n", v99, v100, v101, v102, v103, v104, v105, (uint64_t)&dword_100999128);
  sub_100253320((uint64_t)"\n", v124, v125, v126, v127, v128, v129, v130, a9);
}

void sub_100250498(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;

  v1 = *(_QWORD *)(a1 + 8);
  v2 = v1 + 8;
  v3 = sub_10024F5A8(*(void **)v1, v1 + 8, *(_QWORD *)(v1 + 16), *(_QWORD *)(v1 + 24), *(_DWORD *)(v1 + 32), *(_BYTE *)(v1 + 36));
  if (v3 && v3 != 1301)
  {
    v4 = sub_10005549C();
    if ((_DWORD)v4)
    {
      v16 = v2;
      sub_100054530("PolicyEnforceReq failed addr %:, status %!");
      v12 = sub_1000544A0(0x37u);
      v4 = os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
      if ((_DWORD)v4)
        sub_1006CEEC0();
    }
    sub_10025013C(v4, v5, v6, v7, v8, v9, v10, v11, v16);
    v13 = sub_100180494(v2, 0xEu);
    if ((_DWORD)v13)
    {
      v14 = v13;
      if (sub_10005549C())
      {
        sub_100054530("PolicyEnforceReq Disconnect failed %!", v14);
        v15 = sub_1000544A0(0x37u);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          sub_1006CEEC0();
      }
    }
    sub_100253460();
  }
}

void sub_10025058C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  uint8_t buf[4];
  void *v12;

  if (sub_10005549C())
  {
    sub_100054530("Send set encryption on");
    v7 = sub_1000544A0(0x37u);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v12 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  v8 = sub_100196768(0x10u, v0, v1, v2, v3, v4, v5, v6, qword_10098FE80);
  if ((_DWORD)v8)
  {
    v9 = v8;
    if (sub_10005549C())
    {
      sub_100054530("OI_HCICMD_SetConnectionEncryption %!", v9, 1);
      v10 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    sub_10024C3C8(v9);
  }
  else
  {
    dword_10098FEB8 = 2;
  }
}

void sub_1002506C0()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  uint8_t buf[4];
  void *v12;

  if (sub_10005549C())
  {
    sub_100054530("Send authentication request");
    v7 = sub_1000544A0(0x37u);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v12 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  v8 = sub_100196768(0xFu, v0, v1, v2, v3, v4, v5, v6, qword_10098FE80);
  if ((_DWORD)v8)
  {
    v9 = v8;
    if (sub_10005549C())
    {
      sub_100054530("OI_HCICMD_AuthenticationRequested %!", v9);
      v10 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
    sub_10024C3C8(v9);
  }
  else
  {
    dword_10098FEB8 = 1;
  }
}

void sub_1002507F0(uint64_t a1)
{
  NSObject *v2;

  if ((_DWORD)a1)
  {
    if (sub_10005549C())
    {
      sub_100054530("bondingDisconnectCb %!", a1);
      v2 = sub_1000544A0(0x37u);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_1006CEEC0();
    }
  }
  sub_10024C5CC(a1);
}

void sub_100250864(uint64_t a1)
{
  double v2;
  NSObject *v3;

  if (dword_10098FE6C != 2)
    sub_100253460();
  if (!(_QWORD)xmmword_10098FE90)
    sub_100253460();
  if (!HIDWORD(xmmword_10098FE90))
    HIDWORD(xmmword_10098FE90) = a1;
  sub_100180714();
  DWORD2(xmmword_10098FE90) = 6;
  v2 = sub_10024BCA8(1);
  if ((_QWORD)xmmword_10098FE90)
  {
    ((void (*)(_QWORD, double))xmmword_10098FE90)(HIDWORD(xmmword_10098FE90), v2);
  }
  else if (sub_10005549C())
  {
    sub_100054530("bondingFinishWriteAuthCB %!, %!", a1, 123);
    v3 = sub_1000544A0(0x37u);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      sub_1006CEEC0();
  }
}

__int16 *sub_100250944(unint64_t a1)
{
  char v1;

  word_10098FEEA = 30768;
  v1 = a0123456789abcd[(a1 >> 8) & 0xF];
  byte_10098FEEC = a0123456789abcd[(unint64_t)a1 >> 12];
  byte_10098FEED = v1;
  byte_10098FEEE = a0123456789abcd[a1 >> 4];
  byte_10098FEEF = a0123456789abcd[a1 & 0xF];
  byte_10098FEF0 = 0;
  return &word_10098FEEA;
}

const char *sub_10025099C(unsigned int *a1)
{
  if (!a1)
    return "invalid";
  if (*(_QWORD *)a1 == 0x10000000000001 && *((_QWORD *)a1 + 1) == 0x20000EE02000080)
    return "SyncMLServer";
  if (*(_QWORD *)a1 == 0x10000000000002 && *((_QWORD *)a1 + 1) == 0x20000EE02000080)
    return "SyncMLClient";
  if (*(_QWORD *)a1 == 0xFECACADE00000000 && *((_QWORD *)a1 + 1) == 0xFECACADEFECACADELL)
    return "D2D";
  if (*(_QWORD *)a1 == 0xDEFACADE00000000 && *((_QWORD *)a1 + 1) == 0xFECACADEAFDECADELL)
    return "WiapGateWay";
  if (*(_QWORD *)a1 == 0xDEFACADE00000000 && *((_QWORD *)a1 + 1) == 0xFFCACADEAFDECADELL)
    return "WiapSink";
  if (*(_QWORD *)a1 == 0x5F41191DC327ED08 && *((_QWORD *)a1 + 1) == 0x770A6A10A222F286)
    return "WiapGateWay_v2";
  if (*(_QWORD *)a1 == 0x5F41191DC327ED08 && *((_QWORD *)a1 + 1) == 0x780A6A10A222F286)
    return "WiapSink_v2";
  if (*(_QWORD *)a1 == 0x14DAD0B74EC2172 && *((_QWORD *)a1 + 1) == 0x2A72E02B7B99778FLL)
    return "AapServer";
  if (*(_QWORD *)a1 == 0xDE49F4074B7C6F4BLL && *((_QWORD *)a1 + 1) == 0x298F720443ABB9B0)
    return "AapService";
  if (*(_QWORD *)a1 == 0x364B2E573619F31FLL && *((_QWORD *)a1 + 1) == 0xF4A61A9B40B2BFA2)
    return "AapClient";
  if (*(_QWORD *)a1 == 0x2A43B1001E0DE104 && *((_QWORD *)a1 + 1) == 0x41F93A98BADD64B7)
    return "Magnet";
  if (*(_QWORD *)a1 == 0xA24041CD484388ECLL && *((_QWORD *)a1 + 1) == 0xD31FBF505D572797)
    return "Carplay";
  if (*(_QWORD *)a1 == 0x1C454DE166248D2DLL && *((_QWORD *)a1 + 1) == 0x1A29EAAB0173BC88)
    return "CarplayGateway";
  if (*(_QWORD *)(a1 + 1) == 0x8000008000100000 && a1[3] == -80438433)
    return sub_100250C9C(*a1);
  else
    return "unknown";
}

const char *sub_100250C9C(unint64_t a1)
{
  const char *result;

  if ((int)a1 <= 4352)
  {
    if ((int)a1 > 255)
    {
      if ((int)a1 > 4096)
      {
        if ((_DWORD)a1 == 4097)
          return "BrowseGroupDescriptorServiceClassID";
        if ((_DWORD)a1 == 4098)
          return "PublicBrowseGroup";
      }
      else
      {
        if ((_DWORD)a1 == 256)
          return "L2CAP";
        if ((_DWORD)a1 == 4096)
          return "ServiceDiscoveryServerServiceClassID";
      }
      goto LABEL_111;
    }
    result = "NULL";
    switch((int)a1)
    {
      case 0:
        return result;
      case 1:
        result = "SDP";
        break;
      case 2:
        result = "UDP";
        break;
      case 3:
        result = "RFCOMM";
        break;
      case 4:
        result = "TCP";
        break;
      case 5:
        result = "TCS_BIN";
        break;
      case 6:
        result = "TCS_AT";
        break;
      case 8:
        result = "OBEX";
        break;
      case 9:
        result = "IP";
        break;
      case 10:
        result = "FTP";
        break;
      case 12:
        result = "HTTP";
        break;
      case 14:
        result = "WSP";
        break;
      case 15:
        result = "BNEP";
        break;
      case 16:
        result = "UPNP";
        break;
      case 17:
        result = "HIDP";
        break;
      case 18:
        result = "HardcopyControlChannel";
        break;
      case 20:
        result = "HardcopyDataChannel";
        break;
      case 22:
        result = "HardcopyNotification";
        break;
      case 23:
        result = "AVCTP";
        break;
      case 25:
        result = "AVDTP";
        break;
      default:
        goto LABEL_111;
    }
  }
  else
  {
    if ((int)a1 <= 4607)
    {
      switch((int)a1)
      {
        case 4353:
          result = "SerialPort";
          break;
        case 4354:
          result = "LANAccessUsingPPP";
          break;
        case 4355:
          result = "DialupNetworking";
          break;
        case 4356:
          result = "IrMCSync";
          break;
        case 4357:
          result = "OBEXObjectPush";
          break;
        case 4358:
          result = "OBEXFileTransfer";
          break;
        case 4359:
          result = "IrMCSyncCommand";
          break;
        case 4360:
          result = "Headset";
          break;
        case 4361:
          result = "CordlessTelephony";
          break;
        case 4362:
          result = "AudioSource";
          break;
        case 4363:
          result = "AudioSink";
          break;
        case 4364:
          result = "AV_RemoteControlTarget";
          break;
        case 4365:
          result = "AdvancedAudioDistribution";
          break;
        case 4366:
          result = "AV_RemoteControl";
          break;
        case 4367:
          result = "AV_RemoteControlController";
          break;
        case 4368:
          result = "Intercom";
          break;
        case 4369:
          result = "Fax";
          break;
        case 4370:
          result = "HeadsetAudioGateway";
          break;
        case 4371:
          result = "WAP";
          break;
        case 4372:
          result = "WAP_CLIENT";
          break;
        case 4373:
          result = "PANU";
          break;
        case 4374:
          result = "NAP";
          break;
        case 4375:
          result = "GN";
          break;
        case 4376:
          result = "DirectPrinting";
          break;
        case 4377:
          result = "ReferencePrinting";
          break;
        case 4378:
          result = "Imaging";
          break;
        case 4379:
          result = "ImagingResponder";
          break;
        case 4380:
          result = "ImagingAutomaticArchive";
          break;
        case 4381:
          result = "ImagingReferencedObjects";
          break;
        case 4382:
          result = "Handsfree";
          break;
        case 4383:
          result = "HandsfreeAudioGateway";
          break;
        case 4384:
          result = "DirectPrintingReferenceObjectsService";
          break;
        case 4385:
          result = "ReflectedUI";
          break;
        case 4386:
          result = "BasicPrinting";
          break;
        case 4387:
          result = "PrintingStatus";
          break;
        case 4388:
          result = "HumanInterfaceDeviceService";
          break;
        case 4389:
          result = "HardcopyCableReplacement";
          break;
        case 4390:
          result = "HCR_Print";
          break;
        case 4391:
          result = "HCR_Scan";
          break;
        case 4392:
          result = "Common_ISDN_Access";
          break;
        case 4393:
          result = "VideoConferencingGW";
          break;
        case 4394:
          result = "UID_MT";
          break;
        case 4395:
          result = "UID_TA";
          break;
        case 4396:
          result = "Audio_Video";
          break;
        case 4397:
          result = "SIM_Access";
          break;
        case 4398:
          result = "PhonebookAccessClient";
          break;
        case 4399:
          result = "PhonebookAccessServer";
          break;
        case 4400:
          result = "PhonebookAccess";
          break;
        case 4401:
          result = "Headset_HS";
          break;
        case 4402:
          result = "Message_Access_Server";
          break;
        case 4403:
          result = "OI_UUID_Message_Notification_Server";
          break;
        case 4404:
          result = "OI_UUID_Message_Access_Profile";
          break;
        default:
          goto LABEL_111;
      }
      return result;
    }
    if ((int)a1 > 4863)
    {
      if ((int)a1 <= 5119)
      {
        switch((int)a1)
        {
          case 4864:
            result = "ESDP_UPNP_IP_PAN";
            break;
          case 4865:
            result = "ESDP_UPNP_IP_LAP";
            break;
          case 4866:
            result = "ESDP_UPNP_IP_L2CAP";
            break;
          case 4867:
            result = "VideoSource";
            break;
          case 4868:
            result = "VideoSink";
            break;
          case 4869:
            result = "VideoDistribution";
            break;
          default:
            goto LABEL_111;
        }
        return result;
      }
      if ((int)a1 <= 5121)
      {
        if ((_DWORD)a1 == 5120)
          return "Health_Device_Profile";
        else
          return "Health_Device_Profile_Source";
      }
      if ((_DWORD)a1 == 5122)
        return "Health_Device_Profile_Sink";
      if ((_DWORD)a1 == 6145)
        return "GATT";
LABEL_111:
      result = (const char *)&word_10098FEEA;
      word_10098FEEA = 30768;
      byte_10098FEEC = a0123456789abcd[(unsigned __int16)a1 >> 12];
      byte_10098FEED = a0123456789abcd[(a1 >> 8) & 0xF];
      byte_10098FEEE = a0123456789abcd[a1 >> 4];
      byte_10098FEEF = a0123456789abcd[a1 & 0xF];
      byte_10098FEF0 = 0;
      return result;
    }
    switch((int)a1)
    {
      case 4608:
        result = "PnPInformation";
        break;
      case 4609:
        result = "GenericNetworking";
        break;
      case 4610:
        result = "GenericFileTransfer";
        break;
      case 4611:
        result = "GenericAudio";
        break;
      case 4612:
        result = "GenericTelephony";
        break;
      case 4613:
        result = "UPNP_Service";
        break;
      case 4614:
        result = "UPNP_IP_Service";
        break;
      default:
        goto LABEL_111;
    }
  }
  return result;
}

_QWORD *sub_100251288(uint64_t a1, uint64_t a2)
{
  _QWORD *result;

  result = sub_100052DC0(0x28uLL);
  if (result)
  {
    *result = a1;
    result[1] = a2;
    result[2] = 0;
    result[3] = 0;
    *((_DWORD *)result + 8) = 0;
  }
  return result;
}

void sub_1002512C0(_QWORD *ptr)
{
  _QWORD *v2;
  void (*v3)(_QWORD);

  if (ptr)
  {
    while (1)
    {
      v2 = (_QWORD *)ptr[2];
      if (!v2)
        break;
      ptr[2] = v2[1];
      v3 = (void (*)(_QWORD))ptr[1];
      if (v3)
        v3(*v2);
      sub_100053298(v2);
    }
    sub_100053298(ptr);
  }
}

void sub_100251314(uint64_t a1)
{
  _QWORD *v1;
  uint64_t v2;
  void (*v4)(_QWORD);

  v2 = a1 + 16;
  v1 = *(_QWORD **)(a1 + 16);
  if (v1)
  {
    do
    {
      *(_QWORD *)(a1 + 16) = v1[1];
      v4 = *(void (**)(_QWORD))(a1 + 8);
      if (v4)
        v4(*v1);
      sub_100053298(v1);
      v1 = *(_QWORD **)v2;
    }
    while (*(_QWORD *)v2);
  }
  *(_QWORD *)v2 = 0;
  *(_QWORD *)(v2 + 8) = 0;
  *(_DWORD *)(v2 + 16) = 0;
}

_QWORD *sub_100251374(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;
  uint64_t v5;

  result = sub_1002513B8((void (**)(void *, uint64_t, uint64_t))a1, a2, a3);
  if (result)
  {
    v5 = *(_QWORD *)(a1 + 24);
    result[1] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = result;
    if (!v5)
      *(_QWORD *)(a1 + 24) = result;
    ++*(_DWORD *)(a1 + 32);
  }
  return result;
}

_QWORD *sub_1002513B8(void (**a1)(void *, uint64_t, uint64_t), uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  _QWORD *v7;
  void *v8;

  v6 = sub_100052DC0(0x10uLL);
  v7 = v6;
  if (v6)
  {
    v6[1] = 0;
    if (*a1)
    {
      v8 = sub_100052DC0(a3);
      *v7 = v8;
      if (v8)
        (*a1)(v8, a2, a3);
    }
    else
    {
      *v6 = a2;
    }
  }
  return v7;
}

_QWORD *sub_10025142C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;
  uint64_t v5;

  result = sub_1002513B8((void (**)(void *, uint64_t, uint64_t))a1, a2, a3);
  if (result)
  {
    result[1] = 0;
    v5 = *(_QWORD *)(a1 + 24);
    if (v5)
      *(_QWORD *)(v5 + 8) = result;
    *(_QWORD *)(a1 + 24) = result;
    if (!*(_QWORD *)(a1 + 16))
      *(_QWORD *)(a1 + 16) = result;
    ++*(_DWORD *)(a1 + 32);
  }
  return result;
}

_QWORD *sub_10025147C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(_QWORD, uint64_t))
{
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *result;
  uint64_t v13;
  _QWORD *v14;

  v8 = (_QWORD *)(a1 + 16);
  v7 = *(_QWORD **)(a1 + 16);
  if (v7)
  {
    v10 = 0;
    while (1)
    {
      v11 = v7;
      result = (_QWORD *)a4(*v7, a2);
      if (!(_DWORD)result)
        break;
      if ((int)result >= 1)
      {
        result = sub_1002513B8((void (**)(void *, uint64_t, uint64_t))a1, a2, a3);
        if (!result)
          return result;
        result[1] = v11;
        v14 = v10 + 1;
        if (!v10)
          v14 = v8;
        *v14 = result;
        goto LABEL_15;
      }
      v7 = (_QWORD *)v11[1];
      v10 = v11;
      if (!v7)
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    result = sub_1002513B8((void (**)(void *, uint64_t, uint64_t))a1, a2, a3);
    if (result)
    {
      v13 = *(_QWORD *)(a1 + 24);
      if (v13)
        *(_QWORD *)(v13 + 8) = result;
      *(_QWORD *)(a1 + 24) = result;
      if (!*(_QWORD *)(a1 + 16))
        *v8 = result;
LABEL_15:
      ++*(_DWORD *)(a1 + 32);
    }
  }
  return result;
}

uint64_t sub_10025155C(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 16);
  if (v1)
    return *(_QWORD *)v1;
  else
    return 0;
}

uint64_t sub_100251574(uint64_t a1, int a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  void (*v6)(_QWORD);

  if (!a1)
    return 0;
  v3 = *(_QWORD **)(a1 + 16);
  if (!v3)
    return 0;
  v4 = *v3;
  v5 = v3[1];
  if (a2)
  {
    v6 = *(void (**)(_QWORD))(a1 + 8);
    if (v6)
    {
      v6(*v3);
      v3 = *(_QWORD **)(a1 + 16);
    }
  }
  sub_100053298(v3);
  *(_QWORD *)(a1 + 16) = v5;
  if (!v5)
    *(_QWORD *)(a1 + 24) = 0;
  --*(_DWORD *)(a1 + 32);
  return v4;
}

uint64_t sub_1002515E8(uint64_t a1, int a2)
{
  _QWORD *v2;
  _QWORD *v4;
  uint64_t v5;
  void (*v6)(_QWORD);
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v2 = (_QWORD *)(a1 + 16);
  if (!*(_QWORD *)(a1 + 16))
    return 0;
  v4 = *(_QWORD **)(a1 + 24);
  v5 = *v4;
  if (a2)
  {
    v6 = *(void (**)(_QWORD))(a1 + 8);
    if (v6)
    {
      v6(*v4);
      v4 = *(_QWORD **)(a1 + 24);
    }
  }
  sub_100053298(v4);
  v8 = *(_QWORD *)(a1 + 16);
  v7 = *(_QWORD *)(a1 + 24);
  if (v8 == v7)
  {
    v9 = 0;
  }
  else
  {
    do
    {
      v9 = v8;
      v8 = *(_QWORD *)(v8 + 8);
    }
    while (v8 != v7);
    v2 = (_QWORD *)(v9 + 8);
  }
  *v2 = 0;
  *(_QWORD *)(a1 + 24) = v9;
  --*(_DWORD *)(a1 + 32);
  return v5;
}

uint64_t sub_100251684(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t sub_10025168C(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    v1 = *(_QWORD *)(*(_QWORD *)result + 8);
    *(_QWORD *)result = v1;
    return v1 != 0;
  }
  return result;
}

uint64_t sub_1002516A8(uint64_t a1)
{
  return *(_QWORD *)a1;
}

uint64_t sub_1002516B0(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *(_QWORD *)(result + 16);
  if (v2 != a2)
  {
    v3 = *(_QWORD *)(result + 16);
    while (v3)
    {
      v4 = v3;
      v3 = *(_QWORD *)(v3 + 8);
      if (v3 == a2)
      {
        *(_QWORD *)(v4 + 8) = *(_QWORD *)(a2 + 8);
        *(_QWORD *)(a2 + 8) = v2;
        *(_QWORD *)(result + 16) = a2;
        if (*(_QWORD *)(result + 24) == a2)
          *(_QWORD *)(result + 24) = v4;
        return result;
      }
    }
  }
  return result;
}

void sub_1002516FC(uint64_t a1, _QWORD *ptr, int a3)
{
  _QWORD *v3;
  _QWORD *v5;
  uint64_t v6;
  void (*v7)(_QWORD);

  v3 = *(_QWORD **)(a1 + 16);
  if (!v3)
    return;
  if (v3 == ptr)
  {
    v5 = 0;
LABEL_8:
    v6 = ptr[1];
    if (v5)
    {
      v5[1] = v6;
      if (ptr[1])
      {
LABEL_11:
        --*(_DWORD *)(a1 + 32);
        if (a3)
        {
          v7 = *(void (**)(_QWORD))(a1 + 8);
          if (v7)
            v7(*ptr);
        }
        sub_100053298(ptr);
        return;
      }
    }
    else
    {
      *(_QWORD *)(a1 + 16) = v6;
      if (v6)
        goto LABEL_11;
    }
    *(_QWORD *)(a1 + 24) = v5;
    goto LABEL_11;
  }
  while (1)
  {
    v5 = v3;
    v3 = (_QWORD *)v3[1];
    if (!v3)
      break;
    if (v3 == ptr)
      goto LABEL_8;
  }
}

void sub_100251798(_QWORD *a1, _QWORD *ptr, int a3)
{
  _QWORD *v4;
  _QWORD *v6;
  _QWORD *v7;
  BOOL v8;
  _QWORD *v9;
  void (*v10)(_QWORD);

  v4 = (_QWORD *)a1[2];
  if (v4 == ptr)
  {
    sub_100251314((uint64_t)a1);
  }
  else
  {
    v6 = ptr;
    do
    {
      v7 = v4;
      v4 = (_QWORD *)v4[1];
      if (v4)
        v8 = v4 == ptr;
      else
        v8 = 1;
    }
    while (!v8);
    if (v4)
    {
      v7[1] = 0;
      a1[3] = v7;
      if (ptr)
      {
        do
        {
          v9 = v6;
          v6 = (_QWORD *)v6[1];
          if (a3)
          {
            v10 = (void (*)(_QWORD))a1[1];
            if (v10)
              v10(*v9);
          }
          sub_100053298(v9);
        }
        while (v6);
      }
    }
  }
}

double sub_100251830(uint64_t a1)
{
  double result;

  result = -3.59869635e230;
  *(_OWORD *)a1 = xmmword_10073BBA0;
  *(_QWORD *)(a1 + 16) = 0;
  return result;
}

void *sub_100251844(uint64_t a1, __int128 *__src, size_t a3)
{
  __int16 v3;
  __int128 *v4;
  int v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  _OWORD *v10;
  uint64_t v11;
  unsigned __int16 v12;
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;

  v3 = a3;
  v4 = __src;
  v6 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a1 + 16) = v6 + a3;
  if (__CFADD__(v6, (_DWORD)a3))
    ++*(_DWORD *)(a1 + 20);
  v7 = v6 & 0x3F;
  v8 = 64 - v7;
  if (64 - (int)v7 <= a3)
  {
    v10 = (_OWORD *)(a1 + 24);
    memmove((void *)(a1 - v8 + 88), __src, v8);
    v11 = 0;
    do
      v11 += 4;
    while ((_DWORD)v11 != 64);
    sub_100251950((_DWORD *)a1, (int *)(a1 + 24));
    v4 = (__int128 *)((char *)v4 + v8);
    v12 = v3 - v8;
    if (v12 >= 0x40u)
    {
      do
      {
        v13 = 0;
        v14 = *v4;
        v15 = v4[1];
        v16 = v4[3];
        *(_OWORD *)(a1 + 56) = v4[2];
        *(_OWORD *)(a1 + 72) = v16;
        *v10 = v14;
        *(_OWORD *)(a1 + 40) = v15;
        do
          v13 += 4;
        while ((_DWORD)v13 != 64);
        sub_100251950((_DWORD *)a1, (int *)(a1 + 24));
        v4 += 4;
        v12 -= 64;
      }
      while (v12 > 0x3Fu);
    }
    a3 = v12;
    v9 = (void *)(a1 + 24);
  }
  else
  {
    v9 = (void *)(a1 - v8 + 88);
    a3 = a3;
  }
  return memmove(v9, v4, a3);
}

_DWORD *sub_100251950(_DWORD *result, int *a2)
{
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  unint64_t v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  int v72;
  int v73;
  int v74;
  int v75;
  int v76;
  int v77;
  int v78;
  int v79;
  int v80;
  int v81;
  int v82;
  int v83;
  int v84;

  v2 = result[1];
  v4 = result[2];
  v3 = result[3];
  v5 = *a2;
  v6 = a2[1];
  HIDWORD(v7) = *result + *a2 - 680876936 + (v4 & v2 | v3 & ~v2);
  LODWORD(v7) = HIDWORD(v7);
  v8 = (v7 >> 25) + v2;
  HIDWORD(v7) = v3 + v6 - 389564586 + (v2 & v8 | v4 & ~v8);
  LODWORD(v7) = HIDWORD(v7);
  v9 = (v7 >> 20) + v8;
  v10 = a2[2];
  v11 = a2[3];
  HIDWORD(v7) = v4 + v10 + 606105819 + (v8 & v9 | v2 & ~v9);
  LODWORD(v7) = HIDWORD(v7);
  v12 = (v7 >> 15) + v9;
  HIDWORD(v7) = v2 + v11 - 1044525330 + (v9 & v12 | v8 & ~v12);
  LODWORD(v7) = HIDWORD(v7);
  v13 = (v7 >> 10) + v12;
  v15 = a2[4];
  v14 = a2[5];
  HIDWORD(v7) = v15 + v8 - 176418897 + (v12 & v13 | v9 & ~v13);
  LODWORD(v7) = HIDWORD(v7);
  v16 = (v7 >> 25) + v13;
  HIDWORD(v7) = v14 + v9 + 1200080426 + (v13 & v16 | v12 & ~v16);
  LODWORD(v7) = HIDWORD(v7);
  v17 = (v7 >> 20) + v16;
  v18 = a2[6];
  v19 = a2[7];
  HIDWORD(v7) = v18 + v12 - 1473231341 + (v16 & v17 | v13 & ~v17);
  LODWORD(v7) = HIDWORD(v7);
  v20 = (v7 >> 15) + v17;
  HIDWORD(v7) = v19 + v13 - 45705983 + (v17 & v20 | v16 & ~v20);
  LODWORD(v7) = HIDWORD(v7);
  v21 = (v7 >> 10) + v20;
  v22 = a2[8];
  v23 = a2[9];
  HIDWORD(v7) = v22 + v16 + 1770035416 + (v20 & v21 | v17 & ~v21);
  LODWORD(v7) = HIDWORD(v7);
  v24 = (v7 >> 25) + v21;
  HIDWORD(v7) = v23 + v17 - 1958414417 + (v21 & v24 | v20 & ~v24);
  LODWORD(v7) = HIDWORD(v7);
  v25 = (v7 >> 20) + v24;
  v27 = a2[10];
  v26 = a2[11];
  HIDWORD(v7) = v27 + v20 - 42063 + (v24 & v25 | v21 & ~v25);
  LODWORD(v7) = HIDWORD(v7);
  v28 = (v7 >> 15) + v25;
  HIDWORD(v7) = v26 + v21 - 1990404162 + (v25 & v28 | v24 & ~v28);
  LODWORD(v7) = HIDWORD(v7);
  v29 = (v7 >> 10) + v28;
  v31 = a2[12];
  v30 = a2[13];
  HIDWORD(v7) = v31 + v24 + 1804603682 + (v28 & v29 | v25 & ~v29);
  LODWORD(v7) = HIDWORD(v7);
  v32 = (v7 >> 25) + v29;
  HIDWORD(v7) = v30 + v25 - 40341101 + (v29 & v32 | v28 & ~v32);
  LODWORD(v7) = HIDWORD(v7);
  v33 = (v7 >> 20) + v32;
  v35 = a2[14];
  v34 = a2[15];
  HIDWORD(v7) = v35 + v28 - 1502002290 + (v32 & v33 | v29 & ~v33);
  LODWORD(v7) = HIDWORD(v7);
  v36 = (v7 >> 15) + v33;
  HIDWORD(v7) = v34 + v29 + 1236535329 + (v33 & v36 | v32 & ~v36);
  LODWORD(v7) = HIDWORD(v7);
  v37 = (v7 >> 10) + v36;
  HIDWORD(v7) = v6 + v32 - 165796510 + (v37 & v33 | v36 & ~v33);
  LODWORD(v7) = HIDWORD(v7);
  v38 = (v7 >> 27) + v37;
  HIDWORD(v7) = v18 + v33 - 1069501632 + (v38 & v36 | v37 & ~v36);
  LODWORD(v7) = HIDWORD(v7);
  v39 = (v7 >> 23) + v38;
  HIDWORD(v7) = v26 + v36 + 643717713 + (v39 & v37 | v38 & ~v37);
  LODWORD(v7) = HIDWORD(v7);
  v40 = (v7 >> 18) + v39;
  HIDWORD(v7) = v5 + v37 - 373897302 + (v40 & v38 | v39 & ~v38);
  LODWORD(v7) = HIDWORD(v7);
  v41 = (v7 >> 12) + v40;
  HIDWORD(v7) = v14 + v38 - 701558691 + (v41 & v39 | v40 & ~v39);
  LODWORD(v7) = HIDWORD(v7);
  v42 = (v7 >> 27) + v41;
  HIDWORD(v7) = v27 + v39 + 38016083 + (v42 & v40 | v41 & ~v40);
  LODWORD(v7) = HIDWORD(v7);
  v43 = (v7 >> 23) + v42;
  HIDWORD(v7) = v34 + v40 - 660478335 + (v43 & v41 | v42 & ~v41);
  LODWORD(v7) = HIDWORD(v7);
  v44 = (v7 >> 18) + v43;
  HIDWORD(v7) = v15 + v41 - 405537848 + (v44 & v42 | v43 & ~v42);
  LODWORD(v7) = HIDWORD(v7);
  v45 = (v7 >> 12) + v44;
  HIDWORD(v7) = v23 + v42 + 568446438 + (v45 & v43 | v44 & ~v43);
  LODWORD(v7) = HIDWORD(v7);
  v46 = (v7 >> 27) + v45;
  HIDWORD(v7) = v35 + v43 - 1019803690 + (v46 & v44 | v45 & ~v44);
  LODWORD(v7) = HIDWORD(v7);
  v47 = (v7 >> 23) + v46;
  HIDWORD(v7) = v11 + v44 - 187363961 + (v47 & v45 | v46 & ~v45);
  LODWORD(v7) = HIDWORD(v7);
  v48 = (v7 >> 18) + v47;
  HIDWORD(v7) = v22 + v45 + 1163531501 + (v48 & v46 | v47 & ~v46);
  LODWORD(v7) = HIDWORD(v7);
  v49 = (v7 >> 12) + v48;
  HIDWORD(v7) = v30 + v46 - 1444681467 + (v49 & v47 | v48 & ~v47);
  LODWORD(v7) = HIDWORD(v7);
  v50 = (v7 >> 27) + v49;
  HIDWORD(v7) = v10 + v47 - 51403784 + (v50 & v48 | v49 & ~v48);
  LODWORD(v7) = HIDWORD(v7);
  v51 = (v7 >> 23) + v50;
  HIDWORD(v7) = v19 + v48 + 1735328473 + (v51 & v49 | v50 & ~v49);
  LODWORD(v7) = HIDWORD(v7);
  v52 = (v7 >> 18) + v51;
  HIDWORD(v7) = v31 + v49 - 1926607734 + ((v52 ^ v51) & v50 ^ v51);
  LODWORD(v7) = HIDWORD(v7);
  v53 = (v7 >> 12) + v52;
  HIDWORD(v7) = v14 + v50 - 378558 + (v52 ^ v51 ^ v53);
  LODWORD(v7) = HIDWORD(v7);
  v54 = (v7 >> 28) + v53;
  HIDWORD(v7) = v22 + v51 - 2022574463 + (v53 ^ v52 ^ v54);
  LODWORD(v7) = HIDWORD(v7);
  v55 = (v7 >> 21) + v54;
  HIDWORD(v7) = v26 + v52 + 1839030562 + (v54 ^ v53 ^ v55);
  LODWORD(v7) = HIDWORD(v7);
  v56 = (v7 >> 16) + v55;
  HIDWORD(v7) = v35 + v53 - 35309556 + (v55 ^ v54 ^ v56);
  LODWORD(v7) = HIDWORD(v7);
  v57 = (v7 >> 9) + v56;
  HIDWORD(v7) = v6 + v54 - 1530992060 + (v56 ^ v55 ^ v57);
  LODWORD(v7) = HIDWORD(v7);
  v58 = (v7 >> 28) + v57;
  HIDWORD(v7) = v15 + v55 + 1272893353 + (v57 ^ v56 ^ v58);
  LODWORD(v7) = HIDWORD(v7);
  v59 = (v7 >> 21) + v58;
  HIDWORD(v7) = v19 + v56 - 155497632 + (v58 ^ v57 ^ v59);
  LODWORD(v7) = HIDWORD(v7);
  v60 = (v7 >> 16) + v59;
  HIDWORD(v7) = v27 + v57 - 1094730640 + (v59 ^ v58 ^ v60);
  LODWORD(v7) = HIDWORD(v7);
  v61 = (v7 >> 9) + v60;
  HIDWORD(v7) = v30 + v58 + 681279174 + (v60 ^ v59 ^ v61);
  LODWORD(v7) = HIDWORD(v7);
  v62 = (v7 >> 28) + v61;
  HIDWORD(v7) = v5 + v59 - 358537222 + (v61 ^ v60 ^ v62);
  LODWORD(v7) = HIDWORD(v7);
  v63 = (v7 >> 21) + v62;
  HIDWORD(v7) = v11 + v60 - 722521979 + (v62 ^ v61 ^ v63);
  LODWORD(v7) = HIDWORD(v7);
  v64 = (v7 >> 16) + v63;
  HIDWORD(v7) = v18 + v61 + 76029189 + (v63 ^ v62 ^ v64);
  LODWORD(v7) = HIDWORD(v7);
  v65 = (v7 >> 9) + v64;
  HIDWORD(v7) = v23 + v62 - 640364487 + (v64 ^ v63 ^ v65);
  LODWORD(v7) = HIDWORD(v7);
  v66 = (v7 >> 28) + v65;
  HIDWORD(v7) = v31 + v63 - 421815835 + (v65 ^ v64 ^ v66);
  LODWORD(v7) = HIDWORD(v7);
  v67 = (v7 >> 21) + v66;
  HIDWORD(v7) = v34 + v64 + 530742520 + (v66 ^ v65 ^ v67);
  LODWORD(v7) = HIDWORD(v7);
  v68 = (v7 >> 16) + v67;
  HIDWORD(v7) = v10 + v65 - 995338651 + (v67 ^ v66 ^ v68);
  LODWORD(v7) = HIDWORD(v7);
  v69 = (v7 >> 9) + v68;
  HIDWORD(v7) = v5 + v66 - 198630844 + ((v69 | ~v67) ^ v68);
  LODWORD(v7) = HIDWORD(v7);
  v70 = (v7 >> 26) + v69;
  HIDWORD(v7) = v19 + v67 + 1126891415 + ((v70 | ~v68) ^ v69);
  LODWORD(v7) = HIDWORD(v7);
  v71 = (v7 >> 22) + v70;
  HIDWORD(v7) = v35 + v68 - 1416354905 + ((v71 | ~v69) ^ v70);
  LODWORD(v7) = HIDWORD(v7);
  v72 = (v7 >> 17) + v71;
  HIDWORD(v7) = v14 + v69 - 57434055 + ((v72 | ~v70) ^ v71);
  LODWORD(v7) = HIDWORD(v7);
  v73 = (v7 >> 11) + v72;
  HIDWORD(v7) = v31 + v70 + 1700485571 + ((v73 | ~v71) ^ v72);
  LODWORD(v7) = HIDWORD(v7);
  v74 = (v7 >> 26) + v73;
  HIDWORD(v7) = v11 + v71 - 1894986606 + ((v74 | ~v72) ^ v73);
  LODWORD(v7) = HIDWORD(v7);
  v75 = (v7 >> 22) + v74;
  HIDWORD(v7) = v27 + v72 - 1051523 + ((v75 | ~v73) ^ v74);
  LODWORD(v7) = HIDWORD(v7);
  v76 = (v7 >> 17) + v75;
  HIDWORD(v7) = v6 + v73 - 2054922799 + ((v76 | ~v74) ^ v75);
  LODWORD(v7) = HIDWORD(v7);
  v77 = (v7 >> 11) + v76;
  HIDWORD(v7) = v22 + v74 + 1873313359 + ((v77 | ~v75) ^ v76);
  LODWORD(v7) = HIDWORD(v7);
  v78 = (v7 >> 26) + v77;
  HIDWORD(v7) = v34 + v75 - 30611744 + ((v78 | ~v76) ^ v77);
  LODWORD(v7) = HIDWORD(v7);
  v79 = (v7 >> 22) + v78;
  HIDWORD(v7) = v18 + v76 - 1560198380 + ((v79 | ~v77) ^ v78);
  LODWORD(v7) = HIDWORD(v7);
  v80 = (v7 >> 17) + v79;
  HIDWORD(v7) = v30 + v77 + 1309151649 + ((v80 | ~v78) ^ v79);
  LODWORD(v7) = HIDWORD(v7);
  v81 = (v7 >> 11) + v80;
  HIDWORD(v7) = v15 + v78 - 145523070 + ((v81 | ~v79) ^ v80);
  LODWORD(v7) = HIDWORD(v7);
  v82 = (v7 >> 26) + v81;
  HIDWORD(v7) = v26 + v79 - 1120210379 + ((v82 | ~v80) ^ v81);
  LODWORD(v7) = HIDWORD(v7);
  v83 = (v7 >> 22) + v82;
  HIDWORD(v7) = v10 + v80 + 718787259 + ((v83 | ~v81) ^ v82);
  LODWORD(v7) = HIDWORD(v7);
  v84 = (v7 >> 17) + v83;
  HIDWORD(v7) = v23 + v81 - 343485551 + ((v84 | ~v82) ^ v83);
  LODWORD(v7) = HIDWORD(v7);
  *result += v82;
  result[1] = v84 + v2 + (v7 >> 11);
  result[2] = v84 + v4;
  result[3] = v83 + v3;
  return result;
}

double sub_10025232C(_OWORD *a1, uint64_t a2)
{
  uint64_t v4;
  int *v5;
  _BYTE *v6;
  int *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  double result;

  v4 = *(_DWORD *)(a2 + 16) & 0x3F;
  v5 = (int *)(a2 + 24);
  v6 = (_BYTE *)(a2 + 24 + v4);
  *v6 = 0x80;
  v7 = (int *)(v6 + 1);
  if (v4 < 0x38)
  {
    v9 = 55 - v4;
  }
  else
  {
    bzero(v7, v4 ^ 0x3F);
    v8 = 0;
    do
      v8 += 4;
    while ((_DWORD)v8 != 64);
    sub_100251950((_DWORD *)a2, v5);
    v9 = 56;
    v7 = v5;
  }
  bzero(v7, (v9 + 8));
  v10 = 0;
  do
    v10 += 4;
  while ((_DWORD)v10 != 56);
  *(_QWORD *)(a2 + 80) = 8 * *(_QWORD *)(a2 + 16);
  sub_100251950((_DWORD *)a2, v5);
  v11 = 0;
  do
    v11 += 4;
  while ((_DWORD)v11 != 16);
  *a1 = *(_OWORD *)a2;
  *(_QWORD *)(a2 + 80) = 0;
  result = 0.0;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  return result;
}

void sub_10025240C(const char *a1, int a2, const char *a3)
{
  NSObject *v6;
  uint8_t buf[4];
  void *v8;

  if (sub_10005549C())
  {
    sub_100054530("WARNING!!! ByteStream_NumReadBytesAvail fault at File:%s, Line:%d, Func:%s", a1, a2, a3);
    v6 = sub_1000544A0(0x39u);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v8 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
}

uint64_t sub_1002524E0(uint64_t *a1, unsigned int a2, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  int v15;
  unsigned int **v16;
  uint64_t *v17;
  unsigned int **v18;
  uint64_t v19;
  _WORD *v20;
  unsigned __int8 *v21;
  unsigned __int8 *v22;
  __int16 v23;
  uint64_t v24;
  unsigned int *v25;
  unsigned int v26;
  uint64_t *v27;
  _BYTE *v28;
  _WORD *v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  int v33;
  uint64_t *v34;
  uint64_t *v35;
  int v36;
  uint64_t *v37;
  uint64_t v38;
  _BYTE *v39;
  uint64_t v40;
  uint64_t v41;
  unsigned __int16 *v42;
  unsigned int v43;
  unsigned int v44;
  char *v45;
  _BYTE *v46;
  char v47;
  uint64_t v48;
  _DWORD *v49;
  uint64_t v50;
  _DWORD *v51;
  _DWORD *v52;
  unsigned __int16 v53;
  char *v54;
  _BYTE *v55;
  char v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  int v64;
  uint64_t v66;
  uint64_t v68;
  uint64_t *v69;

  if (!a1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c");
  if (!*a1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c");
  v69 = &a9;
  if (a4)
  {
    v10 = a3;
    v12 = 0;
    v13 = a4;
    v68 = a4;
    while (1)
    {
      switch(*(_BYTE *)(v10 + v12))
      {
        case 0:
        case 1:
          v17 = v69++;
          if (*((_BYTE *)a1 + 14) != 1)
            sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c");
          if (*((_BYTE *)a1 + 15))
          {
            v15 = 151;
            goto LABEL_75;
          }
          v38 = *((unsigned __int16 *)a1 + 6);
          if (*((unsigned __int16 *)a1 + 5) <= v38)
            goto LABEL_76;
          v39 = (_BYTE *)*v17;
          v40 = *a1;
          *((_WORD *)a1 + 6) = v38 + 1;
          *v39 = *(_BYTE *)(v40 + v38);
          goto LABEL_77;
        case 2:
        case 3:
        case 0xC:
          v14 = v69++;
          if (*((_BYTE *)a1 + 14) != 1 || a2 >= 2)
            sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c");
          if (*((_BYTE *)a1 + 15))
          {
            v15 = 157;
            goto LABEL_75;
          }
          v19 = *((unsigned __int16 *)a1 + 6);
          if (*((unsigned __int16 *)a1 + 5) - (int)v19 < 2)
            goto LABEL_76;
          v20 = (_WORD *)*v14;
          v21 = (unsigned __int8 *)(*a1 + v19);
          if (a2)
            v22 = v21 + 1;
          else
            v22 = v21;
          if (!a2)
            ++v21;
          *v20 = *v21 | (*v22 << 8);
          v23 = *((_WORD *)a1 + 6) + 2;
          goto LABEL_83;
        case 4:
        case 5:
          v18 = (unsigned int **)v69++;
          if (*((_BYTE *)a1 + 14) != 1 || a2 >= 2)
            sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c");
          if (*((_BYTE *)a1 + 15))
          {
            v15 = 162;
            goto LABEL_75;
          }
          v41 = *((unsigned __int16 *)a1 + 6);
          if (*((unsigned __int16 *)a1 + 5) - (int)v41 < 3)
            goto LABEL_76;
          v42 = (unsigned __int16 *)(*a1 + v41);
          if (a2)
          {
            v44 = *v42++;
            v43 = v44;
          }
          else
          {
            v43 = __rev16(*(unsigned __int16 *)((char *)v42 + 1));
          }
          **v18 = v43 | (*(unsigned __int8 *)v42 << 16);
          v23 = v41 + 3;
          goto LABEL_83;
        case 6:
        case 7:
        case 0xD:
          v16 = (unsigned int **)v69++;
          if (*((_BYTE *)a1 + 14) != 1 || a2 >= 2)
            sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c");
          if (*((_BYTE *)a1 + 15))
          {
            v15 = 168;
            goto LABEL_75;
          }
          v24 = *((unsigned __int16 *)a1 + 6);
          if (*((unsigned __int16 *)a1 + 5) - (int)v24 < 4)
            goto LABEL_76;
          v25 = (unsigned int *)(*a1 + v24);
          if (a2)
            v26 = *v25;
          else
            v26 = bswap32(*v25);
          **v16 = v26;
          v23 = v24 + 4;
          goto LABEL_83;
        case 0xA:
          v27 = v69;
          v28 = (_BYTE *)*v69;
          v69 += 2;
          if (*((_BYTE *)a1 + 14) != 1)
            sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c");
          v29 = (_WORD *)v27[1];
          v66 = *a1;
          v30 = *((unsigned __int16 *)a1 + 6);
          v31 = (unsigned __int16)*v29;
          if (*((_BYTE *)a1 + 15))
          {
            sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c", 174, "OI_STATUS ByteStream_Parse(OI_BYTE_STREAM *, int, const char *, unsigned int, ...)");
            v32 = 0;
          }
          else
          {
            v32 = *((unsigned __int16 *)a1 + 5) - (_DWORD)v30;
          }
          v33 = (unsigned __int16)*v29;
          if (v32 >= v33)
          {
            if ((_DWORD)v31)
            {
              v45 = (char *)(v66 + v30);
              v46 = &v28[v31];
              do
              {
                v47 = *v45++;
                *v28++ = v47;
              }
              while (v28 < v46);
              LOWORD(v33) = *v29;
            }
            *((_WORD *)a1 + 6) += v33;
          }
          else
          {
            *((_BYTE *)a1 + 15) = 1;
          }
          v10 = a3;
          v13 = v68;
          goto LABEL_77;
        case 0xB:
          v34 = v69++;
          if (*((_BYTE *)a1 + 14) != 1 || a2 >= 2)
            sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c");
          if (*((_BYTE *)a1 + 15))
          {
            v15 = 178;
            goto LABEL_75;
          }
          v61 = *((unsigned __int16 *)a1 + 6);
          if (*((unsigned __int16 *)a1 + 5) - (int)v61 < 6)
            goto LABEL_76;
          v62 = *v34;
          v63 = *a1 + v61;
          if (a2)
          {
            sub_10004C878(v62, v63, 6uLL);
          }
          else
          {
            v64 = *(_DWORD *)v63;
            *(_WORD *)(v62 + 4) = *(_WORD *)(v63 + 4);
            *(_DWORD *)v62 = v64;
          }
          v23 = *((_WORD *)a1 + 6) + 6;
          goto LABEL_83;
        case 0xE:
          v35 = v69++;
          if (*((_BYTE *)a1 + 14) != 1)
            sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c");
          if (*((_BYTE *)a1 + 15))
          {
            sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c", 182, "OI_STATUS ByteStream_Parse(OI_BYTE_STREAM *, int, const char *, unsigned int, ...)");
            v36 = *((unsigned __int8 *)a1 + 14);
            *((_BYTE *)a1 + 15) = 1;
            if (v36 != 1)
              sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c");
            goto LABEL_74;
          }
          v48 = *((unsigned __int16 *)a1 + 6);
          if (*((unsigned __int16 *)a1 + 5) - (int)v48 <= 3)
          {
            *((_BYTE *)a1 + 15) = 1;
LABEL_74:
            v15 = 183;
            goto LABEL_75;
          }
          v49 = (_DWORD *)*v35;
          v50 = *a1;
          v51 = (_DWORD *)*v35;
          *v51 = bswap32(*(_DWORD *)(*a1 + v48));
          v52 = v51 + 4;
          v53 = v48 + 4;
          *((_WORD *)a1 + 6) = v53;
          if (*((unsigned __int16 *)a1 + 5) - (unint64_t)v53 < 0xC)
            goto LABEL_76;
          v54 = (char *)(v50 + v53);
          v55 = v49 + 1;
          do
          {
            v56 = *v54++;
            *v55++ = v56;
          }
          while (v55 < (_BYTE *)v52);
          v23 = *((_WORD *)a1 + 6) + 12;
LABEL_83:
          *((_WORD *)a1 + 6) = v23;
LABEL_77:
          if (++v12 == v13)
            goto LABEL_84;
          break;
        case 0x10:
          v37 = v69++;
          if (*((_BYTE *)a1 + 14) != 1)
            sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c");
          if (*((_BYTE *)a1 + 15))
          {
            v15 = 188;
LABEL_75:
            sub_10025240C("/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c", v15, "OI_STATUS ByteStream_Parse(OI_BYTE_STREAM *, int, const char *, unsigned int, ...)");
LABEL_76:
            *((_BYTE *)a1 + 15) = 1;
            goto LABEL_77;
          }
          v57 = *((unsigned __int16 *)a1 + 6);
          if (*((unsigned __int16 *)a1 + 5) - (int)v57 < 16)
            goto LABEL_76;
          v58 = 0;
          v59 = *v37;
          v60 = *a1 + v57;
          do
          {
            *(_BYTE *)(v59 + v58) = *(_BYTE *)(v60 + v58);
            ++v58;
          }
          while (v58 != 16);
          v23 = *((_WORD *)a1 + 6) + 16;
          goto LABEL_83;
        default:
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_bytestream.c");
      }
    }
  }
LABEL_84:
  if (*((_BYTE *)a1 + 15))
    return 1031;
  else
    return 0;
}

uint64_t sub_100252B54(_QWORD *a1)
{
  uint64_t i;
  char *v3;
  uint64_t j;
  _QWORD *v5;
  NSObject *v6;
  uint64_t result;

  if (!dword_1009991EC)
  {
    for (i = 0; i != 10; i += 2)
      qword_10098FEF8[i] = 0;
    dword_1009991EC = 1;
  }
  if (!*a1)
    sub_100253460();
  if (!a1[1])
    sub_100253460();
  v3 = 0;
  for (j = &stru_100000020.vmsize; j != -16; j -= 16)
  {
    v5 = *(_QWORD **)((char *)qword_10098FEF8 + j);
    if (v5)
    {
      if (v5 == a1)
      {
        sub_100253460();
        return 105;
      }
    }
    else
    {
      v3 = (char *)qword_10098FEF8 + j;
    }
  }
  if (v3)
  {
    *(_QWORD *)v3 = a1;
    *((_QWORD *)v3 + 1) = 0x100000001;
    sub_100252C8C((uint64_t)v3);
    if (*((_DWORD *)v3 + 3) == 2)
    {
      if (sub_10005549C())
      {
        sub_100054530("Command chain initiation failed in first command");
        v6 = sub_1000544A0(0x29u);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
          sub_1006D3CC8(v6);
      }
      *(_QWORD *)v3 = 0;
      *((_DWORD *)v3 + 3) = 0;
      return 1023;
    }
    else
    {
      result = 0;
      *((_DWORD *)v3 + 3) = 3;
    }
  }
  else
  {
    sub_100253460();
    return 104;
  }
  return result;
}

uint64_t sub_100252C8C(uint64_t result)
{
  uint64_t v1;
  uint64_t (*v2)(void);
  uint64_t (*v3)(_QWORD);

  v1 = *(int *)(result + 8);
  v2 = *(uint64_t (**)(void))(*(_QWORD *)result + 8 * v1);
  if (v2)
  {
    *(_DWORD *)(result + 8) = v1 + 1;
    return v2();
  }
  else if (*(_DWORD *)(result + 12) == 1)
  {
    *(_DWORD *)(result + 12) = 2;
  }
  else
  {
    v3 = **(uint64_t (***)(_QWORD))result;
    *(_QWORD *)result = 0;
    *(_DWORD *)(result + 12) = 0;
    return v3(0);
  }
  return result;
}

void sub_100252CD4(uint64_t a1)
{
  uint64_t v2;

  if (!dword_1009991EC)
    sub_100253460();
  v2 = 0;
  while (qword_10098FEF8[v2] != a1)
  {
    v2 += 2;
    if (v2 == 10)
    {
      sub_100253460();
      return;
    }
  }
  sub_100252C8C((uint64_t)&qword_10098FEF8[v2]);
}

void sub_100252D38(void (**a1)(uint64_t), uint64_t a2)
{
  uint64_t v4;
  uint64_t *v5;
  void (*v6)(uint64_t);

  if (!dword_1009991EC)
    sub_100253460();
  v4 = 0;
  while ((void (**)(uint64_t))qword_10098FEF8[v4] != a1)
  {
    v4 += 2;
    if (v4 == 10)
    {
      sub_100253460();
      return;
    }
  }
  v5 = &qword_10098FEF8[v4];
  if (*((_DWORD *)v5 + 3) == 1)
  {
    *((_DWORD *)v5 + 3) = 2;
  }
  else
  {
    v6 = *a1;
    *v5 = 0;
    *((_DWORD *)v5 + 3) = 0;
    v6(a2);
  }
}

void *sub_100252DD0()
{
  return memcpy(&unk_10098FF48, &unk_10091F400, 0x238uLL);
}

uint64_t sub_100252DE8(unsigned int a1)
{
  uint64_t result;

  if (a1 >= 0x47)
    sub_100253460();
  result = qword_10098FF48[a1];
  if (!result)
  {
    sub_100253460();
    return qword_10098FF48[a1];
  }
  return result;
}

void sub_100252E2C(uint64_t a1, unsigned int a2)
{
  NSObject *v4;
  NSObject *v5;

  if (a2 >= 0x47)
    sub_100253460();
  if (sub_100253BF0(a2))
    sub_100253460();
  if (sub_100253BF0(a2))
  {
    if (sub_10005549C())
    {
      sub_100054530("OI_ConfigTable_SetConfig fail: module %d is already initialized", a2);
      v4 = sub_1000544A0(0x39u);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
LABEL_8:
        sub_1006D202C();
    }
  }
  else if (a2 == 40 && !sub_100253C24())
  {
    if (sub_10005549C())
    {
      sub_100054530("OI_ConfigTable_SetConfig fail: cannot set Common Configuration");
      v5 = sub_1000544A0(0x39u);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        goto LABEL_8;
    }
  }
  else
  {
    qword_10098FF48[a2] = a1;
  }
}

char *sub_100252F1C(char *result, int a2, _WORD *a3)
{
  int v3;
  char v4;

  LOWORD(v3) = *a3;
  if (a2)
  {
    do
    {
      --a2;
      v4 = *result++;
      v3 = word_10073BBD2[(v4 ^ v3)] ^ ((unsigned __int16)(v3 & 0xFF00) >> 8);
    }
    while ((_WORD)a2);
  }
  *a3 = v3;
  return result;
}

unint64_t sub_100252F58(unint64_t result, _BYTE *a2)
{
  *a2 = byte_10073BDD2[result >> 4] | (16 * byte_10073BDD2[result & 0xF]);
  a2[1] = byte_10073BDD2[(unint64_t)result >> 12] | (16 * byte_10073BDD2[(result >> 8) & 0xF]);
  return result;
}

uint64_t sub_100252F98()
{
  uint64_t result;

  if (qword_100990190)
    free((void *)qword_100990190);
  qword_100990190 = 0;
  dword_100990188 = 0;
  result = qword_100990198;
  if (qword_100990198)
  {
    result = munmap((void *)qword_100990198, dword_100990184);
    qword_100990198 = 0;
  }
  if (dword_10097AA08 != -1)
  {
    shm_unlink("com.apple.bluetooth.magnet.shm");
    result = close(dword_10097AA08);
    dword_10097AA08 = -1;
  }
  return result;
}

char *sub_100253014(unsigned int a1)
{
  if (a1 <= 0x5C)
    return off_10091F638[a1];
  else
    return 0;
}

uint64_t sub_100253034()
{
  nullsub_90();
  return 0;
}

uint64_t sub_10025304C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int128 v9;

  v9 = unk_10091F920;
  sub_1002596F4((uint64_t)&v9, (uint64_t)"%:", a3, a4, a5, a6, a7, a8, a1);
  return sub_10025971C((uint64_t)&v9);
}

uint64_t sub_100253090(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int128 v9;

  v9 = unk_10091F920;
  sub_1002596F4((uint64_t)&v9, (uint64_t)"%@", a3, a4, a5, a6, a7, a8, a1);
  return sub_10025971C((uint64_t)&v9);
}

void sub_1002530D8(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  __int128 v11;
  uint8_t buf[4];
  uint64_t v13;

  v11 = unk_10091F930;
  v2 = sub_1000545AC(&v11, a1, a2);
  if ((_DWORD)v2)
  {
    WORD2(v11) = 0;
    sub_1002596F4((uint64_t)&v11, (uint64_t)"Invalid parameter in debug output %! \"%s\"", v3, v4, v5, v6, v7, v8, v2);
  }
  v9 = sub_1000544A0(0x5Cu);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    v10 = sub_10025971C((uint64_t)&v11);
    *(_DWORD *)buf = 136446210;
    v13 = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
  }
}

void sub_1002531B8(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  __int128 v11;
  uint8_t buf[4];
  uint64_t v13;

  v11 = unk_10091F930;
  v2 = sub_1000545AC(&v11, a1, a2);
  if ((_DWORD)v2)
  {
    WORD2(v11) = 0;
    sub_1002596F4((uint64_t)&v11, (uint64_t)"Invalid parameter in debug output %! \"%s\"", v3, v4, v5, v6, v7, v8, v2);
  }
  v9 = sub_1000544A0(0x58u);
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    v10 = sub_10025971C((uint64_t)&v11);
    *(_DWORD *)buf = 136446210;
    v13 = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
  }
}

uint64_t sub_100253298(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  _QWORD v6[2];

  result = 0xFFFFFFFFLL;
  if (a1 && a2)
  {
    v6[0] = 0;
    v6[1] = a1;
    *(_DWORD *)((char *)v6 + 2) = (unsigned __int16)(a2 - 1);
    if (sub_1000545AC(v6, a3, a4))
    {
      return 0xFFFFFFFFLL;
    }
    else
    {
      result = WORD2(v6[0]);
      *(_BYTE *)(a1 + WORD2(v6[0])) = 0;
    }
  }
  return result;
}

uint64_t sub_1002532F8(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  return sub_100253298(a1, a2, a3, (uint64_t)&a9);
}

void sub_100253320(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1002530D8(a1, (uint64_t)&a9);
}

void sub_100253348(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1002531B8(a1, (uint64_t)&a9);
}

const char *sub_100253370(unsigned int a1)
{
  if (a1 > 2)
    return "unknown";
  else
    return off_10091F940[(char)a1];
}

const char *sub_100253398(int a1)
{
  if (a1 <= 1)
  {
    if (!a1)
      return "sco";
    if (a1 == 1)
      return "acl";
  }
  else
  {
    switch(a1)
    {
      case 2:
        return "esco";
      case 240:
        return "acl-hdr";
      case 241:
        return "acl-hdr-hrb";
    }
  }
  return "unknown";
}

const char *sub_10025340C(unsigned int a1)
{
  if (a1 > 2)
    return "unknown";
  else
    return off_10091F958[(char)a1];
}

const char *sub_100253434(int a1)
{
  const char *v1;

  v1 = "unknown";
  if (a1 == 1)
    v1 = "peripheral";
  if (a1)
    return v1;
  else
    return "central";
}

void sub_100253460()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t (*v8)(_QWORD);
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v0 = qword_1009919A8;
  if (qword_1009919A8 || (v18 = 0, sub_1001E4180(&qword_1009919A8, &v18), (v0 = qword_1009919A8) != 0))
  {
    v8 = *(uint64_t (**)(_QWORD))(v0 + 96);
    if (v8)
    {
      v9 = v8(0);
      if ((_DWORD)v9)
      {
        if ((_DWORD)v9 != 102)
          sub_100253320((uint64_t)"Calling HciDriver_t::triggerCapture failed with status %!", v10, v11, v12, v13, v14, v15, v16, v9);
      }
    }
  }
  else
  {
    sub_100253320((uint64_t)"BT driver not ready yet!, skipping", v1, v2, v3, v4, v5, v6, v7, v17);
  }
}

void *sub_1002534E8(void *result)
{
  off_1009919A0 = result;
  return result;
}

uint64_t sub_1002534F4()
{
  uint64_t result;

  if (off_1009919A0)
    return off_1009919A0();
  return result;
}

void sub_100253508(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint8_t buf[16];
  __int128 v105;
  __int128 v106;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;

  if (sub_10002825C())
  {
    sub_100255B10(a1);
    sub_100253320((uint64_t)"------------------------- Stack Dump reason: %s (%d) ------------------------------\n", v3, v4, v5, v6, v7, v8, v9, v2);
    if ((sub_10010B3D0() & 1) != 0)
    {
      v10 = sub_10005549C();
      v17 = v10;
      if ((v10 & 1) == 0)
        sub_1000477B8();
      if ((int)a1 > 3699)
      {
        if ((_DWORD)a1 == 3700 || (_DWORD)a1 == 3702)
          goto LABEL_14;
      }
      else if ((_DWORD)a1 == 621 || (_DWORD)a1 == 3602)
      {
        goto LABEL_14;
      }
      v118 = 0u;
      v119 = 0u;
      v116 = 0u;
      v117 = 0u;
      v114 = 0u;
      v115 = 0u;
      v112 = 0u;
      v113 = 0u;
      v110 = 0u;
      v111 = 0u;
      v108 = 0u;
      v109 = 0u;
      v106 = 0u;
      v107 = 0u;
      *(_OWORD *)buf = 0u;
      v105 = 0u;
      sub_1002532F8((uint64_t)buf, 256, (uint64_t)"Fatal error detected, reason %! (0x%x)", v12, v13, v14, v15, v16, a1);
      sub_10011D44C((const char *)buf);
LABEL_14:
      v19 = nullsub_90(v10, v11);
      sub_100222BC0(v19, v20, v21, v22, v23, v24, v25, v26);
      sub_1000F4350(v27, v28, v29, v30, v31, v32, v33, v34);
      sub_1001736D8(v35, v36, v37, v38, v39, v40, v41, v42);
      sub_10025013C(v43, v44, v45, v46, v47, v48, v49, v50, v101);
      sub_1001F051C(v51, v52, v53, v54, v55, v56, v57, v58);
      sub_1001DB12C(v59, v60, v61, v62, v63, v64, v65, v66);
      sub_10017FB44(v67, v68, v69, v70, v71, v72, v73, v74, v102);
      sub_10019A930(v75, v76, v77, v78, v79, v80, v81, v82);
      sub_1001A2450(v83, v84, v85, v86, v87, v88, v89, v90, v103);
      nullsub_90(v91, v92);
      sub_100253A68();
      sub_1000DF954(v93, v94, v95, v96, v97, v98, v99, v100);
      if ((v17 & 1) == 0)
        sub_1000478A0();
      return;
    }
    v18 = sub_1000544A0(0x5Cu);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "Stack is not running";
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
    }
  }
}

void *sub_10025369C(uint64_t a1, uint64_t (*a2)(_QWORD))
{
  NSObject *v4;
  NSObject *v5;
  void *result;

  if (dword_1009991F0)
  {
    if (sub_10005549C())
    {
      sub_100054530("OI_Dispatch_Init: %!", 140);
      v4 = sub_1000544A0(0x2Au);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    sub_100253460();
  }
  if (a1)
  {
    if (sub_10005549C())
    {
      sub_100054530("OI_Dispatch_Init: configuration parameter is deprecated");
      v5 = sub_1000544A0(0x2Au);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    sub_100252E2C(a1, 0x2Au);
  }
  if (!sub_100252DE8(0x2Au))
    sub_100253460();
  byte_1009919B0 = 0;
  byte_1009919B8 = 0;
  word_1009919C4 = *(_WORD *)sub_100252DE8(0x2Au);
  result = sub_100114588(24 * (unsigned __int16)word_1009919C4);
  qword_1009919D0 = (uint64_t)result;
  word_1009919C0 = -1;
  off_1009919D8 = a2;
  dword_1009919E0 = -1;
  dword_1009991F0 = 1;
  return result;
}

uint64_t sub_1002537E8(unsigned int a1, int a2)
{
  if (!sub_10004A088(a1))
    return 1001;
  if ((a2 & 0x8000) != 0)
  {
    sub_100253460();
    return 101;
  }
  else
  {
    sub_10004AC7C(qword_1009919D0 + 24 * HIWORD(a1), a2);
    return 0;
  }
}

uint64_t sub_100253848(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(*(_QWORD *)(a1 + 8) + 8))(**(_QWORD **)(a1 + 8));
}

uint64_t sub_100253854(unsigned int a1, int a2)
{
  uint64_t v4;
  int v5;
  uint64_t v7;

  if (!sub_10004A088(a1))
    return 1001;
  v4 = qword_1009919D0;
  v7 = 0;
  sub_10004AD30((uint64_t)&v7);
  v5 = (SWORD2(v7) + 99) / 100 + 10 * v7;
  *(_WORD *)(v4 + 24 * HIWORD(a1) + 2) = v5 + a2;
  if (a2 <= (__int16)(word_1009919C8 - v5))
  {
    word_1009919C8 = v5 + a2;
    if (off_1009919D8)
      off_1009919D8((100 * a2));
  }
  return 0;
}

uint64_t sub_10025391C(unsigned int a1, _WORD *a2)
{
  uint64_t v4;
  uint64_t result;
  uint64_t v6;

  if (!sub_10004A088(a1))
    return 1001;
  v4 = qword_1009919D0;
  v6 = 0;
  sub_10004AD30((uint64_t)&v6);
  result = 0;
  *a2 = *(_WORD *)(v4 + 24 * HIWORD(a1) + 2) + (SWORD2(v6) + 99) / -100 - 10 * v6;
  return result;
}

uint64_t sub_1002539B8(unsigned int a1)
{
  uint64_t v2;
  unsigned int v3;
  uint64_t v4;
  int v5;
  _QWORD *v6;
  uint64_t v8;
  _QWORD *v9;

  if (!sub_10004A088(a1))
    return 1001;
  v8 = 0;
  v9 = 0;
  v2 = qword_1009919D0;
  v3 = HIWORD(a1);
  v4 = qword_1009919D0 + 24 * v3;
  *(_BYTE *)v4 = 1;
  v5 = *(__int16 *)(v4 + 6);
  if (v5)
  {
    LOWORD(v8) = v5;
    v6 = (_QWORD *)(v2 + 24 * v3 + 16);
    if (v5 >= 9)
      v6 = (_QWORD *)*v6;
    v9 = v6;
    (*(void (**)(uint64_t *))(v2 + 24 * v3 + 8))(&v8);
  }
  else
  {
    (*(void (**)(_QWORD))(v2 + 24 * v3 + 8))(0);
  }
  sub_100049FD4((__int16)v3);
  return 0;
}

void sub_100253A68()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;

  v40 = 0;
  sub_10004AD30((uint64_t)&v40);
  sub_100253320((uint64_t)"Dispatcher dump:\n", v0, v1, v2, v3, v4, v5, v6, v39);
  sub_100253320((uint64_t)"   Running\t\t%d\n", v7, v8, v9, v10, v11, v12, v13, byte_1009919B0);
  sub_100253320((uint64_t)"   TableSize\t  %d\n", v14, v15, v16, v17, v18, v19, v20, (unsigned __int16)word_1009919C4);
  sub_100253320((uint64_t)"   max_used_count %d\n", v21, v22, v23, v24, v25, v26, v27, dword_1009919E0);
  v35 = (unsigned __int16)word_1009919C4;
  if (word_1009919C4)
  {
    v36 = 0;
    v37 = 0;
    v38 = qword_1009919D0;
    do
    {
      if (*(_QWORD *)(v38 + v36 + 8))
      {
        sub_100253320((uint64_t)"entry %2d: %18s timeout %d, CBFunc 0x%x\n", v28, v29, v30, v31, v32, v33, v34, v37);
        v38 = qword_1009919D0;
        v35 = (unsigned __int16)word_1009919C4;
      }
      ++v37;
      v36 += 24;
    }
    while (v37 < v35);
  }
}

double sub_100253BB4()
{
  double result;

  result = 0.0;
  xmmword_100999238 = 0u;
  unk_100999248 = 0u;
  xmmword_100999218 = 0u;
  unk_100999228 = 0u;
  xmmword_1009991F8 = 0u;
  unk_100999208 = 0u;
  xmmword_1009991D8 = 0u;
  unk_1009991E8 = 0u;
  unk_1009991B8 = 0u;
  unk_1009991C8 = 0u;
  unk_100999198 = 0u;
  *(_OWORD *)&dword_1009991A8 = 0u;
  unk_100999178 = 0u;
  *(_OWORD *)&dword_100999188 = 0u;
  xmmword_100999158 = 0u;
  unk_100999168 = 0u;
  *(_OWORD *)&dword_100999148 = 0u;
  xmmword_100999254 = 0u;
  return result;
}

uint64_t sub_100253BF0(unsigned int a1)
{
  if (a1 >= 0x47)
    sub_100253460();
  return dword_100999148[a1];
}

BOOL sub_100253C24()
{
  unint64_t v1;
  unint64_t v2;

  if (dword_100999148[0])
    return 0;
  v1 = 0;
  do
  {
    v2 = v1;
    if (v1 == 70)
      break;
  }
  while (!dword_100999148[++v1]);
  return v2 > 0x45;
}

_QWORD *sub_100253C6C(_QWORD *result)
{
  *result = result;
  result[1] = result;
  return result;
}

_QWORD *sub_100253C74(_QWORD *result, uint64_t *a2)
{
  uint64_t v2;

  v2 = *a2;
  *a2 = (uint64_t)result;
  *result = v2;
  result[1] = a2;
  *(_QWORD *)(v2 + 8) = result;
  return result;
}

_QWORD *sub_100253C88(_QWORD *result, uint64_t a2)
{
  _QWORD *v2;

  v2 = *(_QWORD **)(a2 + 8);
  *v2 = result;
  *result = a2;
  result[1] = v2;
  *(_QWORD *)(a2 + 8) = result;
  return result;
}

void sub_100253C9C(_QWORD *a1)
{
  _QWORD *v1;
  uint64_t v2;
  NSObject *v3;

  v1 = (_QWORD *)a1[1];
  if ((_QWORD *)*v1 == a1 && (v2 = *a1, *(_QWORD **)(*a1 + 8) == a1))
  {
    *v1 = v2;
    *(_QWORD *)(v2 + 8) = v1;
  }
  else if (sub_10005549C())
  {
    sub_100054530("Attempt to delete element not in list\n");
    v3 = sub_1000544A0(0x39u);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      sub_1006CEF28(v3);
  }
}

uint64_t sub_100253D1C(_QWORD **a1)
{
  uint64_t v1;

  v1 = (uint64_t)*a1;
  if (*a1 == a1)
    return 0;
  sub_100253C9C(*a1);
  return v1;
}

char *sub_100253D54(unsigned int a1)
{
  char v1;
  char *result;

  v1 = a1;
  result = (char *)sub_100052DC0(24 * a1 + 16);
  if (result)
  {
    *result = v1;
    *(_WORD *)(result + 1) = 0;
    *((_DWORD *)result + 1) = 0;
  }
  return result;
}

uint64_t sub_100253D90(_QWORD *a1, uint64_t a2, char a3)
{
  unsigned __int8 v6;
  char *v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  char *v12;
  unsigned int v13;
  char *v14;
  const void *v15;
  char *v16;
  uint64_t result;

  v6 = *(_BYTE *)a2 + a3;
  v7 = (char *)sub_100052DC0(24 * v6 + 16);
  if (!v7)
    return 106;
  v8 = v7;
  *v7 = v6;
  *(_WORD *)(v7 + 1) = 0;
  *((_DWORD *)v7 + 1) = 0;
  *v7 = *(_BYTE *)a2 + a3;
  v7[1] = *(_BYTE *)(a2 + 1);
  *((_WORD *)v7 + 3) = *(_WORD *)(a2 + 6);
  v7[2] = *(_BYTE *)(a2 + 2);
  *((_WORD *)v7 + 2) = *(_WORD *)(a2 + 4);
  *((_QWORD *)v7 + 1) = *(_QWORD *)(a2 + 8);
  if (*(_BYTE *)(a2 + 2))
  {
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v11 = a2 + v9;
      v12 = &v8[v9];
      *(_WORD *)&v8[v9 + 18] = *(_WORD *)(a2 + v9 + 18);
      v13 = *(unsigned __int8 *)(a2 + v9 + 16);
      if (v13 < 3)
        break;
      if (v13 == 4)
      {
        v12[16] = 4;
        v16 = &v8[v9];
        *((_WORD *)v16 + 17) = *(_WORD *)(a2 + v9 + 34);
        v16[32] = *(_BYTE *)(a2 + v9 + 32);
        sub_100253D90(&v8[v9 + 24], *(_QWORD *)(a2 + v9 + 24), 0);
        goto LABEL_13;
      }
      if (v13 == 3)
      {
        v12[16] = 3;
        v14 = &v8[v9 + 24];
        v15 = (const void *)(a2 + v9 + 24);
LABEL_10:
        memmove(v14, v15, *(unsigned __int16 *)(v11 + 18));
      }
LABEL_13:
      ++v10;
      v9 += 24;
      if (v10 >= *(unsigned __int8 *)(a2 + 2))
        goto LABEL_14;
    }
    v12[16] = 0;
    v14 = (char *)sub_100052DC0(*(unsigned __int16 *)(v11 + 18));
    *((_QWORD *)v12 + 3) = v14;
    if (!v14)
    {
      *((_WORD *)v12 + 9) = 0;
      goto LABEL_13;
    }
    v15 = *(const void **)(a2 + v9 + 24);
    goto LABEL_10;
  }
LABEL_14:
  result = 0;
  *a1 = v8;
  return result;
}

void sub_100253F14(uint64_t a1)
{
  unint64_t v2;
  uint64_t v3;
  unsigned int v4;
  void *v5;

  if (*(_BYTE *)(a1 + 2))
  {
    v2 = 0;
    v3 = a1 + 18;
    do
    {
      v4 = *(unsigned __int8 *)(v3 - 2);
      if (v4 >= 2)
      {
        if (v4 == 4)
        {
          *(_BYTE *)(*(_QWORD *)(v3 + 6) + 1) = *(_BYTE *)(v3 + 14);
          *(_WORD *)(*(_QWORD *)(v3 + 6) + 6) = *(_WORD *)(v3 + 16);
          *(_WORD *)(*(_QWORD *)(v3 + 6) + 4) = *(_WORD *)v3;
          sub_100253F14(*(_QWORD *)(v3 + 6));
        }
      }
      else
      {
        v5 = *(void **)(v3 + 6);
        if (!v5)
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c");
        sub_100053298(v5);
        *(_QWORD *)(v3 + 6) = 0;
      }
      v3 += 24;
      ++v2;
    }
    while (v2 < *(unsigned __int8 *)(a1 + 2));
  }
  *(_DWORD *)(a1 + 4) = 0;
  *(_WORD *)(a1 + 1) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  sub_100053298((void *)a1);
}

void sub_100253FD8(uint64_t a1)
{
  unsigned int v2;
  unint64_t v3;
  uint64_t v4;
  unsigned int v5;
  void *v6;

  v2 = *(unsigned __int8 *)(a1 + 2);
  if (*(_BYTE *)(a1 + 2))
  {
    v3 = 0;
    v4 = a1 + 18;
    do
    {
      v5 = *(unsigned __int8 *)(v4 - 2);
      if (v5 >= 2)
      {
        if (v5 == 4)
        {
          *(_BYTE *)(*(_QWORD *)(v4 + 6) + 1) = *(_BYTE *)(v4 + 14);
          *(_WORD *)(*(_QWORD *)(v4 + 6) + 6) = *(_WORD *)(v4 + 16);
          *(_WORD *)(*(_QWORD *)(v4 + 6) + 4) = *(_WORD *)v4;
        }
      }
      else
      {
        v6 = *(void **)(v4 + 6);
        if (!v6)
          sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c");
        sub_100053298(v6);
        *(_QWORD *)(v4 + 6) = 0;
        v2 = *(unsigned __int8 *)(a1 + 2);
      }
      v4 += 24;
      ++v3;
    }
    while (v3 < v2);
  }
  *(_DWORD *)(a1 + 4) = 0;
  *(_WORD *)(a1 + 1) = 0;
  *(_QWORD *)(a1 + 8) = 0;
}

void sub_100254090(void *a1)
{
  sub_100253FD8((uint64_t)a1);
  sub_100053298(a1);
}

uint64_t sub_1002540B4(uint64_t result)
{
  unsigned int v1;
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;

  *(_BYTE *)(result + 1) = 0;
  *(_DWORD *)(result + 4) = 0;
  v1 = *(unsigned __int8 *)(result + 2);
  if (*(_BYTE *)(result + 2))
  {
    v2 = result;
    v3 = 0;
    v4 = result + 16;
    do
    {
      *(_WORD *)(v2 + 4) += *(_WORD *)(v4 + 2);
      if (*(_BYTE *)v4 == 4)
      {
        result = sub_1002540B4(*(_QWORD *)(v4 + 8));
        v1 = *(unsigned __int8 *)(v2 + 2);
      }
      v4 += 24;
      ++v3;
    }
    while (v3 < v1);
  }
  return result;
}

void sub_100254128(void **ptr, _QWORD *a2, _WORD *a3)
{
  unsigned int v6;
  __int16 v7;

  if (!ptr || !a2 || !a3)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c");
  v6 = *(unsigned __int8 *)ptr;
  if (v6 >= 2)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c");
  if (*((unsigned __int8 *)ptr + 2) != v6)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c");
  if (v6 != 1)
    goto LABEL_11;
  if (!*((_BYTE *)ptr + 16))
  {
    sub_100053298(ptr[3]);
    goto LABEL_11;
  }
  if (*((_BYTE *)ptr + 16) != 2)
  {
LABEL_11:
    v7 = 0;
    *a2 = 0;
    goto LABEL_12;
  }
  *a2 = ptr[3];
  v7 = *((_WORD *)ptr + 9);
LABEL_12:
  *a3 = v7;
  sub_100053298(ptr);
}

void *sub_100254200(char *a1, size_t a2, int a3)
{
  _WORD *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  _WORD *v11;

  if (a1 && (_DWORD)a2)
  {
    v6 = sub_100052DC0(0x28uLL);
    v7 = v6;
    if (v6)
    {
      *v6 = 1;
      v6[3] = 0;
      *((_BYTE *)v6 + 2) = 1;
      v6[2] = a2;
      v8 = sub_100053C48((uint64_t)(v6 + 8), a1, a2, a3);
      if ((_DWORD)v8)
      {
        v9 = v8;
        if (sub_10005549C())
        {
          sub_100054530("OI_MBUF_Wrap - InitCell failed %!", v9);
          v10 = sub_1000544A0(0x30u);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
        sub_100253FD8((uint64_t)v7);
        sub_100053298(v7);
        return 0;
      }
    }
  }
  else
  {
    v11 = sub_100052DC0(0x10uLL);
    v7 = v11;
    if (v11)
    {
      *v11 = 0;
      *((_BYTE *)v11 + 2) = 0;
      *((_DWORD *)v11 + 1) = 0;
    }
  }
  return v7;
}

uint64_t sub_1002542F8(unsigned __int8 *a1, char *a2, size_t size, unsigned int a4)
{
  uint64_t result;
  __int16 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 *v11;
  __int128 v12;
  NSObject *v13;

  if (!a1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c");
  if (!a2)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c");
  if (*((_WORD *)a1 + 3))
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c");
  if (a4 > 2)
    return 101;
  v6 = size;
  if (!(_DWORD)size)
    return 0;
  v7 = a1[2];
  if (v7 >= *a1)
  {
    if (sub_10005549C())
    {
      sub_100054530("MBUF Prepend overflow: alloc %d", *a1);
      v13 = sub_1000544A0(0x30u);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 124;
  }
  else
  {
    if (a1[2])
    {
      v8 = (uint64_t)&a1[24 * a1[2] + 16];
      v9 = v7 - 1;
      do
      {
        v10 = v9;
        v11 = &a1[24 * v9];
        v12 = *((_OWORD *)v11 + 1);
        *(_QWORD *)(v8 + 16) = *((_QWORD *)v11 + 4);
        *(_OWORD *)v8 = v12;
        v8 -= 24;
        --v9;
      }
      while (v10);
    }
    a1[2] = v7 + 1;
    result = sub_100053C48((uint64_t)(a1 + 16), a2, size, a4);
    if (!(_DWORD)result)
      *((_WORD *)a1 + 2) += v6;
  }
  return result;
}

uint64_t sub_10025444C(unsigned __int8 *a1, uint64_t a2)
{
  unsigned int v3;
  uint64_t result;
  unsigned __int8 *v5;
  NSObject *v6;

  v3 = a1[2];
  if (v3 >= *a1)
  {
    if (sub_10005549C())
    {
      sub_100054530("MBUF Append Mbuf overflow: alloc %d", *a1);
      v6 = sub_1000544A0(0x30u);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    return 124;
  }
  else
  {
    result = 0;
    v5 = &a1[24 * v3];
    a1[2] = v3 + 1;
    *((_WORD *)a1 + 2) += *(_WORD *)(a2 + 4);
    v5[16] = 4;
    *((_QWORD *)v5 + 3) = a2;
    *((_WORD *)v5 + 9) = *(_WORD *)(a2 + 4);
    v5[32] = *(_BYTE *)(a2 + 1);
    *((_WORD *)v5 + 17) = *(_WORD *)(a2 + 6);
  }
  return result;
}

uint64_t sub_100254518(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  if (!a1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c");
  v2 = *(unsigned __int16 *)(a1 + 4);
  if (v2 > a2)
  {
    *(_WORD *)(a1 + 4) = a2;
    v2 = a2;
  }
  *(_WORD *)(a1 + 6) = 0;
  *(_BYTE *)(a1 + 1) = 0;
  return v2;
}

uint64_t sub_100254564(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  unsigned __int16 v4;
  unsigned int v5;
  unsigned __int16 *v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  unsigned __int8 v10;
  unsigned int v11;
  BOOL v12;
  unsigned __int16 *v13;
  uint64_t v14;
  int v15;

  if (!a1)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c");
  v2 = *(unsigned __int8 *)(a1 + 1);
  v3 = *(unsigned __int8 *)(a1 + 2);
  if (v2 >= v3)
    sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c");
  v4 = *(_WORD *)(a1 + 6) + *(_WORD *)(a1 + 4);
  *(_WORD *)(a1 + 6) = v4;
  v5 = *(unsigned __int16 *)(a1 + 24 * v2 + 18);
  if (v5 <= v4)
  {
    v6 = (unsigned __int16 *)(a1 + 24 * v2 + 42);
    v7 = v2 + 1;
    do
    {
      LOBYTE(v2) = v7;
      v4 -= v5;
      if (v3 == v7)
        break;
      v8 = *v6;
      v6 += 12;
      LOWORD(v5) = v8;
      ++v7;
    }
    while (v8 <= v4);
    *(_WORD *)(a1 + 6) = v4;
    *(_BYTE *)(a1 + 1) = v2;
  }
  if (v2 == (_DWORD)v3)
  {
    LOWORD(v9) = 0;
    v10 = v3 - 1;
    *(_BYTE *)(a1 + 1) = v10;
    *(_WORD *)(a1 + 6) = *(_WORD *)(a1 + 24 * v10 + 18);
  }
  else
  {
    v11 = *(unsigned __int16 *)(a1 + 24 * v2 + 18);
    v12 = v11 >= v4;
    v9 = v11 - v4;
    if (!v12)
      sub_1001494E0((uint64_t)"/Library/Caches/com.apple.xbs/Sources/MobileBluetooth_base/Stack/corestack/support/oi_mbuf.c");
    if (v2 + 1 < v3)
    {
      v13 = (unsigned __int16 *)(a1 + 24 * v2 + 42);
      v14 = ~(unint64_t)v2 + v3;
      do
      {
        v15 = *v13;
        v13 += 12;
        v9 += v15;
        --v14;
      }
      while (v14);
    }
    if (v9 >= a2)
      LOWORD(v9) = a2;
  }
  *(_WORD *)(a1 + 4) = v9;
  return (unsigned __int16)v9;
}

void sub_1002546B0(uint64_t a1, char *a2, _WORD *a3)
{
  unsigned int v6;
  char v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v12;
  NSObject *v13;

  v6 = *(unsigned __int16 *)(sub_100252DE8(0x2Cu) + 10);
  if (a1)
  {
    if (a2)
      goto LABEL_3;
LABEL_26:
    sub_100253460();
    if (a3)
      goto LABEL_4;
    goto LABEL_27;
  }
  sub_100253460();
  if (!a2)
    goto LABEL_26;
LABEL_3:
  if (a3)
    goto LABEL_4;
LABEL_27:
  sub_100253460();
LABEL_4:
  if (dword_10099920C)
  {
    if (*(_WORD *)(qword_1009919E8 + 20))
    {
      v7 = 0;
      v8 = *(_QWORD *)(qword_1009919E8 + 24);
      v9 = *(unsigned __int16 *)(qword_1009919E8 + 20);
      do
      {
        if (*(_DWORD *)(v8 + 56) >> 18 >= 0x69u
          && (unsigned __int16)*(_DWORD *)(v8 + 56) < *(unsigned __int16 *)(qword_1009919E8 + 20)
          && *(_DWORD *)a1 == *(_DWORD *)v8
          && *(unsigned __int16 *)(a1 + 4) == *(unsigned __int16 *)(v8 + 4))
        {
          if (*(_BYTE *)(v8 + 24))
            v7 = 1;
          v12 = v6 & 0xFFFFFFFD;
          if ((*(_BYTE *)(v8 + 40) & 1) == 0)
            v12 = v6;
          if ((*(_BYTE *)(v8 + 40) & 2) != 0)
            v6 = v12 & 0xFFFFFFFB;
          else
            v6 = v12;
        }
        v8 += 64;
        --v9;
      }
      while (v9);
    }
    else
    {
      v7 = 0;
    }
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("OI_POLICYMGR_GetDevmgrPolicy");
      v13 = sub_1000544A0(0x31u);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        sub_1006D3010();
    }
    v7 = 0;
  }
  *a2 = v7;
  *a3 = v6;
}

uint64_t sub_1002547FC(uint64_t a1)
{
  NSObject *v2;
  uint64_t result;
  uint64_t v4;
  unsigned __int16 *v5;
  _DWORD *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  _DWORD *v11;

  if (a1)
  {
    if (sub_10005549C())
    {
      sub_100054530("OI_POLICYMGR_Init: configuration parameter is deprecated");
      v2 = sub_1000544A0(0x31u);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    sub_100252E2C(a1, 0x31u);
  }
  if (dword_10099920C)
    return 140;
  v4 = sub_100252DE8(0x31u);
  if (v4)
  {
    v5 = (unsigned __int16 *)v4;
    v6 = sub_100114588(0x30uLL);
    qword_1009919E8 = (uint64_t)v6;
    if (v6)
    {
      v6[4] = 0;
      v7 = *v5;
      *((_WORD *)v6 + 10) = v7;
      v8 = sub_100114588(v7 << 6);
      v9 = qword_1009919E8;
      *(_QWORD *)(qword_1009919E8 + 24) = v8;
      if (!v8)
      {
        sub_100253460();
        v9 = qword_1009919E8;
      }
      v10 = *(unsigned __int16 *)(v9 + 20);
      if (*(_WORD *)(v9 + 20))
      {
        v11 = (_DWORD *)(*(_QWORD *)(v9 + 24) + 56);
        do
        {
          *v11 = 0;
          v11 += 16;
          --v10;
        }
        while (v10);
      }
      result = 0;
      *(_WORD *)(v9 + 32) = 420;
      *(_DWORD *)(v9 + 16) = 1;
      *(_QWORD *)(v9 + 40) = 0;
      dword_10099920C = 1;
    }
    else
    {
      return 106;
    }
  }
  else
  {
    sub_100253460();
    return 127;
  }
  return result;
}

void sub_100254920(uint64_t a1)
{
  if (!dword_10099920C)
    sub_100253460();
  *(_QWORD *)(qword_1009919E8 + 40) = a1;
}

uint64_t sub_10025495C(uint64_t a1, uint64_t a2, __int128 *a3, int *a4, char a5)
{
  uint64_t result;
  uint64_t v11;
  unsigned int v12;
  __int16 v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  NSObject *v19;
  int v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  _QWORD v24[2];
  const void *v25[2];

  if (a3 && a2 && a4)
  {
    if (dword_10099920C)
    {
      v25[0] = 0;
      v23 = 0;
      v24[0] = 0;
      result = sub_100182588(a2, &v23);
      if (!(_DWORD)result)
      {
        v11 = qword_1009919E8;
        v12 = (unsigned __int16)(*(_WORD *)(qword_1009919E8 + 32) + 1);
        if (v12 <= 0x1A4)
          v13 = 420;
        else
          v13 = *(_WORD *)(qword_1009919E8 + 32) + 1;
        *(_WORD *)(qword_1009919E8 + 32) = v13;
        v14 = *(unsigned __int16 *)(v11 + 20);
        if (*(_WORD *)(v11 + 20))
        {
          v15 = *(_QWORD *)(v11 + 24);
          if (v12 <= 0x1A4)
            v16 = 420;
          else
            v16 = v12;
          v17 = v16 << 16;
          v18 = v15 + 56;
          while (*(_DWORD *)v18)
          {
            ++v17;
            v18 += 64;
            if (!--v14)
              goto LABEL_16;
          }
          *(_DWORD *)v18 = v17;
          v20 = *(_DWORD *)a2;
          *(_WORD *)(v18 - 52) = *(_WORD *)(a2 + 4);
          *(_DWORD *)(v18 - 56) = v20;
          *(_BYTE *)(v18 + 4) = a5;
          v21 = a3[2];
          v22 = *a3;
          *(_OWORD *)(v18 - 32) = a3[1];
          *(_OWORD *)(v18 - 16) = v21;
          *(_OWORD *)(v18 - 48) = v22;
          v24[1] = a1;
          LODWORD(v24[0]) = v17;
          *a4 = v17;
          v25[1] = v24;
          LOWORD(v25[0]) = 16;
          return sub_10004AE90((uint64_t)sub_100254AE0, v25, 0);
        }
        else
        {
LABEL_16:
          if (sub_10005549C())
          {
            sub_100054530("OI_POLICYMGR_NewConnection: connection list full!");
            v19 = sub_1000544A0(0x31u);
            if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
              sub_1006CE7A4();
          }
          return 104;
        }
      }
    }
    else
    {
      return 103;
    }
  }
  else
  {
    sub_100253460();
    return 101;
  }
  return result;
}

void sub_100254AE0(uint64_t a1)
{
  unsigned __int16 *v1;
  NSObject *v2;
  _BOOL4 v3;
  unsigned int v5;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  NSObject *v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  NSObject *v20;
  uint64_t v21;
  const char *v22;
  NSObject *v23;
  void *v24;
  uint64_t v25;
  const void *v26;
  unsigned __int16 *v27;
  uint8_t buf[4];
  void *v29;

  v26 = 0;
  v27 = 0;
  v1 = *(unsigned __int16 **)(a1 + 8);
  if (sub_10005549C())
  {
    sub_100054530("Trace deferredEnforcerCB, handle 0x%x", *(_DWORD *)v1);
    v2 = sub_1000544A0(0x31u);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v29 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  v3 = sub_1002294E8(*(_QWORD *)(qword_1009919E8 + 24) + ((unint64_t)*v1 << 6));
  if (*(_DWORD *)(qword_1009919E8 + 16) != 1 || v3)
  {
    v25 = 0;
    sub_10004AD30((uint64_t)&v25);
    v5 = sub_10025899C(&dword_1009919F0, (int *)&v25);
    if (dword_1009919F0 && v5 >= 0x258)
      sub_1001131F8(1501, "Policy enforcement timeout");
    if (sub_10005549C())
    {
      v6 = *(int *)(qword_1009919E8 + 16);
      v7 = v6 > 5 ? "unknown" : off_10091FBD8[v6];
      sub_100054530("deferredEnforcerCB busy, reposting request, pmanState %s", v7);
      v16 = sub_1000544A0(0x31u);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        v17 = sub_100054494();
        *(_DWORD *)buf = 136446210;
        v29 = v17;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
      }
    }
    v27 = v1;
    LOWORD(v26) = 16;
    v18 = sub_10004A9EC((uint64_t)sub_100254AE0, &v26, 1, 0);
    if ((_DWORD)v18)
    {
      v19 = v18;
      if (sub_10005549C())
      {
        sub_100054530("OI_Dispatch_RegisterTimedFunc failed %!", v19);
        v20 = sub_1000544A0(0x31u);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      (*((void (**)(_QWORD, uint64_t, _QWORD))v1 + 1))(*(unsigned int *)v1, v19, 0);
    }
    return;
  }
  sub_10004AD30((uint64_t)&dword_1009919F0);
  v8 = qword_1009919E8;
  *(_OWORD *)qword_1009919E8 = *(_OWORD *)v1;
  v9 = *(_QWORD *)(v8 + 24) + ((unint64_t)(unsigned __int16)*(_DWORD *)v8 << 6);
  if (*(_DWORD *)(v9 + 56) != *(_DWORD *)v8)
  {
    if (sub_10005549C())
    {
      sub_100054530("startSecurityPolicyEnforcement, handle %d no longer valid", *(_DWORD *)qword_1009919E8);
      v15 = sub_1000544A0(0x31u);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    v13 = 122;
    v14 = 0;
    goto LABEL_23;
  }
  v10 = sub_10024F5A8(sub_1002556D0, v9, *(_QWORD *)(v9 + 8), *(_QWORD *)(v9 + 16), *(_DWORD *)v8, *(_BYTE *)(v9 + 60));
  if ((_DWORD)v10)
  {
    v11 = v10;
    if (sub_10005549C())
    {
      sub_100054530("OI_SECMGR_EnforcePolicy failed addr %:, status %!", v9, v11);
      v12 = sub_1000544A0(0x31u);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        sub_1006D1FB0(v12);
    }
    v13 = v11;
    v14 = 1;
LABEL_23:
    sub_100255524(v13, v14);
    return;
  }
  if (sub_10005549C())
  {
    v21 = *(int *)(qword_1009919E8 + 16);
    v22 = v21 > 5 ? "unknown" : off_10091FBD8[v21];
    sub_100054530("Trace startSecurityPolicyEnforcement handle %#x : %s --------------------> %s\n\n\n\n", *(_DWORD *)(v9 + 56), v22, "PMAN_ST_DEVMGR_ENFORCE");
    v23 = sub_1000544A0(0x31u);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      v24 = sub_100054494();
      *(_DWORD *)buf = 136446210;
      v29 = v24;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  *(_DWORD *)(qword_1009919E8 + 16) = 2;
}

uint64_t sub_100254EF0(uint64_t a1, uint64_t a2, __int128 *a3, int *a4)
{
  uint64_t result;

  if (!dword_10099920C)
    return 103;
  result = 101;
  if (a2 && a3)
  {
    if (a4)
      return sub_10025495C(a1, a2, a3, a4, 0);
  }
  return result;
}

void sub_100254F2C(unsigned int a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  NSObject *v5;
  NSObject *v6;
  _QWORD v7[2];
  const void *v8[2];
  int v9;
  int v10;
  __int16 v11;

  v11 = 0;
  v10 = 0;
  v8[0] = 0;
  v7[0] = 0;
  if (dword_10099920C)
  {
    if (a1)
    {
      if (a1 >> 18 < 0x69 || (unsigned __int16)a1 >= *(unsigned __int16 *)(qword_1009919E8 + 20))
      {
        if (sub_10005549C())
        {
          sub_100054530("OI_POLICYMGR_Disconnect invalid handle 0x%x", a1);
          v6 = sub_1000544A0(0x31u);
          if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
      }
      else if (sub_1002550D4(a1, (uint64_t)&v10))
      {
        v9 = 0;
        if (sub_1002551C8((uint64_t)&v10, &v9))
        {
          v7[1] = nullsub_106;
          LODWORD(v7[0]) = *(_DWORD *)(*(_QWORD *)(qword_1009919E8 + 24) + ((uint64_t)v9 << 6) + 56);
          v8[1] = v7;
          LOWORD(v8[0]) = 16;
          v2 = sub_10004AE90((uint64_t)sub_100255244, v8, 0);
          if ((_DWORD)v2)
          {
            v3 = v2;
            if (sub_10005549C())
            {
              sub_100054530("OI_Dispatch_RegisterFunc failed %!", v3);
              v4 = sub_1000544A0(0x31u);
              if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
                sub_1006CE7A4();
            }
          }
        }
      }
    }
  }
  else if (sub_10005549C())
  {
    sub_100054530("OI_POLICYMGR_Disconnect");
    v5 = sub_1000544A0(0x31u);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      sub_1006D3010();
  }
}

uint64_t sub_1002550D4(unsigned int a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _DWORD *v6;
  int v7;
  int *v8;
  int v9;
  uint64_t result;
  NSObject *v11;
  uint64_t v12;

  if (a1 >> 18 < 0x69
    || (v3 = qword_1009919E8, (unsigned __int16)a1 >= *(unsigned __int16 *)(qword_1009919E8 + 20)))
  {
    result = sub_10005549C();
    if (!(_DWORD)result)
      return result;
    sub_100054530("Invalid handle 0x%x", a1);
    v11 = sub_1000544A0(0x31u);
    result = os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    sub_1006CE7A4();
    return 0;
  }
  v4 = *(_QWORD *)(qword_1009919E8 + 24);
  v5 = v4 + ((unint64_t)(unsigned __int16)a1 << 6);
  v7 = *(_DWORD *)(v5 + 56);
  v6 = (_DWORD *)(v5 + 56);
  if (v7 != a1)
    return 0;
  *v6 = 0;
  if (a2)
  {
    v8 = (int *)(v4 + ((unint64_t)(unsigned __int16)a1 << 6));
    v9 = *v8;
    *(_WORD *)(a2 + 4) = *((_WORD *)v8 + 2);
    *(_DWORD *)a2 = v9;
  }
  if (*(_QWORD *)(v3 + 40))
  {
    v12 = 0;
    if (!sub_100182588(*(_QWORD *)(v3 + 24) + ((unint64_t)(unsigned __int16)a1 << 6), &v12))
      (*(void (**)(uint64_t))(qword_1009919E8 + 40))(v12);
  }
  return 1;
}

BOOL sub_1002551C8(uint64_t a1, _DWORD *a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  BOOL v5;

  v2 = *(unsigned __int16 *)(qword_1009919E8 + 20);
  if (*(_WORD *)(qword_1009919E8 + 20))
  {
    v3 = 0;
    v4 = *(_QWORD *)(qword_1009919E8 + 24);
    v5 = 1;
    while (*(_DWORD *)(v4 + 56) >> 18 < 0x69u
         || (unsigned __int16)*(_DWORD *)(v4 + 56) >= v2
         || *(_DWORD *)a1 != *(_DWORD *)v4
         || *(unsigned __int16 *)(a1 + 4) != *(unsigned __int16 *)(v4 + 4))
    {
      v5 = ++v3 < v2;
      v4 += 64;
      if (v2 == v3)
        return 0;
    }
    *a2 = v3;
  }
  else
  {
    return 0;
  }
  return v5;
}

void sub_100255244(uint64_t a1)
{
  unsigned __int16 *v1;
  _BOOL4 v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  const void *v14[2];
  char v15;
  __int16 v16;

  v16 = 0;
  v15 = 0;
  v14[0] = 0;
  v1 = *(unsigned __int16 **)(a1 + 8);
  v2 = sub_1002294E8(*(_QWORD *)(qword_1009919E8 + 24) + ((unint64_t)*v1 << 6));
  v3 = qword_1009919E8;
  if (*(_DWORD *)(qword_1009919E8 + 16) == 1 && !v2)
  {
    *(_OWORD *)qword_1009919E8 = *(_OWORD *)v1;
    v8 = *(_QWORD *)(v3 + 24);
    v9 = *(_DWORD *)v3;
    v10 = v8 + ((unint64_t)(unsigned __int16)v9 << 6);
    if (*(_DWORD *)(v10 + 56) == v9)
    {
      sub_1002546B0(v10, &v15, &v16);
      v11 = sub_10018BC38((uint64_t)sub_1002558A0, v10, v15, v16, *(_DWORD *)(v10 + 56));
      if ((_DWORD)v11)
      {
        v12 = v11;
        if (sub_10005549C())
        {
          sub_100054530("OI_DEVMGR_EnforceLinkPolicy failed %!", v12, v14[0]);
          v13 = sub_1000544A0(0x31u);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
            sub_1006CE7A4();
        }
      }
      else
      {
        *(_DWORD *)(qword_1009919E8 + 16) = 3;
      }
    }
  }
  else
  {
    v14[1] = v1;
    LOWORD(v14[0]) = 16;
    v5 = sub_10004A9EC((uint64_t)sub_100255244, v14, 1, 0);
    if ((_DWORD)v5)
    {
      v6 = v5;
      if (sub_10005549C())
      {
        sub_100054530("OI_Dispatch_RegisterTimedFunc failed %!", v6);
        v7 = sub_1000544A0(0x31u);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
    }
  }
}

void sub_1002553C4(unsigned int a1)
{
  NSObject *v2;

  if (!dword_10099920C)
  {
    if (sub_10005549C())
    {
      sub_100054530("OI_POLICYMGR_RemoveConnectionPolicy");
      v2 = sub_1000544A0(0x31u);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_1006D3010();
    }
  }
  sub_100254F2C(a1);
}

void sub_100255438(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  int v5;

  if (dword_10099920C)
  {
    v5 = 0;
    if (sub_1002551C8(a1, &v5))
    {
      v2 = qword_1009919E8;
      do
      {
        v3 = v5;
        if (*(_DWORD *)(v2 + 16) != 1 && *(_DWORD *)v2 == *(_DWORD *)(*(_QWORD *)(v2 + 24) + ((uint64_t)v5 << 6) + 56))
        {
          sub_100255524(1500, 1);
          v2 = qword_1009919E8;
        }
        *(_DWORD *)(*(_QWORD *)(v2 + 24) + (v3 << 6) + 56) = 0;
      }
      while (sub_1002551C8(a1, &v5));
    }
  }
  else if (sub_10005549C())
  {
    sub_100054530("OI_POLICYMGR_DevmgrDisconnect");
    v4 = sub_1000544A0(0x31u);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      sub_1006D3010();
  }
}

uint64_t sub_100255524(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  const char *v5;
  NSObject *v6;
  unsigned int *v7;
  NSObject *v8;
  uint8_t buf[4];
  void *v11;

  if (!*(_QWORD *)(qword_1009919E8 + 8))
    sub_100253460();
  if (sub_10005549C())
  {
    v4 = *(int *)(qword_1009919E8 + 16);
    v5 = v4 > 5 ? "unknown" : off_10091FBD8[v4];
    sub_100054530("Trace finishEnforcementEffort handle %#x : %s --------------------> %s\n\n\n\n", *(_DWORD *)qword_1009919E8, v5, "PMAN_ST_IDLE");
    v6 = sub_1000544A0(0x31u);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v11 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
  v7 = (unsigned int *)qword_1009919E8;
  *(_DWORD *)(qword_1009919E8 + 16) = 1;
  dword_1009919F0 = 0;
  word_1009919F4 = 0;
  if ((_DWORD)a1)
  {
    if ((sub_1002550D4(*v7, 0) & 1) == 0)
    {
      if (sub_10005549C())
      {
        sub_100054530("Orphaned policy, handle 0x%x", *(_DWORD *)qword_1009919E8);
        v8 = sub_1000544A0(0x31u);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
    }
  }
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t))(qword_1009919E8 + 8))(*(unsigned int *)qword_1009919E8, a1, a2);
}

void sub_1002556D0(uint64_t a1, int a2)
{
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  NSObject *v11;
  char v12;
  __int16 v13;

  v4 = qword_1009919E8;
  if (*(_DWORD *)(qword_1009919E8 + 16) != 2)
  {
    sub_100253460();
    v4 = qword_1009919E8;
  }
  if (*(_DWORD *)v4 == a2)
  {
    if ((_DWORD)a1)
    {
      sub_100255524(a1, 1);
      return;
    }
    v13 = 0;
    v12 = 0;
    v6 = *(_QWORD *)(v4 + 24) + ((unint64_t)(unsigned __int16)a2 << 6);
    if (*(_DWORD *)(v6 + 56) == a2)
    {
      sub_1002546B0(v6, &v12, &v13);
      v7 = sub_10018BC38((uint64_t)sub_1002558A0, v6, v12, v13, *(_DWORD *)(v6 + 56));
      if (!(_DWORD)v7)
      {
        *(_DWORD *)(qword_1009919E8 + 16) = 3;
        return;
      }
      v8 = v7;
      if (sub_10005549C())
      {
        sub_100054530("OI_DEVMGR_EnforceLinkPolicy failed %!", v8);
        v9 = sub_1000544A0(0x31u);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      v10 = v8;
    }
    else
    {
      if (sub_10005549C())
      {
        sub_100054530("startDevmgrPolicyEnforcement, handle %d no longer valid", *(_DWORD *)qword_1009919E8);
        v11 = sub_1000544A0(0x31u);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
      v10 = 122;
    }
    sub_100255524(v10, 0);
  }
  else if (sub_10005549C())
  {
    sub_100054530("cookie does not match current enforcement (%d vs 0x%x)", a2, *(_DWORD *)qword_1009919E8);
    v5 = sub_1000544A0(0x31u);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      sub_1006CE7A4();
  }
}

void sub_1002558A0(uint64_t a1, uint64_t a2, int a3)
{
  NSObject *v4;
  NSObject *v5;
  NSObject *v6;

  if (*(_DWORD *)(qword_1009919E8 + 16) != 3)
  {
    if (!sub_10005549C())
      return;
    sub_100054530("Policy Enforce State == %d", *(_DWORD *)(qword_1009919E8 + 16));
    v4 = sub_1000544A0(0x31u);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      return;
LABEL_7:
    sub_1006CE7A4();
    return;
  }
  if (*(_DWORD *)qword_1009919E8 != a3)
  {
    if (!sub_10005549C())
      return;
    sub_100054530("cookie does not match current enforcement (0x%x vs 0x%x)", a3, *(_DWORD *)qword_1009919E8);
    v5 = sub_1000544A0(0x31u);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      return;
    goto LABEL_7;
  }
  if ((_DWORD)a1)
  {
LABEL_4:
    sub_100255524(a1, 0);
    return;
  }
  if (*(_DWORD *)(*(_QWORD *)(qword_1009919E8 + 24) + ((unint64_t)(unsigned __int16)a3 << 6) + 56) == a3)
  {
    a1 = sub_10004AE90((uint64_t)sub_100255A2C, 0, 0);
    if ((_DWORD)a1)
      goto LABEL_4;
    *(_DWORD *)(qword_1009919E8 + 16) = 4;
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("startPowerPolicyEnforcement, handle %d no longer valid", *(_DWORD *)qword_1009919E8);
      v6 = sub_1000544A0(0x31u);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    sub_100255524(122, 0);
  }
}

uint64_t sub_100255A2C()
{
  unsigned __int16 *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v8;

  v0 = (unsigned __int16 *)qword_1009919E8;
  if (*(_DWORD *)(qword_1009919E8 + 16) != 4)
  {
    sub_100253460();
    v0 = (unsigned __int16 *)qword_1009919E8;
  }
  v1 = *((_QWORD *)v0 + 3);
  v2 = v1 + ((unint64_t)*v0 << 6);
  v3 = v0[10];
  if ((_DWORD)v3)
  {
    v4 = 0;
    v5 = v3;
    do
    {
      if (*(_DWORD *)(v1 + 56) >> 18 >= 0x69u
        && (unsigned __int16)*(_DWORD *)(v1 + 56) < v3
        && *(_DWORD *)v2 == *(_DWORD *)v1
        && *(unsigned __int16 *)(v2 + 4) == *(unsigned __int16 *)(v1 + 4))
      {
        v8 = *(_QWORD *)(v1 + 48);
        if (v8)
        {
          if (!v4
            || *(_DWORD *)v8 > *(_DWORD *)v4
            || *(unsigned __int16 *)(v8 + 4) < *(unsigned __int16 *)(v4 + 4)
            || *(unsigned __int16 *)(v8 + 10) > *(unsigned __int16 *)(v4 + 10))
          {
            v4 = *(_QWORD *)(v1 + 48);
          }
        }
      }
      v1 += 64;
      --v5;
    }
    while (v5);
  }
  else
  {
    v4 = 0;
  }
  sub_10018765C(v2, (uint64_t *)v4);
  return sub_100255524(0, 0);
}

double sub_100255B10(uint64_t a1)
{
  unint64_t i;
  uint64_t (*v3)();
  double result;

  if (sub_10002825C())
  {
    for (i = 0; ; ++i)
    {
      v3 = off_10097AA10[i];
      if (!v3 || i > 4)
        break;
      if (((uint64_t (*)(uint64_t))v3)(a1))
        return result;
    }
  }
  return sub_100255B7C(a1);
}

double sub_100255B7C(unsigned int a1)
{
  unsigned int v1;
  _BYTE *v2;
  BOOL v3;
  double result;

  if (a1)
  {
    v1 = a1;
    if (a1 != 0xFFFF)
    {
      v2 = &unk_100991A05;
      byte_100991A0D = 0;
      do
      {
        v2[7] = a0123456789_0[v1 % 0xA];
        --v2;
        v3 = v1 > 9;
        v1 /= 0xAu;
      }
      while (v3);
      result = 5.76777859e-153;
      *(_QWORD *)v2 = 0x2053555441545320;
    }
  }
  return result;
}

const char *sub_100255BFC(int a1)
{
  const char *result;

  if (a1 <= 1499)
  {
    if (a1 > 1200)
    {
      switch(a1)
      {
        case 1201:
          result = "OI_HCITRANS_CANNOT_CONNECT_TO_DEVICE";
          break;
        case 1203:
          result = "OI_HCITRANS_BUFFER_TOO_SMALL";
          break;
        case 1204:
          result = "OI_HCITRANS_NULL_DEVICE_HANDLE";
          break;
        case 1205:
          result = "OI_HCITRANS_IO_ERROR";
          break;
        case 1206:
          result = "OI_HCITRANS_DEVICE_NOT_READY";
          break;
        case 1207:
          result = "OI_HCITRANS_FUNCTION_NOT_SUPPORTED";
          break;
        case 1209:
          result = "OI_HCITRANS_ACCESS_DENIED";
          break;
        case 1210:
          result = "OI_HCITRANS_ACL_DATA_ERROR";
          break;
        case 1211:
          result = "OI_HCITRANS_SCO_DATA_ERROR";
          break;
        case 1212:
          result = "OI_HCITRANS_EVENT_DATA_ERROR";
          break;
        case 1214:
          result = "OI_HCITRANS_INTERNAL_ERROR";
          break;
        case 1215:
          result = "OI_HCITRANS_LINK_NOT_ACTIVE";
          break;
        case 1216:
          result = "OI_HCITRANS_INITIALIZING";
          break;
        case 1217:
          result = "OI_HCITRANS_H4BC_TIMEOUT";
          break;
        case 1218:
          result = "OI_HCITRANS_NO_RESOURCES";
          break;
        case 1219:
          result = "OI_HCITRANS_DRIVER_ERROR";
          break;
        case 1220:
          result = "OI_HCITRANS_DEVICE_FATAL_ERROR";
          break;
        case 1301:
          result = "OI_DEVMGR_NO_CONNECTION";
          break;
        case 1302:
          result = "OI_DEVMGR_CONNECTION_PENDING_READY";
          break;
        case 1305:
          result = "OI_DEVMGR_HARDWARE_ERROR";
          break;
        case 1307:
          result = "OI_DEVMGR_PENDING_CONNECT_LIST_FULL";
          break;
        case 1309:
          result = "OI_DEVMGR_CONNECTION_LIST_FULL";
          break;
        case 1310:
          result = "OI_DEVMGR_NO_SUCH_CONNECTION";
          break;
        case 1311:
          result = "OI_DEVMGR_INQUIRY_IN_PROGRESS";
          break;
        case 1312:
          result = "OI_DEVMGR_PERIODIC_INQUIRY_ACTIVE";
          break;
        case 1313:
          result = "OI_DEVMGR_NO_INQUIRIES_ACTIVE";
          break;
        case 1314:
          result = "OI_DEVMGR_DUPLICATE_CONNECTION";
          break;
        case 1316:
          result = "OI_DEVMGR_DUPLICATE_EVENT_CALLBACK";
          break;
        case 1317:
          result = "OI_DEVMGR_EVENT_CALLBACK_LIST_FULL";
          break;
        case 1318:
          result = "OI_DEVMGR_EVENT_CALLBACK_NOT_FOUND";
          break;
        case 1319:
          result = "OI_DEVMGR_BUSY";
          break;
        case 1320:
          result = "OI_DEVMGR_ENUM_UNEXPECTED_INQ_COMPLETE";
          break;
        case 1321:
          result = "OI_DEVMGR_ENUM_UNEXPECTED_INQ_RESULT";
          break;
        case 1322:
          result = "OI_DEVMGR_ENUM_DATABASE_FULL";
          break;
        case 1323:
          result = "OI_DEVMGR_ENUM_INQUIRIES_OVERLAP";
          break;
        case 1324:
          result = "OI_DEVMGR_UNKNOWN_LINK_TYPE";
          break;
        case 1325:
          result = "OI_DEVMGR_PARAM_IO_ACTIVE";
          break;
        case 1326:
          result = "OI_DEVMGR_UNKNOWN_IAC_LAP";
          break;
        case 1327:
          result = "OI_DEVMGR_SCO_ALREADY_REGISTERED";
          break;
        case 1328:
          result = "OI_DEVMGR_SCO_NOT_REGISTERED";
          break;
        case 1329:
          result = "OI_DEVMGR_SCO_WITHOUT_ACL";
          break;
        case 1330:
          result = "OI_DEVMGR_NO_SUPPORT";
          break;
        case 1331:
          result = "OI_DEVMGR_WRITE_POLICY_FAILED";
          break;
        case 1332:
          result = "OI_DEVMGR_NOT_IN_CENTRAL_MODE";
          break;
        case 1333:
          result = "OI_DEVMGR_POLICY_VIOLATION";
          break;
        case 1334:
          result = "OI_DEVMGR_BUSY_TIMEOUT";
          break;
        case 1335:
          result = "OI_DEVMGR_REENCRYPT_FAILED";
          break;
        case 1336:
          result = "OI_DEVMGR_ROLE_POLICY_CONFLICT";
          break;
        case 1337:
          result = "OI_DEVMGR_BAD_INTERVAL";
          break;
        case 1338:
          result = "OI_DEVMGR_INVALID_SCO_HANDLE";
          break;
        case 1339:
          result = "OI_DEVMGR_CONNECTION_OVERLAP";
          break;
        case 1340:
          result = "OI_DEVMGR_ORPHAN_SUBRATE_COMPLETE";
          break;
        case 1341:
          result = "OI_DEVMGR_EIR_RESPONSE_2_LARGE";
          break;
        case 1342:
          result = "OI_DEVMGR_GENTLY_CENTRAL_SKIP_CONN";
          break;
        case 1343:
          result = "OI_DEVMGR_REQUEST_INVALID_TYPE";
          break;
        case 1344:
          result = "OI_DEVMGR_REQUEST_CONN_DISCONNECTED";
          break;
        case 1345:
          result = "OI_DEVMGR_REQUEST_FINISH_BONDING";
          break;
        case 1346:
          result = "OI_DEVMGR_REQUEST_FINISH_NAME_REQ";
          break;
        case 1348:
          result = "OI_DEVMGR_DISCONNECT_UNCONDITIONAL";
          break;
        case 1349:
          result = "OI_DEVMGR_INVALID_HANDLE_LINK_INFO";
          break;
        case 1350:
          result = "OI_DEVMGR_INVALID_HANDLE_COUNTER";
          break;
        case 1351:
          result = "OI_DEVMGR_INVALID_HANDLE_LINK_QUAL";
          break;
        case 1352:
          result = "OI_DEVMGR_INVALID_HANDLE_RSSI";
          break;
        case 1353:
          result = "OI_DEVMGR_INVALID_HANDLE_AUTO_FLUSH";
          break;
        case 1354:
          result = "OI_DEVMGR_INVALID_HANDLE_TX_POWER";
          break;
        case 1355:
          result = "OI_DEVMGR_INVALID_HANDLE_MAX_POWER";
          break;
        case 1356:
          result = "OI_DEVMGR_INVALID_HANDLE_LSTO";
          break;
        case 1358:
          result = "OI_DEVMGR_STATUS_DEFAULT";
          break;
        case 1359:
          result = "OI_DEVMGR_NAME_REQUEST_IS_INVALID";
          break;
        case 1360:
          result = "OI_DEVMGR_SCO_NO_ESCO_SUPPORT";
          break;
        case 1361:
          result = "OI_DEVMGR_INVALID_ACL_STATE";
          break;
        case 1362:
          result = "OI_DEVMGR_REMOTENAMECANCEL_CB";
          break;
        case 1363:
          result = "OI_DEVMGR_INVALID_HANDLE_LINK_POL";
          break;
        case 1401:
          result = "OI_SECMGR_NO_POLICY";
          break;
        case 1402:
          result = "OI_SECMGR_INTERNAL_ERROR";
          break;
        case 1403:
          result = "OI_SECMGR_ORPHANED_CALLBACK";
          break;
        case 1404:
          result = "OI_SECMGR_BUSY";
          break;
        case 1405:
          result = "OI_SECMGR_DEVICE_NOT_TRUSTED";
          break;
        case 1407:
          result = "OI_SECMGR_DEVICE_ENCRYPT_FAIL";
          break;
        case 1408:
          result = "OI_SECMGR_DISCONNECTED_FAIL";
          break;
        case 1409:
          result = "OI_SECMGR_ACCESS_PENDING";
          break;
        case 1410:
          result = "OI_SECMGR_PIN_CODE_TOO_SHORT";
          break;
        case 1411:
          result = "OI_SECMGR_UNKNOWN_ENCRYPT_VALUE";
          break;
        case 1412:
          result = "OI_SECMGR_INVALID_POLICY";
          break;
        case 1413:
          result = "OI_SECMGR_AUTHORIZATION_FAILED";
          break;
        case 1414:
          result = "OI_SECMGR_ENCRYPTION_FAILED";
          break;
        case 1415:
          result = "OI_SECMGR_UNIT_KEY_UNSUPPORTED";
          break;
        case 1416:
          result = "OI_SECMGR_NOT_REGISTERED";
          break;
        case 1417:
          result = "OI_SECMGR_ILLEGAL_WRITE_SSP_MODE";
          break;
        case 1418:
          result = "OI_SECMGR_INVALID_SEC_LEVEL";
          break;
        case 1419:
          result = "OI_SECMGR_INSUFFICIENT_LINK_KEY";
          break;
        case 1420:
          result = "OI_SECMGR_INVALID_KEY_TYPE";
          break;
        case 1421:
          result = "OI_SECMGR_SSP_NOT_ENCRYPTED";
          break;
        case 1422:
          result = "OI_SECMGR_ORPHAN_EVENT";
          break;
        case 1423:
          result = "OI_SECMGR_NOT_BONDABLE";
          break;
        case 1424:
          result = "OI_SECMGR_INVALID_REMOTE_AUTH";
          break;
        default:
          return 0;
      }
    }
    else
    {
      switch(a1)
      {
        case 402:
          result = "OI_STATUS_PSM_ALREADY_REGISTERED";
          break;
        case 403:
          result = "OI_STATUS_INVALID_CID";
          break;
        case 404:
          result = "OI_STATUS_CID_NOT_FOUND";
          break;
        case 405:
        case 409:
        case 413:
        case 415:
        case 416:
        case 417:
        case 419:
        case 420:
        case 421:
        case 422:
        case 424:
        case 432:
        case 438:
        case 442:
        case 443:
        case 446:
        case 447:
        case 448:
        case 449:
        case 455:
        case 456:
        case 457:
        case 458:
        case 459:
        case 465:
        case 466:
        case 467:
        case 468:
        case 469:
        case 473:
        case 474:
        case 475:
        case 476:
        case 477:
        case 478:
        case 479:
        case 480:
        case 481:
        case 487:
        case 488:
        case 489:
        case 491:
        case 492:
        case 493:
        case 494:
        case 495:
        case 496:
        case 497:
        case 498:
        case 499:
        case 504:
        case 505:
        case 506:
        case 507:
        case 512:
        case 513:
        case 514:
        case 515:
        case 516:
        case 517:
        case 518:
        case 519:
        case 520:
        case 521:
        case 522:
        case 523:
        case 524:
        case 525:
        case 526:
        case 527:
        case 528:
        case 529:
        case 557:
        case 561:
        case 562:
        case 563:
        case 564:
        case 565:
        case 566:
        case 567:
        case 568:
        case 569:
        case 570:
        case 571:
        case 572:
        case 573:
        case 574:
        case 575:
        case 576:
        case 577:
        case 578:
        case 579:
        case 581:
        case 583:
        case 592:
        case 593:
        case 594:
        case 595:
        case 596:
        case 597:
        case 598:
        case 599:
        case 600:
        case 602:
        case 604:
        case 606:
        case 609:
        case 610:
        case 617:
        case 618:
        case 636:
        case 655:
        case 656:
        case 657:
        case 658:
        case 659:
        case 660:
        case 661:
        case 662:
        case 663:
        case 664:
        case 665:
        case 666:
        case 667:
        case 668:
        case 669:
        case 670:
        case 671:
        case 672:
        case 673:
        case 674:
        case 675:
        case 676:
        case 677:
        case 678:
        case 679:
        case 680:
        case 681:
        case 682:
        case 683:
        case 684:
        case 685:
        case 686:
        case 687:
        case 688:
        case 689:
        case 690:
        case 691:
        case 692:
        case 693:
        case 694:
        case 695:
        case 696:
        case 697:
        case 698:
        case 699:
        case 700:
        case 764:
        case 765:
        case 767:
        case 768:
        case 770:
        case 771:
        case 772:
        case 773:
        case 774:
        case 775:
        case 776:
        case 777:
        case 778:
        case 779:
        case 780:
        case 781:
        case 782:
        case 783:
        case 784:
        case 785:
        case 786:
        case 787:
        case 788:
        case 789:
        case 790:
        case 791:
        case 792:
        case 793:
        case 794:
        case 795:
        case 796:
        case 797:
        case 798:
        case 799:
        case 801:
        case 809:
        case 814:
        case 818:
        case 820:
        case 822:
        case 828:
        case 848:
        case 849:
        case 850:
        case 851:
        case 852:
        case 853:
        case 854:
        case 855:
        case 856:
        case 857:
        case 858:
        case 859:
        case 860:
        case 861:
        case 862:
        case 863:
        case 864:
        case 865:
        case 866:
        case 867:
        case 868:
        case 869:
        case 870:
        case 871:
        case 872:
        case 873:
        case 874:
        case 875:
        case 876:
        case 877:
        case 878:
        case 879:
        case 880:
        case 881:
        case 882:
        case 883:
        case 884:
        case 885:
        case 886:
        case 887:
        case 888:
        case 889:
        case 890:
        case 891:
        case 892:
        case 893:
        case 894:
        case 895:
        case 896:
        case 897:
        case 898:
        case 899:
        case 900:
        case 902:
        case 914:
        case 919:
        case 936:
        case 937:
        case 938:
        case 939:
        case 940:
        case 941:
        case 942:
        case 943:
        case 944:
        case 945:
        case 946:
        case 947:
        case 948:
        case 949:
        case 950:
        case 951:
        case 952:
        case 953:
        case 954:
        case 955:
        case 956:
        case 957:
        case 958:
        case 959:
        case 960:
        case 961:
        case 962:
        case 963:
        case 964:
        case 965:
        case 966:
        case 967:
        case 968:
        case 969:
        case 970:
        case 971:
        case 972:
        case 973:
        case 974:
        case 975:
        case 976:
        case 977:
        case 978:
        case 979:
        case 980:
        case 981:
        case 982:
        case 983:
        case 984:
        case 985:
        case 986:
        case 987:
        case 988:
        case 989:
        case 990:
        case 991:
        case 992:
        case 993:
        case 994:
        case 995:
        case 996:
        case 997:
        case 998:
        case 999:
        case 1000:
        case 1003:
        case 1004:
        case 1005:
        case 1006:
        case 1007:
        case 1008:
        case 1009:
        case 1011:
        case 1012:
        case 1013:
        case 1014:
        case 1015:
        case 1016:
        case 1017:
        case 1018:
        case 1019:
        case 1020:
        case 1024:
        case 1025:
        case 1026:
        case 1027:
        case 1028:
        case 1029:
        case 1032:
        case 1033:
        case 1034:
        case 1035:
        case 1036:
        case 1037:
        case 1038:
        case 1039:
        case 1052:
        case 1053:
        case 1054:
        case 1055:
        case 1056:
        case 1057:
        case 1058:
        case 1059:
        case 1060:
        case 1061:
        case 1062:
        case 1063:
        case 1064:
        case 1068:
        case 1069:
        case 1070:
        case 1071:
        case 1072:
        case 1073:
        case 1074:
        case 1075:
        case 1076:
        case 1077:
        case 1078:
        case 1079:
        case 1080:
        case 1081:
        case 1082:
        case 1083:
        case 1084:
        case 1085:
        case 1086:
        case 1087:
        case 1088:
        case 1089:
        case 1090:
        case 1091:
        case 1092:
        case 1093:
        case 1094:
        case 1095:
        case 1096:
        case 1097:
        case 1098:
        case 1099:
        case 1100:
          return 0;
        case 406:
          result = "OI_STATUS_CHANNEL_NOT_FOUND";
          break;
        case 407:
          result = "OI_STATUS_PSM_NOT_FOUND";
          break;
        case 408:
          result = "OI_STATUS_INVALID_STATE";
          break;
        case 410:
          result = "OI_STATUS_WRITE_IN_PROGRESS";
          break;
        case 411:
          result = "OI_STATUS_INVALID_PACKET";
          break;
        case 412:
          result = "OI_STATUS_SEND_COMPLETE";
          break;
        case 414:
          result = "OI_STATUS_INVALID_HANDLE";
          break;
        case 418:
          result = "OI_STATUS_GROUP_FULL";
          break;
        case 423:
          result = "OI_STATUS_DEVICE_ALREADY_IN_GROUP";
          break;
        case 425:
          result = "OI_STATUS_DUPLICATE_GROUP";
          break;
        case 426:
          result = "OI_STATUS_EMPTY_GROUP";
          break;
        case 427:
          result = "OI_STATUS_PACKET_NOT_FOUND";
          break;
        case 428:
          result = "OI_STATUS_BUFFER_TOO_SMALL";
          break;
        case 429:
          result = "OI_STATUS_IDENTIFIER_NOT_FOUND";
          break;
        case 430:
          result = "OI_L2CAP_DISCONNECT_LOWER_LAYER";
          break;
        case 431:
          result = "OI_L2CAP_DISCONNECT_REMOTE_REQUEST";
          break;
        case 433:
          result = "OI_L2CAP_GROUP_ADD_CONNECT_FAIL";
          break;
        case 434:
          result = "OI_L2CAP_GROUP_REMOVE_FAILURE";
          break;
        case 435:
          result = "OI_L2CAP_DATA_WRITE_ERROR_LINK_TERM";
          break;
        case 436:
          result = "OI_L2CAP_DISCONNECT_LOCAL_REQUEST";
          break;
        case 437:
          result = "OI_L2CAP_CONNECT_TIMEOUT";
          break;
        case 439:
          result = "OI_L2CAP_DISCONNECT_TIMEOUT";
          break;
        case 440:
          result = "OI_L2CAP_PING_TIMEOUT";
          break;
        case 441:
          result = "OI_L2CAP_GET_INFO_TIMEOUT";
          break;
        case 444:
          result = "OI_L2CAP_INVALID_ADDRESS";
          break;
        case 445:
          result = "OI_L2CAP_CMD_REJECT_RCVD";
          break;
        case 450:
          result = "OI_L2CAP_CONNECT_BASE";
          break;
        case 451:
          result = "OI_L2CAP_CONNECT_PENDING";
          break;
        case 452:
          result = "OI_L2CAP_CONNECT_REFUSED_INVALID_PSM";
          break;
        case 453:
          result = "OI_L2CAP_CONNECT_REFUSED_SECURITY";
          break;
        case 454:
          result = "OI_L2CAP_CONNECT_REFUSED_NO_RESOURCES";
          break;
        case 460:
          result = "OI_L2CAP_CONFIG_BASE";
          break;
        case 461:
          result = "OI_L2CAP_CONFIG_FAIL_INVALID_PARAMETERS";
          break;
        case 462:
          result = "OI_L2CAP_CONFIG_FAIL_NO_REASON";
          break;
        case 463:
          result = "OI_L2CAP_CONFIG_FAIL_UNKNOWN_OPTIONS";
          break;
        case 464:
          result = "OI_L2CAP_CONFIG_FAIL_TIMEOUT";
          break;
        case 470:
          result = "OI_L2CAP_GET_INFO_BASE";
          break;
        case 471:
          result = "OI_L2CAP_GET_INFO_NOT_SUPPORTED";
          break;
        case 472:
          result = "OI_L2CAP_MTU_EXCEEDED";
          break;
        case 482:
          result = "OI_L2CAP_INVALID_PSM";
          break;
        case 483:
          result = "OI_L2CAP_INVALID_MTU";
          break;
        case 484:
          result = "OI_L2CAP_INVALID_FLUSHTO";
          break;
        case 485:
          result = "OI_L2CAP_DEQUEUE_ERT_ERROR";
          break;
        case 486:
          result = "OI_L2CAP_ZERO_LENGTH_RECV_PAYLOAD";
          break;
        case 490:
          result = "OI_L2CAP_INVALID_FLOW_CONTROL";
          break;
        case 500:
          result = "OI_L2CAP_QUEUE_LOCAL_NOT_READY";
          break;
        case 501:
          result = "OI_L2CAP_QUEUE_REMOTE_NOT_READY";
          break;
        case 502:
          result = "OI_L2CAP_QUEUE_FRAGMENTATION";
          break;
        case 503:
          result = "OI_L2CAP_QUEUE_SFRAME_HEADER_ERROR";
          break;
        case 508:
          result = "OI_L2CAP_QUEUE_ERTM_CID_ERROR";
          break;
        case 509:
          result = "OI_L2CAP_QUEUE_SUPERVISION_ERROR";
          break;
        case 510:
          result = "OI_L2CAP_QUEUE_RETRANS_ERROR";
          break;
        case 511:
          result = "OI_L2CAP_QUEUE_THREAD_CREATION_FAILED";
          break;
        case 530:
          result = "OI_L2CAP_ACCEPT_RESPOND_REJECT";
          break;
        case 531:
          result = "OI_L2CAP_CONMAN_DEFAULT";
          break;
        case 532:
          result = "OI_L2CAP_FIXCHAN_WRONG_TYPE";
          break;
        case 533:
          result = "OI_L2CAP_FLOW_SENT_INVALID_CHANNEL";
          break;
        case 534:
          result = "OI_L2CAP_FLOW_UNEXPECTED_STATE";
          break;
        case 535:
          result = "OI_L2CAP_FLOW_INIT_INVALID_CHAN";
          break;
        case 536:
          result = "OI_L2CAP_FLOW_RECV_INVALID_CHAN";
          break;
        case 537:
          result = "OI_L2CAP_QOS_POKE_INVALID_CHAN";
          break;
        case 538:
          result = "OI_L2CAP_ERTM_SENDSREJLIST_ERROR";
          break;
        case 539:
          result = "OI_L2CAP_ERTM_SENDSREJTAIL_ERROR";
          break;
        case 540:
          result = "OI_L2CAP_ERTM_RETRANS_IFRAME_ERROR";
          break;
        case 541:
          result = "OI_L2CAP_ERTM_RETRANS_IFRAME_COUNT_EXCEEDED";
          break;
        case 542:
          result = "OI_L2CAP_ERTM_RETRANS_REQ_IFRAME_ERROR";
          break;
        case 543:
          result = "OI_L2CAP_ERTM_RX_IFRAME_IN_RX_UNEXPECTED_STATE";
          break;
        case 544:
          result = "OI_L2CAP_ERTM_RX_IFRAME_IN_REJ_UNEXPECTED_STATE";
          break;
        case 545:
          result = "OI_L2CAP_ERTM_RX_IFRAME_IN_SREJ_UNEXPECTED_STATE";
          break;
        case 546:
          result = "OI_L2CAP_ERTM_RETRANS_BAD_LENGTH_RECVD_DATA";
          break;
        case 547:
          result = "OI_L2CAP_ERTM_RETRANS_BAD_SFRAME_RECVD_DATA";
          break;
        case 548:
          result = "OI_L2CAP_ERTM_RETRANS_BAD_IFRAME_RECVD_DATA";
          break;
        case 549:
          result = "OI_L2CAP_ERTM_RETRANS_ALLOC_FAIL_RECVD_DATA";
          break;
        case 550:
          result = "OI_L2CAP_ERTM_RECVDATA_UNEXPECTED_STATE";
          break;
        case 551:
          result = "OI_L2CAP_ERTM_LOCAL_BUSY_UNEXPECTED_STATE";
          break;
        case 552:
          result = "OI_L2CAP_ERTM_LOCAL_BUSY_CLEAR_UNEXPECTED_STATE";
          break;
        case 553:
          result = "OI_L2CAP_ERTM_SEQ_N_FBIT_UNEXPECTED_STATE";
          break;
        case 554:
          result = "OI_L2CAP_ERTM_FBIT_UNEXPECTED_STATE";
          break;
        case 555:
          result = "OI_L2CAP_ERTM_UNEXPECTED_RETRX_TIMER";
          break;
        case 556:
          result = "OI_L2CAP_ERTM_UNEXPECTED_MONITOR_TIMER";
          break;
        case 558:
          result = "OI_L2CAP_ERTM_TIMEOUT";
          break;
        case 559:
          result = "OI_L2CAP_SIGNALMAN_TIMEOUT";
          break;
        case 560:
          result = "OI_L2CAP_DISC_DLCI0";
          break;
        case 580:
          result = "OI_L2CAP_LE_BASE";
          break;
        case 582:
          result = "OI_L2CAP_LE_LE_PSM_NOT_SUPPORTED";
          break;
        case 584:
          result = "OI_L2CAP_LE_NO_RESOURCES";
          break;
        case 585:
          result = "OI_L2CAP_LE_INSUFFICIENT_AUTHENTICATION";
          break;
        case 586:
          result = "OI_L2CAP_LE_INSUFFICIENT_AUTHORIZATION";
          break;
        case 587:
          result = "OI_L2CAP_LE_INSUFFICIENT_ENC_KEY_SIZE";
          break;
        case 588:
          result = "OI_L2CAP_LE_INSUFFICIENT_ENCRYPTION";
          break;
        case 589:
          result = "OI_L2CAP_LE_INVALID_SOURCE_CID";
          break;
        case 590:
          result = "OI_L2CAP_LE_SOURCE_CID_ALREADY_REGISTERED";
          break;
        case 591:
          result = "OI_L2CAP_LE_UNACCEPTABLE_PARAMS";
          break;
        case 601:
          result = "OI_HCI_NO_SUCH_CONNECTION";
          break;
        case 603:
          result = "OI_HCI_CB_LIST_FULL";
          break;
        case 605:
          result = "OI_HCI_EVENT_UNDERRUN";
          break;
        case 607:
          result = "OI_HCI_UNKNOWN_EVENT_CODE";
          break;
        case 608:
          result = "OI_HCI_BAD_EVENT_PARM_LEN";
          break;
        case 611:
          result = "OI_HCI_CMD_QUEUE_FULL";
          break;
        case 612:
          result = "OI_HCI_SHORT_EVENT";
          break;
        case 613:
          result = "OI_HCI_TRANSMIT_NOT_READY";
          break;
        case 614:
          result = "OI_HCI_ORPHAN_SENT_EVENT";
          break;
        case 615:
          result = "OI_HCI_CMD_TABLE_ERROR";
          break;
        case 616:
          result = "OI_HCI_UNKNOWN_CMD_ID";
          break;
        case 619:
          result = "OI_HCI_UNEXPECTED_EVENT";
          break;
        case 620:
          result = "OI_HCI_EVENT_TABLE_ERROR";
          break;
        case 621:
          result = "OI_HCI_EXPECTED_EVENT_TIMEOUT";
          break;
        case 622:
          result = "OI_HCI_NO_CMD_DESC_FOR_OPCODE";
          break;
        case 623:
          result = "OI_HCI_INVALID_OPCODE_ERROR";
          break;
        case 624:
          result = "OI_HCI_FLOW_CONTROL_DISABLED";
          break;
        case 625:
          result = "OI_HCI_TX_COMPLETE";
          break;
        case 626:
          result = "OI_HCI_TX_ERROR";
          break;
        case 627:
          result = "OI_HCI_DEVICE_NOT_INITIALIZED";
          break;
        case 628:
          result = "OI_HCI_UNSUPPORTED_COMMAND";
          break;
        case 629:
          result = "OI_HCI_PASSTHROUGH_ERROR";
          break;
        case 630:
          result = "OI_HCI_PASSTHROUGH_ALREADY_SET";
          break;
        case 631:
          result = "OI_HCI_RESET_FAILURE";
          break;
        case 632:
          result = "OI_HCI_TRANSPORT_RESET";
          break;
        case 633:
          result = "OI_HCIERR_HCIIFC_INIT_FAILURE";
          break;
        case 634:
          result = "OI_HCI_EXPECTED_EVENT_CONN_RELEASED";
          break;
        case 635:
          result = "OI_HCI_EXPECTED_EVENT_ORPHANED";
          break;
        case 637:
          result = "OI_HCI_STATUS_DEFAULT";
          break;
        case 638:
          result = "OI_HCI_FAIL_MISSING_PARAMS";
          break;
        case 639:
          result = "OI_HCI_MISSING_LINKTYPE";
          break;
        case 640:
          result = "OI_HCI_EXPECTED_EVENT_NOT_FOUND";
          break;
        case 641:
          result = "OI_HCI_WRITE_COD_HW_WORKAROUND";
          break;
        case 642:
          result = "OI_HCI_HW_ERROR_CHIP_RX_INVALID";
          break;
        case 643:
          result = "OI_HCI_HW_ERROR_HOST_RX_INVALID";
          break;
        case 644:
          result = "OI_HCI_HW_ERROR_TIMEDOUT_INVALID";
          break;
        case 645:
          result = "OI_HCI_HW_ERROR_RX_INVALID_STATE";
          break;
        case 646:
          result = "OI_HCI_HW_ERROR_TIMEDOUT_INVALID_STATE";
          break;
        case 647:
          result = "OI_HCI_HW_ERROR_RX_INVALID_LENGTH";
          break;
        case 648:
          result = "OI_HCI_HW_ERROR_CODE_UNKNOWN";
          break;
        case 649:
          result = "OI_HCI_DUPLICATE_LM_HANDLE";
          break;
        case 650:
          result = "OI_HCI_HW_ERROR_NOT_INITIALIZED";
          break;
        case 651:
          result = "OI_HCI_EVENT_DATA_UNDERRUN";
          break;
        case 652:
          result = "OI_HCI_HW_ERROR_SPMI_TIMEOUT";
          break;
        case 653:
          result = "OI_HCI_HW_ERROR_DID_NOT_SLEEP";
          break;
        case 654:
          result = "OI_HCI_HW_ERROR_CMD_DISALLOWED";
          break;
        case 701:
          result = "OI_HCIERR_UNKNOWN_HCI_COMMAND";
          break;
        case 702:
          result = "OI_HCIERR_UNKNOWN_CONNECTION_IDENTIFIER";
          break;
        case 703:
          result = "OI_HCIERR_HARDWARE_FAILURE";
          break;
        case 704:
          result = "OI_HCIERR_PAGE_TIMEOUT";
          break;
        case 705:
          result = "OI_HCIERR_AUTHENTICATION_FAILURE";
          break;
        case 706:
          result = "OI_HCIERR_KEY_MISSING";
          break;
        case 707:
          result = "OI_HCIERR_MEMORY_CAPACITY_EXCEEDED";
          break;
        case 708:
          result = "OI_HCIERR_CONNECTION_TIMEOUT";
          break;
        case 709:
          result = "OI_HCIERR_MAX_NUM_OF_CONNECTIONS";
          break;
        case 710:
          result = "OI_HCIERR_MAX_NUM_OF_SCO_CONNECTIONS";
          break;
        case 711:
          result = "OI_HCIERR_ACL_CONNECTION_ALREADY_EXISTS";
          break;
        case 712:
          result = "OI_HCIERR_COMMAND_DISALLOWED";
          break;
        case 713:
          result = "OI_HCIERR_HOST_REJECTED_RESOURCES";
          break;
        case 714:
          result = "OI_HCIERR_HOST_REJECTED_SECURITY";
          break;
        case 715:
          result = "OI_HCIERR_HOST_REJECTED_PERSONAL_DEVICE";
          break;
        case 716:
          result = "OI_HCIERR_HOST_TIMEOUT";
          break;
        case 717:
          result = "OI_HCIERR_UNSUPPORTED";
          break;
        case 718:
          result = "OI_HCIERR_INVALID_PARAMETERS";
          break;
        case 719:
          result = "OI_HCIERR_OTHER_END_USER_DISCONNECT";
          break;
        case 720:
          result = "OI_HCIERR_OTHER_END_LOW_RESOURCES";
          break;
        case 721:
          result = "OI_HCIERR_OTHER_END_POWERING_OFF";
          break;
        case 722:
          result = "OI_HCIERR_CONNECTION_TERMINATED_LOCALLY";
          break;
        case 723:
          result = "OI_HCIERR_REPEATED_ATTEMPTS";
          break;
        case 724:
          result = "OI_HCIERR_PAIRING_NOT_ALLOWED";
          break;
        case 725:
          result = "OI_HCIERR_UNKNOWN_LMP_PDU";
          break;
        case 726:
          result = "OI_HCIERR_UNSUPPORTED_REMOTE_FEATURE";
          break;
        case 727:
          result = "OI_HCIERR_SCO_OFFSET_REJECTED";
          break;
        case 728:
          result = "OI_HCIERR_SCO_INTERVAL_REJECTED";
          break;
        case 729:
          result = "OI_HCIERR_SCO_AIR_MODE_REJECTED";
          break;
        case 730:
          result = "OI_HCIERR_INVALID_LMP_PARMS";
          break;
        case 731:
          result = "OI_HCIERR_UNSPECIFIED_ERROR";
          break;
        case 732:
          result = "OI_HCIERR_UNSUPPORTED_LMP_PARAMETERS";
          break;
        case 733:
          result = "OI_HCIERR_ROLE_CHANGE_NOT_ALLOWED";
          break;
        case 734:
          result = "OI_HCIERR_LMP_RESPONSE_TIMEOUT";
          break;
        case 735:
          result = "OI_HCIERR_LMP_ERROR_TRANS_COLLISION";
          break;
        case 736:
          result = "OI_HCIERR_LMP_PDU_NOT_ALLOWED";
          break;
        case 737:
          result = "OI_HCIERR_ENCRYPTION_MODE_NOT_ACCEPTABLE";
          break;
        case 738:
          result = "OI_HCIERR_UNIT_KEY_USED";
          break;
        case 739:
          result = "OI_HCIERR_QOS_NOT_SUPPORTED";
          break;
        case 740:
          result = "OI_HCIERR_INSTANT_PASSED";
          break;
        case 741:
          result = "OI_HCIERR_UNIT_KEY_PAIRING_UNSUPPORTED";
          break;
        case 742:
          result = "OI_HCIERR_DIFFERENT_TRANS_COLLISION";
          break;
        case 743:
          result = "OI_HCIERR_RESERVED_2B";
          break;
        case 744:
          result = "OI_HCIERR_QOS_UNACCEPTABLE_PARAMETER";
          break;
        case 745:
          result = "OI_HCIERR_QOS_REJECTED";
          break;
        case 746:
          result = "OI_HCIERR_CHANNEL_CLASSIFICATION_NOT_SUPPORTED";
          break;
        case 747:
          result = "OI_HCIERR_INSUFFICIENT_SECURITY";
          break;
        case 748:
          result = "OI_HCIERR_PARAMETER_OUT_OF_MANDATORY_RANGE";
          break;
        case 749:
          result = "OI_HCIERR_RESERVED_31";
          break;
        case 750:
          result = "OI_HCIERR_ROLE_SWITCH_PENDING";
          break;
        case 751:
          result = "OI_HCIERR_RESERVED_33";
          break;
        case 752:
          result = "OI_HCIERR_RESERVED_SLOT_VIOLATION";
          break;
        case 753:
          result = "OI_HCIERR_ROLE_SWITCH_FAILED";
          break;
        case 754:
          result = "OI_HCIERR_EIR_TOO_LARGE";
          break;
        case 755:
          result = "OI_HCIERR_SSP_NOT_SUPPORTED_BY_HOST";
          break;
        case 756:
          result = "OI_HCIERR_HOST_BUSY_PAIRING";
          break;
        case 757:
          result = "OI_HCIERR_CONNECTION_REJ_NO_SUITABLE_CHANNEL";
          break;
        case 758:
          result = "OI_HCIERR_CONTROLLER_BUSY";
          break;
        case 759:
          result = "OI_HCIERR_UNACCEPTABLE_CONNECTION_PARAMETERS";
          break;
        case 760:
          result = "OI_HCIERR_ADVERTISING_TIMEOUT";
          break;
        case 761:
          result = "OI_HCIERR_CONNECTION_TERMINATED_DUE_TO_MIC_FAILURE";
          break;
        case 762:
          result = "OI_HCIERR_CONNECTION_FAILED_TO_BE_ESTABLISHED";
          break;
        case 763:
          result = "OI_HCIERR_MAC_CONNECTION_FAILED";
          break;
        case 766:
          result = "OI_HCIERR_UNKNOWN_ADVERTISING_IDENTIFIER";
          break;
        case 769:
          result = "OI_HCIERR_UNKNOWN_ERROR";
          break;
        case 800:
          result = "OI_SDP_SPEC_ERROR";
          break;
        case 802:
          result = "OI_SDP_INVALID_SERVICE_RECORD_HANDLE";
          break;
        case 803:
          result = "OI_SDP_INVALID_REQUEST_SYNTAX";
          break;
        case 804:
          result = "OI_SDP_INVALID_PDU_SIZE";
          break;
        case 805:
          result = "OI_SDP_INVALID_CONTINUATION_STATE";
          break;
        case 806:
          result = "OI_SDP_INSUFFICIENT_RESOURCES";
          break;
        case 807:
          result = "OI_SDP_ERROR";
          break;
        case 808:
          result = "OI_SDP_CORRUPT_DATA_ELEMENT";
          break;
        case 810:
          result = "OI_SDP_SERVER_NOT_CONNECTED";
          break;
        case 811:
          result = "OI_SDP_ACCESS_DENIED";
          break;
        case 812:
          result = "OI_SDP_ATTRIBUTES_OUT_OF_ORDER";
          break;
        case 813:
          result = "OI_SDP_DEVICE_DOES_NOT_SUPPORT_SDP";
          break;
        case 815:
          result = "OI_SDP_NO_MORE_DATA";
          break;
        case 816:
          result = "OI_SDP_REQUEST_PARAMS_TOO_LONG";
          break;
        case 817:
          result = "OI_SDP_REQUEST_PENDING";
          break;
        case 819:
          result = "OI_SDP_SERVER_CONNECT_FAILED";
          break;
        case 821:
          result = "OI_SDP_SERVER_TOO_MANY_CONNECTIONS";
          break;
        case 823:
          result = "OI_SDP_NO_MATCHING_SERVICE_RECORD";
          break;
        case 824:
          result = "OI_SDP_PARTIAL_RESPONSE";
          break;
        case 825:
          result = "OI_SDP_ILLEGAL_ARGUMENT";
          break;
        case 826:
          result = "OI_SDP_ATTRIBUTE_NOT_FOUND";
          break;
        case 827:
          result = "OI_SDP_DATABASE_OUT_OF_RESOURCES";
          break;
        case 829:
          result = "OI_SDP_SHORT_PDU";
          break;
        case 830:
          result = "OI_SDP_TRANSACTION_ID_MISMATCH";
          break;
        case 831:
          result = "OI_SDP_UNEXPECTED_RESPONSE_PDU_ID";
          break;
        case 832:
          result = "OI_SDP_REQUEST_TIMEOUT";
          break;
        case 833:
          result = "OI_SDP_INVALID_RESPONSE_SYNTAX";
          break;
        case 834:
          result = "OI_SDP_CONNECTION_TIMEOUT";
          break;
        case 835:
          result = "OI_SDP_RESPONSE_DATA_ERROR";
          break;
        case 836:
          result = "OI_SDP_TOO_MANY_ATTRIBUTE_BYTES";
          break;
        case 837:
          result = "OI_SDP_TOO_MANY_SERVICE_RECORDS";
          break;
        case 838:
          result = "OI_SDP_INVALID_CONNECTION_ID";
          break;
        case 839:
          result = "OI_SDP_CANNOT_SET_ATTRIBUTE";
          break;
        case 840:
          result = "OI_SDP_BADLY_FORMED_ATTRIBUTE_VALUE";
          break;
        case 841:
          result = "OI_SDP_NO_ATTRIBUTE_LIST_TO_REMOVE";
          break;
        case 842:
          result = "OI_SDP_ATTRIBUTE_LIST_ALREADY_ADDED";
          break;
        case 843:
          result = "OI_SDP_DATA_ELEMENT_TRUNCATED";
          break;
        case 844:
          result = "OI_SDP_STATUS_DEFAULT";
          break;
        case 845:
          result = "OI_SDP_ACCEPT_INCOMING_REQUEST";
          break;
        case 846:
          result = "OI_SDP_REJECT_INCOMING_REQUEST";
          break;
        case 847:
          result = "OI_SDP_STALL_INCOMING_REQUEST";
          break;
        case 901:
          result = "OI_RFCOMM_WRITE_IN_PROGRESS";
          break;
        case 903:
          result = "OI_RFCOMM_INVALID_BAUDRATE";
          break;
        case 904:
          result = "OI_RFCOMM_INVALID_DATABIT";
          break;
        case 905:
          result = "OI_RFCOMM_INVALID_STOPBIT";
          break;
        case 906:
          result = "OI_RFCOMM_INVALID_PARITY";
          break;
        case 907:
          result = "OI_RFCOMM_INVALID_PARITYTYPE";
          break;
        case 908:
          result = "OI_RFCOMM_INVALID_FLOWCONTROL";
          break;
        case 909:
          result = "OI_RFCOMM_SESSION_EXISTS";
          break;
        case 910:
          result = "OI_RFCOMM_INVALID_CHANNEL";
          break;
        case 911:
          result = "OI_RFCOMM_DLCI_EXISTS";
          break;
        case 912:
          result = "OI_RFCOMM_LINK_NOT_FOUND";
          break;
        case 913:
          result = "OI_RFCOMM_REMOTE_REJECT";
          break;
        case 915:
          result = "OI_RFCOMM_TEST_IN_PROGRESS";
          break;
        case 916:
          result = "OI_RFCOMM_SESSION_NOT_FOUND";
          break;
        case 917:
          result = "OI_RFCOMM_INVALID_PACKET";
          break;
        case 918:
          result = "OI_RFCOMM_FRAMESIZE_EXCEEDED";
          break;
        case 920:
          result = "OI_RFCOMM_INVALID_DLCI";
          break;
        case 921:
          result = "OI_RFCOMM_SERVER_NOT_REGISTERED";
          break;
        case 922:
          result = "OI_RFCOMM_CREDIT_ERROR";
          break;
        case 923:
          result = "OI_RFCOMM_NO_CHANNEL_NUMBER";
          break;
        case 924:
          result = "OI_RFCOMM_QUERY_IN_PROGRESS";
          break;
        case 925:
          result = "OI_RFCOMM_SESSION_SHUTDOWN";
          break;
        case 926:
          result = "OI_RFCOMM_LOCAL_DEVICE_DISCONNECTED";
          break;
        case 927:
          result = "OI_RFCOMM_REMOTE_DEVICE_DISCONNECTED";
          break;
        case 928:
          result = "OI_RFCOMM_OUT_OF_SERVER_CHANNELS";
          break;
        case 929:
          result = "OI_RFCOMM_SESSION_REQ_REJECTED";
          break;
        case 930:
          result = "OI_RFCOMM_SESSION_SHUTDOWN_TIMER_EXPIRED";
          break;
        case 931:
          result = "OI_RFCOMM_SESSION_SHUTDOWN_FRAME_TIMER_EXPIRED";
          break;
        case 932:
          result = "OI_RFCOMM_SESSION_SHUTDOWN_SEND_CREDIT_FAILED";
          break;
        case 933:
          result = "OI_RFCOMM_LINK_DISC_UA_SEND_FAILED";
          break;
        case 934:
          result = "OI_RFCOMM_LINK_DISC_REMOTE_ERROR";
          break;
        case 935:
          result = "OI_RFCOMM_LINK_DISC_FAILED";
          break;
        case 1001:
          result = "OI_DISPATCH_INVALID_CB_HANDLE";
          break;
        case 1002:
          result = "OI_DISPATCH_TABLE_OVERFLOW";
          break;
        case 1010:
          result = "OI_DATAELEM_INVALID_TYPE_ERROR";
          break;
        case 1021:
          result = "OI_SUPPORT_STRCAT_ERROR";
          break;
        case 1022:
          result = "OI_SUPPORT_MUTEX_FAILED";
          break;
        case 1023:
          result = "OI_SUPPORT_CMDCHAIN_INITIATE_ERROR";
          break;
        case 1030:
          result = "OI_BYTESTREAM_INVALID_DATA_POINTER";
          break;
        case 1031:
          result = "OI_BYTESTREAM_PARSE_ERROR";
          break;
        case 1040:
          result = "OI_OS_INTF_ABS_TIME_FAIL";
          break;
        case 1041:
          result = "OI_OS_INTF_AES128_CREATE_ERROR";
          break;
        case 1042:
          result = "OI_OS_INTF_AES128_UPDATE_ERROR";
          break;
        case 1043:
          result = "OI_OS_INTF_AES128_SIZE_ERROR";
          break;
        case 1044:
          result = "OI_OS_INTF_SUBKEY_ERROR";
          break;
        case 1045:
          result = "OI_OS_INTF_MAC_SUBKEY_ERROR";
          break;
        case 1046:
          result = "OI_OS_INTF_MAC_BLOCKS_ERROR";
          break;
        case 1047:
          result = "OI_OS_INTF_MAC_XOR_ERROR";
          break;
        case 1048:
          result = "OI_OS_INTF_DHKEY_PUB_ERROR";
          break;
        case 1049:
          result = "OI_OS_INTF_DHKEY_PRIV_ERROR";
          break;
        case 1050:
          result = "OI_OS_INTF_DHKEY_COMPUTE_KEY_ERROR";
          break;
        case 1051:
          result = "OI_OS_INTF_READ_LOCAL_PUBLIC_ERROR";
          break;
        case 1065:
          result = "OI_PLTF_INIT_ERROR";
          break;
        case 1066:
          result = "OI_PLTF_DEV_NAME_ERROR";
          break;
        case 1067:
          result = "OI_PLTF_DEV_ADDR_ERROR";
          break;
        case 1101:
          result = "OI_TEST_UNKNOWN_TEST";
          break;
        case 1102:
          result = "OI_TEST_FAIL";
          break;
        default:
          switch(a1)
          {
            case 101:
              result = "OI_STATUS_INVALID_PARAMETERS";
              break;
            case 102:
              result = "OI_STATUS_NOT_IMPLEMENTED";
              break;
            case 103:
              result = "OI_STATUS_NOT_INITIALIZED";
              break;
            case 104:
              result = "OI_STATUS_NO_RESOURCES";
              break;
            case 105:
              result = "OI_STATUS_INTERNAL_ERROR";
              break;
            case 106:
              result = "OI_STATUS_OUT_OF_MEMORY";
              break;
            case 107:
              result = "OI_ILLEGAL_REENTRANT_CALL";
              break;
            case 108:
              result = "OI_STATUS_INITIALIZATION_FAILED";
              break;
            case 109:
              result = "OI_STATUS_INITIALIZATION_PENDING";
              break;
            case 110:
              result = "OI_STATUS_NO_SCO_SUPPORT";
              break;
            case 111:
              result = "OI_STATUS_OUT_OF_STATIC_MEMORY";
              break;
            case 112:
              result = "OI_TIMEOUT";
              break;
            case 113:
              result = "OI_OS_ERROR";
              break;
            case 114:
              result = "OI_FAIL";
              break;
            case 115:
              result = "OI_STRING_FORMAT_ERROR";
              break;
            case 116:
              result = "OI_STATUS_PENDING";
              break;
            case 117:
              result = "OI_STATUS_INVALID_COMMAND";
              break;
            case 118:
              result = "OI_BUSY_FAIL";
              break;
            case 119:
              result = "OI_STATUS_ALREADY_REGISTERED";
              break;
            case 120:
              result = "OI_STATUS_NOT_FOUND";
              break;
            case 121:
              result = "OI_STATUS_NOT_REGISTERED";
              break;
            case 122:
              result = "OI_STATUS_NOT_CONNECTED";
              break;
            case 123:
              result = "OI_CALLBACK_FUNCTION_REQUIRED";
              break;
            case 124:
              result = "OI_STATUS_MBUF_OVERFLOW";
              break;
            case 125:
              result = "OI_STATUS_MBUF_UNDERFLOW";
              break;
            case 126:
              result = "OI_STATUS_CONNECTION_EXISTS";
              break;
            case 127:
              result = "OI_STATUS_NOT_CONFIGURED";
              break;
            case 128:
              result = "OI_LOWER_STACK_ERROR";
              break;
            case 129:
              result = "OI_STATUS_RESET_IN_PROGRESS";
              break;
            case 130:
              result = "OI_STATUS_ACCESS_DENIED";
              break;
            case 131:
              result = "OI_STATUS_DATA_ERROR";
              break;
            case 132:
              result = "OI_STATUS_INVALID_ROLE";
              break;
            case 133:
              result = "OI_STATUS_ALREADY_CONNECTED";
              break;
            case 134:
              result = "OI_STATUS_PARSE_ERROR";
              break;
            case 135:
              result = "OI_STATUS_END_OF_FILE";
              break;
            case 136:
              result = "OI_STATUS_READ_ERROR";
              break;
            case 137:
              result = "OI_STATUS_WRITE_ERROR";
              break;
            case 138:
              result = "OI_STATUS_NEGOTIATION_FAILURE";
              break;
            case 139:
              result = "OI_STATUS_READ_IN_PROGRESS";
              break;
            case 140:
              result = "OI_STATUS_ALREADY_INITIALIZED";
              break;
            case 141:
              result = "OI_STATUS_STILL_CONNECTED";
              break;
            case 142:
              result = "OI_STATUS_MTU_EXCEEDED";
              break;
            case 143:
              result = "OI_STATUS_LINK_TERMINATED";
              break;
            case 144:
              result = "OI_STATUS_PIN_CODE_TOO_LONG";
              break;
            case 145:
              result = "OI_STATUS_STILL_REGISTERED";
              break;
            case 146:
              result = "OI_STATUS_SPEC_VIOLATION";
              break;
            case 147:
              result = "OI_STATUS_LE_NOT_SUPPORTED";
              break;
            case 148:
              result = "OI_STATUS_MUTEX_DESTROY_FAILED";
              break;
            case 149:
              result = "OI_STATUS_INVALID_LE_CONNECTION";
              break;
            case 150:
              result = "OI_STACKWRAPPER_TIMEOUT";
              break;
            case 151:
              result = "OI_CONDITIONAL_TIMEOUT";
              break;
            case 152:
              result = "OI_STATUS_UNSUPPORTED";
              break;
            case 153:
              result = "OI_STATUS_WATCH_TS_REMOTE_UNSUPPORTED";
              break;
            case 154:
              result = "OI_STATUS_CCECB_FAIL";
              break;
            case 155:
              result = "OI_STATUS_INVALID_LE_PERIODIC_SYNC";
              break;
            case 156:
              return 0;
            case 157:
              result = "OI_STATUS_LE_DUPLICATE_CONNECTIONS";
              break;
            case 158:
              result = "OI_STATUS_DUPLICATE_BD_ADDR";
              break;
            case 159:
              result = "OI_STATUS_FAST_LE_CONNECTION_FAILED";
              break;
            case 160:
              result = "OI_STATUS_OUTGOING_CONNECTION_DENIED";
              break;
            case 161:
              result = "OI_STATUS_INCOMPLETE_DATA";
              break;
            case 162:
              result = "OI_STATUS_INVALID_LENGTH";
              break;
            default:
              if (a1)
                return 0;
              result = "OI_OK";
              break;
          }
          break;
      }
    }
    return result;
  }
  if (a1 <= 3569)
  {
    if (a1 > 2100)
    {
      if (a1 > 3100)
      {
        if (a1 > 3389)
        {
          switch(a1)
          {
            case 3450:
              result = "BT_MAP_CONNECT_MNS_MAX_CONN";
              break;
            case 3451:
              result = "BT_MAP_SERVER_CONN_IND_MAX_CLIENT";
              break;
            case 3452:
              result = "BT_MAP_SERVER_GET_IND_MAX_CLIENT";
              break;
            case 3453:
              result = "BT_MAP_SERVER_PUT_IND_MAX_CLIENT";
              break;
            case 3454:
              result = "BT_MAP_SERVER_DISC_MAX_CLIENT";
              break;
            case 3455:
              result = "BT_MAP_SERVER_ACCEPT_MAX_CLIENT";
              break;
            case 3456:
              result = "BT_MAP_SEND_MAX_CLIENT";
              break;
            case 3457:
              result = "BT_MAP_GETRESPONSE_MAX_CLIENT";
              break;
            case 3458:
              result = "BT_MAP_SEND_MSG_RESPONSE_ERROR";
              break;
            case 3459:
              result = "BT_MAP_SEND_MSG_MAX_CLIENT";
              break;
            case 3460:
              result = "BT_MAP_GET_FOLDER_MAX_CLIENT";
              break;
            case 3461:
            case 3462:
            case 3463:
            case 3464:
            case 3465:
            case 3466:
            case 3467:
            case 3468:
            case 3469:
              return 0;
            case 3470:
              result = "BT_NETWORK_STATUS_DEFAULT";
              break;
            case 3471:
              result = "BT_NETWORK_IF_CREATE_ERROR";
              break;
            case 3472:
              result = "BT_NETWORK_ADD_HOST_ERROR";
              break;
            case 3473:
              result = "BT_NETWORK_MAX_CONN_ERROR";
              break;
            case 3474:
              result = "BT_NETWORK_IF_WRITE_ERROR";
              break;
            default:
              switch(a1)
              {
                case 3390:
                  result = "OI_BIPSRV_REJECT";
                  break;
                case 3391:
                case 3392:
                case 3393:
                case 3394:
                case 3395:
                case 3396:
                case 3397:
                case 3398:
                case 3399:
                  return 0;
                case 3400:
                  result = "OI_PAN_CONSUMER_IF_WRITE_ERROR";
                  break;
                case 3401:
                  result = "OI_PAN_STATUS_DEFAULT";
                  break;
                case 3402:
                  result = "OI_PAN_INVALID_NET_IFC";
                  break;
                case 3403:
                  result = "OI_PAN_USER_IFCREATE_ERROR";
                  break;
                case 3404:
                  result = "OI_PAN_USER_IFWRITE_ERROR";
                  break;
                default:
                  switch(a1)
                  {
                    case 3550:
                      result = "BT_MAGIC_PAIRING_IN_PROGRESS";
                      break;
                    case 3551:
                      result = "BT_MAGIC_PAIRING_NO_TABLE_FOUND";
                      break;
                    case 3552:
                      result = "BT_MAGIC_PAIRING_NO_HINT";
                      break;
                    case 3553:
                      result = "BT_MAGIC_PAIRING_NOT_INPROGRESS";
                      break;
                    default:
                      return 0;
                  }
                  break;
              }
              break;
          }
        }
        else
        {
          if (a1 <= 3200)
          {
            switch(a1)
            {
              case 3101:
                return "OI_AADP_BAD_ENDPOINT";
              case 3102:
                return "OI_AADP_BAD_STATE";
              case 3200:
                return "OI_UNICODE_INVALID_SOURCE";
            }
            return 0;
          }
          switch(a1)
          {
            case 3300:
              result = "OI_AVRCP_TOO_MANY_CONNECTIONS";
              break;
            case 3301:
              result = "OI_AVRCP_NOT_IMPLEMENTED";
              break;
            case 3302:
              result = "OI_AVRCP_REJECTED";
              break;
            case 3303:
              result = "OI_AVRCP_INVALID_RESPONSE";
              break;
            case 3304:
              result = "OI_AVRCP_RESPONSE_PACKET_OVERFLOW";
              break;
            case 3305:
              result = "OI_AVRCP_RESPONSE_INVALID_PDU";
              break;
            case 3306:
              result = "OI_AVRCP_RESPONSE_INVALID_PARAMETER";
              break;
            case 3307:
              result = "OI_AVRCP_RESPONSE_PARAMETER_NOT_FOUND";
              break;
            case 3308:
              result = "OI_AVRCP_RESPONSE_INTERNAL_ERROR";
              break;
            case 3309:
              result = "OI_AVRCP_NO_REGISTERED_HANDLER_ERROR";
              break;
            case 3310:
              result = "OI_AVRCP_RECVIND_INVALID_PID_ERROR";
              break;
            case 3311:
              result = "OI_AVRCP_B_RECVIND_INVALID_PID_ERROR";
              break;
            case 3312:
              result = "OI_AVRCP_TIMEOUT";
              break;
            default:
              if (a1 == 3201)
              {
                result = "OI_UNICODE_SOURCE_EXHAUSTED";
              }
              else
              {
                if (a1 != 3202)
                  return 0;
                result = "OI_UNICODE_DESTINATION_EXHAUSTED";
              }
              break;
          }
        }
      }
      else if (a1 > 2600)
      {
        if (a1 > 2800)
        {
          if (a1 > 2902)
          {
            switch(a1)
            {
              case 3001:
                result = "OI_PBAP_REPOSITORY_NOT_SET";
                break;
              case 3002:
                result = "OI_PBAP_PHONEBOOK_NOT_SET";
                break;
              case 3003:
                result = "OI_PBAP_SET_PATH_DONE_ERROR";
                break;
              case 3004:
                result = "OI_PBAP_SERVER_SIZE_ERROR";
                break;
              case 3005:
                result = "OI_PBAP_CLIENT_ADDR_ERROR";
                break;
              default:
                if (a1 != 2903)
                  return 0;
                result = "OI_AVDTP_INVALID_STREAM_HANDLE";
                break;
            }
          }
          else
          {
            switch(a1)
            {
              case 2801:
                result = "OI_BLST_CHARACTER_TIMEOUT";
                break;
              case 2802:
                result = "OI_BLST_ACKNOWLDGE_TIMEOUT";
                break;
              case 2803:
                result = "OI_BLST_TX_NOT_READY";
                break;
              case 2804:
                result = "OI_BLST_TX_BUSY";
                break;
              default:
                if (a1 == 2901)
                {
                  result = "OI_AVDTP_CONNECTION_SEQ_ERROR";
                }
                else
                {
                  if (a1 != 2902)
                    return 0;
                  result = "OI_AVDTP_OUT_OF_RESOURCES";
                }
                break;
            }
          }
        }
        else
        {
          switch(a1)
          {
            case 2701:
              result = "OI_AT_ERROR";
              break;
            case 2702:
              result = "OI_AT_NO_CARRIER";
              break;
            case 2703:
              result = "OI_AT_BUSY";
              break;
            case 2704:
              result = "OI_AT_NO_ANSWER";
              break;
            case 2705:
              result = "OI_AT_DELAYED";
              break;
            case 2706:
              result = "OI_AT_BLACKLISTED";
              break;
            case 2707:
              result = "OI_AT_CME_ERROR";
              break;
            case 2708:
              result = "OI_AT_CMS_ERROR";
              break;
            default:
              switch(a1)
              {
                case 2601:
                  result = "OI_HID_HOST_SERVICE_NOT_STARTED";
                  break;
                case 2602:
                  result = "OI_HID_DEVICE_SERVICE_NOT_STARTED";
                  break;
                case 2603:
                  result = "OI_HID_CONTROL_DISC_IND";
                  break;
                case 2604:
                  result = "OI_HID_TIMEOUT";
                  break;
                default:
                  return 0;
              }
              break;
          }
        }
      }
      else if (a1 > 2300)
      {
        switch(a1)
        {
          case 2301:
            result = "OI_CODEC_SBC_NO_SYNCWORD";
            break;
          case 2302:
            result = "OI_CODEC_SBC_NOT_ENOUGH_HEADER_DATA";
            break;
          case 2303:
            result = "OI_CODEC_SBC_NOT_ENOUGH_BODY_DATA";
            break;
          case 2304:
            result = "OI_CODEC_SBC_NOT_ENOUGH_AUDIO_DATA";
            break;
          case 2305:
            result = "OI_CODEC_SBC_CHECKSUM_MISMATCH";
            break;
          case 2306:
            result = "OI_CODEC_SBC_PARTIAL_DECODE";
            break;
          default:
            switch(a1)
            {
              case 2401:
                result = "OI_FIFOQ_QUEUE_NOT_ALIGNED";
                break;
              case 2402:
                result = "OI_FIFOQ_INVALID_Q";
                break;
              case 2403:
                result = "OI_FIFOQ_BUF_TOO_LARGE";
                break;
              case 2404:
                result = "OI_FIFOQ_FULL";
                break;
              case 2405:
                result = "OI_FIFOQ_NOT_ALLOCATED";
                break;
              case 2406:
                result = "OI_FIFOQ_INVALID_DATA_PTR";
                break;
              default:
                return 0;
            }
            break;
        }
      }
      else
      {
        switch(a1)
        {
          case 2201:
            result = "OI_PAN_ROLE_ALREADY_REGISTERED";
            break;
          case 2202:
            result = "OI_PAN_ROLE_NOT_ALLOWED";
            break;
          case 2203:
            result = "OI_PAN_INCOMPATIBLE_ROLES";
            break;
          case 2204:
            result = "OI_PAN_INVALID_ROLE";
            break;
          case 2205:
            result = "OI_PAN_CONNECTION_IN_PROGRESS";
            break;
          case 2206:
            result = "OI_PAN_USER_ALREADY_CONNECTED";
            break;
          case 2207:
            result = "OI_PAN_DEVICE_CONNECTED";
            break;
          default:
            switch(a1)
            {
              case 2101:
                result = "OI_NETIFC_UP_FAILED";
                break;
              case 2102:
                result = "OI_NETIFC_COULD_NOT_CREATE_THREAD";
                break;
              case 2103:
                result = "OI_NETIFC_INITIALIZATION_FAILED";
                break;
              case 2104:
                result = "OI_NETIFC_INTERFACE_ALREADY_UP";
                break;
              case 2105:
                result = "OI_NETIFC_INTERFACE_NOT_UP";
                break;
              case 2106:
                result = "OI_NETIFC_PACKET_TOO_BIG";
                break;
              default:
                return 0;
            }
            break;
        }
      }
    }
    else if (a1 > 1900)
    {
      if (a1 <= 2000)
      {
        switch(a1)
        {
          case 1901:
            return "OI_HEADSET_SERVICE_NOT_STARTED";
          case 1902:
            return "OI_HEADSET_AG_SERVICE_NOT_STARTED";
          case 1903:
            return "OI_HEADSET_COMMAND_IN_PROGRESS";
        }
        return 0;
      }
      switch(a1)
      {
        case 2001:
          result = "OI_BNEP_INVALID_MTU";
          break;
        case 2002:
          result = "OI_BNEP_SETUP_TIMEOUT";
          break;
        case 2003:
          result = "OI_BNEP_SERVICE_NOT_REGISTERED";
          break;
        case 2004:
          result = "OI_BNEP_INVALID_HANDLE";
          break;
        case 2005:
          result = "OI_BNEP_RESPONSE_TIMEOUT";
          break;
        case 2006:
          result = "OI_BNEP_INVALID_CONNECTION";
          break;
        case 2007:
          result = "OI_BNEP_INVALID_FILTER";
          break;
        case 2008:
          result = "OI_BNEP_CONNECTION_EXISTS";
          break;
        case 2009:
          result = "OI_BNEP_NOT_INITIALIZED";
          break;
        case 2010:
          result = "OI_BNEP_CONNECT_BASE";
          break;
        case 2011:
          result = "OI_BNEP_CONNECT_FAILED_INVALID_DEST_UUID";
          break;
        case 2012:
          result = "OI_BNEP_CONNECT_FAILED_INVALID_SOURCE_UUID";
          break;
        case 2013:
          result = "OI_BNEP_CONNECT_FAILED_INVALID_UUID_SIZE";
          break;
        case 2014:
          result = "OI_BNEP_CONNECT_FAILED_NOT_ALLOWED";
          break;
        case 2020:
          result = "OI_BNEP_FILTER_NET_BASE";
          break;
        case 2021:
          result = "OI_BNEP_FILTER_NET_UNSUPPORTED_REQUEST";
          break;
        case 2022:
          result = "OI_BNEP_FILTER_NET_FAILED_INVALID_PROTOCOL_TYPE";
          break;
        case 2023:
          result = "OI_BNEP_FILTER_NET_FAILED_MAX_LIMIT_REACHED";
          break;
        case 2024:
          result = "OI_BNEP_FILTER_NET_FAILED_SECURITY";
          break;
        case 2030:
          result = "OI_BNEP_FILTER_MULTI_BASE";
          break;
        case 2031:
          result = "OI_BNEP_FILTER_MULTI_UNSUPPORTED_REQUEST";
          break;
        case 2032:
          result = "OI_BNEP_FILTER_MULTI_FAILED_INVALID_ADDRESS";
          break;
        case 2033:
          result = "OI_BNEP_FILTER_MULTI_FAILED_MAX_LIMIT_REACHED";
          break;
        case 2034:
          result = "OI_BNEP_FILTER_MULTI_FAILED_SECURITY";
          break;
        case 2040:
          result = "OI_BNEP_LOCAL_DEVICE_MUST_BE_CENTRAL";
          break;
        case 2041:
          result = "OI_BNEP_PACKET_FILTERED_OUT";
          break;
        case 2042:
          result = "OI_BNEP_NO_PACKET_FOUND";
          break;
        case 2043:
          result = "OI_BNEP_TIMEOUT";
          break;
        default:
          return 0;
      }
    }
    else if (a1 <= 1700)
    {
      switch(a1)
      {
        case 1602:
          result = "OI_TCS_INVALID_ELEMENT_TYPE";
          break;
        case 1603:
          result = "OI_TCS_INVALID_PACKET";
          break;
        case 1604:
          result = "OI_TCS_CALL_IN_PROGRESS";
          break;
        case 1605:
          result = "OI_TCS_NO_CALL_IN_PROGRESS";
          break;
        default:
          if (a1 == 1500)
          {
            result = "OI_DEVMGR_POLICY_ACL_DISCONNECTED";
          }
          else
          {
            if (a1 != 1501)
              return 0;
            result = "OI_DEVMGR_POLICY_ENFORCEMENT_TIMEOUT";
          }
          break;
      }
    }
    else
    {
      switch(a1)
      {
        case 1701:
          result = "OI_OBEX_CONTINUE";
          break;
        case 1702:
          result = "OI_OBEX_COMMAND_ERROR";
          break;
        case 1703:
          result = "OI_OBEX_CONNECTION_TIMEOUT";
          break;
        case 1704:
          result = "OI_OBEX_CONNECT_FAILED";
          break;
        case 1705:
          result = "OI_OBEX_DISCONNECT_FAILED";
          break;
        case 1706:
          result = "OI_OBEX_ERROR";
          break;
        case 1707:
          result = "OI_OBEX_INCOMPLETE_PACKET";
          break;
        case 1708:
          result = "OI_OBEX_LENGTH_REQUIRED";
          break;
        case 1709:
          result = "OI_OBEX_NOT_CONNECTED";
          break;
        case 1710:
          result = "OI_OBEX_NO_MORE_CONNECTIONS";
          break;
        case 1711:
          result = "OI_OBEX_OPERATION_IN_PROGRESS";
          break;
        case 1712:
          result = "OI_OBEX_PUT_RESPONSE_ERROR";
          break;
        case 1713:
          result = "OI_OBEX_GET_RESPONSE_ERROR";
          break;
        case 1714:
          result = "OI_OBEX_REQUIRED_HEADER_NOT_FOUND";
          break;
        case 1715:
          result = "OI_OBEX_SERVICE_UNAVAILABLE";
          break;
        case 1716:
          result = "OI_OBEX_TOO_MANY_HEADER_BYTES";
          break;
        case 1717:
          result = "OI_OBEX_UNKNOWN_COMMAND";
          break;
        case 1718:
          result = "OI_OBEX_UNSUPPORTED_VERSION";
          break;
        case 1719:
          result = "OI_OBEX_CLIENT_ABORTED_COMMAND";
          break;
        case 1720:
          result = "OI_OBEX_BAD_PACKET";
          break;
        case 1721:
          result = "OI_OBEX_BAD_REQUEST";
          break;
        case 1723:
          result = "OI_OBEX_OBJECT_OVERFLOW";
          break;
        case 1724:
          result = "OI_OBEX_NOT_FOUND";
          break;
        case 1735:
          result = "OI_OBEX_ACCESS_DENIED";
          break;
        case 1736:
          result = "OI_OBEX_VALUE_NOT_ACCEPTABLE";
          break;
        case 1737:
          result = "OI_OBEX_PACKET_OVERFLOW";
          break;
        case 1738:
          result = "OI_OBEX_NO_SUCH_FOLDER";
          break;
        case 1739:
          result = "OI_OBEX_NAME_REQUIRED";
          break;
        case 1740:
          result = "OI_OBEX_PASSWORD_TOO_LONG";
          break;
        case 1741:
          result = "OI_OBEX_PRECONDITION_FAILED";
          break;
        case 1742:
          result = "OI_OBEX_UNAUTHORIZED";
          break;
        case 1743:
          result = "OI_OBEX_NOT_IMPLEMENTED";
          break;
        case 1744:
          result = "OI_OBEX_INVALID_AUTH_DIGEST";
          break;
        case 1745:
          result = "OI_OBEX_INVALID_OPERATION";
          break;
        case 1746:
          result = "OI_OBEX_DATABASE_FULL";
          break;
        case 1747:
          result = "OI_OBEX_DATABASE_LOCKED";
          break;
        case 1748:
          result = "OI_OBEX_INTERNAL_SERVER_ERROR";
          break;
        case 1749:
          result = "OI_OBEX_UNSUPPORTED_MEDIA_TYPE";
          break;
        case 1750:
          result = "OI_OBEX_PARTIAL_CONTENT";
          break;
        case 1751:
          result = "OI_OBEX_METHOD_NOT_ALLOWED";
          break;
        case 1752:
          result = "OI_OBEXSRV_INCOMPLETE_GET";
          break;
        case 1753:
          result = "OI_OBEX_FOLDER_BROWSING_NOT_ALLOWED";
          break;
        case 1754:
          result = "OI_OBEX_SERVER_FORCED_DISCONNECT";
          break;
        case 1755:
          result = "OI_OBEX_OFS_ERROR";
          break;
        case 1756:
          result = "OI_OBEX_FILEOP_ERROR";
          break;
        case 1757:
          result = "OI_OBEX_USERID_TOO_LONG";
          break;
        case 1758:
          result = "OI_OBEX_APPEND_PARSER_ERROR";
          break;
        case 1759:
          result = "OI_OBEXSRV_REJECT";
          break;
        case 1801:
          result = "OI_HANDSFREE_EVENT_REPORTING_DISABLED";
          break;
        case 1802:
          result = "OI_HANDSFREE_NOT_CONNECTED";
          break;
        case 1803:
          result = "OI_HANDSFREE_SERVICE_NOT_STARTED";
          break;
        case 1804:
          result = "OI_HANDSFREE_AG_SERVICE_NOT_STARTED";
          break;
        case 1805:
          result = "OI_HANDSFREE_COMMAND_IN_PROGRESS";
          break;
        case 1806:
          result = "OI_HANDSFREE_AUDIO_ALREADY_CONNECTED";
          break;
        case 1807:
          result = "OI_HANDSFREE_AUDIO_NOT_CONNECTED";
          break;
        case 1808:
          result = "OI_HANDSFREE_FEATURE_NOT_SUPPORTED";
          break;
        case 1809:
          result = "OI_HANDSFREE_CODEC_SELECTION_TIMEOUT";
          break;
        case 1810:
          result = "OI_HANDSFREE_CODEC_SELECTION_FAILED";
          break;
        case 1811:
          result = "OI_HANDSFREE_PARAMS_EXCEEDED";
          break;
        case 1812:
          result = "OI_HANDSFREE_CODEC_NOT_SUPPORTED";
          break;
        case 1813:
          result = "OI_HANDSFREE_INVALID_CODEC";
          break;
        case 1814:
          result = "OI_HANDSFREE_AG_TIMEOUT";
          break;
        case 1815:
          result = "OI_HANDSFREE_DISC_MAX_HFP_DEVICES";
          break;
        case 1816:
          result = "OI_HANDSFREE_LOCAL_DISC_CTRL_MISMATCH";
          break;
        case 1817:
          result = "OI_HANDSFREE_LOCAL_DISC_SCO_REG_FAIL";
          break;
        case 1818:
          result = "OI_LOCAL_DEVICE_DISC";
          break;
        default:
          return 0;
      }
    }
  }
  else
  {
    if (a1 > 4299)
    {
      if (a1 <= 4999)
      {
        switch(a1)
        {
          case 4800:
            result = "OI_SMP_ERROR_FAIL";
            break;
          case 4801:
            result = "OI_SMP_ERROR_ALREADY_ENCRYPTED";
            break;
          case 4802:
            result = "OI_SMP_ERROR_NOT_ENCRYPTED";
            break;
          case 4803:
            result = "OI_SMP_ERROR_NO_KEY";
            break;
          case 4804:
            result = "OI_SMP_ERROR_IN_PROGRESS";
            break;
          case 4805:
            result = "OI_SMP_ERROR_CONFIRM_VALUE_FAILED";
            break;
          case 4806:
            result = "OI_SMP_ERROR_NOT_IN_PAIRING_MODE";
            break;
          case 4807:
            result = "OI_SMP_ERROR_TIMEOUT";
            break;
          case 4808:
            result = "OI_SMP_ERROR_ALREADY_PAIRED";
            break;
          case 4809:
            result = "OI_SMP_ERROR_PASSKEY_ENTRY_FAILED";
            break;
          case 4810:
            result = "OI_SMP_ERROR_OOB_NOT_AVAILABLE";
            break;
          case 4811:
            result = "OI_SMP_ERROR_AUTH_REQUIREMENT";
            break;
          case 4812:
            result = "OI_SMP_ERROR_PAIRING_NOT_SUPPORTED";
            break;
          case 4813:
            result = "OI_SMP_ERROR_ENCYPRTION_KEY_SIZE";
            break;
          case 4814:
            result = "OI_SMP_ERROR_COMMAND_NOT_SUPPORTED";
            break;
          case 4815:
            result = "OI_SMP_ERROR_UNSPECIFIED_REASON";
            break;
          case 4816:
            result = "OI_SMP_ERROR_REPEATED_ATTEMPS";
            break;
          case 4817:
            result = "OI_SMP_ERROR_INVALID_PARAMETERS";
            break;
          case 4818:
            result = "OI_SMP_ERROR_DHKEY_CHECK_FAILED";
            break;
          case 4819:
            result = "OI_SMP_ERROR_NUM_COMPARISON_FAILED";
            break;
          case 4820:
            result = "OI_SMP_ERROR_INVALID_HANDLE";
            break;
          case 4821:
            result = "OI_SMP_ERROR_NOT_CENTRAL";
            break;
          case 4822:
            result = "OI_SMP_ERROR_NOT_PERIPHERAL";
            break;
          case 4823:
            result = "OI_SMP_ERROR_INVALID_PAIR_STATE";
            break;
          case 4824:
            result = "OI_SMP_ERROR_NO_CALLBACK";
            break;
          case 4825:
            result = "OI_SMP_ERROR_CRYPTO_FAILED";
            break;
          case 4826:
            result = "OI_SMP_ERROR_NO_ROOT_KEYS";
            break;
          case 4827:
            result = "OI_SMP_ERROR_TIMEOUT_USER_RSP";
            break;
          case 4828:
            result = "OI_SMP_ERROR_CRYPTO_IRK";
            break;
          case 4829:
            result = "OI_SMP_ERROR_CRYPTO";
            break;
          case 4830:
            result = "OI_SMP_ERROR_BREDR_PAIRING_IN_PROGRESS";
            break;
          case 4831:
            result = "OI_SMP_ERROR_CTKD_NA";
            break;
          case 4832:
            result = "LE_SECURITY_ERROR_COMPROMISED_DEVICE";
            break;
          case 4833:
            result = "LE_SECURITY_ERROR_OTHER_SIDE_UNPAIRED";
            break;
          case 4834:
            result = "LE_SECURITY_ERROR_ENCRYPTION_TIMEOUT";
            break;
          case 4835:
            result = "LE_SECURITY_ERROR_TOO_MANY_PAIRED_DEVICES";
            break;
          case 4836:
            result = "LE_SECURITY_ERROR_NEW_LOCAL_DEVICE_IDENTIFIER";
            break;
          case 4837:
            result = "LE_SECURITY_ERROR_PAIRING_NOT_ALLOWED";
            break;
          default:
            switch(a1)
            {
              case 4300:
                result = "BT_ATT_STATUS_SUCCESS";
                break;
              case 4301:
                result = "BT_ATT_ERROR_INVALID_HANDLE";
                break;
              case 4302:
                result = "BT_ATT_ERROR_READ_NOT_PERMITTED";
                break;
              case 4303:
                result = "BT_ATT_ERROR_WRITE_NOT_PERMITTED";
                break;
              case 4304:
                result = "BT_ATT_ERROR_INVALID_PDU";
                break;
              case 4305:
                result = "BT_ATT_ERROR_INSUFFICIENT_AUTHENTICATION";
                break;
              case 4306:
                result = "BT_ATT_ERROR_REQUEST_NOT_SUPPORTED";
                break;
              case 4307:
                result = "BT_ATT_ERROR_INVALID_OFFSET";
                break;
              case 4308:
                result = "BT_ATT_ERROR_INSUFFICIENT_AUTHORIZATION";
                break;
              case 4309:
                result = "BT_ATT_ERROR_PREPARE_QUEUE_FULL";
                break;
              case 4310:
                result = "BT_ATT_ERROR_ATTRIBUTE_NOT_FOUND";
                break;
              case 4311:
                result = "BT_ATT_ERROR_ATTRIBUTE_NOT_LONG";
                break;
              case 4312:
                result = "BT_ATT_ERROR_INSUFFICIENT_ENCRYPTION_KEY_SIZE";
                break;
              case 4313:
                result = "BT_ATT_ERROR_INVALID_ATTRIBUTE_VALUE_LENGTH";
                break;
              case 4314:
                result = "BT_ATT_ERROR_UNLIKELY_ERROR";
                break;
              case 4315:
                result = "BT_ATT_ERROR_INSUFFICIENT_ENCRYPTION";
                break;
              case 4316:
                result = "BT_ATT_ERROR_UNSUPPORTED_GROUP_TYPEN";
                break;
              case 4317:
                result = "BT_ATT_ERROR_INSUFFICIENT_RESOURCES";
                break;
              default:
                switch(a1)
                {
                  case 4540:
                    result = "BT_ATT_ERROR_RESPONSE_PENDING";
                    break;
                  case 4541:
                    result = "BT_ATT_ERROR_RESPONSE_TIMEOUT_REACHED";
                    break;
                  case 4542:
                    result = "BT_ATT_ERROR_APPLICATION_UNAVAILABLE";
                    break;
                  case 4543:
                    result = "BT_ATT_ERROR_RESPONSE_FULL";
                    break;
                  case 4544:
                    result = "BT_ATT_ERROR_PREPARE_WRITE_INVALID";
                    break;
                  case 4545:
                    result = "BT_ATT_ERROR_WRITE_REJECTED";
                    break;
                  default:
                    return 0;
                }
                break;
            }
            break;
        }
        return result;
      }
      if (a1 <= 5099)
      {
        switch(a1)
        {
          case 5000:
            result = "BT_TS_TIMEOUT_UPGRADE_ERR";
            break;
          case 5001:
            result = "BT_TS_TIMEOUT_UPGRADING_ERR";
            break;
          case 5002:
            result = "BT_TS_TIMEOUT_UPGRADE_ENCRYPT_ERR";
            break;
          case 5003:
            result = "BT_TS_TIMEOUT_UPGRADE_FINAL_ERR";
            break;
          case 5004:
            result = "BT_TS_TIMEOUT_DOWNGRADE_STALL_ERR";
            break;
          case 5005:
            result = "BT_TS_TIMEOUT_DOWNGRADE_ERR";
            break;
          case 5006:
            result = "BT_TS_L2CAP_ERR";
            break;
          case 5007:
            result = "BT_TS_NO_ALTERNATE_TRANSPORT";
            break;
          case 5008:
            result = "BT_TS_FLUSH_NOT_SUPPORTED_ON_LE";
            break;
          case 5009:
            result = "BT_TS_LE_DISCONNECTED";
            break;
          case 5010:
            result = "BT_TS_UPGRADE_NOT_TRACKED_CENTRAL";
            break;
          case 5011:
            result = "BT_TS_UPGRADE_NOT_TRACKED_PERIPHERAL";
            break;
          case 5012:
            result = "BT_TS_UPGRADE_POLICY_ENF_FAILED";
            break;
          case 5013:
            result = "BT_TS_STATUS_DEFAULT";
            break;
          case 5014:
            result = "BT_TS_TIMEOUT";
            break;
          case 5015:
            result = "BT_TS_SWITCH_HW_ERROR";
            break;
          case 5016:
            result = "BT_TS_ERROR_INVALID_LMHANDLE";
            break;
          case 5017:
            result = "BT_TS_ERROR_LL_COLLISION_DETECTED_AFH";
            break;
          case 5018:
            result = "BT_TS_ERROR_LL_COLLISION_DETECTED_CON_UPDATE";
            break;
          case 5019:
            result = "BT_TS_ERROR_LL_COLLISION_REJECTED_AFH";
            break;
          case 5020:
            result = "BT_TS_ERROR_LL_COLLISION_REJECTED_CON_UPDATE";
            break;
          case 5021:
          case 5022:
          case 5023:
          case 5024:
          case 5025:
          case 5026:
          case 5027:
          case 5028:
          case 5029:
          case 5030:
          case 5031:
          case 5032:
          case 5033:
          case 5034:
          case 5035:
          case 5036:
          case 5037:
          case 5038:
          case 5039:
          case 5040:
          case 5041:
          case 5042:
          case 5043:
          case 5044:
          case 5045:
          case 5046:
          case 5047:
          case 5048:
          case 5049:
            return 0;
          case 5050:
            result = "BT_TS_STATUS_SUCCESS";
            break;
          case 5051:
            result = "BT_TS_STATUS_ERROR_INTERNAL";
            break;
          case 5052:
            result = "BT_TS_STATUS_ERROR_ROLE";
            break;
          case 5053:
            result = "BT_TS_STATUS_ERROR_PDU";
            break;
          case 5054:
            result = "BT_TS_STATUS_ERROR_TRANSPORT";
            break;
          case 5055:
            result = "BT_TS_STATUS_ERROR_STATE";
            break;
          case 5056:
            result = "BT_TS_STATUS_ERROR_ENCRYPTION";
            break;
          case 5057:
            result = "BT_TS_STATUS_ERROR_CONTROLLER";
            break;
          default:
            if (a1 != 5090)
              return 0;
            result = "BT_TR_PARSER_PRELUDE_INCOMPLETE";
            break;
        }
        return result;
      }
      if (a1 > 5402)
      {
        switch(a1)
        {
          case 9500:
            result = "BD_HCI_STALL_ERROR";
            break;
          case 9501:
            result = "BD_GATT_UPDATE_GAP_NAME_ERROR";
            break;
          case 9502:
            result = "BD_TEST_ERROR";
            break;
          case 9503:
            result = "BD_PROFILE_FAILED_TO_STOP_ERROR";
            break;
          case 9504:
            result = "BD_PROFILE_FAILED_TO_DEREGISTER_ERROR";
            break;
          case 9505:
            result = "BD_PROFILE_FAILED_TO_CLEANUP_ERROR";
            break;
          default:
            if (a1 == 5403)
            {
              result = "OI_MAX_BM3_STATUS_VAL";
            }
            else
            {
              if (a1 != 0xFFFF)
                return 0;
              result = "OI_STATUS_NONE";
            }
            break;
        }
        return result;
      }
      if (a1 <= 5101)
      {
        if (a1 == 5100)
          return "BT_CL_SEND_PDU_INVALID_HANDLE";
        else
          return "BT_CL_PEER_REMOVED_SERVICE";
      }
      if (a1 == 5102)
        return "BT_CL_SERVICE_UNREGISTERED_LOCALLY";
      if (a1 == 5300)
        return "BT_LEA_ERROR_STALLED_CONNECTION";
      return 0;
    }
    if (a1 <= 3999)
    {
      if (a1 <= 3601)
      {
        switch(a1)
        {
          case 3570:
            return "BT_AAP_DISCONNECT";
          case 3600:
            return "BT_VSC_SEND_INPROGRESS_ERROR";
          case 3601:
            return "BT_VSC_NOT_IMPLEMENTED_ERROR";
        }
        return 0;
      }
      switch(a1)
      {
        case 3700:
          result = "BD_DEBUG_DUMP";
          break;
        case 3701:
          result = "BT_ASSERT_FAILURE";
          break;
        case 3702:
          return 0;
        case 3703:
          result = "BT_CONTROLLER_CORE_DUMP";
          break;
        case 3704:
          result = "BT_CONTROLLER_CORE_DUMP_INPROGRESS";
          break;
        case 3705:
          result = "BD_ABORT_FAILURE";
          break;
        case 3706:
          result = "BD_COREDUMP_IDLE_TIMEOUT";
          break;
        case 3707:
          result = "BD_COREDUMP_TOO_LONG";
          break;
        case 3708:
          result = "BT_MAC_IN_DARK_SLEEP_MODE";
          break;
        case 3709:
          result = "BT_HCI_CMD_PENDING_BEFORE_DARK_SLEEP";
          break;
        case 3710:
          result = "BT_TRANS_NOT_READY_BEFORE_DARK_WAKE";
          break;
        case 3711:
          result = "BT_MAC_DARK_WAKE_TAKE_TOO_LONG";
          break;
        case 3712:
          result = "BT_FAILED_TO_START_MAC_USER";
          break;
        case 3713:
          result = "BT_FAILED_TO_CREATE_PCIE_ERROR_LISTENER";
          break;
        case 3714:
          result = "BT_FAILED_TO_CREATE_PCIE_TIMESYNC_LISTENER";
          break;
        case 3715:
          result = "BT_STACK_STOP_ERROR";
          break;
        case 3716:
          result = "BT_MISSED_HEART_BEAT_NOTIFICATION";
          break;
        default:
          if (a1 != 3602)
            return 0;
          result = "BT_VSC_STALL_ERROR";
          break;
      }
    }
    else
    {
      if (a1 > 4199)
      {
        switch(a1)
        {
          case 4200:
            return "BT_ATT_CLASSIC_MTU_REQ_ERROR";
          case 4201:
            return "BT_ATT_UNHANDLED_CLIENT_REQ_ERROR";
          case 4202:
            return "BT_ATT_SESSION_NOT_FOUND_ERROR";
        }
        return 0;
      }
      switch(a1)
      {
        case 4000:
          result = "LE_LENGTH_ALREADY_BEST_FIT";
          break;
        case 4001:
          result = "LE_ATT_WRITE_DATA_DROP_ERROR";
          break;
        case 4002:
          result = "LE_ATT_SENDPDU_INVALID_BEARER";
          break;
        case 4003:
          result = "LE_ATT_SENDPDU_INVALID_CONN";
          break;
        case 4004:
          result = "LE_ATT_STATUS_DEFAULT";
          break;
        case 4005:
          result = "LE_ATT_MTU_EXCH_ERROR";
          break;
        case 4006:
          result = "LE_ATT_RSP_FIND_INFO_ERROR";
          break;
        case 4007:
          result = "LE_ATT_RSP_FIND_INFO_UUID_ERROR";
          break;
        case 4008:
          result = "LE_ATT_RSP_READ_BY_TYPE_LEN_ERROR";
          break;
        case 4009:
          result = "LE_ATT_RSP_READ_BY_TYPE_ATRB_LEN_ERROR";
          break;
        case 4010:
          result = "LE_ATT_RSP_READ_BY_GROUP_LEN_ERROR";
          break;
        case 4011:
          result = "LE_ATT_RSP_READ_BY_GROUP_ATTRB_ERROR";
          break;
        case 4012:
          result = "LE_ATT_RSP_PREPARE_WRITE_ERROR";
          break;
        case 4013:
          result = "LE_ATT_INIT_FAIL";
          break;
        case 4014:
          result = "LE_ATT_DB_SET_CB_ERROR";
          break;
        case 4015:
          result = "LE_ATT_DB_UNSET_CB_ERROR";
          break;
        case 4016:
          result = "LE_ATT_REG_ATRB_MAX_HANDLE_ERROR";
          break;
        case 4017:
          result = "LE_ATT_REG_ATRB_INVALID_HANDLE_ERROR";
          break;
        case 4018:
          result = "LE_ATT_SEND_CHAR_VAL_UPDATE_ERROR";
          break;
        case 4019:
          result = "LE_ATT_SEND_CHAR_VAL_UPDATE_ALLOC_ERROR";
          break;
        case 4020:
          result = "LE_ATT_SEND_CHAR_VAL_UPDATE_SESS_ERROR";
          break;
        case 4021:
          result = "LE_ATT_WRITE_UNPACK_ERROR";
          break;
        case 4022:
          result = "LE_ATT_RSP_FIND_BY_TYPE_ERROR";
          break;
        case 4050:
          result = "LE_GAP_CALLBACK_MAX_ERROR";
          break;
        case 4051:
          result = "LE_GAP_GETCONNINT_INVALIDHANDLE";
          break;
        case 4052:
          result = "LE_GAP_GETADDR_INVALIDHANDLE";
          break;
        case 4053:
          result = "LE_GAP_ADDADDR_MAXCB_ERROR";
          break;
        case 4054:
          result = "LE_GAP_ROLE_ALREADY_SET_ERROR";
          break;
        case 4055:
          result = "LE_GAP_SET_DISCOVERABLE_STATE_ERROR";
          break;
        case 4056:
          result = "LE_GAP_PARSE_UUID_ERROR";
          break;
        case 4057:
          result = "LE_GAP_PARSE_ADSERVICE_ERROR";
          break;
        case 4058:
          result = "LE_GAP_PARSE_AD_RSP_ERROR";
          break;
        case 4059:
          result = "LE_GAP_PARSE_AD_RSP_SIZE_ERROR";
          break;
        case 4060:
          result = "LE_GAP_DISCOVERY_ALREADY_SCANNING";
          break;
        case 4061:
          result = "LE_GAP_START_ADVERTISING_ERROR";
          break;
        case 4062:
          result = "LE_GAP_INIT_ADVERTISING_WRONG_ADDR_ERROR";
          break;
        case 4063:
          result = "LE_GAP_DIRECT_CONNECTABLE_ERROR";
          break;
        case 4064:
          result = "LE_GAP_UNDIRECT_CONNECTABLE_ERROR";
          break;
        case 4065:
          result = "LE_GAP_AUTO_CONNECT_ROLE_ERROR";
          break;
        case 4066:
          result = "LE_GAP_AUTO_CONNECT_FILTER_ACCEPT_LIST_ERROR";
          break;
        case 4067:
          result = "LE_GAP_DIRECT_CONNECT_ERROR";
          break;
        case 4068:
          result = "LE_GAP_START_BONDING_ERROR";
          break;
        case 4069:
          result = "LE_GAP_UNKNOWN_RANDOM_ADDR_ERROR";
          break;
        case 4070:
          result = "LE_GAP_GEN_ADDR_ERROR";
          break;
        case 4071:
          result = "LE_GAP_SET_ADDR_ERROR";
          break;
        case 4072:
          result = "LE_GAP_REFRESH_ADDR_ERROR";
          break;
        case 4073:
          result = "LE_GAP_ADDRESS_REFRESH_IN_PROGRESS";
          break;
        case 4074:
          result = "LE_GAP_ADDRESS_REFRESH_TIMEOUT";
          break;
        case 4075:
          result = "LE_GAP_ADVERTISING_STATE_UNSETTLED";
          break;
        case 4100:
          result = "LE_GATT_SESSION_MTU_ERROR";
          break;
        case 4101:
          result = "LE_GATT_EXE_LONGCHARVALUE_RSP_ERROR";
          break;
        case 4102:
          result = "LE_GATT_WRITE_LONGCHARVALUE_RSP_ERROR";
          break;
        case 4103:
          result = "LE_GATT_ADD_CHAR_CB_ERROR";
          break;
        case 4104:
          result = "LE_GATT_ADD_CHAR_PROPERTIES_ERROR";
          break;
        case 4105:
          result = "LE_GATT_DB_REGISTERATION_ERROR";
          break;
        case 4106:
          result = "LE_GATT_DB_REGISTER_ATTRB_ERROR";
          break;
        case 4107:
          result = "LE_GATT_SENDCHAR_UPDATE_UUID_ERROR";
          break;
        case 4108:
          result = "LE_GATT_SENDCHAR_NOTIFY_ERROR";
          break;
        case 4109:
          result = "LE_GATT_SENDCHAR_INDICATE_ERROR";
          break;
        case 4120:
          result = "LE_SIGNALMAN_SEND_REJECTED";
          break;
        case 4121:
          result = "LE_SIGNALMAN_SEND_CONN_UPDATE";
          break;
        case 4122:
          result = "LE_SIGNALMAN_SEND_CHANN_RSP";
          break;
        case 4123:
          result = "LE_SIGNALMAN_SEND_CHANN_REQ";
          break;
        case 4124:
          result = "LE_SIGNALMAN_FLOW_ERROR";
          break;
        case 4125:
          result = "LE_SIGNALMAN_CMD_REJECT_ERROR";
          break;
        case 4126:
          result = "LE_SIGNALMAN_DISC_REQ_ERROR";
          break;
        case 4127:
          result = "LE_SIGNALMAN_DISC_RSP_ERROR";
          break;
        case 4151:
          result = "LE_FILTER_ACCEPT_LIST_ADDRESS_NOT_FOUND_ERROR";
          break;
        case 4152:
          result = "LE_FILTER_ACCEPT_LIST_DUPLICATE_ADDRESS_FOUND_ERROR";
          break;
        case 4170:
          result = "LE_CONNECTION_UPDATE_DUPLICATE";
          break;
        default:
          return 0;
      }
    }
  }
  return result;
}

uint64_t sub_100258988(uint64_t a1)
{
  return (*(__int16 *)(a1 + 4) + 1000 * *(_DWORD *)a1);
}

uint64_t sub_10025899C(int *a1, int *a2)
{
  int v4;
  int v5;
  __int16 v6;
  __int16 v7;
  int v8;
  __int16 v9;
  int v10;
  int v11;
  BOOL v12;
  int v13;
  unsigned int v14;

  v4 = *a2;
  v5 = *a1;
  v6 = *((_WORD *)a2 + 2);
  v7 = *((_WORD *)a1 + 2);
  v8 = *a2 - *a1;
  if (*a2 < *a1)
  {
    sub_100253460();
    v4 = *a2;
    v5 = *a1;
  }
  if (v4 == v5 && *((__int16 *)a2 + 2) < *((__int16 *)a1 + 2))
    sub_100253460();
  v9 = v6 - v7;
  v10 = (__int16)(v6 - v7);
  if (v10 < 0)
    v9 = v6 - v7 + 1000;
  v11 = 10 * v9;
  v13 = v11 + 512;
  v12 = v11 < -512;
  v14 = v11 + 1535;
  if (!v12)
    v14 = v13;
  return (unsigned __int16)(10 * (v8 + (v10 >> 15)) + (v14 >> 10));
}

uint64_t sub_100258A4C(int *a1, int *a2)
{
  int v4;
  int v5;
  __int16 v6;
  __int16 v7;
  int v8;
  __int16 v9;
  int v10;

  v4 = *a2;
  v5 = *a1;
  v6 = *((_WORD *)a2 + 2);
  v7 = *((_WORD *)a1 + 2);
  v8 = *a2 - *a1;
  if (*a2 < *a1)
  {
    sub_100253460();
    v4 = *a2;
    v5 = *a1;
  }
  if (v4 == v5 && *((__int16 *)a2 + 2) < *((__int16 *)a1 + 2))
    sub_100253460();
  v9 = v6 - v7;
  v10 = (__int16)(v6 - v7);
  if (v10 < 0)
    v9 = v6 - v7 + 1000;
  return (1000 * (v8 + (v10 >> 15)) + v9);
}

BOOL sub_100258AE0(uint64_t a1)
{
  uint64_t v3;

  v3 = 0;
  sub_10004AD30((uint64_t)&v3);
  return (sub_100072ACC((uint64_t)&v3, a1) & 0x8000) == 0;
}

uint64_t sub_100258B24(unsigned __int8 *a1, int a2, _WORD *a3, int a4)
{
  _WORD *v4;
  int v5;
  uint64_t result;
  _WORD *v7;
  unsigned __int8 *v8;

  v7 = a3;
  v8 = a1;
  if (a1 && a2 > 0 && a3 && a4 > 0)
  {
    v4 = &a3[a4];
    v5 = sub_1000FF11C(&v8, (unint64_t)&a1[a2], &v7, (unint64_t)v4, 0);
    if (v5)
    {
      return dword_10073CA34[v5];
    }
    else if (v7 >= v4)
    {
      if (v7 == v4)
      {
        if (*(v4 - 1))
          return 3202;
        else
          return 0;
      }
      else
      {
        return 0;
      }
    }
    else
    {
      result = 0;
      *v7 = 0;
    }
  }
  else
  {
    sub_100253460();
    return 101;
  }
  return result;
}

uint64_t sub_100258BD0(unint64_t a1, int a2, _BYTE *a3, int a4)
{
  unint64_t v4;
  int v5;
  uint64_t result;
  _BYTE *v7;
  unint64_t v8;

  v7 = a3;
  v8 = a1;
  if (a1 && a2 > 0 && a3 && a4 > 0)
  {
    v4 = (unint64_t)&a3[a4];
    v5 = sub_1000FEEDC(&v8, a1 + 2 * a2, (uint64_t *)&v7, v4, 0);
    if (v5)
    {
      return dword_10073CA34[v5];
    }
    else if ((unint64_t)v7 >= v4)
    {
      if (v7 == (_BYTE *)v4)
      {
        if (*(_BYTE *)(v4 - 1))
          return 3202;
        else
          return 0;
      }
      else
      {
        return 0;
      }
    }
    else
    {
      result = 0;
      *v7 = 0;
    }
  }
  else
  {
    sub_100253460();
    return 101;
  }
  return result;
}

uint64_t sub_100258C7C(unsigned __int16 *a1)
{
  unsigned __int16 *v1;
  uint64_t result;
  int v3;

  v1 = a1;
  if (!a1)
    sub_100253460();
  LODWORD(result) = -1;
  do
  {
    v3 = *v1++;
    result = (result + 1);
  }
  while (v3);
  return result;
}

uint64_t sub_100258CB0(unsigned __int16 *a1, unsigned __int16 *a2)
{
  unsigned int v4;
  unsigned int v5;
  unsigned __int16 *v6;
  unsigned __int16 *v7;
  unsigned int v8;
  unsigned int v9;

  if (a1)
  {
    if (a2)
      goto LABEL_4;
    goto LABEL_3;
  }
  sub_100253460();
  if (!a2)
LABEL_3:
    sub_100253460();
LABEL_4:
  v4 = *a1;
  v5 = *a2;
  if (v4 < v5)
    return 0xFFFFFFFFLL;
  v6 = a2 + 1;
  v7 = a1 + 1;
  while (1)
  {
    if (v4 > v5)
      return 1;
    if (!v4)
      break;
    v8 = *v7++;
    v4 = v8;
    v9 = *v6++;
    v5 = v9;
    if (v4 < v9)
      return 0xFFFFFFFFLL;
  }
  return 0;
}

uint64_t sub_100258D30(unsigned __int16 *a1, unsigned __int16 *a2, int a3)
{
  unsigned __int16 *v4;
  unsigned __int16 *v5;
  unsigned int v6;
  unsigned int v7;
  BOOL v8;

  v4 = a2;
  v5 = a1;
  if (a1)
  {
    if (a2)
      goto LABEL_3;
  }
  else
  {
    sub_100253460();
    if (v4)
    {
LABEL_3:
      if (a3)
        goto LABEL_4;
      return 0;
    }
  }
  sub_100253460();
  if (!a3)
    return 0;
  while (1)
  {
LABEL_4:
    LOWORD(a3) = a3 - 1;
    v6 = *v5;
    v7 = *v4;
    if (v6 < v7)
      return 0xFFFFFFFFLL;
    if (v6 > v7)
      break;
    ++v5;
    ++v4;
    if (v6)
      v8 = (unsigned __int16)a3 == 0;
    else
      v8 = 1;
    if (v8)
      return 0;
  }
  return 1;
}

_BYTE *sub_100258DC0(_BYTE *result, int *a2)
{
  uint64_t i;
  int v3;
  uint64_t v5;
  uint64_t v6;
  _BYTE *v7;
  int v8;
  _BYTE *v9;
  int v10;
  _BYTE *v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  unsigned int v17;
  int v18;

  if (result && a2)
  {
    for (i = 0; ; ++i)
    {
      v3 = result[i];
      if (v3 != 32 && v3 != 9)
        break;
    }
    v5 = v3 == 45;
    v6 = (uint64_t)(v3 == 45 ? result + 1 : result);
    v7 = (_BYTE *)(v6 + i);
    v8 = *(unsigned __int8 *)(v6 + i);
    if ((v8 - 48) <= 9)
    {
      if (v8 == 48 && (v9 = &result[v5 + i], v9[1] == 120))
      {
        v12 = v9[2];
        v11 = v9 + 2;
        v10 = v12;
        if (v12)
        {
          v13 = 0;
          do
          {
            if ((v10 - 48) >= 0xA)
            {
              if ((v10 - 97) >= 6)
              {
                if ((v10 - 65) > 5)
                  break;
                v14 = -55;
              }
              else
              {
                v14 = -87;
              }
            }
            else
            {
              v14 = -48;
            }
            v13 = v14 + 16 * v13 + v10;
            v10 = result[v5++ + 3 + i];
          }
          while (v10);
          result += i + v5 + 2;
        }
        else
        {
          v13 = 0;
          result = v11;
        }
      }
      else
      {
        v15 = 0;
        do
        {
          v13 = v15;
          result = v7;
          v16 = *v7;
          if (!*v7)
            break;
          v17 = v16 - 48;
          v15 = v16 - 48 + 10 * v13;
          ++v7;
        }
        while (v17 < 0xA);
      }
      if (v3 == 45)
        v18 = -v13;
      else
        v18 = v13;
      *a2 = v18;
    }
  }
  return result;
}

uint64_t sub_100258ED8(unsigned __int8 *a1, unsigned __int8 *a2, int a3)
{
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  int i;
  int v7;
  int v8;
  BOOL v9;

  v4 = a2;
  v5 = a1;
  if (a1)
  {
    if (a2)
      goto LABEL_3;
  }
  else
  {
    sub_100253460();
    if (v4)
    {
LABEL_3:
      if (!a3)
        return 0;
      goto LABEL_7;
    }
  }
  sub_100253460();
  if (!a3)
    return 0;
LABEL_7:
  for (i = a3 - 1; ; --i)
  {
    v7 = *v5;
    if ((v7 - 97) < 0x1A)
      LOBYTE(v7) = v7 - 32;
    v8 = *v4;
    if ((v8 - 97) < 0x1A)
      LOBYTE(v8) = v8 - 32;
    if (v7 < v8)
      return 0xFFFFFFFFLL;
    if (v7 > v8)
      break;
    ++v5;
    ++v4;
    if ((_BYTE)v7)
      v9 = i == 0;
    else
      v9 = 1;
    if (v9)
      return 0;
  }
  return 1;
}

uint64_t sub_100258F90(_BYTE *a1)
{
  unsigned int v2;

  v2 = 0;
  if (sub_100258DC0(a1, (int *)&v2) == a1)
    return 0;
  else
    return v2;
}

uint64_t sub_100258FCC(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v4;
  int v5;
  unsigned __int8 v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  int v9;
  char v10;
  int v11;
  unsigned __int8 v12;

  if (a1)
  {
    if (a2)
      goto LABEL_4;
    goto LABEL_3;
  }
  sub_100253460();
  if (!a2)
LABEL_3:
    sub_100253460();
LABEL_4:
  v4 = *a1;
  if ((v4 - 97) < 0x1A)
    LOBYTE(v4) = v4 - 32;
  v5 = *a2;
  if ((v5 - 97) >= 0x1A)
    v6 = *a2;
  else
    v6 = v5 - 32;
  if (v4 < v6)
    return 0xFFFFFFFFLL;
  v7 = a2 + 1;
  v8 = a1 + 1;
  while (1)
  {
    if (v4 > v6)
      return 1;
    if (!(_BYTE)v4)
      break;
    v9 = *v8++;
    LOBYTE(v4) = v9;
    v10 = v9 - 32;
    if ((v9 - 97) < 0x1A)
      LOBYTE(v4) = v10;
    v11 = *v7++;
    v6 = v11;
    v12 = v11 - 32;
    if ((v11 - 97) < 0x1A)
      v6 = v12;
    if (v4 < v6)
      return 0xFFFFFFFFLL;
  }
  return 0;
}

uint64_t sub_10025909C(uint64_t a1, size_t size)
{
  __int16 v2;
  void *v4;
  __int16 v5;
  uint64_t result;

  v2 = size;
  *(_BYTE *)a1 = 1;
  *(_WORD *)(a1 + 4) = 0;
  v4 = sub_100052DC0(size);
  *(_QWORD *)(a1 + 8) = v4;
  if (v4)
    v5 = v2;
  else
    v5 = 0;
  if (v4)
    result = 0;
  else
    result = 106;
  *(_WORD *)(a1 + 2) = v5;
  return result;
}

void sub_1002590E8(uint64_t a1)
{
  if (!*(_BYTE *)a1)
    sub_100253460();
  sub_100053298(*(void **)(a1 + 8));
  *(_QWORD *)(a1 + 8) = 0;
  *(_WORD *)(a1 + 2) = 0;
}

uint64_t sub_100259120(uint64_t a1, char *a2, int a3)
{
  uint64_t result;
  int v5;
  char *v6;
  char v7;
  unsigned int v8;
  uint64_t v9;

  result = 0;
  if (a2)
  {
    v5 = a3;
    if (a3)
    {
      v6 = a2;
      while (1)
      {
        v7 = *v6;
        if (!*v6)
          return 0;
        if (!*(_WORD *)(a1 + 2)
          || (v8 = *(unsigned __int16 *)(a1 + 4), *(unsigned __int16 *)(a1 + 2) - 1 <= v8))
        {
          if (!*(_BYTE *)a1)
            return 0;
          if (!sub_1002591C0(a1))
            return 106;
          v7 = *v6;
          v8 = *(unsigned __int16 *)(a1 + 4);
        }
        --v5;
        ++v6;
        v9 = *(_QWORD *)(a1 + 8);
        *(_WORD *)(a1 + 4) = v8 + 1;
        *(_BYTE *)(v9 + v8) = v7;
        if (!(_WORD)v5)
          return 0;
      }
    }
  }
  return result;
}

BOOL sub_1002591C0(uint64_t a1)
{
  _BYTE *v2;
  _BYTE *v3;
  unint64_t v4;

  if (!*(_QWORD *)(a1 + 8))
    sub_100253460();
  if (!*(_BYTE *)a1)
    sub_100253460();
  v2 = sub_100052DC0(*(unsigned __int16 *)(a1 + 2) + 32);
  v3 = v2;
  if (v2)
  {
    if (*(_WORD *)(a1 + 4))
    {
      v4 = 0;
      do
      {
        v2[v4] = *(_BYTE *)(*(_QWORD *)(a1 + 8) + v4);
        ++v4;
      }
      while (v4 < *(unsigned __int16 *)(a1 + 4));
    }
    sub_100053298(*(void **)(a1 + 8));
    *(_QWORD *)(a1 + 8) = v3;
    *(_WORD *)(a1 + 2) += 32;
  }
  return v3 != 0;
}

uint64_t sub_100259250(uint64_t a1, _BYTE *a2)
{
  int v2;
  unsigned __int8 *v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;

  if (!a2)
    return 0;
  v2 = *a2;
  if (!*a2)
    return 0;
  v4 = a2 + 1;
  while (*(_WORD *)(a1 + 2) && *(unsigned __int16 *)(a1 + 2) - 1 > *(unsigned __int16 *)(a1 + 4))
  {
LABEL_9:
    if (v2 == 10)
    {
      v5 = a1;
      v6 = "<lf>";
    }
    else
    {
      if (v2 != 13)
      {
        v7 = *(_QWORD *)(a1 + 8);
        v8 = *(unsigned __int16 *)(a1 + 4);
        *(_WORD *)(a1 + 4) = v8 + 1;
        *(_BYTE *)(v7 + v8) = v2;
        goto LABEL_15;
      }
      v5 = a1;
      v6 = "<cr>";
    }
    sub_1000729B4(v5, v6);
LABEL_15:
    v9 = *v4++;
    v2 = v9;
    if (!v9)
      return 0;
  }
  if (!*(_BYTE *)a1)
    return 0;
  if (sub_1002591C0(a1))
  {
    v2 = *(v4 - 1);
    goto LABEL_9;
  }
  return 106;
}

uint64_t sub_100259320(uint64_t a1, _BYTE *a2, int a3)
{
  uint64_t result;
  int v5;
  _BYTE *i;
  int v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;

  result = 0;
  if (a2)
  {
    v5 = a3;
    if (a3)
    {
      for (i = a2; ; ++i)
      {
        if (!*(_WORD *)(a1 + 2) || *(unsigned __int16 *)(a1 + 2) - 1 <= *(unsigned __int16 *)(a1 + 4))
        {
          if (!*(_BYTE *)a1)
            return 0;
          if (!sub_1002591C0(a1))
            return 106;
        }
        v7 = *i;
        if (*i)
        {
          if (v7 == 10)
          {
            v8 = a1;
            v9 = "<lf>";
          }
          else
          {
            if (v7 != 13)
            {
              v10 = *(_QWORD *)(a1 + 8);
              v11 = *(unsigned __int16 *)(a1 + 4);
              *(_WORD *)(a1 + 4) = v11 + 1;
              *(_BYTE *)(v10 + v11) = v7;
              goto LABEL_16;
            }
            v8 = a1;
            v9 = "<cr>";
          }
        }
        else
        {
          v8 = a1;
          v9 = "<null>";
        }
        sub_1000729B4(v8, v9);
LABEL_16:
        if (!(_WORD)--v5)
          return 0;
      }
    }
  }
  return result;
}

uint64_t sub_100259414(uint64_t a1, int a2)
{
  int v2;
  unsigned int v4;
  uint64_t v5;

  if (!a2)
    return 0;
  v2 = a2;
  while (1)
  {
    if (*(_WORD *)(a1 + 2))
    {
      v4 = *(unsigned __int16 *)(a1 + 4);
      if (*(unsigned __int16 *)(a1 + 2) - 1 > v4)
        goto LABEL_8;
    }
    if (!*(_BYTE *)a1)
      return 0;
    if (!sub_1002591C0(a1))
      return 106;
    v4 = *(unsigned __int16 *)(a1 + 4);
LABEL_8:
    --v2;
    v5 = *(_QWORD *)(a1 + 8);
    *(_WORD *)(a1 + 4) = v4 + 1;
    *(_BYTE *)(v5 + v4) = 32;
    if (!(_BYTE)v2)
      return 0;
  }
}

uint64_t sub_1002594A4(uint64_t a1, unsigned int a2)
{
  unsigned int v4;
  char *v5;
  BOOL v6;
  char v7;
  char v8;

  if (a2 == 0x80000000)
    return sub_1000729B4(a1, "-2147483648");
  v4 = a2;
  if ((a2 & 0x80000000) != 0)
  {
    sub_1000729B4(a1, "-");
    v4 = -v4;
  }
  v7 = 0;
  v5 = &v8;
  v8 = 0;
  do
  {
    *--v5 = a0123456789abcd_0[v4 % 0xA];
    v6 = v4 > 9;
    v4 /= 0xAu;
  }
  while (v6);
  return sub_1000729B4(a1, v5);
}

uint64_t sub_1002595A0(uint64_t a1, unint64_t a2)
{
  _BYTE *v3;
  BOOL v4;
  __int16 v6;

  v3 = (char *)&v6 + 1;
  v6 = 0;
  do
  {
    *--v3 = a0123456789abcd_0[a2 % 0xA];
    v4 = a2 > 9;
    a2 /= 0xAuLL;
  }
  while (v4);
  return sub_1000729B4(a1, v3);
}

uint64_t sub_100259630(uint64_t result, unsigned __int16 *a2, int a3)
{
  int v3;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  __int16 v8;
  uint64_t v9;
  unsigned __int16 *v10;

  v10 = a2;
  if (a2)
  {
    v3 = a3;
    v5 = result;
    if ((int)sub_100258C7C(a2) <= a3)
      v3 = sub_100258C7C(a2);
    v6 = (unint64_t)&a2[v3];
    do
    {
      v7 = *(_QWORD *)(v5 + 8);
      v9 = v7 + *(unsigned __int16 *)(v5 + 4);
      v8 = *(_WORD *)(v5 + 2) + v7 - 1;
      result = sub_1000FEEDC((unint64_t *)&v10, v6, &v9, *(unsigned __int16 *)(v5 + 2) + v7 - 1, 0);
      *(_WORD *)(v5 + 4) = ~v8 + *(_WORD *)(v5 + 2) + v9;
      if ((_DWORD)result != 2)
        break;
      if (!*(_BYTE *)v5)
        break;
      result = sub_1002591C0(v5);
    }
    while ((result & 1) != 0);
  }
  return result;
}

uint64_t sub_1002596F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  return sub_1000545AC(a1, a2, &a9);
}

uint64_t sub_10025971C(uint64_t a1)
{
  uint64_t v1;
  unsigned int v3;

  v1 = *(_QWORD *)(a1 + 8);
  if (!v1)
    return 0;
  v3 = *(unsigned __int16 *)(a1 + 4);
  if (v3 >= *(unsigned __int16 *)(a1 + 2))
  {
    sub_100253460();
    v1 = *(_QWORD *)(a1 + 8);
    v3 = *(unsigned __int16 *)(a1 + 4);
  }
  *(_BYTE *)(v1 + v3) = 0;
  return *(_QWORD *)(a1 + 8);
}

const char *sub_10025976C()
{
  return "5.0";
}

const char *sub_100259778()
{
  return "Copyright (c) 2017 Apple Inc. All rights reserved";
}

uint64_t sub_100259784(_QWORD *a1, _WORD *a2)
{
  *a2 = 0;
  *a1 = 0;
  return 102;
}

uint64_t sub_100259794(NSObject *a1, uint64_t (*a2)(_QWORD, _QWORD), uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFDictionary *v10;
  io_service_t MatchingService;
  io_service_t v12;
  IONotificationPortRef v13;
  IONotificationPort *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  uint64_t v25;
  io_object_t notification;

  if (!a1 || !a2)
  {
    v23 = "Invalid parameter\n";
LABEL_10:
    sub_100253320((uint64_t)v23, (uint64_t)a2, a3, a4, a5, a6, a7, a8, v25);
    return 0;
  }
  v10 = IOServiceMatching("AppleBluetoothModule");
  MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v10);
  if (!MatchingService)
  {
    v23 = "Cannot find AppleBluetoothModule service\n";
    goto LABEL_10;
  }
  v12 = MatchingService;
  v13 = IONotificationPortCreate(kIOMainPortDefault);
  if (!v13)
  {
    v23 = "Cannot create notification port\n";
    goto LABEL_10;
  }
  v14 = v13;
  notification = 0;
  dispatch_retain(a1);
  off_100991A10 = a2;
  IONotificationPortSetDispatchQueue(v14, a1);
  v15 = IOServiceAddInterestNotification(v14, v12, "IOGeneralInterest", (IOServiceInterestCallback)sub_1002598A4, 0, &notification);
  if (!(_DWORD)v15)
    return 1;
  sub_100253320((uint64_t)"Could not add interest notification on service: %#x\n", v16, v17, v18, v19, v20, v21, v22, v15);
  IONotificationPortDestroy(v14);
  dispatch_release(a1);
  return 0;
}

uint64_t sub_1002598A4(uint64_t a1, uint64_t a2, int a3, unsigned int *a4)
{
  uint64_t result;

  if (a3 == -469794804 && a4 != 0)
    return off_100991A10(*a4, *((_QWORD *)a4 + 1));
  return result;
}

_QWORD *sub_1002598D0(unsigned __int16 *a1, uint64_t a2)
{
  _QWORD *result;
  uint64_t v5;
  _QWORD *v6;

  result = (_QWORD *)sub_1001DBC18((uint64_t)sub_100259954, *a1, 0, a2, 0);
  if (*(_WORD *)(a2 + 4))
  {
    v5 = *((_QWORD *)a1 + 14);
    v6 = sub_100114588(8uLL);
    sub_100253D90(v6, a2, 0);
    return sub_100251374(v5, (uint64_t)v6, 8);
  }
  return result;
}

void sub_100259954(int a1, void *a2, uint64_t a3, uint64_t a4)
{
  unsigned __int16 *v6;
  _QWORD *v7;

  v6 = sub_100119734(a1);
  sub_10011996C((uint64_t)v6, a2, a4);
  if (sub_100056080(*((_QWORD *)v6 + 14)))
  {
    v7 = (_QWORD *)sub_100251574(*((_QWORD *)v6 + 14), 0);
    sub_1002598D0(v6, *v7);
    sub_100053298(v7);
  }
}

uint64_t sub_1002599CC(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;

  if (sub_100056080(*(_QWORD *)(a1 + 112)))
  {
    v2 = *(_QWORD *)(a1 + 112);
    v3 = *(_QWORD *)(a1 + 40);
    v4 = sub_100114588(8uLL);
    sub_100253D90(v4, v3, 0);
    sub_10025142C(v2, (uint64_t)v4, 8);
    sub_100254090(*(void **)(a1 + 40));
    *(_QWORD *)(a1 + 40) = 0;
  }
  else
  {
    sub_1002598D0((unsigned __int16 *)a1, *(_QWORD *)(a1 + 40));
  }
  return 0;
}

uint64_t sub_100259A4C(uint64_t a1, uint64_t a2, int a3, unsigned __int16 *a4, uint64_t a5, char a6)
{
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  NSObject *v15;
  _QWORD *v16;
  NSObject *v17;
  uint8_t buf[4];
  void *v20;

  sub_1001E3B68(a4);
  v12 = sub_1001E3870(*a4, (uint64_t)sub_100259C50);
  if ((_DWORD)v12)
  {
    v13 = v12;
    if (sub_10005549C())
    {
      sub_100054530("OI_L2CAP_Register failed with result %!", v13);
      v14 = sub_1000544A0(0x18u);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
  }
  else
  {
    if (sub_10005549C())
    {
      sub_100054530("Registered PSM %d", *a4);
      v15 = sub_1000544A0(0x18u);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 136446210;
        v20 = sub_100054494();
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_INFO, " %{public}s", buf, 0xCu);
      }
    }
    v16 = sub_100114588(0xD8uLL);
    v16[18] = a2;
    *((_DWORD *)v16 + 38) = a3;
    *((_WORD *)v16 + 100) = 0;
    *((_DWORD *)v16 + 51) = 0;
    *((_WORD *)v16 + 98) = *a4;
    if (a1)
    {
      v16[17] = *(_QWORD *)(a1 + 8);
      *((_WORD *)v16 + 64) = *(_WORD *)a1;
    }
    v16[23] = a5;
    *((_BYTE *)v16 + 192) = a6;
    v16[8] = 0;
    v16[1] = 0;
    v13 = sub_1001198A8((uint64_t)v16);
    if ((_DWORD)v13)
    {
      if (sub_10005549C())
      {
        sub_100054530("AddConnection failed with result %!", v13);
        v17 = sub_1000544A0(0x18u);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
    }
    else
    {
      ++dword_1009991A8;
    }
  }
  return v13;
}

void sub_100259C50(int a1, int *a2, unsigned int a3)
{
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  void *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;

  v5 = sub_1001197C0(a1);
  if (*(_DWORD *)(v5 + 204))
  {
    if (sub_10005549C())
    {
      sub_100054530("Rejecting the L2CAP connection");
      v6 = sub_1000544A0(0x18u);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    sub_1001DDCAC(0, 0, 0, a3, 0, 0, 0);
  }
  else
  {
    v7 = v5;
    v8 = *(void **)(v5 + 8);
    if (v8)
      sub_100053298(v8);
    *(_QWORD *)(v7 + 112) = 0;
    *(_OWORD *)(v7 + 80) = 0u;
    *(_OWORD *)(v7 + 96) = 0u;
    *(_OWORD *)(v7 + 48) = 0u;
    *(_OWORD *)(v7 + 64) = 0u;
    *(_OWORD *)(v7 + 16) = 0u;
    *(_OWORD *)(v7 + 32) = 0u;
    *(_OWORD *)v7 = 0u;
    v9 = *a2;
    *(_WORD *)(v7 + 108) = *((_WORD *)a2 + 2);
    *(_DWORD *)(v7 + 104) = v9;
    *(_WORD *)v7 = a3;
    *(_DWORD *)(v7 + 4) = 1;
    *(_QWORD *)(v7 + 112) = sub_100251288(0, 0);
    v10 = sub_1001DDCAC((uint64_t)sub_100259E24, (uint64_t)sub_10025A020, (uint64_t)sub_10025A13C, a3, (uint64_t)&unk_10091FC08, 1, *(_QWORD *)(v7 + 184));
    if ((_DWORD)v10)
    {
      v11 = v10;
      if (sub_10005549C())
      {
        sub_100054530("OI_L2CAP_Accept failed with result %!", v11);
        v12 = sub_1000544A0(0x18u);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
    }
    else
    {
      *(_DWORD *)(v7 + 204) = 1;
    }
  }
}

uint64_t sub_100259DC4(int a1)
{
  sub_10011984C(a1);
  return sub_1001E3A38(a1);
}

uint64_t sub_100259DE8(unsigned int a1, _WORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t result;

  v3 = sub_100119938(a1);
  if (!v3)
    return 1709;
  v4 = v3;
  result = 0;
  *a2 = *(_WORD *)(v4 + 196);
  return result;
}

void sub_100259E24(int a1, unsigned int a2, unsigned __int16 a3, uint64_t a4)
{
  unsigned __int16 *v7;
  unsigned __int16 *v8;
  NSObject *v9;
  void *v10;
  void *v11;
  int v12;
  _DWORD *v13;
  NSObject *v14;
  _BOOL4 v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  const void *v20[2];
  uint8_t buf[4];
  void *v22;

  v7 = sub_100119734(a1);
  v8 = v7;
  v20[0] = 0;
  if ((_DWORD)a4)
  {
    if (sub_10005549C())
    {
      sub_100054530("L2CAPConnectCB failed with result %!", a4);
      v9 = sub_1000544A0(0x18u);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_1006CE7A4();
    }
    *((_DWORD *)v8 + 51) = 0;
    v10 = (void *)*((_QWORD *)v8 + 1);
    if (v10)
    {
      sub_100053298(v10);
      *((_QWORD *)v8 + 1) = 0;
    }
  }
  else
  {
    *((_DWORD *)v7 + 51) = 2;
    v7[36] = a3;
    v7[38] = a3;
    v7[37] = a2;
    v11 = sub_100114588(a2);
    v13 = v8 + 88;
    v12 = *((_DWORD *)v8 + 44);
    *((_QWORD *)v8 + 1) = v11;
    if (v12)
    {
      if (sub_10005549C())
      {
        sub_100054530("Cancelling timeout countdown");
        v14 = sub_1000544A0(0x18u);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446210;
          v22 = sub_100054494();
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, " %{public}s", buf, 0xCu);
        }
      }
      sub_100049F6C(*v13);
      *v13 = 0;
    }
    v15 = *((_DWORD *)v8 + 38) != 0;
    v16 = *(unsigned __int16 *)(sub_100252DE8(0x18u) + 2 * v15);
    v20[1] = v8 + 104;
    LOWORD(v20[0]) = 2;
    v17 = sub_10004A9EC((uint64_t)sub_10025A168, v20, v16, (int *)v8 + 44);
    if ((_DWORD)v17)
    {
      v18 = v17;
      if (sub_10005549C())
      {
        sub_100054530("OI_Dispatch_RegisterTimedFunc failed with result %!", v18);
        v19 = sub_1000544A0(0x18u);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          sub_1006CE7A4();
      }
    }
  }
}

void sub_10025A020(unsigned int a1, uint64_t a2)
{
  unsigned __int16 *v4;
  uint64_t v5;
  NSObject *v6;
  _BYTE buf[24];

  v4 = sub_100119734(a1);
  if (v4)
  {
    v5 = (uint64_t)v4;
    sub_1002512C0(*((_QWORD **)v4 + 14));
    *(_QWORD *)buf = 0;
    if (!sub_1001DB044(a1, (uint64_t *)buf))
      sub_1001DC658(*(uint64_t *)buf);
    sub_10011AB40(v5);
  }
  else if (sub_10005549C())
  {
    sub_100054530("IGNORING L2CAPDisconnectCB as connection was NULL (cid = %d, reason = %!)", a1, a2);
    v6 = sub_1000544A0(0x18u);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, " %{public}s", buf, 0xCu);
    }
  }
}

void sub_10025A13C(int a1, void *a2, size_t a3)
{
  unsigned __int16 *v5;

  v5 = sub_100119734(a1);
  sub_10011AC0C((uint64_t)v5, a2, a3);
}

uint64_t sub_10025A168(uint64_t a1)
{
  unsigned int v1;
  uint64_t v2;

  v1 = **(unsigned __int16 **)(a1 + 8);
  v2 = sub_100119938(v1);
  if (*(_DWORD *)(v2 + 204) == 5)
    sub_100253460();
  *(_DWORD *)(v2 + 176) = 0;
  return sub_10011BAB0(v1);
}

_QWORD *sub_10025A1AC(uint64_t a1)
{
  NSObject *v2;
  _QWORD *result;
  int v4;
  void *v5;

  if (sub_10005549C())
  {
    sub_100054530("HandsfreeAoS_Register");
    v2 = sub_1000544A0(0x5Au);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136446210;
      v5 = sub_100054494();
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, " %{public}s", (uint8_t *)&v4, 0xCu);
    }
  }
  result = malloc_type_calloc(1uLL, 0x88uLL, 0xA004050197E0BuLL);
  qword_100991A18 = (uint64_t)result;
  result[16] = a1;
  return result;
}

