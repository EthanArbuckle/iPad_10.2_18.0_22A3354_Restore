void sub_10066617C(uint64_t a1)
{
  uint64_t v2;
  unsigned __int16 v3;
  NSObject *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  int v10;
  _DWORD v11[2];
  __int16 v12;
  uint64_t v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  unsigned int v17;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = 60 * arc4random_uniform(0xCu) + 720;
  *(_WORD *)(v2 + 372) = v3;
  v4 = qword_100999810;
  if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
  {
    v5 = *(_DWORD *)(a1 + 56);
    v6 = *(_QWORD *)(a1 + 40);
    v7 = *(_QWORD *)(a1 + 48);
    v11[0] = 67109888;
    v11[1] = v5;
    v12 = 2048;
    v13 = v6;
    v14 = 2048;
    v15 = v7;
    v16 = 1024;
    v17 = v3 / 0x3Cu;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "[BTGlobalTCCNames] LeDeviceManager::leScanComplete result:%d totalRXTimeMS:%llu BtMCRxTimeMS%llu nextScan in %d hours", (uint8_t *)v11, 0x22u);
  }
  if (qword_100977B50 != -1)
    dispatch_once(&qword_100977B50, &stru_10093E8B0);
  v8 = qword_100977B48;
  v9 = sub_100022AE4(*(_QWORD *)(v2 + 352));
  v10 = sub_10000B174(v8, v9);
  *(_QWORD *)(v2 + 352) = 0;
  if (v10)
  {
    if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_ERROR))
      sub_100715C00();
  }
}

void sub_1006662F4(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  sub_1006660F4(a1 - 64, a2, a3, a4, a5);
}

uint64_t sub_1006662FC(uint64_t a1)
{
  double v2;
  int v3;
  NSObject *v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  _DWORD v11[2];
  __int16 v12;
  int v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;

  if (qword_100977B40 != -1)
    dispatch_once(&qword_100977B40, &stru_10093E910);
  v2 = *((double *)off_100977B38 + 62);
  if (v2 == 0.0)
    v3 = 9999;
  else
    v3 = (int)((CFAbsoluteTimeGetCurrent() - v2) / 60.0);
  v4 = qword_100999810;
  if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
  {
    v5 = *(unsigned __int8 *)(a1 + 375);
    v6 = *(unsigned __int8 *)(a1 + 321);
    v7 = *(unsigned __int8 *)(a1 + 376);
    v8 = *(unsigned __int8 *)(a1 + 377);
    v9 = *(_DWORD *)(a1 + 368);
    v11[0] = 67110400;
    v11[1] = v5;
    v12 = 1024;
    v13 = v6;
    v14 = 1024;
    v15 = v7;
    v16 = 1024;
    v17 = v8;
    v18 = 1024;
    v19 = v9;
    v20 = 1024;
    v21 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "[BTGlobalTCCNames] LeDeviceManager::checkForBTTCCNamesCache fScreenState:%d fStackStarted:%d fDeviceFirstUnlocked:%d fDeviceLocked:%d fNameSearchActiveScanCounter:%d LastActiveScanTime:%d minutes ago", (uint8_t *)v11, 0x26u);
  }
  return 0;
}

uint64_t sub_10066644C(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  int v4;
  int v5;
  uint64_t v7;
  void *__p[2];
  char v9;
  unint64_t v10;

  v2 = qword_100999810;
  if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(__p[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "[BTGlobalTCCNames] LeDeviceManager::startNameScan", (uint8_t *)__p, 2u);
  }
  if (*(_QWORD *)(a1 + 352))
  {
    if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_ERROR))
      sub_100715CD4();
    return 12;
  }
  v10 = 0;
  if (qword_100977B50 != -1)
    dispatch_once(&qword_100977B50, &stru_10093E8B0);
  v3 = qword_100977B48;
  sub_100091AE8(__p, (char *)objc_msgSend(*(id *)(a1 + 360), "UTF8String"));
  v4 = sub_10000A378(v3, (uint64_t)__p);
  v5 = v4;
  if (v9 < 0)
  {
    operator delete(__p[0]);
    if (v5)
    {
LABEL_10:
      if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_ERROR))
        sub_100715CA8();
      return 12;
    }
  }
  else if (v4)
  {
    goto LABEL_10;
  }
  if (qword_100977B50 != -1)
    dispatch_once(&qword_100977B50, &stru_10093E8B0);
  v7 = sub_1000229D8((_QWORD *)qword_100977B48, v10);
  *(_QWORD *)(a1 + 352) = v7;
  if (!v7)
  {
    if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_ERROR))
      sub_100715C7C();
    return 12;
  }
  if (*(_BYTE *)(a1 + 321))
    operator new();
  return 0;
}

void sub_10066669C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  operator delete();
}

uint64_t sub_1006666D8(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint8_t v7[16];

  v2 = qword_100999810;
  if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v7 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "[BTGlobalTCCNames] LeDeviceManager::stopNameScan", v7, 2u);
  }
  if (*(_QWORD *)(a1 + 352))
  {
    if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_ERROR))
      sub_100715CD4();
    return 12;
  }
  else
  {
    if (*(_BYTE *)(a1 + 321))
    {
      if (qword_100977FB0 != -1)
        dispatch_once(&qword_100977FB0, &stru_10093E930);
      if (sub_100012EF4((uint64_t)off_100977FA8, *(_QWORD *)(a1 + 352), 1, 1, 0)
        && os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_ERROR))
      {
        sub_100715D9C();
      }
    }
    if (qword_100977B50 != -1)
      dispatch_once(&qword_100977B50, &stru_10093E8B0);
    v4 = qword_100977B48;
    v5 = sub_100022AE4(*(_QWORD *)(a1 + 352));
    v3 = sub_10000B174(v4, v5);
    if ((_DWORD)v3 && os_log_type_enabled((os_log_t)qword_100999928, OS_LOG_TYPE_ERROR))
      sub_100715D38();
    *(_QWORD *)(a1 + 352) = 0;
  }
  return v3;
}

void sub_100666874(uint64_t a1, void *a2, char a3)
{
  id v5;
  _QWORD *v6;
  _QWORD v7[2];

  v5 = a2;
  v7[0] = 0;
  v7[1] = 0;
  sub_10003415C((uint64_t)v7, a1 + 88);
  v6 = sub_1000306B0(a1, v5);
  if (v6)
    sub_100666900((uint64_t)v6, a3);
  sub_100034234((uint64_t)v7);

}

void sub_1006668E0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

char *sub_100666900(uint64_t a1, char a2)
{
  char *result;
  uint64_t v4;
  char v5;

  v5 = a2;
  result = sub_100669758((_QWORD *)(a1 + 584), *(char **)(a1 + 584), &v5);
  v4 = *(_QWORD *)(a1 + 592);
  if ((unint64_t)(v4 - *(_QWORD *)(a1 + 584)) >= 6)
    *(_QWORD *)(a1 + 592) = v4 - 1;
  return result;
}

void sub_100666954(uint64_t a1, void *a2, char a3)
{
  id v5;
  _QWORD *v6;
  _QWORD v7[2];

  v5 = a2;
  v7[0] = 0;
  v7[1] = 0;
  sub_10003415C((uint64_t)v7, a1 + 88);
  v6 = sub_1000306B0(a1, v5);
  if (v6)
    *((_BYTE *)v6 + 608) = a3;
  sub_100034234((uint64_t)v7);

}

void sub_1006669BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v9;

  sub_100034234((uint64_t)&a9);

  _Unwind_Resume(a1);
}

uint64_t sub_1006669DC(uint64_t a1, void *a2)
{
  id v3;
  _QWORD *v4;
  char *v5;
  uint64_t v6;
  char *v7;
  __int128 v8;
  char *v9;
  char *v10;
  char *v11;
  __int128 v12;
  char *v13;
  uint64_t v14;
  char *v15;
  __int128 v16;
  char *v17;
  char *v18;
  char *v19;
  __int128 v20;
  NSObject *v21;
  uint64_t v22;
  unint64_t v24;
  unint64_t v25;
  NSObject *v26;
  _BOOL4 v27;
  uint64_t v28;
  _BOOL4 v29;
  _BOOL4 v30;
  _BOOL4 v32;
  NSObject *v33;
  NSObject *v34;
  NSObject *v35;
  _BOOL4 v36;
  uint64_t v37;
  _BOOL4 v38;
  _BOOL4 v39;
  _BOOL4 v40;
  int v41;
  unint64_t v42;
  NSObject *v43;
  id v44;
  void *v45;
  id v46;
  id v47;
  uint64_t v48;
  uint64_t v49;
  void *v50;
  id v51;
  NSObject *v52;
  void *v53;
  NSObject *v54;
  id v55;
  id v56;
  int v57;
  int v58;
  char v59;
  NSObject *v60;
  NSObject *v61;
  uint64_t v62;
  __int128 *v63;
  unsigned __int8 *v64;
  char *v65;
  unsigned __int8 *v66;
  uint64_t v67;
  __int128 *v68;
  unsigned __int8 *v69;
  char *v70;
  unsigned __int8 *v71;
  uint64_t v72;
  __int128 *v73;
  unsigned __int8 *v74;
  char *v75;
  unsigned __int8 *v76;
  uint64_t v77;
  id v78;
  BOOL v79;
  id v80;
  id v81;
  BOOL v82;
  id v83;
  id v84;
  BOOL v85;
  id v86;
  id v87;
  BOOL v88;
  id v89;
  id v90;
  BOOL v91;
  id v92;
  uint64_t v93;
  __int128 *v94;
  unsigned __int8 *v95;
  char *v96;
  unsigned __int8 *v97;
  uint64_t v98;
  __int128 *v99;
  unsigned __int8 *v100;
  char *v101;
  unsigned __int8 *v102;
  uint64_t v103;
  __int128 *v104;
  unsigned __int8 *v105;
  char *v106;
  unsigned __int8 *v107;
  unint64_t v108;
  char *v109;
  char *v110;
  uint64_t v111;
  char *v112;
  char *v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  unsigned int v117;
  void *v118;
  void **v119;
  size_t v120;
  int v121;
  void **v122;
  size_t v123;
  int v124;
  int v125;
  __int128 *v126;
  size_t v127;
  int v128;
  CC_LONG v129;
  NSObject *v130;
  char *v131;
  __int128 *v132;
  void **v133;
  void **v134;
  __int128 *v135;
  _OWORD *v136;
  char *v137;
  _OWORD *v138;
  uint64_t v139;
  NSObject *v140;
  uint64_t v141;
  int v142;
  void *v143;
  void *v144;
  uint64_t v145;
  NSObject *v146;
  uint64_t v147;
  int v148;
  NSObject *v149;
  char v150;
  void *v151;
  id v152;
  void *v153;
  void *v154[2];
  char v155;
  _BYTE v156[14];
  char v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  __int128 v161;
  void *v162;
  char *v163;
  char *v164;
  void *__p;
  char *v166;
  char *v167;
  unsigned __int8 __dst[8];
  _QWORD v169[2];
  _BYTE buf[26];
  __int128 *p_data;
  __int16 v172;
  __int128 *v173;
  __int16 v174;
  int v175;
  __int16 v176;
  int v177;
  __int16 v178;
  int v179;
  __int16 v180;
  int v181;
  __int16 v182;
  __int128 *v183;
  __int16 v184;
  int v185;
  __int16 v186;
  char *v187;
  __int16 v188;
  int v189;
  __int16 v190;
  int v191;
  __int16 v192;
  int v193;
  __int16 v194;
  int v195;
  __int16 v196;
  int v197;
  __int16 v198;
  int v199;
  __int16 v200;
  int v201;
  __int16 v202;
  int v203;
  __int16 v204;
  int v205;
  __int16 v206;
  int v207;
  __int16 v208;
  int v209;
  __int16 v210;
  int v211;
  __int16 v212;
  int v213;
  __int16 v214;
  int v215;
  __int16 v216;
  int v217;
  __int16 v218;
  int v219;
  __int16 v220;
  int v221;
  __int16 v222;
  int v223;
  __int16 v224;
  int v225;
  __int16 v226;
  int v227;
  __int16 v228;
  int v229;
  __int16 v230;
  int v231;
  __int16 v232;
  void **v233;
  __int16 v234;
  char *v235;
  __int16 v236;
  void **v237;
  __int16 v238;
  __int128 *v239;
  __int16 v240;
  _OWORD *v241;
  __int16 v242;
  char *v243;
  __int16 v244;
  _OWORD *v245;
  __int16 v246;
  int v247;
  _BYTE v248[128];
  __int128 v249;
  int v250;
  __int128 v251;
  int v252;
  __int128 data;
  __int128 v254;
  __int128 v255;
  __int128 v256;
  __int128 v257;
  void *v258[6];
  __int128 v259;
  __int128 v260;
  __int128 v261;
  _OWORD v262[3];
  _OWORD v263[4];
  __int128 v264;
  __int128 v265;

  v3 = a2;
  v169[0] = 0;
  v169[1] = 0;
  sub_10003415C((uint64_t)v169, a1 + 88);
  v4 = sub_1000306B0(a1, v3);
  v264 = 0u;
  v265 = 0u;
  memset(v263, 0, sizeof(v263));
  v261 = 0u;
  memset(v262, 0, sizeof(v262));
  v259 = 0u;
  v260 = 0u;
  v257 = 0u;
  memset(v258, 0, sizeof(v258));
  v255 = 0u;
  v256 = 0u;
  data = 0u;
  v254 = 0u;
  *(_DWORD *)&__dst[3] = 0;
  *(_DWORD *)__dst = 0;
  __p = 0;
  v166 = 0;
  v167 = 0;
  v251 = xmmword_10073B4A4;
  v252 = 0;
  sub_100042F44((__n128 *)buf, (__n128 *)&v251);
  v5 = (char *)sub_1000B58EC((uint64_t)&v167, 1uLL);
  v7 = &v5[20 * v6];
  v8 = *(_OWORD *)buf;
  *((_DWORD *)v5 + 4) = *(_DWORD *)&buf[16];
  *(_OWORD *)v5 = v8;
  v9 = v5 + 20;
  v11 = (char *)__p;
  v10 = v166;
  if (v166 != __p)
  {
    do
    {
      v12 = *(_OWORD *)(v10 - 20);
      *((_DWORD *)v5 - 1) = *((_DWORD *)v10 - 1);
      *(_OWORD *)(v5 - 20) = v12;
      v5 -= 20;
      v10 -= 20;
    }
    while (v10 != v11);
    v10 = (char *)__p;
  }
  __p = v5;
  v166 = v9;
  v167 = v7;
  if (v10)
    operator delete(v10);
  v166 = v9;
  v162 = 0;
  v163 = 0;
  v164 = 0;
  v249 = xmmword_10073B4B8;
  v250 = 0;
  sub_100042F44((__n128 *)buf, (__n128 *)&v249);
  v13 = (char *)sub_1000B58EC((uint64_t)&v164, 1uLL);
  v15 = &v13[20 * v14];
  v16 = *(_OWORD *)buf;
  *((_DWORD *)v13 + 4) = *(_DWORD *)&buf[16];
  *(_OWORD *)v13 = v16;
  v17 = v13 + 20;
  v19 = (char *)v162;
  v18 = v163;
  if (v163 != v162)
  {
    do
    {
      v20 = *(_OWORD *)(v18 - 20);
      *((_DWORD *)v13 - 1) = *((_DWORD *)v18 - 1);
      *(_OWORD *)(v13 - 20) = v20;
      v13 -= 20;
      v18 -= 20;
    }
    while (v18 != v19);
    v18 = (char *)v162;
  }
  v162 = v13;
  v163 = v17;
  v164 = v15;
  if (v18)
    operator delete(v18);
  v163 = v17;
  if (*((_BYTE *)v4 + 357))
  {
    v21 = qword_100999810;
    if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Identification - metric has already been updated", buf, 2u);
    }
    v22 = 3;
    goto LABEL_15;
  }
  if (qword_1009778F8 != -1)
    dispatch_once(&qword_1009778F8, &stru_10093E9B0);
  if (sub_1005E0AD8(qword_1009778F0, v3, (__int128 **)&__p, 1, 0, 0))
  {
    BYTE3(data) = 1;
  }
  else
  {
    if (qword_1009778F8 != -1)
      dispatch_once(&qword_1009778F8, &stru_10093E9B0);
    if (!sub_1005E0AD8(qword_1009778F0, v3, (__int128 **)&v162, 1, 0, 0))
    {
      v34 = qword_100999810;
      if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "Identification - le metric only send for HIDs and GHSS, returning", buf, 2u);
      }
      v22 = 1;
      goto LABEL_15;
    }
    BYTE8(v265) = 1;
  }
  if (*((_BYTE *)v4 + 359))
  {
    v24 = v4[3];
    if (v24)
    {
      v25 = sub_100225368(v24);
      *(_DWORD *)v156 = v25;
      *(_WORD *)&v156[4] = WORD2(v25);
      LOWORD(data) = v25;
      BYTE2(data) = BYTE2(v25);
      v26 = qword_100999810;
      if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 68289538;
        *(_DWORD *)&buf[4] = 6;
        *(_WORD *)&buf[8] = 2098;
        *(_QWORD *)&buf[10] = v156;
        *(_WORD *)&buf[18] = 1042;
        *(_DWORD *)&buf[20] = 3;
        *(_WORD *)&buf[24] = 2098;
        p_data = &data;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Identification - device has resolved address %{public}.6P and OUI %{public}.3P", buf, 0x22u);
        v26 = qword_100999810;
      }
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        v27 = BYTE6(v24) == 1;
        v28 = (v24 >> 40) & 0xC0;
        if (v28)
          v29 = 0;
        else
          v29 = BYTE6(v24) == 1;
        v30 = v28 == 64 && BYTE6(v24) == 1;
        if (v28 != 192)
          v27 = 0;
        if (BYTE6(v24))
          v32 = BYTE6(v24) == 1 && v28 != 128;
        else
          v32 = 1;
        *(_DWORD *)buf = 67110144;
        *(_DWORD *)&buf[4] = BYTE6(v24) == 0;
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = v30;
        *(_WORD *)&buf[14] = 1024;
        *(_DWORD *)&buf[16] = v27;
        *(_WORD *)&buf[20] = 1024;
        *(_DWORD *)&buf[22] = v29;
        LOWORD(p_data) = 1024;
        *(_DWORD *)((char *)&p_data + 2) = v32;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Identification - le device has address type %d, %d, %d, %d, %d", buf, 0x20u);
      }
      LOWORD(data) = -1;
      BYTE2(data) = -1;
    }
    else
    {
      v24 = v4[2];
      if (BYTE6(v24))
      {
        v35 = qword_100999810;
        if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
        {
          v36 = BYTE6(v24) == 1;
          v37 = (v24 >> 40) & 0xC0;
          if (v37)
            v38 = 0;
          else
            v38 = BYTE6(v24) == 1;
          *(_DWORD *)buf = 67110144;
          *(_DWORD *)&buf[4] = 0;
          v39 = v37 == 64 && BYTE6(v24) == 1;
          *(_WORD *)&buf[8] = 1024;
          *(_DWORD *)&buf[10] = v39;
          v40 = v37 == 192 && BYTE6(v24) == 1;
          *(_WORD *)&buf[14] = 1024;
          *(_DWORD *)&buf[16] = v40;
          if (v37 == 128)
            v36 = 0;
          *(_WORD *)&buf[20] = 1024;
          *(_DWORD *)&buf[22] = v38;
          LOWORD(p_data) = 1024;
          *(_DWORD *)((char *)&p_data + 2) = v36;
          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "Identification - le device has address type %d, %d, %d, %d, %d, can not generate metric", buf, 0x20u);
        }
        memset(buf, 0, 24);
        if (qword_1009778C8 != -1)
          dispatch_once(&qword_1009778C8, &stru_10093E890);
        sub_10000602C((uint64_t)off_1009778C0, v3, (uint64_t)buf);
        v41 = std::string::compare((const std::string *)buf, "Arc Touch BT Mouse");
        if (v41)
        {
          *((_BYTE *)v4 + 368) = 0;
        }
        else
        {
          v149 = qword_100999810;
          if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)v156 = 0;
            _os_log_impl((void *)&_mh_execute_header, v149, OS_LOG_TYPE_DEFAULT, "HIDIdentification - WAR for Arc Touch BT Mouse Identification", v156, 2u);
          }
          LOWORD(data) = -1;
          BYTE2(data) = -1;
        }
        if ((buf[23] & 0x80000000) != 0)
          operator delete(*(void **)buf);
        if (v41)
        {
          v22 = 2;
          goto LABEL_15;
        }
      }
      else
      {
        v42 = sub_100225368(v24);
        *(_DWORD *)v156 = v42;
        *(_WORD *)&v156[4] = WORD2(v42);
        LOWORD(data) = v42;
        BYTE2(data) = BYTE2(v42);
        v43 = qword_100999810;
        if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 68289538;
          *(_DWORD *)&buf[4] = 6;
          *(_WORD *)&buf[8] = 2098;
          *(_QWORD *)&buf[10] = v156;
          *(_WORD *)&buf[18] = 1042;
          *(_DWORD *)&buf[20] = 3;
          *(_WORD *)&buf[24] = 2098;
          p_data = &data;
          _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "Identification - device has public address %{public}.6P and OUI %{public}.3P", buf, 0x22u);
        }
      }
    }
    if (qword_100978170 != -1)
      dispatch_once(&qword_100978170, &stru_10093E850);
    v153 = v3;
    v44 = sub_1002E11E8((uint64_t)off_100978168, v3);
    v45 = (void *)objc_claimAutoreleasedReturnValue(v44);
    v160 = 0u;
    v161 = 0u;
    v158 = 0u;
    v159 = 0u;
    v46 = v45;
    v47 = objc_msgSend(v46, "countByEnumeratingWithState:objects:count:", &v158, v248, 16);
    if (v47)
    {
      v48 = *(_QWORD *)v159;
LABEL_81:
      v49 = 0;
      while (1)
      {
        if (*(_QWORD *)v159 != v48)
          objc_enumerationMutation(v46);
        v50 = *(void **)(*((_QWORD *)&v158 + 1) + 8 * v49);
        if ((objc_msgSend(v50, "isEqualToString:", CFSTR("com.apple.BTLEServer")) & 1) == 0
          && (objc_msgSend(v50, "isEqualToString:", CFSTR("com.apple.Preferences")) & 1) == 0)
        {
          break;
        }
        if (v47 == (id)++v49)
        {
          v47 = objc_msgSend(v46, "countByEnumeratingWithState:objects:count:", &v158, v248, 16);
          if (v47)
            goto LABEL_81;
          goto LABEL_88;
        }
      }
      v51 = v50;

      if (!v51)
        goto LABEL_95;
      v52 = qword_100999810;
      if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138543618;
        *(_QWORD *)&buf[4] = v51;
        *(_WORD *)&buf[12] = 2114;
        *(_QWORD *)&buf[14] = v3;
        _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "%{public}@ bundleid found for uuid %{public}@", buf, 0x16u);
      }
      v152 = objc_retainAutorelease(v51);
      sub_100091AE8(buf, (char *)objc_msgSend(v152, "UTF8String"));
      v53 = v3;
      if (SHIBYTE(v258[2]) < 0)
        operator delete(v258[0]);
      *(_OWORD *)v258 = *(_OWORD *)buf;
      v258[2] = *(void **)&buf[16];
    }
    else
    {
LABEL_88:

LABEL_95:
      v54 = qword_100999810;
      v53 = v3;
      if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138543362;
        *(_QWORD *)&buf[4] = v3;
        _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "No bundleid found for uuid %{public}@", buf, 0xCu);
      }
      v152 = 0;
    }
    v55 = (id)v4[42];
    v151 = v55;
    if (v55)
    {
      v56 = objc_retainAutorelease(v55);
      memcpy(__dst, objc_msgSend(v56, "bytes"), (size_t)objc_msgSend(v56, "length"));
      v57 = __dst[0];
      v58 = *(unsigned __int16 *)&__dst[1];
      DWORD2(v255) = __dst[0];
      HIDWORD(v255) = *(unsigned __int16 *)&__dst[1];
      LODWORD(v256) = *(unsigned __int16 *)&__dst[3];
      DWORD1(v256) = *(unsigned __int16 *)&__dst[5];
      v53 = v153;
    }
    else
    {
      v57 = DWORD2(v255);
      v58 = HIDWORD(v255);
    }
    if (v57 == 2 && v58 == 1452 || (v59 = 0, v57 == 1) && v58 == 76)
    {
      v60 = qword_100999810;
      if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "Overriding LE OUI for apple devices", buf, 2u);
        v57 = DWORD2(v255);
        v58 = HIDWORD(v255);
      }
      LOWORD(data) = 2560;
      BYTE2(data) = 39;
      v59 = 1;
    }
    if (v57 == 2 && v58 == 1118)
    {
      v61 = qword_100999810;
      if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "Overriding LE OUI for MSFT devices", buf, 2u);
      }
      LOWORD(data) = 7664;
      BYTE2(data) = -68;
    }
    if (qword_1009778C8 != -1)
      dispatch_once(&qword_1009778C8, &stru_10093E890);
    sub_10000602C((uint64_t)off_1009778C0, v53, (uint64_t)buf);
    if (SBYTE7(v265) < 0)
      operator delete((void *)v264);
    *(_QWORD *)&v265 = *(_QWORD *)&buf[16];
    v264 = *(_OWORD *)buf;
    v62 = buf[23];
    if (buf[23] >= 0)
      v63 = &v264;
    else
      v63 = (__int128 *)v264;
    if (buf[23] < 0)
      v62 = *((_QWORD *)&v264 + 1);
    buf[0] = 13;
    v64 = sub_10044CC00(v63, (unsigned __int8 *)v63 + v62, buf);
    v65 = (char *)&v264 + BYTE7(v265);
    if ((SBYTE7(v265) & 0x80u) == 0)
    {
      v66 = (unsigned __int8 *)&v264;
    }
    else
    {
      v65 = (char *)(v264 + *((_QWORD *)&v264 + 1));
      v66 = (unsigned __int8 *)v264;
    }
    std::string::erase((std::string *)&v264, v64 - v66, v65 - (char *)v64);
    v67 = BYTE7(v265);
    if ((SBYTE7(v265) & 0x80u) == 0)
      v68 = &v264;
    else
      v68 = (__int128 *)v264;
    if (SBYTE7(v265) < 0)
      v67 = *((_QWORD *)&v264 + 1);
    buf[0] = 10;
    v69 = sub_10044CC00(v68, (unsigned __int8 *)v68 + v67, buf);
    v70 = (char *)&v264 + BYTE7(v265);
    if ((SBYTE7(v265) & 0x80u) == 0)
    {
      v71 = (unsigned __int8 *)&v264;
    }
    else
    {
      v70 = (char *)(v264 + *((_QWORD *)&v264 + 1));
      v71 = (unsigned __int8 *)v264;
    }
    std::string::erase((std::string *)&v264, v69 - v71, v70 - (char *)v69);
    v72 = BYTE7(v265);
    if ((SBYTE7(v265) & 0x80u) == 0)
      v73 = &v264;
    else
      v73 = (__int128 *)v264;
    if (SBYTE7(v265) < 0)
      v72 = *((_QWORD *)&v264 + 1);
    buf[0] = 44;
    v74 = sub_10044CC00(v73, (unsigned __int8 *)v73 + v72, buf);
    v75 = (char *)&v264 + BYTE7(v265);
    if ((SBYTE7(v265) & 0x80u) == 0)
    {
      v76 = (unsigned __int8 *)&v264;
    }
    else
    {
      v75 = (char *)(v264 + *((_QWORD *)&v264 + 1));
      v76 = (unsigned __int8 *)v264;
    }
    std::string::erase((std::string *)&v264, v74 - v76, v75 - (char *)v74);
    v157 = 0;
    sub_100043758(&v157);
    v150 = v59;
    *(_DWORD *)&v156[3] = 0;
    *(_DWORD *)v156 = 0;
    v77 = sub_1000746A4(v24);
    *(_DWORD *)v156 = v77;
    v156[6] = BYTE6(v77);
    *(_WORD *)&v156[4] = WORD2(v77);
    if (sub_1001828C0(v156, (_WORD *)&data + 2, (_BYTE *)&data + 8, (_WORD *)&data + 3)
      && os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_ERROR))
    {
      sub_100715E5C();
    }
    if (sub_100182870(v156, &v257) && os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_ERROR))
      sub_100715DFC();
    sub_10004339C(&v157);
    v78 = (id)v4[34];
    v79 = v78 == 0;

    if (!v79)
    {
      v80 = objc_retainAutorelease((id)v4[34]);
      sub_100091AE8(buf, (char *)objc_msgSend(v80, "UTF8String"));
      if (SHIBYTE(v258[5]) < 0)
        operator delete(v258[3]);
      *(_OWORD *)&v258[3] = *(_OWORD *)buf;
      v258[5] = *(void **)&buf[16];
      buf[23] = 0;
      buf[0] = 0;

    }
    v81 = (id)v4[35];
    v82 = v81 == 0;

    if (!v82)
    {
      v83 = objc_retainAutorelease((id)v4[35]);
      sub_100091AE8(buf, (char *)objc_msgSend(v83, "UTF8String"));
      if (SBYTE7(v260) < 0)
        operator delete((void *)v259);
      v259 = *(_OWORD *)buf;
      *(_QWORD *)&v260 = *(_QWORD *)&buf[16];
      buf[23] = 0;
      buf[0] = 0;

    }
    v84 = (id)v4[37];
    v85 = v84 == 0;

    if (!v85)
    {
      v86 = objc_retainAutorelease((id)v4[37]);
      sub_100091AE8(buf, (char *)objc_msgSend(v86, "UTF8String"));
      if (SBYTE7(v262[1]) < 0)
        operator delete(*(void **)&v262[0]);
      v262[0] = *(_OWORD *)buf;
      *(_QWORD *)&v262[1] = *(_QWORD *)&buf[16];
      buf[23] = 0;
      buf[0] = 0;

    }
    v87 = (id)v4[38];
    v88 = v87 == 0;

    if (!v88)
    {
      v89 = objc_retainAutorelease((id)v4[38]);
      sub_100091AE8(buf, (char *)objc_msgSend(v89, "UTF8String"));
      if (SHIBYTE(v262[2]) < 0)
        operator delete(*((void **)&v262[1] + 1));
      *(_OWORD *)((char *)&v262[1] + 8) = *(_OWORD *)buf;
      *((_QWORD *)&v262[2] + 1) = *(_QWORD *)&buf[16];
      buf[23] = 0;
      buf[0] = 0;

    }
    v90 = (id)v4[39];
    v91 = v90 == 0;

    if (!v91)
    {
      v92 = objc_retainAutorelease((id)v4[39]);
      sub_100091AE8(buf, (char *)objc_msgSend(v92, "UTF8String"));
      if (SBYTE7(v263[1]) < 0)
        operator delete(*(void **)&v263[0]);
      v263[0] = *(_OWORD *)buf;
      *(_QWORD *)&v263[1] = *(_QWORD *)&buf[16];
      buf[23] = 0;
      buf[0] = 0;

    }
    v93 = BYTE7(v265);
    if ((SBYTE7(v265) & 0x80u) == 0)
      v94 = &v264;
    else
      v94 = (__int128 *)v264;
    if (SBYTE7(v265) < 0)
      v93 = *((_QWORD *)&v264 + 1);
    buf[0] = 13;
    v95 = sub_10044CC00(v94, (unsigned __int8 *)v94 + v93, buf);
    v96 = (char *)&v264 + BYTE7(v265);
    if ((SBYTE7(v265) & 0x80u) == 0)
    {
      v97 = (unsigned __int8 *)&v264;
    }
    else
    {
      v96 = (char *)(v264 + *((_QWORD *)&v264 + 1));
      v97 = (unsigned __int8 *)v264;
    }
    std::string::erase((std::string *)&v264, v95 - v97, v96 - (char *)v95);
    v98 = BYTE7(v265);
    if ((SBYTE7(v265) & 0x80u) == 0)
      v99 = &v264;
    else
      v99 = (__int128 *)v264;
    if (SBYTE7(v265) < 0)
      v98 = *((_QWORD *)&v264 + 1);
    buf[0] = 10;
    v100 = sub_10044CC00(v99, (unsigned __int8 *)v99 + v98, buf);
    v101 = (char *)&v264 + BYTE7(v265);
    if ((SBYTE7(v265) & 0x80u) == 0)
    {
      v102 = (unsigned __int8 *)&v264;
    }
    else
    {
      v101 = (char *)(v264 + *((_QWORD *)&v264 + 1));
      v102 = (unsigned __int8 *)v264;
    }
    std::string::erase((std::string *)&v264, v100 - v102, v101 - (char *)v100);
    v103 = BYTE7(v265);
    if ((SBYTE7(v265) & 0x80u) == 0)
      v104 = &v264;
    else
      v104 = (__int128 *)v264;
    if (SBYTE7(v265) < 0)
      v103 = *((_QWORD *)&v264 + 1);
    buf[0] = 44;
    v105 = sub_10044CC00(v104, (unsigned __int8 *)v104 + v103, buf);
    v106 = (char *)&v264 + BYTE7(v265);
    if ((SBYTE7(v265) & 0x80u) == 0)
    {
      v107 = (unsigned __int8 *)&v264;
    }
    else
    {
      v106 = (char *)(v264 + *((_QWORD *)&v264 + 1));
      v107 = (unsigned __int8 *)v264;
    }
    std::string::erase((std::string *)&v264, v105 - v107, v106 - (char *)v105);
    v108 = HIBYTE(v258[2]);
    if (SHIBYTE(v258[2]) < 0)
      v108 = (unint64_t)v258[1];
    v109 = (char *)HIBYTE(v258[5]);
    if (SHIBYTE(v258[5]) < 0)
      v109 = (char *)v258[4];
    v110 = &v109[v108];
    v111 = BYTE7(v260);
    if (SBYTE7(v260) < 0)
      v111 = *((_QWORD *)&v259 + 1);
    v112 = (char *)malloc_type_calloc((size_t)&v110[v111 + 80], 1uLL, 0x100004077774924uLL);
    v113 = v112;
    *(_OWORD *)v112 = data;
    v114 = v254;
    v115 = v255;
    v116 = v257;
    *((_OWORD *)v112 + 3) = v256;
    *((_OWORD *)v112 + 4) = v116;
    *((_OWORD *)v112 + 1) = v114;
    *((_OWORD *)v112 + 2) = v115;
    if ((v150 & 1) != 0)
    {
      v117 = 80;
    }
    else
    {
      v118 = v112 + 80;
      if (SHIBYTE(v258[2]) >= 0)
        v119 = v258;
      else
        v119 = (void **)v258[0];
      if (SHIBYTE(v258[2]) >= 0)
        v120 = HIBYTE(v258[2]);
      else
        v120 = (size_t)v258[1];
      memcpy(v118, v119, v120);
      v121 = HIBYTE(v258[2]);
      if (SHIBYTE(v258[2]) < 0)
        v121 = (int)v258[1];
      v117 = v121 + 80;
    }
    if (SHIBYTE(v258[5]) >= 0)
      v122 = &v258[3];
    else
      v122 = (void **)v258[3];
    if (SHIBYTE(v258[5]) >= 0)
      v123 = HIBYTE(v258[5]);
    else
      v123 = (size_t)v258[4];
    memcpy(&v113[v117], v122, v123);
    v124 = HIBYTE(v258[5]);
    if (SHIBYTE(v258[5]) < 0)
      v124 = (int)v258[4];
    v125 = v124 + v117;
    if ((SBYTE7(v260) & 0x80u) == 0)
      v126 = &v259;
    else
      v126 = (__int128 *)v259;
    if ((SBYTE7(v260) & 0x80u) == 0)
      v127 = BYTE7(v260);
    else
      v127 = *((_QWORD *)&v259 + 1);
    memcpy(&v113[v125], v126, v127);
    v128 = BYTE7(v260);
    if (SBYTE7(v260) < 0)
      v128 = DWORD2(v259);
    v129 = v128 + v125;
    CC_SHA1(&data, v129, (unsigned __int8 *)&v263[1] + 8);
    v130 = qword_100999810;
    if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 68157954;
      *(_DWORD *)&buf[4] = v129;
      *(_WORD *)&buf[8] = 2098;
      *(_QWORD *)&buf[10] = &data;
      _os_log_impl((void *)&_mh_execute_header, v130, OS_LOG_TYPE_DEFAULT, "Identification - LE raw serialized data dump {%{public}.*P}", buf, 0x12u);
      v130 = qword_100999810;
    }
    if (os_log_type_enabled(v130, OS_LOG_TYPE_DEFAULT))
    {
      v131 = (char *)&v260 + 8;
      if ((SBYTE7(v265) & 0x80u) == 0)
        v132 = &v264;
      else
        v132 = (__int128 *)v264;
      if (SHIBYTE(v258[2]) >= 0)
        v133 = v258;
      else
        v133 = (void **)v258[0];
      if (v261 < 0)
        v131 = (char *)*((_QWORD *)&v260 + 1);
      v134 = (void **)v258[3];
      if (SHIBYTE(v258[5]) >= 0)
        v134 = &v258[3];
      v135 = &v259;
      if (SBYTE7(v260) < 0)
        v135 = (__int128 *)v259;
      v136 = v262;
      if (SBYTE7(v262[1]) < 0)
        v136 = *(_OWORD **)&v262[0];
      v137 = (char *)&v262[1] + 8;
      if (v262[2] < 0)
        v137 = (char *)*((_QWORD *)&v262[1] + 1);
      v138 = *(_OWORD **)&v263[0];
      if ((SBYTE7(v263[1]) & 0x80u) == 0)
        v138 = v263;
      *(_DWORD *)&buf[4] = 20;
      p_data = &data;
      v173 = v132;
      v175 = WORD2(data);
      v179 = WORD3(data);
      v183 = &v257;
      v187 = (char *)&v257 + 8;
      v191 = WORD5(data);
      v195 = HIWORD(data);
      v199 = WORD1(v254);
      v203 = WORD3(v254);
      v207 = WORD5(v254);
      v211 = HIWORD(v254);
      v215 = WORD1(v255);
      v219 = WORD3(v255);
      v223 = HIDWORD(v255);
      v227 = DWORD1(v256);
      v231 = BYTE3(data);
      v233 = v133;
      *(_QWORD *)&buf[10] = (char *)&v263[1] + 8;
      *(_DWORD *)&buf[20] = 3;
      v177 = BYTE8(data);
      *(_WORD *)&buf[18] = 1042;
      v180 = 1042;
      v184 = 1042;
      v181 = 8;
      v185 = 8;
      *(_WORD *)&buf[8] = 2098;
      *(_WORD *)&buf[24] = 2098;
      v182 = 2098;
      v186 = 2098;
      v239 = v135;
      v241 = v136;
      v243 = v137;
      v247 = BYTE8(v265);
      v189 = HIDWORD(v256);
      v193 = WORD6(data);
      v197 = (unsigned __int16)v254;
      v201 = WORD2(v254);
      v205 = WORD4(v254);
      v209 = WORD6(v254);
      v213 = (unsigned __int16)v255;
      v217 = WORD2(v255);
      v221 = DWORD2(v255);
      v225 = v256;
      v229 = DWORD2(v256);
      v235 = v131;
      v237 = v134;
      v172 = 2082;
      v232 = 2082;
      v234 = 2082;
      v236 = 2082;
      v238 = 2082;
      v240 = 2082;
      v242 = 2082;
      v244 = 2082;
      v245 = v138;
      v174 = 1024;
      v176 = 1024;
      v178 = 1024;
      v188 = 1024;
      v190 = 1024;
      v192 = 1024;
      v194 = 1024;
      v196 = 1024;
      v198 = 1024;
      v200 = 1024;
      v202 = 1024;
      v204 = 1024;
      v206 = 1024;
      v208 = 1024;
      v210 = 1024;
      v212 = 1024;
      v214 = 1024;
      v216 = 1024;
      v218 = 1024;
      v220 = 1024;
      v222 = 1024;
      v224 = 1024;
      v226 = 1024;
      v228 = 1024;
      v230 = 1024;
      v246 = 1024;
      *(_DWORD *)buf = 68299266;
      _os_log_impl((void *)&_mh_execute_header, v130, OS_LOG_TYPE_DEFAULT, "Identification - generating LE metric {%{public}.20P, %{public}.3P, %{public}s, 0x%x, 0x%x, 0x%x, %{public}.8P, %{public}.8P, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, %d, %{public}s, %{public}s, %{public}s, %{public}s, %{public}s, %{public}s, %{public}s, %d}", buf, 0x12Eu);
    }
    free(v113);
    v139 = sub_100027F68();
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v139 + 8))(v139) && (WORD1(v255) || BYTE3(data)))
    {
      v146 = qword_100999810;
      if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
      {
        v147 = sub_100027F68();
        v148 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v147 + 8))(v147);
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)&buf[4] = v148;
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = BYTE3(data);
        _os_log_impl((void *)&_mh_execute_header, v146, OS_LOG_TYPE_DEFAULT, "Identification - routing LE friendly name: internal %d, le hid service present %d", buf, 0xEu);
      }
    }
    else
    {
      v140 = qword_100999810;
      if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
      {
        v141 = sub_100027F68();
        v142 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v141 + 8))(v141);
        *(_DWORD *)buf = 67109632;
        *(_DWORD *)&buf[4] = v142;
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = BYTE3(data);
        *(_WORD *)&buf[14] = 1024;
        *(_DWORD *)&buf[16] = BYTE8(v265);
        _os_log_impl((void *)&_mh_execute_header, v140, OS_LOG_TYPE_DEFAULT, "Identification - clearing LE friendly name: internal %d, le hid service present %d, le ghs service present %d", buf, 0x14u);
      }
      if (SBYTE7(v265) < 0)
        operator delete((void *)v264);
      v264 = 0uLL;
      *(_QWORD *)&v265 = 0;
    }
    if (qword_1009778C8 != -1)
      dispatch_once(&qword_1009778C8, &stru_10093E890);
    v143 = off_1009778C0;
    sub_100091AE8(v154, "LeIdentificationHashExist");
    sub_1006576F0((uint64_t)v143, v153, (unsigned __int8 *)v154);
    if (v155 < 0)
      operator delete(v154[0]);
    *((_BYTE *)v4 + 357) = 1;
    v144 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", (char *)&v263[1] + 8, 20, v262));
    objc_storeStrong((id *)v4 + 45, v144);

    sub_100034264((uint64_t)v169);
    v145 = sub_100065478();
    (*(void (**)(uint64_t, __int128 *))(*(_QWORD *)v145 + 224))(v145, &data);
    sub_100043728(&v157);

    v22 = 0;
    v3 = v153;
  }
  else
  {
    v33 = qword_100999810;
    if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "Identification - DI not yet completed, returning", buf, 2u);
    }
    v22 = 4;
  }
LABEL_15:
  if (v162)
  {
    v163 = (char *)v162;
    operator delete(v162);
  }
  if (__p)
  {
    v166 = (char *)__p;
    operator delete(__p);
  }
  sub_100393448((uint64_t)&data);
  sub_100034234((uint64_t)v169);

  return v22;
}

void sub_100668234(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *__p,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
  void *v39;

  if (__p)
    operator delete(__p);
  if (a35)
    operator delete(a35);
  sub_100393448((uint64_t)&STACK[0x2F0]);
  sub_100034234((uint64_t)&a39);

  _Unwind_Resume(a1);
}

uint64_t sub_10066839C(uint64_t a1)
{
  NSObject *v1;
  NSObject *v2;
  uint64_t v3;
  id v4;
  uint64_t v5;
  void *v6;
  void *v7;
  unsigned __int8 *v8;
  __int16 v9;
  uint64_t v10;
  _BYTE *v11;
  void *v12;
  int v13;
  int v14;
  int v15;
  int v16;
  unsigned int v17;
  const char *v18;
  void *p_p;
  NSObject *v20;
  uint64_t *v21;
  NSObject *v22;
  const char *v23;
  int v24;
  uint64_t *v25;
  uint64_t *v26;
  BOOL v27;
  uint64_t v28;
  NSObject *v29;
  NSArray *v30;
  id v31;
  id v32;
  uint64_t v33;
  void *i;
  NSObject *v35;
  void *v36;
  NSObject *v37;
  uint64_t j;
  NSObject *v39;
  _BYTE *v40;
  uint64_t v42;
  id v44;
  id obj;
  int v46;
  NSObject *log;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  void *__p;
  char v53;
  void *v54;
  char v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  uint64_t *v61;
  _QWORD *v62[2];
  _QWORD v63[2];
  uint8_t v64[128];
  _BYTE v65[12];
  char v66;
  _BYTE buf[12];
  __int16 v68;
  _BYTE *v69;
  __int16 v70;
  void *v71;
  __int16 v72;
  int v73;
  __int16 v74;
  int v75;
  __int16 v76;
  int v77;
  __int16 v78;
  int v79;
  __int16 v80;
  int v81;
  __int16 v82;
  const char *v83;
  __int16 v84;
  void *v85;
  _BYTE v86[128];

  v63[0] = 0;
  v63[1] = 0;
  sub_10003415C((uint64_t)v63, a1 + 88);
  v1 = qword_100999810;
  if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "statedump: ------------------ LE Device Manager -------------------", buf, 2u);
  }
  *(_QWORD *)buf = 0;
  sub_10004AD30((uint64_t)buf);
  v2 = qword_100999810;
  v3 = a1;
  if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: Devices:", buf, 2u);
  }
  v62[0] = 0;
  v62[1] = 0;
  v61 = (uint64_t *)v62;
  v57 = 0u;
  v58 = 0u;
  v59 = 0u;
  v60 = 0u;
  obj = *(id *)(a1 + 168);
  v4 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v57, v86, 16);
  if (v4)
  {
    v5 = *(_QWORD *)v58;
    v42 = *(_QWORD *)v58;
    do
    {
      v6 = 0;
      v44 = v4;
      do
      {
        if (*(_QWORD *)v58 != v5)
          objc_enumerationMutation(obj);
        v7 = *(void **)(*((_QWORD *)&v57 + 1) + 8 * (_QWORD)v6);
        v8 = (unsigned __int8 *)objc_msgSend(*(id *)(v3 + 168), "objectForKey:", v7);
        v56 = *((_OWORD *)v8 + 15);
        *(_DWORD *)v65 = sub_1006589A8(v3, v7);
        *(_QWORD *)buf = v65;
        v9 = *((_WORD *)sub_100646320(&v61, (unsigned int *)v65, (uint64_t)&unk_100740F58, (_DWORD **)buf) + 16);
        *(_DWORD *)v65 = *((_DWORD *)v8 + 93);
        *(_QWORD *)buf = v65;
        *((_WORD *)sub_100646320(&v61, (unsigned int *)v65, (uint64_t)&unk_100740F58, (_DWORD **)buf) + 16) = v9 + 1;
        v10 = qword_100999810;
        if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
        {
          sub_10064E030((uint64_t)v8);
          if (v66 >= 0)
            v11 = v65;
          else
            v11 = *(_BYTE **)v65;
          sub_100645DCC((unint64_t *)&v56);
          log = v10;
          if (v55 >= 0)
            v12 = &v54;
          else
            v12 = v54;
          v13 = v8[358];
          v14 = *((_DWORD *)v8 + 93);
          v15 = v8[355];
          v16 = v8[356];
          v46 = v8[488];
          v17 = sub_10064CFD4((uint64_t)v8);
          v18 = sub_10064CFB0(v17);
          sub_10064D8AC((uint64_t)v8);
          p_p = &__p;
          if (v53 < 0)
            p_p = __p;
          *(_DWORD *)buf = 138545667;
          *(_QWORD *)&buf[4] = v7;
          v68 = 2082;
          v69 = v11;
          v70 = 2082;
          v71 = v12;
          v72 = 1024;
          v73 = v13;
          v74 = 1024;
          v75 = v14;
          v76 = 1024;
          v77 = v15;
          v78 = 1024;
          v79 = v16;
          v80 = 1024;
          v81 = v46;
          v82 = 2080;
          v83 = v18;
          v84 = 2081;
          v85 = p_p;
          _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, "statedump:    %{public}@ â†’ %{public}s (added to WL %{public}s ago) disableDisconnect:%d useCase:%d scanDutyCycle screenON:%d screenOFF:%d pendingDelete:%d type:%s FindMy:%{private}s ", buf, 0x52u);
          if (v53 < 0)
            operator delete(__p);
          v3 = a1;
          v4 = v44;
          v5 = v42;
          if (v55 < 0)
            operator delete(v54);
          if (v66 < 0)
            operator delete(*(void **)v65);
        }
        v6 = (char *)v6 + 1;
      }
      while (v4 != v6);
      v4 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v57, v86, 16);
    }
    while (v4);
  }

  v20 = qword_100999810;
  if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "statedump:    useCase map:", buf, 2u);
  }
  v21 = v61;
  if (v61 != (uint64_t *)v62)
  {
    v22 = qword_100999810;
    do
    {
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        v23 = sub_100036798(*((_DWORD *)v21 + 7));
        v24 = *((unsigned __int16 *)v21 + 16);
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = v23;
        v68 = 1024;
        LODWORD(v69) = v24;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "statedump:    \tuseCase:%{public}s count:%d", buf, 0x12u);
        v22 = qword_100999810;
      }
      v25 = (uint64_t *)v21[1];
      if (v25)
      {
        do
        {
          v26 = v25;
          v25 = (uint64_t *)*v25;
        }
        while (v25);
      }
      else
      {
        do
        {
          v26 = (uint64_t *)v21[2];
          v27 = *v26 == (_QWORD)v21;
          v21 = v26;
        }
        while (!v27);
      }
      v21 = v26;
    }
    while (v26 != (uint64_t *)v62);
  }
  sub_10033FE5C(*(_QWORD *)(a1 + 248));
  if (_os_feature_enabled_impl("DeviceAccess", "AccessorySetupKit"))
  {
    v28 = sub_100027F68();
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v28 + 160))(v28))
    {
      v29 = qword_100999810;
      if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "statedump: Device name check:", buf, 2u);
      }
      v30 = sub_100665EA8((_QWORD *)a1, 1u);
      v50 = 0u;
      v51 = 0u;
      v48 = 0u;
      v49 = 0u;
      v31 = (id)objc_claimAutoreleasedReturnValue(v30);
      v32 = objc_msgSend(v31, "countByEnumeratingWithState:objects:count:", &v48, v64, 16);
      if (v32)
      {
        v33 = *(_QWORD *)v49;
        do
        {
          for (i = 0; i != v32; i = (char *)i + 1)
          {
            if (*(_QWORD *)v49 != v33)
              objc_enumerationMutation(v31);
            v35 = qword_100999810;
            if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
            {
              v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*((_QWORD *)&v48 + 1) + 8 * (_QWORD)i), "objectForKeyedSubscript:", CFSTR("mapLabelCalloutTitleKey")));
              *(_DWORD *)buf = 138412290;
              *(_QWORD *)&buf[4] = v36;
              _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "statedump:    \"%@\"", buf, 0xCu);

            }
          }
          v32 = objc_msgSend(v31, "countByEnumeratingWithState:objects:count:", &v48, v64, 16);
        }
        while (v32);
      }

      v37 = qword_100999810;
      if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "statedump: evicted devices:", buf, 2u);
      }
      for (j = *(_QWORD *)(a1 + 264); j != a1 + 256; j = *(_QWORD *)(j + 8))
      {
        v39 = qword_100999810;
        if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
        {
          sub_100665BD4(j + 16);
          if (v70 >= 0)
            v40 = buf;
          else
            v40 = *(_BYTE **)buf;
          *(_DWORD *)v65 = 136380675;
          *(_QWORD *)&v65[4] = v40;
          _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "statedump:    \"%{private}s\"", v65, 0xCu);
          if (SHIBYTE(v70) < 0)
            operator delete(*(void **)buf);
        }
      }

    }
  }
  sub_10001A82C((uint64_t)&v61, v62[0]);
  return sub_100034234((uint64_t)v63);
}

void sub_100668B1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *__p,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46,uint64_t a47,uint64_t a48,char a49)
{
  void *v49;

  sub_10001A82C((uint64_t)&a46, (_QWORD *)a47);
  sub_100034234((uint64_t)&a49);
  _Unwind_Resume(a1);
}

uint64_t sub_100668BD0(uint64_t a1)
{
  id v2;
  id v3;
  uint64_t v4;
  void *i;
  void *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  void *__p[2];
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  _QWORD v18[2];
  __int128 v19;
  _BYTE v20[128];
  __int128 v21;

  v18[0] = 0;
  v18[1] = 0;
  sub_10003415C((uint64_t)v18, a1 + 88);
  v21 = 0uLL;
  v14 = 0u;
  v15 = 0u;
  v16 = 0u;
  v17 = 0u;
  v2 = *(id *)(a1 + 168);
  v3 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v14, v20, 16);
  if (v3)
  {
    v4 = *(_QWORD *)v15;
    do
    {
      for (i = 0; i != v3; i = (char *)i + 1)
      {
        if (*(_QWORD *)v15 != v4)
          objc_enumerationMutation(v2);
        v6 = *(void **)(*((_QWORD *)&v14 + 1) + 8 * (_QWORD)i);
        v7 = (char *)objc_msgSend(*(id *)(a1 + 168), "objectForKey:", v6, __p[0], __p[1], v12, v13, (_QWORD)v14);
        v19 = 0uLL;
        objc_msgSend(v6, "getUUIDBytes:", &v19);
        v21 = v19;
        if (v7[164])
        {
          *(_DWORD *)((char *)&v13 + 3) = 0;
          LODWORD(v13) = 0;
          v8 = sub_1000746A4(*((_QWORD *)v7 + 3));
          LODWORD(v13) = v8;
          BYTE6(v13) = BYTE6(v8);
          WORD2(v13) = WORD2(v8);
          if (v7[127] < 0)
          {
            sub_10003430C(__p, *((void **)v7 + 13), *((_QWORD *)v7 + 14));
          }
          else
          {
            *(_OWORD *)__p = *(_OWORD *)(v7 + 104);
            v12 = *((_QWORD *)v7 + 15);
          }
          if (v12 >= 0)
            v9 = (char *)__p;
          else
            v9 = (char *)__p[0];
          sub_10011D5FC(&v13, v9, &v21);
          if (SHIBYTE(v12) < 0)
            operator delete(__p[0]);
        }
      }
      v3 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v14, v20, 16);
    }
    while (v3);
  }

  return sub_100034234((uint64_t)v18);
}

void sub_100668D94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24)
{
  void *v24;

  sub_100034234((uint64_t)&a24);
  _Unwind_Resume(a1);
}

uint64_t sub_100668DE4(uint64_t a1, uint64_t a2)
{
  _QWORD v5[2];

  v5[0] = 0;
  v5[1] = 0;
  sub_10003415C((uint64_t)v5, a1 + 88);
  sub_100668E44(a1 + 288, a2);
  return sub_100034234((uint64_t)v5);
}

void sub_100668E30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100034234((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_100668E44(uint64_t a1, uint64_t a2)
{
  char *v4;
  char *v5;
  uint64_t v6;

  os_unfair_lock_lock((os_unfair_lock_t)a1);
  v5 = *(char **)(a1 + 8);
  v4 = *(char **)(a1 + 16);
  if (v5 != v4)
  {
    while (*(_QWORD *)v5 != a2)
    {
      v5 += 8;
      if (v5 == v4)
      {
        v5 = *(char **)(a1 + 16);
        break;
      }
    }
  }
  if (v5 == v4)
  {
    v6 = a2;
    sub_10066A724(a1 + 8, v4, (char *)&v6);
    sub_10007AA30(a1 + 8);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

void sub_100668ECC(os_unfair_lock_s *a1, void *a2)
{
  void (**v3)(id, _QWORD);
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;

  v3 = a2;
  os_unfair_lock_lock(a1);
  v5 = 0;
  v6 = 0;
  v7 = 0;
  sub_10001FE6C(&v5, (uint64_t)&a1[2]);
  os_unfair_lock_unlock(a1);
  v4 = v5;
  if (v5 != v6)
  {
    do
      v3[2](v3, *v4++);
    while (v4 != v6);
    v4 = v5;
  }
  if (v4)
  {
    v6 = v4;
    operator delete(v4);
  }

}

void sub_100668F60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  void *v11;

  _Unwind_Resume(a1);
}

void sub_100668F8C(uint64_t a1)
{
  sub_100669954(a1);
  operator delete();
}

void sub_100668FCC(void **a1)
{
  void **v2;
  _QWORD **v3;
  _QWORD *v4;
  void **v5;

  if (a1[2])
  {
    v3 = (_QWORD **)*a1;
    v2 = (void **)a1[1];
    v4 = *v2;
    v4[1] = *((_QWORD *)*a1 + 1);
    *v3[1] = v4;
    a1[2] = 0;
    if (v2 != a1)
    {
      do
      {
        v5 = (void **)v2[1];
        sub_10066902C((int)a1, v2);
        v2 = v5;
      }
      while (v5 != a1);
    }
  }
}

void sub_10066902C(int a1, void **__p)
{
  if (*((char *)__p + 47) < 0)
    operator delete(__p[3]);
  operator delete(__p);
}

void sub_10066905C(uint64_t a1, uint64_t a2)
{
  char *v4;
  char *v5;
  char *v6;
  uint64_t v7;

  os_unfair_lock_lock((os_unfair_lock_t)a1);
  v4 = *(char **)(a1 + 8);
  v5 = *(char **)(a1 + 16);
  if (v4 == v5)
  {
    v6 = *(char **)(a1 + 8);
    goto LABEL_10;
  }
  v6 = *(char **)(a1 + 8);
  while (*(_QWORD *)v6 != a2)
  {
    v6 += 8;
    if (v6 == v5)
    {
      v6 = *(char **)(a1 + 16);
      break;
    }
  }
  if (v6 == v5)
  {
    if (v4 != v5)
    {
LABEL_11:
      v7 = a2;
      sub_100669110(a1 + 8, v6, (char *)&v7);
      sub_10007AA30(a1 + 8);
      goto LABEL_12;
    }
LABEL_10:
    (***(void (****)(_QWORD, uint64_t))(a1 + 32))(*(_QWORD *)(a1 + 32), a1);
    goto LABEL_11;
  }
LABEL_12:
  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

char *sub_100669110(uint64_t a1, char *__src, char *a3)
{
  char *v3;
  char *v4;
  char *v6;
  unint64_t v7;
  uint64_t v8;
  char *v9;
  char *v10;
  _QWORD *v11;
  uint64_t v12;
  char *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  char *v20;
  unint64_t v21;
  unint64_t v22;
  char *v23;
  uint64_t v24;
  void *__p;
  char *v27;
  char *v28;
  char *v29;
  uint64_t v30;

  v3 = a3;
  v4 = __src;
  v6 = *(char **)(a1 + 8);
  v8 = a1 + 16;
  v7 = *(_QWORD *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    v13 = *(char **)a1;
    v14 = ((uint64_t)&v6[-*(_QWORD *)a1] >> 3) + 1;
    if (v14 >> 61)
      abort();
    v15 = __src - v13;
    v16 = (__src - v13) >> 3;
    v17 = v7 - (_QWORD)v13;
    if (v17 >> 2 > v14)
      v14 = v17 >> 2;
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8)
      v18 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v18 = v14;
    v30 = a1 + 16;
    if (v18)
      v19 = (char *)sub_10007ABA0(a1 + 16, v18);
    else
      v19 = 0;
    v20 = &v19[8 * v16];
    __p = v19;
    v27 = v20;
    v28 = v20;
    v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4)
          v22 = 1;
        else
          v22 = v15 >> 2;
        v23 = (char *)sub_10007ABA0(v8, v22);
        v20 = &v23[8 * (v22 >> 2)];
        __p = v23;
        v27 = v20;
        v29 = &v23[8 * v24];
        if (v19)
          operator delete(v19);
      }
      else
      {
        v21 = v16 + 2;
        if (v16 >= -1)
          v21 = v16 + 1;
        v20 -= 8 * (v21 >> 1);
        v27 = v20;
      }
    }
    *(_QWORD *)v20 = *(_QWORD *)v3;
    v28 = v20 + 8;
    v4 = sub_10007AADC((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27)
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8;
    if (__p)
      operator delete(__p);
  }
  else if (__src == v6)
  {
    *(_QWORD *)__src = *(_QWORD *)a3;
    *(_QWORD *)(a1 + 8) = __src + 8;
  }
  else
  {
    v9 = __src + 8;
    v10 = v6 - 8;
    v11 = *(_QWORD **)(a1 + 8);
    while (v10 < v6)
    {
      v12 = *(_QWORD *)v10;
      v10 += 8;
      *v11++ = v12;
    }
    *(_QWORD *)(a1 + 8) = v11;
    if (v6 != v9)
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    if (v4 <= v3)
      v3 += 8 * (*(_QWORD *)(a1 + 8) > (unint64_t)v3);
    *(_QWORD *)v4 = *(_QWORD *)v3;
  }
  return v4;
}

void sub_100669314(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_10066934C(uint64_t a1, uint64_t a2)
{
  char *v4;
  char *v5;
  char *v6;
  uint64_t v7;

  os_unfair_lock_lock((os_unfair_lock_t)a1);
  v4 = *(char **)(a1 + 8);
  v5 = *(char **)(a1 + 16);
  if (v4 == v5)
  {
    v6 = *(char **)(a1 + 8);
    goto LABEL_10;
  }
  v6 = *(char **)(a1 + 8);
  while (*(_QWORD *)v6 != a2)
  {
    v6 += 8;
    if (v6 == v5)
    {
      v6 = *(char **)(a1 + 16);
      break;
    }
  }
  if (v6 == v5)
  {
    if (v4 != v5)
    {
LABEL_11:
      v7 = a2;
      sub_100669400(a1 + 8, v6, (char *)&v7);
      sub_10007AA30(a1 + 8);
      goto LABEL_12;
    }
LABEL_10:
    (***(void (****)(_QWORD, uint64_t))(a1 + 32))(*(_QWORD *)(a1 + 32), a1);
    goto LABEL_11;
  }
LABEL_12:
  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

char *sub_100669400(uint64_t a1, char *__src, char *a3)
{
  char *v3;
  char *v4;
  char *v6;
  unint64_t v7;
  uint64_t v8;
  char *v9;
  char *v10;
  _QWORD *v11;
  uint64_t v12;
  char *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  char *v20;
  unint64_t v21;
  unint64_t v22;
  char *v23;
  uint64_t v24;
  void *__p;
  char *v27;
  char *v28;
  char *v29;
  uint64_t v30;

  v3 = a3;
  v4 = __src;
  v6 = *(char **)(a1 + 8);
  v8 = a1 + 16;
  v7 = *(_QWORD *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    v13 = *(char **)a1;
    v14 = ((uint64_t)&v6[-*(_QWORD *)a1] >> 3) + 1;
    if (v14 >> 61)
      abort();
    v15 = __src - v13;
    v16 = (__src - v13) >> 3;
    v17 = v7 - (_QWORD)v13;
    if (v17 >> 2 > v14)
      v14 = v17 >> 2;
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8)
      v18 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v18 = v14;
    v30 = a1 + 16;
    if (v18)
      v19 = (char *)sub_10007ABA0(a1 + 16, v18);
    else
      v19 = 0;
    v20 = &v19[8 * v16];
    __p = v19;
    v27 = v20;
    v28 = v20;
    v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4)
          v22 = 1;
        else
          v22 = v15 >> 2;
        v23 = (char *)sub_10007ABA0(v8, v22);
        v20 = &v23[8 * (v22 >> 2)];
        __p = v23;
        v27 = v20;
        v29 = &v23[8 * v24];
        if (v19)
          operator delete(v19);
      }
      else
      {
        v21 = v16 + 2;
        if (v16 >= -1)
          v21 = v16 + 1;
        v20 -= 8 * (v21 >> 1);
        v27 = v20;
      }
    }
    *(_QWORD *)v20 = *(_QWORD *)v3;
    v28 = v20 + 8;
    v4 = sub_10007AADC((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27)
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8;
    if (__p)
      operator delete(__p);
  }
  else if (__src == v6)
  {
    *(_QWORD *)__src = *(_QWORD *)a3;
    *(_QWORD *)(a1 + 8) = __src + 8;
  }
  else
  {
    v9 = __src + 8;
    v10 = v6 - 8;
    v11 = *(_QWORD **)(a1 + 8);
    while (v10 < v6)
    {
      v12 = *(_QWORD *)v10;
      v10 += 8;
      *v11++ = v12;
    }
    *(_QWORD *)(a1 + 8) = v11;
    if (v6 != v9)
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    if (v4 <= v3)
      v3 += 8 * (*(_QWORD *)(a1 + 8) > (unint64_t)v3);
    *(_QWORD *)v4 = *(_QWORD *)v3;
  }
  return v4;
}

void sub_100669604(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_10066963C(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 584);
  if (v2)
  {
    *(_QWORD *)(a1 + 592) = v2;
    operator delete(v2);
  }

  if (*(char *)(a1 + 231) < 0)
    operator delete(*(void **)(a1 + 208));

  sub_100056BAC(a1 + 176, *(char **)(a1 + 184));
  if (*(char *)(a1 + 127) < 0)
    operator delete(*(void **)(a1 + 104));

  return a1;
}

char *sub_100669758(_QWORD *a1, char *__src, char *a3)
{
  char *v3;
  char *v4;
  char *v6;
  unint64_t v7;
  char *v8;
  _BYTE *v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  size_t v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;
  size_t v19;
  char *v20;
  char *v21;
  char *v22;
  char v23;
  _BYTE *v24;
  uint64_t v25;
  char *v26;

  v3 = a3;
  v4 = __src;
  v6 = (char *)a1[1];
  v7 = a1[2];
  if ((unint64_t)v6 >= v7)
  {
    v10 = (char *)*a1;
    v11 = (uint64_t)&v6[-*a1 + 1];
    if (v11 < 0)
      abort();
    v12 = __src - v10;
    v13 = v7 - (_QWORD)v10;
    if (2 * v13 > v11)
      v11 = 2 * v13;
    if (v13 >= 0x3FFFFFFFFFFFFFFFLL)
      v14 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v14 = v11;
    if (v14)
      v15 = (char *)operator new(v14);
    else
      v15 = 0;
    v16 = &v15[v12];
    v17 = &v15[v14];
    if (v12 == v14)
    {
      if (v12 < 1)
      {
        if ((unint64_t)(2 * v12) <= 1)
          v19 = 1;
        else
          v19 = 2 * v12;
        v20 = (char *)operator new(v19);
        v16 = &v20[v19 >> 2];
        v17 = &v20[v19];
        if (v15)
        {
          operator delete(v15);
          v10 = (char *)*a1;
        }
      }
      else
      {
        if (v12 + 1 >= 0)
          v18 = v12 + 1;
        else
          v18 = v12 + 2;
        v16 -= v18 >> 1;
      }
    }
    *v16 = *v3;
    v21 = v16;
    if (v10 != v4)
    {
      v22 = v4;
      v21 = v16;
      do
      {
        v23 = *--v22;
        *--v21 = v23;
      }
      while (v22 != v10);
    }
    v24 = (_BYTE *)a1[1];
    v25 = v24 - v4;
    if (v24 != v4)
      memmove(v16 + 1, v4, v24 - v4);
    v26 = (char *)*a1;
    *a1 = v21;
    a1[1] = &v16[v25 + 1];
    a1[2] = v17;
    if (v26)
      operator delete(v26);
    return v16;
  }
  else if (__src == v6)
  {
    *__src = *a3;
    a1[1] = __src + 1;
  }
  else
  {
    v8 = __src + 1;
    if (v6)
    {
      *v6 = *(v6 - 1);
      v9 = v6 + 1;
    }
    else
    {
      v9 = 0;
    }
    a1[1] = v9;
    if (v6 != v8)
      memmove(__src + 1, __src, v6 - v8);
    if (v4 <= v3 && a1[1] > (unint64_t)v3)
      ++v3;
    *v4 = *v3;
  }
  return v4;
}

void sub_10066993C(_Unwind_Exception *exception_object)
{
  void *v1;

  if (v1)
    operator delete(v1);
  _Unwind_Resume(exception_object);
}

uint64_t sub_100669954(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = off_10093E4B0;
  *(_QWORD *)(a1 + 8) = off_10093E558;
  *(_QWORD *)(a1 + 16) = off_10093E578;
  *(_QWORD *)(a1 + 24) = off_10093E5A0;
  *(_QWORD *)(a1 + 32) = &off_10093E5D0;
  *(_QWORD *)(a1 + 40) = &off_10093E5E8;
  *(_QWORD *)(a1 + 48) = &off_10093E600;
  *(_QWORD *)(a1 + 56) = &off_10093E618;
  *(_QWORD *)(a1 + 64) = &off_10093E630;

  v2 = *(void **)(a1 + 296);
  if (v2)
  {
    *(_QWORD *)(a1 + 304) = v2;
    operator delete(v2);
  }

  sub_100668FCC((void **)(a1 + 256));
  sub_10001A82C(a1 + 224, *(_QWORD **)(a1 + 232));
  sub_10002074C((_QWORD *)(a1 + 200));
  sub_10001A82C(a1 + 176, *(_QWORD **)(a1 + 184));

  sub_100069BDC(a1 + 88);
  return a1;
}

void sub_100669A18(id a1)
{
  operator new();
}

void sub_100669A58()
{
  operator delete();
}

void sub_100669A7C(id a1)
{
  operator new();
}

void sub_100669ABC()
{
  operator delete();
}

uint64_t *sub_100669AE0(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_100669B34(a1, *(unsigned __int8 **)a2, (unsigned __int8 *)(a2 + 8));
  return a1;
}

void sub_100669B1C(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_10001A82C(v1, *(_QWORD **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_100669B34(uint64_t *result, unsigned __int8 *a2, unsigned __int8 *a3)
{
  unsigned __int8 *v4;
  uint64_t **v5;
  uint64_t *v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  BOOL v9;

  if (a2 != a3)
  {
    v4 = a2;
    v5 = (uint64_t **)result;
    v6 = result + 1;
    do
    {
      result = sub_100669BB8(v5, v6, v4 + 25, v4 + 25);
      v7 = (unsigned __int8 *)*((_QWORD *)v4 + 1);
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = *(unsigned __int8 **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (unsigned __int8 *)*((_QWORD *)v4 + 2);
          v9 = *(_QWORD *)v8 == (_QWORD)v4;
          v4 = v8;
        }
        while (!v9);
      }
      v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *sub_100669BB8(uint64_t **a1, uint64_t *a2, unsigned __int8 *uu2, const unsigned __int8 *a4)
{
  uint64_t **v6;
  uint64_t *result;
  unsigned __int8 *v8[3];
  uint64_t v9;
  const unsigned __int8 *v10;

  v9 = 0;
  v10 = 0;
  v6 = (uint64_t **)sub_100669C44(a1, a2, &v10, &v9, uu2);
  result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_1000568B4((uint64_t)a1, a4, v8);
    sub_100004078(a1, (uint64_t)v10, v6, (uint64_t *)v8[0]);
    return (uint64_t *)v8[0];
  }
  return result;
}

const unsigned __int8 *sub_100669C44(_QWORD *a1, uint64_t *a2, const unsigned __int8 **a3, uint64_t *a4, unsigned __int8 *uu2)
{
  const unsigned __int8 *v9;
  const unsigned __int8 *v11;
  const unsigned __int8 *v12;
  uint64_t v13;
  const unsigned __int8 *v14;
  const unsigned __int8 *v15;
  uint64_t *v16;
  BOOL v17;
  const unsigned __int8 *v19;

  v9 = (const unsigned __int8 *)(a1 + 1);
  if (a1 + 1 == a2 || uuid_compare(uu2, (const unsigned __int8 *)a2 + 25) < 0)
  {
    if ((uint64_t *)*a1 == a2)
    {
      v12 = (const unsigned __int8 *)a2;
    }
    else
    {
      v11 = (const unsigned __int8 *)*a2;
      if (*a2)
      {
        do
        {
          v12 = v11;
          v11 = (const unsigned __int8 *)*((_QWORD *)v11 + 1);
        }
        while (v11);
      }
      else
      {
        v16 = a2;
        do
        {
          v12 = (const unsigned __int8 *)v16[2];
          v17 = *(_QWORD *)v12 == (_QWORD)v16;
          v16 = (uint64_t *)v12;
        }
        while (v17);
      }
      if ((uuid_compare(v12 + 25, uu2) & 0x80000000) == 0)
        return (const unsigned __int8 *)sub_100056928((uint64_t)a1, a3, uu2);
    }
    if (*a2)
    {
      *a3 = v12;
      return v12 + 8;
    }
    else
    {
      *a3 = (const unsigned __int8 *)a2;
      return (const unsigned __int8 *)a2;
    }
  }
  if (uuid_compare((const unsigned __int8 *)a2 + 25, uu2) < 0)
  {
    a4 = a2 + 1;
    v13 = a2[1];
    if (v13)
    {
      v14 = (const unsigned __int8 *)a2[1];
      do
      {
        v15 = v14;
        v14 = *(const unsigned __int8 **)v14;
      }
      while (v14);
    }
    else
    {
      v19 = (const unsigned __int8 *)a2;
      do
      {
        v15 = (const unsigned __int8 *)*((_QWORD *)v19 + 2);
        v17 = *(_QWORD *)v15 == (_QWORD)v19;
        v19 = v15;
      }
      while (!v17);
    }
    if (v15 == v9)
      goto LABEL_27;
    if (uuid_compare(uu2, v15 + 25) < 0)
    {
      v13 = *a4;
LABEL_27:
      if (v13)
      {
        *a3 = v15;
        return v15;
      }
      else
      {
        *a3 = (const unsigned __int8 *)a2;
      }
      return (const unsigned __int8 *)a4;
    }
    return (const unsigned __int8 *)sub_100056928((uint64_t)a1, a3, uu2);
  }
  *a3 = (const unsigned __int8 *)a2;
  *a4 = (uint64_t)a2;
  return (const unsigned __int8 *)a4;
}

void sub_100669DC8(id a1)
{
  operator new();
}

void sub_100669E08()
{
  operator delete();
}

void sub_100669E2C(id a1)
{
  operator new();
}

void sub_100669E6C()
{
  operator delete();
}

void sub_100669E90(id a1)
{
  operator new();
}

void sub_100669ED0()
{
  operator delete();
}

void sub_100669EF4(id a1)
{
  operator new();
}

void sub_100669F34()
{
  operator delete();
}

void sub_100669F58(id a1)
{
  operator new();
}

void sub_10066A070()
{
  operator delete();
}

void sub_10066A094(id a1)
{
  operator new();
}

void sub_10066A0D4()
{
  operator delete();
}

void sub_10066A0F8(id a1)
{
  operator new();
}

void sub_10066A138(id a1)
{
  operator new();
}

void sub_10066A178()
{
  operator delete();
}

void *sub_10066A19C(uint64_t a1, uint64_t a2, uint64_t a3, const unsigned __int8 *a4)
{
  void *v7;

  v7 = operator new(0x20uLL);
  *(_QWORD *)v7 = a2;
  *((_QWORD *)v7 + 1) = a3;
  uuid_copy((unsigned __int8 *)v7 + 16, a4);
  return v7;
}

void sub_10066A1E4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_10066A1F8(id a1)
{
  operator new();
}

void sub_10066A238()
{
  operator delete();
}

uint64_t sub_10066A25C(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  _QWORD *v4;
  uint64_t v6;

  *(_QWORD *)(a1 + 8) = 0;
  v4 = (_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = a1 + 8;
  if (a3)
  {
    v6 = 8 * a3;
    do
    {
      sub_10031F50C((uint64_t **)a1, v4, a2, (uint64_t *)a2);
      ++a2;
      v6 -= 8;
    }
    while (v6);
  }
  return a1;
}

void sub_10066A2C0(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_10001A82C(v1, *(_QWORD **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_10066A2D8(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    sub_10066A2D8(a1, *a2);
    sub_10066A2D8(a1, a2[1]);
    sub_10066A320((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void sub_10066A320(uint64_t a1)
{
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

uint64_t *sub_10066A364(uint64_t **a1, const void **a2, uint64_t a3, __int128 **a4)
{
  uint64_t **v6;
  uint64_t *v7;
  uint64_t **v8;
  uint64_t *v10[3];
  uint64_t v11;

  v11 = 0;
  v6 = (uint64_t **)sub_10001F574((uint64_t)a1, &v11, a2);
  v7 = *v6;
  if (!*v6)
  {
    v8 = v6;
    memset(v10, 0, sizeof(v10));
    sub_10066A418((uint64_t)a1, a4, v10);
    sub_100004078(a1, v11, v8, v10[0]);
    v7 = v10[0];
    v10[0] = 0;
    sub_10066A4B4((uint64_t)v10, 0);
  }
  return v7;
}

_BYTE *sub_10066A418@<X0>(uint64_t a1@<X0>, __int128 **a2@<X2>, _QWORD *a3@<X8>)
{
  uint64_t v5;
  _QWORD *v6;
  _BYTE *result;
  __int128 *v8;
  __int128 v9;

  v5 = a1 + 8;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v6 = operator new(0x50uLL);
  *a3 = v6;
  a3[1] = v5;
  *((_BYTE *)a3 + 16) = 0;
  result = v6 + 4;
  v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    result = sub_10003430C(result, *(void **)v8, *((_QWORD *)v8 + 1));
  }
  else
  {
    v9 = *v8;
    v6[6] = *((_QWORD *)v8 + 2);
    *(_OWORD *)result = v9;
  }
  v6[7] = 0;
  v6[8] = 0;
  v6[9] = 0;
  *((_BYTE *)a3 + 16) = 1;
  return result;
}

void sub_10066A49C(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_10066A4B4(v1, 0);
  _Unwind_Resume(a1);
}

void sub_10066A4B4(uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      sub_10066A320((uint64_t)v2 + 32);
    operator delete(v2);
  }
}

uint64_t sub_10066A4F8(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  const void **v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  int v14;
  BOOL v16;
  uint64_t result;

  v2 = *(unsigned __int8 *)(a1 + 31);
  if ((v2 & 0x80u) == 0)
    v3 = *(unsigned __int8 *)(a1 + 31);
  else
    v3 = *(_QWORD *)(a1 + 16);
  v4 = *(unsigned __int8 *)(a2 + 31);
  v5 = (char)v4;
  if ((v4 & 0x80u) != 0)
    v4 = *(_QWORD *)(a2 + 16);
  if (v3 != v4)
    return 0;
  v6 = (const void **)(a1 + 8);
  v9 = *(unsigned __int8 **)(a2 + 8);
  v7 = (unsigned __int8 *)(a2 + 8);
  v8 = v9;
  if (v5 < 0)
    v7 = v8;
  if ((v2 & 0x80) != 0)
    return memcmp(*v6, v7, *(_QWORD *)(a1 + 16)) == 0;
  if (!*(_BYTE *)(a1 + 31))
    return 1;
  v10 = v2 - 1;
  do
  {
    v12 = *(unsigned __int8 *)v6;
    v6 = (const void **)((char *)v6 + 1);
    v11 = v12;
    v14 = *v7++;
    v13 = v14;
    v16 = v10-- != 0;
    result = v11 == v13;
  }
  while (v11 == v13 && v16);
  return result;
}

char *sub_10066A598(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char *v7;
  _BYTE *v8;

  v7 = (char *)operator new(0x40uLL);
  *(_QWORD *)v7 = a2;
  *((_QWORD *)v7 + 1) = a3;
  *((_QWORD *)v7 + 2) = *(_QWORD *)a4;
  v8 = v7 + 24;
  if (*(char *)(a4 + 31) < 0)
  {
    sub_10003430C(v8, *(void **)(a4 + 8), *(_QWORD *)(a4 + 16));
  }
  else
  {
    *(_OWORD *)v8 = *(_OWORD *)(a4 + 8);
    *((_QWORD *)v7 + 5) = *(_QWORD *)(a4 + 24);
  }
  *((_QWORD *)v7 + 6) = *(_QWORD *)(a4 + 32);
  v7[56] = *(_BYTE *)(a4 + 40);
  return v7;
}

void sub_10066A61C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

char **sub_10066A630(char **a1, uint64_t a2)
{
  uint64_t i;
  char *v5;
  char *v6;

  *a1 = (char *)a1;
  a1[1] = (char *)a1;
  a1[2] = 0;
  for (i = *(_QWORD *)(a2 + 8); i != a2; i = *(_QWORD *)(i + 8))
  {
    v5 = sub_10066A598((uint64_t)a1, 0, 0, i + 16);
    v6 = *a1;
    *(_QWORD *)v5 = *a1;
    *((_QWORD *)v5 + 1) = a1;
    *((_QWORD *)v6 + 1) = v5;
    *a1 = v5;
    ++a1[2];
  }
  return a1;
}

void sub_10066A6AC(_Unwind_Exception *a1)
{
  void **v1;

  sub_100668FCC(v1);
  _Unwind_Resume(a1);
}

void sub_10066A6C0(id a1)
{
  operator new();
}

void sub_10066A700()
{
  operator delete();
}

char *sub_10066A724(uint64_t a1, char *__src, char *a3)
{
  char *v3;
  char *v4;
  char *v6;
  unint64_t v7;
  uint64_t v8;
  char *v9;
  char *v10;
  _QWORD *v11;
  uint64_t v12;
  char *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  char *v20;
  unint64_t v21;
  unint64_t v22;
  char *v23;
  uint64_t v24;
  void *__p;
  char *v27;
  char *v28;
  char *v29;
  uint64_t v30;

  v3 = a3;
  v4 = __src;
  v6 = *(char **)(a1 + 8);
  v8 = a1 + 16;
  v7 = *(_QWORD *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    v13 = *(char **)a1;
    v14 = ((uint64_t)&v6[-*(_QWORD *)a1] >> 3) + 1;
    if (v14 >> 61)
      abort();
    v15 = __src - v13;
    v16 = (__src - v13) >> 3;
    v17 = v7 - (_QWORD)v13;
    if (v17 >> 2 > v14)
      v14 = v17 >> 2;
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8)
      v18 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v18 = v14;
    v30 = a1 + 16;
    if (v18)
      v19 = (char *)sub_10007ABA0(a1 + 16, v18);
    else
      v19 = 0;
    v20 = &v19[8 * v16];
    __p = v19;
    v27 = v20;
    v28 = v20;
    v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4)
          v22 = 1;
        else
          v22 = v15 >> 2;
        v23 = (char *)sub_10007ABA0(v8, v22);
        v20 = &v23[8 * (v22 >> 2)];
        __p = v23;
        v27 = v20;
        v29 = &v23[8 * v24];
        if (v19)
          operator delete(v19);
      }
      else
      {
        v21 = v16 + 2;
        if (v16 >= -1)
          v21 = v16 + 1;
        v20 -= 8 * (v21 >> 1);
        v27 = v20;
      }
    }
    *(_QWORD *)v20 = *(_QWORD *)v3;
    v28 = v20 + 8;
    v4 = sub_10007AADC((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27)
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8;
    if (__p)
      operator delete(__p);
  }
  else if (__src == v6)
  {
    *(_QWORD *)__src = *(_QWORD *)a3;
    *(_QWORD *)(a1 + 8) = __src + 8;
  }
  else
  {
    v9 = __src + 8;
    v10 = v6 - 8;
    v11 = *(_QWORD **)(a1 + 8);
    while (v10 < v6)
    {
      v12 = *(_QWORD *)v10;
      v10 += 8;
      *v11++ = v12;
    }
    *(_QWORD *)(a1 + 8) = v11;
    if (v6 != v9)
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    if (v4 <= v3)
      v3 += 8 * (*(_QWORD *)(a1 + 8) > (unint64_t)v3);
    *(_QWORD *)v4 = *(_QWORD *)v3;
  }
  return v4;
}

void sub_10066A928(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_10066A960(uint64_t result, uint64_t a2, uint64_t a3, float a4)
{
  *(float *)a3 = a4;
  *(_QWORD *)(a3 + 4) = result;
  *(_WORD *)(a3 + 12) = 2114;
  *(_QWORD *)(a3 + 14) = a2;
  return result;
}

void sub_10066A988(uint64_t a1@<X8>)
{
  uint64_t v1;

  *(_QWORD *)(v1 - 8) = a1;
}

void sub_10066A994()
{
  void **v0;

  operator delete(*v0);
}

void sub_10066A99C()
{
  uint64_t i;

  for (i = 0; i != -160; i -= 32)
  {
    if (*((char *)&unk_100993F58 + i + 151) < 0)
      operator delete(*(void **)((char *)&unk_100993F58 + i + 128));
  }
}

void sub_10066A9E0()
{
  void *v0;
  _QWORD *v1;

  v0 = objc_autoreleasePoolPush();
  v1 = sub_100091AE8(qword_100993F58, "CORSAIR HARPOON");
  *((_DWORD *)v1 + 6) = 454826846;
  sub_100091AE8(v1 + 4, "CORSAIR IRONCLAW");
  dword_100993F90 = 454826828;
  sub_100091AE8(qword_100993F98, "DARK CORE RGB PRO SE");
  dword_100993FB0 = 461249308;
  sub_100091AE8(qword_100993FB8, "DARK CORE RGB PRO");
  dword_100993FD0 = 454826880;
  sub_100091AE8(qword_100993FD8, "KATAR PRO Wireless");
  dword_100993FF0 = 454826926;
  __cxa_atexit((void (*)(void *))sub_10066A99C, 0, (void *)&_mh_execute_header);
  objc_autoreleasePoolPop(v0);
}

void sub_10066AACC(_Unwind_Exception *a1)
{
  _QWORD *v1;

  sub_100715EBC(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_10066AAE0(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  void *v4;
  std::string __p;

  *(_QWORD *)a1 = &off_10093F2C0;
  *(_QWORD *)(a1 + 8) = off_10093F2F8;
  *(_QWORD *)(a1 + 16) = &off_10093DCA0;
  *(_QWORD *)(a1 + 24) = &off_10093DCD0;
  *(_QWORD *)(a1 + 32) = &off_10093DD18;
  *(_QWORD *)(a1 + 40) = &off_10093DCE8;
  *(_QWORD *)(a1 + 48) = off_10093F360;
  v2 = (_QWORD *)(a1 + 56);
  sub_100091AE8(&__p, "LeObserver");
  sub_1004AF368(v2, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  *(_QWORD *)a1 = off_10093EA50;
  *(_QWORD *)(a1 + 8) = &off_10093EB48;
  *(_QWORD *)(a1 + 16) = off_10093EBB0;
  *(_QWORD *)(a1 + 24) = &off_10093EBE0;
  *(_QWORD *)(a1 + 32) = off_10093EBF8;
  *(_QWORD *)(a1 + 40) = &off_10093EC48;
  *(_QWORD *)(a1 + 48) = off_10093EC78;
  *(_QWORD *)(a1 + 56) = &off_10093ED28;
  *(_QWORD *)(a1 + 112) = &off_10093ED40;
  *(_QWORD *)(a1 + 120) = &off_10093ED58;
  *(_QWORD *)(a1 + 128) = off_10093ED70;
  *(_QWORD *)(a1 + 136) = &off_10093EDA0;
  *(_QWORD *)(a1 + 152) = 0;
  *(_BYTE *)(a1 + 1792) = 1;
  *(_OWORD *)(a1 + 1824) = 0u;
  *(_OWORD *)(a1 + 1800) = 0u;
  *(_QWORD *)(a1 + 1816) = a1 + 1824;
  *(_WORD *)(a1 + 1840) = 1;
  *(_BYTE *)(a1 + 1842) = 0;
  *(_DWORD *)(a1 + 1848) = -16777216;
  *(_BYTE *)(a1 + 1864) = 0;
  *(_DWORD *)(a1 + 1872) = 0;
  *(_OWORD *)(a1 + 1880) = 0u;
  *(_QWORD *)(a1 + 1928) = 0;
  *(_OWORD *)(a1 + 1912) = 0u;
  *(_OWORD *)(a1 + 1944) = 0u;
  *(_DWORD *)(a1 + 1852) = 0;
  *(_QWORD *)(a1 + 1896) = 0;
  *(_DWORD *)(a1 + 1904) = 0;
  *(_QWORD *)(a1 + 1936) = a1 + 1944;
  *(_QWORD *)(a1 + 1960) = 0;
  *(_OWORD *)(a1 + 2008) = 0u;
  *(_QWORD *)(a1 + 2000) = a1 + 2008;
  *(_OWORD *)(a1 + 2048) = 0u;
  *(_OWORD *)(a1 + 2024) = 0u;
  *(_QWORD *)(a1 + 2040) = a1 + 2048;
  *(_OWORD *)(a1 + 2072) = 0u;
  *(_QWORD *)(a1 + 2064) = a1 + 2072;
  *(_OWORD *)(a1 + 2088) = 0u;
  *(_BYTE *)(a1 + 2104) = 0;
  *(_OWORD *)(a1 + 2112) = 0u;
  *(_QWORD *)(a1 + 2128) = 300000;
  *(_BYTE *)(a1 + 2168) = 0;
  *(_OWORD *)(a1 + 2176) = 0u;
  *(_OWORD *)(a1 + 2192) = 0u;
  *(_OWORD *)(a1 + 2206) = 0u;
  *(_BYTE *)(a1 + 2244) = 1;
  *(_BYTE *)(a1 + 2247) = 0;
  *(_DWORD *)(a1 + 2292) = 0;
  *(_QWORD *)(a1 + 2344) = 0;
  *(_BYTE *)(a1 + 2352) = 0;
  *(_QWORD *)(a1 + 2272) = 0;
  *(_OWORD *)(a1 + 2256) = 0u;
  *(_QWORD *)(a1 + 3216) = 0x700000003;
  *(_BYTE *)(a1 + 3224) = 0;
  *(_BYTE *)(a1 + 3256) = 0;
  *(_QWORD *)(a1 + 3264) = 0;
  *(_BYTE *)(a1 + 4296) = 0;
  *(_OWORD *)(a1 + 4312) = 0u;
  *(_QWORD *)(a1 + 4304) = a1 + 4312;
  *(_OWORD *)(a1 + 4336) = 0u;
  *(_QWORD *)(a1 + 4328) = a1 + 4336;
  *(_BYTE *)(a1 + 4381) = 0;
  *(_QWORD *)(a1 + 4368) = 0;
  *(_OWORD *)(a1 + 4352) = 0u;
  *(_WORD *)(a1 + 4382) = 1;
  *(_BYTE *)(a1 + 4385) = 1;
  v3 = objc_claimAutoreleasedReturnValue(+[NSMutableSet set](NSMutableSet, "set"));
  v4 = *(void **)(a1 + 3264);
  *(_QWORD *)(a1 + 3264) = v3;

  return a1;
}

void sub_10066AD70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19)
{
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void **v24;
  uint64_t v25;
  uint64_t v26;
  void *v28;
  void *v29;

  sub_10001A82C(v20, *(_QWORD **)(v19 + 4336));
  sub_10001A82C(v25, *(_QWORD **)(v19 + 4312));

  sub_100091BF8((void ***)&a19);
  sub_100685ED0(v26, *(_QWORD **)(v19 + 2072));
  sub_10001A82C(v21, *(_QWORD **)(v19 + 2048));
  sub_100685E3C(v23, *(_QWORD **)(v19 + 2008));
  sub_10001A82C(v22, *(_QWORD **)(v19 + 1944));
  v28 = *(void **)(v19 + 1912);
  if (v28)
  {
    *(_QWORD *)(v19 + 1920) = v28;
    operator delete(v28);
  }
  v29 = *v24;
  if (*v24)
  {
    *(_QWORD *)(v19 + 1888) = v29;
    operator delete(v29);
  }
  sub_10001A82C(a11, *(_QWORD **)(v19 + 1824));

  sub_1004AF52C(a12);
  _Unwind_Resume(a1);
}

void sub_10066AE64(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  NSObject *v10;
  int v11;
  uint64_t v12;
  int v13;
  NSObject *v14;
  uint64_t v15;
  int v16;
  int v17;
  NSObject *v18;
  int i;
  uint64_t **v20;
  NSObject *v21;
  uint64_t v22;
  int v23;
  int v24;
  uint64_t v25;
  NSObject *v26;
  uint64_t v27;
  int v28;
  NSObject *v29;
  uint64_t v30;
  int v31;
  int v32;
  unsigned int v33;
  NSObject *v34;
  uint64_t v35;
  int v36;
  int v37;
  unsigned int v38;
  NSObject *v39;
  uint64_t v40;
  int v41;
  int v42;
  unsigned int v43;
  NSObject *v44;
  uint64_t v45;
  unsigned __int8 *v46;
  int v47;
  NSObject *v48;
  uint64_t v49;
  int v50;
  int v51;
  unsigned int v52;
  NSObject *v53;
  uint64_t v54;
  int v55;
  NSObject *v56;
  uint64_t v57;
  int v58;
  NSObject *v59;
  uint64_t v60;
  int v61;
  NSObject *v62;
  const char *v63;
  uint64_t v64;
  int v65;
  unsigned int v66;
  NSObject *v67;
  const char *v68;
  uint64_t v69;
  int v70;
  unsigned int v71;
  NSObject *v72;
  const char *v73;
  NSObject *v74;
  unsigned int v75;
  unsigned int v76;
  unsigned int v77;
  int v78;
  unsigned int v79;
  double v80;
  double v81;
  const char *v82;
  int v83;
  const char *v84;
  int v85;
  uint64_t v86;
  int v87;
  int v88;
  NSObject *v89;
  uint64_t v90;
  int *v91;
  int v92;
  NSObject *v93;
  int v94;
  uint64_t v95;
  int v96;
  NSObject *v97;
  uint64_t v98;
  int v99;
  NSObject *v100;
  uint64_t v101;
  int v102;
  NSObject *v103;
  uint64_t v104;
  int v105;
  int v106;
  NSObject *v107;
  uint64_t v108;
  int v109;
  int v110;
  NSObject *v111;
  uint64_t v112;
  int v113;
  int v114;
  NSObject *v115;
  uint64_t v116;
  unsigned __int8 *v117;
  int v118;
  uint64_t v119;
  NSObject *v120;
  int v121;
  int v122;
  uint64_t v123;
  int v124;
  NSObject *v125;
  uint64_t v126;
  void *v127;
  uint64_t v128;
  void *v129;
  uint64_t v130;
  void *v131;
  uint64_t v132;
  void *v133;
  unsigned __int8 *v134;
  char v135;
  unsigned int v136;
  unsigned __int8 v137[15];
  char v138;
  void *__p[2];
  char v140;
  _BYTE buf[20];
  _BYTE v142[6];
  _BYTE v143[6];
  int v144;
  __int16 v145;
  unsigned int v146;
  __int16 v147;
  double v148;
  __int16 v149;
  double v150;
  __int16 v151;
  double v152;
  __int16 v153;
  double v154;
  __int16 v155;
  const char *v156;
  __int16 v157;
  const char *v158;
  __int16 v159;
  int v160;
  __int16 v161;
  int v162;

  if (qword_100978170 != -1)
    dispatch_once(&qword_100978170, &stru_10093F458);
  sub_1005AE2E8((uint64_t)off_100978168 + 192, a1);
  if (qword_100977A58 != -1)
    dispatch_once(&qword_100977A58, &stru_10093F478);
  sub_1002609C8((uint64_t)off_100977A50 + 64, a1 + 16);
  if (qword_100977B40 != -1)
    dispatch_once(&qword_100977B40, &stru_10093F498);
  sub_1004B983C((uint64_t)off_100977B38, a1 + 32);
  if (qword_1009778A8 != -1)
    dispatch_once(&qword_1009778A8, &stru_10093F4B8);
  sub_10061F358((uint64_t)off_1009778A0, a1 + 48, 0);
  if (qword_100977FD0 != -1)
    dispatch_once(&qword_100977FD0, &stru_10093F4D8);
  sub_10039CBB0(qword_100977FC8, a1 + 128);
  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_10093F4F8);
  sub_100668DE4((uint64_t)off_1009778C0, a1 + 136);
  v2 = sub_100038E50();
  sub_10066905C(v2 + 1128, a1 + 120);
  v3 = sub_100038E50();
  sub_10066934C(v3 + 1088, a1 + 112);
  v4 = sub_10003BE44();
  if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 408))(v4) & 1) == 0)
  {
    v5 = sub_100038E50();
    sub_10043B4A8(v5 + 728, a1 + 24);
  }
  v6 = sub_100038E50();
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v6 + 152))(v6, a1 + 144);
  v7 = sub_100027F68();
  *(_BYTE *)(a1 + 2168) = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v7 + 784))(v7, a1 + 2176);
  v8 = sub_100027F68();
  sub_100091AE8(buf, "LE");
  sub_100091AE8(__p, "EnableScanAgentPrints");
  v134 = (unsigned __int8 *)(a1 + 4381);
  v9 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, uint64_t))(*(_QWORD *)v8 + 72))(v8, buf, __p, a1 + 4385);
  if (v140 < 0)
    operator delete(__p[0]);
  if ((v142[3] & 0x80000000) != 0)
  {
    operator delete(*(void **)buf);
    if (!v9)
      goto LABEL_23;
  }
  else if (!v9)
  {
    goto LABEL_23;
  }
  v10 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    v11 = *(unsigned __int8 *)(a1 + 4385);
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v11;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "fEnableDebugScanAgent is now %d", buf, 8u);
  }
LABEL_23:
  v12 = sub_100027F68();
  sub_100091AE8(buf, "ADVBUFF");
  sub_100091AE8(__p, "UseDebugTypes");
  if ((*(unsigned int (**)(uint64_t, _BYTE *, void **, uint64_t))(*(_QWORD *)v12 + 72))(v12, buf, __p, a1 + 2104))
  {
    v13 = *(unsigned __int8 *)(a1 + 2104);
    if (v140 < 0)
      operator delete(__p[0]);
    if ((v142[3] & 0x80000000) != 0)
      operator delete(*(void **)buf);
    if (v13)
    {
      v14 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Warning: Using debug types for ADV buffer", buf, 2u);
      }
    }
  }
  else
  {
    if (v140 < 0)
      operator delete(__p[0]);
    if ((v142[3] & 0x80000000) != 0)
      operator delete(*(void **)buf);
  }
  v138 = 0;
  v15 = sub_100027F68();
  sub_100091AE8(buf, "ADVBUFF");
  sub_100091AE8(__p, "DisableENADVBuffers");
  v16 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, char *))(*(_QWORD *)v15 + 72))(v15, buf, __p, &v138);
  if (v138)
    v17 = v16;
  else
    v17 = 0;
  if (v140 < 0)
    operator delete(__p[0]);
  if ((v142[3] & 0x80000000) != 0)
  {
    operator delete(*(void **)buf);
    if (!v17)
      goto LABEL_46;
  }
  else if (!v17)
  {
    goto LABEL_46;
  }
  *(_BYTE *)(a1 + 1792) = 0;
  v18 = qword_100999948;
  if (os_log_type_enabled((os_log_t)qword_100999948, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Disabling EN ADV Buffers for this platform", buf, 2u);
  }
LABEL_46:
  for (i = 256; i != 262; ++i)
  {
    v137[0] = i;
    *(_QWORD *)buf = v137;
    v20 = sub_10000DB5C((uint64_t **)(a1 + 1816), v137, (uint64_t)&unk_100740F58, (char **)buf);
    *((_WORD *)v20 + 14) = 255;
    *((_WORD *)v20 + 15) = i;
    v20[4] = 0;
    v21 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 67110144;
      *(_DWORD *)&buf[4] = i;
      *(_WORD *)&buf[8] = 1024;
      *(_DWORD *)&buf[10] = 255;
      *(_WORD *)&buf[14] = 1024;
      *(_DWORD *)&buf[16] = 0;
      *(_WORD *)v142 = 1024;
      *(_DWORD *)&v142[2] = 0;
      *(_WORD *)v143 = 1024;
      *(_DWORD *)&v143[2] = 0;
      _os_log_debug_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEBUG, "MATCH TABLE Setting up table entry handle:%d type:%d length:%d created:%d enabled:%d", buf, 0x20u);
    }
  }
  *(_QWORD *)v137 = 0;
  v22 = sub_100027F68();
  sub_100091AE8(buf, "ADVBUFF");
  sub_100091AE8(__p, "OverrideAPWakeDebounceTimerSeconds");
  v23 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, unsigned __int8 *))(*(_QWORD *)v22 + 144))(v22, buf, __p, v137);
  if (*(_QWORD *)v137)
    v24 = v23;
  else
    v24 = 0;
  if (v140 < 0)
    operator delete(__p[0]);
  if ((v142[3] & 0x80000000) != 0)
  {
    operator delete(*(void **)buf);
    if (!v24)
      goto LABEL_61;
  }
  else if (!v24)
  {
    goto LABEL_61;
  }
  v25 = 1000 * *(_QWORD *)v137;
  *(_QWORD *)(a1 + 2128) = 1000 * *(_QWORD *)v137;
  v26 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    *(_QWORD *)&buf[4] = v25;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Warning: Overriding fApWakeReadADVBuffersDebounceDelta with %llu seconds", buf, 0xCu);
  }
LABEL_61:
  *(_BYTE *)(a1 + 2222) = 0;
  *(_OWORD *)(a1 + 2136) = 0u;
  *(_OWORD *)(a1 + 2152) = 0u;
  v136 = 0;
  *(_WORD *)(a1 + 2232) = 0;
  *(_BYTE *)(a1 + 2234) = 0;
  *(_DWORD *)(a1 + 2224) = 0;
  *(_DWORD *)(a1 + 2227) = 0;
  v27 = sub_100027F68();
  sub_100091AE8(buf, "BLESCAN");
  sub_100091AE8(__p, "IsScanParamsOverriden");
  if ((*(unsigned int (**)(uint64_t, _BYTE *, void **, uint64_t))(*(_QWORD *)v27 + 72))(v27, buf, __p, a1 + 2222))
  {
    v28 = *(unsigned __int8 *)(a1 + 2222);
    if (v140 < 0)
      operator delete(__p[0]);
    if ((v142[3] & 0x80000000) != 0)
    {
      operator delete(*(void **)buf);
      if (!v28)
        goto LABEL_191;
    }
    else if (!v28)
    {
      goto LABEL_191;
    }
    v29 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "Overriding BLE Scan Parameters.", buf, 2u);
    }
    v30 = sub_100027F68();
    sub_100091AE8(buf, "BLESCAN");
    sub_100091AE8(__p, "Interval");
    v31 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, unsigned int *))(*(_QWORD *)v30 + 88))(v30, buf, __p, &v136);
    if (v136)
      v32 = v31;
    else
      v32 = 0;
    if (v140 < 0)
      operator delete(__p[0]);
    if ((v142[3] & 0x80000000) != 0)
      operator delete(*(void **)buf);
    if (v32)
    {
      v33 = v136;
      *(_WORD *)(a1 + 2224) = v136;
      v34 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v33;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "Overriding BLE Scan Parameters Interval %d.", buf, 8u);
      }
    }
    v35 = sub_100027F68();
    sub_100091AE8(buf, "BLESCAN");
    sub_100091AE8(__p, "WindowMainCoreELNAOn");
    v36 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, unsigned int *))(*(_QWORD *)v35 + 88))(v35, buf, __p, &v136);
    if (v136)
      v37 = v36;
    else
      v37 = 0;
    if (v140 < 0)
      operator delete(__p[0]);
    if ((v142[3] & 0x80000000) != 0)
      operator delete(*(void **)buf);
    if (v37)
    {
      v38 = v136;
      *(_WORD *)(a1 + 2226) = v136;
      v39 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v38;
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "Overriding BLE Scan Parameters WindowMainCoreELNAOn %d.", buf, 8u);
      }
    }
    v40 = sub_100027F68();
    sub_100091AE8(buf, "BLESCAN");
    sub_100091AE8(__p, "WindowMainCoreELNABypass");
    v41 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, unsigned int *))(*(_QWORD *)v40 + 88))(v40, buf, __p, &v136);
    if (v136)
      v42 = v41;
    else
      v42 = 0;
    if (v140 < 0)
      operator delete(__p[0]);
    if ((v142[3] & 0x80000000) != 0)
      operator delete(*(void **)buf);
    if (v42)
    {
      v43 = v136;
      *(_WORD *)(a1 + 2228) = v136;
      v44 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v43;
        _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "Overriding BLE Scan Parameters WindowMainCoreELNABypass %d.", buf, 8u);
      }
    }
    v45 = sub_100027F68();
    sub_100091AE8(buf, "BLESCAN");
    sub_100091AE8(__p, "IsScanCoreELNAOn");
    v46 = (unsigned __int8 *)(a1 + 2230);
    if ((*(unsigned int (**)(uint64_t, _BYTE *, void **, uint64_t))(*(_QWORD *)v45 + 72))(v45, buf, __p, a1 + 2230))
    {
      v47 = *v46;
      if (v140 < 0)
        operator delete(__p[0]);
      if ((v142[3] & 0x80000000) != 0)
        operator delete(*(void **)buf);
      if (v47)
      {
        v48 = qword_100999828;
        if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "Overriding BLE Scan Parameters ScanCore ELNA is On", buf, 2u);
        }
      }
    }
    else
    {
      if (v140 < 0)
        operator delete(__p[0]);
      if ((v142[3] & 0x80000000) != 0)
        operator delete(*(void **)buf);
    }
    v49 = sub_100027F68();
    sub_100091AE8(buf, "BLESCAN");
    sub_100091AE8(__p, "WindowScanCore");
    v50 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, unsigned int *))(*(_QWORD *)v49 + 88))(v49, buf, __p, &v136);
    if (v136)
      v51 = v50;
    else
      v51 = 0;
    if (v140 < 0)
      operator delete(__p[0]);
    if ((v142[3] & 0x80000000) != 0)
      operator delete(*(void **)buf);
    if (v51)
    {
      v52 = v136;
      *(_WORD *)(a1 + 2232) = v136;
      v53 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v52;
        _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "Overriding BLE Scan Parameters WindowScancore %d", buf, 8u);
      }
    }
    v54 = sub_100027F68();
    sub_100091AE8(buf, "BLESCAN");
    sub_100091AE8(__p, "IsScanCoreELNAOn");
    if ((*(unsigned int (**)(uint64_t, _BYTE *, void **, uint64_t))(*(_QWORD *)v54 + 72))(v54, buf, __p, a1 + 2230))
    {
      v55 = *v46;
      if (v140 < 0)
        operator delete(__p[0]);
      if ((v142[3] & 0x80000000) != 0)
        operator delete(*(void **)buf);
      if (v55)
      {
        v56 = qword_100999828;
        if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "Overriding BLE Scan Parameters ScanCore ELNA is On", buf, 2u);
        }
      }
    }
    else
    {
      if (v140 < 0)
        operator delete(__p[0]);
      if ((v142[3] & 0x80000000) != 0)
        operator delete(*(void **)buf);
    }
    v57 = sub_100027F68();
    sub_100091AE8(buf, "BLESCAN");
    sub_100091AE8(__p, "IsScanCoreConcurrent");
    if ((*(unsigned int (**)(uint64_t, _BYTE *, void **, uint64_t))(*(_QWORD *)v57 + 72))(v57, buf, __p, a1 + 2234))
    {
      v58 = *(unsigned __int8 *)(a1 + 2234);
      if (v140 < 0)
        operator delete(__p[0]);
      if ((v142[3] & 0x80000000) != 0)
        operator delete(*(void **)buf);
      if (v58)
      {
        v59 = qword_100999828;
        if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "Overriding BLE Scan Parameters ScanCore Concurrent", buf, 2u);
        }
      }
    }
    else
    {
      if (v140 < 0)
        operator delete(__p[0]);
      if ((v142[3] & 0x80000000) != 0)
        operator delete(*(void **)buf);
    }
    *(_BYTE *)(a1 + 2235) = 0;
    v60 = sub_100027F68();
    sub_100091AE8(buf, "BLESCAN");
    sub_100091AE8(__p, "IsScanCoreCompensated");
    v61 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, uint64_t))(*(_QWORD *)v60 + 72))(v60, buf, __p, a1 + 2238);
    if (v140 < 0)
      operator delete(__p[0]);
    if ((v142[3] & 0x80000000) != 0)
      operator delete(*(void **)buf);
    if (v61)
    {
      *(_BYTE *)(a1 + 2235) = 1;
      v62 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
      {
        if (*(_BYTE *)(a1 + 2238))
          v63 = "Yes";
        else
          v63 = "No";
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = v63;
        _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "Overriding BLE Scan Parameters ScanCore Compensated: %{public}s", buf, 0xCu);
      }
    }
    *(_BYTE *)(a1 + 2236) = 0;
    v64 = sub_100027F68();
    sub_100091AE8(buf, "BLESCAN");
    sub_100091AE8(__p, "ScanCoreCompensationPercent");
    v65 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, unsigned int *))(*(_QWORD *)v64 + 88))(v64, buf, __p, &v136);
    if (v140 < 0)
      operator delete(__p[0]);
    if ((v142[3] & 0x80000000) != 0)
      operator delete(*(void **)buf);
    if (v65)
    {
      v66 = v136;
      if (v136 > 0x64)
      {
        v67 = qword_100999828;
        if (!os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
          goto LABEL_171;
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v66;
        v68 = "Overriding BLE ScanCore Compensation Percent %d failed (0<= ScanCoreCompensationPercent <=100)";
      }
      else
      {
        *(_BYTE *)(a1 + 2236) = 1;
        *(_WORD *)(a1 + 2240) = v66;
        v67 = qword_100999828;
        if (!os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
          goto LABEL_171;
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v66;
        v68 = "Overriding BLE ScanCore Compensation Percent %d";
      }
      _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, v68, buf, 8u);
    }
LABEL_171:
    *(_BYTE *)(a1 + 2237) = 0;
    v69 = sub_100027F68();
    sub_100091AE8(buf, "BLESCAN");
    sub_100091AE8(__p, "ScanCoreCoexQueryPeriod");
    v70 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, unsigned int *))(*(_QWORD *)v69 + 88))(v69, buf, __p, &v136);
    if (v140 < 0)
      operator delete(__p[0]);
    if ((v142[3] & 0x80000000) != 0)
      operator delete(*(void **)buf);
    if (!v70)
      goto LABEL_181;
    v71 = v136;
    if (v136 > 4 || v136 == 3)
    {
      v72 = qword_100999828;
      if (!os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
      {
LABEL_181:
        v74 = qword_100999828;
        if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
        {
          v75 = *(unsigned __int16 *)(a1 + 2224);
          v76 = *(unsigned __int16 *)(a1 + 2226);
          v77 = *(unsigned __int16 *)(a1 + 2228);
          v78 = *(unsigned __int8 *)(a1 + 2230);
          v79 = *(unsigned __int16 *)(a1 + 2232);
          v80 = (double)v79 * 0.625;
          if (*(_BYTE *)(a1 + 2230))
          {
            v81 = (double)v79 * 0.625;
            v78 = *(unsigned __int16 *)(a1 + 2232);
            v80 = 0.0;
            v79 = 0;
          }
          else
          {
            v81 = 0.0;
          }
          v82 = "Yes";
          v83 = *(unsigned __int16 *)(a1 + 2240);
          if (*(_BYTE *)(a1 + 2234))
            v84 = "Yes";
          else
            v84 = "No";
          v85 = *(unsigned __int16 *)(a1 + 2242);
          if (!*(_BYTE *)(a1 + 2235))
            v82 = "No";
          *(_DWORD *)buf = 67112450;
          *(_DWORD *)&buf[4] = v75;
          *(_WORD *)&buf[8] = 2048;
          *(double *)&buf[10] = (double)v75 * 0.625;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)v142 = v76;
          *(_WORD *)&v142[4] = 1024;
          *(_DWORD *)v143 = v77;
          *(_WORD *)&v143[4] = 1024;
          v144 = v78;
          v145 = 1024;
          v146 = v79;
          v147 = 2048;
          v148 = (double)v76 * 0.625;
          v149 = 2048;
          v150 = (double)v77 * 0.625;
          v151 = 2048;
          v152 = v81;
          v153 = 2048;
          v154 = v80;
          v155 = 2082;
          v156 = v84;
          v157 = 2082;
          v158 = v82;
          v159 = 1024;
          v160 = v83;
          v161 = 1024;
          v162 = v85;
          _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "Overriding BLE Scan Parameters Interval %d(%.2fms) Window %d/%d/%d/%d(%.2fms/%.2fms/%.2fms/%.2fms) Concurrent %{public}s Compensation %{public}s percent %d period %d", buf, 0x72u);
        }
        goto LABEL_191;
      }
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v71;
      v73 = "Overriding BLE ScanCore Query Period %d failed (period must be in {0, 1, 2, 4}";
    }
    else
    {
      *(_BYTE *)(a1 + 2237) = 1;
      *(_WORD *)(a1 + 2242) = v71;
      v72 = qword_100999828;
      if (!os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
        goto LABEL_181;
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v71;
      v73 = "Overriding BLE ScanCore Query Period %d";
    }
    _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, v73, buf, 8u);
    goto LABEL_181;
  }
  if (v140 < 0)
    operator delete(__p[0]);
  if ((v142[3] & 0x80000000) != 0)
    operator delete(*(void **)buf);
LABEL_191:
  v135 = 0;
  v86 = sub_100027F68();
  sub_100091AE8(buf, "BLESCAN");
  sub_100091AE8(__p, "IsScanCompensationDisabled");
  v87 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, char *))(*(_QWORD *)v86 + 72))(v86, buf, __p, &v135);
  if (v135)
    v88 = v87;
  else
    v88 = 0;
  if (v140 < 0)
    operator delete(__p[0]);
  if ((v142[3] & 0x80000000) != 0)
  {
    operator delete(*(void **)buf);
    if (!v88)
      goto LABEL_203;
  }
  else if (!v88)
  {
    goto LABEL_203;
  }
  v89 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_DEFAULT, "Disable ScanCore Compensation", buf, 2u);
  }
  *(_BYTE *)(a1 + 2244) = 0;
LABEL_203:
  v90 = sub_100027F68();
  sub_100091AE8(buf, "BLESCAN");
  sub_100091AE8(__p, "ApplyRSSIOffset");
  v91 = (int *)(a1 + 2292);
  if (!(*(unsigned int (**)(uint64_t, _BYTE *, void **, uint64_t))(*(_QWORD *)v90 + 88))(v90, buf, __p, a1 + 2292)|| (v92 = *v91) == 0|| v92 > 127)
  {
    if (v140 < 0)
      operator delete(__p[0]);
    if ((v142[3] & 0x80000000) != 0)
      operator delete(*(void **)buf);
    goto LABEL_217;
  }
  if (v140 < 0)
    operator delete(__p[0]);
  if ((v142[3] & 0x80000000) != 0)
    operator delete(*(void **)buf);
  if (v92 < -128)
  {
LABEL_217:
    *v91 = 0;
    goto LABEL_218;
  }
  v93 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    v94 = *v91;
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v94;
    _os_log_impl((void *)&_mh_execute_header, v93, OS_LOG_TYPE_DEFAULT, "Warning: Applying RSSI offset of %d", buf, 8u);
  }
LABEL_218:
  *(_BYTE *)(a1 + 2245) = 0;
  v95 = sub_100027F68();
  sub_100091AE8(buf, "BLESCAN");
  sub_100091AE8(__p, "IsScanCoreDebug");
  if ((*(unsigned int (**)(uint64_t, _BYTE *, void **, uint64_t))(*(_QWORD *)v95 + 72))(v95, buf, __p, a1 + 2245))
  {
    v96 = *(unsigned __int8 *)(a1 + 2245);
    if (v140 < 0)
      operator delete(__p[0]);
    if ((v142[3] & 0x80000000) != 0)
      operator delete(*(void **)buf);
    if (v96)
    {
      v97 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v97, OS_LOG_TYPE_DEFAULT, "Enabling ScanCore Debug prints", buf, 2u);
      }
    }
  }
  else
  {
    if (v140 < 0)
      operator delete(__p[0]);
    if ((v142[3] & 0x80000000) != 0)
      operator delete(*(void **)buf);
  }
  xpc_set_event_stream_handler("com.apple.alarm", 0, &stru_10093EDD0);
  v98 = sub_100027F68();
  sub_100091AE8(buf, "SCANDEBUG");
  sub_100091AE8(__p, "DebugControllerConfigDispatchSequence");
  if ((*(unsigned int (**)(uint64_t, _BYTE *, void **, unsigned __int8 *))(*(_QWORD *)v98 + 72))(v98, buf, __p, v134))
  {
    v99 = *v134;
    if (v140 < 0)
      operator delete(__p[0]);
    if ((v142[3] & 0x80000000) != 0)
      operator delete(*(void **)buf);
    if (v99)
    {
      v100 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_DEFAULT, "fDebugControllerConfigDispatchSequence is true, dispatching config after serial config", buf, 2u);
      }
    }
  }
  else
  {
    if (v140 < 0)
      operator delete(__p[0]);
    if ((v142[3] & 0x80000000) != 0)
      operator delete(*(void **)buf);
  }
  v101 = sub_100027F68();
  sub_100091AE8(buf, "SCANDEBUG");
  sub_100091AE8(__p, "ForceDispatchInsteadOfSerialConfig");
  if ((*(unsigned int (**)(uint64_t, _BYTE *, void **, uint64_t))(*(_QWORD *)v101 + 72))(v101, buf, __p, a1 + 4382))
  {
    v102 = *(unsigned __int8 *)(a1 + 4382);
    if (v140 < 0)
      operator delete(__p[0]);
    if ((v142[3] & 0x80000000) != 0)
    {
      operator delete(*(void **)buf);
      if (v102)
        goto LABEL_255;
    }
    else if (v102)
    {
      goto LABEL_255;
    }
    v103 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v103, OS_LOG_TYPE_DEFAULT, "fForceDispatchInsteadOfSerialConfig is false, Forcing disable dispatch config", buf, 2u);
    }
  }
  else
  {
    if (v140 < 0)
      operator delete(__p[0]);
    if ((v142[3] & 0x80000000) != 0)
      operator delete(*(void **)buf);
  }
LABEL_255:
  v104 = sub_100027F68();
  sub_100091AE8(buf, "SCANDEBUG");
  sub_100091AE8(__p, "DebugScanConfigSequence");
  v105 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, char *))(*(_QWORD *)v104 + 72))(v104, buf, __p, &byte_1009940AC);
  if (byte_1009940AC)
    v106 = v105;
  else
    v106 = 0;
  if (v140 < 0)
    operator delete(__p[0]);
  if ((v142[3] & 0x80000000) != 0)
  {
    operator delete(*(void **)buf);
    if (!v106)
      goto LABEL_266;
  }
  else if (!v106)
  {
    goto LABEL_266;
  }
  v107 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v107, OS_LOG_TYPE_DEFAULT, "gSniffScanDebug is true", buf, 2u);
  }
LABEL_266:
  v108 = sub_100027F68();
  sub_100091AE8(buf, "BLESCAN");
  sub_100091AE8(__p, "DisablePrioritizationOverBT");
  v109 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, char *))(*(_QWORD *)v108 + 72))(v108, buf, __p, &byte_1009940AD);
  if (byte_1009940AD)
    v110 = v109;
  else
    v110 = 0;
  if (v140 < 0)
    operator delete(__p[0]);
  if ((v142[3] & 0x80000000) != 0)
  {
    operator delete(*(void **)buf);
    if (!v110)
      goto LABEL_277;
  }
  else if (!v110)
  {
    goto LABEL_277;
  }
  v111 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_DEFAULT, "Disable Scan Prioritization over BT.", buf, 2u);
  }
LABEL_277:
  v112 = sub_100027F68();
  sub_100091AE8(buf, "BLESCAN");
  sub_100091AE8(__p, "PrioritizationOverWiFiEnabled");
  v113 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, char *))(*(_QWORD *)v112 + 72))(v112, buf, __p, &byte_1009940AE);
  if (byte_1009940AE)
    v114 = v113;
  else
    v114 = 0;
  if (v140 < 0)
    operator delete(__p[0]);
  if ((v142[3] & 0x80000000) != 0)
  {
    operator delete(*(void **)buf);
    if (!v114)
      goto LABEL_288;
  }
  else if (!v114)
  {
    goto LABEL_288;
  }
  v115 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v115, OS_LOG_TYPE_DEFAULT, "Scan Prioritization over WiFi is supported.", buf, 2u);
  }
LABEL_288:
  *(_WORD *)(a1 + 2246) = 0;
  v116 = sub_100027F68();
  sub_100091AE8(buf, "BLESCAN");
  sub_100091AE8(__p, "forcePassiveScan");
  v117 = (unsigned __int8 *)(a1 + 2246);
  if ((*(unsigned int (**)(uint64_t, _BYTE *, void **, uint64_t))(*(_QWORD *)v116 + 72))(v116, buf, __p, a1 + 2246))
  {
    v118 = *v117;
    if (v140 < 0)
      operator delete(__p[0]);
    if ((v142[3] & 0x80000000) != 0)
    {
      operator delete(*(void **)buf);
      if (!v118)
        goto LABEL_305;
    }
    else if (!v118)
    {
      goto LABEL_305;
    }
    v119 = sub_100027F68();
    sub_100091AE8(buf, "BLESCAN");
    sub_100091AE8(__p, "forcePassiveScanEnable");
    (*(void (**)(uint64_t, _BYTE *, void **, uint64_t))(*(_QWORD *)v119 + 72))(v119, buf, __p, a1 + 2247);
    if (v140 < 0)
      operator delete(__p[0]);
    if ((v142[3] & 0x80000000) != 0)
      operator delete(*(void **)buf);
    v120 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      v121 = *v117;
      v122 = *(unsigned __int8 *)(a1 + 2247);
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)&buf[4] = v121;
      *(_WORD *)&buf[8] = 1024;
      *(_DWORD *)&buf[10] = v122;
      _os_log_impl((void *)&_mh_execute_header, v120, OS_LOG_TYPE_DEFAULT, "Overriding BLE Scan Parameters to force passive scan to %d force to : %d", buf, 0xEu);
    }
  }
  else
  {
    if (v140 < 0)
      operator delete(__p[0]);
    if ((v142[3] & 0x80000000) != 0)
      operator delete(*(void **)buf);
  }
LABEL_305:
  *(_BYTE *)(a1 + 2248) = 0;
  v123 = sub_100027F68();
  sub_100091AE8(buf, "BLESCAN");
  sub_100091AE8(__p, "enableMatchingRuleAndAddressBatched");
  if ((*(unsigned int (**)(uint64_t, _BYTE *, void **, uint64_t))(*(_QWORD *)v123 + 72))(v123, buf, __p, a1 + 2248))
  {
    v124 = *(unsigned __int8 *)(a1 + 2248);
    if (v140 < 0)
      operator delete(__p[0]);
    if ((v142[3] & 0x80000000) != 0)
      operator delete(*(void **)buf);
    if (v124)
    {
      v125 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v125, OS_LOG_TYPE_DEFAULT, "Overriding BLE Scan Parameters to enable matching rules batched", buf, 2u);
      }
    }
  }
  else
  {
    if (v140 < 0)
      operator delete(__p[0]);
    if ((v142[3] & 0x80000000) != 0)
      operator delete(*(void **)buf);
  }
  *(_OWORD *)(a1 + 2312) = 0u;
  *(_OWORD *)(a1 + 2328) = 0u;
  *(_OWORD *)(a1 + 2296) = 0u;
  *(_QWORD *)(a1 + 2280) = 0;
  *(_QWORD *)(a1 + 2712) = 0;
  *(_DWORD *)(a1 + 2719) = 0;
  sub_10066CC24(a1);
  sub_10066CD14(a1);
  *(_QWORD *)(a1 + 3208) = 0;
  sub_10066CDC8(a1);
  sub_10066CE44(a1);
  sub_10066CFF0(a1);
  v126 = objc_claimAutoreleasedReturnValue(+[NSMutableArray array](NSMutableArray, "array"));
  v127 = *(void **)(a1 + 4352);
  *(_QWORD *)(a1 + 4352) = v126;

  v128 = objc_claimAutoreleasedReturnValue(+[NSMutableArray array](NSMutableArray, "array"));
  v129 = *(void **)(a1 + 4360);
  *(_QWORD *)(a1 + 4360) = v128;

  v130 = objc_claimAutoreleasedReturnValue(+[NSMutableArray array](NSMutableArray, "array"));
  v131 = *(void **)(a1 + 4368);
  *(_QWORD *)(a1 + 4368) = v130;

  v132 = objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary"));
  v133 = *(void **)(a1 + 2088);
  *(_QWORD *)(a1 + 2088) = v132;

}

void sub_10066C9F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a21 < 0)
    operator delete(__p);
  if (a27 < 0)
    operator delete(a22);
  _Unwind_Resume(exception_object);
}

void sub_10066CAF4(id a1, void *a2)
{
  const char *string;
  NSObject *v3;
  void *v4;
  int v5;
  void *v6;
  __int16 v7;
  const char *v8;

  string = xpc_dictionary_get_string(a2, _xpc_event_key_name);
  xpc_set_event("com.apple.alarm", string, 0);
  v3 = qword_100999948;
  if (os_log_type_enabled((os_log_t)qword_100999948, OS_LOG_TYPE_DEFAULT))
  {
    v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate date](NSDate, "date"));
    v5 = 138412546;
    v6 = v4;
    v7 = 2082;
    v8 = string;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "com.apple.alarm xpc event handler at %@ for %{public}s", (uint8_t *)&v5, 0x16u);

  }
  if (qword_10097B180 != -1)
    dispatch_once(&qword_10097B180, &stru_10093F518);
  ++*((_WORD *)off_10097B178 + 117);
}

void sub_10066CC24(uint64_t a1)
{
  NSObject *v2;
  uint8_t v3[16];

  v2 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Reset BLE Scan Configuration Stat", v3, 2u);
  }
  *(_OWORD *)(a1 + 2680) = 0u;
  *(_OWORD *)(a1 + 2696) = 0u;
  *(_OWORD *)(a1 + 2648) = 0u;
  *(_OWORD *)(a1 + 2664) = 0u;
  *(_OWORD *)(a1 + 2616) = 0u;
  *(_OWORD *)(a1 + 2632) = 0u;
  *(_OWORD *)(a1 + 2584) = 0u;
  *(_OWORD *)(a1 + 2600) = 0u;
  *(_OWORD *)(a1 + 2552) = 0u;
  *(_OWORD *)(a1 + 2568) = 0u;
  *(_OWORD *)(a1 + 2520) = 0u;
  *(_OWORD *)(a1 + 2536) = 0u;
  *(_OWORD *)(a1 + 2488) = 0u;
  *(_OWORD *)(a1 + 2504) = 0u;
  *(_OWORD *)(a1 + 2456) = 0u;
  *(_OWORD *)(a1 + 2472) = 0u;
  *(_OWORD *)(a1 + 2424) = 0u;
  *(_OWORD *)(a1 + 2440) = 0u;
  *(_OWORD *)(a1 + 2392) = 0u;
  *(_OWORD *)(a1 + 2408) = 0u;
  *(_OWORD *)(a1 + 2360) = 0u;
  *(_OWORD *)(a1 + 2376) = 0u;
  *(_DWORD *)(a1 + 2492) = 0xFFFF;
  *(CFAbsoluteTime *)(a1 + 2360) = CFAbsoluteTimeGetCurrent();
  *(_OWORD *)(a1 + 2536) = 0u;
  *(_OWORD *)(a1 + 2552) = 0u;
  *(_OWORD *)(a1 + 2568) = 0u;
  *(_OWORD *)(a1 + 2584) = 0u;
  *(_OWORD *)(a1 + 2600) = 0u;
  *(_OWORD *)(a1 + 2616) = 0u;
  *(_OWORD *)(a1 + 2632) = 0u;
  *(_OWORD *)(a1 + 2648) = 0u;
  *(_OWORD *)(a1 + 2664) = 0u;
  *(_OWORD *)(a1 + 2680) = 0u;
  *(_OWORD *)(a1 + 2696) = 0u;
  *(_OWORD *)(a1 + 2712) = 0u;
  *(_OWORD *)(a1 + 2728) = 0u;
  *(_OWORD *)(a1 + 2744) = 0u;
  *(_OWORD *)(a1 + 2760) = 0u;
  *(_OWORD *)(a1 + 2776) = 0u;
  *(_OWORD *)(a1 + 2792) = 0u;
  *(_OWORD *)(a1 + 2808) = 0u;
  *(_OWORD *)(a1 + 2824) = 0u;
  *(_OWORD *)(a1 + 2840) = 0u;
  *(_OWORD *)(a1 + 2856) = 0u;
  *(_OWORD *)(a1 + 2872) = 0u;
  *(_DWORD *)(a1 + 2668) = 0xFFFF;
  *(CFAbsoluteTime *)(a1 + 2536) = CFAbsoluteTimeGetCurrent();
}

void sub_10066CD14(uint64_t a1)
{
  NSObject *v2;
  uint8_t v3[16];

  v2 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Reset BLE Scan Stat", v3, 2u);
  }
  *(_OWORD *)(a1 + 3176) = 0u;
  *(_OWORD *)(a1 + 3192) = 0u;
  *(_OWORD *)(a1 + 3144) = 0u;
  *(_OWORD *)(a1 + 3160) = 0u;
  *(_OWORD *)(a1 + 3112) = 0u;
  *(_OWORD *)(a1 + 3128) = 0u;
  *(_OWORD *)(a1 + 3080) = 0u;
  *(_OWORD *)(a1 + 3096) = 0u;
  *(_OWORD *)(a1 + 3048) = 0u;
  *(_OWORD *)(a1 + 3064) = 0u;
  *(_OWORD *)(a1 + 3016) = 0u;
  *(_OWORD *)(a1 + 3032) = 0u;
  *(_OWORD *)(a1 + 2984) = 0u;
  *(_OWORD *)(a1 + 3000) = 0u;
  *(_OWORD *)(a1 + 2952) = 0u;
  *(_OWORD *)(a1 + 2968) = 0u;
  *(_OWORD *)(a1 + 2920) = 0u;
  *(_OWORD *)(a1 + 2936) = 0u;
  *(_OWORD *)(a1 + 2888) = 0u;
  *(_OWORD *)(a1 + 2904) = 0u;
  *(_OWORD *)(a1 + 2856) = 0u;
  *(_OWORD *)(a1 + 2872) = 0u;
  *(_OWORD *)(a1 + 2824) = 0u;
  *(_OWORD *)(a1 + 2840) = 0u;
  *(_OWORD *)(a1 + 2792) = 0u;
  *(_OWORD *)(a1 + 2808) = 0u;
  *(_OWORD *)(a1 + 2760) = 0u;
  *(_OWORD *)(a1 + 2776) = 0u;
  *(_OWORD *)(a1 + 2728) = 0u;
  *(_OWORD *)(a1 + 2744) = 0u;
  *(CFAbsoluteTime *)(a1 + 2728) = CFAbsoluteTimeGetCurrent();
}

void sub_10066CDC8(uint64_t a1)
{
  NSObject *v2;
  uint8_t v3[16];

  v2 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Reset ScanCore BLE Connection Scan Stat", v3, 2u);
  }
  *(_QWORD *)(a1 + 3248) = 0;
  *(_OWORD *)(a1 + 3232) = 0u;
  *(CFAbsoluteTime *)(a1 + 3232) = CFAbsoluteTimeGetCurrent();
}

double sub_10066CE44(uint64_t a1)
{
  uint64_t v2;
  BOOL v3;
  char v4;
  char v5;
  BOOL v6;
  char v7;
  char v8;
  double result;

  v2 = a1 + 710;
  bzero((void *)(a1 + 200), 0x638uLL);
  *(_DWORD *)(a1 + 160) = 5046046;
  v3 = *(_BYTE *)(a1 + 2104) == 0;
  if (*(_BYTE *)(a1 + 2104))
    v4 = 16;
  else
    v4 = 18;
  *(_BYTE *)(a1 + 164) = v4;
  if (v3)
    v5 = 14;
  else
    v5 = 0;
  *(_BYTE *)(a1 + 165) = v5;
  *(_BYTE *)(a1 + 172) = -1;
  *(_WORD *)(a1 + 170) = 0;
  *(_DWORD *)(a1 + 166) = 100;
  *(_QWORD *)(a1 + 181) = 0;
  *(_QWORD *)(a1 + 173) = 0;
  *(_QWORD *)(a1 + 188) = 0xFCB2160600000000;
  *(_DWORD *)(a1 + 196) = 25690112;
  *(_BYTE *)(a1 + 200) = 2;
  *(_BYTE *)(a1 + 229) = 1;
  *(_BYTE *)(a1 + 202) = 0;
  if (_os_feature_enabled_impl("BluetoothFeatures", "StandardUTFEAA")
    && _os_feature_enabled_impl("CoreLocation", "StandardUT"))
  {
    *(_DWORD *)(a1 + 260) = 25690112;
    *(_DWORD *)(a1 + 256) = -22407674;
    *(_WORD *)(a1 + 264) = 258;
    *(_BYTE *)(a1 + 292) = 1;
  }
  *(_DWORD *)(a1 + 704) = 5046158;
  v6 = *(_BYTE *)(a1 + 2104) == 0;
  if (*(_BYTE *)(a1 + 2104))
    v7 = 16;
  else
    v7 = 18;
  *(_BYTE *)(a1 + 708) = v7;
  if (v6)
    v8 = 14;
  else
    v8 = 0;
  *(_BYTE *)(a1 + 709) = v8;
  *(_BYTE *)(a1 + 716) = -1;
  *(_WORD *)(a1 + 714) = 0;
  *(_DWORD *)v2 = 100;
  *(_QWORD *)(a1 + 725) = 0;
  *(_QWORD *)(a1 + 717) = 0;
  *(_QWORD *)(a1 + 732) = 0xFCB2160600000000;
  *(_DWORD *)(a1 + 740) = 25690112;
  *(_BYTE *)(a1 + 744) = 2;
  *(_WORD *)(a1 + 772) = 511;
  *(_WORD *)(a1 + 745) = 257;
  *(_DWORD *)(a1 + 1248) = -43051482;
  *(_BYTE *)(a1 + 1260) = -1;
  *(_QWORD *)&result = 13107200;
  *(_QWORD *)(v2 + 542) = 13107200;
  *(_QWORD *)(a1 + 1269) = 0;
  *(_QWORD *)(a1 + 1261) = 0;
  *(_DWORD *)(a1 + 1276) = 0;
  return result;
}

uint64_t sub_10066CFF0(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t i;
  _DWORD *v7;
  uint64_t v8;
  uint64_t j;
  uint64_t k;
  uint64_t v11;
  char v12;
  char v13;
  uint64_t v14;
  uint64_t result;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  uint64_t v20;
  char v21;
  uint64_t v22;
  uint64_t v23;
  char v24;
  uint64_t v25;
  char v26;
  uint64_t v27;
  uint64_t m;
  uint64_t n;
  uint64_t v30;
  char v31;
  uint64_t v32;
  char v33;

  v2 = 0;
  v3 = a1 + 3272;
  do
  {
    v4 = 0;
    v5 = v3;
    do
    {
      for (i = 0; i != 32; i += 16)
      {
        v7 = (_DWORD *)(v5 + i);
        *(_DWORD *)((char *)v7 + 3) = 0;
        *v7 = 0;
        v7[128] = 0;
        *(_DWORD *)(v5 + i + 515) = 0;
        v8 = v5 + i + 520;
        v7[2] = 0;
        *(_DWORD *)((char *)v7 + 11) = 0;
        v7[130] = 0;
        *(_DWORD *)(v8 + 3) = 0;
      }
      ++v4;
      v5 += 32;
    }
    while (v4 != 2);
    ++v2;
    v3 += 64;
  }
  while (v2 != 8);
  for (j = 0; j != 2; ++j)
  {
    for (k = 0; k != 2; ++k)
    {
      v11 = 0;
      v12 = 1;
      do
      {
        v13 = v12;
        v14 = sub_10003BE44();
        result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v14 + 632))(v14);
        if ((result & 1) == 0)
        {
          v16 = a1 + 32 * j + 16 * k + 8 * v11;
          *(_DWORD *)(v16 + 3528) = 43;
          *(_WORD *)(v16 + 3532) = 0;
          *(_BYTE *)(v16 + 3534) = 0;
          *(_DWORD *)(v16 + 3592) = 16;
          *(_WORD *)(v16 + 3596) = 0;
          *(_BYTE *)(v16 + 3598) = 0;
        }
        v12 = 0;
        v17 = a1 + 32 * j + 16 * k + 8 * v11;
        *(_DWORD *)(v17 + 3656) = 48;
        *(_WORD *)(v17 + 3660) = 0;
        *(_BYTE *)(v17 + 3662) = 0;
        v11 = 1;
      }
      while ((v13 & 1) != 0);
    }
  }
  v18 = 0;
  *(_DWORD *)(a1 + 3832) = 3145728;
  *(_WORD *)(a1 + 3836) = 0;
  v19 = 1;
  *(_BYTE *)(a1 + 3838) = 1;
  *(_DWORD *)(a1 + 3840) = 3145728;
  *(_WORD *)(a1 + 3844) = 0;
  *(_BYTE *)(a1 + 3846) = 1;
  do
  {
    v20 = a1 + 16 * v18;
    *(_DWORD *)(v20 + 4080) = 2818048;
    *(_WORD *)(v20 + 4084) = 0;
    v21 = v19;
    *(_BYTE *)(v20 + 4086) = 0;
    *(_DWORD *)(v20 + 4072) = 0;
    *(_WORD *)(v20 + 4076) = 80;
    *(_BYTE *)(v20 + 4078) = 0;
    v22 = a1 + 4040 + 16 * v18;
    *(_DWORD *)(v22 + 8) = 524331;
    *(_WORD *)(v22 + 12) = 0;
    *(_BYTE *)(v22 + 14) = 0;
    *(_DWORD *)v22 = 43;
    *(_WORD *)(v22 + 4) = 16;
    v18 = 1;
    *(_BYTE *)(v22 + 6) = 0;
    v19 = 0;
  }
  while ((v21 & 1) != 0);
  v23 = 0;
  v24 = 1;
  do
  {
    v25 = a1 + 16 * v23;
    *(_DWORD *)(v25 + 4144) = 0x100000;
    *(_WORD *)(v25 + 4148) = 0;
    v26 = v24;
    *(_BYTE *)(v25 + 4150) = 0;
    *(_DWORD *)(v25 + 4136) = 0;
    *(_WORD *)(v25 + 4140) = 32;
    *(_BYTE *)(v25 + 4142) = 0;
    v27 = a1 + 4104 + 16 * v23;
    *(_DWORD *)(v27 + 8) = 524304;
    *(_WORD *)(v27 + 12) = 0;
    *(_BYTE *)(v27 + 14) = 0;
    *(_DWORD *)v27 = 16;
    *(_WORD *)(v27 + 4) = 16;
    v23 = 1;
    *(_BYTE *)(v27 + 6) = 0;
    v24 = 0;
  }
  while ((v26 & 1) != 0);
  for (m = 0; m != 2; ++m)
  {
    for (n = 0; n != 2; ++n)
    {
      v30 = 0;
      v31 = 1;
      do
      {
        v32 = a1 + 32 * m + 16 * n + 8 * v30;
        *(_DWORD *)(v32 + 4168) = 32;
        *(_WORD *)(v32 + 4172) = 32;
        *(_BYTE *)(v32 + 4174) = 0;
        *(_DWORD *)(v32 + 3848) = 0;
        v33 = v31;
        *(_WORD *)(v32 + 3852) = 16;
        *(_BYTE *)(v32 + 3854) = 0;
        v30 = 1;
        v31 = 0;
      }
      while ((v33 & 1) != 0);
    }
  }
  return result;
}

void sub_10066D2EC(void **a1, __int128 *a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  unint64_t v7;
  __int128 v8;
  char *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  __int128 v17;
  char *v18;
  char *v19;
  __int128 v20;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (v7 >= (unint64_t)v6)
  {
    v10 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v7 - (_QWORD)*a1) >> 2);
    v11 = v10 + 1;
    if (v10 + 1 > 0xCCCCCCCCCCCCCCCLL)
      abort();
    v12 = 0xCCCCCCCCCCCCCCCDLL * ((v5 - (_BYTE *)*a1) >> 2);
    if (2 * v12 > v11)
      v11 = 2 * v12;
    if (v12 >= 0x666666666666666)
      v13 = 0xCCCCCCCCCCCCCCCLL;
    else
      v13 = v11;
    if (v13)
      v14 = (char *)sub_1000B58EC(v4, v13);
    else
      v14 = 0;
    v15 = &v14[20 * v10];
    v16 = &v14[20 * v13];
    v17 = *a2;
    *((_DWORD *)v15 + 4) = *((_DWORD *)a2 + 4);
    *(_OWORD *)v15 = v17;
    v9 = v15 + 20;
    v19 = (char *)*a1;
    v18 = (char *)a1[1];
    if (v18 != *a1)
    {
      do
      {
        v20 = *(_OWORD *)(v18 - 20);
        *((_DWORD *)v15 - 1) = *((_DWORD *)v18 - 1);
        *(_OWORD *)(v15 - 20) = v20;
        v15 -= 20;
        v18 -= 20;
      }
      while (v18 != v19);
      v18 = (char *)*a1;
    }
    *a1 = v15;
    a1[1] = v9;
    a1[2] = v16;
    if (v18)
      operator delete(v18);
  }
  else
  {
    v8 = *a2;
    *(_DWORD *)(v7 + 16) = *((_DWORD *)a2 + 4);
    *(_OWORD *)v7 = v8;
    v9 = (char *)(v7 + 20);
  }
  a1[1] = v9;
}

uint64_t sub_10066D40C(uint64_t *a1, uint64_t a2)
{
  unint64_t v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  uint64_t result;

  v4 = a1[1];
  if (v4 >= a1[2])
  {
    result = sub_100686328(a1, a2);
  }
  else
  {
    *(_QWORD *)v4 = *(id *)a2;
    *(_QWORD *)(v4 + 8) = *(id *)(a2 + 8);
    *(_OWORD *)(v4 + 16) = *(_OWORD *)(a2 + 16);
    v6 = *(_OWORD *)(a2 + 48);
    v5 = *(_OWORD *)(a2 + 64);
    v7 = *(_OWORD *)(a2 + 32);
    *(_OWORD *)(v4 + 78) = *(_OWORD *)(a2 + 78);
    *(_OWORD *)(v4 + 48) = v6;
    *(_OWORD *)(v4 + 64) = v5;
    *(_OWORD *)(v4 + 32) = v7;
    result = v4 + 96;
  }
  a1[1] = result;
  return result;
}

void sub_10066D490()
{
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEBUG))
    sub_100715EFC();
}

void sub_10066D4D4(uint64_t a1)
{
  NSObject *v2;
  const char *v3;
  int v4;
  const char *v5;

  v2 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
  {
    if (*(_BYTE *)(a1 + 144))
      v3 = "On";
    else
      v3 = "Off";
    v4 = 136446210;
    v5 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "LeObserver Power : system woke up, screen is %{public}s", (uint8_t *)&v4, 0xCu);
  }
}

void sub_10066D590(uint64_t a1)
{
  sub_10066D4D4(a1 - 40);
}

_BYTE *sub_10066D598(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  const __CFString *v5;
  uint64_t v6;
  _QWORD v8[5];
  char v9;
  uint8_t buf[4];
  const __CFString *v11;

  v9 = 0;
  sub_100043758(&v9);
  if (sub_100225224())
  {
    sub_100221E3C(0x200000);
    sub_10004339C(&v9);
    v2 = 0;
    v3 = 167;
    do
    {
      if (*(_BYTE *)(a1 + v3))
      {
        v4 = qword_100999828;
        if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
        {
          v5 = CFSTR("UNKNOWN");
          if (v2 <= 2u)
            v5 = off_10093F698[v2];
          *(_DWORD *)buf = 138412290;
          v11 = v5;
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Destroying stale ADVBUFF(%@):", buf, 0xCu);
        }
        sub_10066D748(a1, v2);
      }
      ++v2;
      v3 += 544;
    }
    while (v2 != 3);
    *(_BYTE *)(a1 + 4384) = 0;
    v6 = sub_1000419F4();
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 3221225472;
    v8[2] = sub_10066DB94;
    v8[3] = &unk_100917378;
    v8[4] = a1;
    sub_100023D84(v6, v8);
  }
  return sub_100043728(&v9);
}

void sub_10066D728(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  _Unwind_Resume(exception_object);
}

uint64_t sub_10066D748(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v10;
  char v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  NSObject *v17;
  __CFString *v18;
  uint64_t v19;
  NSObject *v20;
  __CFString *v21;
  NSObject *v22;
  __CFString *v23;
  uint64_t v24;
  NSObject *v25;
  __CFString *v26;
  uint64_t v27;
  int v29;
  int v30;
  __int16 v31;
  uint8_t buf[4];
  __CFString *v33;
  __int16 v34;
  int v35;

  if (qword_100994118 != -1)
    dispatch_once(&qword_100994118, &stru_10093F188);
  if (a2 < 3)
  {
    v6 = a1 + 544 * a2;
    v8 = *(unsigned __int8 *)(v6 + 167);
    v7 = v6 + 167;
    *(_BYTE *)(v7 + 4) = 0;
    *(_WORD *)(v7 + 2) = 0;
    if (v8)
    {
      if (a2 <= 1 && byte_100994110)
      {
        v9 = sub_1000438A4();
        v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 2328))(v9);
        v31 = 0;
        v30 = 0;
        if (v10)
        {
          v11 = v10;
          v12 = 0;
          v13 = a1 + 544 * a2 + 228;
          do
          {
            if (*(_WORD *)(v13 - 34))
            {
              v14 = sub_1000438A4();
              BYTE2(v29) = *(_BYTE *)(v13 - 28);
              LOWORD(v29) = *(_WORD *)(v13 - 30);
              v15 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, int *, _QWORD, _QWORD, _QWORD, _QWORD, int, uint64_t, uint64_t))(*(_QWORD *)v14 + 2808))(v14, a2, *(unsigned __int8 *)(v13 - 36), &v30, *(unsigned __int8 *)(v13 - 35), *(unsigned __int16 *)(v13 - 34), *(unsigned __int8 *)(v13 - 32), *(unsigned __int8 *)(v13 - 31), v29, v13 - 27, v13);
              if (v15)
              {
                v16 = v15;
                v17 = qword_100999828;
                if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
                {
                  v18 = off_10093F698[(char)a2];
                  *(_DWORD *)buf = 138543618;
                  v33 = v18;
                  v34 = 1024;
                  v35 = v16;
                  _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "ADVBUFF(%{public}@): Failed to remove ext buffer adv rule: %d", buf, 0x12u);
                }
              }
              else
              {
                --v11;
              }
            }
            if (v12 > 6)
              break;
            ++v12;
            v13 += 64;
          }
          while (v11);
        }
        v19 = sub_1000438A4();
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v19 + 2816))(v19, a2);
      }
      v20 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
      {
        v21 = off_10093F698[(char)a2];
        *(_DWORD *)buf = 138543362;
        v33 = v21;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_INFO, "ADVBUFF(%{public}@): Destroying ADV buffer", buf, 0xCu);
      }
      v24 = sub_1000438A4();
      v5 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD))(*(_QWORD *)v24 + 2856))(v24, a2, 0, 0);
      v25 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
      {
        v26 = off_10093F698[(char)a2];
        *(_DWORD *)buf = 138543618;
        v33 = v26;
        v34 = 1024;
        v35 = v5;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_INFO, "ADVBUFF(%{public}@): advBufControl Disabled returned %d", buf, 0x12u);
      }
      if ((_DWORD)v5)
      {
        if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
          sub_100715F2C();
      }
      else
      {
        *(_BYTE *)v7 = 0;
        v27 = a1 + 544 * a2;
        *(_BYTE *)(v27 + 168) = 0;
        *(_BYTE *)(v27 + 172) = -1;
      }
    }
    else
    {
      v22 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
      {
        v23 = off_10093F698[(char)a2];
        *(_DWORD *)buf = 138543362;
        v33 = v23;
        v5 = 12;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_INFO, "ADVBUFF(%{public}@): destroyADVBuffer - not created", buf, 0xCu);
      }
      else
      {
        return 12;
      }
    }
  }
  else
  {
    v4 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      LODWORD(v33) = a2;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "HW ADV Buffer handle out of range (%d), ignoring agent request", buf, 8u);
    }
    return 7;
  }
  return v5;
}

void sub_10066DB94(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void (***v5)(_QWORD, void **);
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  NSObject *v10;
  void **v11;
  uint64_t v12;
  void *__p[2];
  char v14;
  void *v15;
  uint64_t *v16;
  uint64_t v17;
  uint8_t buf[4];
  void **v19;
  __int16 v20;
  int v21;
  _QWORD v22[2];

  v1 = *(_QWORD *)(a1 + 32);
  *(_DWORD *)(v1 + 1960) = 1;
  *(_QWORD *)(v1 + 1840) = 0;
  *(_DWORD *)(v1 + 1847) = 0;
  v2 = sub_1000438A4();
  sub_100333414(v2, v1 + 8);
  v3 = sub_1000438A4();
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v3 + 640))(v3, 1);
  v4 = sub_1000438A4();
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v4 + 992))(v4, 1);
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v5 = (void (***)(_QWORD, void **))sub_10034D508();
  (**v5)(v5, &v15);
  v6 = (uint64_t *)v15;
  if (v15 != v16)
  {
    while (1)
    {
      v7 = *v6;
      v22[0] = 0;
      v22[1] = 0;
      v8 = sub_10034D508();
      v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD *))(*(_QWORD *)v8 + 96))(v8, v7, 3, v22);
      v10 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
      {
        sub_10043E5F8(v7, __p);
        v11 = __p;
        if (v14 < 0)
          v11 = (void **)__p[0];
        *(_DWORD *)buf = 136446466;
        v19 = v11;
        v20 = 1024;
        v21 = v9;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Read encryption key for device %{public}s : result %d", buf, 0x12u);
        if (v14 < 0)
          break;
      }
      if (!v9)
        goto LABEL_7;
LABEL_9:
      if (++v6 == v16)
        goto LABEL_10;
    }
    operator delete(__p[0]);
    if (v9)
      goto LABEL_9;
LABEL_7:
    LOBYTE(__p[0]) = 0;
    *(_DWORD *)((char *)__p + 1) = *(_DWORD *)(v7 + 128);
    *(_WORD *)((char *)__p + 5) = *(_WORD *)(v7 + 132);
    sub_10066DE10(v1, (unsigned __int8 *)__p, (uint64_t)v22);
    goto LABEL_9;
  }
LABEL_10:
  v12 = sub_100038E50();
  sub_100260C8C(v12 + 368, v1 + 40);
  if (qword_100977A58 != -1)
    dispatch_once(&qword_100977A58, &stru_10093F478);
  sub_1004A3424((uint64_t)off_100977A50, v1 + 2216);
  sub_10001A7AC(v1);
  *(_BYTE *)(v1 + 4383) = 0;
  if (v15)
  {
    v16 = (uint64_t *)v15;
    operator delete(v15);
  }
}

void sub_10066DDE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_10066DE10(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  unsigned __int8 *v5;
  id v6;
  void *v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  void *v13;
  void *v14;
  _QWORD *v15;
  void *v16;
  void *v17;
  _QWORD *v18;
  void *v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void **v24;

  if (a2)
  {
    if (a3)
    {
      v5 = a2 + 1;
      v6 = sub_100021770(((unint64_t)a2[1] << 40) | ((unint64_t)a2[2] << 32) | ((unint64_t)a2[3] << 24) | ((unint64_t)a2[4] << 16) | ((unint64_t)a2[5] << 8) | a2[6] | ((unint64_t)*a2 << 48));
      v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
      if (!objc_msgSend(v7, "length"))
      {
        if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
          sub_100716014();
        goto LABEL_42;
      }
      v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", a3, 16));
      objc_msgSend(*(id *)(a1 + 2088), "setObject:forKeyedSubscript:", v8, v7);

      if (qword_1009778E8 != -1)
        dispatch_once(&qword_1009778E8, &stru_10093F598);
      LODWORD(v21) = *(_DWORD *)v5;
      WORD2(v21) = *((_WORD *)v5 + 2);
      v9 = sub_1004704A8((uint64_t)off_1009778E0, (uint64_t)&v21, 1);
      if (!v9)
      {
LABEL_42:

        return;
      }
      v21 = 0;
      v22 = 0;
      v23 = 0;
      if (!sub_100448DAC(v9, (uint64_t)&v21))
        goto LABEL_41;
      v10 = v21;
      v11 = 0xAAAAAAAAAAAAAAABLL * ((v22 - v21) >> 3);
      if (v11 < 4)
        goto LABEL_41;
      v12 = (_QWORD *)(v21 + 72);
      if (*(char *)(v21 + 95) < 0)
      {
        if (*(_QWORD *)(v21 + 80) <= 1uLL)
          goto LABEL_23;
        v12 = (_QWORD *)*v12;
      }
      else if (*(unsigned __int8 *)(v21 + 95) <= 1u)
      {
        goto LABEL_23;
      }
      v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v12));
      if (objc_msgSend(v13, "length"))
      {
        v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", a3, 16));
        objc_msgSend(*(id *)(a1 + 2088), "setObject:forKeyedSubscript:", v14, v13);

      }
      v10 = v21;
      v11 = 0xAAAAAAAAAAAAAAABLL * ((v22 - v21) >> 3);
LABEL_23:
      if (v11 < 9)
        goto LABEL_41;
      v15 = (_QWORD *)(v10 + 192);
      if (*(char *)(v10 + 215) < 0)
      {
        if (*(_QWORD *)(v10 + 200) <= 1uLL)
          goto LABEL_32;
        v15 = (_QWORD *)*v15;
      }
      else if (*(unsigned __int8 *)(v10 + 215) <= 1u)
      {
        goto LABEL_32;
      }
      v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v15));
      if (objc_msgSend(v16, "length"))
      {
        v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", a3, 16));
        objc_msgSend(*(id *)(a1 + 2088), "setObject:forKeyedSubscript:", v17, v16);

      }
      v10 = v21;
      v11 = 0xAAAAAAAAAAAAAAABLL * ((v22 - v21) >> 3);
LABEL_32:
      if (v11 >= 0xA)
      {
        v18 = (_QWORD *)(v10 + 216);
        if ((*(char *)(v10 + 239) & 0x80000000) == 0)
        {
          if (*(unsigned __int8 *)(v10 + 239) <= 1u)
            goto LABEL_41;
LABEL_38:
          v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v18));
          if (objc_msgSend(v19, "length"))
          {
            v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", a3, 16));
            objc_msgSend(*(id *)(a1 + 2088), "setObject:forKeyedSubscript:", v20, v19);

          }
          goto LABEL_41;
        }
        if (*(_QWORD *)(v10 + 224) > 1uLL)
        {
          v18 = (_QWORD *)*v18;
          goto LABEL_38;
        }
      }
LABEL_41:
      v24 = (void **)&v21;
      sub_100091BF8(&v24);
      goto LABEL_42;
    }
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
      sub_100715FE8();
  }
  else if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
  {
    sub_100715FBC();
  }
}

void sub_10066E188(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  void *v12;
  void *v13;
  void *v14;

  a12 = (void **)&a9;
  sub_100091BF8(&a12);

  _Unwind_Resume(a1);
}

_BYTE *sub_10066E1FC(uint64_t a1)
{
  return sub_10066D598(a1 - 16);
}

void sub_10066E204(uint64_t a1)
{
  if (qword_1009940D0 != -1)
    dispatch_once(&qword_1009940D0, &stru_10093EDF0);
  if (!*(_QWORD *)(a1 + 2200))
    sub_10034FFF8();
}

void sub_10066E308(id a1)
{
  uint64_t v1;
  void *__p[2];
  char v3;
  void *v4[2];
  char v5;

  v1 = sub_100027F68();
  sub_100091AE8(v4, "POWER");
  sub_100091AE8(__p, "ForceWakeScanForClient");
  (*(void (**)(uint64_t, void **, void **, char *))(*(_QWORD *)v1 + 72))(v1, v4, __p, &byte_1009940C8);
  if (v3 < 0)
    operator delete(__p[0]);
  if (v5 < 0)
    operator delete(v4[0]);
}

void sub_10066E390(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  _Unwind_Resume(exception_object);
}

void sub_10066E3C4(id a1)
{
  uint64_t v1;
  void *__p[2];
  char v3;
  void *v4[2];
  char v5;

  v1 = sub_100027F68();
  sub_100091AE8(v4, "POWER");
  sub_100091AE8(__p, "ForceWakeScanConfig");
  (*(void (**)(uint64_t, void **, void **, char *))(*(_QWORD *)v1 + 72))(v1, v4, __p, &byte_1009940D8);
  if (v3 < 0)
    operator delete(__p[0]);
  if (v5 < 0)
    operator delete(v4[0]);
}

void sub_10066E44C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  _Unwind_Resume(exception_object);
}

_BYTE *sub_10066E480(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  NSObject *v4;
  _QWORD v6[5];
  char v7;
  uint8_t buf[16];

  v2 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "LeObserver::stackWillStop enter", buf, 2u);
  }
  v7 = 0;
  sub_100043758(&v7);
  if (sub_100225224())
  {
    sub_100221E3C(0);
    sub_10004339C(&v7);
    v3 = sub_1000419F4();
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    v6[2] = sub_10066E5A8;
    v6[3] = &unk_100917378;
    v6[4] = a1;
    sub_100023D84(v3, v6);
    v4 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "LeObserver::stackWillStop exit", buf, 2u);
    }
  }
  return sub_100043728(&v7);
}

void sub_10066E594(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  sub_100043728(&a17);
  _Unwind_Resume(a1);
}

void sub_10066E5A8(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  BOOL v12;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = sub_100038E50();
  sub_1002B43D4(v2 + 368, v1 + 40);
  v3 = sub_1000438A4();
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v3 + 640))(v3, 0);
  v4 = sub_1000438A4();
  sub_100333478(v4, v1 + 8);
  sub_10066E6D4(v1);
  v5 = *(void **)(v1 + 2112);
  *(_QWORD *)(v1 + 2112) = 0;

  v6 = *(void **)(v1 + 2120);
  *(_QWORD *)(v1 + 2120) = 0;

  *(_QWORD *)(v1 + 1960) = 0;
  v7 = *(_QWORD **)(v1 + 2040);
  v8 = (_QWORD *)(v1 + 2048);
  if (v7 != (_QWORD *)(v1 + 2048))
  {
    do
    {
      v9 = v7[5];
      if (v9)
        (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
      v10 = (_QWORD *)v7[1];
      if (v10)
      {
        do
        {
          v11 = v10;
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          v11 = (_QWORD *)v7[2];
          v12 = *v11 == (_QWORD)v7;
          v7 = v11;
        }
        while (!v12);
      }
      v7 = v11;
    }
    while (v11 != v8);
  }
  sub_10001A82C(v1 + 2040, *(_QWORD **)(v1 + 2048));
  *(_QWORD *)(v1 + 2040) = v8;
  *(_OWORD *)(v1 + 2048) = 0u;
  sub_100685ED0(v1 + 2064, *(_QWORD **)(v1 + 2072));
  *(_QWORD *)(v1 + 2064) = v1 + 2072;
  *(_QWORD *)(v1 + 2080) = 0;
  *(_QWORD *)(v1 + 2072) = 0;
  sub_10005D1C4(v1);
  sub_10066E900((dispatch_object_t *)v1);
  sub_10005D5E4(v1);
  sub_1004AF56C(v1 + 56);
}

uint64_t sub_10066E6D4(uint64_t a1)
{
  NSObject *v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t **v5;
  int v6;
  char v7;
  int v8;
  int v9;
  __int16 v10;
  NSObject *v11;
  uint64_t **v12;
  _QWORD *v13;
  _QWORD *v14;
  BOOL v15;
  uint64_t v17;
  unsigned __int8 v18;
  uint8_t buf[8];
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;

  v2 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Destroying match table for all registered types", buf, 2u);
  }
  v3 = *(_QWORD **)(a1 + 1816);
  v17 = a1;
  v4 = (_QWORD *)(a1 + 1824);
  if (v3 != (_QWORD *)(a1 + 1824))
  {
    v5 = (uint64_t **)(a1 + 1816);
    do
    {
      v6 = *((unsigned __int8 *)v3 + 28);
      v7 = *((_BYTE *)v3 + 29);
      v8 = *((unsigned __int16 *)v3 + 15);
      v9 = *((unsigned __int16 *)v3 + 18);
      v10 = *((_WORD *)v3 + 19);
      v11 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 67109632;
        *(_DWORD *)&buf[4] = v8;
        v20 = 1024;
        v21 = v6;
        v22 = 1024;
        v23 = v9;
        _os_log_debug_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "handle:%d type:%d length:%d setCreated(false) setEnabled(false)", buf, 0x14u);
      }
      v18 = v8;
      *(_QWORD *)buf = &v18;
      v12 = sub_10000DB5C(v5, &v18, (uint64_t)&unk_100740F58, (char **)buf);
      *((_BYTE *)v12 + 28) = v6;
      *((_BYTE *)v12 + 29) = v7;
      *((_WORD *)v12 + 15) = v8;
      *((_DWORD *)v12 + 8) = 0;
      *((_WORD *)v12 + 18) = v9;
      *((_WORD *)v12 + 19) = v10;
      v13 = (_QWORD *)v3[1];
      if (v13)
      {
        do
        {
          v14 = v13;
          v13 = (_QWORD *)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          v14 = (_QWORD *)v3[2];
          v15 = *v14 == (_QWORD)v3;
          v3 = v14;
        }
        while (!v15);
      }
      v3 = v14;
    }
    while (v14 != v4);
  }
  if (qword_100977FD0 != -1)
    dispatch_once(&qword_100977FD0, &stru_10093F4D8);
  sub_10039F8C0(qword_100977FC8, &off_100961190);
  *(_BYTE *)(v17 + 1855) = 0;
  sub_10006DE50((double *)v17, 22, 0);
  return 0;
}

uint64_t sub_10066E900(dispatch_object_t *a1)
{
  NSObject *v2;
  uint64_t v3;
  NSObject *v4;
  NSObject *v5;
  NSObject *v6;
  _QWORD v8[6];

  v2 = qword_100999948;
  if (os_log_type_enabled((os_log_t)qword_100999948, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v8[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Disarming contactTracing timers", (uint8_t *)v8, 2u);
  }
  if (qword_10097B180 != -1)
    dispatch_once(&qword_10097B180, &stru_10093F518);
  sub_10041BBB0((uint64_t)off_10097B178);
  v3 = sub_1000419F4();
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_10067C28C;
  v8[3] = &unk_100917378;
  v8[4] = a1;
  sub_100041A34(v3, v8);
  sub_10067C1B0((uint64_t)a1);
  v4 = a1[284];
  if (v4)
  {
    dispatch_source_cancel(v4);
    dispatch_release(a1[284]);
    a1[284] = 0;
  }
  v5 = a1[282];
  if (v5)
  {
    dispatch_source_cancel(v5);
    dispatch_release(a1[282]);
    a1[282] = 0;
  }
  v6 = a1[283];
  if (v6)
  {
    dispatch_source_cancel(v6);
    dispatch_release(a1[283]);
    a1[283] = 0;
  }
  return xpc_set_event("com.apple.alarm", "com.apple.bluetooth.contactTracingScanSystemWake", 0);
}

_BYTE *sub_10066EA40(uint64_t a1)
{
  return sub_10066E480(a1 - 16);
}

void sub_10066EA48(uint64_t a1, __int128 *a2)
{
  __int128 v2;
  uint64_t v3;
  _QWORD v4[4];
  __int128 v5;
  __int128 v6;
  __int128 v7;
  uint64_t v8;

  v2 = a2[1];
  v5 = *a2;
  v6 = v2;
  v7 = a2[2];
  v8 = *((_QWORD *)a2 + 6);
  v3 = sub_1000419F4();
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_10066EADC;
  v4[3] = &unk_1009371C8;
  sub_100041A34(v3, v4);
}

void sub_10066EADC(uint64_t a1)
{
  __int128 v2;
  NSObject *v3;
  uint64_t v4;
  unsigned int v5;
  NSObject *v6;
  _BOOL4 v7;
  unint64_t v8;
  NSObject *v9;
  uint8x8_t v10;
  int16x8_t v11;
  uint64_t v12;
  void *v13;
  char v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint8_t buf[4];
  void *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  __int16 v26;
  char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  int v31;
  char v32;
  char v33;
  char v34;
  _OWORD v35[2];
  __int128 v36;
  uint64_t v37;

  v2 = *(_OWORD *)(a1 + 48);
  v35[0] = *(_OWORD *)(a1 + 32);
  v35[1] = v2;
  v36 = *(_OWORD *)(a1 + 64);
  v37 = *(_QWORD *)(a1 + 80);
  v3 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEBUG))
    sub_1007161F0(a1 + 32, v3, v4);
  v5 = BYTE7(v36);
  v6 = qword_100999828;
  v7 = os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEBUG);
  if (BYTE7(v36))
  {
    if (v7)
    {
      v12 = CUPrintAddress((char *)&v36 + 8, 6, 0);
      v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
      *(_DWORD *)buf = 138413570;
      v21 = v13;
      v22 = 1024;
      v23 = BYTE7(v36);
      v24 = 1040;
      v25 = 31;
      v26 = 2096;
      v27 = (char *)v35 + 8;
      v28 = 1024;
      v29 = SBYTE14(v36);
      v30 = 1024;
      v31 = HIBYTE(v36);
      _os_log_debug_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "aopReceivedDeviceFoundEvent: Parsing entry, address:%@ len:%d payload:%.31P rssi:%d channel:%d", buf, 0x2Eu);

      v5 = BYTE7(v36);
    }
    if (v5 < 0x20)
    {
      bzero(buf, 0x1788uLL);
      v18 = 0u;
      v19 = 0u;
      v16 = 0u;
      v17 = 0u;
      v15 = 0u;
      sub_10004C878((uint64_t)&v15 + 2, (uint64_t)&v36 + 8, 6uLL);
      v8 = ((unint64_t)BYTE2(v15) << 40) | ((unint64_t)BYTE3(v15) << 32) | ((unint64_t)BYTE4(v15) << 24) | ((unint64_t)BYTE5(v15) << 16) | ((unint64_t)BYTE6(v15) << 8) | BYTE7(v15);
      if (v8 && (!HIWORD(v8) || HIWORD(v8) == 1 && (BYTE2(v15) & 0xC0) != 0x80))
      {
        LOWORD(v15) = 256;
        WORD4(v15) = BYTE7(v36);
        *(_QWORD *)&v16 = (char *)v35 + 8;
        BYTE11(v17) = 0;
        BYTE8(v16) = BYTE14(v36);
        v14 = 0;
        sub_100043758(&v14);
        sub_1000554A4((unsigned __int8 *)&v15, (uint64_t)buf, v10, v11);
        sub_10004339C(&v14);
        BYTE2(v23) = 0;
        v33 = 0;
        v34 = 1;
        v32 = 0;
        sub_1000407C4();
      }
      v9 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
        sub_100716164(v8, v9);
    }
    else if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
    {
      sub_100716100();
    }
  }
  else if (v7)
  {
    sub_1007160D0();
  }
}

void sub_10066EDB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  sub_100043728(&a13);
  _Unwind_Resume(a1);
}

void sub_10066EDD4(uint64_t a1, __int128 *a2)
{
  __int128 v2;
  uint64_t v3;
  _QWORD v4[4];
  __int128 v5;
  __int128 v6;
  __int128 v7;
  uint64_t v8;

  v2 = a2[1];
  v5 = *a2;
  v6 = v2;
  v7 = a2[2];
  v8 = *((_QWORD *)a2 + 6);
  v3 = sub_1000419F4();
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_10066EADC;
  v4[3] = &unk_1009371C8;
  sub_100041A34(v3, v4);
}

void sub_10066EE70(uint64_t a1, _QWORD *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  const void *v7;
  int64_t v8;
  char *v9;
  _QWORD v10[5];
  void *__p;
  void *__dst;
  uint64_t v13;
  __int128 buf;
  uint64_t v15;

  v4 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    v5 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(a2[1] - *a2) >> 3);
    LODWORD(buf) = 134217984;
    *(_QWORD *)((char *)&buf + 4) = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "AOPBTBUFF: Read Event with %lu advertisements", (uint8_t *)&buf, 0xCu);
  }
  buf = 0uLL;
  v15 = 0;
  sub_1003A1FA4(&buf, (uint64_t)a2);
  v6 = sub_1000419F4();
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3321888768;
  v10[2] = sub_10066F050;
  v10[3] = &unk_10093EE30;
  v10[4] = a1;
  __p = 0;
  __dst = 0;
  v13 = 0;
  v7 = (const void *)buf;
  v8 = *((_QWORD *)&buf + 1) - buf;
  if (*((_QWORD *)&buf + 1) != (_QWORD)buf)
  {
    sub_1003A201C(&__p, 0x6DB6DB6DB6DB6DB7 * (v8 >> 3));
    v9 = (char *)__dst;
    memmove(__dst, v7, v8);
    __dst = &v9[8 * (v8 >> 3)];
  }
  sub_100041A34(v6, v10);
  if (__p)
  {
    __dst = __p;
    operator delete(__p);
  }
  if ((_QWORD)buf)
  {
    *((_QWORD *)&buf + 1) = buf;
    operator delete((void *)buf);
  }
}

void sub_10066F014(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, uint64_t a16, void *a17, uint64_t a18)
{
  if (__p)
    operator delete(__p);
  if (a17)
    operator delete(a17);
  _Unwind_Resume(exception_object);
}

void sub_10066F050(_QWORD *a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unsigned int v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  BOOL v16;
  NSObject *v17;
  void *p_p;
  NSObject *v19;
  uint64_t v20;
  int v21;
  _BYTE *v22;
  unsigned __int8 *v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  _BYTE *v28;
  int v29;
  unsigned __int8 *v30;
  uint8x8_t v31;
  int16x8_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unsigned __int8 *v36;
  _QWORD v37[5];
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  _BYTE v43[12];
  char v44;
  void *__p;
  __int16 v46;
  uint64_t v47;
  __int16 v48;
  _BYTE *v49;
  __int16 v50;
  int v51;
  __int16 v52;
  uint64_t v53;
  __int16 v54;
  int v55;
  uint8_t buf[4];
  unsigned int v57;
  char v58;
  char v59;
  uint64_t v60;
  uint64_t v61;
  BOOL v62;
  char v63;

  v36 = (unsigned __int8 *)a1[4];
  v2 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "AOPBTBUFF: Read Event unpack devices", buf, 2u);
  }
  v3 = a1[5];
  if (a1[6] != v3)
  {
    v4 = 0;
    v5 = 0;
    v6 = 39;
    do
    {
      v7 = *(unsigned __int8 *)(v3 + v6);
      if (v7 < 0x20)
      {
        bzero(buf, 0x1788uLL);
        v41 = 0u;
        v42 = 0u;
        v39 = 0u;
        v40 = 0u;
        v38 = 0u;
        sub_10004C878((uint64_t)&v38 + 2, v3 + v6 + 1, 6uLL);
        BYTE1(v38) = 1;
        v9 = BYTE2(v38);
        v10 = BYTE3(v38);
        v11 = BYTE4(v38);
        v12 = BYTE5(v38);
        v13 = BYTE6(v38);
        v14 = BYTE7(v38);
        if (qword_1009778B8 != -1)
          dispatch_once(&qword_1009778B8, &stru_10093F538);
        v15 = (v10 << 32) | (v9 << 40) | (v11 << 24) | (v12 << 16) | (v13 << 8) | v14 | 0x1000000000000;
        if (!sub_1006A1AB0(qword_1009778B0, v15, (uint64_t)&v38 + 1)
          && (v15 = ((unint64_t)BYTE2(v38) << 40) | ((unint64_t)BYTE3(v38) << 32) | ((unint64_t)BYTE4(v38) << 24) | ((unint64_t)BYTE5(v38) << 16) | ((unint64_t)BYTE6(v38) << 8) | BYTE7(v38) | ((unint64_t)BYTE1(v38) << 48)) == 0
          || HIWORD(v15) && (HIWORD(v15) == 1 ? (v16 = (v15 & 0xC00000000000) == 0x800000000000) : (v16 = 1), v16))
        {
          v17 = qword_100999828;
          if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
          {
            sub_1000217F4(v15);
            p_p = &__p;
            if (SBYTE3(v49) < 0)
              p_p = __p;
            *(_DWORD *)v43 = 136315138;
            *(_QWORD *)&v43[4] = p_p;
            _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "AOPBTBUFF: Remote Bluetooth address \"%s\" is invalid!", v43, 0xCu);
            if (SBYTE3(v49) < 0)
              operator delete(__p);
          }
        }
        else
        {
          v19 = qword_100999828;
          if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
          {
            v20 = *(_QWORD *)(a1[5] + v6 - 39);
            sub_1000217F4(v15);
            v21 = v44;
            v22 = *(_BYTE **)v43;
            v23 = (unsigned __int8 *)(a1[5] + v6);
            v24 = *v23;
            v25 = CUPrintHex(v23 - 31, 31, 31, 0);
            v26 = objc_claimAutoreleasedReturnValue(v25);
            v27 = (void *)v26;
            v28 = v43;
            if (v21 < 0)
              v28 = v22;
            v29 = *(char *)(a1[5] + v6 + 7);
            LODWORD(__p) = 67110402;
            HIDWORD(__p) = v5;
            v46 = 2048;
            v47 = v20;
            v48 = 2080;
            v49 = v28;
            v50 = 1024;
            v51 = v24;
            v52 = 2112;
            v53 = v26;
            v54 = 1024;
            v55 = v29;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_INFO, "AOPBTBUFF: Parsing entry %d, TIMESTAMP %f, ADDR %s, LEN %d, PAYLOAD %@, RSSI %3d", (uint8_t *)&__p, 0x32u);
            if (v44 < 0)
              operator delete(*(void **)v43);

          }
        }
        LOBYTE(v38) = 3;
        v30 = (unsigned __int8 *)(a1[5] + v6);
        WORD4(v38) = *v30;
        BYTE8(v39) = v30[7];
        *(_QWORD *)&v39 = v30 - 31;
        BYTE11(v40) = 0;
        LOBYTE(__p) = 0;
        sub_100043758(&__p);
        sub_1000554A4((unsigned __int8 *)&v38, (uint64_t)buf, v31, v32);
        sub_10004339C(&__p);
        v58 = 0;
        v33 = a1[5];
        v60 = *(_QWORD *)(v33 + v6 - 39);
        if (*(_QWORD *)(v33 + v6 + 9))
          v61 = *(_QWORD *)(v33 + v6 + 9);
        v59 = *(_BYTE *)(v33 + v6 + 8);
        v34 = (unsigned __int128)((a1[6] - v33) * (__int128)0x4924924924924925) >> 64;
        v62 = v4 + (v34 >> 4) + ((unint64_t)v34 >> 63) > 1;
        v63 = 1;
        sub_1000407C4();
      }
      v8 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        v57 = v7;
        _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Ignoring invalid data length %d", buf, 8u);
      }
      ++v5;
      v3 = a1[5];
      v6 += 56;
      --v4;
    }
    while (0x6DB6DB6DB6DB6DB7 * ((a1[6] - v3) >> 3) > v5);
  }
  v35 = sub_1000419F4();
  v37[0] = _NSConcreteStackBlock;
  v37[1] = 3221225472;
  v37[2] = sub_10066F5EC;
  v37[3] = &unk_100917378;
  v37[4] = v36;
  sub_100041A34(v35, v37);
  v36[1854] = 0;
  v36[1864] = 0;
  sub_10005CACC(v36);
}

void sub_10066F5B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *__p,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,char a42)
{
  if (a40 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_10066F5EC()
{
  sub_10066F5F4();
}

void sub_10066F5F4()
{
  NSObject *v0;
  uint8_t buf[16];

  v0 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "AOPBTBUFF Sending empty event", buf, 2u);
  }
  operator new();
}

void sub_10066F830(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29)
{
  operator delete();
}

_QWORD *sub_10066F8C0(uint64_t a1, uint64_t a2)
{
  return sub_1003A1FA4((_QWORD *)(a1 + 40), a2 + 40);
}

void sub_10066F8CC(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(_QWORD *)(a1 + 48) = v2;
    operator delete(v2);
  }
}

void sub_10066F8E4(uint64_t a1, _QWORD *a2)
{
  sub_10066EE70(a1 - 128, a2);
}

void sub_10066F8EC(uint64_t a1, uint64_t a2)
{
  if (sub_10000D558(a1, a2))
  {
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
      sub_100716454();
  }
  else if (sub_10066F994(a1, a2) && os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
  {
    sub_1007163E8();
  }
}

uint64_t sub_10066F994(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t **v8;
  NSObject *v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __int16 v14;
  uint64_t **v15;
  BOOL v16;
  uint64_t v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  char v23;
  __int16 v24;
  __int16 v25;
  unsigned __int8 v26;
  unsigned __int16 v27;
  unsigned __int8 v28;
  char *v29;
  const __CFString *v30;
  void *v31;
  const __CFString *v32;
  void *v33;
  _QWORD v34[2];
  _QWORD v35[2];
  uint8_t buf[16];
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  _BYTE v49[30];

  v27 = 0;
  if ((_DWORD)a2)
  {
    v4 = 7;
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEBUG))
      sub_100716654();
    v4 = 3;
  }
  v5 = sub_100008090(a1, a2, 1, &v27);
  if ((_DWORD)v5)
  {
    v6 = v5;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
      sub_1007165F4();
  }
  else
  {
    v7 = v27;
    v28 = v27;
    *(_QWORD *)buf = &v28;
    v8 = sub_10000DB5C((uint64_t **)(a1 + 1816), &v28, (uint64_t)&unk_100740F58, (char **)buf);
    v25 = *((_WORD *)v8 + 15);
    v23 = *((_BYTE *)v8 + 29);
    v24 = *((_WORD *)v8 + 17);
    v9 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)&buf[4] = v7;
      *(_WORD *)&buf[8] = 1024;
      *(_DWORD *)&buf[10] = a2;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Creating an AOP match table with handle %d for type %d", buf, 0xEu);
    }
    if ((_DWORD)a2 == 22 && qword_100994108 != -1)
      dispatch_once(&qword_100994108, &stru_10093F168);
    if (qword_100977FD0 != -1)
      dispatch_once(&qword_100977FD0, &stru_10093F4D8);
    v10 = sub_10039F83C(qword_100977FC8, a2);
    if ((_DWORD)a2 == 22 && *(double *)(a1 + 1856) == 0.0)
    {
      +[NSDate timeIntervalSinceReferenceDate](NSDate, "timeIntervalSinceReferenceDate");
      *(_QWORD *)(a1 + 1856) = v11;
    }
    v12 = sub_1000438A4();
    v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, char, _QWORD, _BYTE, _QWORD, _QWORD, _BYTE))(*(_QWORD *)v12 + 2832))(v12, v7, v4, 255, 76, a2, 0, 1, v10, 0, 0, 0, 0, 0);
    if ((_DWORD)v6)
    {
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
        sub_10071658C();
    }
    else
    {
      v48 = 0u;
      memset(v49, 0, sizeof(v49));
      v46 = 0u;
      v47 = 0u;
      v44 = 0u;
      v45 = 0u;
      v42 = 0u;
      v43 = 0u;
      v40 = 0u;
      v41 = 0u;
      v38 = 0u;
      v39 = 0u;
      *(_OWORD *)buf = 0u;
      v37 = 0u;
      buf[6] = 2;
      v13 = sub_1000438A4();
      v6 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint8_t *))(*(_QWORD *)v13 + 2880))(v13, v7, 0, 0, buf);
      if ((_DWORD)v6)
      {
        if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
          sub_100716524();
      }
      else
      {
        if ((_DWORD)a2 == 22)
        {
          v14 = 1;
        }
        else if ((_DWORD)a2 == 7)
        {
          v14 = 4;
        }
        else if ((_DWORD)a2)
        {
          v14 = 0;
        }
        else
        {
          v14 = 2;
        }
        v26 = v25;
        v29 = (char *)&v26;
        v15 = sub_10000DB5C((uint64_t **)(a1 + 1816), &v26, (uint64_t)&unk_100740F58, &v29);
        *((_BYTE *)v15 + 28) = a2;
        *((_BYTE *)v15 + 29) = v23;
        *((_WORD *)v15 + 15) = v25;
        *((_WORD *)v15 + 16) = 1;
        *((_WORD *)v15 + 17) = v24;
        *((_WORD *)v15 + 18) = 1;
        *((_WORD *)v15 + 19) = v14;
        v16 = (_DWORD)a2 != 22;
        if (*(_BYTE *)(a1 + 1855))
          v16 = 1;
        if (!v16)
        {
          if (qword_100977FD0 != -1)
            dispatch_once(&qword_100977FD0, &stru_10093F4D8);
          v17 = qword_100977FC8;
          v34[0] = CFSTR("type");
          v34[1] = CFSTR("descriptor");
          v35[0] = &off_100960AD8;
          v32 = CFSTR("conf");
          v30 = CFSTR("appleType");
          v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", 22));
          v31 = v18;
          v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v31, &v30, 1));
          v33 = v19;
          v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v33, &v32, 1));
          v35[1] = v20;
          v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v35, v34, 2));
          sub_10039F8C0(v17, v21);

          *(_BYTE *)(a1 + 1855) = 1;
        }
      }
    }
  }
  return v6;
}

void sub_10066FE7C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_10066FEB8(uint64_t a1, uint64_t a2)
{
  sub_10066F8EC(a1 - 128, a2);
}

void sub_10066FEC0(uint64_t a1, const void *a2, unsigned int a3)
{
  NSObject *v6;
  char v7;
  void *v8;
  uint64_t v9;
  _QWORD v10[7];
  __int16 v11;
  uint8_t buf[8];
  uint8_t *v13;
  uint64_t v14;
  char v15;

  v6 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "ADVBUFF advBufferEvent length=%d", buf, 8u);
  }
  *(_QWORD *)buf = 0;
  v13 = buf;
  v14 = 0x2020000000;
  v15 = 5;
  if (a3 == 244)
  {
    v7 = 2;
    goto LABEL_7;
  }
  if (a3 == 219)
  {
    v7 = *(_BYTE *)(a1 + 1796);
LABEL_7:
    v15 = v7;
    v8 = malloc_type_malloc(a3, 0x3708C53CuLL);
    memcpy(v8, a2, a3);
    v9 = sub_1000419F4();
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    v10[2] = sub_100670070;
    v10[3] = &unk_10093EE68;
    v10[4] = buf;
    v10[5] = a1;
    v11 = a3;
    v10[6] = v8;
    sub_100041A34(v9, v10);
    goto LABEL_10;
  }
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
    sub_100716684();
LABEL_10:
  _Block_object_dispose(buf, 8);
}

void sub_100670050(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  _Unwind_Resume(exception_object);
}

void sub_100670070(uint64_t a1)
{
  uint64_t v2;
  os_log_t *v3;
  NSObject *v4;
  unint64_t v5;
  const __CFString *v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  unsigned int v15;
  NSObject *v16;
  int *v17;
  int v18;
  uint64_t v19;
  NSObject *v20;
  const __CFString *v21;
  NSObject *v22;
  const __CFString *v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  NSObject *v27;
  uint64_t v28;
  unsigned int v29;
  NSObject *v30;
  unint64_t v31;
  NSObject *v32;
  int v33;
  int v34;
  int v35;
  uint8x8_t v36;
  int16x8_t v37;
  uint64_t v38;
  uint64_t v39;
  NSObject *v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  const __CFString *v44;
  NSObject *v45;
  uint64_t v46;
  _BYTE *v47;
  unsigned int v48;
  unsigned int v49;
  unint64_t v50;
  unint64_t v51;
  const __CFString *v52;
  uint64_t v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  unint64_t v59;
  id v60;
  void *v61;
  id v62;
  void *v63;
  NSObject *v64;
  unint64_t v66;
  const __CFString *v67;
  int v68;
  uint64_t v69;
  unsigned __int8 v70;
  uint64_t v71;
  _BYTE *v72;
  unsigned int v73;
  unsigned int v74;
  int v75;
  int v76;
  unint64_t v77;
  NSObject *v78;
  os_log_t *v79;
  const __CFString *v80;
  uint64_t v81;
  int v82;
  int v83;
  int v84;
  unsigned int v85;
  NSObject *v86;
  unint64_t v87;
  NSObject *v88;
  uint8_t v89;
  uint8x8_t v90;
  int16x8_t v91;
  uint64_t v92;
  int v93;
  unsigned int v94;
  NSObject *v95;
  unint64_t v96;
  const __CFString *v97;
  int v98;
  int v99;
  uint64_t v100;
  unsigned int v101;
  unint64_t v102;
  unint64_t v103;
  id v104;
  void *v105;
  NSObject *v106;
  unint64_t v107;
  const __CFString *v108;
  int v109;
  int v110;
  unsigned int v111;
  NSObject *v112;
  const __CFString *v113;
  int v114;
  uint64_t v115;
  _BYTE *v116;
  int v117;
  NSObject *v118;
  unint64_t v119;
  const __CFString *v120;
  int v121;
  int v122;
  uint64_t v123;
  int v124;
  uint64_t v125;
  const __CFString *v126;
  const __CFString *v127;
  int *v128;
  _QWORD v129[5];
  char v130;
  int v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  int v135;
  _DWORD v136[2];
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint8_t v140[64];
  _BYTE v141[18];
  __int16 v142;
  int v143;
  __int16 v144;
  int v145;
  __int16 v146;
  int v147;
  __int16 v148;
  int v149;
  __int16 v150;
  int v151;
  uint8_t v152[48];
  __int128 v153;
  __int128 v154;
  _BYTE buf[24];
  _BYTE v156[18];
  uint64_t v157;
  _BYTE v158[6];
  _BYTE v159[6];
  __int16 v160;
  uint64_t v161;
  __int16 v162;
  int v163;
  __int16 v164;
  int v165;
  __int16 v166;
  int v167;
  __int16 v168;
  uint64_t v169;
  __int16 v170;
  int v171;
  __int16 v172;
  int v173;
  char v174;
  unsigned int v175;
  BOOL v176;
  __int16 v177;
  unsigned __int8 v178;
  unsigned __int8 v179;
  unsigned __int8 v180;
  unsigned __int8 v181;
  char v182;
  char v183;
  int v184;
  int v185;
  _DWORD *v186;
  char *v187;
  char *v188;
  char *v189;
  _DWORD *v190;

  v2 = *(_QWORD *)(a1 + 40);
  v3 = (os_log_t *)&qword_100999828;
  v4 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
  {
    v5 = *(char *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    if (v5 > 2)
      v6 = CFSTR("UNKNOWN");
    else
      v6 = off_10093F698[v5];
    v7 = *(unsigned __int8 *)(v2 + 1260);
    v8 = *(unsigned __int8 *)(v2 + 172);
    v9 = *(unsigned __int8 *)(v2 + 716);
    v10 = *(unsigned __int8 *)(v2 + 544 * *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 169);
    v11 = *(unsigned __int8 *)(v2 + 167);
    v12 = *(unsigned __int8 *)(v2 + 711);
    v13 = *(unsigned __int8 *)(v2 + 171);
    v14 = *(unsigned __int8 *)(v2 + 715);
    *(_DWORD *)buf = 138414338;
    *(_QWORD *)&buf[4] = v6;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v7;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v8;
    *(_WORD *)v156 = 1024;
    *(_DWORD *)&v156[2] = v9;
    *(_WORD *)&v156[6] = 1024;
    *(_DWORD *)&v156[8] = v10;
    *(_WORD *)&v156[12] = 1024;
    *(_DWORD *)&v156[14] = v11;
    LOWORD(v157) = 1024;
    *(_DWORD *)((char *)&v157 + 2) = v12;
    HIWORD(v157) = 1024;
    *(_DWORD *)v158 = v13;
    *(_WORD *)&v158[4] = 1024;
    *(_DWORD *)v159 = v14;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "ADVBUFF(%@): advBufferEvent expectedEntries EN:%d ObjDiscoveryWild:%d ObjectDiscoveryNO:%d pendingDraining:%d createdWild:%d createdNO:%d readInProgressWild:%d readInProgressNO:%d", buf, 0x3Cu);
  }
  v15 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (*(_BYTE *)(v2 + 544 * *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 167))
  {
    if (*(unsigned __int8 *)(v2 + 544 * *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 172) == 255)
    {
      v16 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_FAULT, "We were not expecting to get anything right now", buf, 2u);
        v15 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      }
    }
    if (v15 <= 1)
    {
      if (*(_BYTE *)(v2 + 544 * v15 + 172)
        && *(unsigned __int8 *)(v2 + 544 * v15 + 172) != 255
        && *(_WORD *)(a1 + 56) == 219)
      {
        *(_BYTE *)(v2 + 544 * v15 + 169) = 0;
        v17 = *(int **)(a1 + 48);
        v186 = v17 + 1;
        v187 = (char *)v17 + 47;
        v188 = (char *)v17 + 90;
        v189 = (char *)v17 + 133;
        v128 = v17;
        v190 = v17 + 44;
        if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
        {
          if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) == 1)
          {
            if (*(unsigned __int8 *)(v2 + 716) >= 5u)
              v18 = 5;
            else
              v18 = *(unsigned __int8 *)(v2 + 716);
            v19 = sub_100065478();
            v136[0] = 0;
            v136[1] = v18;
            v138 = 0;
            v139 = 0;
            v137 = 0;
            (*(void (**)(uint64_t, _DWORD *))(*(_QWORD *)v19 + 584))(v19, v136);
          }
        }
        else
        {
          if (*(unsigned __int8 *)(v2 + 172) >= 5u)
            v68 = 5;
          else
            v68 = *(unsigned __int8 *)(v2 + 172);
          v69 = sub_100065478();
          v131 = v68;
          v132 = 0;
          v134 = 0;
          v133 = 0;
          v135 = 0;
          (*(void (**)(uint64_t, int *))(*(_QWORD *)v69 + 584))(v69, &v131);
        }
        v70 = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
        v71 = v2 + 544 * v70;
        v74 = *(unsigned __int8 *)(v71 + 172);
        v72 = (_BYTE *)(v71 + 172);
        v73 = v74;
        if (v74 >= 5)
          v75 = 5;
        else
          v75 = v73;
        if (v75)
        {
          v76 = 0;
          v77 = 0;
          do
          {
            v78 = *v3;
            v79 = v3;
            if (os_log_type_enabled(*v3, OS_LOG_TYPE_INFO))
            {
              v80 = CFSTR("UNKNOWN");
              if (v70 <= 2u)
                v80 = off_10093F698[(char)v70];
              v81 = (uint64_t)(&v186)[v77];
              v82 = *(unsigned __int8 *)(v81 + 6);
              v83 = *(_DWORD *)(v81 + 38);
              v84 = *(char *)(v81 + 42);
              *(_DWORD *)buf = 138414850;
              *(_QWORD *)&buf[4] = v80;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v77;
              *(_WORD *)&buf[18] = 1040;
              *(_DWORD *)&buf[20] = 43;
              *(_WORD *)v156 = 2096;
              *(_QWORD *)&v156[2] = v81;
              *(_WORD *)&v156[10] = 1040;
              *(_DWORD *)&v156[12] = 6;
              *(_WORD *)&v156[16] = 2096;
              v157 = v81;
              *(_WORD *)v158 = 1024;
              *(_DWORD *)&v158[2] = v82;
              *(_WORD *)v159 = 1040;
              *(_DWORD *)&v159[2] = 31;
              v160 = 2096;
              v161 = v81 + 7;
              v162 = 1024;
              v163 = v83;
              v164 = 1024;
              v165 = v84;
              _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_INFO, "ADVBUFF(%@): Parsing entry %d entry_buff:%.43P address:%.6P len:%d payload:%.31P timestamp:%d rssi:%d", buf, 0x54u);
            }
            else
            {
              v81 = (uint64_t)(&v186)[v77];
            }
            v85 = *(unsigned __int8 *)(v81 + 6);
            if (v85 < 0x20)
            {
              bzero(buf, 0x1788uLL);
              *(_OWORD *)v141 = 0u;
              memset(v140, 0, sizeof(v140));
              sub_10004C878((uint64_t)&v140[2], v81, 6uLL);
              v87 = ((unint64_t)v140[2] << 40) | ((unint64_t)v140[3] << 32) | ((unint64_t)v140[4] << 24) | ((unint64_t)v140[5] << 16) | ((unint64_t)v140[6] << 8) | v140[7] | ((unint64_t)v140[1] << 48);
              if (!v87 || HIWORD(v87) && (HIWORD(v87) != 1 || (v140[2] & 0xC0) == 0x80))
              {
                v88 = *v79;
                if (os_log_type_enabled(*v79, OS_LOG_TYPE_ERROR))
                {
                  v103 = *(char *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
                  v126 = CFSTR("UNKNOWN");
                  if (v103 <= 2)
                    v126 = off_10093F698[v103];
                  v104 = sub_100021770(v87);
                  v105 = (void *)objc_claimAutoreleasedReturnValue(v104);
                  *(_DWORD *)v152 = 138412546;
                  *(_QWORD *)&v152[4] = v126;
                  *(_WORD *)&v152[12] = 2112;
                  *(_QWORD *)&v152[14] = v105;
                  _os_log_error_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_ERROR, "ADVBUFF(%@): Remote Bluetooth address \"%@\" is invalid!", v152, 0x16u);

                }
              }
              v89 = sub_100041C6C(v2, *(char *)(v81 + 42));
              *(_BYTE *)(v81 + 42) = v89;
              *(_WORD *)v140 = 259;
              *(_WORD *)&v140[8] = *(unsigned __int8 *)(v81 + 6);
              v140[24] = v89;
              *(_QWORD *)&v140[16] = v81 + 7;
              v140[43] = 0;
              v130 = 0;
              sub_100043758(&v130);
              sub_1000554A4(v140, (uint64_t)buf, v90, v91);
              sub_10004339C(&v130);
              buf[16] = 0;
              v92 = *(_QWORD *)(a1 + 32);
              v176 = v76 + *(unsigned __int8 *)(v2 + 544 * *(unsigned __int8 *)(*(_QWORD *)(v92 + 8) + 24) + 172) > 1;
              LOBYTE(v177) = 1;
              v93 = *v128;
              v94 = *(_DWORD *)(v81 + 38);
              if (*v128 < v94)
                v93 = *v128 + 0xFFFFFFF;
              v175 = v93 - v94;
              v95 = *v79;
              if (os_log_type_enabled(*v79, OS_LOG_TYPE_INFO))
              {
                v96 = *(char *)(*(_QWORD *)(v92 + 8) + 24);
                v97 = CFSTR("UNKNOWN");
                if (v96 <= 2)
                  v97 = off_10093F698[v96];
                v98 = *v128;
                v99 = *(_DWORD *)(v81 + 38);
                *(_DWORD *)v152 = 138413826;
                *(_QWORD *)&v152[4] = v97;
                *(_WORD *)&v152[12] = 1040;
                *(_DWORD *)&v152[14] = 6;
                *(_WORD *)&v152[18] = 2096;
                *(_QWORD *)&v152[20] = &v140[2];
                *(_WORD *)&v152[28] = 1024;
                *(_DWORD *)&v152[30] = v98;
                *(_WORD *)&v152[34] = 1024;
                *(_DWORD *)&v152[36] = v99;
                *(_WORD *)&v152[40] = 1024;
                *(_DWORD *)&v152[42] = v175;
                *(_WORD *)&v152[46] = 1024;
                LODWORD(v153) = *(unsigned __int16 *)&v140[8];
                _os_log_impl((void *)&_mh_execute_header, v95, OS_LOG_TYPE_INFO, "ADVBUFF(%@): found %.6P now:%u event:%u delta:%u dataLen:%d", v152, 0x34u);
              }
              sub_1000407C4();
            }
            v3 = v79;
            v86 = *v79;
            if (os_log_type_enabled(*v79, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 67109120;
              *(_DWORD *)&buf[4] = v85;
              _os_log_error_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_ERROR, "Ignoring invalid data length %d", buf, 8u);
            }
            ++v77;
            v70 = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
            v100 = v2 + 544 * v70;
            v101 = *(unsigned __int8 *)(v100 + 172);
            v72 = (_BYTE *)(v100 + 172);
            v73 = v101;
            if (v101 >= 5)
              v102 = 5;
            else
              v102 = v73;
            --v76;
          }
          while (v77 < v102);
        }
        else
        {
          LOBYTE(v77) = 0;
        }
        *v72 = v73 - v77;
        v106 = *v3;
        if (os_log_type_enabled(*v3, OS_LOG_TYPE_INFO))
        {
          v107 = *(char *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
          if (v107 > 2)
            v108 = CFSTR("UNKNOWN");
          else
            v108 = off_10093F698[v107];
          v110 = *(unsigned __int8 *)(v2
                                    + 544 * *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24)
                                    + 172);
          *(_DWORD *)buf = 138412546;
          *(_QWORD *)&buf[4] = v108;
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v110;
          _os_log_impl((void *)&_mh_execute_header, v106, OS_LOG_TYPE_INFO, "ADVBUFF(%@): after parsing, expectedEntries=%d ", buf, 0x12u);
        }
        v111 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
        if (!*(_BYTE *)(v2 + 544 * *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 172))
        {
          v112 = *v3;
          if (os_log_type_enabled(*v3, OS_LOG_TYPE_INFO))
          {
            if (v111 > 2)
              v113 = CFSTR("UNKNOWN");
            else
              v113 = off_10093F698[(char)v111];
            v121 = *(unsigned __int8 *)(v2 + 144);
            v122 = *(unsigned __int8 *)(v2
                                      + 544 * *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24)
                                      + 172);
            *(_DWORD *)buf = 138412802;
            *(_QWORD *)&buf[4] = v113;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v121;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v122;
            _os_log_impl((void *)&_mh_execute_header, v112, OS_LOG_TYPE_INFO, "ADVBUFF(%@): We're done screenstate=%d fADVBufferExpectedEntries=%d", buf, 0x18u);
            v111 = *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
          }
          *(_BYTE *)(v2 + 160 + 544 * v111 + 12) = -1;
          *(_BYTE *)(v2 + 160 + 544 * *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 11) = 0;
          v123 = sub_1000419F4();
          v129[0] = _NSConcreteStackBlock;
          v129[1] = 3221225472;
          v129[2] = sub_100671374;
          v129[3] = &unk_100917378;
          v129[4] = v2;
          sub_100041A34(v123, v129);
        }
        goto LABEL_31;
      }
      goto LABEL_26;
    }
    if (v15 != 2 || !*(_BYTE *)(v2 + 1260) || *(unsigned __int8 *)(v2 + 1260) == 255)
    {
LABEL_26:
      v22 = qword_100999928;
      if (os_log_type_enabled((os_log_t)qword_100999928, OS_LOG_TYPE_ERROR))
      {
        if (v15 > 2)
          v23 = CFSTR("UNKNOWN");
        else
          v23 = off_10093F698[(char)v15];
        v109 = *(unsigned __int8 *)(v2
                                  + 544 * *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24)
                                  + 172);
        *(_DWORD *)buf = 138412546;
        *(_QWORD *)&buf[4] = v23;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v109;
        _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "ADVBUFF(%@): invalid state expectedEntries=%d", buf, 0x12u);
      }
      goto LABEL_31;
    }
    v24 = 0;
    v25 = *(_QWORD *)(a1 + 48);
    v186 = (_DWORD *)(v25 + 4);
    v187 = (char *)(v25 + 52);
    v188 = (char *)(v25 + 100);
    v189 = (char *)(v25 + 148);
    v190 = (_DWORD *)(v25 + 196);
    do
    {
      v26 = sub_100027F68();
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v26 + 176))(v26))
      {
        v27 = qword_100999948;
        if (os_log_type_enabled((os_log_t)qword_100999948, OS_LOG_TYPE_DEBUG))
        {
          v51 = *(char *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
          v52 = CFSTR("UNKNOWN");
          if (v51 <= 2)
            v52 = off_10093F698[v51];
          v53 = (uint64_t)(&v186)[v24];
          v54 = *(unsigned __int8 *)(v53 + 6);
          v55 = *(unsigned __int16 *)(v53 + 38);
          v56 = *(unsigned __int16 *)(v53 + 40);
          v57 = *(char *)(v53 + 46);
          v58 = *(char *)(v53 + 47);
          *(_DWORD *)buf = 138415874;
          *(_QWORD *)&buf[4] = v52;
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v24;
          *(_WORD *)&buf[18] = 1040;
          *(_DWORD *)&buf[20] = 48;
          *(_WORD *)v156 = 2096;
          *(_QWORD *)&v156[2] = v53;
          *(_WORD *)&v156[10] = 1040;
          *(_DWORD *)&v156[12] = 6;
          *(_WORD *)&v156[16] = 2096;
          v157 = v53;
          *(_WORD *)v158 = 1024;
          *(_DWORD *)&v158[2] = v54;
          *(_WORD *)v159 = 1040;
          *(_DWORD *)&v159[2] = 31;
          v160 = 2096;
          v161 = v53 + 7;
          v162 = 1024;
          v163 = v55;
          v164 = 1024;
          v165 = v56;
          v166 = 1040;
          v167 = 4;
          v168 = 2096;
          v169 = v53 + 42;
          v170 = 1024;
          v171 = v57;
          v172 = 1024;
          v173 = v58;
          _os_log_debug_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEBUG, "ADVBUFF(%@): Parsing entry %d entry_buff:%.48P address:%.6P len:%d payload:%.31P first:%d last:%d rssi:%.4P maxRSSI:%d avgRSSI:%d", buf, 0x70u);
        }
      }
      v28 = (uint64_t)(&v186)[v24];
      v29 = *(unsigned __int8 *)(v28 + 6);
      if (v29 < 0x20)
      {
        bzero(buf, 0x1788uLL);
        v153 = 0u;
        v154 = 0u;
        memset(v152, 0, sizeof(v152));
        sub_10004C878((uint64_t)&v152[2], v28, 6uLL);
        v31 = ((unint64_t)v152[2] << 40) | ((unint64_t)v152[3] << 32) | ((unint64_t)v152[4] << 24) | ((unint64_t)v152[5] << 16) | ((unint64_t)v152[6] << 8) | v152[7] | ((unint64_t)v152[1] << 48);
        if (!v31 || HIWORD(v31) && (HIWORD(v31) != 1 || (v152[2] & 0xC0) == 0x80))
        {
          v32 = qword_100999928;
          if (os_log_type_enabled((os_log_t)qword_100999928, OS_LOG_TYPE_ERROR))
          {
            v59 = *(char *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
            v127 = CFSTR("UNKNOWN");
            if (v59 <= 2)
              v127 = off_10093F698[v59];
            v60 = sub_100021770(v31);
            v61 = (void *)objc_claimAutoreleasedReturnValue(v60);
            *(_DWORD *)v140 = 138412546;
            *(_QWORD *)&v140[4] = v127;
            *(_WORD *)&v140[12] = 2112;
            *(_QWORD *)&v140[14] = v61;
            _os_log_error_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "ADVBUFF(%@): Remote Bluetooth address \"%@\" is invalid!", v140, 0x16u);

          }
        }
        *(_BYTE *)(v28 + 46) = sub_100041C6C(v2, *(char *)(v28 + 46));
        v33 = sub_100041C6C(v2, *(char *)(v28 + 47));
        v34 = v33;
        *(_BYTE *)(v28 + 47) = v33;
        v35 = *(char *)(v28 + 46);
        if (v35 <= 0 && v33 < 1)
        {
          *(_WORD *)v152 = 259;
          *(_WORD *)&v152[8] = *(unsigned __int8 *)(v28 + 6);
          *(_QWORD *)&v152[16] = v28 + 7;
          v152[43] = 0;
          v130 = 0;
          sub_100043758(&v130);
          sub_1000554A4(v152, (uint64_t)buf, v36, v37);
          sub_10004339C(&v130);
          v38 = 0;
          buf[16] = 0;
          v176 = *(unsigned __int8 *)(v2
                                    + 544 * *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24)
                                    + 172)
               - (int)v24 > 1;
          v177 = 257;
          v182 = *(_BYTE *)(v28 + 46);
          v183 = *(_BYTE *)(v28 + 47);
          v174 = v182;
          do
          {
            *(&v178 + v38) = *(_BYTE *)(v28 + 42 + v38);
            ++v38;
          }
          while (v38 != 4);
          v184 = *(unsigned __int16 *)(v28 + 38);
          v185 = *(unsigned __int16 *)(v28 + 40);
          v39 = sub_100027F68();
          if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v39 + 176))(v39))
          {
            v40 = qword_100999948;
            if (os_log_type_enabled((os_log_t)qword_100999948, OS_LOG_TYPE_INFO))
            {
              v43 = *(char *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
              v44 = CFSTR("UNKNOWN");
              if (v43 <= 2)
                v44 = off_10093F698[v43];
              LODWORD(v41) = v184;
              LODWORD(v42) = v185;
              *(_DWORD *)v140 = 138415874;
              *(_QWORD *)&v140[4] = v44;
              *(_WORD *)&v140[12] = 1040;
              *(_DWORD *)&v140[14] = 6;
              *(_WORD *)&v140[18] = 2096;
              *(_QWORD *)&v140[20] = &v152[2];
              *(_WORD *)&v140[28] = 1040;
              *(_DWORD *)&v140[30] = 31;
              *(_WORD *)&v140[34] = 2096;
              *(_QWORD *)&v140[36] = *(_QWORD *)&v152[16];
              *(_WORD *)&v140[44] = 2048;
              *(double *)&v140[46] = (double)v41 * 0.02;
              *(_WORD *)&v140[54] = 2048;
              *(double *)&v140[56] = (double)v42 * 0.02;
              *(_WORD *)v141 = 1024;
              *(_DWORD *)&v141[2] = *(unsigned __int16 *)&v152[8];
              *(_WORD *)&v141[6] = 1024;
              *(_DWORD *)&v141[8] = v182;
              *(_WORD *)&v141[12] = 1024;
              *(_DWORD *)&v141[14] = v183;
              v142 = 1024;
              v143 = v178;
              v144 = 1024;
              v145 = v179;
              v146 = 1024;
              v147 = v180;
              v148 = 1024;
              v149 = v181;
              v150 = 1024;
              v151 = v179 + v178 + 2 * v180;
              _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_INFO, "ADVBUFF(%@): found %.6P payload:%.31P first:%fs last:%fs dataLen:%d maxRSSI:%d avgRSSI:%d bin0:%d bin1:%d bin2:%d bin3:%d total:%d", v140, 0x70u);
            }
          }
          ++*(_QWORD *)(v2 + 2312);
          sub_1000407C4();
        }
        v45 = qword_100999928;
        if (os_log_type_enabled((os_log_t)qword_100999928, OS_LOG_TYPE_ERROR))
        {
          v62 = sub_100021770(v31);
          v63 = (void *)objc_claimAutoreleasedReturnValue(v62);
          *(_DWORD *)v140 = 67109634;
          *(_DWORD *)&v140[4] = v34;
          *(_WORD *)&v140[8] = 1024;
          *(_DWORD *)&v140[10] = v35;
          *(_WORD *)&v140[14] = 2112;
          *(_QWORD *)&v140[16] = v63;
          _os_log_error_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, "Ignoring invalid RSSI level (avg:%d/max:%d) received from device %@", v140, 0x18u);

        }
      }
      else
      {
        v30 = qword_100999928;
        if (os_log_type_enabled((os_log_t)qword_100999928, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = v29;
          _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Ignoring invalid data length %d", buf, 8u);
        }
      }
      ++v24;
      v46 = v2 + 544 * *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      v49 = *(unsigned __int8 *)(v46 + 172);
      v47 = (_BYTE *)(v46 + 172);
      v48 = v49;
      if (v49 >= 5)
        v50 = 5;
      else
        v50 = v48;
    }
    while (v24 < v50);
    *v47 = v48 - v24;
    v64 = qword_100999948;
    if (os_log_type_enabled((os_log_t)qword_100999948, OS_LOG_TYPE_INFO))
    {
      v66 = *(char *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
      if (v66 > 2)
        v67 = CFSTR("UNKNOWN");
      else
        v67 = off_10093F698[v66];
      v114 = *(unsigned __int8 *)(v2 + 544 * *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 172);
      *(_DWORD *)buf = 138412546;
      *(_QWORD *)&buf[4] = v67;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v114;
      _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_INFO, "ADVBUFF(%@): after parsing,expectedEntries=%d ", buf, 0x12u);
    }
    v115 = v2 + 544 * *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    v117 = *(unsigned __int8 *)(v115 + 172);
    v116 = (_BYTE *)(v115 + 172);
    if (!v117)
    {
      *v116 = -1;
      v118 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
      {
        v119 = *(char *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
        if (v119 > 2)
          v120 = CFSTR("UNKNOWN");
        else
          v120 = off_10093F698[v119];
        v124 = *(unsigned __int8 *)(v2
                                  + 544 * *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24)
                                  + 172);
        *(_DWORD *)buf = 138412546;
        *(_QWORD *)&buf[4] = v120;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v124;
        _os_log_impl((void *)&_mh_execute_header, v118, OS_LOG_TYPE_INFO, "ADVBUFF(%@): We're done expectedEntries=%d", buf, 0x12u);
      }
      v125 = sub_1000419F4();
      *(_QWORD *)buf = _NSConcreteStackBlock;
      *(_QWORD *)&buf[8] = 3221225472;
      *(_QWORD *)&buf[16] = sub_10067C28C;
      *(_QWORD *)v156 = &unk_100917378;
      *(_QWORD *)&v156[8] = v2;
      sub_100041A34(v125, buf);
      sub_100671BC4(v2, *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), 1);
      sub_10067217C(v2);
      *(_BYTE *)(v2 + 544 * *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) + 171) = 0;
    }
  }
  else
  {
    v20 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      if (v15 > 2)
        v21 = CFSTR("UNKNOWN");
      else
        v21 = off_10093F698[(char)v15];
      *(_DWORD *)buf = 138412290;
      *(_QWORD *)&buf[4] = v21;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "ADVBUFF(%@): Received AdvBufferEvent for a buffer that is not created, ignoring", buf, 0xCu);
    }
  }
LABEL_31:
  free(*(void **)(a1 + 48));
}

void sub_10067134C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  _Unwind_Resume(exception_object);
}

void sub_100671374(uint64_t a1)
{
  sub_10067137C(*(_QWORD *)(a1 + 32));
}

void sub_10067137C(uint64_t a1)
{
  NSObject *v2;
  __int128 v3;
  unint64_t v4;
  unsigned __int8 *v5;
  NSObject *v6;
  const __CFString *v7;
  int v8;
  int v9;
  NSObject *v10;
  const __CFString *v11;
  int v12;
  int v13;
  NSObject *v14;
  const __CFString *v15;
  NSObject *v16;
  const __CFString *v17;
  NSObject *v18;
  const __CFString *v19;
  int v20;
  const __CFString *v21;
  uint64_t v22;
  void *v23;
  void *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  NSObject *v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  NSObject *v33;
  const __CFString *v34;
  int v35;
  NSObject *v36;
  const __CFString *v37;
  const __CFString *v38;
  uint64_t v39;
  uint64_t v41;
  const __CFString *v43;
  NSObject *v44;
  const __CFString *v45;
  __int128 v46;
  _QWORD v47[5];
  char v48;
  char v49[15];
  uint8_t buf[4];
  const __CFString *v51;
  __int16 v52;
  _BYTE v53[10];
  uint64_t v54;
  __int16 v55;
  uint64_t v56;

  if (qword_1009940F0 != -1)
    dispatch_once(&qword_1009940F0, &stru_10093EEB8);
  v2 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "ADVBUFF readNextADVBuffer", buf, 2u);
  }
  if (sub_10006E040(a1))
  {
    v4 = 0;
    v5 = (unsigned __int8 *)(a1 + 169);
    *(_QWORD *)&v3 = 138413058;
    v46 = v3;
    do
    {
      v6 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
      {
        v7 = CFSTR("UNKNOWN");
        if (v4 <= 2u)
          v7 = off_10093F698[v4];
        v8 = *v5;
        v9 = *(unsigned __int8 *)(a1 + v4 + 1793);
        *(_DWORD *)buf = 138412802;
        v51 = v7;
        v52 = 1024;
        *(_DWORD *)v53 = v8;
        *(_WORD *)&v53[4] = 1024;
        *(_DWORD *)&v53[6] = v9;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "ADVBUFF(%@): pendingDraining:%d fObjectDiscoveryBuffersToRead:%d", buf, 0x18u);
      }
      if (*(_BYTE *)(a1 + v4 + 1793) && *v5)
      {
        *(_BYTE *)(a1 + v4 + 1793) = 0;
        v10 = qword_100999828;
        if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
        {
          v11 = CFSTR("UNKNOWN");
          if (v4 <= 2u)
            v11 = off_10093F698[v4];
          v12 = v5[3];
          v13 = v5[2];
          *(_DWORD *)buf = 138412802;
          v51 = v11;
          v52 = 1024;
          *(_DWORD *)v53 = v12;
          *(_WORD *)&v53[4] = 1024;
          *(_DWORD *)&v53[6] = v13;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "ADVBUFF(%@): expectedEntries=%d readInProgress:%d", buf, 0x18u);
        }
        if (v5[3] == 255)
        {
          v14 = qword_100999828;
        }
        else
        {
          v14 = qword_100999828;
          if (!v5[2])
          {
            if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
            {
              if (v4 > 2u)
                v43 = CFSTR("UNKNOWN");
              else
                v43 = off_10093F698[v4];
              *(_DWORD *)buf = 138412290;
              v51 = v43;
              _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "ADVBUFF(%@): Already reading ADV Buffer", buf, 0xCu);
            }
LABEL_78:
            v44 = qword_100999828;
            if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
            {
              if (v4 > 2u)
                v45 = CFSTR("UNKNOWN");
              else
                v45 = off_10093F698[(char)v4];
              *(_DWORD *)buf = 138412546;
              v51 = v45;
              v52 = 1024;
              *(_DWORD *)v53 = v4;
              _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_INFO, "ADVBUFF(%@): waiting for buffer %d events", buf, 0x12u);
            }
            return;
          }
        }
        if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
        {
          v15 = CFSTR("UNKNOWN");
          if (v4 <= 2u)
            v15 = off_10093F698[v4];
          *(_DWORD *)buf = 138412290;
          v51 = v15;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "ADVBUFF(%@): Pausing ADV Buffers", buf, 0xCu);
        }
        if (sub_100671BC4(a1, v4, 0))
        {
          v16 = qword_100999828;
          if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
          {
            v17 = CFSTR("UNKNOWN");
            if (v4 <= 2u)
              v17 = off_10093F698[(char)v4];
            *(_DWORD *)buf = 138412290;
            v51 = v17;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_INFO, "ADVBUFF(%@): could not disable ADV buffering", buf, 0xCu);
          }
        }
        else
        {
          v5[2] = 1;
          sub_100673C68(a1);
          sub_100673CFC(a1);
          v18 = qword_100999828;
          if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
          {
            v19 = CFSTR("UNKNOWN");
            if (v4 <= 2u)
              v19 = off_10093F698[(char)v4];
            *(_DWORD *)buf = 138412290;
            v51 = v19;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_INFO, "ADVBUFF(%@): Trying to read", buf, 0xCu);
          }
          *(_BYTE *)(a1 + 1796) = v4;
          v20 = sub_100673E40(a1, v4);
          if (v4 == 1)
            v21 = CFSTR("NearOwner");
          else
            v21 = CFSTR("Wild");
          objc_msgSend(*(id *)(a1 + 152), "setObject:forKeyedSubscript:", v21, CFSTR("AdvertisementBufferType"), v46);
          if (v5[3] == 255)
            v22 = 0;
          else
            v22 = v5[3];
          v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v22));
          objc_msgSend(*(id *)(a1 + 152), "setObject:forKeyedSubscript:", v23, CFSTR("CurrentCapacityAtDrain"));

          v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", 100));
          objc_msgSend(*(id *)(a1 + 152), "setObject:forKeyedSubscript:", v24, CFSTR("MaxCapacity"));

          v25 = mach_continuous_time() * dword_1009940E8 / *(unsigned int *)algn_1009940EC / 0x3B9ACA00;
          v26 = *(_QWORD *)(v5 + 15);
          if (v26)
            v27 = v25 - v26;
          else
            v27 = 0;
          v28 = qword_100999828;
          if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEBUG))
          {
            v38 = CFSTR("UNKNOWN");
            if (v4 <= 2u)
              v38 = off_10093F698[(char)v4];
            v39 = *(_QWORD *)(v5 + 15);
            *(_DWORD *)buf = v46;
            v51 = v38;
            v52 = 2048;
            *(_QWORD *)v53 = v39;
            *(_WORD *)&v53[8] = 2048;
            v54 = v25;
            v55 = 2048;
            v56 = v27;
            _os_log_debug_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEBUG, "ADVBUFF(%@): lastReadTimeStamp:%llu now:%llu delta:%llu", buf, 0x2Au);
          }
          *(_QWORD *)(v5 + 15) = v25;
          v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v27));
          objc_msgSend(*(id *)(a1 + 152), "setObject:forKeyedSubscript:", v29, CFSTR("TimeSinceLastDrainInSeconds"));

          v30 = sub_100065478();
          (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v30 + 376))(v30, *(_QWORD *)(a1 + 152));
          if (v4 < 2)
          {
            if (v4)
              v31 = 74;
            else
              v31 = 75;
            v32 = (_QWORD *)sub_100065478();
            (*(void (**)(void))(*v32 + 8 * v31))();
          }
          v33 = qword_100999828;
          if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
          {
            v34 = CFSTR("UNKNOWN");
            if (v4 <= 2u)
              v34 = off_10093F698[(char)v4];
            v35 = v5[3];
            *(_DWORD *)buf = 138412802;
            v51 = v34;
            v52 = 1024;
            *(_DWORD *)v53 = v20;
            *(_WORD *)&v53[4] = 1024;
            *(_DWORD *)&v53[6] = v35;
            _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_INFO, "ADVBUFF(%@): ReadADVBuffer returned %d, fADVBufferExpectedEntries:%d", buf, 0x18u);
          }
          if (v20 && os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_FAULT))
            sub_1007166E8(&v48, v49);
          if (v5[3] != 255)
            goto LABEL_78;
          v5[2] = 0;
        }
        if ((_os_feature_enabled_impl("BluetoothFeatures", "SentinelNewLocationFeatures") & 1) == 0)
          sub_10067366C();
        v36 = qword_100999828;
        if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
        {
          v37 = CFSTR("UNKNOWN");
          if (v4 <= 2u)
            v37 = off_10093F698[(char)v4];
          *(_DWORD *)buf = 138412290;
          v51 = v37;
          _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_INFO, "ADVBUFF(%@): trying to read the next buffer", buf, 0xCu);
        }
      }
      ++v4;
      v5 += 544;
    }
    while (v4 != 3);
    if (_os_feature_enabled_impl("BluetoothFeatures", "SentinelNewLocationFeatures"))
    {
      v41 = sub_1000419F4();
      v47[0] = _NSConcreteStackBlock;
      v47[1] = 3221225472;
      v47[2] = sub_100674284;
      v47[3] = &unk_100917378;
      v47[4] = a1;
      sub_100041A34(v41, v47);
    }
    sub_10005C80C(a1);
  }
}

void sub_100671BA4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t sub_100671BC4(uint64_t a1, uint64_t a2, int a3)
{
  NSObject *v4;
  uint64_t v5;
  unsigned int v8;
  NSObject *v9;
  const __CFString *v10;
  NSObject *v11;
  const __CFString *v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  _BYTE *v16;
  int v17;
  NSObject *v18;
  _BOOL4 v19;
  const __CFString *v20;
  NSObject *v21;
  const __CFString *v22;
  const __CFString *v23;
  const char *v24;
  const char *v25;
  uint64_t v26;
  NSObject *v27;
  const __CFString *v28;
  uint64_t v29;
  _BYTE *v30;
  char v31;
  NSObject *v32;
  const __CFString *v33;
  int v34;
  uint64_t v35;
  uint64_t *v36;
  NSObject *v37;
  const __CFString *v38;
  uint64_t v39;
  int v41;
  const __CFString *v42;
  __int16 v43;
  _BYTE v44[10];
  __int16 v45;
  int v46;

  if (a2 >= 3)
  {
    v4 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      v41 = 67109120;
      LODWORD(v42) = a2;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "HW ADV Buffer handle out of range (%d), ignoring agent request", (uint8_t *)&v41, 8u);
    }
    return 7;
  }
  v8 = a2;
  if (a3 && *(_BYTE *)(a1 + 544 * a2 + 170) && *(_BYTE *)(a1 + 544 * a2 + 167))
  {
    v9 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
    {
      if (a2 > 2)
        v10 = CFSTR("UNKNOWN");
      else
        v10 = off_10093F698[(char)a2];
      v41 = 138543362;
      v42 = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "ADVBUFF(%{public}@): created and pending destroy", (uint8_t *)&v41, 0xCu);
    }
    sub_10066D748(a1, a2);
  }
  v11 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
  {
    if (a2 > 2)
      v12 = CFSTR("UNKNOWN");
    else
      v12 = off_10093F698[(char)a2];
    v13 = a1 + 544 * a2;
    v14 = *(unsigned __int8 *)(v13 + 167);
    LODWORD(v13) = *(unsigned __int8 *)(v13 + 168);
    v41 = 138544130;
    v42 = v12;
    v43 = 1024;
    *(_DWORD *)v44 = a3;
    *(_WORD *)&v44[4] = 1024;
    *(_DWORD *)&v44[6] = v14;
    v45 = 1024;
    v46 = v13;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "ADVBUFF(%{public}@): enableADVBuffering enable=%d created=%d enabled=%d", (uint8_t *)&v41, 0x1Eu);
  }
  if (!*(_BYTE *)(a1 + 544 * v8 + 167))
  {
    v21 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
    {
      if (a2 > 2)
        v22 = CFSTR("UNKNOWN");
      else
        v22 = off_10093F698[(char)a2];
      v41 = 138543362;
      v42 = v22;
      v5 = 12;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_INFO, "ADVBUFF(%{public}@): not created", (uint8_t *)&v41, 0xCu);
      return v5;
    }
    return 12;
  }
  v15 = a1 + 544 * v8;
  v17 = *(unsigned __int8 *)(v15 + 168);
  v16 = (_BYTE *)(v15 + 168);
  v18 = qword_100999828;
  v19 = os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO);
  if (v17 == a3)
  {
    if (v19)
    {
      if (a2 > 2)
        v20 = CFSTR("UNKNOWN");
      else
        v20 = off_10093F698[(char)a2];
      v24 = "paused";
      if (a3)
        v24 = "active";
      v41 = 138543618;
      v42 = v20;
      v43 = 2082;
      *(_QWORD *)v44 = v24;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_INFO, "ADVBUFF(%{public}@): already %{public}s", (uint8_t *)&v41, 0x16u);
    }
    return 12;
  }
  if (v19)
  {
    if (a2 > 2)
      v23 = CFSTR("UNKNOWN");
    else
      v23 = off_10093F698[(char)a2];
    v25 = "pausing";
    if (a3)
      v25 = "activating";
    v41 = 138543618;
    v42 = v23;
    v43 = 2082;
    *(_QWORD *)v44 = v25;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_INFO, "ADVBUFF(%{public}@): mode change -> %{public}s ", (uint8_t *)&v41, 0x16u);
  }
  v26 = sub_1000438A4();
  v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)v26 + 2856))(v26, a2, 1, a3 ^ 1u);
  v27 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
  {
    if (a2 > 2)
      v28 = CFSTR("UNKNOWN");
    else
      v28 = off_10093F698[(char)a2];
    v41 = 138543618;
    v42 = v28;
    v43 = 1024;
    *(_DWORD *)v44 = v5;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_INFO, "ADVBUFF(%{public}@): advBufMatchControl returned %d", (uint8_t *)&v41, 0x12u);
  }
  if ((_DWORD)v5)
  {
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
      sub_100716714();
  }
  else
  {
    *v16 = a3;
    v29 = a1 + 544 * v8;
    v31 = *(_BYTE *)(v29 + 169);
    v30 = (_BYTE *)(v29 + 169);
    *v30 = v31 | a3;
    v32 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
    {
      if (a2 > 2)
        v33 = CFSTR("UNKNOWN");
      else
        v33 = off_10093F698[(char)a2];
      v34 = *v30;
      v41 = 138543618;
      v42 = v33;
      v43 = 1024;
      *(_DWORD *)v44 = v34;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_INFO, "ADVBUFF(%{public}@): pendingDraining:%d", (uint8_t *)&v41, 0x12u);
    }
    if (a3)
    {
      v35 = a1 + 544 * v8;
      *(CFAbsoluteTime *)(v35 + 176) = CFAbsoluteTimeGetCurrent();
      v36 = (uint64_t *)(v35 + 176);
      v37 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
      {
        if (a2 > 2)
          v38 = CFSTR("UNKNOWN");
        else
          v38 = off_10093F698[(char)a2];
        v39 = *v36;
        v41 = 138543618;
        v42 = v38;
        v43 = 2048;
        *(_QWORD *)v44 = v39;
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_INFO, "ADVBUFF(%{public}@): setting start time to %f", (uint8_t *)&v41, 0x16u);
      }
    }
    return 0;
  }
  return v5;
}

void sub_10067217C(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  NSObject *v4;
  NSObject *v5;
  uint64_t v6;
  dispatch_time_t v7;
  uint64_t v8;
  void *v9;
  double v10;
  double v11;
  xpc_object_t v12;
  NSObject *v13;
  _QWORD handler[5];
  uint8_t buf[4];
  uint64_t v16;

  if (!*(_QWORD *)(a1 + 2272))
  {
    v2 = sub_1000419F4();
    v3 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, *(dispatch_queue_t *)(v2 + 8));
    *(_QWORD *)(a1 + 2272) = v3;
    v4 = qword_100999948;
    if (os_log_type_enabled((os_log_t)qword_100999948, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "fContactTracingScanDeltaTimer Timer Armed!", buf, 2u);
      v3 = *(NSObject **)(a1 + 2272);
    }
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472;
    handler[2] = sub_10067CAA0;
    handler[3] = &unk_100917378;
    handler[4] = a1;
    dispatch_source_set_event_handler(v3, handler);
    v5 = *(NSObject **)(a1 + 2272);
    if (qword_10097B180 != -1)
      dispatch_once(&qword_10097B180, &stru_10093F518);
    v6 = sub_10041C350((uint64_t)off_10097B178);
    v7 = dispatch_time(0x8000000000000000, 1000000 * v6);
    dispatch_source_set_timer(v5, v7, 0xFFFFFFFFFFFFFFFFLL, 0);
    dispatch_activate(*(dispatch_object_t *)(a1 + 2272));
    if (*(_BYTE *)(a1 + 1255))
    {
      if (qword_10097B180 != -1)
        dispatch_once(&qword_10097B180, &stru_10093F518);
      v8 = sub_10041C26C((uint64_t)off_10097B178);
    }
    else
    {
      if (qword_10097B180 != -1)
        dispatch_once(&qword_10097B180, &stru_10093F518);
      v8 = sub_10041C7D8((uint64_t)off_10097B178);
    }
    v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate date](NSDate, "date"));
    objc_msgSend(v9, "timeIntervalSince1970");
    v11 = v10;

    v12 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_date(v12, "Date", (uint64_t)((v11 + (double)v8) * 1000000000.0));
    v13 = qword_100999948;
    if (os_log_type_enabled((os_log_t)qword_100999948, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      v16 = v8;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "XPC event com.apple.alarm for %llu seconds armed!", buf, 0xCu);
    }
    xpc_set_event("com.apple.alarm", "com.apple.bluetooth.contactTracingScanSystemWake", v12);
    xpc_release(v12);
  }
}

void sub_100672420(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_100672438(uint64_t a1, _OWORD *a2)
{
  _OWORD *v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  _QWORD v17[6];

  v4 = malloc_type_malloc(0xEEuLL, 0x1000040AEA256DBuLL);
  v6 = a2[1];
  v5 = a2[2];
  *v4 = *a2;
  v4[1] = v6;
  v4[2] = v5;
  v7 = a2[6];
  v9 = a2[3];
  v8 = a2[4];
  v4[5] = a2[5];
  v4[6] = v7;
  v4[3] = v9;
  v4[4] = v8;
  v10 = a2[10];
  v12 = a2[7];
  v11 = a2[8];
  v4[9] = a2[9];
  v4[10] = v10;
  v4[7] = v12;
  v4[8] = v11;
  v14 = a2[12];
  v13 = a2[13];
  v15 = a2[11];
  *(_OWORD *)((char *)v4 + 222) = *(_OWORD *)((char *)a2 + 222);
  v4[12] = v14;
  v4[13] = v13;
  v4[11] = v15;
  v16 = sub_1000419F4();
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 3221225472;
  v17[2] = sub_100672508;
  v17[3] = &unk_100918090;
  v17[4] = a1;
  v17[5] = v4;
  sub_100041A34(v16, v17);
}

void sub_100672508(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  int v3;
  int v4;
  unsigned int v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unsigned __int8 v15;
  NSObject *v16;
  unsigned __int8 *v17;
  int v18;
  id v19;
  void *v20;
  uint8x8_t v21;
  int16x8_t v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  NSObject *v27;
  NSObject *v28;
  int v29;
  unsigned __int8 v30;
  NSObject *v31;
  NSObject *v32;
  int v33;
  const char *v34;
  uint64_t v35;
  NSObject *v36;
  _BOOL4 v37;
  int v38;
  char v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  uint8_t v46[4];
  int v47;
  __int16 v48;
  char *v49;
  __int16 v50;
  unsigned int v51;
  __int16 v52;
  unsigned int v53;
  __int16 v54;
  unsigned int v55;
  __int16 v56;
  int v57;
  int buf;
  int v59;
  __int16 v60;
  int v61;
  __int16 v62;
  int v63;
  __int16 v64;
  const char *v65;
  unsigned int v66;
  BOOL v67;
  char v68;
  _QWORD v69[13];

  v1 = *(_QWORD *)(a1 + 32);
  v2 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
  {
    v3 = *(unsigned __int8 *)(v1 + 1851);
    v4 = *(unsigned __int8 *)(v1 + 1852);
    buf = 67109376;
    v59 = v3;
    v60 = 1024;
    v61 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Match Buffer matchBufferEvent fMatchBufferExpectedEntries:%d fMatchBufferEntriesReceived:%d", (uint8_t *)&buf, 0xEu);
  }
  if (*(unsigned __int8 *)(v1 + 1851) == 255 && os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_FAULT))
    sub_100716864();
  v5 = *(unsigned __int8 *)(v1 + 1852);
  if (v5 <= 0x13 && *(unsigned __int8 *)(v1 + 1851) != 255)
  {
    v6 = 0;
    v7 = *(_QWORD *)(a1 + 40);
    v69[0] = v7 + 4;
    v69[1] = v7 + 22;
    v69[2] = v7 + 40;
    v69[3] = v7 + 58;
    v69[4] = v7 + 76;
    v8 = v7 + 130;
    v9 = v7 + 148;
    v10 = v7 + 166;
    v69[5] = v7 + 94;
    v69[6] = v7 + 112;
    v11 = v7 + 184;
    v12 = v7 + 202;
    v13 = v7 + 220;
    v69[7] = v8;
    v69[8] = v9;
    if (v5 >= 7)
      v14 = 20 - v5;
    else
      v14 = 13;
    v69[9] = v10;
    v69[10] = v11;
    v69[11] = v12;
    v69[12] = v13;
    do
    {
      v15 = *(_BYTE *)(v1 + 1852) + v6;
      v16 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
      {
        buf = 67109376;
        v59 = v6;
        v60 = 1024;
        v61 = v15;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_INFO, "Match Buffer Parsing i:%d tableIndex:%d", (uint8_t *)&buf, 0xEu);
      }
      v17 = (unsigned __int8 *)v69[v6];
      v18 = (char)v17[17];
      if (v17[17] && *(_DWORD *)(v17 + 13))
      {
        --*(_BYTE *)(v1 + 1851);
        bzero(&buf, 0x1788uLL);
        v44 = 0u;
        v45 = 0u;
        v42 = 0u;
        v43 = 0u;
        v41 = 0u;
        v19 = objc_msgSend((id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v1 + 2112), "objectAtIndex:", v15)), "objectForKeyedSubscript:", CFSTR("MatchActionRulePeerAddress"));
        v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
        objc_msgSend(v20, "getBytes:range:", (char *)&v41 + 2, 0, 6);

        LOWORD(v41) = 259;
        WORD4(v41) = *v17 + 1;
        BYTE8(v42) = sub_100041C6C(v1, (char)v17[17]);
        *(_QWORD *)&v42 = v17;
        BYTE11(v43) = 0;
        v40 = 0;
        sub_100043758(&v40);
        sub_1000554A4((unsigned __int8 *)&v41, (uint64_t)&buf, v21, v22);
        sub_10004339C(&v40);
        v67 = *(_BYTE *)(v1 + 1851) != 0;
        v68 = 1;
        v23 = **(_DWORD **)(a1 + 40);
        v24 = *(_DWORD *)(v17 + 13);
        v25 = v23 + 0xFFFFFFF;
        if (v23 >= v24)
          v25 = **(_DWORD **)(a1 + 40);
        v26 = v25 - v24;
        v66 = v25 - v24;
        v27 = qword_100999828;
        if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)v46 = 68158978;
          v47 = 6;
          v48 = 2096;
          v49 = (char *)&v41 + 2;
          v50 = 1024;
          v51 = v23;
          v52 = 1024;
          v53 = v24;
          v54 = 1024;
          v55 = v26;
          v56 = 1024;
          v57 = WORD4(v41);
          _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_INFO, "ADV Buffer found %.6P now:%u event:%u delta:%u dataLen:%d", v46, 0x2Au);
        }
        sub_1000407C4();
      }
      v28 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEBUG))
      {
        v29 = *(_DWORD *)(v17 + 13);
        buf = 67109888;
        v59 = v6;
        v60 = 1024;
        v61 = v15;
        v62 = 1024;
        v63 = v18;
        v64 = 1024;
        LODWORD(v65) = v29;
        _os_log_debug_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEBUG, "Skipping entry i:%d tableIndex:%d rssi:%d timeStamp:%d", (uint8_t *)&buf, 0x1Au);
      }
      ++v6;
    }
    while (v6 < v14);
    v30 = *(_BYTE *)(v1 + 1852) + 13;
    *(_BYTE *)(v1 + 1852) = v30;
    v31 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEBUG))
    {
      v38 = *(unsigned __int8 *)(v1 + 1851);
      buf = 67109376;
      v59 = v38;
      v60 = 1024;
      v61 = v30;
      _os_log_debug_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEBUG, "Match Buffer after parsing,fMatchBufferExpectedEntries:%d fMatchBufferEntriesReceived:%d", (uint8_t *)&buf, 0xEu);
      v30 = *(_BYTE *)(v1 + 1852);
    }
    if (v30 >= 0x14u)
    {
      *(_WORD *)(v1 + 1851) = 255;
      v32 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
      {
        v33 = *(unsigned __int8 *)(v1 + 144);
        if (*(_QWORD *)(v1 + 2120))
          v34 = "YES";
        else
          v34 = "NO";
        buf = 67109890;
        v59 = v33;
        v60 = 1024;
        v61 = 255;
        v62 = 1024;
        v63 = 0;
        v64 = 2082;
        v65 = v34;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_INFO, "Match Buffer We're done screenstate=%d fMatchBufferExpectedEntries:%d fMatchBufferEntriesReceived:%d pendingRules:%{public}s", (uint8_t *)&buf, 0x1Eu);
      }
      *(_BYTE *)(v1 + 1853) = 0;
      v35 = *(_QWORD *)(v1 + 2120);
      v36 = qword_100999828;
      v37 = os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO);
      if (v35)
      {
        if (v37)
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_INFO, "Match Buffer Reconfiguring the table", (uint8_t *)&buf, 2u);
        }
        sub_100672B94(v1);
        if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEBUG))
          sub_100716804();
      }
      else
      {
        if (v37)
        {
          LOWORD(buf) = 0;
          _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_INFO, "Match Buffer enabling the buffer again after reading", (uint8_t *)&buf, 2u);
        }
        sub_1006730E0(v1, 1);
        if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEBUG))
          sub_1007167A4();
      }
    }
  }
  free(*(void **)(a1 + 40));
}

void sub_100672B5C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t sub_100672B94(uint64_t a1)
{
  NSObject *v2;
  id *v3;
  void *v4;
  uint64_t v5;
  NSObject *v6;
  int v7;
  NSObject *v8;
  __int128 v10;
  unsigned int v11;
  unsigned int v12;
  unsigned __int8 v13;
  NSObject *v14;
  unsigned __int8 v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  NSObject *v20;
  void *v21;
  void *v22;
  uint8_t *v23;
  uint64_t v24;
  uint64_t v25;
  __int128 v26;
  unsigned int v27;
  unsigned int v28;
  unsigned __int8 v29;
  unsigned __int8 v30;
  char v31;
  unsigned __int16 v32;
  uint8_t v33[4];
  void *v34;
  uint8_t buf[16];
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  _OWORD v48[2];

  v2 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "configureMatchActionRulesTableInternal", buf, 2u);
  }
  v3 = (id *)(a1 + 2112);
  objc_storeStrong((id *)(a1 + 2112), *(id *)(a1 + 2120));
  v4 = *(void **)(a1 + 2120);
  *(_QWORD *)(a1 + 2120) = 0;

  if (*(_QWORD *)(a1 + 2112) && objc_msgSend(*(id *)(a1 + 2112), "count"))
  {
    v32 = 256;
    v5 = sub_10067AAB4(a1, &v32);
    v6 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "createMatchActionRulesTable returned %d", buf, 8u);
    }
    if ((_DWORD)v5 != 15 && (_DWORD)v5)
    {
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
        sub_100716894();
    }
    else
    {
      if ((unint64_t)objc_msgSend(*v3, "count") > 0x13)
        v7 = 20;
      else
        v7 = objc_msgSend(*v3, "count");
      v28 = v7;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEBUG))
        sub_1007169B4();
      v27 = v32;
      v11 = v28;
      if (v28)
      {
        v12 = 0;
        v13 = 0;
        v14 = qword_100999828;
        *(_QWORD *)&v10 = 67109120;
        v26 = v10;
        while (1)
        {
          v29 = v13;
          v31 = v12;
          *(_OWORD *)((char *)v48 + 14) = 0u;
          if ((int)(v11 - v12) >= 14)
            v15 = 14;
          else
            v15 = v11 - v12;
          v47 = 0uLL;
          v48[0] = 0uLL;
          v45 = 0uLL;
          v46 = 0uLL;
          v43 = 0uLL;
          v44 = 0uLL;
          v42 = 0uLL;
          v40 = 0uLL;
          v41 = 0uLL;
          v38 = 0uLL;
          v39 = 0uLL;
          v36 = 0uLL;
          v37 = 0uLL;
          *(_OWORD *)buf = 0uLL;
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)v33 = v26;
            LODWORD(v34) = v15;
            _os_log_debug_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "count=%d", v33, 8u);
          }
          v30 = v15;
          if (v15)
          {
            v16 = 0;
            v17 = v12;
            v18 = 17 * v15;
            do
            {
              v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*v3, "objectAtIndex:", v17, v26));
              v20 = qword_100999828;
              if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)v33 = 138412290;
                v34 = v19;
                _os_log_debug_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEBUG, "rule=%@", v33, 0xCu);
              }
              v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v19, "objectForKeyedSubscript:", CFSTR("MatchActionRuleLocalToken")));
              objc_msgSend(v21, "getBytes:range:", &buf[v16 + 7], 0, 6);

              v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v19, "objectForKeyedSubscript:", CFSTR("MatchActionRulePeerAddress")));
              objc_msgSend(v22, "getBytes:range:", &buf[v16], 0, 6);

              v23 = &buf[v16];
              v23[6] = 1;
              v23[13] = 18;

              v16 += 17;
              ++v17;
            }
            while (v18 != v16);
          }
          v24 = sub_1000438A4();
          v13 = v30 + v31;
          v5 = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD, uint8_t *))(*(_QWORD *)v24 + 2880))(v24, v27, v29, (v30 + v31 - 1), buf);
          v14 = qword_100999828;
          if ((_DWORD)v5)
            break;
          v12 = (v30 + v31);
          if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)v33 = v26;
            LODWORD(v34) = (v30 + v31);
            _os_log_debug_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "entriesSent=%d", v33, 8u);
            v14 = qword_100999828;
          }
          v11 = v28;
          if (v28 <= v12)
          {
            v27 = v32;
            goto LABEL_39;
          }
        }
        if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
          sub_100716954();
      }
      else
      {
LABEL_39:
        v25 = sub_1000438A4();
        v5 = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, _QWORD))(*(_QWORD *)v25 + 2856))(v25, v27, 1, 0);
        if ((_DWORD)v5 && os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
          sub_1007168F4();
      }
    }
  }
  else
  {
    v8 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "new Match table rules are nil", buf, 2u);
    }
    return 0;
  }
  return v5;
}

void sub_1006730B0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t sub_1006730E0(uint64_t a1, int a2)
{
  NSObject *v4;
  NSObject *v5;
  uint64_t v6;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  BOOL v11;
  NSObject *v12;
  uint64_t v13;
  NSObject *v14;
  const char *v15;
  uint64_t v16;
  int v17;
  const char *v18;

  v4 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
  {
    v17 = 67109120;
    LODWORD(v18) = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Match Buffer enableMatchBuffering enable=%d", (uint8_t *)&v17, 8u);
  }
  if (*(unsigned __int8 *)(a1 + 1851) == 255)
  {
    v8 = *(_QWORD **)(a1 + 1816);
    if (v8 == (_QWORD *)(a1 + 1824))
    {
LABEL_16:
      v12 = qword_100999828;
      v6 = 0;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v17) = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "No table is configured", (uint8_t *)&v17, 2u);
        return 0;
      }
    }
    else
    {
      while (*((_BYTE *)v8 + 28) != 18)
      {
        v9 = (_QWORD *)v8[1];
        if (v9)
        {
          do
          {
            v10 = v9;
            v9 = (_QWORD *)*v9;
          }
          while (v9);
        }
        else
        {
          do
          {
            v10 = (_QWORD *)v8[2];
            v11 = *v10 == (_QWORD)v8;
            v8 = v10;
          }
          while (!v11);
        }
        v8 = v10;
        if (v10 == (_QWORD *)(a1 + 1824))
          goto LABEL_16;
      }
      v13 = *((unsigned __int16 *)v8 + 15);
      v14 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
      {
        v15 = "pausing";
        if (a2)
          v15 = "activating";
        v17 = 136446210;
        v18 = v15;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "Match Buffer mode change -> %{public}s ", (uint8_t *)&v17, 0xCu);
      }
      v16 = sub_1000438A4();
      v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)v16 + 2856))(v16, v13, 1, a2 ^ 1u);
      if ((_DWORD)v6 && os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
        sub_100716A14();
    }
  }
  else
  {
    v5 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v17) = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "We're in the middle of reading it, we cant pause now", (uint8_t *)&v17, 2u);
    }
    return 12;
  }
  return v6;
}

void sub_100673324(uint64_t a1, uint64_t a2)
{
  id v2;

  if (a2)
  {
    v2 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", a2, *(unsigned __int8 *)(a2 + 1) + 4);
    objc_msgSend(gCBDaemonServer, "aopMessageReceived:");

  }
}

void sub_100673394(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint64_t sub_1006733AC(uint64_t a1, void *a2)
{
  id v3;
  NSObject *v4;
  uint64_t v5;
  id v6;
  NSObject *v7;
  uint64_t v8;
  void *v9;
  NSObject *v10;
  int v11;
  NSObject *v12;
  NSObject *v13;
  const char *v14;
  NSObject *v15;
  int v17;
  id v18;

  v3 = a2;
  v4 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
  {
    v17 = 138412290;
    v18 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Setting up match rules with %@", (uint8_t *)&v17, 0xCu);
  }
  v5 = sub_10003BE44();
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 704))(v5))
  {
    if (v3)
      v6 = v3;
    else
      v6 = (id)objc_claimAutoreleasedReturnValue(+[NSArray array](NSArray, "array"));
    v9 = *(void **)(a1 + 2120);
    *(_QWORD *)(a1 + 2120) = v6;

    v8 = sub_1006730E0(a1, 0);
    if (!(_DWORD)v8)
    {
      v10 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
      {
        LOWORD(v17) = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "succesfully paused", (uint8_t *)&v17, 2u);
      }
      v11 = sub_1006755B0(a1);
      v12 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
      {
        v17 = 67109120;
        LODWORD(v18) = v11;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "readMatchBuffers returned %d", (uint8_t *)&v17, 8u);
      }
      if (v11 == 12)
      {
        v13 = qword_100999828;
        if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
        {
          LOWORD(v17) = 0;
          v14 = "Match buffer read already in progress";
          goto LABEL_21;
        }
LABEL_22:
        v8 = 0;
        goto LABEL_26;
      }
      if (!v11)
      {
        v13 = qword_100999828;
        if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
        {
          LOWORD(v17) = 0;
          v14 = "Match buffer read started";
LABEL_21:
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_INFO, v14, (uint8_t *)&v17, 2u);
          goto LABEL_22;
        }
        goto LABEL_22;
      }
      v15 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
      {
        LOWORD(v17) = 0;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_INFO, "we need to reconfigure now", (uint8_t *)&v17, 2u);
      }
      v8 = sub_100672B94(a1);
    }
  }
  else
  {
    v7 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
    {
      LOWORD(v17) = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "This hardware does not support MatchActioRules", (uint8_t *)&v17, 2u);
    }
    v8 = 11;
  }
LABEL_26:

  return v8;
}

void sub_100673654(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_10067366C()
{
  NSObject *v0;
  uint8_t buf[16];

  v0 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "ADVBUFF Sending empty event", buf, 2u);
  }
  operator new();
}

void sub_1006738D8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29)
{
  operator delete();
}

void sub_10067396C(uint64_t a1, void (***a2)(_QWORD, uint64_t, _QWORD, uint64_t, uint64_t, _QWORD, _QWORD ***, const __CFString *))
{
  uint64_t v3;
  _QWORD **v4;
  _QWORD *v5[2];

  v3 = *(_QWORD *)(a1 + 32);
  v5[0] = 0;
  v5[1] = 0;
  v4 = v5;
  (**a2)(a2, v3, 0, a1 + 40, a1 + 56, 0, &v4, CFSTR("default"));
  sub_10001A82C((uint64_t)&v4, v5[0]);
}

void sub_1006739DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, _QWORD *a11)
{
  sub_10001A82C((uint64_t)&a10, a11);
  _Unwind_Resume(a1);
}

char *sub_1006739F4(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 40) = &off_100918298;
  *(_QWORD *)(a1 + 48) = v4;
  if (v4)
    sub_10003C37C(v4);
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 72) = 0;
  return sub_1000B61B8((char *)(a1 + 56), *(__int128 **)(a2 + 56), *(__int128 **)(a2 + 64), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(a2 + 64) - *(_QWORD *)(a2 + 56)) >> 2));
}

void sub_100673A5C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  unsigned int *v4;

  *(_QWORD *)(v1 + 40) = v2;
  v4 = *(unsigned int **)(v1 + 48);
  if (v4)
    sub_100056AAC(v4);
  _Unwind_Resume(exception_object);
}

void sub_100673A78(_QWORD *a1)
{
  void *v2;
  unsigned int *v3;

  v2 = (void *)a1[7];
  if (v2)
  {
    a1[8] = v2;
    operator delete(v2);
  }
  a1[5] = &off_100918298;
  v3 = (unsigned int *)a1[6];
  if (v3)
    sub_100056AAC(v3);
}

void sub_100673AC4(uint64_t a1, void (***a2)(_QWORD, uint64_t, _QWORD, uint64_t, uint64_t, _QWORD, _QWORD ***, const __CFString *))
{
  uint64_t v3;
  _QWORD **v4;
  _QWORD *v5[2];

  v3 = *(_QWORD *)(a1 + 32);
  v5[0] = 0;
  v5[1] = 0;
  v4 = v5;
  (**a2)(a2, v3, 0, a1 + 40, a1 + 56, 0, &v4, CFSTR("default"));
  sub_10001A82C((uint64_t)&v4, v5[0]);
}

void sub_100673B34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, _QWORD *a11)
{
  sub_10001A82C((uint64_t)&a10, a11);
  _Unwind_Resume(a1);
}

void sub_100673B4C(uint64_t a1, void (***a2)(_QWORD, uint64_t, _QWORD, uint64_t, uint64_t, _QWORD, _QWORD ***, const __CFString *))
{
  uint64_t v3;
  _QWORD **v4;
  _QWORD *v5[2];

  v3 = *(_QWORD *)(a1 + 32);
  v5[0] = 0;
  v5[1] = 0;
  v4 = v5;
  (**a2)(a2, v3, 0, a1 + 40, a1 + 56, 0, &v4, CFSTR("default"));
  sub_10001A82C((uint64_t)&v4, v5[0]);
}

void sub_100673BBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, _QWORD *a11)
{
  sub_10001A82C((uint64_t)&a10, a11);
  _Unwind_Resume(a1);
}

void sub_100673BD4(uint64_t a1, void (***a2)(_QWORD, uint64_t, _QWORD, uint64_t, uint64_t, _QWORD, _QWORD ***, const __CFString *))
{
  uint64_t v3;
  _QWORD **v4;
  _QWORD *v5[2];

  v3 = *(_QWORD *)(a1 + 32);
  v5[0] = 0;
  v5[1] = 0;
  v4 = v5;
  (**a2)(a2, v3, 0, a1 + 40, a1 + 56, 0, &v4, CFSTR("default"));
  sub_10001A82C((uint64_t)&v4, v5[0]);
}

void sub_100673C44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, _QWORD *a11)
{
  sub_10001A82C((uint64_t)&a10, a11);
  _Unwind_Resume(a1);
}

void sub_100673C5C(id a1)
{
  mach_timebase_info((mach_timebase_info_t)&dword_1009940E8);
}

uint64_t sub_100673C68(uint64_t a1)
{
  NSObject *v1;
  NSObject *v3;
  uint8_t v5[16];

  v1 = *(NSObject **)(a1 + 1800);
  if (v1)
  {
    v3 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "fADVBufferPeriodicDrainTimer destroyed!", v5, 2u);
      v1 = *(NSObject **)(a1 + 1800);
    }
    dispatch_source_cancel(v1);
    dispatch_release(*(dispatch_object_t *)(a1 + 1800));
    *(_QWORD *)(a1 + 1800) = 0;
  }
  return 0;
}

uint64_t sub_100673CFC(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  dispatch_time_t v7;
  _QWORD handler[5];
  uint8_t buf[4];
  uint64_t v11;

  if (!*(_QWORD *)(a1 + 1800))
  {
    v2 = *(_QWORD *)(a1 + 2128);
    v3 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      v11 = v2;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "fADVBufferPeriodicDrainTimer %llu ms Armed!", buf, 0xCu);
    }
    v4 = sub_1000419F4();
    v5 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, *(dispatch_queue_t *)(v4 + 8));
    *(_QWORD *)(a1 + 1800) = v5;
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472;
    handler[2] = sub_10067AF38;
    handler[3] = &unk_100917378;
    handler[4] = a1;
    dispatch_source_set_event_handler(v5, handler);
    v6 = *(NSObject **)(a1 + 1800);
    v7 = dispatch_time(0x8000000000000000, 1000000 * v2);
    dispatch_source_set_timer(v6, v7, 0xFFFFFFFFFFFFFFFFLL, 0);
    dispatch_activate(*(dispatch_object_t *)(a1 + 1800));
  }
  return 0;
}

uint64_t sub_100673E40(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  uint64_t v4;
  uint64_t v6;
  _BYTE *v7;
  int v8;
  uint64_t v9;
  const __CFString *v10;
  unsigned int v11;
  int v12;
  NSObject *v13;
  _BOOL4 v14;
  const __CFString *v15;
  const char *v16;
  NSObject *v17;
  const __CFString *v18;
  uint64_t v19;
  NSObject *v20;
  const __CFString *v21;
  uint64_t v22;
  const __CFString *v23;
  int v24;
  NSObject *v25;
  const __CFString *v26;
  __int16 v28;
  __int16 v29;
  uint8_t buf[4];
  const __CFString *v31;
  __int16 v32;
  int v33;
  __int16 v34;
  int v35;

  if (a2 >= 3)
  {
    v3 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      LODWORD(v31) = a2;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "HW ADV Buffer handle out of range (%d), ignoring agent request", buf, 8u);
    }
    return 7;
  }
  v6 = a1 + 544 * a2;
  v8 = *(unsigned __int8 *)(v6 + 172);
  v7 = (_BYTE *)(v6 + 172);
  if (v8 != 255)
  {
    v9 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
    {
      if (a2 > 2)
        v10 = CFSTR("UNKNOWN");
      else
        v10 = off_10093F698[(char)a2];
      *(_DWORD *)buf = 138543362;
      v31 = v10;
      v16 = "ADVBUFF(%{public}@): Cannot read ADV buffer since we're already in the process of reading it";
      v4 = 12;
      v17 = v9;
LABEL_15:
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_INFO, v16, buf, 0xCu);
      return v4;
    }
    return 12;
  }
  v11 = a2;
  v12 = *(unsigned __int8 *)(a1 + 544 * a2 + 167);
  v13 = qword_100999828;
  v14 = os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO);
  if (!v12)
  {
    if (v14)
    {
      if (a2 > 2)
        v18 = CFSTR("UNKNOWN");
      else
        v18 = off_10093F698[(char)a2];
      *(_DWORD *)buf = 138543362;
      v31 = v18;
      v16 = "ADVBUFF(%{public}@): Cannot read ADV buffer since its not created yet";
      v4 = 12;
      v17 = v13;
      goto LABEL_15;
    }
    return 12;
  }
  if (v14)
  {
    if (a2 > 2)
      v15 = CFSTR("UNKNOWN");
    else
      v15 = off_10093F698[(char)a2];
    *(_DWORD *)buf = 138543362;
    v31 = v15;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_INFO, "ADVBUFF(%{public}@): Reading ADV Buffer", buf, 0xCu);
  }
  v29 = 0;
  v28 = 0;
  v19 = sub_1000438A4();
  v4 = (*(uint64_t (**)(uint64_t, uint64_t, char *, __int16 *, __int16 *))(*(_QWORD *)v19 + 2824))(v19, a2, (char *)&v29 + 1, &v29, &v28);
  v20 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    if (a2 > 2)
      v21 = CFSTR("UNKNOWN");
    else
      v21 = off_10093F698[(char)a2];
    *(_DWORD *)buf = 138543874;
    v31 = v21;
    v32 = 1024;
    v33 = v4;
    v34 = 1024;
    v35 = HIBYTE(v29);
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "ADVBUFF(%{public}@): Read ADV buffer complete with status %d expectedEntries %d", buf, 0x18u);
    v20 = qword_100999828;
  }
  *v7 = HIBYTE(v29);
  v22 = a1 + 544 * v11;
  *(_BYTE *)(v22 + 173) = v29;
  *(_WORD *)(v22 + 174) = v28;
  if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
  {
    if (a2 > 2)
      v23 = CFSTR("UNKNOWN");
    else
      v23 = off_10093F698[(char)a2];
    v24 = *v7;
    *(_DWORD *)buf = 138543874;
    v31 = v23;
    v32 = 1024;
    v33 = v4;
    v34 = 1024;
    v35 = v24;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_INFO, "ADVBUFF(%{public}@): Read ADV buffer complete with status %d number of available entries %d", buf, 0x18u);
  }
  if ((_DWORD)a2 == 2)
    ++*(_QWORD *)(a1 + 2296);
  if (!(_DWORD)v4 && !*v7)
  {
    v25 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
    {
      if (a2 > 2)
        v26 = CFSTR("UNKNOWN");
      else
        v26 = off_10093F698[(char)a2];
      *(_DWORD *)buf = 138543362;
      v31 = v26;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_INFO, "ADVBUFF(%{public}@): Nothing in the ADV buffer, we're not expecing any events", buf, 0xCu);
    }
    *v7 = -1;
    *(_BYTE *)(a1 + 544 * v11 + 169) = 0;
  }
  return v4;
}

void sub_100674284()
{
  sub_10067366C();
}

uint64_t sub_10067428C(_BYTE *a1)
{
  uint64_t v2;
  uint64_t v4;
  _QWORD v5[5];
  _QWORD v6[5];
  int v7;

  if (!sub_10006E040((uint64_t)a1))
  {
    if (!os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
    {
LABEL_13:
      v2 = sub_1000419F4();
      v5[0] = _NSConcreteStackBlock;
      v5[1] = 3221225472;
      v5[2] = sub_1006743F0;
      v5[3] = &unk_100917378;
      v5[4] = a1;
      sub_100041A34(v2, v5);
      return 12;
    }
LABEL_12:
    sub_100716A74();
    goto LABEL_13;
  }
  if (!a1[167] && !a1[711])
  {
    if (!os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
      goto LABEL_13;
    goto LABEL_12;
  }
  if (a1[1853] || a1[171] && a1[167] || a1[715] && a1[711])
  {
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
      sub_100716AA0();
    return 12;
  }
  v4 = sub_1000419F4();
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_1006751C0;
  v6[3] = &unk_1009173C0;
  v6[4] = a1;
  v7 = 4;
  sub_100041A34(v4, v6);
  return 0;
}

void sub_1006743F0()
{
  sub_10067366C();
}

void sub_1006743F8(uint64_t a1)
{
  int v2;
  NSObject *v3;
  int v4;
  NSObject *v5;
  NSObject *v6;
  NSObject *v7;
  _DWORD v8[2];
  __int16 v9;
  int v10;

  if ((sub_10067465C(a1) & 1) != 0)
    v2 = 1;
  else
    v2 = sub_1006746C4(a1);
  v3 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    v4 = *(unsigned __int8 *)(a1 + 1864);
    v8[0] = 67109376;
    v8[1] = v2;
    v9 = 1024;
    v10 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "tryReadAOPBTProxCtxBuffers AOPBTProxContextBufferRequests:%d fAOPBTProxCtxBufferReadInProgress:%d", (uint8_t *)v8, 0xEu);
  }
  if (*(_BYTE *)(a1 + 1864))
  {
    v5 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v8[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "AOPBTProxCtxBuffers already being read, skipping", (uint8_t *)v8, 2u);
    }
  }
  else if (v2)
  {
    if (!sub_10067465C(a1))
      goto LABEL_27;
    v6 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
    {
      LOWORD(v8[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "AOPBTProxCtxBuffer read in progress, pause match All Types match table", (uint8_t *)v8, 2u);
    }
    if (sub_10067472C(a1, 0, 0))
    {
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
        sub_100716B2C();
    }
    else
    {
      if (!sub_1006746C4(a1))
        goto LABEL_22;
LABEL_27:
      v7 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
      {
        LOWORD(v8[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "AOPBTProxCtxBuffer read in progress, pause Proximity Pairing match table", (uint8_t *)v8, 2u);
      }
      if (sub_10067472C(a1, 7, 0))
      {
        if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
          sub_100716ACC();
      }
      else
      {
LABEL_22:
        *(_BYTE *)(a1 + 1864) = 1;
        if (qword_100977FD0 != -1)
          dispatch_once(&qword_100977FD0, &stru_10093F4D8);
        sub_10039D63C(qword_100977FC8);
      }
    }
  }
}

uint64_t sub_10067465C(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *v2;
  unsigned int v3;
  uint64_t result;
  _QWORD *v5;
  _QWORD *v6;
  BOOL v7;

  v1 = *(_QWORD **)(a1 + 2040);
  v2 = (_QWORD *)(a1 + 2048);
  if (v1 == (_QWORD *)(a1 + 2048))
    return 0;
  do
  {
    v3 = *(unsigned __int16 *)(*(_QWORD *)(v1[5] + 8) + 124);
    result = (v3 >> 1) & 1;
    if ((v3 & 2) != 0)
      break;
    v5 = (_QWORD *)v1[1];
    if (v5)
    {
      do
      {
        v6 = v5;
        v5 = (_QWORD *)*v5;
      }
      while (v5);
    }
    else
    {
      do
      {
        v6 = (_QWORD *)v1[2];
        v7 = *v6 == (_QWORD)v1;
        v1 = v6;
      }
      while (!v7);
    }
    v1 = v6;
  }
  while (v6 != v2);
  return result;
}

uint64_t sub_1006746C4(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *v2;
  unsigned int v3;
  uint64_t result;
  _QWORD *v5;
  _QWORD *v6;
  BOOL v7;

  v1 = *(_QWORD **)(a1 + 2040);
  v2 = (_QWORD *)(a1 + 2048);
  if (v1 == (_QWORD *)(a1 + 2048))
    return 0;
  do
  {
    v3 = *(unsigned __int16 *)(*(_QWORD *)(v1[5] + 8) + 124);
    result = (v3 >> 2) & 1;
    if ((v3 & 4) != 0)
      break;
    v5 = (_QWORD *)v1[1];
    if (v5)
    {
      do
      {
        v6 = v5;
        v5 = (_QWORD *)*v5;
      }
      while (v5);
    }
    else
    {
      do
      {
        v6 = (_QWORD *)v1[2];
        v7 = *v6 == (_QWORD)v1;
        v1 = v6;
      }
      while (!v7);
    }
    v1 = v6;
  }
  while (v6 != v2);
  return result;
}

uint64_t sub_10067472C(uint64_t a1, int a2, int a3)
{
  uint64_t **v6;
  _QWORD *v7;
  BOOL v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  NSObject *v12;
  int v13;
  _BOOL4 v14;
  _BOOL4 v15;
  NSObject *v16;
  uint64_t v17;
  char v18;
  NSObject *v19;
  _BOOL4 v20;
  int v21;
  const char *v22;
  uint64_t v23;
  NSObject *v24;
  int v25;
  NSObject *v26;
  int v27;
  NSObject *v28;
  int v29;
  const char *v30;
  int v32;
  unsigned __int8 v33;
  unsigned __int8 v34;
  unsigned __int8 v35;
  uint8_t buf[8];
  __int16 v37;
  int v38;
  __int16 v39;
  _BYTE v40[10];
  __int16 v41;
  _BOOL4 v42;

  v6 = (uint64_t **)(a1 + 1816);
  v7 = *(_QWORD **)(a1 + 1816);
  if (v7 == (_QWORD *)(a1 + 1824))
  {
LABEL_13:
    v11 = 0;
  }
  else
  {
    while (1)
    {
      v8 = *((unsigned __int8 *)v7 + 28) != a2 || *((_WORD *)v7 + 16) == 0;
      if (!v8)
        break;
      v9 = (_QWORD *)v7[1];
      if (v9)
      {
        do
        {
          v10 = v9;
          v9 = (_QWORD *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          v10 = (_QWORD *)v7[2];
          v8 = *v10 == (_QWORD)v7;
          v7 = v10;
        }
        while (!v8);
      }
      v7 = v10;
      if (v10 == (_QWORD *)(a1 + 1824))
        goto LABEL_13;
    }
    v11 = *((unsigned __int16 *)v7 + 15);
  }
  v12 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
  {
    v35 = v11;
    *(_QWORD *)buf = &v35;
    v13 = *((unsigned __int8 *)sub_10000DB5C(v6, &v35, (uint64_t)&unk_100740F58, (char **)buf) + 28);
    v34 = v11;
    *(_QWORD *)buf = &v34;
    v14 = *((_WORD *)sub_10000DB5C(v6, &v34, (uint64_t)&unk_100740F58, (char **)buf) + 16) != 0;
    v33 = v11;
    *(_QWORD *)buf = &v33;
    v15 = *((_WORD *)sub_10000DB5C(v6, &v33, (uint64_t)&unk_100740F58, (char **)buf) + 17) != 0;
    *(_DWORD *)buf = 67110144;
    *(_DWORD *)&buf[4] = v11;
    v37 = 1024;
    v38 = v13;
    v39 = 1024;
    *(_DWORD *)v40 = a3;
    *(_WORD *)&v40[4] = 1024;
    *(_DWORD *)&v40[6] = v14;
    v41 = 1024;
    v42 = v15;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "enableMatchTable handle:%d type:%d enable=%d created=%d enabled=%d", buf, 0x20u);
  }
  if ((unsigned __int16)(v11 - 262) > 0xFFF9u)
  {
    v35 = v11;
    *(_QWORD *)buf = &v35;
    if (*((_WORD *)sub_10000DB5C(v6, &v35, (uint64_t)&unk_100740F58, (char **)buf) + 16))
    {
      v35 = v11;
      *(_QWORD *)buf = &v35;
      v18 = (*((_WORD *)sub_10000DB5C(v6, &v35, (uint64_t)&unk_100740F58, (char **)buf) + 17) != 0) ^ a3;
      v19 = qword_100999828;
      v20 = os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO);
      if ((v18 & 1) != 0)
      {
        if (v20)
        {
          v35 = v11;
          *(_QWORD *)buf = &v35;
          v21 = *((unsigned __int8 *)sub_10000DB5C(v6, &v35, (uint64_t)&unk_100740F58, (char **)buf) + 28);
          v22 = "pausing";
          *(_DWORD *)buf = 67109634;
          *(_DWORD *)&buf[4] = v11;
          if (a3)
            v22 = "activating";
          v37 = 1024;
          v38 = v21;
          v39 = 2082;
          *(_QWORD *)v40 = v22;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_INFO, "Match Table handle:%d type:%d mode change -> %{public}s ", buf, 0x18u);
        }
        v23 = sub_1000438A4();
        v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)v23 + 2856))(v23, v11, 1, a3 ^ 1u);
        v24 = qword_100999828;
        if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
        {
          v35 = v11;
          *(_QWORD *)buf = &v35;
          v25 = *((unsigned __int8 *)sub_10000DB5C(v6, &v35, (uint64_t)&unk_100740F58, (char **)buf) + 28);
          *(_DWORD *)buf = 67109632;
          *(_DWORD *)&buf[4] = v11;
          v37 = 1024;
          v38 = v25;
          v39 = 1024;
          *(_DWORD *)v40 = v17;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_INFO, "Match Table handle:%d type:%d advBufMatchControl returned %d", buf, 0x14u);
        }
        if ((_DWORD)v17)
        {
          v26 = qword_100999828;
          if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
          {
            v35 = v11;
            *(_QWORD *)buf = &v35;
            v27 = *((unsigned __int8 *)sub_10000DB5C(v6, &v35, (uint64_t)&unk_100740F58, (char **)buf) + 28);
            *(_DWORD *)buf = 67109632;
            *(_DWORD *)&buf[4] = v11;
            v37 = 1024;
            v38 = v27;
            v39 = 1024;
            *(_DWORD *)v40 = v17;
            _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Match Table handle:%d type:%d Failed to enable match table : %d", buf, 0x14u);
          }
        }
        else
        {
          v35 = v11;
          *(_QWORD *)buf = &v35;
          *((_WORD *)sub_10000DB5C(v6, &v35, (uint64_t)&unk_100740F58, (char **)buf) + 17) = a3;
        }
        sub_10006DE50((double *)a1, a2, a3);
      }
      else
      {
        if (v20)
        {
          v35 = v11;
          *(_QWORD *)buf = &v35;
          v29 = *((unsigned __int8 *)sub_10000DB5C(v6, &v35, (uint64_t)&unk_100740F58, (char **)buf) + 28);
          v30 = "paused";
          *(_DWORD *)buf = 67109634;
          *(_DWORD *)&buf[4] = v11;
          if (a3)
            v30 = "active";
          v37 = 1024;
          v38 = v29;
          v39 = 2082;
          *(_QWORD *)v40 = v30;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_INFO, "Match Table handle:%d type:%d already %{public}s", buf, 0x18u);
        }
        return 0;
      }
    }
    else
    {
      v28 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
      {
        v35 = v11;
        *(_QWORD *)buf = &v35;
        v32 = *((unsigned __int8 *)sub_10000DB5C(v6, &v35, (uint64_t)&unk_100740F58, (char **)buf) + 28);
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)&buf[4] = v11;
        v37 = 1024;
        v38 = v32;
        _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "Match Table handle:%d type:%d not created", buf, 0xEu);
      }
      return 12;
    }
  }
  else
  {
    v16 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
      sub_100716B8C(a2, v11, v16);
    return 7;
  }
  return v17;
}

void sub_100674D00(uint64_t a1)
{
  int v2;
  NSObject *v3;
  int v4;
  NSObject *v5;
  NSObject *v6;
  _DWORD v7[2];
  __int16 v8;
  int v9;

  v2 = sub_100674ED0(a1);
  v3 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    v4 = *(unsigned __int8 *)(a1 + 1854);
    v7[0] = 67109376;
    v7[1] = v2;
    v8 = 1024;
    v9 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "tryReadAOPBTADPDBuffers haveAnyHwAOPBTADPDBufferRequests:%d fAOPBTBufferReadInProgress:%d", (uint8_t *)v7, 0xEu);
  }
  if (*(_BYTE *)(a1 + 1854))
  {
    v5 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "AOPBTADPDBuff Already being read, skipping", (uint8_t *)v7, 2u);
    }
  }
  else if (v2)
  {
    v6 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
    {
      LOWORD(v7[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "AOPBTADPDBuff read in progress", (uint8_t *)v7, 2u);
    }
    if (sub_10067472C(a1, 22, 0))
    {
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
        sub_100716C00();
    }
    else
    {
      *(_BYTE *)(a1 + 1854) = 1;
      sub_100674F38(a1);
      sub_100674FCC(a1);
      if (qword_100977FD0 != -1)
        dispatch_once(&qword_100977FD0, &stru_10093F4D8);
      sub_10039D808(qword_100977FC8);
    }
  }
}

uint64_t sub_100674ED0(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *v2;
  __int16 v3;
  uint64_t result;
  _QWORD *v5;
  _QWORD *v6;
  BOOL v7;

  v1 = *(_QWORD **)(a1 + 2040);
  v2 = (_QWORD *)(a1 + 2048);
  if (v1 == (_QWORD *)(a1 + 2048))
    return 0;
  do
  {
    v3 = *(_WORD *)(*(_QWORD *)(v1[5] + 8) + 124);
    result = v3 & 1;
    if ((v3 & 1) != 0)
      break;
    v5 = (_QWORD *)v1[1];
    if (v5)
    {
      do
      {
        v6 = v5;
        v5 = (_QWORD *)*v5;
      }
      while (v5);
    }
    else
    {
      do
      {
        v6 = (_QWORD *)v1[2];
        v7 = *v6 == (_QWORD)v1;
        v1 = v6;
      }
      while (!v7);
    }
    v1 = v6;
  }
  while (v6 != v2);
  return result;
}

uint64_t sub_100674F38(uint64_t a1)
{
  NSObject *v1;
  NSObject *v3;
  uint8_t v5[16];

  v1 = *(NSObject **)(a1 + 1808);
  if (v1)
  {
    v3 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "fAOPBTBufferPeriodicDrainTimer destroyed!", v5, 2u);
      v1 = *(NSObject **)(a1 + 1808);
    }
    dispatch_source_cancel(v1);
    dispatch_release(*(dispatch_object_t *)(a1 + 1808));
    *(_QWORD *)(a1 + 1808) = 0;
  }
  return 0;
}

uint64_t sub_100674FCC(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  NSObject *v4;
  NSObject *v5;
  dispatch_time_t v6;
  _QWORD handler[5];
  uint8_t buf[16];

  if (!*(_QWORD *)(a1 + 1808))
  {
    v2 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Arming fAOPBTBufferPeriodicDrainTimer", buf, 2u);
    }
    v3 = sub_1000419F4();
    v4 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, *(dispatch_queue_t *)(v3 + 8));
    *(_QWORD *)(a1 + 1808) = v4;
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472;
    handler[2] = sub_10067AE3C;
    handler[3] = &unk_100917378;
    handler[4] = a1;
    dispatch_source_set_event_handler(v4, handler);
    v5 = *(NSObject **)(a1 + 1808);
    v6 = dispatch_time(0x8000000000000000, 300000000000);
    dispatch_source_set_timer(v5, v6, 0xFFFFFFFFFFFFFFFFLL, 0);
    dispatch_activate(*(dispatch_object_t *)(a1 + 1808));
  }
  return 0;
}

void sub_1006750CC(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  const char *v5;
  _DWORD v6[2];
  __int16 v7;
  const char *v8;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    v4 = *(_DWORD *)(a1 + 40);
    v5 = "On";
    if (!*(_BYTE *)(v2 + 144))
      v5 = "Off";
    v6[0] = 67109378;
    v6[1] = v4;
    v7 = 2082;
    v8 = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "tryReadAOPBTBuffers reason:%d fScreenState:%{public}s", (uint8_t *)v6, 0x12u);
  }
  if (*(_DWORD *)(a1 + 40) == 1)
    sub_1006743F8(v2);
  sub_100674D00(v2);
}

void sub_1006751C0(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  NSObject *v5;
  int v6;
  int v7;
  const char *v8;
  int v9;
  _BOOL4 v10;
  int v11;
  int v12;
  int v13;
  int v14;
  NSObject *v15;
  NSMutableDictionary *v16;
  void *v17;
  uint64_t v18;
  BOOL v19;
  uint64_t v20;
  NSObject *v21;
  int v22;
  NSObject *v23;
  int v24;
  BOOL v25;
  NSObject *v26;
  int v27;
  int v28;
  __int16 v29;
  int v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  int v34;
  __int16 v35;
  int v36;
  __int16 v37;
  _BOOL4 v38;
  __int16 v39;
  int v40;
  __int16 v41;
  int v42;
  __int16 v43;
  int v44;
  __int16 v45;
  int v46;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = sub_10003BE44();
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 704))(v3);
  v5 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    v6 = *(_DWORD *)(a1 + 40);
    v7 = *(unsigned __int8 *)(v2 + 1851);
    if (*(_BYTE *)(v2 + 144))
      v8 = "On";
    else
      v8 = "Off";
    v9 = (unsigned __int16)objc_msgSend(*(id *)(v2 + 2112), "count");
    v10 = sub_10006E040(v2);
    v11 = *(unsigned __int8 *)(v2 + 172);
    v12 = *(unsigned __int8 *)(v2 + 171);
    v13 = *(unsigned __int8 *)(v2 + 715);
    v14 = *(unsigned __int8 *)(v2 + 1853);
    v27 = 67111426;
    v28 = v6;
    v29 = 1024;
    v30 = v7;
    v31 = 2082;
    v32 = v8;
    v33 = 1024;
    v34 = v9;
    v35 = 1024;
    v36 = v4;
    v37 = 1024;
    v38 = v10;
    v39 = 1024;
    v40 = v11;
    v41 = 1024;
    v42 = v12;
    v43 = 1024;
    v44 = v13;
    v45 = 1024;
    v46 = v14;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "TryReadMatchAndADVBuffers reason:%d fMatchBufferExpectedEntries:0x%d fScreenState:%{public}s fMatchActionTableRulesCount:%d supportedADVBuffers:%d haveAnyHwObjectDiscoveryRequests:%d fADVBufferExpectedEntries:%d readInProgress[Wild]:%d readInProgress[NearOwner]:%d fMatchBufferReadInProgress:%d", (uint8_t *)&v27, 0x42u);
  }
  if (*(_BYTE *)(v2 + 1853)
    || *(_BYTE *)(v2 + 171) && *(_BYTE *)(v2 + 167)
    || *(_BYTE *)(v2 + 715) && *(_BYTE *)(v2 + 711))
  {
    v15 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v27) = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Already reading buffers, skipping", (uint8_t *)&v27, 2u);
    }
  }
  else
  {
    sub_100673C68(v2);
    if (*(unsigned __int8 *)(v2 + 1851) == 255)
    {
      if (objc_msgSend(*(id *)(v2 + 2112), "count"))
      {
        v20 = sub_10003BE44();
        if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v20 + 704))(v20))
        {
          *(_BYTE *)(v2 + 1853) = 1;
          v21 = qword_100999828;
          if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
          {
            LOWORD(v27) = 0;
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_INFO, "Match Buffer Reading ADV Buff", (uint8_t *)&v27, 2u);
          }
          v22 = sub_1006730E0(v2, 0);
          v23 = qword_100999828;
          if (v22)
          {
            v24 = v22;
            if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
            {
              v27 = 67109120;
              v28 = v24;
              _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "Failed to pause match buffers with result %d", (uint8_t *)&v27, 8u);
            }
          }
          else
          {
            if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEBUG))
              sub_100716CDC(v2, v2 + 1851, v23);
            if (*(unsigned __int8 *)(v2 + 1851) == 255)
            {
              v26 = qword_100999828;
              if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
              {
                LOWORD(v27) = 0;
                _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_INFO, "Buffer is empty, we need to re-enable the match tables now", (uint8_t *)&v27, 2u);
                v26 = qword_100999828;
              }
              *(_BYTE *)(v2 + 1853) = 0;
              if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
                sub_100716C60(v2, v26);
            }
          }
        }
      }
    }
    *(_BYTE *)(v2 + 1795) = 0;
    *(_WORD *)(v2 + 1793) = 0;
    if (sub_10006E040(v2))
    {
      v16 = objc_opt_new(NSMutableDictionary);
      v17 = *(void **)(v2 + 152);
      *(_QWORD *)(v2 + 152) = v16;

      v18 = *(int *)(a1 + 40);
      if (v18 <= 4)
        objc_msgSend(*(id *)(v2 + 152), "setObject:forKeyedSubscript:", *((_QWORD *)&off_10093F5D8 + v18), CFSTR("DrainReason"));
      v19 = *(unsigned __int8 *)(v2 + 172) == 255 && *(_BYTE *)(v2 + 167) != 0;
      *(_BYTE *)(v2 + 1793) = v19;
      v25 = *(unsigned __int8 *)(v2 + 716) == 255 && *(_BYTE *)(v2 + 711) != 0;
      *(_BYTE *)(v2 + 1794) = v25;
    }
    sub_10067137C(v2);
  }
}

uint64_t sub_1006755B0(uint64_t a1)
{
  NSObject *v1;
  uint64_t v2;
  id v4;
  NSObject *v5;
  _BOOL4 v6;
  _QWORD *v7;
  _BYTE *v8;
  _QWORD *v9;
  _QWORD *v10;
  BOOL v11;
  NSObject *v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  NSObject *v16;
  int v17;
  NSObject *v19;
  int v20;
  int v21;
  __int16 v22;
  int v23;

  if (*(unsigned __int8 *)(a1 + 1851) != 255)
  {
    v1 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
    {
      LOWORD(v20) = 0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_INFO, "Match Buffer Cannot read Match buffer since we're already in the process of reading it", (uint8_t *)&v20, 2u);
    }
    return 12;
  }
  v4 = objc_msgSend(*(id *)(a1 + 2112), "count");
  v5 = qword_100999828;
  v6 = os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO);
  if (!v4)
  {
    if (v6)
    {
      LOWORD(v20) = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "Match Buffer Cannot read Match buffer since we do not have any rules set up", (uint8_t *)&v20, 2u);
    }
    return 18;
  }
  if (v6)
  {
    LOWORD(v20) = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "Match Buffer Reading Match Buffer", (uint8_t *)&v20, 2u);
  }
  v7 = *(_QWORD **)(a1 + 1816);
  if (v7 == (_QWORD *)(a1 + 1824))
  {
LABEL_17:
    v12 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v20) = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "No table is configured", (uint8_t *)&v20, 2u);
    }
    return 17;
  }
  else
  {
    v8 = (_BYTE *)(a1 + 1851);
    while (*((_BYTE *)v7 + 28) != 18)
    {
      v9 = (_QWORD *)v7[1];
      if (v9)
      {
        do
        {
          v10 = v9;
          v9 = (_QWORD *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          v10 = (_QWORD *)v7[2];
          v11 = *v10 == (_QWORD)v7;
          v7 = v10;
        }
        while (!v11);
      }
      v7 = v10;
      if (v10 == (_QWORD *)(a1 + 1824))
        goto LABEL_17;
    }
    v13 = *((unsigned __int16 *)v7 + 15);
    v14 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
    {
      v20 = 67109120;
      v21 = v13;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "Match Buffer reading handle %d", (uint8_t *)&v20, 8u);
    }
    *(_BYTE *)(a1 + 1852) = 0;
    v15 = sub_1000438A4();
    v2 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v15 + 2896))(v15, v13, a1 + 1851);
    v16 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
    {
      v17 = *v8;
      v20 = 67109376;
      v21 = v2;
      v22 = 1024;
      v23 = v17;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_INFO, "Match Buffer Read Match buffer complete with status %d number of available entries %d", (uint8_t *)&v20, 0xEu);
    }
    if (!(_DWORD)v2)
    {
      if (*v8)
        return 0;
      v19 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
      {
        LOWORD(v20) = 0;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_INFO, "Match Buffer Nothing in the ADV buffer, we're not expecing any events", (uint8_t *)&v20, 2u);
      }
      *v8 = -1;
      return 18;
    }
  }
  return v2;
}

void sub_1006758AC(uint64_t a1, const void *a2)
{
  uint64_t v3;
  _QWORD v4[5];
  _BYTE v5[260];

  memcpy(v5, a2, sizeof(v5));
  v3 = sub_1000419F4();
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_10067591C;
  v4[3] = &unk_10093EED8;
  v4[4] = a1;
  sub_100041A34(v3, v4);
}

void sub_10067591C(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  uint64_t v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  int v72;
  int v73;
  int v74;
  int v75;
  int v76;
  int v77;
  int v78;
  int v79;
  int v80;
  int v81;
  int v82;
  int v83;
  int v84;
  int v85;
  int v86;
  int v87;
  int v88;
  int v89;
  int v90;
  int v91;
  uint8_t buf[4];
  _BYTE v93[10];
  uint64_t v94;
  _BYTE v95[10];
  __int16 v96;
  _BYTE v97[10];
  _BYTE v98[6];
  _BYTE v99[6];
  _BYTE v100[6];
  _BYTE v101[6];
  _BYTE v102[6];
  _BYTE v103[6];
  _BYTE v104[6];
  _BYTE v105[6];
  _BYTE v106[6];
  _BYTE v107[6];
  _BYTE v108[6];
  _BYTE v109[6];
  _BYTE v110[6];
  _BYTE v111[6];
  _BYTE v112[6];
  _BYTE v113[6];
  int v114;
  __int16 v115;
  int v116;
  __int16 v117;
  int v118;
  __int16 v119;
  int v120;
  __int16 v121;
  int v122;
  __int16 v123;
  int v124;
  __int16 v125;
  int v126;
  __int16 v127;
  int v128;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_QWORD *)(v2 + 2144) + *(unsigned int *)(a1 + 68);
  *(_QWORD *)(v2 + 2144) = v3;
  v4 = *(_QWORD *)(v2 + 2136) + *(unsigned int *)(a1 + 72);
  *(_QWORD *)(v2 + 2136) = v4;
  v5 = *(_QWORD *)(v2 + 2160) + *(unsigned int *)(a1 + 60);
  *(_QWORD *)(v2 + 2160) = v5;
  v6 = *(_QWORD *)(v2 + 2152) + *(unsigned int *)(a1 + 64);
  *(_QWORD *)(v2 + 2152) = v6;
  v7 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    v8 = *(_DWORD *)(a1 + 80);
    v9 = *(_DWORD *)(a1 + 84);
    v10 = *(_DWORD *)(a1 + 88);
    v11 = *(_DWORD *)(a1 + 92);
    v12 = *(_DWORD *)(a1 + 96);
    v13 = *(_DWORD *)(a1 + 100);
    v14 = *(_DWORD *)(a1 + 104);
    v15 = *(_DWORD *)(a1 + 108);
    v16 = *(_DWORD *)(a1 + 112);
    v17 = *(_DWORD *)(a1 + 116);
    v18 = *(_DWORD *)(a1 + 120);
    v19 = *(_DWORD *)(a1 + 124);
    v20 = *(_DWORD *)(a1 + 128);
    v21 = *(_DWORD *)(a1 + 132);
    v22 = *(_DWORD *)(a1 + 136);
    v23 = *(_DWORD *)(a1 + 140);
    v24 = *(_DWORD *)(a1 + 144);
    v25 = *(_DWORD *)(a1 + 148);
    v26 = *(_DWORD *)(a1 + 152);
    v27 = *(_DWORD *)(a1 + 156);
    v28 = *(_DWORD *)(a1 + 160);
    v89 = *(_DWORD *)(a1 + 164);
    v90 = *(_DWORD *)(a1 + 168);
    v91 = *(_DWORD *)(a1 + 172);
    *(_DWORD *)buf = 134224896;
    *(_QWORD *)v93 = v3;
    *(_WORD *)&v93[8] = 2048;
    v94 = v4;
    *(_WORD *)v95 = 2048;
    *(_QWORD *)&v95[2] = v5;
    v96 = 2048;
    *(_QWORD *)v97 = v6;
    *(_WORD *)&v97[8] = 1024;
    *(_DWORD *)v98 = v8;
    *(_WORD *)&v98[4] = 1024;
    *(_DWORD *)v99 = v9;
    *(_WORD *)&v99[4] = 1024;
    *(_DWORD *)v100 = v10;
    *(_WORD *)&v100[4] = 1024;
    *(_DWORD *)v101 = v11;
    *(_WORD *)&v101[4] = 1024;
    *(_DWORD *)v102 = v12;
    *(_WORD *)&v102[4] = 1024;
    *(_DWORD *)v103 = v13;
    *(_WORD *)&v103[4] = 1024;
    *(_DWORD *)v104 = v14;
    *(_WORD *)&v104[4] = 1024;
    *(_DWORD *)v105 = v15;
    *(_WORD *)&v105[4] = 1024;
    *(_DWORD *)v106 = v16;
    *(_WORD *)&v106[4] = 1024;
    *(_DWORD *)v107 = v17;
    *(_WORD *)&v107[4] = 1024;
    *(_DWORD *)v108 = v18;
    *(_WORD *)&v108[4] = 1024;
    *(_DWORD *)v109 = v19;
    *(_WORD *)&v109[4] = 1024;
    *(_DWORD *)v110 = v20;
    *(_WORD *)&v110[4] = 1024;
    *(_DWORD *)v111 = v21;
    *(_WORD *)&v111[4] = 1024;
    *(_DWORD *)v112 = v22;
    *(_WORD *)&v112[4] = 1024;
    *(_DWORD *)v113 = v23;
    *(_WORD *)&v113[4] = 1024;
    v114 = v24;
    v115 = 1024;
    v116 = v25;
    v117 = 1024;
    v118 = v26;
    v119 = 1024;
    v120 = v27;
    v121 = 1024;
    v122 = v28;
    v123 = 1024;
    v124 = v89;
    v125 = 1024;
    v126 = v90;
    v127 = 1024;
    v128 = v91;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "LEStats: BMC:%lld LP:%lld, MC: %lld  %lld  ]  RxL:%05d:%05d:%05d  EAdv:%04d:%04d:%04d LeLR:%04d:%04d:%04d Aux:%04d:%04d:%04d Arsp:%04d:%04d:%04d cd:%04d:%04d:%04d aCrc:%05d:%05d:%05d def:%04d:%04d:%04d", buf, 0xBAu);
    v7 = qword_100999828;
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    v29 = *(_DWORD *)(a1 + 176);
    v30 = *(_DWORD *)(a1 + 180);
    v31 = *(_DWORD *)(a1 + 184);
    v32 = *(_DWORD *)(a1 + 188);
    v33 = *(_DWORD *)(a1 + 192);
    v34 = *(_DWORD *)(a1 + 196);
    v35 = *(_DWORD *)(a1 + 200);
    v36 = *(_DWORD *)(a1 + 204);
    v37 = *(_DWORD *)(a1 + 208);
    v38 = *(_DWORD *)(a1 + 212);
    v39 = *(_DWORD *)(a1 + 216);
    v40 = *(_DWORD *)(a1 + 220);
    v41 = *(_DWORD *)(a1 + 224);
    v42 = *(_DWORD *)(a1 + 228);
    v43 = *(_DWORD *)(a1 + 232);
    v44 = *(_DWORD *)(a1 + 236);
    v45 = *(_DWORD *)(a1 + 240);
    v46 = *(_DWORD *)(a1 + 244);
    v47 = *(_DWORD *)(a1 + 248);
    v48 = *(_DWORD *)(a1 + 252);
    v49 = *(_DWORD *)(a1 + 256);
    v50 = *(_DWORD *)(a1 + 260);
    v51 = *(_DWORD *)(a1 + 264);
    *(_DWORD *)buf = 67114752;
    *(_DWORD *)v93 = v29;
    *(_WORD *)&v93[4] = 1024;
    *(_DWORD *)&v93[6] = v30;
    LOWORD(v94) = 1024;
    *(_DWORD *)((char *)&v94 + 2) = v31;
    HIWORD(v94) = 1024;
    *(_DWORD *)v95 = v32;
    *(_WORD *)&v95[4] = 1024;
    *(_DWORD *)&v95[6] = v33;
    v96 = 1024;
    *(_DWORD *)v97 = v34;
    *(_WORD *)&v97[4] = 1024;
    *(_DWORD *)&v97[6] = v35;
    *(_WORD *)v98 = 1024;
    *(_DWORD *)&v98[2] = v36;
    *(_WORD *)v99 = 1024;
    *(_DWORD *)&v99[2] = v37;
    *(_WORD *)v100 = 1024;
    *(_DWORD *)&v100[2] = v38;
    *(_WORD *)v101 = 1024;
    *(_DWORD *)&v101[2] = v39;
    *(_WORD *)v102 = 1024;
    *(_DWORD *)&v102[2] = v40;
    *(_WORD *)v103 = 1024;
    *(_DWORD *)&v103[2] = v41;
    *(_WORD *)v104 = 1024;
    *(_DWORD *)&v104[2] = v42;
    *(_WORD *)v105 = 1024;
    *(_DWORD *)&v105[2] = v43;
    *(_WORD *)v106 = 1024;
    *(_DWORD *)&v106[2] = v44;
    *(_WORD *)v107 = 1024;
    *(_DWORD *)&v107[2] = v45;
    *(_WORD *)v108 = 1024;
    *(_DWORD *)&v108[2] = v46;
    *(_WORD *)v109 = 1024;
    *(_DWORD *)&v109[2] = v47;
    *(_WORD *)v110 = 1024;
    *(_DWORD *)&v110[2] = v48;
    *(_WORD *)v111 = 1024;
    *(_DWORD *)&v111[2] = v49;
    *(_WORD *)v112 = 1024;
    *(_DWORD *)&v112[2] = v50;
    *(_WORD *)v113 = 1024;
    *(_DWORD *)&v113[2] = v51;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "LEStats2: Rxa=%04d tSr=%04d tASr=%04d rSr=%04d tCi=%04d tCr=%04d rsRsp=%04d rsi=%04d rcr=%04d nba=%04d:%04d:%04d:%04d tot:%04d:%04d cden=%04d:%04d:%04d:%04d totAdv=%04d:%04d:%04d:%04d", buf, 0x8Cu);
    v7 = qword_100999828;
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    v53 = *(_DWORD *)(v2 + 2748);
    v54 = *(_DWORD *)(v2 + 2752);
    v55 = *(_DWORD *)(v2 + 2756);
    v56 = *(_DWORD *)(a1 + 60) + v53;
    v57 = *(_DWORD *)(a1 + 68) + v54;
    v58 = *(_DWORD *)(a1 + 44) + v55;
    *(_DWORD *)buf = 67110400;
    *(_DWORD *)v93 = v53;
    *(_WORD *)&v93[4] = 1024;
    *(_DWORD *)&v93[6] = v54;
    LOWORD(v94) = 1024;
    *(_DWORD *)((char *)&v94 + 2) = v55;
    HIWORD(v94) = 1024;
    *(_DWORD *)v95 = v56;
    *(_WORD *)&v95[4] = 1024;
    *(_DWORD *)&v95[6] = v57;
    v96 = 1024;
    *(_DWORD *)v97 = v58;
    _os_log_debug_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "BLEScanStat: MainCoreELNAOn [numAdvs, numAdvsBeforeFiltering, totalTime] [%d, %d, %d] -> [%d, %d, %d]", buf, 0x26u);
    v7 = qword_100999828;
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    v59 = *(_DWORD *)(v2 + 2760);
    v60 = *(_DWORD *)(v2 + 2764);
    v61 = *(_DWORD *)(v2 + 2768);
    v62 = *(_DWORD *)(a1 + 64) + v59;
    v63 = *(_DWORD *)(a1 + 72) + v60;
    v64 = *(_DWORD *)(a1 + 48) + v61;
    *(_DWORD *)buf = 67110400;
    *(_DWORD *)v93 = v59;
    *(_WORD *)&v93[4] = 1024;
    *(_DWORD *)&v93[6] = v60;
    LOWORD(v94) = 1024;
    *(_DWORD *)((char *)&v94 + 2) = v61;
    HIWORD(v94) = 1024;
    *(_DWORD *)v95 = v62;
    *(_WORD *)&v95[4] = 1024;
    *(_DWORD *)&v95[6] = v63;
    v96 = 1024;
    *(_DWORD *)v97 = v64;
    _os_log_debug_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "BLEScanStat: MainCoreELNABypass [numAdvs, numAdvsBeforeFiltering, totalTime] [%d, %d, %d] -> [%d, %d, %d]", buf, 0x26u);
    v7 = qword_100999828;
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    v65 = *(_DWORD *)(v2 + 2772);
    v66 = *(_DWORD *)(v2 + 2776);
    v67 = *(_DWORD *)(v2 + 2780);
    v68 = *(_DWORD *)(a1 + 252) + v65;
    v69 = *(_DWORD *)(a1 + 260) + v66;
    v70 = *(_DWORD *)(a1 + 228) + v67;
    *(_DWORD *)buf = 67110400;
    *(_DWORD *)v93 = v65;
    *(_WORD *)&v93[4] = 1024;
    *(_DWORD *)&v93[6] = v66;
    LOWORD(v94) = 1024;
    *(_DWORD *)((char *)&v94 + 2) = v67;
    HIWORD(v94) = 1024;
    *(_DWORD *)v95 = v68;
    *(_WORD *)&v95[4] = 1024;
    *(_DWORD *)&v95[6] = v69;
    v96 = 1024;
    *(_DWORD *)v97 = v70;
    _os_log_debug_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "BLEScanStat: ScanCoreELNAOn [numAdvs, numAdvsBeforeFiltering, totalTime] [%d, %d, %d] -> [%d, %d, %d]", buf, 0x26u);
    v7 = qword_100999828;
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    v71 = *(_DWORD *)(v2 + 2784);
    v72 = *(_DWORD *)(v2 + 2788);
    v73 = *(_DWORD *)(v2 + 2792);
    v74 = *(_DWORD *)(a1 + 256) + v71;
    v75 = *(_DWORD *)(a1 + 264) + v72;
    v76 = *(_DWORD *)(a1 + 232) + v73;
    *(_DWORD *)buf = 67110400;
    *(_DWORD *)v93 = v71;
    *(_WORD *)&v93[4] = 1024;
    *(_DWORD *)&v93[6] = v72;
    LOWORD(v94) = 1024;
    *(_DWORD *)((char *)&v94 + 2) = v73;
    HIWORD(v94) = 1024;
    *(_DWORD *)v95 = v74;
    *(_WORD *)&v95[4] = 1024;
    *(_DWORD *)&v95[6] = v75;
    v96 = 1024;
    *(_DWORD *)v97 = v76;
    _os_log_debug_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "BLEScanStat: ScanCoreELNABypass [numAdvs, numAdvsBeforeFiltering, totalTime] [%d, %d, %d] -> [%d, %d, %d]", buf, 0x26u);
    v7 = qword_100999828;
  }
  *(_DWORD *)(v2 + 2748) += *(_DWORD *)(a1 + 60);
  *(_DWORD *)(v2 + 2752) += *(_DWORD *)(a1 + 68);
  *(_DWORD *)(v2 + 2756) += *(_DWORD *)(a1 + 44);
  *(_DWORD *)(v2 + 2760) += *(_DWORD *)(a1 + 64);
  *(_DWORD *)(v2 + 2764) += *(_DWORD *)(a1 + 72);
  *(_DWORD *)(v2 + 2768) += *(_DWORD *)(a1 + 48);
  *(_DWORD *)(v2 + 2772) += *(_DWORD *)(a1 + 252);
  *(_DWORD *)(v2 + 2776) += *(_DWORD *)(a1 + 260);
  *(_DWORD *)(v2 + 2780) += *(_DWORD *)(a1 + 228);
  *(_DWORD *)(v2 + 2784) += *(_DWORD *)(a1 + 256);
  *(_DWORD *)(v2 + 2788) += *(_DWORD *)(a1 + 264);
  *(_DWORD *)(v2 + 2792) += *(_DWORD *)(a1 + 232);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
  {
    v77 = *(_DWORD *)(v2 + 3184);
    v78 = *(_DWORD *)(v2 + 3188);
    v79 = *(_DWORD *)(v2 + 3192);
    v80 = *(_DWORD *)(v2 + 3196);
    v81 = *(_DWORD *)(v2 + 3200);
    v82 = *(_DWORD *)(v2 + 3204);
    v83 = *(_DWORD *)(a1 + 284) + v77;
    v84 = *(_DWORD *)(a1 + 288) + v78;
    v85 = *(_DWORD *)(a1 + 292) + v79;
    v86 = *(_DWORD *)(a1 + 296) + v80;
    v87 = *(_DWORD *)(a1 + 276) + v81;
    v88 = *(_DWORD *)(a1 + 280) + v82;
    *(_DWORD *)buf = 67111936;
    *(_DWORD *)v93 = v77;
    *(_WORD *)&v93[4] = 1024;
    *(_DWORD *)&v93[6] = v78;
    LOWORD(v94) = 1024;
    *(_DWORD *)((char *)&v94 + 2) = v79;
    HIWORD(v94) = 1024;
    *(_DWORD *)v95 = v80;
    *(_WORD *)&v95[4] = 1024;
    *(_DWORD *)&v95[6] = v81;
    v96 = 1024;
    *(_DWORD *)v97 = v82;
    *(_WORD *)&v97[4] = 1024;
    *(_DWORD *)&v97[6] = v83;
    *(_WORD *)v98 = 1024;
    *(_DWORD *)&v98[2] = v84;
    *(_WORD *)v99 = 1024;
    *(_DWORD *)&v99[2] = v85;
    *(_WORD *)v100 = 1024;
    *(_DWORD *)&v100[2] = v86;
    *(_WORD *)v101 = 1024;
    *(_DWORD *)&v101[2] = v87;
    *(_WORD *)v102 = 1024;
    *(_DWORD *)&v102[2] = v88;
    _os_log_debug_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "BLEScanStat: ScanCoreCompensation [numAdvsELNAOn, numAdvsELNABypass, totalTimeELNAOn, totalTimeELNABypass, txBlankingBTMC, txBlankingWLAN] [%d, %d, %d, %d, %d, %d] -> [%d, %d, %d, %d, %d, %d]", buf, 0x4Au);
    v7 = qword_100999828;
  }
  *(int32x4_t *)(v2 + 3184) = vaddq_s32(*(int32x4_t *)(v2 + 3184), *(int32x4_t *)(a1 + 284));
  *(int32x2_t *)(v2 + 3200) = vadd_s32(*(int32x2_t *)(v2 + 3200), *(int32x2_t *)(a1 + 276));
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    sub_100716D68(a1, v7, v52);
}

void sub_1006760F8(uint64_t a1, char a2)
{
  uint64_t v4;
  double Current;
  double v6;
  double v7;
  _QWORD v8[5];
  char v9;

  v4 = sub_1000419F4();
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_1006761D4;
  v8[3] = &unk_100918888;
  v8[4] = a1;
  v9 = a2;
  sub_100041A34(v4, v8);
  if (*(_BYTE *)(a1 + 2245))
  {
    sub_100677028(a1);
    sub_100677A50(a1);
  }
  Current = CFAbsoluteTimeGetCurrent();
  v6 = *(double *)(a1 + 2728);
  if (Current > v6 && Current - v6 > 604800.0)
    sub_10066CD14(a1);
  v7 = *(double *)(a1 + 3232);
  if (Current > v7 && Current - v7 > 604800.0)
    sub_10066CDC8(a1);
}

void sub_1006761D4(uint64_t a1)
{
  uint64_t v1;
  int v2;
  NSObject *v3;
  int v4;
  const char *v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  int v13;
  _QWORD *v14;
  char v15;
  uint64_t v16;
  id v17;
  id v18;
  id v19;
  uint64_t v20;
  void *i;
  _QWORD *v22;
  _QWORD *v23;
  BOOL v24;
  char v25;
  NSObject *v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  NSObject *v34;
  int v35;
  uint64_t v36;
  int v37;
  NSObject *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  NSObject *v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  _BYTE buf[32];
  _BYTE v91[12];
  _BYTE v92[6];
  _BYTE v93[6];
  _BYTE v94[6];
  _BYTE v95[6];
  _BYTE v96[6];
  _BYTE v97[6];
  _BYTE v98[6];
  _BYTE v99[6];
  _BYTE v100[6];
  _BYTE v101[6];
  _BYTE v102[6];
  _BYTE v103[6];
  _BYTE v104[6];
  _BYTE v105[6];
  _BYTE v106[6];
  _BYTE v107[6];
  int v108;
  __int16 v109;
  int v110;
  __int16 v111;
  int v112;
  __int16 v113;
  int v114;
  __int16 v115;
  int v116;
  __int16 v117;
  int v118;
  __int16 v119;
  int v120;
  __int16 v121;
  int v122;
  _BYTE v123[128];

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(unsigned __int8 *)(a1 + 40);
  *(_BYTE *)(v1 + 144) = v2;
  v3 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    v4 = *(unsigned __int8 *)(v1 + 1851);
    if (v2)
      v5 = "On";
    else
      v5 = "Off";
    v6 = (unsigned __int16)objc_msgSend(*(id *)(v1 + 2112), "count");
    v7 = sub_10003BE44();
    v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 704))(v7);
    *(_DWORD *)buf = 67110402;
    *(_DWORD *)&buf[4] = v4;
    *(_WORD *)&buf[8] = 2082;
    *(_QWORD *)&buf[10] = v5;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v6;
    *(_WORD *)&buf[24] = 1024;
    *(_DWORD *)&buf[26] = v8;
    *(_WORD *)&buf[30] = 1024;
    *(_DWORD *)v91 = sub_10006E040(v1);
    *(_WORD *)&v91[4] = 1024;
    *(_DWORD *)&v91[6] = sub_10005CCAC(v1);
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "screenStateChanged fMatchBufferExpectedEntries:0x%d fScreenState:%{public}s fMatchActionTableRulesCount:%d supportedADVBuffers:%d haveAnyHwObjectDiscoveryRequests:%d haveAnyHwAOPBTBufferRequests:%d", buf, 0x2Au);
    v2 = *(unsigned __int8 *)(v1 + 144);
  }
  if (v2)
  {
    v9 = sub_1000419F4();
    *(_QWORD *)buf = _NSConcreteStackBlock;
    *(_QWORD *)&buf[8] = 3221225472;
    *(_QWORD *)&buf[16] = sub_1006751C0;
    *(_QWORD *)&buf[24] = &unk_1009173C0;
    *(_QWORD *)v91 = v1;
    *(_DWORD *)&v91[8] = 1;
    sub_100041A34(v9, buf);
    v10 = sub_1000419F4();
    *(_QWORD *)buf = _NSConcreteStackBlock;
    *(_QWORD *)&buf[8] = 3221225472;
    *(_QWORD *)&buf[16] = sub_1006750CC;
    *(_QWORD *)&buf[24] = &unk_1009173C0;
    *(_QWORD *)v91 = v1;
    *(_DWORD *)&v91[8] = 1;
    sub_100041A34(v10, buf);
  }
  else
  {
    if (objc_msgSend(*(id *)(v1 + 2112), "count"))
    {
      v11 = sub_10003BE44();
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v11 + 704))(v11))
      {
        if (*(unsigned __int8 *)(v1 + 1851) == 255)
        {
          v43 = sub_1006730E0(v1, 1);
          if (v43)
          {
            v44 = qword_100999828;
            if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)buf = 67109120;
              *(_DWORD *)&buf[4] = v43;
              _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_INFO, "enableMatchActionRulesBuffering failed with result %d", buf, 8u);
            }
          }
        }
      }
    }
    sub_10005C80C((unsigned __int8 *)v1);
    sub_10005CACC((unsigned __int8 *)v1);
  }
  if (sub_100676FAC(v1))
  {
    *(_BYTE *)(v1 + 1840) = 1;
    v12 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      v13 = *(_DWORD *)(v1 + 1960);
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Restarting scans since the screen is transitioning while there is a request for active scans fState:%d", buf, 8u);
    }
  }
  v14 = *(_QWORD **)(v1 + 2040);
  if (v14 == (_QWORD *)(v1 + 2048))
  {
LABEL_37:
    v25 = 0;
  }
  else
  {
    v15 = 0;
    while (1)
    {
      v16 = *(_QWORD *)(v14[5] + 8);
      if (*(_DWORD *)(v16 + 168))
        break;
      v17 = *(id *)(v16 + 176);
      v86 = 0u;
      v87 = 0u;
      v88 = 0u;
      v89 = 0u;
      v18 = v17;
      v19 = objc_msgSend(v18, "countByEnumeratingWithState:objects:count:", &v86, v123, 16);
      if (v19)
      {
        v20 = *(_QWORD *)v87;
        while (2)
        {
          for (i = 0; i != v19; i = (char *)i + 1)
          {
            if (*(_QWORD *)v87 != v20)
              objc_enumerationMutation(v18);
            if (objc_msgSend(*(id *)(*((_QWORD *)&v86 + 1) + 8 * (_QWORD)i), "intValue"))
            {
              v15 = 1;
              goto LABEL_28;
            }
          }
          v19 = objc_msgSend(v18, "countByEnumeratingWithState:objects:count:", &v86, v123, 16);
          if (v19)
            continue;
          break;
        }
      }
LABEL_28:

      v22 = (_QWORD *)v14[1];
      if (v22)
      {
        do
        {
          v23 = v22;
          v22 = (_QWORD *)*v22;
        }
        while (v22);
      }
      else
      {
        do
        {
          v23 = (_QWORD *)v14[2];
          v24 = *v23 == (_QWORD)v14;
          v14 = v23;
        }
        while (!v24);
      }
      v14 = v23;
      if (v23 == (_QWORD *)(v1 + 2048))
      {
        if ((v15 & 1) == 0)
          goto LABEL_37;
        break;
      }
    }
    v25 = 1;
    *(_BYTE *)(v1 + 1840) = 1;
    v26 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      v27 = *(_DWORD *)(v1 + 1960);
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v27;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Restarting scans since the screen is transitioning while there are scan agents with specific usecases fState:%d", buf, 8u);
    }
  }
  if (*(_DWORD *)(v1 + 1964) != 2 && ((v25 & 1) != 0 || *(_BYTE *)(v1 + 1840)))
    sub_100004AE4(v1, 1);
  v28 = sub_10003BE44();
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v28 + 664))(v28))
  {
    v29 = sub_1000438A4();
    if ((*(unsigned int (**)(uint64_t, uint64_t))(*(_QWORD *)v29 + 728))(v29, 1))
    {
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
        sub_100716DE4();
    }
  }
  else
  {
    v30 = sub_10003BE44();
    if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v30 + 624))(v30) & 1) != 0
      || (v31 = sub_10003BE44(), (*(unsigned int (**)(uint64_t))(*(_QWORD *)v31 + 648))(v31)))
    {
      v32 = sub_10003BE44();
      v33 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v32 + 656))(v32);
      v34 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
      {
        v35 = *(_DWORD *)(v1 + 1960);
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v35;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "Call LP Core statistic VSC scren:%d", buf, 8u);
      }
      v85 = 0;
      v84 = 0;
      v83 = 0;
      v82 = 0;
      v81 = 0;
      v80 = 0;
      v79 = 0;
      v78 = 0;
      v77 = 0;
      v76 = 0;
      v75 = 0;
      v74 = 0;
      v73 = 0;
      v72 = 0;
      v71 = 0;
      v70 = 0;
      v69 = 0;
      v67 = 0;
      v68 = 0;
      v65 = 0;
      v66 = 0;
      v63 = 0;
      v64 = 0;
      v61 = 0;
      v62 = 0;
      v59 = 0;
      v60 = 0;
      v58 = 0;
      v57 = 0;
      v36 = sub_1000438A4();
      v37 = (*(uint64_t (**)(uint64_t, uint64_t, char *, uint64_t *, char *, uint64_t *, char *, uint64_t *, char *, uint64_t *, char *, uint64_t *, char *, uint64_t *, char *, uint64_t *, char *, uint64_t *, char *, uint64_t *, char *, uint64_t *, char *, uint64_t *, char *, uint64_t *, char *, uint64_t *, char *, uint64_t *, char *, uint64_t *, char *, uint64_t *, char *, uint64_t *, char *, uint64_t *, char *, uint64_t *, char *, uint64_t *, char *, uint64_t *, char *, uint64_t *, char *, uint64_t *, char *, uint64_t *, char *, uint64_t *, char *, uint64_t *, char *, uint64_t *, char *, uint64_t *, int *))(*(_QWORD *)v36 + 720))(v36, v33, (char *)&v85 + 4, &v85, (char *)&v84 + 4, &v84, (char *)&v83 + 4, &v83, (char *)&v82 + 4, &v82, (char *)&v81 + 4, &v81, (char *)&v80 + 4, &v80, (char *)&v79 + 4, &v79, (char *)&v78 + 4, &v78, (char *)&v77 + 4,
              &v77,
              (char *)&v76 + 4,
              &v76,
              (char *)&v75 + 4,
              &v75,
              (char *)&v74 + 4,
              &v74,
              (char *)&v73 + 4,
              &v73,
              (char *)&v72 + 4,
              &v72,
              (char *)&v71 + 4,
              &v71,
              (char *)&v70 + 4,
              &v70,
              (char *)&v69 + 4,
              &v69,
              (char *)&v68 + 4,
              &v68,
              (char *)&v67 + 4,
              &v67,
              (char *)&v66 + 4,
              &v66,
              (char *)&v65 + 4,
              &v65,
              (char *)&v64 + 4,
              &v64,
              (char *)&v63 + 4,
              &v63,
              (char *)&v62 + 4,
              &v62,
              (char *)&v61 + 4,
              &v61,
              (char *)&v60 + 4,
              &v60,
              (char *)&v59 + 4,
              &v59,
              (char *)&v58 + 4,
              &v58,
              &v57);
      v38 = qword_100999828;
      if (v37 && os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v37;
        _os_log_error_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "Error reading getLPCoreStats %{bluetooth:OI_STATUS}u", buf, 8u);
        v38 = qword_100999828;
      }
      v39 = *(_QWORD *)(v1 + 2144) + v82;
      *(_QWORD *)(v1 + 2144) = v39;
      v40 = *(_QWORD *)(v1 + 2136) + HIDWORD(v81);
      *(_QWORD *)(v1 + 2136) = v40;
      v41 = *(_QWORD *)(v1 + 2160) + v83;
      *(_QWORD *)(v1 + 2160) = v41;
      v42 = *(_QWORD *)(v1 + 2152) + HIDWORD(v82);
      *(_QWORD *)(v1 + 2152) = v42;
      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134224896;
        *(_QWORD *)&buf[4] = v39;
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v40;
        *(_WORD *)&buf[22] = 2048;
        *(_QWORD *)&buf[24] = v41;
        *(_WORD *)v91 = 2048;
        *(_QWORD *)&v91[2] = v42;
        *(_WORD *)&v91[10] = 1024;
        *(_DWORD *)v92 = HIDWORD(v80);
        *(_WORD *)&v92[4] = 1024;
        *(_DWORD *)v93 = v80;
        *(_WORD *)&v93[4] = 1024;
        *(_DWORD *)v94 = HIDWORD(v79);
        *(_WORD *)&v94[4] = 1024;
        *(_DWORD *)v95 = v79;
        *(_WORD *)&v95[4] = 1024;
        *(_DWORD *)v96 = HIDWORD(v78);
        *(_WORD *)&v96[4] = 1024;
        *(_DWORD *)v97 = v78;
        *(_WORD *)&v97[4] = 1024;
        *(_DWORD *)v98 = HIDWORD(v77);
        *(_WORD *)&v98[4] = 1024;
        *(_DWORD *)v99 = v77;
        *(_WORD *)&v99[4] = 1024;
        *(_DWORD *)v100 = HIDWORD(v76);
        *(_WORD *)&v100[4] = 1024;
        *(_DWORD *)v101 = v76;
        *(_WORD *)&v101[4] = 1024;
        *(_DWORD *)v102 = HIDWORD(v75);
        *(_WORD *)&v102[4] = 1024;
        *(_DWORD *)v103 = v75;
        *(_WORD *)&v103[4] = 1024;
        *(_DWORD *)v104 = HIDWORD(v74);
        *(_WORD *)&v104[4] = 1024;
        *(_DWORD *)v105 = v74;
        *(_WORD *)&v105[4] = 1024;
        *(_DWORD *)v106 = HIDWORD(v73);
        *(_WORD *)&v106[4] = 1024;
        *(_DWORD *)v107 = v73;
        *(_WORD *)&v107[4] = 1024;
        v108 = HIDWORD(v72);
        v109 = 1024;
        v110 = v72;
        v111 = 1024;
        v112 = HIDWORD(v71);
        v113 = 1024;
        v114 = v71;
        v115 = 1024;
        v116 = HIDWORD(v70);
        v117 = 1024;
        v118 = v70;
        v119 = 1024;
        v120 = HIDWORD(v69);
        v121 = 1024;
        v122 = v69;
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "LEStats: BMC:%lld LP:%lld, MC: %lld  %lld  ]  RxL:%05d:%05d:%05d  EAdv:%04d:%04d:%04d LeLR:%04d:%04d:%04d Aux:%04d:%04d:%04d Arsp:%04d:%04d:%04d cd:%04d:%04d:%04d aCrc:%05d:%05d:%05d def:%04d:%04d:%04d", buf, 0xBAu);
        v38 = qword_100999828;
      }
      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67114752;
        *(_DWORD *)&buf[4] = HIDWORD(v68);
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = v68;
        *(_WORD *)&buf[14] = 1024;
        *(_DWORD *)&buf[16] = HIDWORD(v67);
        *(_WORD *)&buf[20] = 1024;
        *(_DWORD *)&buf[22] = v67;
        *(_WORD *)&buf[26] = 1024;
        *(_DWORD *)&buf[28] = HIDWORD(v66);
        *(_WORD *)v91 = 1024;
        *(_DWORD *)&v91[2] = v66;
        *(_WORD *)&v91[6] = 1024;
        *(_DWORD *)&v91[8] = HIDWORD(v65);
        *(_WORD *)v92 = 1024;
        *(_DWORD *)&v92[2] = v65;
        *(_WORD *)v93 = 1024;
        *(_DWORD *)&v93[2] = HIDWORD(v64);
        *(_WORD *)v94 = 1024;
        *(_DWORD *)&v94[2] = v64;
        *(_WORD *)v95 = 1024;
        *(_DWORD *)&v95[2] = HIDWORD(v63);
        *(_WORD *)v96 = 1024;
        *(_DWORD *)&v96[2] = v63;
        *(_WORD *)v97 = 1024;
        *(_DWORD *)&v97[2] = HIDWORD(v62);
        *(_WORD *)v98 = 1024;
        *(_DWORD *)&v98[2] = v62;
        *(_WORD *)v99 = 1024;
        *(_DWORD *)&v99[2] = HIDWORD(v61);
        *(_WORD *)v100 = 1024;
        *(_DWORD *)&v100[2] = v61;
        *(_WORD *)v101 = 1024;
        *(_DWORD *)&v101[2] = HIDWORD(v60);
        *(_WORD *)v102 = 1024;
        *(_DWORD *)&v102[2] = v60;
        *(_WORD *)v103 = 1024;
        *(_DWORD *)&v103[2] = HIDWORD(v59);
        *(_WORD *)v104 = 1024;
        *(_DWORD *)&v104[2] = v59;
        *(_WORD *)v105 = 1024;
        *(_DWORD *)&v105[2] = HIDWORD(v58);
        *(_WORD *)v106 = 1024;
        *(_DWORD *)&v106[2] = v58;
        *(_WORD *)v107 = 1024;
        *(_DWORD *)&v107[2] = v57;
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "LEStats2: Rxa=%04d tSr=%04d tASr=%04d rSr=%04d tCi=%04d tCr=%04d rsRsp=%04d rsi=%04d rcr=%04d nba=%04d:%04d:%04d:%04d tot:%04d:%04d cden=%04d:%04d:%04d:%04d totAdv=%04d:%04d:%04d:%04d", buf, 0x8Cu);
        v38 = qword_100999828;
      }
      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
      {
        v45 = *(_DWORD *)(v1 + 2748);
        v46 = *(_DWORD *)(v1 + 2752);
        v47 = *(_DWORD *)(v1 + 2756);
        *(_DWORD *)buf = 67110400;
        *(_DWORD *)&buf[4] = v45;
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = v46;
        *(_WORD *)&buf[14] = 1024;
        *(_DWORD *)&buf[16] = v47;
        *(_WORD *)&buf[20] = 1024;
        *(_DWORD *)&buf[22] = v83 + v45;
        *(_WORD *)&buf[26] = 1024;
        *(_DWORD *)&buf[28] = v82 + v46;
        *(_WORD *)v91 = 1024;
        *(_DWORD *)&v91[2] = v85 + v47;
        _os_log_debug_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEBUG, "BLEScanStat: MainCoreELNAOn [numAdvs, numAdvsBeforeFiltering, totalTime] [%d, %d, %d] -> [%d, %d, %d]", buf, 0x26u);
        v38 = qword_100999828;
      }
      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
      {
        v48 = *(_DWORD *)(v1 + 2760);
        v49 = *(_DWORD *)(v1 + 2764);
        v50 = *(_DWORD *)(v1 + 2768);
        *(_DWORD *)buf = 67110400;
        *(_DWORD *)&buf[4] = v48;
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = v49;
        *(_WORD *)&buf[14] = 1024;
        *(_DWORD *)&buf[16] = v50;
        *(_WORD *)&buf[20] = 1024;
        *(_DWORD *)&buf[22] = HIDWORD(v82) + v48;
        *(_WORD *)&buf[26] = 1024;
        *(_DWORD *)&buf[28] = HIDWORD(v81) + v49;
        *(_WORD *)v91 = 1024;
        *(_DWORD *)&v91[2] = HIDWORD(v84) + v50;
        _os_log_debug_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEBUG, "BLEScanStat: MainCoreELNABypass [numAdvs, numAdvsBeforeFiltering, totalTime] [%d, %d, %d] -> [%d, %d, %d]", buf, 0x26u);
        v38 = qword_100999828;
      }
      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
      {
        v51 = *(_DWORD *)(v1 + 2772);
        v52 = *(_DWORD *)(v1 + 2776);
        v53 = *(_DWORD *)(v1 + 2780);
        *(_DWORD *)buf = 67110400;
        *(_DWORD *)&buf[4] = v51;
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = v52;
        *(_WORD *)&buf[14] = 1024;
        *(_DWORD *)&buf[16] = v53;
        *(_WORD *)&buf[20] = 1024;
        *(_DWORD *)&buf[22] = v59 + v51;
        *(_WORD *)&buf[26] = 1024;
        *(_DWORD *)&buf[28] = v58 + v52;
        *(_WORD *)v91 = 1024;
        *(_DWORD *)&v91[2] = v62 + v53;
        _os_log_debug_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEBUG, "BLEScanStat: ScanCoreELNAOn [numAdvs, numAdvsBeforeFiltering, totalTime] [%d, %d, %d] -> [%d, %d, %d]", buf, 0x26u);
        v38 = qword_100999828;
      }
      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
      {
        v54 = *(_DWORD *)(v1 + 2784);
        v55 = *(_DWORD *)(v1 + 2788);
        v56 = *(_DWORD *)(v1 + 2792);
        *(_DWORD *)buf = 67110400;
        *(_DWORD *)&buf[4] = v54;
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = v55;
        *(_WORD *)&buf[14] = 1024;
        *(_DWORD *)&buf[16] = v56;
        *(_WORD *)&buf[20] = 1024;
        *(_DWORD *)&buf[22] = HIDWORD(v58) + v54;
        *(_WORD *)&buf[26] = 1024;
        *(_DWORD *)&buf[28] = v57 + v55;
        *(_WORD *)v91 = 1024;
        *(_DWORD *)&v91[2] = HIDWORD(v61) + v56;
        _os_log_debug_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEBUG, "BLEScanStat: ScanCoreELNABypass [numAdvs, numAdvsBeforeFiltering, totalTime] [%d, %d, %d] -> [%d, %d, %d]", buf, 0x26u);
      }
      *(_DWORD *)(v1 + 2748) += v83;
      *(_DWORD *)(v1 + 2752) += v82;
      *(_DWORD *)(v1 + 2756) += v85;
      *(_DWORD *)(v1 + 2760) += HIDWORD(v82);
      *(_DWORD *)(v1 + 2764) += HIDWORD(v81);
      *(_DWORD *)(v1 + 2768) += HIDWORD(v84);
      *(_DWORD *)(v1 + 2772) += v59;
      *(_DWORD *)(v1 + 2776) += v58;
      *(_DWORD *)(v1 + 2780) += v62;
      *(_DWORD *)(v1 + 2784) += HIDWORD(v58);
      *(_DWORD *)(v1 + 2788) += v57;
      *(_DWORD *)(v1 + 2792) += HIDWORD(v61);
    }
  }
}

void sub_100676F88(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL sub_100676FAC(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *v2;
  _BOOL8 result;
  _QWORD *v4;
  _QWORD *v5;
  BOOL v6;

  v1 = *(_QWORD **)(a1 + 2040);
  v2 = (_QWORD *)(a1 + 2048);
  if (v1 == (_QWORD *)(a1 + 2048))
    return 0;
  while (1)
  {
    result = sub_10006DB60(v1[5]);
    if (result)
      break;
    v4 = (_QWORD *)v1[1];
    if (v4)
    {
      do
      {
        v5 = v4;
        v4 = (_QWORD *)*v4;
      }
      while (v4);
    }
    else
    {
      do
      {
        v5 = (_QWORD *)v1[2];
        v6 = *v5 == (_QWORD)v1;
        v1 = v5;
      }
      while (!v6);
    }
    v1 = v5;
    if (v5 == v2)
      return result;
  }
  return 1;
}

void sub_100677028(uint64_t a1)
{
  NSObject *v2;
  double v3;
  double Current;
  NSObject *v5;
  double v6;
  double v7;
  BOOL v8;
  double v9;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  int v23;
  NSObject *v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  const char *v41;
  const char *v42;
  const char *v43;
  uint64_t v44;
  uint64_t v45;
  uint8_t buf[4];
  double v47;
  __int16 v48;
  const char *v49;
  __int16 v50;
  const char *v51;
  __int16 v52;
  uint64_t v53;

  v2 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: BLE Scan Stat:", buf, 2u);
    v2 = qword_100999828;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v3 = *(double *)(a1 + 2728);
    *(_DWORD *)buf = 134217984;
    v47 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: \tLast Stat Start Time: %f sec", buf, 0xCu);
  }
  Current = CFAbsoluteTimeGetCurrent();
  v5 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    v6 = *(double *)(a1 + 2728);
    v7 = Current - v6;
    v8 = Current < v6;
    v9 = 0.0;
    if (!v8)
      v9 = v7;
    *(_DWORD *)buf = 134217984;
    v47 = v9;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: \tStat Measurement Duration: %f sec", buf, 0xCu);
    v5 = qword_100999828;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v10 = *(_DWORD *)(a1 + 2736);
    *(_DWORD *)buf = 67109120;
    LODWORD(v47) = v10;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: \tNum Range Scan Requests: %u", buf, 8u);
    v5 = qword_100999828;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v11 = *(_DWORD *)(a1 + 2740);
    *(_DWORD *)buf = 67109120;
    LODWORD(v47) = v11;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: \tNum Priority Critical Scan Requests: %u", buf, 8u);
    v5 = qword_100999828;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v12 = *(_DWORD *)(a1 + 2744);
    *(_DWORD *)buf = 67109120;
    LODWORD(v47) = v12;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: \tNum Scan Requests: %u", buf, 8u);
  }
  v13 = sub_10003BE44();
  if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v13 + 624))(v13) & 1) != 0
    || (v14 = sub_10003BE44(), (*(unsigned int (**)(uint64_t))(*(_QWORD *)v14 + 648))(v14)))
  {
    v15 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "statedump: \tMainCoreELNAOnStat:", buf, 2u);
      v15 = qword_100999828;
    }
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      v16 = *(_DWORD *)(a1 + 2748);
      *(_DWORD *)buf = 67109120;
      LODWORD(v47) = v16;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "statedump: \t\tnumAdvsAfterFiltering: %u", buf, 8u);
      v15 = qword_100999828;
    }
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      v17 = *(_DWORD *)(a1 + 2752);
      *(_DWORD *)buf = 67109120;
      LODWORD(v47) = v17;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "statedump: \t\tnumAdvsBeforeFiltering: %u", buf, 8u);
      v15 = qword_100999828;
    }
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      v18 = *(_DWORD *)(a1 + 2756);
      *(_DWORD *)buf = 67109120;
      LODWORD(v47) = v18;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "statedump: \t\ttotalTime: %u msec", buf, 8u);
      v15 = qword_100999828;
    }
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "statedump: \tMainCoreELNABypassStat:", buf, 2u);
      v15 = qword_100999828;
    }
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      v19 = *(_DWORD *)(a1 + 2760);
      *(_DWORD *)buf = 67109120;
      LODWORD(v47) = v19;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "statedump: \t\tnumAdvsAfterFiltering: %u", buf, 8u);
      v15 = qword_100999828;
    }
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      v20 = *(_DWORD *)(a1 + 2764);
      *(_DWORD *)buf = 67109120;
      LODWORD(v47) = v20;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "statedump: \t\tnumAdvsBeforeFiltering: %u", buf, 8u);
      v15 = qword_100999828;
    }
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      v21 = *(_DWORD *)(a1 + 2768);
      *(_DWORD *)buf = 67109120;
      LODWORD(v47) = v21;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "statedump: \t\ttotalTime: %u msec", buf, 8u);
    }
  }
  v22 = sub_10003BE44();
  v23 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v22 + 648))(v22);
  v24 = qword_100999828;
  if (v23)
  {
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "statedump: \tScanCoreELNAOnStat:", buf, 2u);
      v24 = qword_100999828;
    }
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      v25 = *(_DWORD *)(a1 + 2772);
      *(_DWORD *)buf = 67109120;
      LODWORD(v47) = v25;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "statedump: \t\tnumAdvsAfterFiltering: %u", buf, 8u);
      v24 = qword_100999828;
    }
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      v26 = *(_DWORD *)(a1 + 2776);
      *(_DWORD *)buf = 67109120;
      LODWORD(v47) = v26;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "statedump: \t\tnumAdvsBeforeFiltering: %u", buf, 8u);
      v24 = qword_100999828;
    }
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      v27 = *(_DWORD *)(a1 + 2780);
      *(_DWORD *)buf = 67109120;
      LODWORD(v47) = v27;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "statedump: \t\ttotalTime: %u msec", buf, 8u);
      v24 = qword_100999828;
    }
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "statedump: \tScanCoreELNABypassStat:", buf, 2u);
      v24 = qword_100999828;
    }
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      v28 = *(_DWORD *)(a1 + 2784);
      *(_DWORD *)buf = 67109120;
      LODWORD(v47) = v28;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "statedump: \t\tnumAdvsAfterFiltering: %u", buf, 8u);
      v24 = qword_100999828;
    }
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      v29 = *(_DWORD *)(a1 + 2788);
      *(_DWORD *)buf = 67109120;
      LODWORD(v47) = v29;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "statedump: \t\tnumAdvsBeforeFiltering: %u", buf, 8u);
      v24 = qword_100999828;
    }
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      v30 = *(_DWORD *)(a1 + 2792);
      *(_DWORD *)buf = 67109120;
      LODWORD(v47) = v30;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "statedump: \t\ttotalTime: %u msec", buf, 8u);
      v24 = qword_100999828;
    }
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "statedump: \tScanCoreCompsensationStat:", buf, 2u);
      v24 = qword_100999828;
    }
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      v31 = *(_DWORD *)(a1 + 3184);
      *(_DWORD *)buf = 67109120;
      LODWORD(v47) = v31;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "statedump: \t\tnumAdvsELNAOn: %u", buf, 8u);
      v24 = qword_100999828;
    }
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      v32 = *(_DWORD *)(a1 + 3188);
      *(_DWORD *)buf = 67109120;
      LODWORD(v47) = v32;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "statedump: \t\numAdvsELNABypass: %u", buf, 8u);
      v24 = qword_100999828;
    }
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      v33 = *(_DWORD *)(a1 + 3192);
      *(_DWORD *)buf = 67109120;
      LODWORD(v47) = v33;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "statedump: \t\totalTimeELNAOn: %u", buf, 8u);
      v24 = qword_100999828;
    }
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      v34 = *(_DWORD *)(a1 + 3196);
      *(_DWORD *)buf = 67109120;
      LODWORD(v47) = v34;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "statedump: \t\totalTimeELNABypass: %u", buf, 8u);
      v24 = qword_100999828;
    }
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      v35 = *(_DWORD *)(a1 + 3200);
      *(_DWORD *)buf = 67109120;
      LODWORD(v47) = v35;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "statedump: \t\txBlankingTimeByBTMC: %u", buf, 8u);
      v24 = qword_100999828;
    }
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      v36 = *(_DWORD *)(a1 + 3204);
      *(_DWORD *)buf = 67109120;
      LODWORD(v47) = v36;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "statedump: \t\txBlankingTimeByWLAN: %u", buf, 8u);
      v24 = qword_100999828;
    }
  }
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "statedump: \tTotal Scan Time per Type:", buf, 2u);
    v24 = qword_100999828;
  }
  v37 = 0;
  v38 = a1 + 2800;
  do
  {
    v39 = 0;
    v45 = v38;
    do
    {
      v40 = 0;
      if (v39)
        v41 = "Active ";
      else
        v41 = "Passive";
      do
      {
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          *(double *)&v42 = COERCE_DOUBLE("Unknown Scan Agent Type");
          if (v40 <= 2u)
            v42 = off_10093F638[v40];
          v43 = "Unknown Duty Cycle Type";
          if (v37 <= 6u)
            v43 = off_10093F600[(char)v37];
          v44 = *(_QWORD *)(v38 + 8 * v40);
          *(_DWORD *)buf = 136446978;
          v47 = *(double *)&v42;
          v48 = 2082;
          v49 = v41;
          v50 = 2080;
          v51 = v43;
          v52 = 2048;
          v53 = v44;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "statedump: \t\t%{public}s %{public}s %-37s: %f sec", buf, 0x2Au);
          v24 = qword_100999828;
        }
        ++v40;
      }
      while (v40 != 3);
      ++v39;
      v38 += 24;
    }
    while (v39 != 2);
    ++v37;
    v38 = v45 + 48;
  }
  while (v37 != 7);
}

void sub_100677A50(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  double Current;
  NSObject *v5;
  double v6;
  double v7;
  CFAbsoluteTime v8;
  int v9;
  int v10;
  int v11;
  int v12;
  CFAbsoluteTime v13;

  v2 = sub_10003BE44();
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v2 + 648))(v2))
  {
    v3 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v12) = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "statedump: BLE Connection Scan Stat (ScanCore):", (uint8_t *)&v12, 2u);
    }
    Current = CFAbsoluteTimeGetCurrent();
    v5 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(double *)(a1 + 3232);
      v7 = Current - v6;
      if (Current < v6)
        v7 = 0.0;
      v12 = 134217984;
      v13 = v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: \tLast Stat Start Time: %f sec", (uint8_t *)&v12, 0xCu);
      v5 = qword_100999828;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v8 = CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 3232);
      v12 = 134217984;
      v13 = v8;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: \tStat Measurement Duration: %f sec", (uint8_t *)&v12, 0xCu);
      v5 = qword_100999828;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v9 = *(_DWORD *)(a1 + 3240);
      v12 = 67109120;
      LODWORD(v13) = v9;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: \tNum Connections made with MainCore while ScanCore Enabled:%u", (uint8_t *)&v12, 8u);
      v5 = qword_100999828;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v10 = *(_DWORD *)(a1 + 3244);
      v12 = 67109120;
      LODWORD(v13) = v10;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: \tNum Connections made with ScanCore while ScanCore Enabled:%u", (uint8_t *)&v12, 8u);
      v5 = qword_100999828;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v11 = *(_DWORD *)(a1 + 3248);
      v12 = 67109120;
      LODWORD(v13) = v11;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: \tNum ScanCore Enabled for Connection Scan:%u", (uint8_t *)&v12, 8u);
    }
  }
}

void sub_100677C98(uint64_t a1, char a2)
{
  sub_1006760F8(a1 - 24, a2);
}

__n128 sub_100677CA0(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 2152);
  result = *(__n128 *)(a1 + 2136);
  *(__n128 *)a2 = result;
  return result;
}

void sub_100677CB8(uint64_t a1)
{
  if (qword_100977A58 != -1)
    dispatch_once(&qword_100977A58, &stru_10093F478);
  sub_100069060((uint64_t)off_100977A50 + 64, a1 + 16);
  if (qword_100978170 != -1)
    dispatch_once(&qword_100978170, &stru_10093F458);
  sub_100069060((uint64_t)off_100978168 + 192, a1);
}

uint64_t sub_100677D48(uint64_t a1)
{
  return (*(_BYTE *)(a1 + 711) + *(_BYTE *)(a1 + 167));
}

uint64_t sub_100677D5C(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BYTE *v9;
  int v10;
  NSObject *v11;
  const __CFString *v12;
  NSObject *v13;
  const __CFString *v14;
  unsigned int v15;
  NSObject *v16;
  const __CFString *v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  NSObject *v21;
  const __CFString *v22;
  uint64_t v23;
  int v24;
  char v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  NSObject *v29;
  __CFString *v30;
  NSObject *v31;
  uint64_t v32;
  NSObject *v33;
  int v35;
  int v36;
  __int16 v37;
  uint8_t buf[4];
  const __CFString *v39;
  __int16 v40;
  int v41;

  if (a2 >= 3)
  {
    v3 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      LODWORD(v39) = a2;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "HW ADV Buffer handle out of range (%d), ignoring agent request", buf, 8u);
    }
    return 7;
  }
  v6 = sub_10003BE44();
  if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)v6 + 704))(v6))
  {
    v13 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      if (a2 > 2)
        v14 = CFSTR("UNKNOWN");
      else
        v14 = off_10093F698[(char)a2];
      *(_DWORD *)buf = 138543362;
      v39 = v14;
      v18 = "HW ADV for %{public}@ not supported on this hardware, ignoring agent request";
      goto LABEL_23;
    }
    return 11;
  }
  if ((_DWORD)a2 == 2)
  {
    v7 = sub_1000438A4();
    if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 2336))(v7) & 1) == 0)
    {
      v13 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138543362;
        v39 = CFSTR("EN");
        v18 = "HW ADV Buffers for %{public}@ not supported on this hardware, ignoring agent request";
LABEL_23:
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v18, buf, 0xCu);
        return 11;
      }
      return 11;
    }
  }
  v8 = a1 + 544 * a2;
  v10 = *(unsigned __int8 *)(v8 + 167);
  v9 = (_BYTE *)(v8 + 167);
  if (v10)
  {
    v11 = qword_100999828;
    if (!os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
      return 12;
    if (a2 > 2)
      v12 = CFSTR("UNKNOWN");
    else
      v12 = off_10093F698[(char)a2];
    *(_DWORD *)buf = 138543362;
    v39 = v12;
    v4 = 12;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "ADVBUFF(%{public}@): already created", buf, 0xCu);
    return v4;
  }
  v15 = a2;
  v37 = 0;
  v36 = 0;
  v16 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
  {
    if (a2 > 2)
      v17 = CFSTR("UNKNOWN");
    else
      v17 = off_10093F698[(char)a2];
    *(_DWORD *)buf = 138543362;
    v39 = v17;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_INFO, "ADVBUFF(%{public}@): sending advBufConfig", buf, 0xCu);
  }
  v19 = sub_1000438A4();
  v20 = a1 + 544 * a2;
  v4 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, int *, _QWORD, _QWORD, _QWORD, _QWORD, _BYTE))(*(_QWORD *)v19 + 2792))(v19, a2, *(v9 - 7), &v36, *(unsigned __int8 *)(v20 + 161), *(unsigned __int16 *)(v20 + 162), *(unsigned __int8 *)(v20 + 164), *(unsigned __int8 *)(v20 + 165), *(_BYTE *)(v20 + 166));
  v21 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
  {
    if (a2 > 2)
      v22 = CFSTR("UNKNOWN");
    else
      v22 = off_10093F698[(char)a2];
    *(_DWORD *)buf = 138543618;
    v39 = v22;
    v40 = 1024;
    v41 = v4;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_INFO, "ADVBUFF(%{public}@): ADVBufConfig returned %d", buf, 0x12u);
  }
  if ((_DWORD)v4)
  {
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
      sub_100717134();
    return v4;
  }
  v23 = *(_QWORD *)sub_1000438A4();
  if (a2 <= 1)
  {
    v24 = (*(uint64_t (**)(void))(v23 + 2328))();
    if (v24)
    {
      v25 = v24;
      v26 = 0;
      v4 = 0;
      v27 = a1 + 544 * a2 + 228;
      do
      {
        if (*(_WORD *)(v27 - 34))
        {
          v28 = sub_1000438A4();
          BYTE2(v35) = *(_BYTE *)(v27 - 28);
          LOWORD(v35) = *(_WORD *)(v27 - 30);
          v4 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, int *, _QWORD, _QWORD, _QWORD, _QWORD, int, uint64_t, uint64_t))(*(_QWORD *)v28 + 2800))(v28, a2, *(unsigned __int8 *)(v27 - 36), &v36, *(unsigned __int8 *)(v27 - 35), *(unsigned __int16 *)(v27 - 34), *(unsigned __int8 *)(v27 - 32), *(unsigned __int8 *)(v27 - 31), v35, v27 - 27, v27);
          if ((_DWORD)v4)
          {
            v29 = qword_100999828;
            if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
            {
              v30 = off_10093F698[(char)a2];
              *(_DWORD *)buf = 138543618;
              v39 = v30;
              v40 = 1024;
              v41 = v4;
              _os_log_error_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "ADVBUFF(%{public}@): Failed to configure ext buffer adv rule: %d", buf, 0x12u);
            }
          }
          else
          {
            --v25;
          }
        }
        if (v26 > 6)
          break;
        ++v26;
        v27 += 64;
      }
      while (v25);
    }
    else
    {
      v4 = 0;
    }
LABEL_59:
    *v9 = 1;
    *(_WORD *)(a1 + 544 * v15 + 170) = 0;
    return v4;
  }
  v4 = (*(uint64_t (**)(void))(v23 + 2864))();
  v31 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 138543618;
    v39 = CFSTR("EN");
    v40 = 1024;
    v41 = v4;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_INFO, "ADVBUFF(%{public}@): advBufRSSIBinsThreshold returned %d", buf, 0x12u);
  }
  if ((_DWORD)v4)
  {
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
      sub_1007170C4();
  }
  else
  {
    v32 = sub_1000438A4();
    v4 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v32 + 2872))(v32, a2, 0);
    v33 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 138543618;
      v39 = CFSTR("EN");
      v40 = 1024;
      v41 = v4;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_INFO, "ADVBUFF(%{public}@): advBufConfigTimeSlice returned %d", buf, 0x12u);
    }
    if (!(_DWORD)v4)
      goto LABEL_59;
  }
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
    sub_1007170C4();
  return v4;
}

void sub_10067839C(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  dispatch_time_t v8;
  _QWORD handler[5];
  _QWORD v10[6];
  uint8_t buf[4];
  uint64_t v12;

  if (!*(_QWORD *)(a1 + 2256))
  {
    *(_BYTE *)(a1 + 2288) = 0;
    if (qword_10097B180 != -1)
      dispatch_once(&qword_10097B180, &stru_10093F518);
    v2 = sub_10041C420((uint64_t)off_10097B178);
    v3 = qword_100999948;
    if (os_log_type_enabled((os_log_t)qword_100999948, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      v12 = v2;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "fContactTracingScanDurationTimer Timer %llu ms Armed!", buf, 0xCu);
    }
    sub_10067C0D8(a1);
    sub_10067C388(a1);
    if (qword_10097B180 != -1)
      dispatch_once(&qword_10097B180, &stru_10093F518);
    sub_10041BB04();
    v4 = sub_1000419F4();
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    v10[2] = sub_10067C8D8;
    v10[3] = &unk_100918090;
    v10[4] = a1;
    v10[5] = v2;
    sub_100041A34(v4, v10);
    v5 = sub_1000419F4();
    v6 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, *(dispatch_queue_t *)(v5 + 8));
    *(_QWORD *)(a1 + 2256) = v6;
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472;
    handler[2] = sub_10067C980;
    handler[3] = &unk_100917378;
    handler[4] = a1;
    dispatch_source_set_event_handler(v6, handler);
    v7 = *(NSObject **)(a1 + 2256);
    v8 = dispatch_time(0x8000000000000000, 1000000 * v2);
    dispatch_source_set_timer(v7, v8, 0xFFFFFFFFFFFFFFFFLL, 0);
    dispatch_activate(*(dispatch_object_t *)(a1 + 2256));
  }
}

uint64_t sub_10067858C(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v5;
  int v6;
  uint64_t v7;
  id v8;
  void *v9;
  id v10;
  id v11;
  uint64_t v12;
  void *i;
  void *v14;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  _BYTE v20[128];

  v5 = sub_10003BE44();
  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 952))(v5);
  v7 = 0;
  if (a2 && v6)
  {
    if (*(_QWORD *)(a2 + 8))
    {
      v8 = sub_10003920C(a2);
      v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
      if (sub_100039218(a2) == 589824)
      {
        *a3 = sub_100039218(a2);
LABEL_6:
        v7 = 1;
      }
      else
      {
        if (v9 && objc_msgSend(v9, "count"))
        {
          v18 = 0u;
          v19 = 0u;
          v16 = 0u;
          v17 = 0u;
          v10 = v9;
          v11 = objc_msgSend(v10, "countByEnumeratingWithState:objects:count:", &v16, v20, 16);
          if (v11)
          {
            v12 = *(_QWORD *)v17;
            while (2)
            {
              for (i = 0; i != v11; i = (char *)i + 1)
              {
                if (*(_QWORD *)v17 != v12)
                  objc_enumerationMutation(v10);
                v14 = *(void **)(*((_QWORD *)&v16 + 1) + 8 * (_QWORD)i);
                if (objc_msgSend(v14, "longLongValue", (_QWORD)v16) == 589824)
                {
                  *a3 = objc_msgSend(v14, "longLongValue");

                  goto LABEL_6;
                }
              }
              v11 = objc_msgSend(v10, "countByEnumeratingWithState:objects:count:", &v16, v20, 16);
              if (v11)
                continue;
              break;
            }
          }

        }
        v7 = 0;
      }

    }
    else
    {
      return 0;
    }
  }
  return v7;
}

void sub_10067871C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t sub_100678748(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)a2 + 72))(a2, *(unsigned int *)(a1 + 32), 1);
}

id sub_100678764(id a1, NSNumber *a2)
{
  NSNumber *v2;
  NSNumber *v3;
  NSNumber *v4;

  v2 = a2;
  if (-[NSNumber integerValue](v2, "integerValue") <= 0)
    v3 = 0;
  else
    v3 = v2;
  v4 = v3;

  return v4;
}

void sub_1006787A0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id sub_1006787B0(id a1, NSNumber *a2)
{
  NSNumber *v2;
  NSNumber *v3;
  NSNumber *v4;

  v2 = a2;
  if (-[NSNumber integerValue](v2, "integerValue") <= 0)
    v3 = 0;
  else
    v3 = v2;
  v4 = v3;

  return v4;
}

void sub_1006787EC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t sub_1006787FC(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  NSObject *v4;
  int v5;
  uint64_t v6;
  id v7;
  void *v8;
  void *v9;
  id v10;
  uint64_t v11;
  uint64_t i;
  void *v13;
  id v14;
  NSObject *v15;
  const char *v16;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  uint8_t v22[128];
  uint8_t buf[4];
  const char *v24;

  if (!a2 || !*(_QWORD *)(a2 + 8))
    return 0;
  v3 = sub_100039218(a2);
  if (sub_10067D3F8(v3, v3))
  {
    v4 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      v5 = sub_100039218(a2);
      *(_DWORD *)buf = 136315138;
      v24 = sub_100036ECC(v5);
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Scanning Prioritization over WiFi for useCase %s", buf, 0xCu);
    }
    return 1;
  }
  else
  {
    v7 = sub_10003920C(a2);
    v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
    v9 = v8;
    if (v8 && objc_msgSend(v8, "count"))
    {
      v20 = 0u;
      v21 = 0u;
      v18 = 0u;
      v19 = 0u;
      v10 = v9;
      v6 = (uint64_t)objc_msgSend(v10, "countByEnumeratingWithState:objects:count:", &v18, v22, 16);
      if (v6)
      {
        v11 = *(_QWORD *)v19;
        while (2)
        {
          for (i = 0; i != v6; ++i)
          {
            if (*(_QWORD *)v19 != v11)
              objc_enumerationMutation(v10);
            v13 = *(void **)(*((_QWORD *)&v18 + 1) + 8 * i);
            v14 = objc_msgSend(v13, "longLongValue", (_QWORD)v18);
            if (sub_10067D3F8((uint64_t)v14, (int)v14))
            {
              v15 = qword_100999828;
              if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
              {
                v16 = sub_100036ECC((int)objc_msgSend(v13, "longLongValue"));
                *(_DWORD *)buf = 136315138;
                v24 = v16;
                _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Scanning Prioritization over WiFi for useCase %s", buf, 0xCu);
              }
              v6 = 1;
              goto LABEL_23;
            }
          }
          v6 = (uint64_t)objc_msgSend(v10, "countByEnumeratingWithState:objects:count:", &v18, v22, 16);
          if (v6)
            continue;
          break;
        }
      }
LABEL_23:

    }
    else
    {
      v6 = 0;
    }

  }
  return v6;
}

void sub_100678A20(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t sub_100678A50(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 72))(a2, *(unsigned int *)(a1 + 32), 0);
}

void sub_100678A6C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v11;
  uint64_t v12;
  _QWORD v13[9];
  int v14;

  v11 = *(_QWORD *)(a1 + 32);
  v12 = sub_1000419F4();
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_100680BAC;
  v13[3] = &unk_10093DC00;
  v14 = a6;
  v13[4] = v11;
  v13[5] = a2;
  v13[6] = a3;
  v13[7] = a4;
  v13[8] = a5;
  sub_100041A34(v12, v13);
}

uint64_t sub_100678AFC(uint64_t a1, unint64_t a2, uint64_t a3)
{
  _QWORD *v4;
  uint64_t v6;
  unint64_t v7;
  BOOL v8;
  _QWORD *v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  _OWORD v15[3];
  uint64_t v16;

  if (!*(_DWORD *)(a1 + 1960))
    return 105;
  v4 = *(_QWORD **)(a1 + 2048);
  if (!v4)
    goto LABEL_29;
  v6 = a1 + 2048;
  do
  {
    v7 = v4[4];
    v8 = v7 >= a2;
    if (v7 >= a2)
      v9 = v4;
    else
      v9 = v4 + 1;
    if (v8)
      v6 = (uint64_t)v4;
    v4 = (_QWORD *)*v9;
  }
  while (*v9);
  if (v6 == a1 + 2048 || *(_QWORD *)(v6 + 32) > a2)
  {
LABEL_29:
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
      sub_100717284();
    return 401;
  }
  v11 = *(_QWORD *)(v6 + 40);
  if (((*(_QWORD *)(*(_QWORD *)(v11 + 8) + (((unint64_t)a3 >> 3) & 0x18) + 240) >> a3) & 1) == 0)
  {
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
      sub_1007172B0();
    return 401;
  }
  sub_10068AD40(v11, a3);
  v16 = 0;
  memset(v15, 0, sizeof(v15));
  v12 = sub_10003BE44();
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v12 + 600))(v12))
  {
    v13 = sub_1000438A4();
    v14 = (*(uint64_t (**)(uint64_t, _OWORD *, _QWORD, uint64_t, uint64_t))(*(_QWORD *)v13 + 752))(v13, v15, 0, 1, a3);
  }
  else
  {
    v14 = sub_100004AE4(a1, 1);
  }
  if (v14 && os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
    sub_1007172DC();
  return 0;
}

uint64_t sub_100678CB0(uint64_t a1, char a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;

  v7 = sub_1000438A4();
  if ((*(unsigned int (**)(uint64_t, _QWORD, uint64_t, uint64_t))(*(_QWORD *)v7 + 744))(v7, a2, a3, a4)&& os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
  {
    sub_10071733C();
  }
  return 0;
}

uint64_t sub_100678D30(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9;

  v9 = sub_1000438A4();
  if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v9 + 752))(v9, a2, a3, a4, a5)&& os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
  {
    sub_10071739C();
  }
  return 0;
}

uint64_t sub_100678DB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, unsigned int a8, unsigned __int8 a9, uint64_t a10, __int16 a11, char a12, char a13, char a14)
{
  uint64_t v20;
  uint64_t v21;
  uint64_t v23;

  v20 = sub_10003BE44();
  if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)v20 + 592))(v20)
    || (v21 = sub_1000438A4(),
        BYTE4(v23) = a14,
        BYTE3(v23) = a13,
        BYTE2(v23) = a12,
        LOWORD(v23) = a11,
        (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, uint64_t, uint64_t))(*(_QWORD *)v21 + 688))(v21, a3, a4, a5, a6, a7, a8, a9, a10, v23)))
  {
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
      sub_1007173FC();
  }
  return 0;
}

uint64_t sub_100678ECC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned __int8 a9, uint64_t a10, __int16 a11, char a12)
{
  uint64_t v18;
  uint64_t v19;
  int v21;

  v18 = sub_10003BE44();
  if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)v18 + 592))(v18)
    || (v19 = sub_1000438A4(),
        BYTE2(v21) = a12,
        LOWORD(v21) = a11,
        (*(unsigned int (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, int))(*(_QWORD *)v19 + 704))(v19, a3, a4, a5, a6, a7, a8, a9, a10, v21)))
  {
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
      sub_10071745C();
  }
  return 0;
}

uint64_t sub_100678FCC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v4 = sub_10003BE44();
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v4 + 592))(v4))
  {
    v5 = sub_1000438A4();
    v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v5 + 736))(v5, a3);
    if (!(_DWORD)v6)
      return v6;
  }
  else
  {
    v6 = 11;
  }
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
    sub_1007174BC();
  return v6;
}

uint64_t sub_100679050(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;

  v5 = sub_10003BE44();
  if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 592))(v5)
    || (v6 = sub_1000438A4(),
        (*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v6 + 712))(v6, a2, a3)))
  {
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
      sub_10071751C();
  }
  return 0;
}

uint64_t sub_1006790DC(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD v5[6];
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  char v9;

  v6 = 0;
  v7 = &v6;
  v8 = 0x2020000000;
  v9 = 0;
  v2 = sub_1000419F4();
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = sub_100679184;
  v5[3] = &unk_100919528;
  v5[4] = &v6;
  v5[5] = a1;
  sub_100023D84(v2, v5);
  v3 = *((unsigned __int8 *)v7 + 24);
  _Block_object_dispose(&v6, 8);
  return v3;
}

void sub_10067916C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100679184(uint64_t result)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = *(_DWORD *)(*(_QWORD *)(result + 40) + 1960) == 3;
  return result;
}

uint64_t sub_1006791A0(uint64_t a1, unint64_t a2)
{
  _QWORD *v2;
  _QWORD *v3;
  unint64_t v4;
  BOOL v5;
  _QWORD *v6;

  v2 = *(_QWORD **)(a1 + 2048);
  if (v2)
  {
    v3 = (_QWORD *)(a1 + 2048);
    do
    {
      v4 = v2[4];
      v5 = v4 >= a2;
      if (v4 >= a2)
        v6 = v2;
      else
        v6 = v2 + 1;
      if (v5)
        v3 = v2;
      v2 = (_QWORD *)*v6;
    }
    while (*v6);
    if (v3 != (_QWORD *)(a1 + 2048) && v3[4] <= a2 && *(_QWORD *)(v3[5] + 8))
      operator new();
  }
  return 0;
}

void sub_100679240()
{
  operator delete();
}

void sub_100679278(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  unsigned __int8 *v11;
  unint64_t v12;
  unsigned __int8 *v13;
  unint64_t v14;
  unint64_t v15;
  unsigned __int8 *v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  _QWORD *v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void **v29;

  if ((unint64_t)sub_10003F8C4(*(_QWORD *)(a2 + 8) + 48) >= 0x19)
  {
    v6 = sub_10003EB18(*(_QWORD *)(a2 + 8) + 48);
    v7 = *(_WORD *)v6 == 76 && *(_BYTE *)(v6 + 2) == 2;
    if (v7)
    {
      v8 = v6;
      if (*(unsigned __int8 *)(v6 + 3) >= 0x15u)
      {
        v9 = sub_1000438A4();
        if ((*(int (**)(uint64_t))(*(_QWORD *)v9 + 3520))(v9) <= a3)
        {
          v26 = 0;
          v27 = 0;
          v28 = 0;
          v10 = *(_QWORD **)(a1 + 2000);
          if (v10 != (_QWORD *)(a1 + 2008))
          {
            do
            {
              v11 = (unsigned __int8 *)sub_10003EB18((uint64_t)(v10 + 4));
              v12 = sub_10003F8C4((uint64_t)(v10 + 4));
              v13 = (unsigned __int8 *)sub_10003EB18((uint64_t)(v10 + 6));
              v14 = sub_10003F8C4((uint64_t)(v10 + 6));
              if (v12 >= v14)
                v15 = v14;
              else
                v15 = v12;
              if (v15)
              {
                v16 = (unsigned __int8 *)(v8 + 4);
                while (1)
                {
                  v18 = *v16++;
                  v17 = v18;
                  v19 = *v13++;
                  v20 = v19 & v17;
                  v21 = *v11++;
                  if (v20 != v21)
                    break;
                  if (!--v15)
                    goto LABEL_17;
                }
              }
              else
              {
LABEL_17:
                sub_10067A0BC(&v26, (uint64_t)(v10 + 4));
              }
              v22 = (_QWORD *)v10[1];
              if (v22)
              {
                do
                {
                  v23 = v22;
                  v22 = (_QWORD *)*v22;
                }
                while (v22);
              }
              else
              {
                do
                {
                  v23 = (_QWORD *)v10[2];
                  v7 = *v23 == (_QWORD)v10;
                  v10 = v23;
                }
                while (!v7);
              }
              v10 = v23;
            }
            while (v23 != (_QWORD *)(a1 + 2008));
            v24 = v26;
            v25 = v27;
            if (v27 != v26)
            {
              do
              {
                sub_100686E0C((uint64_t **)(a1 + 2000), v24);
                v24 += 32;
              }
              while (v24 != v25);
              sub_100679DC0(a1);
            }
          }
          v29 = (void **)&v26;
          sub_100686BD4(&v29);
        }
      }
    }
  }
}

void sub_100679424(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  sub_100686BD4(&a12);
  _Unwind_Resume(a1);
}

uint64_t sub_100679458(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a2 + 32))(a2, *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 32), a1 + 48);
}

uint64_t sub_100679474(uint64_t a1, uint64_t (***a2)(_QWORD, _QWORD, _QWORD, uint64_t, uint64_t, _QWORD, uint64_t, _QWORD))
{
  return (**a2)(a2, *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 32), a1 + 56, a1 + 72, *(unsigned __int8 *)(a1 + 120), a1 + 96, *(_QWORD *)(a1 + 40));
}

uint64_t *sub_1006794A0(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a1 + 56) = &off_100918298;
  *(_QWORD *)(a1 + 64) = v4;
  if (v4)
    sub_10003C37C(v4);
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  sub_1000B61B8((char *)(a1 + 72), *(__int128 **)(a2 + 72), *(__int128 **)(a2 + 80), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(a2 + 80) - *(_QWORD *)(a2 + 72)) >> 2));
  return sub_10068665C((uint64_t *)(a1 + 96), a2 + 96);
}

void sub_100679518(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  void **v2;
  uint64_t v3;
  void *v5;
  unsigned int *v6;

  v5 = *v2;
  if (*v2)
  {
    v1[10] = v5;
    operator delete(v5);
  }
  v1[7] = v3;
  v6 = (unsigned int *)v1[8];
  if (v6)
    sub_100056AAC(v6);
  _Unwind_Resume(exception_object);
}

void sub_10067954C(uint64_t a1)
{
  void *v2;
  unsigned int *v3;

  sub_10001A82C(a1 + 96, *(_QWORD **)(a1 + 104));
  v2 = *(void **)(a1 + 72);
  if (v2)
  {
    *(_QWORD *)(a1 + 80) = v2;
    operator delete(v2);
  }
  *(_QWORD *)(a1 + 56) = &off_100918298;
  v3 = *(unsigned int **)(a1 + 64);
  if (v3)
    sub_100056AAC(v3);
}

uint64_t sub_1006795A4(uint64_t a1, uint64_t (***a2)(_QWORD, _QWORD, _QWORD, uint64_t, uint64_t, _QWORD, uint64_t, _QWORD))
{
  return (**a2)(a2, *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 32), a1 + 56, a1 + 72, *(unsigned __int8 *)(a1 + 120), a1 + 96, *(_QWORD *)(a1 + 40));
}

id sub_1006795D0(uint64_t a1)
{
  id v1;

  if (*(_QWORD *)(a1 + 64) == *(_QWORD *)(a1 + 72) || !*(_QWORD *)(a1 + 160))
    v1 = *(id *)(a1 + 152);
  else
    v1 = (id)objc_claimAutoreleasedReturnValue(+[NSSet setWithObject:](NSSet, "setWithObject:"));
  return v1;
}

uint64_t sub_100679610(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)a2 + 48))(a2, *(_QWORD *)(a1 + 32), a1 + 40);
}

id sub_10067962C(uint64_t a1, uint64_t a2)
{
  id v3;
  unint64_t v4;
  _WORD *v5;
  _WORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  void *v11;

  v3 = objc_alloc_init((Class)NSMutableString);
  v4 = sub_10003F8C4(a2);
  v5 = (_WORD *)sub_10003EB18(a2);
  v6 = v5;
  if (v4 > 2)
  {
    if (v4 != 3)
    {
      LODWORD(v7) = 2;
      v8 = 3;
      do
      {
        v9 = *((unsigned __int8 *)v6 + v8);
        v10 = "Invalid";
        switch(*((_BYTE *)v6 + (int)v7))
        {
          case 0:
            break;
          case 1:
            v10 = "Hash";
            break;
          case 2:
            v10 = "iBeacon";
            break;
          case 3:
            v10 = "AirPrint";
            break;
          case 4:
            v10 = "LegacyATVSetup";
            break;
          case 5:
            v10 = "AirDrop";
            break;
          case 6:
            v10 = "HomeKitV1";
            break;
          case 7:
            v10 = "ProxPairing";
            break;
          case 8:
            v10 = "HeySiri";
            break;
          case 9:
            v10 = "AirPlayTarget";
            break;
          case 0xA:
            v10 = "AirPlaySource";
            break;
          case 0xB:
            v10 = "MagicSwitch";
            break;
          case 0xC:
            v10 = "Continuity";
            break;
          case 0xD:
            v10 = "TetheringTarget";
            break;
          case 0xE:
            v10 = "TetheringSource";
            break;
          case 0xF:
            v10 = "NearbyAction";
            break;
          case 0x10:
            v10 = "NearbyInfo";
            break;
          case 0x11:
            v10 = "HomeKitV2";
            break;
          case 0x12:
            v10 = "ObjectDiscovery";
            break;
          case 0x13:
            v10 = "SpatialInteraction";
            break;
          case 0x14:
            v10 = "DCKit";
            break;
          case 0x15:
            v10 = "NearbyActionV2";
            break;
          case 0x16:
            v10 = "NearbyInfoV2";
            break;
          case 0x17:
          case 0x19:
            goto LABEL_10;
          case 0x18:
            v10 = "DSInfo";
            break;
          case 0x1A:
            v10 = "NearbyActionNoWake";
            break;
          default:
            if (*((_BYTE *)v6 + (int)v7) == 100)
              v10 = "FastLEConnection";
            else
LABEL_10:
              v10 = "?";
            break;
        }
        v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v10));
        objc_msgSend(v3, "appendFormat:", CFSTR("%@,"), v11);

        v7 = (int)v7 + 2 + v9;
        v8 = v7 + 1;
      }
      while (v4 > v7 + 1);
    }
  }
  else if (*v5 != 76)
  {
    objc_msgSend(v3, "appendFormat:", CFSTR("Others,"));
  }
  return v3;
}

void sub_10067988C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t sub_1006798B4(uint64_t a1)
{
  sub_100056BAC(a1 + 24, *(char **)(a1 + 32));
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t sub_1006798F0(os_unfair_lock_s *a1, unsigned int a2)
{
  NSObject *v4;
  uint64_t os_unfair_lock_opaque;
  const char *v6;
  unsigned int v7;
  const char *v8;
  const char *v9;
  os_unfair_lock_s *v10;
  Block_layout *v11;
  int v13;
  const char *v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  unsigned int v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  unsigned int v22;

  v4 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    os_unfair_lock_opaque = (int)a1[490]._os_unfair_lock_opaque;
    if (os_unfair_lock_opaque > 4)
      v6 = "UNKNOWN";
    else
      v6 = off_10093F650[os_unfair_lock_opaque];
    v7 = a1[491]._os_unfair_lock_opaque;
    if (v7 > 3)
      v8 = "UNKNOWN";
    else
      v8 = off_10093F678[v7];
    if (a2 > 3)
      v9 = "UNKNOWN";
    else
      v9 = off_10093F678[a2];
    v13 = 136447234;
    v14 = v6;
    v15 = 2082;
    v16 = v8;
    v17 = 1024;
    v18 = v7;
    v19 = 2082;
    v20 = v9;
    v21 = 1024;
    v22 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "scan state:%{public}s, changing ObserverState %{public}s(%d) --> %{public}s(%d)", (uint8_t *)&v13, 0x2Cu);
  }
  a1[491]._os_unfair_lock_opaque = a2;
  switch(a2)
  {
    case 0u:
      sub_1004AF56C((uint64_t)&a1[14]);
      v10 = a1 + 468;
      v11 = &stru_10093F270;
      goto LABEL_16;
    case 1u:
    case 3u:
      sub_1004AF644((uint64_t)&a1[14]);
      break;
    case 2u:
      v10 = a1 + 468;
      v11 = &stru_10093F250;
LABEL_16:
      sub_10003F2E8(v10, v11);
      break;
    default:
      return sub_100004AE4(a1, 0);
  }
  return sub_100004AE4(a1, 0);
}

void sub_100679A90(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v6;
  NSObject *v7;
  NSObject *v8;
  uint8_t *v9;
  dispatch_time_t v10;
  dispatch_time_t v11;
  dispatch_time_t v12;
  NSObject *v13;
  dispatch_time_t v14;
  _QWORD v15[6];
  uint8_t buf[32];
  _BYTE v17[24];

  if ((unint64_t)sub_10003F8C4(a2) <= 0x15 && (v6 = sub_10003F8C4(a2), v6 <= sub_10003F8C4(a3)))
  {
    v8 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
    {
      sub_1000453F0(a2, buf);
      v9 = (buf[23] & 0x80u) == 0 ? buf : *(uint8_t **)buf;
      *(_DWORD *)v17 = 136446210;
      *(_QWORD *)&v17[4] = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "Received zone lost event for zone %{public}s", v17, 0xCu);
      if ((char)buf[23] < 0)
        operator delete(*(void **)buf);
    }
    v10 = dispatch_time(0, 0);
    v11 = *(_QWORD *)(a1 + 2024);
    if (v10 <= v11)
    {
      memset(buf, 0, sizeof(buf));
      sub_100685B74(buf, a2, a3);
      if ((_QWORD *)(a1 + 2008) == sub_10068686C(a1 + 2000, (uint64_t)buf))
      {
        v14 = dispatch_time(0, 30000000000);
        *(_QWORD *)v17 = buf;
        sub_100686958((uint64_t **)(a1 + 2000), (uint64_t)buf, (uint64_t)&unk_100740F58, (uint64_t *)v17)[8] = v14;
        sub_100679DC0(a1);
      }
      *(_QWORD *)&buf[16] = &off_100918258;
      if (*(_QWORD *)&buf[24])
        sub_100056AAC(*(unsigned int **)&buf[24]);
      *(_QWORD *)buf = &off_100918258;
      if (*(_QWORD *)&buf[8])
        sub_100056AAC(*(unsigned int **)&buf[8]);
    }
    else
    {
      v12 = v10;
      v13 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134218240;
        *(_QWORD *)&buf[4] = v11;
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v12;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "We are beyond the zone lost timeout (%lld).  Sending directly to clients.  Now %lld", buf, 0x16u);
      }
      v15[0] = _NSConcreteStackBlock;
      v15[1] = 3221225472;
      v15[2] = sub_100679DA8;
      v15[3] = &unk_10093F020;
      v15[4] = a2;
      v15[5] = a3;
      sub_10003F2E8((os_unfair_lock_s *)(a1 + 1872), v15);
      if (*(_DWORD *)(sub_1000438A4() + 712) == 1)
        sub_100004AE4(a1, 1);
    }
  }
  else
  {
    v7 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 134218240;
      *(_QWORD *)&buf[4] = sub_10003F8C4(a2);
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = sub_10003F8C4(a3);
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "Zone Lost event has invalid sizes.  zoneLength:%zu maskLength:%zu", buf, 0x16u);
    }
  }
}

void sub_100679D88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  sub_100679EB0((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100679DA8(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)a2 + 8))(a2, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
}

void sub_100679DC0(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  NSObject *v5;
  _QWORD *v6;
  dispatch_time_t v7;
  _QWORD *v8;
  _QWORD *v9;
  BOOL v10;

  v2 = *(_QWORD *)(a1 + 2016);
  v3 = *(NSObject **)(a1 + 2032);
  if (v2)
  {
    if (v3)
    {
      dispatch_suspend(v3);
    }
    else
    {
      v4 = sub_1000419F4();
      v5 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, *(dispatch_queue_t *)(v4 + 8));
      *(_QWORD *)(a1 + 2032) = v5;
      dispatch_source_set_event_handler(v5, &stru_10093F040);
    }
    v6 = *(_QWORD **)(a1 + 2000);
    v7 = -1;
    if (v6 != (_QWORD *)(a1 + 2008))
    {
      do
      {
        if (v7 >= v6[8])
          v7 = v6[8];
        v8 = (_QWORD *)v6[1];
        if (v8)
        {
          do
          {
            v9 = v8;
            v8 = (_QWORD *)*v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            v9 = (_QWORD *)v6[2];
            v10 = *v9 == (_QWORD)v6;
            v6 = v9;
          }
          while (!v10);
        }
        v6 = v9;
      }
      while (v9 != (_QWORD *)(a1 + 2008));
    }
    dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 2032), v7, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
    dispatch_resume(*(dispatch_object_t *)(a1 + 2032));
  }
  else if (v3)
  {
    dispatch_source_cancel(v3);
    dispatch_release(*(dispatch_object_t *)(a1 + 2032));
    *(_QWORD *)(a1 + 2032) = 0;
  }
}

_QWORD *sub_100679EB0(_QWORD *a1)
{
  unsigned int *v2;
  unsigned int *v3;

  a1[2] = &off_100918258;
  v2 = (unsigned int *)a1[3];
  if (v2)
    sub_100056AAC(v2);
  *a1 = &off_100918258;
  v3 = (unsigned int *)a1[1];
  if (v3)
    sub_100056AAC(v3);
  return a1;
}

void sub_100679EF8(id a1)
{
  if (qword_100977FB0 != -1)
    dispatch_once(&qword_100977FB0, &stru_10093F438);
  sub_100679F38((uint64_t)off_100977FA8);
}

void sub_100679F38(uint64_t a1)
{
  dispatch_time_t v2;
  _QWORD *v3;
  dispatch_time_t v4;
  _QWORD *v5;
  _QWORD *v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD v10[5];
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void **v14;

  v2 = dispatch_time(0, 0);
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v3 = *(_QWORD **)(a1 + 2000);
  if (v3 != (_QWORD *)(a1 + 2008))
  {
    v4 = v2;
    do
    {
      if (v3[8] <= v4)
      {
        v10[0] = _NSConcreteStackBlock;
        v10[1] = 3221225472;
        v10[2] = sub_10067A0A0;
        v10[3] = &unk_10093F060;
        v10[4] = v3 + 4;
        sub_10003F2E8((os_unfair_lock_s *)(a1 + 1872), v10);
        sub_10067A0BC(&v11, (uint64_t)(v3 + 4));
      }
      v5 = (_QWORD *)v3[1];
      if (v5)
      {
        do
        {
          v6 = v5;
          v5 = (_QWORD *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          v6 = (_QWORD *)v3[2];
          v7 = *v6 == (_QWORD)v3;
          v3 = v6;
        }
        while (!v7);
      }
      v3 = v6;
    }
    while (v6 != (_QWORD *)(a1 + 2008));
    v8 = v11;
    v9 = v12;
    while (v8 != v9)
    {
      sub_100686E0C((uint64_t **)(a1 + 2000), v8);
      v8 += 32;
    }
  }
  sub_100679DC0(a1);
  v14 = (void **)&v11;
  sub_100686BD4(&v14);
}

void sub_10067A07C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, void **a18)
{
  a18 = (void **)&a15;
  sub_100686BD4(&a18);
  _Unwind_Resume(a1);
}

uint64_t sub_10067A0A0(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)a2 + 8))(a2, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 32) + 16);
}

void *sub_10067A0BC(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  void *result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  void *v15;
  char *v16;
  _QWORD *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (v7 >= v6)
  {
    v10 = (uint64_t)(v7 - *a1) >> 5;
    if ((unint64_t)(v10 + 1) >> 59)
      abort();
    v11 = v5 - *a1;
    v12 = v11 >> 4;
    if (v11 >> 4 <= (unint64_t)(v10 + 1))
      v12 = v10 + 1;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0)
      v13 = 0x7FFFFFFFFFFFFFFLL;
    else
      v13 = v12;
    v19 = v4;
    if (v13)
      v14 = (char *)sub_1002A7408(v4, v13);
    else
      v14 = 0;
    v15 = v14;
    v16 = &v14[32 * v10];
    v18 = &v14[32 * v13];
    sub_100686B20(v16, a2);
    v17 = v16 + 32;
    sub_100686CA4(a1, &v15);
    v9 = a1[1];
    result = sub_100686D98(&v15);
  }
  else
  {
    result = sub_100686B20(*(_QWORD **)(v4 - 8), a2);
    v9 = v7 + 32;
    a1[1] = v7 + 32;
  }
  a1[1] = v9;
  return result;
}

void sub_10067A1A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  uint64_t v10;
  uint64_t v11;

  *(_QWORD *)(v10 + 8) = v11;
  _Unwind_Resume(exception_object);
}

uint64_t sub_10067A1C8(int a1, const void *a2, size_t __n, uint64_t a4)
{
  uint64_t result;
  NSObject *v8;
  uint64_t v9;
  _BYTE *v10;
  unsigned __int8 v11;

  result = 161;
  if (a2)
  {
    if (__n)
    {
      result = 161;
      if (a1 == 18)
      {
        if (a4)
        {
          if (__n < 0x1E)
          {
            v9 = a4 + 5072 + 56 * *(unsigned __int8 *)(a4 + 5632);
            *(_DWORD *)(v9 + 16) = 0;
            *(_OWORD *)v9 = xmmword_10073B660;
            v10 = (_BYTE *)(a4 + 5072 + 56 * *(unsigned __int8 *)(a4 + 5632));
            v10[20] = 1;
            v10[21] = __n < 4;
            memcpy(v10 + 22, a2, __n);
            result = 0;
            v11 = *(_BYTE *)(a4 + 5632);
            *(_WORD *)(a4 + 5072 + 56 * v11 + 52) = __n + 2;
            *(_BYTE *)(a4 + 5632) = v11 + 1;
          }
          else
          {
            v8 = qword_100999828;
            if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
              sub_100717B60(__n, v8);
            return 162;
          }
        }
      }
    }
  }
  return result;
}

uint64_t sub_10067A2C8(int a1, uint64_t a2, unint64_t a3, BOOL *a4)
{
  uint64_t result;

  result = 161;
  if (a2 && a3 && a1 == 18)
  {
    if (a4)
    {
      result = 0;
      *a4 = a3 < 3;
    }
  }
  return result;
}

uint64_t sub_10067A2F8(uint64_t a1)
{
  if (qword_100977FB0 != -1)
    dispatch_once(&qword_100977FB0, &stru_10093F438);
  return sub_10003C868((uint64_t)off_100977FA8, *(_QWORD *)(a1 + 32), *(unsigned __int8 *)(a1 + 56), a1 + 40, *(_BYTE *)(a1 + 57), *(unsigned __int8 *)(a1 + 58));
}

void sub_10067A360(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int *v4;
  unsigned int *v5;
  uint64_t v6;
  _QWORD v7[4];
  uint64_t (**v8)();
  unsigned int *v9;
  uint64_t (**v10)();
  unsigned int *v11;

  v4 = *(unsigned int **)(a2 + 8);
  if (v4)
    sub_10003C37C(*(_QWORD *)(a2 + 8));
  v5 = *(unsigned int **)(a3 + 8);
  if (v5)
    sub_10003C37C((uint64_t)v5);
  v6 = sub_1000419F4();
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3321888768;
  v7[2] = sub_10067A4BC;
  v7[3] = &unk_10093F0D0;
  v8 = &off_100918258;
  v9 = v4;
  if (v4)
    sub_10003C37C((uint64_t)v4);
  v10 = &off_100918258;
  v11 = v5;
  if (v5)
    sub_10003C37C((uint64_t)v5);
  sub_100041A34(v6, v7);
  v10 = &off_100918258;
  if (v11)
    sub_100056AAC(v11);
  v8 = &off_100918258;
  if (v9)
    sub_100056AAC(v9);
  if (v5)
    sub_100056AAC(v5);
  if (v4)
    sub_100056AAC(v4);
}

void sub_10067A44C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, unsigned int *a14, uint64_t a15, uint64_t a16)
{
  unsigned int *v16;
  unsigned int *v17;

  if (a14)
  {
    sub_100056AAC(a14);
    if (!v17)
    {
LABEL_3:
      if (!v16)
        goto LABEL_5;
      goto LABEL_4;
    }
  }
  else if (!v17)
  {
    goto LABEL_3;
  }
  sub_100056AAC(v17);
  if (!v16)
LABEL_5:
    _Unwind_Resume(exception_object);
LABEL_4:
  sub_100056AAC(v16);
  goto LABEL_5;
}

void sub_10067A4BC(uint64_t a1)
{
  if (qword_100977FB0 != -1)
    dispatch_once(&qword_100977FB0, &stru_10093F438);
  sub_100679A90((uint64_t)off_100977FA8, a1 + 32, a1 + 48);
}

void sub_10067A510(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = *(_QWORD *)(a2 + 40);
  a1[4] = &off_100918258;
  a1[5] = v4;
  if (v4)
    sub_10003C37C(v4);
  v5 = *(_QWORD *)(a2 + 56);
  a1[6] = &off_100918258;
  a1[7] = v5;
  if (v5)
    sub_10003C37C(v5);
}

void sub_10067A560(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;
  unsigned int *v4;

  *(_QWORD *)(v1 + 32) = v2;
  v4 = *(unsigned int **)(v1 + 40);
  if (v4)
    sub_100056AAC(v4);
  _Unwind_Resume(exception_object);
}

void sub_10067A57C(_QWORD *a1)
{
  unsigned int *v2;
  unsigned int *v3;

  a1[6] = &off_100918258;
  v2 = (unsigned int *)a1[7];
  if (v2)
    sub_100056AAC(v2);
  a1[4] = &off_100918258;
  v3 = (unsigned int *)a1[5];
  if (v3)
    sub_100056AAC(v3);
}

void sub_10067A5CC()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[16];

  v0 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_INFO, "Stream state changed, re-evaluating scan params", v2, 2u);
  }
  v1 = sub_1000419F4();
  sub_100041A34(v1, &stru_10093F100);
}

void sub_10067A640(id a1)
{
  if (qword_100977FB0 != -1)
    dispatch_once(&qword_100977FB0, &stru_10093F438);
  sub_100004AE4((uint64_t)off_100977FA8, 0);
}

void sub_10067A684()
{
  sub_10067A5CC();
}

void sub_10067A68C()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[16];

  v0 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_INFO, "BT ACL protect mode changed, re-evaluating scan params", v2, 2u);
  }
  v1 = sub_1000419F4();
  sub_100041A34(v1, &stru_10093F120);
}

void sub_10067A700(id a1)
{
  if (qword_100977FB0 != -1)
    dispatch_once(&qword_100977FB0, &stru_10093F438);
  sub_100004AE4((uint64_t)off_100977FA8, 0);
}

void sub_10067A744()
{
  sub_10067A68C();
}

void sub_10067A74C(uint64_t a1, int a2)
{
  NSObject *v4;
  uint64_t v5;
  _QWORD v6[5];
  char v7;
  uint8_t buf[4];
  int v9;

  v4 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    v9 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "SDP Progress Changed inProgress=%d", buf, 8u);
  }
  v5 = sub_1000419F4();
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_10067A838;
  v6[3] = &unk_100918888;
  v6[4] = a1;
  v7 = a2;
  sub_100041A34(v5, v6);
}

uint64_t sub_10067A838(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  *(_BYTE *)(v1 + 4384) = *(_BYTE *)(a1 + 40);
  return sub_100004AE4(v1, 0);
}

void sub_10067A854(uint64_t a1, int a2)
{
  sub_10067A74C(a1 - 32, a2);
}

void sub_10067A85C(uint64_t a1, unint64_t a2, uint64_t a3, char a4, char a5)
{
  unint64_t v8;
  __int128 v9;
  id v10;
  void *v11;
  uint64_t v12;
  id v13;
  _QWORD v14[4];
  id v15;
  uint64_t v16;
  char v17;
  char v18;
  unsigned __int8 uu[8];
  uint64_t v20;

  *((_QWORD *)&v9 + 1) = a3;
  *(_QWORD *)&v9 = bswap64(a2);
  v8 = v9 >> 16;
  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_10093F4F8);
  *(_QWORD *)uu = 0;
  v20 = 0;
  sub_10003F924((uint64_t)off_1009778C0, v8, 0, 1u, 0, 0, uu);
  if (uuid_is_null(uu))
  {
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
      sub_100717BEC();
  }
  else
  {
    v10 = sub_100030DF4(uu);
    v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
    v12 = sub_1000419F4();
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 3221225472;
    v14[2] = sub_10067A9F8;
    v14[3] = &unk_10092A3E0;
    v16 = a1;
    v13 = v11;
    v15 = v13;
    v17 = a4;
    v18 = a5;
    sub_100041A34(v12, v14);

  }
}

void sub_10067A9D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  void *v13;

  _Unwind_Resume(a1);
}

void sub_10067A9F8(uint64_t a1)
{
  void *v2;
  os_unfair_lock_s *v3;
  _QWORD v4[4];
  id v5;
  __int16 v6;

  v2 = *(void **)(a1 + 32);
  v3 = (os_unfair_lock_s *)(*(_QWORD *)(a1 + 40) + 1872);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_10067AA88;
  v4[3] = &unk_10093F148;
  v5 = v2;
  v6 = *(_WORD *)(a1 + 48);
  sub_10003F2E8(v3, v4);

}

void sub_10067AA74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{

  _Unwind_Resume(a1);
}

uint64_t sub_10067AA88(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a2 + 40))(a2, *(_QWORD *)(a1 + 32), *(unsigned __int8 *)(a1 + 40), *(unsigned __int8 *)(a1 + 41));
}

void sub_10067AAA8(uint64_t a1, uint64_t a2, uint64_t a3, char a4, char a5)
{
  sub_10067A85C(a1 - 8, a2 & 0xFFFFFFFFFFFFLL, a3, a4, a5);
}

uint64_t sub_10067AAB4(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t **v7;
  uint64_t **v8;
  char v9;
  __int16 v10;
  __int16 v11;
  __int16 v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t **v15;
  uint64_t v16;
  char v18;
  int v19;
  char v20;
  char v21;
  unsigned __int8 v22;
  unsigned __int16 v23;
  uint8_t buf[8];
  __int16 v25;
  int v26;

  v23 = 0;
  v4 = sub_100008090(a1, 18, 20, &v23);
  v5 = v23;
  *a2 = v23;
  if ((_DWORD)v4)
  {
    v6 = v4;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
      sub_100717224();
  }
  else
  {
    v7 = (uint64_t **)(a1 + 1816);
    v22 = v5;
    *(_QWORD *)buf = &v22;
    v8 = sub_10000DB5C(v7, &v22, (uint64_t)&unk_100740F58, (char **)buf);
    v9 = *((_BYTE *)v8 + 29);
    v10 = *((_WORD *)v8 + 15);
    v11 = *((_WORD *)v8 + 17);
    v12 = *((_WORD *)v8 + 19);
    v13 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)&buf[4] = v5;
      v25 = 1024;
      v26 = 18;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Creating a match table with handle %d for type %d", buf, 0xEu);
    }
    v14 = sub_1000438A4();
    v21 = 0;
    v20 = 0;
    v19 = 0;
    v18 = 0;
    v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, char, _QWORD, char, _QWORD, _QWORD, char))(*(_QWORD *)v14 + 2832))(v14, v5, 23, 255, 76, 18, 0, 20, v18, 0, v20, 0, 0, v21);
    if (!(_DWORD)v6)
    {
      v22 = v10;
      *(_QWORD *)buf = &v22;
      v15 = sub_10000DB5C(v7, &v22, (uint64_t)&unk_100740F58, (char **)buf);
      *((_BYTE *)v15 + 28) = 18;
      *((_BYTE *)v15 + 29) = v9;
      *((_WORD *)v15 + 15) = v10;
      *((_WORD *)v15 + 16) = 1;
      *((_WORD *)v15 + 17) = v11;
      *((_WORD *)v15 + 18) = 20;
      *((_WORD *)v15 + 19) = v12;
      *a2 = v5;
      v16 = sub_1000438A4();
      v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v16 + 2888))(v16, v5, 1, 10, 1, 12);
      if ((_DWORD)v6)
      {
        if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
          sub_100717CD4();
      }
    }
  }
  return v6;
}

void sub_10067AD10(id a1)
{
  uint64_t v1;
  uint64_t v2;
  void *__p[2];
  char v4;
  void *v5[2];
  char v6;

  v1 = sub_100027F68();
  sub_100091AE8(v5, "MatchTable");
  sub_100091AE8(__p, "ADPDBufferDupNumEntries");
  (*(void (**)(uint64_t, void **, void **, int *))(*(_QWORD *)v1 + 128))(v1, v5, __p, &dword_10097B8E8);
  if (v4 < 0)
    operator delete(__p[0]);
  if (v6 < 0)
    operator delete(v5[0]);
  v2 = sub_100027F68();
  sub_100091AE8(v5, "MatchTable");
  sub_100091AE8(__p, "ADPDBufferDupClearTimeoutSeconds");
  (*(void (**)(uint64_t, void **, void **, int *))(*(_QWORD *)v2 + 128))(v2, v5, __p, &dword_10097B8EC);
  if (v4 < 0)
    operator delete(__p[0]);
  if (v6 < 0)
    operator delete(v5[0]);
}

void sub_10067AE00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  _Unwind_Resume(exception_object);
}

void sub_10067AE3C(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  int v3;
  uint64_t v4;
  _QWORD v5[5];
  int v6;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    v3 = *(unsigned __int8 *)(v1 + 144);
    LODWORD(v5[0]) = 67109120;
    HIDWORD(v5[0]) = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "fAOPBTBufferPeriodicDrainTimer Timer expired! screenState:%d", (uint8_t *)v5, 8u);
  }
  dispatch_source_cancel(*(dispatch_source_t *)(v1 + 1808));
  dispatch_release(*(dispatch_object_t *)(v1 + 1808));
  *(_QWORD *)(v1 + 1808) = 0;
  v4 = sub_1000419F4();
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = sub_1006750CC;
  v5[3] = &unk_1009173C0;
  v5[4] = v1;
  v6 = 2;
  sub_100041A34(v4, v5);
}

void sub_10067AF38(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  int v3;
  uint64_t v4;
  _QWORD v5[5];
  int v6;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    v3 = *(unsigned __int8 *)(v1 + 144);
    LODWORD(v5[0]) = 67109120;
    HIDWORD(v5[0]) = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "fADVBufferPeriodicDrainTimer Timer expired! screenState:%d", (uint8_t *)v5, 8u);
  }
  dispatch_source_cancel(*(dispatch_source_t *)(v1 + 1800));
  dispatch_release(*(dispatch_object_t *)(v1 + 1800));
  *(_QWORD *)(v1 + 1800) = 0;
  if (!*(_BYTE *)(v1 + 144))
  {
    v4 = sub_1000419F4();
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472;
    v5[2] = sub_1006751C0;
    v5[3] = &unk_1009173C0;
    v5[4] = v1;
    v6 = 3;
    sub_100041A34(v4, v5);
  }
}

void sub_10067B03C(id a1)
{
  uint64_t v1;
  void *__p[2];
  char v3;
  void *v4[2];
  char v5;

  v1 = sub_100027F68();
  sub_100091AE8(v4, "ADVBUFF");
  sub_100091AE8(__p, "TestRemoevAndClearOnBufferDestroy");
  (*(void (**)(uint64_t, void **, void **, char *))(*(_QWORD *)v1 + 72))(v1, v4, __p, &byte_100994110);
  if (v3 < 0)
    operator delete(__p[0]);
  if (v5 < 0)
    operator delete(v4[0]);
}

void sub_10067B0C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  _Unwind_Resume(exception_object);
}

void sub_10067B0F8(uint64_t a1, void *a2)
{
  id v3;
  NSObject *v4;
  int v5;
  void *v6;
  id v7;
  id v8;
  NSData *v9;
  NSData *v10;
  void *v11;
  signed __int8 v12;
  void *v13;
  signed __int8 v14;
  unsigned __int8 v15;
  void *v16;
  NSObject *v17;
  uint64_t v18;
  void **v19;
  uint64_t v20;
  void (*v21)(uint64_t, void *, uint64_t, _BYTE *);
  void *v22;
  id v23;
  _BYTE *v24;
  uint8_t v25[4];
  uint64_t v26;
  __int16 v27;
  id v28;
  _BYTE buf[24];
  uint64_t (*v30)(uint64_t, uint64_t);
  void (*v31)(uint64_t);
  id v32;

  v3 = a2;
  v4 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
  {
    v5 = *(unsigned __int8 *)(a1 + 144);
    *(_DWORD *)buf = 138412546;
    *(_QWORD *)&buf[4] = v3;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "addUniqueUUIDRulesToDictionary %@ fScreenState:%d", buf, 0x12u);
  }
  if (*(_BYTE *)(a1 + 144))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x3032000000;
    v30 = sub_10067B468;
    v31 = sub_10067B478;
    v32 = 0;
    v6 = *(void **)(a1 + 4360);
    v19 = _NSConcreteStackBlock;
    v20 = 3221225472;
    v21 = sub_10067B480;
    v22 = &unk_10093F1B0;
    v7 = v3;
    v23 = v7;
    v24 = buf;
    objc_msgSend(v6, "enumerateObjectsUsingBlock:", &v19);
    v8 = objc_msgSend(v7, "mutableCopy", v19, v20, v21, v22);
    if (*(_QWORD *)(*(_QWORD *)&buf[8] + 40))
    {
      objc_msgSend(*(id *)(a1 + 4360), "removeObject:");
      v9 = objc_opt_new(NSData);
      objc_msgSend(v8, "setObject:forKeyedSubscript:", v9, CFSTR("data"));

      v10 = objc_opt_new(NSData);
      objc_msgSend(v8, "setObject:forKeyedSubscript:", v10, CFSTR("mask"));

      v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)&buf[8] + 40), "objectForKeyedSubscript:", CFSTR("rssi")));
      v12 = objc_msgSend(v11, "intValue");
      v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "objectForKeyedSubscript:", CFSTR("rssi")));
      v14 = objc_msgSend(v13, "intValue");
      if (v14 >= v12)
        v15 = v12;
      else
        v15 = v14;
      v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithChar:](NSNumber, "numberWithChar:", v15));
      objc_msgSend(v8, "setObject:forKeyedSubscript:", v16, CFSTR("rssi"));

      v17 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
      {
        v18 = *(_QWORD *)(*(_QWORD *)&buf[8] + 40);
        *(_DWORD *)v25 = 138412546;
        v26 = v18;
        v27 = 2112;
        v28 = v8;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_INFO, "addUniqueUUIDRulesToDictionary removing [%@] and replacing with [%@]", v25, 0x16u);
      }
    }
    objc_msgSend(*(id *)(a1 + 4360), "addObject:", v8);

    _Block_object_dispose(buf, 8);
  }
  else
  {
    objc_msgSend(*(id *)(a1 + 4360), "addObject:", v3);
  }

}

void sub_10067B3D8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t sub_10067B468(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_10067B478(uint64_t a1)
{

}

void sub_10067B480(uint64_t a1, void *a2, uint64_t a3, _BYTE *a4)
{
  id v7;
  void *v8;
  void *v9;
  unsigned int v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  __int16 v16;
  uint64_t v17;

  v7 = a2;
  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "objectForKeyedSubscript:", CFSTR("uuid")));
  v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "objectForKeyedSubscript:", CFSTR("uuid")));
  v10 = objc_msgSend(v8, "isEqual:", v9);

  if (v10)
  {
    objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), a2);
    *a4 = 1;
    v11 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
    {
      v12 = *(_QWORD *)(a1 + 32);
      v13 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40);
      v14 = 138412546;
      v15 = v13;
      v16 = 2112;
      v17 = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "addUniqueUUIDRulesToDictionary found existing rule [%@] with same uuid as new rule [%@]", (uint8_t *)&v14, 0x16u);
    }
  }

}

void sub_10067B5CC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_10067B5FC(uint64_t a1, void *a2)
{
  id v2;
  id v3;
  void *i;
  void *v5;
  void *v6;
  void *v7;
  unsigned int v8;
  NSObject *v9;
  void *v10;
  void *v11;
  unsigned int v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  unsigned __int8 v17;
  NSObject *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  unsigned int v26;
  int v27;
  void *v28;
  void *v29;
  unsigned int v30;
  int v31;
  void *v32;
  uint64_t v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  unsigned __int8 v39;
  NSObject *v40;
  void *v41;
  unsigned int v42;
  NSObject *v43;
  void *v44;
  unsigned int v45;
  id v46;
  id v47;
  id v48;
  id v49;
  uint64_t v50;
  void *v51;
  void *v52;
  id v53;
  void *v55;
  id obj;
  uint64_t v57;
  id v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  uint8_t v67[128];
  uint8_t v68[4];
  unsigned int v69;
  _BYTE buf[42];
  __int16 v71;
  void *v72;
  _BYTE v73[128];

  v2 = a2;
  v55 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](NSMutableArray, "array"));
  if (sub_100059A04((uint64_t)v55, v2))
  {
    v65 = 0u;
    v66 = 0u;
    v63 = 0u;
    v64 = 0u;
    obj = *(id *)(a1 + 4352);
    v3 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v63, v73, 16);
    if (v3)
    {
      v57 = *(_QWORD *)v64;
      do
      {
        v58 = v3;
        for (i = 0; i != v58; i = (char *)i + 1)
        {
          if (*(_QWORD *)v64 != v57)
            objc_enumerationMutation(obj);
          v5 = *(void **)(*((_QWORD *)&v63 + 1) + 8 * (_QWORD)i);
          v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("puckType")));
          v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "objectForKeyedSubscript:", CFSTR("puckType")));
          v8 = objc_msgSend(v6, "isEqual:", v7);

          if (!v8)
            continue;
          v9 = qword_100999828;
          if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
          {
            v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("puckType")));
            v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "objectForKeyedSubscript:", CFSTR("shouldConsolidateRule")));
            v12 = objc_msgSend(v11, "BOOLValue");
            *(_DWORD *)buf = 138413058;
            *(_QWORD *)&buf[4] = v10;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v12;
            *(_WORD *)&buf[18] = 2112;
            *(_QWORD *)&buf[20] = v5;
            *(_WORD *)&buf[28] = 2112;
            *(_QWORD *)&buf[30] = v2;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "Already have this rule for type %@ consolidate %d %@ new rule %@.", buf, 0x26u);

          }
          v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("bypassFilterDuplicate")));
          v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "objectForKeyedSubscript:", CFSTR("bypassFilterDuplicate")));
          if ((objc_msgSend(v13, "isEqualToNumber:", v14) & 1) == 0)
          {

LABEL_14:
            v18 = qword_100999828;
            if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
            {
              v19 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("puckType")));
              v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("bypassFilterDuplicate")));
              v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("rssi")));
              v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "objectForKeyedSubscript:", CFSTR("bypassFilterDuplicate")));
              v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "objectForKeyedSubscript:", CFSTR("rssi")));
              *(_DWORD *)buf = 138413314;
              *(_QWORD *)&buf[4] = v19;
              *(_WORD *)&buf[12] = 2112;
              *(_QWORD *)&buf[14] = v20;
              *(_WORD *)&buf[22] = 2112;
              *(_QWORD *)&buf[24] = v21;
              *(_WORD *)&buf[32] = 2112;
              *(_QWORD *)&buf[34] = v22;
              v71 = 2112;
              v72 = v23;
              _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_INFO, "Consolidate rules type %@ old bypassFilterDuplicate %@ rssi %@ new bypassFilterDuplicate %@ rssi %@", buf, 0x34u);

            }
            goto LABEL_16;
          }
          v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("rssi")));
          v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "objectForKeyedSubscript:", CFSTR("rssi")));
          v17 = objc_msgSend(v15, "isEqualToNumber:", v16);

          if ((v17 & 1) == 0)
            goto LABEL_14;
LABEL_16:
          v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "objectForKeyedSubscript:", CFSTR("shouldConsolidateRule")));
          if (v24)
          {
            v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "objectForKeyedSubscript:", CFSTR("shouldConsolidateRule")));
            v26 = objc_msgSend(v25, "BOOLValue");

            v27 = v26 ^ 1;
          }
          else
          {
            v27 = 0;
          }

          v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("shouldConsolidateRule")));
          if (v28)
          {
            v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("shouldConsolidateRule")));
            v30 = objc_msgSend(v29, "BOOLValue");

            v31 = v30 ^ 1;
          }
          else
          {
            v31 = 0;
          }

          if ((v27 | v31) != 1)
            goto LABEL_32;
          v32 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "objectForKeyedSubscript:", CFSTR("data")));
          v33 = objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("data")));
          v34 = (void *)v33;
          if (!v32 || !v33)
            goto LABEL_31;
          memset(buf, 0, 25);
          v35 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", buf, objc_msgSend(v32, "length")));
          v36 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", buf, objc_msgSend(v34, "length")));
          if ((objc_msgSend(v34, "isEqualToData:", v36) & 1) != 0
            || (objc_msgSend(v32, "isEqualToData:", v35) & 1) != 0
            || (objc_msgSend(v34, "isEqualToData:", v32) & 1) != 0)
          {
            if ((objc_msgSend(v34, "isEqualToData:", v32) & 1) != 0
              || (v37 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("matchAllDevices"))),
                  v38 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "objectForKeyedSubscript:", CFSTR("matchAllDevices"))),
                  v39 = objc_msgSend(v37, "isEqualToNumber:", v38),
                  v38,
                  v37,
                  (v39 & 1) != 0))
            {

LABEL_31:
LABEL_32:
              objc_msgSend(v55, "addObject:", v5);
              continue;
            }
            v40 = qword_100999828;
            if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
            {
              v41 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "objectForKeyedSubscript:", CFSTR("puckType")));
              v42 = objc_msgSend(v41, "intValue");
              *(_DWORD *)v68 = 67109120;
              v69 = v42;
              _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "device filer is different for type %d - ignore consolidating", v68, 8u);

            }
          }
          else
          {
            v43 = qword_100999828;
            if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
            {
              v44 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "objectForKeyedSubscript:", CFSTR("puckType")));
              v45 = objc_msgSend(v44, "intValue");
              *(_DWORD *)v68 = 67109120;
              v69 = v45;
              _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "non-zero data is different for type %d - ignore consolidating", v68, 8u);

            }
          }

        }
        v3 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v63, v73, 16);
      }
      while (v3);
    }

    if (objc_msgSend(v55, "count"))
    {
      v46 = objc_msgSend(v2, "copy");
      v61 = 0u;
      v62 = 0u;
      v59 = 0u;
      v60 = 0u;
      v47 = v55;
      v48 = objc_msgSend(v47, "countByEnumeratingWithState:objects:count:", &v59, v67, 16);
      v49 = v48;
      if (v48)
      {
        v50 = *(_QWORD *)v60;
        do
        {
          v51 = 0;
          v52 = v46;
          do
          {
            if (*(_QWORD *)v60 != v50)
              objc_enumerationMutation(v47);
            v53 = sub_10005A0A4((uint64_t)v48, *(void **)(*((_QWORD *)&v59 + 1) + 8 * (_QWORD)v51), v52);
            v46 = (id)objc_claimAutoreleasedReturnValue(v53);

            v51 = (char *)v51 + 1;
            v52 = v46;
          }
          while (v49 != v51);
          v48 = objc_msgSend(v47, "countByEnumeratingWithState:objects:count:", &v59, v67, 16);
          v49 = v48;
        }
        while (v48);
      }

      objc_msgSend(*(id *)(a1 + 4352), "removeObjectsInArray:", v47);
      objc_msgSend(*(id *)(a1 + 4352), "addObject:", v46);

    }
    else
    {
      objc_msgSend(*(id *)(a1 + 4352), "addObject:", v2);
    }
  }

}

void sub_10067BDC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  void *v17;
  void *v18;
  void *v19;

  _Unwind_Resume(a1);
}

BOOL sub_10067BF6C(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *v2;
  _BOOL8 result;
  _QWORD *v4;
  _QWORD *v5;
  BOOL v6;

  v1 = *(_QWORD **)(a1 + 2040);
  v2 = (_QWORD *)(a1 + 2048);
  if (v1 == (_QWORD *)(a1 + 2048))
    return 0;
  do
  {
    result = *(_BYTE *)(*(_QWORD *)(v1[5] + 8) + 3) != 0;
    if (*(_BYTE *)(*(_QWORD *)(v1[5] + 8) + 3))
      break;
    v4 = (_QWORD *)v1[1];
    if (v4)
    {
      do
      {
        v5 = v4;
        v4 = (_QWORD *)*v4;
      }
      while (v4);
    }
    else
    {
      do
      {
        v5 = (_QWORD *)v1[2];
        v6 = *v5 == (_QWORD)v1;
        v1 = v5;
      }
      while (!v6);
    }
    v1 = v5;
  }
  while (v5 != v2);
  return result;
}

uint64_t sub_10067BFD8(uint64_t a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  BOOL v7;

  v1 = *(_QWORD **)(a1 + 2040);
  if (v1 != (_QWORD *)(a1 + 2048))
  {
    do
    {
      v2 = *(_QWORD *)(v1[5] + 8);
      v3 = *(_QWORD *)(v2 + 96);
      v4 = *(_QWORD *)(v2 + 104);
      while (v3 != v4)
      {
        if (*(_DWORD *)(v3 + 96) == 2)
          return 1;
        v3 += 104;
      }
      v5 = (_QWORD *)v1[1];
      if (v5)
      {
        do
        {
          v6 = v5;
          v5 = (_QWORD *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          v6 = (_QWORD *)v1[2];
          v7 = *v6 == (_QWORD)v1;
          v1 = v6;
        }
        while (!v7);
      }
      v1 = v6;
    }
    while (v6 != (_QWORD *)(a1 + 2048));
  }
  return 0;
}

uint64_t sub_10067C058(uint64_t a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  BOOL v7;

  v1 = *(_QWORD **)(a1 + 2040);
  if (v1 != (_QWORD *)(a1 + 2048))
  {
    do
    {
      v2 = *(_QWORD *)(v1[5] + 8);
      v3 = *(_QWORD *)(v2 + 96);
      v4 = *(_QWORD *)(v2 + 104);
      while (v3 != v4)
      {
        if (*(_DWORD *)(v3 + 96) == 3)
          return 1;
        v3 += 104;
      }
      v5 = (_QWORD *)v1[1];
      if (v5)
      {
        do
        {
          v6 = v5;
          v5 = (_QWORD *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          v6 = (_QWORD *)v1[2];
          v7 = *v6 == (_QWORD)v1;
          v1 = v6;
        }
        while (!v7);
      }
      v1 = v6;
    }
    while (v6 != (_QWORD *)(a1 + 2048));
  }
  return 0;
}

uint64_t sub_10067C0D8(uint64_t result)
{
  if (!*(_QWORD *)(result + 2344))
    sub_10034FFF8();
  return result;
}

void sub_10067C1B0(uint64_t a1)
{
  uint64_t v1;
  NSObject *v3;
  uint64_t v4;
  int v5;
  uint64_t v6;

  v1 = *(_QWORD *)(a1 + 2344);
  if (v1)
  {
    v3 = qword_1009998D8;
    if (!os_log_type_enabled((os_log_t)qword_1009998D8, OS_LOG_TYPE_DEFAULT)
      || (v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 16))(v1),
          v5 = 136446210,
          v6 = v4,
          _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Destroying %{public}s", (uint8_t *)&v5, 0xCu), (v1 = *(_QWORD *)(a1 + 2344)) != 0))
    {
      (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
    }
    *(_QWORD *)(a1 + 2344) = 0;
  }
}

void sub_10067C28C(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  uint64_t v12;
  __int16 v13;
  uint64_t v14;
  __int16 v15;
  uint64_t v16;
  __int16 v17;
  uint64_t v18;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = sub_10005D5A4();
  (*(void (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, double))(*(_QWORD *)v2 + 64))(v2, *(_QWORD *)(v1 + 2296), *(_QWORD *)(v1 + 2304), *(_QWORD *)(v1 + 2312), *(_QWORD *)(v1 + 2320), *(double *)(v1 + 2328));
  v3 = qword_100999948;
  if (os_log_type_enabled((os_log_t)qword_100999948, OS_LOG_TYPE_DEFAULT))
  {
    v4 = *(_QWORD *)(v1 + 2296);
    v5 = *(_QWORD *)(v1 + 2304);
    v6 = *(_QWORD *)(v1 + 2312);
    v7 = *(_QWORD *)(v1 + 2320);
    v8 = *(_QWORD *)(v1 + 2328);
    v9 = 134219008;
    v10 = v4;
    v11 = 2048;
    v12 = v5;
    v13 = 2048;
    v14 = v6;
    v15 = 2048;
    v16 = v7;
    v17 = 2048;
    v18 = v8;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "reportExposureNotificationStats numOfScans:%llu duration:%llu numOfENReports:%llu numOfOtherReports:%llu lastENScanTS:%f", (uint8_t *)&v9, 0x34u);
  }
}

void sub_10067C388(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  dispatch_time_t v7;
  NSObject *v8;
  int v9;
  _QWORD handler[5];
  uint8_t buf[4];
  _QWORD v12[2];

  if (*(_QWORD *)(a1 + 2344))
  {
    if (qword_10097B180 != -1)
      dispatch_once(&qword_10097B180, &stru_10093F518);
    v2 = sub_10041C660((uint64_t)off_10097B178);
    v3 = qword_100999948;
    if (os_log_type_enabled((os_log_t)qword_100999948, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      v12[0] = v2;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "armContactTracingScanWithDuplicatesDurationTimer Timer %llu ms Armed!", buf, 0xCu);
    }
    v4 = sub_1000419F4();
    v5 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, *(dispatch_queue_t *)(v4 + 8));
    *(_QWORD *)(a1 + 2264) = v5;
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472;
    handler[2] = sub_10067C56C;
    handler[3] = &unk_100917378;
    handler[4] = a1;
    dispatch_source_set_event_handler(v5, handler);
    v6 = *(NSObject **)(a1 + 2264);
    v7 = dispatch_time(0x8000000000000000, 1000000 * v2);
    dispatch_source_set_timer(v6, v7, 0xFFFFFFFFFFFFFFFFLL, 0);
    dispatch_activate(*(dispatch_object_t *)(a1 + 2264));
    ++*(_BYTE *)(a1 + 2288);
  }
  else
  {
    v8 = qword_100999948;
    if (os_log_type_enabled((os_log_t)qword_100999948, OS_LOG_TYPE_INFO))
    {
      v9 = *(unsigned __int8 *)(a1 + 2288);
      *(_DWORD *)buf = 67109376;
      LODWORD(v12[0]) = v9;
      WORD2(v12[0]) = 1024;
      *(_DWORD *)((char *)v12 + 6) = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "fContactTracingScanDupClearDeltaTimer fContactTracingScanDupfilterClearCounter=%d isPowerAssertForContactTracingScanCreated=%d", buf, 0xEu);
    }
  }
}

uint64_t sub_10067C56C(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  uint8_t v4[16];

  v1 = *(_QWORD *)(a1 + 32);
  v2 = qword_100999948;
  if (os_log_type_enabled((os_log_t)qword_100999948, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "fContactTracingScanWithDuplicatesDurationTimer Timer expired!", v4, 2u);
  }
  dispatch_source_cancel(*(dispatch_source_t *)(v1 + 2264));
  dispatch_release(*(dispatch_object_t *)(v1 + 2264));
  *(_QWORD *)(v1 + 2264) = 0;
  *(_BYTE *)(v1 + 2352) = 0;
  sub_10067C60C(v1);
  sub_10067C76C(v1, 0);
  return sub_100004AE4(v1, 1);
}

void sub_10067C60C(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;
  NSObject *v4;
  void **v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  BOOL v10;
  void *__p[2];
  char v12;
  uint8_t buf[4];
  void **v14;

  v1 = *(_QWORD **)(a1 + 2040);
  v2 = (_QWORD *)(a1 + 2048);
  if (v1 != (_QWORD *)(a1 + 2048))
  {
    do
    {
      v3 = v1[5];
      if (*(_BYTE *)(*(_QWORD *)(v3 + 8) + 143))
      {
        v4 = qword_100999948;
        if (os_log_type_enabled((os_log_t)qword_100999948, OS_LOG_TYPE_DEFAULT))
        {
          sub_1000340DC(v1[4], (uint64_t)__p);
          v5 = v12 >= 0 ? __p : (void **)__p[0];
          *(_DWORD *)buf = 136446210;
          v14 = v5;
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Clearing scan agent sw dup filter map for session %{public}s", buf, 0xCu);
          if (v12 < 0)
            operator delete(__p[0]);
        }
        v7 = *(_QWORD **)(v3 + 112);
        v6 = (_QWORD *)(v3 + 112);
        sub_100024010((uint64_t)(v6 - 1), v7);
        *(v6 - 1) = v6;
        *v6 = 0;
        v6[1] = 0;
      }
      v8 = (_QWORD *)v1[1];
      if (v8)
      {
        do
        {
          v9 = v8;
          v8 = (_QWORD *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          v9 = (_QWORD *)v1[2];
          v10 = *v9 == (_QWORD)v1;
          v1 = v9;
        }
        while (!v10);
      }
      v1 = v9;
    }
    while (v9 != v2);
  }
}

void sub_10067C76C(uint64_t a1, int a2)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v5;
  _BYTE *v6;
  NSObject *v7;
  void **v8;
  _QWORD *v9;
  _QWORD *v10;
  BOOL v11;
  void *__p[2];
  char v13;
  uint8_t buf[4];
  void **v15;
  __int16 v16;
  int v17;

  v2 = *(_QWORD **)(a1 + 2040);
  v3 = (_QWORD *)(a1 + 2048);
  if (v2 != (_QWORD *)(a1 + 2048))
  {
    do
    {
      v5 = v2[5];
      v6 = *(_BYTE **)(v5 + 8);
      if (v6[143])
      {
        v7 = qword_100999948;
        if (os_log_type_enabled((os_log_t)qword_100999948, OS_LOG_TYPE_DEFAULT))
        {
          sub_1000340DC(v2[4], (uint64_t)__p);
          v8 = __p;
          if (v13 < 0)
            v8 = (void **)__p[0];
          *(_DWORD *)buf = 136446466;
          v15 = v8;
          v16 = 1024;
          v17 = a2;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Setting scan agent for session:%{public}s allowdups:%d", buf, 0x12u);
          if (v13 < 0)
            operator delete(__p[0]);
          v6 = *(_BYTE **)(v5 + 8);
        }
        *v6 = a2;
      }
      v9 = (_QWORD *)v2[1];
      if (v9)
      {
        do
        {
          v10 = v9;
          v9 = (_QWORD *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          v10 = (_QWORD *)v2[2];
          v11 = *v10 == (_QWORD)v2;
          v2 = v10;
        }
        while (!v11);
      }
      v2 = v10;
    }
    while (v10 != v3);
  }
}

double sub_10067C8D8(uint64_t a1)
{
  uint64_t v2;
  double result;

  v2 = *(_QWORD *)(a1 + 32);
  ++*(_QWORD *)(v2 + 2296);
  if (qword_10097B180 != -1)
    dispatch_once(&qword_10097B180, &stru_10093F518);
  result = (double)*(unint64_t *)(v2 + 2304)
         + (double)(*(_QWORD *)(a1 + 40) / 0x3E8uLL)
         * (48.0
          / (double)sub_10041C778((uint64_t)off_10097B178));
  *(_QWORD *)(v2 + 2304) = (unint64_t)result;
  return result;
}

void sub_10067C980(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  uint64_t v3;
  CFAbsoluteTime Current;
  _QWORD v5[6];

  v1 = *(_QWORD *)(a1 + 32);
  v2 = qword_100999948;
  if (os_log_type_enabled((os_log_t)qword_100999948, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v5[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "fContactTracingScanDurationTimer Timer expired!", (uint8_t *)v5, 2u);
  }
  dispatch_source_cancel(*(dispatch_source_t *)(v1 + 2256));
  dispatch_release(*(dispatch_object_t *)(v1 + 2256));
  *(_QWORD *)(v1 + 2256) = 0;
  *(_BYTE *)(v1 + 1840) = 1;
  *(_BYTE *)(v1 + 2352) = 1;
  sub_100004AE4(v1, 1);
  if (qword_10097B180 != -1)
    dispatch_once(&qword_10097B180, &stru_10093F518);
  sub_10041BBB0((uint64_t)off_10097B178);
  v3 = sub_1000419F4();
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = sub_10067C28C;
  v5[3] = &unk_100917378;
  v5[4] = v1;
  sub_100041A34(v3, v5);
  sub_10067217C(v1);
  Current = CFAbsoluteTimeGetCurrent();
  *(CFAbsoluteTime *)(v1 + 2328) = Current;
  *(CFAbsoluteTime *)(v1 + 2280) = Current;
  sub_10067C1B0(v1);
}

void sub_10067CAA0(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  NSObject *v3;
  CFAbsoluteTime Current;
  NSObject *v5;
  NSObject *v6;
  const char *v7;
  int v8;
  _BOOL4 v9;
  uint64_t v10;
  int v11;
  int v12;
  NSObject *v13;
  int v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _BYTE v23[24];
  void *v24;
  uint64_t v25;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = qword_100999948;
  if (os_log_type_enabled((os_log_t)qword_100999948, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v23 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "fContactTracingScanDeltaTimer Timer expired!", v23, 2u);
  }
  v3 = *(NSObject **)(v1 + 2272);
  if (v3)
  {
    dispatch_source_cancel(v3);
    dispatch_release(*(dispatch_object_t *)(v1 + 2272));
    *(_QWORD *)(v1 + 2272) = 0;
  }
  *(_BYTE *)(v1 + 1840) = 1;
  if (!*(_BYTE *)(v1 + 1255))
  {
    sub_10067839C(v1);
    sub_10067C76C(v1, 1);
    sub_10067C60C(v1);
    sub_100004AE4(v1, 1);
    return;
  }
  if (*(double *)(v1 + 2336) != 0.0)
  {
    Current = CFAbsoluteTimeGetCurrent();
    *(_QWORD *)(v1 + 2304) = (unint64_t)(Current
                                              - *(double *)(v1 + 2336)
                                              + (double)*(unint64_t *)(v1 + 2304));
    *(CFAbsoluteTime *)(v1 + 2336) = Current;
  }
  if (sub_100041D74(v1) && *(_BYTE *)(v1 + 1255))
  {
    v5 = qword_100999948;
    if (os_log_type_enabled((os_log_t)qword_100999948, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v23 = 138543362;
      *(_QWORD *)&v23[4] = CFSTR("EN");
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "ADVBUFF(%{public}@): Pausing ADV Buffers", v23, 0xCu);
    }
    if (*(unsigned __int8 *)(v1 + 1260) != 255)
    {
      v6 = qword_100999948;
      if (!os_log_type_enabled((os_log_t)qword_100999948, OS_LOG_TYPE_DEFAULT))
        goto LABEL_20;
      *(_DWORD *)v23 = 138543362;
      *(_QWORD *)&v23[4] = CFSTR("EN");
      v7 = "Already reading ADVBUFF(%{public}@):";
      goto LABEL_19;
    }
    v8 = sub_100671BC4(v1, 2, 0);
    v6 = qword_100999948;
    v9 = os_log_type_enabled((os_log_t)qword_100999948, OS_LOG_TYPE_DEFAULT);
    if (!v8)
    {
      if (v9)
      {
        v11 = *(unsigned __int8 *)(v1 + 1260);
        *(_DWORD *)v23 = 138543618;
        *(_QWORD *)&v23[4] = CFSTR("EN");
        *(_WORD *)&v23[12] = 1024;
        *(_DWORD *)&v23[14] = v11;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "ADVBUFF(%{public}@): Trying to read, current expectedEntries=%d", v23, 0x12u);
      }
      v12 = sub_100673E40(v1, 2);
      v13 = qword_100999948;
      if (os_log_type_enabled((os_log_t)qword_100999948, OS_LOG_TYPE_DEFAULT))
      {
        v14 = *(unsigned __int8 *)(v1 + 1260);
        *(_DWORD *)v23 = 138543874;
        *(_QWORD *)&v23[4] = CFSTR("EN");
        *(_WORD *)&v23[12] = 1024;
        *(_DWORD *)&v23[14] = v12;
        *(_WORD *)&v23[18] = 1024;
        *(_DWORD *)&v23[20] = v14;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "ADVBUFF(%{public}@): ReadADVBuffer returned %d, expectedEntries:%d", v23, 0x18u);
      }
      if (v12)
      {
        v15 = qword_100999828;
        if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_FAULT))
          sub_100718418(v15, v16, v17, v18, v19, v20, v21, v22);
      }
      if (*(unsigned __int8 *)(v1 + 1260) == 255)
      {
        sub_100671BC4(v1, 2, 1);
        if (os_log_type_enabled((os_log_t)qword_100999948, OS_LOG_TYPE_DEBUG))
          sub_1007183B8();
        sub_10067217C(v1);
      }
      goto LABEL_20;
    }
    if (v9)
    {
      *(_DWORD *)v23 = 138543362;
      *(_QWORD *)&v23[4] = CFSTR("EN");
      v7 = "ADVBUFF(%{public}@): could not disable ADV buffering";
LABEL_19:
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v7, v23, 0xCu);
    }
  }
LABEL_20:
  if (*(unsigned __int8 *)(v1 + 1260) == 255)
  {
    v10 = sub_1000419F4();
    *(_QWORD *)v23 = _NSConcreteStackBlock;
    *(_QWORD *)&v23[8] = 3221225472;
    *(_QWORD *)&v23[16] = sub_10067C28C;
    v24 = &unk_100917378;
    v25 = v1;
    sub_100041A34(v10, v23);
  }
}

uint64_t sub_10067CE64(uint64_t a1, uint64_t a2, int a3, uint64_t a4, unsigned __int8 *a5)
{
  uint64_t v9;
  uint64_t result;
  unsigned int v11;
  uint64_t v12;
  unsigned __int16 v13;
  unsigned int v15;
  unint64_t v16;

  v9 = sub_10003BE44();
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 888))(v9);
  switch(a3)
  {
    case 5:
      if ((_DWORD)result == 3)
      {
        v15 = *((unsigned __int16 *)a5 + 1);
        if (a5[1])
        {
          if (*(unsigned __int16 *)(a2 + 2) < v15)
          {
            *(_WORD *)(a2 + 2) = v15;
            goto LABEL_20;
          }
        }
        else if (*(unsigned __int16 *)(a2 + 4) < v15)
        {
          *(_WORD *)(a2 + 4) = v15;
          *(_WORD *)(a2 + 2) = 0;
        }
      }
      break;
    case 3:
      if (!(*(unsigned __int16 *)(a2 + 4) | *(unsigned __int16 *)(a2 + 2)))
      {
        v16 = 1374389535 * (*(unsigned __int16 *)(a4 + 4) - *(unsigned __int16 *)(a4 + 6)) * *a5;
        *(_WORD *)(a2 + 4) = (v16 >> 37) + (v16 >> 63);
      }
      if ((_DWORD)result != 3)
        goto LABEL_20;
      break;
    case 2:
      v11 = *(unsigned __int16 *)(a2 + 4);
      if (!*(_WORD *)(a2 + 4) && !*(_WORD *)(a2 + 2))
      {
        v12 = 1374389535 * (*(unsigned __int16 *)(a4 + 4) - *(unsigned __int16 *)(a4 + 6)) * *a5;
        v13 = (v12 >> 37) + ((unint64_t)v12 >> 63);
        v11 = v13;
        *(_WORD *)(a2 + 4) = v13;
      }
      if ((_DWORD)result != 2 || v11 < 0x11)
      {
        if ((int)result > 1)
          return result;
LABEL_20:
        *(_WORD *)(a2 + 4) = 0;
        return result;
      }
      *(_WORD *)(a2 + 4) = (unsigned __int16)((20976 * *a5) >> 16) >> 1;
      break;
  }
  return result;
}

void sub_10067CFBC(uint64_t a1, unsigned __int8 *a2, char a3, int a4, unsigned int a5, unsigned int a6, uint64_t a7, int a8)
{
  _WORD *v16;
  unsigned int v17;
  unsigned int v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t v26;
  NSObject *v27;
  const mach_header_64 *v28;
  unint64_t v29;
  _BOOL8 v30;
  _BOOL4 v31;
  int v32;
  NSObject *v33;
  int v34;
  int v35;
  const char *v36;
  int v37;
  int v38;
  _BOOL4 v39;
  unsigned int v40;
  int v41;
  int v42;
  _OWORD v43[2];
  uint64_t v44;
  uint8_t buf[4];
  int v46;
  __int16 v47;
  int v48;
  __int16 v49;
  unsigned int v50;
  __int16 v51;
  int v52;
  __int16 v53;
  unsigned int v54;
  __int16 v55;
  unsigned int v56;
  __int16 v57;
  int v58;
  __int16 v59;
  int v60;
  __int16 v61;
  int v62;
  __int16 v63;
  int v64;
  __int16 v65;
  const char *v66;
  __int16 v67;
  unsigned int v68;
  __int16 v69;
  int v70;

  v16 = a2 + 6;
  v17 = sub_100046E20(a1, *((unsigned __int16 *)a2 + 2), *((unsigned __int16 *)a2 + 3));
  if (v17 == 7)
    return;
  v18 = v17;
  if (a4 && (a3 & 1) == 0)
  {
    v19 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
      sub_100718488(v19);
    return;
  }
  v20 = sub_10003BE44();
  v21 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v20 + 888))(v20);
  v22 = v21 - 2;
  v41 = v21;
  if ((v21 - 2) < 2)
  {
    v42 = v21 - 2;
    v23 = *(_QWORD *)(a1 + ((unint64_t)v18 << 6) + 32 * *a2 + 16 * a5 + 8 * a6 + 3784);
    v44 = v23;
    if (*(_BYTE *)a7 || *(_WORD *)(a7 + 2))
    {
      v43[0] = *(_OWORD *)a2;
      *(_OWORD *)((char *)v43 + 10) = *(_OWORD *)(a2 + 10);
      sub_10067CE64(v21, (uint64_t)&v44, v18, (uint64_t)v43, (unsigned __int8 *)a7);
      v23 = v44;
    }
    v24 = *((unsigned __int16 *)a2 + 2);
    if (*((_WORD *)a2 + 2))
      v25 = 100 * (WORD1(v23) + WORD2(v23)) / v24;
    else
      v25 = 0;
    if (v18 == 6)
    {
      v31 = (v23 & 0xFFFFFFFFFFFFLL) == 0x2000000020;
    }
    else
    {
      if (v18 != 5)
      {
        v39 = 0;
        goto LABEL_24;
      }
      v31 = v25 < 0x32;
    }
    v39 = v31;
LABEL_24:
    if ((_WORD)v23)
      v32 = 100;
    else
      v32 = 50;
    if ((v23 & 0xFFFFFFFF0000) == 0)
      v32 = 0;
    v40 = v32;
    v33 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEBUG))
    {
      v34 = *((unsigned __int16 *)a2 + 3);
      v35 = *a2;
      v36 = "N";
      *(_DWORD *)buf = 67112194;
      v46 = v34;
      v47 = 1024;
      if (v39)
        v36 = "Y";
      v48 = v24;
      v49 = 1024;
      v50 = v18;
      v51 = 1024;
      v52 = v35;
      v53 = 1024;
      v54 = a5;
      v55 = 1024;
      v56 = a6;
      v57 = 1024;
      v58 = (unsigned __int16)v23;
      v59 = 1024;
      v60 = WORD1(v23);
      v61 = 1024;
      v62 = WORD2(v23);
      v63 = 1024;
      v64 = BYTE6(v23);
      v65 = 2082;
      v66 = v36;
      v67 = 1024;
      v68 = v40;
      v69 = 1024;
      v70 = 1;
      _os_log_debug_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEBUG, "scanParamsScanCoreTable: input [window %d interval %d type %d passive %d critical %d range %d] output [MCELNABypass %d SCELNAOn %d SCELNABypass %d concurrent %d] compensation [%{public}s, %d, query %d]", buf, 0x54u);
    }
    v29 = (unint64_t)v40 << 16;
    v28 = &_mh_execute_header;
    v30 = v39;
LABEL_31:
    v22 = v42;
    goto LABEL_32;
  }
  if ((_DWORD)v21 == 1)
  {
    v42 = -1;
    v26 = *a2;
    v23 = *(_QWORD *)(a1 + ((unint64_t)v18 << 6) + 32 * v26 + 16 * a5 + 8 * a6 + 3272);
    v27 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEBUG))
    {
      v37 = *((unsigned __int16 *)a2 + 3);
      v38 = *((unsigned __int16 *)a2 + 2);
      *(_DWORD *)buf = 67111424;
      v46 = v37;
      v47 = 1024;
      v48 = v38;
      v49 = 1024;
      v50 = v18;
      v51 = 1024;
      v52 = v26;
      v53 = 1024;
      v54 = a5;
      v55 = 1024;
      v56 = a6;
      v57 = 1024;
      v58 = (unsigned __int16)v23;
      v59 = 1024;
      v60 = WORD1(v23);
      v61 = 1024;
      v62 = WORD2(v23);
      v63 = 1024;
      v64 = BYTE6(v23);
      _os_log_debug_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEBUG, "scanParamsMainCoreELNABypassTable: input [window %d interval %d type %d passive %d critical %d range %d] output [MCELNABypass %d SCELNAOn %d SCELNABypass %d concurrent %d]", buf, 0x3Eu);
    }
    v28 = 0;
    v29 = 0;
    v30 = 0;
    goto LABEL_31;
  }
  v23 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 0;
LABEL_32:
  sub_100046ECC(a1, (uint64_t)a2, v23, v29 | (unint64_t)v28 | v30);
  if (a8 && v18 == 5)
  {
    if (v22 < 2)
    {
      v16 = a2 + 10;
    }
    else if (v41)
    {
      if (v41 != 1)
        return;
      v16 = a2 + 8;
    }
    *v16 += a8;
  }
}

uint64_t sub_10067D3F8(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t (*v7)(void);

  if (a2 == 22)
  {
    v6 = 50;
LABEL_8:
    v7 = *(uint64_t (**)(void))(*(_QWORD *)sub_10003BE44() + 8 * v6);
    return v7();
  }
  if (a2 == 265)
  {
    v2 = sub_10003BE44();
    if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 328))(v2) & 1) != 0)
      return 1;
    v3 = sub_10003BE44();
    if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 384))(v3) & 1) != 0)
      return 1;
    v4 = sub_10003BE44();
    if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 424))(v4) & 1) != 0)
      return 1;
    v6 = 117;
    goto LABEL_8;
  }
  return 0;
}

uint64_t sub_10067D48C(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  int v4;
  uint64_t v5;
  id v6;
  void *v7;
  void *v8;
  id v9;
  uint64_t v10;
  uint64_t i;
  void *v12;
  NSObject *v13;
  const char *v14;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint8_t v20[128];
  uint8_t buf[4];
  const char *v22;

  if (!a2 || !*(_QWORD *)(a2 + 8))
    return 0;
  if (sub_100039218(a2) == 22)
  {
    v3 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      v4 = sub_100039218(a2);
      *(_DWORD *)buf = 136315138;
      v22 = sub_100036ECC(v4);
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "ScanCore offloading is allowed while throttling due to SDP for %s", buf, 0xCu);
    }
    return 1;
  }
  else
  {
    v6 = sub_10003920C(a2);
    v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
    v8 = v7;
    if (v7 && objc_msgSend(v7, "count"))
    {
      v18 = 0u;
      v19 = 0u;
      v16 = 0u;
      v17 = 0u;
      v9 = v8;
      v5 = (uint64_t)objc_msgSend(v9, "countByEnumeratingWithState:objects:count:", &v16, v20, 16);
      if (v5)
      {
        v10 = *(_QWORD *)v17;
        while (2)
        {
          for (i = 0; i != v5; ++i)
          {
            if (*(_QWORD *)v17 != v10)
              objc_enumerationMutation(v9);
            v12 = *(void **)(*((_QWORD *)&v16 + 1) + 8 * i);
            if (objc_msgSend(v12, "longLongValue", (_QWORD)v16) == 22)
            {
              v13 = qword_100999828;
              if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
              {
                v14 = sub_100036ECC((int)objc_msgSend(v12, "longLongValue"));
                *(_DWORD *)buf = 136315138;
                v22 = v14;
                _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "ScanCore offloading is allowed while throttling due to SDP for %s", buf, 0xCu);
              }
              v5 = 1;
              goto LABEL_23;
            }
          }
          v5 = (uint64_t)objc_msgSend(v9, "countByEnumeratingWithState:objects:count:", &v16, v20, 16);
          if (v5)
            continue;
          break;
        }
      }
LABEL_23:

    }
    else
    {
      v5 = 0;
    }

  }
  return v5;
}

void sub_10067D6A8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t sub_10067D6D8(uint64_t a1, uint64_t a2)
{
  int v3;
  NSObject *v4;
  int v5;
  uint64_t v6;
  id v8;
  void *v9;
  void *v10;
  id v11;
  id v12;
  uint64_t v13;
  void *i;
  void *v15;
  unsigned int v16;
  NSObject *v18;
  const char *v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint8_t v24[128];
  uint8_t buf[4];
  const char *v26;

  if (!a2 || !*(_QWORD *)(a2 + 8))
    return 0;
  v3 = sub_100039218(a2);
  if (v3 == 2147418120 || v3 == 131101)
  {
    v4 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      v5 = sub_100039218(a2);
      *(_DWORD *)buf = 136315138;
      v26 = sub_100036ECC(v5);
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Wall power scan boost for %s is allowed", buf, 0xCu);
    }
    return 1;
  }
  else
  {
    v8 = sub_10003920C(a2);
    v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
    v10 = v9;
    if (v9 && objc_msgSend(v9, "count"))
    {
      v22 = 0u;
      v23 = 0u;
      v20 = 0u;
      v21 = 0u;
      v11 = v10;
      v12 = objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v20, v24, 16);
      if (v12)
      {
        v13 = *(_QWORD *)v21;
        while (2)
        {
          for (i = 0; i != v12; i = (char *)i + 1)
          {
            if (*(_QWORD *)v21 != v13)
              objc_enumerationMutation(v11);
            v15 = *(void **)(*((_QWORD *)&v20 + 1) + 8 * (_QWORD)i);
            v16 = objc_msgSend(v15, "longLongValue", (_QWORD)v20);
            if (v16 == 2147418120 || v16 == 131101)
            {
              v18 = qword_100999828;
              if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
              {
                v19 = sub_100036ECC((int)objc_msgSend(v15, "longLongValue"));
                *(_DWORD *)buf = 136315138;
                v26 = v19;
                _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Wall power scan boost for %s is allowed", buf, 0xCu);
              }
              v6 = 1;
              goto LABEL_29;
            }
          }
          v12 = objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v20, v24, 16);
          v6 = 0;
          if (v12)
            continue;
          break;
        }
      }
      else
      {
        v6 = 0;
      }
LABEL_29:

    }
    else
    {
      v6 = 0;
    }

  }
  return v6;
}

void sub_10067D934(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t sub_10067D964(uint64_t a1, uint64_t a2)
{
  int v3;
  unsigned int v5;
  NSObject *v6;
  int v7;
  id v8;
  void *v9;
  void *v10;
  id v11;
  id v12;
  uint64_t v13;
  void *i;
  void *v15;
  unsigned int v16;
  unsigned int v18;
  NSObject *v19;
  const char *v20;
  void *v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint8_t v27[128];
  uint8_t buf[4];
  double v29;
  __int16 v30;
  const char *v31;

  if (a2 && *(_QWORD *)(a2 + 8))
  {
    v3 = sub_100039218(a2);
    if (v3 == 2147418120 || v3 == 131101)
      v5 = 32;
    else
      v5 = 0;
    if (v3 == 2147418120 || v3 == 131101)
    {
      v6 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
      {
        v7 = sub_100039218(a2);
        *(_DWORD *)buf = 134218242;
        v29 = (double)v5 * 0.625;
        v30 = 2080;
        v31 = sub_100036ECC(v7);
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Scan boost incremental window %.2f msec for %s", buf, 0x16u);
      }
    }
    v8 = sub_10003920C(a2);
    v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
    v10 = v9;
    if (v9 && objc_msgSend(v9, "count"))
    {
      v25 = 0u;
      v26 = 0u;
      v23 = 0u;
      v24 = 0u;
      v11 = v10;
      v12 = objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v23, v27, 16);
      v22 = v10;
      if (v12)
      {
        v13 = *(_QWORD *)v24;
        do
        {
          for (i = 0; i != v12; i = (char *)i + 1)
          {
            if (*(_QWORD *)v24 != v13)
              objc_enumerationMutation(v11);
            v15 = *(void **)(*((_QWORD *)&v23 + 1) + 8 * (_QWORD)i);
            v16 = objc_msgSend(v15, "longLongValue");
            if (v16 == 2147418120 || v16 == 131101)
              v18 = 32;
            else
              v18 = 0;
            if (v18 > (unsigned __int16)v5)
            {
              v19 = qword_100999828;
              if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
              {
                v20 = sub_100036ECC((int)objc_msgSend(v15, "longLongValue"));
                *(_DWORD *)buf = 134218242;
                v29 = (double)v18 * 0.625;
                v30 = 2080;
                v31 = v20;
                _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Scan boost incremental window %.2f msec for %s", buf, 0x16u);
              }
              LOWORD(v5) = 32;
            }
          }
          v12 = objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v23, v27, 16);
        }
        while (v12);
      }

      v10 = v22;
    }

  }
  else
  {
    LOWORD(v5) = 0;
  }
  return (unsigned __int16)v5;
}

void sub_10067DBF8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t sub_10067DC34(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  _UNKNOWN **v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  __int128 v13;
  int v14;
  void *v15;
  NSNumber *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  NSNumber *v21;
  void *v22;
  void *v23;
  void *v24;
  NSNumber *v25;
  void *v26;
  NSNumber *v27;
  void *v28;
  NSNumber *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  NSString *v35;
  void *v36;
  _BYTE *v37;
  void *v38;
  _BYTE *v39;
  void *v40;
  uint64_t v41;
  BOOL v42;
  NSObject *v43;
  uint64_t v44;
  uint64_t v45;
  _UNKNOWN **v46;
  int v47;
  NSObject *v48;
  uint64_t v49;
  _BYTE *v50;
  _BOOL4 v51;
  _BOOL4 v52;
  id v53;
  void *v54;
  id v55;
  uint64_t v56;
  unsigned int v57;
  void *i;
  void *v59;
  uint64_t v60;
  NSObject *v61;
  int v62;
  NSObject *v63;
  uint64_t v64;
  int v65;
  int v66;
  const char *v67;
  const char *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  NSObject *v72;
  NSObject *v73;
  uint64_t v74;
  int v75;
  _BYTE *v76;
  int v77;
  _BYTE *v78;
  uint64_t v79;
  uint64_t v80;
  int v81;
  NSObject *v82;
  _BYTE *v83;
  NSObject *v84;
  BOOL v85;
  uint64_t v86;
  uint64_t v88;
  unsigned int v89;
  int v90;
  int v91;
  uint64_t v92;
  uint64_t v93;
  char v94;
  int v95;
  NSObject *v96;
  uint64_t v97;
  int v98;
  uint64_t v99;
  char v100;
  NSObject *v101;
  void *v102;
  int v103;
  _BYTE *v104;
  id v105;
  _BYTE *v106;
  void *v107;
  void *v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  unsigned int v112;
  id v113;
  void *v114;
  _QWORD *v115;
  _QWORD *v116;
  NSObject *v117;
  uint64_t v118;
  int v119;
  uint64_t v120;
  int v121;
  uint64_t v122;
  int v123;
  int v124;
  int v125;
  void *v126;
  NSObject *v127;
  id v128;
  unsigned __int16 v129;
  unsigned int v130;
  unsigned int v131;
  BOOL v132;
  unsigned int v133;
  NSObject *v134;
  unint64_t v135;
  unint64_t v136;
  unsigned __int8 *v137;
  __int16 v138;
  NSObject *v139;
  unint64_t v140;
  unint64_t v141;
  BOOL v142;
  unsigned __int8 *v143;
  int v144;
  unsigned int v145;
  unsigned int v146;
  double v147;
  NSObject *v148;
  NSObject *v149;
  unsigned __int8 *v150;
  NSObject *v151;
  _BOOL4 v152;
  const char *v153;
  const char *v154;
  BOOL v155;
  uint64_t v156;
  NSObject *v157;
  unsigned int v158;
  unsigned int v159;
  unsigned int v160;
  unsigned int v161;
  unsigned int v162;
  int v163;
  int v164;
  _BOOL4 v165;
  const char *v166;
  const char *v167;
  int v168;
  const char *v169;
  int v170;
  int v171;
  uint64_t v172;
  int v173;
  int v174;
  const char *v175;
  const char *v176;
  const char *v177;
  unsigned int v178;
  unsigned int v179;
  unsigned int v180;
  unsigned __int16 v181;
  unsigned __int16 v182;
  int v183;
  _BOOL4 v184;
  int v185;
  int v186;
  NSObject *v187;
  const char *v188;
  const char *v189;
  int v190;
  unsigned int v191;
  void *v192;
  void *v193;
  void *v194;
  void *v195;
  unint64_t v196;
  void *v197;
  unint64_t v198;
  void *v199;
  unint64_t v200;
  void *v201;
  unint64_t v202;
  void *v203;
  unint64_t v204;
  void *v205;
  void *v206;
  void *v207;
  void *v208;
  void *v209;
  void *v210;
  void *v211;
  void *v212;
  void *v213;
  void *v214;
  void *v215;
  void *v216;
  void *v217;
  void *v218;
  void *v219;
  void *v220;
  void *v221;
  void *v222;
  void *v223;
  void *v224;
  void *v225;
  void *v226;
  void *v227;
  id v228;
  uint64_t v230;
  unsigned int v231;
  int v232;
  int v233;
  unsigned int v234;
  unsigned int v235;
  int v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  int v240;
  char v241;
  BOOL v242;
  int v243;
  char v245;
  void *v246;
  uint64_t v247;
  void *v248;
  unsigned __int8 *v249;
  uint64_t v250;
  uint64_t v251;
  void *v252;
  _BOOL4 v253;
  id obj;
  id obja;
  _QWORD v256[4];
  id v257;
  char v258;
  char v259[15];
  __int128 v260;
  __int128 v261;
  __int128 v262;
  __int128 v263;
  _BYTE v264[104];
  _BYTE v265[6];
  _BYTE v266[6];
  __int16 v267;
  int v268;
  __int16 v269;
  int v270;
  __int16 v271;
  const char *v272;
  __int16 v273;
  const char *v274;
  __int16 v275;
  int v276;
  __int16 v277;
  const char *v278;
  __int16 v279;
  int v280;
  __int16 v281;
  int v282;
  _BYTE __p[24];
  __int16 v284;
  int v285;
  _BYTE v286[128];
  _BYTE buf[24];

  v3 = sub_10003BE44();
  v235 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 616))(v3);
  v4 = sub_10003BE44();
  v234 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 648))(v4);
  v5 = sub_10003BE44();
  v236 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 824))(v5);
  v6 = sub_1000438A4();
  v232 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 2672))(v6);
  *(_WORD *)a2 = 1;
  *(_BYTE *)(a2 + 2) = 0;
  *(_WORD *)(a2 + 8) = 0;
  *(_BYTE *)(a2 + 15) = 1;
  v249 = (unsigned __int8 *)a2;
  *(_WORD *)(a2 + 24) = 0;
  v248 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](NSMutableArray, "array"));
  v246 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary"));
  v7 = *(_QWORD **)(a1 + 2040);
  v8 = &AMFDRSealingMapCopyLocalDictForClass_ptr;
  if (v7 != (_QWORD *)(a1 + 2048))
  {
    v242 = 0;
    v243 = 0;
    v9 = 0;
    v231 = 0;
    v237 = 0;
    v245 = 0;
    v233 = 0;
    v230 = 0;
    v240 = 1;
    v241 = 0;
    v238 = 3;
    v10 = 30;
    v239 = 300;
    while (1)
    {
      v11 = *(_QWORD *)(v7[5] + 8);
      memset(&v264[16], 0, 88);
      *(_OWORD *)v264 = 0u;
      v12 = *(_QWORD *)(v7[5] + 8);
      v13 = *(_OWORD *)(v12 + 296);
      *(_OWORD *)v264 = *(_OWORD *)(v12 + 280);
      v14 = *(_DWORD *)(v11 + 168);
      *(_OWORD *)&v264[16] = v13;
      *(_OWORD *)&v264[28] = *(_OWORD *)(v12 + 308);
      *(_QWORD *)&v264[56] = 0;
      *(_QWORD *)&v264[48] = 0;
      sub_100685584(&v264[48], *(_QWORD *)(v12 + 328), *(_QWORD *)(v12 + 336), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(v12 + 336) - *(_QWORD *)(v12 + 328)) >> 5));
      memset(&v264[72], 0, 24);
      sub_1000B61B8(&v264[72], *(__int128 **)(v12 + 352), *(__int128 **)(v12 + 360), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(v12 + 360) - *(_QWORD *)(v12 + 352)) >> 2));
      v250 = v10;
      v264[96] = *(_BYTE *)(v12 + 376);
      v252 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary"));
      v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *(unsigned __int8 *)(*(_QWORD *)(v7[5] + 8) + 3)));
      objc_msgSend(v252, "setObject:forKeyedSubscript:", v15, CFSTR("isAllowedInPaused"));

      v16 = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", sub_100038A04(v7[5]));
      v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
      objc_msgSend(v252, "setObject:forKeyedSubscript:", v17, CFSTR("allowDupes"));

      v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", 0));
      objc_msgSend(v252, "setObject:forKeyedSubscript:", v18, CFSTR("window"));

      v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", 0));
      objc_msgSend(v252, "setObject:forKeyedSubscript:", v19, CFSTR("interval"));

      v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", 0));
      objc_msgSend(v252, "setObject:forKeyedSubscript:", v20, CFSTR("active"));

      v21 = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", sub_100038A1C(v7[5]));
      v22 = (void *)objc_claimAutoreleasedReturnValue(v21);
      objc_msgSend(v252, "setObject:forKeyedSubscript:", v22, CFSTR("requiresActiveScan"));

      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *(unsigned __int8 *)(v7[5] + 81) == 32));
      objc_msgSend(v252, "setObject:forKeyedSubscript:", v23, CFSTR("daemon"));

      v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *(unsigned __int8 *)(v7[5] + 81) == 16));
      objc_msgSend(v252, "setObject:forKeyedSubscript:", v24, CFSTR("ForegroundApp"));

      v25 = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", sub_1000340C8(v7[5]));
      v26 = (void *)objc_claimAutoreleasedReturnValue(v25);
      objc_msgSend(v252, "setObject:forKeyedSubscript:", v26, CFSTR("isAnyHWObjectDiscoveryEnabled"));

      objc_msgSend(v252, "setObject:forKeyedSubscript:", &off_100960AF0, CFSTR("HWADVBufferWindowMs"));
      objc_msgSend(v252, "setObject:forKeyedSubscript:", &off_100960AF0, CFSTR("HWADVBufferIntervalMs"));
      v27 = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", sub_100038A10(v7[5]));
      v28 = (void *)objc_claimAutoreleasedReturnValue(v27);
      objc_msgSend(v252, "setObject:forKeyedSubscript:", v28, CFSTR("isRangeScan"));

      v29 = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", sub_1000389F8(v7[5]));
      v30 = (void *)objc_claimAutoreleasedReturnValue(v29);
      objc_msgSend(v252, "setObject:forKeyedSubscript:", v30, CFSTR("isPriorityCritical"));

      v31 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *(unsigned __int8 *)(*(_QWORD *)(v7[5] + 8) + 142)));
      objc_msgSend(v252, "setObject:forKeyedSubscript:", v31, CFSTR("holdPowerAssert"));

      v32 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *(unsigned __int8 *)(*(_QWORD *)(v7[5] + 8) + 143)));
      objc_msgSend(v252, "setObject:forKeyedSubscript:", v32, CFSTR("isContactTracing"));

      v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(v7[5] + 208)));
      objc_msgSend(v252, "setObject:forKeyedSubscript:", v33, CFSTR("scanAgentType"));

      v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *(unsigned int *)(v7[5] + 96)));
      objc_msgSend(v252, "setObject:forKeyedSubscript:", v34, CFSTR("agentScanLevel"));

      v35 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", sub_100036ECC(v14));
      v36 = (void *)objc_claimAutoreleasedReturnValue(v35);
      objc_msgSend(v252, "setObject:forKeyedSubscript:", v36, CFSTR("usecase"));

      if (v264[8])
      {
        sub_100038468(v264);
        v37 = __p[23] >= 0 ? __p : *(_BYTE **)__p;
        v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v37));
        objc_msgSend(v252, "setObject:forKeyedSubscript:", v38, CFSTR("usecaseParams"));

        if ((__p[23] & 0x80000000) != 0)
          operator delete(*(void **)__p);
      }
      sub_1000340DC(v7[4], (uint64_t)__p);
      if (__p[23] >= 0)
        v39 = __p;
      else
        v39 = *(_BYTE **)__p;
      v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v39));
      objc_msgSend(v246, "setObject:forKeyedSubscript:", v252, v40);

      if ((__p[23] & 0x80000000) != 0)
        operator delete(*(void **)__p);
      if (!sub_100038A28(v7[5]))
        goto LABEL_150;
      ++v245;
      v41 = v7[5];
      if (!*(_BYTE *)(*(_QWORD *)(v41 + 8) + 3) && *(_DWORD *)(a1 + 1964) == 2)
        goto LABEL_150;
      v42 = sub_1000340C8(v41);
      v43 = qword_100999828;
      if (v42)
      {
        if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
          sub_1007185A0(&v258, v259);
        v44 = 0;
        v45 = 0;
        v247 = 0;
        v46 = &AMFDRSealingMapCopyLocalDictForClass_ptr;
        goto LABEL_144;
      }
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
      {
        v47 = *(unsigned __int8 *)(v7[5] + 81);
        *(_DWORD *)__p = 67109120;
        *(_DWORD *)&__p[4] = v47;
        _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "state %d", __p, 8u);
      }
      if (sub_1000589B8(v7[5]) || sub_1000589A4(v7[5]))
      {
        v247 = 0;
      }
      else
      {
        v48 = qword_100999828;
        if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
        {
          v49 = v7[5];
          if (*(char *)(v49 + 255) < 0)
          {
            sub_10003430C(buf, *(void **)(v49 + 232), *(_QWORD *)(v49 + 240));
            v49 = v7[5];
          }
          else
          {
            *(_OWORD *)buf = *(_OWORD *)(v49 + 232);
            *(_QWORD *)&buf[16] = *(_QWORD *)(v49 + 248);
          }
          v50 = buf[23] >= 0 ? buf : *(_BYTE **)buf;
          v51 = sub_1000589B8(v49);
          v52 = sub_1000589A4(v7[5]);
          *(_DWORD *)__p = 136315650;
          *(_QWORD *)&__p[4] = v50;
          *(_WORD *)&__p[12] = 1024;
          *(_DWORD *)&__p[14] = v51;
          *(_WORD *)&__p[18] = 1024;
          *(_DWORD *)&__p[20] = v52;
          _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "Upgrading %s to active scan hasZoneScan:%d hasMatchingRulesScan:%d", __p, 0x18u);
          if ((buf[23] & 0x80000000) != 0)
            operator delete(*(void **)buf);
        }
        v9 |= sub_100038A04(v7[5]);
        v247 = 1;
      }
      if (sub_100687154(v7[5]))
      {
        v53 = sub_100046A04(v7[5], 0, (_DWORD *)(a1 + 4376));
        v54 = (void *)objc_claimAutoreleasedReturnValue(v53);
        v262 = 0u;
        v263 = 0u;
        v260 = 0u;
        v261 = 0u;
        obj = v54;
        v55 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v260, v286, 16);
        if (v55)
        {
          v56 = *(_QWORD *)v261;
          v57 = v14 & 0xFFFF0000;
          do
          {
            for (i = 0; i != v55; i = (char *)i + 1)
            {
              if (*(_QWORD *)v261 != v56)
                objc_enumerationMutation(obj);
              v59 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*((_QWORD *)&v260 + 1) + 8 * (_QWORD)i), "objectForKeyedSubscript:", CFSTR("puckType")));
              if (v59)
              {
                v60 = objc_opt_class(NSNumber);
                if ((objc_opt_isKindOfClass(v59, v60) & 1) != 0 && objc_msgSend(v59, "integerValue") == (id)8)
                {
                  v61 = qword_100999828;
                  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
                  {
                    v62 = sub_100038A04(v7[5]);
                    *(_DWORD *)__p = 67109120;
                    *(_DWORD *)&__p[4] = v62;
                    _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "HS is asking for duplicates? %d", __p, 8u);
                  }
                  v9 |= sub_100038A04(v7[5]);
                }
              }
              if (v57 == 0x10000)
              {
                v63 = qword_100999828;
                if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
                {
                  v64 = v7[5];
                  v65 = *(_DWORD *)(*(_QWORD *)(v64 + 8) + 168);
                  v66 = sub_100038A04(v64);
                  v67 = sub_100036ECC(v65);
                  *(_DWORD *)__p = 136315394;
                  v68 = "No";
                  if (v66)
                    v68 = "Yes";
                  *(_QWORD *)&__p[4] = v67;
                  *(_WORD *)&__p[12] = 2080;
                  *(_QWORD *)&__p[14] = v68;
                  _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "Findmy usecase \"%s\" is asking for duplicates? %s", __p, 0x16u);
                }
                v9 |= sub_100038A04(v7[5]);
              }
              v69 = *(_QWORD *)(v7[5] + 8);
              v70 = *(_QWORD *)(v69 + 64);
              v71 = *(_QWORD *)(v69 + 72);
              while (v70 != v71)
              {
                if (*(_BYTE *)(v70 + 8) == 16 && *(_BYTE *)(v70 + 50) == 1)
                {
                  v72 = qword_100999828;
                  v9 = 1;
                  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_QWORD *)__p = 0x104000100;
                    _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "NearbyInfo asking for duplicates? %d", __p, 8u);
                  }
                }
                v70 += 96;
              }

            }
            v55 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v260, v286, 16);
          }
          while (v55);
        }

      }
      v73 = qword_100999828;
      v46 = &AMFDRSealingMapCopyLocalDictForClass_ptr;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
      {
        v74 = v7[5];
        if (*(char *)(v74 + 255) < 0)
        {
          sub_10003430C(buf, *(void **)(v74 + 232), *(_QWORD *)(v74 + 240));
          v74 = v7[5];
        }
        else
        {
          *(_OWORD *)buf = *(_OWORD *)(v74 + 232);
          *(_QWORD *)&buf[16] = *(_QWORD *)(v74 + 248);
        }
        v75 = buf[23];
        v76 = *(_BYTE **)buf;
        v77 = sub_100038A04(v74);
        *(_DWORD *)__p = 136315906;
        v78 = buf;
        if (v75 < 0)
          v78 = v76;
        *(_QWORD *)&__p[4] = v78;
        *(_WORD *)&__p[12] = 1024;
        *(_DWORD *)&__p[14] = v9 & 1;
        *(_WORD *)&__p[18] = 1024;
        *(_DWORD *)&__p[20] = v77;
        v284 = 1024;
        v285 = v247;
        _os_log_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_DEFAULT, "%s allowDupes:%d, agentAllowDupes:%d, active:%d", __p, 0x1Eu);
        if ((buf[23] & 0x80000000) != 0)
          operator delete(*(void **)buf);
      }
      v79 = v7[5];
      v80 = *(_QWORD *)(v79 + 8);
      v81 = *(unsigned __int8 *)(v80 + 120);
      if (*(_BYTE *)(v80 + 120))
      {
        v44 = *(unsigned int *)(v80 + 128);
        v45 = *(unsigned int *)(v80 + 132);
        v247 = *(unsigned __int8 *)(v80 + 136);
      }
      else
      {
        v44 = 0;
        v45 = 0;
      }
      v82 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
      {
        if (*(char *)(v79 + 255) < 0)
        {
          sub_10003430C(__p, *(void **)(v79 + 232), *(_QWORD *)(v79 + 240));
        }
        else
        {
          *(_OWORD *)__p = *(_OWORD *)(v79 + 232);
          *(_QWORD *)&__p[16] = *(_QWORD *)(v79 + 248);
        }
        v83 = __p;
        if (__p[23] < 0)
          v83 = *(_BYTE **)__p;
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = v83;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v247;
        _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "%s active %d", buf, 0x12u);
        if ((__p[23] & 0x80000000) != 0)
          operator delete(*(void **)__p);
      }
      v242 = (v247 | v242) != 0;
      if (v81)
      {
        if ((_DWORD)v247)
        {
          v84 = qword_100999828;
          if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__p = 67109634;
            *(_DWORD *)&__p[4] = v45;
            *(_WORD *)&__p[8] = 1024;
            *(_DWORD *)&__p[10] = v44;
            *(_WORD *)&__p[14] = 2082;
            *(_QWORD *)&__p[16] = "active";
            _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEFAULT, "Daemon is requesting scan parameters %d/%d (%{public}s)", __p, 0x18u);
          }
        }
        if (sub_10003C804(v7[5]))
        {
          v85 = v45 >= v250 || (_DWORD)v45 == 0;
          if (v85)
            v86 = v250;
          else
            v86 = v45;
          v250 = v86;
          if (v44 >= v239 || (_DWORD)v44 == 0)
            v88 = v239;
          else
            v88 = v44;
          v239 = v88;
        }
        if (*(_BYTE *)(*(_QWORD *)(v7[5] + 8) + 273))
        {
          if (qword_100977B40 != -1)
            dispatch_once(&qword_100977B40, &stru_10093F498);
          if (sub_1004BAAAC((uint64_t)off_100977B38))
          {
            v89 = v231;
            if (v231)
            {
              v90 = v230;
              if ((int)(v231 / v230) < (int)(v239 / v250))
              {
                v90 = v250;
                v89 = v239;
              }
              v231 = v89;
              LODWORD(v230) = v90;
              BYTE4(v230) = 1;
            }
            else
            {
              LODWORD(v230) = v250;
              BYTE4(v230) = 1;
              v231 = v239;
            }
          }
        }
      }
      else
      {
        v91 = *(_DWORD *)(v7[5] + 96);
        v92 = (int)v238 >= v91 ? v91 : v238;
        v238 = v92;
      }
      v93 = v7[5];
      if (*(_BYTE *)(*(_QWORD *)(v93 + 8) + 3))
        BYTE4(v237) |= *(_DWORD *)(a1 + 1964) == 2;
      v94 = sub_1000389F8(v93);
      v95 = v236;
      if (byte_1009940AD)
        v95 = 0;
      if (v95 == 1)
        break;
LABEL_141:
      v241 |= v94;
      if ((v240 & 1) != 0)
        v240 = sub_100038A10(v7[5]);
      else
        v240 = 0;
LABEL_144:
      v102 = v46[497];
      sub_1000340DC(v7[4], (uint64_t)__p);
      v103 = __p[23];
      v104 = *(_BYTE **)__p;
      v105 = objc_msgSend(v46[497], "defaultCStringEncoding");
      if (v103 >= 0)
        v106 = __p;
      else
        v106 = v104;
      v107 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v102, "stringWithCString:encoding:", v106, v105));
      if ((__p[23] & 0x80000000) != 0)
        operator delete(*(void **)__p);
      v108 = v46[497];
      v109 = v7[5];
      v110 = *(unsigned __int8 *)(*(_QWORD *)(v109 + 8) + 3);
      v111 = sub_100038A04(v109);
      v112 = sub_100038A1C(v7[5]);
      v113 = objc_msgSend(v108, "stringWithFormat:", CFSTR("[%@] AP:%d AD:%d(%d/%d) AS:%d RAS:%d DMN:%d FG:%d ADVBF:%d pBT:%d"), v107, v110, v111, v45, v44, v247, v112, *(unsigned __int8 *)(v7[5] + 81) == 32, *(unsigned __int8 *)(v7[5] + 81) == 16, sub_1000340C8(v7[5]), v243 & 1);
      v114 = (void *)objc_claimAutoreleasedReturnValue(v113);
      objc_msgSend(v248, "addObject:", v114);

LABEL_150:
      if (*(_QWORD *)&v264[72])
      {
        *(_QWORD *)&v264[80] = *(_QWORD *)&v264[72];
        operator delete(*(void **)&v264[72]);
      }
      *(_QWORD *)__p = &v264[48];
      sub_1000B5524((void ***)__p);
      v115 = (_QWORD *)v7[1];
      v10 = v250;
      v8 = &AMFDRSealingMapCopyLocalDictForClass_ptr;
      if (v115)
      {
        do
        {
          v116 = v115;
          v115 = (_QWORD *)*v115;
        }
        while (v115);
      }
      else
      {
        do
        {
          v116 = (_QWORD *)v7[2];
          v85 = *v116 == (_QWORD)v7;
          v7 = v116;
        }
        while (!v85);
      }
      v7 = v116;
      if (v116 == (_QWORD *)(a1 + 2048))
        goto LABEL_161;
    }
    if ((sub_100038F18(a1, v7[5]) & 1) == 0)
    {
      if (!*(_BYTE *)(*(_QWORD *)(v7[5] + 8) + 200))
      {
LABEL_123:
        if (byte_1009940AE || sub_1006787FC(a1, v7[5]))
          LODWORD(v237) = v232 | v243;
        if (qword_100977B40 != -1)
          dispatch_once(&qword_100977B40, &stru_10093F498);
        v97 = sub_1004BAB08();
        if ((v243 & 1) == 0)
        {
LABEL_136:
          v243 = 0;
          goto LABEL_139;
        }
        v98 = v97 & 0xFFFFFFFD;
        if ((_DWORD)v97 == 2)
        {
          v99 = sub_1000438A4();
          v97 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v99 + 2664))(v99);
          if (v98 == 1)
            v100 = 0;
          else
            v100 = v97;
          if ((v100 & 1) == 0)
            goto LABEL_134;
        }
        else if (v98 == 1)
        {
LABEL_134:
          LODWORD(v237) = v232 & v237;
          v101 = qword_100999828;
          v97 = os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT);
          v243 = 0;
          if ((v97 & 1) == 0)
            goto LABEL_139;
          *(_WORD *)__p = 0;
          _os_log_impl((void *)&_mh_execute_header, v101, OS_LOG_TYPE_DEFAULT, "Scanning Prioritization is not enabled with HIDs connected.", __p, 2u);
          goto LABEL_136;
        }
        v243 = 1;
LABEL_139:
        if (*(_BYTE *)(a1 + 4384))
          v233 |= sub_10067D48C(v97, v7[5]);
        goto LABEL_141;
      }
      v96 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__p = 0;
        _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_DEFAULT, "Scanning Prioritization for double boost with allowed use cases.", __p, 2u);
      }
    }
    v243 = 1;
    goto LABEL_123;
  }
  v242 = 0;
  v243 = 0;
  LOBYTE(v233) = 0;
  v245 = 0;
  v230 = 0;
  v231 = 0;
  LOBYTE(v9) = 0;
  v239 = 300;
  v10 = 30;
  v237 = 0;
  v238 = 3;
  v240 = 1;
  v241 = 0;
LABEL_161:
  obja = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v8[497], "stringWithFormat:", CFSTR("AD:%d AS:%d MSL:%d (%d/%d) PSV:%d"), v9 & 1, v242, v238, v10, v239, *v249));
  v117 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    v118 = *(_QWORD *)(a1 + 2056);
    *(_DWORD *)v264 = 134218242;
    *(_QWORD *)&v264[4] = v118;
    *(_WORD *)&v264[12] = 2114;
    *(_QWORD *)&v264[14] = obja;
    _os_log_impl((void *)&_mh_execute_header, v117, OS_LOG_TYPE_DEFAULT, "ScanParams: numScanAgents %lu, combined params %{public}@", v264, 0x16u);
  }
  v253 = v245 != 0;
  v251 = v10;
  v119 = objc_msgSend(v248, "count");
  if (v119 >= -1)
  {
    v120 = 0;
    v121 = v119 - 1;
    v122 = ((v119 - 1) / 3 + 1);
    v123 = 2;
    v124 = 1;
    do
    {
      if (v123 >= v121)
        v125 = v121;
      else
        v125 = v123;
      v126 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v248, "subarrayWithRange:", v120, v125 + v124));
      v127 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
      {
        v128 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v126, "componentsJoinedByString:", CFSTR("|")));
        *(_DWORD *)v264 = 138543362;
        *(_QWORD *)&v264[4] = v128;
        _os_log_impl((void *)&_mh_execute_header, v127, OS_LOG_TYPE_DEFAULT, "ScanParams: %{public}@", v264, 0xCu);

      }
      v123 += 3;
      v124 -= 3;
      v120 += 3;
      --v122;
    }
    while (v122);
  }
  switch((int)v238)
  {
    case 1:
      v129 = 64;
      goto LABEL_175;
    case 2:
      v129 = 96;
      goto LABEL_175;
    case 3:
      v129 = 480;
LABEL_175:
      *((_DWORD *)v249 + 1) = v129 | 0x300000;
      break;
    case 4:
      *((_DWORD *)v249 + 1) = 3147273;
      *v249 = 1;
      break;
    default:
      break;
  }
  if (v242)
    *v249 = 0;
  v130 = *((unsigned __int16 *)v249 + 2);
  v131 = *((unsigned __int16 *)v249 + 3);
  if ((int)(v239 / v251) <= (int)(v130 / v131))
  {
    v130 = (int)((double)(int)v239 / 0.625);
    *((_WORD *)v249 + 2) = v130;
    v131 = (int)((double)(int)v251 / 0.625);
    *((_WORD *)v249 + 3) = v131;
  }
  *(_DWORD *)__p = 100;
  v132 = (v230 & 0x100000000) != 0 && v231 / v230 == v130 / v131;
  if (qword_100977B40 != -1)
    dispatch_once(&qword_100977B40, &stru_10093F498);
  if (!sub_1000468F8(off_100977B38))
  {
    v133 = 100 * v131 / v130;
    if (v133 < 0x32)
    {
      if (v133 < 0x21)
        goto LABEL_197;
      v139 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
      {
        v137 = v249;
        LOWORD(v140) = *((_WORD *)v249 + 3);
        LOWORD(v141) = *((_WORD *)v249 + 2);
        *(_DWORD *)v264 = 134219264;
        *(double *)&v264[4] = (double)v140 * 0.625;
        *(_WORD *)&v264[12] = 2048;
        *(double *)&v264[14] = (double)v141 * 0.625;
        *(_WORD *)&v264[22] = 1024;
        *(_DWORD *)&v264[24] = v133;
        *(_WORD *)&v264[28] = 2048;
        *(_QWORD *)&v264[30] = 0x403E000000000000;
        *(_WORD *)&v264[38] = 2048;
        *(_QWORD *)&v264[40] = 0x4056800000000000;
        *(_WORD *)&v264[48] = 1024;
        *(_DWORD *)&v264[50] = v238;
        _os_log_impl((void *)&_mh_execute_header, v139, OS_LOG_TYPE_INFO, "Limiting scan duty cycle based on other activities from %.2fms/%.2fms (scanPercentage %d)to %.2fms/%.2fms minScanLevel %d", v264, 0x36u);
        v138 = 144;
        goto LABEL_196;
      }
      v138 = 144;
    }
    else
    {
      v134 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
      {
        v137 = v249;
        LOWORD(v135) = *((_WORD *)v249 + 3);
        LOWORD(v136) = *((_WORD *)v249 + 2);
        *(_DWORD *)v264 = 134219264;
        *(double *)&v264[4] = (double)v135 * 0.625;
        *(_WORD *)&v264[12] = 2048;
        *(double *)&v264[14] = (double)v136 * 0.625;
        *(_WORD *)&v264[22] = 1024;
        *(_DWORD *)&v264[24] = v133;
        *(_WORD *)&v264[28] = 2048;
        *(_QWORD *)&v264[30] = 0x403E000000000000;
        *(_WORD *)&v264[38] = 2048;
        *(_QWORD *)&v264[40] = 0x404E000000000000;
        *(_WORD *)&v264[48] = 1024;
        *(_DWORD *)&v264[50] = v238;
        _os_log_impl((void *)&_mh_execute_header, v134, OS_LOG_TYPE_INFO, "Limiting scan duty cycle based on other activities from %.2fms/%.2fms (scanPercentage %d)to %.2fms/%.2fms minScanLevel %d", v264, 0x36u);
        v138 = 96;
LABEL_196:
        *((_WORD *)v137 + 2) = v138;
        *((_WORD *)v137 + 3) = 48;
        goto LABEL_197;
      }
      v138 = 96;
    }
    v137 = v249;
    goto LABEL_196;
  }
LABEL_197:
  if (v242 || (v9 & 1) == 0)
  {
    v142 = !v242;
    v143 = v249;
    *v249 = v142;
  }
  else
  {
    v142 = 0;
    v143 = v249;
  }
  v143[3] = v142;
  if ((v235 | v234) == 1 && (*((unsigned __int16 *)v143 + 3) == 0xFFFF || !*((_WORD *)v143 + 3)))
  {
    v144 = sub_10003C5EC(a1);
    v143 = v249;
    if (v144)
      *((_WORD *)v249 + 2) = 4800;
  }
  v145 = *((unsigned __int16 *)v143 + 3);
  v146 = *((unsigned __int16 *)v143 + 2);
  if (*(_BYTE *)(a1 + 4384))
  {
    v147 = (double)v145 * 100.0 / (double)v146;
    v148 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v264 = 67110144;
      *(_DWORD *)&v264[4] = v145;
      *(_WORD *)&v264[8] = 1024;
      *(_DWORD *)&v264[10] = v146;
      *(_WORD *)&v264[14] = 2048;
      *(double *)&v264[16] = (double)v145 * 100.0 / (double)v146;
      *(_WORD *)&v264[24] = 2048;
      *(_QWORD *)&v264[26] = 0x4008DAB7EC1DD343;
      *(_WORD *)&v264[34] = 1024;
      *(_DWORD *)&v264[36] = v147 > 3.10679612;
      _os_log_impl((void *)&_mh_execute_header, v148, OS_LOG_TYPE_DEFAULT, "Checking if throttling down our scan during SDP is needed window:%d interval:%d dutyCycle:%f throttledDutyCycle:%f needToThrottle:%d", v264, 0x28u);
    }
    if (v147 <= 3.10679612)
    {
      v145 = *((unsigned __int16 *)v249 + 3);
      v146 = *((unsigned __int16 *)v249 + 2);
    }
    else
    {
      v149 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v264 = 0;
        _os_log_impl((void *)&_mh_execute_header, v149, OS_LOG_TYPE_DEFAULT, "Throttling down our scan during SDP", v264, 2u);
      }
      *((_DWORD *)v249 + 1) = 3147273;
      if ((v233 & 1) != 0)
      {
        *(_DWORD *)__p = 72745216;
        v132 = 1;
      }
      v145 = 48;
      v146 = 1545;
    }
  }
  if (100 * v145 / v146 < 0x1E)
  {
    if (((v243 | v237) & 1) != 0)
    {
      v151 = qword_100999828;
      v152 = os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT);
      v150 = v249;
      if (v152)
      {
        v153 = "No";
        if ((v243 & 1) != 0)
          v154 = "Yes";
        else
          v154 = "No";
        *(_DWORD *)v264 = 136315650;
        *(_QWORD *)&v264[4] = v154;
        if ((v237 & 1) != 0)
          v153 = "Yes";
        *(_WORD *)&v264[12] = 2080;
        *(_QWORD *)&v264[14] = v153;
        *(_WORD *)&v264[22] = 1024;
        *(_DWORD *)&v264[24] = 100 * v145 / v146;
        _os_log_impl((void *)&_mh_execute_header, v151, OS_LOG_TYPE_DEFAULT, "Do not prioritize scanning over BT %s WiFi %s for scan duty cycle %u.", v264, 0x1Cu);
        v150 = v249;
        v145 = *((unsigned __int16 *)v249 + 3);
        v146 = *((unsigned __int16 *)v249 + 2);
      }
    }
    else
    {
      v150 = v249;
    }
  }
  else
  {
    v249[24] = v243 & 1;
    v249[25] = v237 & 1;
    v150 = v249;
  }
  if (v146 != 48 && v146 && v145 && v145 == v146)
  {
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEBUG))
      sub_10071850C(v146);
    *((_DWORD *)v249 + 1) = 3145776;
    v150 = v249;
  }
  if (*v150)
    v155 = v132;
  else
    v155 = 0;
  if (!v155)
  {
    __p[0] = 0;
    *(_WORD *)&__p[2] = 0;
  }
  sub_10067CFBC(a1, v249, v235, v234, v241 & 1, v253 & v240, (uint64_t)__p, 0);
  v156 = sub_1000438A4();
  if ((*(unsigned int (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)v156 + 2680))(v156, *((unsigned __int16 *)v249 + 2), *((unsigned __int16 *)v249 + 3)))
  {
    v249[25] = 1;
  }
  if (*(_BYTE *)(a1 + 2246))
    *v249 = *(_BYTE *)(a1 + 2247);
  v157 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    v158 = *((unsigned __int16 *)v249 + 3);
    v159 = *((unsigned __int16 *)v249 + 2);
    v160 = *((unsigned __int16 *)v249 + 4);
    v161 = *((unsigned __int16 *)v249 + 6);
    v162 = *((unsigned __int16 *)v249 + 5);
    v163 = v249[14];
    if (qword_100977B40 != -1)
      dispatch_once(&qword_100977B40, &stru_10093F498);
    v164 = *((unsigned __int8 *)off_100977B38 + 204);
    v165 = sub_1000468F8(off_100977B38);
    v166 = "unspported";
    v167 = "supported";
    if (v234)
      v166 = "supported";
    v168 = *(unsigned __int8 *)(a1 + 144);
    v169 = "concurrent";
    v170 = *v249;
    *(_DWORD *)v264 = 134223106;
    if (!v163)
      v169 = "non-concurrent";
    v171 = v249[3];
    v172 = *(_QWORD *)(a1 + 2344);
    v173 = v249[24];
    if (!v235)
      v167 = "unsupported";
    v174 = v249[25];
    *(double *)&v264[4] = (double)v158 * 0.625;
    *(_WORD *)&v264[12] = 2048;
    v85 = v170 == 0;
    *(double *)&v264[14] = (double)v159 * 0.625;
    v175 = "passive";
    *(_WORD *)&v264[22] = 2048;
    if (v85)
      v175 = "active";
    *(double *)&v264[24] = (double)v160 * 0.625;
    v85 = v171 == 0;
    *(_WORD *)&v264[32] = 2048;
    v176 = "Disabled";
    *(double *)&v264[34] = (double)v159 * 0.625;
    if (!v85)
      v176 = "Enabled";
    *(_QWORD *)&v264[44] = v167;
    v177 = "Y";
    *(_WORD *)&v264[42] = 2080;
    *(_WORD *)&v264[52] = 2048;
    if (!v172)
      v177 = "N";
    *(double *)&v264[54] = (double)v161 * 0.625;
    *(_WORD *)&v264[62] = 2048;
    *(double *)&v264[64] = (double)v162 * 0.625;
    *(_WORD *)&v264[72] = 2080;
    *(_QWORD *)&v264[74] = v169;
    *(_WORD *)&v264[82] = 2080;
    *(_QWORD *)&v264[84] = v166;
    *(_WORD *)&v264[92] = 1024;
    *(_DWORD *)&v264[94] = v251;
    *(_WORD *)&v264[98] = 1024;
    *(_DWORD *)&v264[100] = v239;
    *(_WORD *)v265 = 1024;
    *(_DWORD *)&v265[2] = v164;
    *(_WORD *)v266 = 1024;
    *(_DWORD *)&v266[2] = v165;
    v267 = 1024;
    v268 = BYTE4(v237) & 1;
    v269 = 1024;
    v270 = v168;
    v271 = 2082;
    v272 = v175;
    v273 = 2080;
    v274 = v176;
    v275 = 1024;
    v276 = v238;
    v277 = 2080;
    v278 = v177;
    v279 = 1024;
    v280 = v173;
    v281 = 1024;
    v282 = v174;
    _os_log_impl((void *)&_mh_execute_header, v157, OS_LOG_TYPE_DEFAULT, "Returning scan parameters: Main:%.2fms/%.2fms LP:%.2fms/%.2fms(%s) SC:%.2fms/%.2fms/%s(%s) Dm:(m:%d/%d) Cond:%d:%d:%d Sc:%d (%{public}s) Dupfilter:%s minScanLevel:%d ENAssertion:%s Pri:%d/%d", v264, 0xB0u);
  }
  if (*(_BYTE *)(a1 + 2222))
  {
    v178 = *(unsigned __int16 *)(a1 + 2224);
    *((_WORD *)v249 + 2) = v178;
    v179 = *(unsigned __int16 *)(a1 + 2226);
    *((_WORD *)v249 + 3) = v179;
    v180 = *(unsigned __int16 *)(a1 + 2228);
    *((_WORD *)v249 + 4) = v180;
    v181 = *(_BYTE *)(a1 + 2230) ? *(_WORD *)(a1 + 2232) : 0;
    v182 = *(_BYTE *)(a1 + 2230) ? 0 : *(_WORD *)(a1 + 2232);
    *((_WORD *)v249 + 6) = v181;
    *((_WORD *)v249 + 5) = v182;
    v183 = *(unsigned __int8 *)(a1 + 2234);
    v249[14] = v183;
    v184 = *(_BYTE *)(a1 + 2235) && *(_BYTE *)(a1 + 2238) != 0;
    v249[18] = v184;
    v185 = *(_BYTE *)(a1 + 2236) ? *(unsigned __int16 *)(a1 + 2240) : 0;
    *((_WORD *)v249 + 10) = v185;
    v186 = *(_BYTE *)(a1 + 2237) ? *(unsigned __int16 *)(a1 + 2242) : 0;
    *((_WORD *)v249 + 11) = v186;
    v187 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v264 = 67112450;
      v188 = "Yes";
      *(_DWORD *)&v264[4] = v178;
      *(_WORD *)&v264[8] = 2048;
      if (v183)
        v189 = "Yes";
      else
        v189 = "No";
      *(double *)&v264[10] = (double)v178 * 0.625;
      *(_WORD *)&v264[18] = 1024;
      *(_DWORD *)&v264[20] = v179;
      if (!v184)
        v188 = "No";
      *(_WORD *)&v264[24] = 1024;
      *(_DWORD *)&v264[26] = v180;
      *(_WORD *)&v264[30] = 1024;
      *(_DWORD *)&v264[32] = v181;
      *(_WORD *)&v264[36] = 1024;
      *(_DWORD *)&v264[38] = v182;
      *(_WORD *)&v264[42] = 2048;
      *(double *)&v264[44] = (double)v179 * 0.625;
      *(_WORD *)&v264[52] = 2048;
      *(double *)&v264[54] = (double)v180 * 0.625;
      *(_WORD *)&v264[62] = 2048;
      *(double *)&v264[64] = (double)v181 * 0.625;
      *(_WORD *)&v264[72] = 2048;
      *(double *)&v264[74] = (double)v182 * 0.625;
      *(_WORD *)&v264[82] = 2080;
      *(_QWORD *)&v264[84] = v189;
      *(_WORD *)&v264[92] = 2080;
      *(_QWORD *)&v264[94] = v188;
      *(_WORD *)&v264[102] = 1024;
      *(_DWORD *)v265 = v185;
      *(_WORD *)&v265[4] = 1024;
      *(_DWORD *)v266 = v186;
      _os_log_impl((void *)&_mh_execute_header, v187, OS_LOG_TYPE_DEFAULT, "Returning scan parameters (overridden with ScanCore) Interval %d(%.2fms) Window %d/%d/%d/%d(%.2fms/%.2fms/%.2fms/%.2fms) Concurrent %s Compensation %s percent %d query %d", v264, 0x72u);
    }
  }
  v190 = *((unsigned __int16 *)v249 + 3);
  v191 = *((unsigned __int16 *)v249 + 2);
  v192 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary"));
  v193 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *v249));
  objc_msgSend(v192, "setObject:forKeyedSubscript:", v193, CFSTR("scanParams.passive"));

  v194 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v249[1]));
  objc_msgSend(v192, "setObject:forKeyedSubscript:", v194, CFSTR("scanParams.limited"));

  v195 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v249[3]));
  objc_msgSend(v192, "setObject:forKeyedSubscript:", v195, CFSTR("scanParams.filterDups"));

  LOWORD(v196) = *((_WORD *)v249 + 2);
  v197 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", (double)v196 * 0.625));
  objc_msgSend(v192, "setObject:forKeyedSubscript:", v197, CFSTR("scanParams.interval"));

  LOWORD(v198) = *((_WORD *)v249 + 3);
  v199 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", (double)v198 * 0.625));
  objc_msgSend(v192, "setObject:forKeyedSubscript:", v199, CFSTR("scanParams.window"));

  LOWORD(v200) = *((_WORD *)v249 + 4);
  v201 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", (double)v200 * 0.625));
  objc_msgSend(v192, "setObject:forKeyedSubscript:", v201, CFSTR("scanParams.windowLPCore"));

  LOWORD(v202) = *((_WORD *)v249 + 5);
  v203 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", (double)v202 * 0.625));
  objc_msgSend(v192, "setObject:forKeyedSubscript:", v203, CFSTR("scanParams.windowScanCoreELNABypass"));

  LOWORD(v204) = *((_WORD *)v249 + 6);
  v205 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", (double)v204 * 0.625));
  objc_msgSend(v192, "setObject:forKeyedSubscript:", v205, CFSTR("scanParams.windowScanCoreELNAOn"));

  v206 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v249[14]));
  objc_msgSend(v192, "setObject:forKeyedSubscript:", v206, CFSTR("scanParams.concurrencyMode"));

  v207 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", v249[15]));
  objc_msgSend(v192, "setObject:forKeyedSubscript:", v207, CFSTR("scanParams.scanningPhys"));

  v208 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v249[16]));
  objc_msgSend(v192, "setObject:forKeyedSubscript:", v208, CFSTR("scanParams.retainDuplicates"));

  v209 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", v249[17]));
  objc_msgSend(v192, "setObject:forKeyedSubscript:", v209, CFSTR("scanParams.priorityConfig"));

  v210 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v249[18]));
  objc_msgSend(v192, "setObject:forKeyedSubscript:", v210, CFSTR("scanParams.isScanCoreCompensated"));

  v211 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", *((unsigned __int16 *)v249 + 10)));
  objc_msgSend(v192, "setObject:forKeyedSubscript:", v211, CFSTR("scanParams.scanCoreCompensationPercent"));

  v212 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", *((unsigned __int16 *)v249 + 11)));
  objc_msgSend(v192, "setObject:forKeyedSubscript:", v212, CFSTR("scanParams.scanCoreCoexQueryPeriod"));

  v213 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v249[24]));
  objc_msgSend(v192, "setObject:forKeyedSubscript:", v213, CFSTR("scanParams.isPrioritizedOverBT"));

  v214 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v249[25]));
  objc_msgSend(v192, "setObject:forKeyedSubscript:", v214, CFSTR("scanParams.isPrioritizedOverWiFi"));

  v215 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *(unsigned __int8 *)(a1 + 144)));
  objc_msgSend(v192, "setObject:forKeyedSubscript:", v215, CFSTR("fScreenState"));

  v216 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v239));
  objc_msgSend(v192, "setObject:forKeyedSubscript:", v216, CFSTR("daemonInterval"));

  v217 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v251));
  objc_msgSend(v192, "setObject:forKeyedSubscript:", v217, CFSTR("daemonWindow"));

  v218 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", v238));
  objc_msgSend(v192, "setObject:forKeyedSubscript:", v218, CFSTR("minScanLevel"));

  v219 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", 100 * v190 / v191));
  objc_msgSend(v192, "setObject:forKeyedSubscript:", v219, CFSTR("scanPercentage"));

  v220 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", BYTE4(v237) & 1));
  objc_msgSend(v192, "setObject:forKeyedSubscript:", v220, CFSTR("allowInPause"));

  v221 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v235));
  objc_msgSend(v192, "setObject:forKeyedSubscript:", v221, CFSTR("scanLPCoreEnable"));

  v222 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v234));
  objc_msgSend(v192, "setObject:forKeyedSubscript:", v222, CFSTR("isScanCoreEnabled"));

  v223 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v253 & v240));
  objc_msgSend(v192, "setObject:forKeyedSubscript:", v223, CFSTR("isRangeScan"));

  v224 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v241 & 1));
  objc_msgSend(v192, "setObject:forKeyedSubscript:", v224, CFSTR("isPriorityCritical"));

  v225 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v243 & 1));
  objc_msgSend(v192, "setObject:forKeyedSubscript:", v225, CFSTR("isPrioritizedOverBT"));

  v226 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v237 & 1));
  objc_msgSend(v192, "setObject:forKeyedSubscript:", v226, CFSTR("isPrioritizedOverWiFi"));

  v227 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 1964)));
  objc_msgSend(v192, "setObject:forKeyedSubscript:", v227, CFSTR("fObserverState"));

  objc_msgSend(v246, "setObject:forKeyedSubscript:", v192, CFSTR("Controller"));
  v256[0] = _NSConcreteStackBlock;
  v256[1] = 3221225472;
  v256[2] = sub_10068051C;
  v256[3] = &unk_10093F1D8;
  v228 = v246;
  v257 = v228;
  sub_10003F2E8((os_unfair_lock_s *)(a1 + 1872), v256);

  return 1;
}

void sub_10068016C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,void *a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,void *a53)
{

  sub_1000B54DC((uint64_t)&STACK[0x200]);
  _Unwind_Resume(a1);
}

uint64_t sub_10068051C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 64))(a2, *(_QWORD *)(a1 + 32));
}

void sub_100680534(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  void *v10;
  int v11;
  NSString *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  uint64_t v18;
  NSNumber *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  uint64_t v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  _BOOL8 v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  void *v41;
  void *v42;
  void *v43;
  void *v44;
  void *v45;
  void *v46;
  NSObject *v47;
  uint64_t v48;
  id v49;
  uint8_t buf[4];
  void *v51;

  if (a2)
  {
    v6 = *(_QWORD *)(a2 + 8);
    if (*(_BYTE *)(v6 + 288))
    {
      v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary"));
      objc_msgSend(v10, "setObject:forKeyedSubscript:", CFSTR("Discovery"), CFSTR("ScanType"));
      v11 = *(_DWORD *)(*(_QWORD *)(a2 + 8) + 168);
      v12 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", sub_100036ECC(v11));
      v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
      objc_msgSend(v10, "setObject:forKeyedSubscript:", v13, CFSTR("CBUseCase"));

      v49 = *(id *)(*(_QWORD *)(a2 + 8) + 152);
      v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v49, "allObjects"));
      v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithArray:](NSArray, "arrayWithArray:", v14));

      v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "sortedArrayUsingSelector:", "compare:"));
      v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "componentsJoinedByString:", CFSTR(",")));
      objc_msgSend(v10, "setObject:forKeyedSubscript:", v17, CFSTR("BundleID"));

      v18 = sub_10003BE44();
      v19 = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", (*(uint64_t (**)(uint64_t))(*(_QWORD *)v18 + 840))(v18));
      v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
      objc_msgSend(v10, "setObject:forKeyedSubscript:", v20, CFSTR("IsFWBased"));

      objc_msgSend(v10, "setObject:forKeyedSubscript:", CFSTR("NotApplicable"), CFSTR("InitialConnScanParamsType"));
      v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *(unsigned __int8 *)(v6 + 290)));
      objc_msgSend(v10, "setObject:forKeyedSubscript:", v21, CFSTR("IsWiFiCoexCriticalProtected"));

      v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *(unsigned __int8 *)(v6 + 291)));
      objc_msgSend(v10, "setObject:forKeyedSubscript:", v22, CFSTR("IsBTAudioProtected"));

      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", *(unsigned __int8 *)(v6 + 292)));
      objc_msgSend(v10, "setObject:forKeyedSubscript:", v23, CFSTR("IsWiFi2_4GHzProtected"));

      if ((v11 - 65548) < 2)
      {
        v24 = 63;
      }
      else if (v11 == 268)
      {
        v24 = -1;
      }
      else if (v11 == 265)
      {
        v24 = 111;
      }
      else
      {
        v24 = 0;
      }
      v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v24));
      objc_msgSend(v10, "setObject:forKeyedSubscript:", v25, CFSTR("WiFiCriticalDefinition"));

      v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(v6 + 304)));
      objc_msgSend(v10, "setObject:forKeyedSubscript:", v26, CFSTR("ScanDurationReqMsec"));

      v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(v6 + 296)));
      objc_msgSend(v10, "setObject:forKeyedSubscript:", v27, CFSTR("ActualScanTimeReqMsec"));

      v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(v6 + 296)));
      objc_msgSend(v10, "setObject:forKeyedSubscript:", v28, CFSTR("ActualScanTimeMCReqMsec"));

      v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a5));
      objc_msgSend(v10, "setObject:forKeyedSubscript:", v29, CFSTR("ScanDurationMsec"));

      v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a3));
      objc_msgSend(v10, "setObject:forKeyedSubscript:", v30, CFSTR("ActualScanTimeMsec"));

      v31 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a4));
      objc_msgSend(v10, "setObject:forKeyedSubscript:", v31, CFSTR("ActualScanTimeMCMsec"));

      v32 = *(_QWORD *)(v6 + 304);
      if (v32)
        v33 = (100 * a5) / v32;
      else
        LODWORD(v33) = 0;
      if (v33 <= 0x63)
        v34 = v33;
      else
        v34 = 100;
      v35 = *(_QWORD *)(v6 + 296);
      if (v35)
      {
        v36 = (100 * a3) / v35;
        v37 = v36 > 0x63;
        if (v36 <= 0x63)
          v38 = v36;
        else
          v38 = 100;
        v39 = (100 * a4) / v35;
      }
      else
      {
        v38 = 0;
        v37 = 0;
        LODWORD(v39) = 0;
      }
      if (v39 <= 0x63)
        v40 = v39;
      else
        v40 = 100;
      v41 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v34));
      objc_msgSend(v10, "setObject:forKeyedSubscript:", v41, CFSTR("ScanDurationMsecPercentage"));

      v42 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v38));
      objc_msgSend(v10, "setObject:forKeyedSubscript:", v42, CFSTR("ActualScanTimeMsecPercentage"));

      v43 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v40));
      objc_msgSend(v10, "setObject:forKeyedSubscript:", v43, CFSTR("ActualScanTimeMCMsecPercentage"));

      v44 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v33 > 0x63));
      objc_msgSend(v10, "setObject:forKeyedSubscript:", v44, CFSTR("HasScanDurationReqMet"));

      v45 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v37));
      objc_msgSend(v10, "setObject:forKeyedSubscript:", v45, CFSTR("HasActualScanTimeReqMet"));

      v46 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v39 > 0x63));
      objc_msgSend(v10, "setObject:forKeyedSubscript:", v46, CFSTR("HasActualScanTimeMCReqMet"));

      v47 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138543362;
        v51 = v10;
        _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "Sending CloseLoopScanningStats :%{public}@", buf, 0xCu);
      }
      v48 = sub_100065478();
      (*(void (**)(uint64_t, void *))(*(_QWORD *)v48 + 384))(v48, v10);

    }
  }
}

void sub_100680AF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;
  void *v11;
  void *v12;

  _Unwind_Resume(a1);
}

void sub_100680BAC(uint64_t a1)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  BOOL v12;
  _QWORD *v13;
  uint64_t v14;
  NSObject *v15;
  void **v16;
  uint64_t v17;
  void *__p[2];
  char v19;
  _QWORD v20[5];
  __int128 v21;
  int v22;
  uint8_t buf[4];
  void **v24;

  v2 = *(_DWORD *)(a1 + 72);
  if (v2 == 2)
    v3 = 20;
  else
    v3 = 1;
  if (v2 == 1)
    v4 = 342;
  else
    v4 = v3;
  v20[0] = _NSConcreteStackBlock;
  v20[2] = sub_100680D80;
  v20[3] = &unk_10093F1F8;
  v6 = *(_QWORD *)(a1 + 32);
  v5 = *(_QWORD *)(a1 + 40);
  v20[1] = 3221225472;
  v20[4] = v5;
  v22 = v4;
  v21 = *(_OWORD *)(a1 + 48);
  sub_10003F2E8((os_unfair_lock_s *)(v6 + 1872), v20);
  v8 = *(_QWORD **)(v6 + 2048);
  if (v8)
  {
    v9 = *(_QWORD *)(a1 + 40);
    v10 = (_QWORD *)(v6 + 2048);
    do
    {
      v11 = v8[4];
      v12 = v11 >= v9;
      if (v11 >= v9)
        v13 = v8;
      else
        v13 = v8 + 1;
      if (v12)
        v10 = v8;
      v8 = (_QWORD *)*v13;
    }
    while (*v13);
    if (v10 != (_QWORD *)(v6 + 2048) && v9 >= v10[4])
    {
      v14 = v10[5];
      if (*(_DWORD *)(a1 + 72) == 1)
      {
        sub_100680534(v7, v14, *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64));
        v9 = *(_QWORD *)(a1 + 40);
      }
      v15 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
      {
        sub_1000340DC(v9, (uint64_t)__p);
        if (v19 >= 0)
          v16 = __p;
        else
          v16 = (void **)__p[0];
        *(_DWORD *)buf = 136446210;
        v24 = v16;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "stopping scan for %{public}s", buf, 0xCu);
        if (v19 < 0)
          operator delete(__p[0]);
        v9 = *(_QWORD *)(a1 + 40);
      }
      v17 = *(_QWORD *)(v14 + 8);
      *(_DWORD *)(v17 + 188) = 0;
      *(_DWORD *)(v17 + 192) = 0;
      sub_100012EF4(v6, v9, 1, 1, 0);
    }
  }
}

uint64_t sub_100680D80(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a2 + 56))(a2, *(_QWORD *)(a1 + 32), *(unsigned int *)(a1 + 56), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48));
}

void sub_100680DA0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v11;
  uint64_t v12;
  _QWORD v13[9];
  int v14;

  v11 = *(_QWORD *)(a1 + 32);
  v12 = sub_1000419F4();
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_100680BAC;
  v13[3] = &unk_10093DC00;
  v14 = a6;
  v13[4] = v11;
  v13[5] = a2;
  v13[6] = a3;
  v13[7] = a4;
  v13[8] = a5;
  sub_100041A34(v12, v13);
}

uint64_t sub_100680E30(uint64_t result, unint64_t a2, uint64_t a3)
{
  _QWORD *v3;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  BOOL v8;
  _QWORD *v9;
  uint64_t v10;
  int v11;
  NSObject *v12;
  _BOOL8 v13;
  _BYTE *v14;
  _BYTE __p[12];
  char v16;
  uint8_t buf[4];
  _BYTE *v18;
  __int16 v19;
  int v20;

  v3 = *(_QWORD **)(result + 2048);
  if (v3)
  {
    v5 = result;
    v6 = result + 2048;
    do
    {
      v7 = v3[4];
      v8 = v7 >= a2;
      if (v7 >= a2)
        v9 = v3;
      else
        v9 = v3 + 1;
      if (v8)
        v6 = (uint64_t)v3;
      v3 = (_QWORD *)*v9;
    }
    while (*v9);
    if (v6 != result + 2048 && *(_QWORD *)(v6 + 32) <= a2)
    {
      v10 = *(_QWORD *)(v6 + 40);
      if (*(_QWORD *)(v10 + 88) == a3 && !*(_BYTE *)(*(_QWORD *)(v10 + 8) + 143))
      {
        v11 = *(_DWORD *)(v10 + 96);
        v12 = qword_100999828;
        if (v11 >= 3 && os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)__p = 136446210;
          *(_QWORD *)&__p[4] = "level < kNumScanLevels";
          _os_log_fault_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", __p, 0xCu);
          v12 = qword_100999828;
        }
        v13 = os_log_type_enabled(v12, OS_LOG_TYPE_INFO);
        if (v13)
        {
          sub_1000340DC(a2, (uint64_t)__p);
          v14 = v16 >= 0 ? __p : *(_BYTE **)__p;
          *(_DWORD *)buf = 136446466;
          v18 = v14;
          v19 = 1024;
          v20 = v11 + 1;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "Session \"%{public}s\" is now at scan level %d", buf, 0x12u);
          if (v16 < 0)
            operator delete(*(void **)__p);
        }
        *(_DWORD *)(v10 + 96) = v11 + 1;
        if (v11 > 1)
          *(_QWORD *)(v10 + 88) = 0;
        else
          sub_10006E160(v13, a2, v10);
        return sub_100004AE4(v5, 0);
      }
    }
  }
  return result;
}

void sub_100681014(uint64_t a1)
{
  int v2;
  NSObject *v3;
  _DWORD v4[2];

  if (!*(_BYTE *)(a1 + 3256))
  {
    v2 = *(_DWORD *)(a1 + 3248) + 1;
    *(_DWORD *)(a1 + 3248) = v2;
    v3 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67109120;
      v4[1] = v2;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "ScanCoreBLEConnectionScanStat: ScanCore is enabled for Connection Scan %d times", (uint8_t *)v4, 8u);
    }
  }
  *(_BYTE *)(a1 + 3256) = 1;
}

void sub_1006810D8(uint64_t a1)
{
  sub_100681014(a1 - 48);
}

void sub_1006810E0(uint64_t a1)
{
  NSObject *v2;
  uint8_t v3[16];

  if (*(_BYTE *)(a1 + 3256))
  {
    v2 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v3 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "ScanCore is disabled for Connection Scan", v3, 2u);
    }
  }
  *(_BYTE *)(a1 + 3256) = 0;
}

void sub_100681154(uint64_t a1)
{
  sub_1006810E0(a1 - 48);
}

uint64_t sub_10068115C(uint64_t a1, void *a2)
{
  id v3;
  NSObject *v4;
  uint64_t v5;
  const char *v6;
  uint64_t v7;
  const char *v8;
  int v9;
  int v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  const char *v14;
  const char *v15;
  NSObject *v16;
  const char *v17;
  const char *v18;
  uint64_t v19;
  int v21;
  const char *v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  uint64_t v26;

  v3 = a2;
  v4 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    v5 = *(int *)(a1 + 1960);
    if (v5 > 4)
      v6 = "UNKNOWN";
    else
      v6 = off_10093F650[v5];
    v7 = *(int *)(a1 + 1964);
    if (v7 > 3)
      v8 = "UNKNOWN";
    else
      v8 = off_10093F678[v7];
    v21 = 136446466;
    v22 = v6;
    v23 = 2082;
    v24 = v8;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "pauseScans State: %{public}s, ObserverState: %{public}s", (uint8_t *)&v21, 0x16u);
  }
  v9 = *(_DWORD *)(a1 + 1964);
  if ((v9 - 1) < 2)
  {
    v12 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      v13 = *(int *)(a1 + 1960);
      v14 = "UNKNOWN";
      v15 = "UNKNOWN";
      if (v13 <= 4)
        v15 = off_10093F650[v13];
      if (v9 == 1)
        v14 = "Pausing";
      if (v9 == 2)
        v14 = "Paused";
      v21 = 136446466;
      v22 = v15;
      v23 = 2082;
      v24 = v14;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Already Paused Scans State: %{public}s, ObserverState: %{public}s", (uint8_t *)&v21, 0x16u);
    }
    v11 = 401;
  }
  else
  {
    if (v9 == 3)
    {
      v11 = 1;
      goto LABEL_29;
    }
    if (!v9)
    {
      sub_1006798F0((os_unfair_lock_s *)a1, 1u);
      v10 = *(_DWORD *)(a1 + 1960);
      if (v10 == 1 || v10 == 3 && sub_10067BF6C(a1))
        sub_1006798F0((os_unfair_lock_s *)a1, 2u);
    }
    v11 = 0;
  }
  objc_msgSend(*(id *)(a1 + 3264), "addObject:", v3);
  v16 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    v17 = (const char *)objc_msgSend(objc_retainAutorelease(v3), "UTF8String");
    v18 = (const char *)objc_msgSend(*(id *)(a1 + 3264), "count");
    v19 = *(_QWORD *)(a1 + 3264);
    v21 = 136315650;
    v22 = v17;
    v23 = 2048;
    v24 = v18;
    v25 = 2112;
    v26 = v19;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Added Paused Client: %s, Clients(Count: %lu): %@", (uint8_t *)&v21, 0x20u);
  }
LABEL_29:

  return v11;
}

void sub_1006813F8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t sub_100681414(uint64_t a1, void *a2)
{
  id v3;
  NSObject *v4;
  uint64_t v5;
  const char *v6;
  uint64_t v7;
  const char *v8;
  NSObject *v9;
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  unsigned int v17;
  int v19;
  const char *v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  uint64_t v26;

  v3 = a2;
  objc_msgSend(*(id *)(a1 + 3264), "removeObject:", v3);
  if (objc_msgSend(*(id *)(a1 + 3264), "count"))
  {
    v4 = qword_100999828;
    v5 = 0;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      v6 = (const char *)objc_msgSend(*(id *)(a1 + 3264), "count");
      v7 = *(int *)(a1 + 1960);
      if (v7 > 4)
        v8 = "UNKNOWN";
      else
        v8 = off_10093F650[v7];
      v12 = *(int *)(a1 + 1964);
      if (v12 > 3)
        v13 = "UNKNOWN";
      else
        v13 = off_10093F678[v12];
      v14 = *(_QWORD *)(a1 + 3264);
      v19 = 134218754;
      v20 = v6;
      v21 = 2082;
      v22 = v8;
      v23 = 2082;
      v24 = v13;
      v25 = 2112;
      v26 = v14;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Cannot Resume Scans we have %lu clients required to be paused, State: %{public}s, ObserverState: %{public}s, clients: %@", (uint8_t *)&v19, 0x2Au);
LABEL_13:
      v5 = 0;
    }
  }
  else
  {
    objc_msgSend(*(id *)(a1 + 3264), "removeAllObjects");
    v9 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      v10 = *(int *)(a1 + 1960);
      if (v10 > 4)
        v11 = "UNKNOWN";
      else
        v11 = off_10093F650[v10];
      v15 = *(int *)(a1 + 1964);
      if (v15 > 3)
        v16 = "UNKNOWN";
      else
        v16 = off_10093F678[v15];
      v19 = 136446466;
      v20 = v11;
      v21 = 2082;
      v22 = v16;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "resumeScans State: %{public}s, ObserverState: %{public}s", (uint8_t *)&v19, 0x16u);
    }
    v17 = *(_DWORD *)(a1 + 1964);
    v5 = 1;
    if (v17 >= 2 && v17 != 3)
    {
      if (v17 == 2)
      {
        sub_1006798F0((os_unfair_lock_s *)a1, 3u);
        *(_BYTE *)(a1 + 1840) = 1;
        if ((*(_DWORD *)(a1 + 1960) | 2) == 3)
          sub_1006798F0((os_unfair_lock_s *)a1, 0);
      }
      goto LABEL_13;
    }
  }

  return v5;
}

void sub_100681664(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_100681680(id a1, LeObserverListener *a2)
{
  (*((void (**)(LeObserverListener *))a2->var0 + 2))(a2);
}

void sub_100681690(id a1, LeObserverListener *a2)
{
  (*((void (**)(LeObserverListener *))a2->var0 + 3))(a2);
}

uint64_t sub_1006816A0(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  const char *v5;
  size_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  const char *v10;
  size_t v11;
  _QWORD *v12;
  _OWORD v14[4];
  void *__p[2];
  __int128 v16;
  __int128 v17;
  _OWORD v18[9];
  uint64_t v19;

  v19 = 0;
  v17 = 0u;
  memset(v18, 0, sizeof(v18));
  *(_OWORD *)__p = 0u;
  v16 = 0u;
  memset(v14, 0, sizeof(v14));
  sub_100272ADC((uint64_t)v14);
  v2 = sub_1002614D8(v14, (uint64_t)" client: ", 9);
  sub_1002614D8(v2, (uint64_t)"LeObserver", 10);
  v3 = sub_1002614D8(v14, (uint64_t)" state: (", 9);
  v4 = *(int *)(a1 + 1960);
  if (v4 > 4)
    v5 = "UNKNOWN";
  else
    v5 = off_10093F650[v4];
  v6 = strlen(v5);
  v7 = sub_1002614D8(v3, (uint64_t)v5, v6);
  sub_1002614D8(v7, (uint64_t)")", 1);
  v8 = sub_1002614D8(v14, (uint64_t)" , ObserverState: (", 19);
  v9 = *(int *)(a1 + 1964);
  if (v9 > 3)
    v10 = "UNKNOWN";
  else
    v10 = off_10093F678[v9];
  v11 = strlen(v10);
  v12 = sub_1002614D8(v8, (uint64_t)v10, v11);
  sub_1002614D8(v12, (uint64_t)")", 1);
  std::stringbuf::str((char *)v14 + 8);
  if (SHIBYTE(v16) < 0)
    operator delete(__p[1]);
  std::streambuf::~streambuf((char *)v14 + 8);
  return std::ios::~ios(v18);
}

void sub_100681864(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100272CFC((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_100681878(uint64_t a1)
{
  return sub_1006816A0(a1 - 56);
}

void sub_100681880(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  const char *v4;
  uint64_t v5;
  const char *v6;
  int v7;
  const char *v8;
  _BOOL4 v9;
  const char *v10;
  _BOOL4 v11;
  const char *v12;
  _BOOL4 v13;
  const char *v14;
  int v15;
  const char *v16;
  _BOOL4 v17;
  const char *v18;
  _BOOL4 v19;
  const char *v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  const char *v24;
  const char *v25;
  const char *v26;
  const char *v27;
  const char *v28;
  int v29;
  const char *v30;
  uint64_t v31;
  _BYTE *v32;
  int v33;
  int v34;
  const char *v35;
  uint64_t v36;
  int v37;
  const char *v38;
  const char *v39;
  const char *v40;
  int v41;
  const char *v42;
  const char *v43;
  uint64_t v44;
  NSObject *v45;
  _QWORD *v46;
  NSObject *v47;
  uint8_t *v48;
  _QWORD *v49;
  _QWORD *v50;
  BOOL v51;
  NSObject *v52;
  _QWORD *v53;
  NSObject *v54;
  uint8_t *v55;
  _QWORD *v56;
  _QWORD *v57;
  uint64_t v58;
  NSObject *v59;
  unint64_t v60;
  NSObject *v61;
  unint64_t v62;
  const char *v63;
  const char *v64;
  const char *v65;
  const char *v66;
  _QWORD *v67;
  NSObject *v68;
  uint8_t *v69;
  const char *v70;
  char *v71;
  uint8_t *v72;
  uint64_t v73;
  _QWORD *v74;
  NSObject *v75;
  uint8_t *v76;
  char *v77;
  char *v78;
  uint8_t *v79;
  uint64_t v80;
  _QWORD *v81;
  NSObject *v82;
  uint8_t *v83;
  const char *v84;
  int v85;
  const char *v86;
  const char *v87;
  NSObject *v88;
  const char *v89;
  NSObject *v90;
  int v91;
  int v92;
  int v93;
  char v94;
  NSObject *v95;
  NSObject *v96;
  __int16 v97;
  NSObject *v98;
  NSObject *v99;
  uint64_t v100;
  uint64_t v101;
  NSObject *v102;
  int v103;
  int v104;
  int v105;
  int v106;
  int v107;
  id v108;
  void *v109;
  id v110;
  BOOL v111;
  id v112;
  id v113;
  uint64_t v114;
  void *i;
  const char *v116;
  size_t v117;
  _QWORD *v118;
  NSObject *v119;
  _BYTE *v120;
  NSObject *v121;
  const char *v122;
  _QWORD *v123;
  _QWORD *v124;
  NSObject *v125;
  _QWORD *v126;
  int v127;
  int v128;
  int v129;
  _BOOL4 v130;
  _BOOL4 v131;
  _QWORD *v132;
  _QWORD *v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  __int128 v139;
  __int128 v140;
  __int128 v141;
  __int128 v142;
  void *v143;
  char *v144;
  uint64_t v145;
  _BYTE v146[12];
  char v147;
  uint8_t v148[4];
  _BYTE *v149;
  _BYTE v150[128];
  uint8_t v151[16];
  _OWORD v152[4];
  void *__p[2];
  __int128 v154;
  __int128 v155;
  _OWORD v156[9];
  uint64_t v157;
  uint8_t buf[48];
  __int128 v159;
  __int128 v160;
  void *v161[2];
  __int128 v162;
  __int128 v163;
  _OWORD v164[9];
  uint64_t v165;

  v2 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: -------------------- LE Observer ---------------------", buf, 2u);
    v2 = qword_100999828;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v3 = *(int *)(a1 + 1960);
    if (v3 > 4)
      v4 = "UNKNOWN";
    else
      v4 = off_10093F650[v3];
    v5 = *(int *)(a1 + 1964);
    if (v5 > 3)
      v6 = "UNKNOWN";
    else
      v6 = off_10093F678[v5];
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = v4;
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v6;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: State: %{public}s, ObserverState: %{public}s", buf, 0x16u);
    v2 = qword_100999828;
  }
  v134 = a1;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v7 = sub_10005CD1C(a1);
    v8 = "NO";
    if (v7)
      v8 = "YES";
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = v8;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: haveAnyValidScanRequests:%{public}s", buf, 0xCu);
    v2 = qword_100999828;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v9 = sub_100676FAC(a1);
    v10 = "NO";
    if (v9)
      v10 = "YES";
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = v10;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: haveAnyActiveScanRequests:%{public}s", buf, 0xCu);
    v2 = qword_100999828;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v11 = sub_10067BF6C(a1);
    v12 = "NO";
    if (v11)
      v12 = "YES";
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = v12;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: haveAnyValidScanRequestsInPaused:%{public}s", buf, 0xCu);
    v2 = qword_100999828;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v13 = sub_10006E040(a1);
    v14 = "NO";
    if (v13)
      v14 = "YES";
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = v14;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: haveAnyValidHWObjectDiscovery:%{public}s", buf, 0xCu);
    v2 = qword_100999828;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v15 = sub_10003C5EC(a1);
    v16 = "NO";
    if (v15)
      v16 = "YES";
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = v16;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: objectDiscoveryHwAdvBufferOnly:%{public}s", buf, 0xCu);
    v2 = qword_100999828;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v17 = sub_10005CCAC(a1);
    v18 = "NO";
    if (v17)
      v18 = "YES";
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = v18;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: haveAnyHwAOPBTBufferRequests:%{public}s", buf, 0xCu);
    v2 = qword_100999828;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v19 = sub_10005CA60(a1);
    v20 = "NO";
    v21 = *(_QWORD *)(a1 + 2200);
    if (v19)
      v20 = "YES";
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = v20;
    *(_WORD *)&buf[12] = 2048;
    *(_QWORD *)&buf[14] = v21;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: haveClientPowerAssertion:%{public}s, fScanningPowerAssertion:%llx", buf, 0x16u);
    v2 = qword_100999828;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(_QWORD *)(a1 + 2208))
      v22 = "YES";
    else
      v22 = "NO";
    v23 = sub_1000438A4();
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v23 + 3480))(v23))
      v24 = "YES";
    else
      v24 = "NO";
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = v22;
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v24;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: configPowerAssert:%{public}s needsScanconfigPowerAssertions:%{public}s", buf, 0x16u);
    v2 = qword_100999828;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v25 = "YES";
    if (*(_BYTE *)(a1 + 1840))
      v26 = "YES";
    else
      v26 = "NO";
    if (!*(_BYTE *)(a1 + 1843))
      v25 = "NO";
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = v26;
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v25;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: fScanFiltersNeedUpdating:%{public}s fZoneScansHaveChanged:%{public}s ", buf, 0x16u);
    v2 = qword_100999828;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v27 = "YES";
    if (*(_BYTE *)(a1 + 1848))
      v28 = "YES";
    else
      v28 = "NO";
    v29 = *(unsigned __int8 *)(a1 + 1850);
    if (*(_BYTE *)(a1 + 1849))
      v30 = "YES";
    else
      v30 = "NO";
    *(_DWORD *)buf = 136446722;
    if (!v29)
      v27 = "NO";
    *(_QWORD *)&buf[4] = v28;
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v30;
    *(_WORD *)&buf[22] = 2082;
    *(_QWORD *)&buf[24] = v27;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: fHaveUUIDFilters:%{public}s fHaveZoneFilters:%{public}s fHaveRuleFilters:%{public}s", buf, 0x20u);
    v2 = qword_100999828;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v31 = *(_QWORD *)(a1 + 2128);
    *(_DWORD *)buf = 134217984;
    *(_QWORD *)&buf[4] = v31;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: fApWakeReadADVBuffersDebounceDelta:%llu", buf, 0xCu);
    v2 = qword_100999828;
  }
  v32 = (_BYTE *)(a1 + 4296);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v33 = *(_DWORD *)(a1 + 2292);
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v33;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: fRSSIOffset:%d", buf, 8u);
    v2 = qword_100999828;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v34 = *(unsigned __int8 *)(a1 + 4384);
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v34;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: fScanThrottlingRequired:%d", buf, 8u);
    v2 = qword_100999828;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(_BYTE *)(a1 + 2352))
      v35 = "YES";
    else
      v35 = "NO";
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = v35;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: fShouldRetainDupsNextUpdate:%{public}s", buf, 0xCu);
    v2 = qword_100999828;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v36 = sub_10003BE44();
    v37 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v36 + 704))(v36);
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v37;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: Num of supported ObjectDiscovery HW ADV Buffers:%d", buf, 8u);
    v2 = qword_100999828;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_1009940AC)
      v38 = "YES";
    else
      v38 = "NO";
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = v38;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: gSniffScanDebug:%{public}s", buf, 0xCu);
    v2 = qword_100999828;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v39 = "YES";
    if (*v32)
      v40 = "YES";
    else
      v40 = "NO";
    v41 = *(_DWORD *)(a1 + 4376);
    if (*(_BYTE *)(a1 + 4380))
      v42 = "YES";
    else
      v42 = "NO";
    if (*(_BYTE *)(a1 + 4382))
      v43 = "YES";
    else
      v43 = "NO";
    if (!*(_BYTE *)(a1 + 4381))
      v39 = "NO";
    *(_DWORD *)buf = 136447490;
    *(_QWORD *)&buf[4] = v40;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v41;
    *(_WORD *)&buf[18] = 2082;
    *(_QWORD *)&buf[20] = v42;
    *(_WORD *)&buf[28] = 2082;
    *(_QWORD *)&buf[30] = v43;
    *(_WORD *)&buf[38] = 2082;
    *(_QWORD *)&buf[40] = v39;
    LOWORD(v159) = 2082;
    *(_QWORD *)((char *)&v159 + 2) = v43;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: fControllerConfigInProgress:%{public}s fBypassFilterMask:%04x fGlobalDuplicateFilter:%{public}s shouldDispatchConfig():%{public}s fDebugControllerConfigDispatchSequence:%{public}s fForceDispatchInsteadOfSerialConfig:%{public}s", buf, 0x3Au);
  }
  v44 = sub_100027F68();
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v44 + 8))(v44))
  {
    v45 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "statedump: fFilterPeripherals:", buf, 2u);
    }
    v46 = *(_QWORD **)(a1 + 4304);
    if (v46 != (_QWORD *)(a1 + 4312))
    {
      do
      {
        v47 = qword_100999828;
        if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
        {
          sub_10064960C(v46[4]);
          v48 = (buf[23] & 0x80u) == 0 ? buf : *(uint8_t **)buf;
          *(_DWORD *)v151 = 136446210;
          *(_QWORD *)&v151[4] = v48;
          _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "    %{public}s", v151, 0xCu);
          if ((char)buf[23] < 0)
            operator delete(*(void **)buf);
        }
        v49 = (_QWORD *)v46[1];
        if (v49)
        {
          do
          {
            v50 = v49;
            v49 = (_QWORD *)*v49;
          }
          while (v49);
        }
        else
        {
          do
          {
            v50 = (_QWORD *)v46[2];
            v51 = *v50 == (_QWORD)v46;
            v46 = v50;
          }
          while (!v51);
        }
        v46 = v50;
      }
      while (v50 != (_QWORD *)(v134 + 4312));
    }
    v52 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "statedump: fAllUuids:", buf, 2u);
    }
    v53 = *(_QWORD **)(v134 + 4328);
    if (v53 != (_QWORD *)(v134 + 4336))
    {
      do
      {
        v54 = qword_100999828;
        if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
        {
          sub_10006887C((uint64_t)v53 + 28, buf);
          v55 = (buf[23] & 0x80u) == 0 ? buf : *(uint8_t **)buf;
          *(_DWORD *)v151 = 136446210;
          *(_QWORD *)&v151[4] = v55;
          _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "    %{public}s", v151, 0xCu);
          if ((char)buf[23] < 0)
            operator delete(*(void **)buf);
        }
        v56 = (_QWORD *)v53[1];
        if (v56)
        {
          do
          {
            v57 = v56;
            v56 = (_QWORD *)*v56;
          }
          while (v56);
        }
        else
        {
          do
          {
            v57 = (_QWORD *)v53[2];
            v51 = *v57 == (_QWORD)v53;
            v53 = v57;
          }
          while (!v51);
        }
        v53 = v57;
      }
      while (v57 != (_QWORD *)(v134 + 4336));
    }
  }
  v58 = v134;
  v59 = qword_100999828;
  if (*(_DWORD *)(v134 + 1960) == 3)
  {
    *(_QWORD *)&buf[8] = 0;
    *(_QWORD *)buf = 0;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v151 = 0;
      _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "statedump: Scan configuration:", v151, 2u);
    }
    LOWORD(v60) = *(_WORD *)(v134 + 1972);
    snprintf((char *)buf, 0x10uLL, "%.02fms", (double)v60 * 0.625);
    v61 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v151 = 136446210;
      *(_QWORD *)&v151[4] = buf;
      _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "statedump:    Interval: %{public}s", v151, 0xCu);
    }
    LOWORD(v62) = *(_WORD *)(v134 + 1974);
    snprintf((char *)buf, 0x10uLL, "%.02fms", (double)v62 * 0.625);
    v59 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v151 = 136446210;
      *(_QWORD *)&v151[4] = buf;
      _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "statedump:    Window: %{public}s", v151, 0xCu);
      v59 = qword_100999828;
    }
    if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
    {
      if (*(_BYTE *)(v134 + 1968))
        v63 = "Passive";
      else
        v63 = "Active";
      *(_DWORD *)v151 = 136446210;
      *(_QWORD *)&v151[4] = v63;
      _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "statedump:    Type: %{public}s", v151, 0xCu);
      v59 = qword_100999828;
    }
    if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
    {
      if (*(_BYTE *)(v134 + 1971))
        v64 = "No";
      else
        v64 = "Yes";
      *(_DWORD *)v151 = 136446210;
      *(_QWORD *)&v151[4] = v64;
      _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "statedump:    Duplicates: %{public}s", v151, 0xCu);
      v59 = qword_100999828;
    }
    if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
    {
      if (*(_BYTE *)(v134 + 1970))
        v65 = "Yes";
      else
        v65 = "No";
      *(_DWORD *)v151 = 136446210;
      *(_QWORD *)&v151[4] = v65;
      _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "statedump:    Filter Accept List: %{public}s", v151, 0xCu);
      v59 = qword_100999828;
    }
    if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
    {
      if (*(_BYTE *)(v134 + 1848))
        v66 = "Disabled";
      else
        v66 = "Enabled";
      *(_DWORD *)v151 = 136446210;
      *(_QWORD *)&v151[4] = v66;
      _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "statedump:    HW Filtering: %{public}s", v151, 0xCu);
      v59 = qword_100999828;
    }
  }
  if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "statedump: Scan agents:", buf, 2u);
  }
  if (v32[89])
  {
    v67 = *(_QWORD **)(v134 + 2040);
    if (v67 != (_QWORD *)(v134 + 2048))
    {
      do
      {
        v135 = *(_QWORD *)(v67[5] + 8);
        v68 = qword_100999828;
        if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
        {
          sub_1000340DC(v67[4], (uint64_t)buf);
          v69 = buf;
          if ((buf[23] & 0x80u) != 0)
            v69 = *(uint8_t **)buf;
          *(_DWORD *)v151 = 136446210;
          *(_QWORD *)&v151[4] = v69;
          _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "statedump:    \"%{public}s\"", v151, 0xCu);
          if ((char)buf[23] < 0)
            operator delete(*(void **)buf);
          v68 = qword_100999828;
        }
        if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
        {
          v70 = "Yes";
          if (!*(_BYTE *)v135)
            v70 = "No";
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = v70;
          _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "statedump:       Duplicates: %{public}s", buf, 0xCu);
        }
        v144 = 0;
        v145 = 0;
        v143 = 0;
        sub_1000B61B8((char *)&v143, *(__int128 **)(v135 + 8), *(__int128 **)(v135 + 16), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(v135 + 16) - *(_QWORD *)(v135 + 8)) >> 2));
        v165 = 0;
        v163 = 0u;
        memset(v164, 0, sizeof(v164));
        *(_OWORD *)v161 = 0u;
        v162 = 0u;
        v159 = 0u;
        v160 = 0u;
        memset(buf, 0, sizeof(buf));
        sub_1002613AC((uint64_t)buf);
        v71 = (char *)v143;
        if (v144 != v143)
        {
          do
          {
            sub_10006887C((uint64_t)v71, v151);
            if ((SBYTE7(v152[0]) & 0x80u) == 0)
              v72 = v151;
            else
              v72 = *(uint8_t **)v151;
            if ((SBYTE7(v152[0]) & 0x80u) == 0)
              v73 = BYTE7(v152[0]);
            else
              v73 = *(_QWORD *)&v151[8];
            v74 = sub_1002614D8(&buf[16], (uint64_t)v72, v73);
            sub_1002614D8(v74, (uint64_t)" ", 1);
            if (SBYTE7(v152[0]) < 0)
              operator delete(*(void **)v151);
            v71 += 20;
          }
          while (v71 != v144);
          v75 = qword_100999828;
          if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
          {
            std::stringbuf::str(&buf[24]);
            v76 = (SBYTE7(v152[0]) & 0x80u) == 0 ? v151 : *(uint8_t **)v151;
            *(_DWORD *)v146 = 136446210;
            *(_QWORD *)&v146[4] = v76;
            _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, "statedump:       Services: %{public}s", v146, 0xCu);
            if (SBYTE7(v152[0]) < 0)
              operator delete(*(void **)v151);
          }
        }
        if (&v143 != (void **)(v135 + 32))
          sub_1000B56F0(&v143, *(__int128 **)(v135 + 32), *(__int128 **)(v135 + 40), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(_QWORD *)(v135 + 40) - *(_QWORD *)(v135 + 32)) >> 2));
        memset(v151, 0, sizeof(v151));
        *(_QWORD *)&v152[0] = 0;
        std::string::operator=((std::string *)&v161[1], (const std::string *)v151);
        sub_100337CA4((uint64_t)&buf[24]);
        if (SBYTE7(v152[0]) < 0)
          operator delete(*(void **)v151);
        v78 = (char *)v143;
        v77 = v144;
        while (v78 != v77)
        {
          sub_10006887C((uint64_t)v78, v151);
          if ((SBYTE7(v152[0]) & 0x80u) == 0)
            v79 = v151;
          else
            v79 = *(uint8_t **)v151;
          if ((SBYTE7(v152[0]) & 0x80u) == 0)
            v80 = BYTE7(v152[0]);
          else
            v80 = *(_QWORD *)&v151[8];
          v81 = sub_1002614D8(&buf[16], (uint64_t)v79, v80);
          sub_1002614D8(v81, (uint64_t)" ", 1);
          if (SBYTE7(v152[0]) < 0)
            operator delete(*(void **)v151);
          v78 += 20;
        }
        v82 = qword_100999828;
        if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
        {
          std::stringbuf::str(&buf[24]);
          if ((SBYTE7(v152[0]) & 0x80u) == 0)
            v83 = v151;
          else
            v83 = *(uint8_t **)v151;
          *(_DWORD *)v146 = 136446210;
          *(_QWORD *)&v146[4] = v83;
          _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "statedump:       Solicited Services: %{public}s", v146, 0xCu);
          if (SBYTE7(v152[0]) < 0)
            operator delete(*(void **)v151);
          v82 = qword_100999828;
        }
        if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
        {
          v84 = "YES";
          if (!*(_BYTE *)(v135 + 2))
            v84 = "NO";
          *(_DWORD *)v151 = 136446210;
          *(_QWORD *)&v151[4] = v84;
          _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "statedump:       Requires active scan:%{public}s", v151, 0xCu);
          v82 = qword_100999828;
        }
        if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
        {
          v85 = *(_DWORD *)(v67[5] + 96);
          *(_DWORD *)v151 = 67109120;
          *(_DWORD *)&v151[4] = v85;
          _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "statedump:       scan level:%d", v151, 8u);
          v82 = qword_100999828;
        }
        if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
        {
          v86 = "YES";
          if (!*(_BYTE *)(*(_QWORD *)(v67[5] + 8) + 3))
            v86 = "NO";
          *(_DWORD *)v151 = 136446210;
          *(_QWORD *)&v151[4] = v86;
          _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "statedump:       Allowed in paused:%{public}s", v151, 0xCu);
          v82 = qword_100999828;
        }
        if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
        {
          v87 = "YES";
          if (!*(_BYTE *)(*(_QWORD *)(v67[5] + 8) + 142))
            v87 = "NO";
          *(_DWORD *)v151 = 136446210;
          *(_QWORD *)&v151[4] = v87;
          _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "statedump:       Power assertion:%{public}s", v151, 0xCu);
        }
        v88 = qword_100999948;
        if (os_log_type_enabled((os_log_t)qword_100999948, OS_LOG_TYPE_DEFAULT))
        {
          v89 = "YES";
          if (!*(_BYTE *)(*(_QWORD *)(v67[5] + 8) + 143))
            v89 = "NO";
          *(_DWORD *)v151 = 136446210;
          *(_QWORD *)&v151[4] = v89;
          _os_log_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_DEFAULT, "statedump:       Exposure Notification:%{public}s", v151, 0xCu);
        }
        if (*(_BYTE *)(v135 + 120))
        {
          v90 = qword_100999828;
          if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
          {
            v91 = *(unsigned __int8 *)(v135 + 136);
            v93 = *(_DWORD *)(v135 + 128);
            v92 = *(_DWORD *)(v135 + 132);
            *(_DWORD *)v151 = 67109632;
            *(_DWORD *)&v151[4] = v93;
            *(_WORD *)&v151[8] = 1024;
            *(_DWORD *)&v151[10] = v92;
            *(_WORD *)&v151[14] = 1024;
            LODWORD(v152[0]) = v91;
            _os_log_impl((void *)&_mh_execute_header, v90, OS_LOG_TYPE_DEFAULT, "statedump:       requested interval:%d window:%d active:%d", v151, 0x14u);
          }
        }
        v94 = *(_BYTE *)(v135 + 122);
        if ((v94 & 1) != 0)
        {
          v95 = qword_100999828;
          if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)v151 = 0;
            _os_log_impl((void *)&_mh_execute_header, v95, OS_LOG_TYPE_DEFAULT, "statedump:       HW ObjectDiscovery Wild", v151, 2u);
            v94 = *(_BYTE *)(v135 + 122);
          }
        }
        if ((v94 & 2) != 0)
        {
          v96 = qword_100999828;
          if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)v151 = 0;
            _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_DEFAULT, "statedump:       HW ObjectDiscovery Near Owner", v151, 2u);
          }
        }
        v97 = *(_WORD *)(v135 + 124);
        if ((v97 & 1) != 0)
        {
          v98 = qword_100999828;
          if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)v151 = 0;
            _os_log_impl((void *)&_mh_execute_header, v98, OS_LOG_TYPE_DEFAULT, "statedump:       HW AOP BT Buffer ADPD", v151, 2u);
            v97 = *(_WORD *)(v135 + 124);
          }
        }
        if ((v97 & 2) != 0)
        {
          v99 = qword_100999828;
          if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)v151 = 0;
            _os_log_impl((void *)&_mh_execute_header, v99, OS_LOG_TYPE_DEFAULT, "statedump:       HW AOP BT Buffer All", v151, 2u);
          }
        }
        v100 = *(_QWORD *)(v135 + 64);
        v101 = *(_QWORD *)(v135 + 72);
        while (v100 != v101)
        {
          v102 = qword_100999828;
          if (*(_BYTE *)(v100 + 64) && os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
          {
            v103 = *(unsigned __int8 *)(v100 + 8);
            *(_DWORD *)v151 = 67109120;
            *(_DWORD *)&v151[4] = v103;
            _os_log_impl((void *)&_mh_execute_header, v102, OS_LOG_TYPE_DEFAULT, "statedump:       ObjectLocator type %x", v151, 8u);
            v102 = qword_100999828;
          }
          if (os_log_type_enabled(v102, OS_LOG_TYPE_DEFAULT))
          {
            v104 = *(unsigned __int8 *)(v100 + 8);
            v105 = *(_DWORD *)(v100 + 80);
            v106 = *(_DWORD *)(v100 + 84);
            v107 = *(_DWORD *)(v100 + 88);
            *(_DWORD *)v151 = 67109888;
            *(_DWORD *)&v151[4] = v104;
            *(_WORD *)&v151[8] = 1024;
            *(_DWORD *)&v151[10] = v105;
            *(_WORD *)&v151[14] = 1024;
            LODWORD(v152[0]) = v106;
            WORD2(v152[0]) = 1024;
            *(_DWORD *)((char *)v152 + 6) = v107;
            _os_log_impl((void *)&_mh_execute_header, v102, OS_LOG_TYPE_DEFAULT, "statedump:       Puck: %d  %d/%d/%d", v151, 0x1Au);
          }
          v108 = *(id *)(v100 + 72);
          if (v108)
          {
            v109 = v108;
            v110 = *(id *)(v100 + 72);
            v111 = objc_msgSend(v110, "count") == 0;

            if (!v111)
            {
              v157 = 0;
              v155 = 0u;
              memset(v156, 0, sizeof(v156));
              *(_OWORD *)__p = 0u;
              v154 = 0u;
              memset(v152, 0, sizeof(v152));
              *(_OWORD *)v151 = 0u;
              sub_1002613AC((uint64_t)v151);
              v141 = 0u;
              v142 = 0u;
              v139 = 0u;
              v140 = 0u;
              v112 = *(id *)(v100 + 72);
              v113 = objc_msgSend(v112, "countByEnumeratingWithState:objects:count:", &v139, v150, 16);
              if (v113)
              {
                v114 = *(_QWORD *)v140;
                do
                {
                  for (i = 0; i != v113; i = (char *)i + 1)
                  {
                    if (*(_QWORD *)v140 != v114)
                      objc_enumerationMutation(v112);
                    v116 = sub_100036ECC((int)objc_msgSend(*(id *)(*((_QWORD *)&v139 + 1) + 8 * (_QWORD)i), "longLongValue"));
                    v117 = strlen(v116);
                    v118 = sub_1002614D8(v152, (uint64_t)v116, v117);
                    sub_1002614D8(v118, (uint64_t)" ", 1);
                  }
                  v113 = objc_msgSend(v112, "countByEnumeratingWithState:objects:count:", &v139, v150, 16);
                }
                while (v113);
              }

              v119 = qword_100999828;
              if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
              {
                std::stringbuf::str((char *)v152 + 8);
                v120 = v146;
                if (v147 < 0)
                  v120 = *(_BYTE **)v146;
                *(_DWORD *)v148 = 136315138;
                v149 = v120;
                _os_log_impl((void *)&_mh_execute_header, v119, OS_LOG_TYPE_DEFAULT, "statedump:             UseCaseList: %s", v148, 0xCu);
                if (v147 < 0)
                  operator delete(*(void **)v146);
              }
              *(_QWORD *)v151 = v137;
              *(_QWORD *)&v151[*(_QWORD *)(v137 - 24)] = v136;
              *(_QWORD *)&v152[0] = v138;
              if (SHIBYTE(v154) < 0)
                operator delete(__p[1]);
              std::streambuf::~streambuf((char *)v152 + 8);
              std::ios::~ios(v156);
            }
          }
          v100 += 96;
        }
        v121 = qword_100999828;
        if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
        {
          v122 = "YES";
          if (!*(_BYTE *)(v135 + 200))
            v122 = "NO";
          *(_DWORD *)v151 = 136446210;
          *(_QWORD *)&v151[4] = v122;
          _os_log_impl((void *)&_mh_execute_header, v121, OS_LOG_TYPE_DEFAULT, "statedump:       Requires double boost scan: %{public}s", v151, 0xCu);
        }
        sub_10068B1E4(v67[5]);
        v58 = v134;
        *(_QWORD *)buf = v137;
        *(_QWORD *)&buf[*(_QWORD *)(v137 - 24)] = v136;
        *(_QWORD *)&buf[16] = v138;
        if (SHIBYTE(v162) < 0)
          operator delete(v161[1]);
        std::streambuf::~streambuf(&buf[24]);
        std::ios::~ios(v164);
        if (v143)
        {
          v144 = (char *)v143;
          operator delete(v143);
        }
        v123 = (_QWORD *)v67[1];
        if (v123)
        {
          do
          {
            v124 = v123;
            v123 = (_QWORD *)*v123;
          }
          while (v123);
        }
        else
        {
          do
          {
            v124 = (_QWORD *)v67[2];
            v51 = *v124 == (_QWORD)v67;
            v67 = v124;
          }
          while (!v51);
        }
        v67 = v124;
      }
      while (v124 != (_QWORD *)(v134 + 2048));
    }
  }
  v125 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v125, OS_LOG_TYPE_DEFAULT, "statedump: Configured ObjectLocator MatchTables:", buf, 2u);
    v125 = qword_100999828;
  }
  v126 = *(_QWORD **)(v58 + 1816);
  if (v126 != (_QWORD *)(v58 + 1824))
  {
    do
    {
      if (os_log_type_enabled(v125, OS_LOG_TYPE_DEFAULT))
      {
        v127 = *((unsigned __int16 *)v126 + 18);
        v128 = *((unsigned __int16 *)v126 + 15);
        v129 = *((unsigned __int8 *)v126 + 28);
        v130 = *((_WORD *)v126 + 16) != 0;
        v131 = *((unsigned __int16 *)v126 + 17) != 0;
        *(_DWORD *)buf = 67110144;
        *(_DWORD *)&buf[4] = v129;
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = v128;
        *(_WORD *)&buf[14] = 1024;
        *(_DWORD *)&buf[16] = v127;
        *(_WORD *)&buf[20] = 1024;
        *(_DWORD *)&buf[22] = v130;
        *(_WORD *)&buf[26] = 1024;
        *(_DWORD *)&buf[28] = v131;
        _os_log_impl((void *)&_mh_execute_header, v125, OS_LOG_TYPE_DEFAULT, "statedump: \tType:%x handle:%d Length:%d created:%d enabled:%d", buf, 0x20u);
        v125 = qword_100999828;
      }
      v132 = (_QWORD *)v126[1];
      if (v132)
      {
        do
        {
          v133 = v132;
          v132 = (_QWORD *)*v132;
        }
        while (v132);
      }
      else
      {
        do
        {
          v133 = (_QWORD *)v126[2];
          v51 = *v133 == (_QWORD)v126;
          v126 = v133;
        }
        while (!v51);
      }
      v126 = v133;
    }
    while (v133 != (_QWORD *)(v58 + 1824));
  }
  if (os_log_type_enabled(v125, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v125, OS_LOG_TYPE_DEFAULT, "statedump: Configured Payload encryption keys:", buf, 2u);
  }
  objc_msgSend(*(id *)(v134 + 2088), "enumerateKeysAndObjectsWithOptions:usingBlock:", 1, &stru_10093F290);
  sub_100683654(v134);
  sub_100677028(v134);
  sub_100677A50(v134);
  sub_100683E18(v134);
}

void sub_100683434(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,void *a44)
{
  STACK[0x300] = a31;
  *(unint64_t *)((char *)&STACK[0x300] + *(_QWORD *)(a31 - 24)) = a30;
  STACK[0x310] = a32;
  if (SLOBYTE(STACK[0x36F]) < 0)
    operator delete((void *)STACK[0x358]);
  std::streambuf::~streambuf(a20);
  std::ios::~ios(a15);
  if (a44)
    operator delete(a44);
  _Unwind_Resume(a1);
}

void sub_100683580(id a1, id a2, id a3, BOOL *a4)
{
  NSObject *v6;
  int v7;
  uint64_t v8;
  __int16 v9;
  id v10;
  __int16 v11;
  uint64_t v12;
  __int16 v13;
  id v14;

  v6 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    v7 = 141558787;
    v8 = 1752392040;
    v9 = 2113;
    v10 = a2;
    v11 = 2160;
    v12 = 1752392040;
    v13 = 2113;
    v14 = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "statedump:       %{private, mask.hash}@ --> %{private, mask.hash}@", (uint8_t *)&v7, 0x2Au);
  }
}

void sub_100683654(uint64_t a1)
{
  NSObject *v2;
  double Current;
  uint64_t v4;
  NSObject *v5;
  char v6;
  char v7;
  double v8;
  double v9;
  const char *v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  uint8_t buf[4];
  double v33;

  v2 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: BLE Scan Configuration Stat:", buf, 2u);
  }
  sub_1006849A0(a1);
  Current = CFAbsoluteTimeGetCurrent();
  v4 = 0;
  v5 = qword_100999828;
  v6 = 1;
  do
  {
    v7 = v6;
    v8 = *(double *)(a1 + 176 * v4 + 2360);
    if (Current >= v8)
      v9 = Current - v8;
    else
      v9 = 0.0;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v10 = "screen off";
      if ((v7 & 1) != 0)
        v10 = "screen on";
      *(_DWORD *)buf = 136315138;
      v33 = *(double *)&v10;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: \t=================== LE Scan Configuration Stats when %s ===================", buf, 0xCu);
      v5 = qword_100999828;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      v33 = v9;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: \tBLE Scan Configuration Stats started %f sec ago", buf, 0xCu);
      v5 = qword_100999828;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v11 = *(_DWORD *)(a1 + 176 * v4 + 2448);
      *(_DWORD *)buf = 67109120;
      LODWORD(v33) = v11;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: \tBLE Scan Configuration Count: %u", buf, 8u);
      v5 = qword_100999828;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v12 = *(_DWORD *)(a1 + 176 * v4 + 2452);
      *(_DWORD *)buf = 67109120;
      LODWORD(v33) = v12;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: \tBLE Scan Configuration Count hasParamUpdate : %u", buf, 8u);
      v5 = qword_100999828;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v13 = *(_DWORD *)(a1 + 176 * v4 + 2456);
      *(_DWORD *)buf = 67109120;
      LODWORD(v33) = v13;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: \tBLE Scan Configuration Count needFWScanRestart : %u", buf, 8u);
      v5 = qword_100999828;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v14 = *(_DWORD *)(a1 + 176 * v4 + 2464);
      *(_DWORD *)buf = 67109120;
      LODWORD(v33) = v14;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: \tBLE Scan Configuration Count needNoFWScanRestart : %u", buf, 8u);
      v5 = qword_100999828;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v15 = *(_DWORD *)(a1 + 176 * v4 + 2484);
      *(_DWORD *)buf = 67109120;
      LODWORD(v33) = v15;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: \tBLE Scan Configuration Count hasMatchingRuleUpdate : %u", buf, 8u);
      v5 = qword_100999828;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v16 = *(_DWORD *)(a1 + 176 * v4 + 2480);
      *(_DWORD *)buf = 67109120;
      LODWORD(v33) = v16;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: \tBLE Scan Configuration Count hasMatchingAddressUpdate : %u", buf, 8u);
      v5 = qword_100999828;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v17 = *(_DWORD *)(a1 + 176 * v4 + 2476);
      *(_DWORD *)buf = 67109120;
      LODWORD(v33) = v17;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: \tBLE Scan Configuration Count hasPCFUpdate : %u", buf, 8u);
      v5 = qword_100999828;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v18 = *(_DWORD *)(a1 + 176 * v4 + 2472);
      *(_DWORD *)buf = 67109120;
      LODWORD(v33) = v18;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: \tBLE Scan Configuration Count hasZoneUpdate : %u", buf, 8u);
      v5 = qword_100999828;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v19 = *(_DWORD *)(a1 + 176 * v4 + 2488);
      *(_DWORD *)buf = 67109120;
      LODWORD(v33) = v19;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: \tBLE Scan Configuration Count hasAdvMatchBufUpdate : %u", buf, 8u);
      v5 = qword_100999828;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v20 = *(unsigned __int16 *)(a1 + 176 * v4 + 2492);
      *(_DWORD *)buf = 67109120;
      LODWORD(v33) = v20;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: \tBLE Scan Configuration Min: %u ms", buf, 8u);
      v5 = qword_100999828;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v21 = *(unsigned __int16 *)(a1 + 176 * v4 + 2494);
      *(_DWORD *)buf = 67109120;
      LODWORD(v33) = v21;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: \tBLE Scan Configuration Max: %u ms", buf, 8u);
      v5 = qword_100999828;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v22 = *(unsigned __int16 *)(a1 + 176 * v4 + 2496);
      *(_DWORD *)buf = 67109120;
      LODWORD(v33) = v22;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: \tBLE Scan Configuration Average: %u ms", buf, 8u);
      v5 = qword_100999828;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v23 = *(unsigned __int16 *)(a1 + 176 * v4 + 2498);
      *(_DWORD *)buf = 67109120;
      LODWORD(v33) = v23;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: \tBLE Scan Configuration 5 Percentile: %u ms", buf, 8u);
      v5 = qword_100999828;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v24 = *(unsigned __int16 *)(a1 + 176 * v4 + 2500);
      *(_DWORD *)buf = 67109120;
      LODWORD(v33) = v24;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: \tBLE Scan Configuration 25 Percentile: %u ms", buf, 8u);
      v5 = qword_100999828;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v25 = *(unsigned __int16 *)(a1 + 176 * v4 + 2502);
      *(_DWORD *)buf = 67109120;
      LODWORD(v33) = v25;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: \tBLE Scan Configuration 50 Percentile: %u ms", buf, 8u);
      v5 = qword_100999828;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v26 = *(unsigned __int16 *)(a1 + 176 * v4 + 2504);
      *(_DWORD *)buf = 67109120;
      LODWORD(v33) = v26;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: \tBLE Scan Configuration 75 Percentile: %u ms", buf, 8u);
      v5 = qword_100999828;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v27 = *(unsigned __int16 *)(a1 + 176 * v4 + 2506);
      *(_DWORD *)buf = 67109120;
      LODWORD(v33) = v27;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: \tBLE Scan Configuration 95 Percentile: %u ms", buf, 8u);
      v5 = qword_100999828;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v28 = *(unsigned __int16 *)(a1 + 176 * v4 + 2516);
      *(_DWORD *)buf = 67109120;
      LODWORD(v33) = v28;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: \tBLE Scan Configuration Average HeySiri UseCase: %u ms", buf, 8u);
      v5 = qword_100999828;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v29 = *(_DWORD *)(a1 + 176 * v4 + 2508);
      *(_DWORD *)buf = 67109120;
      LODWORD(v33) = v29;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: \tBLE Scan Configuration Count HeySiri UseCase: %u", buf, 8u);
      v5 = qword_100999828;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v30 = *(unsigned __int16 *)(a1 + 176 * v4 + 2528);
      *(_DWORD *)buf = 67109120;
      LODWORD(v33) = v30;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: \tBLE Scan Configuration Average Sharing UseCases: %u ms", buf, 8u);
      v5 = qword_100999828;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v31 = *(_DWORD *)(a1 + 176 * v4 + 2520);
      *(_DWORD *)buf = 67109120;
      LODWORD(v33) = v31;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: \tBLE Scan Configuration Count Sharing UseCase: %u", buf, 8u);
      v5 = qword_100999828;
    }
    v6 = 0;
    v4 = 1;
  }
  while ((v7 & 1) != 0);
}

void sub_100683E18(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  const __CFString *v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  const char *v13;
  const char *v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  uint8_t buf[4];
  const __CFString *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  int v24;
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  __int16 v33;
  const char *v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  int v38;
  __int16 v39;
  int v40;
  __int16 v41;
  int v42;
  __int16 v43;
  uint64_t v44;

  v2 = 0;
  v3 = qword_100999828;
  v4 = -1632;
  do
  {
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v5 = CFSTR("UNKNOWN");
      if (v2 <= 2u)
        v5 = off_10093F698[v2];
      v6 = a1 + v4;
      v7 = *(unsigned __int8 *)(a1 + v4 + 1792);
      v8 = *(unsigned __int8 *)(a1 + v4 + 1793);
      v9 = *(unsigned __int16 *)(a1 + v4 + 1794);
      v10 = *(unsigned __int8 *)(a1 + v4 + 1796);
      v11 = *(unsigned __int8 *)(a1 + v4 + 1797);
      v12 = *(unsigned __int8 *)(a1 + v4 + 1798);
      if (*(_BYTE *)(a1 + v4 + 1799))
        v13 = "YES";
      else
        v13 = "NO";
      if (*(_BYTE *)(v6 + 1800))
        v14 = "YES";
      else
        v14 = "NO";
      v15 = *(unsigned __int8 *)(v6 + 1804);
      v16 = *(unsigned __int8 *)(v6 + 1805);
      v17 = *(unsigned __int16 *)(v6 + 1806);
      v18 = *(_QWORD *)(v6 + 1808);
      *(_DWORD *)buf = 138546434;
      v20 = v5;
      v21 = 1024;
      v22 = v7;
      v23 = 1024;
      v24 = v8;
      v25 = 1024;
      v26 = v9;
      v27 = 1024;
      v28 = v10;
      v29 = 1024;
      v30 = v11;
      v31 = 1024;
      v32 = v12;
      v33 = 2082;
      v34 = v13;
      v35 = 2082;
      v36 = v14;
      v37 = 1024;
      v38 = v15;
      v39 = 1024;
      v40 = v16;
      v41 = 1024;
      v42 = v17;
      v43 = 2048;
      v44 = v18;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "statedump: ADVBUFF(%{public}@): mask:0x%x advADType:0x%x advCompanyID:0x%x advType:0x%x minPayloadSize:%d buffEntries:%d created:%{public}s enabled:%{public}s expectedEntries:%d statusMask:0x%x overflows:%d enabledTS:%f", buf, 0x60u);
      v3 = qword_100999828;
    }
    ++v2;
    v4 += 544;
  }
  while (v4);
}

void sub_100683FE8(uint64_t a1, void *a2, uint64_t a3)
{
  id v5;
  void *v6;

  v5 = a2;
  if (v5)
  {
    if (a3)
    {
      v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", a3, 16));
      objc_msgSend(*(id *)(a1 + 2088), "setObject:forKeyedSubscript:", v6, v5);

    }
    else if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
    {
      sub_100715FE8();
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
  {
    sub_100714B28();
  }

}

void sub_1006840A8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1006840C4(uint64_t a1, unsigned __int8 *a2)
{
  unsigned __int8 *v3;
  void *v4;
  id v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  void *v11;
  _QWORD *v12;
  void *v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void **v19;

  v3 = a2 + 1;
  v4 = *(void **)(a1 + 2088);
  v5 = sub_100021770(((unint64_t)a2[1] << 40) | ((unint64_t)a2[2] << 32) | ((unint64_t)a2[3] << 24) | ((unint64_t)a2[4] << 16) | ((unint64_t)a2[5] << 8) | a2[6] | ((unint64_t)*a2 << 48));
  v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
  objc_msgSend(v4, "removeObjectForKey:", v6);

  if (qword_1009778E8 != -1)
    dispatch_once(&qword_1009778E8, &stru_10093F598);
  LODWORD(v16) = *(_DWORD *)v3;
  WORD2(v16) = *((_WORD *)v3 + 2);
  v7 = sub_1004704A8((uint64_t)off_1009778E0, (uint64_t)&v16, 1);
  if (v7)
  {
    v16 = 0;
    v17 = 0;
    v18 = 0;
    if (!sub_100448DAC(v7, (uint64_t)&v16))
      goto LABEL_32;
    v8 = v16;
    v9 = 0xAAAAAAAAAAAAAAABLL * ((v17 - v16) >> 3);
    if (v9 < 4)
      goto LABEL_32;
    v10 = (_QWORD *)(v16 + 72);
    if (*(char *)(v16 + 95) < 0)
    {
      if (*(_QWORD *)(v16 + 80) <= 1uLL)
        goto LABEL_14;
      v10 = (_QWORD *)*v10;
    }
    else if (*(unsigned __int8 *)(v16 + 95) <= 1u)
    {
      goto LABEL_14;
    }
    v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v10));
    if (objc_msgSend(v11, "length"))
      objc_msgSend(*(id *)(a1 + 2088), "removeObjectForKey:", v11);

    v8 = v16;
    v9 = 0xAAAAAAAAAAAAAAABLL * ((v17 - v16) >> 3);
LABEL_14:
    if (v9 < 9)
      goto LABEL_32;
    v12 = (_QWORD *)(v8 + 192);
    if (*(char *)(v8 + 215) < 0)
    {
      if (*(_QWORD *)(v8 + 200) <= 1uLL)
        goto LABEL_23;
      v12 = (_QWORD *)*v12;
    }
    else if (*(unsigned __int8 *)(v8 + 215) <= 1u)
    {
      goto LABEL_23;
    }
    v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v12));
    if (objc_msgSend(v13, "length"))
      objc_msgSend(*(id *)(a1 + 2088), "removeObjectForKey:", v13);

    v8 = v16;
    v9 = 0xAAAAAAAAAAAAAAABLL * ((v17 - v16) >> 3);
LABEL_23:
    if (v9 >= 0xA)
    {
      v14 = (_QWORD *)(v8 + 216);
      if ((*(char *)(v8 + 239) & 0x80000000) == 0)
      {
        if (*(unsigned __int8 *)(v8 + 239) <= 1u)
          goto LABEL_32;
LABEL_29:
        v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v14));
        if (objc_msgSend(v15, "length"))
          objc_msgSend(*(id *)(a1 + 2088), "removeObjectForKey:", v15);

        goto LABEL_32;
      }
      if (*(_QWORD *)(v8 + 224) > 1uLL)
      {
        v14 = (_QWORD *)*v14;
        goto LABEL_29;
      }
    }
LABEL_32:
    v19 = (void **)&v16;
    sub_100091BF8(&v19);
  }
}

void sub_100684328(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  sub_100091BF8(&a12);
  _Unwind_Resume(a1);
}

BOOL sub_100684370(uint64_t a1, void *a2, uint64_t a3)
{
  id v5;
  void *v6;
  NSObject *v7;
  id v8;
  int v10;
  uint64_t v11;
  __int16 v12;
  id v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  void *v17;

  v5 = a2;
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 2088), "objectForKey:", v5));
  v7 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
  {
    v10 = 141558787;
    v11 = 1752392040;
    v12 = 2113;
    v13 = v5;
    v14 = 2160;
    v15 = 1752392040;
    v16 = 2113;
    v17 = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "getDeviceEncryptionKey SN:%{private, mask.hash}@ key:%{private, mask.hash}@", (uint8_t *)&v10, 0x2Au);
  }
  v8 = objc_msgSend(v6, "length");
  if (v8)
    objc_msgSend(v6, "getBytes:length:", a3, 16);

  return v8 != 0;
}

void sub_100684494(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL sub_1006844B8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v5;
  id v6;
  void *v7;
  void *v8;
  NSObject *v9;
  id v10;
  void *v11;
  id v12;
  int v14;
  void *v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  void *v19;

  v5 = *(void **)(a1 + 2088);
  v6 = sub_100021770(a2);
  v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKey:", v7));

  v9 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
  {
    v10 = sub_100021770(a2);
    v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
    v14 = 138412803;
    v15 = v11;
    v16 = 2160;
    v17 = 1752392040;
    v18 = 2113;
    v19 = v8;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "getDeviceEncryptionKey address:%@ key:%{private, mask.hash}@", (uint8_t *)&v14, 0x20u);

  }
  v12 = objc_msgSend(v8, "length");
  if (v12)
    objc_msgSend(v8, "getBytes:length:", a3, 16);

  return v12 != 0;
}

void sub_1006845F4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t sub_10068461C(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v6;
  id v7;
  void *v8;
  id v9;
  void *v10;
  BOOL v11;
  unsigned __int8 v13[16];

  if (sub_1006844B8(a1, a2, a3))
    return 1;
  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_10093F4F8);
  sub_10003F924((uint64_t)off_1009778C0, a2, 0, 1u, 0, 0, v13);
  v7 = sub_100030DF4(v13);
  v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
  if (!v8)
    goto LABEL_10;
  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_10093F4F8);
  v9 = sub_100660C64((uint64_t)off_1009778C0, v8);
  v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
  v11 = sub_100684370(a1, v10, a3);

  if (v11)
    v6 = 1;
  else
LABEL_10:
    v6 = 0;

  return v6;
}

void sub_10068475C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_100684780(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  id v5;
  _QWORD v6[4];
  id v7;
  uint64_t v8;

  v3 = a2;
  v4 = sub_1000419F4();
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_100684830;
  v6[3] = &unk_100918868;
  v8 = a1;
  v5 = v3;
  v7 = v5;
  sub_100041A34(v4, v6);

}

void sub_100684810(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  void *v13;

  _Unwind_Resume(a1);
}

void sub_100684830(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;
  _QWORD *v3;
  NSObject *v5;
  void **v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  BOOL v10;
  void *__p[2];
  char v12;
  uint8_t buf[4];
  void **v14;
  __int16 v15;
  uint64_t v16;

  v1 = *(_QWORD *)(a1 + 40);
  v2 = *(_QWORD **)(v1 + 2040);
  v3 = (_QWORD *)(v1 + 2048);
  if (v2 != (_QWORD *)(v1 + 2048))
  {
    do
    {
      v5 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
      {
        sub_1000340DC(v2[4], (uint64_t)__p);
        v6 = v12 >= 0 ? __p : (void **)__p[0];
        v7 = *(_QWORD *)(a1 + 32);
        *(_DWORD *)buf = 136446466;
        v14 = v6;
        v15 = 2114;
        v16 = v7;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "session %{public}s device %{public}@ invalidated", buf, 0x16u);
        if (v12 < 0)
          operator delete(__p[0]);
      }
      sub_10068BA60(v2[5], *(void **)(a1 + 32));
      v8 = (_QWORD *)v2[1];
      if (v8)
      {
        do
        {
          v9 = v8;
          v8 = (_QWORD *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          v9 = (_QWORD *)v2[2];
          v10 = *v9 == (_QWORD)v2;
          v2 = v9;
        }
        while (!v10);
      }
      v2 = v9;
    }
    while (v9 != v3);
  }
}

void sub_100684998(uint64_t a1, void *a2)
{
  sub_100684780(a1 - 136, a2);
}

uint64_t sub_1006849A0(uint64_t result)
{
  uint64_t v1;
  char v2;
  char v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  NSObject *v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  BOOL v19;
  BOOL v20;
  BOOL v21;
  BOOL v22;
  BOOL v23;
  uint64_t v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int *v31;
  char v32;
  uint64_t v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int v38;
  unsigned int v39;
  uint8_t buf[4];
  int v41;
  __int16 v42;
  int v43;

  v1 = 0;
  v29 = result + 2368;
  v2 = 1;
  v30 = result;
  do
  {
    v3 = v2;
    v4 = result + 176 * v1;
    v5 = *(_DWORD *)(v4 + 2448);
    if (v5)
    {
      v32 = v3;
      v6 = 0;
      v7 = 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      v11 = 0;
      v12 = 0;
      v13 = 0;
      v31 = (unsigned int *)(v4 + 2448);
      v38 = v5 / 0x14;
      v37 = v5 >> 2;
      v36 = v5 >> 1;
      v35 = (3 * v5) >> 2;
      v34 = 19 * v5 / 0x14;
      v14 = qword_100999828;
      v33 = v1;
      v15 = v29 + 176 * v1;
      v16 = 10;
      do
      {
        v39 = v12;
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          v17 = *(_DWORD *)(v15 + 4 * v6);
          *(_DWORD *)buf = 67109376;
          v41 = v6;
          v42 = 1024;
          v43 = v17;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "statedump: \tBLE Scan Configuration Count Bucket %d Count: %u", buf, 0xEu);
          v14 = qword_100999828;
        }
        v18 = *(_DWORD *)(v15 + 4 * v6);
        v12 = v39 + ((v16 * v18) >> 1);
        v13 += v18;
        if (v11)
          v19 = 0;
        else
          v19 = v13 >= v38;
        if (v19)
          v11 = v6;
        if (v10)
          v20 = 0;
        else
          v20 = v13 >= v37;
        if (v20)
          v10 = v6;
        if (v9)
          v21 = 0;
        else
          v21 = v13 >= v36;
        if (v21)
          v9 = v6;
        if (v8)
          v22 = 0;
        else
          v22 = v13 >= v35;
        if (v22)
          v8 = v6;
        if (v7)
          v23 = 0;
        else
          v23 = v13 >= v34;
        if (v23)
          v7 = v6;
        ++v6;
        v16 += 20;
      }
      while (v6 != 20);
      result = v30;
      v24 = v30 + 176 * v33;
      *(_WORD *)(v24 + 2498) = 10 * v11 + 5;
      *(_WORD *)(v24 + 2500) = 10 * v10 + 5;
      *(_WORD *)(v24 + 2502) = 10 * v9 + 5;
      *(_WORD *)(v24 + 2504) = 10 * v8 + 5;
      *(_WORD *)(v24 + 2506) = 10 * v7 + 5;
      v25 = *v31;
      *(_WORD *)(v24 + 2496) = v12 / *v31;
      v26 = *(_DWORD *)(v24 + 2508);
      if (v26)
        *(_WORD *)(v30 + 176 * v33 + 2516) = *(_DWORD *)(v30 + 176 * v33 + 2512) / v26;
      v27 = *(_DWORD *)(v30 + 176 * v33 + 2520);
      if (v27)
        *(_WORD *)(v30 + 176 * v33 + 2528) = *(_DWORD *)(v30 + 176 * v33 + 2524) / v27;
      v28 = v30 + 176 * v33;
      *(_BYTE *)(v28 + 2460) = 100 * *(_DWORD *)(v28 + 2456) / v25;
      *(_BYTE *)(v28 + 2468) = 100 * *(_DWORD *)(v28 + 2464) / v25;
      v3 = v32;
    }
    v2 = 0;
    v1 = 1;
  }
  while ((v3 & 1) != 0);
  return result;
}

void sub_100684C5C(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  char v4;
  char v5;
  NSMutableDictionary *v6;
  NSMutableDictionary *v7;
  const __CFString *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  uint8_t v31[16];

  v2 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v31 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Send BLE Scan Configuration Daily Stat for Metric", v31, 2u);
  }
  sub_1006849A0(a1);
  v3 = 0;
  v4 = 1;
  do
  {
    v5 = v4;
    v6 = objc_opt_new(NSMutableDictionary);
    v7 = v6;
    if ((v5 & 1) != 0)
      v8 = CFSTR("ScreenOff");
    else
      v8 = CFSTR("ScreenOn");
    -[NSMutableDictionary setObject:forKeyedSubscript:](v6, "setObject:forKeyedSubscript:", v8, CFSTR("ScreenState"));
    v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 176 * v3 + 2448)));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v7, "setObject:forKeyedSubscript:", v9, CFSTR("ScanConfigCount"));

    v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 176 * v3 + 2452)));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v7, "setObject:forKeyedSubscript:", v10, CFSTR("ScanConfigCountHasParamsUpdate"));

    v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", *(unsigned __int8 *)(a1 + 176 * v3 + 2460)));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v7, "setObject:forKeyedSubscript:", v11, CFSTR("ScanConfigPercentageNeedFWScanRestart"));

    v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", *(unsigned __int8 *)(a1 + 176 * v3 + 2468)));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v7, "setObject:forKeyedSubscript:", v12, CFSTR("ScanConfigPercentageNeedNoFWScanRestart"));

    v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 176 * v3 + 2484)));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v7, "setObject:forKeyedSubscript:", v13, CFSTR("ScanConfigCountHasMatchingRuleRequested"));

    v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 176 * v3 + 2480)));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v7, "setObject:forKeyedSubscript:", v14, CFSTR("ScanConfigCountHasMatchingAddressRequested"));

    v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 176 * v3 + 2476)));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v7, "setObject:forKeyedSubscript:", v15, CFSTR("ScanConfigCountHasPCFRequested"));

    v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 176 * v3 + 2472)));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v7, "setObject:forKeyedSubscript:", v16, CFSTR("ScanConfigCountHasZoneRequested"));

    v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 176 * v3 + 2488)));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v7, "setObject:forKeyedSubscript:", v17, CFSTR("ScanConfigCountHasAdvMatchBufRequested"));

    v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", *(unsigned __int16 *)(a1 + 176 * v3 + 2492)));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v7, "setObject:forKeyedSubscript:", v18, CFSTR("ScanConfigTimeMin"));

    v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", *(unsigned __int16 *)(a1 + 176 * v3 + 2494)));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v7, "setObject:forKeyedSubscript:", v19, CFSTR("ScanConfigTimeMax"));

    v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", *(unsigned __int16 *)(a1 + 176 * v3 + 2496)));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v7, "setObject:forKeyedSubscript:", v20, CFSTR("ScanConfigTimeAvg"));

    v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", *(unsigned __int16 *)(a1 + 176 * v3 + 2498)));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v7, "setObject:forKeyedSubscript:", v21, CFSTR("ScanConfigTimePercentile5"));

    v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", *(unsigned __int16 *)(a1 + 176 * v3 + 2500)));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v7, "setObject:forKeyedSubscript:", v22, CFSTR("ScanConfigTimePercentile25"));

    v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", *(unsigned __int16 *)(a1 + 176 * v3 + 2502)));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v7, "setObject:forKeyedSubscript:", v23, CFSTR("ScanConfigTimePercentile50"));

    v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", *(unsigned __int16 *)(a1 + 176 * v3 + 2504)));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v7, "setObject:forKeyedSubscript:", v24, CFSTR("ScanConfigTimePercentile75"));

    v25 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", *(unsigned __int16 *)(a1 + 176 * v3 + 2506)));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v7, "setObject:forKeyedSubscript:", v25, CFSTR("ScanConfigTimePercentile95"));

    v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", *(unsigned __int16 *)(a1 + 176 * v3 + 2516)));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v7, "setObject:forKeyedSubscript:", v26, CFSTR("ScanConfigTimeAvgHeySiriUseCase"));

    v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 176 * v3 + 2508)));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v7, "setObject:forKeyedSubscript:", v27, CFSTR("ScanConfigCountHeySiriUseCase"));

    v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", *(unsigned __int16 *)(a1 + 176 * v3 + 2528)));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v7, "setObject:forKeyedSubscript:", v28, CFSTR("ScanConfigTimeAvgSharingUseCase"));

    v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", *(unsigned int *)(a1 + 176 * v3 + 2520)));
    -[NSMutableDictionary setObject:forKeyedSubscript:](v7, "setObject:forKeyedSubscript:", v29, CFSTR("ScanConfigCountSharingUseCase"));

    v30 = sub_100065478();
    (*(void (**)(uint64_t, NSMutableDictionary *))(*(_QWORD *)v30 + 312))(v30, v7);

    v4 = 0;
    v3 = 1;
  }
  while ((v5 & 1) != 0);
  sub_10066CC24(a1);
}

void sub_10068515C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

__n128 sub_1006851C8(uint64_t a1, uint64_t a2)
{
  float64x2_t *v4;
  uint64_t v5;
  NSObject *v6;
  CFAbsoluteTime Current;
  double v8;
  unsigned int v9;
  float64x2_t v10;
  int32x4_t v11;
  float64x2_t v12;
  int32x4_t v13;
  int32x4_t v14;
  int32x4_t v15;
  int32x4_t v16;
  int32x4_t v17;
  __n128 result;
  uint8_t v19[16];

  v4 = (float64x2_t *)(a1 + 3024);
  v5 = a1 + 2748;
  v6 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v19 = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Get BLE Scan Stat for Metric", v19, 2u);
  }
  Current = CFAbsoluteTimeGetCurrent();
  v8 = *(double *)(a1 + 2728);
  v9 = ((Current - v8) * 1000.0);
  if (Current < v8)
    v9 = 0;
  *(_DWORD *)a2 = v9;
  *(_OWORD *)(a2 + 4) = *(_OWORD *)v5;
  *(_OWORD *)(a2 + 20) = *(_OWORD *)(v5 + 16);
  *(_OWORD *)(a2 + 36) = *(_OWORD *)(v5 + 32);
  v10 = (float64x2_t)vdupq_n_s64(0x408F400000000000uLL);
  v11 = vuzp1q_s32((int32x4_t)vcvtq_u64_f64(vmulq_f64(*(float64x2_t *)(v5 + 52), v10)), (int32x4_t)vcvtq_u64_f64(vmulq_f64(*(float64x2_t *)(v5 + 68), v10)));
  v12 = vmulq_f64(*(float64x2_t *)(v5 + 84), v10);
  *(_QWORD *)(a2 + 52) = *(_QWORD *)(a1 + 2736);
  v13 = (int32x4_t)vcvtq_u64_f64(vmulq_f64(*(float64x2_t *)(v5 + 100), v10));
  *(_DWORD *)(a2 + 60) = *(_DWORD *)(a1 + 2744);
  *(int32x4_t *)(a2 + 64) = v11;
  *(int32x4_t *)(a2 + 80) = vuzp1q_s32((int32x4_t)vcvtq_u64_f64(v12), v13);
  v14 = vuzp1q_s32((int32x4_t)vcvtq_u64_f64(vmulq_f64(*(float64x2_t *)(v5 + 148), v10)), (int32x4_t)vcvtq_u64_f64(vmulq_f64(*(float64x2_t *)(v5 + 164), v10)));
  *(int32x4_t *)(a2 + 96) = vuzp1q_s32((int32x4_t)vcvtq_u64_f64(vmulq_f64(*(float64x2_t *)(v5 + 116), v10)), (int32x4_t)vcvtq_u64_f64(vmulq_f64(*(float64x2_t *)(v5 + 132), v10)));
  *(int32x4_t *)(a2 + 112) = v14;
  v15 = vuzp1q_s32((int32x4_t)vcvtq_u64_f64(vmulq_f64(*(float64x2_t *)(v5 + 212), v10)), (int32x4_t)vcvtq_u64_f64(vmulq_f64(*(float64x2_t *)(v5 + 228), v10)));
  *(int32x4_t *)(a2 + 128) = vuzp1q_s32((int32x4_t)vcvtq_u64_f64(vmulq_f64(*(float64x2_t *)(v5 + 180), v10)), (int32x4_t)vcvtq_u64_f64(vmulq_f64(*(float64x2_t *)(v5 + 196), v10)));
  *(int32x4_t *)(a2 + 144) = v15;
  v16 = vuzp1q_s32((int32x4_t)vcvtq_u64_f64(vmulq_f64(*v4, v10)), (int32x4_t)vcvtq_u64_f64(vmulq_f64(v4[1], v10)));
  *(int32x4_t *)(a2 + 160) = vuzp1q_s32((int32x4_t)vcvtq_u64_f64(vmulq_f64(*(float64x2_t *)(v5 + 244), v10)), (int32x4_t)vcvtq_u64_f64(vmulq_f64(*(float64x2_t *)(v5 + 260), v10)));
  *(int32x4_t *)(a2 + 176) = v16;
  v17 = vuzp1q_s32((int32x4_t)vcvtq_u64_f64(vmulq_f64(v4[4], v10)), (int32x4_t)vcvtq_u64_f64(vmulq_f64(v4[5], v10)));
  *(int32x4_t *)(a2 + 192) = vuzp1q_s32((int32x4_t)vcvtq_u64_f64(vmulq_f64(v4[2], v10)), (int32x4_t)vcvtq_u64_f64(vmulq_f64(v4[3], v10)));
  *(int32x4_t *)(a2 + 208) = v17;
  *(int32x2_t *)(a2 + 224) = vmovn_s64((int64x2_t)vcvtq_u64_f64(vmulq_f64(*(float64x2_t *)(a1 + 3120), v10)));
  sub_10066CD14(a1);
  return result;
}

uint64_t sub_1006853E8()
{
  return 1;
}

void sub_1006853F4(uint64_t a1)
{
  uint64_t v2;
  _QWORD v3[5];

  v2 = sub_1000419F4();
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100685DC0;
  v3[3] = &unk_100917378;
  v3[4] = a1;
  sub_100041A34(v2, v3);
}

void sub_100685454(uint64_t a1)
{
  uint64_t v2;
  _QWORD v3[5];

  v2 = sub_1000419F4();
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100685DCC;
  v3[3] = &unk_100917378;
  v3[4] = a1;
  sub_100041A34(v2, v3);
}

uint64_t sub_1006854B8()
{
  return 1;
}

void sub_1006854C4(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD v3[5];

  v1 = a1 - 112;
  v2 = sub_1000419F4();
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100685DC0;
  v3[3] = &unk_100917378;
  v3[4] = v1;
  sub_100041A34(v2, v3);
}

void sub_100685524(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD v3[5];

  v1 = a1 - 120;
  v2 = sub_1000419F4();
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100685DCC;
  v3[3] = &unk_100917378;
  v3[4] = v1;
  sub_100041A34(v2, v3);
}

_QWORD *sub_100685584(_QWORD *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;

  if (a4)
  {
    v6 = result;
    sub_1000B6ABC(result, a4);
    result = (_QWORD *)sub_1006855E0((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_1006855D8(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_1006855E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;

  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      *(_QWORD *)a4 = *(id *)v6;
      *(_QWORD *)(a4 + 8) = *(id *)(v6 + 8);
      *(_OWORD *)(a4 + 16) = *(_OWORD *)(v6 + 16);
      v8 = *(_OWORD *)(v6 + 48);
      v7 = *(_OWORD *)(v6 + 64);
      v9 = *(_OWORD *)(v6 + 32);
      *(_OWORD *)(a4 + 78) = *(_OWORD *)(v6 + 78);
      *(_OWORD *)(a4 + 48) = v8;
      *(_OWORD *)(a4 + 64) = v7;
      *(_OWORD *)(a4 + 32) = v9;
      a4 += 96;
      v6 += 96;
    }
    while (v6 != a3);
  }
  return a4;
}

void sub_100685660(uint64_t *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8;
  id *v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char v15;
  char v16;

  v8 = (uint64_t)(a1 + 2);
  v9 = (id *)*a1;
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 5) < a4)
  {
    sub_1006857B8(a1);
    if (a4 > 0x2AAAAAAAAAAAAAALL)
      abort();
    v10 = 0x5555555555555556 * ((a1[2] - *a1) >> 5);
    if (v10 <= a4)
      v10 = a4;
    if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 5) >= 0x155555555555555)
      v11 = 0x2AAAAAAAAAAAAAALL;
    else
      v11 = v10;
    sub_1000B6ABC(a1, v11);
    v12 = sub_1006855E0(v8, a2, a3, a1[1]);
    goto LABEL_11;
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[1] - (uint64_t)v9) >> 5) < a4)
  {
    v13 = a2 + 32 * ((a1[1] - (uint64_t)v9) >> 5);
    sub_1006857F0((int)&v15, a2, v13, v9);
    v12 = sub_1006855E0(v8, v13, a3, a1[1]);
LABEL_11:
    a1[1] = v12;
    return;
  }
  sub_1006857F0((int)&v16, a2, a3, v9);
  sub_1000B5564((uint64_t)a1, v14);
}

void sub_1006857A8(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_1006857B0(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_1006857B8(uint64_t *a1)
{
  if (*a1)
  {
    sub_1000B5564((uint64_t)a1, *a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t sub_1006857F0(int a1, uint64_t a2, uint64_t a3, id *location)
{
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;

  v5 = a2;
  if (a2 == a3)
    return a2;
  v6 = a3;
  do
  {
    objc_storeStrong(location, *(id *)v5);
    objc_storeStrong(location + 1, *(id *)(v5 + 8));
    *((_OWORD *)location + 1) = *(_OWORD *)(v5 + 16);
    v7 = *(_OWORD *)(v5 + 32);
    v8 = *(_OWORD *)(v5 + 48);
    v9 = *(_OWORD *)(v5 + 64);
    *(_OWORD *)((char *)location + 78) = *(_OWORD *)(v5 + 78);
    *((_OWORD *)location + 3) = v8;
    *((_OWORD *)location + 4) = v9;
    *((_OWORD *)location + 2) = v7;
    location += 12;
    v5 += 96;
  }
  while (v5 != v6);
  return v6;
}

void sub_10068587C(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  int v4;
  _QWORD *v5;
  unint64_t v6;
  unint64_t v7;
  _QWORD *v8;

  v2 = a2;
  v4 = *(_DWORD *)(a1 + 8);
  v5 = *(_QWORD **)a1;
  if (v4)
  {
    if ((64 - v4) >= a2)
      v6 = a2;
    else
      v6 = (64 - v4);
    *v5++ &= ~((0xFFFFFFFFFFFFFFFFLL >> (64 - v4 - v6)) & (-1 << v4));
    v2 = a2 - v6;
    *(_QWORD *)a1 = v5;
  }
  v7 = v2 >> 6;
  if (v2 >= 0x40)
    bzero(v5, 8 * v7);
  if ((v2 & 0x3F) != 0)
  {
    v8 = &v5[v7];
    *(_QWORD *)a1 = v8;
    *v8 &= ~(0xFFFFFFFFFFFFFFFFLL >> -(v2 & 0x3F));
  }
}

uint64_t sub_100685928(uint64_t a1, __int128 **a2, __int128 **a3, char a4, char a5)
{
  uint64_t v7;
  void *v8;
  uint64_t v9;
  void *v10;

  *(_BYTE *)a1 = a4 & 1;
  *(_BYTE *)(a1 + 1) = (a4 & 2) != 0;
  *(_BYTE *)(a1 + 2) = 0;
  *(_BYTE *)(a1 + 3) = a5;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  sub_1000B61B8((char *)(a1 + 8), *a2, a2[1], 0xCCCCCCCCCCCCCCCDLL * (((char *)a2[1] - (char *)*a2) >> 2));
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  sub_1000B61B8((char *)(a1 + 32), *a3, a3[1], 0xCCCCCCCCCCCCCCCDLL * (((char *)a3[1] - (char *)*a3) >> 2));
  *(_WORD *)(a1 + 121) = 0;
  *(_WORD *)(a1 + 124) = 0;
  *(_QWORD *)(a1 + 176) = 0;
  *(_BYTE *)(a1 + 184) = 0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_QWORD *)(a1 + 128) = 0;
  *(_WORD *)(a1 + 136) = 0;
  *(_DWORD *)(a1 + 142) = 0;
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 160) = 0;
  *(_DWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 188) = 0;
  *(_BYTE *)(a1 + 196) = 0;
  *(_WORD *)(a1 + 197) = 257;
  *(_DWORD *)(a1 + 199) = 0;
  *(_BYTE *)(a1 + 203) = 8;
  *(_BYTE *)(a1 + 280) = 0;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_BYTE *)(a1 + 281) = 1;
  *(_DWORD *)(a1 + 282) = 0;
  *(_BYTE *)(a1 + 286) = 1;
  *(_DWORD *)(a1 + 320) = 0;
  *(_DWORD *)(a1 + 287) = 0;
  *(_WORD *)(a1 + 291) = 0;
  *(_QWORD *)(a1 + 309) = 0;
  *(_QWORD *)(a1 + 294) = 0;
  *(_QWORD *)(a1 + 302) = 0;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_BYTE *)(a1 + 376) = 1;
  *(_DWORD *)(a1 + 384) = 0;
  *(_QWORD *)(a1 + 456) = 0;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_OWORD *)(a1 + 440) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  v7 = objc_claimAutoreleasedReturnValue(+[NSMutableArray array](NSMutableArray, "array"));
  v8 = *(void **)(a1 + 88);
  *(_QWORD *)(a1 + 88) = v7;

  *(_BYTE *)(a1 + 4) = 0;
  v9 = objc_claimAutoreleasedReturnValue(+[NSSet set](NSSet, "set"));
  v10 = *(void **)(a1 + 152);
  *(_QWORD *)(a1 + 152) = v9;

  return a1;
}

void sub_100685AC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  uint64_t v10;
  void **v11;
  void *v13;

  v13 = *v11;
  if (*v11)
  {
    *(_QWORD *)(v10 + 16) = v13;
    operator delete(v13);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *sub_100685B74(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;

  v5 = *(_QWORD *)(a2 + 8);
  *a1 = &off_100918258;
  a1[1] = v5;
  if (v5)
    sub_10003C37C(v5);
  v6 = *(_QWORD *)(a3 + 8);
  a1[2] = &off_100918258;
  a1[3] = v6;
  if (v6)
    sub_10003C37C(v6);
  return a1;
}

void sub_100685BC8(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  unsigned int *v4;

  *v1 = v2;
  v4 = (unsigned int *)v1[1];
  if (v4)
    sub_100056AAC(v4);
  _Unwind_Resume(exception_object);
}

uint64_t sub_100685BE4(int8x8_t *a1, unsigned int a2, uint64_t a3, unsigned int a4, _BYTE *a5)
{
  unint64_t v5;

  v5 = a4 - (unint64_t)a2 + 8 * (a3 - (_QWORD)a1);
  if (*a5)
    return sub_100685C04(a1, a2, v5);
  else
    return sub_100685CA8((uint64_t *)a1, a2, v5);
}

uint64_t sub_100685C04(int8x8_t *a1, unsigned int a2, unint64_t a3)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint8x8_t v6;
  int8x8_t v7;
  uint8x8_t v8;
  uint8x8_t v9;

  v3 = a2;
  if (a2)
  {
    if (64 - a2 >= a3)
      v4 = a3;
    else
      v4 = 64 - a2;
    v5 = (uint64_t)*a1++;
    v6 = (uint8x8_t)vcnt_s8((int8x8_t)((0xFFFFFFFFFFFFFFFFLL >> (64 - a2 - v4)) & (-1 << a2) & v5));
    v6.i16[0] = vaddlv_u8(v6);
    v3 = v6.u32[0];
    a3 -= v4;
  }
  if (a3 >= 0x40)
  {
    do
    {
      v7 = *a1++;
      v8 = (uint8x8_t)vcnt_s8(v7);
      v8.i16[0] = vaddlv_u8(v8);
      v3 += v8.u32[0];
      a3 -= 64;
    }
    while (a3 > 0x3F);
  }
  if (a3)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)(*(_QWORD *)a1 & (0xFFFFFFFFFFFFFFFFLL >> -(char)a3)));
    v9.i16[0] = vaddlv_u8(v9);
    v3 += v9.u32[0];
  }
  return v3;
}

uint64_t sub_100685CA8(uint64_t *a1, unsigned int a2, unint64_t a3)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint8x8_t v6;
  uint64_t v7;
  uint8x8_t v8;
  uint8x8_t v9;

  v3 = a2;
  if (a2)
  {
    if (64 - a2 >= a3)
      v4 = a3;
    else
      v4 = 64 - a2;
    v5 = *a1++;
    v6 = (uint8x8_t)vcnt_s8((int8x8_t)((0xFFFFFFFFFFFFFFFFLL >> (64 - a2 - v4)) & (-1 << a2) & ~v5));
    v6.i16[0] = vaddlv_u8(v6);
    v3 = v6.u32[0];
    a3 -= v4;
  }
  if (a3 >= 0x40)
  {
    do
    {
      v7 = *a1++;
      v8 = (uint8x8_t)vcnt_s8((int8x8_t)~v7);
      v8.i16[0] = vaddlv_u8(v8);
      v3 += v8.u32[0];
      a3 -= 64;
    }
    while (a3 > 0x3F);
  }
  if (a3)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)((0xFFFFFFFFFFFFFFFFLL >> -(char)a3) & ~*a1));
    v9.i16[0] = vaddlv_u8(v9);
    v3 += v9.u32[0];
  }
  return v3;
}

void sub_100685D58()
{
  operator delete();
}

uint64_t sub_100685D6C(uint64_t a1)
{
  if (qword_100977FB0 != -1)
    dispatch_once(&qword_100977FB0, &stru_10093F438);
  return sub_100680E30((uint64_t)off_100977FA8, *(_QWORD *)(a1 + 24), a1);
}

uint64_t sub_100685DC0(uint64_t a1)
{
  return sub_100004AE4(*(_QWORD *)(a1 + 32), 0);
}

uint64_t sub_100685DCC(uint64_t a1)
{
  return sub_100004AE4(*(_QWORD *)(a1 + 32), 0);
}

void sub_100685DD8(id a1)
{
  operator new();
}

void sub_100685E18()
{
  operator delete();
}

void sub_100685E3C(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    sub_100685E3C(a1, *a2);
    sub_100685E3C(a1, a2[1]);
    sub_100685E84(a2 + 4);
    operator delete(a2);
  }
}

void sub_100685E84(_QWORD *a1)
{
  unsigned int *v2;
  unsigned int *v3;

  a1[2] = &off_100918258;
  v2 = (unsigned int *)a1[3];
  if (v2)
    sub_100056AAC(v2);
  *a1 = &off_100918258;
  v3 = (unsigned int *)a1[1];
  if (v3)
    sub_100056AAC(v3);
}

void sub_100685ED0(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    sub_100685ED0(a1, *a2);
    sub_100685ED0(a1, a2[1]);
    sub_100685F18(a2 + 4);
    operator delete(a2);
  }
}

void sub_100685F18(_QWORD *a1)
{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int *v4;
  unsigned int *v5;
  unsigned int *v6;

  a1[10] = &off_100918298;
  v2 = (unsigned int *)a1[11];
  if (v2)
    sub_100056AAC(v2);
  a1[8] = &off_100918298;
  v3 = (unsigned int *)a1[9];
  if (v3)
    sub_100056AAC(v3);
  a1[6] = &off_100918298;
  v4 = (unsigned int *)a1[7];
  if (v4)
    sub_100056AAC(v4);
  a1[4] = &off_100918298;
  v5 = (unsigned int *)a1[5];
  if (v5)
    sub_100056AAC(v5);
  a1[2] = &off_100918298;
  v6 = (unsigned int *)a1[3];
  if (v6)
    sub_100056AAC(v6);
}

void sub_100685F94(id a1)
{
  operator new();
}

void sub_100685FD4()
{
  operator delete();
}

void sub_100685FF8(id a1)
{
  operator new();
}

void sub_100686038()
{
  operator delete();
}

void sub_10068605C(id a1)
{
  operator new();
}

void sub_100686174()
{
  operator delete();
}

void sub_100686198(id a1)
{
  operator new();
}

void sub_1006861D8()
{
  operator delete();
}

void sub_1006861FC(id a1)
{
  operator new();
}

void sub_10068623C()
{
  operator delete();
}

void sub_100686260(id a1)
{
  operator new();
}

void sub_1006862A0()
{
  operator delete();
}

void sub_1006862C4(id a1)
{
  operator new();
}

void sub_100686304()
{
  operator delete();
}

uint64_t sub_100686328(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  char *v11;
  char *v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  _QWORD v18[5];

  v2 = *a1;
  v3 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 5);
  v4 = v3 + 1;
  if (v3 + 1 > 0x2AAAAAAAAAAAAAALL)
    abort();
  v8 = a1[2];
  v7 = (uint64_t)(a1 + 2);
  v9 = 0xAAAAAAAAAAAAAAABLL * ((v8 - v2) >> 5);
  if (2 * v9 > v4)
    v4 = 2 * v9;
  if (v9 >= 0x155555555555555)
    v10 = 0x2AAAAAAAAAAAAAALL;
  else
    v10 = v4;
  v18[4] = v7;
  if (v10)
    v11 = (char *)sub_1000B5B70(v7, v10);
  else
    v11 = 0;
  v12 = &v11[96 * v3];
  v18[0] = v11;
  v18[1] = v12;
  v18[3] = &v11[96 * v10];
  *(_QWORD *)v12 = *(id *)a2;
  *((_QWORD *)v12 + 1) = *(id *)(a2 + 8);
  *((_OWORD *)v12 + 1) = *(_OWORD *)(a2 + 16);
  v14 = *(_OWORD *)(a2 + 48);
  v13 = *(_OWORD *)(a2 + 64);
  v15 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v12 + 78) = *(_OWORD *)(a2 + 78);
  *((_OWORD *)v12 + 3) = v14;
  *((_OWORD *)v12 + 4) = v13;
  *((_OWORD *)v12 + 2) = v15;
  v18[2] = v12 + 96;
  sub_10003C3F0(a1, v18);
  v16 = a1[1];
  sub_10003C46C((uint64_t)v18);
  return v16;
}

void sub_100686438(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_10003C46C((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_10068644C(uint64_t a1, uint64_t a2)
{
  uint64_t i;

  for (i = *(_QWORD *)(a1 + 16); i != a2; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 96;

  }
}

void sub_1006864A4(id a1)
{
  operator new();
}

void sub_1006864E4()
{
  operator delete();
}

void sub_100686508(id a1)
{
  operator new();
}

void sub_100686534(void ***a1)
{
  void **v1;
  id *v2;
  id *v4;
  void *v5;
  id *v6;

  v1 = *a1;
  v2 = (id *)**a1;
  if (v2)
  {
    v4 = (id *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4 - 5;

        v4 = v6;
      }
      while (v6 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

_QWORD *sub_1006865A8(_QWORD *result, __int128 *a2, __int128 *a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  __int128 v8;

  if (a4)
  {
    v6 = result;
    result = sub_1004BF5FC(result, a4);
    v7 = v6[1];
    while (a2 != a3)
    {
      v8 = *a2;
      *(_OWORD *)(v7 + 12) = *(__int128 *)((char *)a2 + 12);
      *(_OWORD *)v7 = v8;
      result = objc_retainBlock(*((id *)a2 + 4));
      *(_QWORD *)(v7 + 32) = result;
      v7 += 40;
      a2 = (__int128 *)((char *)a2 + 40);
    }
    v6[1] = v7;
  }
  return result;
}

void sub_100686618(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;

  v2 = *(_QWORD **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      sub_100685F18(v2 + 4);
    operator delete(v2);
  }
}

uint64_t *sub_10068665C(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_1006866B0(a1, *(unsigned __int8 **)a2, (unsigned __int8 *)(a2 + 8));
  return a1;
}

void sub_100686698(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_10001A82C(v1, *(_QWORD **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_1006866B0(uint64_t *result, unsigned __int8 *a2, unsigned __int8 *a3)
{
  unsigned __int8 *v4;
  uint64_t **v5;
  uint64_t *v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  BOOL v9;

  if (a2 != a3)
  {
    v4 = a2;
    v5 = (uint64_t **)result;
    v6 = result + 1;
    do
    {
      result = sub_1000677F8(v5, v6, v4 + 25, v4 + 25);
      v7 = (unsigned __int8 *)*((_QWORD *)v4 + 1);
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = *(unsigned __int8 **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (unsigned __int8 *)*((_QWORD *)v4 + 2);
          v9 = *(_QWORD *)v8 == (_QWORD)v4;
          v4 = v8;
        }
        while (!v9);
      }
      v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

_OWORD *sub_100686734(uint64_t **a1, const void **a2, uint64_t a3, _OWORD **a4)
{
  void **v6;
  _OWORD *v7;
  uint64_t **v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD v12[2];
  uint64_t v13;
  uint64_t v14;

  v14 = 0;
  v6 = (void **)sub_10001F574((uint64_t)a1, &v14, a2);
  v7 = *v6;
  if (!*v6)
  {
    v8 = (uint64_t **)v6;
    v13 = 0;
    v7 = operator new(0x50uLL);
    v12[1] = a1 + 1;
    v9 = *a4;
    v10 = *((_QWORD *)*a4 + 2);
    v7[2] = **a4;
    *((_QWORD *)v7 + 6) = v10;
    v9[1] = 0;
    v9[2] = 0;
    *v9 = 0;
    *((_QWORD *)v7 + 9) = 0;
    *((_QWORD *)v7 + 8) = 0;
    *((_QWORD *)v7 + 7) = v7 + 4;
    LOBYTE(v13) = 1;
    sub_100004078(a1, v14, v8, (uint64_t *)v7);
    v12[0] = 0;
    sub_1005BD754((uint64_t)v12, 0);
  }
  return v7;
}

void sub_100686808(id a1)
{
  operator new();
}

void sub_100686848()
{
  operator delete();
}

_QWORD *sub_10068686C(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v5;
  _QWORD *v6;
  _BOOL4 v7;
  _QWORD *v8;

  v2 = (_QWORD *)(a1 + 8);
  v3 = *(_QWORD **)(a1 + 8);
  if (!v3)
    return v2;
  v5 = a1 + 16;
  v6 = (_QWORD *)(a1 + 8);
  do
  {
    v7 = sub_1006868F8(v5, (uint64_t)(v3 + 4), a2);
    v8 = v3 + 1;
    if (!v7)
    {
      v8 = v3;
      v6 = v3;
    }
    v3 = (_QWORD *)*v8;
  }
  while (*v8);
  if (v6 == v2 || sub_1006868F8(v5, a2, (uint64_t)(v6 + 4)))
    return v2;
  return v6;
}

BOOL sub_1006868F8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (sub_1005F5738(a2, a3))
    return 1;
  if (sub_1005F5738(a3, a2))
    return 0;
  return sub_1005F5738(a2 + 16, a3 + 16);
}

uint64_t *sub_100686958(uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t **v6;
  uint64_t *v7;
  uint64_t **v8;
  uint64_t *v10[3];
  uint64_t v11;

  v11 = 0;
  v6 = (uint64_t **)sub_100686A0C((uint64_t)a1, &v11, a2);
  v7 = *v6;
  if (!*v6)
  {
    v8 = v6;
    memset(v10, 0, sizeof(v10));
    sub_100686AA8((uint64_t)a1, a4, v10);
    sub_100004078(a1, v11, v8, v10[0]);
    v7 = v10[0];
    v10[0] = 0;
    sub_100686B90((uint64_t)v10, 0);
  }
  return v7;
}

_QWORD *sub_100686A0C(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD **)(a1 + 8);
  if (v4)
  {
    v7 = a1 + 16;
    do
    {
      while (1)
      {
        v8 = v4;
        v9 = (uint64_t)(v4 + 4);
        if (!sub_1006868F8(v7, a3, (uint64_t)(v4 + 4)))
          break;
        v4 = (_QWORD *)*v8;
        v5 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (!sub_1006868F8(v7, v9, a3))
        break;
      v5 = v8 + 1;
      v4 = (_QWORD *)v8[1];
    }
    while (v4);
  }
  else
  {
    v8 = (_QWORD *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

_QWORD *sub_100686AA8@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X2>, _QWORD *a3@<X8>)
{
  uint64_t v5;
  _QWORD *v6;
  _QWORD *result;

  v5 = a1 + 8;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v6 = operator new(0x48uLL);
  *a3 = v6;
  a3[1] = v5;
  *((_BYTE *)a3 + 16) = 0;
  result = sub_100686B20(v6 + 4, *a2);
  v6[8] = 0;
  *((_BYTE *)a3 + 16) = 1;
  return result;
}

void sub_100686B08(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_100686B90(v1, 0);
  _Unwind_Resume(a1);
}

_QWORD *sub_100686B20(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = *(_QWORD *)(a2 + 8);
  *a1 = &off_100918258;
  a1[1] = v4;
  if (v4)
    sub_10003C37C(v4);
  v5 = *(_QWORD *)(a2 + 24);
  a1[2] = &off_100918258;
  a1[3] = v5;
  if (v5)
    sub_10003C37C(v5);
  return a1;
}

void sub_100686B74(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  unsigned int *v4;

  *v1 = v2;
  v4 = (unsigned int *)v1[1];
  if (v4)
    sub_100056AAC(v4);
  _Unwind_Resume(exception_object);
}

void sub_100686B90(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;

  v2 = *(_QWORD **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      sub_100685E84(v2 + 4);
    operator delete(v2);
  }
}

void sub_100686BD4(void ***a1)
{
  void **v1;
  _QWORD *v2;
  _QWORD *v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 4;
        sub_100686C58((uint64_t)(v1 + 2), v4);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_100686C58(uint64_t a1, _QWORD *a2)
{
  unsigned int *v3;
  unsigned int *v4;

  a2[2] = &off_100918258;
  v3 = (unsigned int *)a2[3];
  if (v3)
    sub_100056AAC(v3);
  *a2 = &off_100918258;
  v4 = (unsigned int *)a2[1];
  if (v4)
    sub_100056AAC(v4);
}

_QWORD *sub_100686CA4(uint64_t *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v5 = *a1;
  v4 = a1[1];
  result = (_QWORD *)a2[1];
  while (v4 != v5)
  {
    v4 -= 32;
    result = sub_100686D28(result - 4, v4);
  }
  a2[1] = result;
  v7 = *a1;
  *a1 = (uint64_t)result;
  a2[1] = v7;
  v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

_QWORD *sub_100686D28(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;

  v4 = *(_QWORD *)(a2 + 8);
  *a1 = &off_100918258;
  a1[1] = v4;
  if (v4)
    sub_10003C37C(v4);
  v5 = *(_QWORD *)(a2 + 24);
  a1[2] = &off_100918258;
  a1[3] = v5;
  if (v5)
    sub_10003C37C(v5);
  return a1;
}

void sub_100686D7C(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  uint64_t v2;
  unsigned int *v4;

  *v1 = v2;
  v4 = (unsigned int *)v1[1];
  if (v4)
    sub_100056AAC(v4);
  _Unwind_Resume(exception_object);
}

void **sub_100686D98(void **a1)
{
  sub_100686DC8(a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void sub_100686DC8(_QWORD *a1)
{
  uint64_t i;
  uint64_t v2;
  uint64_t v4;

  v2 = a1[1];
  for (i = a1[2]; i != v2; i = a1[2])
  {
    v4 = a1[4];
    a1[2] = i - 32;
    sub_100686C58(v4, (_QWORD *)(i - 32));
  }
}

uint64_t sub_100686E0C(uint64_t **a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t *v4;

  v3 = sub_10068686C((uint64_t)a1, a2);
  if (a1 + 1 == (uint64_t **)v3)
    return 0;
  v4 = v3;
  sub_1000040CC(a1, v3);
  sub_100685E84(v4 + 4);
  operator delete(v4);
  return 1;
}

uint64_t sub_100686E64(_QWORD *a1)
{
  int v2;
  const char *v4;

  if (a1 + 4 == sub_100686ED0(a1 + 1, 0, 0xC0uLL) && v2 == 0)
    return *a1;
  v4 = (const char *)sub_100686EB4("bitset to_ullong overflow error");
  return sub_100686EB4(v4);
}

uint64_t sub_100686EB4(const char *a1)
{
  std::__libcpp_verbose_abort("overflow_error was thrown in -fno-exceptions mode with message \"%s\"", a1);
  return sub_100686ED0();
}

_QWORD *sub_100686ED0(_QWORD *result, unsigned int a2, unint64_t a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;

  if (!a2)
  {
LABEL_8:
    if (a3 >= 0x40)
    {
      do
      {
        if (*result)
          break;
        ++result;
        a3 -= 64;
      }
      while (a3 > 0x3F);
    }
    return result;
  }
  v3 = 64 - a2;
  if (v3 >= a3)
    v4 = a3;
  else
    v4 = 64 - a2;
  if (((0xFFFFFFFFFFFFFFFFLL >> (64 - a2 - v4)) & (-1 << a2) & *result) != 0)
    return result;
  if (v3 < a3)
  {
    a3 -= v4;
    ++result;
    goto LABEL_8;
  }
  v5 = a2 + a3;
  v6 = v5 - 63;
  if ((uint64_t)(v5 - 63) < 0)
    v6 = a2 + a3;
  v7 = v6 >> 6;
  v8 = v5 >> 6;
  if ((a3 & 0x8000000000000000) != 0)
    v8 = v7;
  result += v8;
  return result;
}

void sub_100686FCC(id a1)
{
  operator new();
}

void sub_10068700C()
{
  operator delete();
}

void sub_100687030(id a1)
{
  operator new();
}

void sub_100687070()
{
  operator delete();
}

void sub_100687094(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, a5, 8u);
}

double sub_1006870A0(double a1)
{
  return a1 * 0.625;
}

void sub_1006870FC(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 0x2Au);
}

void sub_100687114()
{
  void *v0;

  v0 = objc_autoreleasePoolPush();
  sub_100069B04((uint64_t)&unk_100994098, &xmmword_1007434D4, 16);
  objc_autoreleasePoolPop(v0);
}

uint64_t sub_100687154(uint64_t a1)
{
  return *(unsigned __int8 *)(*(_QWORD *)(a1 + 8) + 1);
}

id sub_100687160(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v4;
  uint64_t i;
  uint64_t v6;
  NSObject *v7;
  int v8;
  void **v9;
  void **v10;
  _BYTE *v11;
  __int128 v12;
  void *v13;
  int v14;
  int v15;
  void *v16;
  uint64_t v17;
  NSData *v18;
  void *v19;
  uint64_t v20;
  NSData *v21;
  void *v22;
  void *v23;
  NSObject *v24;
  void **v25;
  id v27;
  _BYTE __p[12];
  __int16 v29;
  void *v30;
  char v31;
  void *v32[2];
  int v33;
  char v34;
  _BYTE buf[22];

  v27 = (id)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](NSMutableArray, "array"));
  v4 = *(_QWORD *)(a1 + 8);
  v6 = *(_QWORD *)(v4 + 96);
  for (i = *(_QWORD *)(v4 + 104); v6 != i; v6 += 104)
  {
    v7 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
    {
      sub_10006887C((uint64_t)a2, v32);
      v8 = v34;
      v9 = (void **)v32[0];
      sub_100563FC4(v6);
      v10 = v32;
      if (v8 < 0)
        v10 = v9;
      v11 = __p;
      if (v31 < 0)
        v11 = *(_BYTE **)__p;
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = v10;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = v11;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "enhancedUUIDRulesForUUID uuid:%s filter:%s", buf, 0x16u);
      if (v31 < 0)
        operator delete(*(void **)__p);
      if (v34 < 0)
        operator delete(v32[0]);
    }
    if (*(_DWORD *)(v6 + 96) == 1)
    {
      v12 = *(_OWORD *)(v6 + 20);
      v33 = *(_DWORD *)(v6 + 36);
      *(_OWORD *)v32 = v12;
      if (sub_100072DF0((unsigned __int8 *)v32, a2))
      {
        v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary"));
        v14 = *(char *)(v6 + 72);
        v15 = *a2;
        if (v15 == 2 || v15 == 16)
        {
          *(_QWORD *)buf = 0;
          *(_QWORD *)&buf[8] = 0;
          sub_1000689E4(a2, buf);
          if (sub_10003F8C4(v6 + 40))
          {
            if (sub_10003F8C4(v6 + 56) && *(_BYTE *)(v6 + 79))
            {
              if (v14 >= 0)
                LOBYTE(v14) = -87;
              v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", buf, *a2));
              objc_msgSend(v13, "setObject:forKeyedSubscript:", v16, CFSTR("uuid"));

              v17 = sub_10003EB18(v6 + 40);
              v18 = +[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", v17, sub_10003F8C4(v6 + 40));
              v19 = (void *)objc_claimAutoreleasedReturnValue(v18);
              objc_msgSend(v13, "setObject:forKeyedSubscript:", v19, CFSTR("data"));

              v20 = sub_10003EB18(v6 + 56);
              v21 = +[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", v20, sub_10003F8C4(v6 + 56));
              v22 = (void *)objc_claimAutoreleasedReturnValue(v21);
              objc_msgSend(v13, "setObject:forKeyedSubscript:", v22, CFSTR("mask"));

              v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithChar:](NSNumber, "numberWithChar:", v14));
              objc_msgSend(v13, "setObject:forKeyedSubscript:", v23, CFSTR("rssi"));

              objc_msgSend(v27, "addObject:", v13);
              v24 = qword_100999828;
              if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
              {
                sub_100563FC4(v6);
                v25 = v32;
                if (v34 < 0)
                  v25 = (void **)v32[0];
                *(_DWORD *)__p = 136315394;
                *(_QWORD *)&__p[4] = v25;
                v29 = 2112;
                v30 = v13;
                _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_INFO, "enhancedRule %s converted to %@", __p, 0x16u);
                if (v34 < 0)
                  operator delete(v32[0]);
              }
            }
          }
        }

      }
    }
  }
  return v27;
}

void sub_1006874F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  void *v22;

  _Unwind_Resume(a1);
}

uint64_t sub_100687570(uint64_t a1)
{
  return (*(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 124) >> 1) & 1;
}

uint64_t sub_100687580(uint64_t a1)
{
  return (*(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 124) >> 2) & 1;
}

BOOL sub_100687590(uint64_t a1)
{
  return *(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 124) - 1 < 0xFF;
}

uint64_t sub_1006875A8(uint64_t a1, unsigned __int8 *a2, uint64_t a3, void **a4, void *a5)
{
  void *v5;
  id v10;
  void *v11;
  _BYTE *v12;
  unint64_t v13;
  _WORD *v14;
  int v15;
  uint64_t v16;
  id v17;
  id v18;
  uint64_t v19;
  uint64_t v20;
  id v21;
  uint64_t v22;
  char v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  NSObject *v36;
  _BYTE *v37;
  int v38;
  NSObject *v39;
  unsigned int v40;
  _QWORD *v41;
  NSObject *v43;
  _BYTE *v44;
  uint64_t v45;
  int v46;
  _BOOL4 v47;
  char v48;
  _BYTE out[40];
  _BYTE __p[12];
  char v51;
  uint8_t buf[4];
  _BYTE *v53;
  uuid_t dst;

  v10 = a5;
  v11 = v10;
  v48 = 0;
  v12 = *(_BYTE **)(a3 + 8);
  if (v12[304] && !v12[370])
  {
    v19 = *(_QWORD *)(a1 + 8);
    if (!*(_BYTE *)(v19 + 122) && *(unsigned __int16 *)(v19 + 170) << 16 != 0x10000)
      goto LABEL_17;
    goto LABEL_61;
  }
  if (!v12[305])
  {
    objc_msgSend(v10, "setString:", CFSTR("default"));
    if (!sub_10003EB2C(a1))
      goto LABEL_17;
    if (!sub_10003EBC4(a1))
    {
LABEL_44:
      v25 = sub_100068124((uint64_t **)(a1 + 104), a2, a3);
      if ((v26 & 1) == 0)
      {
        v27 = v25;
        if (!v48 && (sub_10006DB10(a1, v26, a3, (uint64_t)(v25 + 6)) & 1) == 0)
        {
          v43 = qword_100999828;
          if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
          {
            sub_1003D2DB4(a2, out);
            v44 = out[23] >= 0 ? out : *(_BYTE **)out;
            *(_DWORD *)__p = 136446210;
            *(_QWORD *)&__p[4] = v44;
            _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_INFO, "Ignoring duplicate advertisement data for device \"%{public}s\"", __p, 0xCu);
            if ((out[23] & 0x80000000) != 0)
              operator delete(*(void **)out);
          }
          goto LABEL_17;
        }
        sub_100041698((uint64_t)(v27 + 6), a3);
      }
      v28 = sub_10000C5B8(a1 + 152, a2);
      if (a1 + 160 != v28)
      {
        v29 = *(uint64_t **)(v28 + 48);
        v30 = *v29;
        *(_QWORD *)(v30 + 8) = v29[1];
        *(_QWORD *)v29[1] = v30;
        --*(_QWORD *)(a1 + 144);
        operator delete(v29);
      }
      v31 = sub_10066A19C(a1 + 128, 0, 0, a2);
      *v31 = a1 + 128;
      v32 = *(_QWORD **)(a1 + 136);
      v31[1] = v32;
      *v32 = v31;
      v33 = *(_QWORD *)(a1 + 144) + 1;
      *(_QWORD *)(a1 + 136) = v31;
      *(_QWORD *)(a1 + 144) = v33;
      *(_QWORD *)out = a2;
      sub_100068084((uint64_t **)(a1 + 152), a2, (uint64_t)&unk_100740F58, (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)out)[6] = (uint64_t)v31;
      if (*(_QWORD *)(a1 + 144) <= (unint64_t)*(unsigned __int16 *)(a1 + 176))
      {
        v38 = 1;
      }
      else
      {
        memset(dst, 0, sizeof(dst));
        uuid_copy(dst, (const unsigned __int8 *)(*(_QWORD *)(a1 + 128) + 16));
        v34 = *(uint64_t **)(a1 + 128);
        v35 = *v34;
        *(_QWORD *)(v35 + 8) = v34[1];
        *(_QWORD *)v34[1] = v35;
        --*(_QWORD *)(a1 + 144);
        operator delete(v34);
        v36 = qword_100999828;
        if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
        {
          memset(out, 0, 37);
          uuid_unparse_upper(dst, out);
          sub_100091AE8(__p, out);
          v37 = v51 >= 0 ? __p : *(_BYTE **)__p;
          *(_DWORD *)buf = 136446210;
          v53 = v37;
          _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_INFO, "doesDeviceMatch: erasing last device %{public}s", buf, 0xCu);
          if (v51 < 0)
            operator delete(*(void **)__p);
        }
        sub_10068C078((uint64_t **)(a1 + 104), dst);
        sub_10068C104((uint64_t **)(a1 + 152), dst);
        v38 = 0;
      }
      v39 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEBUG))
      {
        v45 = *(_QWORD *)(a1 + 120);
        v46 = *(unsigned __int16 *)(a1 + 176);
        v47 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 64) != *(_QWORD *)(*(_QWORD *)(a1 + 8) + 72);
        *(_DWORD *)out = 134219008;
        *(_QWORD *)&out[4] = v45;
        *(_WORD *)&out[12] = 1024;
        *(_DWORD *)&out[14] = v46;
        *(_WORD *)&out[18] = 2048;
        *(_QWORD *)&out[20] = v45;
        *(_WORD *)&out[28] = 1024;
        *(_DWORD *)&out[30] = v47;
        *(_WORD *)&out[34] = 1024;
        *(_DWORD *)&out[36] = v38;
        _os_log_debug_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEBUG, "doesDeviceMatch: fAdvDataMap size:%lu fMaxNumOfReportsInMap:%d fAdvDataMap size:%lu Puck?:%d roomInMap:%d", out, 0x28u);
      }
      goto LABEL_61;
    }
    v13 = sub_10003F8C4(*(_QWORD *)(a3 + 8) + 48);
    v14 = (_WORD *)sub_10003EB18(*(_QWORD *)(a3 + 8) + 48);
    v15 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 384);
    if (v15)
    {
      if (v15 == 1)
      {
        if (sub_100687C6C(a1) && (sub_100041F48(a1, a2, a3, a4, &v48) & 1) != 0)
          goto LABEL_44;
        v17 = objc_msgSend(*(id *)(*(_QWORD *)(a1 + 8) + 56), "count");
        if (v17)
        {
          v18 = sub_100030DF4(a2);
          v5 = (void *)objc_claimAutoreleasedReturnValue(v18);
          if ((sub_100687CD4(a1, v5) & 1) != 0)
          {
LABEL_14:

            goto LABEL_44;
          }
        }
        v22 = *(_QWORD *)(a1 + 8);
        if (*(_BYTE *)(v22 + 137))
        {
          if ((sub_100687DD0(a1, a2, a3) & 1) != 0)
          {
LABEL_28:
            v23 = 1;
            goto LABEL_41;
          }
          v22 = *(_QWORD *)(a1 + 8);
        }
        if (*(_QWORD *)(v22 + 64) != *(_QWORD *)(v22 + 72))
        {
          if ((sub_100688240(a1, v14, v13, a4, &v48) & 1) != 0)
            goto LABEL_28;
          v22 = *(_QWORD *)(a1 + 8);
        }
        if (*(_QWORD *)(v22 + 96) != *(_QWORD *)(v22 + 104))
          goto LABEL_40;
        if (!v17)
          goto LABEL_17;
        goto LABEL_22;
      }
LABEL_17:
      v20 = 0;
      goto LABEL_67;
    }
    if (sub_100687C6C(a1) && !sub_100041F48(a1, a2, a3, a4, &v48))
      goto LABEL_17;
    v17 = objc_msgSend(*(id *)(*(_QWORD *)(a1 + 8) + 56), "count");
    if (v17)
    {
      v21 = sub_100030DF4(a2);
      v5 = (void *)objc_claimAutoreleasedReturnValue(v21);
      if ((sub_100687CD4(a1, v5) & 1) == 0)
      {
LABEL_22:

        goto LABEL_17;
      }
    }
    v24 = *(_QWORD *)(a1 + 8);
    if (*(_BYTE *)(v24 + 137))
    {
      if (!sub_100687DD0(a1, a2, a3))
        goto LABEL_37;
      v24 = *(_QWORD *)(a1 + 8);
    }
    if (*(_QWORD *)(v24 + 64) == *(_QWORD *)(v24 + 72))
      goto LABEL_35;
    if (sub_100688240(a1, v14, v13, a4, &v48))
    {
      v24 = *(_QWORD *)(a1 + 8);
LABEL_35:
      if (*(_QWORD *)(v24 + 96) == *(_QWORD *)(v24 + 104))
      {
        if (!v17)
          goto LABEL_44;
        goto LABEL_14;
      }
LABEL_40:
      v23 = sub_100688270(a1, a2, a3, v16, v11);
LABEL_41:
      if (v17)

      if ((v23 & 1) == 0)
        goto LABEL_17;
      goto LABEL_44;
    }
LABEL_37:
    v23 = 0;
    goto LABEL_41;
  }
  if (!*(_WORD *)(*(_QWORD *)(a1 + 8) + 124))
    goto LABEL_17;
LABEL_61:
  v40 = *(unsigned __int8 *)(a1 + 81);
  v20 = 1;
  if (v40 <= 0x20)
  {
    if (((1 << v40) & 0x100010002) != 0)
    {
      v41 = (_QWORD *)(a1 + 32);
    }
    else
    {
      if (((1 << v40) & 0x110) == 0)
        goto LABEL_67;
      v41 = (_QWORD *)(a1 + 24);
    }
    ++*v41;
  }
LABEL_67:

  return v20;
}

void sub_100687C0C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL sub_100687C6C(uint64_t a1)
{
  _BOOL8 v2;
  void *v4;
  void *v5;

  sub_10068A5D0(*(_QWORD *)(a1 + 8), &v4);
  if (v5 == v4)
  {
    v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 40) != *(_QWORD *)(*(_QWORD *)(a1 + 8) + 32);
    if (!v4)
      return v2;
    goto LABEL_3;
  }
  v2 = 1;
  if (v4)
  {
LABEL_3:
    v5 = v4;
    operator delete(v4);
  }
  return v2;
}

uint64_t sub_100687CD4(uint64_t a1, void *a2)
{
  id v3;
  NSObject *v4;
  uint64_t v5;
  int v7;
  id v8;

  v3 = a2;
  if (objc_msgSend(*(id *)(*(_QWORD *)(a1 + 8) + 56), "count")
    && objc_msgSend(*(id *)(*(_QWORD *)(a1 + 8) + 56), "containsObject:", v3))
  {
    v4 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      v7 = 138543362;
      v8 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Peer %{public}@ matched the peripheral filter", (uint8_t *)&v7, 0xCu);
    }
    v5 = 1;
  }
  else
  {
    v5 = 0;
  }

  return v5;
}

void sub_100687DB4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t sub_100687DD0(uint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  BOOL v8;
  unint64_t v9;
  unint64_t v10;
  int v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  uint64_t result;
  unsigned __int8 v24;
  NSObject *v25;
  void **v26;
  int v27;
  NSObject *v28;
  unsigned __int8 *uu;
  void *__p[2];
  __int128 v32;
  _BYTE v33[21];
  _BYTE dst[64];
  int v35;
  char v36;

  if (!*(_BYTE *)(*(_QWORD *)(a1 + 8) + 137))
    return 0;
  uuid_copy(dst, a2);
  uu = (unsigned __int8 *)a2;
  memset(&dst[16], 0, 48);
  *(_OWORD *)__p = 0u;
  v32 = 0u;
  v35 = 0;
  v36 = 0;
  memset(v33, 0, sizeof(v33));
  v5 = sub_10068C154((uint64_t **)(a1 + 184), dst, (uint64_t)dst);
  sub_10068BED8(&dst[16]);
  sub_10068BED8(__p);
  *(_QWORD *)dst = 0;
  sub_10004AD30((uint64_t)dst);
  v6 = *(__int16 *)&dst[4];
  v7 = *(__int16 *)&dst[4] + 1000 * *(int *)dst;
  v8 = v7 >= 0x3E8;
  v9 = v7 - 1000;
  if (v8)
    v10 = v9;
  else
    v10 = 0;
  v11 = *(unsigned __int8 *)(*(_QWORD *)(a3 + 8) + 216);
  if (v11 != 127)
  {
    *(_QWORD *)dst = *(int *)dst;
    *(_QWORD *)&dst[8] = v6;
    dst[16] = v11;
    sub_10068A7AC((uint64_t)(v5 + 6), (__n128 *)dst);
    *((_DWORD *)v5 + 24) += *(char *)(*(_QWORD *)(a3 + 8) + 216);
  }
  v12 = v5[11];
  if (!v12)
    goto LABEL_17;
  while (1)
  {
    v13 = v12 + v5[10] - 1;
    v14 = *(_QWORD *)(v5[7] + 8 * (v13 / 0xAA));
    v15 = v13 % 0xAA;
    v16 = (_QWORD *)(v14 + 24 * (v13 % 0xAA));
    *(_QWORD *)dst = 0;
    *(_DWORD *)dst = *v16;
    *(_WORD *)&dst[4] = v16[1];
    LODWORD(__p[0]) = v10 / 0x3E8;
    HIDWORD(__p[0]) = v10 % 0x3E8;
    if ((int)sub_100072ACC((uint64_t)dst, (uint64_t)__p) > 0)
      break;
    v17 = v5[11];
    *((_DWORD *)v5 + 24) -= *(char *)(v14 + 24 * v15 + 16);
    v5[11] = v17 - 1;
    sub_10068C630(v5 + 6, 1);
    v12 = v5[11];
    if (!v12)
      goto LABEL_17;
  }
  v18 = v5[11];
  if ((unint64_t)v18 < 0xA)
  {
LABEL_17:
    result = 0;
    *((_BYTE *)v5 + 100) = 0;
    return result;
  }
  v19 = *((unsigned __int8 *)v5 + 100);
  v20 = *(_QWORD *)(a3 + 8);
  v21 = *((int *)v5 + 24) / v18;
  if (*(_BYTE *)(v20 + 42))
    LOBYTE(v21) = v21 - *(_BYTE *)(v20 + 43);
  if (*((_BYTE *)v5 + 100))
  {
    if (byte_1007435DD[(v19 - 1)] >= (char)v21)
    {
      if ((char)v21 + 3 >= byte_1007435DD[v19])
        goto LABEL_33;
      v22 = 1;
    }
    else
    {
      v22 = -1;
    }
    v24 = v19 + v22;
    *((_BYTE *)v5 + 100) = v19 + v22;
  }
  else
  {
    if (v21 == 127)
    {
      v24 = 0;
    }
    else
    {
      v24 = 0;
      do
        *((_BYTE *)v5 + 100) = ++v24;
      while (byte_1007435DD[v24] > (char)v21);
    }
    if (!v24)
      goto LABEL_33;
  }
  v25 = qword_100999828;
  LOBYTE(v19) = v24;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    memset(dst, 0, 37);
    uuid_unparse_upper(uu, dst);
    sub_100091AE8(__p, dst);
    if ((SBYTE7(v32) & 0x80u) == 0)
      v26 = __p;
    else
      v26 = (void **)__p[0];
    v27 = *((unsigned __int8 *)v5 + 100);
    *(_DWORD *)dst = 136446722;
    *(_QWORD *)&dst[4] = v26;
    *(_WORD *)&dst[12] = 1024;
    *(_DWORD *)&dst[14] = v27;
    *(_WORD *)&dst[18] = 1024;
    *(_DWORD *)&dst[20] = (char)v21;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Device %{public}s is now at proximity level %u with an average RSSI of %d dB", dst, 0x18u);
    if (SBYTE7(v32) < 0)
      operator delete(__p[0]);
    LOBYTE(v19) = *((_BYTE *)v5 + 100);
  }
LABEL_33:
  if ((v19 - 1) >= 3u)
  {
    v28 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)dst = 136446210;
      *(_QWORD *)&dst[4] = "(info.proximityLevel > 0) && (info.proximityLevel < kRSSIThresholdsSize)";
      _os_log_fault_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", dst, 0xCu);
      LOBYTE(v19) = *((_BYTE *)v5 + 100);
    }
  }
  if (*(unsigned __int8 *)(*(_QWORD *)(a1 + 8) + 137) < v19)
    return 0;
  *(_BYTE *)(*(_QWORD *)(a3 + 8) + 218) = v19;
  return 1;
}

void sub_100688214(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  _QWORD *v3;
  va_list va;

  va_start(va, a3);
  sub_10068BED8(v3);
  sub_10068BED8((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_100688240(uint64_t a1, _WORD *a2, unint64_t a3, void **a4, _BYTE *a5)
{
  if (a3 < 3 || *(_QWORD *)(*(_QWORD *)(a1 + 8) + 64) == *(_QWORD *)(*(_QWORD *)(a1 + 8) + 72) || *a2 != 76)
    return 0;
  else
    return sub_10003EC24(a1, (uint64_t)a2, a3, a4, a5);
}

uint64_t sub_100688270(uint64_t a1, const unsigned __int8 *a2, uint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  char *v11;
  __int128 *v12;
  __int128 v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  char *v17;
  char *v18;
  __int128 v19;
  char *v20;
  char *v21;
  char *v22;
  __int128 v23;
  _QWORD *v24;
  _QWORD *v25;
  BOOL v26;
  uint64_t i;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unsigned __int8 **v32;
  _DWORD *v33;
  char v34;
  _DWORD *v35;
  char v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unsigned __int8 **v41;
  _DWORD *v42;
  id v43;
  char **v44;
  id v45;
  _OWORD *v46;
  char v47;
  NSObject *v48;
  uint64_t v49;
  void *v50;
  __int128 v51;
  char *v52;
  id v53;
  id v54;
  int v55;
  _QWORD *v56;
  _QWORD *v57;
  _DWORD *v58;
  _DWORD *v59;
  unsigned __int8 *v60;
  size_t v61;
  size_t v62;
  unsigned __int8 *v63;
  unsigned __int8 *v64;
  BOOL v65;
  char v66;
  id v67;
  char **v68;
  id v69;
  _OWORD *v70;
  NSObject *v71;
  uint64_t v72;
  __int128 *v73;
  char *v74;
  __int128 *v75;
  void **v76;
  void **v77;
  id v78;
  id v79;
  int v80;
  _QWORD *v81;
  _QWORD *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  _BOOL4 v88;
  char v89;
  size_t v90;
  unsigned __int8 *v91;
  unsigned __int8 *v92;
  id v93;
  char **v94;
  id v95;
  _OWORD *v96;
  BOOL v97;
  NSObject *v98;
  uint64_t v99;
  __int128 *v100;
  int v101;
  _QWORD *v102;
  char *v103;
  void **v104;
  void **v105;
  id v106;
  id v107;
  int v108;
  uint64_t v109;
  uint64_t v110;
  char **v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  int v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  unsigned int v119;
  _BYTE *v120;
  void *v121;
  id v122;
  _BYTE *v123;
  void *v124;
  id v125;
  _BYTE *v126;
  void *v127;
  id v128;
  id v129;
  char **v130;
  id v131;
  _OWORD *v132;
  char v133;
  NSObject *v134;
  uint64_t v135;
  __int128 *v136;
  id v137;
  int v138;
  id v139;
  id v140;
  int v141;
  uint64_t *v142;
  char *v143;
  char **v144;
  int v145;
  _QWORD *v146;
  void *v147;
  id v149;
  char *v150;
  _QWORD *v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  _QWORD *v155;
  unsigned __int8 *v156;
  uint64_t v157;
  size_t v158;
  __int128 *v159;
  uint64_t v160;
  char *v162;
  _BOOL4 v163;
  char v164;
  int v165;
  void *v166[2];
  char v167;
  void *v168[2];
  char v169;
  void *v170[2];
  char v171;
  void *v172;
  char *v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  void *v178;
  char *v179;
  char *v180;
  char **v181;
  char *v182[2];
  void **v183;
  _BYTE __p[24];
  _BYTE v185[10];
  _BYTE v186[20];
  _BYTE v187[10];
  _BYTE v188[6];
  _BYTE v189[10];
  _DWORD v190[4];
  __int128 v191;
  int v192;
  char v193;
  __int128 v194;
  int v195;
  __int128 v196;
  uint64_t v197;
  uuid_string_t out;

  v149 = a5;
  v153 = a1;
  v7 = *(_QWORD *)(a1 + 8);
  if (*(_QWORD *)(v7 + 96) == *(_QWORD *)(v7 + 104))
  {
    v86 = 1;
  }
  else
  {
    v182[0] = 0;
    v182[1] = 0;
    v180 = 0;
    v181 = v182;
    v8 = *(_QWORD **)(a3 + 8);
    v178 = 0;
    v179 = 0;
    v151 = v8;
    v152 = a3;
    if (v8[16])
    {
      v9 = (_QWORD *)v8[14];
      v10 = v8 + 15;
      if (v9 != v8 + 15)
      {
        v11 = 0;
        do
        {
          v12 = (__int128 *)(v9 + 4);
          if (v11 >= v180)
          {
            v14 = 0xCCCCCCCCCCCCCCCDLL * ((v11 - (_BYTE *)v178) >> 2);
            v15 = v14 + 1;
            if (v14 + 1 > 0xCCCCCCCCCCCCCCCLL)
              abort();
            if (0x999999999999999ALL * ((v180 - (_BYTE *)v178) >> 2) > v15)
              v15 = 0x999999999999999ALL * ((v180 - (_BYTE *)v178) >> 2);
            if (0xCCCCCCCCCCCCCCCDLL * ((v180 - (_BYTE *)v178) >> 2) >= 0x666666666666666)
              v16 = 0xCCCCCCCCCCCCCCCLL;
            else
              v16 = v15;
            if (v16)
              v17 = (char *)sub_1000B58EC((uint64_t)&v180, v16);
            else
              v17 = 0;
            v18 = &v17[20 * v14];
            v19 = *v12;
            *((_DWORD *)v18 + 4) = *((_DWORD *)v9 + 12);
            *(_OWORD *)v18 = v19;
            v21 = (char *)v178;
            v20 = v179;
            v22 = v18;
            if (v179 != v178)
            {
              do
              {
                v23 = *(_OWORD *)(v20 - 20);
                *((_DWORD *)v22 - 1) = *((_DWORD *)v20 - 1);
                *(_OWORD *)(v22 - 20) = v23;
                v22 -= 20;
                v20 -= 20;
              }
              while (v20 != v21);
              v20 = (char *)v178;
            }
            v11 = v18 + 20;
            v178 = v22;
            v179 = v18 + 20;
            v180 = &v17[20 * v16];
            if (v20)
              operator delete(v20);
          }
          else
          {
            v13 = *v12;
            *((_DWORD *)v11 + 4) = *((_DWORD *)v9 + 12);
            *(_OWORD *)v11 = v13;
            v11 += 20;
          }
          v179 = v11;
          v24 = (_QWORD *)v9[1];
          if (v24)
          {
            do
            {
              v25 = v24;
              v24 = (_QWORD *)*v24;
            }
            while (v24);
          }
          else
          {
            do
            {
              v25 = (_QWORD *)v9[2];
              v26 = *v25 == (_QWORD)v9;
              v9 = v25;
            }
            while (!v26);
          }
          v9 = v25;
        }
        while (v25 != v10);
        v7 = *(_QWORD *)(v153 + 8);
      }
    }
    v175 = 0;
    v176 = 0;
    v177 = 0;
    sub_100689D98(v7, &v175);
    v28 = v175;
    for (i = v176; v28 != i; v28 += 104)
    {
      v29 = *(_QWORD *)(v152 + 8);
      v30 = *(_QWORD *)(v29 + 64);
      v31 = *(_QWORD *)(v29 + 72);
      v32 = (unsigned __int8 **)(v29 + 64);
      if (v31 != v30)
      {
        *(_OWORD *)out = *(_OWORD *)(v28 + 20);
        *(_DWORD *)&out[16] = *(_DWORD *)(v28 + 36);
        v33 = operator new(0x14uLL);
        *(_QWORD *)&__p[8] = v33 + 5;
        *(_QWORD *)&__p[16] = v33 + 5;
        *(_OWORD *)v33 = *(_OWORD *)out;
        v33[4] = *(_DWORD *)&out[16];
        *(_QWORD *)__p = v33;
        v34 = sub_100689E64((uint64_t)v33, a2, (uint64_t)__p, v32);
        operator delete(v33);
        if ((v34 & 1) != 0)
          goto LABEL_33;
      }
      if (v179 == v178)
        goto LABEL_34;
      *(_OWORD *)out = *(_OWORD *)(v28 + 20);
      *(_DWORD *)&out[16] = *(_DWORD *)(v28 + 36);
      v35 = operator new(0x14uLL);
      *(_QWORD *)&__p[8] = v35 + 5;
      *(_QWORD *)&__p[16] = v35 + 5;
      *(_OWORD *)v35 = *(_OWORD *)out;
      v35[4] = *(_DWORD *)&out[16];
      *(_QWORD *)__p = v35;
      v36 = sub_100689E64((uint64_t)v35, a2, (uint64_t)__p, (unsigned __int8 **)&v178);
      operator delete(v35);
      if ((v36 & 1) == 0)
      {
LABEL_34:
        v38 = *(_QWORD *)(v152 + 8);
        v39 = *(_QWORD *)(v38 + 88);
        v40 = *(_QWORD *)(v38 + 96);
        v41 = (unsigned __int8 **)(v38 + 88);
        if (v40 == v39)
        {
          v37 = 0;
        }
        else
        {
          *(_OWORD *)out = *(_OWORD *)(v28 + 20);
          *(_DWORD *)&out[16] = *(_DWORD *)(v28 + 36);
          v42 = operator new(0x14uLL);
          *(_QWORD *)&__p[8] = v42 + 5;
          *(_QWORD *)&__p[16] = v42 + 5;
          *(_OWORD *)v42 = *(_OWORD *)out;
          v42[4] = *(_DWORD *)&out[16];
          *(_QWORD *)__p = v42;
          v37 = sub_100689E64((uint64_t)v42, a2, (uint64_t)__p, v41);
          operator delete(v42);
        }
      }
      else
      {
LABEL_33:
        v37 = 1;
      }
      v43 = objc_retainAutorelease(*(id *)v28);
      sub_100091AE8(__p, (char *)objc_msgSend(v43, "UTF8String"));
      v44 = (char **)sub_10001F2AC((uint64_t)&v181, (const void **)__p);
      if ((__p[23] & 0x80000000) != 0)
        operator delete(*(void **)__p);

      if (v182 == v44)
      {
        v45 = objc_retainAutorelease(*(id *)v28);
        sub_100091AE8(__p, (char *)objc_msgSend(v45, "UTF8String"));
        *(_QWORD *)out = __p;
        *((_BYTE *)sub_1002F7194((uint64_t **)&v181, (const void **)__p, (uint64_t)&unk_100740F58, (_OWORD **)out) + 56) = v37;
        if ((__p[23] & 0x80000000) != 0)
          operator delete(*(void **)__p);
      }
      else
      {
        v45 = objc_retainAutorelease(*(id *)v28);
        sub_100091AE8(__p, (char *)objc_msgSend(v45, "UTF8String"));
        *(_QWORD *)out = __p;
        v46 = sub_1002F7194((uint64_t **)&v181, (const void **)__p, (uint64_t)&unk_100740F58, (_OWORD **)out);
        if (*((_BYTE *)v46 + 56))
          v47 = v37;
        else
          v47 = 0;
        *((_BYTE *)v46 + 56) = v47;
        if ((__p[23] & 0x80000000) != 0)
          operator delete(*(void **)__p);
      }

      v48 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
      {
        v49 = v153 + 232;
        if (*(char *)(v153 + 255) < 0)
          v49 = *(_QWORD *)(v153 + 232);
        memset(out, 0, sizeof(out));
        uuid_unparse_upper(a2, out);
        sub_100091AE8(&v172, out);
        if (v174 >= 0)
          v50 = &v172;
        else
          v50 = v172;
        v51 = *(_OWORD *)(v28 + 20);
        v192 = *(_DWORD *)(v28 + 36);
        v191 = v51;
        sub_10006887C((uint64_t)&v191, out);
        if (out[23] >= 0)
          v52 = out;
        else
          v52 = *(char **)out;
        v53 = *(id *)v28;
        v54 = objc_retainAutorelease(*(id *)v28);
        sub_100091AE8(&v196, (char *)objc_msgSend(v54, "UTF8String"));
        v170[0] = &v196;
        v55 = *((unsigned __int8 *)sub_1002F7194((uint64_t **)&v181, (const void **)&v196, (uint64_t)&unk_100740F58, (_OWORD **)v170)+ 56);
        *(_DWORD *)__p = 136316418;
        *(_QWORD *)&__p[4] = v49;
        *(_WORD *)&__p[12] = 2080;
        *(_QWORD *)&__p[14] = v50;
        *(_WORD *)&__p[22] = 2080;
        *(_QWORD *)v185 = v52;
        *(_WORD *)&v185[8] = 1024;
        *(_DWORD *)v186 = v37;
        *(_WORD *)&v186[4] = 2112;
        *(_QWORD *)&v186[6] = v53;
        *(_WORD *)&v186[14] = 1024;
        *(_DWORD *)&v186[16] = v55;
        _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_INFO, "filterByEnhancedRules uuidWithoutBlobAndMask session:%s device:%s uuid:%s match:%d matchMap[%@]:%d", __p, 0x36u);
        if (SHIBYTE(v197) < 0)
          operator delete((void *)v196);

        if (out[23] < 0)
          operator delete(*(void **)out);
        if (SHIBYTE(v174) < 0)
          operator delete(v172);

      }
    }
    v172 = 0;
    v173 = 0;
    v174 = 0;
    sub_10068A030(*(_QWORD *)(v153 + 8), (uint64_t *)&v172);
    v150 = v173;
    v162 = (char *)v172;
    v56 = v151;
    if (v173 != v172 && v151[16])
    {
      v155 = v151 + 15;
      while (1)
      {
        v57 = (_QWORD *)v56[14];
        if (v57 != v155)
          break;
LABEL_122:
        v162 += 104;
        v56 = v151;
        if (v162 == v150)
          goto LABEL_123;
      }
      v164 = 0;
      v157 = (uint64_t)(v162 + 40);
      v159 = (__int128 *)(v162 + 20);
      v154 = (uint64_t)(v162 + 56);
      while (1)
      {
        v196 = *v159;
        LODWORD(v197) = *((_DWORD *)v162 + 9);
        v58 = operator new(0x14uLL);
        *(_QWORD *)&__p[8] = v58 + 5;
        *(_QWORD *)&__p[16] = v58 + 5;
        *(_OWORD *)v58 = v196;
        v58[4] = v197;
        *(_QWORD *)__p = v58;
        v191 = *((_OWORD *)v57 + 2);
        v192 = *((_DWORD *)v57 + 12);
        v59 = operator new(0x14uLL);
        *(_QWORD *)&out[8] = v59 + 5;
        *(_QWORD *)&out[16] = v59 + 5;
        *(_OWORD *)v59 = v191;
        v59[4] = v192;
        *(_QWORD *)out = v59;
        if ((sub_100689E64((uint64_t)v59, a2, (uint64_t)__p, (unsigned __int8 **)out) & 1) != 0)
        {
          v60 = (unsigned __int8 *)sub_10003EB18((uint64_t)(v57 + 7));
          v61 = sub_10003F8C4((uint64_t)(v57 + 7));
          v62 = sub_10003F8C4(v157);
          v63 = (unsigned __int8 *)sub_10003EB18(v154);
          v64 = (unsigned __int8 *)sub_10003EB18(v157);
          v65 = sub_10068A0FC((uint64_t)v64, v60, v61, v62, v63, v64);
          v59 = *(_DWORD **)out;
          v164 |= v65;
          v66 = v164 & 1;
          if (!*(_QWORD *)out)
            goto LABEL_75;
        }
        else
        {
          v66 = v164 & 1;
        }
        operator delete(v59);
LABEL_75:
        if (*(_QWORD *)__p)
          operator delete(*(void **)__p);
        v67 = objc_retainAutorelease(*(id *)v162);
        sub_100091AE8(__p, (char *)objc_msgSend(v67, "UTF8String"));
        v68 = (char **)sub_10001F2AC((uint64_t)&v181, (const void **)__p);
        if ((__p[23] & 0x80000000) != 0)
          operator delete(*(void **)__p);

        if (v182 == v68)
        {
          v69 = objc_retainAutorelease(*(id *)v162);
          sub_100091AE8(__p, (char *)objc_msgSend(v69, "UTF8String"));
          *(_QWORD *)out = __p;
          *((_BYTE *)sub_1002F7194((uint64_t **)&v181, (const void **)__p, (uint64_t)&unk_100740F58, (_OWORD **)out) + 56) = v66;
          if ((__p[23] & 0x80000000) != 0)
            operator delete(*(void **)__p);
        }
        else
        {
          v69 = objc_retainAutorelease(*(id *)v162);
          sub_100091AE8(__p, (char *)objc_msgSend(v69, "UTF8String"));
          *(_QWORD *)out = __p;
          v70 = sub_1002F7194((uint64_t **)&v181, (const void **)__p, (uint64_t)&unk_100740F58, (_OWORD **)out);
          *((_BYTE *)v70 + 56) = v164 & (*((_BYTE *)v70 + 56) != 0);
          if ((__p[23] & 0x80000000) != 0)
            operator delete(*(void **)__p);
        }

        v71 = qword_100999828;
        if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
        {
          v72 = v153 + 232;
          if (*(char *)(v153 + 255) < 0)
            v72 = *(_QWORD *)(v153 + 232);
          memset(out, 0, sizeof(out));
          uuid_unparse_upper(a2, out);
          sub_100091AE8(&v196, out);
          if (v197 >= 0)
            v73 = &v196;
          else
            v73 = (__int128 *)v196;
          v194 = *v159;
          v195 = *((_DWORD *)v162 + 9);
          sub_10006887C((uint64_t)&v194, out);
          if (out[23] >= 0)
            v74 = out;
          else
            v74 = *(char **)out;
          sub_1000453F0((uint64_t)(v57 + 7), &v191);
          if (v193 >= 0)
            v75 = &v191;
          else
            v75 = (__int128 *)v191;
          sub_1000453F0(v157, v170);
          if (v171 >= 0)
            v76 = v170;
          else
            v76 = (void **)v170[0];
          sub_1000453F0(v154, v168);
          if (v169 >= 0)
            v77 = v168;
          else
            v77 = (void **)v168[0];
          v78 = *(id *)v162;
          v79 = objc_retainAutorelease(*(id *)v162);
          sub_100091AE8(v166, (char *)objc_msgSend(v79, "UTF8String"));
          v183 = v166;
          v80 = *((unsigned __int8 *)sub_1002F7194((uint64_t **)&v181, (const void **)v166, (uint64_t)&unk_100740F58, (_OWORD **)&v183)+ 56);
          *(_DWORD *)__p = 136317186;
          *(_QWORD *)&__p[4] = v72;
          *(_WORD *)&__p[12] = 2080;
          *(_QWORD *)&__p[14] = v73;
          *(_WORD *)&__p[22] = 2080;
          *(_QWORD *)v185 = v74;
          *(_WORD *)&v185[8] = 2080;
          *(_QWORD *)v186 = v75;
          *(_WORD *)&v186[8] = 2080;
          *(_QWORD *)&v186[10] = v76;
          *(_WORD *)&v186[18] = 2080;
          *(_QWORD *)v187 = v77;
          *(_WORD *)&v187[8] = 1024;
          *(_DWORD *)v188 = v164 & 1;
          *(_WORD *)&v188[4] = 2112;
          *(_QWORD *)v189 = v78;
          *(_WORD *)&v189[8] = 1024;
          v190[0] = v80;
          _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_INFO, "filterByEnhancedRules uuidWithBlobAndMask session:%s device:%s uuid:%s data:%s blob:%s mask:%s match:%d matchMap[%@]:%d", __p, 0x54u);
          if (v167 < 0)
            operator delete(v166[0]);

          if (v169 < 0)
            operator delete(v168[0]);
          if (v171 < 0)
            operator delete(v170[0]);
          if (v193 < 0)
            operator delete((void *)v191);
          if (out[23] < 0)
            operator delete(*(void **)out);
          if (SHIBYTE(v197) < 0)
            operator delete((void *)v196);

        }
        v81 = (_QWORD *)v57[1];
        if (v81)
        {
          do
          {
            v82 = v81;
            v81 = (_QWORD *)*v81;
          }
          while (v81);
        }
        else
        {
          do
          {
            v82 = (_QWORD *)v57[2];
            v26 = *v82 == (_QWORD)v57;
            v57 = v82;
          }
          while (!v26);
        }
        v57 = v82;
        if (v82 == v155)
          goto LABEL_122;
      }
    }
LABEL_123:
    v83 = *(_QWORD *)(v153 + 8);
    v84 = *(_QWORD *)(v83 + 96);
    v85 = *(_QWORD *)(v83 + 104);
    while (v84 != v85)
    {
      if (*(_DWORD *)(v84 + 96) == 2)
      {
        v158 = sub_10003F8C4(*(_QWORD *)(v152 + 8) + 48);
        v156 = (unsigned __int8 *)sub_10003EB18(*(_QWORD *)(v152 + 8) + 48);
        if (v158 >= 2 && *(_WORD *)v156 != 76)
        {
          v196 = 0uLL;
          v197 = 0;
          sub_10068A460(*(_QWORD *)(v153 + 8), (uint64_t *)&v196);
          v160 = *((_QWORD *)&v196 + 1);
          v87 = v196;
          if ((_QWORD)v196 != *((_QWORD *)&v196 + 1))
          {
            v165 = *(unsigned __int16 *)v156;
            do
            {
              if (v165 == *(unsigned __int16 *)(v87 + 16))
              {
                if (sub_1000452EC(v87 + 40))
                {
                  v88 = 1;
                }
                else
                {
                  v88 = sub_1000452EC(v87 + 56);
                  v89 = v158 < 3 || v88;
                  if ((v89 & 1) == 0)
                  {
                    v90 = sub_10003F8C4(v87 + 40);
                    v91 = (unsigned __int8 *)sub_10003EB18(v87 + 56);
                    v92 = (unsigned __int8 *)sub_10003EB18(v87 + 40);
                    v88 = sub_10068A0FC((uint64_t)v92, v156 + 2, v158 - 2, v90, v91, v92);
                  }
                }
                v163 = v88;
                v93 = objc_retainAutorelease(*(id *)v87);
                sub_100091AE8(__p, (char *)objc_msgSend(v93, "UTF8String"));
                v94 = (char **)sub_10001F2AC((uint64_t)&v181, (const void **)__p);
                if ((__p[23] & 0x80000000) != 0)
                  operator delete(*(void **)__p);

                if (v182 == v94)
                {
                  v95 = objc_retainAutorelease(*(id *)v87);
                  sub_100091AE8(__p, (char *)objc_msgSend(v95, "UTF8String"));
                  *(_QWORD *)out = __p;
                  *((_BYTE *)sub_1002F7194((uint64_t **)&v181, (const void **)__p, (uint64_t)&unk_100740F58, (_OWORD **)out)+ 56) = v163;
                  if ((__p[23] & 0x80000000) != 0)
                    operator delete(*(void **)__p);
                }
                else
                {
                  v95 = objc_retainAutorelease(*(id *)v87);
                  sub_100091AE8(__p, (char *)objc_msgSend(v95, "UTF8String"));
                  *(_QWORD *)out = __p;
                  v96 = sub_1002F7194((uint64_t **)&v181, (const void **)__p, (uint64_t)&unk_100740F58, (_OWORD **)out);
                  v97 = v163;
                  if (!*((_BYTE *)v96 + 56))
                    v97 = 0;
                  *((_BYTE *)v96 + 56) = v97;
                  if ((__p[23] & 0x80000000) != 0)
                    operator delete(*(void **)__p);
                }

                v98 = qword_100999828;
                if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
                {
                  v99 = v153 + 232;
                  if (*(char *)(v153 + 255) < 0)
                    v99 = *(_QWORD *)(v153 + 232);
                  memset(out, 0, sizeof(out));
                  uuid_unparse_upper(a2, out);
                  sub_100091AE8(&v191, out);
                  if (v193 >= 0)
                    v100 = &v191;
                  else
                    v100 = (__int128 *)v191;
                  v101 = *(unsigned __int16 *)(v87 + 16);
                  v102 = sub_10003994C(&v194, v156, v158);
                  sub_1000453F0((uint64_t)v102, out);
                  if (out[23] >= 0)
                    v103 = out;
                  else
                    v103 = *(char **)out;
                  sub_1000453F0(v87 + 40, v170);
                  if (v171 >= 0)
                    v104 = v170;
                  else
                    v104 = (void **)v170[0];
                  sub_1000453F0(v87 + 56, v168);
                  if (v169 >= 0)
                    v105 = v168;
                  else
                    v105 = (void **)v168[0];
                  v106 = *(id *)v87;
                  v107 = objc_retainAutorelease(*(id *)v87);
                  sub_100091AE8(v166, (char *)objc_msgSend(v107, "UTF8String"));
                  v183 = v166;
                  v108 = *((unsigned __int8 *)sub_1002F7194((uint64_t **)&v181, (const void **)v166, (uint64_t)&unk_100740F58, (_OWORD **)&v183)+ 56);
                  *(_DWORD *)__p = 136317442;
                  *(_QWORD *)&__p[4] = v99;
                  *(_WORD *)&__p[12] = 2080;
                  *(_QWORD *)&__p[14] = v100;
                  *(_WORD *)&__p[22] = 1024;
                  *(_DWORD *)v185 = v101;
                  *(_WORD *)&v185[4] = 1024;
                  *(_DWORD *)&v185[6] = v165;
                  *(_WORD *)v186 = 2080;
                  *(_QWORD *)&v186[2] = v103;
                  *(_WORD *)&v186[10] = 2080;
                  *(_QWORD *)&v186[12] = v104;
                  *(_WORD *)v187 = 2080;
                  *(_QWORD *)&v187[2] = v105;
                  *(_WORD *)v188 = 1024;
                  *(_DWORD *)&v188[2] = v163;
                  *(_WORD *)v189 = 2112;
                  *(_QWORD *)&v189[2] = v106;
                  LOWORD(v190[0]) = 1024;
                  *(_DWORD *)((char *)v190 + 2) = v108;
                  _os_log_impl((void *)&_mh_execute_header, v98, OS_LOG_TYPE_INFO, "filterByEnhancedRules NonAppleManufacturerData session:%s device:%s filterMfgrID:%04X payloadMfgrId:%04X payload:%s blob:%s mask:%s match:%d matchMap[%@]:%d", __p, 0x56u);
                  if (v167 < 0)
                    operator delete(v166[0]);

                  if (v169 < 0)
                    operator delete(v168[0]);
                  if (v171 < 0)
                    operator delete(v170[0]);
                  if (out[23] < 0)
                    operator delete(*(void **)out);
                  *(_QWORD *)&v194 = &off_100918258;
                  if (*((_QWORD *)&v194 + 1))
                    sub_100056AAC(*((unsigned int **)&v194 + 1));
                  if (v193 < 0)
                    operator delete((void *)v191);

                }
              }
              v87 += 104;
            }
            while (v87 != v160);
          }
          *(_QWORD *)__p = &v196;
          sub_1000B55B4((void ***)__p);
        }
        break;
      }
      v84 += 104;
    }
    v109 = *(_QWORD *)(v153 + 8);
    v110 = *(_QWORD *)(v109 + 96);
    v111 = *(char ***)(v109 + 104);
    while (1)
    {
      if ((char **)v110 == v111)
        goto LABEL_236;
      if (*(_DWORD *)(v110 + 96) == 3)
        break;
      v110 += 104;
    }
    v196 = 0uLL;
    v197 = 0;
    sub_10068A518(v109, (uint64_t *)&v196);
    v113 = *((_QWORD *)&v196 + 1);
    v112 = v196;
    v114 = v152;
    if ((_QWORD)v196 != *((_QWORD *)&v196 + 1))
    {
      while (1)
      {
        v115 = *(_DWORD *)(v112 + 80);
        if (!v115)
          break;
        if (v115 == 2)
        {
          v117 = *(_QWORD *)(v114 + 8);
          if (*(char *)(v117 + 39) < 0)
          {
            sub_10003430C(__p, *(void **)(v117 + 16), *(_QWORD *)(v117 + 24));
          }
          else
          {
            *(_OWORD *)__p = *(_OWORD *)(v117 + 16);
            *(_QWORD *)&__p[16] = *(_QWORD *)(v117 + 32);
          }
          if (__p[23] >= 0)
            v120 = __p;
          else
            v120 = *(_BYTE **)__p;
          v121 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v120, v149));
          v122 = *(id *)(v112 + 88);
          v119 = objc_msgSend(v121, "hasSuffix:", v122);

          goto LABEL_210;
        }
        if (v115 == 1)
        {
          v116 = *(_QWORD *)(v114 + 8);
          if (*(char *)(v116 + 39) < 0)
          {
            sub_10003430C(__p, *(void **)(v116 + 16), *(_QWORD *)(v116 + 24));
          }
          else
          {
            *(_OWORD *)__p = *(_OWORD *)(v116 + 16);
            *(_QWORD *)&__p[16] = *(_QWORD *)(v116 + 32);
          }
          if (__p[23] >= 0)
            v126 = __p;
          else
            v126 = *(_BYTE **)__p;
          v127 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v126, v149));
          v128 = *(id *)(v112 + 88);
          v119 = objc_msgSend(v127, "hasPrefix:", v128);

          goto LABEL_210;
        }
        v119 = 0;
LABEL_212:
        v129 = objc_retainAutorelease(*(id *)v112);
        sub_100091AE8(__p, (char *)objc_msgSend(v129, "UTF8String"));
        v130 = (char **)sub_10001F2AC((uint64_t)&v181, (const void **)__p);
        if ((__p[23] & 0x80000000) != 0)
          operator delete(*(void **)__p);

        if (v182 == v130)
        {
          v131 = objc_retainAutorelease(*(id *)v112);
          sub_100091AE8(__p, (char *)objc_msgSend(v131, "UTF8String"));
          *(_QWORD *)out = __p;
          *((_BYTE *)sub_1002F7194((uint64_t **)&v181, (const void **)__p, (uint64_t)&unk_100740F58, (_OWORD **)out) + 56) = v119;
          if ((__p[23] & 0x80000000) != 0)
            operator delete(*(void **)__p);
        }
        else
        {
          v131 = objc_retainAutorelease(*(id *)v112);
          sub_100091AE8(__p, (char *)objc_msgSend(v131, "UTF8String"));
          *(_QWORD *)out = __p;
          v132 = sub_1002F7194((uint64_t **)&v181, (const void **)__p, (uint64_t)&unk_100740F58, (_OWORD **)out);
          if (*((_BYTE *)v132 + 56))
            v133 = v119;
          else
            v133 = 0;
          *((_BYTE *)v132 + 56) = v133;
          if ((__p[23] & 0x80000000) != 0)
            operator delete(*(void **)__p);
        }

        v134 = qword_100999828;
        if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
        {
          v135 = v153 + 232;
          if (*(char *)(v153 + 255) < 0)
            v135 = *(_QWORD *)(v153 + 232);
          memset(out, 0, sizeof(out));
          uuid_unparse_upper(a2, out);
          sub_100091AE8(&v191, out);
          if (v193 >= 0)
            v136 = &v191;
          else
            v136 = (__int128 *)v191;
          v137 = *(id *)(v112 + 88);
          v138 = *(_DWORD *)(v112 + 80);
          v139 = *(id *)v112;
          v140 = objc_retainAutorelease(*(id *)v112);
          sub_100091AE8(out, (char *)objc_msgSend(v140, "UTF8String"));
          v170[0] = out;
          v141 = *((unsigned __int8 *)sub_1002F7194((uint64_t **)&v181, (const void **)out, (uint64_t)&unk_100740F58, (_OWORD **)v170)+ 56);
          *(_DWORD *)__p = 136316674;
          *(_QWORD *)&__p[4] = v135;
          *(_WORD *)&__p[12] = 2080;
          *(_QWORD *)&__p[14] = v136;
          *(_WORD *)&__p[22] = 2112;
          *(_QWORD *)v185 = v137;
          *(_WORD *)&v185[8] = 1024;
          *(_DWORD *)v186 = v138;
          *(_WORD *)&v186[4] = 1024;
          *(_DWORD *)&v186[6] = v119;
          *(_WORD *)&v186[10] = 2112;
          *(_QWORD *)&v186[12] = v139;
          *(_WORD *)v187 = 1024;
          *(_DWORD *)&v187[2] = v141;
          _os_log_impl((void *)&_mh_execute_header, v134, OS_LOG_TYPE_INFO, "filterByEnhancedRules Name session:%s device:%s filterNameSubstr:%@ matchOption:%d match:%d matchMap[%@]:%d", __p, 0x3Cu);
          if (out[23] < 0)
            operator delete(*(void **)out);

          if (v193 < 0)
            operator delete((void *)v191);

        }
        v112 += 104;
        v114 = v152;
        if (v112 == v113)
          goto LABEL_235;
      }
      v118 = *(_QWORD *)(v114 + 8);
      if (*(char *)(v118 + 39) < 0)
      {
        sub_10003430C(__p, *(void **)(v118 + 16), *(_QWORD *)(v118 + 24));
      }
      else
      {
        *(_OWORD *)__p = *(_OWORD *)(v118 + 16);
        *(_QWORD *)&__p[16] = *(_QWORD *)(v118 + 32);
      }
      if (__p[23] >= 0)
        v123 = __p;
      else
        v123 = *(_BYTE **)__p;
      v124 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v123, v149));
      v125 = *(id *)(v112 + 88);
      v119 = objc_msgSend(v124, "containsString:", v125);

LABEL_210:
      if ((__p[23] & 0x80000000) != 0)
        operator delete(*(void **)__p);
      goto LABEL_212;
    }
LABEL_235:
    *(_QWORD *)__p = &v196;
    sub_1000B55B4((void ***)__p);
LABEL_236:
    v142 = (uint64_t *)v181;
    if (v181 == v182)
    {
LABEL_244:
      v145 = 0;
    }
    else
    {
      while (!*((_BYTE *)v142 + 56))
      {
        v143 = (char *)v142[1];
        if (v143)
        {
          do
          {
            v144 = (char **)v143;
            v143 = *(char **)v143;
          }
          while (v143);
        }
        else
        {
          do
          {
            v144 = (char **)v142[2];
            v26 = *v144 == (char *)v142;
            v142 = (uint64_t *)v144;
          }
          while (!v26);
        }
        v142 = (uint64_t *)v144;
        v111 = v182;
        if (v144 == v182)
          goto LABEL_244;
      }
      v146 = v142 + 4;
      if (*((char *)v142 + 55) < 0)
        v146 = (_QWORD *)*v146;
      v147 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v146, v149));
      objc_msgSend(v149, "setString:", v147);

      LODWORD(v111) = *((_BYTE *)v142 + 56) != 0;
      v145 = 1;
    }
    v86 = v145 & v111;
    *(_QWORD *)__p = &v172;
    sub_1000B55B4((void ***)__p);
    *(_QWORD *)__p = &v175;
    sub_1000B55B4((void ***)__p);
    if (v178)
    {
      v179 = (char *)v178;
      operator delete(v178);
    }
    sub_100056BAC((uint64_t)&v181, v182[0]);
  }

  return v86;
}

void sub_1006898C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,char a40,uint64_t a41,uint64_t a42,void *__p,uint64_t a44,uint64_t a45,char a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51)
{
  a51 = &a37;
  sub_1000B55B4((void ***)&a51);
  a51 = &a40;
  sub_1000B55B4((void ***)&a51);
  if (__p)
  {
    a44 = (uint64_t)__p;
    operator delete(__p);
  }
  sub_100056BAC((uint64_t)&a46, (char *)a47);

  _Unwind_Resume(a1);
}

uint64_t sub_100689D98@<X0>(uint64_t result@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v3 = *(_QWORD *)(result + 96);
  v4 = *(_QWORD *)(result + 104);
  if (v3 != v4)
  {
    v5 = v3 + 56;
    do
    {
      if (*(_DWORD *)(v5 + 40) == 1)
      {
        if (sub_1000452EC(v5 - 16) || (result = sub_1000452EC(v5), (_DWORD)result))
        {
          v6 = v5 - 56;
          v7 = a2[1];
          if (v7 >= a2[2])
          {
            result = sub_10068BC48(a2, v6);
          }
          else
          {
            sub_10068BD5C(a2[1], v6);
            result = v7 + 104;
            a2[1] = v7 + 104;
          }
          a2[1] = result;
        }
      }
      v5 += 104;
    }
    while (v5 - 56 != v4);
  }
  return result;
}

void sub_100689E40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  uint64_t v10;
  uint64_t v11;

  *(_QWORD *)(v10 + 8) = v11;
  a10 = (void **)v10;
  sub_1000B55B4(&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_100689E64(uint64_t a1, const unsigned __int8 *a2, uint64_t a3, unsigned __int8 **a4)
{
  unsigned __int8 *v4;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  NSObject *v11;
  void **v12;
  void **v13;
  void *__p[2];
  char v15;
  void *v16[2];
  char v17;
  uint8_t buf[4];
  void **v19;
  __int16 v20;
  void **v21;
  char out[40];

  v4 = *(unsigned __int8 **)a3;
  if (*(_QWORD *)a3 == *(_QWORD *)(a3 + 8))
    return 0;
  v8 = a4[1];
  while (1)
  {
    v9 = *a4;
    if (*a4 == v8)
    {
      v9 = v8;
    }
    else
    {
      while (!sub_100072DF0(v9, v4))
      {
        v9 += 20;
        if (v9 == v8)
        {
          v9 = v8;
          break;
        }
      }
      v8 = a4[1];
    }
    if (v9 != v8)
      break;
    v4 += 20;
    if (v4 == *(unsigned __int8 **)(a3 + 8))
      return 0;
  }
  v11 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    sub_10006887C((uint64_t)v4, v16);
    if (v17 >= 0)
      v12 = v16;
    else
      v12 = (void **)v16[0];
    memset(out, 0, 37);
    uuid_unparse_upper(a2, out);
    sub_100091AE8(__p, out);
    if (v15 >= 0)
      v13 = __p;
    else
      v13 = (void **)__p[0];
    *(_DWORD *)buf = 136446466;
    v19 = v12;
    v20 = 2082;
    v21 = v13;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Matched UUID %{public}s for device \"%{public}s\"", buf, 0x16u);
    if (v15 < 0)
      operator delete(__p[0]);
    if (v17 < 0)
      operator delete(v16[0]);
  }
  return 1;
}

void sub_10068A00C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  _Unwind_Resume(exception_object);
}

uint64_t sub_10068A030@<X0>(uint64_t result@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v3 = *(_QWORD *)(result + 96);
  v4 = *(_QWORD *)(result + 104);
  if (v3 != v4)
  {
    v5 = v3 + 56;
    do
    {
      if (*(_DWORD *)(v5 + 40) == 1)
      {
        result = sub_1000452EC(v5 - 16);
        if ((result & 1) == 0)
        {
          result = sub_1000452EC(v5);
          if ((result & 1) == 0)
          {
            v6 = v5 - 56;
            v7 = a2[1];
            if (v7 >= a2[2])
            {
              result = sub_10068BC48(a2, v6);
            }
            else
            {
              sub_10068BD5C(a2[1], v6);
              result = v7 + 104;
              a2[1] = v7 + 104;
            }
            a2[1] = result;
          }
        }
      }
      v5 += 104;
    }
    while (v5 - 56 != v4);
  }
  return result;
}

void sub_10068A0D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  uint64_t v10;
  uint64_t v11;

  *(_QWORD *)(v10 + 8) = v11;
  a10 = (void **)v10;
  sub_1000B55B4(&a10);
  _Unwind_Resume(a1);
}

BOOL sub_10068A0FC(uint64_t a1, unsigned __int8 *a2, size_t a3, size_t a4, unsigned __int8 *a5, unsigned __int8 *a6)
{
  NSObject *v10;
  void **v11;
  void **v12;
  void **v13;
  BOOL v14;
  void **v15;
  NSObject *v16;
  int v17;
  int v18;
  int v19;
  uint64_t (**v22)();
  unsigned int *v23;
  void *__p[2];
  char v25;
  uint64_t (**v26)();
  unsigned int *v27;
  void *v28[2];
  char v29;
  uint64_t (**v30)();
  unsigned int *v31;
  void *v32[2];
  char v33;
  uint8_t buf[4];
  void **v35;
  __int16 v36;
  _BYTE v37[10];
  void **v38;
  int v39;

  v10 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_INFO))
  {
    sub_10003994C(&v30, a2, a3);
    sub_1000453F0((uint64_t)&v30, v32);
    if (v33 >= 0)
      v11 = v32;
    else
      v11 = (void **)v32[0];
    sub_10003994C(&v26, a6, a4);
    sub_1000453F0((uint64_t)&v26, v28);
    if (v29 >= 0)
      v12 = v28;
    else
      v12 = (void **)v28[0];
    sub_10003994C(&v22, a5, a4);
    sub_1000453F0((uint64_t)&v22, __p);
    if (v25 >= 0)
      v13 = __p;
    else
      v13 = (void **)__p[0];
    *(_DWORD *)buf = 136315650;
    v35 = v11;
    v36 = 2080;
    *(_QWORD *)v37 = v12;
    *(_WORD *)&v37[8] = 2080;
    v38 = v13;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "matchMaskAndBlob data:%s blob:%s mask:%s", buf, 0x20u);
    if (v25 < 0)
      operator delete(__p[0]);
    v22 = &off_100918258;
    if (v23)
      sub_100056AAC(v23);
    if (v29 < 0)
      operator delete(v28[0]);
    v26 = &off_100918258;
    if (v27)
      sub_100056AAC(v27);
    if (v33 < 0)
      operator delete(v32[0]);
    v30 = &off_100918258;
    if (v31)
      sub_100056AAC(v31);
  }
  if (a3 >= a4)
  {
    if (a4)
    {
      v14 = 0;
      v15 = 0;
      v16 = qword_100999828;
      do
      {
        v17 = *((unsigned __int8 *)v15 + (_QWORD)a2);
        v18 = *((unsigned __int8 *)v15 + (_QWORD)a5);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
        {
          v19 = *((unsigned __int8 *)v15 + (_QWORD)a6);
          *(_DWORD *)buf = 134219008;
          v35 = v15;
          v36 = 1024;
          *(_DWORD *)v37 = v17;
          *(_WORD *)&v37[4] = 1024;
          *(_DWORD *)&v37[6] = v18;
          LOWORD(v38) = 1024;
          *(_DWORD *)((char *)&v38 + 2) = v19;
          HIWORD(v38) = 1024;
          v39 = v18 & v17;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_INFO, "matchMaskAndBlob byteIndex:%zu data:0x%02X mask:0x%02X blob:0x%02X result:0x%02X", buf, 0x24u);
          v16 = qword_100999828;
        }
        if ((v18 & v17) != *((unsigned __int8 *)v15 + (_QWORD)a6))
          break;
        v15 = (void **)((char *)v15 + 1);
        v14 = (unint64_t)v15 >= a4;
      }
      while ((void **)a4 != v15);
    }
    else
    {
      return 1;
    }
  }
  else
  {
    return 0;
  }
  return v14;
}

void sub_10068A3C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, unsigned int *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, unsigned int *a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,unsigned int *a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a13)
    sub_100056AAC(a13);
  if (a24 < 0)
    operator delete(__p);
  if (a18)
    sub_100056AAC(a18);
  if (a32 < 0)
    operator delete(a27);
  if (a26)
    sub_100056AAC(a26);
  _Unwind_Resume(exception_object);
}

uint64_t sub_10068A460@<X0>(uint64_t result@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v5;

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v2 = *(_QWORD *)(result + 96);
  v3 = *(_QWORD *)(result + 104);
  if (v2 != v3)
  {
    v5 = 0;
    do
    {
      if (*(_DWORD *)(v2 + 96) == 2)
      {
        if (v5 >= a2[2])
        {
          result = sub_10068BC48(a2, v2);
          v5 = result;
        }
        else
        {
          result = sub_10068BD5C(v5, v2);
          v5 += 104;
          a2[1] = v5;
        }
        a2[1] = v5;
      }
      v2 += 104;
    }
    while (v2 != v3);
  }
  return result;
}

void sub_10068A4F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1000B55B4((void ***)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10068A518@<X0>(uint64_t result@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v5;

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v2 = *(_QWORD *)(result + 96);
  v3 = *(_QWORD *)(result + 104);
  if (v2 != v3)
  {
    v5 = 0;
    do
    {
      if (*(_DWORD *)(v2 + 96) == 3)
      {
        if (v5 >= a2[2])
        {
          result = sub_10068BC48(a2, v2);
          v5 = result;
        }
        else
        {
          result = sub_10068BD5C(v5, v2);
          v5 += 104;
          a2[1] = v5;
        }
        a2[1] = v5;
      }
      v2 += 104;
    }
    while (v2 != v3);
  }
  return result;
}

void sub_10068A5AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1000B55B4((void ***)va);
  _Unwind_Resume(a1);
}

void sub_10068A5D0(uint64_t a1@<X0>, void **a2@<X8>)
{
  __int128 *v3;
  __int128 *i;
  __int128 v6;
  char *v7;
  char *v8;
  __int128 v9;
  char *v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  __int128 v17;
  char *v18;
  char *v19;
  char *v20;
  __int128 v21;
  __int128 v22;
  int v23;

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v3 = *(__int128 **)(a1 + 8);
  for (i = *(__int128 **)(a1 + 16); v3 != i; v3 = (__int128 *)((char *)v3 + 20))
  {
    v6 = *v3;
    v23 = *((_DWORD *)v3 + 4);
    v22 = v6;
    if ((sub_10068BE30(a1, (unsigned __int8 *)&v22) & 1) == 0)
    {
      v8 = (char *)a2[1];
      v7 = (char *)a2[2];
      if (v8 >= v7)
      {
        v11 = 0xCCCCCCCCCCCCCCCDLL * ((v8 - (_BYTE *)*a2) >> 2);
        v12 = v11 + 1;
        if (v11 + 1 > 0xCCCCCCCCCCCCCCCLL)
          abort();
        v13 = 0xCCCCCCCCCCCCCCCDLL * ((v7 - (_BYTE *)*a2) >> 2);
        if (2 * v13 > v12)
          v12 = 2 * v13;
        if (v13 >= 0x666666666666666)
          v14 = 0xCCCCCCCCCCCCCCCLL;
        else
          v14 = v12;
        if (v14)
          v15 = (char *)sub_1000B58EC((uint64_t)(a2 + 2), v14);
        else
          v15 = 0;
        v16 = &v15[20 * v11];
        v17 = *v3;
        *((_DWORD *)v16 + 4) = *((_DWORD *)v3 + 4);
        *(_OWORD *)v16 = v17;
        v19 = (char *)*a2;
        v18 = (char *)a2[1];
        v20 = v16;
        if (v18 != *a2)
        {
          do
          {
            v21 = *(_OWORD *)(v18 - 20);
            *((_DWORD *)v20 - 1) = *((_DWORD *)v18 - 1);
            *(_OWORD *)(v20 - 20) = v21;
            v20 -= 20;
            v18 -= 20;
          }
          while (v18 != v19);
          v18 = (char *)*a2;
        }
        v10 = v16 + 20;
        *a2 = v20;
        a2[1] = v16 + 20;
        a2[2] = &v15[20 * v14];
        if (v18)
          operator delete(v18);
      }
      else
      {
        v9 = *v3;
        *((_DWORD *)v8 + 4) = *((_DWORD *)v3 + 4);
        *(_OWORD *)v8 = v9;
        v10 = v8 + 20;
      }
      a2[1] = v10;
    }
  }
}

void sub_10068A78C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

__n128 sub_10068A7AC(uint64_t a1, __n128 *a2)
{
  unint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  __n128 result;
  uint64_t v9;

  v4 = *(_QWORD *)(a1 + 32);
  if (!v4)
  {
    sub_10068C318((void **)a1);
    v4 = *(_QWORD *)(a1 + 32);
  }
  v5 = *(_QWORD *)(a1 + 8);
  v6 = (_QWORD *)(v5 + 8 * (v4 / 0xAA));
  v7 = *v6 + 24 * (v4 % 0xAA);
  if (*(_QWORD *)(a1 + 16) == v5)
    v7 = 0;
  if (v7 == *v6)
    v7 = *(v6 - 1) + 4080;
  result = *a2;
  *(__n128 *)(v7 - 24) = *a2;
  *(_BYTE *)(v7 - 8) = a2[1].n128_u8[0];
  v9 = *(_QWORD *)(a1 + 40) + 1;
  *(_QWORD *)(a1 + 32) = v4 - 1;
  *(_QWORD *)(a1 + 40) = v9;
  return result;
}

void sub_10068A844(uint64_t a1)
{
  id v2;
  id v3;
  uint64_t v4;
  void *i;
  id v6;
  id v7;
  id v8;
  BOOL v9;
  NSObject *v10;
  unsigned __int16 v11;
  NSObject *v12;
  uint64_t v13;
  uint8_t v14;
  _BYTE v15[15];
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint8_t buf[4];
  id v21;
  _BYTE v22[128];

  if (objc_msgSend(*(id *)(*(_QWORD *)(a1 + 8) + 88), "count"))
  {
    v18 = 0u;
    v19 = 0u;
    v16 = 0u;
    v17 = 0u;
    v2 = *(id *)(*(_QWORD *)(a1 + 8) + 88);
    v3 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v16, v22, 16);
    if (v3)
    {
      v4 = *(_QWORD *)v17;
      do
      {
        for (i = 0; i != v3; i = (char *)i + 1)
        {
          if (*(_QWORD *)v17 != v4)
            objc_enumerationMutation(v2);
          v6 = objc_retainAutorelease(*(id *)(*((_QWORD *)&v16 + 1) + 8 * (_QWORD)i));
          v7 = objc_msgSend(v6, "bytes");
          v8 = objc_msgSend(v6, "length");
          if (v8)
            v9 = v7 == 0;
          else
            v9 = 1;
          if (v9)
          {
            v10 = qword_100999828;
            if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
              sub_1007189F0(&v14, v15, v10);
          }
          else
          {
            if ((unint64_t)v8 >= 0x15)
              v11 = 21;
            else
              v11 = (unsigned __int16)v8;
            v12 = qword_100999828;
            if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 138412290;
              v21 = v6;
              _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Adding zone %@", buf, 0xCu);
            }
            v13 = sub_1000438A4();
            if ((*(unsigned int (**)(uint64_t, id, _QWORD, uint64_t))(*(_QWORD *)v13 + 616))(v13, v7, v11, 240))
            {
              goto LABEL_22;
            }
          }
        }
        v3 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v16, v22, 16);
      }
      while (v3);
    }
LABEL_22:

  }
}

void sub_10068AA28(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t sub_10068AA50(const unsigned __int8 **a1, unsigned int a2)
{
  NSObject *v3;
  const unsigned __int8 *v4;
  const unsigned __int8 **v5;
  const unsigned __int8 *v6;
  const unsigned __int8 *v7;
  NSObject *v8;
  int v9;
  void **v10;
  void **v11;
  _BYTE *v12;
  _BOOL4 v13;
  unsigned __int8 *v14;
  const unsigned __int8 **v15;
  BOOL v16;
  uint64_t v17;
  void *__p[2];
  char v21;
  _OWORD v22[5];
  void *v23[2];
  __int128 v24;
  __int128 v25;
  _BYTE v26[144];
  uint64_t v27;
  uint8_t v28[4];
  void **v29;
  __int16 v30;
  _BYTE *v31;
  __int16 v32;
  unsigned int v33;
  __int16 v34;
  _BOOL4 v35;
  _BYTE buf[37];

  v27 = 0;
  v25 = 0u;
  memset(v26, 0, sizeof(v26));
  *(_OWORD *)v23 = 0u;
  v24 = 0u;
  memset(v22, 0, sizeof(v22));
  sub_1002613AC((uint64_t)v22);
  v3 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    v4 = a1[2];
    *(_DWORD *)buf = 134217984;
    *(_QWORD *)&buf[4] = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "statedump: _printAdvMap %lu items in map", buf, 0xCu);
  }
  v7 = *a1;
  v5 = a1 + 1;
  v6 = v7;
  if (v7 != (const unsigned __int8 *)v5)
  {
    do
    {
      v8 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
      {
        memset(buf, 0, sizeof(buf));
        uuid_unparse_upper(v6 + 32, buf);
        sub_100091AE8(__p, buf);
        v9 = v21;
        v10 = (void **)__p[0];
        sub_100044758(*((_QWORD *)v6 + 7));
        v11 = __p;
        if (v9 < 0)
          v11 = v10;
        v12 = buf;
        if (buf[23] < 0)
          v12 = *(_BYTE **)buf;
        v13 = (*(_QWORD *)(*((_QWORD *)v6 + 7) + 8 * ((unint64_t)a2 >> 6) + 168) & (1 << a2)) != 0;
        *(_DWORD *)v28 = 136315906;
        v29 = v11;
        v30 = 2080;
        v31 = v12;
        v32 = 1024;
        v33 = a2;
        v34 = 1024;
        v35 = v13;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "statedump:    %s:%s hasType(%d):%d", v28, 0x22u);
        if ((buf[23] & 0x80000000) != 0)
          operator delete(*(void **)buf);
        if (v21 < 0)
          operator delete(__p[0]);
      }
      v14 = (unsigned __int8 *)*((_QWORD *)v6 + 1);
      if (v14)
      {
        do
        {
          v15 = (const unsigned __int8 **)v14;
          v14 = *(unsigned __int8 **)v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          v15 = (const unsigned __int8 **)*((_QWORD *)v6 + 2);
          v16 = *v15 == v6;
          v6 = (const unsigned __int8 *)v15;
        }
        while (!v16);
      }
      v6 = (const unsigned __int8 *)v15;
    }
    while (v15 != v5);
  }
  *(_QWORD *)((char *)v22
  *(_QWORD *)&v22[1] = v17;
  if (SHIBYTE(v24) < 0)
    operator delete(v23[1]);
  std::streambuf::~streambuf((char *)&v22[1] + 8);
  return std::ios::~ios(v26);
}

void sub_10068AD0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18)
{
  _Unwind_Resume(exception_object);
}

void sub_10068AD40(uint64_t a1, unsigned int a2)
{
  const unsigned __int8 *v3;
  unsigned __int8 *v4;
  const unsigned __int8 **v5;
  BOOL v6;
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  const unsigned __int8 *v10;
  NSObject *v11;
  int v12;
  void **v13;
  void **v14;
  uint8_t *v15;
  _BOOL4 v16;
  unsigned __int8 *v17;
  const unsigned __int8 **v18;
  void *__p[2];
  char v21;
  const unsigned __int8 *v22;
  _QWORD *v23[2];
  uint8_t v24[4];
  void **v25;
  __int16 v26;
  uint8_t *v27;
  __int16 v28;
  unsigned int v29;
  __int16 v30;
  _BOOL4 v31;
  uint8_t buf[16];
  _BYTE v33[21];

  if (qword_100994128 != -1)
    dispatch_once(&qword_100994128, &stru_10093F6D0);
  v22 = 0;
  v23[0] = 0;
  v23[1] = 0;
  sub_10068C6A4((uint64_t *)&v22, a1 + 104);
  v3 = v22;
  if (v22 != (const unsigned __int8 *)v23)
  {
    do
    {
      if ((*(_QWORD *)(*((_QWORD *)v3 + 7) + 8 * ((unint64_t)a2 >> 6) + 168) & (1 << a2)) != 0)
        sub_10068C078((uint64_t **)(a1 + 104), (unsigned __int8 *)v3 + 32);
      v4 = (unsigned __int8 *)*((_QWORD *)v3 + 1);
      if (v4)
      {
        do
        {
          v5 = (const unsigned __int8 **)v4;
          v4 = *(unsigned __int8 **)v4;
        }
        while (v4);
      }
      else
      {
        do
        {
          v5 = (const unsigned __int8 **)*((_QWORD *)v3 + 2);
          v6 = *v5 == v3;
          v3 = (const unsigned __int8 *)v5;
        }
        while (!v6);
      }
      v3 = (const unsigned __int8 *)v5;
    }
    while (v5 != (const unsigned __int8 **)v23);
  }
  if (byte_100994120)
  {
    v7 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "statedump: clearAdvDataCacheForAppleType before removal", buf, 2u);
    }
    sub_10068AA50(&v22, a2);
    v8 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "statedump: clearAdvDataCacheForAppleType after removal", buf, 2u);
    }
    sub_10068AA50((const unsigned __int8 **)(a1 + 104), a2);
    v9 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = a2;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "statedump: clearAdvDataCacheForAppleType removed items with type %d", buf, 8u);
    }
    v10 = v22;
    if (v22 != (const unsigned __int8 *)v23)
    {
      do
      {
        if (a1 + 112 == sub_10000C5B8(a1 + 104, (unsigned __int8 *)v10 + 32))
        {
          v11 = qword_100999828;
          if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
          {
            *(_OWORD *)buf = 0u;
            memset(v33, 0, sizeof(v33));
            uuid_unparse_upper(v10 + 32, (char *)buf);
            sub_100091AE8(__p, (char *)buf);
            v12 = v21;
            v13 = (void **)__p[0];
            sub_100044758(*((_QWORD *)v10 + 7));
            v14 = __p;
            if (v12 < 0)
              v14 = v13;
            v15 = buf;
            if (v33[7] < 0)
              v15 = *(uint8_t **)buf;
            v16 = (*(_QWORD *)(*((_QWORD *)v10 + 7) + 8 * ((unint64_t)a2 >> 6) + 168) & (1 << a2)) != 0;
            *(_DWORD *)v24 = 136315906;
            v25 = v14;
            v26 = 2080;
            v27 = v15;
            v28 = 1024;
            v29 = a2;
            v30 = 1024;
            v31 = v16;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "statedump:    %s:%s hasType(%d):%d", v24, 0x22u);
            if ((v33[7] & 0x80000000) != 0)
              operator delete(*(void **)buf);
            if (v21 < 0)
              operator delete(__p[0]);
          }
        }
        v17 = (unsigned __int8 *)*((_QWORD *)v10 + 1);
        if (v17)
        {
          do
          {
            v18 = (const unsigned __int8 **)v17;
            v17 = *(unsigned __int8 **)v17;
          }
          while (v17);
        }
        else
        {
          do
          {
            v18 = (const unsigned __int8 **)*((_QWORD *)v10 + 2);
            v6 = *v18 == v10;
            v10 = (const unsigned __int8 *)v18;
          }
          while (!v6);
        }
        v10 = (const unsigned __int8 *)v18;
      }
      while (v18 != (const unsigned __int8 **)v23);
    }
  }
  sub_100024010((uint64_t)&v22, v23[0]);
}

void sub_10068B0E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19, uint64_t a20)
{
  _Unwind_Resume(exception_object);
}

void sub_10068B128(id a1)
{
  uint64_t v1;
  void *__p[2];
  char v3;
  void *v4[2];
  char v5;

  v1 = sub_100027F68();
  sub_100091AE8(v4, "LE");
  sub_100091AE8(__p, "LeScanAgentDebugClearAdvDataCache");
  (*(void (**)(uint64_t, void **, void **, char *))(*(_QWORD *)v1 + 72))(v1, v4, __p, &byte_100994120);
  if (v3 < 0)
    operator delete(__p[0]);
  if (v5 < 0)
    operator delete(v4[0]);
}

void sub_10068B1B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0)
    operator delete(__p);
  if (a20 < 0)
    operator delete(a15);
  _Unwind_Resume(exception_object);
}

void sub_10068B1E4(uint64_t a1)
{
  NSObject *v2;
  const char *v3;
  int v4;
  const char *v5;
  const char *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  NSObject *v12;
  uint64_t i;
  NSObject *v14;
  void **v15;
  NSObject *v16;
  const unsigned __int8 *v17;
  NSObject *v18;
  void **v19;
  unsigned __int8 *v20;
  const unsigned __int8 **v21;
  BOOL v22;
  NSObject *v23;
  const unsigned __int8 *v24;
  NSObject *v25;
  void **v26;
  unsigned __int8 *v27;
  const unsigned __int8 **v28;
  void *__p[2];
  char v30;
  const unsigned __int8 *v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const unsigned __int8 *v37;
  _QWORD *v38;
  uint64_t v39;
  uint8_t v40[4];
  void **v41;
  uint8_t buf[40];

  v2 = qword_100999828;
  if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
  {
    if (*(_BYTE *)(a1 + 80))
      v3 = "YES";
    else
      v3 = "NO";
    v4 = *(unsigned __int8 *)(a1 + 81);
    if (*(_BYTE *)(a1 + 83))
      v5 = "YES";
    else
      v5 = "NO";
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = v3;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v4;
    *(_WORD *)&buf[18] = 2082;
    *(_QWORD *)&buf[20] = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: \t\tfSupportsBackgrounding:%{public}s fSessionState:%d, fhasEntitlementBTCentralBackground:%{public}s", buf, 0x1Cu);
    v2 = qword_100999828;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(_QWORD *)(a1 + 88))
      v6 = "YES";
    else
      v6 = "NO";
    v7 = *(_DWORD *)(a1 + 96);
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = v6;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v7;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: \t\thasDecayTimer:%{public}s fCurrentScanLevel:%d", buf, 0x12u);
    v2 = qword_100999828;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v8 = *(_QWORD *)(a1 + 120);
    v9 = *(_QWORD *)(a1 + 144);
    v10 = *(unsigned __int16 *)(a1 + 176);
    *(_DWORD *)buf = 134218496;
    *(_QWORD *)&buf[4] = v8;
    *(_WORD *)&buf[12] = 2048;
    *(_QWORD *)&buf[14] = v9;
    *(_WORD *)&buf[22] = 1024;
    *(_DWORD *)&buf[24] = v10;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: \t\tfAdvDataMap.size:%lu fAdvLRUList.size:%lu fMaxNumOfReportsInMap:%d", buf, 0x1Cu);
    v2 = qword_100999828;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v11 = *(_DWORD *)(a1 + 208);
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v11;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: \t\tfScanAgentType:%d", buf, 8u);
  }
  if (*(_BYTE *)(a1 + 178))
  {
    v37 = 0;
    v38 = 0;
    v39 = 0;
    sub_10068C6A4((uint64_t *)&v37, a1 + 104);
    v34 = 0;
    v35 = 0;
    v36 = 0;
    sub_10068C8D4(&v34, a1 + 128);
    v31 = 0;
    v32 = 0;
    v33 = 0;
    sub_10068C964((uint64_t *)&v31, a1 + 152);
    v12 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = v36;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "statedump: \t\t--- fAdvLRUList (size:%lu) ---------", buf, 0xCu);
    }
    for (i = v35; (uint64_t *)i != &v34; i = *(_QWORD *)(i + 8))
    {
      v14 = qword_100999828;
      if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
      {
        memset(buf, 0, 37);
        uuid_unparse_upper((const unsigned __int8 *)(i + 16), (char *)buf);
        sub_100091AE8(__p, (char *)buf);
        v15 = v30 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)v40 = 136446210;
        v41 = v15;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "statedump: \t\t %{public}s", v40, 0xCu);
        if (v30 < 0)
          operator delete(__p[0]);
      }
    }
    v16 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = v33;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "statedump: \t\t--- fAdvLRUListMap (size:%lu) ---------", buf, 0xCu);
    }
    v17 = v31;
    if (v31 != (const unsigned __int8 *)&v32)
    {
      do
      {
        v18 = qword_100999828;
        if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
        {
          memset(buf, 0, 37);
          uuid_unparse_upper(v17 + 32, (char *)buf);
          sub_100091AE8(__p, (char *)buf);
          v19 = v30 >= 0 ? __p : (void **)__p[0];
          *(_DWORD *)v40 = 136446210;
          v41 = v19;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "statedump: \t\t %{public}s", v40, 0xCu);
          if (v30 < 0)
            operator delete(__p[0]);
        }
        v20 = (unsigned __int8 *)*((_QWORD *)v17 + 1);
        if (v20)
        {
          do
          {
            v21 = (const unsigned __int8 **)v20;
            v20 = *(unsigned __int8 **)v20;
          }
          while (v20);
        }
        else
        {
          do
          {
            v21 = (const unsigned __int8 **)*((_QWORD *)v17 + 2);
            v22 = *v21 == v17;
            v17 = (const unsigned __int8 *)v21;
          }
          while (!v22);
        }
        v17 = (const unsigned __int8 *)v21;
      }
      while (v21 != (const unsigned __int8 **)&v32);
    }
    v23 = qword_100999828;
    if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = v39;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "statedump: \t\t--- fAdvDataMap (size:%lu) ---------", buf, 0xCu);
    }
    v24 = v37;
    if (v37 != (const unsigned __int8 *)&v38)
    {
      do
      {
        v25 = qword_100999828;
        if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_DEFAULT))
        {
          memset(buf, 0, 37);
          uuid_unparse_upper(v24 + 32, (char *)buf);
          sub_100091AE8(__p, (char *)buf);
          v26 = v30 >= 0 ? __p : (void **)__p[0];
          *(_DWORD *)v40 = 136446210;
          v41 = v26;
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "statedump: \t\t %{public}s", v40, 0xCu);
          if (v30 < 0)
            operator delete(__p[0]);
        }
        v27 = (unsigned __int8 *)*((_QWORD *)v24 + 1);
        if (v27)
        {
          do
          {
            v28 = (const unsigned __int8 **)v27;
            v27 = *(unsigned __int8 **)v27;
          }
          while (v27);
        }
        else
        {
          do
          {
            v28 = (const unsigned __int8 **)*((_QWORD *)v24 + 2);
            v22 = *v28 == v24;
            v24 = (const unsigned __int8 *)v28;
          }
          while (!v22);
        }
        v24 = (const unsigned __int8 *)v28;
      }
      while (v28 != (const unsigned __int8 **)&v38);
    }
    sub_10001A82C((uint64_t)&v31, v32);
    sub_10002074C(&v34);
    sub_100024010((uint64_t)&v37, v38);
  }
}

void sub_10068B7E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,_QWORD *a21)
{
  sub_10002074C(&a17);
  sub_100024010((uint64_t)&a20, a21);
  _Unwind_Resume(a1);
}

id sub_10068B830(uint64_t a1)
{
  void *v2;
  id v3;
  id v4;
  uint64_t v5;
  void *i;
  id v7;
  id v8;
  BOOL v9;
  NSObject *v10;
  void *v11;
  id v12;
  uint8_t v14;
  _BYTE v15[15];
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  _BYTE v20[128];

  v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](NSMutableArray, "array"));
  if (objc_msgSend(*(id *)(*(_QWORD *)(a1 + 8) + 88), "count"))
  {
    v18 = 0u;
    v19 = 0u;
    v16 = 0u;
    v17 = 0u;
    v3 = *(id *)(*(_QWORD *)(a1 + 8) + 88);
    v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v16, v20, 16);
    if (v4)
    {
      v5 = *(_QWORD *)v17;
      do
      {
        for (i = 0; i != v4; i = (char *)i + 1)
        {
          if (*(_QWORD *)v17 != v5)
            objc_enumerationMutation(v3);
          v7 = objc_retainAutorelease(*(id *)(*((_QWORD *)&v16 + 1) + 8 * (_QWORD)i));
          v8 = objc_msgSend(v7, "bytes");
          if (objc_msgSend(v7, "length"))
            v9 = v8 == 0;
          else
            v9 = 1;
          if (v9)
          {
            v10 = qword_100999828;
            if (os_log_type_enabled((os_log_t)qword_100999828, OS_LOG_TYPE_ERROR))
              sub_1007189F0(&v14, v15, v10);
          }
          else if ((unint64_t)objc_msgSend(v7, "length") < 0x16)
          {
            objc_msgSend(v2, "addObject:", v7);
          }
          else
          {
            v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", objc_msgSend(objc_retainAutorelease(v7), "bytes"), 21));
            objc_msgSend(v2, "addObject:", v11);

          }
        }
        v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v16, v20, 16);
      }
      while (v4);
    }

    v12 = v2;
  }
  else
  {
    v12 = 0;
  }

  return v12;
}

void sub_10068BA20(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_10068BA60(uint64_t a1, void *a2)
{
  id v3;
  uint64_t *v4;
  unsigned __int8 uu2[8];
  uint64_t v6;

  v3 = a2;
  *(_QWORD *)uu2 = 0;
  v6 = 0;
  sub_100030BCC(uu2, v3);
  if (a1 + 112 != sub_10000C5B8(a1 + 104, uu2))
  {
    sub_10068C078((uint64_t **)(a1 + 104), uu2);
    v4 = (uint64_t *)sub_10000C5B8(a1 + 152, uu2);
    if ((uint64_t *)(a1 + 160) != v4)
    {
      sub_1000040CC((uint64_t **)(a1 + 152), v4);
      operator delete(v4);
    }
    sub_10068BB5C(a1 + 128, uu2);
  }

}

void sub_10068BB3C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

_QWORD *sub_10068BB5C(uint64_t a1, unsigned __int8 *uu2)
{
  uint64_t v2;
  int v5;
  uint64_t v6;
  int v7;
  BOOL v8;
  uint64_t v10[3];

  v10[0] = (uint64_t)v10;
  v10[1] = (uint64_t)v10;
  v10[2] = 0;
  v2 = *(_QWORD *)(a1 + 8);
  if (v2 != a1)
  {
    do
    {
      v5 = uuid_compare((const unsigned __int8 *)(v2 + 16), uu2);
      v6 = *(_QWORD *)(v2 + 8);
      if (!v5)
      {
        if (v6 == a1)
        {
          v8 = 1;
LABEL_8:
          v6 = a1;
        }
        else
        {
          while (1)
          {
            v7 = uuid_compare((const unsigned __int8 *)(v6 + 16), uu2);
            v8 = v7 == 0;
            if (v7)
              break;
            v6 = *(_QWORD *)(v6 + 8);
            if (v6 == a1)
              goto LABEL_8;
          }
        }
        sub_10047B820((uint64_t)v10, v10, a1, (_QWORD *)v2, (_QWORD *)v6);
        if (!v8)
          v6 = *(_QWORD *)(v6 + 8);
      }
      v2 = v6;
    }
    while (v6 != a1);
  }
  return sub_10002074C(v10);
}

void sub_10068BC2C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_10002074C((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10068BC48(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  char *v11;
  uint64_t v12;
  void *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v2 = *a1;
  v3 = 0x4EC4EC4EC4EC4EC5 * ((a1[1] - *a1) >> 3);
  v4 = v3 + 1;
  if ((unint64_t)(v3 + 1) > 0x276276276276276)
    abort();
  v8 = a1[2];
  v7 = (uint64_t)(a1 + 2);
  v9 = 0x4EC4EC4EC4EC4EC5 * ((v8 - v2) >> 3);
  if (2 * v9 > v4)
    v4 = 2 * v9;
  if (v9 >= 0x13B13B13B13B13BLL)
    v10 = 0x276276276276276;
  else
    v10 = v4;
  v18 = v7;
  if (v10)
    v11 = (char *)sub_1000B5ED0(v7, v10);
  else
    v11 = 0;
  v14 = v11;
  v15 = &v11[104 * v3];
  v17 = &v11[104 * v10];
  sub_10068BD5C((uint64_t)v15, a2);
  v16 = v15 + 104;
  sub_1000B5E34(a1, &v14);
  v12 = a1[1];
  sub_1000B5F18(&v14);
  return v12;
}

void sub_10068BD48(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1000B5F18((void **)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10068BD5C(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  *(_QWORD *)a1 = *(id *)a2;
  *(_QWORD *)(a1 + 8) = *(id *)(a2 + 8);
  v4 = *(_QWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 32) = v4;
  *(_QWORD *)(a1 + 40) = &off_100918258;
  v5 = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 48) = v5;
  if (v5)
    sub_10003C37C(v5);
  v6 = *(_QWORD *)(a2 + 64);
  *(_QWORD *)(a1 + 56) = &off_100918258;
  *(_QWORD *)(a1 + 64) = v6;
  if (v6)
    sub_10003C37C(v6);
  v7 = *(_QWORD *)(a2 + 72);
  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a2 + 80);
  *(_QWORD *)(a1 + 72) = v7;
  *(_QWORD *)(a1 + 88) = *(id *)(a2 + 88);
  *(_DWORD *)(a1 + 96) = *(_DWORD *)(a2 + 96);
  return a1;
}

void sub_10068BDFC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  unsigned int *v4;

  *(_QWORD *)(v1 + 40) = v2;
  v4 = *(unsigned int **)(v1 + 48);
  if (v4)
    sub_100056AAC(v4);

  _Unwind_Resume(a1);
}

uint64_t sub_10068BE30(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2;
  uint64_t v3;
  __int128 v5;
  __int128 v7;
  int v8;

  v2 = *(_QWORD *)(a1 + 96);
  v3 = *(_QWORD *)(a1 + 104);
  if (v2 == v3)
    return 0;
  while (1)
  {
    if (*(_DWORD *)(v2 + 96) == 1)
    {
      v5 = *(_OWORD *)(v2 + 20);
      v8 = *(_DWORD *)(v2 + 36);
      v7 = v5;
      if (sub_100072DF0(a2, (unsigned __int8 *)&v7))
        break;
    }
    v2 += 104;
    if (v2 == v3)
      return 0;
  }
  return 1;
}

uint64_t sub_10068BED8(_QWORD *a1)
{
  void **v2;
  void **v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  void *v7;

  v2 = (void **)a1[1];
  v3 = (void **)a1[2];
  a1[5] = 0;
  v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      v3 = (void **)a1[2];
      v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  v5 = v4 >> 3;
  if (v5 == 1)
  {
    v6 = 85;
  }
  else
  {
    if (v5 != 2)
      goto LABEL_9;
    v6 = 170;
  }
  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    v7 = *v2++;
    operator delete(v7);
  }
  return sub_1002A4304((uint64_t)a1);
}

uint64_t sub_10068BF6C(uint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v5;

  uuid_copy((unsigned __int8 *)a1, a2);
  v5 = *(_QWORD *)(a3 + 8);
  *(_QWORD *)(a1 + 16) = &off_100918298;
  *(_QWORD *)(a1 + 24) = v5;
  if (v5)
    sub_10003C37C(v5);
  return a1;
}

void sub_10068BFAC(uint64_t a1, _QWORD *__p)
{
  unsigned int *v3;

  if (*(_BYTE *)(a1 + 8))
  {
    __p[6] = &off_100918298;
    v3 = (unsigned int *)__p[7];
    if (v3)
      sub_100056AAC(v3);
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

void sub_10068C000(uint64_t a1@<X0>, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a2@<X2>, unsigned __int8 **a3@<X8>)
{
  unsigned __int8 *v5;
  unsigned __int8 *v6;

  v5 = (unsigned __int8 *)(a1 + 8);
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v6 = (unsigned __int8 *)operator new(0x38uLL);
  *a3 = v6;
  a3[1] = v5;
  *((_BYTE *)a3 + 16) = 0;
  uuid_copy(v6 + 32, *a2);
  *((_QWORD *)v6 + 6) = 0;
  *((_BYTE *)a3 + 16) = 1;
}

void sub_10068C060(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void *v2;

  *v1 = 0;
  operator delete(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_10068C078(uint64_t **a1, unsigned __int8 *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)sub_10000C5B8((uint64_t)a1, a2);
  if (a1 + 1 == (uint64_t **)v3)
    return 0;
  sub_10068C0BC(a1, v3);
  return 1;
}

uint64_t *sub_10068C0BC(uint64_t **a1, uint64_t *a2)
{
  uint64_t *v3;
  unsigned int *v4;

  v3 = sub_1000040CC(a1, a2);
  a2[6] = (uint64_t)&off_100918298;
  v4 = (unsigned int *)a2[7];
  if (v4)
    sub_100056AAC(v4);
  operator delete(a2);
  return v3;
}

uint64_t sub_10068C104(uint64_t **a1, unsigned __int8 *a2)
{
  uint64_t *v3;
  uint64_t *v4;

  v3 = (uint64_t *)sub_10000C5B8((uint64_t)a1, a2);
  if (a1 + 1 == (uint64_t **)v3)
    return 0;
  v4 = v3;
  sub_1000040CC(a1, v3);
  operator delete(v4);
  return 1;
}

uint64_t *sub_10068C154(uint64_t **a1, unsigned __int8 *uu1, uint64_t a3)
{
  uint64_t **v5;
  uint64_t *v6;
  uint64_t **v7;
  uint64_t *v9[3];
  uint64_t v10;

  v10 = 0;
  v5 = (uint64_t **)sub_10000DC28((uint64_t)a1, &v10, uu1);
  v6 = *v5;
  if (!*v5)
  {
    v7 = v5;
    memset(v9, 0, sizeof(v9));
    sub_10068C1F0((uint64_t)a1, a3, v9);
    sub_100004078(a1, v10, v7, v9[0]);
    v6 = v9[0];
    v9[0] = 0;
    sub_10068C2D4((uint64_t)v9, 0);
  }
  return v6;
}

uint64_t sub_10068C1F0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v5;
  void *v6;
  uint64_t result;

  v5 = a1 + 8;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v6 = operator new(0x68uLL);
  *a3 = v6;
  a3[1] = v5;
  *((_BYTE *)a3 + 16) = 0;
  result = sub_10068C260((uint64_t)v6 + 32, a2);
  *((_BYTE *)a3 + 16) = 1;
  return result;
}

void sub_10068C248(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_10068C2D4(v1, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_10068C260(uint64_t a1, uint64_t a2)
{
  int v4;

  uuid_copy((unsigned __int8 *)a1, (const unsigned __int8 *)a2);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 40);
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(a2 + 48) = 0;
  *(_QWORD *)(a2 + 56) = 0;
  v4 = *(_DWORD *)(a2 + 64);
  *(_BYTE *)(a1 + 68) = *(_BYTE *)(a2 + 68);
  *(_DWORD *)(a1 + 64) = v4;
  return a1;
}

void sub_10068C2D4(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;

  v2 = *(_QWORD **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      sub_10068BED8(v2 + 6);
    operator delete(v2);
  }
}

void sub_10068C318(void **a1)
{
  _BYTE *v2;
  _BYTE *v3;
  unint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  _BYTE *v8;
  _BYTE *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  char *v14;
  int64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  int64_t v21;
  char *v22;
  unint64_t v23;
  char *v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  void *v31;
  uint64_t v32;
  char *v33;
  _QWORD *v34;
  uint64_t v35;
  void *v36;
  char *v37;
  char *v38;
  char *v39;
  uint64_t v40;
  void *v41;
  void *__p;
  char *v43;
  char *v44;
  char *v45;
  _QWORD *v46;

  v2 = a1[1];
  v3 = a1[2];
  v4 = (v3 - v2) >> 3;
  if (v3 == v2)
    v5 = 0;
  else
    v5 = 170 * v4 - 1;
  v6 = (char *)a1[4];
  if (v5 - (unint64_t)&v6[(_QWORD)a1[5]] < 0xAA)
  {
    v7 = (uint64_t)(a1 + 3);
    v8 = a1[3];
    v9 = *a1;
    v10 = v8 - (_BYTE *)*a1;
    if (v4 >= v10 >> 3)
    {
      if (v8 == v9)
        v11 = 1;
      else
        v11 = v10 >> 2;
      v46 = a1 + 3;
      __p = sub_10007ABA0(v7, v11);
      v43 = (char *)__p;
      v44 = (char *)__p;
      v45 = (char *)__p + 8 * v12;
      v41 = operator new(0xFF0uLL);
      sub_1002A640C(&__p, &v41);
      v13 = (char *)a1[1];
      v14 = v44;
      if (v13 == a1[2])
      {
        v33 = (char *)a1[1];
      }
      else
      {
        do
        {
          if (v14 == v45)
          {
            v15 = v43 - (_BYTE *)__p;
            if (v43 <= __p)
            {
              if (v14 == __p)
                v23 = 1;
              else
                v23 = (v14 - (_BYTE *)__p) >> 2;
              v24 = (char *)sub_10007ABA0((uint64_t)v46, v23);
              v26 = v43;
              v14 = &v24[8 * (v23 >> 2)];
              v27 = v44 - v43;
              if (v44 != v43)
              {
                v14 = &v24[8 * (v23 >> 2) + (v27 & 0xFFFFFFFFFFFFFFF8)];
                v28 = 8 * (v27 >> 3);
                v29 = &v24[8 * (v23 >> 2)];
                do
                {
                  v30 = *(_QWORD *)v26;
                  v26 += 8;
                  *(_QWORD *)v29 = v30;
                  v29 += 8;
                  v28 -= 8;
                }
                while (v28);
              }
              v31 = __p;
              __p = v24;
              v43 = &v24[8 * (v23 >> 2)];
              v44 = v14;
              v45 = &v24[8 * v25];
              if (v31)
              {
                operator delete(v31);
                v14 = v44;
              }
            }
            else
            {
              v16 = v15 >> 3;
              v17 = v15 >> 3 < -1;
              v18 = (v15 >> 3) + 2;
              if (v17)
                v19 = v18;
              else
                v19 = v16 + 1;
              v20 = &v43[-8 * (v19 >> 1)];
              v21 = v14 - v43;
              if (v14 != v43)
              {
                memmove(&v43[-8 * (v19 >> 1)], v43, v14 - v43);
                v14 = v43;
              }
              v22 = &v14[-8 * (v19 >> 1)];
              v14 = &v20[v21];
              v43 = v22;
              v44 = &v20[v21];
            }
          }
          v32 = *(_QWORD *)v13;
          v13 += 8;
          *(_QWORD *)v14 = v32;
          v14 = v44 + 8;
          v44 += 8;
        }
        while (v13 != a1[2]);
        v33 = (char *)a1[1];
      }
      v36 = *a1;
      v37 = v43;
      *a1 = __p;
      a1[1] = v37;
      __p = v36;
      v43 = v33;
      v38 = (char *)a1[3];
      v39 = v45;
      a1[2] = v14;
      a1[3] = v39;
      v44 = v13;
      v45 = v38;
      if (v14 - v37 == 8)
        v40 = 85;
      else
        v40 = (uint64_t)a1[4] + 170;
      a1[4] = (void *)v40;
      if (v13 != v33)
        v44 = &v13[(v33 - v13 + 7) & 0xFFFFFFFFFFFFFFF8];
      if (v36)
        operator delete(v36);
    }
    else
    {
      if (v2 == v9)
      {
        __p = operator new(0xFF0uLL);
        sub_1002A61DC(a1, &__p);
        v34 = a1[2];
        __p = (void *)*(v34 - 1);
        a1[2] = v34 - 1;
      }
      else
      {
        __p = operator new(0xFF0uLL);
      }
      sub_1002A62F0((uint64_t)a1, &__p);
      if ((_BYTE *)a1[2] - (_BYTE *)a1[1] == 8)
        v35 = 85;
      else
        v35 = (uint64_t)a1[4] + 170;
      a1[4] = (void *)v35;
    }
  }
  else
  {
    a1[4] = v6 + 170;
    __p = (void *)*((_QWORD *)v3 - 1);
    a1[2] = v3 - 8;
    sub_1002A62F0((uint64_t)a1, &__p);
  }
}

void sub_10068C5E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  void *v12;

  operator delete(v12);
  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t sub_10068C630(_QWORD *a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  int v7;

  v3 = a1[1];
  v2 = a1[2];
  if (v2 == v3)
    v4 = 0;
  else
    v4 = 170 * ((v2 - v3) >> 3) - 1;
  v5 = v4 - (a1[5] + a1[4]);
  if (v5 < 0xAA)
    a2 = 1;
  if (v5 < 0x154)
    v7 = a2;
  else
    v7 = 0;
  if ((v7 & 1) == 0)
  {
    operator delete(*(void **)(v2 - 8));
    a1[2] -= 8;
  }
  return v7 ^ 1u;
}

uint64_t *sub_10068C6A4(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_10068C6F8(a1, *(unsigned __int8 **)a2, (unsigned __int8 *)(a2 + 8));
  return a1;
}

void sub_10068C6E0(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_100024010(v1, *(_QWORD **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_10068C6F8(uint64_t *result, unsigned __int8 *a2, unsigned __int8 *a3)
{
  unsigned __int8 *v4;
  uint64_t **v5;
  uint64_t *v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  BOOL v9;

  if (a2 != a3)
  {
    v4 = a2;
    v5 = (uint64_t **)result;
    v6 = result + 1;
    do
    {
      result = sub_10068C77C(v5, v6, v4 + 32, (uint64_t)(v4 + 32));
      v7 = (unsigned __int8 *)*((_QWORD *)v4 + 1);
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = *(unsigned __int8 **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (unsigned __int8 *)*((_QWORD *)v4 + 2);
          v9 = *(_QWORD *)v8 == (_QWORD)v4;
          v4 = v8;
        }
        while (!v9);
      }
      v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *sub_10068C77C(uint64_t **a1, uint64_t *a2, unsigned __int8 *uu2, uint64_t a4)
{
  uint64_t **v6;
  uint64_t *result;
  uint64_t *v8[3];
  uint64_t v9;
  const unsigned __int8 *v10;

  v9 = 0;
  v10 = 0;
  v6 = (uint64_t **)sub_1006490EC(a1, a2, &v10, &v9, uu2);
  result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_10068C808((uint64_t)a1, a4, v8);
    sub_100004078(a1, (uint64_t)v10, v6, v8[0]);
    return v8[0];
  }
  return result;
}

uint64_t sub_10068C808@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v5;
  _QWORD *v6;
  void *v7;
  uint64_t result;

  v5 = a1 + 8;
  *a3 = 0;
  a3[2] = 0;
  a3[1] = 0;
  v6 = a3 + 1;
  v7 = operator new(0x40uLL);
  *a3 = v7;
  *v6 = v5;
  *((_BYTE *)a3 + 16) = 0;
  result = sub_10068C894((uint64_t)v7 + 32, a2);
  *((_BYTE *)a3 + 16) = 1;
  return result;
}

void sub_10068C878(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;

  *v1 = 0;
  sub_10068BFAC(v2, v3);
  _Unwind_Resume(a1);
}

uint64_t sub_10068C894(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  uuid_copy((unsigned __int8 *)a1, (const unsigned __int8 *)a2);
  v4 = *(_QWORD *)(a2 + 24);
  *(_QWORD *)(a1 + 16) = &off_100918298;
  *(_QWORD *)(a1 + 24) = v4;
  if (v4)
    sub_10003C37C(v4);
  return a1;
}

uint64_t *sub_10068C8D4(uint64_t *a1, uint64_t a2)
{
  uint64_t i;
  _QWORD *v5;
  uint64_t v6;

  *a1 = (uint64_t)a1;
  a1[1] = (uint64_t)a1;
  a1[2] = 0;
  for (i = *(_QWORD *)(a2 + 8); i != a2; i = *(_QWORD *)(i + 8))
  {
    v5 = sub_10066A19C((uint64_t)a1, 0, 0, (const unsigned __int8 *)(i + 16));
    v6 = *a1;
    *v5 = *a1;
    v5[1] = a1;
    *(_QWORD *)(v6 + 8) = v5;
    *a1 = (uint64_t)v5;
    ++a1[2];
  }
  return a1;
}

void sub_10068C950(_Unwind_Exception *a1)
{
  _QWORD *v1;

  sub_10002074C(v1);
  _Unwind_Resume(a1);
}

uint64_t *sub_10068C964(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_10068C9B8(a1, *(unsigned __int8 **)a2, (unsigned __int8 *)(a2 + 8));
  return a1;
}

void sub_10068C9A0(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_10001A82C(v1, *(_QWORD **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_10068C9B8(uint64_t *result, unsigned __int8 *a2, unsigned __int8 *a3)
{
  unsigned __int8 *v4;
  uint64_t **v5;
  uint64_t *v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  BOOL v9;

  if (a2 != a3)
  {
    v4 = a2;
    v5 = (uint64_t **)result;
    v6 = result + 1;
    do
    {
      result = sub_10068CA3C(v5, v6, v4 + 32, (uint64_t)(v4 + 32));
      v7 = (unsigned __int8 *)*((_QWORD *)v4 + 1);
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = *(unsigned __int8 **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (unsigned __int8 *)*((_QWORD *)v4 + 2);
          v9 = *(_QWORD *)v8 == (_QWORD)v4;
          v4 = v8;
        }
        while (!v9);
      }
      v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *sub_10068CA3C(uint64_t **a1, uint64_t *a2, unsigned __int8 *uu2, uint64_t a4)
{
  uint64_t **v6;
  uint64_t *result;
  unsigned __int8 *v8[3];
  uint64_t v9;
  const unsigned __int8 *v10;

  v9 = 0;
  v10 = 0;
  v6 = (uint64_t **)sub_1006490EC(a1, a2, &v10, &v9, uu2);
  result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_10068CAC8((uint64_t)a1, a4, v8);
    sub_100004078(a1, (uint64_t)v10, v6, (uint64_t *)v8[0]);
    return (uint64_t *)v8[0];
  }
  return result;
}

void sub_10068CAC8(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned __int8 **a3@<X8>)
{
  unsigned __int8 *v5;
  unsigned __int8 *v6;

  v5 = (unsigned __int8 *)(a1 + 8);
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v6 = (unsigned __int8 *)operator new(0x38uLL);
  *a3 = v6;
  a3[1] = v5;
  *((_BYTE *)a3 + 16) = 0;
  uuid_copy(v6 + 32, (const unsigned __int8 *)a2);
  *((_QWORD *)v6 + 6) = *(_QWORD *)(a2 + 16);
  *((_BYTE *)a3 + 16) = 1;
}

void sub_10068CB2C(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void *v2;

  *v1 = 0;
  operator delete(v2);
  _Unwind_Resume(a1);
}

void sub_10068CB44(id a1)
{
  operator new();
}

void sub_10068CB84()
{
  operator delete();
}

void sub_10068CBA8(uint64_t a1@<X8>)
{
  uint64_t v1;

  *(_QWORD *)(v1 - 8) = a1;
}

_OWORD *sub_10068CBB8(_OWORD *a1, uint64_t a2, int a3)
{
  unint64_t v4;
  int v5;
  _OWORD *v6;

  if (a3 == 34)
  {
    v4 = 0;
    while (1)
    {
      v5 = *(unsigned __int8 *)(a2 + v4);
      v6 = a1;
      if (v5 == 114)
        goto LABEL_6;
      if (v5 == 99)
        break;
LABEL_7:
      if (v4 >= 0x22)
      {
        a1[10] = 0u;
        a1[11] = 0u;
        a1[8] = 0u;
        a1[9] = 0u;
        a1[6] = 0u;
        a1[7] = 0u;
        a1[4] = 0u;
        a1[5] = 0u;
        a1[2] = 0u;
        a1[3] = 0u;
        return a1;
      }
    }
    v6 = a1 + 1;
LABEL_6:
    *v6 = *(_OWORD *)(v4 + a2 + 1);
    v4 += 17;
    goto LABEL_7;
  }
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
    sub_100718B8C();
  return a1;
}

void sub_10068CC74(uint64_t a1, _WORD *a2)
{
  *a2 = 34;
  operator new[]();
}

uint64_t sub_10068CCCC(uint64_t a1)
{
  uint64_t v2;
  int v3;
  NSObject *v4;
  uint64_t v5;
  unsigned __int8 *v6;
  int v7;
  NSObject *v8;
  void *__p[2];
  char v11;
  uint8_t buf[8];
  char v13;

  *(_QWORD *)a1 = off_10093F720;
  *(_QWORD *)(a1 + 8) = &off_10093F780;
  *(_QWORD *)(a1 + 16) = &off_10093F798;
  *(_QWORD *)(a1 + 24) = 0;
  *(_BYTE *)(a1 + 41) = 0;
  sub_1000160D0(a1 + 48);
  *(_OWORD *)(a1 + 120) = 0u;
  *(_QWORD *)(a1 + 112) = a1 + 120;
  *(_QWORD *)(a1 + 216) = 0;
  *(_BYTE *)(a1 + 424) = 1;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_OWORD *)(a1 + 472) = 0u;
  *(_QWORD *)(a1 + 432) = 0;
  *(_QWORD *)(a1 + 440) = a1 + 448;
  *(_QWORD *)(a1 + 464) = a1 + 472;
  *(_OWORD *)(a1 + 496) = 0u;
  *(_QWORD *)(a1 + 488) = a1 + 496;
  *(_OWORD *)(a1 + 520) = 0u;
  *(_QWORD *)(a1 + 512) = a1 + 520;
  *(_QWORD *)(a1 + 536) = a1 + 544;
  *(_WORD *)(a1 + 594) = 0;
  *(_BYTE *)(a1 + 596) = 0;
  *(_BYTE *)(a1 + 3718) = 0;
  *(_BYTE *)(a1 + 592) = 0;
  *(_OWORD *)(a1 + 560) = 0u;
  *(_OWORD *)(a1 + 576) = 0u;
  *(_OWORD *)(a1 + 544) = 0u;
  *(_OWORD *)(a1 + 3720) = 0u;
  *(_WORD *)(a1 + 3736) = 25;
  *(_QWORD *)(a1 + 3752) = 0;
  v2 = sub_100027F68();
  sub_100091AE8(buf, "LE");
  sub_100091AE8(__p, "CloudPair");
  if ((*(unsigned int (**)(uint64_t, uint8_t *, void **, uint64_t))(*(_QWORD *)v2 + 72))(v2, buf, __p, a1 + 424))
  {
    v3 = *(unsigned __int8 *)(a1 + 424);
    if (v11 < 0)
      operator delete(__p[0]);
    if (v13 < 0)
    {
      operator delete(*(void **)buf);
      if (v3)
        goto LABEL_14;
    }
    else if (v3)
    {
      goto LABEL_14;
    }
    v4 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Warning: Cloud pairing disabled by defaults write", buf, 2u);
    }
  }
  else
  {
    if (v11 < 0)
      operator delete(__p[0]);
    if (v13 < 0)
      operator delete(*(void **)buf);
  }
LABEL_14:
  v5 = sub_100027F68();
  sub_100091AE8(buf, "LE");
  sub_100091AE8(__p, "LESecuredConnectionDebugKeys");
  v6 = (unsigned __int8 *)(a1 + 592);
  if ((*(unsigned int (**)(uint64_t, uint8_t *, void **, uint64_t))(*(_QWORD *)v5 + 72))(v5, buf, __p, a1 + 592))
  {
    v7 = *v6;
    if (v11 < 0)
      operator delete(__p[0]);
    if (v13 < 0)
    {
      operator delete(*(void **)buf);
      if (v7)
        goto LABEL_28;
    }
    else if (v7)
    {
      goto LABEL_28;
    }
    v8 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Warning: Using LE 4.2 Secured Conenctions DEBUG KEYS !!!!!!!!", buf, 2u);
    }
    sub_100238FF4(*v6);
  }
  else
  {
    if (v11 < 0)
      operator delete(__p[0]);
    if (v13 < 0)
      operator delete(*(void **)buf);
  }
LABEL_28:
  if (qword_100977A58 != -1)
    dispatch_once(&qword_100977A58, &stru_10093F9F8);
  sub_1002609C8((uint64_t)off_100977A50 + 64, a1);
  *(_QWORD *)(a1 + 3744) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 40) = 0;
  return a1;
}

void sub_10068CFE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object, _QWORD **a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD **v28;
  _QWORD **v29;
  _QWORD **v30;
  _QWORD **v31;
  _QWORD **v32;
  void *v33;

  if (a19 < 0)
    operator delete(__p);
  if (a25 < 0)
    operator delete(a20);

  v33 = *(void **)(v25 + 568);
  if (v33)
  {
    *(_QWORD *)(v25 + 576) = v33;
    operator delete(v33);
  }
  sub_1002BB6B8(v27 + 424, *v28);
  sub_1006A7228(v26, *v29);
  sub_1006A7228(v27 + 376, *a11);
  sub_1006A7228(a12, *v31);
  sub_1006A7228(v27 + 328, *v32);
  sub_1006A718C(v27, *v30);
  sub_100069BDC(a13);

  _Unwind_Resume(a1);
}

uint64_t sub_10068D0D4(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = off_10093F720;
  *(_QWORD *)(a1 + 8) = &off_10093F780;
  *(_QWORD *)(a1 + 16) = &off_10093F798;
  if (qword_100977A58 != -1)
    dispatch_once(&qword_100977A58, &stru_10093F9F8);
  sub_100069060((uint64_t)off_100977A50 + 64, a1);

  v2 = *(void **)(a1 + 568);
  if (v2)
  {
    *(_QWORD *)(a1 + 576) = v2;
    operator delete(v2);
  }
  sub_1002BB6B8(a1 + 536, *(_QWORD **)(a1 + 544));
  sub_1006A7228(a1 + 512, *(_QWORD **)(a1 + 520));
  sub_1006A7228(a1 + 488, *(_QWORD **)(a1 + 496));
  sub_1006A7228(a1 + 464, *(_QWORD **)(a1 + 472));
  sub_1006A7228(a1 + 440, *(_QWORD **)(a1 + 448));
  sub_1006A718C(a1 + 112, *(_QWORD **)(a1 + 120));
  sub_100069BDC(a1 + 48);

  return a1;
}

void sub_10068D1C0(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 568);
  if (v3)
  {
    *(_QWORD *)(v1 + 576) = v3;
    operator delete(v3);
  }
  sub_1002BB6B8(v1 + 536, *(_QWORD **)(v1 + 544));
  sub_1006A7228(v1 + 512, *(_QWORD **)(v1 + 520));
  sub_1006A7228(v1 + 488, *(_QWORD **)(v1 + 496));
  sub_1006A7228(v1 + 464, *(_QWORD **)(v1 + 472));
  sub_1006A7228(v1 + 440, *(_QWORD **)(v1 + 448));
  sub_1006A718C(v1 + 112, *(_QWORD **)(v1 + 120));
  sub_100069BDC(v1 + 48);

  _Unwind_Resume(a1);
}

void sub_10068D248(uint64_t a1)
{
  sub_10068D0D4(a1);
  operator delete();
}

uint64_t sub_10068D26C(uint64_t a1)
{
  uint64_t v2;
  _QWORD v4[2];

  v4[0] = 0;
  v4[1] = 0;
  sub_10003415C((uint64_t)v4, a1 + 48);
  v2 = *(unsigned __int8 *)(a1 + 3718);
  sub_100034234((uint64_t)v4);
  return v2;
}

uint64_t sub_10068D2B0(uint64_t a1)
{
  int v2;
  int v3;
  uint64_t result;
  int v5;
  int v6;
  int v7;
  __int16 v8;
  unsigned int v9;

  v9 = 0;
  v8 = 0;
  v7 = 0;
  v2 = sub_1002FD250(19, (UInt8 *)&v7, 6, &v9);
  if (v2 == -34019)
  {
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
      sub_100718BEC();
    return 130;
  }
  v3 = v2;
  result = 103;
  if (!v3 && v9 == 6)
  {
    *(_QWORD *)(a1 + 240) = ((unint64_t)v7 << 40) | ((unint64_t)BYTE1(v7) << 32) | ((unint64_t)BYTE2(v7) << 24) | ((unint64_t)HIBYTE(v7) << 16) | ((unint64_t)v8 << 8) | HIBYTE(v8) | 0x1000000000000;
    v5 = sub_1002FD250(17, (UInt8 *)(a1 + 152), 16, &v9);
    if (v5 == -34019)
    {
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
        sub_100718C18();
      return 130;
    }
    v6 = v5;
    result = 103;
    if (!v6 && v9 == 16)
    {
      result = sub_100184E88((__int128 *)(a1 + 152), 1, 0, (void *)(a1 + 224));
      if ((_DWORD)result)
      {
        if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
          sub_100718C44();
        return 130;
      }
    }
  }
  return result;
}

uint64_t sub_10068D438(__n128 *a1)
{
  NSObject *v2;
  NSObject *v3;
  NSObject *v4;
  NSObject *v5;
  uint8_t v7[9];
  unsigned __int8 v8;
  int v9;
  __int16 v10;

  v10 = 0;
  v9 = 0;
  v8 = 1;
  arc4random_buf(&v9, 6uLL);
  LOBYTE(v9) = v9 | 0xC0;
  v2 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v7 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Generating new non connectable identity address", v7, 2u);
  }
  if (sub_1002FD428(0x13u, (const UInt8 *)&v9, 6u))
  {
    v3 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)v7 = 0;
      _os_log_fault_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, "Failed to set new non connectable static random address!", v7, 2u);
      v3 = qword_100999818;
    }
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      sub_100718CD0();
    return 130;
  }
  a1[15].n128_u64[0] = ((unint64_t)v9 << 40) | ((unint64_t)BYTE1(v9) << 32) | ((unint64_t)BYTE2(v9) << 24) | ((unint64_t)HIBYTE(v9) << 16) | ((unint64_t)v10 << 8) | HIBYTE(v10) | ((unint64_t)v8 << 48);
  arc4random_buf(&a1[9].n128_i8[8], 0x10uLL);
  v4 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v7 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Generating new non connectable identity root", v7, 2u);
  }
  if (sub_1002FD428(0x11u, &a1[9].n128_u8[8], 0x10u))
  {
    v5 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)v7 = 0;
      _os_log_fault_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "Failed to set new non connectable identity root!", v7, 2u);
      v5 = qword_100999818;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      sub_100718CA4();
    return 130;
  }
  if (sub_100184E88((__int128 *)&a1[9].n128_i8[8], 1, 0, &a1[14]))
  {
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
      sub_100718C44();
    return 130;
  }
  sub_1002FD428(0x12u, (const UInt8 *)&a1[14], 0x10u);
  if (a1[2].n128_u8[9])
  {
    v7[0] = 0;
    sub_100043758(v7);
    sub_1001EDD1C(a1 + 14);
    sub_100043728(v7);
  }
  return 0;
}

void sub_10068D6CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  sub_100043728(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_10068D6E0(uint64_t a1)
{
  uint64_t v2;
  int v3;
  NSObject *v4;
  NSObject *v5;
  uint64_t v6;
  unsigned __int8 v7;
  NSObject *v8;
  unsigned __int8 v9;
  NSObject *v10;
  NSObject *v11;
  NSObject *v13;
  void **v14;
  void *__p;
  char v16;
  unsigned __int8 v17;
  int v18;
  __int16 v19;
  unsigned __int8 v20;
  int v21;
  __int16 v22;
  _QWORD v23[2];
  uint8_t buf[4];
  int v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  int v29;
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  int v33;
  __int16 v34;
  uint64_t v35;
  __int16 v36;
  int v37;
  __int16 v38;
  uint64_t v39;
  __int16 v40;
  void **v41;

  v23[0] = 0;
  v23[1] = 0;
  sub_10003415C((uint64_t)v23, a1 + 48);
  v2 = sub_10003BE44();
  v3 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 432))(v2);
  v4 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    v25 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "createTemporaryRootKeys in diagnostic mode :%d", buf, 8u);
  }
  if ((v3 & 1) != 0)
  {
    arc4random_buf((void *)(a1 + 136), 0x10uLL);
    arc4random_buf((void *)(a1 + 168), 0x10uLL);
    if (sub_100184E88((__int128 *)(a1 + 136), 1, 0, (void *)(a1 + 184)))
    {
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
        sub_100718DBC();
LABEL_22:
      v6 = 130;
      goto LABEL_23;
    }
    if (sub_100184E88((__int128 *)(a1 + 136), 3, 0, (void *)(a1 + 200)))
    {
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
        sub_100718D5C();
      goto LABEL_22;
    }
    v22 = 0;
    v21 = 0;
    v20 = 1;
    arc4random_buf(&v21, 6uLL);
    v7 = v21 | 0xC0;
    LOBYTE(v21) = v21 | 0xC0;
    v8 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "TTD: Generating new local static random", buf, 2u);
      v7 = v21;
    }
    *(_QWORD *)(a1 + 216) = ((unint64_t)v7 << 40) | ((unint64_t)BYTE1(v21) << 32) | ((unint64_t)BYTE2(v21) << 24) | ((unint64_t)HIBYTE(v21) << 16) | ((unint64_t)v22 << 8) | HIBYTE(v22) | ((unint64_t)v20 << 48);
    sub_100114948((__int128 *)(a1 + 136), (__n128 *)(a1 + 168));
    sub_10022BE24(*(_QWORD *)(a1 + 216));
    v19 = 0;
    v18 = 0;
    v17 = 1;
    arc4random_buf(&v18, 6uLL);
    v9 = v18 | 0xC0;
    LOBYTE(v18) = v18 | 0xC0;
    v10 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "TTD: Generating new non connectable identity address", buf, 2u);
      v9 = v18;
    }
    *(_QWORD *)(a1 + 240) = ((unint64_t)v9 << 40) | ((unint64_t)BYTE1(v18) << 32) | ((unint64_t)BYTE2(v18) << 24) | ((unint64_t)HIBYTE(v18) << 16) | ((unint64_t)v19 << 8) | HIBYTE(v19) | ((unint64_t)v17 << 48);
    arc4random_buf((void *)(a1 + 152), 0x10uLL);
    v11 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "TTD: Generating new non connectable identity root", buf, 2u);
    }
    if (sub_100184E88((__int128 *)(a1 + 152), 1, 0, (void *)(a1 + 224)))
    {
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
        sub_100718CFC();
      goto LABEL_22;
    }
    if (*(_BYTE *)(a1 + 41))
    {
      buf[0] = 0;
      sub_100043758(buf);
      sub_1001EDD1C((__n128 *)(a1 + 224));
      sub_100043728(buf);
    }
    v13 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
    {
      sub_1000217F4(*(_QWORD *)(a1 + 216));
      v14 = v16 >= 0 ? &__p : (void **)__p;
      *(_DWORD *)buf = 68225283;
      v25 = 16;
      v26 = 2097;
      v27 = a1 + 184;
      v28 = 1041;
      v29 = 16;
      v30 = 2097;
      v31 = a1 + 200;
      v32 = 1041;
      v33 = 16;
      v34 = 2097;
      v35 = a1 + 136;
      v36 = 1041;
      v37 = 16;
      v38 = 2097;
      v39 = a1 + 168;
      v40 = 2080;
      v41 = v14;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "TTD: created temporary IRK=%{private}.16P DHK=%{private}.16P IR=%{private}.16P ER=%{private}.16P fLocalStaticRandomAddress:%s", buf, 0x4Cu);
      if (v16 < 0)
        operator delete(__p);
    }
    v6 = 0;
    *(_BYTE *)(a1 + 3718) = 1;
  }
  else
  {
    v5 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "TTD: Not in Diagnostics mode, return", buf, 2u);
    }
    v6 = 152;
  }
LABEL_23:
  sub_100034234((uint64_t)v23);
  return v6;
}

void sub_10068DBAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  sub_100034234((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10068DBE8(uint64_t a1)
{
  uint64_t v2;
  int v3;
  NSObject *v4;
  uint64_t v5;
  int v6;
  BOOL v7;
  int v8;
  NSObject *v9;
  int v10;
  NSObject *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  NSObject *v25;
  int v26;
  NSObject *v27;
  NSObject *v29;
  void **v30;
  uint64_t v31;
  void *__p;
  char v33;
  unsigned __int8 v34;
  int v35;
  __int16 v36;
  unsigned int v37;
  _QWORD v38[2];
  uint8_t buf[4];
  int v40;
  __int16 v41;
  uint64_t v42;
  __int16 v43;
  int v44;
  __int16 v45;
  uint64_t v46;
  __int16 v47;
  int v48;
  __int16 v49;
  uint64_t v50;
  __int16 v51;
  int v52;
  __int16 v53;
  uint64_t v54;
  __int16 v55;
  void **v56;

  v38[0] = 0;
  v38[1] = 0;
  sub_10003415C((uint64_t)v38, a1 + 48);
  v37 = 0;
  v2 = sub_10003BE44();
  v3 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 432))(v2);
  v4 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    v40 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "readRootKeys diagnostics mode:%d", buf, 8u);
  }
  if (v3)
  {
    v5 = sub_10068D6E0(a1);
    goto LABEL_96;
  }
  v6 = sub_1002FD250(2, (UInt8 *)(a1 + 136), 16, &v37);
  if (v6 == -34019)
  {
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
      goto LABEL_37;
    goto LABEL_95;
  }
  if (v6)
    v7 = 0;
  else
    v7 = v37 == 16;
  v8 = !v7;
  if (!v7)
  {
    arc4random_buf((void *)(a1 + 136), 0x10uLL);
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
      sub_100719118();
    if (sub_1002FD428(2u, (const UInt8 *)(a1 + 136), 0x10u))
    {
      v9 = qword_100999818;
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "Failed to set new identity root!", buf, 2u);
        v9 = qword_100999818;
      }
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_1007190EC();
      goto LABEL_95;
    }
  }
  v10 = sub_1002FD250(1, (UInt8 *)(a1 + 168), 16, &v37);
  if (v10 == -34019)
  {
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
      goto LABEL_37;
    goto LABEL_95;
  }
  if (v10 || v37 != 16)
  {
    arc4random_buf((void *)(a1 + 168), 0x10uLL);
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
      sub_1007190C0();
    if (sub_1002FD428(1u, (const UInt8 *)(a1 + 168), 0x10u))
    {
      v11 = qword_100999818;
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, "Failed to set new encryption root!", buf, 2u);
        v11 = qword_100999818;
      }
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        sub_100719094();
      goto LABEL_95;
    }
    v8 = 1;
  }
  v12 = sub_1002FD250(5, (UInt8 *)(a1 + 312), 96, &v37);
  if (v12 == -34019)
  {
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
LABEL_37:
      sub_100718C18();
LABEL_95:
    v5 = 130;
    goto LABEL_96;
  }
  if (v12 || v37 != 96)
  {
    buf[0] = 96;
    if (sub_1001859C0((_OWORD *)(a1 + 248), (_OWORD *)(a1 + 312), (uint64_t)buf, v13, v14, v15, v16, v17))
    {
      if (!os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
        goto LABEL_95;
LABEL_45:
      sub_10071903C();
      goto LABEL_95;
    }
    if (sub_1002FD428(5u, (const UInt8 *)(a1 + 312), 0x60u))
    {
      if (!os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_FAULT))
        goto LABEL_95;
    }
    else
    {
      if (!sub_1002FD428(6u, (const UInt8 *)(a1 + 248), 0x40u))
        goto LABEL_48;
      if (!os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_FAULT))
        goto LABEL_95;
    }
LABEL_80:
    sub_100719010();
    goto LABEL_95;
  }
  v18 = sub_1002FD250(6, (UInt8 *)(a1 + 248), 64, &v37);
  if (v18 == -34019)
  {
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
      sub_100719068();
    goto LABEL_95;
  }
  if (v18 || v37 != 64)
  {
    buf[0] = 96;
    if (sub_1001859C0((_OWORD *)(a1 + 248), (_OWORD *)(a1 + 312), (uint64_t)buf, v19, v20, v21, v22, v23))
    {
      if (!os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
        goto LABEL_95;
      goto LABEL_45;
    }
    if (sub_1002FD428(5u, (const UInt8 *)(a1 + 312), 0x60u))
    {
      if (!os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_FAULT))
        goto LABEL_95;
    }
    else
    {
      if (!sub_1002FD428(6u, (const UInt8 *)(a1 + 248), 0x40u))
        goto LABEL_48;
      if (!os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_FAULT))
        goto LABEL_95;
    }
    goto LABEL_80;
  }
LABEL_48:
  v24 = sub_1002FD250(7, (UInt8 *)(a1 + 408), 16, &v37);
  if (v24 == -34019)
  {
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
      sub_100718E1C();
    goto LABEL_95;
  }
  if (v24 || v37 != 16)
  {
    arc4random_buf((void *)(a1 + 408), 0x10uLL);
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
      sub_100718FE4();
    if (sub_1002FD428(7u, (const UInt8 *)(a1 + 408), 0x10u))
    {
      v25 = qword_100999818;
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_FAULT, "Failed to set new Cloud Nonce!", buf, 2u);
        v25 = qword_100999818;
      }
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        sub_100718FB8();
      goto LABEL_95;
    }
  }
  if (sub_100184E88((__int128 *)(a1 + 136), 1, 0, (void *)(a1 + 184)))
  {
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
      sub_100718F58();
    goto LABEL_95;
  }
  sub_1002FD428(8u, (const UInt8 *)(a1 + 184), 0x10u);
  if (sub_100184E88((__int128 *)(a1 + 136), 3, 0, (void *)(a1 + 200)))
  {
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
      sub_100718EF8();
    goto LABEL_95;
  }
  if (v8 && sub_10068E528(a1))
  {
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
      sub_100718E48();
    sub_10068E620();
    v31 = sub_100027F68();
    sub_100576500(v31, 1);
  }
  v36 = 0;
  v35 = 0;
  v34 = 1;
  v26 = sub_1002FD250(16, (UInt8 *)&v35, 6, &v37);
  if (v26 == -34019)
  {
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
      sub_100718E74();
    goto LABEL_95;
  }
  if (v26 || v37 != 6)
  {
    arc4random_buf(&v35, 6uLL);
    LOBYTE(v35) = v35 | 0xC0;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
      sub_100718ECC();
    if (sub_1002FD428(0x10u, (const UInt8 *)&v35, 6u))
    {
      v27 = qword_100999818;
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_FAULT, "Failed to set new local static random address!", buf, 2u);
        v27 = qword_100999818;
      }
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        sub_100718EA0();
      goto LABEL_95;
    }
  }
  *(_QWORD *)(a1 + 216) = ((unint64_t)v35 << 40) | ((unint64_t)BYTE1(v35) << 32) | ((unint64_t)BYTE2(v35) << 24) | ((unint64_t)HIBYTE(v35) << 16) | ((unint64_t)v36 << 8) | HIBYTE(v36) | ((unint64_t)v34 << 48);
  sub_100114948((__int128 *)(a1 + 136), (__n128 *)(a1 + 168));
  sub_10022BE24(*(_QWORD *)(a1 + 216));
  v5 = sub_10068D2B0(a1);
  if ((_DWORD)v5 != 130)
  {
    if ((_DWORD)v5 != 103 || (v5 = sub_10068D438((__n128 *)a1), !(_DWORD)v5))
    {
      v29 = qword_100999818;
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
      {
        sub_1000217F4(*(_QWORD *)(a1 + 216));
        v30 = v33 >= 0 ? &__p : (void **)__p;
        *(_DWORD *)buf = 68225283;
        v40 = 16;
        v41 = 2097;
        v42 = a1 + 184;
        v43 = 1041;
        v44 = 16;
        v45 = 2097;
        v46 = a1 + 200;
        v47 = 1041;
        v48 = 16;
        v49 = 2097;
        v50 = a1 + 136;
        v51 = 1041;
        v52 = 16;
        v53 = 2097;
        v54 = a1 + 168;
        v55 = 2080;
        v56 = v30;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "IRK=%{private}.16P DHK=%{private}.16P IR=%{private}.16P ER=%{private}.16P fLocalStaticRandomAddress:%s", buf, 0x4Cu);
        if (v33 < 0)
          operator delete(__p);
      }
      *(_BYTE *)(a1 + 3718) = 1;
      sub_10068E698(a1);
      v5 = 0;
    }
  }
LABEL_96:
  sub_100034234((uint64_t)v38);
  return v5;
}

void sub_10068E4F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  sub_100034234((uint64_t)va);
  _Unwind_Resume(a1);
}

BOOL sub_10068E528(uint64_t a1)
{
  const unsigned __int8 *v2;
  id v3;
  void *v4;
  _BOOL8 v5;
  unsigned __int8 *v6;
  const unsigned __int8 **v7;
  BOOL v8;
  _QWORD v10[2];

  v10[0] = 0;
  v10[1] = 0;
  sub_10003415C((uint64_t)v10, a1 + 48);
  if (!*(_QWORD *)(a1 + 456) || (v2 = *(const unsigned __int8 **)(a1 + 440), v2 == (const unsigned __int8 *)(a1 + 448)))
  {
    v5 = 0;
  }
  else
  {
    while (1)
    {
      v3 = sub_100030DF4(v2 + 32);
      v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
      v5 = sub_100030864(a1, v4);

      if (v5)
        break;
      v6 = (unsigned __int8 *)*((_QWORD *)v2 + 1);
      if (v6)
      {
        do
        {
          v7 = (const unsigned __int8 **)v6;
          v6 = *(unsigned __int8 **)v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          v7 = (const unsigned __int8 **)*((_QWORD *)v2 + 2);
          v8 = *v7 == v2;
          v2 = (const unsigned __int8 *)v7;
        }
        while (!v8);
      }
      v2 = (const unsigned __int8 *)v7;
      if (v7 == (const unsigned __int8 **)(a1 + 448))
        goto LABEL_13;
    }
    v5 = 1;
  }
LABEL_13:
  sub_100034234((uint64_t)v10);
  return v5;
}

void sub_10068E600(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100034234((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_10068E620()
{
  uint64_t v0;
  void *__p[2];
  char v2;

  v0 = sub_100027F68();
  sub_100091AE8(__p, "LeSecurityManager hit a keychain problem.");
  sub_100576534(v0, (uint64_t *)__p, 3172327085);
  if (v2 < 0)
    operator delete(__p[0]);
}

void sub_10068E67C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_10068E698(uint64_t a1)
{
  UInt8 *v2;
  NSObject *v3;
  uint64_t v4;
  void *v5;
  UInt8 *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  void *v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  void *v17;
  id v18;
  int v19;
  id v20;
  int v21;
  id v22;
  int v23;
  id v24;
  uint64_t v25;
  NSObject *v26;
  uint64_t v27;
  int v28;
  _WORD size[11];
  int v31;
  char v32;
  uint8_t buf[32];
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  _BYTE v49[29];

  *(_DWORD *)&size[1] = 0;
  v2 = (UInt8 *)(a1 + 32);
  if (sub_1002FD250(11, (UInt8 *)(a1 + 32), 4, (unsigned int *)&size[1]) || *(_DWORD *)&size[1] != 4)
  {
    *(_DWORD *)v2 = 144;
    v3 = qword_100999930;
    if (os_log_type_enabled((os_log_t)qword_100999930, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "readTEKsFromKeychain empty fEKRollingPeriod", buf, 2u);
    }
    sub_1002FD428(0xBu, v2, 4u);
  }
  v4 = objc_claimAutoreleasedReturnValue(+[NSMutableArray array](NSMutableArray, "array"));
  v5 = *(void **)(a1 + 24);
  *(_QWORD *)(a1 + 24) = v4;

  size[0] = 301;
  if (sub_1002FD250(13, (UInt8 *)size, 2, (unsigned int *)&size[1]) || *(_DWORD *)&size[1] != 2)
  {
    v12 = sub_100027F68();
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v12 + 176))(v12))
    {
      v13 = qword_100999930;
      if (os_log_type_enabled((os_log_t)qword_100999930, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_INFO, "reading old TEK Keychain storage", buf, 2u);
      }
    }
    size[0] = 301;
    v48 = 0u;
    memset(v49, 0, sizeof(v49));
    v46 = 0u;
    v47 = 0u;
    v44 = 0u;
    v45 = 0u;
    v42 = 0u;
    v43 = 0u;
    v40 = 0u;
    v41 = 0u;
    v38 = 0u;
    v39 = 0u;
    v36 = 0u;
    v37 = 0u;
    v34 = 0u;
    v35 = 0u;
    memset(buf, 0, sizeof(buf));
    if (sub_1002FD250(10, buf, 301, (unsigned int *)&size[1]) || *(_DWORD *)&size[1] != 301)
    {
      if (os_log_type_enabled((os_log_t)qword_100999928, OS_LOG_TYPE_ERROR))
        sub_100719144();
    }
    else if (buf[0])
    {
      v14 = 0;
      v15 = 20 * buf[0];
      do
      {
        *(_OWORD *)&size[3] = *(_OWORD *)&buf[v14 + 1];
        v31 = *(_DWORD *)&buf[v14 + 17];
        v32 = *(_DWORD *)(a1 + 32);
        v16 = *(void **)(a1 + 24);
        v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", &size[3], 21));
        objc_msgSend(v16, "addObject:", v17);

        v14 += 20;
      }
      while (v15 != v14);
    }
    sub_1006A38A8(a1);
  }
  else if (size[0])
  {
    v6 = (UInt8 *)malloc_type_malloc(size[0], 0x6DC56CA0uLL);
    if (sub_1002FD250(14, v6, size[0], (unsigned int *)&size[1]) || *(_DWORD *)&size[1] != size[0])
    {
      if (os_log_type_enabled((os_log_t)qword_100999928, OS_LOG_TYPE_ERROR))
        sub_100719170();
    }
    else if (size[0])
    {
      v7 = 0;
      do
      {
        v8 = v6[v7];
        v9 = v7 + 1;
        v10 = *(void **)(a1 + 24);
        v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", &v6[v7 + 1], v8));
        objc_msgSend(v10, "addObject:", v11);

        v7 = v9 + v8;
      }
      while (v9 + v8 < (unint64_t)size[0]);
    }
    free(v6);
  }
  sub_1006A3F28(a1);
  if (objc_msgSend(*(id *)(a1 + 24), "count"))
  {
    v18 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 24), "objectAtIndex:", 0)));
    v19 = *((unsigned __int8 *)objc_msgSend(v18, "bytes") + 16);
    v20 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 24), "objectAtIndex:", 0)));
    v21 = *((unsigned __int8 *)objc_msgSend(v20, "bytes") + 17);
    v22 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 24), "objectAtIndex:", 0)));
    v23 = *((unsigned __int8 *)objc_msgSend(v22, "bytes") + 18);
    v24 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 24), "objectAtIndex:", 0)));
    *(_DWORD *)(a1 + 36) = v19 | (v21 << 8) | (v23 << 16) | (*((unsigned __int8 *)objc_msgSend(v24, "bytes") + 19) << 24);

  }
  v25 = sub_100027F68();
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v25 + 184))(v25))
  {
    v26 = qword_100999930;
    if (os_log_type_enabled((os_log_t)qword_100999930, OS_LOG_TYPE_INFO))
    {
      v27 = *(_QWORD *)(a1 + 24);
      v28 = *(_DWORD *)(a1 + 36);
      *(_DWORD *)buf = 138412546;
      *(_QWORD *)&buf[4] = v27;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v28;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_INFO, "readTEKsFromKeychain fTEKArray %@ fENIntervalNumber=%d", buf, 0x12u);
    }
  }
  return 0;
}

void sub_10068EB28(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_10068EB7C(uint64_t a1)
{
  uint64_t v1;
  id v2;
  id v3;
  id v4;
  uint64_t v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  id v10;
  NSObject *v11;
  id v12;
  void *v13;
  id v14;
  id v15;
  void *v16;
  id v17;
  void *v18;
  uint8_t *v19;
  void *v20;
  id v21;
  void *v22;
  void *v23;
  int v24;
  int v25;
  id v26;
  NSObject *v27;
  id v28;
  id v29;
  const char *v30;
  uint64_t v31;
  void *v32;
  void *v33;
  void *__p[2];
  char v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  _QWORD v41[2];
  unsigned __int8 uu[8];
  uint64_t v43;
  uint8_t buf[24];
  uint64_t v45;
  _BYTE v46[128];

  v1 = sub_10003BE44();
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v1 + 432))(v1))
  {
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
      sub_10071919C();
    return;
  }
  v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary"));
  v41[0] = 0;
  v41[1] = 0;
  sub_10003415C((uint64_t)v41, a1 + 48);
  v2 = sub_1002FC5A4(0);
  v32 = (void *)objc_claimAutoreleasedReturnValue(v2);
  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_10093FA18);
  sub_10065A204((uint64_t)off_1009778C0, v32, 0);
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  v3 = v32;
  v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v37, v46, 16);
  if (v4)
  {
    v5 = *(_QWORD *)v38;
    do
    {
      v6 = 0;
      do
      {
        if (*(_QWORD *)v38 != v5)
          objc_enumerationMutation(v3);
        v7 = *(void **)(*((_QWORD *)&v37 + 1) + 8 * (_QWORD)v6);
        v8 = objc_autoreleasePoolPush();
        v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectForKeyedSubscript:", v7));
        v10 = objc_msgSend(v9, "unsignedLongLongValue");

        v11 = qword_100999818;
        if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
        {
          v12 = sub_100021770((uint64_t)v10);
          v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
          *(_DWORD *)buf = 138543874;
          *(_QWORD *)&buf[4] = v13;
          *(_WORD *)&buf[12] = 2114;
          *(_QWORD *)&buf[14] = v7;
          *(_WORD *)&buf[22] = 2048;
          v45 = 0;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "MUC - BTAddr %{public}@, BTUUID %{public}@, HostAddr to use 0x%llx", buf, 0x20u);

        }
        if (sub_10068F1D8(a1, (unint64_t)v10, v7))
        {
          *(_QWORD *)uu = 0;
          v43 = 0;
          if (qword_1009778C8 != -1)
            dispatch_once(&qword_1009778C8, &stru_10093FA18);
          sub_10003F924((uint64_t)off_1009778C0, (unint64_t)v10, 0, 1u, 0, 0, uu);
          if (uuid_is_null(uu))
          {
            if (uuid_is_null(uu) && os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_FAULT))
            {
              v14 = sub_100021770((uint64_t)v10);
              objc_claimAutoreleasedReturnValue(v14);
              sub_1007191C8();
            }
            goto LABEL_23;
          }
          memset(buf, 0, sizeof(buf));
          if (qword_1009778C8 != -1)
            dispatch_once(&qword_1009778C8, &stru_10093FA18);
          v16 = off_1009778C0;
          v17 = sub_100030DF4(uu);
          v18 = (void *)objc_claimAutoreleasedReturnValue(v17);
          sub_1006594CC((uint64_t)v16, v18, (uint64_t)buf);

          if ((char)buf[23] < 0)
          {
            if (*(_QWORD *)&buf[8])
            {
              v19 = *(uint8_t **)buf;
LABEL_32:
              v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v19, v32));
              v21 = sub_100030DF4(uu);
              v22 = (void *)objc_claimAutoreleasedReturnValue(v21);
              objc_msgSend(v33, "setObject:forKeyedSubscript:", v20, v22);

            }
          }
          else if (buf[23])
          {
            v19 = buf;
            goto LABEL_32;
          }
          if (qword_1009778C8 != -1)
            dispatch_once(&qword_1009778C8, &stru_10093FA18);
          v23 = off_1009778C0;
          sub_100091AE8(__p, "_HIDEINSETTINGS_");
          v24 = sub_10000628C((uint64_t)v23, v7, (uint64_t)__p);
          v25 = v24;
          if (v36 < 0)
          {
            operator delete(__p[0]);
            if (!v25)
              goto LABEL_42;
          }
          else if (!v24)
          {
LABEL_42:
            if ((char)buf[23] < 0)
              operator delete(*(void **)buf);
            goto LABEL_23;
          }
          if (qword_1009778C8 != -1)
            dispatch_once(&qword_1009778C8, &stru_10093FA18);
          sub_10065DE88((uint64_t)off_1009778C0, v7, 1);
          goto LABEL_42;
        }
        if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
        {
          v15 = sub_100021770((uint64_t)v10);
          objc_claimAutoreleasedReturnValue(v15);
          sub_100719210();
        }
        sub_1002FD0B8((uint64_t)v10, 0, 1);
LABEL_23:
        objc_autoreleasePoolPop(v8);
        v6 = (char *)v6 + 1;
      }
      while (v4 != v6);
      v26 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v37, v46, 16);
      v4 = v26;
    }
    while (v26);
  }

  v27 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    v28 = objc_msgSend(v3, "count");
    v29 = objc_msgSend(v3, "count");
    v30 = "s";
    v31 = *(_QWORD *)(a1 + 456);
    *(_DWORD *)buf = 134218498;
    if (v29 == (id)1)
      v30 = "";
    *(_QWORD *)&buf[4] = v28;
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v30;
    *(_WORD *)&buf[22] = 2048;
    v45 = v31;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Found %lu paired LE device%{public}s in local keychain, loaded %lu", buf, 0x20u);
  }

  sub_100034234((uint64_t)v41);
}

void sub_10068F10C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,void *__p,uint64_t a39,int a40,__int16 a41,char a42,char a43)
{

  sub_100034234((uint64_t)&a30);
  _Unwind_Resume(a1);
}

uint64_t sub_10068F1D8(uint64_t a1, unint64_t a2, void *a3)
{
  id v5;
  id v6;
  _QWORD v8[2];
  _QWORD v9[2];
  unsigned __int8 uu[8];
  uint64_t v11;

  v5 = a3;
  v9[0] = 0;
  v9[1] = 0;
  sub_10003415C((uint64_t)v9, a1 + 48);
  *(_QWORD *)uu = 0;
  v11 = 0;
  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_10093FA18);
  sub_10003F924((uint64_t)off_1009778C0, a2, 0, 1u, 0, 0, uu);
  if (!uuid_is_null(uu))
  {
    v8[0] = 0;
    v8[1] = 0;
    sub_1006903B0(a1, v8);
  }
  if (uuid_is_null(uu) && os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_FAULT))
  {
    v6 = sub_100021770(a2);
    objc_claimAutoreleasedReturnValue(v6);
    sub_1007192A8();
  }
  sub_100034234((uint64_t)v9);

  return 1;
}

void sub_10068F6D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int *a5, ...)
{
  void *v5;
  uint64_t v6;
  va_list va;

  va_start(va, a5);
  if (*(char *)(v6 - 121) < 0)
    operator delete(*(void **)(v6 - 144));
  if (a5)
    sub_100056AAC(a5);
  sub_100034234((uint64_t)va);

  _Unwind_Resume(a1);
}

void sub_10068F79C(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  id v3;
  NSObject *v4;
  id v5;
  id v6;
  const char *v7;
  id v8;
  id v9;
  uint64_t v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  id v15;
  NSObject *v16;
  id v17;
  void *v18;
  id v19;
  void *v20;
  unsigned __int8 v21;
  void *v22;
  id v23;
  void *v24;
  uint64_t *v25;
  NSObject *v26;
  id v27;
  void *v28;
  NSObject *v29;
  id v30;
  id v31;
  void **v32;
  NSObject *v33;
  void *v34;
  void *__p[2];
  char v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  _QWORD v42[2];
  uint8_t v43[4];
  void *v44;
  __int16 v45;
  id v46;
  __int16 v47;
  void **v48;
  unsigned __int8 uu[8];
  uint64_t v50;
  _BYTE v51[128];
  uint8_t buf[40];

  v1 = sub_10003BE44();
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v1 + 432))(v1))
  {
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
      sub_10071919C();
  }
  else
  {
    v2 = sub_10003BE44();
    if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 352))(v2) & 1) != 0)
    {
      v42[0] = 0;
      v42[1] = 0;
      sub_10003415C((uint64_t)v42, a1 + 48);
      v3 = sub_1002FC5B8();
      v34 = (void *)objc_claimAutoreleasedReturnValue(v3);
      v4 = qword_100999818;
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
      {
        v5 = objc_msgSend(v34, "count");
        v6 = objc_msgSend(v34, "count");
        v7 = "s";
        if (v6 == (id)1)
          v7 = "";
        *(_DWORD *)buf = 134218242;
        *(_QWORD *)&buf[4] = v5;
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v7;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Found %lu paired LE device%{public}s in synchronized keychain", buf, 0x16u);
      }
      if (qword_1009778C8 != -1)
        dispatch_once(&qword_1009778C8, &stru_10093FA18);
      sub_10065A204((uint64_t)off_1009778C0, v34, 1);
      v40 = 0u;
      v41 = 0u;
      v38 = 0u;
      v39 = 0u;
      v8 = v34;
      v9 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v38, v51, 16);
      if (v9)
      {
        v10 = *(_QWORD *)v39;
        do
        {
          v11 = 0;
          do
          {
            if (*(_QWORD *)v39 != v10)
              objc_enumerationMutation(v8);
            v12 = *(void **)(*((_QWORD *)&v38 + 1) + 8 * (_QWORD)v11);
            v13 = objc_autoreleasePoolPush();
            v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "objectForKeyedSubscript:", v12));
            v15 = objc_msgSend(v14, "unsignedLongLongValue");

            *(_QWORD *)uu = 0;
            v50 = 0;
            if (qword_1009778C8 != -1)
              dispatch_once(&qword_1009778C8, &stru_10093FA18);
            sub_10003F924((uint64_t)off_1009778C0, (unint64_t)v15, 0, 1u, 0, 0, uu);
            if (uuid_is_null(uu))
            {
              v16 = qword_100999818;
              if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
              {
                v17 = sub_100021770((uint64_t)v15);
                v18 = (void *)objc_claimAutoreleasedReturnValue(v17);
                *(_DWORD *)buf = 138543362;
                *(_QWORD *)&buf[4] = v18;
                _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Failed to retrieve UUID for paired address %{public}@, this is a synced key from another device, we don't really care about it on this device.", buf, 0xCu);

              }
            }
            else
            {
              v19 = sub_100030DF4(uu);
              v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
              v21 = objc_msgSend(v12, "isEqual:", v20);

              if ((v21 & 1) != 0)
              {
                sub_10068F1D8(a1, (unint64_t)v15, v12);
                if (!sub_100030864(a1, v12))
                {
                  if (qword_1009778C8 != -1)
                    dispatch_once(&qword_1009778C8, &stru_10093FA18);
                  v22 = off_1009778C0;
                  v23 = sub_100030DF4(uu);
                  v24 = (void *)objc_claimAutoreleasedReturnValue(v23);
                  v25 = sub_1000306B0((uint64_t)v22, v24);
                  sub_10064D354(v25, 0);

                  v26 = qword_100999818;
                  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
                  {
                    v27 = sub_100021770((uint64_t)v15);
                    v28 = (void *)objc_claimAutoreleasedReturnValue(v27);
                    *(_DWORD *)buf = 138543618;
                    *(_QWORD *)&buf[4] = v12;
                    *(_WORD *)&buf[12] = 2114;
                    *(_QWORD *)&buf[14] = v28;
                    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Device \"%{public}@\" (%{public}@) is not really paired, its just a previously paired watch", buf, 0x16u);

                  }
                }
              }
              else
              {
                v29 = qword_100999818;
                if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
                {
                  v30 = sub_100021770((uint64_t)v15);
                  v31 = (id)objc_claimAutoreleasedReturnValue(v30);
                  memset(buf, 0, 37);
                  uuid_unparse_upper(uu, (char *)buf);
                  sub_100091AE8(__p, (char *)buf);
                  v32 = __p;
                  if (v37 < 0)
                    v32 = (void **)__p[0];
                  *(_DWORD *)v43 = 138543874;
                  v44 = v12;
                  v45 = 2114;
                  v46 = v31;
                  v47 = 2082;
                  v48 = v32;
                  _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "Device \"%{public}@\" (%{public}@) UUID from keychain is different than in local database(\"%{public}s\"). Ignoring keychain copy.", v43, 0x20u);
                  if (v37 < 0)
                    operator delete(__p[0]);

                }
              }
            }
            objc_autoreleasePoolPop(v13);
            v11 = (char *)v11 + 1;
          }
          while (v9 != v11);
          v9 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v38, v51, 16);
        }
        while (v9);
      }

      sub_100034234((uint64_t)v42);
    }
    else
    {
      v33 = qword_100999818;
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "skipping synchronized keychain read since this is not a phone.", buf, 2u);
      }
    }
  }
}

void sub_10068FD2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  void *v29;

  sub_100034234((uint64_t)&a29);
  _Unwind_Resume(a1);
}

BOOL sub_10068FDB8(uint64_t a1, uint64_t a2, int a3)
{
  _BOOL4 v3;
  uint64_t (**v5)();
  unsigned int *v6;

  v5 = 0;
  v6 = 0;
  sub_1003965C0(*(_QWORD *)(a2 + 8), a3, &v5);
  v3 = sub_1000452EC((uint64_t)&v5);
  v5 = &off_100918258;
  if (v6)
    sub_100056AAC(v6);
  return !v3;
}

void sub_10068FE14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, unsigned int *a10)
{
  if (a10)
    sub_100056AAC(a10);
  _Unwind_Resume(exception_object);
}

BOOL sub_10068FE38(uint64_t a1, uint64_t a2)
{
  unsigned int *v3;
  _BOOL8 v4;
  _BOOL4 v5;
  unsigned int *v6;
  _BOOL8 v7;
  _BOOL4 v8;
  unsigned int *v9;
  _BOOL8 v10;
  _BOOL4 v11;
  unsigned int *v12;
  _BOOL8 v13;
  _BOOL8 v14;
  unsigned int *v15;
  _BOOL8 v16;
  _BOOL4 v17;
  unsigned int *v18;
  _BOOL4 v19;
  _BOOL4 v20;
  NSObject *v21;
  _BOOL4 v22;
  _BOOL4 v23;
  uint64_t (**v26)();
  unsigned int *v27;
  uint64_t (**v28)();
  unsigned int *v29;
  uint64_t (**v30)();
  unsigned int *v31;
  uint64_t (**v32)();
  unsigned int *v33;
  _QWORD v34[2];
  _QWORD v35[2];
  _QWORD v36[2];
  _QWORD v37[2];
  _QWORD v38[2];
  _QWORD v39[2];
  uint64_t (**v40)();
  unsigned int *v41;
  __int128 v42;
  uint8_t buf[8];
  unsigned int *v44;
  _BOOL4 v45;
  __int16 v46;
  _BOOL4 v47;
  __int16 v48;
  _BOOL4 v49;
  __int16 v50;
  _BOOL4 v51;
  __int16 v52;
  _BOOL4 v53;

  v3 = *(unsigned int **)(a2 + 8);
  v39[0] = &off_100934340;
  v39[1] = v3;
  if (v3)
    sub_10003C37C((uint64_t)v3);
  v4 = sub_10068FDB8(a1, (uint64_t)v39, 0);
  v5 = v4;
  v39[0] = &off_100934340;
  if (v3)
    sub_100056AAC(v3);
  v6 = *(unsigned int **)(a2 + 8);
  v38[0] = &off_100934340;
  v38[1] = v6;
  if (v6)
    sub_10003C37C((uint64_t)v6);
  v7 = sub_10068FDB8(v4, (uint64_t)v38, 3);
  v8 = v7;
  v38[0] = &off_100934340;
  if (v6)
    sub_100056AAC(v6);
  v9 = *(unsigned int **)(a2 + 8);
  v37[0] = &off_100934340;
  v37[1] = v9;
  if (v9)
    sub_10003C37C((uint64_t)v9);
  v10 = sub_10068FDB8(v7, (uint64_t)v37, 4);
  v11 = v10;
  v37[0] = &off_100934340;
  if (v9)
    sub_100056AAC(v9);
  v12 = *(unsigned int **)(a2 + 8);
  v36[0] = &off_100934340;
  v36[1] = v12;
  if (v12)
    sub_10003C37C((uint64_t)v12);
  v13 = sub_10068FDB8(v10, (uint64_t)v36, 5);
  v14 = v13;
  v36[0] = &off_100934340;
  if (v12)
    sub_100056AAC(v12);
  v15 = *(unsigned int **)(a2 + 8);
  v35[0] = &off_100934340;
  v35[1] = v15;
  if (v15)
    sub_10003C37C((uint64_t)v15);
  v16 = sub_10068FDB8(v13, (uint64_t)v35, 9);
  v17 = v16;
  v35[0] = &off_100934340;
  if (v15)
    sub_100056AAC(v15);
  v18 = *(unsigned int **)(a2 + 8);
  v34[0] = &off_100934340;
  v34[1] = v18;
  if (v18)
    sub_10003C37C((uint64_t)v18);
  v19 = sub_10068FDB8(v16, (uint64_t)v34, 9);
  v34[0] = &off_100934340;
  if (v18)
    sub_100056AAC(v18);
  v32 = 0;
  v33 = 0;
  sub_1003965C0(*(_QWORD *)(a2 + 8), 7, &v32);
  v20 = !sub_1000452EC((uint64_t)&v32)
     && (*(_BYTE *)sub_10003EB18((uint64_t)&v32) == 2 || *(_BYTE *)sub_10003EB18((uint64_t)&v32) == 3);
  v21 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67110656;
    *(_DWORD *)&buf[4] = v14;
    LOWORD(v44) = 1024;
    *(_DWORD *)((char *)&v44 + 2) = v17;
    HIWORD(v44) = 1024;
    v45 = v19;
    v46 = 1024;
    v47 = v5;
    v48 = 1024;
    v49 = v11;
    v50 = 1024;
    v51 = v8;
    v52 = 1024;
    v53 = v20;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "hasLocalLTK=%d hasLocalRAND=%d hasLocalEDIV=%d hasRemoteLTK=%d hasRemoteRand=%d hasRemoteEDIV=%d securedConnection=%d", buf, 0x2Cu);
  }
  if (!v20)
  {
    if (!v5 && !v11 && !v8)
    {
      v14 = v17 ^ v19 ^ 1u;
      goto LABEL_62;
    }
    *(_QWORD *)buf = 0;
    v44 = 0;
    sub_1003965C0(*(_QWORD *)(a2 + 8), 1, buf);
    if (sub_10003F8C4((uint64_t)buf) && *(_BYTE *)sub_10003EB18((uint64_t)buf) == 16)
    {
      v42 = xmmword_10073B7C0;
      v30 = 0;
      v31 = 0;
      sub_10003994C(&v30, &v42, 0x10uLL);
      sub_1003965C0(*(_QWORD *)(a2 + 8), 0, &v40);
      v22 = sub_100068EA0((uint64_t)&v30, (uint64_t)&v40);
      v40 = &off_100918258;
      if (v41)
        sub_100056AAC(v41);
      if (v22)
      {
        if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
          sub_1007192E8();
        v23 = 1;
      }
      else
      {
        v40 = 0;
        v41 = 0;
        sub_10004C878((uint64_t)&v40, (uint64_t)&v42, 0x10uLL);
        v28 = 0;
        v29 = 0;
        sub_10003994C(&v28, &v40, 0x10uLL);
        sub_1003965C0(*(_QWORD *)(a2 + 8), 0, &v26);
        v23 = sub_100068EA0((uint64_t)&v28, (uint64_t)&v26);
        v26 = &off_100918258;
        if (v27)
          sub_100056AAC(v27);
        if (v23)
        {
          if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
            sub_1007192E8();
          v23 = 1;
        }
        v28 = &off_100918258;
        if (v29)
          sub_100056AAC(v29);
      }
      v30 = &off_100918258;
      if (v31)
        sub_100056AAC(v31);
      if (v23 || !v5)
        goto LABEL_59;
    }
    else if (!v5)
    {
LABEL_59:
      v14 = 0;
LABEL_60:
      *(_QWORD *)buf = &off_100918258;
      if (v44)
        sub_100056AAC(v44);
      goto LABEL_62;
    }
    v14 = v8 & v11;
    goto LABEL_60;
  }
LABEL_62:
  v32 = &off_100918258;
  if (v33)
    sub_100056AAC(v33);
  return v14;
}

void sub_100690288(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, unsigned int *a10, uint64_t a11, unsigned int *a12, uint64_t a13, unsigned int *a14, uint64_t a15, unsigned int *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30)
{
  uint64_t v30;
  unsigned int *v32;

  if (a10)
    sub_100056AAC(a10);
  if (a12)
    sub_100056AAC(a12);
  if (a14)
    sub_100056AAC(a14);
  *(_QWORD *)(v30 - 160) = &off_100918258;
  v32 = *(unsigned int **)(v30 - 152);
  if (v32)
    sub_100056AAC(v32);
  if (a16)
    sub_100056AAC(a16);
  _Unwind_Resume(exception_object);
}

void sub_1006903B0(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  _QWORD v3[2];

  v3[0] = 0;
  v3[1] = 0;
  sub_10003415C((uint64_t)v3, a1 + 48);
  *a2 = 0;
  a2[1] = 0;
  operator new();
}

void sub_1006910A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22,uint64_t a23,void *__p,uint64_t a25)
{
  _QWORD *v25;
  unsigned int *v26;
  uint64_t v27;

  *v25 = v27;
  sub_100056AAC(v26);
  sub_100034234((uint64_t)&a22);
  _Unwind_Resume(a1);
}

void sub_1006911A4()
{
  JUMPOUT(0x10069119CLL);
}

uint64_t sub_1006911AC(uint64_t a1, uint64_t a2, _WORD *a3)
{
  uint64_t v5;
  NSObject *v6;
  uint64_t (**v8)();
  unsigned int *v9;
  uint8_t buf[8];
  unsigned int *v11;
  _QWORD v12[2];

  v12[0] = 0;
  v12[1] = 0;
  sub_10003415C((uint64_t)v12, a1 + 48);
  v5 = *(_QWORD *)(a2 + 8);
  if (!a3 || !v5)
  {
    v6 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_fault_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "Invalid params dict and keys should always be valid", buf, 2u);
      v5 = *(_QWORD *)(a2 + 8);
    }
  }
  *(_QWORD *)buf = 0;
  v11 = 0;
  sub_1003965C0(v5, 6, buf);
  if (!sub_1000452EC((uint64_t)buf))
  {
    sub_1000455DC((uint64_t)buf, a3 + 22, 1uLL);
    sub_1003965C0(*(_QWORD *)(a2 + 8), 7, &v8);
    sub_100041698((uint64_t)buf, (uint64_t)&v8);
    v8 = &off_100918258;
    if (v9)
      sub_100056AAC(v9);
    if (!sub_1000452EC((uint64_t)buf))
    {
      sub_1000455DC((uint64_t)buf, (char *)a3 + 45, 1uLL);
      sub_1003965C0(*(_QWORD *)(a2 + 8), 5, &v8);
      sub_100041698((uint64_t)buf, (uint64_t)&v8);
      v8 = &off_100918258;
      if (v9)
        sub_100056AAC(v9);
      if (!sub_1000452EC((uint64_t)buf))
        sub_1000455DC((uint64_t)buf, a3 + 14, 0x10uLL);
    }
    a3[40] |= 8u;
  }
  sub_1003965C0(*(_QWORD *)(a2 + 8), 8, &v8);
  sub_100041698((uint64_t)buf, (uint64_t)&v8);
  v8 = &off_100918258;
  if (v9)
    sub_100056AAC(v9);
  if (!sub_1000452EC((uint64_t)buf))
  {
    sub_1000455DC((uint64_t)buf, a3 + 23, 2uLL);
    a3[40] |= 0x10u;
  }
  sub_1003965C0(*(_QWORD *)(a2 + 8), 9, &v8);
  sub_100041698((uint64_t)buf, (uint64_t)&v8);
  v8 = &off_100918258;
  if (v9)
    sub_100056AAC(v9);
  if (!sub_1000452EC((uint64_t)buf))
  {
    sub_1000455DC((uint64_t)buf, a3 + 24, 8uLL);
    a3[40] |= 0x20u;
  }
  sub_1003965C0(*(_QWORD *)(a2 + 8), 0, &v8);
  sub_100041698((uint64_t)buf, (uint64_t)&v8);
  v8 = &off_100918258;
  if (v9)
    sub_100056AAC(v9);
  if (!sub_1000452EC((uint64_t)buf))
  {
    sub_1000455DC((uint64_t)buf, a3, 0x10uLL);
    sub_1003965C0(*(_QWORD *)(a2 + 8), 1, &v8);
    sub_100041698((uint64_t)buf, (uint64_t)&v8);
    v8 = &off_100918258;
    if (v9)
      sub_100056AAC(v9);
    if (!sub_1000452EC((uint64_t)buf))
      sub_1000455DC((uint64_t)buf, a3 + 8, 1uLL);
    sub_1003965C0(*(_QWORD *)(a2 + 8), 2, &v8);
    sub_100041698((uint64_t)buf, (uint64_t)&v8);
    v8 = &off_100918258;
    if (v9)
      sub_100056AAC(v9);
    if (!sub_1000452EC((uint64_t)buf))
      sub_1000455DC((uint64_t)buf, (char *)a3 + 17, 1uLL);
    a3[40] |= 1u;
  }
  sub_1003965C0(*(_QWORD *)(a2 + 8), 3, &v8);
  sub_100041698((uint64_t)buf, (uint64_t)&v8);
  v8 = &off_100918258;
  if (v9)
    sub_100056AAC(v9);
  if (!sub_1000452EC((uint64_t)buf))
  {
    sub_1000455DC((uint64_t)buf, a3 + 9, 2uLL);
    a3[40] |= 2u;
  }
  sub_1003965C0(*(_QWORD *)(a2 + 8), 4, &v8);
  sub_100041698((uint64_t)buf, (uint64_t)&v8);
  v8 = &off_100918258;
  if (v9)
    sub_100056AAC(v9);
  if (!sub_1000452EC((uint64_t)buf))
  {
    sub_1000455DC((uint64_t)buf, a3 + 10, 8uLL);
    a3[40] |= 4u;
  }
  sub_1003965C0(*(_QWORD *)(a2 + 8), 10, &v8);
  sub_100041698((uint64_t)buf, (uint64_t)&v8);
  v8 = &off_100918258;
  if (v9)
    sub_100056AAC(v9);
  if (!sub_1000452EC((uint64_t)buf))
  {
    sub_1000455DC((uint64_t)buf, a3 + 28, 0x10uLL);
    a3[40] |= 0x40u;
  }
  sub_1003965C0(*(_QWORD *)(a2 + 8), 11, &v8);
  sub_100041698((uint64_t)buf, (uint64_t)&v8);
  v8 = &off_100918258;
  if (v9)
    sub_100056AAC(v9);
  if (!sub_1000452EC((uint64_t)buf))
  {
    sub_1000455DC((uint64_t)buf, a3 + 36, 7uLL);
    a3[40] |= 0x80u;
  }
  sub_1003965C0(*(_QWORD *)(a2 + 8), 16, &v8);
  sub_100041698((uint64_t)buf, (uint64_t)&v8);
  v8 = &off_100918258;
  if (v9)
    sub_100056AAC(v9);
  if (!sub_1000452EC((uint64_t)buf))
  {
    sub_1000455DC((uint64_t)buf, (char *)a3 + 79, 1uLL);
    a3[40] |= 0x100u;
  }
  *(_QWORD *)buf = &off_100918258;
  if (v11)
    sub_100056AAC(v11);
  return sub_100034234((uint64_t)v12);
}

void sub_100691668(_Unwind_Exception *a1, uint64_t a2, unsigned int *a3, uint64_t a4, unsigned int *a5, ...)
{
  va_list va;

  va_start(va, a5);
  if (a3)
    sub_100056AAC(a3);
  if (a5)
    sub_100056AAC(a5);
  sub_100034234((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100691720(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  const unsigned __int8 *v4;
  id v5;
  void *v6;
  unsigned __int8 *v7;
  const unsigned __int8 **v8;
  BOOL v9;
  const unsigned __int8 *v10;
  id v11;
  void *v12;
  unsigned __int8 v13;
  id v14;
  void *v15;
  char v16;
  uint64_t v17;
  void *v18;
  id v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  id v24;
  void *v25;
  int *v26;
  _OWORD *v27;
  unsigned __int8 *v28;
  const unsigned __int8 **v29;
  uint64_t (**v30)();
  unsigned int *v31;
  uint64_t (**v32)();
  unsigned int *v33;

  v2 = sub_10003BE44();
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v2 + 432))(v2))
  {
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
      sub_10071919C();
  }
  else
  {
    v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableSet set](NSMutableSet, "set"));
    if (*(_QWORD *)(a1 + 456))
    {
      v4 = *(const unsigned __int8 **)(a1 + 440);
      if (v4 != (const unsigned __int8 *)(a1 + 448))
      {
        do
        {
          v5 = sub_100030DF4(v4 + 32);
          v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
          objc_msgSend(v3, "addObject:", v6);

          v7 = (unsigned __int8 *)*((_QWORD *)v4 + 1);
          if (v7)
          {
            do
            {
              v8 = (const unsigned __int8 **)v7;
              v7 = *(unsigned __int8 **)v7;
            }
            while (v7);
          }
          else
          {
            do
            {
              v8 = (const unsigned __int8 **)*((_QWORD *)v4 + 2);
              v9 = *v8 == v4;
              v4 = (const unsigned __int8 *)v8;
            }
            while (!v9);
          }
          v4 = (const unsigned __int8 *)v8;
        }
        while (v8 != (const unsigned __int8 **)(a1 + 448));
      }
    }
    sub_10068F79C(a1);
    if (*(_BYTE *)(a1 + 41))
    {
      v10 = *(const unsigned __int8 **)(a1 + 440);
      if (v10 != (const unsigned __int8 *)(a1 + 448))
      {
        do
        {
          v11 = sub_100030DF4(v10 + 32);
          v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
          v13 = objc_msgSend(v3, "containsObject:", v12);

          v32 = 0;
          v33 = 0;
          sub_1003965C0(*((_QWORD *)v10 + 7), 10, &v32);
          if (!sub_1000452EC((uint64_t)&v32))
          {
            v14 = sub_100030DF4(v10 + 32);
            v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
            v16 = sub_100030864(a1, v15) | v13;

            if ((v16 & 1) == 0)
            {
              v17 = sub_1000438A4();
              if (qword_1009778C8 != -1)
                dispatch_once(&qword_1009778C8, &stru_10093FA18);
              v18 = off_1009778C0;
              v19 = sub_100030DF4(v10 + 32);
              v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
              v21 = sub_1000589DC((uint64_t)v18, v20, 0);
              v22 = sub_10003EB18((uint64_t)&v32);
              v23 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v17 + 376))(v17, v21, v22, 1);

              v24 = sub_100030DF4(v10 + 32);
              v25 = (void *)objc_claimAutoreleasedReturnValue(v24);
              sub_100691A74((uint64_t)v25, v25, v23);

              sub_1003965C0(*((_QWORD *)v10 + 7), 11, &v30);
              v26 = (int *)sub_10003EB18((uint64_t)&v30);
              v27 = (_OWORD *)sub_10003EB18((uint64_t)&v32);
              sub_100691AD8(a1, v26, v27);
              v30 = &off_100918258;
              if (v31)
                sub_100056AAC(v31);
            }
          }
          v32 = &off_100918258;
          if (v33)
            sub_100056AAC(v33);
          v28 = (unsigned __int8 *)*((_QWORD *)v10 + 1);
          if (v28)
          {
            do
            {
              v29 = (const unsigned __int8 **)v28;
              v28 = *(unsigned __int8 **)v28;
            }
            while (v28);
          }
          else
          {
            do
            {
              v29 = (const unsigned __int8 **)*((_QWORD *)v10 + 2);
              v9 = *v29 == v10;
              v10 = (const unsigned __int8 *)v29;
            }
            while (!v9);
          }
          v10 = (const unsigned __int8 *)v29;
        }
        while (v29 != (const unsigned __int8 **)(a1 + 448));
      }
    }

  }
}

void sub_1006919F8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_100691A74(uint64_t a1, void *a2, int a3)
{
  id v4;

  v4 = a2;
  if (a3 && os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
    sub_100719314();

}

BOOL sub_100691AD8(uint64_t a1, int *a2, _OWORD *a3)
{
  unint64_t v6;
  NSObject *v7;
  void **v8;
  void **v9;
  int v10;
  id v11;
  void *v12;
  _BOOL4 v13;
  int v14;
  NSObject *v15;
  void **v16;
  void *__p[2];
  char v19;
  void *v20[2];
  char v21;
  _BYTE out[40];
  uint8_t buf[4];
  void **v24;
  __int16 v25;
  const char *v26;
  unsigned __int8 uu[8];
  uint64_t v28;

  v6 = ((unint64_t)*((unsigned __int8 *)a2 + 1) << 40) | ((unint64_t)*((unsigned __int8 *)a2 + 2) << 32) | ((unint64_t)*((unsigned __int8 *)a2 + 3) << 24) | ((unint64_t)*((unsigned __int8 *)a2 + 4) << 16) | ((unint64_t)*((unsigned __int8 *)a2 + 5) << 8) | *((unsigned __int8 *)a2 + 6) | ((unint64_t)*(unsigned __int8 *)a2 << 48);
  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_10093FA18);
  *(_QWORD *)uu = 0;
  v28 = 0;
  sub_10003F924((uint64_t)off_1009778C0, v6, 0, 1u, 0, 0, uu);
  v7 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    v8 = v20;
    sub_1000217F4(v6);
    if (v21 < 0)
      v8 = (void **)v20[0];
    if (uuid_is_null(uu))
    {
      *(_DWORD *)buf = 136446466;
      v24 = v8;
      v25 = 2082;
      v26 = "NONE";
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Adding \"%{public}s\" (%{public}s) to the cache.", buf, 0x16u);
    }
    else
    {
      memset(out, 0, 37);
      uuid_unparse_upper(uu, out);
      sub_100091AE8(__p, out);
      if (v19 >= 0)
        v9 = __p;
      else
        v9 = (void **)__p[0];
      *(_DWORD *)buf = 136446466;
      v24 = v8;
      v25 = 2082;
      v26 = (const char *)v9;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Adding \"%{public}s\" (%{public}s) to the cache.", buf, 0x16u);
      if (v19 < 0)
        operator delete(__p[0]);
    }
    if (v21 < 0)
      operator delete(v20[0]);
  }
  if (uuid_is_null(uu))
  {
    v10 = 0;
  }
  else
  {
    v11 = sub_100030DF4(uu);
    v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
    v13 = sub_100030864(a1, v12);

    v10 = !v13;
  }
  LOBYTE(__p[0]) = 0;
  sub_100043758(__p);
  v14 = sub_10022E1E8(a2, a3, v10);
  sub_10004339C(__p);
  v15 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    sub_1000217F4(v6);
    if (v21 >= 0)
      v16 = v20;
    else
      v16 = (void **)v20[0];
    *(_DWORD *)out = 136447235;
    *(_QWORD *)&out[4] = v16;
    *(_WORD *)&out[12] = 1041;
    *(_DWORD *)&out[14] = 16;
    *(_WORD *)&out[18] = 2097;
    *(_QWORD *)&out[20] = a3;
    *(_WORD *)&out[28] = 1024;
    *(_DWORD *)&out[30] = v10;
    *(_WORD *)&out[34] = 1024;
    *(_DWORD *)&out[36] = v14;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Added \"%{public}s\" to the cache (irk=%{private}.16P, okToRePair=%d) status=%d", out, 0x28u);
    if (v21 < 0)
      operator delete(v20[0]);
  }
  sub_100043728(__p);
  return v14 == 0;
}

void sub_100691E1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  void *v17;

  _Unwind_Resume(a1);
}

uint64_t sub_100691E64(uint64_t a1)
{
  int v2;
  unsigned int v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  NSObject *v8;
  uint32_t v9;
  NSObject *v10;
  NSObject *v11;
  uint64_t v12;
  int v13;
  int v14;
  NSObject *v15;
  uint64_t v16;
  void *v17;
  uint64_t v19;
  void *__p[2];
  char v21;
  char v22;
  _QWORD v23[5];
  _QWORD handler[5];
  int out_token;
  _QWORD v26[2];
  __int128 v27;
  uint8_t buf[8];
  char v29;

  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_10093FA18);
  v2 = *((_DWORD *)off_1009778C0 + 38);
  v3 = *(unsigned __int16 *)(a1 + 3736);
  if (v3 < (unsigned __int16)v2)
  {
    LOWORD(v3) = v2 - 25;
    *(_WORD *)(a1 + 3736) = v2 - 25;
  }
  v4 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = (unsigned __int16)v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "We can have up to %d paired devices", buf, 8u);
  }
  v5 = sub_10068DBE8(a1);
  if ((_DWORD)v5)
  {
    sub_10068E620();
    v19 = sub_100027F68();
    sub_100091AE8(&v27, "");
    sub_1005756F0(v19, v5, &v27, 1);
  }
  v26[0] = 0;
  v26[1] = 0;
  sub_10003415C((uint64_t)v26, a1 + 48);
  sub_10068EB7C(a1);
  sub_10068F79C(a1);
  v6 = sub_10003BE44();
  v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 440))(v6);
  *(_BYTE *)(a1 + 3717) = v7;
  sub_1001EE550(v7 ^ 1u);
  if (*(_BYTE *)(a1 + 3717))
    sub_10023902C();
  out_token = 0;
  v8 = *(NSObject **)(sub_1000419F4() + 8);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472;
  handler[2] = sub_10069227C;
  handler[3] = &unk_100927440;
  handler[4] = a1;
  v9 = notify_register_dispatch("com.apple.mobile.keybagd.first_unlock", &out_token, v8, handler);
  v10 = qword_100999818;
  if (v9)
  {
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
      sub_100719374();
  }
  else if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Successfully registered for MKB first unlock notification", buf, 2u);
  }
  v11 = *(NSObject **)(sub_1000419F4() + 8);
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 3221225472;
  v23[2] = sub_1006923B8;
  v23[3] = &unk_100927440;
  v23[4] = a1;
  notify_register_dispatch("com.apple.purplebuddy.setupdone", &out_token, v11, v23);
  v22 = 0;
  v12 = sub_100027F68();
  sub_100091AE8(buf, "CT");
  sub_100091AE8(__p, "UseCTPrefixForCTCrypto");
  v13 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, char *))(*(_QWORD *)v12 + 72))(v12, buf, __p, &v22);
  if (v22)
    v14 = v13;
  else
    v14 = 0;
  if (v21 < 0)
    operator delete(__p[0]);
  if (v29 < 0)
  {
    operator delete(*(void **)buf);
    if (!v14)
      goto LABEL_27;
  }
  else if (!v14)
  {
    goto LABEL_27;
  }
  v15 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Warning: using the CT- prefix instead of EN- prefix for ContactTracing", buf, 2u);
  }
  *(_BYTE *)(a1 + 40) = 1;
LABEL_27:
  v16 = objc_claimAutoreleasedReturnValue(+[NSMutableArray array](NSMutableArray, "array"));
  v17 = *(void **)(a1 + 3752);
  *(_QWORD *)(a1 + 3752) = v16;

  sub_100692428(a1);
  if (qword_1009778A8 != -1)
    dispatch_once(&qword_1009778A8, &stru_10093FA38);
  sub_10061F358((uint64_t)off_1009778A0, a1 + 16, 0);
  return sub_100034234((uint64_t)v26);
}

void sub_10069220C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (a34 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_10069227C(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  _BOOL8 v3;
  int v4;
  NSObject *v5;
  _DWORD v6[2];

  v1 = *(_QWORD *)(a1 + 32);
  v2 = qword_100999818;
  v3 = os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    v6[0] = 67109120;
    v6[1] = MKBDeviceUnlockedSinceBoot(v3);
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Received MKB first unlock notification. MKBDeviceUnlockedSinceBoot returns : %d", (uint8_t *)v6, 8u);
  }
  v4 = MKBDeviceUnlockedSinceBoot(v3);
  v5 = qword_100999818;
  if (v4 != 1 && os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_FAULT))
  {
    LOWORD(v6[0]) = 0;
    _os_log_fault_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "Received MKB first unlock notification, but MKBDeviceUnlockedSinceBoot returns 0", (uint8_t *)v6, 2u);
    v5 = qword_100999818;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v6[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Received first unlock notification - loading keychain from synchronized again", (uint8_t *)v6, 2u);
  }
  sub_100691720(v1);
}

void sub_1006923B8(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  uint8_t v3[16];

  v1 = *(_QWORD *)(a1 + 32);
  v2 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Received setup done - loading keychain from synchrnized again", v3, 2u);
  }
  sub_100691720(v1);
}

void sub_100692428(uint64_t a1)
{
  void (***v2)(_QWORD, uint64_t **);
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  NSObject *v7;
  void **v8;
  void *__p[2];
  char v10;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t v13;
  uint8_t buf[4];
  void **v15;
  __int16 v16;
  int v17;
  _QWORD v18[2];

  bzero((void *)(a1 + 597), 0xC30uLL);
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v2 = (void (***)(_QWORD, uint64_t **))sub_10034D508();
  (**v2)(v2, &v11);
  v3 = v11;
  if (v11 == v12)
    goto LABEL_11;
  do
  {
    v4 = *v3;
    v18[0] = 0;
    v18[1] = 0;
    v5 = sub_10034D508();
    v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD *))(*(_QWORD *)v5 + 96))(v5, v4, 2, v18);
    v7 = qword_100999818;
    if (!os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
      goto LABEL_6;
    sub_10043E5F8(v4, __p);
    v8 = __p;
    if (v10 < 0)
      v8 = (void **)__p[0];
    *(_DWORD *)buf = 136446466;
    v15 = v8;
    v16 = 1024;
    v17 = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Read IRK for device %{public}s : result %d", buf, 0x12u);
    if ((v10 & 0x80000000) == 0)
    {
LABEL_6:
      if (v6)
        goto LABEL_9;
LABEL_7:
      LOBYTE(__p[0]) = 0;
      *(_DWORD *)((char *)__p + 1) = *(_DWORD *)(v4 + 128);
      *(_WORD *)((char *)__p + 5) = *(_WORD *)(v4 + 132);
      sub_100694CF4(a1, (unsigned __int8 *)__p, (uint64_t)v18);
      goto LABEL_9;
    }
    operator delete(__p[0]);
    if (!v6)
      goto LABEL_7;
LABEL_9:
    ++v3;
  }
  while (v3 != v12);
  v3 = v11;
LABEL_11:
  if (v3)
  {
    v12 = v3;
    operator delete(v3);
  }
}

void sub_1006925EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_100692614(uint64_t a1)
{
  uint64_t v2;
  unsigned __int8 v3;
  uint64_t v4;
  int v5;
  int v6;
  NSObject *v7;
  uint64_t v8;
  int v9;
  NSObject *v10;
  uint64_t v11;
  int v12;
  NSObject *v13;
  unsigned __int8 v14;
  uint64_t v15;
  int v16;
  int v17;
  NSObject *v18;
  uint64_t v19;
  int v20;
  int v21;
  NSObject *v22;
  uint64_t v23;
  int v24;
  int v25;
  NSObject *v26;
  uint64_t v27;
  int v28;
  int v29;
  NSObject *v30;
  _BOOL4 v31;
  __int16 v32;
  uint64_t v33;
  int v34;
  int v35;
  NSObject *v36;
  _BOOL4 v37;
  unsigned __int8 v38;
  uint64_t v39;
  int v40;
  int v41;
  NSObject *v42;
  _BOOL4 v43;
  unsigned __int8 v44;
  uint64_t v45;
  int v46;
  NSObject *v47;
  int v48;
  int v49;
  NSObject *v50;
  char v52;
  char v53;
  char v54;
  int v55;
  void *__p[2];
  char v57;
  char v58;
  char v59;
  _QWORD v60[2];
  uint8_t buf[8];
  char v62;

  v2 = sub_10003BE44();
  v3 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 80))(v2);
  v60[0] = 0;
  v60[1] = 0;
  sub_10003415C((uint64_t)v60, a1 + 48);
  v59 = 0;
  sub_100043758(&v59);
  if (!sub_100225224())
    goto LABEL_125;
  if (sub_100237D0C((__int128 *)(a1 + 136), (__n128 *)(a1 + 184), (__int128 *)(a1 + 168), (__int128 *)(a1 + 200), (__n128 *)(a1 + 224)))
  {
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
      sub_100719554();
    goto LABEL_125;
  }
  *(_OWORD *)(a1 + 184) = *sub_100239024();
  v58 = 0;
  v4 = sub_100027F68();
  sub_100091AE8(buf, "LE");
  sub_100091AE8(__p, "ForceBoolIOCaps");
  v5 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, char *))(*(_QWORD *)v4 + 72))(v4, buf, __p, &v58);
  if (v58)
    v6 = v5;
  else
    v6 = 0;
  if (v57 < 0)
    operator delete(__p[0]);
  if (v62 < 0)
    operator delete(*(void **)buf);
  if (v6)
  {
    v7 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v3 = 2;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Warning: Overriding LE security IO capabilities to YES/NO only - DEPRECATED - please move to modern defaults writes", buf, 2u);
    }
    else
    {
      v3 = 2;
    }
  }
  v55 = 0;
  v8 = sub_100027F68();
  sub_100091AE8(buf, "LE");
  sub_100091AE8(__p, "InputCaps");
  v9 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(_QWORD *)v8 + 88))(v8, buf, __p, &v55);
  if (v57 < 0)
    operator delete(__p[0]);
  if (v62 < 0)
    operator delete(*(void **)buf);
  if (v9)
  {
    v10 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v55;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Warning: Using override value (0x%02x) for LE input capabilities", buf, 8u);
    }
    v3 = v55;
  }
  v11 = sub_100027F68();
  sub_100091AE8(buf, "LE");
  sub_100091AE8(__p, "OutputCaps");
  v12 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(_QWORD *)v11 + 88))(v11, buf, __p, &v55);
  if (v57 < 0)
    operator delete(__p[0]);
  if (v62 < 0)
  {
    operator delete(*(void **)buf);
    if (v12)
      goto LABEL_28;
LABEL_32:
    v14 = 32;
    goto LABEL_33;
  }
  if (!v12)
    goto LABEL_32;
LABEL_28:
  v13 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v55;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Warning: Using override value (0x%02x) for LE output capabilities", buf, 8u);
  }
  v14 = v55;
LABEL_33:
  v54 = 0;
  v15 = sub_100027F68();
  sub_100091AE8(buf, "LE");
  sub_100091AE8(__p, "DisableSSP");
  v16 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, char *))(*(_QWORD *)v15 + 72))(v15, buf, __p, &v54);
  if (v54)
    v17 = v16;
  else
    v17 = 0;
  if (v57 < 0)
    operator delete(__p[0]);
  if (v62 < 0)
    operator delete(*(void **)buf);
  if (v17)
  {
    v18 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Warning: LE secured connections disabled by defaults write", buf, 2u);
    }
  }
  v53 = 0;
  v19 = sub_100027F68();
  sub_100091AE8(buf, "LE");
  sub_100091AE8(__p, "DisableH7");
  v20 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, char *))(*(_QWORD *)v19 + 72))(v19, buf, __p, &v53);
  if (v53)
    v21 = v20;
  else
    v21 = 0;
  if (v57 < 0)
    operator delete(__p[0]);
  if (v62 < 0)
  {
    operator delete(*(void **)buf);
    if (!v21)
      goto LABEL_55;
  }
  else if (!v21)
  {
    goto LABEL_55;
  }
  v22 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Warning: Disabling LE SMP local H7 support!", buf, 2u);
  }
  sub_100239004();
LABEL_55:
  v52 = 0;
  v23 = sub_100027F68();
  sub_100091AE8(buf, "LE");
  sub_100091AE8(__p, "ForceReplyH7");
  v24 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, char *))(*(_QWORD *)v23 + 72))(v23, buf, __p, &v52);
  if (v52)
    v25 = v24;
  else
    v25 = 0;
  if (v57 < 0)
    operator delete(__p[0]);
  if (v62 < 0)
  {
    operator delete(*(void **)buf);
    if (!v25)
      goto LABEL_67;
  }
  else if (!v25)
  {
    goto LABEL_67;
  }
  v26 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Warning: Forcing LE SMP to reply with H7!", buf, 2u);
  }
  sub_100239014();
LABEL_67:
  v27 = sub_100027F68();
  sub_100091AE8(buf, "LE");
  sub_100091AE8(__p, "OverrideMaxLEPairedDevices");
  v28 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(_QWORD *)v27 + 88))(v27, buf, __p, &v55);
  if (v55 > 0)
    v29 = v28;
  else
    v29 = 0;
  if (v57 < 0)
    operator delete(__p[0]);
  if (v62 < 0)
    operator delete(*(void **)buf);
  if (v29)
  {
    v30 = qword_100999818;
    v31 = os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT);
    v32 = v55;
    if (v31)
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v55;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "Warning: Overriding max number of allowed LE Paired devices to %d", buf, 8u);
      v32 = v55;
    }
    *(_WORD *)(a1 + 3736) = v32;
  }
  v33 = sub_100027F68();
  sub_100091AE8(buf, "LE");
  sub_100091AE8(__p, "OverrideInitiatorKeys");
  v34 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(_QWORD *)v33 + 88))(v33, buf, __p, &v55);
  if (v55 > 0)
    v35 = v34;
  else
    v35 = 0;
  if (v57 < 0)
    operator delete(__p[0]);
  if (v62 < 0)
  {
    operator delete(*(void **)buf);
    if (!v35)
      goto LABEL_90;
  }
  else if (!v35)
  {
    goto LABEL_90;
  }
  v36 = qword_100999818;
  v37 = os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT);
  v38 = v55;
  if (v37)
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v55;
    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "Warning: Overriding initiator keys to 0x%0x", buf, 8u);
    v38 = v55;
  }
  sub_100238FD0(v38);
LABEL_90:
  v39 = sub_100027F68();
  sub_100091AE8(buf, "LE");
  sub_100091AE8(__p, "OverrideResponderKeys");
  v40 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(_QWORD *)v39 + 88))(v39, buf, __p, &v55);
  if (v55 > 0)
    v41 = v40;
  else
    v41 = 0;
  if (v57 < 0)
    operator delete(__p[0]);
  if (v62 < 0)
  {
    operator delete(*(void **)buf);
    if (!v41)
      goto LABEL_102;
  }
  else if (!v41)
  {
    goto LABEL_102;
  }
  v42 = qword_100999818;
  v43 = os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT);
  v44 = v55;
  if (v43)
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v55;
    _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "Warning: Overriding responder keys to 0x%0x", buf, 8u);
    v44 = v55;
  }
  sub_100238FE8(v44);
LABEL_102:
  v45 = sub_100027F68();
  sub_100091AE8(buf, "LE");
  sub_100091AE8(__p, "OverrideUsePublicAddress");
  v46 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(_QWORD *)v45 + 88))(v45, buf, __p, &v55);
  if (v57 < 0)
    operator delete(__p[0]);
  if (v62 < 0)
  {
    operator delete(*(void **)buf);
    if (!v46)
      goto LABEL_111;
LABEL_108:
    v47 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v55;
      _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "Warning: Overriding use Public Address to %d", buf, 8u);
    }
    sub_100238FDC((_BYTE)v55 != 0);
    goto LABEL_111;
  }
  if (v46)
    goto LABEL_108;
LABEL_111:
  qword_10097B908 = a1;
  if (sub_10022CDD8(off_10097B8F0, v3, v14, v54 == 0, 0))
  {
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
      sub_1007194F4();
  }
  else
  {
    qword_10097B928 = a1;
    sub_10022D100((uint64_t)off_10097B910);
    if (v48)
    {
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
        sub_100719494();
    }
    else
    {
      qword_10097B940 = a1;
      sub_10022D270((__n128 *)off_10097B930);
      if (v49)
      {
        if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
          sub_100719434();
      }
      else if (sub_100224060(1))
      {
        if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
          sub_1007193D4();
      }
      else
      {
        sub_10004339C(&v59);
        *(_BYTE *)(a1 + 41) = 1;
        v50 = qword_100999818;
        if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "LESecurityManager stackDidStart", buf, 2u);
        }
      }
    }
  }
LABEL_125:
  sub_100043728(&v59);
  return sub_100034234((uint64_t)v60);
}

void sub_100693090(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, int a17, __int16 a18, char a19, char a20,char a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a16 < 0)
    operator delete(__p);
  if (a28 < 0)
    operator delete(a23);
  sub_100043728(&a20);
  sub_100034234((uint64_t)&a21);
  _Unwind_Resume(a1);
}

void sub_100693170(uint64_t a1, void *a2, int a3)
{
  id v5;
  uint64_t v6;
  id v7;
  _QWORD v8[4];
  id v9;
  uint64_t v10;
  int v11;

  v5 = a2;
  v6 = sub_1000419F4();
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_100693228;
  v8[3] = &unk_100919818;
  v10 = a1;
  v7 = v5;
  v9 = v7;
  v11 = a3;
  sub_100041A34(v6, v8);

}

void sub_100693208(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;

  _Unwind_Resume(a1);
}

void sub_100693228(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  int v7;
  NSObject *v8;
  uint8_t *v9;
  uint64_t v10;
  void *__p[2];
  uint64_t v12;
  uint8_t v13[4];
  uint8_t *v14;
  uint8_t buf[16];
  uint64_t v16;

  v2 = *(_QWORD *)(a1 + 40);
  if (objc_msgSend(*(id *)(v2 + 3752), "containsObject:", *(_QWORD *)(a1 + 32)))
  {
    v3 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
    {
      v4 = *(_QWORD *)(a1 + 32);
      *(_DWORD *)buf = 138543362;
      *(_QWORD *)&buf[4] = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Device %{public}@ was pending BMS unpairing but got disconnected, lets complete unpairing", buf, 0xCu);
    }
    objc_msgSend(*(id *)(v2 + 3752), "removeObject:", *(_QWORD *)(a1 + 32));
    sub_100693474(v2, *(void **)(a1 + 32), 0);
  }
  else
  {
    v5 = *(_DWORD *)(a1 + 48);
    if (v5 == 182 || v5 == 179)
    {
      memset(buf, 0, sizeof(buf));
      v16 = 0;
      if (qword_1009778C8 != -1)
        dispatch_once(&qword_1009778C8, &stru_10093FA18);
      sub_1006594CC((uint64_t)off_1009778C0, *(void **)(a1 + 32), (uint64_t)buf);
      v6 = HIBYTE(v16);
      v7 = SHIBYTE(v16);
      if (v16 < 0)
        v6 = *(_QWORD *)&buf[8];
      if (v6)
      {
        v8 = qword_1009997F8;
        if (os_log_type_enabled((os_log_t)qword_1009997F8, OS_LOG_TYPE_DEFAULT))
        {
          v9 = *(uint8_t **)buf;
          if (v7 >= 0)
            v9 = buf;
          *(_DWORD *)v13 = 136446210;
          v14 = v9;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Bad or missing keys, re-cloud pairing for device %{public}s", v13, 0xCu);
        }
        v10 = sub_10034FDA0();
        if (SHIBYTE(v16) < 0)
        {
          sub_10003430C(__p, *(void **)buf, *(unint64_t *)&buf[8]);
        }
        else
        {
          *(_OWORD *)__p = *(_OWORD *)buf;
          v12 = v16;
        }
        (*(void (**)(uint64_t, void **))(*(_QWORD *)v10 + 56))(v10, __p);
        if (SHIBYTE(v12) < 0)
          operator delete(__p[0]);
      }
      if (SHIBYTE(v16) < 0)
        operator delete(*(void **)buf);
    }
  }
}

void sub_100693438(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a14 < 0)
    operator delete(__p);
  if (a23 < 0)
    operator delete(a18);
  _Unwind_Resume(exception_object);
}

void sub_100693474(uint64_t a1, void *a2, int a3)
{
  id v5;
  uint64_t *v6;
  uint64_t *i;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  int v11;
  int v12;
  NSObject *v13;
  _BOOL8 v14;
  void *v15;
  uint64_t v16;
  _QWORD v17[4];
  id v18;
  void *__p[2];
  char v20;
  _QWORD v21[4];
  id v22;
  uint64_t v23;
  uint8_t buf[16];

  v5 = a2;
  v6 = *(uint64_t **)(a1 + 568);
  for (i = *(uint64_t **)(a1 + 576); v6 != i; ++v6)
  {
    v8 = *v6;
    v9 = sub_1000419F4();
    v21[0] = _NSConcreteStackBlock;
    v21[1] = 3221225472;
    v21[2] = sub_10069AFB0;
    v21[3] = &unk_100918868;
    v23 = v8;
    v22 = v5;
    sub_100041A34(v9, v21);

  }
  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_10093FA18);
  v10 = off_1009778C0;
  sub_100091AE8(__p, "PrivateModeDevice");
  v11 = sub_10000628C((uint64_t)v10, v5, (uint64_t)__p);
  v12 = v11;
  if (v20 < 0)
  {
    operator delete(__p[0]);
    if (!v12)
      goto LABEL_14;
  }
  else if (!v11)
  {
    goto LABEL_14;
  }
  v13 = qword_100999818;
  v14 = os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT);
  if (v14)
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Device being unpaired is tagged with private mode. Restart rotation of random address", buf, 2u);
  }
  *(_WORD *)(a1 + 594) = 0;
  sub_10069AE5C(v14, 0);
  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_10093FA18);
  sub_100653B18((uint64_t)off_1009778C0, v5, CFSTR("PrivateModeDevice"));
LABEL_14:
  if (a3)
  {
    if (qword_1009778A8 != -1)
      dispatch_once(&qword_1009778A8, &stru_10093FA38);
    v15 = off_1009778A0;
    sub_100030BCC(buf, v5);
    sub_100622358((uint64_t)v15, buf, 5u);
    v16 = sub_1000419F4();
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 3221225472;
    v17[2] = sub_10069AFC4;
    v17[3] = &unk_1009172A0;
    v18 = v5;
    sub_100041A34(v16, v17);

  }
}

void sub_100693708(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  void *v24;

  _Unwind_Resume(a1);
}

void sub_100693760(uint64_t a1, void *a2, int a3)
{
  sub_100693170(a1 - 16, a2, a3);
}

void sub_100693768(uint64_t a1, void *a2, uint64_t a3)
{
  id v5;
  NSObject *v6;
  int v7;
  id v8;
  __int16 v9;
  int v10;

  v5 = a2;
  v6 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    v7 = 138543618;
    v8 = v5;
    v9 = 1024;
    v10 = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Device %{public}@ disconnected without link ready with result: %d", (uint8_t *)&v7, 0x12u);
  }
  (*(void (**)(uint64_t, id, uint64_t))(*(_QWORD *)a1 + 64))(a1, v5, a3);

}

void sub_100693844(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_10069385C(uint64_t a1, void *a2, uint64_t a3)
{
  sub_100693768(a1 - 16, a2, a3);
}

uint64_t sub_100693864(uint64_t a1)
{
  NSObject *v2;
  id v3;
  id v4;
  uint64_t v5;
  void *v6;
  id v7;
  NSObject *v8;
  uint8_t v10[16];
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  char v15;
  uint8_t buf[8];
  uint64_t v17;
  _BYTE v18[128];

  v2 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "LeSecurityManager::stackWillStop enter", buf, 2u);
  }
  *(_QWORD *)buf = 0;
  v17 = 0;
  sub_10003415C((uint64_t)buf, a1 + 48);
  v15 = 0;
  sub_100043758(&v15);
  if (sub_100225224())
  {
    v13 = 0u;
    v14 = 0u;
    v11 = 0u;
    v12 = 0u;
    v3 = *(id *)(a1 + 3752);
    v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v11, v18, 16);
    if (v4)
    {
      v5 = *(_QWORD *)v12;
      do
      {
        v6 = 0;
        do
        {
          if (*(_QWORD *)v12 != v5)
            objc_enumerationMutation(v3);
          v7 = *(id *)(*((_QWORD *)&v11 + 1) + 8 * (_QWORD)v6);
          sub_100693474(a1, v7, 0);

          v6 = (char *)v6 + 1;
        }
        while (v4 != v6);
        v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v11, v18, 16);
      }
      while (v4);
    }

    objc_msgSend(*(id *)(a1 + 3752), "removeAllObjects");
    sub_10022D328(off_10097B930);
    sub_10022D1A8((uint64_t)off_10097B910);
    sub_10022CFF8((uint64_t)off_10097B8F0);
    sub_100224060(0);
    sub_10004339C(&v15);
    *(_BYTE *)(a1 + 41) = 0;
    objc_msgSend(*(id *)(a1 + 3728), "removeAllObjects");
    sub_1006A7228(a1 + 464, *(_QWORD **)(a1 + 472));
    *(_QWORD *)(a1 + 472) = 0;
    *(_QWORD *)(a1 + 480) = 0;
    *(_QWORD *)(a1 + 464) = a1 + 472;
    sub_1006A7228(a1 + 488, *(_QWORD **)(a1 + 496));
    *(_QWORD *)(a1 + 496) = 0;
    *(_QWORD *)(a1 + 504) = 0;
    *(_QWORD *)(a1 + 488) = a1 + 496;
    sub_1006A7228(a1 + 512, *(_QWORD **)(a1 + 520));
    *(_QWORD *)(a1 + 512) = a1 + 520;
    *(_QWORD *)(a1 + 528) = 0;
    *(_QWORD *)(a1 + 520) = 0;
    v8 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v10 = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "LeSecurityManager::stackWillStop exit", v10, 2u);
    }
  }
  sub_100043728(&v15);
  return sub_100034234((uint64_t)buf);
}

void sub_100693AB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24)
{
  void *v24;

  sub_100043728(&a23);
  sub_100034234((uint64_t)&a24);
  _Unwind_Resume(a1);
}

void sub_100693B04(uint64_t a1, unsigned __int8 *a2)
{
  void *v4;
  NSObject *v5;
  unsigned __int8 *v6;
  const unsigned __int8 *v7;
  char v8;
  void *v9;
  id v10;
  void *v11;
  uint64_t v12;
  unsigned __int8 *v13;
  const unsigned __int8 **v14;
  BOOL v15;
  uint64_t v16;
  NSObject *v17;
  unsigned __int8 *v18;
  _BOOL4 v19;
  void *v20;
  id v21;
  void *v22;
  void *v23;
  int v24;
  NSObject *v25;
  int v26;
  uint64_t v27;
  char v28;
  id v29;
  int v30;
  unsigned int v31;
  uint64_t v32;
  NSObject *v33;
  unsigned __int8 *v34;
  void *v35;
  id v36;
  void *v37;
  char v38;
  NSObject *v39;
  uint64_t v40;
  NSObject *v41;
  uint64_t v42;
  char v43;
  id v44;
  int v45;
  unsigned int v46;
  uint64_t v47;
  NSObject *v48;
  void *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  void *v56;
  id v57;
  void *v58;
  uint64_t v59;
  void *v60;
  id v61;
  void *v62;
  NSObject *v63;
  void **v64;
  void *v65;
  id v66;
  void *v67;
  id v68;
  uint64_t v69;
  uint64_t v70;
  void *v71;
  char v72;
  void *v73[2];
  char v74;
  void *v75[2];
  char v76;
  void *v77[2];
  char v78;
  void *__p[2];
  char v80;
  char v81;
  unsigned __int8 v82;
  uint64_t (**v83)();
  unsigned int *v84;
  char v85;
  uint64_t (**v86)();
  unsigned int *v87;
  uint8_t buf[4];
  void *v89;
  __int16 v90;
  int v91;
  __int16 v92;
  int v93;
  __n128 v94;
  __n128 v95;
  int v96;
  __int128 v97;
  uuid_t dst;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  int v103;
  uuid_t uu;

  v4 = (void *)(((unint64_t)a2[1] << 40) | ((unint64_t)a2[2] << 32) | ((unint64_t)a2[3] << 24) | ((unint64_t)a2[4] << 16) | ((unint64_t)a2[5] << 8) | a2[6] | ((unint64_t)*a2 << 48));
  v5 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    sub_1000217F4((uint64_t)v4);
    v6 = (SBYTE7(v99) & 0x80u) == 0 ? dst : *(unsigned __int8 **)dst;
    *(_DWORD *)buf = 136446210;
    v89 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Deriving key for device %{public}s", buf, 0xCu);
    if (SBYTE7(v99) < 0)
      operator delete(*(void **)dst);
  }
  v86 = &off_100934340;
  v87 = 0;
  v7 = *(const unsigned __int8 **)(a1 + 440);
  if (v7 != (const unsigned __int8 *)(a1 + 448))
  {
    v8 = 0;
    while (1)
    {
      sub_100041698((uint64_t)&v86, (uint64_t)(v7 + 48));
      memset(dst, 0, sizeof(dst));
      uuid_copy(dst, v7 + 32);
      if (qword_1009778C8 != -1)
        dispatch_once(&qword_1009778C8, &stru_10093FA18);
      v9 = off_1009778C0;
      v10 = sub_100030DF4(dst);
      v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
      v12 = sub_1000589DC((uint64_t)v9, v11, 0);

      if (v4 == (void *)v12)
        break;
      v13 = (unsigned __int8 *)*((_QWORD *)v7 + 1);
      if (v13)
      {
        do
        {
          v14 = (const unsigned __int8 **)v13;
          v13 = *(unsigned __int8 **)v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          v14 = (const unsigned __int8 **)*((_QWORD *)v7 + 2);
          v15 = *v14 == v7;
          v7 = (const unsigned __int8 *)v14;
        }
        while (!v15);
      }
      v8 |= v4 == (void *)v12;
      v7 = (const unsigned __int8 *)v14;
      if (v14 == (const unsigned __int8 **)(a1 + 448))
      {
        if ((v8 & 1) == 0)
          goto LABEL_23;
        break;
      }
    }
    v85 = 0;
    sub_100043758(&v85);
    v16 = sub_10019AFA0(a2);
    sub_10004339C(&v85);
    memset(uu, 0, sizeof(uu));
    uuid_clear(uu);
    if (v16)
    {
      if (qword_1009778A8 != -1)
        dispatch_once(&qword_1009778A8, &stru_10093FA38);
      sub_10061E090((uint64_t)off_1009778A0, v16, uu);
    }
    else
    {
      if (qword_1009778C8 != -1)
        dispatch_once(&qword_1009778C8, &stru_10093FA18);
      sub_10003F924((uint64_t)off_1009778C0, ((unint64_t)a2[1] << 40) | ((unint64_t)a2[2] << 32) | ((unint64_t)a2[3] << 24) | ((unint64_t)a2[4] << 16) | ((unint64_t)a2[5] << 8) | a2[6] | ((unint64_t)*a2 << 48), 0, 1u, 0, 0, dst);
      uuid_copy(uu, dst);
    }
    if (uuid_is_null(uu))
    {
LABEL_33:
      v83 = 0;
      v84 = 0;
      sub_1003965C0((uint64_t)v87, 16, &v83);
      v19 = sub_1000452EC((uint64_t)&v83);
      if (qword_1009778C8 != -1)
        dispatch_once(&qword_1009778C8, &stru_10093FA18);
      v20 = off_1009778C0;
      v21 = sub_100030DF4(uu);
      v22 = (void *)objc_claimAutoreleasedReturnValue(v21);
      v23 = (void *)sub_100658AD4((uint64_t)v20, v22);

      v24 = !v19;
      v25 = qword_100999818;
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)dst = 67109376;
        *(_DWORD *)&dst[4] = (_DWORD)v23;
        *(_WORD *)&dst[8] = 1024;
        *(_DWORD *)&dst[10] = v24;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "hasTS:%d hasLKLTK:%d", dst, 0xEu);
      }
      if (((v24 | v23) & 1) == 0)
      {
        v33 = qword_100999818;
        if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
        {
          sub_1000217F4((uint64_t)v4);
          v34 = (SBYTE7(v99) & 0x80u) == 0 ? dst : *(unsigned __int8 **)dst;
          *(_DWORD *)buf = 136446210;
          v89 = v34;
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "Device %{public}s is not an ï£¿Watch and does not have the LKLTK bit set, will not derive a link key for it.", buf, 0xCu);
          if (SBYTE7(v99) < 0)
            operator delete(*(void **)dst);
        }
        goto LABEL_67;
      }
      v103 = 0;
      v101 = 0u;
      v102 = 0u;
      v99 = 0u;
      v100 = 0u;
      *(_OWORD *)dst = 0u;
      v82 = 0;
      v97 = 0uLL;
      v95 = 0uLL;
      v96 = 0;
      sub_1005A9714((uint64_t)&v95);
      sub_1006911AC(a1, (uint64_t)&v86, dst);
      v81 = 0;
      sub_100043758(&v81);
      v26 = sub_10022DC10(&v97, &v82, (uint64_t)dst);
      sub_10004339C(&v81);
      if (v26 || (v82 & 0xFE) != 2)
      {
        v39 = qword_100999818;
        if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
        {
          sub_1000217F4((uint64_t)v4);
          v64 = v72 >= 0 ? &v71 : (void **)v71;
          *(_DWORD *)buf = 136446722;
          v89 = v64;
          v90 = 1024;
          v91 = v26;
          v92 = 1024;
          v93 = v82;
          _os_log_error_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "LE_Security_DeriveLinkKeyForAddress %{public}s with result %{bluetooth:OI_STATUS}u ltkType=%d ", buf, 0x18u);
          if (v72 < 0)
            operator delete(v71);
        }
        goto LABEL_66;
      }
      if (v82 != 3)
      {
        if (v82 != 2)
        {
          v63 = qword_100999818;
          if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_fault_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_FAULT, "Unknown LTK Type - aborting\n", buf, 2u);
            v63 = qword_100999818;
          }
          if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 67109120;
            LODWORD(v89) = v82;
            _os_log_error_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_ERROR, "Unknown LTK Type (%d) - aborting", buf, 8u);
            v63 = qword_100999818;
          }
          if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "LinkKey is not valid", buf, 2u);
          }
          goto LABEL_66;
        }
        v27 = sub_10003BE44();
        v28 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v27 + 344))(v27);
        if ((v28 & 1) != 0)
          goto LABEL_46;
        if (qword_1009778C8 != -1)
          dispatch_once(&qword_1009778C8, &stru_10093FA18);
        v23 = off_1009778C0;
        v29 = sub_100030DF4(uu);
        v4 = (void *)objc_claimAutoreleasedReturnValue(v29);
        sub_100091AE8(__p, "IsAppleWatch");
        if ((sub_10000628C((uint64_t)v23, v4, (uint64_t)__p) & 1) != 0)
        {
LABEL_46:
          v30 = 0;
        }
        else
        {
          if (qword_1009778C8 != -1)
            dispatch_once(&qword_1009778C8, &stru_10093FA18);
          v65 = off_1009778C0;
          v66 = sub_100030DF4(uu);
          v23 = (void *)objc_claimAutoreleasedReturnValue(v66);
          if (!sub_100658AD4((uint64_t)v65, v23))
          {
            v31 = 4;
            v30 = 1;
            goto LABEL_48;
          }
          v30 = 1;
        }
        v31 = 7;
LABEL_48:
        sub_1005A9734((uint64_t)buf, &v97, v31);
        sub_1005A9720(&v95, (__n128 *)buf);
        nullsub_90(buf, v32);
        if (v30)

        if ((v28 & 1) == 0)
        {
          if (v80 < 0)
            operator delete(__p[0]);

        }
LABEL_91:
        v48 = qword_100999818;
        if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "Calling PairingManager::getInstance()->leDevicePaired", buf, 2u);
        }
        if (qword_100978150 != -1)
          dispatch_once(&qword_100978150, &stru_10093FA58);
        v49 = off_100978148;
        v70 = a2[1];
        v50 = a2[2];
        v51 = a2[3];
        v52 = a2[4];
        v53 = a2[5];
        v54 = a2[6];
        v55 = *a2;
        sub_1005A9720(&v94, &v95);
        v69 = (uint64_t)v49;
        if (qword_1009778C8 != -1)
          dispatch_once(&qword_1009778C8, &stru_10093FA18);
        v56 = off_1009778C0;
        v57 = sub_100030DF4(uu);
        v58 = (void *)objc_claimAutoreleasedReturnValue(v57);
        sub_10000602C((uint64_t)v56, v58, (uint64_t)v75);
        sub_1005B7DD4(v69, (v70 << 40) | (v50 << 32) | (v51 << 24) | (v52 << 16) | (v53 << 8) | v54 | (v55 << 48), &v94, (uint64_t)v75);
        if (v76 < 0)
          operator delete(v75[0]);

        nullsub_90(&v94, v59);
        if (qword_1009778C8 != -1)
          dispatch_once(&qword_1009778C8, &stru_10093FA18);
        v60 = off_1009778C0;
        v61 = sub_100030DF4(uu);
        v62 = (void *)objc_claimAutoreleasedReturnValue(v61);
        sub_100091AE8(v73, "_CTKD_");
        sub_1006576F0((uint64_t)v60, v62, (unsigned __int8 *)v73);
        if (v74 < 0)
          operator delete(v73[0]);

LABEL_66:
        sub_100043728(&v81);
        nullsub_90(&v95, v40);
LABEL_67:
        v83 = &off_100918258;
        if (v84)
          sub_100056AAC(v84);
LABEL_74:
        sub_100043728(&v85);
        goto LABEL_75;
      }
      v42 = sub_10003BE44();
      v43 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v42 + 344))(v42);
      if ((v43 & 1) != 0)
        goto LABEL_83;
      if (qword_1009778C8 != -1)
        dispatch_once(&qword_1009778C8, &stru_10093FA18);
      v23 = off_1009778C0;
      v44 = sub_100030DF4(uu);
      v4 = (void *)objc_claimAutoreleasedReturnValue(v44);
      sub_100091AE8(v77, "IsAppleWatch");
      if ((sub_10000628C((uint64_t)v23, v4, (uint64_t)v77) & 1) != 0)
      {
LABEL_83:
        v45 = 0;
      }
      else
      {
        if (qword_1009778C8 != -1)
          dispatch_once(&qword_1009778C8, &stru_10093FA18);
        v67 = off_1009778C0;
        v68 = sub_100030DF4(uu);
        v23 = (void *)objc_claimAutoreleasedReturnValue(v68);
        if (!sub_100658AD4((uint64_t)v67, v23))
        {
          v46 = 5;
          v45 = 1;
          goto LABEL_85;
        }
        v45 = 1;
      }
      v46 = 8;
LABEL_85:
      sub_1005A9734((uint64_t)buf, &v97, v46);
      sub_1005A9720(&v95, (__n128 *)buf);
      nullsub_90(buf, v47);
      if (v45)

      if ((v43 & 1) == 0)
      {
        if (v78 < 0)
          operator delete(v77[0]);

      }
      goto LABEL_91;
    }
    memset(dst, 0, sizeof(dst));
    *(_QWORD *)&v99 = 0;
    if (qword_1009778C8 != -1)
      dispatch_once(&qword_1009778C8, &stru_10093FA18);
    v35 = off_1009778C0;
    v36 = sub_100030DF4(uu);
    v37 = (void *)objc_claimAutoreleasedReturnValue(v36);
    sub_1006594CC((uint64_t)v35, v37, (uint64_t)dst);

    v38 = BYTE7(v99);
    if (SBYTE7(v99) < 0)
    {
      if (!*(_QWORD *)&dst[8])
      {
        operator delete(*(void **)dst);
        goto LABEL_33;
      }
    }
    else if (!BYTE7(v99))
    {
      goto LABEL_33;
    }
    v41 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "LE_Security_DeriveLinkKeyForAddress not applicable for cloud paired devices", buf, 2u);
      v38 = BYTE7(v99);
    }
    if (v38 < 0)
      operator delete(*(void **)dst);
    goto LABEL_74;
  }
LABEL_23:
  v17 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    sub_1000217F4((uint64_t)v4);
    v18 = (SBYTE7(v99) & 0x80u) == 0 ? dst : *(unsigned __int8 **)dst;
    *(_DWORD *)buf = 136446210;
    v89 = v18;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Could not find keys for device %{public}s", buf, 0xCu);
    if (SBYTE7(v99) < 0)
      operator delete(*(void **)dst);
  }
LABEL_75:
  v86 = &off_100934340;
  if (v87)
    sub_100056AAC(v87);
}

void sub_100694714(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,void *a33,uint64_t a34,int a35,__int16 a36,char a37,char a38,int a39,__int16 a40,char a41,uint64_t (**a42)(),unsigned int *a43,int a44,__int16 a45,char a46,char a47,uint64_t (**a48)(),unsigned int *a49,char a50,uint64_t a51,uint64_t a52,uint64_t a53,int a54,char a55,uint64_t a56,uint64_t a57,char a58)
{
  void *v58;
  void *v59;
  uint64_t v61;

  if (a32 < 0)
    operator delete(__p);

  sub_100043728(&a41);
  nullsub_90(&a58, v61);
  a42 = &off_100918258;
  if (a43)
    sub_100056AAC(a43);
  sub_100043728(&a47);
  a48 = &off_100934340;
  if (a49)
    sub_100056AAC(a49);
  _Unwind_Resume(a1);
}

void sub_100694904(uint64_t a1, void *a2, int a3)
{
  id v5;
  NSObject *v6;
  unint64_t v7;
  uint64_t *v8;
  unsigned int *v9;
  uint64_t v10;
  NSObject *v11;
  int v12;
  NSObject *v13;
  const char *v14;
  char v15;
  const char *v16;
  uint64_t v17;
  uint64_t (**v18)();
  unsigned int *v19;
  _QWORD v20[2];
  unsigned __int8 __dst;
  _BYTE buf[22];

  v5 = a2;
  v20[0] = 0;
  v20[1] = 0;
  sub_10003415C((uint64_t)v20, a1 + 48);
  v6 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138543362;
    *(_QWORD *)&buf[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Deriving key for device %{public}@", buf, 0xCu);
  }
  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_10093FA18);
  v7 = sub_1000589DC((uint64_t)off_1009778C0, v5, 0);
  sub_100030BCC(buf, v5);
  v18 = (uint64_t (**)())buf;
  v8 = sub_1006A759C((uint64_t **)(a1 + 440), buf, (uint64_t)&unk_100740F58, (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)&v18);
  v9 = (unsigned int *)v8[7];
  if (v9)
    sub_10003C37C(v8[7]);
  v10 = sub_10003BE44();
  if ((((*(unsigned int (**)(uint64_t))(*(_QWORD *)v10 + 344))(v10) | a3 ^ 1) & 1) == 0)
  {
    v11 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138543362;
      *(_QWORD *)&buf[4] = v5;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Switching derivation method for device \"%{public}@\"", buf, 0xCu);
    }
    v18 = 0;
    v19 = 0;
    sub_1003965C0((uint64_t)v9, 16, &v18);
    __dst = 1;
    if (sub_1000452EC((uint64_t)&v18))
    {
      v12 = 1;
    }
    else
    {
      sub_1000455DC((uint64_t)&v18, &__dst, 1uLL);
      v12 = __dst;
    }
    v13 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
    {
      if (v12 == 1)
        v14 = "6";
      else
        v14 = "7";
      *(_DWORD *)buf = 138543618;
      *(_QWORD *)&buf[4] = v5;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = v14;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Current key derivation method for device \"%{public}@\" is H%s", buf, 0x16u);
      v12 = __dst;
      v13 = qword_100999818;
    }
    if (v12 == 2)
      v15 = 1;
    else
      v15 = 2;
    __dst = v15;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      if (v12 == 2)
        v16 = "6";
      else
        v16 = "7";
      *(_DWORD *)buf = 138543618;
      *(_QWORD *)&buf[4] = v5;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = v16;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "New key derivation method for device \"%{public}@\" is H%s", buf, 0x16u);
    }
    sub_10003994C(buf, &__dst, 1uLL);
    sub_100395D48((uint64_t)v9, 16, (uint64_t)buf);
    *(_QWORD *)buf = &off_100918258;
    if (*(_QWORD *)&buf[8])
      sub_100056AAC(*(unsigned int **)&buf[8]);
    v18 = &off_100918258;
    if (v19)
      sub_100056AAC(v19);
  }
  v17 = sub_1000746A4(v7);
  *(_DWORD *)buf = v17;
  buf[6] = BYTE6(v17);
  *(_WORD *)&buf[4] = WORD2(v17);
  sub_100693B04(a1, buf);
  if (v9)
    sub_100056AAC(v9);
  sub_100034234((uint64_t)v20);

}

void sub_100694C68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, unsigned int *a11, char a12, uint64_t a13, uint64_t a14, uint64_t (**a15)(), unsigned int *a16)
{
  void *v16;
  unsigned int *v17;

  a15 = &off_100918258;
  if (a16)
    sub_100056AAC(a16);
  if (a11)
    sub_100056AAC(a11);
  if (v17)
    sub_100056AAC(v17);
  sub_100034234((uint64_t)&a12);

  _Unwind_Resume(a1);
}

void sub_100694CF4(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t i;
  BOOL v8;
  uint64_t j;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  int v25;
  id v26;
  NSObject *v27;
  void *p_p;
  id v29;
  void *__p;
  char v31;
  uint8_t buf[4];
  void *v33;
  __int16 v34;
  int v35;
  __int16 v36;
  uint64_t v37;

  v6 = 0;
  for (i = 0; i != 130; ++i)
  {
    v8 = *(_DWORD *)(a1 + v6 + 613) == *(_DWORD *)a2 && *(_DWORD *)(a1 + v6 + 616) == *(_DWORD *)(a2 + 3);
    if (v8 && *(_BYTE *)(a1 + v6 + 620))
    {
      v19 = a1 + v6;
      if (*(_QWORD *)(v19 + 597) == *(_QWORD *)a3 && *(_QWORD *)(v19 + 605) == *(_QWORD *)(a3 + 8))
      {
        v27 = qword_100999818;
        if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
        {
          sub_1000217F4(((unint64_t)a2[1] << 40) | ((unint64_t)a2[2] << 32) | ((unint64_t)a2[3] << 24) | ((unint64_t)a2[4] << 16) | ((unint64_t)a2[5] << 8) | a2[6] | ((unint64_t)*a2 << 48));
          if (v31 >= 0)
            p_p = &__p;
          else
            p_p = __p;
          *(_DWORD *)buf = 136446723;
          v33 = p_p;
          v34 = 1041;
          v35 = 16;
          v36 = 2097;
          v37 = a3;
          _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "address %{public}s Incorrect IRK %{private}.16P", buf, 0x1Cu);
          if (v31 < 0)
            operator delete(__p);
        }
      }
      else
      {
        *(_OWORD *)(v19 + 597) = *(_OWORD *)a3;
        *(_BYTE *)(v19 + 620) = 1;
        if (*(_BYTE *)(a1 + 41))
        {
          sub_10069AC78(a1, a2);
          v21 = ((unint64_t)a2[1] << 40) | ((unint64_t)a2[2] << 32) | ((unint64_t)a2[3] << 24) | ((unint64_t)a2[4] << 16) | ((unint64_t)a2[5] << 8) | a2[6] | ((unint64_t)*a2 << 48);
          v22 = sub_1000438A4();
          (*(void (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)v22 + 384))(v22, v21, 1);
LABEL_22:
          sub_100691AD8(a1, (int *)(a1 + 24 * i + 613), (_OWORD *)(a1 + 24 * i + 597));
          v23 = ((unint64_t)a2[1] << 40) | ((unint64_t)a2[2] << 32) | ((unint64_t)a2[3] << 24) | ((unint64_t)a2[4] << 16) | ((unint64_t)a2[5] << 8) | a2[6] | ((unint64_t)*a2 << 48);
          v24 = sub_1000438A4();
          v25 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t, uint64_t))(*(_QWORD *)v24 + 376))(v24, v23, a3, 1);
          v26 = sub_1006A0840(a1, v23);
          v29 = (id)objc_claimAutoreleasedReturnValue(v26);
          sub_100691A74((uint64_t)v29, v29, v25);

        }
      }
      return;
    }
    v6 += 24;
  }
  i = 0;
  for (j = a1 + 597; *(_BYTE *)(j + 23); j += 24)
  {
    if (++i == 130)
    {
      v10 = qword_100999818;
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
        sub_1007195B4(v10, v11, v12, v13, v14, v15, v16, v17);
      return;
    }
  }
  v18 = *(_DWORD *)a2;
  *(_DWORD *)(j + 19) = *(_DWORD *)(a2 + 3);
  *(_DWORD *)(j + 16) = v18;
  *(_OWORD *)j = *(_OWORD *)a3;
  *(_BYTE *)(j + 23) = 1;
  if (*(_BYTE *)(a1 + 41))
    goto LABEL_22;
}

void sub_100695040(uint64_t a1)
{
  id v2;
  NSObject *v3;
  id v4;
  id v5;
  const char *v6;
  id v7;
  id v8;
  uint64_t v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  id v14;
  id v15;
  void *v16;
  id v17;
  void *v18;
  uint8_t *v19;
  void *v20;
  id v21;
  void *v22;
  int v23;
  NSObject *v24;
  _BOOL4 v25;
  void (***v26)(_QWORD, void *);
  NSObject *v27;
  void *v28;
  void *v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  _QWORD v34[2];
  uint8_t buf[32];
  unsigned __int8 uu[8];
  uint64_t v37;
  _BYTE v38[128];

  v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary"));
  v34[0] = 0;
  v34[1] = 0;
  sub_10003415C((uint64_t)v34, a1 + 48);
  v2 = sub_1002FC5A4(0);
  v28 = (void *)objc_claimAutoreleasedReturnValue(v2);
  v3 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    v4 = objc_msgSend(v28, "count");
    v5 = objc_msgSend(v28, "count");
    v6 = "s";
    if (v5 == (id)1)
      v6 = "";
    *(_DWORD *)buf = 134218242;
    *(_QWORD *)&buf[4] = v4;
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v6;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Found %lu paired LE device%{public}s in local keychain", buf, 0x16u);
  }
  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_10093FA18);
  sub_10065A204((uint64_t)off_1009778C0, v28, 0);
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  v7 = v28;
  v8 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v30, v38, 16);
  if (v8)
  {
    v9 = *(_QWORD *)v31;
    do
    {
      v10 = 0;
      do
      {
        if (*(_QWORD *)v31 != v9)
          objc_enumerationMutation(v7);
        v11 = *(void **)(*((_QWORD *)&v30 + 1) + 8 * (_QWORD)v10);
        v12 = objc_autoreleasePoolPush();
        v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "objectForKeyedSubscript:", v11));
        v14 = objc_msgSend(v13, "unsignedLongLongValue");

        if (sub_10068F1D8(a1, (unint64_t)v14, v11))
        {
          *(_QWORD *)uu = 0;
          v37 = 0;
          if (qword_1009778C8 != -1)
            dispatch_once(&qword_1009778C8, &stru_10093FA18);
          sub_10003F924((uint64_t)off_1009778C0, (unint64_t)v14, 0, 1u, 0, 0, uu);
          if (!uuid_is_null(uu))
          {
            memset(buf, 0, 24);
            if (qword_1009778C8 != -1)
              dispatch_once(&qword_1009778C8, &stru_10093FA18);
            v16 = off_1009778C0;
            v17 = sub_100030DF4(uu);
            v18 = (void *)objc_claimAutoreleasedReturnValue(v17);
            sub_1006594CC((uint64_t)v16, v18, (uint64_t)buf);

            if (((char)buf[23] & 0x80000000) == 0)
            {
              if (!buf[23])
                goto LABEL_28;
              v19 = buf;
              goto LABEL_26;
            }
            if (*(_QWORD *)&buf[8])
            {
              v19 = *(uint8_t **)buf;
LABEL_26:
              v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v19));
              v21 = sub_100030DF4(uu);
              v22 = (void *)objc_claimAutoreleasedReturnValue(v21);
              objc_msgSend(v29, "setObject:forKeyedSubscript:", v20, v22);

              if (((char)buf[23] & 0x80000000) == 0)
                goto LABEL_28;
            }
            operator delete(*(void **)buf);
            goto LABEL_28;
          }
          if (uuid_is_null(uu) && os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_FAULT))
          {
            v15 = sub_100021770((uint64_t)v14);
            objc_claimAutoreleasedReturnValue(v15);
            sub_1007191C8();
          }
        }
LABEL_28:
        objc_autoreleasePoolPop(v12);
        v10 = (char *)v10 + 1;
      }
      while (v8 != v10);
      v8 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v30, v38, 16);
    }
    while (v8);
  }

  v23 = *(unsigned __int8 *)(a1 + 424);
  v24 = qword_100999818;
  v25 = os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT);
  if (v23)
  {
    if (v25)
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "CloudPairing is Enabled", buf, 2u);
    }
    v26 = *(void (****)(_QWORD, void *))(a1 + 432);
    if (v26)
      goto LABEL_37;
    v27 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Initialize CloudPairing", buf, 2u);
    }
    v26 = (void (***)(_QWORD, void *))sub_10034FDA0();
    *(_QWORD *)(a1 + 432) = v26;
    if (v26)
LABEL_37:
      (**v26)(v26, v29);
  }
  else if (v25)
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "CloudPairing is Disabled", buf, 2u);
  }

  sub_100034234((uint64_t)v34);
}

void sub_1006954E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  void *v28;

  sub_100034234((uint64_t)&a21);
  _Unwind_Resume(a1);
}

uint64_t sub_100695590(_QWORD *a1)
{
  __int128 v1;
  const unsigned __int8 *v2;
  void *v3;
  uint64_t v4;
  void *v5;
  id v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int *v11;
  _OWORD *v12;
  id v13;
  void *v14;
  const unsigned __int8 *v15;
  const unsigned __int8 *v16;
  BOOL v17;
  void *v18;
  void *v19;
  id v20;
  void *v21;
  int v22;
  void *v23;
  id v24;
  void *v25;
  int v26;
  void *v27;
  id v28;
  void *v29;
  int v30;
  NSObject *v31;
  id v32;
  void *v33;
  NSObject *v34;
  id v35;
  void *v36;
  void *v37;
  id v38;
  void *v39;
  unint64_t v40;
  uint64_t v41;
  const unsigned __int8 *v42;
  const unsigned __int8 *v43;
  _QWORD *v44;
  const unsigned __int8 *v45;
  void *v46;
  void *v47;
  id v48;
  void *v49;
  unint64_t v50;
  uint64_t v51;
  int *v52;
  NSObject *v53;
  unsigned __int8 *v54;
  const unsigned __int8 **v55;
  unsigned __int8 *v56;
  _QWORD *v57;
  _QWORD *v58;
  uint64_t v59;
  void *v60;
  __int128 v62;
  const unsigned __int8 *v64;
  char v65;
  _DWORD v66[2];
  void *v67[2];
  char v68;
  void *__p[2];
  char v70;
  _QWORD v71[2];
  uuid_t dst;
  char v73;
  uint8_t v74[4];
  unsigned __int8 *v75;
  uuid_t uu;
  uint8_t buf[40];

  v71[0] = 0;
  v71[1] = 0;
  sub_10003415C((uint64_t)v71, (uint64_t)(a1 + 6));
  sub_100695EA4();
  v2 = (const unsigned __int8 *)a1[55];
  v64 = (const unsigned __int8 *)(a1 + 56);
  if (v2 != (const unsigned __int8 *)(a1 + 56))
  {
    do
    {
      v3 = objc_autoreleasePoolPush();
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = 0;
      sub_1003965C0(*((_QWORD *)v2 + 7), 10, buf);
      if (!sub_1000452EC((uint64_t)buf))
      {
        v4 = sub_1000438A4();
        if (qword_1009778C8 != -1)
          dispatch_once(&qword_1009778C8, &stru_10093FA18);
        v5 = off_1009778C0;
        v6 = sub_100030DF4(v2 + 32);
        v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
        v8 = sub_1000589DC((uint64_t)v5, v7, 0);
        v9 = sub_10003EB18((uint64_t)buf);
        v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v4 + 376))(v4, v8, v9, 1);

        sub_1003965C0(*((_QWORD *)v2 + 7), 11, dst);
        v11 = (int *)sub_10003EB18((uint64_t)dst);
        v12 = (_OWORD *)sub_10003EB18((uint64_t)buf);
        sub_100691AD8((uint64_t)a1, v11, v12);
        *(_QWORD *)dst = &off_100918258;
        if (*(_QWORD *)&dst[8])
          sub_100056AAC(*(unsigned int **)&dst[8]);
        v13 = sub_100030DF4(v2 + 32);
        v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
        sub_100691A74((uint64_t)v14, v14, v10);

      }
      *(_QWORD *)buf = &off_100918258;
      if (*(_QWORD *)&buf[8])
        sub_100056AAC(*(unsigned int **)&buf[8]);
      objc_autoreleasePoolPop(v3);
      v15 = (const unsigned __int8 *)*((_QWORD *)v2 + 1);
      if (v15)
      {
        do
        {
          v16 = v15;
          v15 = *(const unsigned __int8 **)v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          v16 = (const unsigned __int8 *)*((_QWORD *)v2 + 2);
          v17 = *(_QWORD *)v16 == (_QWORD)v2;
          v2 = v16;
        }
        while (!v17);
      }
      v2 = v16;
    }
    while (v16 != v64);
    v2 = (const unsigned __int8 *)a1[55];
  }
  if (v2 != v64)
  {
    *(_QWORD *)&v1 = 138543362;
    v62 = v1;
    do
    {
      v18 = objc_autoreleasePoolPush();
      memset(dst, 0, sizeof(dst));
      uuid_copy(dst, v2 + 32);
      if (qword_1009778C8 != -1)
        dispatch_once(&qword_1009778C8, &stru_10093FA18);
      v19 = off_1009778C0;
      v20 = sub_100030DF4(dst);
      v21 = (void *)objc_claimAutoreleasedReturnValue(v20);
      sub_100091AE8(__p, "_CTKD_");
      v22 = sub_10000628C((uint64_t)v19, v21, (uint64_t)__p);
      if (v70 < 0)
        operator delete(__p[0]);

      if (qword_1009778C8 != -1)
        dispatch_once(&qword_1009778C8, &stru_10093FA18);
      v23 = off_1009778C0;
      v24 = sub_100030DF4(dst);
      v25 = (void *)objc_claimAutoreleasedReturnValue(v24);
      v26 = sub_100658AD4((uint64_t)v23, v25);

      if (qword_1009778C8 != -1)
        dispatch_once(&qword_1009778C8, &stru_10093FA18);
      v27 = off_1009778C0;
      v28 = sub_100030DF4(dst);
      v29 = (void *)objc_claimAutoreleasedReturnValue(v28);
      sub_100091AE8(v67, "IsAppleWatch");
      v30 = sub_10000628C((uint64_t)v27, v29, (uint64_t)v67);
      if (v68 < 0)
        operator delete(v67[0]);

      v31 = qword_100999818;
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_INFO))
      {
        v32 = sub_100030DF4(dst);
        v33 = (void *)objc_claimAutoreleasedReturnValue(v32);
        *(_DWORD *)buf = 138544130;
        *(_QWORD *)&buf[4] = v33;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v22;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v26;
        *(_WORD *)&buf[24] = 1024;
        *(_DWORD *)&buf[26] = v30;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_INFO, "%{public}@ CTKDTag:%d hasTSTag:%d isAppleWatchTag:%d", buf, 0x1Eu);

      }
      if ((((v26 | v30) ^ 1 | v22) & 1) == 0)
      {
        v34 = qword_100999818;
        if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
        {
          v35 = sub_100030DF4(dst);
          v36 = (void *)objc_claimAutoreleasedReturnValue(v35);
          *(_DWORD *)buf = v62;
          *(_QWORD *)&buf[4] = v36;
          _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "Upgrading device %{public}@ to the new CTKD derived LK", buf, 0xCu);

        }
        if (qword_1009778C8 != -1)
          dispatch_once(&qword_1009778C8, &stru_10093FA18);
        v37 = off_1009778C0;
        v38 = sub_100030DF4(dst);
        v39 = (void *)objc_claimAutoreleasedReturnValue(v38);
        v40 = sub_1000589DC((uint64_t)v37, v39, 0);

        *(_DWORD *)&buf[3] = 0;
        *(_DWORD *)buf = 0;
        v41 = sub_1000746A4(v40);
        *(_DWORD *)buf = v41;
        buf[6] = BYTE6(v41);
        *(_WORD *)&buf[4] = WORD2(v41);
        sub_100693B04((uint64_t)a1, buf);
      }
      objc_autoreleasePoolPop(v18);
      v42 = (const unsigned __int8 *)*((_QWORD *)v2 + 1);
      if (v42)
      {
        do
        {
          v43 = v42;
          v42 = *(const unsigned __int8 **)v42;
        }
        while (v42);
      }
      else
      {
        do
        {
          v43 = (const unsigned __int8 *)*((_QWORD *)v2 + 2);
          v17 = *(_QWORD *)v43 == (_QWORD)v2;
          v2 = v43;
        }
        while (!v17);
      }
      v2 = v43;
    }
    while (v43 != v64);
  }
  sub_10022CB28();
  v44 = (_QWORD *)a1[67];
  if (v44 != a1 + 68)
  {
    do
    {
      v45 = (const unsigned __int8 *)v44[5];
      if (v45 != (const unsigned __int8 *)(v44 + 6))
      {
        do
        {
          v46 = objc_autoreleasePoolPush();
          memset(uu, 0, sizeof(uu));
          uuid_copy(uu, v45 + 32);
          if (!uuid_is_null(uu))
          {
            if (qword_1009778C8 != -1)
              dispatch_once(&qword_1009778C8, &stru_10093FA18);
            v47 = off_1009778C0;
            v48 = sub_100030DF4(uu);
            v49 = (void *)objc_claimAutoreleasedReturnValue(v48);
            v50 = sub_1000589DC((uint64_t)v47, v49, 0);

            memset(v66, 0, 7);
            v51 = sub_1000746A4(v50);
            v66[0] = v51;
            BYTE2(v66[1]) = BYTE6(v51);
            LOWORD(v66[1]) = WORD2(v51);
            v65 = 0;
            sub_100043758(&v65);
            if (uuid_is_null(uu))
              v52 = 0;
            else
              v52 = v66;
            if (sub_10022CB60(v52, 1))
            {
              v53 = qword_100999818;
              if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
              {
                memset(buf, 0, 37);
                uuid_unparse_upper(uu, (char *)buf);
                sub_100091AE8(dst, (char *)buf);
                v56 = dst;
                if (v73 < 0)
                  v56 = *(unsigned __int8 **)dst;
                *(_DWORD *)v74 = 136446210;
                v75 = v56;
                _os_log_error_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_ERROR, "Failed to re-enable OOB pairing for device \"%{public}s\"", v74, 0xCu);
                if (v73 < 0)
                  operator delete(*(void **)dst);
              }
            }
            sub_100043728(&v65);
          }
          objc_autoreleasePoolPop(v46);
          v54 = (unsigned __int8 *)*((_QWORD *)v45 + 1);
          if (v54)
          {
            do
            {
              v55 = (const unsigned __int8 **)v54;
              v54 = *(unsigned __int8 **)v54;
            }
            while (v54);
          }
          else
          {
            do
            {
              v55 = (const unsigned __int8 **)*((_QWORD *)v45 + 2);
              v17 = *v55 == v45;
              v45 = (const unsigned __int8 *)v55;
            }
            while (!v17);
          }
          v45 = (const unsigned __int8 *)v55;
        }
        while (v55 != v44 + 6);
      }
      v57 = (_QWORD *)v44[1];
      if (v57)
      {
        do
        {
          v58 = v57;
          v57 = (_QWORD *)*v57;
        }
        while (v57);
      }
      else
      {
        do
        {
          v58 = (_QWORD *)v44[2];
          v17 = *v58 == (_QWORD)v44;
          v44 = v58;
        }
        while (!v17);
      }
      v44 = v58;
    }
    while (v58 != a1 + 68);
  }
  v59 = objc_claimAutoreleasedReturnValue(+[NSMutableArray array](NSMutableArray, "array", v62));
  v60 = (void *)a1[466];
  a1[466] = v59;

  sub_100692428((uint64_t)a1);
  sub_100695040((uint64_t)a1);
  if (sub_100225224())
  {
    if (qword_1009778C8 != -1)
      dispatch_once(&qword_1009778C8, &stru_10093FA18);
    sub_100655F30((uint64_t)off_1009778C0, 0);
  }
  return sub_100034234((uint64_t)v71);
}

void sub_100695D80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36)
{
  sub_100034234((uint64_t)&a33);
  _Unwind_Resume(a1);
}

_BYTE *sub_100695EA4()
{
  NSObject *v0;
  char v2;
  uint8_t buf[16];

  v0 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "Clearing address resolving cache", buf, 2u);
  }
  v2 = 0;
  sub_100043758(&v2);
  sub_10022E4A0();
  sub_10004339C(&v2);
  return sub_100043728(&v2);
}

void sub_100695F28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  sub_100043728(&a13);
  _Unwind_Resume(a1);
}

uint64_t sub_100695F3C(uint64_t a1, uint64_t a2)
{
  _QWORD v5[2];

  v5[0] = 0;
  v5[1] = 0;
  sub_10003415C((uint64_t)v5, a1 + 48);
  *(_QWORD *)(a1 + 560) = a2;
  return sub_100034234((uint64_t)v5);
}

uint64_t sub_100695F80(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  unint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;
  _QWORD v20[2];

  v20[0] = 0;
  v20[1] = 0;
  sub_10003415C((uint64_t)v20, (uint64_t)(a1 + 6));
  v4 = (_QWORD *)a1[71];
  v5 = (_QWORD *)a1[72];
  v6 = v4;
  if (v4 != v5)
  {
    while (*v6 != a2)
    {
      if (++v6 == v5)
      {
        v6 = (_QWORD *)a1[72];
        break;
      }
    }
  }
  if (v6 == v5)
  {
    v7 = a1[73];
    if ((unint64_t)v5 >= v7)
    {
      v9 = v5 - v4;
      if ((unint64_t)(v9 + 1) >> 61)
        abort();
      v10 = v7 - (_QWORD)v4;
      v11 = v10 >> 2;
      if (v10 >> 2 <= (unint64_t)(v9 + 1))
        v11 = v9 + 1;
      if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
        v12 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v12 = v11;
      if (v12)
        v13 = (char *)sub_10007ABA0((uint64_t)(a1 + 73), v12);
      else
        v13 = 0;
      v14 = &v13[8 * v9];
      v15 = &v13[8 * v12];
      *(_QWORD *)v14 = a2;
      v8 = v14 + 8;
      v16 = (char *)a1[72];
      v17 = (char *)a1[71];
      if (v16 != v17)
      {
        do
        {
          v18 = *((_QWORD *)v16 - 1);
          v16 -= 8;
          *((_QWORD *)v14 - 1) = v18;
          v14 -= 8;
        }
        while (v16 != v17);
        v16 = (char *)a1[71];
      }
      a1[71] = v14;
      a1[72] = v8;
      a1[73] = v15;
      if (v16)
        operator delete(v16);
    }
    else
    {
      *v5 = a2;
      v8 = v5 + 1;
    }
    a1[72] = v8;
  }
  return sub_100034234((uint64_t)v20);
}

void sub_1006960B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100034234((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1006960C4(uint64_t a1, uint64_t a2)
{
  char *v4;
  char *v5;
  int64_t v6;
  _QWORD v8[2];

  v8[0] = 0;
  v8[1] = 0;
  sub_10003415C((uint64_t)v8, a1 + 48);
  v4 = *(char **)(a1 + 568);
  v5 = *(char **)(a1 + 576);
  if (v4 != v5)
  {
    while (*(_QWORD *)v4 != a2)
    {
      v4 += 8;
      if (v4 == v5)
      {
        v4 = *(char **)(a1 + 576);
        break;
      }
    }
  }
  if (v4 != v5)
  {
    v6 = v5 - (v4 + 8);
    if (v5 != v4 + 8)
      memmove(v4, v4 + 8, v5 - (v4 + 8));
    *(_QWORD *)(a1 + 576) = &v4[v6];
  }
  return sub_100034234((uint64_t)v8);
}

void sub_100696160(uint64_t a1, void *a2, int a3, int a4, int a5)
{
  id v9;
  NSObject *v10;
  void *v11;
  unint64_t v12;
  NSObject *v13;
  _BOOL8 v14;
  int v15;
  uint8_t *v16;
  NSObject *v17;
  NSObject *v18;
  void *v19;
  char v20;
  uint64_t v21;
  uint8_t buf[4];
  unint64_t v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  __int16 v28;
  int v29;

  v9 = a2;
  if (*(_BYTE *)(a1 + 3718))
  {
LABEL_2:
    if (*(_BYTE *)(a1 + 41))
    {
      sub_1002A8EA8(19, 0, v9);
      v10 = qword_100999818;
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138544130;
        v23 = (unint64_t)v9;
        v24 = 1024;
        v25 = a3;
        v26 = 1024;
        v27 = a4;
        v28 = 1024;
        v29 = a5;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Initiating pairing to device \"%{public}@\" useMITM=%d distributeIRK=%d disableCTKD=%d", buf, 0x1Eu);
      }
      v21 = 0;
      if (qword_1009778A8 != -1)
        dispatch_once(&qword_1009778A8, &stru_10093FA38);
      v11 = off_1009778A0;
      sub_100030BCC(buf, v9);
      if (sub_100623C54((uint64_t)v11, buf, &v21))
      {
        v12 = *(_QWORD *)(a1 + 456);
        if (v12 >= *(unsigned __int16 *)(a1 + 3736))
        {
          v18 = qword_100999818;
          if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 134217984;
            v23 = v12;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Ignoring pairing request as there are too many paired devices (%lu)", buf, 0xCu);
          }
          v20 = 0;
          sub_100043758(&v20);
          sub_1001EE69C(v21, 4835);
          sub_10004339C(&v20);
          if (qword_1009778A8 != -1)
            dispatch_once(&qword_1009778A8, &stru_10093FA38);
          v19 = off_1009778A0;
          sub_100030BCC(buf, v9);
          sub_100622358((uint64_t)v19, buf, 8u);
          v16 = (uint8_t *)&v20;
        }
        else
        {
          if (a5)
          {
            v13 = qword_100999818;
            v14 = os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT);
            if (v14)
            {
              *(_DWORD *)buf = 138543362;
              v23 = (unint64_t)v9;
              _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Disabling CTKD for device \"%{public}@", buf, 0xCu);
            }
            sub_100696524(v14, v9, 1);
          }
          buf[0] = 0;
          sub_100043758(buf);
          if ((a4 & 1) == 0)
            sub_100238FD0(1);
          v15 = sub_100224098(v21, a3);
          sub_10004339C(buf);
          if (v15 && os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
            sub_10071964C();
          v16 = buf;
        }
        sub_100043728(v16);
      }
      else if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
      {
        sub_1007196AC();
      }
    }
    goto LABEL_30;
  }
  v17 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_fault_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_FAULT, "We don't have root keys for LE, something's wrong, file a radar!", buf, 2u);
    if (*(_BYTE *)(a1 + 3718))
      goto LABEL_2;
    v17 = qword_100999818;
  }
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    sub_100719620();
LABEL_30:

}

void sub_1006964D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  void *v3;
  va_list va;

  va_start(va, a3);
  sub_100043728(va);

  _Unwind_Resume(a1);
}

void sub_100696524(uint64_t a1, void *a2, int a3)
{
  id v4;
  NSObject *v5;
  const char *v6;
  void *v7;
  _BOOL8 v8;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  id v12;

  v4 = a2;
  v5 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    v6 = "enable";
    if (a3)
      v6 = "disable";
    *(_DWORD *)buf = 136446466;
    v10 = v6;
    v11 = 2114;
    v12 = v4;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Warning: Trying to %{public}s CTKD for device %{public}@", buf, 0x16u);
  }
  v8 = 0;
  if (qword_1009778A8 != -1)
    dispatch_once(&qword_1009778A8, &stru_10093FA38);
  v7 = off_1009778A0;
  sub_100030BCC(buf, v4);
  if (sub_100623C54((uint64_t)v7, buf, &v8))
  {
    buf[0] = 0;
    sub_100043758(buf);
    sub_10023903C(v8, a3);
    sub_100043728(buf);
  }
  else if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
  {
    sub_100719710();
  }

}

void sub_100696694(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  void *v3;
  va_list va;

  va_start(va, a3);
  sub_100043728(va);

  _Unwind_Resume(a1);
}

void sub_1006966C0(uint64_t a1, void *a2, int a3, unsigned int a4)
{
  id v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  _BOOL4 v11;
  id v12;
  void *v13;
  NSObject *v14;
  NSObject *v15;
  id v16;
  void *v17;
  int v18;
  __int16 v19;
  char v20;
  uint8_t buf[4];
  _BYTE v22[24];

  v7 = a2;
  if (*(_BYTE *)(a1 + 3718))
  {
LABEL_2:
    if (*(_BYTE *)(a1 + 41))
    {
      if (qword_1009778C8 != -1)
        dispatch_once(&qword_1009778C8, &stru_10093FA18);
      v8 = sub_1000589DC((uint64_t)off_1009778C0, v7, 0);
      v9 = sub_1000746A4(v8);
      v18 = v9;
      v20 = BYTE6(v9);
      v19 = WORD2(v9);
      if (a3)
      {
        v10 = qword_100999818;
        v11 = os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT);
        if (a4)
        {
          if (v11)
          {
            v12 = sub_100021770(v8);
            v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
            *(_DWORD *)buf = 67109634;
            *(_DWORD *)v22 = a4;
            *(_WORD *)&v22[4] = 2114;
            *(_QWORD *)&v22[6] = v7;
            *(_WORD *)&v22[14] = 2114;
            *(_QWORD *)&v22[16] = v13;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Accepting pairing request with passkey %u from device \"%{public}@\" (%{public}@)", buf, 0x1Cu);

          }
        }
        else if (v11)
        {
          v16 = sub_100021770(v8);
          v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
          *(_DWORD *)buf = 138543618;
          *(_QWORD *)v22 = v7;
          *(_WORD *)&v22[8] = 2114;
          *(_QWORD *)&v22[10] = v17;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Accepting pairing request from device \"%{public}@\"(%{public}@)", buf, 0x16u);

        }
        buf[0] = 0;
        sub_100043758(buf);
        if (sub_1002307F0(&v18, a4))
        {
          if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
            sub_100719774();
          sub_1002305D8(&v18);
        }
      }
      else
      {
        v15 = qword_100999818;
        if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138543362;
          *(_QWORD *)v22 = v7;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Rejecting pairing request from device \"%{public}@\"", buf, 0xCu);
        }
        buf[0] = 0;
        sub_100043758(buf);
        if (sub_1002305D8(&v18) && os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
          sub_1007197D4();
      }
      sub_100043728(buf);
    }
    goto LABEL_24;
  }
  v14 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_fault_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_FAULT, "We don't have root keys for LE, something's wrong, file a radar!", buf, 2u);
    if (*(_BYTE *)(a1 + 3718))
      goto LABEL_2;
    v14 = qword_100999818;
  }
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    sub_100719620();
LABEL_24:

}

void sub_1006969D8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_100696A18(uint64_t a1, unint64_t a2, void *a3, int a4, uint64_t a5)
{
  id v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  _OWORD *v15;
  uint64_t v16;
  __int128 v17;
  uint64_t v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  BOOL v26;
  BOOL v27;
  NSObject *v28;
  id v29;
  void *v30;
  int v31;
  NSObject *v32;
  NSObject *v33;
  id v34;
  void *v35;
  int v36;
  NSObject *v37;
  NSObject *v38;
  id v39;
  void *v40;
  int v41;
  NSObject *v42;
  NSObject *v43;
  id v44;
  void *v45;
  id v46;
  void *v47;
  id v48;
  void *v49;
  char v50;
  _QWORD v51[2];
  int v52;
  __int16 v53;
  char v54;
  unint64_t v55;
  uint8_t buf[4];
  id v57;
  __int16 v58;
  void *v59;
  _BYTE uu[32];
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;

  v55 = a2;
  v8 = a3;
  if (*(_BYTE *)(a1 + 3718))
  {
LABEL_2:
    if (*(_BYTE *)(a1 + 41))
    {
      if (qword_1009778C8 != -1)
        dispatch_once(&qword_1009778C8, &stru_10093FA18);
      v9 = sub_1000589DC((uint64_t)off_1009778C0, v8, 0);
      v10 = sub_1000746A4(v9);
      v52 = v10;
      v54 = BYTE6(v10);
      v53 = WORD2(v10);
      if (a4)
      {
        v51[0] = 0;
        v51[1] = 0;
        sub_10003415C((uint64_t)v51, a1 + 48);
        v50 = 0;
        sub_100043758(&v50);
        *(_QWORD *)uu = &v55;
        v11 = sub_1002BBB54((uint64_t **)(a1 + 536), &v55, (uint64_t)&unk_100740F58, (uint64_t **)uu);
        sub_100030BCC(uu, v8);
        v12 = (uint64_t)(v11 + 5);
        v13 = sub_10000C5B8((uint64_t)(v11 + 5), uu);
        v14 = v11 + 6;
        if ((v14 == (uint64_t *)v13 || (v15 = *(_OWORD **)(v13 + 48)) == 0)
          && ((uuid_clear(uu), v16 = sub_10000C5B8(v12, uu), v14 == (uint64_t *)v16)
           || (v15 = *(_OWORD **)(v16 + 48)) == 0))
        {
          v38 = qword_100999818;
          if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
          {
            v39 = sub_100021770(v9);
            v40 = (void *)objc_claimAutoreleasedReturnValue(v39);
            *(_DWORD *)uu = 138543618;
            *(_QWORD *)&uu[4] = v8;
            *(_WORD *)&uu[12] = 2114;
            *(_QWORD *)&uu[14] = v40;
            _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "Accepting out-of-band pairing request from device \"%{public}@\" (%{public}@) with remote keys", uu, 0x16u);

          }
          v31 = sub_100238788(&v52, (_OWORD *)a5, (_OWORD *)(a5 + 16), 0);
        }
        else
        {
          v17 = v15[1];
          *(_OWORD *)uu = *v15;
          *(_OWORD *)&uu[16] = v17;
          v18 = *(_QWORD *)(a5 + 8);
          v26 = *(_QWORD *)a5 == *(_QWORD *)uu;
          v19 = v15[2];
          v20 = v15[3];
          v21 = v15[5];
          v63 = v15[4];
          v64 = v21;
          v61 = v19;
          v62 = v20;
          v22 = v15[7];
          v65 = v15[6];
          v66 = v22;
          v23 = v15[11];
          v25 = v15[8];
          v24 = v15[9];
          v69 = v15[10];
          v70 = v23;
          v26 = v26 && v18 == *(_QWORD *)&uu[8];
          v67 = v25;
          v68 = v24;
          if (v26
            && (*(_QWORD *)(a5 + 16) == *(_QWORD *)&uu[16]
              ? (v27 = *(_QWORD *)(a5 + 24) == *(_QWORD *)&uu[24])
              : (v27 = 0),
                v27))
          {
            v43 = qword_100999818;
            if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
            {
              v44 = sub_100021770(v9);
              v45 = (void *)objc_claimAutoreleasedReturnValue(v44);
              *(_DWORD *)buf = 138543618;
              v57 = v8;
              v58 = 2114;
              v59 = v45;
              _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "Accepting out-of-band pairing request from device \"%{public}@\" (%{public}@) with locally generated key bundle", buf, 0x16u);

            }
            v31 = sub_100238788(&v52, 0, 0, uu);
          }
          else
          {
            v28 = qword_100999818;
            if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
            {
              v29 = sub_100021770(v9);
              v30 = (void *)objc_claimAutoreleasedReturnValue(v29);
              *(_DWORD *)buf = 138543618;
              v57 = v8;
              v58 = 2114;
              v59 = v30;
              _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Accepting out-of-band pairing request from device \"%{public}@\" (%{public}@) with locally generated key bundle for 2-way OOB", buf, 0x16u);

            }
            v31 = sub_100238788(&v52, (_OWORD *)a5, (_OWORD *)(a5 + 16), uu);
          }
        }
        v41 = v31;
        if (v31)
        {
          v42 = qword_100999818;
          if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
          {
            v48 = sub_100021770(v9);
            v49 = (void *)objc_claimAutoreleasedReturnValue(v48);
            *(_DWORD *)uu = 138543874;
            *(_QWORD *)&uu[4] = v8;
            *(_WORD *)&uu[12] = 2114;
            *(_QWORD *)&uu[14] = v49;
            *(_WORD *)&uu[22] = 1024;
            *(_DWORD *)&uu[24] = v41;
            _os_log_error_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "Failed to accept pairing for device \"%{public}@\" (%{public}@) with result %{bluetooth:OI_STATUS}u - cancelling...", uu, 0x1Cu);

          }
          sub_1002305D8(&v52);
        }
        sub_100043728(&v50);
        sub_100034234((uint64_t)v51);
      }
      else
      {
        v33 = qword_100999818;
        if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
        {
          v34 = sub_100021770(v9);
          v35 = (void *)objc_claimAutoreleasedReturnValue(v34);
          *(_DWORD *)uu = 138543618;
          *(_QWORD *)&uu[4] = v8;
          *(_WORD *)&uu[12] = 2114;
          *(_QWORD *)&uu[14] = v35;
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "Rejecting out-of-band pairing request from device \"%{public}@\" (%{public}@)", uu, 0x16u);

        }
        buf[0] = 0;
        sub_100043758(buf);
        v36 = sub_1002305D8(&v52);
        if (v36)
        {
          v37 = qword_100999818;
          if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
          {
            v46 = sub_100021770(v9);
            v47 = (void *)objc_claimAutoreleasedReturnValue(v46);
            *(_DWORD *)uu = 138543874;
            *(_QWORD *)&uu[4] = v8;
            *(_WORD *)&uu[12] = 2114;
            *(_QWORD *)&uu[14] = v47;
            *(_WORD *)&uu[22] = 1024;
            *(_DWORD *)&uu[24] = v36;
            _os_log_error_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, "Failed to cancel pairing to device \"%{public}@\" (%{public}@) with result %{bluetooth:OI_STATUS}u", uu, 0x1Cu);

          }
        }
        sub_100043728(buf);
      }
    }
    goto LABEL_39;
  }
  v32 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)uu = 0;
    _os_log_fault_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_FAULT, "We don't have root keys for LE, something's wrong, file a radar!", uu, 2u);
    if (*(_BYTE *)(a1 + 3718))
      goto LABEL_2;
    v32 = qword_100999818;
  }
  if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    sub_100719620();
LABEL_39:

}

void sub_100696FB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13, char a14)
{
  void *v14;

  sub_100043728(&a13);
  sub_100034234((uint64_t)&a14);

  _Unwind_Resume(a1);
}

uint64_t sub_100697030(uint64_t a1, uint64_t a2, void *a3)
{
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char v13;
  _QWORD v14[3];
  _OWORD v15[12];

  v14[2] = a2;
  v4 = a3;
  memset(v15, 0, sizeof(v15));
  v14[0] = 0;
  v14[1] = 0;
  sub_10003415C((uint64_t)v14, a1 + 48);
  v13 = 0;
  sub_100043758(&v13);
  if (!sub_100238600(v15, v5, v6, v7, v8, v9, v10, v11))
    operator new();
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
    sub_100719834();
  sub_100043728(&v13);
  sub_100034234((uint64_t)v14);

  return 0;
}

void sub_10069732C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, __int16 a10, char a11, char a12, char a13)
{
  void *v13;

  sub_100043728(&a12);
  sub_100034234((uint64_t)&a13);

  _Unwind_Resume(a1);
}

void sub_100697378(uint64_t a1, unint64_t a2, void *a3, char a4)
{
  id v6;
  uint64_t *v7;
  uint64_t **v8;
  uint64_t *v9;
  NSObject *v10;
  _BOOL4 v11;
  unint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  int *v15;
  _QWORD v16[2];
  unint64_t v17;
  const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v18;
  _BYTE buf[24];

  v17 = a2;
  v6 = a3;
  v16[0] = 0;
  v16[1] = 0;
  sub_10003415C((uint64_t)v16, a1 + 48);
  *(_QWORD *)buf = &v17;
  v7 = sub_1002BBB54((uint64_t **)(a1 + 536), &v17, (uint64_t)&unk_100740F58, (uint64_t **)buf);
  sub_100030BCC(buf, v6);
  v8 = (uint64_t **)(v7 + 5);
  v18 = buf;
  v9 = sub_1006A76D4(v8, buf, (uint64_t)&unk_100740F58, &v18);
  *((_BYTE *)v9 + 56) = a4;
  if ((a4 & 1) != 0)
  {
    v10 = qword_100999818;
    v11 = os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT);
    if (v6)
    {
      if (v11)
      {
        *(_DWORD *)buf = 138543362;
        *(_QWORD *)&buf[4] = v6;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Enabling out-of-band pairing for device \"%{public}@\"", buf, 0xCu);
      }
      if (qword_1009778C8 != -1)
        dispatch_once(&qword_1009778C8, &stru_10093FA18);
      v12 = sub_1000589DC((uint64_t)off_1009778C0, v6, 0);
    }
    else
    {
      if (v11)
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Enabling out-of-band pairing for all devices", buf, 2u);
      }
      v12 = 0;
    }
    v14 = sub_1000746A4(v12);
    *(_DWORD *)buf = v14;
    buf[6] = BYTE6(v14);
    *(_WORD *)&buf[4] = WORD2(v14);
    LOBYTE(v18) = 0;
    sub_100043758(&v18);
    if (v6)
      v15 = (int *)buf;
    else
      v15 = 0;
    if (sub_10022CB60(v15, 1) && os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
      sub_100719894();
    sub_100043728(&v18);
  }
  else
  {
    if (!v9[6])
    {
      sub_100030BCC(buf, v6);
      v13 = (uint64_t *)sub_10000C5B8((uint64_t)v8, buf);
      sub_1000040CC(v8, v13);
      operator delete(v13);
    }
    sub_100697628(a1, v6);
  }
  sub_100034234((uint64_t)v16);

}

void sub_1006975D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  va_list va;

  va_start(va, a2);
  sub_100034234((uint64_t)va);

  _Unwind_Resume(a1);
}

void sub_100697628(uint64_t a1, void *a2)
{
  id v3;
  _QWORD *v4;
  char v5;
  const unsigned __int8 *v6;
  id v7;
  void *v8;
  int v9;
  unsigned __int8 *v10;
  const unsigned __int8 **v11;
  BOOL v12;
  _QWORD *v13;
  _QWORD *v14;
  NSObject *v15;
  _BOOL4 v16;
  unint64_t v17;
  uint64_t v18;
  int v19;
  unint64_t v20;
  uint64_t v21;
  int v22;
  char v23;
  uint8_t buf[4];
  id v25;

  v3 = a2;
  v4 = *(_QWORD **)(a1 + 536);
  if (v4 == (_QWORD *)(a1 + 544))
  {
LABEL_21:
    if (!*(_BYTE *)(a1 + 41))
      goto LABEL_39;
    v23 = 0;
    sub_100043758(&v23);
    v15 = qword_100999818;
    v16 = os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT);
    if (v3)
    {
      if (v16)
      {
        *(_DWORD *)buf = 138543362;
        v25 = v3;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Disabling out-of-band pairing for device \"%{public}@\"", buf, 0xCu);
      }
      if (qword_1009778C8 != -1)
        dispatch_once(&qword_1009778C8, &stru_10093FA18);
      v17 = sub_1000589DC((uint64_t)off_1009778C0, v3, 0);
      v18 = sub_1000746A4(v17);
      *(_DWORD *)buf = v18;
      BYTE2(v25) = BYTE6(v18);
      LOWORD(v25) = WORD2(v18);
      v19 = sub_10022CB60((int *)buf, 0);
      if (v19 != 120)
        goto LABEL_35;
      if (qword_1009778C8 != -1)
        dispatch_once(&qword_1009778C8, &stru_10093FA18);
      v20 = sub_1000589DC((uint64_t)off_1009778C0, v3, 1);
      v21 = sub_1000746A4(v20);
      *(_DWORD *)buf = v21;
      BYTE2(v25) = BYTE6(v21);
      LOWORD(v25) = WORD2(v21);
      v22 = sub_10022CB60((int *)buf, 0);
    }
    else
    {
      if (v16)
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Disabling out-of-band pairing for all devices", buf, 2u);
      }
      v22 = sub_10022CB60(0, 0);
    }
    v19 = v22;
LABEL_35:
    if (v19 && os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
      sub_1007198F8();
    sub_100043728(&v23);
    goto LABEL_39;
  }
  v5 = 1;
  do
  {
    v6 = (const unsigned __int8 *)v4[5];
    if (v6 == (const unsigned __int8 *)(v4 + 6))
      goto LABEL_14;
    while (1)
    {
      v7 = sub_100030DF4(v6 + 32);
      v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
      if (!objc_msgSend(v3, "isEqual:", v8))
      {

        goto LABEL_8;
      }
      v9 = v6[56];

      if (v9)
        break;
LABEL_8:
      v10 = (unsigned __int8 *)*((_QWORD *)v6 + 1);
      if (v10)
      {
        do
        {
          v11 = (const unsigned __int8 **)v10;
          v10 = *(unsigned __int8 **)v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          v11 = (const unsigned __int8 **)*((_QWORD *)v6 + 2);
          v12 = *v11 == v6;
          v6 = (const unsigned __int8 *)v11;
        }
        while (!v12);
      }
      v6 = (const unsigned __int8 *)v11;
      if (v11 == v4 + 6)
        goto LABEL_14;
    }
    v5 = 0;
LABEL_14:
    v13 = (_QWORD *)v4[1];
    if (v13)
    {
      do
      {
        v14 = v13;
        v13 = (_QWORD *)*v13;
      }
      while (v13);
    }
    else
    {
      do
      {
        v14 = (_QWORD *)v4[2];
        v12 = *v14 == (_QWORD)v4;
        v4 = v14;
      }
      while (!v12);
    }
    v4 = v14;
  }
  while (v14 != (_QWORD *)(a1 + 544));
  if ((v5 & 1) != 0)
    goto LABEL_21;
LABEL_39:

}

void sub_100697914(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  void *v13;

  sub_100043728(&a13);

  _Unwind_Resume(a1);
}

uint64_t sub_100697958(uint64_t a1, unint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  unint64_t v6;
  BOOL v7;
  _QWORD *v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  unsigned __int8 *v12;
  BOOL v13;
  id v14;
  void *v15;
  _QWORD v17[2];
  uuid_t dst;

  v17[0] = 0;
  v17[1] = 0;
  sub_10003415C((uint64_t)v17, a1 + 48);
  v4 = *(_QWORD **)(a1 + 544);
  if (v4)
  {
    v5 = a1 + 544;
    do
    {
      v6 = v4[4];
      v7 = v6 >= a2;
      if (v6 >= a2)
        v8 = v4;
      else
        v8 = v4 + 1;
      if (v7)
        v5 = (uint64_t)v4;
      v4 = (_QWORD *)*v8;
    }
    while (*v8);
    if (v5 != a1 + 544 && *(_QWORD *)(v5 + 32) <= a2)
    {
      v9 = *(unsigned __int8 **)(v5 + 40);
      if (v9 != (unsigned __int8 *)(v5 + 48))
      {
        do
        {
          memset(dst, 0, sizeof(dst));
          uuid_copy(dst, v9 + 32);
          if (*((_QWORD *)v9 + 6))
            operator delete();
          v10 = (unsigned __int8 *)*((_QWORD *)v9 + 1);
          v11 = v9;
          if (v10)
          {
            do
            {
              v12 = v10;
              v10 = *(unsigned __int8 **)v10;
            }
            while (v10);
          }
          else
          {
            do
            {
              v12 = (unsigned __int8 *)*((_QWORD *)v11 + 2);
              v13 = *(_QWORD *)v12 == (_QWORD)v11;
              v11 = v12;
            }
            while (!v13);
          }
          sub_1000040CC((uint64_t **)(v5 + 40), (uint64_t *)v9);
          operator delete(v9);
          v14 = sub_100030DF4(dst);
          v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
          sub_100697628(a1, v15);

          v9 = v12;
        }
        while (v12 != (unsigned __int8 *)(v5 + 48));
      }
      sub_10039430C((uint64_t **)(a1 + 536), v5);
    }
  }
  return sub_100034234((uint64_t)v17);
}

void sub_100697ADC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_100034234((uint64_t)va);
  _Unwind_Resume(a1);
}

id sub_100697B0C(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, const std::string *a5)
{
  unint64_t v10;
  NSObject *v11;
  void *v12;
  __int128 *v13;
  void *v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  void *v19;
  id v20;
  void *v21;
  unint64_t v22;
  id v23;
  void *v24;
  void *__p[2];
  uint64_t v27;
  _QWORD v28[2];
  unsigned __int8 *v29;
  unsigned __int8 uu2[8];
  uint64_t v31;
  uint8_t buf[24];

  v28[0] = 0;
  v28[1] = 0;
  sub_10003415C((uint64_t)v28, a1 + 48);
  v10 = *(_QWORD *)(a1 + 456);
  if (v10 >= *(unsigned __int16 *)(a1 + 3736))
  {
    v11 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = v10;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Too many paired devices (%lu), but cloud paired devices are allowed", buf, 0xCu);
    }
  }
  *(_OWORD *)buf = 0uLL;
  sub_1003965C0(*(_QWORD *)(a4 + 8), 10, buf);
  *(_QWORD *)uu2 = 0;
  v31 = 0;
  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_10093FA18);
  v12 = off_1009778C0;
  if (sub_1000452EC((uint64_t)buf))
    v13 = 0;
  else
    v13 = (__int128 *)sub_10003EB18((uint64_t)buf);
  sub_10003F924((uint64_t)v12, a2, 1u, 0, 0, v13, uu2);
  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_10093FA18);
  v14 = off_1009778C0;
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10003430C(__p, *(void **)a3, *(_QWORD *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)__p = *(_OWORD *)a3;
    v27 = *(_QWORD *)(a3 + 16);
  }
  sub_10065354C((uint64_t)v14, uu2, (uint64_t)__p, 2);
  if (SHIBYTE(v27) < 0)
    operator delete(__p[0]);
  if (a1 + 472 != sub_10000C5B8(a1 + 464, uu2))
  {
    v15 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_FAULT))
      sub_100719958(v15, v16, v17);
  }
  v29 = uu2;
  v18 = sub_1006A7348((uint64_t **)(a1 + 464), uu2, (uint64_t)&unk_100740F58, (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)&v29);
  sub_100041698((uint64_t)(v18 + 6), a4);
  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_10093FA18);
  v19 = off_1009778C0;
  v20 = sub_100030DF4(uu2);
  v21 = (void *)objc_claimAutoreleasedReturnValue(v20);
  v22 = sub_1000589DC((uint64_t)v19, v21, 0);
  sub_100697E58(a1, v22, a2, 0, a5);

  v23 = sub_100030DF4(uu2);
  v24 = (void *)objc_claimAutoreleasedReturnValue(v23);
  *(_QWORD *)buf = &off_100918258;
  if (*(_QWORD *)&buf[8])
    sub_100056AAC(*(unsigned int **)&buf[8]);
  sub_100034234((uint64_t)v28);
  return v24;
}

void sub_100697DF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t (**a22)(),unsigned int *a23)
{
  a22 = &off_100918258;
  if (a23)
    sub_100056AAC(a23);
  sub_100034234((uint64_t)&a16);
  _Unwind_Resume(a1);
}

void sub_100697E58(uint64_t a1, unint64_t a2, unint64_t a3, int a4, const std::string *a5)
{
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  id v12;
  id v13;
  NSObject *v14;
  id v15;
  void *v16;
  uint64_t **v17;
  void *v18;
  id v19;
  void *v20;
  id v21;
  void *v22;
  uint64_t v23;
  NSObject *v24;
  void **v25;
  void *v26;
  id v27;
  void *v28;
  void *v29;
  id v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  NSObject *v47;
  id v48;
  id v49;
  id v50;
  void *v51;
  _BOOL4 v52;
  NSObject *v53;
  id v54;
  void *v55;
  void *v56;
  id v57;
  void *v58;
  int v59;
  void *v60;
  id v61;
  void *v62;
  uint64_t *v63;
  void *v64;
  id v65;
  void *v66;
  id v67;
  void *v68;
  uint64_t *v69;
  void *v71[2];
  char v72;
  uint64_t (**v73)();
  unsigned int *v74;
  uint64_t (**v75)();
  unsigned int *v76;
  uint64_t (**v77)();
  unsigned int *v78;
  uint64_t (**v79)();
  unsigned int *v80;
  void *__p[2];
  char v82;
  _QWORD v83[2];
  _BYTE src[40];
  uint64_t (**v85)();
  unsigned int *v86;
  __int128 buf;
  void **v88;
  unsigned int *v89;
  char v90;
  uuid_t uu;

  memset(uu, 0, sizeof(uu));
  uuid_clear(uu);
  if (*(_BYTE *)(a1 + 41))
  {
    v9 = sub_1000746A4(a2);
    *(_DWORD *)src = v9;
    src[6] = BYTE6(v9);
    *(_WORD *)&src[4] = WORD2(v9);
    LOBYTE(v88) = 0;
    sub_100043758(&v88);
    v10 = sub_10019AFA0(src);
    sub_10004339C(&v88);
    if (v10)
    {
      if (qword_1009778A8 != -1)
        dispatch_once(&qword_1009778A8, &stru_10093FA38);
      sub_10061E090((uint64_t)off_1009778A0, v10, uu);
    }
    sub_100043728(&v88);
  }
  if (uuid_is_null(uu))
  {
    if (qword_1009778C8 != -1)
      dispatch_once(&qword_1009778C8, &stru_10093FA18);
    sub_10003F924((uint64_t)off_1009778C0, a2, 0, 1u, 0, 0, src);
    uuid_copy(uu, src);
    if (uuid_is_null(uu))
    {
      if (qword_1009778C8 != -1)
        dispatch_once(&qword_1009778C8, &stru_10093FA18);
      sub_10003F924((uint64_t)off_1009778C0, a3, 0, 1u, 0, 0, src);
      uuid_copy(uu, src);
    }
  }
  v11 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_INFO))
  {
    v12 = sub_100021770(a2);
    v13 = (id)objc_claimAutoreleasedReturnValue(v12);
    *(_DWORD *)src = 138543618;
    *(_QWORD *)&src[4] = v13;
    *(_WORD *)&src[12] = 1024;
    *(_DWORD *)&src[14] = a4;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_INFO, "Device \"%{public}@\" finished pairing with status  %{bluetooth:OI_STATUS}u", src, 0x12u);

  }
  if (!uuid_is_null(uu))
  {
    v83[0] = 0;
    v83[1] = 0;
    sub_10003415C((uint64_t)v83, a1 + 48);
    v17 = (uint64_t **)(a1 + 464);
    v69 = (uint64_t *)sub_10000C5B8(a1 + 464, uu);
    if (a4)
    {
      if (a4 != 4832)
      {
        if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
        {
          sub_1003D2DB4(uu, src);
          sub_1007199F8();
        }
        switch(a4)
        {
          case 4818:
          case 4819:
          case 4820:
          case 4821:
          case 4822:
          case 4823:
          case 4824:
          case 4825:
          case 4826:
          case 4827:
            break;
          default:
            switch(a4)
            {
              case 4808:
                if (a3)
                {
                  buf = 0uLL;
                  if (qword_1009778C8 != -1)
                    dispatch_once(&qword_1009778C8, &stru_10093FA18);
                  sub_10003F924((uint64_t)off_1009778C0, a3, 0, 1u, 0, 0, (unsigned __int8 *)&buf);
                  if (uuid_is_null((const unsigned __int8 *)&buf)
                    && os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_FAULT))
                  {
                    sub_1007199CC();
                  }
                  if (!uuid_is_null((const unsigned __int8 *)&buf))
                  {
                    if (qword_1009778C8 != -1)
                      dispatch_once(&qword_1009778C8, &stru_10093FA18);
                    v64 = off_1009778C0;
                    v65 = sub_100030DF4(uu);
                    v66 = (void *)objc_claimAutoreleasedReturnValue(v65);
                    v67 = sub_100030DF4((const unsigned __int8 *)&buf);
                    v68 = (void *)objc_claimAutoreleasedReturnValue(v67);
                    sub_10065A598((uint64_t)v64, v66, v68);

                  }
                }
                break;
              default:
                goto LABEL_98;
            }
            break;
        }
LABEL_98:
        if ((uint64_t *)(a1 + 472) != v69)
          sub_1006A77F0((uint64_t **)(a1 + 464), v69);
        if (qword_1009778F8 != -1)
          dispatch_once(&qword_1009778F8, &stru_10093FA78);
        sub_1005E3B88(qword_1009778F0, 0, uu);
      }
      if ((uint64_t *)(a1 + 472) != v69)
        sub_1006A77F0((uint64_t **)(a1 + 464), v69);
      if (qword_1009778C8 != -1)
        dispatch_once(&qword_1009778C8, &stru_10093FA18);
      v18 = off_1009778C0;
      v19 = sub_100030DF4(uu);
      v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
      sub_100091AE8(__p, "_UNPAIR_AFTER_DISCONNECTION_");
      sub_1006576F0((uint64_t)v18, v20, (unsigned __int8 *)__p);
      if (v82 < 0)
        operator delete(__p[0]);

      v21 = sub_100030DF4(uu);
      v22 = (void *)objc_claimAutoreleasedReturnValue(v21);
      sub_1006A00E8(a1, v22);

      v23 = sub_1000419F4();
      *(_QWORD *)src = _NSConcreteStackBlock;
      *(_QWORD *)&src[8] = 3221225472;
      *(_QWORD *)&src[16] = sub_10069F67C;
      *(_QWORD *)&src[24] = &unk_100917378;
      *(_QWORD *)&src[32] = a1;
      sub_100041A34(v23, src);
    }
    v24 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
    {
      memset(src, 0, 37);
      uuid_unparse_upper(uu, src);
      sub_100091AE8(&v88, src);
      v25 = v90 >= 0 ? (void **)&v88 : v88;
      LODWORD(buf) = 136446210;
      *(_QWORD *)((char *)&buf + 4) = v25;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Pairing succeeded to device \"%{public}s\"", (uint8_t *)&buf, 0xCu);
      if (v90 < 0)
        operator delete(v88);
    }
    if (qword_1009778C8 != -1)
      dispatch_once(&qword_1009778C8, &stru_10093FA18);
    v26 = off_1009778C0;
    v27 = sub_100030DF4(uu);
    v28 = (void *)objc_claimAutoreleasedReturnValue(v27);
    sub_100659588((uint64_t)v26, v28, a5);

    if (qword_1009778C8 != -1)
      dispatch_once(&qword_1009778C8, &stru_10093FA18);
    v29 = off_1009778C0;
    v30 = sub_100030DF4(uu);
    v31 = (void *)objc_claimAutoreleasedReturnValue(v30);
    sub_10065C750((uint64_t)v29, v31, 1, 2, 0);

    sub_10069E524(a1, uu);
    if ((uint64_t *)(a1 + 472) != v69)
    {
      v32 = v69[7];
      *(_QWORD *)&buf = &off_100934340;
      *((_QWORD *)&buf + 1) = v32;
      if (v32)
        sub_10003C37C(v32);
      if (a3)
      {
        sub_1003965C0(*((uint64_t *)&buf + 1), 11, src);
        v33 = *(unsigned __int8 *)(sub_10003EB18((uint64_t)src) + 1);
        sub_1003965C0(*((uint64_t *)&buf + 1), 11, &v88);
        v34 = *(unsigned __int8 *)(sub_10003EB18((uint64_t)&v88) + 2);
        sub_1003965C0(*((uint64_t *)&buf + 1), 11, &v79);
        v35 = *(unsigned __int8 *)(sub_10003EB18((uint64_t)&v79) + 3);
        sub_1003965C0(*((uint64_t *)&buf + 1), 11, &v77);
        v36 = *(unsigned __int8 *)(sub_10003EB18((uint64_t)&v77) + 4);
        sub_1003965C0(*((uint64_t *)&buf + 1), 11, &v85);
        v37 = *(unsigned __int8 *)(sub_10003EB18((uint64_t)&v85) + 5);
        sub_1003965C0(*((uint64_t *)&buf + 1), 11, &v75);
        v38 = *(unsigned __int8 *)(sub_10003EB18((uint64_t)&v75) + 6);
        sub_1003965C0(*((uint64_t *)&buf + 1), 11, &v73);
        v39 = v33 << 40;
        v40 = *(unsigned __int8 *)sub_10003EB18((uint64_t)&v73);
        v73 = &off_100918258;
        if (v74)
          sub_100056AAC(v74);
        v41 = v39 | (v34 << 32);
        v75 = &off_100918258;
        if (v76)
          sub_100056AAC(v76);
        v42 = v41 | (v35 << 24);
        v85 = &off_100918258;
        if (v86)
          sub_100056AAC(v86);
        v43 = v42 | (v36 << 16);
        v77 = &off_100918258;
        if (v78)
          sub_100056AAC(v78);
        v44 = v43 | (v37 << 8);
        v79 = &off_100918258;
        if (v80)
          sub_100056AAC(v80);
        v45 = v44 | v38;
        v88 = (void **)&off_100918258;
        if (v89)
          sub_100056AAC(v89);
        v46 = v45 | (v40 << 48);
        *(_QWORD *)src = &off_100918258;
        if (*(_QWORD *)&src[8])
          sub_100056AAC(*(unsigned int **)&src[8]);
        v17 = (uint64_t **)(a1 + 464);
        if (v46 != a3)
        {
          v47 = qword_100999818;
          if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_FAULT))
          {
            v48 = sub_100021770(a3);
            v49 = (id)objc_claimAutoreleasedReturnValue(v48);
            v50 = sub_100021770(v46);
            v51 = (void *)objc_claimAutoreleasedReturnValue(v50);
            sub_100719AC8(v49, v51, (uint64_t)&v88, v47);
          }
        }
        sub_1003965C0(*((uint64_t *)&buf + 1), 10, src);
        v52 = sub_1000452EC((uint64_t)src);
        *(_QWORD *)src = &off_100918258;
        if (*(_QWORD *)&src[8])
          sub_100056AAC(*(unsigned int **)&src[8]);
        if (v52)
        {
          v53 = qword_100999818;
          if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_FAULT))
          {
            v54 = sub_100021770(a2);
            v55 = (void *)objc_claimAutoreleasedReturnValue(v54);
            sub_100719A64(v55, (uint64_t)&v85, v53);
          }
        }
        if (qword_1009778C8 != -1)
          dispatch_once(&qword_1009778C8, &stru_10093FA18);
        sub_10065AE9C((uint64_t)off_1009778C0, uu, a3);
        if (*(_BYTE *)(a1 + 41))
        {
          if (qword_1009778C8 != -1)
            dispatch_once(&qword_1009778C8, &stru_10093FA18);
          v56 = off_1009778C0;
          v57 = sub_100030DF4(uu);
          v58 = (void *)objc_claimAutoreleasedReturnValue(v57);
          sub_100091AE8(v71, "IsAppleWatch");
          if ((sub_10000628C((uint64_t)v56, v58, (uint64_t)v71) & 1) != 0)
          {
            v59 = 1;
          }
          else
          {
            if (qword_1009778C8 != -1)
              dispatch_once(&qword_1009778C8, &stru_10093FA18);
            v60 = off_1009778C0;
            v61 = sub_100030DF4(uu);
            v62 = (void *)objc_claimAutoreleasedReturnValue(v61);
            v59 = sub_100658AD4((uint64_t)v60, v62);

          }
          if (v72 < 0)
            operator delete(v71[0]);

          if (v59)
          {
            if (qword_1009778C8 != -1)
              dispatch_once(&qword_1009778C8, &stru_10093FA18);
            sub_10065ACB8((uint64_t)off_1009778C0, uu, a3);
            sub_1000419F4();
            operator new();
          }
          sub_1000419F4();
          operator new();
        }
      }
      *(_QWORD *)src = uu;
      v63 = sub_1006A7348((uint64_t **)(a1 + 440), uu, (uint64_t)&unk_100740F58, (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)src);
      sub_100041698((uint64_t)(v63 + 6), (uint64_t)&buf);
      sub_1006A77F0(v17, v69);
      sub_1000419F4();
      operator new();
    }
    operator new();
  }
  v14 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_INFO))
  {
    v15 = sub_100021770(a2);
    v16 = (void *)objc_claimAutoreleasedReturnValue(v15);
    *(_DWORD *)src = 138543362;
    *(_QWORD *)&src[4] = v16;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "Device \"%{public}@\" finished pairing but wasn't being tracked by device manager, ignoring this event", src, 0xCu);

  }
}

void sub_100698FD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,int a47,__int16 a48,char a49,char a50,char a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61)
{
  void *v61;
  void *v62;

  sub_100034234((uint64_t)&a51);
  _Unwind_Resume(a1);
}

uint64_t sub_10069939C(uint64_t a1, unsigned __int8 *a2)
{
  const unsigned __int8 *v3;
  void *v4;
  id v5;
  void *v6;
  size_t v7;
  uint64_t v8;
  int v9;
  unsigned __int8 *v10;
  uint64_t v11;
  int v12;
  int v13;
  BOOL v14;
  BOOL v15;
  void *v16;
  BOOL v17;
  unsigned __int8 *v18;
  const unsigned __int8 **v19;
  NSObject *v20;
  uint64_t v21;
  id v23;
  void *v24;
  void *__s1;
  size_t __n;
  unsigned __int8 v28;
  _QWORD v29[2];
  uuid_t dst;

  v29[0] = 0;
  v29[1] = 0;
  sub_10003415C((uint64_t)v29, a1 + 48);
  if (((char)a2[23] & 0x80000000) == 0)
  {
    if (a2[23])
      goto LABEL_3;
LABEL_38:
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_FAULT))
      sub_100719B44();
    goto LABEL_40;
  }
  if (!*((_QWORD *)a2 + 1))
    goto LABEL_38;
LABEL_3:
  v3 = *(const unsigned __int8 **)(a1 + 440);
  if (v3 == (const unsigned __int8 *)(a1 + 448))
  {
LABEL_35:
    v20 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
      sub_100719B70((char *)a2 + 23, a2, v20);
LABEL_40:
    v21 = 0;
    goto LABEL_41;
  }
  while (1)
  {
    memset(dst, 0, sizeof(dst));
    uuid_copy(dst, v3 + 32);
    if (qword_1009778C8 != -1)
      dispatch_once(&qword_1009778C8, &stru_10093FA18);
    v4 = off_1009778C0;
    v5 = sub_100030DF4(dst);
    v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
    sub_1006594CC((uint64_t)v4, v6, (uint64_t)&__s1);
    if ((v28 & 0x80u) == 0)
      v7 = v28;
    else
      v7 = __n;
    v8 = a2[23];
    v9 = (char)v8;
    if ((v8 & 0x80u) != 0)
      v8 = *((_QWORD *)a2 + 1);
    if (v7 != v8)
    {
      if ((v28 & 0x80) != 0)
        operator delete(__s1);

      goto LABEL_29;
    }
    if (v9 >= 0)
      v10 = a2;
    else
      v10 = *(unsigned __int8 **)a2;
    if ((v28 & 0x80) != 0)
    {
      v16 = __s1;
      v17 = memcmp(__s1, v10, __n) == 0;
      operator delete(v16);

      if (v17)
        goto LABEL_43;
      goto LABEL_29;
    }
    if (!v28)
      break;
    v11 = 0;
    do
    {
      v12 = *((unsigned __int8 *)&__s1 + v11);
      v13 = v10[v11];
      v14 = v12 != v13 || v28 - 1 == v11++;
    }
    while (!v14);
    v15 = v12 != v13;

    if (!v15)
      goto LABEL_43;
LABEL_29:
    v18 = (unsigned __int8 *)*((_QWORD *)v3 + 1);
    if (v18)
    {
      do
      {
        v19 = (const unsigned __int8 **)v18;
        v18 = *(unsigned __int8 **)v18;
      }
      while (v18);
    }
    else
    {
      do
      {
        v19 = (const unsigned __int8 **)*((_QWORD *)v3 + 2);
        v14 = *v19 == v3;
        v3 = (const unsigned __int8 *)v19;
      }
      while (!v14);
    }
    v3 = (const unsigned __int8 *)v19;
    if (v19 == (const unsigned __int8 **)(a1 + 448))
      goto LABEL_35;
  }

LABEL_43:
  v23 = sub_100030DF4(dst);
  v24 = (void *)objc_claimAutoreleasedReturnValue(v23);
  sub_100699674(a1, v24);

  v21 = 1;
LABEL_41:
  sub_100034234((uint64_t)v29);
  return v21;
}

void sub_100699638(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  void *v6;
  va_list va;

  va_start(va, a6);

  sub_100034234((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_100699674(uint64_t a1, void *a2)
{
  id v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  unsigned int *v9;
  _BOOL8 v10;
  void *v11;
  id v12;
  unsigned int v13;
  NSObject *v14;
  _BOOL4 v15;
  uint64_t v16;
  uint64_t *v17;
  unsigned int *v18;
  uint64_t v19;
  int v20;
  NSObject *v21;
  uint64_t v22;
  void *v23;
  int v24;
  int v25;
  NSObject *v26;
  id v27;
  void *v28;
  void *v29;
  int v30;
  NSObject *v31;
  int v32;
  unint64_t v33;
  uint64_t v34;
  void *v35[2];
  char v36;
  void *__p[2];
  char v38;
  int v39;
  __int16 v40;
  char v41;
  _QWORD v42[2];
  _BYTE buf[18];

  v3 = a2;
  if (sub_100030864(a1, v3))
  {
    v4 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138543362;
      *(_QWORD *)&buf[4] = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Unpairing device \"%{public}@\"", buf, 0xCu);
    }
    v42[0] = 0;
    v42[1] = 0;
    sub_10003415C((uint64_t)v42, a1 + 48);
    if (qword_1009778C8 != -1)
      dispatch_once(&qword_1009778C8, &stru_10093FA18);
    v5 = sub_1000589DC((uint64_t)off_1009778C0, v3, 0);
    v6 = sub_1000746A4(v5);
    v39 = v6;
    v41 = BYTE6(v6);
    v40 = WORD2(v6);
    if (sub_100699F80(a1, v3))
    {
      sub_100030BCC(buf, v3);
      v7 = sub_10000C5B8(a1 + 440, buf);
      v8 = (uint64_t *)v7;
      v9 = *(unsigned int **)(v7 + 56);
      if (v9)
        sub_10003C37C(*(_QWORD *)(v7 + 56));
      if (*(_BYTE *)(a1 + 41))
      {
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = 0;
        sub_1003965C0((uint64_t)v9, 10, buf);
        v10 = sub_1000452EC((uint64_t)buf);
        if (!v10)
        {
          sub_1000419F4();
          operator new();
        }
        sub_10069AC78(v10, (unsigned __int8 *)&v39);
        *(_QWORD *)buf = &off_100918258;
        if (*(_QWORD *)&buf[8])
          sub_100056AAC(*(unsigned int **)&buf[8]);
      }
      sub_1006A77F0((uint64_t **)(a1 + 440), v8);
      if (v9)
        sub_100056AAC(v9);
    }
    if (qword_1009778C8 != -1)
      dispatch_once(&qword_1009778C8, &stru_10093FA18);
    v11 = off_1009778C0;
    sub_100030BCC(buf, v3);
    if (sub_10065A530((uint64_t)v11, buf, v5))
    {
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
      {
        v12 = sub_100021770(v5);
        objc_claimAutoreleasedReturnValue(v12);
        sub_100719BE8();
      }
    }
    else
    {
      v19 = sub_10003BE44();
      v20 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v19 + 352))(v19);
      sub_1002FD0B8(v5, 0, v20);
      v21 = qword_100999818;
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
      {
        v22 = *(_QWORD *)(a1 + 456);
        *(_DWORD *)buf = 134217984;
        *(_QWORD *)&buf[4] = v22;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Number of LE Paired devices:%lu", buf, 0xCu);
      }
    }
    if (qword_1009778C8 != -1)
      dispatch_once(&qword_1009778C8, &stru_10093FA18);
    v23 = off_1009778C0;
    sub_100091AE8(__p, "_CTKD_");
    v24 = sub_10000628C((uint64_t)v23, v3, (uint64_t)__p);
    v25 = v24;
    if (v38 < 0)
    {
      operator delete(__p[0]);
      if (v25)
        goto LABEL_37;
    }
    else if (v24)
    {
LABEL_37:
      v26 = qword_100999818;
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Removing _CTKD_ Tag", buf, 2u);
      }
      if (qword_1009778C8 != -1)
        dispatch_once(&qword_1009778C8, &stru_10093FA18);
      sub_100653B18((uint64_t)off_1009778C0, v3, CFSTR("_CTKD_"));
      if (qword_100978150 != -1)
        dispatch_once(&qword_100978150, &stru_10093FA58);
      sub_1005B8674(off_100978148, v5);
      goto LABEL_64;
    }
    if (_os_feature_enabled_impl("DeviceAccess", "AccessorySetupKit"))
    {
      if (qword_1009778C8 != -1)
        dispatch_once(&qword_1009778C8, &stru_10093FA18);
      v27 = sub_1006591DC((uint64_t)off_1009778C0, v3, CFSTR("ASK_LINKED_RADIO_ADDRESS"));
      v28 = (void *)objc_claimAutoreleasedReturnValue(v27);
      if (qword_1009778C8 != -1)
        dispatch_once(&qword_1009778C8, &stru_10093FA18);
      v29 = off_1009778C0;
      sub_100091AE8(v35, "DA_ASK_RETAIN_DEVICE");
      v30 = sub_10000628C((uint64_t)v29, v3, (uint64_t)v35);
      if (v36 < 0)
        operator delete(v35[0]);
      v31 = qword_100999818;
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412546;
        *(_QWORD *)&buf[4] = v28;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v30;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "ASKLinkedRadioAddressString:%@ hasTag:%d", buf, 0x12u);
      }
      if (v28)
        v32 = v30;
      else
        v32 = 0;
      if (v32 == 1)
      {
        v33 = sub_100649C7C(v28);
        if (qword_100978150 != -1)
          dispatch_once(&qword_100978150, &stru_10093FA58);
        sub_1005B8674(off_100978148, v33);
        if (qword_1009778C8 != -1)
          dispatch_once(&qword_1009778C8, &stru_10093FA18);
        sub_1006592E8((uint64_t)off_1009778C0, v3, CFSTR("ASK_LINKED_RADIO_ADDRESS"), 0);
      }

    }
LABEL_64:
    if (qword_1009778F8 != -1)
      dispatch_once(&qword_1009778F8, &stru_10093FA78);
    v34 = qword_1009778F0;
    sub_100030BCC(buf, v3);
    sub_1005E3DAC(v34, a1 + 8, buf);
  }
  v13 = objc_msgSend(*(id *)(a1 + 3752), "containsObject:", v3);
  v14 = qword_100999818;
  v15 = os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT);
  if (v13)
  {
    if (v15)
    {
      *(_DWORD *)buf = 138543362;
      *(_QWORD *)&buf[4] = v3;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Device \"%{public}@\" is still in the process of unpairing, ignore this request, wait for BMS to complete or a disconnection", buf, 0xCu);
    }
  }
  else
  {
    if (v15)
    {
      *(_DWORD *)buf = 138543362;
      *(_QWORD *)&buf[4] = v3;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Device \"%{public}@\" isn't paired", buf, 0xCu);
    }
    sub_100693474(a1, v3, 0);
    sub_100030BCC(buf, v3);
    v16 = sub_10000C5B8(a1 + 440, buf);
    v17 = (uint64_t *)v16;
    if (a1 + 448 != v16)
    {
      v18 = *(unsigned int **)(v16 + 56);
      if (v18)
        sub_10003C37C(*(_QWORD *)(v16 + 56));
      sub_1006A77F0((uint64_t **)(a1 + 440), v17);
      if (v18)
        sub_100056AAC(v18);
    }
  }

}

void sub_100699DBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26)
{
  void *v26;

  _Unwind_Resume(a1);
}

uint64_t sub_100699EA0(uint64_t a1, void *a2)
{
  id v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v8;
  int v9;
  __int16 v10;
  char v11;

  v3 = a2;
  if (*(_BYTE *)(a1 + 41))
  {
    if (qword_1009778C8 != -1)
      dispatch_once(&qword_1009778C8, &stru_10093FA18);
    v4 = sub_1000589DC((uint64_t)off_1009778C0, v3, 0);
    v5 = sub_1000746A4(v4);
    v9 = v5;
    v11 = BYTE6(v5);
    v10 = WORD2(v5);
    v8 = 0;
    sub_100043758(&v8);
    v6 = sub_1002307DC(&v9);
    sub_100043728(&v8);
  }
  else
  {
    v6 = 0;
  }

  return v6;
}

void sub_100699F58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, __int16 a10, char a11, char a12)
{
  void *v12;

  sub_100043728(&a12);

  _Unwind_Resume(a1);
}

BOOL sub_100699F80(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  _BOOL8 v5;
  _QWORD v7[2];
  unsigned __int8 uu2[8];
  unsigned int *v9;

  v3 = a2;
  v7[0] = 0;
  v7[1] = 0;
  sub_10003415C((uint64_t)v7, a1 + 48);
  sub_100030BCC(uu2, v3);
  v4 = sub_10000C5B8(a1 + 440, uu2);
  if (a1 + 448 == v4)
  {
    v5 = 0;
  }
  else
  {
    *(_QWORD *)uu2 = 0;
    v9 = 0;
    sub_1003965C0(*(_QWORD *)(v4 + 56), 17, uu2);
    v5 = sub_1000452EC((uint64_t)uu2);
    *(_QWORD *)uu2 = &off_100918258;
    if (v9)
      sub_100056AAC(v9);
  }
  sub_100034234((uint64_t)v7);

  return v5;
}

void sub_10069A05C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t (**a12)(), unsigned int *a13)
{
  void *v13;

  a12 = &off_100918258;
  if (a13)
    sub_100056AAC(a13);
  sub_100034234((uint64_t)&a10);

  _Unwind_Resume(a1);
}

id sub_10069A0A8(uint64_t a1)
{
  void *v2;
  const unsigned __int8 *v3;
  id v4;
  void *v5;
  void *v6;
  id v7;
  void *v8;
  id v9;
  unsigned __int8 *v10;
  const unsigned __int8 **v11;
  BOOL v12;
  _QWORD v14[2];

  v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](NSMutableArray, "array"));
  v14[0] = 0;
  v14[1] = 0;
  sub_10003415C((uint64_t)v14, a1 + 48);
  v3 = *(const unsigned __int8 **)(a1 + 440);
  if (v3 != (const unsigned __int8 *)(a1 + 448))
  {
    do
    {
      v4 = sub_100030DF4(v3 + 32);
      v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
      if (sub_100030864(a1, v5))
      {
        if (qword_1009778C8 != -1)
          dispatch_once(&qword_1009778C8, &stru_10093FA18);
        v6 = off_1009778C0;
        v7 = sub_100030DF4(v3 + 32);
        v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
        LODWORD(v6) = sub_100659668((uint64_t)v6, v8);

        if (!(_DWORD)v6)
          goto LABEL_8;
        v9 = sub_100030DF4(v3 + 32);
        v5 = (void *)objc_claimAutoreleasedReturnValue(v9);
        objc_msgSend(v2, "addObject:", v5);
      }

LABEL_8:
      v10 = (unsigned __int8 *)*((_QWORD *)v3 + 1);
      if (v10)
      {
        do
        {
          v11 = (const unsigned __int8 **)v10;
          v10 = *(unsigned __int8 **)v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          v11 = (const unsigned __int8 **)*((_QWORD *)v3 + 2);
          v12 = *v11 == v3;
          v3 = (const unsigned __int8 *)v11;
        }
        while (!v12);
      }
      v3 = (const unsigned __int8 *)v11;
    }
    while (v11 != (const unsigned __int8 **)(a1 + 448));
  }
  sub_100034234((uint64_t)v14);
  return v2;
}

void sub_10069A208(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_10069A244(uint64_t a1, void *a2)
{
  id v3;
  NSObject *v4;
  unint64_t v5;
  _QWORD v6[2];
  uint8_t buf[4];
  id v8;

  v3 = a2;
  v6[0] = 0;
  v6[1] = 0;
  sub_10003415C((uint64_t)v6, a1 + 48);
  v4 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138543362;
    v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Device \"%{public}@\" is tagged as a watch", buf, 0xCu);
  }
  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_10093FA18);
  v5 = sub_1000589DC((uint64_t)off_1009778C0, v3, 0);
  sub_10069A384(a1, v5, 0xAu);
  sub_100034234((uint64_t)v6);

}

void sub_10069A35C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t sub_10069A384(uint64_t a1, unint64_t a2, unsigned int a3)
{
  NSObject *v5;
  id v6;
  void *v7;
  unsigned int v8;
  unsigned int v9;
  NSObject *v10;
  id v11;
  int v12;
  NSObject *v13;
  id v14;
  void *v15;
  NSObject *v16;
  NSObject *v17;
  uint8_t v19[16];
  uint64_t v20;
  uint64_t v21;
  const void *v22;
  const UInt8 *v23;
  _QWORD v24[2];
  uint8_t buf[8];
  _BYTE v26[12];
  _QWORD v27[2];

  v24[0] = 0;
  v24[1] = 0;
  sub_10003415C((uint64_t)v24, a1 + 48);
  v5 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    v6 = sub_100021770(a2);
    v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
    *(_DWORD *)buf = 67109378;
    *(_DWORD *)&buf[4] = a3;
    *(_WORD *)v26 = 2114;
    *(_QWORD *)&v26[2] = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Adding keys %d to synced keychain for device \"%{public}@\" tagged as a watch", buf, 0x12u);

  }
  v22 = 0;
  v23 = 0;
  v21 = 0;
  v8 = a3 - 1;
  if (a3 - 1 < 0x10 && ((0x81EFu >> v8) & 1) != 0)
  {
    v9 = dword_100743628[v8];
  }
  else if ((a3 & 0xFFFFFFFE) == 0xE)
  {
    v9 = 4;
  }
  else
  {
    v9 = 16;
  }
  v20 = 0;
  v10 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "addKeyToSyncedKeychainForDevice is calling BTKCCopyLEData", buf, 2u);
  }
  v27[0] = 0;
  v27[1] = 0;
  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_10093FA18);
  sub_10003F924((uint64_t)off_1009778C0, a2, 0, 1u, 0, 0, (unsigned __int8 *)v27);
  v11 = sub_100030DF4((const unsigned __int8 *)v27);

  sub_1002FCF04(a2, a3, (uint64_t)&v23, (_DWORD *)&v21 + 1, (_DWORD *)&v20 + 1, (uint64_t)&v22, &v21, &v20);
  v12 = HIDWORD(v21);
  if (!HIDWORD(v20) && HIDWORD(v21))
  {
    v13 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109632;
      *(_DWORD *)&buf[4] = v20;
      *(_WORD *)v26 = 1024;
      *(_DWORD *)&v26[2] = v12;
      *(_WORD *)&v26[6] = 1024;
      *(_DWORD *)&v26[8] = v21;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Found key in local Keychain syncedStatus=%d localLen=%d syncedLen=%d", buf, 0x14u);
      v12 = HIDWORD(v21);
    }
    if (v12 == v9)
    {
      if ((_DWORD)v20 || memcmp(v23, v22, v9))
      {
        *(_QWORD *)buf = 0;
        *(_QWORD *)v26 = 0;
        if (qword_1009778C8 != -1)
          dispatch_once(&qword_1009778C8, &stru_10093FA18);
        sub_10003F924((uint64_t)off_1009778C0, a2, 0, 1u, 0, 0, buf);
        v14 = sub_100030DF4(buf);
        v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
        sub_1002FCB48(a2, v15, a3, v23, HIDWORD(v21), 1);

        v16 = qword_100999818;
        if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)v19 = 0;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Added Key to synced keychain", v19, 2u);
        }
      }
    }
    else
    {
      v17 = qword_100999818;
      if (!os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_FAULT))
        goto LABEL_26;
      *(_DWORD *)buf = 67109632;
      *(_DWORD *)&buf[4] = a3;
      *(_WORD *)v26 = 1024;
      *(_DWORD *)&v26[2] = v9;
      *(_WORD *)&v26[6] = 1024;
      *(_DWORD *)&v26[8] = v12;
      _os_log_fault_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_FAULT, "Ignoring data of invalid length for key type %d - expected %d byte(s), read %d byte(s)", buf, 0x14u);
    }
    v12 = HIDWORD(v21);
  }
LABEL_26:
  if (v12 && v23)
    operator delete[]();
  if ((_DWORD)v21 && v22)
    operator delete[]();
  return sub_100034234((uint64_t)v24);
}

void sub_10069A780(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  void *v9;
  va_list va;

  va_start(va, a9);

  sub_100034234((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_10069A7B4(uint64_t a1, void *a2)
{
  id v3;
  NSObject *v4;
  uint64_t v5;
  _QWORD v6[2];
  uint8_t buf[4];
  id v8;

  v3 = a2;
  v6[0] = 0;
  v6[1] = 0;
  sub_10003415C((uint64_t)v6, a1 + 48);
  v4 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138543362;
    v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Device \"%{public}@\" is untagged as a watch", buf, 0xCu);
  }
  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_10093FA18);
  v5 = sub_1000589DC((uint64_t)off_1009778C0, v3, 0);
  sub_10069A8F4(a1, v5, 0xAu);
  sub_100034234((uint64_t)v6);

}

void sub_10069A8CC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t sub_10069A8F4(uint64_t a1, uint64_t a2, unsigned int a3)
{
  NSObject *v6;
  id v7;
  void *v8;
  id v9;
  NSObject *v10;
  id v11;
  void *v12;
  NSObject *v13;
  id v14;
  void *v15;
  BOOL v16;
  uint8_t v18[4];
  uint64_t v19;
  const UInt8 *v20;
  _QWORD v21[2];
  uint8_t buf[8];
  _QWORD v23[2];

  v21[0] = 0;
  v21[1] = 0;
  sub_10003415C((uint64_t)v21, a1 + 48);
  v6 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_INFO))
  {
    v7 = sub_100021770(a2);
    v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
    *(_DWORD *)buf = 67109378;
    *(_DWORD *)&buf[4] = a3;
    LOWORD(v23[0]) = 2114;
    *(_QWORD *)((char *)v23 + 2) = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "removing keys %d from synced keychain for device \"%{public}@\" tagged as a watch", buf, 0x12u);

    v6 = qword_100999818;
  }
  v19 = 0;
  v20 = 0;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "removeKeyFromSyncedKeychainForDevice is calling BTKCCopyLEData", buf, 2u);
  }
  *(_QWORD *)buf = 0;
  v23[0] = 0;
  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_10093FA18);
  sub_10003F924(buf, off_1009778C0, a2, 0, 1, 0, 0);
  v9 = sub_100030DF4(buf);

  sub_1002FCF04(a2, a3, 0, 0, 0, (uint64_t)&v20, (_DWORD *)&v19 + 1, &v19);
  if (!(_DWORD)v19 && HIDWORD(v19))
  {
    v10 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v18 = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Found key", v18, 2u);
    }
    v11 = sub_100030DF4(buf);
    v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
    sub_1002FCB48(a2, v12, a3, v20, 0, 1);

    v13 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v18 = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Moved Key", v18, 2u);
    }
    v14 = sub_100030DF4(buf);
    v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
    v16 = sub_100030864(a1, v15);

    if (!v16)
    {
      if (a3 == 10 && *(_BYTE *)(a1 + 41))
      {
        sub_1000419F4();
        operator new();
      }
      sub_1002FD0B8(a2, 0, 1);
    }
    if (v20)
      operator delete[]();
  }
  return sub_100034234((uint64_t)v21);
}

void sub_10069AC38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  sub_100034234((uint64_t)va);
  _Unwind_Resume(a1);
}

BOOL sub_10069AC78(uint64_t a1, unsigned __int8 *a2)
{
  unint64_t v3;
  NSObject *v4;
  void **v5;
  int v6;
  NSObject *v7;
  void **v8;
  char v10;
  void *__p[2];
  char v12;
  uint8_t buf[4];
  void **v14;

  v3 = ((unint64_t)a2[1] << 40) | ((unint64_t)a2[2] << 32) | ((unint64_t)a2[3] << 24) | ((unint64_t)a2[4] << 16) | ((unint64_t)a2[5] << 8) | a2[6] | ((unint64_t)*a2 << 48);
  v4 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    sub_1000217F4(v3);
    v5 = v12 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)buf = 136446210;
    v14 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Removing \"%{public}s\" from the cache.", buf, 0xCu);
    if (v12 < 0)
      operator delete(__p[0]);
  }
  v10 = 0;
  sub_100043758(&v10);
  v6 = sub_10022E354(a2);
  sub_10004339C(&v10);
  v7 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    sub_1000217F4(v3);
    if (v12 >= 0)
      v8 = __p;
    else
      v8 = (void **)__p[0];
    *(_DWORD *)buf = 136446210;
    v14 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Removed \"%{public}s\" from the cache.", buf, 0xCu);
    if (v12 < 0)
      operator delete(__p[0]);
  }
  sub_100043728(&v10);
  return v6 == 0;
}

void sub_10069AE3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, __int16 a10, char a11, char a12)
{
  sub_100043728(&a12);
  _Unwind_Resume(a1);
}

_BYTE *sub_10069AE5C(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  uint64_t v4;
  int v5;
  NSObject *v6;
  int v8;
  int v9;
  __int16 v10;
  int v11;

  v3 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    v8 = 67109120;
    v9 = a2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "setPrivateModeEnabled %d", (uint8_t *)&v8, 8u);
  }
  v4 = sub_1000438A4();
  v5 = (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v4 + 1832))(v4, a2);
  v6 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    v8 = 67109376;
    v9 = a2;
    v10 = 1024;
    v11 = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "enable2MBPHYForDenylistedDevices %d returned %d", (uint8_t *)&v8, 0xEu);
  }
  LOBYTE(v8) = 0;
  sub_100043758(&v8);
  sub_100224440(a2);
  sub_10004339C(&v8);
  return sub_100043728(&v8);
}

void sub_10069AF94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  sub_100043728(&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_10069AFB0(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 40) + 8))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 32));
}

void sub_10069AFC4(uint64_t a1)
{
  if (qword_1009778F8 != -1)
    dispatch_once(&qword_1009778F8, &stru_10093FA78);
  sub_1005DCD50(qword_1009778F0, *(void **)(a1 + 32));
}

void sub_10069B014(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (!*(_WORD *)(a1 + 594) || *(_BYTE *)(a1 + 596))
  {
    *(_WORD *)(a1 + 594) = a2;
    sub_10069AE5C(a1, 1);
    sub_1000419F4();
    operator new();
  }
  v4 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
    sub_100719C28(a2, v4, v5, v6, v7, v8, v9, v10);
  *(_BYTE *)(a1 + 596) = 1;
  *(_WORD *)(a1 + 594) = a2;
}

void sub_10069B0FC(id a1)
{
  if (qword_1009778A8 != -1)
    dispatch_once(&qword_1009778A8, &stru_10093FA38);
  sub_100636F00((uint64_t)off_1009778A0, 1);
}

void sub_10069B140(uint64_t a1)
{
  int v2;
  NSObject *v3;
  _BOOL4 v4;
  NSObject *v5;
  id v6;
  void *v7;
  id v8;
  uint64_t v9;
  void *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint8_t buf[16];
  _BYTE v19[128];

  if (*(_WORD *)(a1 + 594))
  {
    v2 = *(unsigned __int8 *)(a1 + 596);
    v3 = qword_100999818;
    v4 = os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT);
    if (v2)
    {
      if (v4)
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Renew private mode.", buf, 2u);
      }
      sub_1000419F4();
      operator new();
    }
    if (v4)
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Disable private mode.", buf, 2u);
    }
    *(_WORD *)(a1 + 594) = 0;
    v14 = 0u;
    v15 = 0u;
    v16 = 0u;
    v17 = 0u;
    if (qword_1009778B8 != -1)
      dispatch_once(&qword_1009778B8, &stru_10093F9D8);
    v6 = sub_10006A768(qword_1009778B0);
    v7 = (void *)objc_claimAutoreleasedReturnValue(v6);
    v8 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v14, v19, 16);
    if (v8)
    {
      v9 = *(_QWORD *)v15;
      do
      {
        v10 = 0;
        do
        {
          if (*(_QWORD *)v15 != v9)
            objc_enumerationMutation(v7);
          v11 = *(void **)(*((_QWORD *)&v14 + 1) + 8 * (_QWORD)v10);
          if (qword_1009778C8 != -1)
            dispatch_once(&qword_1009778C8, &stru_10093FA18);
          sub_100653B18((uint64_t)off_1009778C0, v11, CFSTR("PrivateModeDevice"));
          v10 = (char *)v10 + 1;
        }
        while (v8 != v10);
        v8 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v14, v19, 16);
      }
      while (v8);
    }

    sub_10069AE5C(v12, 0);
    v13 = sub_1000419F4();
    sub_100041A34(v13, &stru_10093F858);
  }
  else
  {
    v5 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Private mode has already been disabled. Nothing more to do here", buf, 2u);
    }
  }
}

void sub_10069B3F4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_10069B414(id a1)
{
  if (qword_1009778A8 != -1)
    dispatch_once(&qword_1009778A8, &stru_10093FA38);
  sub_100636F00((uint64_t)off_1009778A0, 0);
}

void sub_10069B458(uint64_t a1, void *a2)
{
  id v3;

  v3 = a2;
  objc_msgSend(*(id *)(a1 + 3752), "removeObject:");
  sub_100693474(a1, v3, 1);

}

void sub_10069B4A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_10069B4B8(uint64_t a1, void *a2)
{
  sub_10069B458(a1 - 8, a2);
}

uint64_t sub_10069B4C0(uint64_t a1, unint64_t a2, uint64_t a3, unsigned int **a4, int a5)
{
  NSObject *v9;
  _BYTE *v10;
  char *v11;
  id v12;
  unsigned int *v13;
  unsigned int *v14;
  const char *v15;
  int v16;
  NSObject *v17;
  _BYTE *v18;
  uint64_t v19;
  uint64_t v21;
  const void *v22;
  CFTypeRef cf;
  _QWORD v24[2];
  _BYTE buf[12];
  __int16 v26;
  char *v27;
  char v28;
  _BYTE __p[22];
  __int16 v30;
  int v31;
  __int16 v32;
  int v33;
  __int16 v34;
  int v35;
  _QWORD v36[2];

  v24[0] = 0;
  v24[1] = 0;
  sub_10003415C((uint64_t)v24, a1 + 48);
  v9 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_INFO))
  {
    sub_10064960C(a2);
    v10 = v30 >= 0 ? __p : *(_BYTE **)__p;
    v11 = a5 ? "YES" : "NO";
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = v10;
    v26 = 2082;
    v27 = v11;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "readKeyForDevice address:%{public}s syncedKeychain:%{public}s", buf, 0x16u);
    if (SHIBYTE(v30) < 0)
      operator delete(*(void **)__p);
  }
  v22 = 0;
  cf = 0;
  v21 = 0;
  v36[0] = 0;
  v36[1] = 0;
  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_10093FA18);
  sub_10003F924((uint64_t)off_1009778C0, a2, 0, 1u, 0, 0, (unsigned __int8 *)v36);
  v12 = sub_100030DF4((const unsigned __int8 *)v36);

  v13 = *a4;
  v14 = a4[1];
  if (*a4 != v14)
  {
    if (a5)
      v15 = "YES";
    else
      v15 = "NO";
    do
    {
      v16 = *v13;
      sub_1002FCEA8(a2, *v13, (uint64_t)&v22, (_DWORD *)&v21 + 1, &v21, a5, (const __CFDictionary **)&cf);
      v17 = qword_100999818;
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_INFO))
      {
        sub_10064960C(a2);
        v18 = buf;
        if (v28 < 0)
          v18 = *(_BYTE **)buf;
        *(_DWORD *)__p = 136447234;
        *(_QWORD *)&__p[4] = v18;
        *(_WORD *)&__p[12] = 2082;
        *(_QWORD *)&__p[14] = v15;
        v30 = 1024;
        v31 = v16;
        v32 = 1024;
        v33 = v21;
        v34 = 1024;
        v35 = HIDWORD(v21);
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_INFO, "readKeyForDevice BTKCCopyLEDataEx address:%{public}s synced:%{public}s type:%d status:%d dataLen:%d", __p, 0x28u);
        if (v28 < 0)
          operator delete(*(void **)buf);
      }
      if (!(_DWORD)v21 && HIDWORD(v21))
      {
        v19 = *(_QWORD *)(a3 + 8);
        sub_10003994C(__p, v22, HIDWORD(v21));
        sub_100395D48(v19, v16, (uint64_t)__p);
        *(_QWORD *)__p = &off_100918258;
        if (*(_QWORD *)&__p[8])
          sub_100056AAC(*(unsigned int **)&__p[8]);
        if (v22)
          operator delete[]();
      }
      ++v13;
    }
    while (v13 != v14);
    if (cf)
      CFRelease(cf);
  }
  return sub_100034234((uint64_t)v24);
}

void sub_10069B7C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  sub_100034234((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_10069B818(uint64_t a1, unint64_t a2, uint64_t a3, unsigned int a4, int a5)
{
  signed int v10;
  unsigned int v11;
  id v12;
  NSObject *v13;
  void *p_p;
  const char *v15;
  unsigned int v16;
  NSObject *v17;
  uint64_t v18;
  size_t v19;
  int v20;
  unsigned int v21;
  NSObject *v22;
  uint64_t v23;
  id v24;
  void *v25;
  _BOOL4 v26;
  NSObject *v27;
  id v28;
  void *v29;
  NSObject *v30;
  id v31;
  void *__p;
  char v34;
  uint64_t v35;
  uint64_t v36;
  const void *v37;
  const void *v38;
  _QWORD v39[2];
  _BYTE buf[22];
  __int16 v41;
  unsigned int v42;
  __int16 v43;
  int v44;
  __int16 v45;
  int v46;
  __int16 v47;
  int v48;
  __int16 v49;
  int v50;
  _QWORD v51[2];

  v39[0] = 0;
  v39[1] = 0;
  sub_10003415C((uint64_t)v39, a1 + 48);
  v37 = 0;
  v38 = 0;
  v36 = 0;
  v10 = a4 - 1;
  if (a4 - 1 < 0x10 && ((0x81EFu >> v10) & 1) != 0)
  {
    v11 = dword_100743628[v10];
  }
  else if ((a4 & 0xFFFFFFFE) == 0xE)
  {
    v11 = 4;
  }
  else
  {
    v11 = 16;
  }
  v35 = 0;
  v51[0] = 0;
  v51[1] = 0;
  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_10093FA18);
  sub_10003F924((uint64_t)off_1009778C0, a2, 0, 1u, 0, 0, (unsigned __int8 *)v51);
  v12 = sub_100030DF4((const unsigned __int8 *)v51);

  sub_1002FCF04(a2, a4, (uint64_t)&v38, (_DWORD *)&v36 + 1, (_DWORD *)&v35 + 1, (uint64_t)&v37, &v36, &v35);
  v13 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_INFO))
  {
    sub_10064960C(a2);
    p_p = __p;
    v15 = "NO";
    if (v34 >= 0)
      p_p = &__p;
    if (a5)
      v15 = "YES";
    *(_DWORD *)buf = 136447746;
    *(_QWORD *)&buf[4] = p_p;
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v15;
    v41 = 1024;
    v42 = a4;
    v43 = 1024;
    v44 = HIDWORD(v36);
    v45 = 1024;
    v46 = HIDWORD(v35);
    v47 = 1024;
    v48 = v36;
    v49 = 1024;
    v50 = v35;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_INFO, "readKeyForDevice BTKCCopyLEData address:%{public}s syncedKeychain:%{public}s type:%d localLen:%d localStatus:%d syncedLen:%d, SynedStatus:%d", buf, 0x34u);
    if (v34 < 0)
      operator delete(__p);
  }
  if (!HIDWORD(v35))
  {
    v16 = HIDWORD(v36);
    if (HIDWORD(v36))
    {
      if (HIDWORD(v36) != v11)
      {
        v17 = qword_100999818;
        if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 67109632;
          *(_DWORD *)&buf[4] = a4;
          *(_WORD *)&buf[8] = 1024;
          *(_DWORD *)&buf[10] = v11;
          *(_WORD *)&buf[14] = 1024;
          *(_DWORD *)&buf[16] = v16;
          _os_log_fault_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_FAULT, "Ignoring data of invalid length for key type %d - expected %d byte(s), read %d byte(s)", buf, 0x14u);
          v11 = HIDWORD(v36);
        }
        else
        {
          v11 = v16;
        }
      }
      v18 = *(_QWORD *)(a3 + 8);
      sub_10003994C(buf, v38, v11);
      sub_100395D48(v18, a4, (uint64_t)buf);
      *(_QWORD *)buf = &off_100918258;
      if (*(_QWORD *)&buf[8])
        sub_100056AAC(*(unsigned int **)&buf[8]);
      if ((_DWORD)v35 || !(_DWORD)v36)
      {
        if (!(_DWORD)v35 || !a5)
          goto LABEL_49;
      }
      else
      {
        if (HIDWORD(v36) >= v36)
          v19 = v36;
        else
          v19 = HIDWORD(v36);
        if (!memcmp(v38, v37, v19) || (a5 & 1) == 0)
          goto LABEL_49;
      }
      v30 = qword_100999818;
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "storing synced data with the local values", buf, 2u);
      }
      v31 = sub_100030DF4((const unsigned __int8 *)v51);
      v29 = (void *)objc_claimAutoreleasedReturnValue(v31);
      sub_10069BDC8(a1, a2, v29, a3, a4, 1);
LABEL_48:

LABEL_49:
      v20 = v35;
      goto LABEL_50;
    }
  }
  v20 = v35;
  if (!(_DWORD)v35)
  {
    v21 = v36;
    if ((_DWORD)v36)
    {
      if ((_DWORD)v36 != v11)
      {
        v22 = qword_100999818;
        if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 67109632;
          *(_DWORD *)&buf[4] = a4;
          *(_WORD *)&buf[8] = 1024;
          *(_DWORD *)&buf[10] = v11;
          *(_WORD *)&buf[14] = 1024;
          *(_DWORD *)&buf[16] = v21;
          _os_log_fault_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_FAULT, "Ignoring data of invalid length for key type %d - expected %d byte(s), read %d byte(s)", buf, 0x14u);
          v11 = v36;
        }
        else
        {
          v11 = v21;
        }
      }
      v23 = *(_QWORD *)(a3 + 8);
      sub_10003994C(buf, v37, v11);
      sub_100395D48(v23, a4, (uint64_t)buf);
      *(_QWORD *)buf = &off_100918258;
      if (*(_QWORD *)&buf[8])
        sub_100056AAC(*(unsigned int **)&buf[8]);
      if ((a5 & 1) != 0)
        goto LABEL_49;
      v24 = sub_100030DF4((const unsigned __int8 *)v51);
      v25 = (void *)objc_claimAutoreleasedReturnValue(v24);
      v26 = sub_100030864(a1, v25);

      if (!v26)
        goto LABEL_49;
      v27 = qword_100999818;
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "writing local data with the synced values", buf, 2u);
      }
      v28 = sub_100030DF4((const unsigned __int8 *)v51);
      v29 = (void *)objc_claimAutoreleasedReturnValue(v28);
      sub_10069BDC8(a1, a2, v29, a3, a4, 0);
      goto LABEL_48;
    }
  }
LABEL_50:
  if (!v20 && v37)
    operator delete[]();
  if (!HIDWORD(v35) && v38)
    operator delete[]();
  return sub_100034234((uint64_t)v39);
}

void sub_10069BD54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  void *v9;
  va_list va;

  va_start(va, a9);

  sub_100034234((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_10069BDC8(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, unsigned int a5, int a6)
{
  id v11;
  NSObject *v12;
  const UInt8 *v13;
  CFIndex v14;
  NSObject *v15;
  const UInt8 *v16;
  CFIndex v17;
  uint8_t v18[16];
  uint64_t (**v19)();
  unsigned int *v20;
  _QWORD v21[2];

  v11 = a3;
  v21[0] = 0;
  v21[1] = 0;
  sub_10003415C((uint64_t)v21, a1 + 48);
  v19 = 0;
  v20 = 0;
  sub_1003965C0(*(_QWORD *)(a4 + 8), a5, &v19);
  if (!sub_1000452EC((uint64_t)&v19))
  {
    v12 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v18 = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "writeKeyForDevice is calling BTKCSetLEData sync=0", v18, 2u);
    }
    v13 = (const UInt8 *)sub_10003EB18((uint64_t)&v19);
    v14 = sub_10003F8C4((uint64_t)&v19);
    sub_1002FCB48(a2, v11, a5, v13, v14, 0);
    if (a6)
    {
      v15 = qword_100999818;
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v18 = 0;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "writeKeyForDevice is calling BTKCSetLEData sync=1", v18, 2u);
      }
      v16 = (const UInt8 *)sub_10003EB18((uint64_t)&v19);
      v17 = sub_10003F8C4((uint64_t)&v19);
      sub_1002FCB48(a2, v11, a5, v16, v17, 1);
    }
  }
  v19 = &off_100918258;
  if (v20)
    sub_100056AAC(v20);
  sub_100034234((uint64_t)v21);

}

void sub_10069BF54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  void *v5;
  va_list va;

  va_start(va, a5);
  sub_100034234((uint64_t)va);

  _Unwind_Resume(a1);
}

void sub_10069BF94(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, unsigned int **a5, int a6)
{
  id v11;
  unsigned int *v12;
  unsigned int *v13;
  char v14;
  unsigned int v15;
  NSObject *v16;
  const UInt8 *v17;
  CFIndex v18;
  uint8_t buf[8];
  uint64_t (**v20)();
  unsigned int *v21;
  CFTypeRef cf;
  _QWORD v23[2];

  v11 = a3;
  v23[0] = 0;
  v23[1] = 0;
  sub_10003415C((uint64_t)v23, a1 + 48);
  cf = 0;
  v12 = *a5;
  v13 = a5[1];
  if (*a5 != v13)
  {
    v14 = 0;
    do
    {
      v15 = *v12;
      v20 = 0;
      v21 = 0;
      sub_1003965C0(*(_QWORD *)(a4 + 8), v15, &v20);
      if (!sub_1000452EC((uint64_t)&v20))
      {
        v16 = qword_100999818;
        if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "writeKeyForDevice is calling BTKCSetLEData sync=0", buf, 2u);
        }
        v17 = (const UInt8 *)sub_10003EB18((uint64_t)&v20);
        v18 = sub_10003F8C4((uint64_t)&v20);
        sub_1002FC720(a2, v11, v15, v17, v18, a6, &cf, 0);
        ++v14;
      }
      v20 = &off_100918258;
      if (v21)
        sub_100056AAC(v21);
      ++v12;
    }
    while (v12 != v13);
    if (v14)
      sub_1002FC5CC(a2, v11, a6, &cf);
    if (cf)
      CFRelease(cf);
  }
  sub_100034234((uint64_t)v23);

}

void sub_10069C118(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  void *v7;
  va_list va;

  va_start(va, a7);
  sub_100034234((uint64_t)va);

  _Unwind_Resume(a1);
}

void sub_10069C154(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  id v7;
  void *v8;
  int v9;
  NSObject *v10;
  id v11;
  id v12;
  uint64_t v13;
  _DWORD *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  _DWORD *v19;
  int v20;
  char *v21;
  char *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  char *v27;
  char *v28;
  int v29;
  char *v30;
  char *v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  unint64_t v35;
  char *v36;
  char *v37;
  int v38;
  char *v39;
  char *v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  char *v45;
  char *v46;
  int v47;
  char *v48;
  char *v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  unint64_t v53;
  char *v54;
  char *v55;
  int v56;
  char *v57;
  char *v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  unint64_t v62;
  char *v63;
  char *v64;
  int v65;
  char *v66;
  char *v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  unint64_t v71;
  char *v72;
  char *v73;
  int v74;
  char *v75;
  char *v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  unint64_t v80;
  char *v81;
  char *v82;
  int v83;
  char *v84;
  char *v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  unint64_t v89;
  char *v90;
  char *v91;
  int v92;
  char *v93;
  char *v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  unint64_t v98;
  char *v99;
  char *v100;
  int v101;
  char *v102;
  char *v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  unint64_t v107;
  char *v108;
  char *v109;
  int v110;
  char *v111;
  char *v112;
  uint64_t v113;
  unint64_t v114;
  uint64_t v115;
  unint64_t v116;
  char *v117;
  char *v118;
  int v119;
  char *v120;
  char *v121;
  uint64_t v122;
  unint64_t v123;
  uint64_t v124;
  unint64_t v125;
  char *v126;
  char *v127;
  int v128;
  char *v129;
  char *v130;
  uint64_t v131;
  unint64_t v132;
  uint64_t v133;
  unint64_t v134;
  char *v135;
  char *v136;
  int v137;
  _DWORD *v138;
  char *v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  unint64_t v143;
  char *v144;
  char *v145;
  char *v146;
  int v147;
  void *__p[2];
  char v149;
  _QWORD v150[2];
  uint8_t buf[24];

  v7 = a3;
  v150[0] = 0;
  v150[1] = 0;
  sub_10003415C((uint64_t)v150, a1 + 48);
  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_10093FA18);
  v8 = off_1009778C0;
  sub_100091AE8(__p, "IsAppleWatch");
  v9 = sub_10000628C((uint64_t)v8, v7, (uint64_t)__p);
  if (v149 < 0)
    operator delete(__p[0]);
  v10 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    v11 = sub_100021770(a2);
    v12 = (id)objc_claimAutoreleasedReturnValue(v11);
    *(_DWORD *)buf = 138543618;
    *(_QWORD *)&buf[4] = v12;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v9;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Writing keys to disk for device %{public}@ (isWatch=%d)", buf, 0x12u);

  }
  sub_10069BDC8(a1, a2, v7, a4, 0xAu, v9);
  memset(buf, 0, sizeof(buf));
  v14 = sub_1002B46E0((uint64_t)&buf[16], 1uLL);
  v15 = *(char **)buf;
  v16 = *(char **)&buf[8];
  v17 = (char *)&v14[v13];
  *v14 = 0;
  v18 = (char *)(v14 + 1);
  v19 = v14;
  while (v16 != v15)
  {
    v20 = *((_DWORD *)v16 - 1);
    v16 -= 4;
    *--v19 = v20;
  }
  *(_QWORD *)buf = v19;
  *(_QWORD *)&buf[8] = v14 + 1;
  *(_QWORD *)&buf[16] = &v14[v13];
  if (v15)
  {
    operator delete(v15);
    v17 = *(char **)&buf[16];
  }
  *(_QWORD *)&buf[8] = v14 + 1;
  if (v18 >= v17)
  {
    v22 = *(char **)buf;
    v23 = (uint64_t)&v18[-*(_QWORD *)buf] >> 2;
    v24 = v23 + 1;
    if ((unint64_t)(v23 + 1) >> 62)
      abort();
    v25 = (uint64_t)&v17[-*(_QWORD *)buf];
    if (v25 >> 1 > v24)
      v24 = v25 >> 1;
    if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFFCLL)
      v26 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v26 = v24;
    if (v26)
    {
      v27 = (char *)sub_1002B46E0((uint64_t)&buf[16], v26);
      v22 = *(char **)buf;
      v18 = *(char **)&buf[8];
    }
    else
    {
      v27 = 0;
    }
    v28 = &v27[4 * v23];
    v17 = &v27[4 * v26];
    *(_DWORD *)v28 = 1;
    v21 = v28 + 4;
    while (v18 != v22)
    {
      v29 = *((_DWORD *)v18 - 1);
      v18 -= 4;
      *((_DWORD *)v28 - 1) = v29;
      v28 -= 4;
    }
    *(_QWORD *)buf = v28;
    *(_QWORD *)&buf[8] = v21;
    *(_QWORD *)&buf[16] = v17;
    if (v22)
    {
      operator delete(v22);
      v17 = *(char **)&buf[16];
    }
  }
  else
  {
    v14[1] = 1;
    v21 = (char *)(v14 + 2);
  }
  *(_QWORD *)&buf[8] = v21;
  if (v21 >= v17)
  {
    v31 = *(char **)buf;
    v32 = (uint64_t)&v21[-*(_QWORD *)buf] >> 2;
    v33 = v32 + 1;
    if ((unint64_t)(v32 + 1) >> 62)
      abort();
    v34 = (uint64_t)&v17[-*(_QWORD *)buf];
    if (v34 >> 1 > v33)
      v33 = v34 >> 1;
    if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFFCLL)
      v35 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v35 = v33;
    if (v35)
    {
      v36 = (char *)sub_1002B46E0((uint64_t)&buf[16], v35);
      v31 = *(char **)buf;
      v21 = *(char **)&buf[8];
    }
    else
    {
      v36 = 0;
    }
    v37 = &v36[4 * v32];
    v17 = &v36[4 * v35];
    *(_DWORD *)v37 = 2;
    v30 = v37 + 4;
    while (v21 != v31)
    {
      v38 = *((_DWORD *)v21 - 1);
      v21 -= 4;
      *((_DWORD *)v37 - 1) = v38;
      v37 -= 4;
    }
    *(_QWORD *)buf = v37;
    *(_QWORD *)&buf[8] = v30;
    *(_QWORD *)&buf[16] = v17;
    if (v31)
    {
      operator delete(v31);
      v17 = *(char **)&buf[16];
    }
  }
  else
  {
    *(_DWORD *)v21 = 2;
    v30 = v21 + 4;
  }
  *(_QWORD *)&buf[8] = v30;
  if (v30 >= v17)
  {
    v40 = *(char **)buf;
    v41 = (uint64_t)&v30[-*(_QWORD *)buf] >> 2;
    v42 = v41 + 1;
    if ((unint64_t)(v41 + 1) >> 62)
      abort();
    v43 = (uint64_t)&v17[-*(_QWORD *)buf];
    if (v43 >> 1 > v42)
      v42 = v43 >> 1;
    if ((unint64_t)v43 >= 0x7FFFFFFFFFFFFFFCLL)
      v44 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v44 = v42;
    if (v44)
    {
      v45 = (char *)sub_1002B46E0((uint64_t)&buf[16], v44);
      v40 = *(char **)buf;
      v30 = *(char **)&buf[8];
    }
    else
    {
      v45 = 0;
    }
    v46 = &v45[4 * v41];
    v17 = &v45[4 * v44];
    *(_DWORD *)v46 = 3;
    v39 = v46 + 4;
    while (v30 != v40)
    {
      v47 = *((_DWORD *)v30 - 1);
      v30 -= 4;
      *((_DWORD *)v46 - 1) = v47;
      v46 -= 4;
    }
    *(_QWORD *)buf = v46;
    *(_QWORD *)&buf[8] = v39;
    *(_QWORD *)&buf[16] = v17;
    if (v40)
    {
      operator delete(v40);
      v17 = *(char **)&buf[16];
    }
  }
  else
  {
    *(_DWORD *)v30 = 3;
    v39 = v30 + 4;
  }
  *(_QWORD *)&buf[8] = v39;
  if (v39 >= v17)
  {
    v49 = *(char **)buf;
    v50 = (uint64_t)&v39[-*(_QWORD *)buf] >> 2;
    v51 = v50 + 1;
    if ((unint64_t)(v50 + 1) >> 62)
      abort();
    v52 = (uint64_t)&v17[-*(_QWORD *)buf];
    if (v52 >> 1 > v51)
      v51 = v52 >> 1;
    if ((unint64_t)v52 >= 0x7FFFFFFFFFFFFFFCLL)
      v53 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v53 = v51;
    if (v53)
    {
      v54 = (char *)sub_1002B46E0((uint64_t)&buf[16], v53);
      v49 = *(char **)buf;
      v39 = *(char **)&buf[8];
    }
    else
    {
      v54 = 0;
    }
    v55 = &v54[4 * v50];
    v17 = &v54[4 * v53];
    *(_DWORD *)v55 = 4;
    v48 = v55 + 4;
    while (v39 != v49)
    {
      v56 = *((_DWORD *)v39 - 1);
      v39 -= 4;
      *((_DWORD *)v55 - 1) = v56;
      v55 -= 4;
    }
    *(_QWORD *)buf = v55;
    *(_QWORD *)&buf[8] = v48;
    *(_QWORD *)&buf[16] = v17;
    if (v49)
    {
      operator delete(v49);
      v17 = *(char **)&buf[16];
    }
  }
  else
  {
    *(_DWORD *)v39 = 4;
    v48 = v39 + 4;
  }
  *(_QWORD *)&buf[8] = v48;
  if (v48 >= v17)
  {
    v58 = *(char **)buf;
    v59 = (uint64_t)&v48[-*(_QWORD *)buf] >> 2;
    v60 = v59 + 1;
    if ((unint64_t)(v59 + 1) >> 62)
      abort();
    v61 = (uint64_t)&v17[-*(_QWORD *)buf];
    if (v61 >> 1 > v60)
      v60 = v61 >> 1;
    if ((unint64_t)v61 >= 0x7FFFFFFFFFFFFFFCLL)
      v62 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v62 = v60;
    if (v62)
    {
      v63 = (char *)sub_1002B46E0((uint64_t)&buf[16], v62);
      v58 = *(char **)buf;
      v48 = *(char **)&buf[8];
    }
    else
    {
      v63 = 0;
    }
    v64 = &v63[4 * v59];
    v17 = &v63[4 * v62];
    *(_DWORD *)v64 = 12;
    v57 = v64 + 4;
    while (v48 != v58)
    {
      v65 = *((_DWORD *)v48 - 1);
      v48 -= 4;
      *((_DWORD *)v64 - 1) = v65;
      v64 -= 4;
    }
    *(_QWORD *)buf = v64;
    *(_QWORD *)&buf[8] = v57;
    *(_QWORD *)&buf[16] = v17;
    if (v58)
    {
      operator delete(v58);
      v17 = *(char **)&buf[16];
    }
  }
  else
  {
    *(_DWORD *)v48 = 12;
    v57 = v48 + 4;
  }
  *(_QWORD *)&buf[8] = v57;
  if (v57 >= v17)
  {
    v67 = *(char **)buf;
    v68 = (uint64_t)&v57[-*(_QWORD *)buf] >> 2;
    v69 = v68 + 1;
    if ((unint64_t)(v68 + 1) >> 62)
      abort();
    v70 = (uint64_t)&v17[-*(_QWORD *)buf];
    if (v70 >> 1 > v69)
      v69 = v70 >> 1;
    if ((unint64_t)v70 >= 0x7FFFFFFFFFFFFFFCLL)
      v71 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v71 = v69;
    if (v71)
    {
      v72 = (char *)sub_1002B46E0((uint64_t)&buf[16], v71);
      v67 = *(char **)buf;
      v57 = *(char **)&buf[8];
    }
    else
    {
      v72 = 0;
    }
    v73 = &v72[4 * v68];
    v17 = &v72[4 * v71];
    *(_DWORD *)v73 = 15;
    v66 = v73 + 4;
    while (v57 != v67)
    {
      v74 = *((_DWORD *)v57 - 1);
      v57 -= 4;
      *((_DWORD *)v73 - 1) = v74;
      v73 -= 4;
    }
    *(_QWORD *)buf = v73;
    *(_QWORD *)&buf[8] = v66;
    *(_QWORD *)&buf[16] = v17;
    if (v67)
    {
      operator delete(v67);
      v17 = *(char **)&buf[16];
    }
  }
  else
  {
    *(_DWORD *)v57 = 15;
    v66 = v57 + 4;
  }
  *(_QWORD *)&buf[8] = v66;
  if (v66 >= v17)
  {
    v76 = *(char **)buf;
    v77 = (uint64_t)&v66[-*(_QWORD *)buf] >> 2;
    v78 = v77 + 1;
    if ((unint64_t)(v77 + 1) >> 62)
      abort();
    v79 = (uint64_t)&v17[-*(_QWORD *)buf];
    if (v79 >> 1 > v78)
      v78 = v79 >> 1;
    if ((unint64_t)v79 >= 0x7FFFFFFFFFFFFFFCLL)
      v80 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v80 = v78;
    if (v80)
    {
      v81 = (char *)sub_1002B46E0((uint64_t)&buf[16], v80);
      v76 = *(char **)buf;
      v66 = *(char **)&buf[8];
    }
    else
    {
      v81 = 0;
    }
    v82 = &v81[4 * v77];
    v17 = &v81[4 * v80];
    *(_DWORD *)v82 = 5;
    v75 = v82 + 4;
    while (v66 != v76)
    {
      v83 = *((_DWORD *)v66 - 1);
      v66 -= 4;
      *((_DWORD *)v82 - 1) = v83;
      v82 -= 4;
    }
    *(_QWORD *)buf = v82;
    *(_QWORD *)&buf[8] = v75;
    *(_QWORD *)&buf[16] = v17;
    if (v76)
    {
      operator delete(v76);
      v17 = *(char **)&buf[16];
    }
  }
  else
  {
    *(_DWORD *)v66 = 5;
    v75 = v66 + 4;
  }
  *(_QWORD *)&buf[8] = v75;
  if (v75 >= v17)
  {
    v85 = *(char **)buf;
    v86 = (uint64_t)&v75[-*(_QWORD *)buf] >> 2;
    v87 = v86 + 1;
    if ((unint64_t)(v86 + 1) >> 62)
      abort();
    v88 = (uint64_t)&v17[-*(_QWORD *)buf];
    if (v88 >> 1 > v87)
      v87 = v88 >> 1;
    if ((unint64_t)v88 >= 0x7FFFFFFFFFFFFFFCLL)
      v89 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v89 = v87;
    if (v89)
    {
      v90 = (char *)sub_1002B46E0((uint64_t)&buf[16], v89);
      v85 = *(char **)buf;
      v75 = *(char **)&buf[8];
    }
    else
    {
      v90 = 0;
    }
    v91 = &v90[4 * v86];
    v17 = &v90[4 * v89];
    *(_DWORD *)v91 = 6;
    v84 = v91 + 4;
    while (v75 != v85)
    {
      v92 = *((_DWORD *)v75 - 1);
      v75 -= 4;
      *((_DWORD *)v91 - 1) = v92;
      v91 -= 4;
    }
    *(_QWORD *)buf = v91;
    *(_QWORD *)&buf[8] = v84;
    *(_QWORD *)&buf[16] = v17;
    if (v85)
    {
      operator delete(v85);
      v17 = *(char **)&buf[16];
    }
  }
  else
  {
    *(_DWORD *)v75 = 6;
    v84 = v75 + 4;
  }
  *(_QWORD *)&buf[8] = v84;
  if (v84 >= v17)
  {
    v94 = *(char **)buf;
    v95 = (uint64_t)&v84[-*(_QWORD *)buf] >> 2;
    v96 = v95 + 1;
    if ((unint64_t)(v95 + 1) >> 62)
      abort();
    v97 = (uint64_t)&v17[-*(_QWORD *)buf];
    if (v97 >> 1 > v96)
      v96 = v97 >> 1;
    if ((unint64_t)v97 >= 0x7FFFFFFFFFFFFFFCLL)
      v98 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v98 = v96;
    if (v98)
    {
      v99 = (char *)sub_1002B46E0((uint64_t)&buf[16], v98);
      v94 = *(char **)buf;
      v84 = *(char **)&buf[8];
    }
    else
    {
      v99 = 0;
    }
    v100 = &v99[4 * v95];
    v17 = &v99[4 * v98];
    *(_DWORD *)v100 = 7;
    v93 = v100 + 4;
    while (v84 != v94)
    {
      v101 = *((_DWORD *)v84 - 1);
      v84 -= 4;
      *((_DWORD *)v100 - 1) = v101;
      v100 -= 4;
    }
    *(_QWORD *)buf = v100;
    *(_QWORD *)&buf[8] = v93;
    *(_QWORD *)&buf[16] = v17;
    if (v94)
    {
      operator delete(v94);
      v17 = *(char **)&buf[16];
    }
  }
  else
  {
    *(_DWORD *)v84 = 7;
    v93 = v84 + 4;
  }
  *(_QWORD *)&buf[8] = v93;
  if (v93 >= v17)
  {
    v103 = *(char **)buf;
    v104 = (uint64_t)&v93[-*(_QWORD *)buf] >> 2;
    v105 = v104 + 1;
    if ((unint64_t)(v104 + 1) >> 62)
      abort();
    v106 = (uint64_t)&v17[-*(_QWORD *)buf];
    if (v106 >> 1 > v105)
      v105 = v106 >> 1;
    if ((unint64_t)v106 >= 0x7FFFFFFFFFFFFFFCLL)
      v107 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v107 = v105;
    if (v107)
    {
      v108 = (char *)sub_1002B46E0((uint64_t)&buf[16], v107);
      v103 = *(char **)buf;
      v93 = *(char **)&buf[8];
    }
    else
    {
      v108 = 0;
    }
    v109 = &v108[4 * v104];
    v17 = &v108[4 * v107];
    *(_DWORD *)v109 = 8;
    v102 = v109 + 4;
    while (v93 != v103)
    {
      v110 = *((_DWORD *)v93 - 1);
      v93 -= 4;
      *((_DWORD *)v109 - 1) = v110;
      v109 -= 4;
    }
    *(_QWORD *)buf = v109;
    *(_QWORD *)&buf[8] = v102;
    *(_QWORD *)&buf[16] = v17;
    if (v103)
    {
      operator delete(v103);
      v17 = *(char **)&buf[16];
    }
  }
  else
  {
    *(_DWORD *)v93 = 8;
    v102 = v93 + 4;
  }
  *(_QWORD *)&buf[8] = v102;
  if (v102 >= v17)
  {
    v112 = *(char **)buf;
    v113 = (uint64_t)&v102[-*(_QWORD *)buf] >> 2;
    v114 = v113 + 1;
    if ((unint64_t)(v113 + 1) >> 62)
      abort();
    v115 = (uint64_t)&v17[-*(_QWORD *)buf];
    if (v115 >> 1 > v114)
      v114 = v115 >> 1;
    if ((unint64_t)v115 >= 0x7FFFFFFFFFFFFFFCLL)
      v116 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v116 = v114;
    if (v116)
    {
      v117 = (char *)sub_1002B46E0((uint64_t)&buf[16], v116);
      v112 = *(char **)buf;
      v102 = *(char **)&buf[8];
    }
    else
    {
      v117 = 0;
    }
    v118 = &v117[4 * v113];
    v17 = &v117[4 * v116];
    *(_DWORD *)v118 = 9;
    v111 = v118 + 4;
    while (v102 != v112)
    {
      v119 = *((_DWORD *)v102 - 1);
      v102 -= 4;
      *((_DWORD *)v118 - 1) = v119;
      v118 -= 4;
    }
    *(_QWORD *)buf = v118;
    *(_QWORD *)&buf[8] = v111;
    *(_QWORD *)&buf[16] = v17;
    if (v112)
    {
      operator delete(v112);
      v17 = *(char **)&buf[16];
    }
  }
  else
  {
    *(_DWORD *)v102 = 9;
    v111 = v102 + 4;
  }
  *(_QWORD *)&buf[8] = v111;
  if (v111 >= v17)
  {
    v121 = *(char **)buf;
    v122 = (uint64_t)&v111[-*(_QWORD *)buf] >> 2;
    v123 = v122 + 1;
    if ((unint64_t)(v122 + 1) >> 62)
      abort();
    v124 = (uint64_t)&v17[-*(_QWORD *)buf];
    if (v124 >> 1 > v123)
      v123 = v124 >> 1;
    if ((unint64_t)v124 >= 0x7FFFFFFFFFFFFFFCLL)
      v125 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v125 = v123;
    if (v125)
    {
      v126 = (char *)sub_1002B46E0((uint64_t)&buf[16], v125);
      v121 = *(char **)buf;
      v111 = *(char **)&buf[8];
    }
    else
    {
      v126 = 0;
    }
    v127 = &v126[4 * v122];
    v17 = &v126[4 * v125];
    *(_DWORD *)v127 = 13;
    v120 = v127 + 4;
    while (v111 != v121)
    {
      v128 = *((_DWORD *)v111 - 1);
      v111 -= 4;
      *((_DWORD *)v127 - 1) = v128;
      v127 -= 4;
    }
    *(_QWORD *)buf = v127;
    *(_QWORD *)&buf[8] = v120;
    *(_QWORD *)&buf[16] = v17;
    if (v121)
    {
      operator delete(v121);
      v17 = *(char **)&buf[16];
    }
  }
  else
  {
    *(_DWORD *)v111 = 13;
    v120 = v111 + 4;
  }
  *(_QWORD *)&buf[8] = v120;
  if (v120 >= v17)
  {
    v130 = *(char **)buf;
    v131 = (uint64_t)&v120[-*(_QWORD *)buf] >> 2;
    v132 = v131 + 1;
    if ((unint64_t)(v131 + 1) >> 62)
      abort();
    v133 = (uint64_t)&v17[-*(_QWORD *)buf];
    if (v133 >> 1 > v132)
      v132 = v133 >> 1;
    if ((unint64_t)v133 >= 0x7FFFFFFFFFFFFFFCLL)
      v134 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v134 = v132;
    if (v134)
    {
      v135 = (char *)sub_1002B46E0((uint64_t)&buf[16], v134);
      v130 = *(char **)buf;
      v120 = *(char **)&buf[8];
    }
    else
    {
      v135 = 0;
    }
    v136 = &v135[4 * v131];
    v17 = &v135[4 * v134];
    *(_DWORD *)v136 = 14;
    v129 = v136 + 4;
    while (v120 != v130)
    {
      v137 = *((_DWORD *)v120 - 1);
      v120 -= 4;
      *((_DWORD *)v136 - 1) = v137;
      v136 -= 4;
    }
    *(_QWORD *)buf = v136;
    *(_QWORD *)&buf[8] = v129;
    *(_QWORD *)&buf[16] = v17;
    if (v130)
    {
      operator delete(v130);
      v17 = *(char **)&buf[16];
    }
  }
  else
  {
    *(_DWORD *)v120 = 14;
    v129 = v120 + 4;
  }
  *(_QWORD *)&buf[8] = v129;
  if (v129 >= v17)
  {
    v139 = *(char **)buf;
    v140 = (uint64_t)&v129[-*(_QWORD *)buf] >> 2;
    v141 = v140 + 1;
    if ((unint64_t)(v140 + 1) >> 62)
      abort();
    v142 = (uint64_t)&v17[-*(_QWORD *)buf];
    if (v142 >> 1 > v141)
      v141 = v142 >> 1;
    if ((unint64_t)v142 >= 0x7FFFFFFFFFFFFFFCLL)
      v143 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v143 = v141;
    if (v143)
    {
      v144 = (char *)sub_1002B46E0((uint64_t)&buf[16], v143);
      v139 = *(char **)buf;
      v129 = *(char **)&buf[8];
    }
    else
    {
      v144 = 0;
    }
    v145 = &v144[4 * v140];
    v146 = &v144[4 * v143];
    *(_DWORD *)v145 = 16;
    v138 = v145 + 4;
    while (v129 != v139)
    {
      v147 = *((_DWORD *)v129 - 1);
      v129 -= 4;
      *((_DWORD *)v145 - 1) = v147;
      v145 -= 4;
    }
    *(_QWORD *)buf = v145;
    *(_QWORD *)&buf[8] = v138;
    *(_QWORD *)&buf[16] = v146;
    if (v139)
      operator delete(v139);
  }
  else
  {
    *(_DWORD *)v129 = 16;
    v138 = v129 + 4;
  }
  *(_QWORD *)&buf[8] = v138;
  sub_10069BF94(a1, a2, v7, a4, (unsigned int **)buf, 0);
  if (*(_QWORD *)buf)
  {
    *(_QWORD *)&buf[8] = *(_QWORD *)buf;
    operator delete(*(void **)buf);
  }
  sub_100034234((uint64_t)v150);

}

void sub_10069CD40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19)
{
  void *v19;

  sub_100034234((uint64_t)&a16);

  _Unwind_Resume(a1);
}

void sub_10069CDD4(uint64_t a1, void *a2, uint64_t a3)
{
  id v5;
  uint64_t v6;
  id v7;
  void *v8;
  void *v9;
  uint64_t v10;
  int v11;
  NSObject *v12;
  _BOOL4 v13;
  void *v14;
  int v15;
  uint64_t v16;
  const char *v17;
  NSObject *v18;
  os_log_type_t v19;
  uint64_t v20;
  _QWORD v21[2];
  uint8_t buf[4];
  id v23;
  __int16 v24;
  void *v25;
  __int16 v26;
  int v27;

  v5 = a2;
  v21[0] = 0;
  v21[1] = 0;
  sub_10003415C((uint64_t)v21, a1 + 48);
  sub_100030BCC(buf, v5);
  v6 = sub_10000C5B8(a1 + 488, buf);
  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_10093FA18);
  if (sub_10066039C((uint64_t)off_1009778C0, v5))
  {
    if (qword_1009778C8 != -1)
      dispatch_once(&qword_1009778C8, &stru_10093FA18);
    v7 = sub_1006518F8((uint64_t)off_1009778C0, v5);
    v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
    v9 = v8;
    if (v8)
    {
      *(_WORD *)(a3 + 80) |= 8u;
      *(_WORD *)(a3 + 44) = 528;
      *(_OWORD *)(a3 + 28) = *(_OWORD *)objc_msgSend(objc_retainAutorelease(v8), "bytes");
    }
    else if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
    {
      sub_100719C90();
    }

    goto LABEL_17;
  }
  if (a1 + 496 == v6)
  {
    sub_100030BCC(buf, v5);
    v16 = sub_10000C5B8(a1 + 440, buf);
    if (a1 + 448 != v16)
    {
      sub_1006911AC(a1, v16 + 48, (_WORD *)a3);
      goto LABEL_17;
    }
    v20 = qword_100999818;
    if (!os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_INFO))
      goto LABEL_17;
    *(_DWORD *)buf = 138543362;
    v23 = v5;
    v17 = "No security keys found for device \"%{public}@\"";
    v18 = v20;
    v19 = OS_LOG_TYPE_INFO;
LABEL_22:
    _os_log_impl((void *)&_mh_execute_header, v18, v19, v17, buf, 0xCu);
    goto LABEL_17;
  }
  sub_1006911AC(a1, v6 + 48, (_WORD *)a3);
  v10 = sub_100027F68();
  v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
  v12 = qword_100999818;
  v13 = os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT);
  if (!v11)
  {
    if (!v13)
      goto LABEL_17;
    *(_DWORD *)buf = 138543362;
    v23 = v5;
    v17 = "using temporary keys for device \"%{public}@\"";
    v18 = v12;
    v19 = OS_LOG_TYPE_DEFAULT;
    goto LABEL_22;
  }
  if (v13)
  {
    v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", a3 + 28, *(unsigned __int8 *)(a3 + 44)));
    v15 = *(unsigned __int8 *)(a3 + 45);
    *(_DWORD *)buf = 138543874;
    v23 = v5;
    v24 = 2112;
    v25 = v14;
    v26 = 1024;
    v27 = v15;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "using temporary keys for device \"%{public}@\" LocalLTK:%@(type:%d)", buf, 0x1Cu);

  }
LABEL_17:
  sub_100034234((uint64_t)v21);

}

void sub_10069D0D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  void *v9;

  sub_100034234((uint64_t)&a9);

  _Unwind_Resume(a1);
}

void sub_10069D114(uint64_t a1, unint64_t a2, unsigned int a3, int a4, char a5)
{
  NSObject *v9;
  int v10;
  void **v11;
  id v12;
  uint64_t v13;
  void *v14;
  void **v15;
  const char *v16;
  uint64_t v17;
  void *v18;
  id v19;
  void *v20;
  BOOL v21;
  id v22;
  void *v23;
  _BOOL4 v24;
  uint64_t v25;
  char v26;
  NSObject *v27;
  uint64_t v28;
  id v29;
  void *v30;
  NSObject *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  id v40;
  void *v41;
  id v42;
  void *v43;
  uint64_t *v44;
  uint64_t *i;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  char *v50;
  id v51;
  uint64_t v52;
  void *v53;
  char *v54;
  _QWORD v56[4];
  id v57;
  uint64_t v58;
  char v59;
  void *__p[2];
  char v61;
  uint8_t buf[4];
  void *v63;
  __int16 v64;
  uint64_t v65;
  __int16 v66;
  uint64_t v67;
  unsigned __int8 uu[8];
  uint64_t v69;
  uuid_string_t out;

  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_10093FA18);
  *(_QWORD *)uu = 0;
  v69 = 0;
  sub_10003F924((uint64_t)off_1009778C0, a2, 0, 1u, 0, 0, uu);
  v9 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    memset(out, 0, sizeof(out));
    uuid_unparse_upper(uu, out);
    sub_100091AE8(__p, out);
    v10 = v61;
    v11 = (void **)__p[0];
    v12 = sub_100021770(a2);
    v13 = objc_claimAutoreleasedReturnValue(v12);
    v14 = (void *)v13;
    v15 = __p;
    if (v10 < 0)
      v15 = v11;
    v16 = "disabled";
    *(_DWORD *)buf = 136446722;
    if (a4)
      v16 = "enabled";
    v63 = (void *)v16;
    v64 = 2082;
    v65 = (uint64_t)v15;
    v66 = 2114;
    v67 = v13;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Encryption is now %{public}s for device \"%{public}s\" (%{public}@)", buf, 0x20u);
    if (v61 < 0)
      operator delete(__p[0]);

  }
  if (a4)
  {
    v17 = sub_10000C5B8(a1 + 488, uu);
    if (qword_1009778C8 != -1)
      dispatch_once(&qword_1009778C8, &stru_10093FA18);
    v18 = off_1009778C0;
    v19 = sub_100030DF4(uu);
    v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
    v21 = sub_10066039C((uint64_t)v18, v20);

    v22 = sub_100030DF4(uu);
    v23 = (void *)objc_claimAutoreleasedReturnValue(v22);
    v24 = sub_100030864(a1, v23);

    if (v24)
    {
      v25 = sub_1000438A4();
      (*(void (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)v25 + 1144))(v25, a2, 1);
    }
    else
    {
      v26 = a1 + 496 != v17 || v21;
      if ((v26 & 1) == 0 && (a5 & 1) == 0)
      {
        v27 = qword_100999818;
        if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
        {
          sub_1003D2DB4(uu, out);
          v49 = out[23];
          v50 = *(char **)out;
          v51 = sub_100021770(a2);
          v52 = objc_claimAutoreleasedReturnValue(v51);
          v53 = (void *)v52;
          v54 = out;
          if (v49 < 0)
            v54 = v50;
          *(_DWORD *)buf = 136446466;
          v63 = v54;
          v64 = 2114;
          v65 = v52;
          _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "Unexpected encryption state for device \"%{public}s\" (%{public}@), disconnecting", buf, 0x16u);
          if (out[23] < 0)
            operator delete(*(void **)out);

        }
        if (qword_1009778A8 != -1)
          dispatch_once(&qword_1009778A8, &stru_10093FA38);
        sub_100622358((uint64_t)off_1009778A0, uu, 6u);
      }
    }
  }
  if (a3 == 706)
  {
    if (qword_1009778B8 != -1)
      dispatch_once(&qword_1009778B8, &stru_10093F9D8);
    v28 = qword_1009778B0;
    v29 = sub_100030DF4(uu);
    v30 = (void *)objc_claimAutoreleasedReturnValue(v29);
    LODWORD(v28) = sub_100030864(v28, v30);

    if ((_DWORD)v28)
    {
      v31 = qword_100999818;
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
        sub_100719CF4(v31, v32, v33, v34, v35, v36, v37, v38);
      if (qword_1009778F8 != -1)
        dispatch_once(&qword_1009778F8, &stru_10093FA78);
      v39 = qword_1009778F0;
      v40 = sub_100030DF4(uu);
      v41 = (void *)objc_claimAutoreleasedReturnValue(v40);
      sub_1005DCD50(v39, v41);

    }
  }
  v42 = sub_100030DF4(uu);
  v43 = (void *)objc_claimAutoreleasedReturnValue(v42);
  v44 = *(uint64_t **)(a1 + 568);
  for (i = *(uint64_t **)(a1 + 576); v44 != i; ++v44)
  {
    v46 = *v44;
    v47 = sub_1000419F4();
    v56[0] = _NSConcreteStackBlock;
    v56[1] = 3221225472;
    v56[2] = sub_10069D65C;
    v56[3] = &unk_10092B468;
    v58 = v46;
    v57 = v43;
    v59 = a4;
    sub_100041A34(v47, v56);

  }
  v48 = sub_100065478();
  (*(void (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)v48 + 640))(v48, a3, 2);

}

void sub_10069D5D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a35 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_10069D65C(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(**(_QWORD **)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 32), *(unsigned __int8 *)(a1 + 48));
}

uint64_t sub_10069D674(uint64_t a1, unint64_t a2, uint64_t *a3, int a4)
{
  char v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v12;
  unsigned int *v13;
  BOOL v14;
  char v15;
  int v16;
  void *v17;
  id v18;
  void *v19;
  BOOL v20;
  uint64_t (**v21)();
  unsigned int *v22;
  uint64_t (**v23)();
  unsigned int *v24;
  uint64_t (**v25)();
  unsigned int *v26;
  _QWORD v27[2];
  uint64_t (**v28)();
  unsigned int *v29;
  unsigned __int8 uu[8];
  uint64_t v31;

  v27[0] = 0;
  v27[1] = 0;
  sub_10003415C((uint64_t)v27, a1 + 48);
  *(_QWORD *)uu = 0;
  v31 = 0;
  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_10093FA18);
  sub_10003F924((uint64_t)off_1009778C0, a2, 1u, 1u, 0, 0, uu);
  if (uuid_is_null(uu))
  {
    v8 = 0;
    v9 = 0;
    goto LABEL_5;
  }
  v12 = sub_10000C5B8(a1 + 488, uu);
  if (a1 + 496 == v12)
    v12 = sub_10000C5B8(a1 + 440, uu);
  if (v12 != a1 + 448)
  {
    v13 = *(unsigned int **)(v12 + 56);
    if (v13)
      sub_10003C37C(*(_QWORD *)(v12 + 56));
    v25 = 0;
    v26 = 0;
    sub_1003965C0((uint64_t)v13, 9, &v25);
    v23 = 0;
    v24 = 0;
    sub_1003965C0((uint64_t)v13, 8, &v23);
    v21 = 0;
    v22 = 0;
    sub_1003965C0((uint64_t)v13, 7, &v21);
    if (sub_1000452EC((uint64_t)&v25) && sub_1000452EC((uint64_t)&v23))
    {
      v28 = 0;
      if (a4)
        v14 = 0;
      else
        v14 = *a3 == 0;
      v15 = v14;
      if ((sub_1000452EC((uint64_t)&v21)
         || *(_BYTE *)sub_10003EB18((uint64_t)&v21) != 2 && *(_BYTE *)sub_10003EB18((uint64_t)&v21) != 3)
        && (v15 & 1) == 0)
      {
        goto LABEL_38;
      }
    }
    else
    {
      if (sub_1000452EC((uint64_t)&v25) || sub_1000452EC((uint64_t)&v23))
        goto LABEL_38;
      v16 = *(unsigned __int16 *)sub_10003EB18((uint64_t)&v23);
      v8 = 0;
      v9 = 0;
      if (*a3 != *(_QWORD *)sub_10003EB18((uint64_t)&v25) || v16 != a4)
        goto LABEL_40;
    }
    if (!sub_1000452EC((uint64_t)&v21))
    {
      v8 = *(_BYTE *)sub_10003EB18((uint64_t)&v21);
      sub_1003965C0((uint64_t)v13, 6, &v28);
      sub_100041698((uint64_t)&v23, (uint64_t)&v28);
      v28 = &off_100918258;
      if (v29)
        sub_100056AAC(v29);
      if (!sub_1000452EC((uint64_t)&v23))
      {
        v9 = *(unsigned __int8 *)sub_10003EB18((uint64_t)&v23);
        goto LABEL_40;
      }
LABEL_39:
      v9 = 0;
LABEL_40:
      v21 = &off_100918258;
      if (v22)
        sub_100056AAC(v22);
      v23 = &off_100918258;
      if (v24)
        sub_100056AAC(v24);
      v25 = &off_100918258;
      if (v26)
        sub_100056AAC(v26);
      if (v13)
        sub_100056AAC(v13);
      goto LABEL_5;
    }
LABEL_38:
    v8 = 0;
    goto LABEL_39;
  }
  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_10093FA18);
  v17 = off_1009778C0;
  v18 = sub_100030DF4(uu);
  v19 = (void *)objc_claimAutoreleasedReturnValue(v18);
  LODWORD(v17) = sub_10066039C((uint64_t)v17, v19);

  v20 = (_DWORD)v17 == 0;
  if ((_DWORD)v17)
    v8 = 2;
  else
    v8 = 0;
  if (v20)
    v9 = 0;
  else
    v9 = 16;
LABEL_5:
  v10 = sub_1000746A4(a2);
  LODWORD(v25) = v10;
  BYTE6(v25) = BYTE6(v10);
  WORD2(v25) = WORD2(v10);
  LOBYTE(v23) = 0;
  sub_100043758(&v23);
  sub_10022C4CC(&v25, a3, a4, v9, v8);
  sub_100043728(&v23);
  return sub_100034234((uint64_t)v27);
}

void sub_10069D9FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, unsigned int *a11, uint64_t a12, unsigned int *a13, uint64_t a14, unsigned int *a15, char a16, uint64_t a17, uint64_t (**a18)(), unsigned int *a19)
{
  unsigned int *v19;

  a18 = &off_100918258;
  if (a19)
    sub_100056AAC(a19);
  if (a11)
    sub_100056AAC(a11);
  if (a13)
    sub_100056AAC(a13);
  if (a15)
    sub_100056AAC(a15);
  if (v19)
    sub_100056AAC(v19);
  sub_100034234((uint64_t)&a16);
  _Unwind_Resume(a1);
}

_BYTE *sub_10069DAE8(uint64_t a1, unint64_t a2)
{
  id v4;
  void *v5;
  void *v6;
  id v7;
  void *v8;
  uint64_t v9;
  char v11;
  int v12;
  __int16 v13;
  char v14;
  unsigned __int8 uu[8];
  uint64_t v16;
  _OWORD v17[5];
  int v18;

  v18 = 0;
  memset(v17, 0, sizeof(v17));
  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_10093FA18);
  *(_QWORD *)uu = 0;
  v16 = 0;
  sub_10003F924((uint64_t)off_1009778C0, a2, 1u, 1u, 0, 0, uu);
  if (!uuid_is_null(uu))
  {
    v4 = sub_100030DF4(uu);
    v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
    sub_10069CDD4(a1, v5, (uint64_t)v17);

    if (qword_1009778C8 != -1)
      dispatch_once(&qword_1009778C8, &stru_10093FA18);
    v6 = off_1009778C0;
    v7 = sub_100030DF4(uu);
    v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
    BYTE2(v18) = sub_10066007C((uint64_t)v6, v8);

  }
  v9 = sub_1000746A4(a2);
  v12 = v9;
  v14 = BYTE6(v9);
  v13 = WORD2(v9);
  v11 = 0;
  sub_100043758(&v11);
  sub_10022DDDC(&v12, (uint64_t)v17);
  return sub_100043728(&v11);
}

void sub_10069DC68(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t sub_10069DC9C(uint64_t a1, unint64_t a2, int a3, unsigned __int8 *a4, unsigned int a5)
{
  NSObject *v10;
  id v11;
  void *v12;
  _DWORD v14[2];
  __int16 v15;
  unsigned int v16;
  __int16 v17;
  void *v18;

  v10 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    v11 = sub_100021770(a2);
    v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
    v14[0] = 67109634;
    v14[1] = a3;
    v15 = 1024;
    v16 = a5;
    v17 = 2114;
    v18 = v12;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Adding temporary security keys (type:%d lengh:%d) to device %{public}@", (uint8_t *)v14, 0x18u);

  }
  return sub_10069DDAC(a1, a2, a3, a4, a5, 1);
}

uint64_t sub_10069DDAC(uint64_t a1, unint64_t a2, int a3, unsigned __int8 *a4, unsigned int a5, int a6)
{
  uint64_t v12;
  uint64_t v13;
  id v14;
  id v15;
  NSObject *v16;
  id v17;
  void *v18;
  int v19;
  id v20;
  uint64_t v21;
  id v22;
  uint64_t v23;
  uint64_t (**v25)();
  unsigned int *v26;
  char v27;
  int v28;
  __int16 v29;
  char v30;
  _QWORD v31[2];
  _BYTE src[18];
  __int16 v33;
  int v34;
  __int16 v35;
  unsigned int v36;
  __int16 v37;
  int v38;
  uuid_t uu;

  v31[0] = 0;
  v31[1] = 0;
  sub_10003415C((uint64_t)v31, a1 + 48);
  v12 = sub_1000746A4(a2);
  v28 = v12;
  v30 = BYTE6(v12);
  v29 = WORD2(v12);
  v27 = 0;
  sub_100043758(&v27);
  v13 = sub_10019AFA0(&v28);
  sub_10004339C(&v27);
  memset(uu, 0, sizeof(uu));
  uuid_clear(uu);
  if (!v13)
    goto LABEL_38;
  if (qword_1009778A8 != -1)
    dispatch_once(&qword_1009778A8, &stru_10093FA38);
  if ((sub_10061E090((uint64_t)off_1009778A0, v13, uu) & 1) != 0)
    goto LABEL_38;
  if (uuid_is_null(uu) && os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_FAULT))
  {
    v14 = sub_100021770(a2);
    objc_claimAutoreleasedReturnValue(v14);
    sub_100719E20();
  }
  if (!uuid_is_null(uu))
  {
LABEL_38:
    if (!uuid_is_null(uu))
      goto LABEL_16;
    if (qword_1009778C8 != -1)
      dispatch_once(&qword_1009778C8, &stru_10093FA18);
    sub_10003F924((uint64_t)off_1009778C0, a2, 0, 1u, 0, 0, src);
    uuid_copy(uu, src);
    if (uuid_is_null(uu) && os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_FAULT))
    {
      v15 = sub_100021770(a2);
      objc_claimAutoreleasedReturnValue(v15);
      sub_100719DE0();
    }
    if (!uuid_is_null(uu))
    {
LABEL_16:
      v16 = qword_100999818;
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
      {
        v17 = sub_100021770(a2);
        v18 = (void *)objc_claimAutoreleasedReturnValue(v17);
        v19 = *a4;
        *(_DWORD *)src = 138544386;
        *(_QWORD *)&src[4] = v18;
        *(_WORD *)&src[12] = 1024;
        *(_DWORD *)&src[14] = a3;
        v33 = 1024;
        v34 = v19;
        v35 = 1024;
        v36 = a5;
        v37 = 1024;
        v38 = a6;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Key generated for \"%{public}@\" type=%d value=%d len=%d temporary=%d", src, 0x24u);

      }
      *(_QWORD *)src = &off_100934340;
      *(_QWORD *)&src[8] = 0;
      if ((a6 & 1) != 0)
      {
        if (a1 + 472 != sub_10000C5B8(a1 + 464, uu))
        {
          if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
          {
            v20 = sub_100021770(a2);
            objc_claimAutoreleasedReturnValue(v20);
            sub_100719DA0();
          }
          goto LABEL_28;
        }
        if (a1 + 448 != sub_10000C5B8(a1 + 440, uu))
        {
          if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
          {
            v22 = sub_100021770(a2);
            objc_claimAutoreleasedReturnValue(v22);
            sub_100719D60();
          }
          goto LABEL_28;
        }
        v21 = sub_10000C5B8(a1 + 488, uu);
        if (a1 + 496 == v21)
          operator new();
      }
      else
      {
        v21 = sub_10000C5B8(a1 + 464, uu);
        if (a1 + 472 == v21)
          operator new();
      }
      sub_100041698((uint64_t)src, v21 + 48);
LABEL_28:
      v23 = *(_QWORD *)&src[8];
      if (*(_QWORD *)&src[8])
      {
        sub_10003994C(&v25, a4, a5);
        sub_100395D48(v23, a3, (uint64_t)&v25);
        v25 = &off_100918258;
        if (v26)
          sub_100056AAC(v26);
        *(_QWORD *)src = &off_100934340;
        if (*(_QWORD *)&src[8])
          sub_100056AAC(*(unsigned int **)&src[8]);
      }
    }
  }
  sub_100043728(&v27);
  return sub_100034234((uint64_t)v31);
}

void sub_10069E2C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unsigned int *a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,unsigned int *a21)
{
  if (a10)
    sub_100056AAC(a10);
  if (a21)
    sub_100056AAC(a21);
  sub_100043728(&a14);
  sub_100034234((uint64_t)&a16);
  _Unwind_Resume(a1);
}

uint64_t *sub_10069E36C(uint64_t a1, unsigned __int8 *a2)
{
  NSObject *v4;
  void **v5;
  uint64_t **v6;
  uint64_t *result;
  uint64_t *v8;
  NSObject *v9;
  void **v10;
  void *__p[2];
  char v12;
  uint8_t out[40];

  v4 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    memset(out, 0, 37);
    uuid_unparse_upper(a2, (char *)out);
    sub_100091AE8(__p, (char *)out);
    v5 = v12 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)out = 136446210;
    *(_QWORD *)&out[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Removing temporary security keys for device %{public}s", out, 0xCu);
    if (v12 < 0)
      operator delete(__p[0]);
  }
  v6 = (uint64_t **)(a1 + 488);
  result = (uint64_t *)sub_10000C5B8(a1 + 488, a2);
  if ((uint64_t *)(a1 + 496) != result)
  {
    v8 = result;
    v9 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
    {
      memset(out, 0, 37);
      uuid_unparse_upper(a2, (char *)out);
      sub_100091AE8(__p, (char *)out);
      if (v12 >= 0)
        v10 = __p;
      else
        v10 = (void **)__p[0];
      *(_DWORD *)out = 136446210;
      *(_QWORD *)&out[4] = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Found temporary security keys for device %{public}s, removing now.", out, 0xCu);
      if (v12 < 0)
        operator delete(__p[0]);
    }
    return sub_1006A77F0(v6, v8);
  }
  return result;
}

uint64_t sub_10069E524(uint64_t a1, unsigned __int8 *a2)
{
  NSObject *v4;
  void **v5;
  uint64_t **v6;
  uint64_t result;
  uint64_t *v8;
  NSObject *v9;
  void **v10;
  uint64_t v11;
  unsigned __int8 *v12;
  void *v13;
  id v14;
  void *v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  void *__p[2];
  char v20;
  uuid_string_t out;

  v4 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    memset(out, 0, sizeof(out));
    uuid_unparse_upper(a2, out);
    sub_100091AE8(__p, out);
    v5 = v20 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)out = 136446210;
    *(_QWORD *)&out[4] = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Removing temporary IRK for device %{public}s", (uint8_t *)out, 0xCu);
    if (v20 < 0)
      operator delete(__p[0]);
  }
  v6 = (uint64_t **)(a1 + 512);
  result = sub_10000C5B8(a1 + 512, a2);
  v8 = (uint64_t *)result;
  if (a1 + 520 != result)
  {
    v9 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
    {
      memset(out, 0, sizeof(out));
      uuid_unparse_upper(a2, out);
      sub_100091AE8(__p, out);
      v10 = v20 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)out = 136446210;
      *(_QWORD *)&out[4] = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Found temporary IRK for device %{public}s, removing now.", (uint8_t *)out, 0xCu);
      if (v20 < 0)
        operator delete(__p[0]);
    }
    if (qword_1009778B8 != -1)
      dispatch_once(&qword_1009778B8, &stru_10093F9D8);
    v11 = qword_1009778B0;
    sub_1003965C0(v8[7], 11, out);
    v12 = (unsigned __int8 *)sub_10003EB18((uint64_t)out);
    sub_10069E810(v11, v12);
    *(_QWORD *)out = &off_100918258;
    if (*(_QWORD *)&out[8])
      sub_100056AAC(*(unsigned int **)&out[8]);
    sub_1006A77F0(v6, v8);
    if (qword_1009778C8 != -1)
      dispatch_once(&qword_1009778C8, &stru_10093FA18);
    v13 = off_1009778C0;
    v14 = sub_100030DF4(a2);
    v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
    v16 = sub_1000589DC((uint64_t)v13, v15, 1);

    out[0] = 0;
    v17 = sub_100225368(v16);
    *(_DWORD *)&out[1] = v17;
    *(_WORD *)&out[5] = WORD2(v17);
    sub_10069AC78(v17, (unsigned __int8 *)out);
    v18 = sub_1000438A4();
    return (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)v18 + 384))(v18, v16, 1);
  }
  return result;
}

void sub_10069E7D8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t sub_10069E810(uint64_t result, unsigned __int8 *a2)
{
  uint64_t v3;
  BOOL v4;
  unint64_t v5;
  uint64_t v6;

  v3 = 0;
  while (1)
  {
    v4 = *(_DWORD *)(result + v3 + 613) == *(_DWORD *)a2 && *(_DWORD *)(result + v3 + 616) == *(_DWORD *)(a2 + 3);
    if (v4 && *(_BYTE *)(result + v3 + 620))
      break;
    v3 += 24;
    if (v3 == 3120)
      return result;
  }
  *(_BYTE *)(result + v3 + 620) = 0;
  sub_10069AC78(result, a2);
  v5 = ((unint64_t)a2[1] << 40) | ((unint64_t)a2[2] << 32) | ((unint64_t)a2[3] << 24) | ((unint64_t)a2[4] << 16) | ((unint64_t)a2[5] << 8) | a2[6] | ((unint64_t)*a2 << 48);
  v6 = sub_1000438A4();
  return (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)v6 + 384))(v6, v5, 1);
}

void sub_10069E8D0(uint64_t a1, unint64_t a2, int a3)
{
  id v6;
  int v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  const char *v11;
  void **v12;
  unint64_t v13;
  uint64_t (***v14)(_QWORD, void *, _QWORD);
  id v15;
  void *v16;
  int v17;
  NSObject *v18;
  void **v19;
  id v20;
  void *v21;
  NSObject *v22;
  id v23;
  void *v24;
  const char *v25;
  void *__p[2];
  char v27;
  _QWORD v28[2];
  uint8_t buf[4];
  void *v30;
  __int16 v31;
  void **v32;
  unsigned __int8 uu[8];
  uint64_t v34;
  uint8_t v35[16];
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  int v40;
  uuid_string_t out;

  if (*(_BYTE *)(a1 + 3718))
  {
LABEL_2:
    v40 = 0;
    v38 = 0u;
    v39 = 0u;
    v37 = 0u;
    *(_OWORD *)v35 = 0u;
    v36 = 0u;
    v28[0] = 0;
    v28[1] = 0;
    sub_10003415C((uint64_t)v28, a1 + 48);
    *(_QWORD *)uu = 0;
    v34 = 0;
    if (qword_1009778C8 != -1)
      dispatch_once(&qword_1009778C8, &stru_10093FA18);
    sub_10003F924((uint64_t)off_1009778C0, a2, 0, 1u, 0, 0, uu);
    if (uuid_is_null(uu) && os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_FAULT))
    {
      v6 = sub_100021770(a2);
      objc_claimAutoreleasedReturnValue(v6);
      sub_100719E60();
    }
    if (!uuid_is_null(uu))
    {
      v10 = qword_100999818;
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
      {
        memset(out, 0, sizeof(out));
        uuid_unparse_upper(uu, out);
        sub_100091AE8(__p, out);
        v11 = "without";
        if (a3)
          v11 = "with";
        if (v27 >= 0)
          v12 = __p;
        else
          v12 = (void **)__p[0];
        *(_DWORD *)buf = 136446466;
        v30 = (void *)v11;
        v31 = 2082;
        v32 = v12;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Security (%{public}s man-in-the-middle) was requested by device \"%{public}s\"", buf, 0x16u);
        if (v27 < 0)
          operator delete(__p[0]);
      }
      v13 = *(_QWORD *)(a1 + 456);
      if (v13 >= *(unsigned __int16 *)(a1 + 3736))
      {
        v22 = qword_100999818;
        if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
        {
          v23 = sub_100021770(a2);
          v24 = (void *)objc_claimAutoreleasedReturnValue(v23);
          *(_DWORD *)out = 134218242;
          *(_QWORD *)&out[4] = v13;
          *(_WORD *)&out[12] = 2114;
          *(_QWORD *)&out[14] = v24;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Ignoring security request as there are too many paired devices (%lu), disconnecting %{public}@", (uint8_t *)out, 0x16u);

        }
        *(_QWORD *)out = 0;
        if (qword_1009778A8 != -1)
          dispatch_once(&qword_1009778A8, &stru_10093FA38);
        if (sub_100623C54((uint64_t)off_1009778A0, uu, out))
        {
          LOBYTE(__p[0]) = 0;
          sub_100043758(__p);
          sub_1001EE69C(*(uint64_t *)out, 4835);
          sub_10004339C(__p);
          sub_100043728(__p);
        }
        if (qword_1009778A8 != -1)
          dispatch_once(&qword_1009778A8, &stru_10093FA38);
        sub_100622358((uint64_t)off_1009778A0, uu, 8u);
        goto LABEL_10;
      }
      v14 = *(uint64_t (****)(_QWORD, void *, _QWORD))(a1 + 560);
      if (v14)
      {
        v15 = sub_100030DF4(uu);
        v16 = (void *)objc_claimAutoreleasedReturnValue(v15);
        v17 = (**v14)(v14, v16, 0);

        v18 = qword_100999818;
        if (v17)
        {
          if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
          {
            memset(out, 0, sizeof(out));
            uuid_unparse_upper(uu, out);
            sub_100091AE8(__p, out);
            if (v27 >= 0)
              v19 = __p;
            else
              v19 = (void **)__p[0];
            *(_DWORD *)buf = 136446210;
            v30 = v19;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Accepting security request from device \"%{public}s\"", buf, 0xCu);
            if (v27 < 0)
              operator delete(__p[0]);
          }
          v20 = sub_100030DF4(uu);
          v21 = (void *)objc_claimAutoreleasedReturnValue(v20);
          sub_10069CDD4(a1, v21, (uint64_t)v35);

          v7 = 1;
          goto LABEL_9;
        }
      }
      else
      {
        v18 = qword_100999818;
      }
      v7 = 0;
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
LABEL_9:
        v8 = sub_1000746A4(a2);
        *(_DWORD *)out = v8;
        out[6] = BYTE6(v8);
        *(_WORD *)&out[4] = WORD2(v8);
        LOBYTE(__p[0]) = 0;
        sub_100043758(__p);
        sub_10022E0A4(out, v7, (uint64_t)v35);
        sub_100043728(__p);
LABEL_10:
        sub_100034234((uint64_t)v28);
        return;
      }
      if (*(_QWORD *)(a1 + 560))
        v25 = "there are no sessions that support it!";
      else
        v25 = "there is no listener";
      *(_DWORD *)out = 136446210;
      *(_QWORD *)&out[4] = v25;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Ignoring security request as %{public}s", (uint8_t *)out, 0xCu);
    }
    v7 = 0;
    goto LABEL_9;
  }
  v9 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)v35 = 0;
    _os_log_fault_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "We don't have root keys for LE, something's wrong, file a radar!", v35, 2u);
    if (*(_BYTE *)(a1 + 3718))
      goto LABEL_2;
    v9 = qword_100999818;
  }
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    sub_100719620();
}

void sub_10069EE04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  void *v5;
  va_list va;

  va_start(va, a5);

  sub_100034234((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_10069EE6C(uint64_t a1, unint64_t a2)
{
  int v4;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  void **v8;
  unint64_t v9;
  uint64_t (***v10)(_QWORD, void *, _QWORD);
  id v11;
  void *v12;
  char v13;
  NSObject *v14;
  id v15;
  void *v16;
  char v17;
  char v18;
  _QWORD v19[2];
  void *__p[2];
  char v21;
  uint8_t buf[4];
  void **v23;
  unsigned __int8 uu[8];
  uint64_t v25;
  uuid_string_t out;

  if (*(_BYTE *)(a1 + 3718))
  {
LABEL_2:
    v19[0] = 0;
    v19[1] = 0;
    sub_10003415C((uint64_t)v19, a1 + 48);
    *(_QWORD *)uu = 0;
    v25 = 0;
    if (qword_1009778C8 != -1)
      dispatch_once(&qword_1009778C8, &stru_10093FA18);
    sub_10003F924((uint64_t)off_1009778C0, a2, 1u, 1u, 0, 0, uu);
    if (!uuid_is_null(uu))
    {
      v7 = qword_100999818;
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
      {
        memset(out, 0, sizeof(out));
        uuid_unparse_upper(uu, out);
        sub_100091AE8(__p, out);
        v8 = v21 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)buf = 136446210;
        v23 = v8;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Received a pairing request from device \"%{public}s\"", buf, 0xCu);
        if (v21 < 0)
          operator delete(__p[0]);
      }
      v9 = *(_QWORD *)(a1 + 456);
      if (v9 >= *(unsigned __int16 *)(a1 + 3736))
      {
        v14 = qword_100999818;
        if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
        {
          v15 = sub_100021770(a2);
          v16 = (void *)objc_claimAutoreleasedReturnValue(v15);
          *(_DWORD *)out = 134218242;
          *(_QWORD *)&out[4] = v9;
          *(_WORD *)&out[12] = 2112;
          *(_QWORD *)&out[14] = v16;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Ignoring security request as there are too many paired devices (%lu), disconnecting %@", (uint8_t *)out, 0x16u);

        }
        *(_QWORD *)out = 0;
        if (qword_1009778A8 != -1)
          dispatch_once(&qword_1009778A8, &stru_10093FA38);
        if (sub_100623C54((uint64_t)off_1009778A0, uu, out))
        {
          LOBYTE(__p[0]) = 0;
          sub_100043758(__p);
          sub_1001EE69C(*(uint64_t *)out, 4835);
          sub_10004339C(__p);
          sub_100043728(__p);
        }
        if (qword_1009778A8 != -1)
          dispatch_once(&qword_1009778A8, &stru_10093FA38);
        sub_100622358((uint64_t)off_1009778A0, uu, 8u);
        goto LABEL_9;
      }
      v10 = *(uint64_t (****)(_QWORD, void *, _QWORD))(a1 + 560);
      if (v10)
      {
        v11 = sub_100030DF4(uu);
        v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
        v13 = (**v10)(v10, v12, 0);

        if ((v13 & 1) != 0)
        {
          v4 = 1;
          goto LABEL_6;
        }
      }
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
      {
        sub_1003D2DB4(uu, out);
        sub_100719EA0();
      }
    }
    v4 = 0;
LABEL_6:
    v5 = sub_1000746A4(a2);
    *(_DWORD *)buf = v5;
    BYTE2(v23) = BYTE6(v5);
    LOWORD(v23) = WORD2(v5);
    v18 = 0;
    sub_100043758(&v18);
    v17 = 0;
    if (!sub_100238F84(buf, &v17))
      sub_10022E168(buf, v4, v17 & 4 | v4);
    sub_100043728(&v18);
LABEL_9:
    sub_100034234((uint64_t)v19);
    return;
  }
  v6 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)out = 0;
    _os_log_fault_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "We don't have root keys for LE, something's wrong, file a radar!", (uint8_t *)out, 2u);
    if (*(_BYTE *)(a1 + 3718))
      goto LABEL_2;
    v6 = qword_100999818;
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    sub_100719620();
}

void sub_10069F248(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  sub_100034234((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_10069F2A8(uint64_t a1, unint64_t a2, uint64_t a3, unsigned int *a4)
{
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  int v11;
  id v12;
  NSObject *v13;
  uint64_t (***v14)(_QWORD, void *, _QWORD);
  id v15;
  void *v16;
  int v17;
  NSObject *v18;
  char *v19;
  NSObject *v20;
  void **v21;
  void **v22;
  uint64_t v23;
  id v24;
  void *v25;
  void *__p[2];
  char v27;
  void *v28[2];
  char v29;
  uint8_t v30[4];
  void **v31;
  __int16 v32;
  void **v33;
  unsigned __int8 uu[8];
  uint64_t v35;
  uint8_t buf[16];
  _BYTE v37[21];

  if (*(_BYTE *)(a1 + 3718))
    goto LABEL_2;
  v13 = qword_100999818;
  if (!os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_FAULT))
  {
LABEL_13:
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      sub_100719620();
    return;
  }
  *(_WORD *)buf = 0;
  _os_log_fault_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_FAULT, "We don't have root keys for LE, something's wrong, file a radar!", buf, 2u);
  if (!*(_BYTE *)(a1 + 3718))
  {
    v13 = qword_100999818;
    goto LABEL_13;
  }
LABEL_2:
  v8 = *a4;
  *(_QWORD *)uu = 0;
  v35 = 0;
  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_10093FA18);
  sub_10003F924((uint64_t)off_1009778C0, a2, 0, 1u, 0, 0, uu);
  if (uuid_is_null(uu))
  {
    v9 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_FAULT))
      sub_100719FEC(a2, v9);
  }
  if (uuid_is_null(uu))
    goto LABEL_8;
  v14 = *(uint64_t (****)(_QWORD, void *, _QWORD))(a1 + 560);
  if (!v14
    || (v15 = sub_100030DF4(uu),
        v16 = (void *)objc_claimAutoreleasedReturnValue(v15),
        v17 = (**v14)(v14, v16, 0),
        v16,
        !v17))
  {
    v20 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
      sub_100719F40(uu, v20);
LABEL_8:
    LOBYTE(__p[0]) = 0;
    sub_100043758(__p);
    v10 = sub_1000746A4(a2);
    LODWORD(v28[0]) = v10;
    BYTE6(v28[0]) = BYTE6(v10);
    WORD2(v28[0]) = WORD2(v10);
    v11 = sub_1002305D8(v28);
    sub_10004339C(__p);
    if (v11)
    {
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
      {
        v12 = sub_100021770(a2);
        objc_claimAutoreleasedReturnValue(v12);
        sub_100719EF0();
      }
    }
    sub_100043728(__p);
    return;
  }
  v18 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    if (a3 >= 3)
    {
      if ((_DWORD)a3 == 4)
        v19 = "Numeric Comparison";
      else
        v19 = "Out-of-band";
    }
    else
    {
      v19 = off_10093FAD8[(int)a3];
    }
    v21 = v28;
    sub_100091AE8(v28, v19);
    if (v29 < 0)
      v21 = (void **)v28[0];
    *(_OWORD *)buf = 0u;
    memset(v37, 0, sizeof(v37));
    uuid_unparse_upper(uu, (char *)buf);
    sub_100091AE8(__p, (char *)buf);
    if (v27 >= 0)
      v22 = __p;
    else
      v22 = (void **)__p[0];
    *(_DWORD *)v30 = 136446466;
    v31 = v21;
    v32 = 2082;
    v33 = v22;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Received \"%{public}s\" pairing request for device \"%{public}s\"", v30, 0x16u);
    if (v27 < 0)
      operator delete(__p[0]);
    if (v29 < 0)
      operator delete(v28[0]);
  }
  v23 = *(_QWORD *)(a1 + 560);
  v24 = sub_100030DF4(uu);
  v25 = (void *)objc_claimAutoreleasedReturnValue(v24);
  (*(void (**)(uint64_t, void *, uint64_t, uint64_t))(*(_QWORD *)v23 + 8))(v23, v25, a3, v8);

}

void sub_10069F628(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  void *v17;

  _Unwind_Resume(a1);
}

uint64_t sub_10069F67C(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  NSObject *v3;
  const char *v4;
  NSObject *v5;
  uint64_t v6;
  void **v7;
  uint64_t v8;
  id v9;
  uint64_t v10;
  uint64_t v11;
  __CFString *v12;
  uint64_t v13;
  int v14;
  __CFString *v15;
  id v16;
  void *v17;
  id v18;
  void *v19;
  id v20;
  void *v21;
  id v22;
  void *v23;
  void *v24;
  id v25;
  void *v26;
  const __CFDictionary *v27;
  __CFUserNotification *v28;
  __CFRunLoopSource *RunLoopSource;
  __CFRunLoop *Main;
  void *v32;
  void *v33;
  id v34;
  void *__p[2];
  char v36;
  _QWORD v37[2];
  _QWORD v38[7];
  _QWORD v39[7];
  __int128 buf;
  unsigned __int8 v41;

  v1 = *(_QWORD *)(a1 + 32);
  v37[0] = 0;
  v37[1] = 0;
  sub_10003415C((uint64_t)v37, v1 + 48);
  v2 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "In showAuthorizationAlert", (uint8_t *)&buf, 2u);
  }
  if (*(_QWORD *)(v1 + 3720))
  {
    v3 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      v4 = "Already busy with another notification, waiting for the current one to complete";
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, v4, (uint8_t *)&buf, 2u);
    }
  }
  else
  {
    if (!objc_msgSend(*(id *)(v1 + 3728), "count"))
    {
      v3 = qword_100999818;
      if (!os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
        return sub_100034234((uint64_t)v37);
      LOWORD(buf) = 0;
      v4 = "No more pending devices for AuthorizationAlert";
      goto LABEL_6;
    }
    v33 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v1 + 3728), "objectAtIndex:", 0));
    v5 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138543362;
      *(_QWORD *)((char *)&buf + 4) = v33;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Display Compromised device alert for %{public}@ ", (uint8_t *)&buf, 0xCu);
    }
    if (qword_1009778C8 != -1)
      dispatch_once(&qword_1009778C8, &stru_10093FA18);
    sub_10000602C((uint64_t)off_1009778C0, v33, (uint64_t)&buf);
    v6 = v41;
    if ((v41 & 0x80u) != 0)
      v6 = *((_QWORD *)&buf + 1);
    if (v6)
    {
      if (qword_1009778C8 != -1)
        dispatch_once(&qword_1009778C8, &stru_10093FA18);
      sub_10000602C((uint64_t)off_1009778C0, v33, (uint64_t)__p);
      if (v36 >= 0)
        v7 = __p;
      else
        v7 = (void **)__p[0];
      v32 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v7));
      if (v36 < 0)
        operator delete(__p[0]);
    }
    else
    {
      if (qword_1009778C8 != -1)
        dispatch_once(&qword_1009778C8, &stru_10093FA18);
      v8 = sub_1000589DC((uint64_t)off_1009778C0, v33, 0);
      v9 = sub_100021770(v8);
      v32 = (void *)objc_claimAutoreleasedReturnValue(v9);
    }
    if ((char)v41 < 0)
      operator delete((void *)buf);
    v10 = sub_10003BE44();
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v10 + 328))(v10))
    {
      v11 = sub_10003BE44();
      if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v11 + 368))(v11) & 1) != 0)
      {
        v12 = CFSTR("iPod");
      }
      else
      {
        v13 = sub_10003BE44();
        v14 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v13 + 360))(v13);
        v15 = CFSTR("iPhone");
        if (v14)
          v15 = CFSTR("iPad");
        v12 = v15;
      }
    }
    else
    {
      v12 = CFSTR("iDevice");
    }
    LODWORD(buf) = 0;
    v16 = sub_100355F10(CFSTR("COMPROMISED_DEVICE_TITLE"), CFSTR("Bluetooth Security Alert"));
    v17 = (void *)objc_claimAutoreleasedReturnValue(v16);
    v18 = sub_100355F10(CFSTR("COMPROMISED_DEVICE_ALLOW"), CFSTR("Allow"));
    v19 = (void *)objc_claimAutoreleasedReturnValue(v18);
    v20 = sub_100355F10(CFSTR("COMPROMISED_DEVICE_DONT_ALLOW"), CFSTR("Don't Allow"));
    v21 = (void *)objc_claimAutoreleasedReturnValue(v20);
    v22 = sub_100355F10(CFSTR("COMPROMISED_DEVICE_AUTHORIZATION_MESSAGE"), CFSTR("\"%@\" is trying to connect using an unsecured Bluetooth connection. Unsecured Bluetooth accessories can be used to control your %@ or gain access to your data."));
    v23 = (void *)objc_claimAutoreleasedReturnValue(v22);
    v34 = 0;
    v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithValidatedFormat:validFormatSpecifiers:error:](NSString, "stringWithValidatedFormat:validFormatSpecifiers:error:", v23, CFSTR("%@%@"), &v34, v32, v12));
    v25 = v34;

    if (v24)
    {
      v38[0] = kCFUserNotificationAlertTopMostKey;
      v38[1] = SBUserNotificationAllowMenuButtonDismissal;
      v39[0] = &__kCFBooleanTrue;
      v39[1] = &__kCFBooleanTrue;
      v38[2] = SBUserNotificationDismissOnLock;
      v38[3] = kCFUserNotificationAlertHeaderKey;
      v39[2] = &__kCFBooleanTrue;
      v39[3] = v17;
      v38[4] = kCFUserNotificationAlertMessageKey;
      v38[5] = kCFUserNotificationDefaultButtonTitleKey;
      v39[4] = v24;
      v39[5] = v21;
      v38[6] = kCFUserNotificationAlternateButtonTitleKey;
      v39[6] = v19;
      v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v39, v38, 7));
      v27 = (const __CFDictionary *)objc_msgSend(v26, "mutableCopy");

      v28 = CFUserNotificationCreate(kCFAllocatorDefault, 0.0, 3uLL, (SInt32 *)&buf, v27);
      *(_QWORD *)(v1 + 3720) = v28;
      RunLoopSource = CFUserNotificationCreateRunLoopSource(kCFAllocatorDefault, v28, (CFUserNotificationCallBack)sub_10069FCC4, 0);
      if (RunLoopSource)
      {
        Main = CFRunLoopGetMain();
        CFRunLoopAddSource(Main, RunLoopSource, kCFRunLoopCommonModes);
        CFRelease(RunLoopSource);
      }
      else
      {
        CFUserNotificationCancel(v28);
        CFRelease(v28);
      }

    }
    else if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
    {
      sub_10071A078();
    }

  }
  return sub_100034234((uint64_t)v37);
}

void sub_10069FBE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20)
{
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;

  sub_100034234((uint64_t)&a20);
  _Unwind_Resume(a1);
}

void sub_10069FCC4(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD v5[6];

  if (qword_1009778B8 != -1)
    dispatch_once(&qword_1009778B8, &stru_10093F9D8);
  v3 = qword_1009778B0;
  v4 = sub_1000419F4();
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = sub_10069FD54;
  v5[3] = &unk_100918090;
  v5[4] = v3;
  v5[5] = a2;
  sub_100041A34(v4, v5);
}

void sub_10069FD54(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  NSObject *v4;
  void *v5;
  const char *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  _BYTE v10[24];
  void *v11;
  uint64_t v12;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v2 + 3728), "objectAtIndex:", 0));
  v4 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    v5 = *(void **)(a1 + 40);
    v6 = "unknown";
    if (!v5)
      v6 = "Disallow";
    *(_DWORD *)v10 = 138543874;
    *(_QWORD *)&v10[4] = v3;
    if (v5 == (void *)1)
      v6 = "Allow";
    *(_WORD *)&v10[12] = 2082;
    *(_QWORD *)&v10[14] = v6;
    *(_WORD *)&v10[22] = 2048;
    v11 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "User responded to authorization notification for device \"%{public}@\" with %{public}s (%ld) button", v10, 0x20u);
  }
  v7 = *(_QWORD *)(a1 + 40);
  if (v7 != 1)
  {
    if (v7)
    {
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
        sub_10071A0DC();
    }
    else
    {
      if (qword_1009778A8 != -1)
        dispatch_once(&qword_1009778A8, &stru_10093FA38);
      v8 = off_1009778A0;
      sub_100030BCC(v10, v3);
      sub_100622358((uint64_t)v8, v10, 7u);
    }
  }
  sub_10069FF5C(v2, v3);
  CFRelease(*(CFTypeRef *)(v2 + 3720));
  *(_QWORD *)(v2 + 3720) = 0;
  if (objc_msgSend(*(id *)(v2 + 3728), "count"))
  {
    v9 = sub_1000419F4();
    *(_QWORD *)v10 = _NSConcreteStackBlock;
    *(_QWORD *)&v10[8] = 3221225472;
    *(_QWORD *)&v10[16] = sub_10069F67C;
    v11 = &unk_100917378;
    v12 = v2;
    sub_100041A34(v9, v10);
  }

}

void sub_10069FF40(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_10069FF5C(uint64_t a1, void *a2)
{
  id v3;
  id v4;
  id v5;
  uint64_t v6;
  void *i;
  void *v8;
  void *v9;
  void *v10;
  unsigned int v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  _BYTE v16[128];

  v3 = a2;
  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  v4 = *(id *)(a1 + 3728);
  v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
  if (v5)
  {
    v6 = *(_QWORD *)v13;
    while (2)
    {
      for (i = 0; i != v5; i = (char *)i + 1)
      {
        if (*(_QWORD *)v13 != v6)
          objc_enumerationMutation(v4);
        v8 = *(void **)(*((_QWORD *)&v12 + 1) + 8 * (_QWORD)i);
        v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "UUIDString", (_QWORD)v12));
        v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "UUIDString"));
        v11 = objc_msgSend(v9, "isEqualToString:", v10);

        if (v11)
        {
          objc_msgSend(*(id *)(a1 + 3728), "removeObject:", v8);
          goto LABEL_11;
        }
      }
      v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
      if (v5)
        continue;
      break;
    }
  }
LABEL_11:

}

void sub_1006A00AC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1006A00E8(uint64_t a1, void *a2)
{
  id v3;
  id v4;
  id v5;
  uint64_t v6;
  void *v7;
  void *v8;
  void *v9;
  unsigned int v10;
  NSObject *v11;
  NSObject *v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint8_t buf[4];
  id v18;
  _BYTE v19[128];

  v3 = a2;
  v13 = 0u;
  v14 = 0u;
  v15 = 0u;
  v16 = 0u;
  v4 = *(id *)(a1 + 3728);
  v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v13, v19, 16);
  if (v5)
  {
    v6 = *(_QWORD *)v14;
    while (2)
    {
      v7 = 0;
      do
      {
        if (*(_QWORD *)v14 != v6)
          objc_enumerationMutation(v4);
        v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*((_QWORD *)&v13 + 1) + 8 * (_QWORD)v7), "UUIDString", (_QWORD)v13));
        v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "UUIDString"));
        v10 = objc_msgSend(v8, "isEqualToString:", v9);

        if (v10)
        {
          v12 = qword_100999818;
          if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138543362;
            v18 = v3;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Device '%{public}@' is present in the authorization queue.", buf, 0xCu);
          }

          goto LABEL_15;
        }
        v7 = (char *)v7 + 1;
      }
      while (v5 != v7);
      v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v13, v19, 16);
      if (v5)
        continue;
      break;
    }
  }

  v11 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138543362;
    v18 = v3;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Device '%{public}@' is not present in the authorization queue, creating device object and adding it to the queue", buf, 0xCu);
  }
  objc_msgSend(*(id *)(a1 + 3728), "addObject:", v3, (_QWORD)v13);
LABEL_15:

}

void sub_1006A02D8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1006A031C(uint64_t a1)
{
  void *v2;
  id v3;
  id v4;

  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_10093FA18);
  v2 = off_1009778C0;
  v3 = sub_100030DF4((const unsigned __int8 *)(a1 + 40));
  v4 = (id)objc_claimAutoreleasedReturnValue(v3);
  sub_100662644((uint64_t)v2, v4, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48);

}

void sub_1006A039C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint64_t sub_1006A03B0(uint64_t a1)
{
  return (***(uint64_t (****)(_QWORD, _QWORD, _QWORD))(a1 + 40))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 32), *(unsigned int *)(a1 + 48));
}

uint64_t sub_1006A03C8(uint64_t a1)
{
  if (qword_100977898 != -1)
    dispatch_once(&qword_100977898, &stru_10093FA98);
  return (*(uint64_t (**)(void *, _QWORD, _QWORD))(*(_QWORD *)off_100977890 + 64))(off_100977890, 0, *(unsigned int *)(a1 + 32));
}

uint64_t sub_1006A0424(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  id v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  NSObject *v12;
  void *v13;
  unsigned __int8 *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD v25[7];
  void *__p[2];
  uint64_t v27;
  const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) p_buf;
  __int128 buf;

  v7 = a2;
  if (sub_100699F80(a1, v7))
  {
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
      sub_10071A108();
    v8 = 168;
  }
  else if (sub_100699EA0(a1, v7))
  {
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_ERROR))
      sub_10071A16C();
    v8 = 169;
  }
  else
  {
    v9 = *(_QWORD *)(a1 + 456);
    if (v9 >= *(unsigned __int16 *)(a1 + 3736))
    {
      v12 = qword_100999818;
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 134217984;
        *(_QWORD *)((char *)&buf + 4) = v9;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Ignoring offline pairing request as there are too many paired devices (%lu)", (uint8_t *)&buf, 0xCu);
      }
      v8 = 180;
    }
    else
    {
      sub_100030BCC(&buf, v7);
      p_buf = (const unsigned __int8 *)&buf;
      v10 = sub_1006A759C((uint64_t **)(a1 + 464), (unsigned __int8 *)&buf, (uint64_t)&unk_100740F58, &p_buf);
      sub_100041698((uint64_t)(v10 + 6), a3);
      if (*(char *)(a4 + 23) < 0)
        v11 = *(_QWORD *)(a4 + 8);
      else
        v11 = *(unsigned __int8 *)(a4 + 23);
      if (v11)
      {
        if (qword_1009778C8 != -1)
          dispatch_once(&qword_1009778C8, &stru_10093FA18);
        v13 = off_1009778C0;
        sub_100030BCC(&buf, v7);
        if (*(char *)(a4 + 23) < 0)
        {
          sub_10003430C(__p, *(void **)a4, *(_QWORD *)(a4 + 8));
        }
        else
        {
          *(_OWORD *)__p = *(_OWORD *)a4;
          v27 = *(_QWORD *)(a4 + 16);
        }
        sub_10065354C((uint64_t)v13, (unsigned __int8 *)&buf, (uint64_t)__p, 2);
        if (SHIBYTE(v27) < 0)
          operator delete(__p[0]);
      }
      sub_1003965C0(*(_QWORD *)(a3 + 8), 11, &buf);
      v14 = (unsigned __int8 *)sub_10003EB18((uint64_t)&buf);
      v15 = *v14;
      v16 = v14[1];
      v17 = v14[2];
      v18 = v14[3];
      v19 = v14[4];
      v20 = v14[5];
      v21 = v14[6];
      *(_QWORD *)&buf = &off_100918258;
      if (*((_QWORD *)&buf + 1))
        sub_100056AAC(*((unsigned int **)&buf + 1));
      if (qword_1009778C8 != -1)
        dispatch_once(&qword_1009778C8, &stru_10093FA18);
      v22 = sub_1000589DC((uint64_t)off_1009778C0, v7, 0);
      v23 = sub_1000419F4();
      v25[0] = _NSConcreteStackBlock;
      v25[1] = 3221225472;
      v25[2] = sub_1006A07BC;
      v25[3] = &unk_1009210D8;
      v25[4] = a1;
      v25[5] = v22;
      v25[6] = (v15 << 48) | (v16 << 40) | (v17 << 32) | (v18 << 24) | (v19 << 16) | (v20 << 8) | v21;
      sub_100041A34(v23, v25);
      v8 = 0;
    }
  }

  return v8;
}

void sub_1006A075C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  void *v27;

  if (a22 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_1006A07BC(_QWORD *a1)
{
  uint64_t v1;
  unint64_t v2;
  unint64_t v3;
  std::string __p;

  v1 = a1[4];
  v2 = a1[5];
  v3 = a1[6];
  sub_100091AE8(&__p, "");
  sub_100697E58(v1, v2, v3, 0, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

void sub_1006A0824(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

id sub_1006A0840(uint64_t a1, unint64_t a2)
{
  void *v2;
  uint64_t v5;
  const unsigned __int8 *v6;
  __int128 *v7;
  id v8;
  int v9;
  unsigned __int8 *v10;
  const unsigned __int8 **v11;
  BOOL v12;
  NSObject *v13;
  id v14;
  id v15;
  id v16;
  uint64_t v17;
  NSObject *v18;
  id v19;
  id v20;
  id v21;
  NSObject *v22;
  id v23;
  id v24;
  id v26;
  int v27;
  __int16 v28;
  char v29;
  uint8_t buf[24];

  if ((a2 & 0xFFC00000000000) != 0x1400000000000)
  {
    v22 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
    {
      v23 = sub_100021770(a2);
      v24 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(v23));
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = objc_msgSend(v24, "UTF8String");
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "address \"%{public}s\" is not resolvable.", buf, 0xCu);

    }
LABEL_26:
    v2 = 0;
    return v2;
  }
  v5 = sub_1000746A4(a2);
  v27 = v5;
  v29 = BYTE6(v5);
  v28 = WORD2(v5);
  v6 = *(const unsigned __int8 **)(a1 + 440);
  if (v6 != (const unsigned __int8 *)(a1 + 448))
  {
    do
    {
      *(_OWORD *)buf = 0uLL;
      sub_1003965C0(*((_QWORD *)v6 + 7), 10, buf);
      if (sub_1000452EC((uint64_t)buf)
        || (v7 = (__int128 *)sub_10003EB18((uint64_t)buf), !sub_10022DD00((uint64_t)&v27, v7)))
      {
        v9 = 1;
      }
      else
      {
        v8 = sub_100030DF4(v6 + 32);
        v2 = (void *)objc_claimAutoreleasedReturnValue(v8);
        v9 = 0;
      }
      *(_QWORD *)buf = &off_100918258;
      if (*(_QWORD *)&buf[8])
        sub_100056AAC(*(unsigned int **)&buf[8]);
      if (!v9)
        return v2;
      v10 = (unsigned __int8 *)*((_QWORD *)v6 + 1);
      if (v10)
      {
        do
        {
          v11 = (const unsigned __int8 **)v10;
          v10 = *(unsigned __int8 **)v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          v11 = (const unsigned __int8 **)*((_QWORD *)v6 + 2);
          v12 = *v11 == v6;
          v6 = (const unsigned __int8 *)v11;
        }
        while (!v12);
      }
      v6 = (const unsigned __int8 *)v11;
    }
    while (v11 != (const unsigned __int8 **)(a1 + 448));
  }
  v13 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    v14 = sub_100021770(a2);
    v15 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(v14));
    v16 = objc_msgSend(v15, "UTF8String");
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = v16;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "address \"%{public}s\" is not tracked by LeDeviceManager, trying other devices now.", buf, 0xCu);

  }
  v17 = 0;
  while (!*(_BYTE *)(a1 + v17 + 620) || !sub_10022DD00((uint64_t)&v27, (__int128 *)(a1 + v17 + 597)))
  {
    v17 += 24;
    if (v17 == 3120)
    {
      v18 = qword_100999818;
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
      {
        v19 = sub_100021770(a2);
        v20 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(v19));
        v21 = objc_msgSend(v20, "UTF8String");
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = v21;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "address \"%{public}s\" could not be resolved.", buf, 0xCu);

      }
      goto LABEL_26;
    }
  }
  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_10093FA18);
  sub_10003F924((uint64_t)off_1009778C0, ((unint64_t)*(unsigned __int8 *)(a1 + v17 + 614) << 40) | ((unint64_t)*(unsigned __int8 *)(a1 + v17 + 615) << 32) | ((unint64_t)*(unsigned __int8 *)(a1 + v17 + 616) << 24) | ((unint64_t)*(unsigned __int8 *)(a1 + v17 + 617) << 16) | ((unint64_t)*(unsigned __int8 *)(a1 + v17 + 618) << 8) | *(unsigned __int8 *)(a1 + v17 + 619) | ((unint64_t)*(unsigned __int8 *)(a1 + v17 + 613) << 48), 1u, 1u, 0, 0, buf);
  v26 = sub_100030DF4(buf);
  return (id)objc_claimAutoreleasedReturnValue(v26);
}

void sub_1006A0BA0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t sub_1006A0BE8(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const unsigned __int8 *v7;
  id v8;
  void *v9;
  unsigned int v10;
  NSObject *v11;
  uint64_t v12;
  NSObject *v13;
  NSObject *v14;
  uint64_t v15;
  void *v16;
  id v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  int v22;
  id v23;
  __int128 uu2;
  uint8_t buf[24];

  v3 = a2;
  v4 = sub_1000438A4();
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v4 + 2160))(v4))
  {
    if (sub_100030864(a1, v3))
    {
      if (v3 && *(_BYTE *)(a1 + 41))
      {
        *(_OWORD *)buf = 0uLL;
        sub_10003415C((uint64_t)buf, a1 + 48);
        sub_100030BCC(&uu2, v3);
        v5 = sub_10000C5B8(a1 + 440, (unsigned __int8 *)&uu2);
        v6 = v5;
        if (a1 + 448 == v5)
        {
          v14 = qword_100999818;
          if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(uu2) = 138543362;
            *(_QWORD *)((char *)&uu2 + 4) = v3;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Device \"%{public}@\" does not have any keys for Fast IRK resolution", (uint8_t *)&uu2, 0xCu);
          }
          v12 = 1601;
        }
        else
        {
          v7 = (const unsigned __int8 *)(v5 + 32);
          v8 = sub_100030DF4((const unsigned __int8 *)(v5 + 32));
          v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
          v10 = objc_msgSend(v9, "isEqual:", v3);

          if (v10)
          {
            uu2 = 0uLL;
            sub_1003965C0(*(_QWORD *)(v6 + 56), 10, &uu2);
            if (sub_1000452EC((uint64_t)&uu2))
            {
              v11 = qword_100999818;
              if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
              {
                v22 = 138543362;
                v23 = v3;
                _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Device \"%{public}@\" has an empty IRK", (uint8_t *)&v22, 0xCu);
              }
              v12 = 1601;
            }
            else
            {
              v15 = sub_1000438A4();
              if (qword_1009778C8 != -1)
                dispatch_once(&qword_1009778C8, &stru_10093FA18);
              v16 = off_1009778C0;
              v17 = sub_100030DF4(v7);
              v18 = (void *)objc_claimAutoreleasedReturnValue(v17);
              v19 = sub_1000589DC((uint64_t)v16, v18, 0);
              v20 = sub_10003EB18((uint64_t)&uu2);
              v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v15 + 392))(v15, v19, v20, 1);

            }
            *(_QWORD *)&uu2 = &off_100918258;
            if (*((_QWORD *)&uu2 + 1))
              sub_100056AAC(*((unsigned int **)&uu2 + 1));
          }
          else
          {
            v12 = 0;
          }
        }
        sub_100034234((uint64_t)buf);
      }
      else
      {
        v12 = 0;
      }
    }
    else
    {
      v13 = qword_100999818;
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138543362;
        *(_QWORD *)&buf[4] = v3;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Device \"%{public}@\" is not paired", buf, 0xCu);
      }
      v12 = 1600;
    }
  }
  else
  {
    v12 = 1602;
  }

  return v12;
}

void sub_1006A0ED0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  void *v5;
  va_list va;

  va_start(va, a5);
  sub_100034234((uint64_t)va);

  _Unwind_Resume(a1);
}

void sub_1006A0F3C(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  NSObject *v9;
  uint32_t v10;
  NSObject *v11;
  uint64_t v12;
  _DWORD buf[3];
  __int16 v14;
  id v15;

  v5 = a4;
  if (v5)
  {
    sub_100030BCC(buf, v5);
    if (a1 + 520 == sub_10000C5B8(a1 + 512, (unsigned __int8 *)buf))
    {
      if (*(_BYTE *)(a1 + 41))
        operator new();
      v12 = qword_100999818;
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
      {
        buf[0] = 138543618;
        *(_QWORD *)&buf[1] = v5;
        v14 = 1024;
        LODWORD(v15) = 0;
        v8 = "Unable to configure IRK for \"%{public}@\" since fStarted = %d";
        v9 = v12;
        v10 = 18;
        goto LABEL_5;
      }
    }
    else
    {
      v6 = qword_100999818;
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
      {
        v7 = *(_QWORD *)(a1 + 528);
        buf[0] = 134218242;
        *(_QWORD *)&buf[1] = v7;
        v14 = 2114;
        v15 = v5;
        v8 = "IRK is already configured size=%zu, %{public}@\" ";
        v9 = v6;
        v10 = 22;
LABEL_5:
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)buf, v10);
      }
    }
  }
  else
  {
    v11 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
    {
      buf[0] = 138543362;
      *(_QWORD *)&buf[1] = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Device is nil in setTemporaryIrkForAddress IRK\"%{public}@\" ", (uint8_t *)buf, 0xCu);
    }
  }

}

void sub_1006A126C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, unsigned int *a11)
{
  void *v11;

  if (a11)
    sub_100056AAC(a11);

  _Unwind_Resume(a1);
}

uint64_t sub_1006A12D8(uint64_t a1, _DWORD *a2, _OWORD *a3)
{
  uint64_t v3;
  uint64_t i;
  BOOL v8;
  _QWORD *v9;
  _QWORD *v10;
  void *v11;
  _DWORD *v12;
  BOOL v13;
  char v14;
  BOOL v15;
  int v16;
  _QWORD *v17;
  _QWORD *v18;
  const void *v19;
  size_t v20;
  uint64_t (**v22)();
  unsigned int *v23;
  uint64_t (**v24)();
  unsigned int *v25;
  _QWORD v26[2];

  v3 = 0;
  if (a2 && a3)
  {
    v26[0] = 0;
    v26[1] = 0;
    sub_10003415C((uint64_t)v26, a1 + 48);
    for (i = 0; i != 3120; i += 24)
    {
      v8 = *(_DWORD *)(a1 + i + 613) == *a2 && *(_DWORD *)(a1 + i + 616) == *(_DWORD *)((char *)a2 + 3);
      if (v8 && *(_BYTE *)(a1 + i + 620))
      {
        *a3 = *(_OWORD *)(a1 + i + 597);
        v3 = 1;
        goto LABEL_37;
      }
    }
    v9 = *(_QWORD **)(a1 + 440);
    v10 = (_QWORD *)(a1 + 448);
    if (v9 == (_QWORD *)(a1 + 448))
    {
      v3 = 0;
    }
    else
    {
      do
      {
        v11 = objc_autoreleasePoolPush();
        v24 = 0;
        v25 = 0;
        sub_1003965C0(v9[7], 10, &v24);
        sub_1003965C0(v9[7], 11, &v22);
        v12 = (_DWORD *)sub_10003EB18((uint64_t)&v22);
        v22 = &off_100918258;
        if (v23)
          sub_100056AAC(v23);
        v13 = sub_1000452EC((uint64_t)&v24);
        if (v12)
          v14 = v13;
        else
          v14 = 1;
        if ((v14 & 1) == 0
          && (*v12 == *a2 ? (v15 = *(_DWORD *)((char *)v12 + 3) == *(_DWORD *)((char *)a2 + 3)) : (v15 = 0), v15))
        {
          v19 = (const void *)sub_10003EB18((uint64_t)&v24);
          v20 = sub_10003F8C4((uint64_t)&v24);
          memcpy(a3, v19, v20);
          v16 = 0;
        }
        else
        {
          v16 = 1;
        }
        v24 = &off_100918258;
        if (v25)
          sub_100056AAC(v25);
        objc_autoreleasePoolPop(v11);
        if (!v16)
          break;
        v17 = (_QWORD *)v9[1];
        if (v17)
        {
          do
          {
            v18 = v17;
            v17 = (_QWORD *)*v17;
          }
          while (v17);
        }
        else
        {
          do
          {
            v18 = (_QWORD *)v9[2];
            v8 = *v18 == (_QWORD)v9;
            v9 = v18;
          }
          while (!v8);
        }
        v9 = v18;
      }
      while (v18 != v10);
      v3 = v16 ^ 1u;
    }
LABEL_37:
    sub_100034234((uint64_t)v26);
  }
  return v3;
}

void sub_1006A14BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  sub_100034234((uint64_t)va);
  _Unwind_Resume(a1);
}

BOOL sub_1006A1508(uint64_t a1, void *a2, void *a3, _BYTE *a4, unint64_t *a5)
{
  id v9;
  NSObject *v10;
  _BOOL8 v11;
  const char *v12;
  uint64_t v13;
  unsigned int *v14;
  NSObject *v15;
  NSObject *v16;
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const void *v23;
  size_t v24;
  NSObject *v25;
  unint64_t v26;
  int v27;
  void **v28;
  void **v29;
  void **v30;
  uint64_t v32;
  _BOOL4 v33;
  void *__p[2];
  char v35;
  void *v36[2];
  char v37;
  uint64_t (**v38)();
  unsigned int *v39;
  uint64_t (**v40)();
  unsigned int *v41;
  _QWORD v42[2];
  uint8_t buf[4];
  id v44;
  __int16 v45;
  unint64_t v46;
  __int16 v47;
  void **v48;
  __int16 v49;
  void **v50;

  v9 = a2;
  if (sub_100030864(a1, v9))
  {
    if (sub_100699F80(a1, v9))
    {
      if (sub_100699EA0(a1, v9))
      {
        v10 = qword_100999818;
        v11 = 0;
        if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138543362;
          v44 = v9;
          v12 = "Device \"%{public}@\" pairing at the moment, keys are not complete yet";
LABEL_10:
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v12, buf, 0xCu);
          v11 = 0;
        }
      }
      else
      {
        v42[0] = 0;
        v42[1] = 0;
        sub_10003415C((uint64_t)v42, a1 + 48);
        sub_100030BCC(buf, v9);
        v13 = sub_10000C5B8(a1 + 440, buf);
        if (a1 + 448 == v13)
        {
          v16 = qword_100999818;
          v11 = 0;
          if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138543362;
            v44 = v9;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Device \"%{public}@\" does not have any keys", buf, 0xCu);
            v11 = 0;
          }
        }
        else
        {
          v14 = *(unsigned int **)(v13 + 56);
          if (v14)
            sub_10003C37C(*(_QWORD *)(v13 + 56));
          v40 = 0;
          v41 = 0;
          sub_1003965C0((uint64_t)v14, 10, &v40);
          if (sub_1000452EC((uint64_t)&v40))
          {
            v15 = qword_100999818;
            v11 = 0;
            if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 138543362;
              v44 = v9;
              _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Device \"%{public}@\" does not have an IRK", buf, 0xCu);
              v11 = 0;
            }
          }
          else
          {
            v38 = 0;
            v39 = 0;
            sub_1003965C0((uint64_t)v14, 11, &v38);
            v33 = sub_1000452EC((uint64_t)&v38);
            if (v33)
            {
              v17 = qword_100999818;
              if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 138543362;
                v44 = v9;
                _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Device \"%{public}@\" does not have an identity address", buf, 0xCu);
              }
            }
            else
            {
              v32 = *(unsigned __int8 *)(sub_10003EB18((uint64_t)&v38) + 1);
              v18 = *(unsigned __int8 *)(sub_10003EB18((uint64_t)&v38) + 2);
              v19 = *(unsigned __int8 *)(sub_10003EB18((uint64_t)&v38) + 3);
              v20 = *(unsigned __int8 *)(sub_10003EB18((uint64_t)&v38) + 4);
              v21 = *(unsigned __int8 *)(sub_10003EB18((uint64_t)&v38) + 5);
              v22 = *(unsigned __int8 *)(sub_10003EB18((uint64_t)&v38) + 6);
              *a5 = (v32 << 40) | (v18 << 32) | (v19 << 24) | (v20 << 16) | (v21 << 8) | v22 | ((unint64_t)*(unsigned __int8 *)sub_10003EB18((uint64_t)&v38) << 48);
              v23 = (const void *)sub_10003EB18((uint64_t)&v40);
              v24 = sub_10003F8C4((uint64_t)&v40);
              memcpy(a3, v23, v24);
              *a4 = sub_10003F8C4((uint64_t)&v40);
              v25 = qword_100999818;
              if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
              {
                v26 = *a5;
                sub_1000453F0((uint64_t)&v38, v36);
                v27 = v37;
                v28 = (void **)v36[0];
                sub_1000453F0((uint64_t)&v40, __p);
                v29 = v36;
                if (v27 < 0)
                  v29 = v28;
                if (v35 >= 0)
                  v30 = __p;
                else
                  v30 = (void **)__p[0];
                *(_DWORD *)buf = 138544130;
                v44 = v9;
                v45 = 2048;
                v46 = v26;
                v47 = 2080;
                v48 = v29;
                v49 = 2080;
                v50 = v30;
                _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "device %{public}@ address:%lld identity:%s IRK:%s", buf, 0x2Au);
                if (v35 < 0)
                  operator delete(__p[0]);
                if (v37 < 0)
                  operator delete(v36[0]);
              }
            }
            v11 = !v33;
            v38 = &off_100918258;
            if (v39)
              sub_100056AAC(v39);
          }
          v40 = &off_100918258;
          if (v41)
            sub_100056AAC(v41);
          if (v14)
            sub_100056AAC(v14);
        }
        sub_100034234((uint64_t)v42);
      }
    }
    else
    {
      v10 = qword_100999818;
      v11 = 0;
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138543362;
        v44 = v9;
        v12 = "Device \"%{public}@\" isn't bonded";
        goto LABEL_10;
      }
    }
  }
  else
  {
    v10 = qword_100999818;
    v11 = 0;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138543362;
      v44 = v9;
      v12 = "Device \"%{public}@\" isn't paired";
      goto LABEL_10;
    }
  }

  return v11;
}

void sub_1006A1A0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,unsigned int *a21,uint64_t a22,unsigned int *a23,char a24)
{
  void *v24;
  unsigned int *v25;

  if (a19 < 0)
    operator delete(__p);
  if (a21)
    sub_100056AAC(a21);
  if (a23)
    sub_100056AAC(a23);
  if (v25)
    sub_100056AAC(v25);
  sub_100034234((uint64_t)&a24);

  _Unwind_Resume(a1);
}

uint64_t sub_1006A1AB0(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v6;
  _QWORD *v7;
  __int128 *v8;
  _QWORD *v9;
  _QWORD *v10;
  BOOL v11;
  uint64_t i;
  NSObject *v13;
  id v14;
  id v15;
  id v16;
  uint64_t v17;
  NSObject *v18;
  id v19;
  id v20;
  int v21;
  __int16 v22;
  uint64_t v23;
  int v24;
  __int16 v25;
  uint64_t (**v27)();
  unsigned int *v28;
  int v29;
  __int16 v30;
  char v31;
  __int128 buf;
  uint8_t v33[24];

  if ((a2 & 0xFFC00000000000) == 0x1400000000000)
  {
    v6 = sub_1000746A4(a2);
    v29 = v6;
    v31 = BYTE6(v6);
    v30 = WORD2(v6);
    *(_OWORD *)v33 = 0uLL;
    sub_10003415C((uint64_t)v33, a1 + 48);
    v7 = *(_QWORD **)(a1 + 440);
    if (v7 == (_QWORD *)(a1 + 448))
    {
LABEL_13:
      for (i = 0; i != 3120; i += 24)
      {
        if (*(_BYTE *)(a1 + i + 620) && sub_10022DD00((uint64_t)&v29, (__int128 *)(a1 + i + 597)))
        {
          v17 = 0;
          v21 = *(_DWORD *)(a1 + i + 613);
          v22 = *(_WORD *)(a1 + i + 617);
          *(_BYTE *)(a3 + 6) = *(_BYTE *)(a1 + i + 619);
          *(_WORD *)(a3 + 4) = v22;
          *(_DWORD *)a3 = v21;
          goto LABEL_29;
        }
      }
      v13 = qword_100999818;
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
      {
        v14 = sub_100021770(a2);
        v15 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(v14));
        v16 = objc_msgSend(v15, "UTF8String");
        LODWORD(buf) = 136446210;
        *(_QWORD *)((char *)&buf + 4) = v16;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "address \"%{public}s\" could not be resolved.", (uint8_t *)&buf, 0xCu);

      }
      v17 = 114;
    }
    else
    {
      while (1)
      {
        buf = 0uLL;
        sub_1003965C0(v7[7], 10, &buf);
        if (!sub_1000452EC((uint64_t)&buf))
        {
          v8 = (__int128 *)sub_10003EB18((uint64_t)&buf);
          if (sub_10022DD00((uint64_t)&v29, v8))
            break;
        }
        *(_QWORD *)&buf = &off_100918258;
        if (*((_QWORD *)&buf + 1))
          sub_100056AAC(*((unsigned int **)&buf + 1));
        v9 = (_QWORD *)v7[1];
        if (v9)
        {
          do
          {
            v10 = v9;
            v9 = (_QWORD *)*v9;
          }
          while (v9);
        }
        else
        {
          do
          {
            v10 = (_QWORD *)v7[2];
            v11 = *v10 == (_QWORD)v7;
            v7 = v10;
          }
          while (!v11);
        }
        v7 = v10;
        if (v10 == (_QWORD *)(a1 + 448))
          goto LABEL_13;
      }
      sub_1003965C0(v7[7], 11, &v27);
      v23 = sub_10003EB18((uint64_t)&v27);
      v27 = &off_100918258;
      if (v28)
        sub_100056AAC(v28);
      v24 = *(_DWORD *)v23;
      v25 = *(_WORD *)(v23 + 4);
      *(_BYTE *)(a3 + 6) = *(_BYTE *)(v23 + 6);
      *(_WORD *)(a3 + 4) = v25;
      *(_DWORD *)a3 = v24;
      *(_QWORD *)&buf = &off_100918258;
      if (*((_QWORD *)&buf + 1))
        sub_100056AAC(*((unsigned int **)&buf + 1));
      v17 = 0;
    }
LABEL_29:
    sub_100034234((uint64_t)v33);
  }
  else
  {
    v18 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
    {
      v19 = sub_100021770(a2);
      v20 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(v19));
      *(_DWORD *)v33 = 136446210;
      *(_QWORD *)&v33[4] = objc_msgSend(v20, "UTF8String");
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "address \"%{public}s\" is not resolvable.", v33, 0xCu);

    }
    return 114;
  }
  return v17;
}

void sub_1006A1D90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, unsigned int *a4, uint64_t a5, uint64_t a6, unsigned int *a7, ...)
{
  va_list va;

  va_start(va, a7);
  if (a4)
    sub_100056AAC(a4);
  if (a7)
    sub_100056AAC(a7);
  sub_100034234((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1006A1E00(uint64_t a1, uint64_t a2, int a3, _OWORD *a4, _OWORD *a5, int a6, int a7, uint64_t a8)
{
  NSObject *v16;
  _BOOL4 v17;
  _BYTE *v18;
  _OWORD *v19;
  _OWORD *v20;
  _OWORD *v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD v25[6];
  _QWORD v26[9];
  char v27;
  char v28;
  _OWORD buf[5];
  _BYTE v30[12];
  char v31;

  v16 = qword_100999818;
  v17 = os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT);
  if (a3)
  {
    if (v17)
    {
      sub_10064960C(a2);
      v18 = v31 >= 0 ? v30 : *(_BYTE **)v30;
      LODWORD(buf[0]) = 136316675;
      *(_QWORD *)((char *)buf + 4) = v18;
      WORD6(buf[0]) = 1041;
      *(_DWORD *)((char *)buf + 14) = 16;
      WORD1(buf[1]) = 2097;
      *(_QWORD *)((char *)&buf[1] + 4) = a4;
      WORD6(buf[1]) = 1041;
      *(_DWORD *)((char *)&buf[1] + 14) = 16;
      WORD1(buf[2]) = 2097;
      *(_QWORD *)((char *)&buf[2] + 4) = a5;
      WORD6(buf[2]) = 1024;
      *(_DWORD *)((char *)&buf[2] + 14) = a6;
      WORD1(buf[3]) = 1024;
      DWORD1(buf[3]) = a7;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "LeSecurityManager::classicDevicePaired CTKD Device address:%s LTK:%{private}.16P IRK:%{private}.16P useH7:%d Auth:%d", (uint8_t *)buf, 0x38u);
      if (v31 < 0)
        operator delete(*(void **)v30);
    }
    v19 = malloc_type_malloc(0x10uLL, 0x1EFD8FA5uLL);
    v20 = malloc_type_malloc(0x10uLL, 0x7AF53DCAuLL);
    *v19 = *a5;
    *v20 = *a4;
    *(_QWORD *)&buf[0] = 0;
    *((_QWORD *)&buf[0] + 1) = buf;
    *(_QWORD *)&buf[1] = 0x4812000000;
    *((_QWORD *)&buf[1] + 1) = sub_1006A2148;
    *(_QWORD *)&buf[2] = sub_1006A2164;
    memset((char *)&buf[2] + 8, 0, 32);
    if (*(char *)(a8 + 23) < 0)
    {
      sub_10003430C(&buf[3], *(void **)a8, *(_QWORD *)(a8 + 8));
    }
    else
    {
      buf[3] = *(_OWORD *)a8;
      *(_QWORD *)&buf[4] = *(_QWORD *)(a8 + 16);
    }
    v23 = sub_1000419F4();
    v26[0] = _NSConcreteStackBlock;
    v26[1] = 3221225472;
    v26[2] = sub_1006A2178;
    v26[3] = &unk_10093F8B8;
    v27 = a7;
    v28 = a6;
    v26[6] = a2;
    v26[7] = v19;
    v26[8] = v20;
    v26[4] = buf;
    v26[5] = a1;
    sub_100041A34(v23, v26);
    _Block_object_dispose(buf, 8);
    if (SBYTE7(buf[4]) < 0)
      operator delete(*(void **)&buf[3]);
  }
  else
  {
    if (v17)
    {
      sub_10064960C(a2);
      v21 = (SBYTE7(buf[1]) & 0x80u) == 0 ? buf : *(_OWORD **)&buf[0];
      *(_DWORD *)v30 = 136315138;
      *(_QWORD *)&v30[4] = v21;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "LeSecurityManager::classicDevicePaired Non CTKD Device address:%s", v30, 0xCu);
      if (SBYTE7(buf[1]) < 0)
        operator delete(*(void **)&buf[0]);
    }
    if (_os_feature_enabled_impl("DeviceAccess", "AccessorySetupKit"))
    {
      v22 = sub_1000419F4();
      v25[0] = _NSConcreteStackBlock;
      v25[1] = 3221225472;
      v25[2] = sub_1006A2574;
      v25[3] = &unk_100918090;
      v25[4] = a1;
      v25[5] = a2;
      sub_100041A34(v22, v25);
    }
  }
  return 0;
}

void sub_1006A2118(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  _Block_object_dispose(&a25, 8);
  if (a36 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

__n128 sub_1006A2148(__n128 *a1, __n128 *a2)
{
  __n128 result;

  result = a2[3];
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a1[3] = result;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  a2[3].n128_u64[0] = 0;
  return result;
}

void sub_1006A2164(uint64_t a1)
{
  if (*(char *)(a1 + 71) < 0)
    operator delete(*(void **)(a1 + 48));
}

uint64_t sub_1006A2178(uint64_t a1)
{
  uint64_t v2;
  id v3;
  void *v4;
  BOOL v5;
  uint64_t v6;
  unsigned __int8 v7;
  unsigned __int8 v8;
  unint64_t v9;
  unsigned __int8 *v10;
  unint64_t v11;
  void *v12;
  uint64_t v13;
  void *v14;
  id v15;
  void *v16;
  void *v18[2];
  char v19;
  void *__dst[2];
  uint64_t v21;
  std::string __p;
  unsigned __int8 v23;
  unsigned __int8 v24;
  unsigned __int8 v25;
  _DWORD v26[2];
  _QWORD v27[2];
  _QWORD v28[2];

  v2 = *(_QWORD *)(a1 + 40);
  v27[0] = 0;
  v27[1] = 0;
  sub_10003415C((uint64_t)v27, v2 + 48);
  v28[0] = 0;
  v28[1] = 0;
  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_10093FA18);
  sub_10003F924((uint64_t)off_1009778C0, *(_QWORD *)(a1 + 48), 1u, 1u, 0, 0, (unsigned __int8 *)v28);
  v3 = sub_100030DF4((const unsigned __int8 *)v28);
  v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
  v5 = sub_100030864(v2, v4);

  if (!v5)
  {
    *(_DWORD *)((char *)v26 + 3) = 0;
    v26[0] = 0;
    v6 = sub_1000746A4(*(_QWORD *)(a1 + 48));
    v26[0] = v6;
    BYTE2(v26[1]) = BYTE6(v6);
    LOWORD(v26[1]) = WORD2(v6);
    v25 = 16;
    if (*(_BYTE *)(a1 + 72))
      v7 = 3;
    else
      v7 = 2;
    v24 = v7;
    if (*(_BYTE *)(a1 + 73))
      v8 = 2;
    else
      v8 = 1;
    v23 = v8;
    sub_10069DDAC(v2, *(_QWORD *)(a1 + 48), 10, *(unsigned __int8 **)(a1 + 56), 0x10u, 0);
    v9 = *(_QWORD *)(a1 + 48);
    sub_10003994C(&__p, v26, 7uLL);
    v10 = (unsigned __int8 *)sub_10003EB18((uint64_t)&__p);
    sub_10069DDAC(v2, v9, 11, v10, 7u, 0);
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_100918258;
    if (__p.__r_.__value_.__l.__size_)
      sub_100056AAC((unsigned int *)__p.__r_.__value_.__l.__size_);
    sub_10069DDAC(v2, *(_QWORD *)(a1 + 48), 5, *(unsigned __int8 **)(a1 + 64), 0x10u, 0);
    sub_10069DDAC(v2, *(_QWORD *)(a1 + 48), 6, &v25, 1u, 0);
    sub_10069DDAC(v2, *(_QWORD *)(a1 + 48), 7, &v24, 1u, 0);
    sub_10069DDAC(v2, *(_QWORD *)(a1 + 48), 16, &v23, 1u, 0);
    v11 = *(_QWORD *)(a1 + 48);
    sub_100091AE8(&__p, "");
    sub_100697E58(v2, v11, v11, 0, &__p);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if (qword_1009778C8 != -1)
      dispatch_once(&qword_1009778C8, &stru_10093FA18);
    v12 = off_1009778C0;
    v13 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    if (*(char *)(v13 + 71) < 0)
    {
      sub_10003430C(__dst, *(void **)(v13 + 48), *(_QWORD *)(v13 + 56));
    }
    else
    {
      *(_OWORD *)__dst = *(_OWORD *)(v13 + 48);
      v21 = *(_QWORD *)(v13 + 64);
    }
    sub_10065354C((uint64_t)v12, (unsigned __int8 *)v28, (uint64_t)__dst, 2);
    if (SHIBYTE(v21) < 0)
      operator delete(__dst[0]);
    if (qword_1009778C8 != -1)
      dispatch_once(&qword_1009778C8, &stru_10093FA18);
    v14 = off_1009778C0;
    v15 = sub_100030DF4((const unsigned __int8 *)v28);
    v16 = (void *)objc_claimAutoreleasedReturnValue(v15);
    sub_100091AE8(v18, "_CTKD_");
    sub_1006576F0((uint64_t)v14, v16, (unsigned __int8 *)v18);
    if (v19 < 0)
      operator delete(v18[0]);

  }
  free(*(void **)(a1 + 56));
  free(*(void **)(a1 + 64));
  return sub_100034234((uint64_t)v27);
}

void sub_1006A24CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  void *v28;
  uint64_t v29;

  if (a15 < 0)
    operator delete(__p);

  sub_100034234(v29 - 88);
  _Unwind_Resume(a1);
}

uint64_t sub_1006A2574(uint64_t a1)
{
  uint64_t v2;
  id v3;
  id v4;
  uint64_t v5;
  void *v6;
  id v7;
  void *v8;
  void *v9;
  int v10;
  id v11;
  void *v12;
  id obj;
  void *__p[2];
  char v16;
  void *v17[2];
  char v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  _QWORD v23[2];
  _BYTE v24[128];

  v2 = *(_QWORD *)(a1 + 32);
  v23[0] = 0;
  v23[1] = 0;
  sub_10003415C((uint64_t)v23, v2 + 48);
  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_10093FA18);
  v3 = sub_100658F98((uint64_t)off_1009778C0, &off_100961338);
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  obj = (id)objc_claimAutoreleasedReturnValue(v3);
  v4 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v19, v24, 16);
  if (v4)
  {
    v5 = *(_QWORD *)v20;
    do
    {
      v6 = 0;
      do
      {
        if (*(_QWORD *)v20 != v5)
          objc_enumerationMutation(obj);
        v7 = *(id *)(*((_QWORD *)&v19 + 1) + 8 * (_QWORD)v6);
        if (qword_1009778C8 != -1)
          dispatch_once(&qword_1009778C8, &stru_10093FA18);
        v8 = off_1009778C0;
        sub_100091AE8(v17, "DA_ASK_RETAIN_DEVICE");
        if (sub_10000628C((uint64_t)v8, v7, (uint64_t)v17))
        {
          if (qword_1009778C8 != -1)
            dispatch_once(&qword_1009778C8, &stru_10093FA18);
          v9 = off_1009778C0;
          sub_100091AE8(__p, "_CTKD_");
          v10 = sub_10000628C((uint64_t)v9, v7, (uint64_t)__p) ^ 1;
          if (v16 < 0)
            operator delete(__p[0]);
        }
        else
        {
          v10 = 0;
        }
        if (v18 < 0)
        {
          operator delete(v17[0]);
          if (!v10)
            goto LABEL_29;
        }
        else if (!v10)
        {
          goto LABEL_29;
        }
        if (qword_1009778C8 != -1)
          dispatch_once(&qword_1009778C8, &stru_10093FA18);
        v11 = sub_1006591DC((uint64_t)off_1009778C0, v7, CFSTR("ASK_RELATED_RADIO_ADDRESS"));
        v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
        if (*(_QWORD *)(a1 + 40) == sub_100649C7C(v12))
        {
          if (qword_1009778C8 != -1)
            dispatch_once(&qword_1009778C8, &stru_10093FA18);
          sub_1006592E8((uint64_t)off_1009778C0, v7, CFSTR("ASK_LINKED_RADIO_ADDRESS"), v12);
          if (qword_1009778C8 != -1)
            dispatch_once(&qword_1009778C8, &stru_10093FA18);
          sub_1006592E8((uint64_t)off_1009778C0, v7, CFSTR("ASK_RELATED_RADIO_ADDRESS"), 0);
        }

LABEL_29:
        v6 = (char *)v6 + 1;
      }
      while (v4 != v6);
      v4 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v19, v24, 16);
    }
    while (v4);
  }

  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_10093FA18);
  sub_1006548AC((uint64_t)off_1009778C0, 0);

  return sub_100034234((uint64_t)v23);
}

void sub_1006A28AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{

  sub_100034234((uint64_t)&a31);
  _Unwind_Resume(a1);
}

uint64_t sub_1006A293C(uint64_t a1, uint64_t a2, int a3)
{
  NSObject *v6;
  id v7;
  void *v8;
  uint64_t result;
  id v10;
  void *v11;
  BOOL v12;
  void *v13;
  id v14;
  void *v15;
  int v16;
  NSObject *v17;
  void *v18;
  id v19;
  void *v20;
  uint64_t v21;
  void *v22;
  id v23;
  void *v24;
  char v25;
  uint64_t v26;
  _QWORD v27[6];
  void *v28[2];
  char v29;
  uint8_t v30[16];
  void *__p[2];
  char v32;
  _QWORD v33[5];
  unsigned __int8 v34[16];
  _BYTE buf[18];

  v6 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    v7 = sub_100649588(a2);
    v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
    *(_DWORD *)buf = 138543618;
    *(_QWORD *)&buf[4] = v8;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Trying to unpair classic device %{public}@ ctkd:%d", buf, 0x12u);

  }
  if (a2)
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = 0;
    if (qword_1009778C8 != -1)
      dispatch_once(&qword_1009778C8, &stru_10093FA18);
    sub_10003F924(buf, off_1009778C0, a2, 0, 1, 0, 0);
    if (uuid_is_null(buf))
      return 101;
    if (a3)
    {
      v10 = sub_100030DF4(buf);
      v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
      v12 = sub_100030864(a1, v11);

      if (v12)
      {
        if (qword_1009778C8 != -1)
          dispatch_once(&qword_1009778C8, &stru_10093FA18);
        v13 = off_1009778C0;
        v14 = sub_100030DF4(buf);
        v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
        sub_100091AE8(__p, "_CTKD_");
        v16 = sub_10000628C((uint64_t)v13, v15, (uint64_t)__p);
        if (v32 < 0)
          operator delete(__p[0]);

        if (v16)
        {
          v17 = qword_100999818;
          if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)v30 = 0;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Removing _CTKD_ Tag", v30, 2u);
          }
          if (qword_1009778C8 != -1)
            dispatch_once(&qword_1009778C8, &stru_10093FA18);
          v18 = off_1009778C0;
          v19 = sub_100030DF4(buf);
          v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
          sub_100653B18((uint64_t)v18, v20, CFSTR("_CTKD_"));

          v21 = sub_1000419F4();
          v33[0] = _NSConcreteStackBlock;
          v33[1] = 3321888768;
          v33[2] = sub_1006A2D28;
          v33[3] = &unk_100922AB8;
          v33[4] = a1;
          uuid_copy(v34, buf);
          sub_100023D84(v21, v33);
        }
      }
    }
    else
    {
      result = _os_feature_enabled_impl("DeviceAccess", "AccessorySetupKit");
      if (!(_DWORD)result)
        return result;
      if (qword_1009778C8 != -1)
        dispatch_once(&qword_1009778C8, &stru_10093FA18);
      v22 = off_1009778C0;
      v23 = sub_100030DF4(buf);
      v24 = (void *)objc_claimAutoreleasedReturnValue(v23);
      sub_100091AE8(v28, "_CTKD_");
      v25 = sub_10000628C((uint64_t)v22, v24, (uint64_t)v28);
      if (v29 < 0)
        operator delete(v28[0]);

      if ((v25 & 1) == 0)
      {
        v26 = sub_1000419F4();
        v27[0] = _NSConcreteStackBlock;
        v27[1] = 3221225472;
        v27[2] = sub_1006A2D80;
        v27[3] = &unk_100918090;
        v27[4] = a1;
        v27[5] = a2;
        sub_100041A34(v26, v27);
      }
    }
  }
  return 0;
}

void sub_1006A2CD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  void *v29;

  _Unwind_Resume(a1);
}

void sub_1006A2D28(uint64_t a1)
{
  uint64_t v1;
  id v2;
  id v3;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = sub_100030DF4((const unsigned __int8 *)(a1 + 40));
  v3 = (id)objc_claimAutoreleasedReturnValue(v2);
  sub_100699674(v1, v3);

}

void sub_1006A2D6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1006A2D80(uint64_t a1)
{
  id v2;
  void *v3;
  NSObject *v4;
  id v5;
  uint64_t v6;
  void *v7;
  id v8;
  id v9;
  void *v10;
  unint64_t v11;
  NSObject *v12;
  _BYTE *v13;
  NSObject *v14;
  uint64_t v15;
  id obj;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  _BYTE buf[12];
  char v22;
  uint8_t v23[4];
  id v24;
  __int16 v25;
  _BYTE *v26;
  _BYTE v27[128];

  v15 = *(_QWORD *)(a1 + 32);
  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_10093FA18);
  v2 = sub_100658F98((uint64_t)off_1009778C0, &off_100961350);
  v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  v4 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 138412290;
    *(_QWORD *)&buf[4] = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Found LE Devices linked with classic radios:%@", buf, 0xCu);
  }
  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  obj = v3;
  v5 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v17, v27, 16);
  if (v5)
  {
    v6 = *(_QWORD *)v18;
    while (2)
    {
      v7 = 0;
      do
      {
        if (*(_QWORD *)v18 != v6)
          objc_enumerationMutation(obj);
        v8 = *(id *)(*((_QWORD *)&v17 + 1) + 8 * (_QWORD)v7);
        if (qword_1009778C8 != -1)
          dispatch_once(&qword_1009778C8, &stru_10093FA18);
        v9 = sub_1006591DC((uint64_t)off_1009778C0, v8, CFSTR("ASK_LINKED_RADIO_ADDRESS"));
        v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
        v11 = sub_100649C7C(v10);
        v12 = qword_100999818;
        if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_INFO))
        {
          sub_10064960C(v11);
          v13 = buf;
          if (v22 < 0)
            v13 = *(_BYTE **)buf;
          *(_DWORD *)v23 = 138412547;
          v24 = v8;
          v25 = 2081;
          v26 = v13;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "%@ has linked address %{private}s", v23, 0x16u);
          if (v22 < 0)
            operator delete(*(void **)buf);
        }
        if (*(_QWORD *)(a1 + 40) == v11)
        {
          if (qword_1009778C8 != -1)
            dispatch_once(&qword_1009778C8, &stru_10093FA18);
          sub_1006592E8((uint64_t)off_1009778C0, v8, CFSTR("ASK_LINKED_RADIO_ADDRESS"), 0);
          if (qword_1009778C8 != -1)
            dispatch_once(&qword_1009778C8, &stru_10093FA18);
          sub_1006592E8((uint64_t)off_1009778C0, v8, CFSTR("ASK_RELATED_RADIO_ADDRESS"), 0);
          if (sub_100030864(v15, v8))
          {
            v14 = qword_100999818;
            if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)buf = 138412290;
              *(_QWORD *)&buf[4] = v8;
              _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "Unpairing LE device %@", buf, 0xCu);
            }
            sub_100699674(v15, v8);
          }
          else
          {
            if (qword_1009778C8 != -1)
              dispatch_once(&qword_1009778C8, &stru_10093FA18);
            sub_100653B18((uint64_t)off_1009778C0, v8, CFSTR("DA_ASK_RETAIN_DEVICE"));
            if (qword_1009778C8 != -1)
              dispatch_once(&qword_1009778C8, &stru_10093FA18);
            sub_100653040(off_1009778C0, v8);
          }

          goto LABEL_35;
        }

        v7 = (char *)v7 + 1;
      }
      while (v5 != v7);
      v5 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v17, v27, 16);
      if (v5)
        continue;
      break;
    }
  }
LABEL_35:

}

void sub_1006A3190(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{

  _Unwind_Resume(a1);
}

void sub_1006A31DC(uint64_t a1, void *a2)
{
  id v2;
  uint64_t v3;
  void *v4;
  char v5;
  NSObject *v6;
  _BOOL4 v7;
  char v8;
  uint64_t v9;
  uint8_t buf[4];
  id v11;

  v2 = a2;
  v3 = sub_10003BE44();
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v3 + 344))(v3))
  {
    v9 = 0;
    if (qword_1009778A8 != -1)
      dispatch_once(&qword_1009778A8, &stru_10093FA38);
    v4 = off_1009778A0;
    sub_100030BCC(buf, v2);
    if (sub_100623C54((uint64_t)v4, buf, &v9))
    {
      v8 = 0;
      sub_100043758(&v8);
      v5 = sub_1000F3970(v9);
      v6 = qword_100999818;
      v7 = os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT);
      if ((v5 & 1) != 0)
      {
        if (v7)
        {
          *(_DWORD *)buf = 138543362;
          v11 = v2;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Not disabled CTKD for device %{public}@", buf, 0xCu);
        }
      }
      else
      {
        if (v7)
        {
          *(_DWORD *)buf = 138543362;
          v11 = v2;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Warning: Disabled CTKD for device %{public}@", buf, 0xCu);
        }
        sub_10023903C(v9, 1);
      }
      sub_100043728(&v8);
    }
  }

}

void sub_1006A3360(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1006A3394()
{
  uint64_t v0;
  NSObject *v1;
  uint64_t v2;
  NSObject *v3;
  uint8_t v4[16];
  uint8_t buf[16];

  v0 = sub_100027F68();
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v0 + 176))(v0))
  {
    v1 = qword_100999930;
    if (os_log_type_enabled((os_log_t)qword_100999930, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "checkCTDebugVectors started", buf, 2u);
    }
  }
  v2 = sub_100027F68();
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v2 + 176))(v2))
  {
    v3 = qword_100999930;
    if (os_log_type_enabled((os_log_t)qword_100999930, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "checkCTDebugVectors completed!", v4, 2u);
    }
  }
}

uint64_t sub_1006A345C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  _QWORD v7[2];

  v7[0] = 0;
  v7[1] = 0;
  v5 = sub_1006A34D8(a1, (uint64_t)v7, 0x10uLL, 0);
  return sub_1006A3710(v5, (uint64_t)v7, 0, a2, a3);
}

uint64_t sub_1006A34D8(uint64_t a1, uint64_t a2, unint64_t a3, char a4)
{
  char v7;
  unsigned int v8;
  uint64_t v9;
  NSObject *v10;
  int v11;
  int v12;
  id v13;
  void *v14;
  void *v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  int v21;
  int v22;
  __int16 v23;
  _BYTE v24[10];

  v7 = sub_1006A4354(a1) ^ 1 | a4;
  v8 = ((CFAbsoluteTimeGetCurrent() + kCFAbsoluteTimeIntervalSince1970) / 600.0)
     / *(_DWORD *)(a1 + 32)
     * *(_DWORD *)(a1 + 32);
  v9 = sub_100027F68();
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v9 + 184))(v9))
  {
    v10 = qword_100999930;
    if (os_log_type_enabled((os_log_t)qword_100999930, OS_LOG_TYPE_DEFAULT))
    {
      v12 = *(_DWORD *)(a1 + 32);
      v11 = *(_DWORD *)(a1 + 36);
      v21 = 67109632;
      v22 = v8;
      v23 = 1024;
      *(_DWORD *)v24 = v11;
      *(_WORD *)&v24[4] = 1024;
      *(_DWORD *)&v24[6] = v12;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "getCurrentTEK interval=%d fENIntervalNumber=%d fEKRollingPeriod=%d", (uint8_t *)&v21, 0x14u);
    }
  }
  if ((v7 & 1) != 0
    || v8 >= *(_DWORD *)(a1 + 32) + *(_DWORD *)(a1 + 36)
    || !objc_msgSend(*(id *)(a1 + 24), "count")
    || v8 < *(_DWORD *)(a1 + 36))
  {
    *(_DWORD *)(a1 + 36) = v8;
    v13 = sub_1006A464C(a1, v8);
    v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
    sub_1006A475C(a1, v14);

  }
  v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 24), "objectAtIndex:", 0));
  v16 = v15;
  if (a3 >= 0x10)
    v17 = 16;
  else
    v17 = a3;
  objc_msgSend(v15, "getBytes:length:", a2, v17);

  v18 = sub_100027F68();
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v18 + 184))(v18))
  {
    v19 = qword_100999930;
    if (os_log_type_enabled((os_log_t)qword_100999930, OS_LOG_TYPE_DEFAULT))
    {
      v21 = 68157954;
      v22 = 16;
      v23 = 2096;
      *(_QWORD *)v24 = a2;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "getCurrentTEK returning %.16P", (uint8_t *)&v21, 0x12u);
    }
  }
  return 0;
}

void sub_1006A36F4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t sub_1006A3710(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v7;
  _QWORD v9[2];

  result = 3;
  if (a4 && a5 == 16)
  {
    v7 = a3;
    if (!(_DWORD)a3)
      v7 = ((CFAbsoluteTimeGetCurrent() + kCFAbsoluteTimeIntervalSince1970) / 600.0);
    v9[0] = 0;
    v9[1] = 0;
    ENRPIKDerive(v9, a2);
    ENRPIDerive(a4, v9, v7);
    return 0;
  }
  return result;
}

uint64_t sub_1006A37CC(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  void *v5;
  uint8_t v7[16];

  v2 = sub_100027F68();
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v2 + 176))(v2))
  {
    v3 = qword_100999930;
    if (os_log_type_enabled((os_log_t)qword_100999930, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v7 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Erasing TEK History", v7, 2u);
    }
  }
  v4 = objc_claimAutoreleasedReturnValue(+[NSMutableArray array](NSMutableArray, "array"));
  v5 = *(void **)(a1 + 24);
  *(_QWORD *)(a1 + 24) = v4;

  sub_1002FD630(12);
  sub_1006A38A8(a1);
  if (qword_10097B180 != -1)
    dispatch_once(&qword_10097B180, &stru_10093FAB8);
  return sub_10041910C((uint64_t)off_10097B178);
}

BOOL sub_1006A38A8(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int16 v10;
  char *v11;
  unint64_t v12;
  unsigned __int16 v13;
  unsigned __int16 v14;
  void *v15;
  int v16;
  int v17;
  size_t v19;

  v2 = sub_100027F68();
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v2 + 184))(v2))
  {
    v3 = qword_100999930;
    if (os_log_type_enabled((os_log_t)qword_100999930, OS_LOG_TYPE_DEBUG))
      sub_10071A290(a1, v3, v4, v5, v6, v7, v8, v9);
  }
  v10 = (unsigned __int16)objc_msgSend(*(id *)(a1 + 24), "count");
  LOWORD(v19) = 22 * v10;
  if (22 * v10)
  {
    v11 = (char *)malloc_type_malloc((unsigned __int16)(22 * v10), 0xCB64FB4DuLL);
    bzero(v11, (unsigned __int16)v19);
    if (objc_msgSend(*(id *)(a1 + 24), "count"))
    {
      v12 = 0;
      v13 = 0;
      do
      {
        v11[v13] = 21;
        v14 = v13 + 1;
        v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 24), "objectAtIndex:", v12));
        objc_msgSend(v15, "getBytes:length:", &v11[v14], 21);

        v13 = v14 + 21;
        ++v12;
      }
      while ((unint64_t)objc_msgSend(*(id *)(a1 + 24), "count") > v12);
    }
    v16 = sub_1002FD428(0xEu, (const UInt8 *)v11, (unsigned __int16)v19);
    if (v16)
    {
      v17 = v16;
      if (os_log_type_enabled((os_log_t)qword_100999928, OS_LOG_TYPE_ERROR))
        sub_10071A230();
    }
    else
    {
      v17 = sub_1002FD428(0xDu, (const UInt8 *)&v19, 2u);
      if (v17 && os_log_type_enabled((os_log_t)qword_100999928, OS_LOG_TYPE_ERROR))
        sub_10071A1D0();
    }
    free(v11);
  }
  else
  {
    if (sub_1002FD630(14) && os_log_type_enabled((os_log_t)qword_100999928, OS_LOG_TYPE_ERROR))
      sub_10071A230();
    if (sub_1002FD428(0xDu, (const UInt8 *)&v19, 2u))
    {
      if (os_log_type_enabled((os_log_t)qword_100999928, OS_LOG_TYPE_ERROR))
        sub_10071A1D0();
      v17 = 1;
    }
    else
    {
      v17 = 0;
    }
  }
  return v17 != 0;
}

void sub_1006A3AE0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id sub_1006A3AF0(uint64_t a1, char a2, int a3)
{
  uint64_t v5;
  void *v6;

  if (a3)
  {
    sub_1006A3BBC(a1);
    if (*(_BYTE *)(a1 + 41))
    {
      if (qword_10097B180 != -1)
        dispatch_once(&qword_10097B180, &stru_10093FAB8);
      if (*((_QWORD *)off_10097B178 + 10))
        sub_1006A3E1C(a1);
    }
  }
  sub_1006A3F28(a1);
  if ((a2 & 1) != 0)
    v5 = 0;
  else
    v5 = sub_1006A4354(a1);
  if (objc_msgSend(*(id *)(a1 + 24), "count"))
    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 24), "subarrayWithRange:", v5, (char *)objc_msgSend(*(id *)(a1 + 24), "count") - v5));
  else
    v6 = &__NSArray0__struct;
  return v6;
}

uint64_t sub_1006A3BBC(uint64_t a1)
{
  id *v2;
  void *v3;
  int v4;
  int v5;
  int v6;
  double Current;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  NSObject *v11;
  id v12;
  void *v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD v24[3];

  if (sub_1006A4354(a1))
  {
    memset(&v24[1], 0, 13);
    v2 = (id *)(a1 + 24);
    v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 24), "objectAtIndex:", 0, 0, 0));
    objc_msgSend(v3, "getBytes:length:", v24, 21);

    v4 = LOBYTE(v24[2]);
    LODWORD(v3) = BYTE1(v24[2]);
    v5 = BYTE2(v24[2]);
    v6 = BYTE3(v24[2]);
    Current = CFAbsoluteTimeGetCurrent();
    v8 = sub_100027F68();
    v9 = ((Current + kCFAbsoluteTimeIntervalSince1970) / 600.0)
       - (v4 | ((_DWORD)v3 << 8) | (v5 << 16) | (v6 << 24));
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v8 + 184))(v8)
      && os_log_type_enabled((os_log_t)qword_100999930, OS_LOG_TYPE_DEBUG))
    {
      sub_10071A3E0();
    }
    if (v9 < *(_DWORD *)(a1 + 32))
    {
      BYTE4(v24[2]) = ((kCFAbsoluteTimeIntervalSince1970 + CFAbsoluteTimeGetCurrent()) / 600.0) - v4 + 1;
      v10 = sub_100027F68();
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v10 + 184))(v10))
      {
        v11 = qword_100999930;
        if (os_log_type_enabled((os_log_t)qword_100999930, OS_LOG_TYPE_DEBUG))
          sub_10071A360((uint64_t)v24, v11);
      }
      objc_msgSend(*v2, "removeObjectAtIndex:", 0);
      v12 = *v2;
      v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", v24, 21));
      objc_msgSend(v12, "insertObject:atIndex:", v13, 0);

      v14 = sub_100027F68();
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v14 + 184))(v14))
      {
        v15 = qword_100999930;
        if (os_log_type_enabled((os_log_t)qword_100999930, OS_LOG_TYPE_DEBUG))
          sub_10071A2F8((uint64_t)v2, v15, v16, v17, v18, v19, v20, v21);
      }
    }
  }
  else
  {
    v22 = sub_100027F68();
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v22 + 184))(v22)
      && os_log_type_enabled((os_log_t)qword_100999930, OS_LOG_TYPE_DEBUG))
    {
      sub_10071A440();
    }
  }
  return 0;
}

void sub_1006A3E00(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t sub_1006A3E1C(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  _DWORD v4[2];
  __int16 v5;
  _QWORD *v6;
  _QWORD v7[2];

  v7[0] = 0;
  v7[1] = 0;
  sub_1006A34D8(a1, (uint64_t)v7, 0x10uLL, 1);
  v1 = sub_100027F68();
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v1 + 184))(v1))
  {
    v2 = qword_100999930;
    if (os_log_type_enabled((os_log_t)qword_100999930, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 68157954;
      v4[1] = 16;
      v5 = 2096;
      v6 = v7;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "forceRefreshTEK new TEK:%.16P", (uint8_t *)v4, 0x12u);
    }
  }
  if (qword_10097B180 != -1)
    dispatch_once(&qword_10097B180, &stru_10093FAB8);
  return sub_10041910C((uint64_t)off_10097B178);
}

uint64_t sub_1006A3F28(uint64_t a1)
{
  double Current;
  unsigned int v2;
  uint64_t v3;
  unsigned int v4;
  void *v5;
  id v6;
  id v7;
  uint64_t v8;
  void *v9;
  id v10;
  int v11;
  id v12;
  int v13;
  id v14;
  int v15;
  id v16;
  uint64_t v17;
  unsigned int v18;
  NSObject *v19;
  uint64_t v20;
  NSObject *v21;
  uint64_t v22;
  NSObject *v23;
  uint64_t v24;
  NSObject *v25;
  id v26;
  id *locationa;
  id obj;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  uint8_t buf[4];
  id v36;
  __int16 v37;
  unsigned int v38;
  __int16 v39;
  unsigned int v40;
  __int16 v41;
  unsigned int v42;
  _BYTE v43[128];

  obj = (id)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](NSMutableArray, "array"));
  Current = CFAbsoluteTimeGetCurrent();
  v2 = *(_DWORD *)(a1 + 32);
  v3 = sub_100027F68();
  v4 = ((Current + kCFAbsoluteTimeIntervalSince1970) / 600.0) / v2 * v2 - 2016;
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v3 + 184))(v3)
    && os_log_type_enabled((os_log_t)qword_100999930, OS_LOG_TYPE_DEBUG))
  {
    sub_10071A478();
  }
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v5 = *(void **)(a1 + 24);
  locationa = (id *)(a1 + 24);
  v6 = v5;
  v7 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v31, v43, 16);
  if (v7)
  {
    v8 = *(_QWORD *)v32;
    do
    {
      v9 = 0;
      do
      {
        if (*(_QWORD *)v32 != v8)
          objc_enumerationMutation(v6);
        v10 = objc_retainAutorelease(*(id *)(*((_QWORD *)&v31 + 1) + 8 * (_QWORD)v9));
        v11 = *((unsigned __int8 *)objc_msgSend(v10, "bytes") + 16);
        v12 = objc_retainAutorelease(v10);
        v13 = *((unsigned __int8 *)objc_msgSend(v12, "bytes") + 17);
        v14 = objc_retainAutorelease(v12);
        v15 = *((unsigned __int8 *)objc_msgSend(v14, "bytes") + 18);
        v16 = objc_retainAutorelease(v14);
        LODWORD(v14) = *((unsigned __int8 *)objc_msgSend(v16, "bytes") + 19);
        v17 = sub_100027F68();
        v18 = v11 | (v13 << 8) | (v15 << 16) | ((_DWORD)v14 << 24);
        if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v17 + 184))(v17))
        {
          v19 = qword_100999930;
          if (os_log_type_enabled((os_log_t)qword_100999930, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 138413058;
            v36 = v16;
            v37 = 1024;
            v38 = v18;
            v39 = 1024;
            v40 = v4;
            v41 = 1024;
            v42 = v18 - v4;
            _os_log_debug_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "maintainTEKList key:%@ ENIN:%d oldestInterval:%d delta:%d", buf, 0x1Eu);
          }
        }
        if (v18 <= v4)
        {
          v22 = sub_100027F68();
          if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v22 + 184))(v22))
          {
            v23 = qword_100999930;
            if (os_log_type_enabled((os_log_t)qword_100999930, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 138412290;
              v36 = v16;
              _os_log_debug_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEBUG, "dropping %@ as its too old", buf, 0xCu);
            }
          }
        }
        else
        {
          v20 = sub_100027F68();
          if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v20 + 184))(v20))
          {
            v21 = qword_100999930;
            if (os_log_type_enabled((os_log_t)qword_100999930, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 138412290;
              v36 = v16;
              _os_log_debug_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEBUG, "keeping %@", buf, 0xCu);
            }
          }
          objc_msgSend(obj, "addObject:", v16);
        }
        v9 = (char *)v9 + 1;
      }
      while (v7 != v9);
      v7 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v31, v43, 16);
    }
    while (v7);
  }

  objc_storeStrong(locationa, obj);
  v24 = sub_100027F68();
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v24 + 184))(v24))
  {
    v25 = qword_100999930;
    if (os_log_type_enabled((os_log_t)qword_100999930, OS_LOG_TYPE_INFO))
    {
      v26 = *locationa;
      *(_DWORD *)buf = 138412290;
      v36 = v26;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_INFO, "updated list of keys:%@", buf, 0xCu);
    }
  }

  return 0;
}

void sub_1006A431C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  void *v16;

  _Unwind_Resume(a1);
}

id sub_1006A4354(uint64_t a1)
{
  id result;
  id v3;
  unsigned __int8 *v4;
  uint64_t v5;
  NSObject *v6;

  result = objc_msgSend(*(id *)(a1 + 24), "count");
  if (result)
  {
    v3 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 24), "objectAtIndex:", 0)));
    v4 = (unsigned __int8 *)objc_msgSend(v3, "bytes");

    v5 = sub_100027F68();
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 184))(v5))
    {
      v6 = qword_100999930;
      if (os_log_type_enabled((os_log_t)qword_100999930, OS_LOG_TYPE_DEBUG))
        sub_10071A4D8((uint64_t)v4, a1, v6);
    }
    return (id)(*(_DWORD *)(a1 + 32) == v4[20]);
  }
  return result;
}

void sub_1006A43FC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t sub_1006A440C(CFAbsoluteTime a1)
{
  if (a1 == 0.0)
    a1 = CFAbsoluteTimeGetCurrent() + kCFAbsoluteTimeIntervalSince1970;
  return (a1 / 600.0);
}

void sub_1006A4448(uint64_t a1, int a2)
{
  double Current;
  unsigned int v5;
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  id v10;
  void *v11;
  int v12;
  uint64_t v13;
  NSObject *v14;
  uint8_t buf[4];
  unsigned int v16;
  __int16 v17;
  unsigned int v18;
  __int16 v19;
  void *v20;

  objc_msgSend(*(id *)(a1 + 24), "removeAllObjects");
  Current = CFAbsoluteTimeGetCurrent();
  v5 = *(_DWORD *)(a1 + 32);
  v6 = sub_100027F68();
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v6 + 176))(v6)
    && os_log_type_enabled((os_log_t)qword_100999930, OS_LOG_TYPE_DEBUG))
  {
    sub_10071A550();
  }
  v7 = *(_DWORD *)(a1 + 32);
  if (0x90 / v7 * a2)
  {
    v8 = 0;
    v9 = ((Current + kCFAbsoluteTimeIntervalSince1970) / 600.0) / v5 * v5 - 144 * a2;
    do
    {
      v10 = sub_1006A464C(a1, v9 + v7 * v8);
      v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
      sub_1006A475C(a1, v11);
      v12 = *(_DWORD *)(a1 + 32);
      v13 = sub_100027F68();
      v9 += v12;
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v13 + 176))(v13))
      {
        v14 = qword_100999930;
        if (os_log_type_enabled((os_log_t)qword_100999930, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 67109634;
          v16 = v8;
          v17 = 1024;
          v18 = v9;
          v19 = 2112;
          v20 = v11;
          _os_log_debug_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "debugFillTEKHistory i:%d interval:%d tek:%@", buf, 0x18u);
        }
      }

      ++v8;
      v7 = *(_DWORD *)(a1 + 32);
    }
    while (v8 < 0x90 / v7 * a2);
  }
}

void sub_1006A4634(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id sub_1006A464C(uint64_t a1, int a2)
{
  uint64_t v4;
  NSObject *v5;
  _DWORD v7[2];
  __int16 v8;
  _QWORD *v9;
  __int16 v10;
  int v11;
  _QWORD __buf[3];

  memset(__buf, 0, 21);
  arc4random_buf(__buf, 0x10uLL);
  LODWORD(__buf[2]) = a2;
  BYTE4(__buf[2]) = *(_DWORD *)(a1 + 32);
  v4 = sub_100027F68();
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v4 + 184))(v4))
  {
    v5 = qword_100999930;
    if (os_log_type_enabled((os_log_t)qword_100999930, OS_LOG_TYPE_DEFAULT))
    {
      v7[0] = 68158210;
      v7[1] = 21;
      v8 = 2096;
      v9 = __buf;
      v10 = 1024;
      v11 = a2;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "createTEKForInterval outBuffer %.21P interval:%d", (uint8_t *)v7, 0x18u);
    }
  }
  return (id)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", __buf, 21));
}

void sub_1006A475C(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;

  v3 = a2;
  objc_msgSend(*(id *)(a1 + 24), "insertObject:atIndex:", v3, 0);
  v4 = sub_100027F68();
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v4 + 184))(v4)
    && os_log_type_enabled((os_log_t)qword_100999930, OS_LOG_TYPE_DEBUG))
  {
    sub_10071A5B0();
  }
  sub_1006A3F28(a1);
  sub_1006A38A8(a1);

}

void sub_1006A47F4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t sub_1006A4804(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  int v9;
  _QWORD v10[2];

  result = 3;
  if (a2 && a3 && a4)
  {
    if (a5)
    {
      v9 = 0;
      ENRPIMetadataSerialize(a3, &v9);
      v10[0] = 0;
      v10[1] = 0;
      ENAEMKDerive(v10, a2);
      ENAEMCrypt(a5, &v9, 4, v10, a4);
      return 0;
    }
  }
  return result;
}

uint64_t sub_1006A48B4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5)
{
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  NSObject *v9;
  uint32_t v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v17;
  uint8_t buf[4];
  int v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;

  v17 = 0;
  v6 = sub_1006A4A08(a1, a4, a2, a3, (uint64_t)&v17);
  if ((_DWORD)v6)
  {
    v7 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109120;
      v19 = v6;
      v8 = "decryptAEM failed with result %d";
      v9 = v7;
      v10 = 8;
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, v8, buf, v10);
    }
  }
  else
  {
    ENRPIMetadataDeserialize(a5, &v17);
    v11 = qword_100999818;
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_INFO))
    {
      v12 = *a5;
      v13 = a5[1];
      v14 = (char)a5[2];
      v15 = a5[3];
      *(_DWORD *)buf = 67109888;
      v19 = v12;
      v20 = 1024;
      v21 = v13;
      v22 = 1024;
      v23 = v14;
      v24 = 1024;
      v25 = v15;
      v8 = "decryptAEM majorVersion:%d minorVersion:%d txPower:%d calibrationConfidence:%d";
      v9 = v11;
      v10 = 26;
      goto LABEL_6;
    }
  }
  return v6;
}

uint64_t sub_1006A4A08(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  _QWORD v9[2];

  result = 3;
  if (a2 && a3 && a4)
  {
    if (a5)
    {
      v9[0] = 0;
      v9[1] = 0;
      ENAEMKDerive(v9, a3);
      ENAEMCrypt(a5, a2, 4, v9, a4);
      return 0;
    }
  }
  return result;
}

uint64_t sub_1006A4AA8(uint64_t a1, int a2)
{
  uint64_t result;
  uint64_t v5;
  NSObject *v6;
  int v7;
  _DWORD v8[2];

  result = 3;
  if ((a2 - 1) <= 0x8F && *(_DWORD *)(a1 + 32) != a2)
  {
    sub_1006A3BBC(a1);
    *(_DWORD *)(a1 + 32) = a2;
    v5 = sub_100027F68();
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 184))(v5))
    {
      v6 = qword_100999930;
      if (os_log_type_enabled((os_log_t)qword_100999930, OS_LOG_TYPE_DEFAULT))
      {
        v7 = *(_DWORD *)(a1 + 32);
        v8[0] = 67109120;
        v8[1] = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "setEKRollingPeriod new EKRollingPeriod set to %d", (uint8_t *)v8, 8u);
      }
    }
    sub_1002FD428(0xBu, (const UInt8 *)(a1 + 32), 4u);
    if (qword_10097B180 != -1)
      dispatch_once(&qword_10097B180, &stru_10093FAB8);
    sub_10041910C((uint64_t)off_10097B178);
    return 0;
  }
  return result;
}

uint64_t sub_1006A4BE0(uint64_t a1, _OWORD *a2, int a3, _QWORD *a4)
{
  int v6;
  uint64_t result;
  __int128 v8;
  uint64_t v9;
  unsigned int v10;

  if (a2 && a3 == 16)
  {
    __chkstk_darwin();
    v8 = 0uLL;
    v9 = 0;
    v10 = 0;
    v6 = sub_1002FD250(12, (UInt8 *)&v8, 24, &v10);
    result = 1;
    if (!v6 && v10 == 24)
    {
      result = 0;
      *a2 = v8;
      *a4 = v9;
    }
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_100999928, OS_LOG_TYPE_ERROR))
      sub_10071A630();
    return 3;
  }
  return result;
}

BOOL sub_1006A4CF0(uint64_t a1, uint64_t a2, int a3)
{
  __int128 *v3;
  uint64_t v4;
  __int128 v6;
  uint64_t v7;

  if (a2 && a3 == 16)
  {
    __chkstk_darwin();
    v6 = *v3;
    v7 = v4;
    return sub_1002FD428(0xCu, (const UInt8 *)&v6, 0x18u) != 0;
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_100999928, OS_LOG_TYPE_ERROR))
      sub_10071A690();
    return 1;
  }
}

NSMutableDictionary *sub_1006A4DC8(uint64_t a1, int a2)
{
  NSMutableDictionary *v3;
  void *v4;
  void *v5;
  void *v6;

  if (a2 == 1)
  {
    v3 = objc_opt_new(NSMutableDictionary);
    if (v3)
    {
      v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", 1));
      -[NSMutableDictionary setObject:forKeyedSubscript:](v3, "setObject:forKeyedSubscript:", v4, CFSTR("instance"));

      v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", a1 + 224, 16));
      -[NSMutableDictionary setObject:forKeyedSubscript:](v3, "setObject:forKeyedSubscript:", v5, CFSTR("identity"));

      v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(a1 + 240)));
      -[NSMutableDictionary setObject:forKeyedSubscript:](v3, "setObject:forKeyedSubscript:", v6, CFSTR("address"));

    }
  }
  else
  {
    v3 = 0;
  }
  return v3;
}

void sub_1006A4EA4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1006A4EC8(uint64_t a1, const unsigned __int8 **a2)
{
  const unsigned __int8 **v2;
  const unsigned __int8 *v3;
  unsigned int *v4;
  uint64_t v5;
  unsigned __int8 *v6;
  const unsigned __int8 **v7;
  BOOL v8;
  _QWORD v9[2];
  uuid_t dst;

  v2 = a2 + 1;
  v3 = *a2;
  if (*a2 != (const unsigned __int8 *)(a2 + 1))
  {
    do
    {
      v4 = (unsigned int *)*((_QWORD *)v3 + 7);
      if (v4)
        sub_10003C37C(*((_QWORD *)v3 + 7));
      memset(dst, 0, sizeof(dst));
      uuid_copy(dst, v3 + 32);
      v9[0] = &off_100934340;
      v9[1] = v4;
      if (v4)
        sub_10003C37C((uint64_t)v4);
      sub_1006A4FFC(v5, dst, (uint64_t)v9);
      v9[0] = &off_100934340;
      if (v4)
      {
        sub_100056AAC(v4);
        sub_100056AAC(v4);
      }
      v6 = (unsigned __int8 *)*((_QWORD *)v3 + 1);
      if (v6)
      {
        do
        {
          v7 = (const unsigned __int8 **)v6;
          v6 = *(unsigned __int8 **)v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          v7 = (const unsigned __int8 **)*((_QWORD *)v3 + 2);
          v8 = *v7 == v3;
          v3 = (const unsigned __int8 *)v7;
        }
        while (!v8);
      }
      v3 = (const unsigned __int8 *)v7;
    }
    while (v7 != v2);
  }
}

void sub_1006A4FC0(_Unwind_Exception *a1)
{
  unsigned int *v1;

  sub_100056AAC(v1);
  _Unwind_Resume(a1);
}

void sub_1006A4FFC(uint64_t a1, const unsigned __int8 *a2, uint64_t a3)
{
  NSObject *v5;
  void *p_p;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  char *v20;
  void *__p;
  unsigned int *v22;
  char v23;
  uint8_t buf[4];
  char *v25;
  uuid_string_t out;

  v5 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    memset(out, 0, sizeof(out));
    uuid_unparse_upper(a2, out);
    sub_100091AE8(&__p, out);
    if (v23 >= 0)
      p_p = &__p;
    else
      p_p = __p;
    *(_DWORD *)out = 136446210;
    *(_QWORD *)&out[4] = p_p;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump:    %{public}s", (uint8_t *)out, 0xCu);
    if (v23 < 0)
      operator delete(__p);
    v5 = qword_100999818;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003965C0(*(_QWORD *)(a3 + 8), 0, &__p);
    sub_1000453F0((uint64_t)&__p, out);
    if (out[23] >= 0)
      v7 = out;
    else
      v7 = *(char **)out;
    *(_DWORD *)buf = 136315138;
    v25 = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump:       Remote LTK:     %s", buf, 0xCu);
    if (out[23] < 0)
      operator delete(*(void **)out);
    __p = &off_100918258;
    if (v22)
      sub_100056AAC(v22);
    v5 = qword_100999818;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003965C0(*(_QWORD *)(a3 + 8), 1, &__p);
    sub_1000453F0((uint64_t)&__p, out);
    if (out[23] >= 0)
      v8 = out;
    else
      v8 = *(char **)out;
    *(_DWORD *)buf = 136315138;
    v25 = v8;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump:       Remote LTK len: %s", buf, 0xCu);
    if (out[23] < 0)
      operator delete(*(void **)out);
    __p = &off_100918258;
    if (v22)
      sub_100056AAC(v22);
    v5 = qword_100999818;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003965C0(*(_QWORD *)(a3 + 8), 3, &__p);
    sub_1000453F0((uint64_t)&__p, out);
    if (out[23] >= 0)
      v9 = out;
    else
      v9 = *(char **)out;
    *(_DWORD *)buf = 136315138;
    v25 = v9;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump:       Remote EDIV:    %s", buf, 0xCu);
    if (out[23] < 0)
      operator delete(*(void **)out);
    __p = &off_100918258;
    if (v22)
      sub_100056AAC(v22);
    v5 = qword_100999818;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003965C0(*(_QWORD *)(a3 + 8), 4, &__p);
    sub_1000453F0((uint64_t)&__p, out);
    if (out[23] >= 0)
      v10 = out;
    else
      v10 = *(char **)out;
    *(_DWORD *)buf = 136315138;
    v25 = v10;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump:       Remote Rand:    %s", buf, 0xCu);
    if (out[23] < 0)
      operator delete(*(void **)out);
    __p = &off_100918258;
    if (v22)
      sub_100056AAC(v22);
    v5 = qword_100999818;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003965C0(*(_QWORD *)(a3 + 8), 12, &__p);
    sub_1000453F0((uint64_t)&__p, out);
    if (out[23] >= 0)
      v11 = out;
    else
      v11 = *(char **)out;
    *(_DWORD *)buf = 136315138;
    v25 = v11;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump:       Remote CSRK:    %s", buf, 0xCu);
    if (out[23] < 0)
      operator delete(*(void **)out);
    __p = &off_100918258;
    if (v22)
      sub_100056AAC(v22);
    v5 = qword_100999818;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003965C0(*(_QWORD *)(a3 + 8), 10, &__p);
    sub_1000453F0((uint64_t)&__p, out);
    if (out[23] >= 0)
      v12 = out;
    else
      v12 = *(char **)out;
    *(_DWORD *)buf = 136315138;
    v25 = v12;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump:       Remote IRK:     %s", buf, 0xCu);
    if (out[23] < 0)
      operator delete(*(void **)out);
    __p = &off_100918258;
    if (v22)
      sub_100056AAC(v22);
    v5 = qword_100999818;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003965C0(*(_QWORD *)(a3 + 8), 11, &__p);
    sub_1000453F0((uint64_t)&__p, out);
    if (out[23] >= 0)
      v13 = out;
    else
      v13 = *(char **)out;
    *(_DWORD *)buf = 136446210;
    v25 = v13;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump:       Remote Address: %{public}s", buf, 0xCu);
    if (out[23] < 0)
      operator delete(*(void **)out);
    __p = &off_100918258;
    if (v22)
      sub_100056AAC(v22);
    v5 = qword_100999818;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003965C0(*(_QWORD *)(a3 + 8), 6, &__p);
    sub_1000453F0((uint64_t)&__p, out);
    if (out[23] >= 0)
      v14 = out;
    else
      v14 = *(char **)out;
    *(_DWORD *)buf = 136315138;
    v25 = v14;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump:       Local LTK len:  %s", buf, 0xCu);
    if (out[23] < 0)
      operator delete(*(void **)out);
    __p = &off_100918258;
    if (v22)
      sub_100056AAC(v22);
    v5 = qword_100999818;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003965C0(*(_QWORD *)(a3 + 8), 5, &__p);
    sub_1000453F0((uint64_t)&__p, out);
    if (out[23] >= 0)
      v15 = out;
    else
      v15 = *(char **)out;
    *(_DWORD *)buf = 136315138;
    v25 = v15;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump:       Local LTK:      %s", buf, 0xCu);
    if (out[23] < 0)
      operator delete(*(void **)out);
    __p = &off_100918258;
    if (v22)
      sub_100056AAC(v22);
    v5 = qword_100999818;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003965C0(*(_QWORD *)(a3 + 8), 7, &__p);
    sub_1000453F0((uint64_t)&__p, out);
    if (out[23] >= 0)
      v16 = out;
    else
      v16 = *(char **)out;
    *(_DWORD *)buf = 136315138;
    v25 = v16;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump:       Local LTK type: %s", buf, 0xCu);
    if (out[23] < 0)
      operator delete(*(void **)out);
    __p = &off_100918258;
    if (v22)
      sub_100056AAC(v22);
    v5 = qword_100999818;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003965C0(*(_QWORD *)(a3 + 8), 8, &__p);
    sub_1000453F0((uint64_t)&__p, out);
    if (out[23] >= 0)
      v17 = out;
    else
      v17 = *(char **)out;
    *(_DWORD *)buf = 136315138;
    v25 = v17;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump:       Local EDIV:     %s", buf, 0xCu);
    if (out[23] < 0)
      operator delete(*(void **)out);
    __p = &off_100918258;
    if (v22)
      sub_100056AAC(v22);
    v5 = qword_100999818;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003965C0(*(_QWORD *)(a3 + 8), 9, &__p);
    sub_1000453F0((uint64_t)&__p, out);
    if (out[23] >= 0)
      v18 = out;
    else
      v18 = *(char **)out;
    *(_DWORD *)buf = 136315138;
    v25 = v18;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump:       Local Rand:     %s", buf, 0xCu);
    if (out[23] < 0)
      operator delete(*(void **)out);
    __p = &off_100918258;
    if (v22)
      sub_100056AAC(v22);
    v5 = qword_100999818;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003965C0(*(_QWORD *)(a3 + 8), 13, &__p);
    sub_1000453F0((uint64_t)&__p, out);
    if (out[23] >= 0)
      v19 = out;
    else
      v19 = *(char **)out;
    *(_DWORD *)buf = 136315138;
    v25 = v19;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump:       Local CSRK:     %s", buf, 0xCu);
    if (out[23] < 0)
      operator delete(*(void **)out);
    __p = &off_100918258;
    if (v22)
      sub_100056AAC(v22);
    v5 = qword_100999818;
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    sub_1003965C0(*(_QWORD *)(a3 + 8), 16, &__p);
    sub_1000453F0((uint64_t)&__p, out);
    if (out[23] >= 0)
      v20 = out;
    else
      v20 = *(char **)out;
    *(_DWORD *)buf = 136315138;
    v25 = v20;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump:       deriveLKLTK:    %s", buf, 0xCu);
    if (out[23] < 0)
      operator delete(*(void **)out);
    __p = &off_100918258;
    if (v22)
      sub_100056AAC(v22);
  }
}

void sub_1006A59B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, unsigned int *a11)
{
  if (a11)
    sub_100056AAC(a11);
  _Unwind_Resume(exception_object);
}

void sub_1006A5A10(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  int v4;
  NSObject *v5;
  _BYTE *v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  NSObject *v10;
  int v11;
  int v12;
  uint64_t v13;
  NSObject *v14;
  id v15;
  uint64_t v16;
  NSObject *v17;
  _QWORD *v18;
  NSObject *v19;
  _BYTE *v20;
  const unsigned __int8 *v21;
  NSObject *v22;
  _BYTE *v23;
  const char *v24;
  unsigned __int8 *v25;
  const unsigned __int8 **v26;
  BOOL v27;
  _QWORD *v28;
  _QWORD *v29;
  NSObject *v30;
  NSObject *v31;
  NSObject *v32;
  NSObject *v33;
  uint64_t i;
  int v35;
  NSObject *v36;
  id v37;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  _QWORD *v41;
  _BYTE __p[12];
  char v43;
  _BYTE buf[50];
  __int16 v45;
  uint64_t v46;
  __int16 v47;
  int v48;
  __int16 v49;
  uint64_t v50;
  __int16 v51;
  _BYTE *v52;

  v2 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: ---------------- LE Security Manager ----------------", buf, 2u);
  }
  v3 = sub_100027F68();
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 8))(v3);
  v5 = qword_100999818;
  if (v4)
  {
    if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
    {
      sub_1000217F4(*(_QWORD *)(a1 + 216));
      if (v43 >= 0)
        v6 = __p;
      else
        v6 = *(_BYTE **)__p;
      *(_DWORD *)buf = 141560323;
      *(_QWORD *)&buf[4] = 1752392040;
      *(_WORD *)&buf[12] = 1041;
      *(_DWORD *)&buf[14] = 16;
      *(_WORD *)&buf[18] = 2097;
      *(_QWORD *)&buf[20] = a1 + 184;
      *(_WORD *)&buf[28] = 1041;
      *(_DWORD *)&buf[30] = 16;
      *(_WORD *)&buf[34] = 2097;
      *(_QWORD *)&buf[36] = a1 + 200;
      *(_WORD *)&buf[44] = 1041;
      *(_DWORD *)&buf[46] = 16;
      v45 = 2097;
      v46 = a1 + 136;
      v47 = 1041;
      v48 = 16;
      v49 = 2097;
      v50 = a1 + 168;
      v51 = 2081;
      v52 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: IRK=%{private, mask.hash}.16P DHK=%{private}.16P IR=%{private}.16P ER=%{private}.16P fLocalStaticRandomAddress:%{private}s", buf, 0x56u);
      if (v43 < 0)
        operator delete(*(void **)__p);
      v5 = qword_100999818;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 68224515;
      *(_DWORD *)&buf[4] = 96;
      *(_WORD *)&buf[8] = 2097;
      *(_QWORD *)&buf[10] = a1 + 312;
      *(_WORD *)&buf[18] = 1041;
      *(_DWORD *)&buf[20] = 64;
      *(_WORD *)&buf[24] = 2097;
      *(_QWORD *)&buf[26] = a1 + 248;
      *(_WORD *)&buf[34] = 1041;
      *(_DWORD *)&buf[36] = 16;
      *(_WORD *)&buf[40] = 2097;
      *(_QWORD *)&buf[42] = a1 + 408;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: CloudPrivate=%{private}.96P CloudPublic=%{private}.64P CloudNonce=%{private}.16P", buf, 0x32u);
      v5 = qword_100999818;
    }
  }
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v7 = *(_QWORD *)(a1 + 456);
    v8 = *(unsigned __int16 *)(a1 + 3736);
    *(_DWORD *)buf = 134218240;
    *(_QWORD *)&buf[4] = v7;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v8;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "statedump: Paired LE devices: %lu/%d", buf, 0x12u);
  }
  v9 = sub_100027F68();
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v9 + 184))(v9))
  {
    v10 = qword_100999930;
    if (os_log_type_enabled((os_log_t)qword_100999930, OS_LOG_TYPE_DEFAULT))
    {
      v11 = *(_DWORD *)(a1 + 32);
      v12 = *(_DWORD *)(a1 + 36);
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)&buf[4] = v11;
      *(_WORD *)&buf[8] = 1024;
      *(_DWORD *)&buf[10] = v12;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "statedump: fEKRollingPeriod:%d fENIntervalNumber:%d", buf, 0xEu);
    }
  }
  v13 = sub_100027F68();
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v13 + 184))(v13))
  {
    v14 = qword_100999930;
    if (os_log_type_enabled((os_log_t)qword_100999930, OS_LOG_TYPE_DEFAULT))
    {
      v15 = objc_msgSend(*(id *)(a1 + 24), "count");
      v16 = *(_QWORD *)(a1 + 24);
      *(_DWORD *)buf = 134218242;
      *(_QWORD *)&buf[4] = v15;
      *(_WORD *)&buf[12] = 2112;
      *(_QWORD *)&buf[14] = v16;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "statedump: fTEKArraySize:%zu fTEKArray:%@", buf, 0x16u);
    }
  }
  v17 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "statedump: Out-of-band devices:", buf, 2u);
  }
  v18 = *(_QWORD **)(a1 + 536);
  v40 = a1;
  v41 = (_QWORD *)(a1 + 544);
  if (v18 != (_QWORD *)(a1 + 544))
  {
    do
    {
      v19 = qword_100999818;
      if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
      {
        sub_1000340DC(v18[4], (uint64_t)buf);
        v20 = buf;
        if (buf[23] < 0)
          v20 = *(_BYTE **)buf;
        *(_DWORD *)__p = 136446210;
        *(_QWORD *)&__p[4] = v20;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "statedump:   %{public}s", __p, 0xCu);
        if ((buf[23] & 0x80000000) != 0)
          operator delete(*(void **)buf);
      }
      v21 = (const unsigned __int8 *)v18[5];
      if (v21 != (const unsigned __int8 *)(v18 + 6))
      {
        v22 = qword_100999818;
        do
        {
          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
          {
            memset(buf, 0, 37);
            uuid_unparse_upper(v21 + 32, buf);
            sub_100091AE8(__p, buf);
            v23 = __p;
            if (v43 < 0)
              v23 = *(_BYTE **)__p;
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = v23;
            _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "statedump:      %{public}s", buf, 0xCu);
            if (v43 < 0)
              operator delete(*(void **)__p);
            v22 = qword_100999818;
          }
          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
          {
            if (v21[56])
              v24 = "Yes";
            else
              v24 = "No";
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = v24;
            _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "statedump:         Enabled: %{public}s", buf, 0xCu);
            v22 = qword_100999818;
          }
          v25 = (unsigned __int8 *)*((_QWORD *)v21 + 1);
          if (v25)
          {
            do
            {
              v26 = (const unsigned __int8 **)v25;
              v25 = *(unsigned __int8 **)v25;
            }
            while (v25);
          }
          else
          {
            do
            {
              v26 = (const unsigned __int8 **)*((_QWORD *)v21 + 2);
              v27 = *v26 == v21;
              v21 = (const unsigned __int8 *)v26;
            }
            while (!v27);
          }
          v21 = (const unsigned __int8 *)v26;
        }
        while (v26 != v18 + 6);
      }
      v28 = (_QWORD *)v18[1];
      if (v28)
      {
        do
        {
          v29 = v28;
          v28 = (_QWORD *)*v28;
        }
        while (v28);
      }
      else
      {
        do
        {
          v29 = (_QWORD *)v18[2];
          v27 = *v29 == (_QWORD)v18;
          v18 = v29;
        }
        while (!v27);
      }
      v18 = v29;
    }
    while (v29 != v41);
  }
  v30 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "statedump: In-progress keys:", buf, 2u);
  }
  sub_1006A4EC8(v40, (const unsigned __int8 **)(v40 + 464));
  v31 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "statedump: Temporary Security keys:", buf, 2u);
  }
  sub_1006A4EC8(v40, (const unsigned __int8 **)(v40 + 488));
  v32 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "statedump: Temporary IRKs:", buf, 2u);
  }
  sub_1006A4EC8(v40, (const unsigned __int8 **)(v40 + 512));
  v33 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "statedump: All IRKs:", buf, 2u);
    v33 = qword_100999818;
  }
  for (i = 620; i != 3740; i += 24)
  {
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      v35 = *(unsigned __int8 *)(v40 + i);
      *(_DWORD *)buf = 68158723;
      *(_DWORD *)&buf[4] = 7;
      *(_WORD *)&buf[8] = 2096;
      *(_QWORD *)&buf[10] = v40 + i - 7;
      *(_WORD *)&buf[18] = 1041;
      *(_DWORD *)&buf[20] = 16;
      *(_WORD *)&buf[24] = 2097;
      *(_QWORD *)&buf[26] = v40 + i - 23;
      *(_WORD *)&buf[34] = 1024;
      *(_DWORD *)&buf[36] = v35;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "statedump: Device %{bluetooth:BD_ADDR}.7P with IRK %{private}.16P used:%d", buf, 0x28u);
      v33 = qword_100999818;
    }
  }
  if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "statedump: Security keys:", buf, 2u);
  }
  sub_1006A4EC8(v40, (const unsigned __int8 **)(v40 + 440));
  v36 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    v37 = sub_100021770(*(_QWORD *)(v40 + 3744));
    v38 = (void *)objc_claimAutoreleasedReturnValue(v37);
    *(_DWORD *)buf = 138543362;
    *(_QWORD *)&buf[4] = v38;
    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "statedump: Current user's RSA: %{public}@", buf, 0xCu);

  }
  if (*(_BYTE *)(v40 + 424))
  {
    v39 = *(_QWORD *)(v40 + 432);
    if (v39)
      (*(void (**)(uint64_t))(*(_QWORD *)v39 + 8))(v39);
  }
}

uint64_t sub_1006A6270(uint64_t a1, uint64_t a2, unsigned __int8 *src, uint64_t a4)
{
  uint64_t v6;

  *(_WORD *)(a1 + 8) = 1;
  *(_QWORD *)a1 = off_10093F8E8;
  *(_QWORD *)(a1 + 16) = a2;
  uuid_copy((unsigned __int8 *)(a1 + 24), src);
  v6 = *(_QWORD *)(a4 + 8);
  *(_QWORD *)(a1 + 40) = &off_100934340;
  *(_QWORD *)(a1 + 48) = v6;
  if (v6)
    sub_10003C37C(v6);
  return a1;
}

_QWORD *sub_1006A62D0(_QWORD *a1)
{
  unsigned int *v2;

  *a1 = off_10093F8E8;
  a1[5] = &off_100934340;
  v2 = (unsigned int *)a1[6];
  if (v2)
    sub_100056AAC(v2);
  return a1;
}

void sub_1006A6314(_QWORD *a1)
{
  unsigned int *v1;

  *a1 = off_10093F8E8;
  a1[5] = &off_100934340;
  v1 = (unsigned int *)a1[6];
  if (v1)
    sub_100056AAC(v1);
  operator delete();
}

void sub_1006A6368(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  id v4;
  id v5;

  if (qword_1009778B8 != -1)
    dispatch_once(&qword_1009778B8, &stru_10093F9D8);
  v2 = qword_1009778B0;
  v3 = *(_QWORD *)(a1 + 16);
  v4 = sub_100030DF4((const unsigned __int8 *)(a1 + 24));
  v5 = (id)objc_claimAutoreleasedReturnValue(v4);
  sub_10069C154(v2, v3, v5, a1 + 40);

}

void sub_1006A63F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1006A6404()
{
  sub_1000419F4();
  operator new();
}

void sub_1006A64AC(unsigned __int8 *a1)
{
  unint64_t v1;
  uint64_t v2;
  _QWORD v3[5];

  v1 = ((unint64_t)a1[1] << 40) | ((unint64_t)a1[2] << 32) | ((unint64_t)a1[3] << 24) | ((unint64_t)a1[4] << 16) | ((unint64_t)a1[5] << 8) | a1[6] | ((unint64_t)*a1 << 48);
  v2 = sub_1000419F4();
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_1006A66D8;
  v3[3] = &unk_100917378;
  v3[4] = v1;
  sub_100041A34(v2, v3);
}

void sub_1006A6540(unsigned __int8 *a1, int a2, const void *a3, size_t size)
{
  unsigned int v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  _QWORD v17[6];
  int v18;
  char v19;

  v4 = size;
  v6 = a1[1];
  v7 = a1[2];
  v8 = a1[3];
  v9 = a1[4];
  v10 = a1[5];
  v11 = a1[6];
  v12 = *a1;
  if (size >= 0x11 && os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_FAULT))
    sub_10071A6F0();
  v13 = (v6 << 40) | (v7 << 32) | (v8 << 24) | (v9 << 16) | (v10 << 8) | v11 | (v12 << 48);
  v14 = malloc_type_malloc(v4, 0x6C8E4376uLL);
  memcpy(v14, a3, v4);
  v15 = sub_1000419F4();
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 3221225472;
  v17[2] = sub_1006A6728;
  v17[3] = &unk_1009226D0;
  v18 = a2;
  v17[4] = v13;
  v17[5] = v14;
  v19 = v4;
  sub_100041A34(v15, v17);
}

void sub_1006A666C()
{
  operator delete();
}

uint64_t sub_1006A6680(uint64_t a1)
{
  if (qword_1009778B8 != -1)
    dispatch_once(&qword_1009778B8, &stru_10093F9D8);
  return sub_10069D674(qword_1009778B0, *(_QWORD *)(a1 + 16), (uint64_t *)(a1 + 24), *(unsigned __int16 *)(a1 + 32));
}

_BYTE *sub_1006A66D8(uint64_t a1)
{
  if (qword_1009778B8 != -1)
    dispatch_once(&qword_1009778B8, &stru_10093F9D8);
  return sub_10069DAE8(qword_1009778B0, *(_QWORD *)(a1 + 32));
}

void sub_1006A6728(uint64_t a1)
{
  if (qword_1009778B8 != -1)
    dispatch_once(&qword_1009778B8, &stru_10093F9D8);
  sub_10069DDAC(qword_1009778B0, *(_QWORD *)(a1 + 32), *(_DWORD *)(a1 + 48), *(unsigned __int8 **)(a1 + 40), *(unsigned __int8 *)(a1 + 52), 0);
  free(*(void **)(a1 + 40));
}

void sub_1006A678C(unsigned __int8 *a1, char a2)
{
  unint64_t v3;
  uint64_t v4;
  _QWORD v5[5];
  char v6;

  v3 = ((unint64_t)a1[1] << 40) | ((unint64_t)a1[2] << 32) | ((unint64_t)a1[3] << 24) | ((unint64_t)a1[4] << 16) | ((unint64_t)a1[5] << 8) | a1[6] | ((unint64_t)*a1 << 48);
  v4 = sub_1000419F4();
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = sub_1006A6980;
  v5[3] = &unk_100918888;
  v5[4] = v3;
  v6 = a2;
  sub_100041A34(v4, v5);
}

void sub_1006A6828(unsigned __int8 *a1)
{
  unint64_t v1;
  uint64_t v2;
  _QWORD v3[5];

  v1 = ((unint64_t)a1[1] << 40) | ((unint64_t)a1[2] << 32) | ((unint64_t)a1[3] << 24) | ((unint64_t)a1[4] << 16) | ((unint64_t)a1[5] << 8) | a1[6] | ((unint64_t)*a1 << 48);
  v2 = sub_1000419F4();
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_1006A69D4;
  v3[3] = &unk_100917378;
  v3[4] = v1;
  sub_100041A34(v2, v3);
}

void sub_1006A68BC(unsigned __int8 *a1, int a2, _OWORD *a3)
{
  unint64_t v5;
  _OWORD *v6;
  uint64_t v7;
  _QWORD v8[6];
  int v9;

  v5 = ((unint64_t)a1[1] << 40) | ((unint64_t)a1[2] << 32) | ((unint64_t)a1[3] << 24) | ((unint64_t)a1[4] << 16) | ((unint64_t)a1[5] << 8) | a1[6] | ((unint64_t)*a1 << 48);
  v6 = malloc_type_malloc(0x10uLL, 0xEE12D0D2uLL);
  *v6 = *a3;
  v7 = sub_1000419F4();
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_1006A6A24;
  v8[3] = &unk_1009180B0;
  v9 = a2;
  v8[4] = v5;
  v8[5] = v6;
  sub_100041A34(v7, v8);
}

void sub_1006A6980(uint64_t a1)
{
  if (qword_1009778B8 != -1)
    dispatch_once(&qword_1009778B8, &stru_10093F9D8);
  sub_10069E8D0(qword_1009778B0, *(_QWORD *)(a1 + 32), *(unsigned __int8 *)(a1 + 40));
}

void sub_1006A69D4(uint64_t a1)
{
  if (qword_1009778B8 != -1)
    dispatch_once(&qword_1009778B8, &stru_10093F9D8);
  sub_10069EE6C(qword_1009778B0, *(_QWORD *)(a1 + 32));
}

void sub_1006A6A24(uint64_t a1)
{
  if (qword_1009778B8 != -1)
    dispatch_once(&qword_1009778B8, &stru_10093F9D8);
  sub_10069F2A8(qword_1009778B0, *(_QWORD *)(a1 + 32), *(unsigned int *)(a1 + 48), *(unsigned int **)(a1 + 40));
  free(*(void **)(a1 + 40));
}

void sub_1006A6A80(uint64_t a1, int a2, char a3)
{
  unint64_t v6;
  int v7;
  NSObject *v8;
  void *p_p;
  uint64_t v10;
  _QWORD v11[5];
  int v12;
  char v13;
  char v14;
  void *__p;
  char v16;
  unsigned __int8 v17[8];
  uint8_t buf[4];
  uint64_t v19;
  __int16 v20;
  int v21;
  __int16 v22;
  void *v23;
  __int16 v24;
  int v25;

  *(_DWORD *)&v17[3] = 0;
  *(_DWORD *)v17 = 0;
  sub_1002214B4(a1, (uint64_t)v17, 0);
  v6 = ((unint64_t)v17[1] << 40) | ((unint64_t)v17[2] << 32) | ((unint64_t)v17[3] << 24) | ((unint64_t)v17[4] << 16) | ((unint64_t)v17[5] << 8) | v17[6] | ((unint64_t)v17[0] << 48);
  v7 = sub_1002307DC(v17);
  v8 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    sub_1000217F4(v6);
    if (v16 >= 0)
      p_p = &__p;
    else
      p_p = __p;
    *(_DWORD *)buf = 134218754;
    v19 = a1;
    v20 = 1024;
    v21 = a2;
    v22 = 2082;
    v23 = p_p;
    v24 = 1024;
    v25 = v7;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "encryptionStatusChangedCb handle:%p status=%{bluetooth:OI_STATUS}u address=%{public}s isPairing=%d", buf, 0x22u);
    if (v16 < 0)
      operator delete(__p);
  }
  v10 = sub_1000419F4();
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  v11[2] = sub_1006A6E5C;
  v11[3] = &unk_10092D0A8;
  v11[4] = v6;
  v12 = a2;
  v13 = a3;
  v14 = v7;
  sub_100041A34(v10, v11);
}

void sub_1006A6C30(unsigned __int8 *a1, unsigned __int8 *a2, int a3)
{
  unint64_t v6;
  unint64_t v7;
  NSObject *v8;
  void *v9;
  void *p_p;
  uint64_t v11;
  _QWORD v12[8];
  int v13;
  void *__p;
  char v15;
  void *v16;
  char v17;
  uint8_t buf[4];
  void *v19;
  __int16 v20;
  void *v21;
  __int16 v22;
  int v23;

  if (a2)
    v6 = ((unint64_t)a2[1] << 40) | ((unint64_t)a2[2] << 32) | ((unint64_t)a2[3] << 24) | ((unint64_t)a2[4] << 16) | ((unint64_t)a2[5] << 8) | a2[6] | ((unint64_t)*a2 << 48);
  else
    v6 = 0;
  v7 = ((unint64_t)a1[1] << 40) | ((unint64_t)a1[2] << 32) | ((unint64_t)a1[3] << 24) | ((unint64_t)a1[4] << 16) | ((unint64_t)a1[5] << 8) | a1[6] | ((unint64_t)*a1 << 48);
  v8 = qword_100999818;
  if (os_log_type_enabled((os_log_t)qword_100999818, OS_LOG_TYPE_DEFAULT))
  {
    sub_1000217F4(v7);
    sub_1000217F4(v6);
    v9 = &v16;
    if (v17 < 0)
      v9 = v16;
    if (v15 >= 0)
      p_p = &__p;
    else
      p_p = __p;
    *(_DWORD *)buf = 136446722;
    v19 = v9;
    v20 = 2082;
    v21 = p_p;
    v22 = 1024;
    v23 = a3;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "smpPairingCompleted address=%{public}s resolvedAddress:%{public}s status=%{bluetooth:OI_STATUS}u", buf, 0x1Cu);
    if (v15 < 0)
      operator delete(__p);
    if (v17 < 0)
      operator delete(v16);
  }
  sub_100238FD0(255);
  v11 = sub_1000419F4();
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_1006A6EC0;
  v12[3] = &unk_10093F948;
  v12[4] = v7;
  v12[5] = v6;
  v13 = a3;
  v12[6] = a2;
  v12[7] = a1;
  sub_100041A34(v11, v12);
}

void sub_1006A6E38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1006A6E5C(uint64_t a1)
{
  if (qword_1009778B8 != -1)
    dispatch_once(&qword_1009778B8, &stru_10093F9D8);
  sub_10069D114(qword_1009778B0, *(_QWORD *)(a1 + 32), *(_DWORD *)(a1 + 40), *(_BYTE *)(a1 + 44) != 0, *(_BYTE *)(a1 + 45));
}

void sub_1006A6EC0(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  int v5;
  unsigned __int8 *v6;
  std::string __p;

  if (qword_1009778B8 != -1)
    dispatch_once(&qword_1009778B8, &stru_10093F9D8);
  v2 = qword_1009778B0;
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(_QWORD *)(a1 + 40);
  v5 = *(_DWORD *)(a1 + 64);
  sub_100091AE8(&__p, "");
  sub_100697E58(v2, v3, v4, v5, &__p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (!*(_DWORD *)(a1 + 64) && (*(_QWORD *)(a1 + 40) || !*(_BYTE *)(a1 + 38)))
  {
    if (qword_1009778B8 != -1)
      dispatch_once(&qword_1009778B8, &stru_10093F9D8);
    v6 = *(unsigned __int8 **)(a1 + 48);
    if (!v6)
      v6 = *(unsigned __int8 **)(a1 + 56);
    sub_100693B04(qword_1009778B0, v6);
  }
}

void sub_1006A6FC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *sub_1006A6FDC(_QWORD *result)
{
  *result = off_10093F978;
  if (result[3])
    operator delete[]();
  return result;
}

void sub_1006A7024(_QWORD *a1)
{
  *a1 = off_10093F978;
  if (a1[3])
    operator delete[]();
  operator delete();
}

uint64_t sub_1006A707C(uint64_t a1)
{
  int v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *(unsigned __int8 *)(a1 + 32);
  v3 = sub_1000438A4();
  v4 = *(_QWORD *)(a1 + 16);
  if (v2)
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v3 + 384))(v3, v4, 1);
  else
    return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(*(_QWORD *)v3 + 376))(v3, v4, *(_QWORD *)(a1 + 24), 1);
}

void sub_1006A70D4()
{
  operator delete();
}

void sub_1006A70E8()
{
  if (qword_1009778B8 != -1)
    dispatch_once(&qword_1009778B8, &stru_10093F9D8);
  sub_10069B140(qword_1009778B0);
}

void sub_1006A7128(id a1)
{
  operator new();
}

void sub_1006A7168()
{
  operator delete();
}

void sub_1006A718C(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    sub_1006A718C(a1, *a2);
    sub_1006A718C(a1, a2[1]);
    sub_1006A71D4((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void sub_1006A71D4(uint64_t a1)
{
  if (*(char *)(a1 + 71) < 0)
    operator delete(*(void **)(a1 + 48));
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

void sub_1006A7228(uint64_t a1, _QWORD *a2)
{
  unsigned int *v4;

  if (a2)
  {
    sub_1006A7228(a1, *a2);
    sub_1006A7228(a1, a2[1]);
    a2[6] = &off_100934340;
    v4 = (unsigned int *)a2[7];
    if (v4)
      sub_100056AAC(v4);
    operator delete(a2);
  }
}

void sub_1006A7280(id a1)
{
  operator new();
}

void sub_1006A72C0()
{
  operator delete();
}

void sub_1006A72E4(id a1)
{
  operator new();
}

void sub_1006A7324()
{
  operator delete();
}

uint64_t *sub_1006A7348(uint64_t **a1, unsigned __int8 *uu1, uint64_t a3, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a4)
{
  uint64_t **v6;
  uint64_t *result;
  unsigned __int8 *v8[3];
  uint64_t v9;

  v9 = 0;
  v6 = (uint64_t **)sub_10000DC28((uint64_t)a1, &v9, uu1);
  result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_1006A73E8((uint64_t)a1, a4, v8);
    sub_100004078(a1, v9, v6, (uint64_t *)v8[0]);
    return (uint64_t *)v8[0];
  }
  return result;
}

void sub_1006A73E8(uint64_t a1@<X0>, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a2@<X2>, unsigned __int8 **a3@<X8>)
{
  uint64_t v5;
  _QWORD *v6;
  unsigned __int8 *v7;

  v5 = a1 + 8;
  *a3 = 0;
  a3[2] = 0;
  a3[1] = 0;
  v6 = a3 + 1;
  v7 = (unsigned __int8 *)operator new(0x40uLL);
  *a3 = v7;
  *v6 = v5;
  *((_BYTE *)a3 + 16) = 0;
  uuid_copy(v7 + 32, *a2);
  *((_QWORD *)v7 + 6) = &off_100934340;
  *((_QWORD *)v7 + 7) = 0;
  *((_BYTE *)a3 + 16) = 1;
}

void sub_1006A7464(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;

  *v1 = 0;
  sub_1006A7480(v2, v3);
  _Unwind_Resume(a1);
}

void sub_1006A7480(uint64_t a1, _QWORD *__p)
{
  unsigned int *v3;

  if (*(_BYTE *)(a1 + 8))
  {
    __p[6] = &off_100934340;
    v3 = (unsigned int *)__p[7];
    if (v3)
      sub_100056AAC(v3);
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

void sub_1006A74D4(id a1)
{
  operator new();
}

void sub_1006A7514()
{
  operator delete();
}

void sub_1006A7538(id a1)
{
  operator new();
}

void sub_1006A7578()
{
  operator delete();
}

uint64_t *sub_1006A759C(uint64_t **a1, unsigned __int8 *uu1, uint64_t a3, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a4)
{
  uint64_t **v6;
  uint64_t *result;
  unsigned __int8 *v8[3];
  uint64_t v9;

  v9 = 0;
  v6 = (uint64_t **)sub_10000DC28((uint64_t)a1, &v9, uu1);
  result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_1006A763C((uint64_t)a1, a4, v8);
    sub_100004078(a1, v9, v6, (uint64_t *)v8[0]);
    return (uint64_t *)v8[0];
  }
  return result;
}

void sub_1006A763C(uint64_t a1@<X0>, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a2@<X2>, unsigned __int8 **a3@<X8>)
{
  uint64_t v5;
  _QWORD *v6;
  unsigned __int8 *v7;

  v5 = a1 + 8;
  *a3 = 0;
  a3[2] = 0;
  a3[1] = 0;
  v6 = a3 + 1;
  v7 = (unsigned __int8 *)operator new(0x40uLL);
  *a3 = v7;
  *v6 = v5;
  *((_BYTE *)a3 + 16) = 0;
  uuid_copy(v7 + 32, *a2);
  *((_QWORD *)v7 + 6) = &off_100934340;
  *((_QWORD *)v7 + 7) = 0;
  *((_BYTE *)a3 + 16) = 1;
}

void sub_1006A76B8(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;

  *v1 = 0;
  sub_1006A7480(v2, v3);
  _Unwind_Resume(a1);
}

uint64_t *sub_1006A76D4(uint64_t **a1, unsigned __int8 *uu1, uint64_t a3, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a4)
{
  uint64_t **v6;
  uint64_t *result;
  unsigned __int8 *v8[3];
  uint64_t v9;

  v9 = 0;
  v6 = (uint64_t **)sub_10000DC28((uint64_t)a1, &v9, uu1);
  result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_1006A7774((uint64_t)a1, a4, v8);
    sub_100004078(a1, v9, v6, (uint64_t *)v8[0]);
    return (uint64_t *)v8[0];
  }
  return result;
}

void sub_1006A7774(uint64_t a1@<X0>, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a2@<X2>, unsigned __int8 **a3@<X8>)
{
  unsigned __int8 *v5;
  unsigned __int8 *v6;

  v5 = (unsigned __int8 *)(a1 + 8);
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v6 = (unsigned __int8 *)operator new(0x40uLL);
  *a3 = v6;
  a3[1] = v5;
  *((_BYTE *)a3 + 16) = 0;
  uuid_copy(v6 + 32, *a2);
  *((_QWORD *)v6 + 6) = 0;
  v6[56] = 0;
  *((_BYTE *)a3 + 16) = 1;
}

void sub_1006A77D8(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void *v2;

  *v1 = 0;
  operator delete(v2);
  _Unwind_Resume(a1);
}

uint64_t *sub_1006A77F0(uint64_t **a1, uint64_t *a2)
{
  uint64_t *v3;
  unsigned int *v4;

  v3 = sub_1000040CC(a1, a2);
  a2[6] = (uint64_t)&off_100934340;
  v4 = (unsigned int *)a2[7];
  if (v4)
    sub_100056AAC(v4);
  operator delete(a2);
  return v3;
}

void sub_1006A7838(id a1)
{
  operator new();
}

void sub_1006A7878()
{
  operator delete();
}

void sub_1006A789C(id a1)
{
  operator new();
}

void sub_1006A78DC()
{
  operator delete();
}

void sub_1006A7900(id a1)
{
  operator new();
}

void sub_1006A7940()
{
  operator delete();
}

void sub_1006A7964(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_debug_impl(a1, log, OS_LOG_TYPE_DEBUG, a4, (uint8_t *)va, 0xEu);
}

void sub_1006A7978(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v6;
  id v7;
  const std::string::value_type *v8;
  const std::string::value_type *v9;
  NSObject *v10;
  std::string *v11;
  std::string *v12;
  std::string *v13;
  void *v14;
  void *v15;
  void *v16;
  std::string *v17;
  void *v18;
  std::string *v19;
  void *v20;
  void *v21;
  std::string v22;
  std::string v23;
  std::string v24;
  _QWORD v25[4];
  _QWORD v26[4];
  _BYTE buf[12];
  __int16 v28;
  std::string *v29;
  __int16 v30;
  std::string *v31;
  __int16 v32;
  uint64_t v33;

  v6 = a4;
  memset(&v24, 0, sizeof(v24));
  memset(&v23, 0, sizeof(v23));
  sub_100091AE8(&v23, "Unknown");
  memset(&v22, 0, sizeof(v22));
  sub_100091AE8(&v22, "");
  if (v6)
  {
    v7 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "UUIDString")));
    std::string::assign(&v22, (const std::string::value_type *)objc_msgSend(v7, "UTF8String"));

    if (qword_1009778C8 != -1)
      dispatch_once(&qword_1009778C8, &stru_10093FB58);
    sub_10000602C((uint64_t)off_1009778C0, v6, (uint64_t)buf);
    if (v30 >= 0)
      v8 = buf;
    else
      v8 = *(const std::string::value_type **)buf;
    std::string::assign(&v23, v8);
    if (SHIBYTE(v30) < 0)
      operator delete(*(void **)buf);
  }
  if ((a2 - 1) > 3)
    v9 = "UnknownEvent";
  else
    v9 = off_10093FB78[(int)a2 - 1];
  std::string::assign(&v24, v9);
  v10 = qword_1009998D8;
  if (os_log_type_enabled((os_log_t)qword_1009998D8, OS_LOG_TYPE_DEFAULT))
  {
    v11 = &v24;
    if ((v24.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v11 = (std::string *)v24.__r_.__value_.__r.__words[0];
    v12 = &v22;
    if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v12 = (std::string *)v22.__r_.__value_.__r.__words[0];
    v13 = &v23;
    if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v13 = (std::string *)v23.__r_.__value_.__r.__words[0];
    *(_DWORD *)buf = 136315906;
    *(_QWORD *)&buf[4] = v11;
    v28 = 2082;
    v29 = v12;
    v30 = 2080;
    v31 = v13;
    v32 = 2082;
    v33 = a3;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "ThirdParty App Connection Limit exceeded wakeup by LE %s uuid=%{public}s(%s), bundleID=%{public}s", buf, 0x2Au);
  }
  v14 = objc_autoreleasePoolPush();
  v25[0] = CFSTR("WakeEventType");
  v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a2));
  v26[0] = v15;
  v25[1] = CFSTR("BundleID");
  v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a3));
  v26[1] = v16;
  v25[2] = CFSTR("CBUUID");
  if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v17 = &v22;
  else
    v17 = (std::string *)v22.__r_.__value_.__r.__words[0];
  v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v17));
  v26[2] = v18;
  v25[3] = CFSTR("DeviceName");
  if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v19 = &v23;
  else
    v19 = (std::string *)v23.__r_.__value_.__r.__words[0];
  v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v19));
  v26[3] = v20;
  v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v26, v25, 4));

  PLLogRegisteredEvent(35, CFSTR("HostWakeThirdPartyConnectionLimit"), v21, 0);
  objc_autoreleasePoolPop(v14);
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v22.__r_.__value_.__l.__data_);
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v23.__r_.__value_.__l.__data_);
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v24.__r_.__value_.__l.__data_);

}

void sub_1006A7CDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  void *v27;
  uint64_t v28;

  if (*(char *)(v28 - 105) < 0)
    operator delete(*(void **)(v28 - 128));
  if (a15 < 0)
    operator delete(__p);
  if (a21 < 0)
    operator delete(a16);
  if (a27 < 0)
    operator delete(a22);

  _Unwind_Resume(a1);
}

void sub_1006A7DA0(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  _QWORD v12[3];
  _QWORD v13[3];

  v6 = a4;
  if (sub_10005DABC())
  {
    v7 = objc_autoreleasePoolPush();
    v12[0] = CFSTR("BundleID");
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a2));
    v13[0] = v8;
    v12[1] = CFSTR("Connect");
    v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", a3));
    v13[1] = v9;
    v12[2] = CFSTR("CBUUID");
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "UUIDString"));
    v13[2] = v10;
    v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v13, v12, 3));

    PLLogRegisteredEvent(35, CFSTR("LEConnectionRequest"), v11, 0);
    objc_autoreleasePoolPop(v7);
  }
  else if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_ERROR))
  {
    sub_10071A760();
  }

}

void sub_1006A7F08(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1006A7F54(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v6;
  uint64_t v7;
  __CFString *v8;
  _BYTE *v9;
  __CFString *v10;
  uint64_t v11;
  NSObject *v12;
  const char *v13;
  const char *v14;
  void *v15;
  void *v16;
  uint64_t v17;
  void *v18;
  const __CFString *v19;
  const __CFString *v20;
  void *v21;
  void *v22;
  _QWORD v23[5];
  _QWORD v24[5];
  _BYTE __p[22];
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  const char *v29;

  v6 = a4;
  if (sub_10005DABC())
  {
    if (v6)
    {
      if (qword_1009778C8 != -1)
        dispatch_once(&qword_1009778C8, &stru_10093FB58);
      v7 = sub_10066240C((uint64_t)off_1009778C0, v6);
      v8 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "UUIDString"));
      if (qword_1009778C8 != -1)
        dispatch_once(&qword_1009778C8, &stru_10093FB58);
      sub_10000602C((uint64_t)off_1009778C0, v6, (uint64_t)__p);
      if (SHIBYTE(v26) < 0)
      {
        v11 = *(_QWORD *)&__p[8];
        operator delete(*(void **)__p);
        if (v11)
          goto LABEL_9;
      }
      else if (HIBYTE(v26))
      {
LABEL_9:
        if (qword_1009778C8 != -1)
          dispatch_once(&qword_1009778C8, &stru_10093FB58);
        sub_10000602C((uint64_t)off_1009778C0, v6, (uint64_t)__p);
        if (v26 >= 0)
          v9 = __p;
        else
          v9 = *(_BYTE **)__p;
        v10 = (__CFString *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v9));
        if (SHIBYTE(v26) < 0)
          operator delete(*(void **)__p);
        goto LABEL_21;
      }
      v10 = CFSTR("Unknown");
    }
    else
    {
      v7 = 0;
      v8 = CFSTR("Unknown");
      v10 = CFSTR("Unknown");
    }
LABEL_21:
    v12 = qword_1009998D8;
    if (os_log_type_enabled((os_log_t)qword_1009998D8, OS_LOG_TYPE_DEFAULT))
    {
      v13 = sub_10064CFB0(v7);
      v14 = "disconnect";
      *(_DWORD *)__p = 138544130;
      *(_QWORD *)&__p[4] = v6;
      if ((_DWORD)a3)
        v14 = "connect";
      *(_WORD *)&__p[12] = 2080;
      *(_QWORD *)&__p[14] = v14;
      v26 = 2082;
      v27 = a2;
      v28 = 2080;
      v29 = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "PowerLogger device \"%{public}@\" %s for bundleIDs \"%{public}s\" peerType %s", __p, 0x2Au);
    }
    v15 = objc_autoreleasePoolPush();
    v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a2, CFSTR("BundleID")));
    v24[0] = v16;
    v23[1] = CFSTR("Connect");
    v17 = objc_claimAutoreleasedReturnValue(+[NSNumber numberWithBool:](NSNumber, "numberWithBool:", a3));
    v18 = (void *)v17;
    if (v8)
      v19 = v8;
    else
      v19 = CFSTR("Unknown");
    v24[1] = v17;
    v24[2] = v19;
    v23[2] = CFSTR("CBUUID");
    v23[3] = CFSTR("Name");
    if (v10)
      v20 = v10;
    else
      v20 = CFSTR("Unknown");
    v24[3] = v20;
    v23[4] = CFSTR("PeerType");
    v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v7));
    v24[4] = v21;
    v22 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v24, v23, 5));

    PLLogRegisteredEvent(35, CFSTR("LEConnectionStateEvent"), v22, 0);
    objc_autoreleasePoolPop(v15);

    goto LABEL_32;
  }
  if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_ERROR))
    sub_10071A760();
LABEL_32:

}

void sub_1006A82E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  void *v24;
  void *v25;

  if (a24 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_1006A8378(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  _QWORD v12[3];
  _QWORD v13[3];

  if (sub_10005DABC())
  {
    v7 = objc_autoreleasePoolPush();
    v12[0] = CFSTR("Duration");
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a2));
    v13[0] = v8;
    v12[1] = CFSTR("PercentageEPAPower");
    v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a3));
    v13[1] = v9;
    v12[2] = CFSTR("PercentageIPAPower");
    v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a4));
    v13[2] = v10;
    v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v13, v12, 3));

    PLLogRegisteredEvent(35, CFSTR("PowerA2DPSession"), v11, 0);
    objc_autoreleasePoolPop(v7);
  }
  else if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_ERROR))
  {
    sub_10071A760();
  }
}

void sub_1006A84D8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1006A8514(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  _QWORD v18[5];
  _QWORD v19[5];

  if (sub_10005DABC())
  {
    v11 = objc_autoreleasePoolPush();
    v18[0] = CFSTR("Duration");
    v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a2));
    v19[0] = v12;
    v18[1] = CFSTR("PercentageEPAPowerFirstWindow");
    v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a3));
    v19[1] = v13;
    v18[2] = CFSTR("PercentageIPAPowerFirstWindow");
    v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a4));
    v19[2] = v14;
    v18[3] = CFSTR("PercentageEPAPowerSecondWindow");
    v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a5));
    v19[3] = v15;
    v18[4] = CFSTR("PercentageIPAPowerSecondWindow");
    v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a6));
    v19[4] = v16;
    v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v19, v18, 5));

    PLLogRegisteredEvent(35, CFSTR("PowerHFPSession"), v17, 0);
    objc_autoreleasePoolPop(v11);
  }
  else if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_ERROR))
  {
    sub_10071A760();
  }
}

void sub_1006A86D4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1006A8728(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _BYTE *a6)
{
  uint64_t v10;
  unsigned int *v11;
  uint64_t v12;
  uint64_t (**v13)();
  unsigned int *v14;
  uint64_t (**v15)();
  unsigned int *v16;

  if (a6 && *a6)
  {
    v10 = *(_QWORD *)(a2 + 8);
    v13 = &off_100918258;
    v14 = (unsigned int *)v10;
    if (v10)
      sub_10003C37C(v10);
    sub_1006A8830((uint64_t)&v13, a3, a4, a5, (uint64_t)a6, 0);
    v13 = &off_100918258;
    v11 = v14;
    if (!v14)
      return;
LABEL_10:
    sub_100056AAC(v11);
    return;
  }
  v12 = *(_QWORD *)(a2 + 8);
  v15 = &off_100918258;
  v16 = (unsigned int *)v12;
  if (v12)
    sub_10003C37C(v12);
  sub_1006A8830((uint64_t)&v15, a3, a4, a5, (uint64_t)"Unknown", 0);
  v15 = &off_100918258;
  v11 = v16;
  if (v16)
    goto LABEL_10;
}

void sub_1006A8800(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, unsigned int *a10, uint64_t a11, uint64_t a12)
{
  if (a10)
    sub_100056AAC(a10);
  _Unwind_Resume(exception_object);
}

void sub_1006A8830(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  const std::string::value_type *v12;
  NSObject *v13;
  int v14;
  std::string::size_type v15;
  const char *v16;
  std::string *v17;
  void *v18;
  uint64_t v19;
  NSData *v20;
  uint64_t v21;
  void *v22;
  const __CFString *v23;
  void *v24;
  __CFString *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  std::string v30;
  _QWORD v31[6];
  _QWORD v32[6];
  uint8_t buf[4];
  std::string *v34;
  __int16 v35;
  uint64_t v36;
  __int16 v37;
  uint64_t v38;
  __int16 v39;
  uint64_t v40;
  __int16 v41;
  const char *v42;

  if (sub_10005DABC())
  {
    memset(&v30, 0, sizeof(v30));
    v12 = "PassupAdvertising";
    switch((int)a2)
    {
      case 0:
        std::string::assign(&v30, "Others");
        goto LABEL_17;
      case 1:
        v12 = "Advertising";
        goto LABEL_13;
      case 2:
        goto LABEL_13;
      case 3:
        v12 = "Connection";
        goto LABEL_13;
      case 4:
        v12 = "Data";
        goto LABEL_13;
      case 5:
        v12 = "Disconnection";
        goto LABEL_13;
      case 6:
        v12 = "RSSIRegionDetection";
        goto LABEL_13;
      case 7:
        v12 = "SensorTracking";
        goto LABEL_13;
      default:
        v12 = "UnknownEvent";
LABEL_13:
        std::string::assign(&v30, v12);
        v13 = qword_1009998D8;
        if (os_log_type_enabled((os_log_t)qword_1009998D8, OS_LOG_TYPE_DEFAULT))
        {
          v14 = SHIBYTE(v30.__r_.__value_.__r.__words[2]);
          v15 = v30.__r_.__value_.__r.__words[0];
          v16 = sub_10064CFB0(a6);
          *(_DWORD *)buf = 136447234;
          v17 = &v30;
          if (v14 < 0)
            v17 = (std::string *)v15;
          v34 = v17;
          v35 = 2082;
          v36 = a3;
          v37 = 2082;
          v38 = a4;
          v39 = 2080;
          v40 = a5;
          v41 = 2082;
          v42 = v16;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "AP wakeup by LE %{public}s bundleID=%{public}s, uuid=%{public}s, deviceName=%s, peerType=%{public}s", buf, 0x34u);
        }
LABEL_17:
        v18 = objc_autoreleasePoolPush();
        v19 = sub_10003EB18(a1);
        v20 = +[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", v19, sub_10003F8C4(a1));
        v21 = objc_claimAutoreleasedReturnValue(v20);
        v22 = (void *)v21;
        v23 = &stru_100941758;
        if (v21)
          v23 = (const __CFString *)v21;
        v32[0] = v23;
        v31[0] = CFSTR("HostWakeReport");
        v31[1] = CFSTR("WakeEventType");
        v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a2));
        v32[1] = v24;
        v31[2] = CFSTR("BundleID");
        if (a3)
          v25 = (__CFString *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a3));
        else
          v25 = CFSTR("Unknown");
        v32[2] = v25;
        v31[3] = CFSTR("CBUUID");
        v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a4));
        v32[3] = v26;
        v31[4] = CFSTR("DeviceName");
        v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a5));
        v32[4] = v27;
        v31[5] = CFSTR("PeerType");
        v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a6));
        v32[5] = v28;
        v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v32, v31, 6));

        if (a3)
        PLLogRegisteredEvent(35, CFSTR("HostWakeReport"), v29, 0);

        objc_autoreleasePoolPop(v18);
        if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v30.__r_.__value_.__l.__data_);
        break;
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_ERROR))
  {
    sub_10071A760();
  }
}

void sub_1006A8BB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1006A8C40(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5)
{
  id v8;
  id v9;
  uint64_t v10;
  unsigned int *v11;
  std::string *v12;
  void **v13;
  uint64_t (**v14)();
  unsigned int *v15;
  __int128 v16;
  uint64_t v17;
  std::string v18;
  void *__p[2];
  uint64_t v20;

  v8 = a4;
  __p[0] = 0;
  __p[1] = 0;
  v20 = 0;
  sub_100091AE8(__p, "Unknown");
  memset(&v18, 0, sizeof(v18));
  sub_100091AE8(&v18, "Unknown");
  if (v8)
  {
    v9 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "UUIDString")));
    std::string::assign(&v18, (const std::string::value_type *)objc_msgSend(v9, "UTF8String"));

    if (qword_1009778C8 != -1)
      dispatch_once(&qword_1009778C8, &stru_10093FB58);
    sub_10000602C((uint64_t)off_1009778C0, v8, (uint64_t)&v16);
    if (SHIBYTE(v20) < 0)
      operator delete(__p[0]);
    *(_OWORD *)__p = v16;
    v20 = v17;
    if (qword_1009778C8 != -1)
      dispatch_once(&qword_1009778C8, &stru_10093FB58);
    v10 = sub_10066240C((uint64_t)off_1009778C0, v8);
  }
  else
  {
    v10 = 0;
  }
  v11 = *(unsigned int **)(a5 + 8);
  v14 = &off_100918258;
  v15 = v11;
  if (v11)
    sub_10003C37C((uint64_t)v11);
  if ((v18.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v12 = &v18;
  else
    v12 = (std::string *)v18.__r_.__value_.__r.__words[0];
  if (v20 >= 0)
    v13 = __p;
  else
    v13 = (void **)__p[0];
  sub_1006A8830((uint64_t)&v14, a2, a3, (uint64_t)v12, (uint64_t)v13, v10);
  v14 = &off_100918258;
  if (v15)
    sub_100056AAC(v15);
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v18.__r_.__value_.__l.__data_);
  if (SHIBYTE(v20) < 0)
    operator delete(__p[0]);

}

void sub_1006A8E00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  void *v25;

  if (a19 < 0)
    operator delete(__p);
  if (a25 < 0)
    operator delete(a20);

  _Unwind_Resume(a1);
}

void sub_1006A8E68(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  _QWORD v15[4];
  _QWORD v16[4];

  if (sub_10005DABC())
  {
    v9 = objc_autoreleasePoolPush();
    v15[0] = CFSTR("LegacyDupFilterOverflowReport");
    v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", a2));
    v16[0] = v10;
    v15[1] = CFSTR("ExtDupFilterOverflow");
    v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", a3));
    v16[1] = v11;
    v15[2] = CFSTR("LegacyDupFilterOverflowCnt");
    v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", a4));
    v16[2] = v12;
    v15[3] = CFSTR("ExtDupFilterOverflowCnt");
    v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", a5));
    v16[3] = v13;
    v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v16, v15, 4));

    PLLogRegisteredEvent(35, CFSTR("DuplicateFilterOverflowReport"), v14, 0);
    objc_autoreleasePoolPop(v9);
  }
  else if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_ERROR))
  {
    sub_10071A760();
  }
}

void sub_1006A8FF4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1006A903C(double a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  _QWORD v18[5];
  _QWORD v19[5];

  v11 = objc_autoreleasePoolPush();
  v18[0] = CFSTR("CTScanCount");
  v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a3));
  v19[0] = v12;
  v18[1] = CFSTR("CTScanDuration");
  v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a4));
  v19[1] = v13;
  v18[2] = CFSTR("CTAdvertisingReports");
  v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a5));
  v19[2] = v14;
  v18[3] = CFSTR("NonCTAdvertisingReports");
  v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a6));
  v19[3] = v15;
  v18[4] = CFSTR("CTLastScanTS");
  v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", a1));
  v19[4] = v16;
  v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v19, v18, 5));

  PLLogRegisteredEvent(35, CFSTR("BTContactTracingStatus"), v17, 0);
  objc_autoreleasePoolPop(v11);
}

void sub_1006A91D4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1006A922C()
{
  operator delete();
}

void sub_1006A9240(id a1)
{
  operator new();
}

void sub_1006A9280()
{
  operator delete();
}

uint64_t sub_1006A92A4(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  __CFNotificationCenter *DarwinNotifyCenter;

  *(_QWORD *)(a1 + 8) = off_10093FC40;
  v2 = a1 + 8;
  *(_QWORD *)(a1 + 16) = &off_10093FC70;
  v3 = a1 + 16;
  *(_QWORD *)a1 = off_10093FBA8;
  *(_DWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  if (qword_100977A58 != -1)
    dispatch_once(&qword_100977A58, &stru_10093FD28);
  sub_1002609C8((uint64_t)off_100977A50 + 64, v2);
  v4 = sub_100038E50();
  sub_1006AC24C(v4 + 768, v3);
  if (sub_1006A93C4() && sub_1004F9864())
  {
    DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterAddObserver(DarwinNotifyCenter, 0, (CFNotificationCallback)sub_1006A94F4, kRegulatoryDomainUpdateNotification, 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  }
  return a1;
}

void sub_1006A9390(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;
  void *v4;
  void *v5;

  v4 = *(void **)(v1 + 64);
  if (v4)
  {
    *(_QWORD *)(v1 + 72) = v4;
    operator delete(v4);
  }
  v5 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 40) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(a1);
}

BOOL sub_1006A93C4()
{
  NSObject *v0;
  const char *v1;
  const char *v2;
  const char *v3;
  int v5;
  const char *v6;
  __int16 v7;
  const char *v8;
  __int16 v9;
  const char *v10;

  if (qword_100994138 != -1)
    dispatch_once(&qword_100994138, &stru_10093FC78);
  v0 = qword_1009997E8;
  if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
  {
    v1 = "TRUE";
    if (byte_100994130)
      v2 = "TRUE";
    else
      v2 = "FALSE";
    if (byte_100994131)
      v3 = "TRUE";
    else
      v3 = "FALSE";
    v5 = 136315650;
    v6 = v2;
    v7 = 2080;
    if (!(byte_100994131 | byte_100994130))
      v1 = "FALSE";
    v8 = v3;
    v9 = 2080;
    v10 = v1;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "PurpleLocation::useRegulatoryDomainForCountryCode() -- enabled = %s -- overrideEnabled = %s -- returning %s", (uint8_t *)&v5, 0x20u);
  }
  return (byte_100994130 | byte_100994131) != 0;
}

void sub_1006A94F4()
{
  uint64_t v0;

  v0 = sub_10006BBEC();
  sub_100041A34(v0, &stru_10093FD08);
}

_QWORD *sub_1006A9514(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  __CFNotificationCenter *DarwinNotifyCenter;
  void *v5;
  void *v6;

  *a1 = off_10093FBA8;
  a1[1] = off_10093FC40;
  a1[2] = &off_10093FC70;
  v2 = (uint64_t)(a1 + 2);
  v3 = sub_100038E50();
  sub_1002B43D4(v3 + 768, v2);
  if (sub_1006A93C4() && sub_1004F9864())
  {
    DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterRemoveObserver(DarwinNotifyCenter, a1, kRegulatoryDomainUpdateNotification, 0);
  }

  v5 = (void *)a1[8];
  if (v5)
  {
    a1[9] = v5;
    operator delete(v5);
  }
  v6 = (void *)a1[4];
  if (v6)
  {
    a1[5] = v6;
    operator delete(v6);
  }
  return a1;
}

void sub_1006A95B4(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 64);
  if (v3)
  {
    *(_QWORD *)(v1 + 72) = v3;
    operator delete(v3);
  }
  sub_10071A78C(v1);
  _Unwind_Resume(a1);
}

void sub_1006A95E4(_QWORD *a1)
{
  sub_1006A9514(a1);
  operator delete();
}

void sub_1006A9608(id a1)
{
  uint64_t v1;
  int v2;
  NSObject *v3;
  const char *v4;
  void *__p[2];
  char v6;
  _BYTE buf[12];
  char v8;

  byte_100994130 = _os_feature_enabled_impl("BluetoothFeatures", "UseRegulatoryDomainForCountryCode");
  v1 = sub_100027F68();
  sub_100091AE8(buf, "CountryCode");
  sub_100091AE8(__p, "UseRegulatoryDomain");
  v2 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, char *))(*(_QWORD *)v1 + 72))(v1, buf, __p, &byte_100994131);
  if (v6 < 0)
    operator delete(__p[0]);
  if (v8 < 0)
  {
    operator delete(*(void **)buf);
    if (!v2)
      return;
  }
  else if (!v2)
  {
    return;
  }
  v3 = qword_1009997E8;
  if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_100994131)
      v4 = "Yes";
    else
      v4 = "No";
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Warning: overrideEnabled: %s", buf, 0xCu);
  }
}

void sub_1006A9758(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a15 < 0)
    operator delete(__p);
  if (a21 < 0)
    operator delete(a16);
  _Unwind_Resume(exception_object);
}

id sub_1006A9794(uint64_t a1)
{
  return *(id *)(a1 + 88);
}

uint64_t sub_1006A979C()
{
  uint64_t v0;
  int v1;

  if (*(_DWORD *)(sub_1000438A4() + 712) < 0x18u)
    return 0;
  v0 = 0;
  v1 = sub_10005F864();
  if (((v1 - 230) > 0xD || v1 == 231)
    && ((v1 - 112) > 0x15 || ((1 << (v1 - 112)) & 0x3C000F) == 0))
  {
    return 1;
  }
  return v0;
}

BOOL sub_1006A9818()
{
  int v0;

  v0 = sub_10005F864();
  return (v0 - 252) <= 0xC && ((1 << (v0 + 4)) & 0x1987) != 0 || (v0 - 123) < 2;
}

void sub_1006A9860(uint64_t a1, void *a2, _BYTE *a3, _BYTE *a4, BOOL *a5)
{
  __CFString *v8;
  const __CFString *v9;
  unsigned int v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  unsigned __int8 v16;
  unsigned __int8 v17;
  void *v18;
  void *v19;
  id v20;
  NSObject *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  NSObject *v28;
  unsigned int v29;
  const __CFString *v30;
  int v31;
  int v32;
  _BOOL4 v33;
  id v34;
  uint8_t buf[4];
  const __CFString *v36;
  __int16 v37;
  int v38;
  __int16 v39;
  int v40;
  __int16 v41;
  _BOOL4 v42;
  char v43[24];

  v8 = a2;
  if (-[__CFString isEqualToString:](v8, "isEqualToString:", CFSTR("XZ")))
  {
    *a3 = 0;
    *a4 = 1;
    *a5 = 1;
  }
  else
  {
    if ((sub_10005F864() | 8) == 0x9C)
    {
      v9 = CFSTR("/Library/Application Support/BTServer/countryCodesJ3tv.plist");
    }
    else
    {
      v10 = *(_DWORD *)(sub_1000438A4() + 712);
      v11 = sub_10003BE44();
      v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v11 + 384))(v11);
      if (v10)
        v13 = v12;
      else
        v13 = 0;
      if (v13 == 1 && v10 <= 0x7CF && v10 > 0x17
        || v10 == 22
        && (v14 = sub_10003BE44(), ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v14 + 424))(v14) & 1) != 0))
      {
        v9 = CFSTR("/Library/Application Support/BTServer/countryCodes3.plist");
      }
      else
      {
        v15 = sub_10003BE44();
        v16 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v15 + 360))(v15);
        if (v10)
          v17 = v16;
        else
          v17 = 0;
        if (v10 >= 0x7D0)
          v17 = 0;
        if ((v17 & (v10 > 0x12)) != 0)
          v9 = CFSTR("/Library/Application Support/BTServer/countryCodes2.plist");
        else
          v9 = CFSTR("/Library/Application Support/BTServer/countryCodes.plist");
      }
    }
    v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL fileURLWithPath:isDirectory:relativeToURL:](NSURL, "fileURLWithPath:isDirectory:relativeToURL:", v9, 0, 0));
    v34 = 0;
    v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithContentsOfURL:error:](NSDictionary, "dictionaryWithContentsOfURL:error:", v18, &v34));
    v20 = v34;
    if (v20)
    {
      v21 = qword_1009997E8;
      if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_FAULT))
      {
        v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v20, "localizedDescription"));
        sub_10071A7A4(v22, (uint64_t)v43, v21);
      }
    }
    v23 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString uppercaseString](v8, "uppercaseString"));
    v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v19, "objectForKey:", v23));

    v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v24, "objectForKey:", CFSTR("CC")));
    *a3 = objc_msgSend(v25, "intValue");

    v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v24, "objectForKey:", CFSTR("LEFlag")));
    *a4 = objc_msgSend(v26, "BOOLValue");

    v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v24, "objectForKey:", CFSTR("HDRFlag")));
    *a5 = v27 != 0;

  }
  v28 = qword_1009997E8;
  if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
  {
    v29 = -[__CFString isEqualToString:](v8, "isEqualToString:", CFSTR("XZ"));
    v30 = CFSTR("default");
    if (!v29)
      v30 = v8;
    v31 = *a3;
    v32 = *a4;
    v33 = *a5;
    *(_DWORD *)buf = 138544130;
    v36 = v30;
    v37 = 1024;
    v38 = v31;
    v39 = 1024;
    v40 = v32;
    v41 = 1024;
    v42 = v33;
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Country specific power settings for country: \"%{public}@\" CC %d LEFlag %d HDRFlag %d", buf, 0x1Eu);
  }

}

void sub_1006A9B78(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1006A9BF0(uint64_t a1, void *a2, unsigned __int8 *a3, _BYTE *a4)
{
  uint64_t v6;
  _BOOL4 v7;
  const __CFString *v8;
  uint64_t v9;
  const __CFString *v10;
  NSObject *v11;
  void *v12;
  void *v13;
  void *v14;
  id v15;
  id v16;
  __int128 v17;
  uint64_t v18;
  void *i;
  __CFString *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  NSObject *v30;
  NSObject *v31;
  unsigned int v32;
  int v33;
  const __CFString *v34;
  int v35;
  int v36;
  int v37;
  int v38;
  __int128 v39;
  void *v40;
  id v41;
  void *v42;
  __CFString *v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  uint64_t v48;
  uint8_t buf[4];
  const __CFString *v50;
  __int16 v51;
  int v52;
  __int16 v53;
  int v54;
  __int16 v55;
  int v56;
  __int16 v57;
  int v58;
  __int16 v59;
  int v60;
  _BYTE v61[128];
  char v62[16];

  v43 = a2;
  if (-[__CFString isEqualToString:](v43, "isEqualToString:", CFSTR("XZ")))
  {
    *a3 = 0;
    *(_DWORD *)(a3 + 1) = -1;
    *((_DWORD *)a3 + 1) = -1;
    *a4 = 1;
    goto LABEL_41;
  }
  v6 = sub_10003BE44();
  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v6 + 384))(v6))
  {
    if (sub_1006A979C())
    {
      v7 = sub_1006A9818();
      v8 = CFSTR("/Library/Application Support/BTServer/countryCodes5Mac.plist");
      goto LABEL_9;
    }
  }
  else
  {
    v9 = sub_10003BE44();
    if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)v9 + 360))(v9))
    {
      if (*(_DWORD *)(sub_1000438A4() + 712) == 26)
        v10 = CFSTR("/Library/Application Support/BTServer/countryCodes6_CC6.plist");
      else
        v10 = CFSTR("/Library/Application Support/BTServer/countryCodes5.plist");
      goto LABEL_16;
    }
    if (sub_1006A979C())
    {
      v7 = sub_1006A9818();
      v8 = CFSTR("/Library/Application Support/BTServer/countryCodes5iPads.plist");
LABEL_9:
      if (v7)
        v10 = CFSTR("/Library/Application Support/BTServer/countryCodes5MacV39.plist");
      else
        v10 = v8;
      goto LABEL_16;
    }
  }
  v10 = CFSTR("/Library/Application Support/BTServer/countryCodes4.plist");
LABEL_16:
  v48 = 0;
  v40 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL fileURLWithPath:isDirectory:relativeToURL:](NSURL, "fileURLWithPath:isDirectory:relativeToURL:", v10, 0, 0));
  v42 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithContentsOfURL:error:](NSDictionary, "dictionaryWithContentsOfURL:error:"));
  v41 = 0;
  if (v41)
  {
    v11 = qword_1009997E8;
    if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_FAULT))
    {
      v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v41, "localizedDescription"));
      sub_10071A7A4(v12, (uint64_t)v62, v11);
    }
  }
  *a3 = 0;
  *(_DWORD *)(a3 + 1) = -1;
  *((_DWORD *)a3 + 1) = -1;
  v13 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString uppercaseString](v43, "uppercaseString"));
  v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v42, "objectForKey:", v13));

  v46 = 0u;
  v47 = 0u;
  v44 = 0u;
  v45 = 0u;
  v15 = v14;
  v16 = objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v44, v61, 16);
  if (v16)
  {
    v18 = *(_QWORD *)v45;
    *(_QWORD *)&v17 = 138412290;
    v39 = v17;
    do
    {
      for (i = 0; i != v16; i = (char *)i + 1)
      {
        if (*(_QWORD *)v45 != v18)
          objc_enumerationMutation(v15);
        v20 = *(__CFString **)(*((_QWORD *)&v44 + 1) + 8 * (_QWORD)i);
        if (-[__CFString isEqualToString:](v20, "isEqualToString:", CFSTR("ISM 2.4"), v39))
        {
          v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "objectForKey:", v20));
          *a3 = objc_msgSend(v21, "unsignedIntValue");

        }
        else if (-[__CFString isEqualToString:](v20, "isEqualToString:", CFSTR("LE Flag")))
        {
          v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "objectForKey:", v20));
          *a4 = objc_msgSend(v22, "BOOLValue");

        }
        else if (-[__CFString isEqualToString:](v20, "isEqualToString:", CFSTR("UNII-1")))
        {
          v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "objectForKey:", v20));
          a3[1] = objc_msgSend(v23, "unsignedIntValue");

        }
        else if (-[__CFString isEqualToString:](v20, "isEqualToString:", CFSTR("UNII-3")))
        {
          v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "objectForKey:", v20));
          a3[2] = objc_msgSend(v24, "unsignedIntValue");

        }
        else if (-[__CFString isEqualToString:](v20, "isEqualToString:", CFSTR("UNII-4")))
        {
          v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "objectForKey:", v20));
          a3[3] = objc_msgSend(v25, "unsignedIntValue");

        }
        else if (-[__CFString isEqualToString:](v20, "isEqualToString:", CFSTR("UNII-5")))
        {
          v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "objectForKey:", v20));
          a3[4] = objc_msgSend(v26, "unsignedIntValue");

          v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "objectForKey:", v20));
          a3[5] = objc_msgSend(v27, "unsignedIntValue");

          v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "objectForKey:", v20));
          a3[6] = objc_msgSend(v28, "unsignedIntValue");

          v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "objectForKey:", v20));
          a3[7] = objc_msgSend(v29, "unsignedIntValue");

        }
        else
        {
          v30 = qword_1009997E8;
          if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = v39;
            v50 = v20;
            _os_log_error_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "PurpleLocation::getCountrySpecificPowerSettingsHRB: Unexpected key: %@", buf, 0xCu);
          }
        }
      }
      v16 = objc_msgSend(v15, "countByEnumeratingWithState:objects:count:", &v44, v61, 16);
    }
    while (v16);
  }

LABEL_41:
  v31 = qword_1009997E8;
  if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
  {
    v32 = -[__CFString isEqualToString:](v43, "isEqualToString:", CFSTR("XZ"));
    v33 = *a3;
    v34 = CFSTR("default");
    v35 = *a4;
    if (!v32)
      v34 = v43;
    v36 = a3[1];
    v37 = a3[2];
    v38 = a3[4];
    *(_DWORD *)buf = 138544642;
    v50 = v34;
    v51 = 1024;
    v52 = v33;
    v53 = 1024;
    v54 = v35;
    v55 = 1024;
    v56 = v36;
    v57 = 1024;
    v58 = v37;
    v59 = 1024;
    v60 = v38;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "Country specific power settings for country: \"%{public}@\" ISM 2.4 CC: %d, LEFlag: %d, UNII-1 CC: %d, UNII-3 CC: %d, UNII-5 CC: %d", buf, 0x2Au);
  }

}

void sub_1006AA164(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{

  _Unwind_Resume(a1);
}

void sub_1006AA24C(uint64_t a1, void *a2, uint64_t a3, int a4)
{
  id v6;
  int v7;
  NSObject *v8;
  __CFString *v9;
  void *v10;
  NSObject *v11;
  void *v12;
  void *v13;
  NSObject *v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  id v18;
  id v19;
  __int128 v20;
  uint64_t v21;
  void *i;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  __int128 v32;
  NSObject *log;
  void *v34;
  void *v35;
  void *v36;
  id v37;
  id v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  id v43;
  uint8_t v44[128];
  uint8_t buf[4];
  _BYTE v46[18];
  __int16 v47;
  uint64_t v48;
  __int16 v49;
  const char *v50;
  __int16 v51;
  int v52;

  v6 = a2;
  if (objc_msgSend(v6, "isEqualToString:", CFSTR("XZ")))
  {
    *(_BYTE *)a3 = 0;
    *(_DWORD *)(a3 + 1) = -1;
    *(_DWORD *)(a3 + 4) = -1;
    goto LABEL_43;
  }
  v7 = a4 - 8212;
  if ((a4 - 8212) < 0x11 && ((0x116A1u >> v7) & 1) != 0)
  {
    v9 = off_10093FD48[v7];
    *(_BYTE *)a3 = 0;
    *(_DWORD *)(a3 + 1) = -1;
    *(_DWORD *)(a3 + 4) = -1;
    v38 = v6;
    v43 = 0;
    v36 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL fileURLWithPath:isDirectory:relativeToURL:](NSURL, "fileURLWithPath:isDirectory:relativeToURL:", v9, 0, 0));
    v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithContentsOfURL:error:](NSDictionary, "dictionaryWithContentsOfURL:error:", v36, &v43));
    v37 = v43;
    if (v37)
    {
      v11 = qword_1009997E8;
      if (!os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
      {
LABEL_42:

        v6 = v38;
        goto LABEL_43;
      }
      v35 = v10;
      v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v37, "localizedDescription"));
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)v46 = a4;
      *(_WORD *)&v46[4] = 2112;
      *(_QWORD *)&v46[6] = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "PurpleLocation::getCountrySpecificPowerSettingsForProduct: Unable to extract country code plist for productID 0x%08X: %@", buf, 0x12u);

    }
    else
    {
      v35 = v10;
      v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "uppercaseString"));
      v34 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "objectForKey:", v13));

      v14 = qword_1009997E8;
      if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_INFO))
      {
        v15 = sub_1000438A4();
        v16 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v15 + 2496))(v15);
        *(_DWORD *)buf = 138413315;
        *(_QWORD *)v46 = v6;
        *(_WORD *)&v46[8] = 2112;
        *(_QWORD *)&v46[10] = v34;
        v47 = 2160;
        v48 = 1752392040;
        v49 = 2081;
        v50 = "device supports HRB";
        v51 = 1024;
        v52 = v16;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "PurpleLocation::getCountrySpecificPowerSettingsForProduct: countryString: %@, countryCodeDict: %@, %{private, mask.hash}s: %u", buf, 0x30u);
      }
      v17 = sub_1000438A4();
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v17 + 2496))(v17))
      {
        v41 = 0u;
        v42 = 0u;
        v39 = 0u;
        v40 = 0u;
        v18 = v34;
        v19 = objc_msgSend(v18, "countByEnumeratingWithState:objects:count:", &v39, v44, 16);
        if (v19)
        {
          v21 = *(_QWORD *)v40;
          *(_QWORD *)&v20 = 138412290;
          v32 = v20;
          do
          {
            for (i = 0; i != v19; i = (char *)i + 1)
            {
              if (*(_QWORD *)v40 != v21)
                objc_enumerationMutation(v18);
              v23 = *(void **)(*((_QWORD *)&v39 + 1) + 8 * (_QWORD)i);
              if (objc_msgSend(v23, "isEqualToString:", CFSTR("ISM 2.4"), v32))
              {
                v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "objectForKey:", v23));
                *(_BYTE *)a3 = objc_msgSend(v24, "unsignedIntValue");

              }
              else if (objc_msgSend(v23, "isEqualToString:", CFSTR("UNII-1")))
              {
                v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "objectForKey:", v23));
                *(_BYTE *)(a3 + 1) = objc_msgSend(v25, "unsignedIntValue");

              }
              else if (objc_msgSend(v23, "isEqualToString:", CFSTR("UNII-3")))
              {
                v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "objectForKey:", v23));
                *(_BYTE *)(a3 + 2) = objc_msgSend(v26, "unsignedIntValue");

              }
              else if (objc_msgSend(v23, "isEqualToString:", CFSTR("UNII-4")))
              {
                v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "objectForKey:", v23));
                *(_BYTE *)(a3 + 3) = objc_msgSend(v27, "unsignedIntValue");

              }
              else if (objc_msgSend(v23, "isEqualToString:", CFSTR("UNII-5a")))
              {
                v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "objectForKey:", v23));
                *(_BYTE *)(a3 + 4) = objc_msgSend(v28, "unsignedIntValue");

              }
              else if (objc_msgSend(v23, "isEqualToString:", CFSTR("UNII-5b")))
              {
                v29 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "objectForKey:", v23));
                *(_BYTE *)(a3 + 5) = objc_msgSend(v29, "unsignedIntValue");

              }
              else if (objc_msgSend(v23, "isEqualToString:", CFSTR("UNII-5c")))
              {
                v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "objectForKey:", v23));
                *(_BYTE *)(a3 + 6) = objc_msgSend(v30, "unsignedIntValue");

              }
              else if (objc_msgSend(v23, "isEqualToString:", CFSTR("UNII-5d")))
              {
                v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v18, "objectForKey:", v23));
                *(_BYTE *)(a3 + 7) = objc_msgSend(v31, "unsignedIntValue");

              }
              else
              {
                log = qword_1009997E8;
                if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = v32;
                  *(_QWORD *)v46 = v23;
                  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "PurpleLocation::getCountrySpecificPowerSettingsForProduct: Unexpected key: %@", buf, 0xCu);
                }
              }
            }
            v19 = objc_msgSend(v18, "countByEnumeratingWithState:objects:count:", &v39, v44, 16);
          }
          while (v19);
        }
      }
      else
      {
        v18 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v34, "objectForKey:", CFSTR("ISM 2.4")));
        *(_BYTE *)a3 = objc_msgSend(v18, "unsignedIntValue");
      }

    }
    v10 = v35;
    goto LABEL_42;
  }
  *(_BYTE *)a3 = 0;
  *(_DWORD *)(a3 + 1) = -1;
  *(_DWORD *)(a3 + 4) = -1;
  v8 = qword_1009997E8;
  if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)v46 = a4;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "PurpleLocation::getCountrySpecificPowerSettingsForProduct: Unexpected product ID: %u", buf, 8u);
  }
LABEL_43:

}

void sub_1006AA850(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, void *a14, void *a15, void *a16)
{
  void *v16;

  _Unwind_Resume(a1);
}

void sub_1006AA944(uint64_t a1)
{
  int v2;
  NSObject *v3;
  _BOOL4 v4;
  void *v5;
  NSObject *v6;
  uint8_t v7[16];
  uint8_t v8[16];
  uint8_t buf[16];

  sub_1000438A4();
  if (sub_100333630())
  {
    if (sub_1006A93C4())
    {
      v2 = sub_1004F9864();
      v3 = qword_1009997E8;
      v4 = os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT);
      if (v2)
      {
        if (v4)
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "CountryCode: Location update triggered using RegulatoryDomain", buf, 2u);
        }
        sub_1006AAA90(a1);
      }
      else
      {
        if (v4)
        {
          *(_WORD *)v8 = 0;
          _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "RegulatoryDomain is not available -- setting country code to default", v8, 2u);
        }
        sub_1006AAE28(a1, CFSTR("XZ"));
      }
    }
    else
    {
      v6 = qword_1009997E8;
      if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v7 = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "CountryCode: Location update triggered using Geo", v7, 2u);
      }
      sub_1006AB170(a1);
    }
  }
  else
  {
    v5 = *(void **)(a1 + 88);
    *(_QWORD *)(a1 + 88) = CFSTR("XZ");

  }
}

void sub_1006AAA90(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  id v5;
  void *v6;
  id v7;
  NSObject *v8;
  unsigned __int8 v9;
  NSObject *v10;
  _BOOL4 v11;
  NSObject *v12;
  void *v13;
  void *v14;
  NSObject *v15;
  _BOOL4 v16;
  NSObject *v17;
  id v18;
  uint8_t buf[4];
  void *v20;
  __int16 v21;
  id v22;

  v2 = qword_1009997E8;
  if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "PurpleLocation::startLocationUpdatesRD() -- using RegulatoryDomain for country code", buf, 2u);
  }
  v3 = sub_1000438A4();
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 3360))(v3);
  if ((_DWORD)v4)
  {
    v18 = 0;
    v5 = sub_1006AB83C(v4, &v18);
    v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
    v7 = v18;
    v8 = qword_1009997E8;
    if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138543618;
      v20 = v6;
      v21 = 2114;
      v22 = v7;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "CountryCode from RegulatoryDomain, Current Country: %{public}@, Last Known Country: %{public}@", buf, 0x16u);
    }
    if (!v6)
    {
      v13 = (void *)objc_claimAutoreleasedReturnValue(+[GEOCountryConfiguration sharedConfiguration](GEOCountryConfiguration, "sharedConfiguration"));
      v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "countryCode"));
      v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@"), v14));

      v15 = qword_1009997E8;
      v16 = os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT);
      if (!v6)
      {
        if (v16)
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Both RegulatoryDomain and GEOCountryConfiguration returned nil", buf, 2u);
        }
        v17 = qword_1009997E8;
        if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "RegulatoryDomain and GeoCountryConfiguration returned nil -- setting country code to default", buf, 2u);
        }
        v6 = 0;
        sub_1006AAE28(a1, CFSTR("XZ"));
        goto LABEL_25;
      }
      if (v16)
      {
        *(_DWORD *)buf = 138543362;
        v20 = v6;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Setting country code from GeoCountryConfiguration %{public}@", buf, 0xCu);
      }
    }
    v9 = objc_msgSend(*(id *)(a1 + 88), "isEqualToString:", v6);
    v10 = qword_1009997E8;
    v11 = os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT);
    if ((v9 & 1) != 0)
    {
      if (v11)
      {
        *(_DWORD *)buf = 138543362;
        v20 = v6;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "CountryCode: update not needed -- same country code %{public}@", buf, 0xCu);
      }
    }
    else
    {
      if (v11)
      {
        *(_DWORD *)buf = 138543362;
        v20 = v6;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "CountryCode changed -- new country code %{public}@", buf, 0xCu);
      }
      sub_1006AAE28(a1, v6);
    }
LABEL_25:

    return;
  }
  if ((objc_msgSend(*(id *)(a1 + 88), "isEqualToString:", CFSTR("XZ")) & 1) == 0)
  {
    v12 = qword_1009997E8;
    if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Does not support location based power tables -- setting country code to default", buf, 2u);
    }
    sub_1006AAE28(a1, CFSTR("XZ"));
  }
}

void sub_1006AADEC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1006AAE28(uint64_t a1, void *a2)
{
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  int v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;
  uint64_t v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned __int8 v24[10];
  unsigned __int8 v25;
  unsigned __int8 v26;
  __int16 v27;
  unsigned __int8 v28;
  uint8_t buf[4];
  id v30;
  __int16 v31;
  int v32;
  __int16 v33;
  int v34;
  __int16 v35;
  int v36;
  __int16 v37;
  int v38;
  __int16 v39;
  int v40;

  v4 = a2;
  v28 = 0;
  v27 = 0;
  v26 = 0;
  v25 = 1;
  v5 = sub_1000438A4();
  if ((*(_DWORD *)(v5 + 712) - 24) > 0x7B7)
  {
    (*(void (**)(uint64_t, id, unsigned __int8 *, unsigned __int8 *, unsigned __int8 *))(*(_QWORD *)a1 + 8))(a1, v4, &v28, &v26, &v25);
    v14 = qword_1009997E8;
    if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138543874;
      v30 = v4;
      v31 = 1024;
      v32 = v26;
      v33 = 1024;
      v34 = v25;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "PurpleLocation: Action - country: %{public}@,  LEFlag: %u, HDR Flag: %u", buf, 0x18u);
    }
    v15 = sub_1000438A4();
    (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, __int16 *, _QWORD))(*(_QWORD *)v15 + 584))(v15, 1, v28, v26, &v27, 0);
    (*(void (**)(uint64_t, id, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a1 + 88))(a1, v4, v28, v26, v25);
  }
  else
  {
    v24[0] = 0;
    memset(&v24[1], 255, 7);
    sub_1006A9BF0(v5, v4, v24, &v26);
    v6 = sub_1000438A4();
    v7 = v24[0];
    v8 = v26;
    v9 = v24[1];
    v10 = v24[2];
    v11 = v24[4];
    (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, __int16 *, _QWORD))(*(_QWORD *)v6 + 592))(v6, 1, v24[0], v26, v24[1], v24[2], v24[4], &v27, 0);
    sub_1006ABC14((os_unfair_lock_s *)a1, v4, v7, v8 != 0, v9, v10, v11);
    v12 = qword_1009997E8;
    if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138544642;
      v30 = v4;
      v31 = 1024;
      v32 = v7;
      v33 = 1024;
      v34 = v8;
      v35 = 1024;
      v36 = v9;
      v37 = 1024;
      v38 = v10;
      v39 = 1024;
      v40 = v11;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "PurpleLocation: Notify HRB Listeners - country: %{public}@, ISM 2.4 CC: %u, LEFlag: %u, UNII-1 CC: %u, UNII-3 CC: %u, UNII-5 CC: %u", buf, 0x2Au);
    }
    (*(void (**)(uint64_t, id, uint64_t, BOOL, uint64_t))(*(_QWORD *)a1 + 88))(a1, v4, v7, v8 != 0, 1);
    v13 = qword_1009997E8;
    if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138544130;
      v30 = v4;
      v31 = 1024;
      v32 = v7;
      v33 = 1024;
      v34 = v8;
      v35 = 1024;
      v36 = 1;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "PurpleLocation: Notify Legacy Listeners - country: %{public}@, ISM 2.4 CC: %u, LEFlag: %u, HDR Flag: %u", buf, 0x1Eu);
    }
  }
  objc_storeStrong((id *)(a1 + 88), a2);
  v16 = qword_1009997E8;
  if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEBUG))
    sub_10071A7EC(v16, v17, v18, v19, v20, v21, v22, v23);

}

void sub_1006AB154(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1006AB170(uint64_t a1)
{
  NSObject *v2;
  void *v3;
  unsigned int v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  NSObject *v14;
  _QWORD v15[5];
  _QWORD block[5];
  uint8_t buf[16];

  v2 = qword_1009997E8;
  if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "PurpleLocation::startLocationUpdates() -- using Geo for country code", buf, 2u);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1006AB454;
  block[3] = &unk_100917378;
  block[4] = a1;
  if (qword_100994140 != -1)
    dispatch_once(&qword_100994140, block);
  v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSBundle bundleWithPath:](NSBundle, "bundleWithPath:", CFSTR("/System/Library/PrivateFrameworks/MobileWiFi.framework")));
  v4 = +[CLLocationManager authorizationStatusForBundle:](CLLocationManager, "authorizationStatusForBundle:", v3);

  if (v4 - 3 > 1)
  {
    if ((objc_msgSend(*(id *)(a1 + 88), "isEqualToString:", CFSTR("XZ")) & 1) == 0)
    {
      v14 = qword_1009997E8;
      if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "CountryCode: Location Services disabled!", buf, 2u);
      }
      sub_1006AAE28(a1, CFSTR("XZ"));
    }
  }
  else
  {
    v5 = qword_1009997E8;
    if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEBUG))
      sub_10071A81C(v5, v6, v7, v8, v9, v10, v11, v12);
    v13 = (void *)objc_claimAutoreleasedReturnValue(+[GEOCountryConfiguration sharedConfiguration](GEOCountryConfiguration, "sharedConfiguration"));
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 3221225472;
    v15[2] = sub_1006AB620;
    v15[3] = &unk_10093FC98;
    v15[4] = a1;
    objc_msgSend(v13, "updateCountryConfiguration:", v15);

  }
}

void sub_1006AB34C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1006AB360(uint64_t a1, unsigned int a2)
{
  NSObject *v4;
  dispatch_time_t v5;
  NSObject *global_queue;
  _QWORD v7[5];
  unsigned int v8;
  uint8_t buf[16];

  v4 = qword_1009997E8;
  if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "CountryCode: Location refresh timer expiry", buf, 2u);
  }
  sub_1006AB170(a1);
  v5 = dispatch_time(0, 1000000000 * a2);
  global_queue = dispatch_get_global_queue(0, 0);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_1006AB444;
  v7[3] = &unk_1009173C0;
  v7[4] = a1;
  v8 = a2;
  dispatch_after(v5, global_queue, v7);
}

uint64_t sub_1006AB444(uint64_t a1)
{
  return sub_1006AB360(*(_QWORD *)(a1 + 32), *(unsigned int *)(a1 + 40));
}

void sub_1006AB454(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  dispatch_time_t v4;
  NSObject *global_queue;
  _QWORD v6[5];
  unsigned int v7;
  void *__p[2];
  char v9;
  unsigned int v10;
  uint8_t buf[8];
  char v12;

  v1 = *(_QWORD *)(a1 + 32);
  v10 = 3599;
  v2 = sub_100027F68();
  sub_100091AE8(buf, "LOCATION");
  sub_100091AE8(__p, "RefreshTime");
  (*(void (**)(uint64_t, uint8_t *, void **, unsigned int *))(*(_QWORD *)v2 + 128))(v2, buf, __p, &v10);
  if (v9 < 0)
    operator delete(__p[0]);
  if (v12 < 0)
    operator delete(*(void **)buf);
  v3 = qword_1009997E8;
  if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v10;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "CountryCode: Location refresh time set to %u", buf, 8u);
  }
  v4 = dispatch_time(0, 1000000000 * v10);
  global_queue = dispatch_get_global_queue(0, 0);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_1006AB610;
  v6[3] = &unk_1009173C0;
  v6[4] = v1;
  v7 = v10;
  dispatch_after(v4, global_queue, v6);
}

void sub_1006AB5D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  uint64_t v20;

  if (a20 < 0)
    operator delete(__p);
  if (*(char *)(v20 - 25) < 0)
    operator delete(*(void **)(v20 - 48));
  _Unwind_Resume(exception_object);
}

void sub_1006AB610(uint64_t a1)
{
  sub_1006AB360(*(_QWORD *)(a1 + 32), *(_DWORD *)(a1 + 40));
}

void sub_1006AB620(uint64_t a1, int a2)
{
  uint64_t v3;
  NSObject *v4;
  _DWORD v5[2];

  v3 = *(_QWORD *)(a1 + 32);
  v4 = qword_1009997E8;
  if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
  {
    v5[0] = 67109120;
    v5[1] = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "CountryCode: Callback from GEO..country code available?%d", (uint8_t *)v5, 8u);
  }
  sub_1006AB6D4(v3);
}

void sub_1006AB6D4(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  NSObject *v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint8_t buf[4];
  void *v15;

  v2 = (void *)objc_claimAutoreleasedReturnValue(+[GEOCountryConfiguration sharedConfiguration](GEOCountryConfiguration, "sharedConfiguration"));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "countryCode"));
  v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@"), v3));

  v5 = qword_1009997E8;
  if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138543362;
    v15 = v4;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "CountryCode: Callback from GEO, Country: %{public}@", buf, 0xCu);
  }
  if (v4 && (objc_msgSend(*(id *)(a1 + 88), "isEqualToString:", v4) & 1) == 0)
  {
    sub_1006AAE28(a1, v4);
  }
  else
  {
    v6 = qword_1009997E8;
    if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEBUG))
      sub_10071A84C(v6, v7, v8, v9, v10, v11, v12, v13);
  }

}

void sub_1006AB80C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id sub_1006AB83C(uint64_t a1, _QWORD *a2)
{
  void *v3;
  void *v4;
  void *v5;
  NSObject *v6;
  NSObject *v7;
  void *v8;
  void *v9;
  id v10;
  NSObject *v11;
  unsigned int v12;
  NSObject *v13;
  int v15;
  id v16;
  __int16 v17;
  unsigned int v18;

  v3 = (void *)objc_claimAutoreleasedReturnValue(+[RDEstimate currentEstimates](RDEstimate, "currentEstimates"));
  if (!objc_msgSend(v3, "count"))
  {
    v7 = qword_1009997E8;
    if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v15) = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "RegulatoryDomain current estimates not available", (uint8_t *)&v15, 2u);
    }
    v5 = 0;
    goto LABEL_10;
  }
  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectAtIndex:", 0));
  v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "countryCode"));
  v6 = qword_1009997E8;
  if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
  {
    v15 = 138412546;
    v16 = v5;
    v17 = 1024;
    v18 = objc_msgSend(v5, "length");
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "RegulatoryDomain current estimates -- countryCode = %@ countryCode length = %d", (uint8_t *)&v15, 0x12u);
  }

  if (!v5 || objc_msgSend(v5, "length") != (id)2)
  {
LABEL_10:

    v5 = 0;
  }
  *a2 = 0;
  v8 = (void *)objc_claimAutoreleasedReturnValue(+[RDEstimate lastKnownEstimates](RDEstimate, "lastKnownEstimates"));
  if (objc_msgSend(v8, "count"))
  {
    v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "objectAtIndex:", 0));
    v10 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "countryCode"));
    v11 = qword_1009997E8;
    if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
    {
      v12 = objc_msgSend(v10, "length");
      v15 = 138412546;
      v16 = v10;
      v17 = 1024;
      v18 = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "RegulatoryDomain last-known estimates -- countryCode = %@ countryCode length = %d", (uint8_t *)&v15, 0x12u);
    }

    if (v10 && objc_msgSend(v10, "length") == (id)2)
    {
      v10 = objc_retainAutorelease(v10);
      *a2 = v10;
    }
  }
  else
  {
    v13 = qword_1009997E8;
    if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v15) = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "RegulatoryDomain last-known estimates not available", (uint8_t *)&v15, 2u);
    }
    v10 = 0;
  }

  return v5;
}

void sub_1006ABAC4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1006ABB3C(uint64_t a1, void *a2)
{
  id v3;
  NSObject *v4;
  int v5;
  id v6;

  v3 = a2;
  v4 = qword_1009997E8;
  if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
  {
    v5 = 138412290;
    v6 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "PurpleLocation::simulateLocationUpdate: country = %@", (uint8_t *)&v5, 0xCu);
  }
  sub_1006AAE28(a1, v3);

}

void sub_1006ABBFC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1006ABC14(os_unfair_lock_s *a1, void *a2, char a3, char a4, char a5, char a6, char a7)
{
  id v13;
  _QWORD v14[4];
  id v15;
  char v16;
  char v17;
  char v18;
  char v19;
  char v20;

  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  v14[2] = sub_1006AC1F0;
  v14[3] = &unk_10093FCE8;
  v15 = a2;
  v16 = a3;
  v17 = a4;
  v18 = a5;
  v19 = a6;
  v20 = a7;
  v13 = v15;
  sub_1006AC134(a1 + 14, v14);

}

void sub_1006ABCC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  void *v13;

  _Unwind_Resume(a1);
}

uint64_t sub_1006ABCE0(uint64_t a1, uint64_t a2, int a3)
{
  NSObject *v5;
  uint64_t v6;
  NSObject *v7;
  NSObject *v8;
  uint64_t (*v9)(void);
  int v11;
  uint64_t v12;

  v5 = qword_1009997E8;
  if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
  {
    v6 = *(_QWORD *)(a1 + 88);
    v11 = 138543362;
    v12 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Gaze: Current country code: %{public}@", (uint8_t *)&v11, 0xCu);
  }
  if ((objc_msgSend(*(id *)(a1 + 88), "isEqualToString:", CFSTR("CA")) & 1) != 0
    || (objc_msgSend(*(id *)(a1 + 88), "isEqualToString:", CFSTR("US")) & 1) != 0
    || a3)
  {
    v8 = qword_1009997E8;
    if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v11) = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Setting Gaze State to controller: On head", (uint8_t *)&v11, 2u);
    }
  }
  else
  {
    v7 = qword_1009997E8;
    if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v11) = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Setting Gaze State to controller: On body", (uint8_t *)&v11, 2u);
    }
  }
  v9 = *(uint64_t (**)(void))(*(_QWORD *)sub_1000438A4() + 96);
  return v9();
}

uint64_t sub_1006ABE64(uint64_t a1, uint64_t a2, int a3)
{
  return sub_1006ABCE0(a1 - 16, 0, a3);
}

void sub_1006ABE70(uint64_t a1, uint64_t a2)
{
  sub_100069060(a1 + 24, a2);
}

void sub_1006ABE78(uint64_t a1, uint64_t a2)
{
  sub_1006ABE80(a1 + 24, a2);
}

void sub_1006ABE80(uint64_t a1, uint64_t a2)
{
  char *v4;
  char *v5;
  uint64_t v6;

  os_unfair_lock_lock((os_unfair_lock_t)a1);
  v5 = *(char **)(a1 + 8);
  v4 = *(char **)(a1 + 16);
  if (v5 != v4)
  {
    while (*(_QWORD *)v5 != a2)
    {
      v5 += 8;
      if (v5 == v4)
      {
        v5 = *(char **)(a1 + 16);
        break;
      }
    }
  }
  if (v5 == v4)
  {
    v6 = a2;
    sub_1006AC614(a1 + 8, v4, (char *)&v6);
    sub_10007AA30(a1 + 8);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

void sub_1006ABF08(uint64_t a1, uint64_t a2)
{
  sub_100069060(a1 + 56, a2);
}

void sub_1006ABF10(uint64_t a1, uint64_t a2)
{
  sub_1006ABF18(a1 + 56, a2);
}

void sub_1006ABF18(uint64_t a1, uint64_t a2)
{
  char *v4;
  char *v5;
  uint64_t v6;

  os_unfair_lock_lock((os_unfair_lock_t)a1);
  v5 = *(char **)(a1 + 8);
  v4 = *(char **)(a1 + 16);
  if (v5 != v4)
  {
    while (*(_QWORD *)v5 != a2)
    {
      v5 += 8;
      if (v5 == v4)
      {
        v5 = *(char **)(a1 + 16);
        break;
      }
    }
  }
  if (v5 == v4)
  {
    v6 = a2;
    sub_1006AC850(a1 + 8, v4, (char *)&v6);
    sub_10007AA30(a1 + 8);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

void sub_1006ABFA0(os_unfair_lock_s *a1, void *a2, char a3, char a4, char a5)
{
  id v9;
  _QWORD v10[4];
  id v11;
  char v12;
  char v13;
  char v14;

  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_1006AC110;
  v10[3] = &unk_10093FCC0;
  v11 = a2;
  v12 = a3;
  v13 = a4;
  v14 = a5;
  v9 = v11;
  sub_1006AC054(a1 + 6, v10);

}

void sub_1006AC03C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  void *v13;

  _Unwind_Resume(a1);
}

void sub_1006AC054(os_unfair_lock_s *a1, void *a2)
{
  void (**v3)(id, _QWORD);
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;

  v3 = a2;
  os_unfair_lock_lock(a1);
  v5 = 0;
  v6 = 0;
  v7 = 0;
  sub_10001FE6C(&v5, (uint64_t)&a1[2]);
  os_unfair_lock_unlock(a1);
  v4 = v5;
  if (v5 != v6)
  {
    do
      v3[2](v3, *v4++);
    while (v4 != v6);
    v4 = v5;
  }
  if (v4)
  {
    v6 = v4;
    operator delete(v4);
  }

}

void sub_1006AC0E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  void *v11;

  _Unwind_Resume(a1);
}

uint64_t sub_1006AC110(uint64_t a1, uint64_t (***a2)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))
{
  return (**a2)(a2, *(_QWORD *)(a1 + 32), *(unsigned __int8 *)(a1 + 40), *(unsigned __int8 *)(a1 + 41), *(unsigned __int8 *)(a1 + 42));
}

void sub_1006AC134(os_unfair_lock_s *a1, void *a2)
{
  void (**v3)(id, _QWORD);
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;

  v3 = a2;
  os_unfair_lock_lock(a1);
  v5 = 0;
  v6 = 0;
  v7 = 0;
  sub_10001FE6C(&v5, (uint64_t)&a1[2]);
  os_unfair_lock_unlock(a1);
  v4 = v5;
  if (v5 != v6)
  {
    do
      v3[2](v3, *v4++);
    while (v4 != v6);
    v4 = v5;
  }
  if (v4)
  {
    v6 = v4;
    operator delete(v4);
  }

}

void sub_1006AC1C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  void *v11;

  _Unwind_Resume(a1);
}

uint64_t sub_1006AC1F0(uint64_t a1, uint64_t (***a2)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))
{
  return (**a2)(a2, *(_QWORD *)(a1 + 32), *(unsigned __int8 *)(a1 + 40), *(unsigned __int8 *)(a1 + 41), *(unsigned __int8 *)(a1 + 42), *(unsigned __int8 *)(a1 + 43), *(unsigned __int8 *)(a1 + 44));
}

uint64_t sub_1006AC21C(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
}

uint64_t sub_1006AC228(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 - 8) + 24))(a1 - 8);
}

void sub_1006AC24C(uint64_t a1, uint64_t a2)
{
  char *v4;
  char *v5;
  char *v6;
  uint64_t v7;

  os_unfair_lock_lock((os_unfair_lock_t)a1);
  v4 = *(char **)(a1 + 8);
  v5 = *(char **)(a1 + 16);
  if (v4 == v5)
  {
    v6 = *(char **)(a1 + 8);
    goto LABEL_10;
  }
  v6 = *(char **)(a1 + 8);
  while (*(_QWORD *)v6 != a2)
  {
    v6 += 8;
    if (v6 == v5)
    {
      v6 = *(char **)(a1 + 16);
      break;
    }
  }
  if (v6 == v5)
  {
    if (v4 != v5)
    {
LABEL_11:
      v7 = a2;
      sub_1006AC300(a1 + 8, v6, (char *)&v7);
      sub_10007AA30(a1 + 8);
      goto LABEL_12;
    }
LABEL_10:
    (***(void (****)(_QWORD, uint64_t))(a1 + 32))(*(_QWORD *)(a1 + 32), a1);
    goto LABEL_11;
  }
LABEL_12:
  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

char *sub_1006AC300(uint64_t a1, char *__src, char *a3)
{
  char *v3;
  char *v4;
  char *v6;
  unint64_t v7;
  uint64_t v8;
  char *v9;
  char *v10;
  _QWORD *v11;
  uint64_t v12;
  char *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  char *v20;
  unint64_t v21;
  unint64_t v22;
  char *v23;
  uint64_t v24;
  void *__p;
  char *v27;
  char *v28;
  char *v29;
  uint64_t v30;

  v3 = a3;
  v4 = __src;
  v6 = *(char **)(a1 + 8);
  v8 = a1 + 16;
  v7 = *(_QWORD *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    v13 = *(char **)a1;
    v14 = ((uint64_t)&v6[-*(_QWORD *)a1] >> 3) + 1;
    if (v14 >> 61)
      abort();
    v15 = __src - v13;
    v16 = (__src - v13) >> 3;
    v17 = v7 - (_QWORD)v13;
    if (v17 >> 2 > v14)
      v14 = v17 >> 2;
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8)
      v18 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v18 = v14;
    v30 = a1 + 16;
    if (v18)
      v19 = (char *)sub_10007ABA0(a1 + 16, v18);
    else
      v19 = 0;
    v20 = &v19[8 * v16];
    __p = v19;
    v27 = v20;
    v28 = v20;
    v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4)
          v22 = 1;
        else
          v22 = v15 >> 2;
        v23 = (char *)sub_10007ABA0(v8, v22);
        v20 = &v23[8 * (v22 >> 2)];
        __p = v23;
        v27 = v20;
        v29 = &v23[8 * v24];
        if (v19)
          operator delete(v19);
      }
      else
      {
        v21 = v16 + 2;
        if (v16 >= -1)
          v21 = v16 + 1;
        v20 -= 8 * (v21 >> 1);
        v27 = v20;
      }
    }
    *(_QWORD *)v20 = *(_QWORD *)v3;
    v28 = v20 + 8;
    v4 = sub_10007AADC((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27)
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8;
    if (__p)
      operator delete(__p);
  }
  else if (__src == v6)
  {
    *(_QWORD *)__src = *(_QWORD *)a3;
    *(_QWORD *)(a1 + 8) = __src + 8;
  }
  else
  {
    v9 = __src + 8;
    v10 = v6 - 8;
    v11 = *(_QWORD **)(a1 + 8);
    while (v10 < v6)
    {
      v12 = *(_QWORD *)v10;
      v10 += 8;
      *v11++ = v12;
    }
    *(_QWORD *)(a1 + 8) = v11;
    if (v6 != v9)
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    if (v4 <= v3)
      v3 += 8 * (*(_QWORD *)(a1 + 8) > (unint64_t)v3);
    *(_QWORD *)v4 = *(_QWORD *)v3;
  }
  return v4;
}

void sub_1006AC504(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1006AC53C(id a1)
{
  NSObject *v1;
  uint64_t v2;
  uint8_t v3[16];

  v1 = qword_1009997E8;
  if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Received RegulatoryDomain country code update notification", v3, 2u);
  }
  v2 = sub_10034FE84();
  (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
}

void sub_1006AC5B0(id a1)
{
  operator new();
}

void sub_1006AC5F0()
{
  operator delete();
}

char *sub_1006AC614(uint64_t a1, char *__src, char *a3)
{
  char *v3;
  char *v4;
  char *v6;
  unint64_t v7;
  uint64_t v8;
  char *v9;
  char *v10;
  _QWORD *v11;
  uint64_t v12;
  char *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  char *v20;
  unint64_t v21;
  unint64_t v22;
  char *v23;
  uint64_t v24;
  void *__p;
  char *v27;
  char *v28;
  char *v29;
  uint64_t v30;

  v3 = a3;
  v4 = __src;
  v6 = *(char **)(a1 + 8);
  v8 = a1 + 16;
  v7 = *(_QWORD *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    v13 = *(char **)a1;
    v14 = ((uint64_t)&v6[-*(_QWORD *)a1] >> 3) + 1;
    if (v14 >> 61)
      abort();
    v15 = __src - v13;
    v16 = (__src - v13) >> 3;
    v17 = v7 - (_QWORD)v13;
    if (v17 >> 2 > v14)
      v14 = v17 >> 2;
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8)
      v18 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v18 = v14;
    v30 = a1 + 16;
    if (v18)
      v19 = (char *)sub_10007ABA0(a1 + 16, v18);
    else
      v19 = 0;
    v20 = &v19[8 * v16];
    __p = v19;
    v27 = v20;
    v28 = v20;
    v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4)
          v22 = 1;
        else
          v22 = v15 >> 2;
        v23 = (char *)sub_10007ABA0(v8, v22);
        v20 = &v23[8 * (v22 >> 2)];
        __p = v23;
        v27 = v20;
        v29 = &v23[8 * v24];
        if (v19)
          operator delete(v19);
      }
      else
      {
        v21 = v16 + 2;
        if (v16 >= -1)
          v21 = v16 + 1;
        v20 -= 8 * (v21 >> 1);
        v27 = v20;
      }
    }
    *(_QWORD *)v20 = *(_QWORD *)v3;
    v28 = v20 + 8;
    v4 = sub_10007AADC((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27)
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8;
    if (__p)
      operator delete(__p);
  }
  else if (__src == v6)
  {
    *(_QWORD *)__src = *(_QWORD *)a3;
    *(_QWORD *)(a1 + 8) = __src + 8;
  }
  else
  {
    v9 = __src + 8;
    v10 = v6 - 8;
    v11 = *(_QWORD **)(a1 + 8);
    while (v10 < v6)
    {
      v12 = *(_QWORD *)v10;
      v10 += 8;
      *v11++ = v12;
    }
    *(_QWORD *)(a1 + 8) = v11;
    if (v6 != v9)
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    if (v4 <= v3)
      v3 += 8 * (*(_QWORD *)(a1 + 8) > (unint64_t)v3);
    *(_QWORD *)v4 = *(_QWORD *)v3;
  }
  return v4;
}

void sub_1006AC818(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

char *sub_1006AC850(uint64_t a1, char *__src, char *a3)
{
  char *v3;
  char *v4;
  char *v6;
  unint64_t v7;
  uint64_t v8;
  char *v9;
  char *v10;
  _QWORD *v11;
  uint64_t v12;
  char *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  char *v20;
  unint64_t v21;
  unint64_t v22;
  char *v23;
  uint64_t v24;
  void *__p;
  char *v27;
  char *v28;
  char *v29;
  uint64_t v30;

  v3 = a3;
  v4 = __src;
  v6 = *(char **)(a1 + 8);
  v8 = a1 + 16;
  v7 = *(_QWORD *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    v13 = *(char **)a1;
    v14 = ((uint64_t)&v6[-*(_QWORD *)a1] >> 3) + 1;
    if (v14 >> 61)
      abort();
    v15 = __src - v13;
    v16 = (__src - v13) >> 3;
    v17 = v7 - (_QWORD)v13;
    if (v17 >> 2 > v14)
      v14 = v17 >> 2;
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8)
      v18 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v18 = v14;
    v30 = a1 + 16;
    if (v18)
      v19 = (char *)sub_10007ABA0(a1 + 16, v18);
    else
      v19 = 0;
    v20 = &v19[8 * v16];
    __p = v19;
    v27 = v20;
    v28 = v20;
    v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4)
          v22 = 1;
        else
          v22 = v15 >> 2;
        v23 = (char *)sub_10007ABA0(v8, v22);
        v20 = &v23[8 * (v22 >> 2)];
        __p = v23;
        v27 = v20;
        v29 = &v23[8 * v24];
        if (v19)
          operator delete(v19);
      }
      else
      {
        v21 = v16 + 2;
        if (v16 >= -1)
          v21 = v16 + 1;
        v20 -= 8 * (v21 >> 1);
        v27 = v20;
      }
    }
    *(_QWORD *)v20 = *(_QWORD *)v3;
    v28 = v20 + 8;
    v4 = sub_10007AADC((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27)
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8;
    if (__p)
      operator delete(__p);
  }
  else if (__src == v6)
  {
    *(_QWORD *)__src = *(_QWORD *)a3;
    *(_QWORD *)(a1 + 8) = __src + 8;
  }
  else
  {
    v9 = __src + 8;
    v10 = v6 - 8;
    v11 = *(_QWORD **)(a1 + 8);
    while (v10 < v6)
    {
      v12 = *(_QWORD *)v10;
      v10 += 8;
      *v11++ = v12;
    }
    *(_QWORD *)(a1 + 8) = v11;
    if (v6 != v9)
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    if (v4 <= v3)
      v3 += 8 * (*(_QWORD *)(a1 + 8) > (unint64_t)v3);
    *(_QWORD *)v4 = *(_QWORD *)v3;
  }
  return v4;
}

void sub_1006ACA54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1006ACA8C(uint64_t a1)
{
  uint64_t v1;

  v1 = sub_100278350(a1, 23);
  sub_100321888(v1 + 256, 0, 1, 1007);
}

void sub_1006ACAE0(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_100278464(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1006ACAF8(uint64_t a1)
{
  sub_1003219A8(a1 + 256);
  return sub_100278464(a1);
}

uint64_t sub_1006ACB20(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 - 256;
  sub_1003219A8(a1);
  return sub_100278464(v1);
}

void sub_1006ACB44(uint64_t a1)
{
  sub_1003219A8(a1 + 256);
  sub_100278464(a1);
  operator delete();
}

void sub_1006ACB80(uint64_t a1)
{
  sub_1006ACB44(a1 - 256);
}

uint64_t sub_1006ACB88(uint64_t a1)
{
  _BYTE *v2;
  uint64_t v3;
  char v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;

  v8 = 0u;
  v9 = 0u;
  v6 = 0u;
  v7 = 0u;
  v2 = (_BYTE *)(a1 + 504);
  *(_BYTE *)(a1 + 504) = 3;
  v5 = 0;
  sub_100043758(&v5);
  if (sub_10023E274((uint64_t)sub_1006ACD30, (uint64_t)off_10093FEA0, 0x3EFu, 0x3B01u, v2, (uint64_t)&unk_10093FEC8))
  {
    if (os_log_type_enabled((os_log_t)qword_1009997D8, OS_LOG_TYPE_ERROR))
      sub_10071A93C();
LABEL_10:
    v3 = 1;
    goto LABEL_11;
  }
  *(_QWORD *)&v8 = &unk_10093FEF8;
  WORD4(v8) = 3;
  *(_QWORD *)&v9 = &unk_10093FE70;
  WORD4(v9) = 1;
  *(_QWORD *)&v6 = &unk_10093FF40;
  WORD4(v6) = 3;
  *(_QWORD *)&v7 = &unk_10093FE88;
  WORD4(v7) = 1;
  byte_100994148 = 1;
  word_10099414A = 1;
  dword_100994150 = *(unsigned __int8 *)(a1 + 504);
  if (sub_1002465CC((uint64_t)&v8, (int *)(a1 + 496)))
  {
    if (os_log_type_enabled((os_log_t)qword_1009997D8, OS_LOG_TYPE_ERROR))
      sub_10071A8DC();
    goto LABEL_10;
  }
  v3 = sub_1002465CC((uint64_t)&v6, (int *)(a1 + 500));
  if ((_DWORD)v3)
  {
    if (os_log_type_enabled((os_log_t)qword_1009997D8, OS_LOG_TYPE_ERROR))
      sub_10071A87C();
    goto LABEL_10;
  }
LABEL_11:
  sub_100043728(&v5);
  return v3;
}

void sub_1006ACD1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  sub_100043728(&a13);
  _Unwind_Resume(a1);
}

void sub_1006ACD30(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  if (qword_10097B838 != -1)
    dispatch_once(&qword_10097B838, &stru_10093FFA8);
  sub_1006AD2B8(off_10097B830, a1, a4);
}

uint64_t sub_1006ACD88(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char v12;

  v12 = 0;
  sub_100043758(&v12);
  sub_1002467B8(*(_DWORD *)(a1 + 496));
  sub_1002467B8(*(_DWORD *)(a1 + 500));
  if (sub_10023E540(*(unsigned __int8 *)(a1 + 504)) == 101)
  {
    v2 = qword_1009997D8;
    if (os_log_type_enabled((os_log_t)qword_1009997D8, OS_LOG_TYPE_ERROR))
      sub_10070B488(v2, v3, v4, v5, v6, v7, v8, v9);
    v10 = 1;
  }
  else
  {
    v10 = 0;
  }
  sub_100043728(&v12);
  return v10;
}

void sub_1006ACE18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  sub_100043728(&a13);
  _Unwind_Resume(a1);
}

uint64_t sub_1006ACE30(uint64_t a1)
{
  sub_10032251C(a1 + 256);
  return 0;
}

uint64_t sub_1006ACE4C(uint64_t a1, unint64_t a2)
{
  int v4;
  _OWORD *v5;
  _OWORD *v6;
  _QWORD *v7;
  uint64_t v9;
  BOOL v10;
  int v11;
  uint64_t v12;
  NSObject *v13;
  NSObject *v14;
  void **v15;
  const char *v16;
  void *v18;
  _OWORD *v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  void *__p[2];
  char v24;
  _BYTE buf[18];
  __int16 v26;
  const char *v27;

  if (a2)
  {
    v21 = unk_10093FF98;
    v22 = unk_10093FF88;
    v18 = 0;
    v19 = 0;
    v20 = 0;
    v4 = sub_1004442A0(a2, (uint64_t)&v21, 4u, &v18);
    if ((v4 & 1) != 0 || sub_1004442A0(a2, (uint64_t)&v22, 4u, &v18))
    {
      v6 = v18;
      v5 = v19;
      if (v18 != v19)
      {
        v7 = v18;
        while (1)
        {
          if (*(_BYTE *)v7 == 6 && *((_WORD *)v7 + 1) == 2)
          {
            v9 = v7[1];
            v10 = *(_BYTE *)v9 == 3 && *(_DWORD *)(v9 + 8) == 3;
            if (v10 && *(_BYTE *)(v9 + 16) == 1)
              break;
          }
          v7 += 2;
          if (v7 == (_QWORD *)v19)
          {
            v11 = -1;
            goto LABEL_26;
          }
        }
        v11 = *(_DWORD *)(v9 + 24);
LABEL_26:
        while (v6 != v5)
        {
          *(_OWORD *)buf = *v6;
          sub_1002C3FB4(buf);
          ++v6;
          v5 = v19;
        }
        if (v11 != -1)
        {
          v14 = qword_1009997D8;
          if (os_log_type_enabled((os_log_t)qword_1009997D8, OS_LOG_TYPE_INFO))
          {
            sub_10043E5F8(a2, __p);
            if (v24 >= 0)
              v15 = __p;
            else
              v15 = (void **)__p[0];
            v16 = "Old WiAP UUID";
            *(_DWORD *)buf = 136446722;
            if (v4)
              v16 = "New WiAP UUID";
            *(_QWORD *)&buf[4] = v15;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v11;
            v26 = 2082;
            v27 = v16;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "Initiating outgoing Wireless IAP connection request to device %{public}s on rfcomm channel %d,  %{public}s", buf, 0x1Cu);
            if (v24 < 0)
              operator delete(__p[0]);
          }
          LOBYTE(__p[0]) = 0;
          sub_100043758(__p);
          *(_WORD *)buf = 0;
          if (sub_10023E88C((uint64_t)sub_1006AD1C8, off_10093FEA0, a2 + 128, v11, 0x3EFu, 0x3B01u, buf, (uint64_t)&unk_10093FEC8))
          {
            if (os_log_type_enabled((os_log_t)qword_1009997D8, OS_LOG_TYPE_ERROR))
              sub_10071A9F4();
            v12 = 305;
          }
          else
          {
            sub_1004820E0(a1, a2, *(__int16 *)buf);
            v12 = 0;
          }
          sub_100043728(__p);
          goto LABEL_45;
        }
      }
      if (os_log_type_enabled((os_log_t)qword_1009997D8, OS_LOG_TYPE_ERROR))
        sub_10071A9C8();
    }
    else
    {
      v13 = qword_1009997D8;
      if (os_log_type_enabled((os_log_t)qword_1009997D8, OS_LOG_TYPE_ERROR))
      {
        sub_10043E5F8(a2, buf);
        sub_10070B5AC(buf, (uint64_t)__p, v13);
      }
    }
    v12 = 305;
LABEL_45:
    if (v18)
    {
      v19 = v18;
      operator delete(v18);
    }
    return v12;
  }
  if (os_log_type_enabled((os_log_t)qword_1009997D8, OS_LOG_TYPE_ERROR))
    sub_10071A99C();
  return 1;
}

void sub_1006AD184(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1006AD1C8(int a1, uint64_t a2, uint64_t a3)
{
  if (qword_10097B838 != -1)
    dispatch_once(&qword_10097B838, &stru_10093FFA8);
  sub_1006AD4CC(off_10097B830, a1, a3);
}

uint64_t sub_1006AD220(_QWORD *a1, unint64_t a2)
{
  unsigned int v2;
  uint64_t v3;
  char v5;

  v2 = sub_1004821D4(a1, a2);
  v5 = 0;
  sub_100043758(&v5);
  v3 = sub_10023EEBC(v2, 1818);
  if ((_DWORD)v3)
  {
    if (os_log_type_enabled((os_log_t)qword_1009997D8, OS_LOG_TYPE_ERROR))
      sub_1006FD130();
    v3 = 1;
  }
  sub_100043728(&v5);
  return v3;
}

void sub_1006AD2A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  sub_100043728(&a13);
  _Unwind_Resume(a1);
}

void sub_1006AD2B8(_QWORD *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v6;
  NSObject *v7;
  void **v8;
  int v9;
  int v10;
  char v11;
  NSObject *v12;
  int v13;
  NSObject *v14;
  void *__p[2];
  char v16;
  uint8_t buf[4];
  void **v18;

  if (qword_1009778E8 != -1)
    dispatch_once(&qword_1009778E8, &stru_100940038);
  LODWORD(__p[0]) = *(_DWORD *)a2;
  WORD2(__p[0]) = *(_WORD *)(a2 + 4);
  v6 = sub_1004704A8((uint64_t)off_1009778E0, (uint64_t)__p, 1);
  v7 = qword_1009997D8;
  if (os_log_type_enabled((os_log_t)qword_1009997D8, OS_LOG_TYPE_DEFAULT))
  {
    sub_10043E5F8(v6, __p);
    v8 = v16 >= 0 ? __p : (void **)__p[0];
    *(_DWORD *)buf = 136446210;
    v18 = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Received incoming connection attempt from device %{public}s", buf, 0xCu);
    if (v16 < 0)
      operator delete(__p[0]);
  }
  v9 = sub_100481EC8((uint64_t)a1, v6);
  if ((v9 & 1) != 0)
  {
    v10 = sub_10023EB7C((uint64_t)sub_1006AD1C8, a3, v9);
    v11 = v9 ^ 1;
    if (v10)
      v11 = 1;
    if ((v11 & 1) == 0)
    {
      sub_1004820E0((uint64_t)a1, v6, a3);
      sub_1004816DC(a1, v6);
    }
  }
  else
  {
    v12 = qword_1009997D8;
    if (os_log_type_enabled((os_log_t)qword_1009997D8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(__p[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Denying connection attempt", (uint8_t *)__p, 2u);
    }
    v10 = sub_10023EB7C((uint64_t)sub_1006AD1C8, a3, v9);
  }
  v13 = v10;
  if (v10)
  {
    v14 = qword_1009997D8;
    if (os_log_type_enabled((os_log_t)qword_1009997D8, OS_LOG_TYPE_ERROR))
      sub_10070B614(v9, v13, v14);
  }
}

void sub_1006AD4CC(_QWORD *a1, int a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  int v8;
  void **v9;
  void *__p[2];
  char v11;
  uint8_t buf[4];
  void **v13;
  __int16 v14;
  int v15;

  v5 = sub_1004822D0(a1, a2);
  if (v5)
  {
    v6 = v5;
    if ((_DWORD)a3)
    {
      v7 = qword_1009997D8;
      if (os_log_type_enabled((os_log_t)qword_1009997D8, OS_LOG_TYPE_ERROR))
      {
        sub_10043E5F8(v6, __p);
        v9 = v11 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)buf = 136446466;
        v13 = v9;
        v14 = 1024;
        v15 = a3;
        _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Connection to device %{public}s failed - result was %{bluetooth:OI_STATUS}u", buf, 0x12u);
        if (v11 < 0)
          operator delete(__p[0]);
      }
      if (qword_100977A58 != -1)
        dispatch_once(&qword_100977A58, &stru_100940058);
      v8 = sub_1004A35C0((uint64_t)off_100977A50, a3, 20000);
      sub_10048183C((uint64_t)a1, v6, v8);
    }
    sub_10048183C((uint64_t)a1, v5, 0);
  }
  if (os_log_type_enabled((os_log_t)qword_1009997D8, OS_LOG_TYPE_ERROR))
    sub_10071AA54();
}

void sub_1006AD6D8(_QWORD *a1, int a2, uint64_t a3, int a4)
{
  unint64_t v7;

  v7 = sub_1004822D0(a1, a2);
  if (v7)
  {
    sub_100322608((uint64_t)(a1 + 32), v7, a3, a4, 0);
  }
  else if (os_log_type_enabled((os_log_t)qword_1009997D8, OS_LOG_TYPE_ERROR))
  {
    sub_10071AB2C();
  }
}

void sub_1006AD758(_QWORD *a1, int a2)
{
  unint64_t v3;

  v3 = sub_1004822D0(a1, a2);
  if (v3)
  {
    sub_10032280C((uint64_t)(a1 + 32), v3);
  }
  else if (os_log_type_enabled((os_log_t)qword_1009997D8, OS_LOG_TYPE_ERROR))
  {
    sub_10071AB58();
  }
}

BOOL sub_1006AD7B8(_QWORD *a1, unint64_t a2, char *a3, unsigned __int16 a4)
{
  unsigned int v6;
  int v7;
  char v9;

  v6 = sub_1004821D4(a1, a2);
  v9 = 0;
  sub_100043758(&v9);
  v7 = sub_10023E880((uint64_t)sub_1006AD878, v6, a3, a4);
  sub_10004339C(&v9);
  if (v7 && os_log_type_enabled((os_log_t)qword_1009997D8, OS_LOG_TYPE_ERROR))
    sub_10071AB84();
  sub_100043728(&v9);
  return v7 == 0;
}

void sub_1006AD864(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  sub_100043728(&a13);
  _Unwind_Resume(a1);
}

void sub_1006AD878(int a1, uint64_t a2, uint64_t a3, int a4)
{
  if (a4 && os_log_type_enabled((os_log_t)qword_1009997D8, OS_LOG_TYPE_ERROR))
    sub_10071ABE4();
  if (qword_10097B838 != -1)
    dispatch_once(&qword_10097B838, &stru_10093FFA8);
  sub_1006AD758(off_10097B830, a1);
}

BOOL sub_1006AD908(uint64_t a1, unint64_t a2, char *a3, unsigned __int16 a4)
{
  return sub_1006AD7B8((_QWORD *)(a1 - 256), a2, a3, a4);
}

uint64_t sub_1006AD910()
{
  return 3;
}

void sub_1006AD918(int a1)
{
  if (qword_10097B838 != -1)
    dispatch_once(&qword_10097B838, &stru_10093FFA8);
  sub_10042F83C(off_10097B830, a1);
}

void sub_1006AD970(int a1, uint64_t a2, int a3)
{
  if (qword_10097B838 != -1)
    dispatch_once(&qword_10097B838, &stru_10093FFA8);
  sub_1006AD6D8(off_10097B830, a1, a2, a3);
}

void sub_1006AD9D8(id a1)
{
  operator new();
}

void sub_1006ADA18()
{
  operator delete();
}

void sub_1006ADA3C(id a1)
{
  operator new();
}

void sub_1006ADA7C()
{
  operator delete();
}

void sub_1006ADAA0(id a1)
{
  operator new();
}

void sub_1006ADAE0()
{
  operator delete();
}

void sub_1006ADBA4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1006ADC34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)UserNotification;
  -[_Unwind_Exception dealloc](&a9, "dealloc");
  _Unwind_Resume(a1);
}

void sub_1006ADECC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1006ADF74(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1006ADFF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  void *v9;
  void *v10;

  v10 = v9;

  a9.super_class = (Class)UninstallObserver;
  -[_Unwind_Exception dealloc](&a9, "dealloc");
  _Unwind_Resume(a1);
}

void sub_1006AE07C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1006AE0E0(id a1)
{
  BTAppInteraction *v1;
  void *v2;

  v1 = objc_opt_new(BTAppInteraction);
  v2 = (void *)qword_100994158;
  qword_100994158 = (uint64_t)v1;

}

void sub_1006AE2A0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1006AE2B8(uint64_t a1, void *a2)
{
  id v3;

  v3 = a2;
  if (objc_msgSend(CFSTR("bluetooth-central"), "isEqualToString:"))
  {
    objc_msgSend(*(id *)(a1 + 32), "setSupportsBackgroundedCentrals:", 1);
  }
  else if (objc_msgSend(CFSTR("bluetooth-peripheral"), "isEqualToString:", v3))
  {
    objc_msgSend(*(id *)(a1 + 32), "setSupportsBackgroundedPeripherals:", 1);
  }

}

void sub_1006AE32C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1006AE340(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  uint64_t v7;
  void *v8;
  NSObject *v9;
  id v10;
  uint64_t v11;
  void *v12;
  NSObject *v13;
  id v14;
  NSObject *v15;
  void *v16;
  NSObject *v17;
  void *v18;
  void *v19;
  int v20;
  id v21;

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 40), "objectForKeyedSubscript:", *(_QWORD *)(a1 + 40)));
  v3 = v2;
  if (v2)
  {
    if (objc_msgSend(v2, "isApp"))
    {
      v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 48), "interestedBundleIDs"));
      v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray arrayWithArray:](NSMutableArray, "arrayWithArray:", v4));

      objc_msgSend(v5, "removeObject:", *(_QWORD *)(a1 + 40));
      v6 = *(void **)(*(_QWORD *)(a1 + 32) + 48);
      if (objc_msgSend(v5, "count"))
        v7 = 15;
      else
        v7 = 0;
      objc_msgSend(v6, "updateInterestedBundleIDs:states:", v5, v7);
      v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 88), "objectForKeyedSubscript:", *(_QWORD *)(a1 + 40)));
      if (v8)
      {
        v9 = qword_1009997E8;
        if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
        {
          v10 = objc_msgSend(objc_retainAutorelease(*(id *)(a1 + 40)), "UTF8String");
          v20 = 136446210;
          v21 = v10;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Removing outstanding process assertion for unregistered application \"%{public}s\"", (uint8_t *)&v20, 0xCu);
        }
        objc_msgSend(v8, "invalidate");
        objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 88), "removeObjectForKey:", *(_QWORD *)(a1 + 40));
      }
      v11 = objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 96), "objectForKeyedSubscript:", *(_QWORD *)(a1 + 40)));

      v12 = (void *)v11;
      if (v11)
      {
        v13 = qword_1009997E8;
        if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
        {
          v14 = objc_msgSend(objc_retainAutorelease(*(id *)(a1 + 40)), "UTF8String");
          v20 = 136446210;
          v21 = v14;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Removing (URGENT) outstanding process assertion for unregistered application \"%{public}s\"", (uint8_t *)&v20, 0xCu);
        }
        objc_msgSend(v12, "invalidate");
        objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 96), "removeObjectForKey:", *(_QWORD *)(a1 + 40));
      }

    }
    v15 = qword_1009997E8;
    if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
    {
      v16 = *(void **)(a1 + 40);
      v20 = 138412290;
      v21 = v16;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Unregistered application - %@", (uint8_t *)&v20, 0xCu);
    }
    objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 40), "removeObjectForKey:", *(_QWORD *)(a1 + 40));
    objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 112), "removeObjectForKey:", *(_QWORD *)(a1 + 40));
  }
  else
  {
    v17 = qword_1009997E8;
    if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_FAULT))
    {
      v19 = *(void **)(a1 + 40);
      v20 = 138543362;
      v21 = v19;
      _os_log_fault_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_FAULT, "Application \"%{public}@\" wasn't registered!", (uint8_t *)&v20, 0xCu);
      v17 = qword_1009997E8;
    }
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      v18 = *(void **)(a1 + 40);
      v20 = 138543362;
      v21 = v18;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Cannot unregister application \"%{public}@\" - info is empty", (uint8_t *)&v20, 0xCu);
    }
  }

}

void sub_1006AE658(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1006AE750(_QWORD *a1)
{
  id v2;

  v2 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1[4] + 40), "objectForKey:", a1[5]));
  *(_DWORD *)(*(_QWORD *)(a1[6] + 8) + 24) = objc_msgSend(v2, "pid");

}

void sub_1006AE79C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1006AE840(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1006AE924(id *a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  NSObject *v6;
  unsigned int v7;
  id v8;
  unsigned int v9;
  const char *v10;
  NSObject *v11;
  id v12;
  NSObject *v13;
  id v14;
  _BYTE v15[12];
  __int16 v16;
  id v17;
  __int16 v18;
  unsigned int v19;
  _QWORD v20[2];
  _QWORD v21[2];

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*((id *)a1[4] + 5), "objectForKey:", a1[5]));
  v3 = v2;
  if (v2)
  {
    if ((objc_msgSend(v2, "isApp") & 1) != 0)
    {
      v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary"));
      if (objc_msgSend(a1[6], "count"))
        objc_msgSend(v4, "setObject:forKey:", a1[6], CFSTR("UIApplicationLaunchOptionsBluetoothCentralsKey"));
      if (objc_msgSend(a1[7], "count"))
        objc_msgSend(v4, "setObject:forKey:", a1[7], CFSTR("UIApplicationLaunchOptionsBluetoothPeripheralsKey"));
      v20[0] = BKSOpenApplicationOptionKeyActivateSuspended;
      v20[1] = BKSOpenApplicationOptionKeyPayloadOptions;
      v21[0] = &__kCFBooleanTrue;
      v21[1] = v4;
      v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v21, v20, 2));
      v6 = qword_1009998F0;
      if (os_log_type_enabled((os_log_t)qword_1009998F0, OS_LOG_TYPE_DEFAULT))
      {
        v7 = objc_msgSend(v3, "isAlive");
        v8 = a1[5];
        v9 = objc_msgSend(v3, "pid");
        v10 = "false";
        *(_DWORD *)v15 = 136315650;
        if (v7)
          v10 = "true";
        *(_QWORD *)&v15[4] = v10;
        v16 = 2112;
        v17 = v8;
        v18 = 1024;
        v19 = v9;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "launchApplication:{isAlive: %s, bundleId: \"%@\", pid: %d}", v15, 0x1Cu);
      }
      if (objc_msgSend(v3, "pid", *(_QWORD *)v15) && (objc_msgSend(v3, "isAlive") & 1) != 0)
      {
        v11 = qword_1009998F0;
        if (os_log_type_enabled((os_log_t)qword_1009998F0, OS_LOG_TYPE_DEFAULT))
        {
          v12 = a1[5];
          *(_DWORD *)v15 = 138543362;
          *(_QWORD *)&v15[4] = v12;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Application pending termination, delaying resurrection - %{public}@", v15, 0xCu);
        }
        objc_msgSend(*((id *)a1[4] + 14), "setObject:forKey:", v5, a1[5]);
      }
      else
      {
        objc_msgSend(a1[4], "openBundle:options:", a1[5], v5);
      }

    }
    else
    {
      v13 = qword_1009998F0;
      if (os_log_type_enabled((os_log_t)qword_1009998F0, OS_LOG_TYPE_DEFAULT))
      {
        v14 = a1[5];
        *(_DWORD *)v15 = 138543362;
        *(_QWORD *)&v15[4] = v14;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Application %{public}@ is a daemon (not supported).", v15, 0xCu);
      }
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_ERROR))
  {
    sub_10071ACC8((uint64_t)objc_msgSend(objc_retainAutorelease(a1[5]), "UTF8String"), (uint64_t)v15);
  }

}

void sub_1006AEC04(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1006AEE78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, void *a15)
{
  void *v15;
  void *v16;
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

void sub_1006AEECC(uint64_t a1)
{
  if (qword_100978170 != -1)
    dispatch_once(&qword_100978170, &stru_100940468);
  sub_1002EF65C((uint64_t)off_100978168, *(void **)(a1 + 32));
}

void sub_1006AEF1C(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  NSObject *v7;
  uint64_t v8;
  void *v9;
  NSObject *v10;
  dispatch_time_t v11;
  unsigned int v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t *v15;
  void *v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;
  _QWORD v20[5];
  id v21;
  id v22;
  int v23;
  uint8_t buf[4];
  uint64_t v25;
  __int16 v26;
  unsigned int v27;

  v5 = a2;
  v6 = a3;
  if (v6)
  {
    v7 = qword_1009998F0;
    if (os_log_type_enabled((os_log_t)qword_1009998F0, OS_LOG_TYPE_ERROR))
      sub_10071AE04(a1, (uint64_t)v6, v7);
    v9 = *(void **)(a1 + 32);
    v8 = *(_QWORD *)(a1 + 40);
    v10 = *(NSObject **)(v8 + 16);
    v20[0] = _NSConcreteStackBlock;
    v20[2] = sub_1006AF174;
    v20[3] = &unk_1009400E8;
    v11 = *(_QWORD *)(a1 + 56);
    v20[1] = 3221225472;
    v20[4] = v8;
    v21 = v9;
    v22 = *(id *)(a1 + 48);
    v23 = *(_DWORD *)(a1 + 64);
    dispatch_after(v11, v10, v20);

  }
  else
  {
    v12 = objc_msgSend(v5, "isValid");
    v13 = qword_1009998F0;
    if (v12)
    {
      if (os_log_type_enabled((os_log_t)qword_1009998F0, OS_LOG_TYPE_DEFAULT))
      {
        v14 = *(_QWORD *)(a1 + 32);
        *(_DWORD *)buf = 138543618;
        v25 = v14;
        v26 = 1026;
        v27 = objc_msgSend(v5, "pid");
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Resurrected: %{public}@, pid: %{public}u", buf, 0x12u);
      }
      v15 = (uint64_t *)(a1 + 32);
      v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)(a1 + 40) + 40), "objectForKeyedSubscript:", *(_QWORD *)(a1 + 32)));
      if (v16)
      {
        objc_msgSend(v16, "setPid:", objc_msgSend(v5, "pid"));
        objc_msgSend(*(id *)(a1 + 40), "takeAssertionForProcess:duration:isUrgent:", *(_QWORD *)(a1 + 32), 10, 0);
      }
      else
      {
        v18 = qword_1009998F0;
        if (os_log_type_enabled((os_log_t)qword_1009998F0, OS_LOG_TYPE_ERROR))
          sub_10071AD2C(v15, v18, v19);
      }

    }
    else if (os_log_type_enabled((os_log_t)qword_1009998F0, OS_LOG_TYPE_ERROR))
    {
      sub_10071AD98(a1, v13, v17);
    }
  }

}

void sub_1006AF148(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id sub_1006AF174(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "openBundle:options:attempt:", *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), (*(_DWORD *)(a1 + 56) + 1));
}

void sub_1006AF208(uint64_t a1)
{
  id v2;
  __int128 v3;
  uint64_t v4;
  void *i;
  void *v6;
  void *v7;
  void *v8;
  NSObject *v9;
  uint64_t v10;
  NSObject *v11;
  _BOOL4 v12;
  uint64_t v13;
  __int128 v14;
  id obj;
  _QWORD block[6];
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  uint8_t buf[4];
  void *v22;
  __int16 v23;
  void *v24;
  __int16 v25;
  uint64_t v26;
  _BYTE v27[128];

  v17 = 0u;
  v18 = 0u;
  v19 = 0u;
  v20 = 0u;
  obj = *(id *)(a1 + 32);
  v2 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v17, v27, 16);
  if (v2)
  {
    v4 = *(_QWORD *)v18;
    *(_QWORD *)&v3 = 138543362;
    v14 = v3;
    do
    {
      for (i = 0; i != v2; i = (char *)i + 1)
      {
        if (*(_QWORD *)v18 != v4)
          objc_enumerationMutation(obj);
        v6 = *(void **)(*((_QWORD *)&v17 + 1) + 8 * (_QWORD)i);
        v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "applicationIdentifier", v14));
        v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)(a1 + 40) + 40), "objectForKey:", v7));
        v9 = qword_1009998F0;
        if (os_log_type_enabled((os_log_t)qword_1009998F0, OS_LOG_TYPE_DEFAULT))
        {
          v10 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 40);
          *(_DWORD *)buf = 138543874;
          v22 = v7;
          v23 = 2112;
          v24 = v8;
          v25 = 2112;
          v26 = v10;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}@ %@ %@", buf, 0x20u);
        }
        v11 = qword_1009998F0;
        v12 = os_log_type_enabled((os_log_t)qword_1009998F0, OS_LOG_TYPE_DEFAULT);
        if (v8)
        {
          if (v12)
          {
            *(_DWORD *)buf = v14;
            v22 = v7;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Application %{public}@ has been uninstalled!", buf, 0xCu);
          }
          v13 = *(_QWORD *)(a1 + 40);
          if (*(_QWORD *)(v13 + 8))
          {
            block[0] = _NSConcreteStackBlock;
            block[1] = 3221225472;
            block[2] = sub_1006AF4B8;
            block[3] = &unk_100918340;
            block[4] = v13;
            block[5] = v6;
            dispatch_async((dispatch_queue_t)&_dispatch_main_q, block);
          }
        }
        else if (v12)
        {
          *(_DWORD *)buf = v14;
          v22 = v7;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Unable To Uninstall %{public}@, AppInfo Not Found", buf, 0xCu);
        }

      }
      v2 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v17, v27, 16);
    }
    while (v2);
  }

}

void sub_1006AF484(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{

  _Unwind_Resume(a1);
}

void sub_1006AF4B8(uint64_t a1)
{
  uint64_t v1;
  id v2;
  void *__p[2];
  char v4;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v2 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "applicationIdentifier")));
  sub_100091AE8(__p, (char *)objc_msgSend(v2, "UTF8String"));
  (*(void (**)(uint64_t, void **, uint64_t))(*(_QWORD *)v1 + 16))(v1, __p, 2);
  if (v4 < 0)
    operator delete(__p[0]);

}

void sub_1006AF52C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  void *v15;

  if (a15 < 0)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_1006AF5D0(uint64_t a1)
{
  void *v2;
  void *v3;
  uint64_t v4;

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 40), "objectForKey:", *(_QWORD *)(a1 + 40)));
  v3 = v2;
  if (v2)
  {
    objc_msgSend(v2, "setIsApp:", 1);
    objc_msgSend(v3, "setSupportsBackgroundedCentrals:", 1);
  }
  else if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_ERROR))
  {
    sub_10071ACC8((uint64_t)objc_msgSend(objc_retainAutorelease(*(id *)(a1 + 40)), "UTF8String"), (uint64_t)&v4);
  }

}

void sub_1006AF694(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1006AF72C(uint64_t a1)
{
  void *v2;
  void *v3;
  uint64_t v4;

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 40), "objectForKey:", *(_QWORD *)(a1 + 40)));
  v3 = v2;
  if (v2)
  {
    objc_msgSend(v2, "setIsApp:", 1);
    objc_msgSend(v3, "setSupportsBackgroundedPeripherals:", 1);
  }
  else if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_ERROR))
  {
    sub_10071ACC8((uint64_t)objc_msgSend(objc_retainAutorelease(*(id *)(a1 + 40)), "UTF8String"), (uint64_t)&v4);
  }

}

void sub_1006AF7F0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1006AF80C(uint64_t a1)
{
  uint64_t v2;
  void *__p[2];
  char v4;

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  sub_100091AE8(__p, (char *)objc_msgSend(objc_retainAutorelease(*(id *)(a1 + 40)), "UTF8String"));
  (*(void (**)(uint64_t, void **, _QWORD))(*(_QWORD *)v2 + 16))(v2, __p, *(unsigned __int8 *)(a1 + 48));
  if (v4 < 0)
    operator delete(__p[0]);
}

void sub_1006AF874(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1006AF890(uint64_t a1)
{
  void (***v2)(_QWORD, void **, _QWORD);
  void *__p[2];
  char v4;

  v2 = *(void (****)(_QWORD, void **, _QWORD))(*(_QWORD *)(a1 + 32) + 8);
  sub_100091AE8(__p, (char *)objc_msgSend(objc_retainAutorelease(*(id *)(a1 + 40)), "UTF8String"));
  (**v2)(v2, __p, *(unsigned __int8 *)(a1 + 48));
  if (v4 < 0)
    operator delete(__p[0]);
}

void sub_1006AF8F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1006AF9A8(uint64_t a1)
{
  void *v2;
  void *v3;
  NSObject *v4;
  uint64_t v5;
  id v6;
  uint64_t v7;
  void *v8;
  void *v9;
  NSObject *v10;
  int v11;
  uint64_t v12;
  __int16 v13;
  id v14;
  _BYTE v15[24];

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 40), "objectForKeyedSubscript:", *(_QWORD *)(a1 + 40)));
  if ((objc_msgSend(v2, "isApp") & 1) != 0)
  {
    if (!objc_msgSend(v2, "pid") && os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_ERROR))
      sub_10071AE78((uint64_t)objc_msgSend(objc_retainAutorelease(*(id *)(a1 + 40)), "UTF8String"), (uint64_t)v15);
    v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 88), "objectForKeyedSubscript:", *(_QWORD *)(a1 + 40)));
    if (v3)
    {
      v4 = qword_1009997E8;
      if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_INFO))
      {
        v5 = *(_QWORD *)(a1 + 48);
        v6 = objc_msgSend(objc_retainAutorelease(*(id *)(a1 + 40)), "UTF8String");
        v11 = 134218242;
        v12 = v5;
        v13 = 2082;
        v14 = v6;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Attempting to add %lu seconds to process assertion for application \"%{public}s\"", (uint8_t *)&v11, 0x16u);
      }
      objc_msgSend(v3, "setSecondsLeft:", (char *)objc_msgSend(v3, "secondsLeft") + *(_QWORD *)(a1 + 48));
      if ((unint64_t)objc_msgSend(v3, "secondsLeft") > 9)
        v7 = 10;
      else
        v7 = (uint64_t)objc_msgSend(v3, "secondsLeft");
      objc_msgSend(v3, "setSecondsLeft:", v7);
    }
    else
    {
      objc_msgSend(*(id *)(a1 + 32), "createAssertionForBundleID:duration:isUrgent:withPid:", *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), 0, objc_msgSend(v2, "pid"));
    }
    if (*(_BYTE *)(a1 + 56)
      && objc_msgSend(*(id *)(a1 + 32), "isPrivilegedBundleID:", *(_QWORD *)(a1 + 40)))
    {
      objc_msgSend(*(id *)(a1 + 32), "disableHIP");
      v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 96), "objectForKeyedSubscript:", *(_QWORD *)(a1 + 40)));

      v8 = v9;
      if (v9)
      {
        v10 = qword_1009997E8;
        if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_INFO))
        {
          LOWORD(v11) = 0;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "(EE) Refreshing URGENT Process Assertion", (uint8_t *)&v11, 2u);
        }
        objc_msgSend(v9, "setSecondsLeft:", 3);
      }
      else
      {
        v8 = 0;
        objc_msgSend(*(id *)(a1 + 32), "createAssertionForBundleID:duration:isUrgent:withPid:", *(_QWORD *)(a1 + 40), 3, 1, objc_msgSend(v2, "pid"));
      }
    }
    else
    {
      v8 = v3;
    }
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_ERROR))
      sub_10071AEB0((uint64_t)objc_msgSend(objc_retainAutorelease(*(id *)(a1 + 40)), "UTF8String"), (uint64_t)&v11);
    v8 = 0;
  }

}

void sub_1006AFC94(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1006AFFC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id location)
{
  void *v19;
  void *v20;
  id *v21;

  objc_destroyWeak(v21);
  objc_destroyWeak(&location);

  _Unwind_Resume(a1);
}

void sub_1006B003C(uint64_t a1)
{
  id WeakRetained;
  id v3;

  v3 = (id)objc_claimAutoreleasedReturnValue(+[BTAppInteraction instance](BTAppInteraction, "instance"));
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  objc_msgSend(v3, "urgentAssertionInvalidationCallback:", WeakRetained);

}

void sub_1006B0094(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1006B00AC(uint64_t a1)
{
  id WeakRetained;
  id v3;

  v3 = (id)objc_claimAutoreleasedReturnValue(+[BTAppInteraction instance](BTAppInteraction, "instance"));
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  objc_msgSend(v3, "assertionInvalidationCallback:", WeakRetained);

}

void sub_1006B0104(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1006B0198(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  id v7;
  id v8;

  v2 = *(void **)(*(_QWORD *)(a1 + 32) + 96);
  v7 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "name"));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "objectForKeyedSubscript:"));
  v4 = *(void **)(a1 + 40);

  if (v3 == v4)
  {
    v5 = *(void **)(a1 + 40);
    v6 = *(void **)(*(_QWORD *)(a1 + 32) + 96);
    v8 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "name"));
    objc_msgSend(v6, "removeObjectForKey:");

  }
}

void sub_1006B023C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

void sub_1006B02D0(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  NSObject *v6;
  id v7;
  void *v8;
  void *v9;
  void *v10;
  int v11;
  id v12;

  v2 = *(void **)(*(_QWORD *)(a1 + 32) + 88);
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "name"));
  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "objectForKeyedSubscript:", v3));
  v5 = *(void **)(a1 + 40);

  if (v4 == v5)
  {
    v6 = qword_1009997E8;
    if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_INFO))
    {
      v7 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 40), "name")));
      v11 = 136446210;
      v12 = objc_msgSend(v7, "UTF8String");
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "Removing invalidated process assertion for application \"%{public}s\"", (uint8_t *)&v11, 0xCu);

    }
    v8 = *(void **)(a1 + 40);
    v9 = *(void **)(*(_QWORD *)(a1 + 32) + 88);
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "name"));
    objc_msgSend(v9, "removeObjectForKey:", v10);

  }
}

void sub_1006B03F4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id sub_1006B0514(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "assertionTimerFired");
}

void sub_1006B05F4(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  id v7;

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 88), "keysOfEntriesPassingTest:", &stru_1009401C0));
  v3 = *(void **)(*(_QWORD *)(a1 + 32) + 88);
  v4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v2, "allObjects"));
  objc_msgSend(v3, "removeObjectsForKeys:", v4);

  v7 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 96), "keysOfEntriesPassingTest:", &stru_1009401E0));
  v5 = *(void **)(*(_QWORD *)(a1 + 32) + 96);
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "allObjects"));
  objc_msgSend(v5, "removeObjectsForKeys:", v6);

  if (!objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 88), "count")
    && !objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 96), "count"))
  {
    objc_msgSend(*(id *)(a1 + 32), "invalidateAssertionTimer");
  }

}

void sub_1006B06F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

BOOL sub_1006B0728(id a1, NSString *a2, ProcessAssertion *a3, BOOL *a4)
{
  ProcessAssertion *v4;
  unint64_t v5;
  NSObject *v6;
  id v7;
  int v9;
  id v10;

  v4 = a3;
  -[ProcessAssertion setSecondsLeft:](v4, "setSecondsLeft:", (char *)-[ProcessAssertion secondsLeft](v4, "secondsLeft") - 1);
  v5 = -[ProcessAssertion secondsLeft](v4, "secondsLeft");
  if (!v5)
  {
    v6 = qword_1009997E8;
    if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_INFO))
    {
      v7 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(-[ProcessAssertion name](v4, "name")));
      v9 = 136446210;
      v10 = objc_msgSend(v7, "UTF8String");
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "Removing expired process assertion for application \"%{public}s\"", (uint8_t *)&v9, 0xCu);

    }
    -[ProcessAssertion invalidate](v4, "invalidate");
  }

  return v5 == 0;
}

void sub_1006B0828(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

BOOL sub_1006B0850(id a1, NSString *a2, ProcessAssertion *a3, BOOL *a4)
{
  ProcessAssertion *v4;
  unint64_t v5;
  NSObject *v6;
  uint8_t v8[16];

  v4 = a3;
  -[ProcessAssertion setSecondsLeft:](v4, "setSecondsLeft:", (char *)-[ProcessAssertion secondsLeft](v4, "secondsLeft") - 1);
  v5 = -[ProcessAssertion secondsLeft](v4, "secondsLeft");
  if (!v5)
  {
    -[ProcessAssertion invalidate](v4, "invalidate");
    v6 = qword_1009997E8;
    if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)v8 = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "(EE) Expired URGENT Process Assertion", v8, 2u);
    }
  }

  return v5 == 0;
}

void sub_1006B08FC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1006B0974(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1006B0AE4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1006B0AF4(uint64_t a1)
{
  void *v2;
  void *v3;
  UserNotification *v4;
  uint64_t v5;
  void *v6;
  void *v7;
  void *v8;
  id v9;
  id v10;
  void *v11;
  id v12;
  void *v13;
  void *v14;
  void *v15;
  id v16;
  id v17;
  void *v18;
  const __CFDictionary *v19;
  id v20;
  void *v21;
  void *v22;
  CFUserNotificationRef v23;
  CFRunLoopSourceRef RunLoopSource;
  void *v25;
  id v26;
  id v27;
  _BYTE v28[16];
  _QWORD v29[4];
  _QWORD v30[4];
  _QWORD v31[5];
  _QWORD v32[5];

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 40), "objectForKey:", *(_QWORD *)(a1 + 40)));
  v3 = v2;
  if ((!*(_BYTE *)(a1 + 48) || (objc_msgSend(v2, "isApp") & 1) != 0)
    && !*(_QWORD *)(*(_QWORD *)(a1 + 32) + 64))
  {
    v4 = -[UserNotification initWithType:device:bundleID:]([UserNotification alloc], "initWithType:device:bundleID:", 0, 0, *(_QWORD *)(a1 + 40));
    v5 = *(_QWORD *)(a1 + 32);
    v6 = *(void **)(v5 + 64);
    *(_QWORD *)(v5 + 64) = v4;

    v7 = (void *)objc_claimAutoreleasedReturnValue(+[LSApplicationProxy applicationProxyForIdentifier:](LSApplicationProxy, "applicationProxyForIdentifier:", *(_QWORD *)(a1 + 40)));
    v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "localizedNameForContext:", 0));
    v9 = sub_100355F10(CFSTR("CLOSE"), CFSTR("Close"));
    v25 = (void *)objc_claimAutoreleasedReturnValue(v9);
    v10 = sub_100355F10(CFSTR("SETTINGS"), CFSTR("Settings"));
    v11 = (void *)objc_claimAutoreleasedReturnValue(v10);
    if (*(_BYTE *)(a1 + 49))
    {
      v12 = sub_100355F10(CFSTR("LE_DENYLIST_ENABLED_HEADER"), CFSTR("Allow New Connections"));
      v13 = (void *)objc_claimAutoreleasedReturnValue(v12);
      v27 = 0;
      v14 = v8;
      if (!v8)
        v14 = *(void **)(a1 + 40);
      v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithValidatedFormat:validFormatSpecifiers:error:](NSString, "stringWithValidatedFormat:validFormatSpecifiers:error:", v13, CFSTR("%@"), &v27, v14));
      v16 = v27;

      if (v15)
      {
        v17 = sub_100355F10(CFSTR("LE_DENYLIST_ENABLED_BODY"), &stru_100941758);
        v18 = (void *)objc_claimAutoreleasedReturnValue(v17);
        v31[0] = kCFUserNotificationAlertHeaderKey;
        v31[1] = kCFUserNotificationAlertMessageKey;
        v32[0] = v15;
        v32[1] = v18;
        v31[2] = kCFUserNotificationDefaultButtonTitleKey;
        v31[3] = kCFUserNotificationAlternateButtonTitleKey;
        v32[2] = v25;
        v32[3] = v11;
        v31[4] = SBUserNotificationAllowMenuButtonDismissal;
        v32[4] = &__kCFBooleanTrue;
        v19 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v32, v31, 5));

        goto LABEL_13;
      }
      if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_ERROR))
        sub_10071AFF4();
    }
    else
    {
      v20 = sub_100355F10(CFSTR("LE_POWER_OFF_HEADER"), CFSTR("Power Off"));
      v21 = (void *)objc_claimAutoreleasedReturnValue(v20);
      v26 = 0;
      v22 = v8;
      if (!v8)
        v22 = *(void **)(a1 + 40);
      v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithValidatedFormat:validFormatSpecifiers:error:](NSString, "stringWithValidatedFormat:validFormatSpecifiers:error:", v21, CFSTR("%@"), &v26, v22));
      v16 = v26;

      if (v15)
      {
        v29[0] = kCFUserNotificationAlertHeaderKey;
        v29[1] = kCFUserNotificationDefaultButtonTitleKey;
        v30[0] = v15;
        v30[1] = v25;
        v29[2] = kCFUserNotificationAlternateButtonTitleKey;
        v29[3] = SBUserNotificationAllowMenuButtonDismissal;
        v30[2] = v11;
        v30[3] = &__kCFBooleanTrue;
        v19 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v30, v29, 4));
LABEL_13:
        v23 = CFUserNotificationCreate(kCFAllocatorDefault, 0.0, 0, 0, v19);
        if (v23)
        {
          objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 64), "setNotification:", v23);
          CFRelease(v23);
          RunLoopSource = CFUserNotificationCreateRunLoopSource(kCFAllocatorDefault, v23, (CFUserNotificationCallBack)sub_1006B1050, 0);
          if (RunLoopSource)
          {
            objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 64), "setRunLoopSource:", RunLoopSource);
            CFRelease(RunLoopSource);
          }
          else if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_ERROR))
          {
            sub_10071AFBC((uint64_t)objc_msgSend(objc_retainAutorelease(*(id *)(a1 + 40)), "UTF8String"), (uint64_t)v28);
          }
        }
        else if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_ERROR))
        {
          sub_10071AF84((uint64_t)objc_msgSend(objc_retainAutorelease(*(id *)(a1 + 40)), "UTF8String"), (uint64_t)v28);
        }
        goto LABEL_25;
      }
      if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_ERROR))
        sub_10071AF20();
    }
    v15 = 0;
    v19 = 0;
LABEL_25:

  }
}

void sub_1006B0F8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

void sub_1006B1050(uint64_t a1, uint64_t a2)
{
  id v4;

  v4 = (id)objc_claimAutoreleasedReturnValue(+[BTAppInteraction instance](BTAppInteraction, "instance"));
  objc_msgSend(v4, "powerAlertCallback:flags:", a1, a2);

}

void sub_1006B109C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1006B1108(uint64_t a1)
{
  NSObject *v2;
  id v3;
  id v4;
  uint64_t v5;
  const char *v6;
  const char *v7;
  void *v8;
  void *v9;
  uint64_t v10;
  void *v11;
  int v12;
  id v13;
  __int16 v14;
  const char *v15;

  v2 = qword_1009997E8;
  if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
  {
    v3 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 64), "bundleID")));
    v4 = objc_msgSend(v3, "UTF8String");
    v5 = *(_QWORD *)(a1 + 40);
    v6 = "unknown";
    if (v5 == 1)
      v6 = "settings";
    if (v5)
      v7 = v6;
    else
      v7 = "cancel";
    v12 = 136446466;
    v13 = v4;
    v14 = 2082;
    v15 = v7;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "User responded to power notification callback for application \"%{public}s\" with %{public}s button", (uint8_t *)&v12, 0x16u);

  }
  if (*(_QWORD *)(a1 + 40) == 1)
  {
    v8 = (void *)objc_claimAutoreleasedReturnValue(+[LSApplicationWorkspace defaultWorkspace](LSApplicationWorkspace, "defaultWorkspace"));
    v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL URLWithString:](NSURL, "URLWithString:", CFSTR("prefs:root=Bluetooth")));
    objc_msgSend(v8, "openSensitiveURL:withOptions:", v9, 0);

  }
  v10 = *(_QWORD *)(a1 + 32);
  v11 = *(void **)(v10 + 64);
  *(_QWORD *)(v10 + 64) = 0;

}

void sub_1006B126C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1006B134C(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  id v5;
  void *v6;
  int v7;
  NSObject *v8;
  id v9;
  __CFString *v10;
  id v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  id v16;
  _BYTE *v17;
  void *v18;
  void *v19;
  id v20;
  id v21;
  void *v22;
  const __CFDictionary *v23;
  CFUserNotificationRef v24;
  CFRunLoopSourceRef RunLoopSource;
  void *v26;
  void *v27;
  id v28;
  void *v29;
  __CFString *v30;
  UserNotification *v31;
  id v32;
  _QWORD v33[4];
  id v34;
  _QWORD v35[9];
  _QWORD v36[9];
  _BYTE buf[12];
  char v38;

  v2 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 40), "objectForKey:", *(_QWORD *)(a1 + 40)));
  if ((objc_msgSend(v2, "isApp") & 1) != 0)
  {
    v31 = -[UserNotification initWithType:device:bundleID:]([UserNotification alloc], "initWithType:device:bundleID:", *(unsigned int *)(a1 + 56), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 40));
    v3 = *(void **)(a1 + 40);
    v4 = *(void **)(*(_QWORD *)(a1 + 32) + 72);
    v33[0] = _NSConcreteStackBlock;
    v33[1] = 3221225472;
    v33[2] = sub_1006B19E0;
    v33[3] = &unk_100940230;
    v34 = v3;
    v5 = objc_msgSend(v4, "indexOfObjectPassingTest:", v33);
    if (v5 != (id)0x7FFFFFFFFFFFFFFFLL)
    {
      v30 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 72), "objectAtIndexedSubscript:", v5));
      v6 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString device](v30, "device"));
      if (objc_msgSend(v6, "isEqual:", *(_QWORD *)(a1 + 48)))
      {
        v7 = *(_DWORD *)(a1 + 56);

        if (v7 != 1)
        {
          v8 = qword_1009997E8;
          if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_INFO))
          {
            v9 = objc_msgSend(objc_retainAutorelease(*(id *)(a1 + 40)), "UTF8String");
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = v9;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_INFO, "Suppressing duplicate notification for application \"%{public}s\"", buf, 0xCu);
          }
LABEL_33:

          goto LABEL_34;
        }
      }
      else
      {

      }
      objc_msgSend(*(id *)(a1 + 32), "cancelAppLaunchAlert:", *(_QWORD *)(a1 + 40));

    }
    if (*(_DWORD *)(a1 + 56) == 1)
      v10 = CFSTR("APP_LAUNCH_HEADER_DISCONNECTED");
    else
      v10 = CFSTR("APP_LAUNCH_HEADER_GENERAL");
    v30 = v10;
    v11 = sub_100355F10(v30, CFSTR("APP_LAUNCH_BODY"));
    v29 = (void *)objc_claimAutoreleasedReturnValue(v11);
    v12 = (void *)objc_claimAutoreleasedReturnValue(-[UserNotification bundleID](v31, "bundleID"));
    v13 = (void *)objc_claimAutoreleasedReturnValue(+[LSApplicationProxy applicationProxyForIdentifier:](LSApplicationProxy, "applicationProxyForIdentifier:", v12));

    v27 = v13;
    v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "localizedNameForContext:", 0));
    v15 = v14;
    if (!v14)
      v15 = *(void **)(a1 + 40);
    v16 = v15;
    if (qword_1009778C8 != -1)
      dispatch_once(&qword_1009778C8, &stru_100940488);
    sub_10000602C((uint64_t)off_1009778C0, *(void **)(a1 + 48), (uint64_t)buf);
    if (v38 >= 0)
      v17 = buf;
    else
      v17 = *(_BYTE **)buf;
    v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v17));
    if (v38 < 0)
      operator delete(*(void **)buf);
    v32 = 0;
    v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithValidatedFormat:validFormatSpecifiers:error:](NSString, "stringWithValidatedFormat:validFormatSpecifiers:error:", v29, CFSTR("%@%@"), &v32, v18, v16));
    v28 = v32;
    if (v19)
    {
      v20 = sub_100355F10(CFSTR("CLOSE"), CFSTR("Close"));
      v26 = (void *)objc_claimAutoreleasedReturnValue(v20);
      v21 = sub_100355F10(CFSTR("VIEW"), CFSTR("View"));
      v22 = (void *)objc_claimAutoreleasedReturnValue(v21);
      v35[0] = kCFUserNotificationAlertHeaderKey;
      v35[1] = kCFUserNotificationAlertMessageKey;
      v36[0] = v16;
      v36[1] = v19;
      v35[2] = kCFUserNotificationDefaultButtonTitleKey;
      v35[3] = kCFUserNotificationAlternateButtonTitleKey;
      v35[4] = kCFUserNotificationAlertTopMostKey;
      v35[5] = SBUserNotificationDontDismissOnUnlock;
      v36[4] = &__kCFBooleanTrue;
      v36[5] = &__kCFBooleanTrue;
      v35[6] = SBUserNotificationButtonTagForUnlockActionKey;
      v35[7] = SBUserNotificationSoundRepeatDurationKey;
      v36[2] = v22;
      v36[3] = v26;
      v36[6] = &off_100960B08;
      v36[7] = &off_100960B20;
      v35[8] = SBUserNotificationSystemSoundIDKey;
      v36[8] = &off_100960B38;
      v23 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v36, v35, 9));
      v24 = CFUserNotificationCreate(kCFAllocatorDefault, 0.0, 0, 0, v23);
      if (v24)
      {
        -[UserNotification setNotification:](v31, "setNotification:", v24);
        CFRelease(v24);
        RunLoopSource = CFUserNotificationCreateRunLoopSource(kCFAllocatorDefault, v24, (CFUserNotificationCallBack)sub_1006B1A30, 0);
        if (RunLoopSource)
        {
          -[UserNotification setRunLoopSource:](v31, "setRunLoopSource:", RunLoopSource);
          CFRelease(RunLoopSource);
          objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 72), "addObject:", v31);
        }
        else if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_ERROR))
        {
          sub_10071B0F4((uint64_t)objc_msgSend(objc_retainAutorelease(*(id *)(a1 + 40)), "UTF8String"), (uint64_t)buf);
        }
      }
      else if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_ERROR))
      {
        sub_10071B0BC((uint64_t)objc_msgSend(objc_retainAutorelease(*(id *)(a1 + 40)), "UTF8String"), (uint64_t)buf);
      }

    }
    else if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_ERROR))
    {
      sub_10071B058();
    }

    goto LABEL_33;
  }
LABEL_34:

}

void sub_1006B18C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22)
{
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;

  _Unwind_Resume(a1);
}

id sub_1006B19E0(uint64_t a1, void *a2)
{
  void *v3;
  id v4;

  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a2, "bundleID"));
  v4 = objc_msgSend(v3, "isEqualToString:", *(_QWORD *)(a1 + 32));

  return v4;
}

void sub_1006B1A20(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1006B1A30(uint64_t a1, uint64_t a2)
{
  id v4;

  v4 = (id)objc_claimAutoreleasedReturnValue(+[BTAppInteraction instance](BTAppInteraction, "instance"));
  objc_msgSend(v4, "appLaunchCallback:flags:", a1, a2);

}

void sub_1006B1A7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

id sub_1006B1A90(uint64_t a1, void *a2)
{
  void *v3;
  id v4;

  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a2, "bundleID"));
  v4 = objc_msgSend(v3, "isEqualToString:", *(_QWORD *)(a1 + 32));

  return v4;
}

void sub_1006B1AD0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1006B1B3C(_QWORD *a1)
{
  uint64_t v2;
  void *v3;
  id v4;
  void *v5;
  NSObject *v6;
  id v7;
  id v8;
  uint64_t v9;
  const char *v10;
  unsigned int v11;
  uint64_t v12;
  NSObject *v13;
  id v14;
  id v15;
  void *v16;
  void *v17;
  void **v18;
  uint64_t v19;
  void (*v20)(uint64_t, void *, void *);
  void *v21;
  id v22;
  _QWORD v23[5];
  uint8_t buf[4];
  id v25;
  __int16 v26;
  const char *v27;

  v2 = a1[5];
  v3 = *(void **)(a1[4] + 72);
  v23[2] = sub_1006B1E64;
  v23[3] = &unk_100940250;
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 3221225472;
  v23[4] = v2;
  v4 = objc_msgSend(v3, "indexOfObjectPassingTest:", v23);
  if (v4 == (id)0x7FFFFFFFFFFFFFFFLL)
  {
    if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_ERROR))
      sub_10071B12C();
  }
  else
  {
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1[4] + 72), "objectAtIndexedSubscript:", v4));
    v6 = qword_1009997E8;
    if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
    {
      v7 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "bundleID")));
      v8 = objc_msgSend(v7, "UTF8String");
      v9 = a1[6];
      if (v9)
      {
        if (v9 == 1)
        {
          v10 = "cancel";
        }
        else
        {
          v11 = objc_msgSend(&off_100960B08, "intValue");
          v10 = "unknown";
          if (v9 == v11)
            v10 = "unlock";
        }
      }
      else
      {
        v10 = "default";
      }
      *(_DWORD *)buf = 136446466;
      v25 = v8;
      v26 = 2082;
      v27 = v10;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "User responded to app launch notification callback for application \"%{public}s\" with %{public}s button", buf, 0x16u);

    }
    v12 = a1[6];
    if (!v12 || v12 == (int)objc_msgSend(&off_100960B08, "intValue"))
    {
      v13 = qword_1009997E8;
      if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
      {
        v14 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "bundleID")));
        v15 = objc_msgSend(v14, "UTF8String");
        *(_DWORD *)buf = 136446210;
        v25 = v15;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Attempting to launch application \"%{public}s\"", buf, 0xCu);

      }
      v16 = (void *)objc_claimAutoreleasedReturnValue(+[FBSOpenApplicationService serviceWithDefaultShellEndpoint](FBSOpenApplicationService, "serviceWithDefaultShellEndpoint"));
      v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "bundleID"));
      v18 = _NSConcreteStackBlock;
      v19 = 3221225472;
      v20 = sub_1006B1E94;
      v21 = &unk_100940278;
      v22 = v5;
      objc_msgSend(v16, "openApplication:withOptions:completion:", v17, 0, &v18);

    }
    objc_msgSend(*(id *)(a1[4] + 72), "removeObjectAtIndex:", v4, v18, v19, v20, v21);

  }
}

void sub_1006B1E0C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

BOOL sub_1006B1E64(uint64_t a1, void *a2)
{
  return objc_msgSend(a2, "notification") == *(id *)(a1 + 32);
}

void sub_1006B1E94(uint64_t a1, void *a2, void *a3)
{
  id v5;
  id v6;
  NSObject *v7;
  void *v8;
  id v9;
  unsigned int v10;
  NSObject *v11;
  id v12;
  id v13;
  uint8_t buf[4];
  id v15;
  __int16 v16;
  unsigned int v17;

  v5 = a2;
  v6 = a3;
  if (v6)
  {
    v7 = qword_1009997E8;
    if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_ERROR))
    {
      v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "bundleID"));
      v9 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Failed to launch application \"%@\" with error %@"), v8, v6)));
      *(_DWORD *)buf = 136446210;
      v15 = objc_msgSend(v9, "UTF8String");
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "%{public}s", buf, 0xCu);

    }
  }
  else
  {
    v10 = objc_msgSend(v5, "isValid");
    v11 = qword_1009997E8;
    if (v10)
    {
      if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
      {
        v12 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "bundleID")));
        *(_DWORD *)buf = 136446466;
        v15 = objc_msgSend(v12, "UTF8String");
        v16 = 1026;
        v17 = objc_msgSend(v5, "pid");
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Launched application: \"%{public}s\", pid: %{public}ul", buf, 0x12u);

      }
    }
    else if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_ERROR))
    {
      v13 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 32), "bundleID")));
      *(_DWORD *)buf = 136446210;
      v15 = objc_msgSend(v13, "UTF8String");
      _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Failed to lookup the process ID of \"%{public}s\"", buf, 0xCu);

    }
  }

}

void sub_1006B20A4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1006B21FC(uint64_t a1)
{
  void *v2;
  PairingNotification *v3;
  NSObject *v4;
  uint64_t v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  uint64_t v10;
  void *v11;
  void *v12;
  void *v13;
  uint64_t v14;
  id v15;
  id v16;
  id v17;
  id v18;
  id v19;
  __int128 *p_buf;
  void *v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  int v25;
  void *v26;
  void *v27;
  _BOOL4 v28;
  id v29;
  id v30;
  id v31;
  id v32;
  void *v33;
  NSObject *v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  void **v39;
  id v40;
  void *v41;
  void *v42;
  id v43;
  void *v44;
  id v45;
  void *v46;
  void *v47;
  int v48;
  const __CFString *v49;
  void *v50;
  id v51;
  void *v52;
  void *v53;
  uint64_t v54;
  void *v55;
  CFUserNotificationRef v56;
  CFRunLoopSourceRef RunLoopSource;
  void *v58;
  void *v59;
  void *v60;
  void *v61;
  void *v62;
  void *v63;
  void *v64;
  CFDictionaryRef dictionary;
  __CFString *v66;
  id v67;
  id v68;
  id v69;
  id v70;
  _QWORD v71[2];
  char v72;
  _QWORD v73[2];
  char v74;
  id v75;
  _QWORD v76[2];
  _QWORD v77[2];
  _QWORD v78[4];
  _QWORD v79[4];
  uint8_t v80[8];
  uint64_t v81;
  unsigned __int8 v82;
  __int128 buf;
  uint64_t v84;

  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40)
    || (v2 = *(void **)(*(_QWORD *)(a1 + 32) + 80),
        v3 = -[PairingNotification initWithType:passkey:device:]([PairingNotification alloc], "initWithType:passkey:device:", *(unsigned int *)(a1 + 56), *(_QWORD *)(a1 + 48), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40)), objc_msgSend(v2, "addObject:", v3), v3, (unint64_t)objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 80), "count") < 2))
  {
    if (objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 80), "count"))
    {
      v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 80), "objectAtIndexedSubscript:", 0));
      v7 = v6;
      if (v6 && !objc_msgSend(v6, "notification"))
      {
        buf = 0uLL;
        v84 = 0;
        if (qword_1009778C8 != -1)
          dispatch_once(&qword_1009778C8, &stru_100940488);
        v8 = off_1009778C0;
        v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "device"));
        sub_10000602C((uint64_t)v8, v9, (uint64_t)v80);
        if ((v82 & 0x80u) == 0)
          v10 = v82;
        else
          v10 = v81;
        if (v10)
        {
          if (qword_1009778C8 != -1)
            dispatch_once(&qword_1009778C8, &stru_100940488);
          v11 = off_1009778C0;
          v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "device"));
          sub_10000602C((uint64_t)v11, v12, (uint64_t)&buf);
        }
        else
        {
          if (qword_1009778C8 != -1)
            dispatch_once(&qword_1009778C8, &stru_100940488);
          v13 = off_1009778C0;
          v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "device"));
          v14 = sub_1000589DC((uint64_t)v13, v12, 0);
          v15 = sub_100021770(v14);
          v16 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(v15));
          sub_100091AE8(&buf, (char *)objc_msgSend(v16, "UTF8String"));

        }
        if ((char)v82 < 0)
          operator delete(*(void **)v80);

        v17 = sub_100355F10(CFSTR("PAIRING_TITLE"), CFSTR("Pairing"));
        v64 = (void *)objc_claimAutoreleasedReturnValue(v17);
        v18 = sub_100355F10(CFSTR("CANCEL"), CFSTR("Cancel"));
        v61 = (void *)objc_claimAutoreleasedReturnValue(v18);
        v19 = sub_100355F10(CFSTR("PAIR"), CFSTR("Pair"));
        v60 = (void *)objc_claimAutoreleasedReturnValue(v19);
        if (v84 >= 0)
          p_buf = &buf;
        else
          p_buf = (__int128 *)buf;
        v63 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", p_buf));
        v62 = (void *)MGCopyAnswer(CFSTR("MarketingDeviceFamilyName"), 0);
        v78[0] = kCFUserNotificationAlertTopMostKey;
        v78[1] = SBUserNotificationAllowMenuButtonDismissal;
        v79[0] = &__kCFBooleanTrue;
        v79[1] = &__kCFBooleanTrue;
        v78[2] = SBUserNotificationDismissOnLock;
        v78[3] = kCFUserNotificationAlertHeaderKey;
        v79[2] = &__kCFBooleanTrue;
        v79[3] = v64;
        v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v79, v78, 4));
        dictionary = (CFDictionaryRef)objc_msgSend(v21, "mutableCopy");

        v22 = sub_10003BE44();
        v23 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v22 + 360))(v22);
        v24 = sub_10003BE44();
        v25 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v24 + 272))(v24);
        if (qword_1009778C8 != -1)
          dispatch_once(&qword_1009778C8, &stru_100940488);
        v26 = off_1009778C0;
        v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "device"));
        v28 = sub_10065E0D4((uint64_t)v26, v27);

        v29 = 0;
        v66 = &stru_100941758;
        v30 = 0;
        v31 = 0;
        switch(objc_msgSend(v7, "pairingType"))
        {
          case 0u:
            v32 = sub_100355F10(CFSTR("JUST_WORKS_MESSAGE"), CFSTR("Body"));
            v33 = (void *)objc_claimAutoreleasedReturnValue(v32);
            v75 = 0;
            v66 = (__CFString *)objc_claimAutoreleasedReturnValue(+[NSString stringWithValidatedFormat:validFormatSpecifiers:error:](NSString, "stringWithValidatedFormat:validFormatSpecifiers:error:", v33, CFSTR("%@%@"), &v75, v63, v62));
            v31 = v75;

            if (!v66)
            {
              if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_ERROR))
                sub_10071B220();
              goto LABEL_81;
            }
            if ((v23 & v25 & v28) != 1)
              goto LABEL_65;
            v34 = qword_1009997E8;
            if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)v80 = 0;
              _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "Pairing LE HID with old iPad. Show modified message", v80, 2u);
            }
            if (_os_feature_enabled_impl("BluetoothFeatures", "RuleBasedHIDClassification"))
            {
              if (qword_1009778C8 != -1)
                dispatch_once(&qword_1009778C8, &stru_100940488);
              v35 = off_1009778C0;
              v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "device"));
              sub_100653B18((uint64_t)v35, v36, CFSTR("HIDDeviceUnknownBehavior"));

              if (qword_1009778C8 != -1)
                dispatch_once(&qword_1009778C8, &stru_100940488);
              v37 = off_1009778C0;
              v38 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "device"));
              sub_100091AE8(v73, "HIDDeviceKnownPoorBehavior");
              sub_1006576F0((uint64_t)v37, v38, (unsigned __int8 *)v73);
              if ((v74 & 0x80000000) == 0)
                goto LABEL_61;
              v39 = (void **)v73;
            }
            else
            {
              if (qword_1009778C8 != -1)
                dispatch_once(&qword_1009778C8, &stru_100940488);
              v47 = off_1009778C0;
              v38 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "device"));
              sub_100091AE8(v71, "HIDDeviceUnknownBehavior");
              sub_1006576F0((uint64_t)v47, v38, (unsigned __int8 *)v71);
              if ((v72 & 0x80000000) == 0)
                goto LABEL_61;
              v39 = (void **)v71;
            }
            operator delete(*v39);
LABEL_61:

            v48 = MGGetBoolAnswer(CFSTR("wapi"));
            v49 = CFSTR("WIFI");
            if (v48)
              v49 = CFSTR("WLAN");
            v50 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@_JUST_WORKS_MESSAGE_HID_OLD"), v49));
            v51 = sub_100355F10(v50, CFSTR("Body"));
            v52 = (void *)objc_claimAutoreleasedReturnValue(v51);
            v53 = v31;
            v70 = v31;
            v54 = objc_claimAutoreleasedReturnValue(+[NSString stringWithValidatedFormat:validFormatSpecifiers:error:](NSString, "stringWithValidatedFormat:validFormatSpecifiers:error:", v52, CFSTR("%@%@"), &v70, v63, v62));
            v31 = v70;

            if (v54)
            {
              v66 = (__CFString *)v54;
              goto LABEL_65;
            }
            if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_ERROR))
              sub_10071B284();
            goto LABEL_81;
          case 1u:
            v43 = sub_100355F10(CFSTR("PASSKEY_DISPLAY_MESSAGE"), CFSTR("Body"));
            v44 = (void *)objc_claimAutoreleasedReturnValue(v43);
            v69 = 0;
            v66 = (__CFString *)objc_claimAutoreleasedReturnValue(+[NSString stringWithValidatedFormat:validFormatSpecifiers:error:](NSString, "stringWithValidatedFormat:validFormatSpecifiers:error:", v44, CFSTR("%@%@%06u%@"), &v69, v63, v62, objc_msgSend(v7, "passkey"), v63, v60));
            v31 = v69;

            if (v66)
            {
              v29 = v61;
              v30 = 0;
              goto LABEL_66;
            }
            if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_ERROR))
              sub_10071B2E8();
            goto LABEL_81;
          case 2u:
            v40 = sub_100355F10(CFSTR("PASSKEY_ENTRY_MESSAGE"), CFSTR("Body"));
            v41 = (void *)objc_claimAutoreleasedReturnValue(v40);
            v68 = 0;
            v66 = (__CFString *)objc_claimAutoreleasedReturnValue(+[NSString stringWithValidatedFormat:validFormatSpecifiers:error:](NSString, "stringWithValidatedFormat:validFormatSpecifiers:error:", v41, CFSTR("%@%@%@%@"), &v68, v63, v62, v63, v63));
            v31 = v68;

            if (v66)
            {
              v29 = v60;
              v30 = v61;
              v76[0] = kCFUserNotificationTextFieldTitlesKey;
              v76[1] = kCFUserNotificationKeyboardTypesKey;
              v77[0] = &stru_100941758;
              v77[1] = &off_100960B50;
              v42 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v77, v76, 2));
              -[__CFDictionary addEntriesFromDictionary:](dictionary, "addEntriesFromDictionary:", v42);

              goto LABEL_66;
            }
            if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_ERROR))
              sub_10071B34C();
            goto LABEL_81;
          case 3u:
            goto LABEL_66;
          case 4u:
            v45 = sub_100355F10(CFSTR("NUMERIC_MESSAGE"), CFSTR("Body"));
            v46 = (void *)objc_claimAutoreleasedReturnValue(v45);
            v67 = 0;
            v66 = (__CFString *)objc_claimAutoreleasedReturnValue(+[NSString stringWithValidatedFormat:validFormatSpecifiers:error:](NSString, "stringWithValidatedFormat:validFormatSpecifiers:error:", v46, CFSTR("%@%@%06u%@"), &v67, v63, v62, objc_msgSend(v7, "passkey"), v63, v60, v61));
            v31 = v67;

            if (v66)
            {
LABEL_65:
              v29 = v60;
              v30 = v61;
LABEL_66:
              -[__CFDictionary setObject:forKey:](dictionary, "setObject:forKey:", v66, kCFUserNotificationAlertMessageKey);
              if (v29)
                -[__CFDictionary setObject:forKey:](dictionary, "setObject:forKey:", v29, kCFUserNotificationDefaultButtonTitleKey);
              if (v30)
                -[__CFDictionary setObject:forKey:](dictionary, "setObject:forKey:", v30, kCFUserNotificationAlternateButtonTitleKey);
              v55 = v31;
              v56 = CFUserNotificationCreate(kCFAllocatorDefault, 0.0, 0x10003uLL, 0, dictionary);
              if (v56)
              {
                objc_msgSend(v7, "setNotification:", v56);
                CFRelease(v56);
                RunLoopSource = CFUserNotificationCreateRunLoopSource(kCFAllocatorDefault, v56, (CFUserNotificationCallBack)sub_1006B30B8, 0);
                if (RunLoopSource)
                {
                  objc_msgSend(v7, "setRunLoopSource:", RunLoopSource);
                  CFRelease(RunLoopSource);
                  goto LABEL_82;
                }
                if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_ERROR))
                {
                  v59 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "device"));
                  sub_10071B1D8(v59, (uint64_t)v80);
                  v55 = v31;
                }
              }
              else if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_ERROR))
              {
                v58 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "device"));
                sub_10071B190(v58, (uint64_t)v80);
                v55 = v31;
              }
              objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 80), "removeObjectAtIndex:", 0);
            }
            else
            {
              if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_ERROR))
                sub_10071B3B0();
LABEL_81:
              v66 = 0;
              v29 = 0;
              v30 = 0;
              v55 = v31;
            }
LABEL_82:

            if (SHIBYTE(v84) < 0)
              operator delete((void *)buf);
            break;
          default:
            v30 = 0;
            v31 = 0;
            goto LABEL_66;
        }
      }
    }
    else
    {
      v7 = 0;
    }

    return;
  }
  v4 = qword_1009997E8;
  if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_INFO))
  {
    v5 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40);
    LODWORD(buf) = 138412290;
    *(_QWORD *)((char *)&buf + 4) = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Waiting for current pairing prompt to go away before displaying prompt for device \"%@\"", (uint8_t *)&buf, 0xCu);
  }
}

void sub_1006B2E70(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  void *v35;
  void *v36;
  void *v37;
  uint64_t v38;

  if (a29 < 0)
    operator delete(__p);

  if (*(char *)(v38 - 105) < 0)
    operator delete(*(void **)(v38 - 128));

  _Unwind_Resume(a1);
}

void sub_1006B30B8(uint64_t a1, uint64_t a2)
{
  id v4;

  v4 = (id)objc_claimAutoreleasedReturnValue(+[BTAppInteraction instance](BTAppInteraction, "instance"));
  objc_msgSend(v4, "pairingAlertCallback:flags:", a1, a2);

}

void sub_1006B3104(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1006B3194(uint64_t a1)
{
  void *v2;
  void *v3;
  id v4;
  uint64_t v5;
  NSObject *v6;
  _QWORD v7[4];
  id v8;
  uint64_t v9;
  uint8_t buf[16];

  v2 = *(void **)(a1 + 32);
  if (v2)
  {
    v3 = *(void **)(*(_QWORD *)(a1 + 40) + 80);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    v7[2] = sub_1006B3284;
    v7[3] = &unk_100938260;
    v4 = v2;
    v5 = *(_QWORD *)(a1 + 40);
    v8 = v4;
    v9 = v5;
    objc_msgSend(v3, "enumerateObjectsUsingBlock:", v7);

  }
  else
  {
    v6 = qword_1009997E8;
    if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Clearing all active pairing notifications", buf, 2u);
    }
    objc_msgSend(*(id *)(*(_QWORD *)(a1 + 40) + 80), "removeAllObjects");
  }
}

void sub_1006B3270(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{

  _Unwind_Resume(a1);
}

void sub_1006B3284(uint64_t a1, void *a2, uint64_t a3, _BYTE *a4)
{
  id v7;
  void *v8;
  unsigned int v9;
  NSObject *v10;
  const char *v11;
  uint64_t v12;
  int v13;
  const char *v14;
  __int16 v15;
  uint64_t v16;

  v7 = a2;
  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "device"));
  v9 = objc_msgSend(v8, "isEqual:", *(_QWORD *)(a1 + 32));

  if (v9)
  {
    v10 = qword_1009997E8;
    if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
    {
      v11 = "queued";
      v12 = *(_QWORD *)(a1 + 32);
      if (!a3)
        v11 = "active";
      v13 = 136446466;
      v14 = v11;
      v15 = 2112;
      v16 = v12;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Clearing %{public}s pairing notification for device \"%@\"", (uint8_t *)&v13, 0x16u);
    }
    objc_msgSend(*(id *)(*(_QWORD *)(a1 + 40) + 80), "removeObjectAtIndex:", a3);
    *a4 = 1;
  }

}

void sub_1006B33A8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1006B3428(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  id v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  NSObject *v8;
  void *v9;
  const char *v10;
  unsigned int v11;
  const char *v12;
  CFStringRef ResponseValue;
  void *v14;
  void *v15;
  NSObject *v16;
  void *v17;
  const char *v18;
  uint64_t v19;
  unsigned int v20;
  const char *v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  _QWORD v25[5];
  _QWORD v26[5];
  uint8_t buf[4];
  void *v28;
  __int16 v29;
  const char *v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  uint64_t v34;
  __int16 v35;
  unsigned int v36;

  v2 = *(_QWORD *)(a1 + 40);
  v3 = *(void **)(*(_QWORD *)(a1 + 32) + 80);
  v26[2] = sub_1006B3868;
  v26[3] = &unk_100940250;
  v26[0] = _NSConcreteStackBlock;
  v26[1] = 3221225472;
  v26[4] = v2;
  v4 = objc_msgSend(v3, "indexOfObjectPassingTest:", v26);
  if (v4 == (id)0x7FFFFFFFFFFFFFFFLL)
  {
    if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_ERROR))
      sub_10071B414();
  }
  else
  {
    v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 80), "objectAtIndexedSubscript:", v4));
    v6 = 0;
    v7 = 1;
    switch(objc_msgSend(v5, "pairingType"))
    {
      case 0u:
      case 4u:
        goto LABEL_6;
      case 1u:
        v7 = 0;
        v6 = 1;
LABEL_6:
        v8 = qword_1009997E8;
        if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
        {
          v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "device"));
          v10 = *(const char **)(a1 + 48);
          v11 = objc_msgSend(v5, "pairingType");
          v12 = "unknown";
          *(_DWORD *)buf = 138413058;
          v28 = v9;
          if (v10 == (const char *)v7)
            v12 = "cancel";
          v29 = 2082;
          if (v10 == (const char *)v6)
            v12 = "pair";
          v30 = v12;
          v31 = 2048;
          v32 = v10;
          v33 = 1024;
          LODWORD(v34) = v11;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "User responded to pairing notification for device \"%@\" with %{public}s (%ld) button for pairing type:%d", buf, 0x26u);

        }
        break;
      case 2u:
        ResponseValue = CFUserNotificationGetResponseValue(*(CFUserNotificationRef *)(a1 + 40), kCFUserNotificationTextFieldValuesKey, 0);
        v14 = (void *)objc_claimAutoreleasedReturnValue(ResponseValue);
        v15 = v14;
        if (v14)
          objc_msgSend(v5, "setPasskey:", (int)objc_msgSend(v14, "intValue"));
        v16 = qword_1009997E8;
        if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
        {
          v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "device"));
          v18 = (const char *)objc_msgSend(v5, "passkey");
          v19 = *(_QWORD *)(a1 + 48);
          v20 = objc_msgSend(v5, "pairingType");
          v21 = "unknown";
          *(_DWORD *)buf = 138413314;
          v28 = v17;
          if (v19 == 1)
            v21 = "cancel";
          v30 = v18;
          v31 = 2082;
          v29 = 2048;
          if (!v19)
            v21 = "pair";
          v32 = v21;
          v33 = 2048;
          v34 = v19;
          v35 = 1024;
          v36 = v20;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "User responded to pairing notification for device \"%@\" with passkey %lu and %{public}s (%ld) button for pairing type:%d", buf, 0x30u);

        }
        v6 = 0;
        break;
      default:
        break;
    }
    if (qword_1009778B8 != -1)
      dispatch_once(&qword_1009778B8, &stru_1009404A8);
    v22 = qword_1009778B0;
    v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "device"));
    sub_1006966C0(v22, v23, *(_QWORD *)(a1 + 48) == v6, objc_msgSend(v5, "passkey"));

    objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 80), "removeObjectAtIndex:", v4);
    if (objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 80), "count"))
    {
      v24 = *(_QWORD *)(a1 + 32);
      if (*(_QWORD *)(v24 + 8))
      {
        v25[0] = _NSConcreteStackBlock;
        v25[1] = 3221225472;
        v25[2] = sub_1006B3898;
        v25[3] = &unk_1009172A0;
        v25[4] = v24;
        dispatch_async((dispatch_queue_t)&_dispatch_main_q, v25);
      }
    }

  }
}

void sub_1006B3800(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

BOOL sub_1006B3868(uint64_t a1, void *a2)
{
  return objc_msgSend(a2, "notification") == *(id *)(a1 + 32);
}

void sub_1006B3898(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void *v3;
  id v4;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(_QWORD *)(v1 + 8);
  v4 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(v1 + 80), "objectAtIndexedSubscript:", 0));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "device"));
  (*(void (**)(uint64_t, void *))(*(_QWORD *)v2 + 24))(v2, v3);

}

void sub_1006B38FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1006B39E8(id a1, NSString *a2, ProcessAssertion *a3, BOOL *a4)
{
  ProcessAssertion *v4;
  NSObject *v5;
  id v6;
  uint8_t buf[4];
  id v8;

  v4 = a3;
  v5 = qword_1009997E8;
  if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
  {
    v6 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("   %@"), v4)));
    *(_DWORD *)buf = 136446210;
    v8 = objc_msgSend(v6, "UTF8String");
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);

  }
}

void sub_1006B3AC4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1006B3AE8(id a1, NSString *a2, ProcessAssertion *a3, BOOL *a4)
{
  ProcessAssertion *v4;
  NSObject *v5;
  id v6;
  uint8_t buf[4];
  id v8;

  v4 = a3;
  v5 = qword_1009997E8;
  if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
  {
    v6 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("   %@"), v4)));
    *(_DWORD *)buf = 136446210;
    v8 = objc_msgSend(v6, "UTF8String");
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);

  }
}

void sub_1006B3BC4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1006B3FDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,void *a24,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  void *v29;
  void *v30;
  void *v31;

  _Unwind_Resume(a1);
}

void sub_1006B406C(uint64_t a1)
{
  void *v2;
  void *v3;
  id v4;
  void *v5;
  id v6;
  __CFString *v7;
  id v8;
  __CFString *v9;
  id v10;
  __CFString *v11;
  NSObject *v12;
  const char *v13;
  void *v14;
  NSMutableArray *v15;
  id v16;
  void *v17;
  void *v18;
  NSObject *v19;
  void *v20;
  void *v21;
  void *v22;
  __CFString *alertHeader;
  CFOptionFlags v24;
  uint8_t buf[4];
  void *v26;

  *(_BYTE *)(*(_QWORD *)(a1 + 32) + 32) = 1;
  v24 = 0;
  v2 = (void *)objc_claimAutoreleasedReturnValue(+[CBAccessoryLogging getProductNameFromProductID:](CBAccessoryLogging, "getProductNameFromProductID:", *(unsigned int *)(a1 + 48)));
  v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@ Issue Detected"), v2));
  v4 = sub_100355F10(CFSTR("TITLE"), v3);
  alertHeader = (__CFString *)objc_claimAutoreleasedReturnValue(v4);

  v5 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("An issue was detected with your %@. Do you wish to file a radar with AirWave?"), v2));
  v6 = sub_100355F10(CFSTR("CONTENT"), v5);
  v7 = (__CFString *)objc_claimAutoreleasedReturnValue(v6);

  v8 = sub_100355F10(CFSTR("OPEN_AIRWAVE"), CFSTR("Open AirWave"));
  v9 = (__CFString *)objc_claimAutoreleasedReturnValue(v8);
  v10 = sub_100355F10(CFSTR("NO_THANKS"), CFSTR("No thanks"));
  v11 = (__CFString *)objc_claimAutoreleasedReturnValue(v10);
  CFUserNotificationDisplayAlert(0.0, 1uLL, 0, 0, 0, alertHeader, v7, v9, v11, 0, &v24);
  if (v24)
  {
    if (v24 == 1)
    {
      v12 = qword_1009997E8;
      if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        v13 = "displayAirWaveLaunchNotification: Dismissing crash log";
LABEL_10:
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, v13, buf, 2u);
      }
    }
    else
    {
      v12 = qword_1009997E8;
      if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        v13 = "displayAirWaveLaunchNotification: No response";
        goto LABEL_10;
      }
    }
  }
  else
  {
    v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSURLComponents componentsWithString:](NSURLComponents, "componentsWithString:", CFSTR("wayfinder://")));
    objc_msgSend(v14, "setHost:", CFSTR("debug"));
    v15 = objc_opt_new(NSMutableArray);
    v16 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%u"), *(unsigned __int8 *)(a1 + 52));
    v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSURLQueryItem queryItemWithName:value:](NSURLQueryItem, "queryItemWithName:value:", CFSTR("opcode"), v16));
    -[NSMutableArray addObject:](v15, "addObject:", v17);

    v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSURLQueryItem queryItemWithName:value:](NSURLQueryItem, "queryItemWithName:value:", CFSTR("findMySerialNumber"), *(_QWORD *)(a1 + 40)));
    -[NSMutableArray addObject:](v15, "addObject:", v18);

    objc_msgSend(v14, "setQueryItems:", v15);
    v19 = qword_1009997E8;
    if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
    {
      v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "string"));
      *(_DWORD *)buf = 138543362;
      v26 = v20;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "displayAirWaveLaunchNotification: Launching AirWave with URL %{public}@", buf, 0xCu);

    }
    v21 = (void *)objc_claimAutoreleasedReturnValue(+[LSApplicationWorkspace defaultWorkspace](LSApplicationWorkspace, "defaultWorkspace"));
    v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "URL"));
    objc_msgSend(v21, "openURL:configuration:completionHandler:", v22, 0, &stru_100940340);

  }
  *(_BYTE *)(*(_QWORD *)(a1 + 32) + 32) = 0;

}

void sub_1006B4404(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

void sub_1006B44C8(id a1, NSDictionary *a2, NSError *a3)
{
  NSDictionary *v4;
  NSError *v5;
  NSObject *v6;
  void *v7;
  int v8;
  NSDictionary *v9;
  __int16 v10;
  void *v11;

  v4 = a2;
  v5 = a3;
  v6 = qword_1009997E8;
  if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
  {
    v7 = (void *)objc_claimAutoreleasedReturnValue(-[NSError description](v5, "description"));
    v8 = 138412546;
    v9 = v4;
    v10 = 2112;
    v11 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "displayAirWaveLaunchNotification: AirWave launch result %@, error %@", (uint8_t *)&v8, 0x16u);

  }
}

void sub_1006B45A8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1006B48E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;

  _Unwind_Resume(a1);
}

void sub_1006B496C(uint64_t a1)
{
  id v2;
  __CFString *v3;
  id v4;
  __CFString *v5;
  int v6;
  NSObject *v7;
  int v8;
  NSObject *v9;
  __CFString *v10;
  id v11;
  __CFString *v12;
  CFOptionFlags v13;
  uint8_t buf[4];
  int v15;

  *(_BYTE *)(*(_QWORD *)(a1 + 32) + 32) = 1;
  v13 = 0;
  v2 = sub_100355F10(CFSTR("FILE_A_RADAR"), CFSTR("File a Radar"));
  v3 = (__CFString *)objc_claimAutoreleasedReturnValue(v2);
  v4 = sub_100355F10(CFSTR("NO_THANKS"), CFSTR("No thanks"));
  v5 = (__CFString *)objc_claimAutoreleasedReturnValue(v4);
  CFUserNotificationDisplayAlert(0.0, 1uLL, 0, 0, 0, *(CFStringRef *)(a1 + 40), *(CFStringRef *)(a1 + 48), v3, v5, 0, &v13);
  if (v13)
  {
    if (v13 == 1)
    {
      if (qword_100978180 != -1)
        dispatch_once(&qword_100978180, &stru_1009404C8);
      v6 = sub_1003C0728(qword_100978178, a1 + 64, 6, 1u);
      v7 = qword_1009997E8;
      if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        v15 = v6;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "showFoundAccessoryCrashAlert: Dismissing crash log (result = %d)", buf, 8u);
      }
    }
    else if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_ERROR))
    {
      sub_10071B52C();
    }
  }
  else
  {
    if (qword_100978180 != -1)
      dispatch_once(&qword_100978180, &stru_1009404C8);
    v8 = sub_1003C0728(qword_100978178, a1 + 64, 5, 1u);
    v9 = qword_1009997E8;
    if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      v15 = v8;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "showFoundAccessoryCrashAlert: Requesting crash log (result = %d)", buf, 8u);
    }
    if (v8 == 312 || v8 == 12)
    {
      v10 = (__CFString *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Crash retrieval failed as the connection to %@ has been lost.  You will be prompted again after you re-connect."), *(_QWORD *)(a1 + 56)));
      v11 = sub_100355F10(CFSTR("OK"), CFSTR("OK"));
      v12 = (__CFString *)objc_claimAutoreleasedReturnValue(v11);
      CFUserNotificationDisplayAlert(0.0, 1uLL, 0, 0, 0, CFSTR("No Longer Connected"), v10, v12, 0, 0, &v13);

    }
  }
  *(_BYTE *)(*(_QWORD *)(a1 + 32) + 32) = 0;

}

void sub_1006B4C3C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1006B4FCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;

  _Unwind_Resume(a1);
}

void sub_1006B5048(uint64_t a1)
{
  id v2;
  __CFString *v3;
  id v4;
  __CFString *v5;
  uint64_t v6;
  CFOptionFlags v7;

  v7 = 0;
  v2 = sub_100355F10(CFSTR("FILE_A_RADAR"), CFSTR("File a Radar"));
  v3 = (__CFString *)objc_claimAutoreleasedReturnValue(v2);
  v4 = sub_100355F10(CFSTR("NO_THANKS"), CFSTR("No thanks"));
  v5 = (__CFString *)objc_claimAutoreleasedReturnValue(v4);
  CFUserNotificationDisplayAlert(0.0, 1uLL, 0, 0, 0, *(CFStringRef *)(a1 + 32), *(CFStringRef *)(a1 + 40), v3, v5, 0, &v7);
  if (!v7)
  {
    if (*(_BYTE *)(a1 + 72))
      v6 = 1;
    else
      v6 = 2;
    objc_msgSend(*(id *)(a1 + 48), "openTapToRadarWithAccessoryLogs:reason:pid:", *(_QWORD *)(a1 + 56), v6, *(_QWORD *)(a1 + 64));
  }

}

void sub_1006B5108(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1006B553C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  void *v27;
  void *v28;
  void *v29;

  _Unwind_Resume(a1);
}

void sub_1006B55B0(uint64_t a1)
{
  id v2;
  __CFString *v3;
  id v4;
  __CFString *v5;
  __CFString *v6;
  id v7;
  __CFString *v8;
  CFOptionFlags v9;

  *(_BYTE *)(*(_QWORD *)(a1 + 32) + 32) = 1;
  v9 = 0;
  v2 = sub_100355F10(CFSTR("FILE_A_RADAR"), CFSTR("File a Radar"));
  v3 = (__CFString *)objc_claimAutoreleasedReturnValue(v2);
  v4 = sub_100355F10(CFSTR("NO_THANKS"), CFSTR("No thanks"));
  v5 = (__CFString *)objc_claimAutoreleasedReturnValue(v4);
  CFUserNotificationDisplayAlert(0.0, 1uLL, 0, 0, 0, *(CFStringRef *)(a1 + 40), *(CFStringRef *)(a1 + 48), v3, v5, 0, &v9);
  if (!v9)
  {
    if (qword_100977A88 != -1)
      dispatch_once(&qword_100977A88, &stru_1009404E8);
    if (sub_10029AD9C((uint64_t)off_100977A80, *(unsigned int *)(a1 + 76) | ((unint64_t)*(unsigned __int16 *)(a1 + 80) << 32)))
    {
      objc_msgSend(*(id *)(a1 + 32), "openTapToRadarWithAccessoryLogs:reason:pid:", 0, *(unsigned int *)(a1 + 72), *(_QWORD *)(a1 + 64));
    }
    else
    {
      v6 = (__CFString *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Your connection to the %@ does not exist; not opening Tap-to-Radar.  Please re-connect your %@ and file a radar separately."),
                             *(_QWORD *)(a1 + 56),
                             *(_QWORD *)(a1 + 56)));
      v7 = sub_100355F10(CFSTR("OK"), CFSTR("OK"));
      v8 = (__CFString *)objc_claimAutoreleasedReturnValue(v7);
      CFUserNotificationDisplayAlert(0.0, 1uLL, 0, 0, 0, CFSTR("No Longer Connected"), v6, v8, 0, 0, &v9);

    }
  }
  *(_BYTE *)(*(_QWORD *)(a1 + 32) + 32) = 0;

}

void sub_1006B5744(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1006B606C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;

  _Unwind_Resume(a1);
}

void sub_1006B61AC(id a1, NSDictionary *a2, NSError *a3)
{
  NSDictionary *v4;
  NSError *v5;

  v4 = a2;
  v5 = a3;
  if (v5 && os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_ERROR))
    sub_10071B6A8();

}

void sub_1006B6310(uint64_t a1)
{
  int v2;
  id v3;
  void *v4;
  void *v5;
  uint64_t v6;
  __CFString *v7;
  id v8;
  void *v9;
  __CFString *v10;
  void *v11;
  void *v12;
  void *v13;
  id v14;
  void *v15;
  void *v16;
  void *v17;
  id v18;
  void *v19;
  void *v20;
  NSObject *v21;
  id v22;
  void *v23;
  void *v24;
  NSObject *v25;
  CFOptionFlags v26;
  uint8_t buf[4];
  id v28;

  v26 = 0;
  CFUserNotificationDisplayAlert(0.0, 1uLL, 0, 0, 0, CFSTR("Your device has BT Issues"), CFSTR("File a radar now?"), CFSTR("OK"), CFSTR("Cancel"), 0, &v26);
  if (v26)
    return;
  v2 = *(_DWORD *)(a1 + 64);
  switch(v2)
  {
    case 0:
      v7 = CFSTR("tap-to-radar://new?Title=BT%20Controller%20Crashed&Classification=Crash%2FHang%2FData%20Loss");
LABEL_9:
      v11 = (void *)objc_claimAutoreleasedReturnValue(-[__CFString stringByAppendingString:](v7, "stringByAppendingString:", CFSTR("&ComponentID=")));

      v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "stringByAppendingString:", *(_QWORD *)(a1 + 40)));
      v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "stringByAppendingString:", CFSTR("&ComponentName=")));

      v14 = sub_1006B66DC(*(void **)(a1 + 48));
      v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
      v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "stringByAppendingString:", v15));

      v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v16, "stringByAppendingString:", CFSTR("&ComponentVersion=")));
      v18 = sub_1006B66DC(*(void **)(a1 + 56));
      v19 = (void *)objc_claimAutoreleasedReturnValue(v18);
      v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "stringByAppendingString:", v19));

      v21 = qword_1009997E8;
      if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
      {
        v22 = objc_msgSend(objc_retainAutorelease(v20), "UTF8String");
        *(_DWORD *)buf = 136446210;
        v28 = v22;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "btControllerTapToRadar: Launch TapToRadar URL : %{public}s", buf, 0xCu);
      }
      v23 = (void *)objc_claimAutoreleasedReturnValue(+[NSURL URLWithString:](NSURL, "URLWithString:", v20));
      v24 = (void *)objc_claimAutoreleasedReturnValue(+[LSApplicationWorkspace defaultWorkspace](LSApplicationWorkspace, "defaultWorkspace"));
      objc_msgSend(v24, "openURL:configuration:completionHandler:", v23, 0, &stru_100940420);

      return;
    case 2:
      v8 = sub_1006B66DC(*(void **)(a1 + 32));
      v9 = (void *)objc_claimAutoreleasedReturnValue(v8);
      v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(CFSTR("tap-to-radar://new?Title="), "stringByAppendingString:", v9));

      v6 = objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "stringByAppendingString:", CFSTR("&Classification=Security")));
      goto LABEL_8;
    case 1:
      v3 = sub_1006B66DC(*(void **)(a1 + 32));
      v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
      v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(CFSTR("tap-to-radar://new?Title=BT%20Controller%20Error%20Found%3A%20"), "stringByAppendingString:", v4));

      v6 = objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "stringByAppendingString:", CFSTR("&Classification=Crash%2FHang%2FData%20Loss")));
LABEL_8:
      v10 = (__CFString *)v6;

      v7 = v10;
      goto LABEL_9;
  }
  v25 = qword_1009997E8;
  if (os_log_type_enabled((os_log_t)qword_1009997E8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    LODWORD(v28) = v2;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Invalid Tap-To-Radar Type %d", buf, 8u);
  }
}

void sub_1006B664C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id sub_1006B66DC(void *a1)
{
  id v1;
  void *v2;
  void *v3;

  v1 = a1;
  v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSCharacterSet characterSetWithCharactersInString:](NSCharacterSet, "characterSetWithCharactersInString:", CFSTR("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")));
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v1, "stringByAddingPercentEncodingWithAllowedCharacters:", v2));

  return v3;
}

void sub_1006B6740(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1006B67F0(id a1)
{
  operator new();
}

void sub_1006B6830()
{
  operator delete();
}

void sub_1006B6854(id a1)
{
  operator new();
}

void sub_1006B6894()
{
  operator delete();
}

void sub_1006B68B8(id a1)
{
  operator new();
}

void sub_1006B68F8()
{
  operator delete();
}

void sub_1006B691C(id a1)
{
  operator new();
}

void sub_1006B695C()
{
  operator delete();
}

void sub_1006B6980(id a1)
{
  operator new();
}

void sub_1006B69C0()
{
  operator delete();
}

uint64_t sub_1006B69E4()
{
  uint64_t result;

  result = sub_100016B48();
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 16))(result);
  return result;
}

uint64_t sub_1006B6A0C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = sub_100016B48();
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)result + 32))(result, a2, a3);
  return result;
}

uint64_t sub_1006B6A50(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  result = sub_100016B48();
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)result + 40))(result, a2, a3);
  return result;
}

_QWORD *sub_1006B6A94(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  NSMutableOrderedSet *v4;
  void *v5;

  a1[1] = &off_100940618;
  v2 = (uint64_t)(a1 + 1);
  *a1 = off_100940518;
  a1[2] = 0;
  v3 = sub_1000419F4();
  sub_10026C3D0((_DWORD)a1 + 24, (int)a1, "com.apple.BTServer.le", *(dispatch_queue_t *)(v3 + 8));
  sub_10026C40C((uint64_t)(a1 + 3));
  v4 = objc_opt_new(NSMutableOrderedSet);
  v5 = (void *)a1[2];
  a1[2] = v4;

  if (qword_10097AC28 != -1)
    dispatch_once(&qword_10097AC28, &stru_100940630);
  sub_100484B48(qword_10097AC20, v2);
  return a1;
}

void sub_1006B6B50(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

uint64_t sub_1006B6B78(uint64_t a1)
{
  uint64_t v2;

  *(_QWORD *)a1 = off_100940518;
  *(_QWORD *)(a1 + 8) = &off_100940618;
  v2 = a1 + 8;
  if (qword_10097AC28 != -1)
    dispatch_once(&qword_10097AC28, &stru_100940630);
  sub_100484BD8(qword_10097AC20, v2);
  sub_10026C408(a1 + 24);

  return a1;
}

void sub_1006B6BF8(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_10026C408(v1 + 24);

  _Unwind_Resume(a1);
}

void sub_1006B6C18(uint64_t a1)
{
  sub_1006B6B78(a1);
  operator delete();
}

void sub_1006B6C40(uint64_t a1, void *a2)
{
  id v3;
  xpc_object_t v4;
  unsigned __int8 uuid[8];
  uint64_t v6;

  v3 = a2;
  v4 = xpc_dictionary_create(0, 0, 0);
  *(_QWORD *)uuid = 0;
  v6 = 0;
  objc_msgSend(v3, "getUUIDBytes:", uuid);
  xpc_dictionary_set_uuid(v4, "kPeerIdentifier", uuid);
  sub_10026C614(a1 + 24, "ConnectOnce", v4, 0);

}

void sub_1006B6CF4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1006B6D14(uint64_t a1, void *a2)
{
  id v3;
  xpc_object_t v4;
  xpc_object_t v5;
  id v6;
  id v7;
  uint64_t v8;
  void *v9;
  void *v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  unsigned __int8 uuid[8];
  uint64_t v16;
  _BYTE v17[128];

  v3 = a2;
  v4 = xpc_dictionary_create(0, 0, 0);
  v5 = xpc_array_create(0, 0);
  v13 = 0u;
  v14 = 0u;
  v11 = 0u;
  v12 = 0u;
  v6 = v3;
  v7 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v11, v17, 16);
  if (v7)
  {
    v8 = *(_QWORD *)v12;
    do
    {
      v9 = 0;
      do
      {
        if (*(_QWORD *)v12 != v8)
          objc_enumerationMutation(v6);
        v10 = *(void **)(*((_QWORD *)&v11 + 1) + 8 * (_QWORD)v9);
        *(_QWORD *)uuid = 0;
        v16 = 0;
        objc_msgSend(v10, "getUUIDBytes:", uuid, (_QWORD)v11);
        xpc_array_set_uuid(v5, 0xFFFFFFFFFFFFFFFFLL, uuid);
        v9 = (char *)v9 + 1;
      }
      while (v7 != v9);
      v7 = objc_msgSend(v6, "countByEnumeratingWithState:objects:count:", &v11, v17, 16);
    }
    while (v7);
  }

  xpc_dictionary_set_value(v4, "kPeerIdentifiers", v5);
  xpc_release(v5);
  sub_10026C614(a1 + 24, "ConnectAlways", v4, 0);

}

void sub_1006B6E88(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1006B6EC0(uint64_t a1, unsigned int a2, unsigned int a3)
{
  xpc_object_t v6;

  v6 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_uint64(v6, "kPiconetClock", a2);
  xpc_dictionary_set_uint64(v6, "kPiconetPhaseClock", a3);
  sub_10026C614(a1 + 24, "NotifyPiconetClock", v6, 0);
}

void sub_1006B6F3C(uint64_t a1, void *a2)
{
  id v3;
  xpc_object_t v4;
  unsigned __int8 uuid[8];
  uint64_t v6;

  v3 = a2;
  v4 = xpc_dictionary_create(0, 0, 0);
  *(_QWORD *)uuid = 0;
  v6 = 0;
  objc_msgSend(v3, "getUUIDBytes:", uuid);
  xpc_dictionary_set_uuid(v4, "kPeerIdentifier", uuid);
  sub_10026C614(a1 + 24, "DOAPDeviceConnected", v4, 0);

}

void sub_1006B6FF0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1006B700C(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  xpc_object_t v7;
  id v8;

  v3 = a2;
  v8 = v3;
  if (qword_1009778C8 == -1)
  {
    v4 = v3;
  }
  else
  {
    dispatch_once(&qword_1009778C8, &stru_100940650);
    v4 = v8;
  }
  v5 = sub_1000589DC((uint64_t)off_1009778C0, v4, 0);
  if (qword_1009778E8 != -1)
    dispatch_once(&qword_1009778E8, &stru_100940670);
  v6 = sub_10006D488((uint64_t)off_1009778E0, v5, 0);
  if (v6 && sub_100442880(v6))
    sub_1006B7114(a1, v8);
  v7 = xpc_dictionary_create(0, 0, 0);
  sub_10026C614(a1 + 24, "UARPDeviceConnected", v7, 0);

}

void sub_1006B70FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1006B7114(uint64_t a1, void *a2)
{
  id v3;
  xpc_object_t v4;
  unsigned __int8 uuid[8];
  uint64_t v6;

  v3 = a2;
  v4 = xpc_dictionary_create(0, 0, 0);
  *(_QWORD *)uuid = 0;
  v6 = 0;
  objc_msgSend(v3, "getUUIDBytes:", uuid);
  xpc_dictionary_set_uuid(v4, "kUARPDeviceUUID", uuid);
  sub_10026C614(a1 + 24, "UARPAACPTransportChange", v4, 0);

}

void sub_1006B71C8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1006B71E8(uint64_t a1, void *a2)
{
  id v3;
  NSObject *v4;
  xpc_object_t v5;
  uint8_t v6[16];

  v3 = a2;
  v4 = qword_100999810;
  if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Sending HRM connected xpc message", v6, 2u);
  }
  v5 = xpc_dictionary_create(0, 0, 0);
  sub_10026C614(a1 + 24, "HRMDeviceConnected", v5, 0);

}

void sub_1006B728C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1006B729C(uint64_t a1, unsigned int a2, uint64_t a3)
{
  void *__p[2];
  uint64_t v6;

  if (*(char *)(a3 + 23) < 0)
  {
    sub_10003430C(__p, *(void **)a3, *(_QWORD *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)__p = *(_OWORD *)a3;
    v6 = *(_QWORD *)(a3 + 16);
  }
  sub_1006B7328(a1, a2, (const char *)__p);
  if (SHIBYTE(v6) < 0)
    operator delete(__p[0]);
}

void sub_1006B730C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1006B7328(uint64_t a1, unsigned int a2, const char *a3)
{
  xpc_object_t v6;

  v6 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_uint64(v6, "kEasyPairingVersion", a2);
  if (a3[23] < 0)
    a3 = *(const char **)a3;
  xpc_dictionary_set_string(v6, "kCloudAccount", a3);
  sub_10026C614(a1 + 24, "VersionInfoRequest", v6, 0);
}

void sub_1006B73AC(uint64_t a1, unsigned int a2, uint64_t a3, unsigned int a4)
{
  void *__p[2];
  uint64_t v8;

  if (*(char *)(a3 + 23) < 0)
  {
    sub_10003430C(__p, *(void **)a3, *(_QWORD *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)__p = *(_OWORD *)a3;
    v8 = *(_QWORD *)(a3 + 16);
  }
  sub_1006B7448(a1, a2, (const char *)__p, a4);
  if (SHIBYTE(v8) < 0)
    operator delete(__p[0]);
}

void sub_1006B742C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1006B7448(uint64_t a1, unsigned int a2, const char *a3, unsigned int a4)
{
  xpc_object_t v8;

  v8 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_uint64(v8, "kEasyPairingVersion", a2);
  if (a3[23] < 0)
    a3 = *(const char **)a3;
  xpc_dictionary_set_string(v8, "kCloudAccount", a3);
  xpc_dictionary_set_uint64(v8, "kEasyPairingStatus", a4);
  sub_10026C614(a1 + 24, "VersionInfoResponse", v8, 0);
}

void sub_1006B74EC(uint64_t a1, uint64_t a2)
{
  void *__p[2];
  uint64_t v4;

  if (*(char *)(a2 + 23) < 0)
  {
    sub_10003430C(__p, *(void **)a2, *(_QWORD *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)__p = *(_OWORD *)a2;
    v4 = *(_QWORD *)(a2 + 16);
  }
  sub_1006B7574(a1, (const char *)__p);
  if (SHIBYTE(v4) < 0)
    operator delete(__p[0]);
}

void sub_1006B7558(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1006B7574(uint64_t a1, const char *a2)
{
  xpc_object_t v4;
  void *v5;

  v4 = xpc_dictionary_create(0, 0, 0);
  v5 = v4;
  if (a2[23] < 0)
    a2 = *(const char **)a2;
  xpc_dictionary_set_string(v4, "kDeviceAddress", a2);
  sub_10026C614(a1 + 24, "ClassicPairStateRequest", v5, 0);
}

void sub_1006B75E4(uint64_t a1, uint64_t a2, unsigned int a3)
{
  void *__p[2];
  uint64_t v6;

  if (*(char *)(a2 + 23) < 0)
  {
    sub_10003430C(__p, *(void **)a2, *(_QWORD *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)__p = *(_OWORD *)a2;
    v6 = *(_QWORD *)(a2 + 16);
  }
  sub_1006B7674(a1, (const char *)__p, a3);
  if (SHIBYTE(v6) < 0)
    operator delete(__p[0]);
}

void sub_1006B7658(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1006B7674(uint64_t a1, const char *a2, unsigned int a3)
{
  xpc_object_t v6;
  void *v7;

  v6 = xpc_dictionary_create(0, 0, 0);
  v7 = v6;
  if (a2[23] < 0)
    a2 = *(const char **)a2;
  xpc_dictionary_set_string(v6, "kDeviceAddress", a2);
  xpc_dictionary_set_uint64(v7, "kDevicePairState", a3);
  sub_10026C614(a1 + 24, "ClassicPairStateResponse", v7, 0);
}

void sub_1006B76FC(uint64_t a1, uint64_t a2, const char *a3, const void *a4, unsigned int a5)
{
  void *__p[2];
  uint64_t v10;

  if (*(char *)(a2 + 23) < 0)
  {
    sub_10003430C(__p, *(void **)a2, *(_QWORD *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)__p = *(_OWORD *)a2;
    v10 = *(_QWORD *)(a2 + 16);
  }
  sub_1006B77A4(a1, (const char *)__p, a3, a4, a5);
  if (SHIBYTE(v10) < 0)
    operator delete(__p[0]);
}

void sub_1006B7788(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1006B77A4(uint64_t a1, const char *a2, const char *a3, const void *a4, unsigned int a5)
{
  xpc_object_t v10;
  void *v11;

  v10 = xpc_dictionary_create(0, 0, 0);
  v11 = v10;
  if (a2[23] < 0)
    a2 = *(const char **)a2;
  xpc_dictionary_set_string(v10, "kDeviceAddress", a2);
  xpc_dictionary_set_string(v11, "kDeviceName", a3);
  xpc_dictionary_set_data(v11, "kDeviceLinkKey", a4, a5);
  sub_10026C614(a1 + 24, "StoreClassicLinkKeyRequest", v11, 0);
}

void sub_1006B7854(uint64_t a1, uint64_t a2, const char *a3, const void *a4, unsigned int a5, unsigned int a6, unsigned int a7)
{
  void *__p[2];
  uint64_t v14;

  if (*(char *)(a2 + 23) < 0)
  {
    sub_10003430C(__p, *(void **)a2, *(_QWORD *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)__p = *(_OWORD *)a2;
    v14 = *(_QWORD *)(a2 + 16);
  }
  sub_1006B7914(a1, (const char *)__p, a3, a4, a5, a6, a7);
  if (SHIBYTE(v14) < 0)
    operator delete(__p[0]);
}

void sub_1006B78F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1006B7914(uint64_t a1, const char *a2, const char *a3, const void *a4, unsigned int a5, unsigned int a6, unsigned int a7)
{
  xpc_object_t v14;
  void *v15;

  v14 = xpc_dictionary_create(0, 0, 0);
  v15 = v14;
  if (a2[23] < 0)
    a2 = *(const char **)a2;
  xpc_dictionary_set_string(v14, "kDeviceAddress", a2);
  xpc_dictionary_set_string(v15, "kDeviceName", a3);
  xpc_dictionary_set_data(v15, "kDeviceLinkKey", a4, a5);
  xpc_dictionary_set_uint64(v15, "kDeviceServiceMask", a6);
  xpc_dictionary_set_uint64(v15, "kClassOfDeviceMask", a7);
  sub_10026C614(a1 + 24, "StoreClassicLinkKeyRequestExtended", v15, 0);
}

void sub_1006B79FC(uint64_t a1, uint64_t a2, void *a3, const char *a4)
{
  id v7;
  void *__p[2];
  uint64_t v9;

  v7 = a3;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10003430C(__p, *(void **)a2, *(_QWORD *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)__p = *(_OWORD *)a2;
    v9 = *(_QWORD *)(a2 + 16);
  }
  sub_1006B7AB0(a1, (const char *)__p, v7, a4);
  if (SHIBYTE(v9) < 0)
    operator delete(__p[0]);

}

void sub_1006B7A88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  void *v14;

  _Unwind_Resume(a1);
}

void sub_1006B7AB0(uint64_t a1, const char *a2, void *a3, const char *a4)
{
  xpc_object_t v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  xpc_object_t v12;
  id v13;

  v13 = a3;
  v7 = xpc_dictionary_create(0, 0, 0);
  v8 = v7;
  if (a2[23] < 0)
    a2 = *(const char **)a2;
  xpc_dictionary_set_string(v7, "kDeviceAddress", a2);
  xpc_dictionary_set_string(v8, "kDeviceName", a4);
  v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "objectForKey:", CFSTR("kCfgMicSide")));
  xpc_dictionary_set_uint64(v8, "kClassicDeviceMicMode", (int)objc_msgSend(v9, "intValue"));

  v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "objectForKey:", CFSTR("kCfgInEarMode")));
  xpc_dictionary_set_uint64(v8, "kClassicDeviceInEarEnable", objc_msgSend(v10, "BOOLValue"));

  v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v13, "objectForKey:", CFSTR("kCfgDoubleTap")));
  xpc_dictionary_set_uint64(v8, "kClassicDeviceDoubleTapMode", (int)objc_msgSend(v11, "intValue"));

  v12 = sub_1004B0F58(v13);
  xpc_dictionary_set_value(v8, "kClassicDeviceSettings", v12);
  xpc_release(v12);
  sub_10026C614(a1 + 24, "StoreClassicDeviceSettings", v8, 0);

}

void sub_1006B7C14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1006B7C40(uint64_t a1, uint64_t a2)
{
  void *__p[2];
  uint64_t v4;

  if (*(char *)(a2 + 23) < 0)
  {
    sub_10003430C(__p, *(void **)a2, *(_QWORD *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)__p = *(_OWORD *)a2;
    v4 = *(_QWORD *)(a2 + 16);
  }
  sub_1006B7CC8(a1, (const char *)__p);
  if (SHIBYTE(v4) < 0)
    operator delete(__p[0]);
}

void sub_1006B7CAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1006B7CC8(uint64_t a1, const char *a2)
{
  xpc_object_t v4;
  void *v5;

  v4 = xpc_dictionary_create(0, 0, 0);
  v5 = v4;
  if (a2[23] < 0)
    a2 = *(const char **)a2;
  xpc_dictionary_set_string(v4, "kDeviceAddress", a2);
  sub_10026C614(a1 + 24, "ClassicDeviceUnexpectedDisconnection", v5, 0);
}

void sub_1006B7D38(uint64_t a1, uint64_t a2, unsigned int a3)
{
  void *__p[2];
  uint64_t v6;

  if (*(char *)(a2 + 23) < 0)
  {
    sub_10003430C(__p, *(void **)a2, *(_QWORD *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)__p = *(_OWORD *)a2;
    v6 = *(_QWORD *)(a2 + 16);
  }
  sub_1006B7DC8(a1, (const char *)__p, a3);
  if (SHIBYTE(v6) < 0)
    operator delete(__p[0]);
}

void sub_1006B7DAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1006B7DC8(uint64_t a1, const char *a2, unsigned int a3)
{
  xpc_object_t v6;
  void *v7;

  v6 = xpc_dictionary_create(0, 0, 0);
  v7 = v6;
  if (a2[23] < 0)
    a2 = *(const char **)a2;
  xpc_dictionary_set_string(v6, "kDeviceAddress", a2);
  xpc_dictionary_set_uint64(v7, "kQuickDisconnectEnabled", a3);
  sub_10026C614(a1 + 24, "ConnectClassicDevice", v7, 0);
}

void sub_1006B7E50(uint64_t a1, uint64_t a2, unsigned int a3)
{
  void *__p[2];
  uint64_t v6;

  if (*(char *)(a2 + 23) < 0)
  {
    sub_10003430C(__p, *(void **)a2, *(_QWORD *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)__p = *(_OWORD *)a2;
    v6 = *(_QWORD *)(a2 + 16);
  }
  sub_1006B7EE0(a1, (const char *)__p, a3);
  if (SHIBYTE(v6) < 0)
    operator delete(__p[0]);
}

void sub_1006B7EC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1006B7EE0(uint64_t a1, const char *a2, unsigned int a3)
{
  xpc_object_t v6;
  void *v7;

  v6 = xpc_dictionary_create(0, 0, 0);
  v7 = v6;
  if (a2[23] < 0)
    a2 = *(const char **)a2;
  xpc_dictionary_set_string(v6, "kDeviceAddress", a2);
  xpc_dictionary_set_uint64(v7, "kPrimaryBudSide", a3);
  sub_10026C614(a1 + 24, "NotifyPrimaryBudSide", v7, 0);
}

void sub_1006B7F6C(uint64_t a1, void *a2)
{
  id v3;
  xpc_object_t v4;
  unsigned __int8 uuid[8];
  uint64_t v6;

  v3 = a2;
  v4 = xpc_dictionary_create(0, 0, 0);
  *(_QWORD *)uuid = 0;
  v6 = 0;
  objc_msgSend(v3, "getUUIDBytes:", uuid);
  xpc_dictionary_set_uuid(v4, "kPeerIdentifier", uuid);
  sub_10026C614(a1 + 24, "MFiAccessoryAuth", v4, 0);

}

void sub_1006B8020(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1006B8040(uint64_t a1, void *a2)
{
  xpc_object_t v3;
  id v4;

  v4 = a2;
  v3 = sub_1004B0F58(v4);
  sub_10026C614(a1 + 24, "LaunchBTLEServerWithOptions", v3, 0);

}

void sub_1006B808C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1006B80A0(uint64_t a1)
{
  xpc_object_t v2;

  v2 = xpc_dictionary_create(0, 0, 0);
  sub_10026C614(a1 + 24, "PreWarmMFiAccessoryAuth", v2, 0);
}

void sub_1006B80E4(uint64_t a1, void *a2, unsigned int a3, const void *a4)
{
  id v7;
  xpc_object_t v8;
  unsigned __int8 uuid[8];
  uint64_t v10;

  v7 = a2;
  v8 = xpc_dictionary_create(0, 0, 0);
  *(_QWORD *)uuid = 0;
  v10 = 0;
  objc_msgSend(v7, "getUUIDBytes:", uuid);
  xpc_dictionary_set_uuid(v8, "kUARPDeviceUUID", uuid);
  xpc_dictionary_set_data(v8, "kUARPData", a4, a3);
  sub_10026C614(a1 + 24, "UARPDataOverAACP", v8, 0);

}

void sub_1006B81C0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1006B81DC(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v7;
  id v8;
  void *__p[2];
  uint64_t v10;

  v7 = a3;
  v8 = a4;
  if (*(char *)(a2 + 23) < 0)
  {
    sub_10003430C(__p, *(void **)a2, *(_QWORD *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)__p = *(_OWORD *)a2;
    v10 = *(_QWORD *)(a2 + 16);
  }
  sub_1006B82A0(a1, (const char *)__p, v7, v8);
  if (SHIBYTE(v10) < 0)
    operator delete(__p[0]);

}

void sub_1006B8274(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  void *v14;
  void *v15;

  _Unwind_Resume(a1);
}

void sub_1006B82A0(uint64_t a1, const char *a2, void *a3, void *a4)
{
  id v7;
  id v8;
  xpc_object_t v9;
  void *v10;
  id v11;
  void *v12;
  NSObject *v13;
  id v14;
  int v15;
  id v16;

  v7 = a3;
  v8 = a4;
  v9 = xpc_dictionary_create(0, 0, 0);
  v10 = v9;
  if (a2[23] < 0)
    a2 = *(const char **)a2;
  xpc_dictionary_set_string(v9, "kLeaDeviceAddress", a2);
  v11 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "UUIDString")));
  xpc_dictionary_set_string(v10, "kLeaDeviceIdentifier", (const char *)objc_msgSend(v11, "UTF8String"));

  v12 = (void *)sub_1004B10A4(v8);
  xpc_dictionary_set_value(v10, "kLeaDeviceTags", v12);
  xpc_release(v12);
  v13 = qword_100999810;
  if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
  {
    v14 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "UUIDString")));
    v15 = 136315138;
    v16 = objc_msgSend(v14, "UTF8String");
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Sending requestLeaEasyPairMsg: kLeaDeviceIdentifier = %s", (uint8_t *)&v15, 0xCu);

  }
  sub_10026C614(a1 + 24, "LeaEasyPairRequest", v10, 0);

}

void sub_1006B8430(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1006B846C(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, const void *a5, const void *a6, const void *a7)
{
  void *__p[2];
  uint64_t v14;
  void *__dst[2];
  uint64_t v16;

  if (*(char *)(a2 + 23) < 0)
  {
    sub_10003430C(__dst, *(void **)a2, *(_QWORD *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)__dst = *(_OWORD *)a2;
    v16 = *(_QWORD *)(a2 + 16);
  }
  if (*(char *)(a3 + 23) < 0)
  {
    sub_10003430C(__p, *(void **)a3, *(_QWORD *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)__p = *(_OWORD *)a3;
    v14 = *(_QWORD *)(a3 + 16);
  }
  sub_1006B857C(a1, (const char *)__dst, (const char *)__p, a4, a5, a6, a7);
  if (SHIBYTE(v14) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v16) < 0)
    operator delete(__dst[0]);
}

void sub_1006B8548(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1006B857C(uint64_t a1, const char *a2, const char *a3, unsigned int a4, const void *a5, const void *a6, const void *a7)
{
  xpc_object_t v14;
  void *v15;

  v14 = xpc_dictionary_create(0, 0, 0);
  v15 = v14;
  if (a2[23] < 0)
    a2 = *(const char **)a2;
  xpc_dictionary_set_string(v14, "kLeaDeviceAddress", a2);
  if (a3[23] < 0)
    a3 = *(const char **)a3;
  xpc_dictionary_set_string(v15, "kLeaDeviceName", a3);
  xpc_dictionary_set_uint64(v15, "kLeaDeviceEdiv", a4);
  xpc_dictionary_set_data(v15, "kLeaDeviceRand", a5, 8uLL);
  xpc_dictionary_set_data(v15, "kLeaDeviceLtk", a6, 0x10uLL);
  xpc_dictionary_set_data(v15, "kLeaDeviceIrk", a7, 0x10uLL);
  sub_10026C614(a1 + 24, "LeaStoreBondingInfoRequest", v15, 0);
}

void sub_1006B868C(uint64_t a1)
{
  BOOL v2;

  if (qword_10097AC28 != -1)
    dispatch_once(&qword_10097AC28, &stru_100940630);
  v2 = sub_10048472C(qword_10097AC20);
  sub_1006B86E4(a1, v2);
}

void sub_1006B86E4(uint64_t a1, BOOL a2)
{
  xpc_object_t v4;

  v4 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_BOOL(v4, "kPersist", a2);
  sub_10026C614(a1 + 24, "PersistServerServices", v4, 0);
}

void sub_1006B8744(uint64_t a1, const char *a2, unsigned int a3)
{
  xpc_object_t v6;
  void *v7;

  v6 = xpc_dictionary_create(0, 0, 0);
  v7 = v6;
  if (a2[23] < 0)
    a2 = *(const char **)a2;
  xpc_dictionary_set_string(v6, "kDeviceAddress", a2);
  xpc_dictionary_set_uint64(v7, "kStoreClassicLinkKeyResult", a3);
  sub_10026C614(a1 + 24, "StoreClassicLinkKeyResponse", v7, 0);
}

void sub_1006B87CC(uint64_t a1, const char *a2, unsigned int a3)
{
  NSObject *v6;
  xpc_object_t v7;
  void *v8;
  _DWORD v9[2];

  v6 = qword_100999810;
  if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
  {
    v9[0] = 67109120;
    v9[1] = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Sending LeaEasyPairResponse: status=%d", (uint8_t *)v9, 8u);
  }
  v7 = xpc_dictionary_create(0, 0, 0);
  v8 = v7;
  if (a2[23] < 0)
    a2 = *(const char **)a2;
  xpc_dictionary_set_string(v7, "kLeaDeviceAddress", a2);
  xpc_dictionary_set_uint64(v8, "kLeaDevicePairState", a3);
  sub_10026C614(a1 + 24, "LeaEasyPairResponse", v8, 0);
}

void sub_1006B88DC(uint64_t a1, const char *a2, unsigned int a3)
{
  xpc_object_t v6;
  void *v7;

  v6 = xpc_dictionary_create(0, 0, 0);
  v7 = v6;
  if (a2[23] < 0)
    a2 = *(const char **)a2;
  xpc_dictionary_set_string(v6, "kLeaDeviceAddress", a2);
  xpc_dictionary_set_uint64(v7, "kLeaStoreBondingInfoResult", a3);
  sub_10026C614(a1 + 24, "LeaStoreBondingInfoResponse", v7, 0);
}

void sub_1006B8964(uint64_t a1, const char *a2, void *a3)
{
  NSObject *v6;
  id v7;
  id v8;
  uint64_t v9;
  uint64_t v10;
  const void *data;
  void *v12;
  void *v13;
  const unsigned __int8 *uuid;
  double v15;
  double v16;
  double v17;
  unsigned __int16 int64;
  unsigned __int16 v19;
  unsigned __int16 v20;
  __int16 v21;
  unsigned __int16 v22;
  float v23;
  float v24;
  float v25;
  const unsigned __int8 *v26;
  int64_t v27;
  const unsigned __int8 *v28;
  void *v29;
  id v30;
  void *v31;
  void *v32;
  id v33;
  void *v34;
  const unsigned __int8 *v35;
  void *v36;
  id v37;
  void *v38;
  const unsigned __int8 *v39;
  void *v40;
  id v41;
  void *v42;
  char *string;
  unsigned __int8 *v44;
  uint64_t v45;
  id v46;
  unsigned __int16 v47;
  uint64_t v48;
  id v49;
  id v50;
  NSObject *v51;
  uint64_t v52;
  unsigned __int8 *v53;
  const char *v54;
  uint8_t *v55;
  NSObject *v56;
  uint32_t v57;
  void *v58;
  unsigned __int8 v59;
  char *v60;
  uint64_t v61;
  unsigned __int8 v62;
  char *v63;
  unsigned __int8 v64;
  uint64_t v65;
  char *v66;
  unsigned __int8 *v67;
  char *v68;
  unsigned __int8 v69;
  unsigned __int8 *v70;
  uint64_t v71;
  void *v72;
  char *v73;
  char *v74;
  xpc_object_t value;
  unsigned __int8 *v76;
  size_t count;
  size_t v78;
  unsigned __int8 *v79;
  unsigned __int8 *v80;
  NSObject *v82;
  unsigned int v83;
  int v84;
  _BYTE *v85;
  char *v86;
  char *v87;
  xpc_object_t v88;
  int v89;
  int64_t v90;
  unsigned __int8 *v91;
  size_t v92;
  size_t v93;
  unsigned __int8 *v94;
  unsigned int v96;
  int v97;
  NSObject *v98;
  unsigned int v99;
  int v100;
  _BYTE *v101;
  char *v102;
  unsigned __int8 v103;
  unsigned __int8 *v104;
  uint64_t v105;
  char *v106;
  unsigned __int8 *v107;
  int64_t v108;
  int64_t v109;
  int v110;
  xpc_object_t v111;
  uint64_t v112;
  void *v113;
  void *v114;
  unsigned int v115;
  void *v116;
  void *v117;
  char *v118;
  unsigned __int8 *v119;
  unsigned __int8 *v120;
  uint64_t v121;
  NSObject *v122;
  int v123;
  unsigned __int8 *v124;
  _BOOL4 v125;
  unsigned __int8 *v126;
  const char *v127;
  char *v128;
  int64_t v129;
  unsigned __int8 *v130;
  unsigned __int8 *v131;
  uint64_t v132;
  NSObject *v133;
  int v134;
  _BYTE *v135;
  _BOOL4 v136;
  _BYTE *v137;
  const char *v138;
  int v139;
  _BOOL4 v140;
  char *v141;
  unsigned __int8 v142;
  unsigned __int8 *v143;
  uint64_t v144;
  int v145;
  _BOOL4 v146;
  uint64_t v147;
  uint64_t v148;
  int v149;
  void *v150;
  unsigned int v151;
  void *v152;
  void *v153;
  unsigned int v154;
  void *v155;
  void *v156;
  unsigned int v157;
  void *v158;
  void *v159;
  unsigned int v160;
  void *v161;
  void *v162;
  unsigned int v163;
  void *v164;
  char *v165;
  unsigned __int8 *v166;
  uint64_t v167;
  _BOOL4 v168;
  NSObject *v169;
  _BYTE *v170;
  unsigned __int8 *v171;
  char v172;
  char v173;
  char v174;
  char v175;
  char v176;
  char v177;
  NSObject *v178;
  char *v179;
  char *v180;
  xpc_object_t v181;
  uint64_t v182;
  uint64_t v183;
  int v184;
  char *v185;
  unsigned __int8 v186;
  NSObject *v187;
  unsigned __int8 *v188;
  unsigned __int8 *v189;
  unint64_t v190;
  uint64_t v191;
  id v192;
  void *v193;
  _BOOL4 v194;
  uint64_t v195;
  void *v196;
  id v197;
  uint64_t v198;
  void *v199;
  void *v200;
  id v201;
  void *v202;
  uint64_t v203;
  NSObject *v205;
  const char *v206;
  _BYTE *v207;
  uint64_t v208;
  void *v209;
  char *v210;
  char *v211;
  __int16 v212;
  unsigned __int8 *v213;
  uint64_t *v214;
  _OWORD *v215;
  __int128 *v216;
  unint64_t v217;
  NSObject *v218;
  const char *v219;
  NSObject *v220;
  _BYTE *v221;
  NSObject *v222;
  const char *v223;
  _BYTE *v224;
  char *v225;
  unsigned __int8 v226;
  unsigned __int8 *v227;
  NSObject *v228;
  id v229;
  NSObject *v230;
  NSNumber *v231;
  void *v232;
  void *v233;
  NSObject *v234;
  _BYTE *v235;
  void *v236;
  uint64_t v237;
  void *v238;
  uint64_t v239;
  NSObject *v240;
  int v241;
  _BYTE *v242;
  _BYTE *v243;
  _BYTE *v244;
  NSObject *v245;
  void **v246;
  NSObject *v247;
  uint64_t v248;
  id v249;
  void *v250;
  uint64_t v251;
  id v252;
  void *v253;
  uint64_t v254;
  unsigned int v255;
  xpc_object_t v256;
  unsigned int v257;
  unsigned int v258;
  unsigned int v259;
  unsigned int v260;
  int v261;
  __int16 v262;
  int v263;
  __int16 v264;
  _QWORD v265[2];
  __int128 v266;
  uint64_t v267;
  size_t v268;
  __int128 v269;
  uint64_t v270;
  size_t v271;
  __int128 v272;
  uint64_t v273;
  size_t length;
  __int128 v275;
  uint64_t v276;
  int v277;
  __int16 v278;
  int v279;
  __int16 v280;
  __int128 v281;
  uint64_t v282;
  __int128 v283;
  uint64_t v284;
  void *v285[2];
  char v286;
  __int128 v287;
  uint64_t v288;
  void *v289[2];
  uint64_t v290;
  void *v291[2];
  uint64_t v292;
  __int128 v293;
  uint64_t v294;
  __int128 v295;
  uint64_t v296;
  __int128 v297;
  uint64_t v298;
  __int128 v299;
  uint64_t v300;
  std::string v301;
  std::string __dst;
  void *v303[2];
  char v304;
  void *__p[2];
  char v306;
  uint64_t v307;
  const __CFString *v308;
  void *v309;
  _BYTE v310[22];
  char v311;
  _BYTE v312[22];
  char v313;
  uint64_t v314;
  uint64_t v315;
  __int128 v316;
  uuid_t dst;
  uint64_t v318;
  _BYTE buf[32];

  v6 = qword_100999810;
  if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = a2;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Received XPC message \"%{public}s\"", buf, 0xCu);
  }
  if (!strcmp(a2, "SetConnectionParameters"))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = 0;
    uuid = xpc_dictionary_get_uuid(a3, "kPeerIdentifier");
    uuid_copy(buf, uuid);
    v15 = xpc_dictionary_get_double(a3, "kMinInterval");
    v16 = xpc_dictionary_get_double(a3, "kPreferredInterval");
    v17 = xpc_dictionary_get_double(a3, "kMaxInterval");
    int64 = xpc_dictionary_get_int64(a3, "kMinCELength");
    v19 = xpc_dictionary_get_int64(a3, "kMaxCELength");
    v20 = xpc_dictionary_get_int64(a3, "kPreferredPeripheralLatency");
    v21 = xpc_dictionary_get_int64(a3, "kMaxPeripheralLatency");
    v22 = xpc_dictionary_get_int64(a3, "kTimeout");
    xpc_dictionary_get_int64(a3, "kMaxDeferment");
    v23 = v15;
    v24 = v16;
    v25 = v17;
    if (qword_1009778A8 != -1)
      dispatch_once(&qword_1009778A8, &stru_100940690);
    sub_10063AA04((uint64_t)off_1009778A0, buf, int64, v19, v20, v21, v22, v23, v24, v25);
  }
  else if (!strcmp(a2, "AuthenticationDidSucceed"))
  {
    memset(dst, 0, sizeof(dst));
    v26 = xpc_dictionary_get_uuid(a3, "kPeerIdentifier");
    uuid_copy(dst, v26);
    v27 = xpc_dictionary_get_int64(a3, "kCertClass");
    memset(buf, 0, sizeof(buf));
    if (v27 == 0x7FFFFFFF)
      strcpy(buf, "IsMFiAuthenticated");
    else
      snprintf(buf, 0x20uLL, "IsMFiAuthenticated_CertClass%02X", v27);
    if (qword_1009778C8 != -1)
      dispatch_once(&qword_1009778C8, &stru_100940650);
    v32 = off_1009778C0;
    v33 = sub_100030DF4(dst);
    v34 = (void *)objc_claimAutoreleasedReturnValue(v33);
    sub_100091AE8(__p, buf);
    sub_1006576F0((uint64_t)v32, v34, (unsigned __int8 *)__p);
    if (v306 < 0)
      operator delete(__p[0]);

  }
  else if (!strcmp(a2, "AuthenticationDidFail"))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = 0;
    v28 = xpc_dictionary_get_uuid(a3, "kPeerIdentifier");
    uuid_copy(buf, v28);
    if (qword_1009778C8 != -1)
      dispatch_once(&qword_1009778C8, &stru_100940650);
    v29 = off_1009778C0;
    v30 = sub_100030DF4(buf);
    v31 = (void *)objc_claimAutoreleasedReturnValue(v30);
    sub_100653B18((uint64_t)v29, v31, CFSTR("IsMFiAuthenticated"));

  }
  else if (!strcmp(a2, "PeerIsUsingBuiltinService"))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = 0;
    v35 = xpc_dictionary_get_uuid(a3, "kPeerIdentifier");
    uuid_copy(buf, v35);
    if (qword_1009778C8 != -1)
      dispatch_once(&qword_1009778C8, &stru_100940650);
    v36 = off_1009778C0;
    v37 = sub_100030DF4(buf);
    v38 = (void *)objc_claimAutoreleasedReturnValue(v37);
    sub_100091AE8(v303, "HasBuiltinServices");
    sub_1006576F0((uint64_t)v36, v38, (unsigned __int8 *)v303);
    if (v304 < 0)
      operator delete(v303[0]);

  }
  else if (!strcmp(a2, "PeerIsNotUsingBuiltinService"))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = 0;
    v39 = xpc_dictionary_get_uuid(a3, "kPeerIdentifier");
    uuid_copy(buf, v39);
    if (qword_1009778C8 != -1)
      dispatch_once(&qword_1009778C8, &stru_100940650);
    v40 = off_1009778C0;
    v41 = sub_100030DF4(buf);
    v42 = (void *)objc_claimAutoreleasedReturnValue(v41);
    sub_100653B18((uint64_t)v40, v42, CFSTR("HasBuiltinServices"));

  }
  else
  {
    if (!strcmp(a2, "DisconnectClassicDevice"))
    {
      memset(buf, 0, 24);
      string = (char *)xpc_dictionary_get_string(a3, "kDeviceAddress");
      sub_100091AE8(buf, string);
      *(_WORD *)&v310[4] = 0;
      *(_DWORD *)v310 = 0;
      if (buf[23] >= 0)
        v44 = buf;
      else
        v44 = *(unsigned __int8 **)buf;
      if (!sub_10006D80C((uint64_t)v310, v44))
      {
        if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_ERROR))
          sub_10071B77C();
        goto LABEL_136;
      }
      if (qword_1009778E8 != -1)
        dispatch_once(&qword_1009778E8, &stru_100940670);
      v45 = sub_1004704A8((uint64_t)off_1009778E0, (uint64_t)v310, 1);
      if (!v45)
      {
        v51 = qword_100999810;
        if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_ERROR))
        {
          sub_10046E9BC(v310, dst);
          sub_10071B70C((char *)dst, v312, v51);
        }
        goto LABEL_136;
      }
      if (qword_100978190 != -1)
        dispatch_once(&qword_100978190, &stru_1009406B0);
      if (sub_100438E24((uint64_t)off_100978188, v45))
      {
        if (qword_100977A78 != -1)
          dispatch_once(&qword_100977A78, &stru_1009406D0);
        sub_100499FC8((uint64_t)off_100977A70, v45, -1);
        goto LABEL_136;
      }
      v52 = qword_100999810;
      if (!os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
        goto LABEL_136;
      sub_10043E5F8(v45, dst);
      if (v318 >= 0)
        v53 = dst;
      else
        v53 = *(unsigned __int8 **)dst;
      *(_DWORD *)v312 = 136446210;
      *(_QWORD *)&v312[4] = v53;
      v54 = "Ignoring disconnection request as device \"%{public}s\" is not connected";
      v55 = v312;
      v56 = v52;
      v57 = 12;
      goto LABEL_102;
    }
    if (!strcmp(a2, "EnableBTSync"))
    {
      v46 = objc_msgSend(objc_alloc((Class)NSUUID), "initWithUUIDBytes:", xpc_dictionary_get_uuid(a3, "kPeerIdentifier"));
      v47 = xpc_dictionary_get_int64(a3, "kPeriod");
      v48 = sub_1000438A4();
      (*(void (**)(uint64_t, id, _QWORD))(*(_QWORD *)v48 + 952))(v48, v46, v47);

      return;
    }
    if (!strcmp(a2, "DevMgmtPipeConnected"))
    {
      v49 = objc_msgSend(objc_alloc((Class)NSUUID), "initWithUUIDBytes:", xpc_dictionary_get_uuid(a3, "kPeerIdentifier"));
      if (qword_100977B40 != -1)
        dispatch_once(&qword_100977B40, &stru_1009406F0);
      sub_1004B9F74((uint64_t)off_100977B38, 1);
      objc_msgSend(*(id *)(a1 + 16), "addObject:", v49);
      if (qword_100977A88 != -1)
        dispatch_once(&qword_100977A88, &stru_100940710);
      sub_100283AC4((uint64_t)off_100977A80, v49);
      if (qword_100977908 != -1)
        dispatch_once(&qword_100977908, &stru_100940730);
      sub_1005358F0((_BYTE *)qword_100977900, v49);

    }
    else
    {
      if (strcmp(a2, "DevMgmtPipeDisconnected"))
      {
        if (!strcmp(a2, "VersionInfoRequest"))
        {
          v59 = xpc_dictionary_get_int64(a3, "kEasyPairingVersion");
          memset(buf, 0, 24);
          v60 = (char *)xpc_dictionary_get_string(a3, "kCloudAccount");
          sub_100091AE8(buf, v60);
          if (qword_10097AA50 != -1)
            dispatch_once(&qword_10097AA50, &stru_100940750);
          v61 = qword_10097AA48;
          if ((buf[23] & 0x80000000) != 0)
            sub_10003430C(&__dst, *(void **)buf, *(unint64_t *)&buf[8]);
          else
            __dst = *(std::string *)buf;
          sub_100264114(v61, v59, &__dst);
          if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_136;
          v58 = (void *)__dst.__r_.__value_.__r.__words[0];
          goto LABEL_135;
        }
        if (!strcmp(a2, "VersionInfoResponse"))
        {
          v62 = xpc_dictionary_get_int64(a3, "kEasyPairingVersion");
          memset(buf, 0, 24);
          v63 = (char *)xpc_dictionary_get_string(a3, "kCloudAccount");
          sub_100091AE8(buf, v63);
          v64 = xpc_dictionary_get_int64(a3, "kEasyPairingStatus");
          if (qword_10097AA50 != -1)
            dispatch_once(&qword_10097AA50, &stru_100940750);
          v65 = qword_10097AA48;
          if ((buf[23] & 0x80000000) != 0)
            sub_10003430C(&v301, *(void **)buf, *(unint64_t *)&buf[8]);
          else
            v301 = *(std::string *)buf;
          sub_1002645D8(v65, v62, &v301, v64);
          if ((SHIBYTE(v301.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_136;
          v58 = (void *)v301.__r_.__value_.__r.__words[0];
          goto LABEL_135;
        }
        if (!strcmp(a2, "ClassicPairStateRequest"))
        {
          memset(buf, 0, 24);
          v66 = (char *)xpc_dictionary_get_string(a3, "kDeviceAddress");
          sub_100091AE8(buf, v66);
          *(_WORD *)&dst[4] = 0;
          *(_DWORD *)dst = 0;
          if (buf[23] >= 0)
            v67 = buf;
          else
            v67 = *(unsigned __int8 **)buf;
          if (sub_10006D80C((uint64_t)dst, v67))
          {
            if (qword_10097AA50 != -1)
              dispatch_once(&qword_10097AA50, &stru_100940750);
            sub_1002646EC(qword_10097AA48, (uint64_t)dst);
          }
          else if (os_log_type_enabled((os_log_t)qword_100999870, OS_LOG_TYPE_ERROR))
          {
            sub_10071B7A8();
          }
          goto LABEL_136;
        }
        if (!strcmp(a2, "ClassicPairStateResponse"))
        {
          memset(buf, 0, 24);
          v68 = (char *)xpc_dictionary_get_string(a3, "kDeviceAddress");
          sub_100091AE8(buf, v68);
          v69 = xpc_dictionary_get_int64(a3, "kDevicePairState");
          *(_WORD *)&dst[4] = 0;
          *(_DWORD *)dst = 0;
          if (buf[23] >= 0)
            v70 = buf;
          else
            v70 = *(unsigned __int8 **)buf;
          if (sub_10006D80C((uint64_t)dst, v70))
          {
            if (qword_1009778E8 != -1)
              dispatch_once(&qword_1009778E8, &stru_100940670);
            v71 = sub_1004704A8((uint64_t)off_1009778E0, (uint64_t)dst, 1);
            if (qword_100977A88 != -1)
              dispatch_once(&qword_100977A88, &stru_100940710);
            sub_100284274((uint64_t)off_100977A80, v71, v69);
          }
          else if (os_log_type_enabled((os_log_t)qword_100999870, OS_LOG_TYPE_ERROR))
          {
            sub_10071B7D4();
          }
          goto LABEL_136;
        }
        if (!strcmp(a2, "StoreClassicLinkKeyRequest"))
        {
          memset(buf, 0, 24);
          v73 = (char *)xpc_dictionary_get_string(a3, "kDeviceAddress");
          sub_100091AE8(buf, v73);
          memset(dst, 0, sizeof(dst));
          v318 = 0;
          v74 = (char *)xpc_dictionary_get_string(a3, "kDeviceName");
          sub_100091AE8(dst, v74);
          value = xpc_dictionary_get_value(a3, "kDeviceLinkKey");
          WORD2(v307) = 0;
          LODWORD(v307) = 0;
          if (buf[23] >= 0)
            v76 = buf;
          else
            v76 = *(unsigned __int8 **)buf;
          if (!sub_10006D80C((uint64_t)&v307, v76))
          {
            if (os_log_type_enabled((os_log_t)qword_100999870, OS_LOG_TYPE_ERROR))
              sub_10071B8B0();
            if ((buf[23] & 0x80000000) != 0)
            {
              sub_10003430C(&v299, *(void **)buf, *(unint64_t *)&buf[8]);
            }
            else
            {
              v299 = *(_OWORD *)buf;
              v300 = *(_QWORD *)&buf[16];
            }
            sub_1006B8744(a1, (const char *)&v299, 1u);
            if ((SHIBYTE(v300) & 0x80000000) == 0)
              goto LABEL_103;
            v117 = (void *)v299;
            goto LABEL_319;
          }
          count = xpc_array_get_count(value);
          if (!value || count != 16)
          {
            if (os_log_type_enabled((os_log_t)qword_100999870, OS_LOG_TYPE_ERROR))
              sub_10071B800();
            if ((buf[23] & 0x80000000) != 0)
            {
              sub_10003430C(&v297, *(void **)buf, *(unint64_t *)&buf[8]);
            }
            else
            {
              v297 = *(_OWORD *)buf;
              v298 = *(_QWORD *)&buf[16];
            }
            sub_1006B8744(a1, (const char *)&v297, 1u);
            if ((SHIBYTE(v298) & 0x80000000) == 0)
              goto LABEL_103;
            v117 = (void *)v297;
            goto LABEL_319;
          }
          v78 = 0;
          v316 = 0uLL;
          v314 = 0;
          v315 = 0;
          do
          {
            dst[v78 - 16] = xpc_array_get_int64(value, v78);
            ++v78;
          }
          while (v78 != 16);
          if (qword_1009778E8 != -1)
            dispatch_once(&qword_1009778E8, &stru_100940670);
          v79 = (unsigned __int8 *)sub_1004704A8((uint64_t)off_1009778E0, (uint64_t)&v307, 1);
          v80 = v79;
          if ((_QWORD)v316 != v314 || *((_QWORD *)&v316 + 1) != v315)
          {
            memset(v310, 0, 20);
            sub_1005A9714((uint64_t)v310);
            if (qword_100978160 != -1)
              dispatch_once(&qword_100978160, &stru_100940770);
            if (sub_1005BEB64((uint64_t)off_100978158, v80, (__n128 *)v310) != 150)
              goto LABEL_162;
            if (qword_100977A68 != -1)
              dispatch_once(&qword_100977A68, &stru_100940790);
            if ((sub_10045E940((uint64_t)off_100977A60, (uint64_t)v80) & 1) == 0)
            {
              sub_1005A9734((uint64_t)v312, &v316, 5u);
              sub_1005A9720((__n128 *)v310, (__n128 *)v312);
              nullsub_90(v312, v148);
              if (qword_100978160 != -1)
                dispatch_once(&qword_100978160, &stru_100940770);
              v149 = sub_1005BEC60((uint64_t)off_100978158, v80, (__n128 *)v310, 0);
              if (v149)
              {
                v83 = 1;
              }
              else
              {
                v265[0] = 0;
                *(_QWORD *)&v312[8] = 0;
                *(_QWORD *)v312 = 0;
                sub_10004AD30((uint64_t)v265);
                *(_QWORD *)v312 = SLODWORD(v265[0]);
                *(_QWORD *)&v312[8] = SWORD2(v265[0]);
                sub_10044054C((uint64_t)v80, (uint64_t)dst, v312);
                v83 = 0;
              }
              v205 = qword_100999870;
              if (os_log_type_enabled((os_log_t)qword_100999870, OS_LOG_TYPE_DEFAULT))
              {
                v206 = "Failed to store";
                if (!v149)
                  v206 = "Successfully stored";
                v207 = buf;
                if (buf[23] < 0)
                  v207 = *(_BYTE **)buf;
                *(_DWORD *)v312 = 136315394;
                *(_QWORD *)&v312[4] = v206;
                *(_WORD *)&v312[12] = 2080;
                *(_QWORD *)&v312[14] = v207;
                _os_log_impl((void *)&_mh_execute_header, v205, OS_LOG_TYPE_DEFAULT, "%s classic link key for address %s", v312, 0x16u);
              }
            }
            else
            {
LABEL_162:
              v82 = qword_100999870;
              v83 = 0;
              if (os_log_type_enabled((os_log_t)qword_100999870, OS_LOG_TYPE_DEFAULT))
              {
                if (qword_100977A68 != -1)
                  dispatch_once(&qword_100977A68, &stru_100940790);
                v84 = sub_10045E940((uint64_t)off_100977A60, (uint64_t)v80);
                v85 = buf;
                if (buf[23] < 0)
                  v85 = *(_BYTE **)buf;
                *(_DWORD *)v312 = 67109378;
                *(_DWORD *)&v312[4] = v84;
                *(_WORD *)&v312[8] = 2080;
                *(_QWORD *)&v312[10] = v85;
                _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "Already stored classic link key (Magic Paired: %d) for address: %s", v312, 0x12u);
                v83 = 0;
              }
            }
            if ((buf[23] & 0x80000000) != 0)
            {
              sub_10003430C(&v295, *(void **)buf, *(unint64_t *)&buf[8]);
            }
            else
            {
              v295 = *(_OWORD *)buf;
              v296 = *(_QWORD *)&buf[16];
            }
            sub_1006B8744(a1, (const char *)&v295, v83);
            if ((SHIBYTE(v296) & 0x80000000) == 0)
              goto LABEL_550;
            v209 = (void *)v295;
            goto LABEL_549;
          }
          if (v79 && sub_10043E93C(v79))
          {
            if (qword_100977A88 != -1)
              dispatch_once(&qword_100977A88, &stru_100940710);
            *((_BYTE *)off_100977A80 + 431) = 2;
            if (qword_100977A68 != -1)
              dispatch_once(&qword_100977A68, &stru_100940790);
            v139 = sub_10045E940((uint64_t)off_100977A60, (uint64_t)v80);
            v140 = os_log_type_enabled((os_log_t)qword_100999870, OS_LOG_TYPE_ERROR);
            if (v139)
            {
              if (v140)
                sub_10071B858();
              if (qword_100977A68 == -1)
                goto LABEL_301;
LABEL_661:
              dispatch_once(&qword_100977A68, &stru_100940790);
LABEL_301:
              sub_10045E9C0((uint64_t)off_100977A60, v80, 0);
              goto LABEL_103;
            }
            if (v140)
              sub_10071B884();
            if (qword_100978150 == -1)
            {
LABEL_490:
              sub_1005B8744((uint64_t)off_100978148, v80);
              goto LABEL_103;
            }
LABEL_662:
            dispatch_once(&qword_100978150, &stru_1009407B0);
            goto LABEL_490;
          }
          if (!os_log_type_enabled((os_log_t)qword_100999870, OS_LOG_TYPE_ERROR))
            goto LABEL_103;
        }
        else
        {
          if (strcmp(a2, "StoreClassicLinkKeyRequestExtended"))
          {
            if (!strcmp(a2, "StoreClassicLinkKeyResponse"))
            {
              memset(buf, 0, 24);
              v102 = (char *)xpc_dictionary_get_string(a3, "kDeviceAddress");
              sub_100091AE8(buf, v102);
              v103 = xpc_dictionary_get_int64(a3, "kStoreClassicLinkKeyResult");
              *(_WORD *)&dst[4] = 0;
              *(_DWORD *)dst = 0;
              if (buf[23] >= 0)
                v104 = buf;
              else
                v104 = *(unsigned __int8 **)buf;
              if (sub_10006D80C((uint64_t)dst, v104))
              {
                if (qword_1009778E8 != -1)
                  dispatch_once(&qword_1009778E8, &stru_100940670);
                v105 = sub_1004704A8((uint64_t)off_1009778E0, (uint64_t)dst, 1);
                if (qword_100977A88 != -1)
                  dispatch_once(&qword_100977A88, &stru_100940710);
                sub_10028432C((uint64_t)off_100977A80, v105, v103);
              }
              else if (os_log_type_enabled((os_log_t)qword_100999870, OS_LOG_TYPE_ERROR))
              {
                sub_10071B8DC();
              }
              goto LABEL_136;
            }
            if (!strcmp(a2, "StoreClassicDeviceSettings"))
            {
              memset(buf, 0, 24);
              v106 = (char *)xpc_dictionary_get_string(a3, "kDeviceAddress");
              sub_100091AE8(buf, v106);
              WORD2(v316) = 0;
              LODWORD(v316) = 0;
              if (buf[23] >= 0)
                v107 = buf;
              else
                v107 = *(unsigned __int8 **)buf;
              if (!sub_10006D80C((uint64_t)&v316, v107))
              {
                if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_ERROR))
                  sub_10071B9A4();
                goto LABEL_136;
              }
              v108 = xpc_dictionary_get_int64(a3, "kClassicDeviceMicMode");
              v109 = xpc_dictionary_get_int64(a3, "kClassicDeviceInEarEnable");
              v110 = xpc_dictionary_get_int64(a3, "kClassicDeviceDoubleTapMode");
              v111 = xpc_dictionary_get_value(a3, "kClassicDeviceSettings");
              v256 = v111;
              if (v111)
              {
                v112 = sub_100070698(v111);
                v113 = (void *)objc_claimAutoreleasedReturnValue(v112);
                v114 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v113, "allKeys"));
                v115 = objc_msgSend(v114, "containsObject:", CFSTR("kCfgDoubleClickInt"));

                if (v115)
                {
                  v116 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v113, "objectForKey:", CFSTR("kCfgDoubleClickInt")));
                  v258 = objc_msgSend(v116, "intValue");

                }
                else
                {
                  v258 = -1;
                }
                v150 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v113, "allKeys"));
                v151 = objc_msgSend(v150, "containsObject:", CFSTR("kCfgClickHold"));

                if (v151)
                {
                  v152 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v113, "objectForKey:", CFSTR("kCfgClickHold")));
                  v260 = objc_msgSend(v152, "intValue");

                }
                else
                {
                  v260 = -1;
                }
                v153 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v113, "allKeys"));
                v154 = objc_msgSend(v153, "containsObject:", CFSTR("kCfgClickHoldInt"));

                if (v154)
                {
                  v155 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v113, "objectForKey:", CFSTR("kCfgClickHoldInt")));
                  v257 = objc_msgSend(v155, "intValue");

                }
                else
                {
                  v257 = -1;
                }
                v156 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v113, "allKeys"));
                v157 = objc_msgSend(v156, "containsObject:", CFSTR("kCfgListenModeCfgs"));

                if (v157)
                {
                  v158 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v113, "objectForKey:", CFSTR("kCfgListenModeCfgs")));
                  v259 = objc_msgSend(v158, "intValue");

                }
                else
                {
                  v259 = -1;
                }
                v159 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v113, "allKeys"));
                v160 = objc_msgSend(v159, "containsObject:", CFSTR("kCfgOneBudANCMode"));

                if (v160)
                {
                  v161 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v113, "objectForKey:", CFSTR("kCfgOneBudANCMode")));
                  v255 = objc_msgSend(v161, "intValue");

                }
                else
                {
                  v255 = -1;
                }
                v162 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v113, "allKeys"));
                v163 = objc_msgSend(v162, "containsObject:", CFSTR("kCfgListenMode"));

                if (v163)
                {
                  v164 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v113, "objectForKey:", CFSTR("kCfgListenMode")));
                  v147 = (uint64_t)objc_msgSend(v164, "intValue");

                }
                else
                {
                  v147 = 0xFFFFFFFFLL;
                }

              }
              else
              {
                v257 = -1;
                v258 = -1;
                v259 = -1;
                v260 = -1;
                v255 = -1;
                v147 = 0xFFFFFFFFLL;
              }
              memset(dst, 0, sizeof(dst));
              v318 = 0;
              v165 = (char *)xpc_dictionary_get_string(a3, "kDeviceName");
              sub_100091AE8(dst, v165);
              if (qword_1009778E8 != -1)
                dispatch_once(&qword_1009778E8, &stru_100940670);
              v166 = (unsigned __int8 *)sub_1004704A8((uint64_t)off_1009778E0, (uint64_t)&v316, 1);
              v167 = (uint64_t)v166;
              if (v166 && sub_10043E93C(v166))
              {
                if ((v109 != 0) != sub_10044F614(v167) && sub_100442118(v167, 1))
                {
                  if (qword_100977A88 != -1)
                    dispatch_once(&qword_100977A88, &stru_100940710);
                  sub_100285264((uint64_t)off_100977A80, v167, v109 != 0, 3u);
                }
                if (sub_10044F5D0(v167) != (_DWORD)v108)
                {
                  if (qword_100977A88 != -1)
                    dispatch_once(&qword_100977A88, &stru_100940710);
                  sub_100284E30((uint64_t)off_100977A80, v167, v108, 3u);
                }
                if (sub_1004459D0(v167) != v110 && sub_100442118(v167, 14))
                {
                  if (qword_100977A88 != -1)
                    dispatch_once(&qword_100977A88, &stru_100940710);
                  sub_100285094((uint64_t)off_100977A80, v167, BYTE1(v110), v110, 3);
                }
                sub_10043F6EC(v167, (uint64_t)v312);
                v168 = sub_1006BCE88(v312, dst);
                if (v313 < 0)
                  operator delete(*(void **)v312);
                if (v168)
                {
                  v169 = qword_100999810;
                  if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
                  {
                    sub_10043F6EC(v167, (uint64_t)v312);
                    if (v313 >= 0)
                      v170 = v312;
                    else
                      v170 = *(_BYTE **)v312;
                    v171 = dst;
                    if (v318 < 0)
                      v171 = *(unsigned __int8 **)dst;
                    *(_DWORD *)v310 = 136315394;
                    *(_QWORD *)&v310[4] = v170;
                    *(_WORD *)&v310[12] = 2080;
                    *(_QWORD *)&v310[14] = v171;
                    _os_log_impl((void *)&_mh_execute_header, v169, OS_LOG_TYPE_DEFAULT, "StoreClassicDeviceSettings update Device name on Watch side only, oldName = %s, newName = %s", v310, 0x16u);
                    if (v313 < 0)
                      operator delete(*(void **)v312);
                  }
                  sub_100440D9C(v167, (uint64_t)dst, 0);
                  sub_1004417EC(v167, (uint64_t *)dst);
                }
                if (v256)
                {
                  if (v260 != -1 && sub_10044F8A0(v167) != v260 && sub_100442118(v167, 30))
                  {
                    if (qword_100977A88 != -1)
                      dispatch_once(&qword_100977A88, &stru_100940710);
                    sub_100279E6C((uint64_t)off_100977A80, v167, 22, v260, 3u);
                  }
                  v172 = sub_100442118(v167, 43);
                  if (v258 == -1)
                    v173 = 1;
                  else
                    v173 = v172;
                  if ((v173 & 1) == 0
                    && sub_10044F8E4(v167) != v258
                    && ((sub_100442118(v167, 29) & 1) != 0 || sub_10044FE34(v167, 128)))
                  {
                    if (qword_100977A88 != -1)
                      dispatch_once(&qword_100977A88, &stru_100940710);
                    sub_100279E6C((uint64_t)off_100977A80, v167, 23, v258, 3u);
                  }
                  v174 = sub_100442118(v167, 43);
                  if (v257 == -1)
                    v175 = 1;
                  else
                    v175 = v174;
                  if ((v175 & 1) == 0
                    && sub_10044F928(v167) != v257
                    && ((sub_100442118(v167, 30) & 1) != 0 || sub_10044FE34(v167, 128)))
                  {
                    if (qword_100977A88 != -1)
                      dispatch_once(&qword_100977A88, &stru_100940710);
                    sub_100279E6C((uint64_t)off_100977A80, v167, 24, v257, 3u);
                  }
                  if (v259 != -1 && sub_10044F74C(v167) != v259 && sub_100442118(v167, 28))
                  {
                    if (qword_100977A88 != -1)
                      dispatch_once(&qword_100977A88, &stru_100940710);
                    sub_100279E6C((uint64_t)off_100977A80, v167, 26, v259, 3u);
                  }
                  v176 = sub_100442118(v167, 43);
                  if (v255 == -1)
                    v177 = 1;
                  else
                    v177 = v176;
                  if ((v177 & 1) == 0
                    && v255 != sub_10044F96C(v167)
                    && sub_100442118(v167, 16)
                    && sub_100442118(v167, 1))
                  {
                    if (qword_100977A88 != -1)
                      dispatch_once(&qword_100977A88, &stru_100940710);
                    sub_100279E6C((uint64_t)off_100977A80, v167, 27, v255, 3u);
                  }
                  if ((_DWORD)v147 != -1
                    && sub_10044F708(v167) != (_DWORD)v147
                    && sub_100442118(v167, 16)
                    && sub_100442118(v167, 17))
                  {
                    if (qword_100977A88 != -1)
                      dispatch_once(&qword_100977A88, &stru_100940710);
                    sub_100279E6C((uint64_t)off_100977A80, v167, 13, v147, 3u);
                  }
                }
              }
              else
              {
                v178 = qword_100999810;
                if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_ERROR))
                  sub_10071B908(&buf[23], buf, v178);
              }
              goto LABEL_103;
            }
            if (!strcmp(a2, "ClassicDeviceUnexpectedDisconnection"))
            {
              memset(buf, 0, 24);
              v118 = (char *)xpc_dictionary_get_string(a3, "kDeviceAddress");
              sub_100091AE8(buf, v118);
              *(_WORD *)&v310[4] = 0;
              *(_DWORD *)v310 = 0;
              if (buf[23] >= 0)
                v119 = buf;
              else
                v119 = *(unsigned __int8 **)buf;
              if (sub_10006D80C((uint64_t)v310, v119))
              {
                if (qword_1009778E8 != -1)
                  dispatch_once(&qword_1009778E8, &stru_100940670);
                v120 = (unsigned __int8 *)sub_1004704A8((uint64_t)off_1009778E0, (uint64_t)v310, 1);
                v121 = (uint64_t)v120;
                if (v120 && sub_10043E93C(v120))
                {
                  v122 = qword_100999870;
                  if (os_log_type_enabled((os_log_t)qword_100999870, OS_LOG_TYPE_DEFAULT))
                  {
                    sub_10043E5F8(v121, dst);
                    v123 = SHIBYTE(v318);
                    v124 = *(unsigned __int8 **)dst;
                    v125 = sub_10043FC5C(v121);
                    v126 = dst;
                    v127 = "not";
                    if (v123 < 0)
                      v126 = v124;
                    if (v125)
                      v127 = "is";
                    *(_DWORD *)v312 = 136446466;
                    *(_QWORD *)&v312[4] = v126;
                    *(_WORD *)&v312[12] = 2080;
                    *(_QWORD *)&v312[14] = v127;
                    _os_log_impl((void *)&_mh_execute_header, v122, OS_LOG_TYPE_DEFAULT, "ClassicDeviceUnexpectedDisconnection: device %{public}s %s connected", v312, 0x16u);
                    if (SHIBYTE(v318) < 0)
                      operator delete(*(void **)dst);
                  }
                  if (sub_10043FC5C(v121))
                  {
                    if (qword_100977A88 != -1)
                      dispatch_once(&qword_100977A88, &stru_100940710);
                    sub_100284DAC((uint64_t)off_100977A80, v121);
                  }
                }
                else if (os_log_type_enabled((os_log_t)qword_100999870, OS_LOG_TYPE_ERROR))
                {
                  sub_10071B9D0();
                }
              }
              else if (os_log_type_enabled((os_log_t)qword_100999870, OS_LOG_TYPE_ERROR))
              {
                sub_10071B9FC();
              }
              goto LABEL_136;
            }
            if (strcmp(a2, "ConnectClassicDevice"))
            {
              if (!strcmp(a2, "NotifyPrimaryBudSide"))
              {
                memset(buf, 0, 24);
                v141 = (char *)xpc_dictionary_get_string(a3, "kDeviceAddress");
                sub_100091AE8(buf, v141);
                v142 = xpc_dictionary_get_int64(a3, "kPrimaryBudSide");
                *(_WORD *)&dst[4] = 0;
                *(_DWORD *)dst = 0;
                if (buf[23] >= 0)
                  v143 = buf;
                else
                  v143 = *(unsigned __int8 **)buf;
                if (sub_10006D80C((uint64_t)dst, v143))
                {
                  if (qword_1009778E8 != -1)
                    dispatch_once(&qword_1009778E8, &stru_100940670);
                  v144 = sub_1004704A8((uint64_t)off_1009778E0, (uint64_t)dst, 1);
                  if (v144)
                  {
                    if (qword_100977A88 != -1)
                      dispatch_once(&qword_100977A88, &stru_100940710);
                    sub_1002856DC((uint64_t)off_100977A80, v144, v142);
                  }
                }
                else if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_ERROR))
                {
                  sub_10071BA54();
                }
                goto LABEL_136;
              }
              if (strcmp(a2, "LeaEasyPairRequest"))
              {
                if (!strcmp(a2, "LeaEasyPairResponse"))
                {
                  memset(buf, 0, 24);
                  v185 = (char *)xpc_dictionary_get_string(a3, "kLeaDeviceAddress");
                  sub_100091AE8(buf, v185);
                  v186 = xpc_dictionary_get_int64(a3, "kLeaDevicePairState");
                  v187 = qword_100999810;
                  if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)dst = 0;
                    _os_log_impl((void *)&_mh_execute_header, v187, OS_LOG_TYPE_DEFAULT, "Received LeaEasyPairResponse", dst, 2u);
                  }
                  *(_WORD *)&dst[4] = 0;
                  *(_DWORD *)dst = 0;
                  if (buf[23] >= 0)
                    v188 = buf;
                  else
                    v188 = *(unsigned __int8 **)buf;
                  if (sub_10006D80C((uint64_t)dst, v188))
                  {
                    if (qword_100977908 != -1)
                      dispatch_once(&qword_100977908, &stru_100940730);
                    v279 = *(_DWORD *)dst;
                    v280 = *(_WORD *)&dst[4];
                    sub_100535C48(qword_100977900, (unsigned __int8 *)&v279, v186);
                    goto LABEL_136;
                  }
                  v218 = qword_100999810;
                  if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)v312 = 0;
                    v219 = "Received invalid device address on LeaEasyPairResponse";
LABEL_585:
                    _os_log_impl((void *)&_mh_execute_header, v218, OS_LOG_TYPE_DEFAULT, v219, v312, 2u);
                  }
LABEL_136:
                  if ((buf[23] & 0x80000000) == 0)
                    return;
                  v72 = *(void **)buf;
                  goto LABEL_138;
                }
                if (strcmp(a2, "LeaStoreBondingInfoRequest"))
                {
                  if (strcmp(a2, "LeaStoreBondingInfoResponse"))
                  {
                    if (!strcmp(a2, "ANCSNotificationSourceRegistered"))
                    {
                      v229 = objc_msgSend(objc_alloc((Class)NSUUID), "initWithUUIDBytes:", xpc_dictionary_get_uuid(a3, "kPeerIdentifier"));
                      v230 = qword_100999810;
                      if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)buf = 138412290;
                        *(_QWORD *)&buf[4] = v229;
                        _os_log_impl((void *)&_mh_execute_header, v230, OS_LOG_TYPE_DEFAULT, "Device %@ has subscribed to ANCSNotificationSource", buf, 0xCu);
                      }
                      if (qword_10097B670 != -1)
                        dispatch_once(&qword_10097B670, &stru_100940810);
                      sub_1005AB458((uint64_t)off_10097B668, v229);

                    }
                    else if (!strcmp(a2, "UARPDataOverAACP"))
                    {
                      v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", xpc_dictionary_get_string(a3, "kUARPDeviceUUID"));
                      v8 = objc_msgSend(objc_alloc((Class)NSUUID), "initWithUUIDString:", v7);
                      if (qword_1009778C8 != -1)
                        dispatch_once(&qword_1009778C8, &stru_100940650);
                      v9 = sub_1000589DC((uint64_t)off_1009778C0, v8, 0);
                      if (qword_1009778E8 != -1)
                        dispatch_once(&qword_1009778E8, &stru_100940670);
                      v10 = sub_10006D488((uint64_t)off_1009778E0, v9, 1);
                      if (v10)
                      {
                        *(_QWORD *)buf = 0;
                        data = xpc_dictionary_get_data(a3, "kUARPData", (size_t *)buf);
                        if (data && *(_QWORD *)buf)
                        {
                          v12 = malloc_type_malloc(*(size_t *)buf, 0x6F805B68uLL);
                          v13 = v12;
                          if (v12)
                          {
                            memcpy(v12, data, *(size_t *)buf);
                            if (qword_100977A88 != -1)
                              dispatch_once(&qword_100977A88, &stru_100940710);
                            if (sub_10028725C((uint64_t)off_100977A80, v10, *(unsigned __int16 *)buf, v13))
                            {
                              if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_ERROR))
                                sub_10071BBB4();
                            }
                            free(v13);
                          }
                          else if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_ERROR))
                          {
                            sub_10071BB88();
                          }
                        }
                        else if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_ERROR))
                        {
                          sub_10071BB5C();
                        }
                      }
                      else if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_ERROR))
                      {
                        sub_10071BB30();
                      }

                    }
                    return;
                  }
                  memset(buf, 0, 24);
                  v225 = (char *)xpc_dictionary_get_string(a3, "kLeaDeviceAddress");
                  sub_100091AE8(buf, v225);
                  v226 = xpc_dictionary_get_int64(a3, "kLeaStoreBondingInfoResult");
                  *(_WORD *)&dst[4] = 0;
                  *(_DWORD *)dst = 0;
                  if (buf[23] >= 0)
                    v227 = buf;
                  else
                    v227 = *(unsigned __int8 **)buf;
                  if (sub_10006D80C((uint64_t)dst, v227))
                  {
                    if (qword_100977908 != -1)
                      dispatch_once(&qword_100977908, &stru_100940730);
                    v261 = *(_DWORD *)dst;
                    v262 = *(_WORD *)&dst[4];
                    sub_100535D78(qword_100977900, (unsigned __int8 *)&v261, v226);
                    goto LABEL_136;
                  }
                  v218 = qword_100999810;
                  if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)v312 = 0;
                    v219 = "Received invalid device address on LeaStoreBondingInfoResponse";
                    goto LABEL_585;
                  }
                  goto LABEL_136;
                }
                memset(buf, 0, 24);
                v210 = (char *)xpc_dictionary_get_string(a3, "kLeaDeviceAddress");
                sub_100091AE8(buf, v210);
                memset(dst, 0, sizeof(dst));
                v318 = 0;
                v211 = (char *)xpc_dictionary_get_string(a3, "kLeaDeviceName");
                sub_100091AE8(dst, v211);
                v212 = xpc_dictionary_get_int64(a3, "kLeaDeviceEdiv");
                v278 = 0;
                v277 = 0;
                if (buf[23] >= 0)
                  v213 = buf;
                else
                  v213 = *(unsigned __int8 **)buf;
                if (sub_10006D80C((uint64_t)&v277, v213))
                {
                  v307 = 0;
                  *(_QWORD *)&v310[8] = 0;
                  *(_QWORD *)v310 = 0;
                  v316 = 0uLL;
                  length = 0;
                  v214 = (uint64_t *)xpc_dictionary_get_data(a3, "kLeaDeviceRand", &length);
                  if (v214 && length == 8)
                  {
                    v307 = *v214;
                    v271 = 0;
                    v215 = xpc_dictionary_get_data(a3, "kLeaDeviceLtk", &v271);
                    if (v215 && v271 == 16)
                    {
                      *(_OWORD *)v310 = *v215;
                      v268 = 0;
                      v216 = (__int128 *)xpc_dictionary_get_data(a3, "kLeaDeviceIrk", &v268);
                      if (v216 && v268 == 16)
                      {
                        v316 = *v216;
                        if (v212)
                        {
                          v217 = ((unint64_t)v277 << 40) | ((unint64_t)BYTE1(v277) << 32) | ((unint64_t)BYTE2(v277) << 24) | ((unint64_t)HIBYTE(v277) << 16) | ((unint64_t)v278 << 8) | HIBYTE(v278);
                          v314 = 0;
                          v315 = 0;
                          if (qword_1009778C8 != -1)
                            dispatch_once(&qword_1009778C8, &stru_100940650);
                          sub_10003F924((uint64_t)off_1009778C0, v217, 0, 0, 0, 0, (unsigned __int8 *)&v314);
                          v265[0] = 0;
                          v265[1] = 0;
                          operator new();
                        }
                        v247 = qword_100999810;
                        if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
                        {
                          *(_WORD *)v312 = 0;
                          _os_log_impl((void *)&_mh_execute_header, v247, OS_LOG_TYPE_DEFAULT, "Received LeaStoreBondingInfoRequest to trigger unpairing", v312, 2u);
                        }
                        *(_QWORD *)&v312[8] = 0;
                        *(_QWORD *)v312 = 0;
                        if (qword_1009778C8 != -1)
                          dispatch_once(&qword_1009778C8, &stru_100940650);
                        sub_10003F924((uint64_t)off_1009778C0, ((unint64_t)v277 << 40) | ((unint64_t)BYTE1(v277) << 32) | ((unint64_t)BYTE2(v277) << 24) | ((unint64_t)HIBYTE(v277) << 16) | ((unint64_t)v278 << 8) | HIBYTE(v278), 0, 0, 0, 0, v312);
                        if (qword_1009778B8 != -1)
                          dispatch_once(&qword_1009778B8, &stru_1009407F0);
                        v248 = qword_1009778B0;
                        v249 = sub_100030DF4(v312);
                        v250 = (void *)objc_claimAutoreleasedReturnValue(v249);
                        LODWORD(v248) = sub_100030864(v248, v250);

                        if ((_DWORD)v248)
                        {
                          if (qword_100977908 != -1)
                            dispatch_once(&qword_100977908, &stru_100940730);
                          v263 = v277;
                          v264 = v278;
                          sub_100535FB8(qword_100977900, (unsigned __int8 *)&v263);
                          if (qword_1009778B8 != -1)
                            dispatch_once(&qword_1009778B8, &stru_1009407F0);
                          v251 = qword_1009778B0;
                          v252 = sub_100030DF4(v312);
                          v253 = (void *)objc_claimAutoreleasedReturnValue(v252);
                          sub_100699674(v251, v253);

                          goto LABEL_103;
                        }
                        v254 = qword_100999810;
                        if (!os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
                        {
LABEL_103:
                          if ((SHIBYTE(v318) & 0x80000000) == 0)
                            goto LABEL_136;
                          v58 = *(void **)dst;
LABEL_135:
                          operator delete(v58);
                          goto LABEL_136;
                        }
                        LOWORD(v314) = 0;
                        v54 = "Device is already unpaired";
                        v55 = (uint8_t *)&v314;
                        v56 = v254;
                        v57 = 2;
LABEL_102:
                        _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, v54, v55, v57);
                        goto LABEL_103;
                      }
                      if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_ERROR))
                        sub_10071BB04();
                      if ((buf[23] & 0x80000000) != 0)
                      {
                        sub_10003430C(&v266, *(void **)buf, *(unint64_t *)&buf[8]);
                      }
                      else
                      {
                        v266 = *(_OWORD *)buf;
                        v267 = *(_QWORD *)&buf[16];
                      }
                      sub_1006B88DC(a1, (const char *)&v266, 1u);
                      if ((SHIBYTE(v267) & 0x80000000) == 0)
                        goto LABEL_103;
                      v117 = (void *)v266;
                    }
                    else
                    {
                      if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_ERROR))
                        sub_10071BAD8();
                      if ((buf[23] & 0x80000000) != 0)
                      {
                        sub_10003430C(&v269, *(void **)buf, *(unint64_t *)&buf[8]);
                      }
                      else
                      {
                        v269 = *(_OWORD *)buf;
                        v270 = *(_QWORD *)&buf[16];
                      }
                      sub_1006B88DC(a1, (const char *)&v269, 1u);
                      if ((SHIBYTE(v270) & 0x80000000) == 0)
                        goto LABEL_103;
                      v117 = (void *)v269;
                    }
                  }
                  else
                  {
                    if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_ERROR))
                      sub_10071BAAC();
                    if ((buf[23] & 0x80000000) != 0)
                    {
                      sub_10003430C(&v272, *(void **)buf, *(unint64_t *)&buf[8]);
                    }
                    else
                    {
                      v272 = *(_OWORD *)buf;
                      v273 = *(_QWORD *)&buf[16];
                    }
                    sub_1006B88DC(a1, (const char *)&v272, 1u);
                    if ((SHIBYTE(v273) & 0x80000000) == 0)
                      goto LABEL_103;
                    v117 = (void *)v272;
                  }
                }
                else
                {
                  v228 = qword_100999810;
                  if (os_log_type_enabled((os_log_t)qword_100999810, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)v312 = 0;
                    _os_log_impl((void *)&_mh_execute_header, v228, OS_LOG_TYPE_DEFAULT, "Received invalid device address on LeaStoreBondingInfoRequest", v312, 2u);
                  }
                  if ((buf[23] & 0x80000000) != 0)
                  {
                    sub_10003430C(&v275, *(void **)buf, *(unint64_t *)&buf[8]);
                  }
                  else
                  {
                    v275 = *(_OWORD *)buf;
                    v276 = *(_QWORD *)&buf[16];
                  }
                  sub_1006B88DC(a1, (const char *)&v275, 1u);
                  if ((SHIBYTE(v276) & 0x80000000) == 0)
                    goto LABEL_103;
                  v117 = (void *)v275;
                }
LABEL_319:
                operator delete(v117);
                goto LABEL_103;
              }
              memset(buf, 0, 24);
              v179 = (char *)xpc_dictionary_get_string(a3, "kLeaDeviceAddress");
              sub_100091AE8(buf, v179);
              memset(dst, 0, sizeof(dst));
              v318 = 0;
              v180 = (char *)xpc_dictionary_get_string(a3, "kLeaDeviceIdentifier");
              sub_100091AE8(dst, v180);
              v181 = xpc_dictionary_get_value(a3, "kLeaDeviceTags");
              v182 = sub_1000438A4();
              if (sub_100333B30(v182) <= 1)
              {
                if ((buf[23] & 0x80000000) != 0)
                {
                  sub_10003430C(&v287, *(void **)buf, *(unint64_t *)&buf[8]);
                }
                else
                {
                  v287 = *(_OWORD *)buf;
                  v288 = *(_QWORD *)&buf[16];
                }
                sub_1006B87CC(a1, (const char *)&v287, 3u);
                if ((SHIBYTE(v288) & 0x80000000) == 0)
                  goto LABEL_103;
                v117 = (void *)v287;
                goto LABEL_319;
              }
              *(_WORD *)&v310[4] = 0;
              *(_DWORD *)v310 = 0;
              if (buf[23] >= 0)
                v189 = buf;
              else
                v189 = *(unsigned __int8 **)buf;
              if (!sub_10006D80C((uint64_t)v310, v189))
              {
                if (os_log_type_enabled((os_log_t)qword_100999870, OS_LOG_TYPE_ERROR))
                  sub_10071BA80();
                goto LABEL_103;
              }
              v190 = ((unint64_t)v310[0] << 40) | ((unint64_t)v310[1] << 32) | ((unint64_t)v310[2] << 24) | ((unint64_t)v310[3] << 16) | ((unint64_t)v310[4] << 8) | v310[5];
              *(_QWORD *)&v312[8] = 0;
              *(_QWORD *)v312 = 0;
              if (qword_1009778C8 != -1)
                dispatch_once(&qword_1009778C8, &stru_100940650);
              sub_10003F924((uint64_t)off_1009778C0, v190, 1u, 0, 0, 0, v312);
              if (qword_1009778B8 != -1)
                dispatch_once(&qword_1009778B8, &stru_1009407F0);
              v191 = qword_1009778B0;
              v192 = sub_100030DF4(v312);
              v193 = (void *)objc_claimAutoreleasedReturnValue(v192);
              v194 = sub_100030864(v191, v193);

              if (v181)
              {
                v195 = sub_1004B0F5C(v181);
                v181 = (xpc_object_t)objc_claimAutoreleasedReturnValue(v195);
              }
              v196 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v181, "objectEnumerator"));
              if (v196)
              {
                v197 = 0;
                while (1)
                {
                  v198 = objc_claimAutoreleasedReturnValue(objc_msgSend(v196, "nextObject"));

                  if (!v198)
                    break;
                  v199 = (void *)v198;
                  if (qword_1009778C8 != -1)
                    dispatch_once(&qword_1009778C8, &stru_100940650);
                  v200 = off_1009778C0;
                  v201 = sub_100030DF4(v312);
                  v202 = (void *)objc_claimAutoreleasedReturnValue(v201);
                  v197 = objc_retainAutorelease(v199);
                  sub_100091AE8(v285, (char *)objc_msgSend(v197, "UTF8String"));
                  sub_1006576F0((uint64_t)v200, v202, (unsigned __int8 *)v285);
                  if (v286 < 0)
                    operator delete(v285[0]);

                }
              }
              if (v194)
              {
                if ((buf[23] & 0x80000000) != 0)
                {
                  sub_10003430C(&v283, *(void **)buf, *(unint64_t *)&buf[8]);
                }
                else
                {
                  v283 = *(_OWORD *)buf;
                  v284 = *(_QWORD *)&buf[16];
                }
                sub_1006B87CC(a1, (const char *)&v283, 2u);
                if ((SHIBYTE(v284) & 0x80000000) == 0)
                  goto LABEL_623;
                v246 = (void **)&v283;
              }
              else
              {
                if ((buf[23] & 0x80000000) != 0)
                {
                  sub_10003430C(&v281, *(void **)buf, *(unint64_t *)&buf[8]);
                }
                else
                {
                  v281 = *(_OWORD *)buf;
                  v282 = *(_QWORD *)&buf[16];
                }
                sub_1006B87CC(a1, (const char *)&v281, 1u);
                if ((SHIBYTE(v282) & 0x80000000) == 0)
                  goto LABEL_623;
                v246 = (void **)&v281;
              }
              operator delete(*v246);
LABEL_623:

              goto LABEL_103;
            }
            memset(dst, 0, sizeof(dst));
            v318 = 0;
            v128 = (char *)xpc_dictionary_get_string(a3, "kDeviceAddress");
            sub_100091AE8(dst, v128);
            v129 = xpc_dictionary_get_int64(a3, "kQuickDisconnectEnabled");
            WORD2(v316) = 0;
            LODWORD(v316) = 0;
            if (v318 >= 0)
              v130 = dst;
            else
              v130 = *(unsigned __int8 **)dst;
            if (!sub_10006D80C((uint64_t)&v316, v130))
            {
              if ((_BYTE)v316)
              {
LABEL_334:
                if (os_log_type_enabled((os_log_t)qword_100999870, OS_LOG_TYPE_ERROR))
                  sub_10071BA54();
                goto LABEL_339;
              }
              v203 = 1;
              while (v203 != 6)
              {
                if (dst[v203++ - 16])
                {
                  if ((unint64_t)(v203 - 2) > 4)
                    break;
                  goto LABEL_334;
                }
              }
            }
            if (qword_1009778E8 != -1)
              dispatch_once(&qword_1009778E8, &stru_100940670);
            v131 = (unsigned __int8 *)sub_1004704A8((uint64_t)off_1009778E0, (uint64_t)&v316, 0);
            v132 = (uint64_t)v131;
            if (v131 && sub_10043E93C(v131))
            {
              v133 = qword_100999870;
              if (os_log_type_enabled((os_log_t)qword_100999870, OS_LOG_TYPE_DEFAULT))
              {
                sub_10043E5F8(v132, v312);
                v134 = v313;
                v135 = *(_BYTE **)v312;
                v136 = sub_10043FC5C(v132);
                v137 = v312;
                if (v134 < 0)
                  v137 = v135;
                *(_DWORD *)buf = 136446722;
                *(_QWORD *)&buf[4] = v137;
                if (v136)
                  v138 = "is";
                else
                  v138 = "not";
                *(_WORD *)&buf[12] = 2080;
                *(_QWORD *)&buf[14] = v138;
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&buf[24] = v129 != 0;
                _os_log_impl((void *)&_mh_execute_header, v133, OS_LOG_TYPE_DEFAULT, "ConnectClassicDevice: device %{public}s %s connected with QuickDisconnectEnabled %d", buf, 0x1Cu);
                if (v313 < 0)
                  operator delete(*(void **)v312);
              }
              if (sub_10043FC5C(v132))
              {
                if (v129)
                {
                  if (qword_100977A78 != -1)
                    dispatch_once(&qword_100977A78, &stru_1009406D0);
                  sub_1004989D8((uint64_t)off_100977A70, (unsigned __int8 *)&v316);
                }
                else
                {
                  v237 = sub_10003BE44();
                  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v237 + 352))(v237))
                  {
                    v238 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(a1 + 16), "firstObject"));
                    if (v238)
                    {
                      if (qword_1009778C8 != -1)
                        dispatch_once(&qword_1009778C8, &stru_100940650);
                      v239 = sub_1000589DC((uint64_t)off_1009778C0, v238, 0);
                      LOBYTE(v314) = BYTE5(v239);
                      BYTE1(v314) = BYTE4(v239);
                      BYTE2(v314) = BYTE3(v239);
                      BYTE3(v314) = BYTE2(v239);
                      BYTE4(v314) = BYTE1(v239);
                      BYTE5(v314) = v239;
                      v240 = qword_100999870;
                      if (os_log_type_enabled((os_log_t)qword_100999870, OS_LOG_TYPE_DEFAULT))
                      {
                        sub_10043E5F8(v132, v312);
                        v241 = v313;
                        v242 = *(_BYTE **)v312;
                        sub_10046E9BC((unsigned __int8 *)&v314, v310);
                        v243 = v312;
                        if (v241 < 0)
                          v243 = v242;
                        if (v311 >= 0)
                          v244 = v310;
                        else
                          v244 = *(_BYTE **)v310;
                        *(_DWORD *)buf = 136446723;
                        *(_QWORD *)&buf[4] = v243;
                        *(_WORD *)&buf[12] = 2160;
                        *(_QWORD *)&buf[14] = 1752392040;
                        *(_WORD *)&buf[22] = 2081;
                        *(_QWORD *)&buf[24] = v244;
                        _os_log_impl((void *)&_mh_execute_header, v240, OS_LOG_TYPE_DEFAULT, "ConnectClassicDevice: already in triangle, device %{public}s, peerSource %{private, mask.hash}s", buf, 0x20u);
                        if (v311 < 0)
                          operator delete(*(void **)v310);
                        if (v313 < 0)
                          operator delete(*(void **)v312);
                      }
                      if (qword_100977A88 != -1)
                        dispatch_once(&qword_100977A88, &stru_100940710);
                      sub_10027F83C((uint64_t)off_100977A80, v132, 0);
                    }
                    else if (os_log_type_enabled((os_log_t)qword_100999870, OS_LOG_TYPE_ERROR))
                    {
                      sub_10071BA28();
                    }

                  }
                  else
                  {
                    v245 = qword_100999870;
                    if (os_log_type_enabled((os_log_t)qword_100999870, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_WORD *)buf = 0;
                      _os_log_impl((void *)&_mh_execute_header, v245, OS_LOG_TYPE_DEFAULT, "Device already connected ignoring connect classic request", buf, 2u);
                    }
                  }
                }
              }
              else
              {
                if (qword_100977898 != -1)
                  dispatch_once(&qword_100977898, &stru_1009407D0);
                if ((sub_1000261E4() & 1) != 0)
                {
                  v220 = qword_100999870;
                  if (os_log_type_enabled((os_log_t)qword_100999870, OS_LOG_TYPE_DEFAULT))
                  {
                    sub_10043E5F8(v132, buf);
                    v221 = buf[23] >= 0 ? buf : *(_BYTE **)buf;
                    *(_DWORD *)v312 = 136446466;
                    *(_QWORD *)&v312[4] = v221;
                    *(_WORD *)&v312[12] = 2080;
                    *(_QWORD *)&v312[14] = "enabled";
                    _os_log_impl((void *)&_mh_execute_header, v220, OS_LOG_TYPE_DEFAULT, "Ignoring ConnectClassicDevice msg for %{public}s, Denylist is %s", v312, 0x16u);
                    if ((buf[23] & 0x80000000) != 0)
                      operator delete(*(void **)buf);
                  }
                }
                else
                {
                  if (qword_100977A78 != -1)
                    dispatch_once(&qword_100977A78, &stru_1009406D0);
                  memset(buf, 0, 24);
                  sub_100495A98((int64x2_t *)off_100977A70, v132, -1, (const std::string *)buf, 2);
                  if ((buf[23] & 0x80000000) != 0)
                    operator delete(*(void **)buf);
                  v308 = CFSTR("wxAddress");
                  v231 = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", sub_1004110AC((unsigned __int8 *)(v132 + 128)));
                  v232 = (void *)objc_claimAutoreleasedReturnValue(v231);
                  v309 = v232;
                  v233 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v309, &v308, 1));

                  v234 = qword_100999870;
                  if (os_log_type_enabled((os_log_t)qword_100999870, OS_LOG_TYPE_DEFAULT))
                  {
                    sub_10043E5F8(v132, buf);
                    v235 = buf[23] >= 0 ? buf : *(_BYTE **)buf;
                    *(_DWORD *)v312 = 136446210;
                    *(_QWORD *)&v312[4] = v235;
                    _os_log_impl((void *)&_mh_execute_header, v234, OS_LOG_TYPE_DEFAULT, "ConnectClassicDevice: Sending notification to AAD for device %{public}s,", v312, 0xCu);
                    if ((buf[23] & 0x80000000) != 0)
                      operator delete(*(void **)buf);
                  }
                  v236 = (void *)objc_claimAutoreleasedReturnValue(+[NSDistributedNotificationCenter defaultCenter](NSDistributedNotificationCenter, "defaultCenter"));
                  objc_msgSend(v236, "postNotificationName:object:userInfo:", CFSTR("com.apple.BTServer.TriangleRecoveryInitiated"), 0, v233);

                }
              }
            }
            else if (os_log_type_enabled((os_log_t)qword_100999870, OS_LOG_TYPE_ERROR))
            {
              sub_10071B9D0();
            }
LABEL_339:
            if ((SHIBYTE(v318) & 0x80000000) == 0)
              return;
            v72 = *(void **)dst;
LABEL_138:
            operator delete(v72);
            return;
          }
          memset(buf, 0, 24);
          v86 = (char *)xpc_dictionary_get_string(a3, "kDeviceAddress");
          sub_100091AE8(buf, v86);
          memset(dst, 0, sizeof(dst));
          v318 = 0;
          v87 = (char *)xpc_dictionary_get_string(a3, "kDeviceName");
          sub_100091AE8(dst, v87);
          v88 = xpc_dictionary_get_value(a3, "kDeviceLinkKey");
          v89 = xpc_dictionary_get_int64(a3, "kDeviceServiceMask");
          v90 = xpc_dictionary_get_int64(a3, "kClassOfDeviceMask");
          WORD2(v307) = 0;
          LODWORD(v307) = 0;
          if (buf[23] >= 0)
            v91 = buf;
          else
            v91 = *(unsigned __int8 **)buf;
          if (!sub_10006D80C((uint64_t)&v307, v91))
          {
            if (os_log_type_enabled((os_log_t)qword_100999870, OS_LOG_TYPE_ERROR))
              sub_10071B8B0();
            if ((buf[23] & 0x80000000) != 0)
            {
              sub_10003430C(&v293, *(void **)buf, *(unint64_t *)&buf[8]);
            }
            else
            {
              v293 = *(_OWORD *)buf;
              v294 = *(_QWORD *)&buf[16];
            }
            sub_1006B8744(a1, (const char *)&v293, 1u);
            if ((SHIBYTE(v294) & 0x80000000) == 0)
              goto LABEL_103;
            v117 = (void *)v293;
            goto LABEL_319;
          }
          v92 = xpc_array_get_count(v88);
          if (!v88 || v92 != 16)
          {
            if (os_log_type_enabled((os_log_t)qword_100999870, OS_LOG_TYPE_ERROR))
              sub_10071B800();
            if ((buf[23] & 0x80000000) != 0)
            {
              sub_10003430C(v291, *(void **)buf, *(unint64_t *)&buf[8]);
            }
            else
            {
              *(_OWORD *)v291 = *(_OWORD *)buf;
              v292 = *(_QWORD *)&buf[16];
            }
            sub_1006B8744(a1, (const char *)v291, 1u);
            if ((SHIBYTE(v292) & 0x80000000) == 0)
              goto LABEL_103;
            v117 = v291[0];
            goto LABEL_319;
          }
          v93 = 0;
          v316 = 0uLL;
          v314 = 0;
          v315 = 0;
          do
          {
            dst[v93 - 16] = xpc_array_get_int64(v88, v93);
            ++v93;
          }
          while (v93 != 16);
          if (qword_1009778E8 != -1)
            dispatch_once(&qword_1009778E8, &stru_100940670);
          v94 = (unsigned __int8 *)sub_1004704A8((uint64_t)off_1009778E0, (uint64_t)&v307, 1);
          v80 = v94;
          if ((_QWORD)v316 != v314 || *((_QWORD *)&v316 + 1) != v315)
          {
            if ((_DWORD)v90)
            {
              if (qword_1009778E8 != -1)
                dispatch_once(&qword_1009778E8, &stru_100940670);
              sub_100470B08((uint64_t)off_1009778E0, (uint64_t)v80, v90);
            }
            if (v89)
            {
              v96 = 0;
              do
              {
                v97 = 1 << v96;
                if (((1 << v96) & v89) != 0)
                {
                  *(_QWORD *)v310 = 0;
                  *(_QWORD *)&v312[8] = 0;
                  *(_QWORD *)v312 = 0;
                  sub_10004AD30((uint64_t)v310);
                  *(_QWORD *)v312 = *(int *)v310;
                  *(_QWORD *)&v312[8] = *(__int16 *)&v310[4];
                  sub_1004415B0((uint64_t)v80, v97 & v89, 4, v312, 0);
                }
                if (v96 > 0x1E)
                  break;
                v89 &= ~v97;
                ++v96;
              }
              while (v89);
            }
            memset(v310, 0, 20);
            sub_1005A9714((uint64_t)v310);
            if (qword_100978160 != -1)
              dispatch_once(&qword_100978160, &stru_100940770);
            if (sub_1005BEB64((uint64_t)off_100978158, v80, (__n128 *)v310) != 150)
              goto LABEL_200;
            if (qword_100977A68 != -1)
              dispatch_once(&qword_100977A68, &stru_100940790);
            if ((sub_10045E940((uint64_t)off_100977A60, (uint64_t)v80) & 1) == 0)
            {
              sub_1005A9734((uint64_t)v312, &v316, 5u);
              sub_1005A9720((__n128 *)v310, (__n128 *)v312);
              nullsub_90(v312, v183);
              if (qword_100978160 != -1)
                dispatch_once(&qword_100978160, &stru_100940770);
              v184 = sub_1005BEC60((uint64_t)off_100978158, v80, (__n128 *)v310, 0);
              if (v184)
              {
                v99 = 1;
              }
              else
              {
                v265[0] = 0;
                *(_QWORD *)&v312[8] = 0;
                *(_QWORD *)v312 = 0;
                sub_10004AD30((uint64_t)v265);
                *(_QWORD *)v312 = SLODWORD(v265[0]);
                *(_QWORD *)&v312[8] = SWORD2(v265[0]);
                sub_10044054C((uint64_t)v80, (uint64_t)dst, v312);
                v99 = 0;
              }
              v222 = qword_100999870;
              if (os_log_type_enabled((os_log_t)qword_100999870, OS_LOG_TYPE_DEFAULT))
              {
                v223 = "Failed to store";
                if (!v184)
                  v223 = "Successfully stored";
                v224 = buf;
                if (buf[23] < 0)
                  v224 = *(_BYTE **)buf;
                *(_DWORD *)v312 = 136315394;
                *(_QWORD *)&v312[4] = v223;
                *(_WORD *)&v312[12] = 2080;
                *(_QWORD *)&v312[14] = v224;
                _os_log_impl((void *)&_mh_execute_header, v222, OS_LOG_TYPE_DEFAULT, "%s classic link key for address %s", v312, 0x16u);
              }
            }
            else
            {
LABEL_200:
              v98 = qword_100999870;
              v99 = 0;
              if (os_log_type_enabled((os_log_t)qword_100999870, OS_LOG_TYPE_DEFAULT))
              {
                if (qword_100977A68 != -1)
                  dispatch_once(&qword_100977A68, &stru_100940790);
                v100 = sub_10045E940((uint64_t)off_100977A60, (uint64_t)v80);
                v101 = buf;
                if (buf[23] < 0)
                  v101 = *(_BYTE **)buf;
                *(_DWORD *)v312 = 67109378;
                *(_DWORD *)&v312[4] = v100;
                *(_WORD *)&v312[8] = 2080;
                *(_QWORD *)&v312[10] = v101;
                _os_log_impl((void *)&_mh_execute_header, v98, OS_LOG_TYPE_DEFAULT, "Already stored classic link key (Magic Paired: %d) for address: %s", v312, 0x12u);
                v99 = 0;
              }
            }
            if ((buf[23] & 0x80000000) != 0)
            {
              sub_10003430C(v289, *(void **)buf, *(unint64_t *)&buf[8]);
            }
            else
            {
              *(_OWORD *)v289 = *(_OWORD *)buf;
              v290 = *(_QWORD *)&buf[16];
            }
            sub_1006B8744(a1, (const char *)v289, v99);
            if ((SHIBYTE(v290) & 0x80000000) == 0)
              goto LABEL_550;
            v209 = v289[0];
LABEL_549:
            operator delete(v209);
LABEL_550:
            nullsub_90(v310, v208);
            goto LABEL_103;
          }
          if (v94 && sub_10043E93C(v94))
          {
            if (qword_100977A88 != -1)
              dispatch_once(&qword_100977A88, &stru_100940710);
            *((_BYTE *)off_100977A80 + 431) = 2;
            if (qword_100977A68 != -1)
              dispatch_once(&qword_100977A68, &stru_100940790);
            v145 = sub_10045E940((uint64_t)off_100977A60, (uint64_t)v80);
            v146 = os_log_type_enabled((os_log_t)qword_100999870, OS_LOG_TYPE_ERROR);
            if (v145)
            {
              if (v146)
                sub_10071B858();
              if (qword_100977A68 == -1)
                goto LABEL_301;
              goto LABEL_661;
            }
            if (v146)
              sub_10071B884();
            if (qword_100978150 == -1)
              goto LABEL_490;
            goto LABEL_662;
          }
          if (!os_log_type_enabled((os_log_t)qword_100999870, OS_LOG_TYPE_ERROR))
            goto LABEL_103;
        }
        sub_10071B82C();
        goto LABEL_103;
      }
      v50 = objc_msgSend(objc_alloc((Class)NSUUID), "initWithUUIDBytes:", xpc_dictionary_get_uuid(a3, "kPeerIdentifier"));
      if (qword_100977B40 != -1)
        dispatch_once(&qword_100977B40, &stru_1009406F0);
      sub_1004B9F74((uint64_t)off_100977B38, 0);
      objc_msgSend(*(id *)(a1 + 16), "removeObject:", v50);
      if (qword_100977A88 != -1)
        dispatch_once(&qword_100977A88, &stru_100940710);
      sub_100283F6C((uint64_t)off_100977A80, v50);
      if (qword_100977908 != -1)
        dispatch_once(&qword_100977908, &stru_100940730);
      sub_100535A6C(qword_100977900, v50);

    }
  }
}

void sub_1006BC87C(_Unwind_Exception *a1)
{
  void *v1;
  uint64_t v2;

  if (*(char *)(v2 - 185) < 0)
    operator delete(*(void **)(v2 - 208));
  if (*(char *)(v2 - 153) < 0)
    operator delete(*(void **)(v2 - 176));
  _Unwind_Resume(a1);
}

BOOL sub_1006BCE88(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  BOOL v10;

  v2 = a1[23];
  if ((v2 & 0x80u) == 0)
    v3 = a1[23];
  else
    v3 = *((_QWORD *)a1 + 1);
  v4 = a2[23];
  v5 = (char)v4;
  if ((v4 & 0x80u) != 0)
    v4 = *((_QWORD *)a2 + 1);
  if (v3 != v4)
    return 1;
  if (v5 < 0)
    a2 = *(unsigned __int8 **)a2;
  if ((v2 & 0x80) != 0)
    return memcmp(*(const void **)a1, a2, *((_QWORD *)a1 + 1)) != 0;
  if (a1[23])
  {
    v6 = v2 - 1;
    do
    {
      v8 = *a1++;
      v7 = v8;
      v9 = *a2++;
      v10 = v7 == v9;
      v2 = v7 != v9;
      v10 = !v10 || v6-- == 0;
    }
    while (!v10);
  }
  return v2;
}

void sub_1006BCF1C(uint64_t a1)
{
  id v2;
  id v3;
  void *v4;
  id v5;
  void *v6;
  id v7;

  if (qword_100978130 != -1)
    dispatch_once(&qword_100978130, &stru_100940830);
  if (sub_10002527C((uint64_t)off_100978128) == 1)
  {
    if (qword_1009778C8 != -1)
      dispatch_once(&qword_1009778C8, &stru_100940650);
    v2 = sub_10065D314((uint64_t)off_1009778C0);
    v7 = (id)objc_claimAutoreleasedReturnValue(v2);
    if (objc_msgSend(v7, "count"))
      sub_1006B6D14(a1, v7);
    if (qword_10097AC28 != -1)
      dispatch_once(&qword_10097AC28, &stru_100940630);
    if (sub_10048472C(qword_10097AC20))
      sub_1006B86E4(a1, 1);
    v3 = sub_1006BD0B4();
    v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
    if (v4)
      (*(void (**)(uint64_t, void *))(*(_QWORD *)a1 + 48))(a1, v4);
    v5 = sub_1006BD404();
    v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
    if (v6)
      (*(void (**)(uint64_t, void *))(*(_QWORD *)a1 + 56))(a1, v6);

  }
}

void sub_1006BD080(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

id sub_1006BD0B4()
{
  char *v0;
  uint64_t v1;
  char *v2;
  __n128 v3;
  char *v4;
  char *v5;
  char *v6;
  __int128 v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  id v11;
  void *v12;
  void *v13;
  id v14;
  void *__p;
  char *v17;
  char *v18;
  void *v19;
  uint64_t *v20;
  uint64_t v21;
  __int128 v22;
  int v23;
  __n128 v24;
  int v25;

  v19 = 0;
  v20 = 0;
  v21 = 0;
  if (qword_100978190 != -1)
    dispatch_once(&qword_100978190, &stru_1009406B0);
  sub_10006A8A0((uint64_t)off_100978188, &v19);
  __p = 0;
  v17 = 0;
  v18 = 0;
  v22 = xmmword_10073B5A8;
  v23 = 1729713604;
  sub_100042F44(&v24, (__n128 *)&v22);
  v0 = (char *)sub_1000B58EC((uint64_t)&v18, 1uLL);
  v2 = &v0[20 * v1];
  v3 = v24;
  *((_DWORD *)v0 + 4) = v25;
  *(__n128 *)v0 = v3;
  v4 = v0 + 20;
  v6 = (char *)__p;
  v5 = v17;
  if (v17 != __p)
  {
    do
    {
      v7 = *(_OWORD *)(v5 - 20);
      *((_DWORD *)v0 - 1) = *((_DWORD *)v5 - 1);
      *(_OWORD *)(v0 - 20) = v7;
      v0 -= 20;
      v5 -= 20;
    }
    while (v5 != v6);
    v5 = (char *)__p;
  }
  __p = v0;
  v17 = v4;
  v18 = v2;
  if (v5)
    operator delete(v5);
  v17 = v4;
  v8 = (uint64_t *)v19;
  if (v19 == v20)
  {
LABEL_16:
    v13 = 0;
  }
  else
  {
    while (1)
    {
      v9 = *v8;
      if (sub_100442118(*v8, 22))
      {
        v24 = 0uLL;
        if (qword_1009778C8 != -1)
          dispatch_once(&qword_1009778C8, &stru_100940650);
        sub_10065A6B4((uint64_t)off_1009778C0, (unsigned __int8 *)(v9 + 128), (unsigned __int8 *)&v24);
        if (qword_1009778F8 != -1)
          dispatch_once(&qword_1009778F8, &stru_100940850);
        v10 = qword_1009778F0;
        v11 = sub_100030DF4((const unsigned __int8 *)&v24);
        v12 = (void *)objc_claimAutoreleasedReturnValue(v11);
        LODWORD(v10) = sub_1005E0AD8(v10, v12, (__int128 **)&__p, 1, 0, 0);

        if ((_DWORD)v10)
          break;
      }
      if (++v8 == v20)
        goto LABEL_16;
    }
    v14 = sub_100030DF4((const unsigned __int8 *)&v24);
    v13 = (void *)objc_claimAutoreleasedReturnValue(v14);
  }
  if (__p)
  {
    v17 = (char *)__p;
    operator delete(__p);
  }
  if (v19)
  {
    v20 = (uint64_t *)v19;
    operator delete(v19);
  }
  return v13;
}

void sub_1006BD3B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  if (__p)
    operator delete(__p);
  if (a12)
    operator delete(a12);
  _Unwind_Resume(exception_object);
}

id sub_1006BD404()
{
  void *v0;
  uint64_t *v1;
  uint64_t *v2;
  __n128 *v3;
  uint64_t v4;
  id v5;
  void *v6;
  int v7;
  id v8;
  void *__p;
  unsigned __int8 *v11;
  __int8 *v12;
  void *v13;
  uint64_t *v14;
  uint64_t v15;
  __int128 v16;
  int v17;
  __n128 v18;
  unsigned __int32 v19;
  _QWORD v20[2];

  v13 = 0;
  v14 = 0;
  v15 = 0;
  if (qword_100978190 != -1)
    dispatch_once(&qword_100978190, &stru_1009406B0);
  sub_10006A8A0((uint64_t)off_100978188, &v13);
  v1 = (uint64_t *)v13;
  v2 = v14;
  if (v13 == v14)
  {
    v0 = 0;
    if (!v13)
      return v0;
    goto LABEL_17;
  }
  while (1)
  {
    if (sub_100442118(*v1, 23))
    {
      v20[0] = 0;
      v20[1] = 0;
      if (qword_1009778C8 != -1)
        dispatch_once(&qword_1009778C8, &stru_100940650);
      sub_10065A6B4((uint64_t)off_1009778C0, (unsigned __int8 *)(*v1 + 128), (unsigned __int8 *)v20);
      __p = 0;
      v11 = 0;
      v12 = 0;
      v16 = xmmword_10073B5BC;
      v17 = 2027922698;
      sub_100042F44(&v18, (__n128 *)&v16);
      v3 = (__n128 *)operator new(0x14uLL);
      v11 = &v3[1].n128_u8[4];
      v12 = &v3[1].n128_i8[4];
      *v3 = v18;
      v3[1].n128_u32[0] = v19;
      __p = v3;
      if (qword_1009778F8 != -1)
        dispatch_once(&qword_1009778F8, &stru_100940850);
      v4 = qword_1009778F0;
      v5 = sub_100030DF4((const unsigned __int8 *)v20);
      v6 = (void *)objc_claimAutoreleasedReturnValue(v5);
      v7 = sub_1005E0AD8(v4, v6, (__int128 **)&__p, 1, 0, 1);

      if (v7)
      {
        v8 = sub_100030DF4((const unsigned __int8 *)v20);
        v0 = (void *)objc_claimAutoreleasedReturnValue(v8);
      }
      if (__p)
      {
        v11 = (unsigned __int8 *)__p;
        operator delete(__p);
      }
      if ((v7 & 1) != 0)
        break;
    }
    if (++v1 == v2)
    {
      v0 = 0;
      break;
    }
  }
  v1 = (uint64_t *)v13;
  if (v13)
  {
LABEL_17:
    v14 = v1;
    operator delete(v1);
  }
  return v0;
}

void sub_1006BD624(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1006BD684(uint64_t a1)
{
  sub_1006B868C(a1 - 8);
}

void sub_1006BD68C(uint64_t a1)
{
  sub_1006B868C(a1 - 8);
}

void sub_1006BD698(id a1)
{
  operator new();
}

void sub_1006BD6D8()
{
  operator delete();
}

void sub_1006BD6FC(id a1)
{
  operator new();
}

void sub_1006BD73C()
{
  operator delete();
}

void sub_1006BD760(id a1)
{
  operator new();
}

void sub_1006BD7A0()
{
  operator delete();
}

void sub_1006BD7C4(id a1)
{
  operator new();
}

void sub_1006BD804()
{
  operator delete();
}

void sub_1006BD828(id a1)
{
  operator new();
}

void sub_1006BD868()
{
  operator delete();
}

void sub_1006BD88C(id a1)
{
  operator new();
}

void sub_1006BD8CC()
{
  operator delete();
}

void sub_1006BD8F0(id a1)
{
  operator new();
}

void sub_1006BDA08()
{
  operator delete();
}

void sub_1006BDA2C(id a1)
{
  operator new();
}

void sub_1006BDA6C()
{
  operator delete();
}

void sub_1006BDA90(id a1)
{
  operator new();
}

void sub_1006BDAD0()
{
  operator delete();
}

void sub_1006BDAF4(id a1)
{
  operator new();
}

void sub_1006BDB34()
{
  operator delete();
}

void sub_1006BDB58(id a1)
{
  operator new();
}

void sub_1006BDB98()
{
  operator delete();
}

void sub_1006BDBBC(id a1)
{
  operator new();
}

void sub_1006BDBFC()
{
  operator delete();
}

void sub_1006BDC20(id a1)
{
  operator new();
}

void sub_1006BDC60()
{
  operator delete();
}

void sub_1006BDC84(id a1)
{
  operator new();
}

void sub_1006BDCC4()
{
  operator delete();
}

void sub_1006BDCE8(id a1)
{
  operator new();
}

void sub_1006BDD28()
{
  operator delete();
}

void sub_1006BDD4C(id a1)
{
  operator new();
}

void sub_1006BDD8C()
{
  operator delete();
}

void sub_1006BDDB0(id a1)
{
  operator new();
}

void sub_1006BDDF0()
{
  operator delete();
}

void sub_1006BDE14(id a1)
{
  operator new();
}

void sub_1006BDE54()
{
  operator delete();
}

uint64_t sub_1006BDE78(uint64_t a1)
{
  *(_QWORD *)a1 = &off_100940880;
  *(_WORD *)(a1 + 8) = 8;
  sub_1000160D0(a1 + 16);
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 80) = a1 + 88;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  *(_QWORD *)(a1 + 104) = a1 + 112;
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 128) = a1 + 136;
  *(_QWORD *)(a1 + 144) = 0;
  *(_WORD *)(a1 + 152) = 1;
  *(_BYTE *)(a1 + 154) = 1;
  *(_DWORD *)(a1 + 156) = 0;
  *(_WORD *)(a1 + 160) = 0;
  sub_1006BDF68(a1);
  sub_1006BE710();
  sub_1006BF5CC();
  return a1;
}

void sub_1006BDF30(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD **v5;
  _QWORD **v6;
  _QWORD **v7;

  sub_1006C1CB8(v4, *v7);
  sub_100010D8C(v3, *v6);
  sub_10001A82C(v2, *v5);
  sub_100069BDC(v1);
  _Unwind_Resume(a1);
}

void sub_1006BDF68(uint64_t a1)
{
  NSObject *v1;
  uint64_t i;
  uint64_t v3;
  int v4;
  NSObject *v5;
  __int16 v6;
  uint64_t v7;
  int v8;
  int v9;
  NSObject *v10;
  uint64_t v11;
  int v12;
  int v13;
  NSObject *v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  NSObject *v19;
  uint64_t v20;
  int v21;
  int v22;
  int v23;
  NSObject *v24;
  uint64_t v25;
  int v26;
  int v27;
  int v28;
  NSObject *v29;
  uint64_t v30;
  int v31;
  int v32;
  NSObject *v33;
  const char *v34;
  void *__p[2];
  char v37;
  int v38;
  _BYTE buf[12];
  __int16 v40;
  int v41;
  char v42;
  char __s[8];
  uint64_t v44;
  int v45;

  v1 = qword_100999908;
  if (os_log_type_enabled((os_log_t)qword_100999908, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "BTResourceManager LE initialized.", buf, 2u);
  }
  for (i = 0; i != 9; ++i)
  {
    *(_QWORD *)__s = 0;
    v44 = 0;
    v45 = 0;
    sprintf(__s, "%d", dword_10097BA08[i]);
    v38 = 0;
    v3 = sub_100027F68();
    sub_100091AE8(buf, "BTResourceManager");
    sub_100091AE8(__p, __s);
    v4 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, int *))(*(_QWORD *)v3 + 88))(v3, buf, __p, &v38);
    if (v37 < 0)
      operator delete(__p[0]);
    if (v42 < 0)
    {
      operator delete(*(void **)buf);
      if (!v4)
        goto LABEL_12;
    }
    else if (!v4)
    {
      goto LABEL_12;
    }
    v5 = qword_100999908;
    if (os_log_type_enabled((os_log_t)qword_100999908, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = __s;
      v40 = 1024;
      v41 = v38;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Warning: Overriding BTResourceManager max connections for %{public}s usecase to %d", buf, 0x12u);
    }
LABEL_12:
    v6 = v38;
    *(_QWORD *)buf = &dword_10097BA08[i];
    *((_WORD *)sub_100646320((uint64_t **)(a1 + 80), (unsigned int *)&dword_10097BA08[i], (uint64_t)&unk_100740F58, (_DWORD **)buf)+ 16) = v6;
  }
  LOBYTE(v38) = 0;
  v7 = sub_100027F68();
  sub_100091AE8(buf, "LE");
  sub_100091AE8(__p, "DoNotEnforceAllowedList");
  v8 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, int *))(*(_QWORD *)v7 + 72))(v7, buf, __p, &v38);
  if ((_BYTE)v38)
    v9 = v8;
  else
    v9 = 0;
  if (v37 < 0)
    operator delete(__p[0]);
  if (v42 < 0)
  {
    operator delete(*(void **)buf);
    if (!v9)
      goto LABEL_24;
  }
  else if (!v9)
  {
    goto LABEL_24;
  }
  *(_BYTE *)(a1 + 152) = 0;
  v10 = qword_100999908;
  if (os_log_type_enabled((os_log_t)qword_100999908, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Warning: Overriding - Do Not Enforce Allowed List.", buf, 2u);
  }
LABEL_24:
  v11 = sub_100027F68();
  sub_100091AE8(buf, "LE");
  sub_100091AE8(__p, "DebugAllowedList");
  v12 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, int *))(*(_QWORD *)v11 + 72))(v11, buf, __p, &v38);
  if ((_BYTE)v38)
    v13 = v12;
  else
    v13 = 0;
  if (v37 < 0)
    operator delete(__p[0]);
  if (v42 < 0)
  {
    operator delete(*(void **)buf);
    if (!v13)
      goto LABEL_35;
  }
  else if (!v13)
  {
    goto LABEL_35;
  }
  *(_BYTE *)(a1 + 153) = 1;
  v14 = qword_100999908;
  if (os_log_type_enabled((os_log_t)qword_100999908, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Warning: Overriding - Enable Debugging Allowed List.", buf, 2u);
  }
LABEL_35:
  *(_DWORD *)__s = 0;
  v15 = sub_100027F68();
  sub_100091AE8(buf, "LE");
  sub_100091AE8(__p, "MaxConnPerBundleIDFromEndConnectingClient");
  v16 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, char *))(*(_QWORD *)v15 + 88))(v15, buf, __p, __s);
  if (*(_DWORD *)__s)
    v17 = v16;
  else
    v17 = 0;
  if (v37 < 0)
    operator delete(__p[0]);
  if (v42 < 0)
  {
    operator delete(*(void **)buf);
    if (!v17)
      goto LABEL_46;
  }
  else if (!v17)
  {
    goto LABEL_46;
  }
  v18 = *(_DWORD *)__s;
  *(_WORD *)(a1 + 160) = *(_WORD *)__s;
  v19 = qword_100999908;
  if (os_log_type_enabled((os_log_t)qword_100999908, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v18;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Warning: Overriding - MaxConnPerBundleIDFromEndConnectingClient %d", buf, 8u);
  }
LABEL_46:
  *(_DWORD *)__s = 0;
  *(_WORD *)(a1 + 156) = 94;
  v20 = sub_100027F68();
  sub_100091AE8(buf, "LE");
  sub_100091AE8(__p, "MaxConnPerBundleIDFromFindMyClient");
  v21 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, char *))(*(_QWORD *)v20 + 88))(v20, buf, __p, __s);
  if (*(_DWORD *)__s)
    v22 = v21;
  else
    v22 = 0;
  if (v37 < 0)
    operator delete(__p[0]);
  if (v42 < 0)
  {
    operator delete(*(void **)buf);
    if (!v22)
      goto LABEL_57;
  }
  else if (!v22)
  {
    goto LABEL_57;
  }
  v23 = *(_DWORD *)__s;
  *(_WORD *)(a1 + 156) = *(_WORD *)__s;
  v24 = qword_100999908;
  if (os_log_type_enabled((os_log_t)qword_100999908, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v23;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Warning: Overriding - MaxConnPerBundleIDFromFindMyClient %d", buf, 8u);
  }
LABEL_57:
  *(_WORD *)(a1 + 158) = 32;
  v25 = sub_100027F68();
  sub_100091AE8(buf, "LE");
  sub_100091AE8(__p, "MaxConnPerBundleID");
  v26 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, char *))(*(_QWORD *)v25 + 88))(v25, buf, __p, __s);
  if (*(_DWORD *)__s)
    v27 = v26;
  else
    v27 = 0;
  if (v37 < 0)
    operator delete(__p[0]);
  if (v42 < 0)
  {
    operator delete(*(void **)buf);
    if (!v27)
      goto LABEL_68;
  }
  else if (!v27)
  {
    goto LABEL_68;
  }
  v28 = *(_DWORD *)__s;
  *(_WORD *)(a1 + 158) = *(_WORD *)__s;
  v29 = qword_100999908;
  if (os_log_type_enabled((os_log_t)qword_100999908, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v28;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "Warning: Overriding - MaxConnPerBundleID %d", buf, 8u);
  }
LABEL_68:
  v30 = sub_100027F68();
  sub_100091AE8(buf, "LE");
  sub_100091AE8(__p, "EnforceUseCaseRequiredList");
  v31 = (*(uint64_t (**)(uint64_t, _BYTE *, void **, int *))(*(_QWORD *)v30 + 72))(v30, buf, __p, &v38);
  if (v37 < 0)
    operator delete(__p[0]);
  if (v42 < 0)
  {
    operator delete(*(void **)buf);
    if (!v31)
      return;
  }
  else if (!v31)
  {
    return;
  }
  v32 = v38;
  *(_BYTE *)(a1 + 154) = v38;
  v33 = qword_100999908;
  if (os_log_type_enabled((os_log_t)qword_100999908, OS_LOG_TYPE_DEFAULT))
  {
    v34 = "Yes";
    if (!v32)
      v34 = "No";
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = v34;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "Warning: Overriding - Enforce Use Case Required List: %s", buf, 0xCu);
  }
}

void sub_1006BE6A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a18 < 0)
    operator delete(__p);
  if (a25 < 0)
    operator delete(a20);
  _Unwind_Resume(exception_object);
}

void sub_1006BE710()
{
  uint64_t v0;
  void *v1;
  uint64_t v2;
  __int128 *v3;
  __int128 *v4;
  __int128 *v5;
  __int128 *i;
  __int128 v7;
  NSObject *v8;
  __int128 *p_dst;
  id v10;
  __int128 *v11;
  id v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  __int128 *v16;
  __int128 *v17;
  __int128 *v18;
  __int128 *j;
  __int128 v20;
  NSObject *v21;
  __int128 *v22;
  id v23;
  __int128 *v24;
  id v25;
  uint64_t v26;
  void *v27;
  __int128 __dst;
  uint64_t v29;
  __int128 *v30;
  __int128 *v31;
  uint64_t v32;
  uint8_t buf[4];
  __int128 *v34;

  v0 = objc_claimAutoreleasedReturnValue(+[NSMutableSet setWithObjects:](NSMutableSet, "setWithObjects:", CFSTR("554d08b1bf41ced30d076c7ab17284e2afde2f14cf0606f41b106ebabaf98278"), CFSTR("602926fb95b65d8841071711217c956ada1917462051445917d89356ee415929"), CFSTR("3a58c9b9f34737fcb1e4ef2c5665843c6d833a2411d47bec0e7caa34ce401e89"), CFSTR("febeb2bb2afc79b90aee52b3c218ff6772ceb48b3a84caf9aa173247fbe203d9"), CFSTR("5ad8dab6f1fa117db4bc3427c2853a4feceb05332a2bcd6fb5f3a55db03ff081"), CFSTR("15f62a1003c7f91a502a48d8b9d6b9e3234972eb2134266269da426531e0f142"), CFSTR("ec0f8fcfbb71cd4859bdcb14f4840f131b1d0931fda6846f637732a49598a49f"), CFSTR("ef8ff847079725c8fb3ef45a3ad4c69094b719d6eef6207cced996646cad9eb7"), CFSTR("358e413d1ec9ed3836bb8fe3f6c47ef03e29bc368636784543f2be232e66541d"), CFSTR("8b69e99aebb81c30fb34dc5074023e0f5bb05964ee28d7e43010537fba7d36e0"), CFSTR("bf4ce535225ad51bb284f2c4766a0fd74c536abac7a166d9830d3947f374de80"), CFSTR("63c4591131b2604f1ca83bf2ae7895f23c723a92106b3740a972b1b14613bc0f"), CFSTR("38fa5040af8b215d43372179eacbd6f725312c840059488b197711401d7ad5d4"), CFSTR("c097e6524326b43a007761497aca0a778b5581b035f4f0f9773d57156e9b38a0"), CFSTR("b96253cbfed55399a9e8b5820dbcf6abc5d9118ee105e2bdef0b201c3b3e9444"), CFSTR("24f2d03118a59d1daba966600ed07425b0d875d70c06be360d33fd4ca853af58"),
           CFSTR("23982ca925a8cd3342289446b7f42903ab99be060475efa8b0abc1a792effc29"),
           CFSTR("ae5179510709cdca4f1dde3264d1949698b408f426a98be526c4d14dffc26b91"),
           CFSTR("ff31c07022e965aa2a54968917cd4f3d41e165e82d31a5fd22856c4217c28553"),
           CFSTR("7fad0ec0a107abc4276a86c201b1bc46d9ef1b0776cc75b71987505da768393d"),
           CFSTR("ea1d0f537acf0783b76af476c0ec5c3acac48b2a5432a73daa8c5afb42f19b0b"),
           CFSTR("a800fae19a5d4e1e92dd43934636be8787bf74e832a80bf2ea709062799acb94"),
           CFSTR("79f5c84c1c254c76b8d4ea7601499b7c3a67914dfd3e567704db4b9309ae4fb1"),
           CFSTR("06ccfb2f489cc5912a2cda502c69506b82cad5934895ea6ae535cab35c5bc9e3"),
           CFSTR("bb18ff323ebe7357070647660f905b6c4417447bdbcc79bea36ee4cf2c66b3d7"),
           CFSTR("06fa9dee637f78720fe2778c92824a6dd80299f34646910a83029d23ca3399a4"),
           CFSTR("a09e4a534d554ffe8cf0544b591bf9f635ca605771f6a72ef93103fa38c41f95"),
           CFSTR("089f80bd091e54346dc645636f8f7b51c1d22ba623f3c0f8c05d17c34c92bc27"),
           CFSTR("ae98258fc9148e2a33ba48f0e2eaa82e813fdb86d010482101cae83f3d2a877d"),
           CFSTR("decfd0b0b0a0bfeaa333cce4c5ec9590f5f8274561d4347e9f1f6a29aa8f1d34"),
           CFSTR("ecc1d20a6f0e9ee4e7f384a0cdfe18050cee19a5c7c94adb6c94e12f647d24f2"),
           CFSTR("8cbd21794df7f1c16bbd5a267f976326a24bf9ddb3ac745bc4a854af006a50b7"),
           CFSTR("dfa8283074903b24529434aac683ac9d3853d95107f7fd3ee581f7c69ffc65dd"),
           CFSTR("e5457e14a88f3003c6c64edcaa85fbe18f7fd23e6385c9acb0f210bcd84e837e"),
           CFSTR("636c1f0ee6b0cccebbbfd5979ae5ecf09bcbe673df044883881fd69d313a9eac"),
           CFSTR("aaf648093c082f5b9999e9d8eaec9235503aa3963726641be8635701db151cfe"),
           CFSTR("15f6b2947dd7ad89fe858cbe80ee51c2c6c5e4625ad5d4e9b6de6c1b15db213b"),
           CFSTR("be0bcf7017deaa4c2f173c24718a2648f5c5e6b7a6b296df919775043acd7b73"),
           CFSTR("c1d1c54c3bb978737276ec2c974256db9e98e3878cf204c48ecc2bf6a3906e2a"),
           CFSTR("cdf1779ec4f156ca577a1e99372fe3227e2552dff8d533624ea5312c814e9c85"),
           CFSTR("619157a2665ca48dbd59740e7993884af9e9aefa23d42ca3beed72450a80130a"),
           CFSTR("c6538eb30a5e64df30159760d1c20dfb82cf10febdc237bfb3fbeaae8061e958"),
           CFSTR("306dec84ac641c728a5e52b9257a536faaa292db3109b0c6c3b4b2a24999c1d8"),
           CFSTR("64b90991318f675b807c35b4ff35850a05967ee72b06176f5d1f57318bcc60e2"),
           CFSTR("b86e6ba2c543374a4736569af4226371b78532514f935dd1122cdf84199d42b9"),
           CFSTR("e2ae0f5a011d888eb0249f576a1f6d1cf0ab5953cf25e1451f1a476e86673b93"),
           CFSTR("b27625a6780b68f433ec7012f3c75a73925c24a6a91868ceb99ac4a0ea0413e6"),
           CFSTR("e64c7c5f0599df5b5800ec1771e2794491b06f49d43c00707c08c2a8d6fea059"),
           CFSTR("839629816bd50f294becdfa5fb34027f5342f266b376607645cd0615c0a5c556"),
           CFSTR("474646dff450e7a23bd8180829d1712a26d65c6ec4de6eb4ffe233037a2cc69f"),
           CFSTR("3d56a5b22cbe84a53b45bf7ec935e6dfc346edff2d47d974939f3f8c8b0d2862"),
           CFSTR("cb9c7eaccfbe7833daf0f9030e6b2b3e75ca158857d0e5307ca9d9064c3199b2"),
           CFSTR("a7fcb0ca8a4bf8a79ffde6c2e982521085db9296fb451f1bce53819fdfe7d7c2"),
           CFSTR("4641d059088b8c84e32990ea7dfae36dfa988f109bad552d138771782f681d03"),
           CFSTR("5b0a008a845215b74ea580c1ca3096e2a67b0283cfc04548124326b1023d1c05"),
           CFSTR("5ece8d12e33b7abe998fa14e917c5eacd97fecb7be0da94b775389bf92ad8313"),
           CFSTR("75d3a5e65ae4b047e14682759758d41ed65b98d0ad5a2c57eb51ac80e913c45b"),
           CFSTR("8ae9aeabfa6411b461c28f082940ecb9eb25009705bd60498d4de57e1b55c5c1"),
           CFSTR("1d7300686aa7c49abcdbc2a47e30cb7ec451f10f14b240523a57b958c2cb9591"),
           CFSTR("f9306b984dd3cf87c9277b547eb2f11dce7a40d21c8b1ed4fa1d1fffec5acb9f"),
           CFSTR("f53de5dac1ebf57ff83dcd8094e03d8229c5d7457e39184e87ce8bac0b1f95ea")));
  v1 = (void *)qword_100999C50;
  qword_100999C50 = v0;

  v30 = 0;
  v31 = 0;
  v32 = 0;
  v2 = sub_100027F68();
  sub_100091AE8(&__dst, "LEAllowedBundleIDs");
  if ((*(unsigned int (**)(uint64_t, __int128 *, __int128 **))(*(_QWORD *)v2 + 48))(v2, &__dst, &v30))
  {
    v4 = v30;
    v3 = v31;
    if (SHIBYTE(v29) < 0)
      operator delete((void *)__dst);
    if (v3 != v4)
    {
      v5 = v30;
      for (i = v31; v5 != i; v5 = (__int128 *)((char *)v5 + 24))
      {
        __dst = 0uLL;
        v29 = 0;
        if (*((char *)v5 + 23) < 0)
        {
          sub_10003430C(&__dst, *(void **)v5, *((_QWORD *)v5 + 1));
        }
        else
        {
          v7 = *v5;
          v29 = *((_QWORD *)v5 + 2);
          __dst = v7;
        }
        v8 = qword_100999908;
        if (os_log_type_enabled((os_log_t)qword_100999908, OS_LOG_TYPE_DEFAULT))
        {
          if (v29 >= 0)
            p_dst = &__dst;
          else
            p_dst = (__int128 *)__dst;
          *(_DWORD *)buf = 136446210;
          v34 = p_dst;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Additional BundleID for allowedHashedBundleIDsSet by Overriding: %{public}s", buf, 0xCu);
        }
        v10 = objc_alloc((Class)NSString);
        if (v29 >= 0)
          v11 = &__dst;
        else
          v11 = (__int128 *)__dst;
        v12 = objc_msgSend(v10, "initWithUTF8String:", v11);
        v13 = CBGenerateObfuscatedSHA256HashedString(v12);
        v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
        objc_msgSend((id)qword_100999C50, "addObject:", v14);

        if (SHIBYTE(v29) < 0)
          operator delete((void *)__dst);
      }
    }
  }
  else if (SHIBYTE(v29) < 0)
  {
    operator delete((void *)__dst);
  }
  v15 = sub_100027F68();
  sub_100091AE8(&__dst, "LEDisallowedBundleIDs");
  if ((*(unsigned int (**)(uint64_t, __int128 *, __int128 **))(*(_QWORD *)v15 + 48))(v15, &__dst, &v30))
  {
    v17 = v30;
    v16 = v31;
    if (SHIBYTE(v29) < 0)
      operator delete((void *)__dst);
    if (v16 != v17)
    {
      v18 = v30;
      for (j = v31; v18 != j; v18 = (__int128 *)((char *)v18 + 24))
      {
        __dst = 0uLL;
        v29 = 0;
        if (*((char *)v18 + 23) < 0)
        {
          sub_10003430C(&__dst, *(void **)v18, *((_QWORD *)v18 + 1));
        }
        else
        {
          v20 = *v18;
          v29 = *((_QWORD *)v18 + 2);
          __dst = v20;
        }
        v21 = qword_100999908;
        if (os_log_type_enabled((os_log_t)qword_100999908, OS_LOG_TYPE_DEFAULT))
        {
          if (v29 >= 0)
            v22 = &__dst;
          else
            v22 = (__int128 *)__dst;
          *(_DWORD *)buf = 136446210;
          v34 = v22;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "BundleID is removed from allowedHashedBundleIDsSet by Overriding: %{public}s", buf, 0xCu);
        }
        v23 = objc_alloc((Class)NSString);
        if (v29 >= 0)
          v24 = &__dst;
        else
          v24 = (__int128 *)__dst;
        v25 = objc_msgSend(v23, "initWithUTF8String:", v24);
        v26 = CBGenerateObfuscatedSHA256HashedString(v25);
        v27 = (void *)objc_claimAutoreleasedReturnValue(v26);
        objc_msgSend((id)qword_100999C50, "removeObject:", v27);

        if (SHIBYTE(v29) < 0)
          operator delete((void *)__dst);
      }
    }
  }
  else if (SHIBYTE(v29) < 0)
  {
    operator delete((void *)__dst);
  }
  *(_QWORD *)&__dst = &v30;
  sub_100091BF8((void ***)&__dst);
}

void sub_1006BF544(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 137) < 0)
    operator delete(*(void **)(v1 - 160));
  *(_QWORD *)(v1 - 160) = v1 - 136;
  sub_100091BF8((void ***)(v1 - 160));
  _Unwind_Resume(a1);
}

void sub_1006BF5CC()
{
  uint64_t v0;
  void *v1;
  uint64_t v2;
  __int128 *v3;
  __int128 *v4;
  __int128 *v5;
  __int128 *i;
  __int128 v7;
  NSObject *v8;
  void **v9;
  id v10;
  void **v11;
  id v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  __int128 *v16;
  __int128 *v17;
  __int128 *v18;
  __int128 *j;
  __int128 v20;
  NSObject *v21;
  void **v22;
  id v23;
  void **v24;
  id v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  __int128 *v31;
  __int128 *v32;
  __int128 *v33;
  __int128 *k;
  __int128 v35;
  NSObject *v36;
  void **v37;
  id v38;
  void **v39;
  id v40;
  uint64_t v41;
  void *v42;
  uint64_t v43;
  __int128 *v44;
  __int128 *v45;
  __int128 *v46;
  __int128 *m;
  __int128 v48;
  NSObject *v49;
  void **v50;
  id v51;
  void **v52;
  id v53;
  uint64_t v54;
  void *v55;
  uint64_t v56;
  void *v57;
  uint64_t v58;
  __int128 *v59;
  __int128 *v60;
  __int128 *v61;
  __int128 *n;
  __int128 v63;
  NSObject *v64;
  void **v65;
  id v66;
  void **v67;
  id v68;
  uint64_t v69;
  void *v70;
  uint64_t v71;
  __int128 *v72;
  __int128 *v73;
  __int128 *v74;
  __int128 *ii;
  __int128 v76;
  NSObject *v77;
  void **v78;
  id v79;
  void **v80;
  id v81;
  uint64_t v82;
  void *v83;
  void *__p[2];
  uint64_t v85;
  __int128 *v86;
  __int128 *v87;
  uint64_t v88;
  uint8_t buf[4];
  void **v90;

  v86 = 0;
  v87 = 0;
  v88 = 0;
  v0 = objc_claimAutoreleasedReturnValue(+[NSMutableSet setWithObjects:](NSMutableSet, "setWithObjects:", CFSTR("f50eeeda9ef9e96cbfd2e255ecd185cedcaa7c023ad51d903de5405e4d94264c"), CFSTR("28b69483d207baa88955b89e6419fb8a823ddea87ee701fdc8e83b9d819ab4a4"), CFSTR("c48aec1017d2d0d2c9a4a0a9f34d20b42beed75cad781f9e33e45f1df476fac1"), 0));
  v1 = (void *)qword_100999C58;
  qword_100999C58 = v0;

  v2 = sub_100027F68();
  sub_100091AE8(__p, "AddLEUseCaseRequiredBundleIDsScan");
  if ((*(unsigned int (**)(uint64_t, void **, __int128 **))(*(_QWORD *)v2 + 48))(v2, __p, &v86))
  {
    v4 = v86;
    v3 = v87;
    if (SHIBYTE(v85) < 0)
      operator delete(__p[0]);
    if (v3 != v4)
    {
      v5 = v86;
      for (i = v87; v5 != i; v5 = (__int128 *)((char *)v5 + 24))
      {
        __p[0] = 0;
        __p[1] = 0;
        v85 = 0;
        if (*((char *)v5 + 23) < 0)
        {
          sub_10003430C(__p, *(void **)v5, *((_QWORD *)v5 + 1));
        }
        else
        {
          v7 = *v5;
          v85 = *((_QWORD *)v5 + 2);
          *(_OWORD *)__p = v7;
        }
        v8 = qword_100999908;
        if (os_log_type_enabled((os_log_t)qword_100999908, OS_LOG_TYPE_DEFAULT))
        {
          if (v85 >= 0)
            v9 = __p;
          else
            v9 = (void **)__p[0];
          *(_DWORD *)buf = 136446210;
          v90 = v9;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Additional BundleID for useCaseRequiredHashedBundleIDsSet for Scanning by Overriding: %{public}s", buf, 0xCu);
        }
        v10 = objc_alloc((Class)NSString);
        if (v85 >= 0)
          v11 = __p;
        else
          v11 = (void **)__p[0];
        v12 = objc_msgSend(v10, "initWithUTF8String:", v11);
        v13 = CBGenerateObfuscatedSHA256HashedString(v12);
        v14 = (void *)objc_claimAutoreleasedReturnValue(v13);
        objc_msgSend((id)qword_100999C58, "addObject:", v14);

        if (SHIBYTE(v85) < 0)
          operator delete(__p[0]);
      }
    }
  }
  else if (SHIBYTE(v85) < 0)
  {
    operator delete(__p[0]);
  }
  v15 = sub_100027F68();
  sub_100091AE8(__p, "RemoveLEUseCaseRequiredBundleIDsScan");
  if ((*(unsigned int (**)(uint64_t, void **, __int128 **))(*(_QWORD *)v15 + 48))(v15, __p, &v86))
  {
    v17 = v86;
    v16 = v87;
    if (SHIBYTE(v85) < 0)
      operator delete(__p[0]);
    if (v16 != v17)
    {
      v18 = v86;
      for (j = v87; v18 != j; v18 = (__int128 *)((char *)v18 + 24))
      {
        __p[0] = 0;
        __p[1] = 0;
        v85 = 0;
        if (*((char *)v18 + 23) < 0)
        {
          sub_10003430C(__p, *(void **)v18, *((_QWORD *)v18 + 1));
        }
        else
        {
          v20 = *v18;
          v85 = *((_QWORD *)v18 + 2);
          *(_OWORD *)__p = v20;
        }
        v21 = qword_100999908;
        if (os_log_type_enabled((os_log_t)qword_100999908, OS_LOG_TYPE_DEFAULT))
        {
          if (v85 >= 0)
            v22 = __p;
          else
            v22 = (void **)__p[0];
          *(_DWORD *)buf = 136446210;
          v90 = v22;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "BundleID is removed from useCaseRequiredHashedBundleIDsSet for Scanning by Overriding: %{public}s", buf, 0xCu);
        }
        v23 = objc_alloc((Class)NSString);
        if (v85 >= 0)
          v24 = __p;
        else
          v24 = (void **)__p[0];
        v25 = objc_msgSend(v23, "initWithUTF8String:", v24);
        v26 = CBGenerateObfuscatedSHA256HashedString(v25);
        v27 = (void *)objc_claimAutoreleasedReturnValue(v26);
        objc_msgSend((id)qword_100999C58, "removeObject:", v27);

        if (SHIBYTE(v85) < 0)
          operator delete(__p[0]);
      }
    }
  }
  else if (SHIBYTE(v85) < 0)
  {
    operator delete(__p[0]);
  }
  v28 = objc_claimAutoreleasedReturnValue(+[NSMutableSet setWithObjects:](NSMutableSet, "setWithObjects:", CFSTR("f50eeeda9ef9e96cbfd2e255ecd185cedcaa7c023ad51d903de5405e4d94264c"), CFSTR("e4c0ceca17dcd39c038c248f92a18f304213be2c9d5c3acba171e8f4dc098d97"), CFSTR("0604cb11439cce401b58e1cbb1e74790c30d05583fc162c9b0413efacf6a6a4d"), 0));
  v29 = (void *)qword_100999C60;
  qword_100999C60 = v28;

  v30 = sub_100027F68();
  sub_100091AE8(__p, "AddLEUseCaseRequiredBundleIDsConnect");
  if ((*(unsigned int (**)(uint64_t, void **, __int128 **))(*(_QWORD *)v30 + 48))(v30, __p, &v86))
  {
    v32 = v86;
    v31 = v87;
    if (SHIBYTE(v85) < 0)
      operator delete(__p[0]);
    if (v31 != v32)
    {
      v33 = v86;
      for (k = v87; v33 != k; v33 = (__int128 *)((char *)v33 + 24))
      {
        __p[0] = 0;
        __p[1] = 0;
        v85 = 0;
        if (*((char *)v33 + 23) < 0)
        {
          sub_10003430C(__p, *(void **)v33, *((_QWORD *)v33 + 1));
        }
        else
        {
          v35 = *v33;
          v85 = *((_QWORD *)v33 + 2);
          *(_OWORD *)__p = v35;
        }
        v36 = qword_100999908;
        if (os_log_type_enabled((os_log_t)qword_100999908, OS_LOG_TYPE_DEFAULT))
        {
          if (v85 >= 0)
            v37 = __p;
          else
            v37 = (void **)__p[0];
          *(_DWORD *)buf = 136446210;
          v90 = v37;
          _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "Additional BundleID for useCaseRequiredHashedBundleIDsSet for Connection by Overriding: %{public}s", buf, 0xCu);
        }
        v38 = objc_alloc((Class)NSString);
        if (v85 >= 0)
          v39 = __p;
        else
          v39 = (void **)__p[0];
        v40 = objc_msgSend(v38, "initWithUTF8String:", v39);
        v41 = CBGenerateObfuscatedSHA256HashedString(v40);
        v42 = (void *)objc_claimAutoreleasedReturnValue(v41);
        objc_msgSend((id)qword_100999C60, "addObject:", v42);

        if (SHIBYTE(v85) < 0)
          operator delete(__p[0]);
      }
    }
  }
  else if (SHIBYTE(v85) < 0)
  {
    operator delete(__p[0]);
  }
  v43 = sub_100027F68();
  sub_100091AE8(__p, "RemoveLEUseCaseRequiredBundleIDsConnect");
  if ((*(unsigned int (**)(uint64_t, void **, __int128 **))(*(_QWORD *)v43 + 48))(v43, __p, &v86))
  {
    v45 = v86;
    v44 = v87;
    if (SHIBYTE(v85) < 0)
      operator delete(__p[0]);
    if (v44 != v45)
    {
      v46 = v86;
      for (m = v87; v46 != m; v46 = (__int128 *)((char *)v46 + 24))
      {
        __p[0] = 0;
        __p[1] = 0;
        v85 = 0;
        if (*((char *)v46 + 23) < 0)
        {
          sub_10003430C(__p, *(void **)v46, *((_QWORD *)v46 + 1));
        }
        else
        {
          v48 = *v46;
          v85 = *((_QWORD *)v46 + 2);
          *(_OWORD *)__p = v48;
        }
        v49 = qword_100999908;
        if (os_log_type_enabled((os_log_t)qword_100999908, OS_LOG_TYPE_DEFAULT))
        {
          if (v85 >= 0)
            v50 = __p;
          else
            v50 = (void **)__p[0];
          *(_DWORD *)buf = 136446210;
          v90 = v50;
          _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "BundleID is removed from useCaseRequiredHashedBundleIDsSet for Connection by Overriding: %{public}s", buf, 0xCu);
        }
        v51 = objc_alloc((Class)NSString);
        if (v85 >= 0)
          v52 = __p;
        else
          v52 = (void **)__p[0];
        v53 = objc_msgSend(v51, "initWithUTF8String:", v52);
        v54 = CBGenerateObfuscatedSHA256HashedString(v53);
        v55 = (void *)objc_claimAutoreleasedReturnValue(v54);
        objc_msgSend((id)qword_100999C60, "removeObject:", v55);

        if (SHIBYTE(v85) < 0)
          operator delete(__p[0]);
      }
    }
  }
  else if (SHIBYTE(v85) < 0)
  {
    operator delete(__p[0]);
  }
  v56 = objc_claimAutoreleasedReturnValue(+[NSMutableSet setWithObjects:](NSMutableSet, "setWithObjects:", CFSTR("962f55acdffc015a6caaf8083446b7e50ed5cb6cf10eeabdcfefd2f1fd76fca6"), CFSTR("e84ae109a38baeb5483e641b123b64c498a08de3c392e6a15a5464aa163abba1"), 0));
  v57 = (void *)qword_100999C68;
  qword_100999C68 = v56;

  v58 = sub_100027F68();
  sub_100091AE8(__p, "AddLEUseCaseRequiredBundleIDsAdv");
  if ((*(unsigned int (**)(uint64_t, void **, __int128 **))(*(_QWORD *)v58 + 48))(v58, __p, &v86))
  {
    v60 = v86;
    v59 = v87;
    if (SHIBYTE(v85) < 0)
      operator delete(__p[0]);
    if (v59 != v60)
    {
      v61 = v86;
      for (n = v87; v61 != n; v61 = (__int128 *)((char *)v61 + 24))
      {
        __p[0] = 0;
        __p[1] = 0;
        v85 = 0;
        if (*((char *)v61 + 23) < 0)
        {
          sub_10003430C(__p, *(void **)v61, *((_QWORD *)v61 + 1));
        }
        else
        {
          v63 = *v61;
          v85 = *((_QWORD *)v61 + 2);
          *(_OWORD *)__p = v63;
        }
        v64 = qword_100999908;
        if (os_log_type_enabled((os_log_t)qword_100999908, OS_LOG_TYPE_DEFAULT))
        {
          if (v85 >= 0)
            v65 = __p;
          else
            v65 = (void **)__p[0];
          *(_DWORD *)buf = 136446210;
          v90 = v65;
          _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "Additional BundleID for useCaseRequiredHashedBundleIDsSet for Advertising by overriding: %{public}s", buf, 0xCu);
        }
        v66 = objc_alloc((Class)NSString);
        if (v85 >= 0)
          v67 = __p;
        else
          v67 = (void **)__p[0];
        v68 = objc_msgSend(v66, "initWithUTF8String:", v67);
        v69 = CBGenerateObfuscatedSHA256HashedString(v68);
        v70 = (void *)objc_claimAutoreleasedReturnValue(v69);
        objc_msgSend((id)qword_100999C68, "addObject:", v70);

        if (SHIBYTE(v85) < 0)
          operator delete(__p[0]);
      }
    }
  }
  else if (SHIBYTE(v85) < 0)
  {
    operator delete(__p[0]);
  }
  v71 = sub_100027F68();
  sub_100091AE8(__p, "RemoveLEUseCaseRequiredBundleIDsAdv");
  if ((*(unsigned int (**)(uint64_t, void **, __int128 **))(*(_QWORD *)v71 + 48))(v71, __p, &v86))
  {
    v73 = v86;
    v72 = v87;
    if (SHIBYTE(v85) < 0)
      operator delete(__p[0]);
    if (v72 != v73)
    {
      v74 = v86;
      for (ii = v87; v74 != ii; v74 = (__int128 *)((char *)v74 + 24))
      {
        __p[0] = 0;
        __p[1] = 0;
        v85 = 0;
        if (*((char *)v74 + 23) < 0)
        {
          sub_10003430C(__p, *(void **)v74, *((_QWORD *)v74 + 1));
        }
        else
        {
          v76 = *v74;
          v85 = *((_QWORD *)v74 + 2);
          *(_OWORD *)__p = v76;
        }
        v77 = qword_100999908;
        if (os_log_type_enabled((os_log_t)qword_100999908, OS_LOG_TYPE_DEFAULT))
        {
          if (v85 >= 0)
            v78 = __p;
          else
            v78 = (void **)__p[0];
          *(_DWORD *)buf = 136446210;
          v90 = v78;
          _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "BundleID is removed from useCaseRequiredHashedBundleIDsSet for Advertising by overriding: %{public}s", buf, 0xCu);
        }
        v79 = objc_alloc((Class)NSString);
        if (v85 >= 0)
          v80 = __p;
        else
          v80 = (void **)__p[0];
        v81 = objc_msgSend(v79, "initWithUTF8String:", v80);
        v82 = CBGenerateObfuscatedSHA256HashedString(v81);
        v83 = (void *)objc_claimAutoreleasedReturnValue(v82);
        objc_msgSend((id)qword_100999C68, "removeObject:", v83);

        if (SHIBYTE(v85) < 0)
          operator delete(__p[0]);
      }
    }
  }
  else if (SHIBYTE(v85) < 0)
  {
    operator delete(__p[0]);
  }
  __p[0] = &v86;
  sub_100091BF8((void ***)__p);
}

void sub_1006BFFBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,char a21)
{
  if (a20 < 0)
    operator delete(__p);
  __p = &a21;
  sub_100091BF8((void ***)&__p);
  _Unwind_Resume(a1);
}

uint64_t sub_1006C00E8(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  BOOL v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v9;
  int v10;
  uint64_t (*v11)(void);

  v2 = *(_QWORD *)(a1 + 88);
  if (v2)
  {
    v3 = a1 + 88;
    do
    {
      v4 = *(_DWORD *)(v2 + 28);
      v5 = v4 >= a2;
      if (v4 >= a2)
        v6 = (uint64_t *)v2;
      else
        v6 = (uint64_t *)(v2 + 8);
      if (v5)
        v3 = v2;
      v2 = *v6;
    }
    while (*v6);
    if (v3 != a1 + 88 && *(_DWORD *)(v3 + 28) <= a2)
    {
      v7 = *(unsigned __int16 *)(v3 + 32);
      if ((_DWORD)v7)
        return v7;
    }
  }
  if (a2 - 20 < 2 || a2 == 655360)
    return *(unsigned __int16 *)(a1 + 8);
  if ((a2 & 0xFFFF0000) == 0x10000 && dword_10097BA08[0] != a2)
  {
    v9 = 0;
    do
    {
      if (v9 == 8)
        break;
      v10 = dword_10097BA08[++v9];
    }
    while (v10 != a2);
  }
  v11 = *(uint64_t (**)(void))(*(_QWORD *)sub_1000438A4() + 3424);
  return v11();
}

uint64_t sub_1006C020C(uint64_t a1, int a2)
{
  uint64_t v3;
  int v4;

  v3 = 0;
  v4 = 0;
  do
  {
    if (HIWORD(dword_10097BA08[v3]) == a2)
    {
      if (qword_1009778A8 != -1)
        dispatch_once(&qword_1009778A8, &stru_100940890);
      v4 += sub_10062B86C((uint64_t)off_1009778A0, dword_10097BA08[v3]);
    }
    ++v3;
  }
  while (v3 != 9);
  return (unsigned __int16)v4;
}

uint64_t sub_1006C02B8(uint64_t a1, int a2)
{
  __int16 v3;
  uint64_t v5;
  int v6;

  if ((a2 & 0xFFFF0000) == 0x10000)
  {
    if (dword_10097BA08[0] == a2)
    {
LABEL_3:
      v3 = sub_1006C020C(a1, 1);
      if (qword_1009778A8 == -1)
        return (unsigned __int16)(sub_10062B86C((uint64_t)off_1009778A0, 3) + v3);
      goto LABEL_16;
    }
    v5 = 0;
    while (v5 != 8)
    {
      v6 = dword_10097BA08[++v5];
      if (v6 == a2)
      {
        if ((unint64_t)(v5 - 1) <= 7)
          goto LABEL_3;
        break;
      }
    }
    if (qword_1009778A8 == -1)
      return sub_10062B86C((uint64_t)off_1009778A0, a2);
LABEL_17:
    dispatch_once(&qword_1009778A8, &stru_100940890);
    return sub_10062B86C((uint64_t)off_1009778A0, a2);
  }
  if (a2 == 3)
  {
    v3 = sub_1006C020C(a1, 1);
    if (qword_1009778A8 == -1)
      return (unsigned __int16)(sub_10062B86C((uint64_t)off_1009778A0, 3) + v3);
LABEL_16:
    dispatch_once(&qword_1009778A8, &stru_100940890);
    return (unsigned __int16)(sub_10062B86C((uint64_t)off_1009778A0, 3) + v3);
  }
  if (qword_1009778A8 != -1)
    goto LABEL_17;
  return sub_10062B86C((uint64_t)off_1009778A0, a2);
}

uint64_t sub_1006C03EC()
{
  uint64_t v0;
  unsigned __int16 v1;
  uint64_t v2;
  uint64_t v3;

  v0 = sub_10003BE44();
  if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v0 + 336))(v0) & 1) != 0)
  {
    return 2;
  }
  else
  {
    v2 = sub_10003BE44();
    v1 = 2;
    if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 344))(v2) & 1) == 0)
    {
      v3 = sub_10003BE44();
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v3 + 424))(v3))
        return 2;
      else
        return (unsigned __int16)-1;
    }
  }
  return v1;
}

uint64_t sub_1006C0454(uint64_t a1, void *a2)
{
  id v3;
  unsigned __int16 *v4;
  uint64_t v5;

  v3 = a2;
  if ((objc_msgSend(v3, "isEqualToString:", CFSTR("com.apple.locationd")) & 1) != 0
    || objc_msgSend(v3, "isEqualToString:", CFSTR("com.apple.icloud.searchpartyd")))
  {
    v4 = (unsigned __int16 *)(a1 + 156);
  }
  else
  {
    v4 = (unsigned __int16 *)(a1 + 158);
  }
  v5 = *v4;

  return v5;
}

void sub_1006C04B4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t sub_1006C04C4(uint64_t a1)
{
  uint64_t result;

  result = *(unsigned __int16 *)(a1 + 160);
  if (!(_DWORD)result)
    return sub_1006C03EC();
  return result;
}

uint64_t sub_1006C04D4(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;

  v1 = a1;
  v2 = v1;
  if (v1)
  {
    if ((sub_1006C0540(v1) & 1) != 0)
    {
      v3 = 1;
    }
    else if (sub_1006C0598(v2))
    {
      v3 = 15;
    }
    else
    {
      v3 = 0;
    }
  }
  else
  {
    v3 = 0;
  }

  return v3;
}

void sub_1006C0530(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id sub_1006C0540(void *a1)
{
  id v1;
  void *v2;
  id v3;

  v1 = a1;
  v2 = v1;
  if (v1)
    v3 = objc_msgSend(v1, "localizedCaseInsensitiveContainsString:", CFSTR("com.apple.healthkit"));
  else
    v3 = 0;

  return v3;
}

void sub_1006C0588(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t sub_1006C0598(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;

  v1 = a1;
  v2 = v1;
  if (v1)
  {
    if ((objc_msgSend(v1, "localizedCaseInsensitiveContainsString:", CFSTR("com.dexcom.")) & 1) != 0
      || (objc_msgSend(v2, "localizedCaseInsensitiveContainsString:", CFSTR("com.medtronic.")) & 1) != 0)
    {
      v3 = 1;
    }
    else
    {
      v3 = (uint64_t)objc_msgSend(v2, "localizedCaseInsensitiveContainsString:", CFSTR("com.senseonics."));
    }
  }
  else
  {
    v3 = 0;
  }

  return v3;
}

void sub_1006C0610(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id sub_1006C0620(void *a1)
{
  id v1;
  void *v2;
  id v3;

  v1 = a1;
  v2 = v1;
  if (v1)
    v3 = objc_msgSend(v1, "localizedCaseInsensitiveContainsString:", CFSTR("com.apple.bluetoothd-central"));
  else
    v3 = 0;

  return v3;
}

void sub_1006C0668(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t sub_1006C0678(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  id v7;
  id v8;
  NSObject *v9;
  int v10;
  _BYTE *v11;
  NSStringEncoding v12;
  _BYTE *v13;
  void *v14;
  void *v15;
  uint64_t v16;
  NSObject *v17;
  NSObject *v19;
  _BYTE __p[12];
  __int16 v21;
  uint64_t v22;
  char v23;

  v7 = a2;
  v8 = a3;
  if ((_DWORD)a4)
  {
    v9 = qword_100999908;
    if (os_log_type_enabled((os_log_t)qword_100999908, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__p = 134217984;
      *(_QWORD *)&__p[4] = a4;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Accept provided connection use type %ld", __p, 0xCu);
    }
LABEL_17:
    v14 = 0;
    goto LABEL_18;
  }
  if (!a1)
  {
    v17 = qword_100999908;
    if (os_log_type_enabled((os_log_t)qword_100999908, OS_LOG_TYPE_ERROR))
      sub_10071BBE0(v17);
    a4 = 0;
    goto LABEL_17;
  }
  sub_1000340DC(a1, (uint64_t)__p);
  v10 = v23;
  v11 = *(_BYTE **)__p;
  v12 = +[NSString defaultCStringEncoding](NSString, "defaultCStringEncoding");
  if (v10 >= 0)
    v13 = __p;
  else
    v13 = v11;
  v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithCString:encoding:](NSString, "stringWithCString:encoding:", v13, v12));
  if (v23 < 0)
    operator delete(*(void **)__p);
  if ((sub_1006C0620(v14) & 1) == 0)
  {
    v16 = sub_1006C04D4(v14);
    goto LABEL_20;
  }
  v15 = v7;
  if (v7 || (v15 = v8) != 0)
  {
    v16 = sub_1006C04D4(v15);
LABEL_20:
    a4 = v16;
    goto LABEL_21;
  }
  a4 = 0;
LABEL_21:
  v19 = qword_100999908;
  if (os_log_type_enabled((os_log_t)qword_100999908, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__p = 138543618;
    *(_QWORD *)&__p[4] = v14;
    v21 = 2048;
    v22 = a4;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "getConnectionUseCase directConnectionClientString %{public}@ connectionUseCase %ld", __p, 0x16u);
  }
LABEL_18:

  return a4;
}

void sub_1006C087C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  void *v14;
  void *v15;

  _Unwind_Resume(a1);
}

void sub_1006C08BC(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v7;
  NSObject *v8;
  unsigned __int8 *v9;
  void *v10;
  __CFString *v11;
  void *v12;
  __CFString *v13;
  id v14;
  id v15;
  void *v16;
  void *v17;
  unsigned int v18;
  _BOOL4 v20;
  uint64_t **v21;
  NSMutableSet *v22;
  void *v23;
  void *v24;
  _BOOL4 v25;
  void *v26;
  id v27;
  uint64_t v28;
  void *i;
  _BYTE *v30;
  void *v31;
  uint64_t *v32;
  NSObject *v33;
  unsigned __int8 *v34;
  int v35;
  void *v36;
  id v37;
  id v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  _QWORD v43[2];
  unsigned __int8 *v44;
  unsigned __int8 v45[128];
  unsigned __int8 uu1[8];
  char v47;
  _BYTE buf[12];
  __int16 v49;
  unsigned __int8 *v50;
  __int16 v51;
  __CFString *v52;
  __int16 v53;
  _BYTE v54[18];
  __int16 v55;
  id v56;

  v38 = a3;
  v7 = a4;
  v43[0] = 0;
  v43[1] = 0;
  sub_10003415C((uint64_t)v43, a1 + 16);
  v8 = qword_100999908;
  if (os_log_type_enabled((os_log_t)qword_100999908, OS_LOG_TYPE_DEFAULT))
  {
    v9 = uu1;
    sub_1000340DC(a2, (uint64_t)uu1);
    if (v47 < 0)
      v9 = *(unsigned __int8 **)uu1;
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "clientBundleID"));
    if (v10)
      v11 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "clientBundleID"));
    else
      v11 = CFSTR("NoClientBundleID");
    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "clientProcessID"));
    if (v12)
      v13 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "clientProcessID"));
    else
      v13 = CFSTR("NoClientProcessID");
    v14 = objc_msgSend(v7, "connectionUseCase");
    v15 = objc_msgSend(v7, "maxAllowedConnectionDelay");
    *(_DWORD *)buf = 138544642;
    *(_QWORD *)&buf[4] = v38;
    v49 = 2082;
    v50 = v9;
    v51 = 2114;
    v52 = v11;
    v53 = 2112;
    *(_QWORD *)v54 = v13;
    *(_WORD *)&v54[8] = 2048;
    *(_QWORD *)&v54[10] = v14;
    v55 = 2048;
    v56 = v15;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Connect Requested for device %{public}@ by session %{public}s with options clientBundleID %{public}@ clientProcessID %@ connectionUseCase %ld maxAllowedConnectionDelay %ld", buf, 0x3Eu);
    if (v12)

    if (v10)
    if (v47 < 0)
      operator delete(*(void **)uu1);
  }
  v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "clientBundleID"));
  v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "clientProcessID"));
  v18 = sub_1006C0678(a2, v16, v17, (uint64_t)objc_msgSend(v7, "connectionUseCase"));

  v20 = v18 == 15 || v18 == 1;
  sub_100030BCC(buf, v38);
  v21 = (uint64_t **)(a1 + 128);
  *(_QWORD *)uu1 = buf;
  v22 = +[NSMutableSet setWithSet:](NSMutableSet, "setWithSet:", sub_1006C1D64((uint64_t **)(a1 + 128), buf, (uint64_t)&unk_100740F58, (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)uu1)[6]);
  v23 = (void *)objc_claimAutoreleasedReturnValue(v22);
  v24 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "connectingClients"));
  v25 = v24 == 0;

  if (v25)
  {
    sub_1000340DC(a2, (uint64_t)buf);
    if (v51 >= 0)
      v30 = buf;
    else
      v30 = *(_BYTE **)buf;
    v31 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v30));
    objc_msgSend(v23, "addObject:", v31);

    if (SHIBYTE(v51) < 0)
      operator delete(*(void **)buf);
  }
  else
  {
    v41 = 0u;
    v42 = 0u;
    v39 = 0u;
    v40 = 0u;
    v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "connectingClients"));
    v27 = objc_msgSend(v26, "countByEnumeratingWithState:objects:count:", &v39, v45, 16);
    if (v27)
    {
      v28 = *(_QWORD *)v40;
      do
      {
        for (i = 0; i != v27; i = (char *)i + 1)
        {
          if (*(_QWORD *)v40 != v28)
            objc_enumerationMutation(v26);
          objc_msgSend(v23, "addObject:", *(_QWORD *)(*((_QWORD *)&v39 + 1) + 8 * (_QWORD)i));
        }
        v27 = objc_msgSend(v26, "countByEnumeratingWithState:objects:count:", &v39, v45, 16);
      }
      while (v27);
    }

  }
  sub_100030BCC(buf, v38);
  *(_QWORD *)uu1 = buf;
  v32 = sub_1006C1D64(v21, buf, (uint64_t)&unk_100740F58, (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)uu1);
  objc_storeStrong((id *)v32 + 6, v23);
  v33 = qword_100999908;
  if (os_log_type_enabled((os_log_t)qword_100999908, OS_LOG_TYPE_DEFAULT))
  {
    v34 = (unsigned __int8 *)objc_msgSend(v7, "connectionUseCase");
    if (v20)
      v35 = 5;
    else
      v35 = 0;
    sub_100030BCC(uu1, v38);
    v44 = uu1;
    v36 = (void *)sub_1006C1D64(v21, uu1, (uint64_t)&unk_100740F58, (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)&v44)[6];
    *(_DWORD *)buf = 138544386;
    *(_QWORD *)&buf[4] = v38;
    v49 = 2048;
    v50 = v34;
    v51 = 2048;
    v52 = (__CFString *)v18;
    v53 = 1024;
    *(_DWORD *)v54 = v35;
    *(_WORD *)&v54[4] = 2114;
    *(_QWORD *)&v54[6] = v36;
    v37 = v36;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "Device %{public}@ connectionUseCase (req %ld computed %ld) priority %hhu bundleIDs %{public}@", buf, 0x30u);

  }
  sub_100034234((uint64_t)v43);

}

void sub_1006C0D8C(_Unwind_Exception *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  uint64_t v16;
  va_list va;

  va_start(va, a12);

  if (v13)
  if (*(char *)(v16 - 177) < 0)
    operator delete(*(void **)(v16 - 200));
  sub_100034234((uint64_t)va);

  _Unwind_Resume(a1);
}

void sub_1006C0E84(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v7;
  uint64_t **v8;
  NSMutableSet *v9;
  void *v10;
  void *v11;
  void *v12;
  id v13;
  uint64_t v14;
  void *i;
  _BYTE *v16;
  void *v17;
  uint64_t *v18;
  NSObject *v19;
  id v20;
  void *v21;
  id v22;
  void *v23;
  int v24;
  _BYTE *v25;
  NSStringEncoding v26;
  _BYTE *v27;
  void *v28;
  void *v29;
  int v30;
  _BYTE *v31;
  NSStringEncoding v32;
  _BYTE *v33;
  void *v34;
  id v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  _QWORD v40[2];
  unsigned __int8 *v41;
  unsigned __int8 uu1[8];
  _BYTE __p[12];
  __int16 v44;
  id v45;
  __int16 v46;
  void *v47;
  _BYTE v48[128];

  v7 = a3;
  v35 = a4;
  v40[0] = 0;
  v40[1] = 0;
  sub_10003415C((uint64_t)v40, a1 + 16);
  sub_100030BCC(__p, v7);
  v8 = (uint64_t **)(a1 + 128);
  *(_QWORD *)uu1 = __p;
  v9 = +[NSMutableSet setWithSet:](NSMutableSet, "setWithSet:", sub_1006C1D64((uint64_t **)(a1 + 128), __p, (uint64_t)&unk_100740F58, (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)uu1)[6]);
  v10 = (void *)objc_claimAutoreleasedReturnValue(v9);
  v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v35, "connectingClients"));
  LODWORD(a4) = v11 == 0;

  if ((_DWORD)a4)
  {
    sub_1000340DC(a2, (uint64_t)__p);
    if (v46 >= 0)
      v16 = __p;
    else
      v16 = *(_BYTE **)__p;
    v17 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v16));
    objc_msgSend(v10, "removeObject:", v17);

    if (SHIBYTE(v46) < 0)
      operator delete(*(void **)__p);
  }
  else
  {
    v38 = 0u;
    v39 = 0u;
    v36 = 0u;
    v37 = 0u;
    v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v35, "connectingClients"));
    v13 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v36, v48, 16);
    if (v13)
    {
      v14 = *(_QWORD *)v37;
      do
      {
        for (i = 0; i != v13; i = (char *)i + 1)
        {
          if (*(_QWORD *)v37 != v14)
            objc_enumerationMutation(v12);
          objc_msgSend(v10, "removeObject:", *(_QWORD *)(*((_QWORD *)&v36 + 1) + 8 * (_QWORD)i));
        }
        v13 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v36, v48, 16);
      }
      while (v13);
    }

  }
  if (objc_msgSend(v10, "count"))
  {
    sub_100030BCC(__p, v7);
    *(_QWORD *)uu1 = __p;
    v18 = sub_1006C1D64(v8, __p, (uint64_t)&unk_100740F58, (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)uu1);
    objc_storeStrong((id *)v18 + 6, v10);
  }
  v19 = qword_100999908;
  if (os_log_type_enabled((os_log_t)qword_100999908, OS_LOG_TYPE_DEFAULT))
  {
    v20 = objc_msgSend(v35, "connectionUseCase");
    sub_100030BCC(uu1, v7);
    v41 = uu1;
    v21 = (void *)sub_1006C1D64(v8, uu1, (uint64_t)&unk_100740F58, (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)&v41)[6];
    *(_DWORD *)__p = 138543874;
    *(_QWORD *)&__p[4] = v7;
    v44 = 2048;
    v45 = v20;
    v46 = 2114;
    v47 = v21;
    v22 = v21;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Device %{public}@ connectionUseCase (req %ld) bundleIDs %{public}@", __p, 0x20u);

  }
  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_1009408B0);
  v23 = off_1009778C0;
  sub_1000340DC(a2, (uint64_t)__p);
  v24 = SHIBYTE(v46);
  v25 = *(_BYTE **)__p;
  v26 = +[NSString defaultCStringEncoding](NSString, "defaultCStringEncoding");
  if (v24 >= 0)
    v27 = __p;
  else
    v27 = v25;
  v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithCString:encoding:](NSString, "stringWithCString:encoding:", v27, v26));
  sub_10065C588((uint64_t)v23, v7, v28);

  if (SHIBYTE(v46) < 0)
    operator delete(*(void **)__p);
  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_1009408B0);
  v29 = off_1009778C0;
  sub_1000340DC(a2, (uint64_t)__p);
  v30 = SHIBYTE(v46);
  v31 = *(_BYTE **)__p;
  v32 = +[NSString defaultCStringEncoding](NSString, "defaultCStringEncoding");
  if (v30 >= 0)
    v33 = __p;
  else
    v33 = v31;
  v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithCString:encoding:](NSString, "stringWithCString:encoding:", v33, v32));
  sub_10065C38C((uint64_t)v29, v7, v34);

  if (SHIBYTE(v46) < 0)
    operator delete(*(void **)__p);

  sub_100034234((uint64_t)v40);
}

void sub_1006C12AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  void *v30;
  void *v31;
  void *v32;

  if (a30 < 0)
    operator delete(__p);

  sub_100034234((uint64_t)&a19);
  _Unwind_Resume(a1);
}

void sub_1006C135C(uint64_t a1, void *a2, uint64_t a3)
{
  id v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  BOOL v9;
  _QWORD v10[2];
  id v11;
  id *v12[2];

  v5 = a2;
  v10[1] = 0;
  v11 = v5;
  v10[0] = 0;
  sub_10003415C((uint64_t)v10, a1 + 16);
  v6 = *(_QWORD **)(a1 + 104);
  if (v6 != (_QWORD *)(a1 + 112))
  {
    while (!objc_msgSend(v5, "isEqual:", v6[4]))
    {
      v7 = (_QWORD *)v6[1];
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = (_QWORD *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (_QWORD *)v6[2];
          v9 = *v8 == (_QWORD)v6;
          v6 = v8;
        }
        while (!v9);
      }
      v6 = v8;
      if (v8 == (_QWORD *)(a1 + 112))
        goto LABEL_11;
    }
    sub_1002F6C4C((uint64_t **)(a1 + 104), (uint64_t)v6);
  }
LABEL_11:
  if (a3)
  {
    v12[0] = &v11;
    sub_10040FDE8((uint64_t **)(a1 + 104), (unint64_t *)&v11, (uint64_t)&unk_100740F58, v12)[5] = a3;
  }
  else
  {
    sub_100030BCC(v12, v5);
    sub_1006C1F3C((uint64_t **)(a1 + 128), (unsigned __int8 *)v12);
  }
  sub_100034234((uint64_t)v10);

}

void sub_1006C14A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, id a12)
{
  sub_100034234((uint64_t)&a10);

  _Unwind_Resume(a1);
}

void sub_1006C14D8(_QWORD *a1)
{
  NSObject *v2;
  uint64_t v3;
  _QWORD *v4;
  unsigned int v5;
  int v6;
  uint64_t v7;
  _QWORD *v8;
  unsigned int v9;
  BOOL v10;
  uint64_t *v11;
  BOOL v12;
  const char *v13;
  _QWORD *v14;
  unint64_t v15;
  const char *v16;
  uint64_t v17;
  int v18;
  _QWORD *v19;
  _QWORD *v20;
  const unsigned __int8 *v21;
  uint64_t v22;
  id v23;
  id v24;
  uint64_t v25;
  void *i;
  const char *v27;
  size_t v28;
  _QWORD *v29;
  NSObject *v30;
  int v31;
  void **v32;
  void **v33;
  char *v34;
  unsigned __int8 *v35;
  const unsigned __int8 **v36;
  uint64_t v37;
  uint64_t v38;
  void *__p[2];
  char v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  uint8_t v45[4];
  void **v46;
  __int16 v47;
  char *v48;
  _BYTE v49[128];
  uint8_t buf[32];
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  _BYTE v57[144];
  uint64_t v58;
  uuid_string_t out;

  v2 = qword_100999908;
  if (os_log_type_enabled((os_log_t)qword_100999908, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: ------------------ BT Resource Manager -------------------", buf, 2u);
    v2 = qword_100999908;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: Max Connections for use case:", buf, 2u);
    v2 = qword_100999908;
  }
  v3 = 0;
  v4 = a1 + 11;
  do
  {
    v5 = dword_10097BA08[v3];
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      v6 = sub_1006C00E8((uint64_t)a1, v5);
      v7 = a1[11];
      if (!v7)
        goto LABEL_18;
      v8 = a1 + 11;
      do
      {
        v9 = *(_DWORD *)(v7 + 28);
        v10 = v9 >= v5;
        if (v9 >= v5)
          v11 = (uint64_t *)v7;
        else
          v11 = (uint64_t *)(v7 + 8);
        if (v10)
          v8 = (_QWORD *)v7;
        v7 = *v11;
      }
      while (*v11);
      if (v8 == v4 || v5 < *((_DWORD *)v8 + 7))
LABEL_18:
        v8 = a1 + 11;
      v12 = v8 == v4;
      *(_DWORD *)buf = 67109634;
      v13 = "YES";
      if (v12)
        v13 = "NO";
      *(_DWORD *)&buf[4] = v5;
      *(_WORD *)&buf[8] = 1024;
      *(_DWORD *)&buf[10] = v6;
      *(_WORD *)&buf[14] = 2082;
      *(_QWORD *)&buf[16] = v13;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump:  useCase:%d maxConnections:%d (override:%{public}s)", buf, 0x18u);
      v2 = qword_100999908;
    }
    ++v3;
  }
  while (v3 != 9);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: current device states and use cases:", buf, 2u);
    v2 = qword_100999908;
  }
  v14 = (_QWORD *)a1[13];
  if (v14 != a1 + 14)
  {
    do
    {
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
        v15 = v14[5];
        v16 = "unknown";
        if (v15 <= 3)
          v16 = off_1009408D0[v15];
        v17 = v14[4];
        if (qword_1009778C8 != -1)
          dispatch_once(&qword_1009778C8, &stru_1009408B0);
        v18 = sub_1006589A8((uint64_t)off_1009778C0, (void *)v14[4]);
        *(_DWORD *)buf = 138543874;
        *(_QWORD *)&buf[4] = v17;
        *(_WORD *)&buf[12] = 2082;
        *(_QWORD *)&buf[14] = v16;
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&buf[24] = v18;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump:  device:%{public}@ state:%{public}s usecase:%u", buf, 0x1Cu);
        v2 = qword_100999908;
      }
      v19 = (_QWORD *)v14[1];
      if (v19)
      {
        do
        {
          v20 = v19;
          v19 = (_QWORD *)*v19;
        }
        while (v19);
      }
      else
      {
        do
        {
          v20 = (_QWORD *)v14[2];
          v12 = *v20 == (_QWORD)v14;
          v14 = v20;
        }
        while (!v12);
      }
      v14 = v20;
    }
    while (v20 != a1 + 14);
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: current device connect request bundleIDs:", buf, 2u);
  }
  v21 = (const unsigned __int8 *)a1[16];
  if (v21 != (const unsigned __int8 *)(a1 + 17))
  {
    do
    {
      v58 = 0;
      v56 = 0u;
      memset(v57, 0, sizeof(v57));
      v54 = 0u;
      v55 = 0u;
      v52 = 0u;
      v53 = 0u;
      v51 = 0u;
      memset(buf, 0, sizeof(buf));
      sub_1002613AC((uint64_t)buf);
      v43 = 0u;
      v44 = 0u;
      v41 = 0u;
      v42 = 0u;
      v23 = *((id *)v21 + 6);
      v24 = objc_msgSend(v23, "countByEnumeratingWithState:objects:count:", &v41, v49, 16);
      if (v24)
      {
        v25 = *(_QWORD *)v42;
        do
        {
          for (i = 0; i != v24; i = (char *)i + 1)
          {
            if (*(_QWORD *)v42 != v25)
              objc_enumerationMutation(v23);
            v27 = (const char *)objc_msgSend(objc_retainAutorelease(*(id *)(*((_QWORD *)&v41 + 1) + 8 * (_QWORD)i)), "UTF8String");
            v28 = strlen(v27);
            v29 = sub_1002614D8(&buf[16], (uint64_t)v27, v28);
            sub_1002614D8(v29, (uint64_t)",", 1);
          }
          v24 = objc_msgSend(v23, "countByEnumeratingWithState:objects:count:", &v41, v49, 16);
        }
        while (v24);
      }

      v30 = qword_100999908;
      if (os_log_type_enabled((os_log_t)qword_100999908, OS_LOG_TYPE_DEFAULT))
      {
        memset(out, 0, sizeof(out));
        uuid_unparse_upper(v21 + 32, out);
        sub_100091AE8(__p, out);
        v31 = v40;
        v32 = (void **)__p[0];
        std::stringbuf::str(&buf[24]);
        v33 = __p;
        if (v31 < 0)
          v33 = v32;
        v34 = out;
        if (out[23] < 0)
          v34 = *(char **)out;
        *(_DWORD *)v45 = 136446466;
        v46 = v33;
        v47 = 2082;
        v48 = v34;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "statedump:  device:%{public}s connectRequestBundleIDs:%{public}s", v45, 0x16u);
        if (out[23] < 0)
          operator delete(*(void **)out);
        if (v40 < 0)
          operator delete(__p[0]);
      }
      *(_QWORD *)buf = v22;
      *(_QWORD *)&buf[*(_QWORD *)(v22 - 24)] = v38;
      *(_QWORD *)&buf[16] = v37;
      if (SHIBYTE(v55) < 0)
        operator delete(*((void **)&v54 + 1));
      std::streambuf::~streambuf(&buf[24]);
      std::ios::~ios(v57);
      v35 = (unsigned __int8 *)*((_QWORD *)v21 + 1);
      if (v35)
      {
        do
        {
          v36 = (const unsigned __int8 **)v35;
          v35 = *(unsigned __int8 **)v35;
        }
        while (v35);
      }
      else
      {
        do
        {
          v36 = (const unsigned __int8 **)*((_QWORD *)v21 + 2);
          v12 = *v36 == v21;
          v21 = (const unsigned __int8 *)v36;
        }
        while (!v12);
      }
      v21 = (const unsigned __int8 *)v36;
    }
    while (v36 != a1 + 17);
  }
}

void sub_1006C1B18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,char a54)
{
  if (a25 < 0)
    operator delete(__p);
  sub_1006CC5C8((uint64_t)&a54);
  _Unwind_Resume(a1);
}

id sub_1006C1B60(uint64_t a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  _QWORD v7[2];
  unsigned __int8 *v8;
  unsigned __int8 uu2[16];

  v3 = a2;
  v7[0] = 0;
  v7[1] = 0;
  sub_10003415C((uint64_t)v7, a1 + 16);
  sub_100030BCC(uu2, v3);
  if (a1 + 136 == sub_10000C5B8(a1 + 128, uu2))
  {
    v4 = (id)objc_claimAutoreleasedReturnValue(+[NSSet setWithObject:](NSSet, "setWithObject:", CFSTR("com.unknown")));
  }
  else
  {
    sub_100030BCC(uu2, v3);
    v8 = uu2;
    v4 = (id)sub_1006C1D64((uint64_t **)(a1 + 128), uu2, (uint64_t)&unk_100740F58, (const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *)&v8)[6];
  }
  v5 = v4;
  sub_100034234((uint64_t)v7);

  return v5;
}

void sub_1006C1C60(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  va_list va;

  va_start(va, a2);
  sub_100034234((uint64_t)va);

  _Unwind_Resume(a1);
}

void sub_1006C1C94(uint64_t a1)
{
  sub_1006C1FB8(a1);
  operator delete();
}

void sub_1006C1CB8(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    sub_1006C1CB8(a1, *a2);
    sub_1006C1CB8(a1, a2[1]);

    operator delete(a2);
  }
}

void sub_1006C1D00(id a1)
{
  operator new();
}

void sub_1006C1D40()
{
  operator delete();
}

uint64_t *sub_1006C1D64(uint64_t **a1, unsigned __int8 *uu1, uint64_t a3, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a4)
{
  uint64_t **v6;
  uint64_t *result;
  unsigned __int8 *v8[3];
  uint64_t v9;

  v9 = 0;
  v6 = (uint64_t **)sub_10000DC28((uint64_t)a1, &v9, uu1);
  result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_1006C1E04((uint64_t)a1, a4, v8);
    sub_100004078(a1, v9, v6, (uint64_t *)v8[0]);
    return (uint64_t *)v8[0];
  }
  return result;
}

void sub_1006C1E04(uint64_t a1@<X0>, const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) *a2@<X2>, unsigned __int8 **a3@<X8>)
{
  uint64_t v5;
  _QWORD *v6;
  unsigned __int8 *v7;

  v5 = a1 + 8;
  *a3 = 0;
  a3[2] = 0;
  a3[1] = 0;
  v6 = a3 + 1;
  v7 = (unsigned __int8 *)operator new(0x38uLL);
  *a3 = v7;
  *v6 = v5;
  *((_BYTE *)a3 + 16) = 0;
  uuid_copy(v7 + 32, *a2);
  *((_QWORD *)v7 + 6) = 0;
  *((_BYTE *)a3 + 16) = 1;
}

void sub_1006C1E78(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;
  id *v3;

  *v1 = 0;
  sub_1006C1E94(v2, v3);
  _Unwind_Resume(a1);
}

void sub_1006C1E94(uint64_t a1, id *a2)
{
  if (*(_BYTE *)(a1 + 8))
  {

  }
  else if (!a2)
  {
    return;
  }
  operator delete(a2);
}

void sub_1006C1ED8(id a1)
{
  operator new();
}

void sub_1006C1F18()
{
  operator delete();
}

uint64_t sub_1006C1F3C(uint64_t **a1, unsigned __int8 *a2)
{
  uint64_t v3;

  v3 = sub_10000C5B8((uint64_t)a1, a2);
  if (a1 + 1 == (uint64_t **)v3)
    return 0;
  sub_1006C1F80(a1, v3);
  return 1;
}

uint64_t *sub_1006C1F80(uint64_t **a1, uint64_t a2)
{
  uint64_t *v3;

  v3 = sub_1000040CC(a1, (uint64_t *)a2);

  operator delete((void *)a2);
  return v3;
}

uint64_t sub_1006C1FB8(uint64_t a1)
{
  *(_QWORD *)a1 = &off_100940880;
  sub_1006C1CB8(a1 + 128, *(_QWORD **)(a1 + 136));
  sub_100010D8C(a1 + 104, *(_QWORD **)(a1 + 112));
  sub_10001A82C(a1 + 80, *(_QWORD **)(a1 + 88));
  sub_100069BDC(a1 + 16);
  return a1;
}

_QWORD *sub_1006C200C(_QWORD *a1)
{
  _QWORD *v2;
  CFPropertyListRef v3;
  void *v4;

  v2 = sub_10056FCC4(a1);
  *((_DWORD *)v2 + 4) = 0;
  *((_WORD *)v2 + 10) = 0;
  if (sub_1006C20A4((int)v2, "bluetooth", (uint64_t)(v2 + 2)))
  {
    sub_1006C221C((uint64_t)a1);
  }
  else
  {
    v3 = sub_1006C248C();
    v4 = (void *)objc_claimAutoreleasedReturnValue(v3);

    if (v4)
    {
      CFPreferencesSetAppValue(CFSTR("GeneratedLocalAddress"), 0, CFSTR("com.apple.BTServer"));
      CFPreferencesAppSynchronize(CFSTR("com.apple.BTServer"));
    }
  }
  return a1;
}

void sub_1006C2090(_Unwind_Exception *a1)
{
  uint64_t *v1;

  sub_10056FCCC(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1006C20A4(int a1, char *name, uint64_t a3)
{
  const __CFDictionary *v4;
  io_service_t MatchingService;
  io_object_t v6;
  uint64_t v7;
  const __CFData *v8;
  const __CFData *v9;
  NSObject *v10;
  UInt8 buffer[4];
  __int16 v13;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  UInt8 *v19;
  CFRange v20;

  v4 = IOServiceNameMatching(name);
  if (!v4)
    return 1;
  MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v4);
  if (!MatchingService)
    return 1;
  v6 = MatchingService;
  v13 = 0;
  *(_DWORD *)buffer = 0;
  v7 = 1;
  v8 = (const __CFData *)IORegistryEntrySearchCFProperty(MatchingService, "IODeviceTree", CFSTR("local-mac-address"), kCFAllocatorDefault, 1u);
  if (v8)
  {
    v9 = v8;
    v20.location = 0;
    v20.length = 6;
    CFDataGetBytes(v8, v20, buffer);
    *(_DWORD *)a3 = *(_DWORD *)buffer;
    *(_WORD *)(a3 + 4) = v13;
    v10 = qword_100999980;
    if (os_log_type_enabled((os_log_t)qword_100999980, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      v15 = "getAddressFrom";
      v16 = 1040;
      v17 = 6;
      v18 = 2096;
      v19 = buffer;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%s: DeviceTree address = %{bluetooth:BD_ADDR}.6P", buf, 0x1Cu);
    }
    CFRelease(v9);
    v7 = 0;
  }
  IOObjectRelease(v6);
  return v7;
}

void sub_1006C221C(uint64_t a1)
{
  CFPropertyListRef v2;
  void *v3;
  void *v4;
  id v5;
  NSObject *v6;
  char *v7;
  uint64_t i;
  void *v9;
  NSObject *v10;
  int v11;
  __int16 v12;
  char __str[8];
  uint64_t v14;
  __int16 v15;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  char *v19;

  v12 = 0;
  v11 = 0;
  v2 = sub_1006C248C();
  v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  v4 = v3;
  if (v3 && objc_msgSend(v3, "length"))
  {
    v5 = objc_retainAutorelease(v4);
    sscanf((const char *)objc_msgSend(v5, "UTF8String"), "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx", &v11, (char *)&v11 + 1, (char *)&v11 + 2, (char *)&v11 + 3, &v12, (char *)&v12 + 1);
    v6 = (id)qword_100999980;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v7 = (char *)objc_msgSend(objc_retainAutorelease(v5), "UTF8String");
      *(_DWORD *)buf = 136315394;
      v17 = "getGeneratedLocalAddress";
      v18 = 2080;
      v19 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%s Local address from plist:%s.\n", buf, 0x16u);
    }

  }
  else
  {
    for (i = 0; i != 6; ++i)
      *((_BYTE *)&v11 + i) = arc4random_uniform(0xFFu);
    *(_QWORD *)__str = 0;
    v14 = 0;
    v15 = 0;
    snprintf(__str, 0x12uLL, "%02x:%02x:%02x:%02x:%02x:%02x", v11, BYTE1(v11), BYTE2(v11), HIBYTE(v11), v12, HIBYTE(v12));
    v9 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", __str));
    sub_1006C24B4((uint64_t)v9, v9);

    v10 = qword_100999980;
    if (os_log_type_enabled((os_log_t)qword_100999980, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315394;
      v17 = "getGeneratedLocalAddress";
      v18 = 2080;
      v19 = __str;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%s Storing local address to plist:%s.\n", buf, 0x16u);
    }
  }
  *(_DWORD *)(a1 + 16) = v11;
  *(_WORD *)(a1 + 20) = v12;

}

void sub_1006C2454(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

CFPropertyListRef sub_1006C248C()
{
  return (id)CFPreferencesCopyAppValue(CFSTR("GeneratedLocalAddress"), CFSTR("com.apple.BTServer"));
}

void sub_1006C24B4(uint64_t a1, void *a2)
{
  id v2;

  v2 = a2;
  CFPreferencesSetAppValue(CFSTR("GeneratedLocalAddress"), v2, CFSTR("com.apple.BTServer"));
  CFPreferencesAppSynchronize(CFSTR("com.apple.BTServer"));

}

void sub_1006C2504(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

uint64_t sub_1006C2518()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v9;
  const char *v10;

  v0 = qword_100999980;
  if (os_log_type_enabled((os_log_t)qword_100999980, OS_LOG_TYPE_DEFAULT))
  {
    v9 = 136315138;
    v10 = "registerCallbacks";
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "%s", (uint8_t *)&v9, 0xCu);
  }
  return sub_10023FF2C((uint64_t)off_10097BA30, v1, v2, v3, v4, v5, v6, v7);
}

BOOL sub_1006C25C8(uint64_t *a1, _DWORD *a2, uint64_t *a3)
{
  NSObject *v6;
  _BOOL8 v7;
  _BOOL4 v8;
  NSObject *v9;
  _BOOL4 v10;
  int v12;
  const char *v13;

  v6 = qword_100999980;
  if (os_log_type_enabled((os_log_t)qword_100999980, OS_LOG_TYPE_DEFAULT))
  {
    v12 = 136315138;
    v13 = "TransportCreate";
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%s", (uint8_t *)&v12, 0xCu);
  }
  v7 = sub_10056FDF0(a1, a2, a3);
  if (v7)
  {
    v8 = sub_10056FD14(a1, *a3);
    v9 = qword_100999980;
    v10 = os_log_type_enabled((os_log_t)qword_100999980, OS_LOG_TYPE_DEFAULT);
    if (v8)
    {
      if (v10)
      {
        v12 = 136315138;
        v13 = "TransportCreate";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%s: Link Controller, activate", (uint8_t *)&v12, 0xCu);
      }
      if (qword_10097B498 != -1)
        dispatch_once(&qword_10097B498, &stru_100940908);
      sub_1004115B0((id *)qword_10097B490);
    }
    else if (v10)
    {
      v12 = 136315138;
      v13 = "TransportCreate";
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%s: Not Hci Transport Command", (uint8_t *)&v12, 0xCu);
    }
  }
  return v7;
}

uint64_t sub_1006C2780(uint64_t *a1, uint64_t *a2)
{
  _BOOL4 v4;
  NSObject *v5;
  _BOOL4 v6;
  int v8;
  const char *v9;

  v4 = sub_10056FD14(a1, *a2);
  v5 = qword_100999980;
  v6 = os_log_type_enabled((os_log_t)qword_100999980, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (v6)
    {
      v8 = 136315138;
      v9 = "TransportFree";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%s: Link Controller Invalidate", (uint8_t *)&v8, 0xCu);
    }
    if (qword_10097B498 != -1)
      dispatch_once(&qword_10097B498, &stru_100940908);
    sub_1004119AC((id *)qword_10097B490);
  }
  else if (v6)
  {
    v8 = 136315138;
    v9 = "TransportFree";
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%s: Invalidate Link Controller faile, invalid handle", (uint8_t *)&v8, 0xCu);
  }
  return sub_100570058(a1, a2);
}

uint64_t sub_1006C28C8(uint64_t a1)
{
  if (qword_10097B488 != -1)
    dispatch_once(&qword_10097B488, &stru_100940928);
  return nullsub_90(off_10097B480, a1);
}

BOOL sub_1006C2918(_DWORD *a1, uint64_t *a2)
{
  if (qword_10097B488 != -1)
    dispatch_once(&qword_10097B488, &stru_100940928);
  return sub_1006C25C8((uint64_t *)off_10097B480, a1, a2);
}

uint64_t sub_1006C2970(uint64_t *a1)
{
  if (qword_10097B488 != -1)
    dispatch_once(&qword_10097B488, &stru_100940928);
  return sub_1006C2780((uint64_t *)off_10097B480, a1);
}

uint64_t sub_1006C29C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (qword_10097B488 != -1)
    dispatch_once(&qword_10097B488, &stru_100940928);
  return sub_100570230(off_10097B480, a1, a2, a3, a4, a5, a6);
}

BOOL sub_1006C2A48(uint64_t a1)
{
  if (qword_10097B488 != -1)
    dispatch_once(&qword_10097B488, &stru_100940928);
  return sub_1005702B8(off_10097B480, a1);
}

void sub_1006C2A98(id a1)
{
  operator new();
}

void sub_1006C2AD8()
{
  operator delete();
}

void sub_1006C2AFC(id a1)
{
  operator new();
}

void sub_1006C2B3C()
{
  operator delete();
}

void sub_1006C2C44(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id sub_1006C2C64(uint64_t a1, void *a2)
{
  NSObject *v3;
  uint8_t v5[16];

  v3 = qword_100999888;
  if (os_log_type_enabled((os_log_t)qword_100999888, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Received 'favorites changed' notification", v5, 2u);
  }
  objc_msgSend(a2, "_incrementPrimaryFolderVersionForAddressBook:", 8);
  return objc_msgSend(a2, "_incrementSecondaryFolderVersionForAddressBook:", 8);
}

void sub_1006C2E40(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1006C2FD0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1006C3158(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1006C32F0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1006C3470(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1006C3668(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1006C3800(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1006C3880(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1006C3950(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

_QWORD *sub_1006C39D8(_QWORD *a1)
{
  AddressBookObserver *v2;
  void *v3;

  *a1 = off_100940958;
  a1[1] = 0;
  v2 = objc_alloc_init(AddressBookObserver);
  v3 = (void *)a1[1];
  a1[1] = v2;

  return a1;
}

void sub_1006C3A1C(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

id sub_1006C3A34(uint64_t a1, uint64_t a2)
{
  return objc_msgSend(*(id *)(a1 + 8), "getPrimaryFolderVersionForAddressBook:", a2);
}

id sub_1006C3A40(uint64_t a1, uint64_t a2)
{
  return objc_msgSend(*(id *)(a1 + 8), "getSecondaryFolderVersionForAddressBook:", a2);
}

id sub_1006C3A4C(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 8), "getDatabaseIdentifier");
}

id sub_1006C3A54(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 8), "incrementMainAddressBookVersions");
}

uint64_t sub_1006C3A5C(uint64_t a1)
{

  return a1;
}

void sub_1006C3A84(uint64_t a1)
{

  operator delete();
}

uint64_t sub_1006C3ABC(uint64_t a1)
{
  uint64_t v2;
  int v3;
  int v4;
  NSObject *v5;
  _xpc_connection_s *mach_service;
  uint64_t v7;
  int v8;
  int v10;
  _QWORD handler[5];
  void *__p[2];
  char v13;
  uint8_t buf[8];
  char v15;
  char v16;

  *(_QWORD *)a1 = off_1009409D0;
  *(_QWORD *)(a1 + 8) = &off_100940AE0;
  *(_QWORD *)(a1 + 16) = off_100940AF8;
  *(_QWORD *)(a1 + 24) = &off_100940B60;
  *(_QWORD *)(a1 + 32) = off_100940B78;
  *(_QWORD *)(a1 + 40) = off_100940C28;
  *(_QWORD *)(a1 + 48) = &off_100940C78;
  *(_QWORD *)(a1 + 56) = &off_100940C90;
  *(_QWORD *)(a1 + 64) = off_100940CA8;
  *(_QWORD *)(a1 + 72) = off_100940D08;
  sub_1000160D0(a1 + 80);
  *(_OWORD *)(a1 + 168) = 0u;
  *(_QWORD *)(a1 + 336) = 0;
  *(_BYTE *)(a1 + 280) = 0;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 263) = 0u;
  *(_QWORD *)(a1 + 328) = a1 + 336;
  *(_QWORD *)(a1 + 360) = 0;
  *(_QWORD *)(a1 + 368) = 0;
  *(_QWORD *)(a1 + 344) = 0;
  *(_QWORD *)(a1 + 352) = a1 + 360;
  *(_QWORD *)(a1 + 376) = a1 + 384;
  *(_QWORD *)(a1 + 384) = 0;
  *(_QWORD *)(a1 + 408) = 0;
  *(_QWORD *)(a1 + 416) = 0;
  *(_QWORD *)(a1 + 392) = 0;
  *(_QWORD *)(a1 + 400) = a1 + 408;
  *(_QWORD *)(a1 + 432) = 0;
  *(_QWORD *)(a1 + 440) = 0;
  *(_QWORD *)(a1 + 424) = a1 + 432;
  *(_BYTE *)(a1 + 448) = 0;
  *(_BYTE *)(a1 + 452) = 0;
  *(_DWORD *)(a1 + 456) = 0;
  *(_BYTE *)(a1 + 460) = 0;
  *(_DWORD *)(a1 + 464) = 0;
  *(_QWORD *)(a1 + 472) = 0;
  *(_DWORD *)(a1 + 480) = 0;
  *(_QWORD *)(a1 + 496) = 0;
  *(_QWORD *)(a1 + 504) = 0;
  *(_QWORD *)(a1 + 488) = 0;
  v16 = 0;
  v2 = sub_100027F68();
  sub_100091AE8(buf, "CoexManager");
  sub_100091AE8(__p, "Disable");
  v3 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, char *))(*(_QWORD *)v2 + 72))(v2, buf, __p, &v16);
  if (v16)
    v4 = v3;
  else
    v4 = 0;
  if (v13 < 0)
    operator delete(__p[0]);
  if (v15 < 0)
  {
    operator delete(*(void **)buf);
    if (v4)
    {
LABEL_8:
      v5 = qword_1009997F0;
      if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Warning: Disabling WCM interface because of override default", buf, 2u);
      }
      return a1;
    }
  }
  else if (v4)
  {
    goto LABEL_8;
  }
  if (&WCMEnabled)
  {
    mach_service = xpc_connection_create_mach_service("com.apple.WirelessCoexManager", 0, 0);
    *(_QWORD *)(a1 + 144) = mach_service;
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472;
    handler[2] = sub_1000664D8;
    handler[3] = &unk_1009203A0;
    handler[4] = a1;
    xpc_connection_set_event_handler(mach_service, handler);
    xpc_connection_resume(*(xpc_connection_t *)(a1 + 144));
  }
  else if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
  {
    sub_10071BC20();
  }
  *(_BYTE *)(a1 + 154) = 0;
  v10 = 0;
  v7 = sub_100027F68();
  sub_100091AE8(buf, "BTUCM");
  sub_100091AE8(__p, "BTUCMForceFacetimeWifiCoexOverride");
  *(_BYTE *)(a1 + 154) = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(_QWORD *)v7 + 88))(v7, buf, __p, &v10);
  if (v13 < 0)
    operator delete(__p[0]);
  if (v15 < 0)
    operator delete(*(void **)buf);
  if (*(_BYTE *)(a1 + 154))
    v8 = v10;
  else
    v8 = 0;
  *(_DWORD *)(a1 + 156) = v8;
  *(_QWORD *)(a1 + 160) = 0;
  *(_BYTE *)(a1 + 452) = 0;
  *(_DWORD *)(a1 + 456) = 0;
  *(_BYTE *)(a1 + 460) = 0;
  *(_DWORD *)(a1 + 464) = 0;
  return a1;
}

void sub_1006C3DB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  void *v37;

  if (a21 < 0)
    operator delete(__p);
  if (a27 < 0)
    operator delete(a22);
  v31 = v29;
  v32 = v29 - 8;
  v33 = v31 + 16;
  v34 = v31 + 40;
  v35 = v31 + 64;
  v36 = v31 + 88;
  v37 = *(void **)(v31 + 152);
  if (v37)
  {
    *(_QWORD *)(v27 + 496) = v37;
    operator delete(v37);
  }

  sub_10001A82C(v36, *(_QWORD **)(v27 + 432));
  sub_10001A82C(v35, *(_QWORD **)(v27 + 408));
  sub_10001A82C(v34, *(_QWORD **)(v27 + 384));
  sub_10001A82C(v33, *(_QWORD **)(v27 + 360));
  sub_10001A82C(v32, *(_QWORD **)(v27 + 336));
  sub_100069BDC(v28);
  _Unwind_Resume(a1);
}

uint64_t sub_1006C3E7C(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = off_1009409D0;
  *(_QWORD *)(a1 + 8) = &off_100940AE0;
  *(_QWORD *)(a1 + 16) = off_100940AF8;
  *(_QWORD *)(a1 + 24) = &off_100940B60;
  *(_QWORD *)(a1 + 32) = off_100940B78;
  *(_QWORD *)(a1 + 40) = off_100940C28;
  *(_QWORD *)(a1 + 48) = &off_100940C78;
  *(_QWORD *)(a1 + 56) = &off_100940C90;
  *(_QWORD *)(a1 + 64) = off_100940CA8;
  *(_QWORD *)(a1 + 72) = off_100940D08;
  if (&WCMEnabled)
    xpc_release(*(xpc_object_t *)(a1 + 144));
  v2 = *(void **)(a1 + 488);
  if (v2)
  {
    *(_QWORD *)(a1 + 496) = v2;
    operator delete(v2);
  }

  sub_10001A82C(a1 + 424, *(_QWORD **)(a1 + 432));
  sub_10001A82C(a1 + 400, *(_QWORD **)(a1 + 408));
  sub_10001A82C(a1 + 376, *(_QWORD **)(a1 + 384));
  sub_10001A82C(a1 + 352, *(_QWORD **)(a1 + 360));
  sub_10001A82C(a1 + 328, *(_QWORD **)(a1 + 336));
  sub_100069BDC(a1 + 80);
  return a1;
}

void sub_1006C3F4C(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 488);
  if (v3)
  {
    *(_QWORD *)(v1 + 496) = v3;
    operator delete(v3);
  }

  sub_10001A82C(v1 + 424, *(_QWORD **)(v1 + 432));
  sub_10001A82C(v1 + 400, *(_QWORD **)(v1 + 408));
  sub_10001A82C(v1 + 376, *(_QWORD **)(v1 + 384));
  sub_10001A82C(v1 + 352, *(_QWORD **)(v1 + 360));
  sub_10001A82C(v1 + 328, *(_QWORD **)(v1 + 336));
  sub_100069BDC(v1 + 80);
  _Unwind_Resume(a1);
}

void sub_1006C3FB8(uint64_t a1)
{
  sub_1006C3E7C(a1);
  operator delete();
}

uint64_t sub_1006C3FDC(uint64_t a1, uint64_t a2)
{
  _QWORD v5[2];

  v5[0] = 0;
  v5[1] = 0;
  sub_10003415C((uint64_t)v5, a1 + 80);
  sub_1006C403C(a1 + 480, a2);
  return sub_100034234((uint64_t)v5);
}

void sub_1006C4028(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100034234((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_1006C403C(uint64_t a1, uint64_t a2)
{
  char *v4;
  char *v5;
  uint64_t v6;

  os_unfair_lock_lock((os_unfair_lock_t)a1);
  v5 = *(char **)(a1 + 8);
  v4 = *(char **)(a1 + 16);
  if (v5 != v4)
  {
    while (*(_QWORD *)v5 != a2)
    {
      v5 += 8;
      if (v5 == v4)
      {
        v5 = *(char **)(a1 + 16);
        break;
      }
    }
  }
  if (v5 == v4)
  {
    v6 = a2;
    sub_1006CBC1C(a1 + 8, v4, (char *)&v6);
    sub_10007AA30(a1 + 8);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

uint64_t sub_1006C40C4(uint64_t a1, uint64_t a2)
{
  _QWORD v5[2];

  v5[0] = 0;
  v5[1] = 0;
  sub_10003415C((uint64_t)v5, a1 + 80);
  sub_100069060(a1 + 480, a2);
  return sub_100034234((uint64_t)v5);
}

void sub_1006C4110(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100034234((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_1006C4124(uint64_t a1)
{
  uint64_t v2;
  __int128 v3;
  void *v4;
  uint64_t v5;
  _QWORD v6[5];

  if (&WCMEnabled)
  {
    sub_1006C43FC(a1);
    if (qword_100977A78 != -1)
      dispatch_once(&qword_100977A78, &stru_100940DB8);
    sub_100494088(off_100977A70, a1 + 8);
    if (qword_100978130 != -1)
      dispatch_once(&qword_100978130, &stru_100940DD8);
    sub_1002B4110((uint64_t)off_100978128 + 80, a1 + 24);
    if (qword_1009778A8 != -1)
      dispatch_once(&qword_1009778A8, &stru_100940DF8);
    sub_10061F358((uint64_t)off_1009778A0, a1 + 32, 0);
    if (qword_100977B40 != -1)
      dispatch_once(&qword_100977B40, &stru_100940E18);
    sub_1004B983C((uint64_t)off_100977B38, a1 + 40);
    v2 = sub_100038E50();
    sub_100260F7C(v2 + 288, a1 + 48);
    if (qword_10097ADB8 != -1)
      dispatch_once(&qword_10097ADB8, &stru_100940E38);
    sub_1004FD2A8(qword_10097ADB0, a1 + 56);
    if (qword_100977FB0 != -1)
      dispatch_once(&qword_100977FB0, &stru_100940E58);
    sub_1000B5218((uint64_t)off_100977FA8 + 1872, a1 + 64);
    if (qword_1009778E8 != -1)
      dispatch_once(&qword_1009778E8, &stru_100940E78);
    sub_10007A76C((uint64_t)off_1009778E0 + 240, a1 + 72);
    *(_QWORD *)&v3 = -1;
    *((_QWORD *)&v3 + 1) = -1;
    *(_OWORD *)(a1 + 248) = v3;
    *(_OWORD *)(a1 + 232) = v3;
    *(_OWORD *)(a1 + 216) = v3;
    *(_OWORD *)(a1 + 200) = v3;
    *(_OWORD *)(a1 + 184) = v3;
    *(_OWORD *)(a1 + 168) = v3;
    v4 = *(void **)(a1 + 472);
    *(_QWORD *)(a1 + 472) = CFSTR("XZ");

    if (qword_100977B40 != -1)
      dispatch_once(&qword_100977B40, &stru_100940E18);
    sub_1004BA124((uint64_t)off_100977B38, *(void **)(a1 + 472));
    *(_DWORD *)(a1 + 281) = 0;
    *(_OWORD *)(a1 + 288) = xmmword_1007436D0;
    *(_QWORD *)(a1 + 304) = 0;
    *(_QWORD *)(a1 + 312) = 0;
    *(_DWORD *)(a1 + 320) = 0;
    v5 = sub_10006BBEC();
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    v6[2] = sub_1006C44A0;
    v6[3] = &unk_100917378;
    v6[4] = a1;
    sub_100041A34(v5, v6);
    sub_1006C4540(a1);
    sub_1006C466C((uint32x2_t *)a1);
  }
  else if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
  {
    sub_10071BD30();
  }
}

void sub_1006C43FC(uint64_t a1)
{
  NSObject *v2;
  xpc_object_t v3;
  uint8_t v4[16];

  v2 = qword_1009997F0;
  if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Checking in with WCM", v4, 2u);
  }
  v3 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_uint64(v3, "kWCMRegisterProcess_ProcessId", 4uLL);
  sub_1006C4A48(a1, 1uLL, v3);
  xpc_release(v3);
}

uint64_t sub_1006C44A0(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t result;
  int v4;
  int v5;
  char v6;
  __int16 v7;
  __int16 v8;

  v1 = *(_QWORD *)(a1 + 32);
  v8 = 0;
  v7 = 0;
  v6 = 0;
  v5 = 0;
  v2 = sub_100038E50();
  result = (*(uint64_t (**)(uint64_t, char *, __int16 *, char *, __int16 *, char *, int *))(*(_QWORD *)v2 + 48))(v2, (char *)&v8 + 1, &v8, (char *)&v7 + 1, &v7, &v6, &v5);
  if (!(_DWORD)result)
  {
    *(_BYTE *)(v1 + 452) = v7;
    if (HIBYTE(v8))
    {
      v4 = 1;
    }
    else if ((_BYTE)v8)
    {
      v4 = 2;
    }
    else
    {
      if (!HIBYTE(v7))
      {
        *(_DWORD *)(v1 + 456) = 0;
        return result;
      }
      v4 = 3;
    }
    *(_DWORD *)(v1 + 456) = v4;
  }
  return result;
}

void sub_1006C4540(uint64_t a1)
{
  int v2;
  NSObject *v3;
  xpc_object_t v4;
  _DWORD v5[2];

  if (qword_100978130 != -1)
    dispatch_once(&qword_100978130, &stru_100940DD8);
  v2 = sub_10002527C((uint64_t)off_100978128);
  v3 = qword_1009997F0;
  if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_INFO))
  {
    v5[0] = 67109120;
    v5[1] = v2 == 1;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "SendLocalDeviceState with state %d", (uint8_t *)v5, 8u);
  }
  v4 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_uint64(v4, "kWCMBTLocalDeviceState", v2 == 1);
  sub_1006C4A48(a1, 0x1FAuLL, v4);
  xpc_release(v4);
}

uint64_t sub_1006C466C(uint32x2_t *a1)
{
  unsigned int v2;
  __int32 v3;
  __int32 v4;
  int v5;
  int v6;
  NSObject *v7;
  __int32 v8;
  __int32 v9;
  __int32 v10;
  uint32x2_t v11;
  uint32x2_t v12;
  xpc_object_t v13;
  _QWORD v15[2];
  uint8_t buf[4];
  int v17;
  __int16 v18;
  __int32 v19;
  __int16 v20;
  __int32 v21;
  __int16 v22;
  int v23;
  __int16 v24;
  unsigned int v25;
  __int16 v26;
  __int32 v27;
  __int16 v28;
  __int32 v29;
  __int16 v30;
  __int32 v31;
  __int16 v32;
  __int32 v33;
  __int16 v34;
  __int32 v35;

  v15[0] = 0;
  v15[1] = 0;
  sub_10003415C((uint64_t)v15, (uint64_t)&a1[10]);
  if (a1[35].i8[4])
    sub_1006CA77C(a1);
  v2 = a1[36].u32[0];
  v3 = a1[37].i32[0];
  v4 = a1[39].i32[1];
  if (v2 >= 0xFF)
    v5 = 255;
  else
    v5 = a1[36].i32[0];
  v6 = v4 | v3 | v5;
  if (a1[37].i32[1] != v6)
  {
    a1[37].i32[1] = v6;
    v7 = qword_1009997F0;
    if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
    {
      v8 = a1[38].i32[0];
      v9 = a1[38].i32[1];
      v10 = a1[39].i32[0];
      v11 = a1[46];
      v12 = a1[43];
      *(_DWORD *)buf = 67111424;
      v17 = v4 | v3 | v5;
      v18 = 1024;
      v19 = v3;
      v20 = 1024;
      v21 = v4;
      v22 = 1024;
      v23 = v5;
      v24 = 1024;
      v25 = v2;
      v26 = 1024;
      v27 = v8;
      v28 = 1024;
      v29 = v9;
      v30 = 1024;
      v31 = v10;
      v32 = 1024;
      v33 = v11.i32[0];
      v34 = 1024;
      v35 = v12.i32[0];
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Bandwidth: Sending 32bit hex value 0x%08X to UCM. ActiveNonAudioTasks 0x%08X, ActiveAudioTask is 0x%04X, BTLoadValue sent was 0x%02X actual decimal btload value %d, HighConnections bits 20-21 value %d, IrregularConnections bits 22-23 value %d, NormalConnection bits 24-25 %d, numLeConnections = %d, numClassicHids = %d", buf, 0x3Eu);
    }
    v13 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_uint64(v13, "kWCMBTWirelessLoadValue", v4 | v3 | v5);
    sub_1006C4A48((uint64_t)a1, 0x57EuLL, v13);
    xpc_release(v13);
  }
  return sub_100034234((uint64_t)v15);
}

void sub_1006C4818(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_100034234((uint64_t)&a9);
  _Unwind_Resume(a1);
}

void sub_1006C4838(uint64_t a1)
{
  uint64_t v2;

  sub_10001A82C(a1 + 424, *(_QWORD **)(a1 + 432));
  *(_QWORD *)(a1 + 432) = 0;
  *(_QWORD *)(a1 + 440) = 0;
  *(_QWORD *)(a1 + 424) = a1 + 432;
  if (&WCMEnabled)
  {
    v2 = sub_1000438A4();
    sub_100333478(v2, a1 + 16);
    if (qword_100977A78 != -1)
      dispatch_once(&qword_100977A78, &stru_100940DB8);
    sub_100494190((uint64_t)off_100977A70, a1 + 8);
    if (qword_100978130 != -1)
      dispatch_once(&qword_100978130, &stru_100940DD8);
    sub_100069060((uint64_t)off_100978128 + 80, a1 + 24);
    if (qword_1009778A8 != -1)
      dispatch_once(&qword_1009778A8, &stru_100940DF8);
    sub_10061F45C((uint64_t)off_1009778A0, a1 + 32);
    if (qword_100977B40 != -1)
      dispatch_once(&qword_100977B40, &stru_100940E18);
    sub_1004B98CC((uint64_t)off_100977B38, a1 + 40);
    if (qword_10097ADB8 != -1)
      dispatch_once(&qword_10097ADB8, &stru_100940E38);
    sub_1004FD338(qword_10097ADB0, a1 + 56);
    if (qword_100977FB0 != -1)
      dispatch_once(&qword_100977FB0, &stru_100940E58);
    sub_100069060((uint64_t)off_100977FA8 + 1872, a1 + 64);
    if (qword_1009778E8 != -1)
      dispatch_once(&qword_1009778E8, &stru_100940E78);
    sub_100069060((uint64_t)off_1009778E0 + 240, a1 + 72);
  }
  else if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
  {
    sub_10071BD5C();
  }
}

void sub_1006C4A48(uint64_t a1, uint64_t value, void *a3)
{
  xpc_object_t v5;
  NSObject *v6;
  xpc_object_t object[2];
  char *keys[2];

  if (&WCMEnabled)
  {
    *(_OWORD *)keys = *(_OWORD *)&off_100940D88;
    object[0] = xpc_uint64_create(value);
    object[1] = a3;
    v5 = xpc_dictionary_create((const char *const *)keys, object, 2uLL);
    xpc_connection_send_message(*(xpc_connection_t *)(a1 + 144), v5);
    xpc_release(object[0]);
    xpc_release(v5);
  }
  else
  {
    v6 = qword_1009997F0;
    if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_INFO))
    {
      LOWORD(keys[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "WCM not enabled, discarding message", (uint8_t *)keys, 2u);
    }
  }
}

void sub_1006C4B3C(uint64_t a1)
{
  sub_1006C43FC(a1);
  sub_1006C4540(a1);
  sub_1006C4B78(a1);
  sub_1006C4D54(a1);
  sub_1006C4FAC(a1);
}

void sub_1006C4B78(uint64_t a1)
{
  uint64_t *v2;
  uint64_t *v3;
  int v4;
  unsigned int v5;
  unsigned __int8 *v6;
  int v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;

  v8 = 0;
  v9 = 0;
  v10 = 0;
  if (qword_100978190 != -1)
    dispatch_once(&qword_100978190, &stru_100940F18);
  sub_10006A8A0((uint64_t)off_100978188, (void **)&v8);
  v2 = v8;
  v3 = v9;
  if (v8 != v9)
  {
    do
    {
      v4 = sub_1004497F4(*v2);
      v5 = 1;
      do
      {
        if ((v5 & v4) != 0)
          sub_1006C8A48(a1, ((unint64_t)*(unsigned __int8 *)(*v2 + 128) << 40) | ((unint64_t)*(unsigned __int8 *)(*v2 + 129) << 32) | ((unint64_t)*(unsigned __int8 *)(*v2 + 130) << 24) | ((unint64_t)*(unsigned __int8 *)(*v2 + 131) << 16) | ((unint64_t)*(unsigned __int8 *)(*v2 + 132) << 8) | *(unsigned __int8 *)(*v2 + 133), v5, 0xBu, 0);
        v5 *= 2;
      }
      while ((v5 & 0x80000000) == 0);
      v7 = *(_DWORD *)(*v2 + 1312);
      if ((v7 & 0x10) != 0)
      {
        v6 = (unsigned __int8 *)*v2;
        sub_1006C8E48(a1, ((unint64_t)v6[128] << 40) | ((unint64_t)v6[129] << 32) | ((unint64_t)v6[130] << 24) | ((unint64_t)v6[131] << 16) | ((unint64_t)v6[132] << 8) | v6[133], 2uLL, 16, 201, 0, 1u);
      }
      if ((v7 & 1) != 0)
        sub_1006C8E48(a1, ((unint64_t)*(unsigned __int8 *)(*v2 + 128) << 40) | ((unint64_t)*(unsigned __int8 *)(*v2 + 129) << 32) | ((unint64_t)*(unsigned __int8 *)(*v2 + 130) << 24) | ((unint64_t)*(unsigned __int8 *)(*v2 + 131) << 16) | ((unint64_t)*(unsigned __int8 *)(*v2 + 132) << 8) | *(unsigned __int8 *)(*v2 + 133), 1uLL, 1, 101, 0, 1u);
      ++v2;
    }
    while (v2 != v3);
    v2 = v8;
  }
  if (v2)
  {
    v9 = v2;
    operator delete(v2);
  }
}

void sub_1006C4D2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1006C4D54(uint64_t a1)
{
  id v2;
  id v3;
  id v4;
  uint64_t v5;
  void *v6;
  void *v7;
  void *v8;
  unint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  unsigned __int8 v14[16];
  _BYTE v15[128];

  if (qword_1009778A8 != -1)
    dispatch_once(&qword_1009778A8, &stru_100940DF8);
  v2 = sub_100069E14((uint64_t)off_1009778A0);
  v12 = 0u;
  v13 = 0u;
  v10 = 0u;
  v11 = 0u;
  v3 = (id)objc_claimAutoreleasedReturnValue(v2);
  v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v10, v15, 16);
  if (v4)
  {
    v5 = *(_QWORD *)v11;
    do
    {
      v6 = 0;
      do
      {
        if (*(_QWORD *)v11 != v5)
          objc_enumerationMutation(v3);
        v7 = *(void **)(*((_QWORD *)&v10 + 1) + 8 * (_QWORD)v6);
        if (qword_1009778A8 != -1)
          dispatch_once(&qword_1009778A8, &stru_100940DF8);
        v8 = off_1009778A0;
        sub_100030BCC(v14, v7);
        if (sub_100623A78((uint64_t)v8, v14))
        {
          if (qword_1009778C8 != -1)
            dispatch_once(&qword_1009778C8, &stru_100940EF8);
          v9 = sub_1000589DC((uint64_t)off_1009778C0, v7, 0);
          sub_1006C8A48(a1, v9, 0x8000u, 0xBu, 0);
        }
        v6 = (char *)v6 + 1;
      }
      while (v4 != v6);
      v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v10, v15, 16);
    }
    while (v4);
  }

  if (qword_100977B40 != -1)
    dispatch_once(&qword_100977B40, &stru_100940E18);
  if (*((_BYTE *)off_100977B38 + 199))
    sub_1006C8E48(a1, 1, 3uLL, 0x10000, 801, 0, 1u);

}

void sub_1006C4F78(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1006C4FAC(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *v2;
  xpc_object_t v4;
  NSObject *v5;
  const char *v6;
  _QWORD *v7;
  _QWORD *v8;
  BOOL v9;
  uint8_t buf[4];
  const char *v11;

  v1 = *(_QWORD **)(a1 + 400);
  v2 = (_QWORD *)(a1 + 408);
  if (v1 != (_QWORD *)(a1 + 408))
  {
    do
    {
      v4 = xpc_dictionary_create(0, 0, 0);
      xpc_dictionary_set_int64(v4, "kWCMBTLeDiscoveryScan_State", 1);
      xpc_dictionary_set_int64(v4, "kWCMBTLeDiscoveryScan_UseCase", 1);
      v5 = qword_1009997F0;
      if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
      {
        v6 = sub_100037D34(*((_DWORD *)v1 + 7));
        *(_DWORD *)buf = 136315138;
        v11 = v6;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "sendLEScanningUseCaseInfo: Sending Notification to WiFi for CBUseCase %s", buf, 0xCu);
      }
      sub_1006C4A48(a1, 0x206uLL, v4);
      v7 = (_QWORD *)v1[1];
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = (_QWORD *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (_QWORD *)v1[2];
          v9 = *v8 == (_QWORD)v1;
          v1 = v8;
        }
        while (!v9);
      }
      v1 = v8;
    }
    while (v8 != v2);
  }
}

uint64_t sub_1006C511C(int a1, xpc_object_t xdict)
{
  if (xpc_dictionary_get_uint64(xdict, "kMessageArgs"))
  {
    if (qword_100978130 != -1)
      dispatch_once(&qword_100978130, &stru_100940DD8);
    sub_10047DB74((uint64_t)off_100978128);
  }
  else
  {
    if (qword_100978130 != -1)
      dispatch_once(&qword_100978130, &stru_100940DD8);
    sub_10047DECC((uint64_t)off_100978128);
  }
  return 1;
}

uint64_t sub_1006C51A4(int a1, xpc_object_t xdict)
{
  uint64_t uint64;
  NSObject *v3;
  _DWORD v5[2];

  uint64 = xpc_dictionary_get_uint64(xdict, "kWCMBTPreferredRole");
  v3 = qword_1009997F0;
  if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_INFO))
  {
    v5[0] = 67109120;
    v5[1] = uint64 == 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "Setting preferred role to : %d", (uint8_t *)v5, 8u);
  }
  LOBYTE(v5[0]) = 0;
  sub_100043758(v5);
  sub_10018C8A4(uint64 == 0);
  sub_10004339C(v5);
  sub_100043728(v5);
  return 1;
}

void sub_1006C528C(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006C52A8(int a1, xpc_object_t xdict)
{
  _BYTE *data;
  BOOL v3;
  uint64_t i;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  char v13;
  size_t length;
  uint64_t v15;
  __int16 v16;

  v16 = 0;
  length = 0;
  v15 = 0;
  data = xpc_dictionary_get_data(xdict, "kMessageArgs", &length);
  if (data)
    v3 = length >= 0xA;
  else
    v3 = 0;
  if (!v3)
    return 1;
  for (i = 0; i != 10; ++i)
    *((_BYTE *)&v15 + i) = data[i];
  if (qword_100978130 != -1)
    dispatch_once(&qword_100978130, &stru_100940DD8);
  if (sub_10002527C((uint64_t)off_100978128) == 1)
  {
    v13 = 0;
    sub_100043758(&v13);
    v11 = sub_100192970((uint64_t (*)())sub_1006C879C, (uint64_t)&v15, v5, v6, v7, v8, v9, v10);
    sub_10004339C(&v13);
    if (v11)
    {
      if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
        sub_1006F4988();
    }
    sub_100043728(&v13);
    return 1;
  }
  return 202;
}

void sub_1006C53DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  sub_100043728(&a13);
  _Unwind_Resume(a1);
}

uint64_t sub_1006C53F8(int a1, xpc_object_t xdict)
{
  _BYTE *data;
  size_t v3;
  uint64_t i;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  NSObject *v14;
  uint32_t v15;
  uint64_t v16;
  NSObject *v18;
  size_t length;
  int v20;
  char v21;
  uint8_t buf[4];
  size_t v23;

  v21 = 0;
  v20 = 0;
  length = 0;
  data = xpc_dictionary_get_data(xdict, "kMessageArgs", &length);
  if (!data)
  {
    v12 = qword_1009997F0;
    if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v13 = "WCMBLESetChannelMap message is not in expected format";
      v14 = v12;
      v15 = 2;
LABEL_17:
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v13, buf, v15);
    }
    return 1;
  }
  v3 = length;
  if (length != 5)
  {
    v16 = qword_1009997F0;
    if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      v23 = v3;
      v13 = "WCMBLESetChannelMap message has unexpected AFH map with length %zu";
      v14 = v16;
      v15 = 12;
      goto LABEL_17;
    }
    return 1;
  }
  if (qword_100978130 != -1)
    dispatch_once(&qword_100978130, &stru_100940DD8);
  if (sub_10002527C((uint64_t)off_100978128) == 1)
  {
    for (i = 0; i != 5; ++i)
      *((_BYTE *)&v20 + i) = data[i];
    buf[0] = 0;
    sub_100043758(buf);
    v11 = sub_10004C9BC(180, (uint64_t (*)())sub_1006C8918, v5, v6, v7, v8, v9, v10, (uint64_t)&v20);
    sub_10004339C(buf);
    if ((_DWORD)v11)
    {
      if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
        sub_10071BEBC();
      v11 = 1;
    }
    sub_100043728(buf);
  }
  else
  {
    v18 = qword_1009997F0;
    if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "WCMBLESetChannelMap message cannot be handled as the power state is OFF", buf, 2u);
    }
    return 202;
  }
  return v11;
}

void sub_1006C5620(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  sub_100043728(va);
  _Unwind_Resume(a1);
}

uint64_t sub_1006C563C(uint64_t a1, void *a2)
{
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  const char *v6;
  xpc_object_t value;
  void *v9;
  _WORD *data;
  _WORD *v11;
  _WORD *v12;
  _WORD *v13;
  NSObject *v14;
  _WORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  size_t v21;
  size_t v22;
  size_t v23;
  size_t length;
  uint8_t buf[2];
  uint64_t v26;
  __int16 v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  __int16 v31;
  uint64_t v32;
  __int16 v33;
  __int16 v34;
  uint64_t v35;
  __int16 v36;

  v3 = sub_10003BE44();
  if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 136))(v3) & 1) != 0)
  {
    v4 = sub_100027F68();
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v4 + 360))(v4))
    {
      v5 = qword_1009997F0;
      if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        v6 = "Diversity host assisted AFH maps overridden: maps from coex manager ignored";
LABEL_7:
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v6, buf, 2u);
      }
    }
    else
    {
      value = xpc_dictionary_get_value(a2, "kMessageArgs");
      if (value)
      {
        v9 = value;
        v23 = 0;
        length = 0;
        v21 = 0;
        v22 = 0;
        data = xpc_dictionary_get_data(value, "kWCMBTDiversityChannelMap_C0B0", &length);
        v11 = xpc_dictionary_get_data(v9, "kWCMBTDiversityChannelMap_C0B1", &v23);
        v12 = xpc_dictionary_get_data(v9, "kWCMBTDiversityChannelMap_C1B0", &v22);
        v13 = xpc_dictionary_get_data(v9, "kWCMBTDiversityChannelMap_C1B1", &v21);
        v14 = qword_1009997F0;
        if (data && length >= 0xA && v11 && v23 >= 0xA && v12 && v22 >= 0xA && (v15 = v13) != 0 && v21 > 9)
        {
          if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_INFO))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "Sending diversity host assisted AFH maps", buf, 2u);
          }
          *(_WORD *)buf = 0;
          v16 = *(_QWORD *)data;
          v27 = data[4];
          v26 = v16;
          v28 = 256;
          v17 = *(_QWORD *)v11;
          v30 = v11[4];
          v29 = v17;
          v31 = 512;
          v18 = *(_QWORD *)v12;
          v33 = v12[4];
          v32 = v18;
          v34 = 768;
          v19 = *(_QWORD *)v15;
          v36 = v15[4];
          v35 = v19;
          v20 = sub_1000438A4();
          (*(void (**)(uint64_t, uint64_t, uint8_t *))(*(_QWORD *)v20 + 928))(v20, 4, buf);
        }
        else if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
        {
          sub_10071BF14();
        }
      }
      else if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
      {
        sub_10071BEE8();
      }
    }
  }
  else
  {
    v5 = qword_1009997F0;
    if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      v6 = "Diversity not supported on this platform: host assisted AFH maps from coex manager ignored";
      goto LABEL_7;
    }
  }
  return 1;
}

uint64_t sub_1006C58FC(uint64_t a1, void *a2)
{
  NSObject *v3;
  xpc_object_t value;
  void *v5;
  NSObject *v6;
  uint8_t v8[16];
  uint8_t buf[8];
  int v10;

  v3 = qword_1009997F0;
  if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "Received MWS Channel Parameters", buf, 2u);
  }
  v10 = 0;
  *(_QWORD *)buf = 0;
  value = xpc_dictionary_get_value(a2, "kMessageArgs");
  if (value)
  {
    v5 = value;
    buf[0] = xpc_dictionary_get_uint64(value, "kWCMBTSetMWSChannelParameters_Enable");
    *(_WORD *)&buf[2] = xpc_dictionary_get_uint64(v5, "kWCMBTSetMWSChannelParameters_RxCenterFrequency");
    *(_WORD *)&buf[4] = xpc_dictionary_get_uint64(v5, "kWCMBTSetMWSChannelParameters_TxCenterFrequency");
    *(_WORD *)&buf[6] = xpc_dictionary_get_uint64(v5, "kWCMBTSetMWSChannelParameters_RxChannelBandwidth");
    LOWORD(v10) = xpc_dictionary_get_uint64(v5, "kWCMBTSetMWSChannelParameters_TxChannelBandwidth");
    BYTE2(v10) = xpc_dictionary_get_uint64(v5, "kWCMBTSetMWSChannelParameters_Type");
    if (qword_100977A58 != -1)
      dispatch_once(&qword_100977A58, &stru_100940E98);
    sub_1004A9424((uint64_t)off_100977A50, 12, (uint64_t)buf);
  }
  else
  {
    v6 = qword_1009997F0;
    if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)v8 = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_INFO, "Invalid argument for Channel Parameters", v8, 2u);
    }
  }
  return 1;
}

uint64_t sub_1006C5A80(int a1, xpc_object_t xdict)
{
  xpc_object_t value;
  NSObject *v3;
  uint64_t uint64;
  xpc_object_t v5;
  xpc_object_t v6;
  void *v7;
  size_t count;
  size_t v9;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  uint8_t v19[16];
  __int16 v20[52];

  memset(&v20[3], 0, 98);
  value = xpc_dictionary_get_value(xdict, "kMessageArgs");
  v3 = qword_1009997F0;
  if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)v19 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "Received MWS External Frame Config", v19, 2u);
  }
  if (!value)
    return 1;
  v20[0] = xpc_dictionary_get_uint64(value, "kWCMBTSetMWSExternalConfig_ExtFrameDuration");
  v20[1] = xpc_dictionary_get_int64(value, "kWCMBTSetMWSExternalConfig_ExtFrameSyncAssertOffset");
  v20[2] = xpc_dictionary_get_uint64(value, "kWCMBTSetMWSExternalConfig_ExtFrameSyncAssertJitter");
  uint64 = xpc_dictionary_get_uint64(value, "kWCMBTSetMWSExternalConfig_ExtNumPeriods");
  LOBYTE(v20[3]) = uint64;
  v5 = xpc_dictionary_get_value(value, "kWCMBTSetMWSExternalConfig_ExtPeriodDuration");
  v6 = xpc_dictionary_get_value(value, "kWCMBTSetMWSExternalConfig_ExtPeriodType");
  if (uint64 - 1 >= 0x20)
  {
    v11 = qword_1009997F0;
    if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
      sub_10071C02C(uint64, v11, v12, v13, v14, v15, v16, v17);
    return 1;
  }
  if (!v5 || (v7 = v6) == 0)
  {
    if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
      sub_10071C000();
    return 1;
  }
  count = xpc_array_get_count(v5);
  if (count != uint64)
  {
    v18 = qword_1009997F0;
    if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
      sub_10071BF6C(uint64, v5, v18);
    return 1;
  }
  if (xpc_array_get_count(v7) != count)
  {
    if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
      sub_10071BF40();
    return 1;
  }
  v9 = 0;
  do
  {
    v20[v9 + 4] = xpc_array_get_uint64(v5, v9);
    *((_BYTE *)&v20[36] + v9) = xpc_array_get_uint64(v7, v9);
    ++v9;
  }
  while (v9 < uint64);
  if (qword_100977A58 != -1)
    dispatch_once(&qword_100977A58, &stru_100940E98);
  sub_1004A9240((uint64_t)off_100977A50, 104, v20);
  return 0;
}

uint64_t sub_1006C5D24(uint64_t a1, void *a2)
{
  NSObject *v3;
  xpc_object_t value;
  void *v5;
  __int16 v7[16];

  v3 = qword_1009997F0;
  if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_INFO))
  {
    v7[0] = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "Received MWS Signaling Command", (uint8_t *)v7, 2u);
  }
  value = xpc_dictionary_get_value(a2, "kMessageArgs");
  if (value)
  {
    v5 = value;
    v7[0] = xpc_dictionary_get_int64(value, "kWCMBTSetMWSSignaling_MWSRxAssertOffset");
    v7[1] = xpc_dictionary_get_uint64(v5, "kWCMBTSetMWSSignaling_MWSRxAssertJitter");
    v7[2] = xpc_dictionary_get_int64(v5, "kWCMBTSetMWSSignaling_MWSRxDeAssertOffset");
    v7[3] = xpc_dictionary_get_uint64(v5, "kWCMBTSetMWSSignaling_MWSRxDeAssertJitter");
    v7[4] = xpc_dictionary_get_int64(v5, "kWCMBTSetMWSSignaling_MWSTxAssertOffset");
    v7[5] = xpc_dictionary_get_uint64(v5, "kWCMBTSetMWSSignaling_MWSTxAssertJitter");
    v7[6] = xpc_dictionary_get_int64(v5, "kWCMBTSetMWSSignaling_MWSTxDeAssertOffset");
    v7[7] = xpc_dictionary_get_uint64(v5, "kWCMBTSetMWSSignaling_MWSTxDeAssertJitter");
    v7[8] = xpc_dictionary_get_int64(v5, "kWCMBTSetMWSSignaling_MWSPatternAssertOffset");
    v7[9] = xpc_dictionary_get_uint64(v5, "kWCMBTSetMWSSignaling_MWSPatternAssertJitter");
    v7[10] = xpc_dictionary_get_int64(v5, "kWCMBTSetMWSSignaling_MWSInactivityAssertOffset");
    v7[11] = xpc_dictionary_get_uint64(v5, "kWCMBTSetMWSSignaling_MWSInactivityAssertJitter");
    v7[12] = xpc_dictionary_get_int64(v5, "kWCMBTSetMWSSignaling_MWSScanFrequencyAssertOffset");
    v7[13] = xpc_dictionary_get_uint64(v5, "kWCMBTSetMWSSignaling_MWSScanFrequencyAssertJitter");
    v7[14] = xpc_dictionary_get_uint64(v5, "kWCMBTSetMWSSignaling_MWSPriorityAssertOffsetRequest");
    if (qword_100977A58 != -1)
      dispatch_once(&qword_100977A58, &stru_100940E98);
    sub_1004A9670((uint64_t)off_100977A50, 30, v7);
  }
  return 1;
}

uint64_t sub_1006C5F0C(int a1, xpc_object_t xdict)
{
  xpc_object_t value;
  void *v3;
  uint64_t v4;
  _BYTE v6[2];

  value = xpc_dictionary_get_value(xdict, "kMessageArgs");
  if (value)
  {
    v3 = value;
    v6[0] = xpc_dictionary_get_uint64(value, "kWCMBTSetWCI2Mode_ReceiveMessage");
    v6[1] = xpc_dictionary_get_uint64(v3, "kWCMBTSetWCI2Mode_SendMessage");
    v4 = sub_1000438A4();
    (*(void (**)(uint64_t, uint64_t, _BYTE *))(*(_QWORD *)v4 + 504))(v4, 2, v6);
  }
  return 1;
}

uint64_t sub_1006C5F84(int a1, xpc_object_t xdict)
{
  xpc_object_t value;
  uint64_t v3;
  __int16 v5;

  v5 = 0;
  value = xpc_dictionary_get_value(xdict, "kMessageArgs");
  xpc_retain(value);
  if (value)
  {
    LOBYTE(v5) = xpc_dictionary_get_uint64(value, "kWCMBTTriggerWCI2Message_MessageId");
    HIBYTE(v5) = xpc_dictionary_get_uint64(value, "kWCMBTTriggerWCI2Message_Value1");
  }
  xpc_release(value);
  v3 = sub_1000438A4();
  (*(void (**)(uint64_t, uint64_t, __int16 *))(*(_QWORD *)v3 + 528))(v3, 2, &v5);
  return 1;
}

uint64_t sub_1006C6010(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value;
  NSObject *v4;
  unsigned __int8 v5;
  int v6;
  NSString *v7;
  void *v8;
  void *v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  uint8_t v17[16];
  uint8_t buf[8];
  __int16 uint64;
  char v20;
  unsigned __int8 v21;
  __int16 v22;
  __int16 v23;

  value = xpc_dictionary_get_value(xdict, "kMessageArgs");
  v4 = qword_1009997F0;
  if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Setting LTE Link Quality Mode", buf, 2u);
  }
  if (value)
  {
    uint64 = xpc_dictionary_get_uint64(value, "kWCMBTSetLinkQuality_Duration");
    v20 = xpc_dictionary_get_uint64(value, "kWCMBTSetLinkQuality_EventType");
    v5 = xpc_dictionary_get_uint64(value, "kWCMBTSetLinkQuality_Mode");
    v6 = v5;
    v21 = v5;
    v22 = xpc_dictionary_get_uint64(value, "kWCMBTSetLinkQuality_RxThreshold");
    v23 = xpc_dictionary_get_uint64(value, "kWCMBTSetLinkQuality_TxThreshold");
    v7 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", xpc_dictionary_get_string(value, "kWCMBTSetLinkQuality_DeviceAddress"));
    v8 = (void *)objc_claimAutoreleasedReturnValue(v7);
    v9 = v8;
    if (v6)
    {
      v10 = sub_100649C7C(v8);
      if (!v10 && os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
        sub_10071C0F8();
      if (qword_1009778E8 != -1)
        dispatch_once(&qword_1009778E8, &stru_100940E78);
      v11 = sub_10006D488((uint64_t)off_1009778E0, v10, 0);
      if (v11)
      {
        v12 = sub_1000438A4();
        sub_100333414(v12, a1 + 16);
        v13 = sub_1000438A4();
        (*(void (**)(uint64_t, uint64_t, __int16 *, uint64_t))(*(_QWORD *)v13 + 536))(v13, 8, &uint64, v11);
      }
      else if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
      {
        sub_10071C094();
      }
    }
    else
    {
      v15 = sub_1000438A4();
      sub_100333478(v15, a1 + 16);
    }

  }
  else
  {
    v14 = qword_1009997F0;
    if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)v17 = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "Invalid argument for LTE Link Quality Mode", v17, 2u);
    }
  }
  return 1;
}

void sub_1006C625C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t sub_1006C6274(int a1, xpc_object_t xdict)
{
  uint64_t uint64;
  NSObject *v3;
  const char *v4;
  uint64_t v5;
  int v7;
  const char *v8;

  uint64 = xpc_dictionary_get_uint64(xdict, "kMessageArgs");
  v3 = qword_1009997F0;
  if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_INFO))
  {
    v4 = "Enabled";
    if (!uint64)
      v4 = "Disabled";
    v7 = 136446210;
    v8 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "Setting sleep mode to %{public}s", (uint8_t *)&v7, 0xCu);
  }
  v5 = sub_1000438A4();
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 544))(v5, (unsigned __int16)uint64);
  return 1;
}

void sub_1006C6354(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t v3;
  void *v4;
  uint64_t uint64;
  uint64_t v6;
  unsigned __int8 v7;
  unsigned __int8 v8;
  uint64_t v9;
  unsigned int v10;
  BOOL v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  xpc_object_t v15;
  void *v16;
  unsigned int v17;
  uint64_t v18;
  const char *v19;
  uint64_t v20;
  unint64_t v21;
  __int16 v22;
  uint8_t buf[4];
  uint64_t v24;
  uint64_t value[2];

  v3 = xpc_dictionary_get_value(xdict, "kMessageArgs");
  if (v3)
  {
    v4 = v3;
    uint64 = xpc_dictionary_get_uint64(v3, "kWCMBTAntennaAction");
    v6 = xpc_dictionary_get_uint64(v4, "kWCMBTAntennaConfiguration");
    v7 = xpc_dictionary_get_uint64(v4, "kWCMBTAntennaParam1");
    v8 = xpc_dictionary_get_uint64(v4, "kWCMBTAntennaParam2");
    value[0] = 0;
    value[1] = 0;
    v22 = 16;
    v9 = sub_1000438A4();
    if (uint64 >= 6)
    {
      v10 = *(_DWORD *)(v9 + 712);
      if (v10)
      {
        if (v10 < 0x18)
        {
          if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
            sub_10071C188();
          return;
        }
      }
    }
    if (uint64)
      v11 = uint64 == 10;
    else
      v11 = 1;
    if (v11)
      v12 = 4095;
    else
      v12 = 0;
    v13 = qword_1009997F0;
    if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      v24 = uint64;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Sending antenna preference action %llu", buf, 0xCu);
    }
    v14 = sub_1000438A4();
    (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, __int16 *, uint64_t *))(*(_QWORD *)v14 + 912))(v14, v12, uint64, v6, v7, v8, &v22, value);
    v15 = xpc_dictionary_create(0, 0, 0);
    v16 = v15;
    if (v22)
    {
      v17 = LOBYTE(value[0]);
      if (uint64 == 2 || uint64 == 1)
      {
        xpc_dictionary_set_uint64(v15, "kWCMBTCurrentAntenna", BYTE1(value[0]));
        v18 = BYTE2(value[0]);
        v19 = "kWCMBTPreviousAntenna";
        goto LABEL_28;
      }
      if (!uint64)
      {
        v18 = BYTE1(value[0]);
        v19 = "kWCMBTCurrentAntenna";
LABEL_28:
        xpc_dictionary_set_uint64(v16, v19, v18);
LABEL_30:
        xpc_dictionary_set_uint64(v16, "kWCMBTStatus", v17);
        xpc_dictionary_set_uint64(v16, "kWCMBTAntennaAction", uint64);
        sub_1006C4A48(a1, 0x1FEuLL, v16);
        xpc_release(v16);
        return;
      }
    }
    else
    {
      v17 = 255;
    }
    if (uint64 == 3)
    {
      v20 = sub_1000438A4();
      v21 = a1 + 16;
      if (v6 != 1 || v17)
        sub_100333478(v20, v21);
      else
        sub_100333414(v20, v21);
    }
    goto LABEL_30;
  }
  if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
    sub_10071C15C();
}

uint64_t sub_1006C6610(uint64_t a1, void *a2)
{
  NSObject *v3;
  xpc_object_t value;
  void *v5;
  uint64_t uint64;
  xpc_object_t v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  size_t v16;
  xpc_object_t v17;
  char *v18;
  xpc_object_t v19;
  _OWORD v21[4];
  __int16 v22;

  v3 = qword_1009997F0;
  if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_INFO))
  {
    LOWORD(v21[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "Received MWS Set Scan Freq Table", (uint8_t *)v21, 2u);
  }
  v22 = 0;
  memset(v21, 0, sizeof(v21));
  value = xpc_dictionary_get_value(a2, "kMessageArgs");
  if (value)
  {
    v5 = value;
    uint64 = xpc_dictionary_get_uint64(value, "kWCMBTNumScanFrequencies");
    LOBYTE(v21[0]) = uint64;
    v7 = xpc_dictionary_get_value(v5, "kWCMBTScanFrequencies");
    if (uint64 >= 0x20u)
    {
      v8 = qword_1009997F0;
      if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
        sub_10071C1EC(uint64, v8, v9, v10, v11, v12, v13, v14);
      return 1;
    }
    v15 = v7;
    if (xpc_array_get_count(v7) != uint64
      && os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
    {
      sub_10071C254();
      if ((_BYTE)uint64)
      {
LABEL_10:
        v16 = 0;
        do
        {
          v17 = xpc_array_get_value(v15, v16);
          v18 = (char *)v21 + 2 * v16;
          *((_WORD *)v18 + 1) = xpc_array_get_uint64(v17, 0);
          v19 = xpc_array_get_value(v15, v16);
          *((_WORD *)v18 + 17) = xpc_array_get_uint64(v19, 1uLL);
          ++v16;
        }
        while (v16 < uint64);
      }
    }
    else if ((_BYTE)uint64)
    {
      goto LABEL_10;
    }
    if (qword_100977A58 != -1)
      dispatch_once(&qword_100977A58, &stru_100940E98);
    sub_1004A9910((uint64_t)off_100977A50, 66, (char *)v21);
  }
  return 1;
}

void sub_1006C67C8(int a1, xpc_object_t xdict)
{
  xpc_object_t value;
  unsigned __int8 uint64;
  NSObject *v4;
  uint64_t v5;
  _DWORD v6[2];

  value = xpc_dictionary_get_value(xdict, "kMessageArgs");
  if (value)
  {
    uint64 = xpc_dictionary_get_uint64(value, "kWCMBTCoexRxGainModeEnable");
    v4 = qword_1009997F0;
    if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_INFO))
    {
      v6[0] = 67109120;
      v6[1] = uint64;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "BT coex rx mode value: %d", (uint8_t *)v6, 8u);
    }
    v5 = sub_1000438A4();
    (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v5 + 1624))(v5, uint64);
  }
  else if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
  {
    sub_10071C280();
  }
}

void sub_1006C68CC(os_unfair_lock_s *a1, xpc_object_t xdict)
{
  xpc_object_t value;
  unsigned __int8 uint64;
  NSObject *v5;
  _QWORD v6[4];
  unsigned __int8 v7;
  uint8_t buf[4];
  int v9;

  value = xpc_dictionary_get_value(xdict, "kMessageArgs");
  if (value)
  {
    uint64 = xpc_dictionary_get_uint64(value, "kWCMBTAWDLActive");
    v5 = qword_1009997F0;
    if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109120;
      v9 = uint64;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "BT coex AWDL active state is: %d", buf, 8u);
    }
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    v6[2] = sub_1006C7FF4;
    v6[3] = &unk_100940D28;
    v7 = uint64;
    sub_10001AB14(a1 + 120, v6);
  }
  else if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
  {
    sub_10071C2AC();
  }
}

void sub_1006C6A08(os_unfair_lock_s *a1, xpc_object_t xdict)
{
  xpc_object_t value;
  unsigned __int8 uint64;
  NSObject *v5;
  _QWORD v6[4];
  unsigned __int8 v7;
  uint8_t buf[4];
  int v9;

  value = xpc_dictionary_get_value(xdict, "kMessageArgs");
  if (value)
  {
    uint64 = xpc_dictionary_get_uint64(value, "kWCMBT5GHzWiFiRatesLow");
    v5 = qword_1009997F0;
    if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109120;
      v9 = uint64;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "BT coex LowWifiRat state is: %d", buf, 8u);
    }
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    v6[2] = sub_1006C8014;
    v6[3] = &unk_100940D28;
    v7 = uint64;
    sub_10001AB14(a1 + 120, v6);
  }
  else if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
  {
    sub_10071C2D8();
  }
}

void sub_1006C6B44(os_unfair_lock_s *a1, xpc_object_t xdict)
{
  xpc_object_t value;
  unsigned __int8 uint64;
  NSObject *v5;
  _QWORD v6[4];
  unsigned __int8 v7;
  uint8_t buf[4];
  int v9;

  value = xpc_dictionary_get_value(xdict, "kMessageArgs");
  if (value)
  {
    uint64 = xpc_dictionary_get_uint64(value, "kWCMBTAWDLRTGActive");
    v5 = qword_1009997F0;
    if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109120;
      v9 = uint64;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "BT coex AWDLRTG active state is: %d", buf, 8u);
    }
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    v6[2] = sub_1006C8034;
    v6[3] = &unk_100940D28;
    v7 = uint64;
    sub_10001AB14(a1 + 120, v6);
  }
  else if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
  {
    sub_10071C304();
  }
}

void sub_1006C6C80(os_unfair_lock_s *a1, xpc_object_t xdict)
{
  xpc_object_t value;
  unsigned __int8 uint64;
  NSObject *v5;
  _QWORD v6[4];
  unsigned __int8 v7;
  uint8_t buf[4];
  int v9;

  value = xpc_dictionary_get_value(xdict, "kMessageArgs");
  if (value)
  {
    uint64 = xpc_dictionary_get_uint64(value, "kWCMBTUWB5GHzActive");
    v5 = qword_1009997F0;
    if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109120;
      v9 = uint64;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "BT coex UWB 5g active state is: %d", buf, 8u);
    }
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    v6[2] = sub_1006C8054;
    v6[3] = &unk_100940D28;
    v7 = uint64;
    sub_10001AB14(a1 + 120, v6);
  }
  else if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
  {
    sub_10071C330();
  }
}

void sub_1006C6DBC(os_unfair_lock_s *a1, xpc_object_t xdict)
{
  xpc_object_t value;
  unsigned __int8 uint64;
  NSObject *v5;
  _QWORD v6[4];
  unsigned __int8 v7;
  uint8_t buf[4];
  int v9;

  value = xpc_dictionary_get_value(xdict, "kMessageArgs");
  if (value)
  {
    uint64 = xpc_dictionary_get_uint64(value, "kWCMBTNANActive");
    v5 = qword_1009997F0;
    if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109120;
      v9 = uint64;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "BT coex Nan active state is: %d", buf, 8u);
    }
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    v6[2] = sub_1006C8074;
    v6[3] = &unk_100940D28;
    v7 = uint64;
    sub_10001AB14(a1 + 120, v6);
  }
  else if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
  {
    sub_10071C35C();
  }
}

void sub_1006C6EF8(os_unfair_lock_s *a1, xpc_object_t xdict)
{
  xpc_object_t value;
  unsigned __int8 uint64;
  NSObject *v5;
  _QWORD v6[4];
  unsigned __int8 v7;
  uint8_t buf[4];
  int v9;

  value = xpc_dictionary_get_value(xdict, "kMessageArgs");
  if (value)
  {
    uint64 = xpc_dictionary_get_uint64(value, "kWCMBT5GHzHostAPActive");
    v5 = qword_1009997F0;
    if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109120;
      v9 = uint64;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "BT coex 5Ghz Host AP active state is: %d", buf, 8u);
    }
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    v6[2] = sub_1006C8094;
    v6[3] = &unk_100940D28;
    v7 = uint64;
    sub_10001AB14(a1 + 120, v6);
  }
  else if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
  {
    sub_10071C388();
  }
}

void sub_1006C7034(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value;
  void *v4;
  uint64_t uint64;
  uint64_t v6;
  NSObject *v7;
  int v8;
  uint64_t v9;
  __int16 v10;
  uint64_t v11;

  value = xpc_dictionary_get_value(xdict, "kMessageArgs");
  if (value)
  {
    v4 = value;
    uint64 = xpc_dictionary_get_uint64(value, "kWCMBTCoexScanIntervalReason");
    v6 = xpc_dictionary_get_uint64(v4, "kWCMBTCoexScanIntervalState");
    v7 = qword_1009997F0;
    if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
    {
      v8 = 134218240;
      v9 = uint64;
      v10 = 2048;
      v11 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "SetBTCoexParameters reason:%llu state:%llu", (uint8_t *)&v8, 0x16u);
    }
    if (!uint64)
    {
      *(_BYTE *)(a1 + 152) = 1;
      *(_BYTE *)(a1 + 153) = v6 != 0;
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
  {
    sub_10071C3B4();
  }
}

void sub_1006C716C(uint64_t a1, void *a2)
{
  xpc_object_t value;
  void *v5;
  _BOOL8 v6;
  uint64_t uint64;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  _DWORD v12[2];
  __int16 v13;
  int v14;
  __int16 v15;
  int v16;

  if ((MGGetBoolAnswer(CFSTR("ThreadRadioCapability")) & 1) != 0)
  {
    value = xpc_dictionary_get_value(a2, "kMessageArgs");
    if (value)
    {
      v5 = value;
      v6 = xpc_dictionary_get_BOOL(value, "kWCMBTRC2GrantEnable");
      uint64 = xpc_dictionary_get_uint64(v5, "kWCMBTRC2TimingT3");
      v8 = xpc_dictionary_get_uint64(v5, "kWCMBTRC2TimingT4");
      v9 = qword_1009997F0;
      if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
      {
        v12[0] = 67109632;
        v12[1] = v6;
        v13 = 1024;
        v14 = uint64;
        v15 = 1024;
        v16 = v8;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Received UCM GrantRC2MEdium and BT Suppression msg: enable: %d, t3Interval: %u, t4Interval: %u", (uint8_t *)v12, 0x14u);
      }
      if (*(_BYTE *)(a1 + 448) != v6)
      {
        *(_BYTE *)(a1 + 448) = v6;
        v10 = sub_1000438A4();
        (*(void (**)(uint64_t, _BOOL8))(*(_QWORD *)v10 + 3392))(v10, v6);
        v11 = sub_1000438A4();
        (*(void (**)(uint64_t, _BOOL8, uint64_t, uint64_t))(*(_QWORD *)v11 + 3384))(v11, v6, uint64, v8);
      }
    }
    else if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
    {
      sub_10071C3E0();
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
  {
    sub_10071C40C();
  }
}

void sub_1006C7328(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value;
  _BOOL4 v4;
  NSObject *v5;
  uint64_t v6;
  int v7;
  NSObject *v8;
  int v9;
  int v10;
  _BOOL4 v11;
  __int16 v12;
  int v13;

  value = xpc_dictionary_get_value(xdict, "kMessageArgs");
  if (value)
  {
    v4 = xpc_dictionary_get_BOOL(value, "kWCMAirplayCritical");
    v5 = qword_1009997F0;
    if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
    {
      v10 = 67109120;
      v11 = v4;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "WifiAirplayCriticalBuffering state: %d", (uint8_t *)&v10, 8u);
    }
    v6 = sub_1000438A4();
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v6 + 2592))(v6))
    {
      v7 = *(unsigned __int8 *)(a1 + 152);
      if (*(_BYTE *)(a1 + 152))
      {
        v8 = qword_1009997F0;
        if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
        {
          v9 = *(unsigned __int8 *)(a1 + 153);
          v10 = 67109376;
          v11 = v7;
          v12 = 1024;
          v13 = v9;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Overriding current CoexParameter state of Parameter: %d, State: %d", (uint8_t *)&v10, 0xEu);
        }
      }
      *(_BYTE *)(a1 + 152) = 2;
      *(_BYTE *)(a1 + 153) = v4;
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
  {
    sub_10071C438();
  }
}

void sub_1006C74AC(uint64_t a1, xpc_object_t xdict)
{
  _BYTE *data;
  uint64_t i;
  _OWORD *v5;
  uint64_t v6;
  uint8x16_t v7;
  uint16x8_t v8;
  uint16x8_t v9;
  uint8x16_t v10;
  uint16x8_t v11;
  uint16x8_t v12;
  uint8x16_t v13;
  uint16x8_t v14;
  uint16x8_t v15;
  uint8x16_t v16;
  uint16x8_t v17;
  uint16x8_t v18;
  uint8x16_t v19;
  uint16x8_t v20;
  uint16x8_t v21;
  uint8x16_t v22;
  uint16x8_t v23;
  uint16x8_t v24;
  NSObject *v25;
  uint64_t v26;
  char v27;
  int v28;
  char v29;
  uint64_t v30;
  uint64_t v31;
  NSObject *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unsigned __int8 *v36;
  char *v37;
  int v38;
  uint64_t v39;
  __int32 v40;
  int v41;
  int v42;
  __int32 v43;
  int v44;
  __int32 v45;
  _QWORD v46[5];
  size_t length;
  uint8_t buf[4];
  __int32 v49;
  __int16 v50;
  int v51;
  __int16 v52;
  int v53;
  __int16 v54;
  int v55;
  __int16 v56;
  int v57;
  __int16 v58;
  __int32 v59;
  __int16 v60;
  __int32 v61;
  uint64_t v62;
  int v63;
  uint16x8_t v64;
  char v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  _BYTE v77[201];
  uint64_t v78;
  int v79;
  uint64_t v80;
  int v81;

  length = 0;
  data = xpc_dictionary_get_data(xdict, "kMessageArgs", &length);
  if (data && length >= 0x60)
  {
    for (i = 0; i != 96; ++i)
      *(_BYTE *)(a1 + i + 168) = byte_10074380D[i] & data[i];
    v81 = 412948512;
    v80 = 0x17A31725165D141ELL;
    v78 = 0x7D007E007E0065;
    v79 = 8192125;
    v5 = &v65;
    memset(v77, 0, sizeof(v77));
    v76 = 0u;
    v75 = 0u;
    v74 = 0u;
    v73 = 0u;
    v72 = 0u;
    v71 = 0u;
    v70 = 0u;
    v69 = 0u;
    v68 = 0u;
    v67 = 0u;
    v66 = 0u;
    v6 = 168;
    v65 = -1;
    do
    {
      *v5 = *(_OWORD *)(a1 + v6);
      v5 = (_OWORD *)((char *)v5 + 63);
      v6 += 16;
    }
    while (v6 != 264);
    v7 = (uint8x16_t)vcntq_s8(*(int8x16_t *)(a1 + 168));
    v8 = vmovl_high_u8(v7);
    v9 = vmovl_u8(*(uint8x8_t *)v7.i8);
    v10 = (uint8x16_t)vcntq_s8(*(int8x16_t *)(a1 + 184));
    v11 = vmovl_high_u8(v10);
    v12 = vmovl_u8(*(uint8x8_t *)v10.i8);
    v13 = (uint8x16_t)vcntq_s8(*(int8x16_t *)(a1 + 200));
    v14 = vmovl_high_u8(v13);
    v15 = vmovl_u8(*(uint8x8_t *)v13.i8);
    v16 = (uint8x16_t)vcntq_s8(*(int8x16_t *)(a1 + 216));
    v17 = vmovl_high_u8(v16);
    v18 = vmovl_u8(*(uint8x8_t *)v16.i8);
    v19 = (uint8x16_t)vcntq_s8(*(int8x16_t *)(a1 + 232));
    v20 = vmovl_high_u8(v19);
    v21 = vmovl_u8(*(uint8x8_t *)v19.i8);
    v22 = (uint8x16_t)vcntq_s8(*(int8x16_t *)(a1 + 248));
    v23 = vmovl_high_u8(v22);
    v24 = vmovl_u8(*(uint8x8_t *)v22.i8);
    v23.i32[0] = vaddvq_s32(vaddq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v24.i8, *(uint16x4_t *)v23.i8), (int32x4_t)vaddl_high_u16(v24, v23)), (int32x4_t)xmmword_100743710));
    v20.i32[0] = vaddvq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v21.i8, *(uint16x4_t *)v20.i8), (int32x4_t)vaddl_high_u16(v21, v20)));
    v8.i32[0] = vaddvq_s32(vaddq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v9.i8, *(uint16x4_t *)v8.i8), (int32x4_t)vaddl_high_u16(v9, v8)), (int32x4_t)xmmword_1007436E0));
    v40 = v8.i32[0];
    v41 = vaddvq_s32(vaddq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v12.i8, *(uint16x4_t *)v11.i8), (int32x4_t)vaddl_high_u16(v12, v11)), (int32x4_t)xmmword_1007436F0));
    v8.i32[1] = v41;
    v62 = v8.i64[0];
    v63 = 0;
    v42 = vaddvq_s32(vaddq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v15.i8, *(uint16x4_t *)v14.i8), (int32x4_t)vaddl_high_u16(v15, v14)), (int32x4_t)xmmword_100743700));
    v43 = v23.i32[0];
    v8.i32[0] = v42;
    v44 = vaddvq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v18.i8, *(uint16x4_t *)v17.i8), (int32x4_t)vaddl_high_u16(v18, v17)));
    v45 = v20.i32[0];
    v8.i32[1] = v44;
    v8.i64[1] = __PAIR64__(v23.u32[0], v20.u32[0]);
    v64 = v8;
    v25 = qword_1009997F0;
    if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67110656;
      v49 = v40;
      v50 = 1024;
      v51 = v41;
      v52 = 1024;
      v53 = 0;
      v54 = 1024;
      v55 = v42;
      v56 = 1024;
      v57 = v44;
      v58 = 1024;
      v59 = v45;
      v60 = 1024;
      v61 = v43;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "PurpleCoexManager: TotalUniChannels received from cellular: unii1 %d, unii3 %d, unii4 %d, unii5a %d, unii5b %d, unii5c %d, unii5d %d", buf, 0x2Cu);
    }
    v26 = 0;
    v27 = 0;
    while (1)
    {
      v28 = *((_DWORD *)&v62 + v26);
      if (v28 <= 19)
      {
        *(_BYTE *)(a1 + v26 + 271) = 0;
      }
      else
      {
        ++v27;
        v29 = 1;
        *(_BYTE *)(a1 + v26 + 271) = 1;
        if (v28 > 0x31)
          goto LABEL_15;
      }
      v29 = 0;
LABEL_15:
      *(_BYTE *)(a1 + v26++ + 264) = v29;
      if (v26 == 7)
      {
        if (v27)
        {
          if (v27 == 6)
          {
            v30 = sub_1000438A4();
            (*(void (**)(uint64_t, uint64_t, uint64_t *, uint64_t *, char *, uint64_t))(*(_QWORD *)v30 + 1448))(v30, 3, &v80, &v78, &v65, 1);
            v31 = sub_1000438A4();
            (*(void (**)(uint64_t, uint64_t, char *, char *, _BYTE *, uint64_t))(*(_QWORD *)v31 + 1448))(v31, 3, (char *)&v80 + 6, (char *)&v78 + 6, &v77[12], 1);
          }
          else
          {
            v35 = 0;
            v36 = (unsigned __int8 *)(a1 + 271);
            v37 = &v65;
            do
            {
              v38 = *v36++;
              if (v38 == 1)
              {
                v39 = sub_1000438A4();
                (*(void (**)(uint64_t, uint64_t, char *, char *, char *, uint64_t))(*(_QWORD *)v39 + 1448))(v39, 1, (char *)&v80 + v35, (char *)&v78 + v35, v37, 1);
              }
              v37 += 63;
              v35 += 2;
            }
            while (v35 != 14);
          }
        }
        v46[0] = _NSConcreteStackBlock;
        v46[1] = 3221225472;
        v46[2] = sub_1006C8800;
        v46[3] = &unk_100940D48;
        v46[4] = a1;
        sub_10001AB14((os_unfair_lock_s *)(a1 + 480), v46);
        sub_1006C881C(a1, (const void *)(a1 + 168));
        return;
      }
    }
  }
  v32 = qword_1009997F0;
  if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
    sub_10071C464(v32, v33, v34);
}

uint64_t sub_1006C797C(uint64_t a1, xpc_object_t xdict)
{
  _BOOL4 v3;
  NSObject *v4;
  const char *v5;
  uint64_t v6;
  int v8;
  const char *v9;
  __int16 v10;
  const char *v11;

  v3 = xpc_dictionary_get_BOOL(xdict, "kMessageArgs");
  *(_BYTE *)(a1 + 278) = v3;
  v4 = qword_1009997F0;
  if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
  {
    v5 = "Disabled";
    if (v3)
      v5 = "Enabled";
    v8 = 136315394;
    v9 = "void BT::PurpleCoexManager::SetConditionalIdEnable(xpc_object_t)";
    v10 = 2080;
    v11 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%s, ConditionalIDEnable set to %s", (uint8_t *)&v8, 0x16u);
  }
  v6 = sub_1000438A4();
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, _QWORD, uint64_t))(*(_QWORD *)v6 + 2976))(v6, 0, 60, *(unsigned __int8 *)(a1 + 278) ^ 1u, 1);
}

uint64_t sub_1006C7A90(uint64_t a1, xpc_object_t xdict)
{
  _BOOL4 v3;
  NSObject *v4;
  const char *v5;
  uint64_t v6;
  int v8;
  const char *v9;
  __int16 v10;
  const char *v11;

  v3 = xpc_dictionary_get_BOOL(xdict, "kMessageArgs");
  *(_BYTE *)(a1 + 279) = v3;
  v4 = qword_1009997F0;
  if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
  {
    v5 = "Disabled";
    if (v3)
      v5 = "Enabled";
    v8 = 136315394;
    v9 = "void BT::PurpleCoexManager::SetMWSTxIndHRBEnable(xpc_object_t)";
    v10 = 2080;
    v11 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%s, MWSTxIndHRBEnable set to %s", (uint8_t *)&v8, 0x16u);
  }
  v6 = sub_1000438A4();
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, _QWORD, uint64_t))(*(_QWORD *)v6 + 2976))(v6, 0, 49, *(unsigned __int8 *)(a1 + 279) ^ 1u, 1);
}

void sub_1006C7BA4(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value;
  void *v4;
  int uint64;
  NSObject *v6;
  _BOOL4 v7;
  _BOOL4 v8;
  char v9;
  char v10;
  char v11;
  char v12;
  char v13;
  char v14;
  char v15;
  char v16;
  unsigned __int8 v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  NSObject *v22;
  uint8_t v23[16];
  _BYTE buf[12];
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;

  value = xpc_dictionary_get_value(xdict, "kMessageArgs");
  if (value)
  {
    v4 = value;
    uint64 = xpc_dictionary_get_uint64(value, "kWCMAntennaRequestInterval");
    v6 = qword_1009997F0;
    if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "void BT::PurpleCoexManager::SetAntennaRequest(xpc_object_t)";
      v25 = 1024;
      v26 = uint64;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%s, AntennaRequestInterval = %d", buf, 0x12u);
    }
    v7 = xpc_dictionary_get_BOOL(v4, "kWCMAntennaRequestUnii1Enabled");
    v8 = xpc_dictionary_get_BOOL(v4, "kWCMAntennaRequestUnii3Enabled");
    if (v7)
      v9 = 2;
    else
      v9 = 0;
    if (v8)
      v10 = 4;
    else
      v10 = 0;
    v11 = v10 | v9;
    if (xpc_dictionary_get_BOOL(v4, "kWCMAntennaRequestUnii5aEnabled"))
      v12 = 16;
    else
      v12 = 0;
    if (xpc_dictionary_get_BOOL(v4, "kWCMAntennaRequestUnii5bEnabled"))
      v13 = 32;
    else
      v13 = 0;
    v14 = v11 | v12 | v13;
    if (xpc_dictionary_get_BOOL(v4, "kWCMAntennaRequestUnii5cEnabled"))
      v15 = 64;
    else
      v15 = 0;
    if (xpc_dictionary_get_BOOL(v4, "kWCMAntennaRequestUnii5dEnabled"))
      v16 = 0x80;
    else
      v16 = 0;
    v17 = v14 | v15 | v16;
    v18 = qword_1009997F0;
    if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "void BT::PurpleCoexManager::SetAntennaRequest(xpc_object_t)";
      v25 = 1024;
      v26 = v17;
      v27 = 1024;
      v28 = uint64;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%s, Bitmap Sent to VSG MGS 53 = %d and AntennaRequestInterval = %d", buf, 0x18u);
    }
    v19 = sub_1000438A4();
    if ((*(unsigned int (**)(uint64_t, _QWORD, _QWORD, uint64_t))(*(_QWORD *)v19 + 2984))(v19, v17, uint64, 1))
    {
      if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
        sub_10071C564();
    }
    else if (*(_BYTE *)(a1 + 278))
    {
      *(_QWORD *)buf = 520093727;
      buf[1] = xpc_dictionary_get_uint64(v4, "kWCMBTConditionIdUnii1");
      buf[2] = xpc_dictionary_get_uint64(v4, "kWCMBTConditionIdUnii3");
      buf[4] = xpc_dictionary_get_uint64(v4, "kWCMBTConditionIdUnii5a");
      buf[5] = xpc_dictionary_get_uint64(v4, "kWCMBTConditionIdUnii5b");
      buf[6] = xpc_dictionary_get_uint64(v4, "kWCMBTConditionIdUnii5c");
      buf[7] = xpc_dictionary_get_uint64(v4, "kWCMBTConditionIdUnii5d");
      v20 = sub_1000438A4();
      v21 = (*(uint64_t (**)(uint64_t, _BYTE *, uint64_t))(*(_QWORD *)v20 + 2992))(v20, buf, 1);
      v22 = qword_1009997F0;
      if (v21)
      {
        if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
          sub_10071C504();
      }
      else if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v23 = 0;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "SPMI Type 60 config was called", v23, 2u);
      }
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
  {
    sub_10071C4D8();
  }
}

void sub_1006C7F38(os_unfair_lock_s *a1, xpc_object_t xdict)
{
  xpc_object_t value;
  _QWORD v4[7];

  value = xpc_dictionary_get_value(xdict, "kMessageArgs");
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_1006C88FC;
  v4[3] = &unk_100940D68;
  v4[4] = xpc_dictionary_get_uint64(value, "kWCMBTWiFiChannel");
  v4[5] = xpc_dictionary_get_uint64(value, "kWCMBTWiFiChannelBandwidth");
  v4[6] = xpc_dictionary_get_uint64(value, "kWCMBTWiFiRegulatoryBand");
  sub_10001AB14(a1 + 120, v4);
}

uint64_t sub_1006C7FF4(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, BOOL))(*(_QWORD *)a2 + 8))(a2, *(_BYTE *)(a1 + 32) == 1);
}

uint64_t sub_1006C8014(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, BOOL))(*(_QWORD *)a2 + 16))(a2, *(_BYTE *)(a1 + 32) == 1);
}

uint64_t sub_1006C8034(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, BOOL))(*(_QWORD *)a2 + 24))(a2, *(_BYTE *)(a1 + 32) == 1);
}

uint64_t sub_1006C8054(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, BOOL))(*(_QWORD *)a2 + 32))(a2, *(_BYTE *)(a1 + 32) == 1);
}

uint64_t sub_1006C8074(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, BOOL))(*(_QWORD *)a2 + 40))(a2, *(_BYTE *)(a1 + 32) == 1);
}

uint64_t sub_1006C8094(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, BOOL))(*(_QWORD *)a2 + 48))(a2, *(_BYTE *)(a1 + 32) == 1);
}

void sub_1006C80B4(uint64_t a1, int a2, int a3, unsigned int a4, int a5, uint64_t a6)
{
  int v11;
  uint64_t v12;
  _BOOL4 v14;
  NSObject *v15;
  const char *v16;
  const char *v17;
  const char *v18;
  const char *v19;
  const char *v20;
  const char *v21;
  int v22;
  __int16 v23;
  xpc_object_t v24;
  int v25;
  const char *v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  int v30;
  __int16 v31;
  const char *v32;
  __int16 v33;
  unsigned int v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  const char *v38;
  __int16 v39;
  const char *v40;
  __int16 v41;
  uint64_t v42;

  if (a2 <= 95)
  {
    switch(a2)
    {
      case 0:
        v12 = 0;
        v11 = 1;
        goto LABEL_21;
      case 48:
        v11 = 1;
        v12 = 1;
        goto LABEL_21;
      case 64:
        v11 = 1;
        v12 = 2;
        goto LABEL_21;
    }
    goto LABEL_16;
  }
  if (a2 == 96)
  {
    v11 = 1;
    v12 = 3;
    goto LABEL_21;
  }
  if (a2 != 144)
  {
    if (a2 == 480)
    {
      v11 = 1;
      v12 = 6;
      goto LABEL_21;
    }
LABEL_16:
    v11 = 0;
    v12 = -1;
    goto LABEL_21;
  }
  if (a3 == 48)
  {
    v11 = 1;
    v12 = 4;
  }
  else if (a3 == 16)
  {
    v11 = 1;
    v12 = 5;
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
      sub_10071C5C4();
    v12 = 1;
    v11 = 1;
  }
LABEL_21:
  v14 = byte_100994170 != a4 || v12 != byte_100994171;
  byte_100994170 = a4;
  byte_100994171 = v12;
  v15 = qword_1009997F0;
  if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_INFO))
  {
    v16 = "-";
    if (v14)
      v16 = ">";
    if (v11)
      v17 = off_100940F68[v12];
    else
      v17 = "NA";
    v18 = "NA";
    v19 = "NA";
    if (a4 <= 2)
      v19 = off_100940FA0[(char)a4];
    v20 = "kWCMWiFiStateBand5G";
    if (a5 == 2)
      v21 = "kWCMWiFiStateBand5G";
    else
      v21 = "NA";
    if (a5 == 1)
      v21 = "kWCMWiFiStateBand2_4G";
    v22 = *(unsigned __int8 *)(a1 + 162);
    if (v22 != 2)
      v20 = "NA";
    if (v22 == 1)
      v20 = "kWCMWiFiStateBand2_4G";
    v23 = *(_WORD *)(a1 + 160);
    if (v23 <= 2u)
      v18 = off_100940FB8[(char)v23];
    v25 = 136317186;
    v26 = v16;
    v27 = 2080;
    v28 = v17;
    v29 = 1024;
    v30 = a2;
    v31 = 2080;
    v32 = v19;
    v33 = 1024;
    v34 = a4;
    v35 = 2080;
    v36 = v21;
    v37 = 2080;
    v38 = v20;
    v39 = 2080;
    v40 = v18;
    v41 = 2048;
    v42 = a6;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_INFO, "WCMBTLeConnect(-%s) %s(0x%x) %s(%d) BT:%s WiFi:%s %s kWCMBTLeConnect_Duration:%llums", (uint8_t *)&v25, 0x54u);
  }
  if (v14)
  {
    v24 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_uint64(v24, "kWCMBTLeConnect_DC", v12);
    xpc_dictionary_set_uint64(v24, "kWCMBTLeConnect_OverrideReason", a4);
    xpc_dictionary_set_uint64(v24, "kWCMBTLeConnect_Band", 0);
    xpc_dictionary_set_uint64(v24, "kWCMBTLeConnect_Duration", a6);
    sub_1006C4A48(a1, 0x6CuLL, v24);
    xpc_release(v24);
  }
}

uint64_t sub_1006C83F0(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v10;
  __int16 v11;
  _QWORD v13[5];
  uint64_t v14;
  int v15;
  _QWORD v16[5];
  char v17;
  void *__p[2];
  char v19;
  uint8_t buf[8];
  char v21;
  _QWORD v22[2];

  v22[0] = 0;
  v22[1] = 0;
  sub_10003415C((uint64_t)v22, a1 + 80);
  v2 = sub_100027F68();
  sub_100091AE8(buf, "COEXDEBUG");
  sub_100091AE8(__p, "Enabled");
  (*(void (**)(uint64_t, uint8_t *, void **, uint64_t))(*(_QWORD *)v2 + 72))(v2, buf, __p, a1 + 280);
  if (v19 < 0)
    operator delete(__p[0]);
  if (v21 < 0)
    operator delete(*(void **)buf);
  if (*(_BYTE *)(a1 + 280))
  {
    v3 = qword_1009997F0;
    if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "PurpleCoexManager::debugWifiStateUpdate COEXDEBUG", buf, 2u);
    }
    v17 = 0;
    v4 = sub_100027F68();
    sub_100091AE8(buf, "COEXDEBUG");
    sub_100091AE8(__p, "wifiStatePower");
    v5 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, char *))(*(_QWORD *)v4 + 72))(v4, buf, __p, &v17);
    if (v19 < 0)
      operator delete(__p[0]);
    if (v21 < 0)
      operator delete(*(void **)buf);
    if (v17)
      v6 = 0;
    else
      v6 = v5;
    if (v6 == 1)
    {
      *(_DWORD *)(a1 + 160) = 0;
      *(_WORD *)(a1 + 166) = 0;
      v16[0] = _NSConcreteStackBlock;
      v16[1] = 3221225472;
      v16[2] = sub_1006C8764;
      v16[3] = &unk_100940D48;
      v16[4] = a1;
      sub_10001AB14((os_unfair_lock_s *)(a1 + 480), v16);
    }
    else
    {
      v15 = 0;
      v7 = sub_100027F68();
      sub_100091AE8(buf, "COEXDEBUG");
      sub_100091AE8(__p, "wifiStateBand");
      v8 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, int *))(*(_QWORD *)v7 + 88))(v7, buf, __p, &v15);
      if (v19 < 0)
        operator delete(__p[0]);
      if (v21 < 0)
        operator delete(*(void **)buf);
      if (v8)
        *(_WORD *)(a1 + 162) = v15;
      v14 = 0;
      v9 = sub_100027F68();
      sub_100091AE8(buf, "COEXDEBUG");
      sub_100091AE8(__p, "UCMWifiStateBitmap");
      v10 = (*(uint64_t (**)(uint64_t, uint8_t *, void **, uint64_t *))(*(_QWORD *)v9 + 144))(v9, buf, __p, &v14);
      if (v19 < 0)
        operator delete(__p[0]);
      if (v21 < 0)
        operator delete(*(void **)buf);
      if (v10)
      {
        v11 = v14 != 0;
        *(_WORD *)(a1 + 166) = v14;
        *(_WORD *)(a1 + 160) = 2 * v11;
      }
      v13[0] = _NSConcreteStackBlock;
      v13[1] = 3221225472;
      v13[2] = sub_1006C8780;
      v13[3] = &unk_100940D48;
      v13[4] = a1;
      sub_10001AB14((os_unfair_lock_s *)(a1 + 480), v13);
    }
  }
  return sub_100034234((uint64_t)v22);
}

void sub_1006C86EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  uint64_t v27;

  if (a27 < 0)
    operator delete(__p);
  if (*(char *)(v27 - 57) < 0)
    operator delete(*(void **)(v27 - 80));
  sub_100034234(v27 - 48);
  _Unwind_Resume(a1);
}

uint64_t sub_1006C8764(uint64_t a1, uint64_t (***a2)(_QWORD, _QWORD))
{
  return (**a2)(a2, *(unsigned __int16 *)(*(_QWORD *)(a1 + 32) + 166));
}

uint64_t sub_1006C8780(uint64_t a1, uint64_t (***a2)(_QWORD, _QWORD))
{
  return (**a2)(a2, *(unsigned __int16 *)(*(_QWORD *)(a1 + 32) + 166));
}

void sub_1006C879C()
{
  NSObject *v0;
  uint8_t v1[16];

  v0 = qword_1009997F0;
  if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)v1 = 0;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_INFO, "Set AFH CB", v1, 2u);
  }
}

uint64_t sub_1006C8800(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 56))(a2, *(_QWORD *)(a1 + 32) + 264);
}

void sub_1006C881C(uint64_t a1, const void *a2)
{
  NSObject *v4;
  xpc_object_t v5;
  uint8_t v6[16];
  uint8_t buf[16];

  v4 = qword_1009997F0;
  if (!a2 && os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Error: BT is trying to send an empty map to UCM", buf, 2u);
    v4 = qword_1009997F0;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "BT Sending HRB AFH MAP to WCM", v6, 2u);
  }
  v5 = xpc_data_create(a2, 0x60uLL);
  sub_1006C4A48(a1, 0x205uLL, v5);
  xpc_release(v5);
}

uint64_t sub_1006C88FC(_QWORD *a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD))(*(_QWORD *)a2 + 64))(a2, a1[4], a1[5], a1[6]);
}

void sub_1006C8918(int a1)
{
  NSObject *v2;
  _DWORD v3[2];

  v2 = qword_1009997F0;
  if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
  {
    v3[0] = 67109120;
    v3[1] = a1;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Set LE AFH CB status = %{bluetooth:OI_STATUS}u", (uint8_t *)v3, 8u);
  }
}

uint64_t sub_1006C89B8(uint64_t result, _BYTE *a2, _BYTE *a3)
{
  *a2 = *(_BYTE *)(result + 152);
  *a3 = *(_BYTE *)(result + 153);
  return result;
}

uint64_t sub_1006C89CC(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = sub_10003BE44();
  if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 352))(v2) & 1) == 0)
  {
    v3 = sub_10003BE44();
    if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 360))(v3) & 1) == 0)
    {
      v4 = sub_10003BE44();
      if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 424))(v4) & 1) == 0)
        *(_DWORD *)(a1 + 156) = 0;
    }
  }
  return *(unsigned int *)(a1 + 156);
}

uint64_t sub_1006C8A2C(uint64_t a1)
{
  return (*(unsigned __int16 *)(a1 + 166) >> 6) & 1;
}

BOOL sub_1006C8A38(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 162) == 1;
}

void sub_1006C8A48(uint64_t a1, unint64_t a2, unsigned int a3, unsigned int a4, int a5)
{
  id v8;
  id v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  id v16;
  id v17;
  unint64_t v18;
  int v19;
  uint64_t v20;
  xpc_object_t v21;
  NSObject *v22;
  char *string;
  char v26;
  int v27;
  __int16 v28;
  _BYTE buf[12];
  __int16 v30;
  unsigned int v31;
  __int16 v32;
  unsigned int v33;
  __int16 v34;
  int v35;
  __int16 v36;
  uint64_t v37;
  __int16 v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  __int16 v42;
  uint64_t v43;
  __int16 v44;
  uint64_t v45;
  __int16 v46;
  uint64_t v47;
  __int16 v48;
  uint64_t v49;

  if (a3 == 0x8000)
  {
    v8 = sub_100021770(a2);
    v9 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(v8));
    string = (char *)objc_msgSend(v9, "UTF8String");

    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v15 = 0;
  }
  else
  {
    v16 = sub_100649588(a2);
    v17 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(v16));
    string = (char *)objc_msgSend(v17, "UTF8String");

    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    if (a4 == 11 && !a5)
    {
      *(_QWORD *)buf = 0;
      v18 = sub_100225368(a2);
      v27 = v18;
      v28 = WORD2(v18);
      v26 = 0;
      sub_100043758(&v26);
      v19 = sub_100182680((uint64_t)&v27, (uint64_t)buf);
      sub_10004339C(&v26);
      if (v19)
      {
        if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
          sub_10071C640();
        v10 = 0;
        v11 = 0;
        v12 = 0;
        v13 = 0;
        v14 = 0;
      }
      else
      {
        v10 = buf[0];
        v11 = buf[1];
        v12 = buf[2];
        v13 = *(unsigned __int16 *)&buf[4];
        v14 = *(unsigned __int16 *)&buf[6];
      }
      sub_100043728(&v26);
    }
    if (qword_1009778E8 != -1)
      dispatch_once(&qword_1009778E8, &stru_100940E78);
    v20 = sub_10006D488((uint64_t)off_1009778E0, a2, 0);
    v15 = v20;
    if (v20)
    {
      if ((sub_100444F1C(v20) & 1) != 0)
      {
        v15 = 1;
      }
      else if (sub_100444F28(v15))
      {
        v15 = 2;
      }
      else
      {
        v15 = 0;
      }
    }
  }
  v21 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v21, "kWCMBTConnectionConfiguration_Address", string);
  xpc_dictionary_set_uint64(v21, "kWCMBTConnectionConfiguration_ServiceId", a3);
  xpc_dictionary_set_uint64(v21, "kWCMBTConnectionConfiguration_EventId", a4);
  xpc_dictionary_set_uint64(v21, "kWCMBTConnectionConfiguration_Result", a5);
  if (a3 != 0x8000)
  {
    xpc_dictionary_set_uint64(v21, "kWCMBTConnectionConfiguration_DeviceType", v10);
    xpc_dictionary_set_uint64(v21, "kWCMBTConnectionConfiguration_Role", v11);
    xpc_dictionary_set_uint64(v21, "kWCMBTConnectionConfiguration_Mode", v12);
    xpc_dictionary_set_uint64(v21, "kWCMBTConnectionConfiguration_ConnTo", v13);
    xpc_dictionary_set_uint64(v21, "kWCMBTConnectionConfiguration_ConnIntrvl", v14);
    xpc_dictionary_set_uint64(v21, "kWCMBTConnectionConfiguration_Latncy", 0);
    xpc_dictionary_set_uint64(v21, "kWCMBTConnectionConfiguration_RequiresRC2CoExType", v15);
  }
  v22 = qword_1009997F0;
  if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136317698;
    *(_QWORD *)&buf[4] = string;
    v30 = 1024;
    v31 = a3;
    v32 = 1024;
    v33 = a4;
    v34 = 1024;
    v35 = a5;
    v36 = 2048;
    v37 = v10;
    v38 = 2048;
    v39 = v11;
    v40 = 2048;
    v41 = v12;
    v42 = 2048;
    v43 = v13;
    v44 = 2048;
    v45 = v14;
    v46 = 2048;
    v47 = 0;
    v48 = 2048;
    v49 = v15;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Sending Connection Config: Address: %s, ServiceId: %u, EventId: %u, Result: %d, DeviceType: %llu, Role: %llu, Mode: %llu, ConnTo: %llu, ConnIntrv: %llu, Latency: %llu, RC2CoExType: %llu", buf, 0x64u);
  }
  sub_1006C4A48(a1, 0x1F4uLL, v21);
  xpc_release(v21);
}

void sub_1006C8E1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  sub_100043728(&a16);
  _Unwind_Resume(a1);
}

void sub_1006C8E48(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, int a6, unsigned int a7)
{
  id v7;
  id v8;
  id v14;
  const char *v15;
  id v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  unint64_t v22;
  BOOL v23;
  _QWORD *v24;
  NSObject *v25;
  uint64_t v26;
  const char *v27;
  NSObject *v28;
  uint32_t v29;
  NSObject *v30;
  uint64_t v31;
  NSObject *v32;
  xpc_object_t v33;
  NSObject *v34;
  char v36;
  int v37;
  __int16 v38;
  unsigned __int8 v39;
  uint64_t v40;
  unint64_t v41;
  _BYTE buf[12];
  __int16 v43;
  _BYTE v44[14];
  __int16 v45;
  int v46;
  __int16 v47;
  int v48;
  __int16 v49;
  int v50;
  __int16 v51;
  uint64_t v52;
  __int16 v53;
  uint64_t v54;

  v41 = a2;
  if (a4 == 0x10000 || a4 == 0x400000)
  {
    v14 = sub_100021770(a2);
    v7 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(v14));
    v15 = (const char *)objc_msgSend(v7, "UTF8String");
  }
  else
  {
    v16 = sub_100649588(a2);
    v8 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(v16));
    v15 = (const char *)objc_msgSend(v8, "UTF8String");
  }
  if (a4 == 0x400000 || a4 == 0x10000)
  {

    v17 = 0;
    v18 = 0;
    goto LABEL_49;
  }

  v40 = 0;
  v39 = 0;
  v19 = sub_100225368(v41);
  v37 = v19;
  v38 = WORD2(v19);
  v36 = 0;
  sub_100043758(&v36);
  if (sub_100182680((uint64_t)&v37, (uint64_t)&v40))
  {
    if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
      sub_10071C700();
    v17 = 0;
  }
  else
  {
    v17 = BYTE1(v40);
  }
  v18 = 0;
  if (a5 > 109)
  {
    if (a5 == 110)
    {
      v30 = qword_1009997F0;
      if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "set packetype to 1 for BT_SERVICE_A2DP_LOW_LATENCY_ON", buf, 2u);
      }
      v18 = 1;
      goto LABEL_48;
    }
    if (a5 == 111)
    {
      v26 = qword_1009997F0;
      if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        v27 = "set packetype to 2 for BT_SERVICE_A2DP_LOW_LATENCY_OFF";
        v18 = 2;
        v28 = v26;
        v29 = 2;
LABEL_44:
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, v27, buf, v29);
        goto LABEL_48;
      }
      v18 = 2;
    }
LABEL_48:
    sub_10004339C(&v36);
    sub_100043728(&v36);
LABEL_49:
    v33 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_string(v33, "kWCMBTAudioConfiguration_Address", v15);
    xpc_dictionary_set_uint64(v33, "kWCMBTAudioConfiguration_ConnectionState", a7);
    xpc_dictionary_set_uint64(v33, "kWCMBTAudioConfiguration_Type", a3);
    if (a4 != 0x10000 && a4 != 0x400000)
    {
      xpc_dictionary_set_uint64(v33, "kWCMBTAudioConfiguration_Role", v17);
      xpc_dictionary_set_uint64(v33, "kWCMBTAudioConfiguration_PacketType", v18);
    }
    v34 = qword_1009997F0;
    if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136316930;
      *(_QWORD *)&buf[4] = v15;
      v43 = 1024;
      *(_DWORD *)v44 = a7;
      *(_WORD *)&v44[4] = 2048;
      *(_QWORD *)&v44[6] = a3;
      v45 = 1024;
      v46 = a4;
      v47 = 1024;
      v48 = a5;
      v49 = 1024;
      v50 = a6;
      v51 = 2048;
      v52 = v17;
      v53 = 2048;
      v54 = v18;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "Sending Audio Config: Address: %s, Connection: %d, Type: %llu, ServiceId: %u, Event: %u, Result: %d, Role: %llu, PacketType: %llu", buf, 0x42u);
    }
    sub_1006C4A48(a1, 0x1F5uLL, v33);
    xpc_release(v33);
    return;
  }
  if (a5 != 101)
  {
    if (a5 == 102)
    {
      v20 = *(_QWORD **)(a1 + 432);
      if (!v20)
        goto LABEL_27;
      v21 = a1 + 432;
      do
      {
        v22 = v20[4];
        v23 = v22 >= v41;
        if (v22 >= v41)
          v24 = v20;
        else
          v24 = v20 + 1;
        if (v23)
          v21 = (uint64_t)v20;
        v20 = (_QWORD *)*v24;
      }
      while (*v24);
      if (v21 != a1 + 432 && v41 >= *(_QWORD *)(v21 + 32))
      {
        *(_QWORD *)buf = &v41;
        v18 = sub_10002252C((uint64_t **)(a1 + 424), &v41, (uint64_t)&unk_100740F58, (uint64_t **)buf)[5];
        v32 = qword_1009997F0;
        if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = v15;
          v43 = 2048;
          *(_QWORD *)v44 = v18;
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "Found device %{public}s in fScoPacketTypeMap. Sending packet type %llu", buf, 0x16u);
        }
        sub_100015ECC(a1 + 424, &v41);
      }
      else
      {
LABEL_27:
        v25 = qword_1009997F0;
        if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = v15;
          v43 = 2048;
          *(_QWORD *)v44 = 0;
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Did not find device %{public}s in fScoPacketTypeMap. Sending packet type %llu", buf, 0x16u);
        }
        v18 = 0;
      }
    }
    goto LABEL_48;
  }
  if (!sub_1001826F0((uint64_t)&v37, &v39))
  {
    v18 = v39;
    *(_QWORD *)buf = &v41;
    sub_10002252C((uint64_t **)(a1 + 424), &v41, (uint64_t)&unk_100740F58, (uint64_t **)buf)[5] = v18;
    v31 = qword_1009997F0;
    if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134218242;
      *(_QWORD *)&buf[4] = v18;
      v43 = 2082;
      *(_QWORD *)v44 = v15;
      v27 = "Got voice connection info. Sending packet type %llu for device %{public}s";
      v28 = v31;
      v29 = 22;
      goto LABEL_44;
    }
    goto LABEL_48;
  }
  if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
    sub_10071C6A0();
  sub_100043728(&v36);
}

void sub_1006C93E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  sub_100043728(&a13);
  _Unwind_Resume(a1);
}

uint64_t sub_1006C942C(uint64_t a1)
{
  NSObject *v2;
  int v3;
  _QWORD v5[2];
  uint8_t buf[4];
  int v7;

  v5[0] = 0;
  v5[1] = 0;
  sub_10003415C((uint64_t)v5, a1 + 80);
  while (*(_QWORD *)(a1 + 392))
  {
    v2 = qword_1009997F0;
    if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
    {
      v3 = *(_DWORD *)(a1 + 320);
      *(_DWORD *)buf = 67109120;
      v7 = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Warning: Bandwidth: There was still connection 0x%1X in the map after ACL Disconnectd headset!", buf, 8u);
    }
    sub_1006C9540(a1, *(_DWORD *)(a1 + 320), 0);
  }
  return sub_100034234((uint64_t)v5);
}

void sub_1006C9524(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006C9540(uint64_t a1, unsigned int a2, char a3)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  const char *v9;
  NSObject *v10;
  uint32_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  BOOL v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  BOOL v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  int v25;
  int v26;
  _QWORD *v27;
  _QWORD *v28;
  BOOL v29;
  NSObject *v30;
  _BOOL8 v31;
  uint64_t v32;
  _QWORD v34[5];
  _QWORD v35[2];
  uint64_t buf;

  v35[0] = 0;
  v35[1] = 0;
  v6 = sub_10003415C((uint64_t)v35, a1 + 80);
  v7 = *(_DWORD *)(a1 + 320);
  if ((a3 & 1) != 0)
  {
    if (v7 == a2)
    {
      v8 = qword_1009997F0;
      if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        v9 = "Warning: Bandwidth: Received a connection that is currently active!";
        v10 = v8;
        v11 = 2;
LABEL_33:
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&buf, v11);
        return sub_100034234((uint64_t)v35);
      }
      return sub_100034234((uint64_t)v35);
    }
    v17 = *(_QWORD *)(a1 + 384);
    if (v17)
    {
      v18 = a1 + 384;
      do
      {
        v19 = *(_DWORD *)(v17 + 28);
        v20 = v19 >= a2;
        if (v19 >= a2)
          v21 = (uint64_t *)v17;
        else
          v21 = (uint64_t *)(v17 + 8);
        if (v20)
          v18 = v17;
        v17 = *v21;
      }
      while (*v21);
      if (v18 != a1 + 384 && *(_DWORD *)(v18 + 28) <= a2)
      {
        if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
          sub_10071C760();
        return sub_100034234((uint64_t)v35);
      }
    }
    buf = __PAIR64__(sub_1006C98DC(v6, a2), a2);
    v22 = (uint64_t)sub_1006CC250((uint64_t **)(a1 + 376), (unsigned int *)&buf, &buf);
LABEL_35:
    if (!*(_DWORD *)(a1 + 392) || (v24 = *(_QWORD **)(a1 + 376), v24 == (_QWORD *)(a1 + 384)))
    {
      v25 = 0;
    }
    else
    {
      v25 = 0;
      do
      {
        v26 = *((_DWORD *)v24 + 8);
        v22 = sub_1006C98DC(v22, v25);
        if (v26 > (int)v22)
          v25 = *((_DWORD *)v24 + 7);
        v27 = (_QWORD *)v24[1];
        if (v27)
        {
          do
          {
            v28 = v27;
            v27 = (_QWORD *)*v27;
          }
          while (v27);
        }
        else
        {
          do
          {
            v28 = (_QWORD *)v24[2];
            v29 = *v28 == (_QWORD)v24;
            v24 = v28;
          }
          while (!v29);
        }
        v24 = v28;
      }
      while (v28 != (_QWORD *)(a1 + 384));
    }
    *(_DWORD *)(a1 + 288) -= sub_1006C993C(v22, *(_DWORD *)(a1 + 316));
    *(_DWORD *)(a1 + 316) = v25;
    v30 = qword_1009997F0;
    v31 = os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT);
    if (v31)
    {
      LODWORD(buf) = 67109120;
      HIDWORD(buf) = v25;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "Bandwidth: Audio connection 0x%1X, is the current Active Audio Profile", (uint8_t *)&buf, 8u);
      v25 = *(_DWORD *)(a1 + 316);
    }
    *(_DWORD *)(a1 + 288) += sub_1006C993C(v31, v25);
    *(_DWORD *)(a1 + 320) = *(_DWORD *)(a1 + 316);
    v32 = sub_10006BBEC();
    v34[0] = _NSConcreteStackBlock;
    v34[1] = 3221225472;
    v34[2] = sub_1006C999C;
    v34[3] = &unk_100917378;
    v34[4] = a1;
    sub_100041A34(v32, v34);
    return sub_100034234((uint64_t)v35);
  }
  if (v7)
  {
    v12 = *(_QWORD *)(a1 + 384);
    if (!v12)
      goto LABEL_56;
    v13 = a1 + 384;
    do
    {
      v14 = *(_DWORD *)(v12 + 28);
      v15 = v14 >= a2;
      if (v14 >= a2)
        v16 = (uint64_t *)v12;
      else
        v16 = (uint64_t *)(v12 + 8);
      if (v15)
        v13 = v12;
      v12 = *v16;
    }
    while (*v16);
    if (v13 == a1 + 384 || *(_DWORD *)(v13 + 28) > a2)
    {
LABEL_56:
      if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
        sub_10071C7C0();
      return sub_100034234((uint64_t)v35);
    }
    sub_1000040CC((uint64_t **)(a1 + 376), (uint64_t *)v13);
    operator delete((void *)v13);
    goto LABEL_35;
  }
  v23 = qword_1009997F0;
  if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 67109120;
    HIDWORD(buf) = a2;
    v9 = "Warning: Bandwidth: Tried removing connection 0x%1X from the map, but there was no active audio connection!";
    v10 = v23;
    v11 = 8;
    goto LABEL_33;
  }
  return sub_100034234((uint64_t)v35);
}

void sub_1006C98B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  sub_100034234((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1006C98D4(uint64_t a1)
{
  return sub_1006C942C(a1 - 72);
}

uint64_t sub_1006C98DC(uint64_t a1, int a2)
{
  unsigned int v2;
  unint64_t v3;
  uint64_t result;

  HIDWORD(v3) = a2;
  LODWORD(v3) = a2;
  v2 = v3 >> 8;
  if (v2 < 0xB)
    return dword_100743894[v2];
  result = os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR);
  if ((_DWORD)result)
  {
    sub_10071C820();
    return 0;
  }
  return result;
}

uint64_t sub_1006C993C(uint64_t a1, int a2)
{
  unsigned int v2;
  unint64_t v3;
  uint64_t result;

  HIDWORD(v3) = a2;
  LODWORD(v3) = a2;
  v2 = v3 >> 8;
  if (v2 < 0xB)
    return dword_1007438C0[v2];
  result = os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR);
  if ((_DWORD)result)
  {
    sub_10071C84C();
    return 0;
  }
  return result;
}

uint64_t sub_1006C999C(uint64_t a1)
{
  return sub_1006C466C(*(uint32x2_t **)(a1 + 32));
}

uint64_t sub_1006C99A4(uint64_t a1, char a2)
{
  return sub_1006C9540(a1, 0x900u, a2);
}

uint64_t sub_1006C99B0(uint32x2_t *a1, uint64_t a2, int a3, int a4, int a5)
{
  uint64_t v10;
  int v11;
  NSObject *v12;
  int v13;
  unsigned int v14;
  char v15;
  NSObject *v16;
  const char *v17;
  const char *v18;
  uint32x2_t v19;
  uint32x2_t *v20;
  uint32x2_t *v21;
  uint32x2_t v22;
  unsigned int v23;
  BOOL v24;
  uint32x2_t *v25;
  unsigned int v26;
  uint64_t v27;
  uint32x2_t *v28;
  uint32x2_t *v29;
  unsigned int v30;
  uint32x2_t *v31;
  unsigned int v32;
  BOOL v33;
  uint32x2_t **v34;
  NSObject *v35;
  const char *v36;
  const char *v37;
  const char *v38;
  NSObject *v39;
  uint64_t v40;
  uint32x2_t *v41;
  uint32x2_t v42;
  unsigned int v43;
  BOOL v44;
  uint32x2_t *v45;
  uint32x2_t *v46;
  unsigned int v47;
  BOOL v48;
  uint32x2_t *v49;
  _QWORD v51[2];
  int v52;
  int v53;
  uint8_t buf[4];
  double v55;
  __int16 v56;
  const char *v57;
  __int16 v58;
  int v59;
  char v60[24];

  v52 = a4;
  v53 = a3;
  v51[0] = 0;
  v51[1] = 0;
  sub_10003415C((uint64_t)v51, (uint64_t)&a1[10]);
  if (a3 == 16)
  {
    if (a4 <= 110)
    {
      switch(a4)
      {
        case 11:
          if (a1[35].i8[1])
            goto LABEL_70;
          a1[36].i32[0] += 27;
          a1[35].i8[1] = 1;
          break;
        case 12:
          if (!a1[35].i8[1])
            goto LABEL_70;
          a1[36].i32[0] -= 27;
          a1[35].i8[1] = 0;
          break;
        case 110:
          v15 = 1;
LABEL_64:
          v26 = 1024;
          goto LABEL_65;
        default:
          goto LABEL_70;
      }
      sub_1006C466C(a1);
      return sub_100034234((uint64_t)v51);
    }
    if (a4 == 111)
    {
      v15 = 0;
      goto LABEL_64;
    }
    if (a4 == 201)
    {
      if (!a1[35].i8[2])
      {
        a1[35].i8[2] = 1;
        sub_1006C9540((uint64_t)a1, 0x300u, 1);
        if (!a1[35].i8[1])
        {
          a1[36].i32[0] += 27;
          a1[35].i8[1] = 1;
        }
        return sub_100034234((uint64_t)v51);
      }
      if (a2)
      {
        if (*(_WORD *)(a2 + 978))
        {
          sub_1006C9540((uint64_t)a1, 0x800u, 1);
        }
        else if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
        {
          sub_10071C910();
        }
        return sub_100034234((uint64_t)v51);
      }
    }
    else if (a4 == 202 && a1[35].i8[2])
    {
      v19 = a1[48];
      if (v19)
      {
        v20 = a1 + 48;
        v21 = a1 + 48;
        v22 = a1[48];
        do
        {
          v23 = *(_DWORD *)(*(_QWORD *)&v22 + 28);
          v24 = v23 >= 0x800;
          if (v23 >= 0x800)
            v25 = (uint32x2_t *)v22;
          else
            v25 = (uint32x2_t *)(*(_QWORD *)&v22 + 8);
          if (v24)
            v21 = (uint32x2_t *)v22;
          v22 = *v25;
        }
        while (*v25);
        if (v21 != v20 && v21[3].i32[1] < 0x801u)
        {
          v15 = 0;
          v26 = 2048;
LABEL_65:
          sub_1006C9540((uint64_t)a1, v26, v15);
          return sub_100034234((uint64_t)v51);
        }
        v41 = a1 + 48;
        v42 = a1[48];
        do
        {
          v43 = *(_DWORD *)(*(_QWORD *)&v42 + 28);
          v44 = v43 >= 0x300;
          if (v43 >= 0x300)
            v45 = (uint32x2_t *)v42;
          else
            v45 = (uint32x2_t *)(*(_QWORD *)&v42 + 8);
          if (v44)
            v41 = (uint32x2_t *)v42;
          v42 = *v45;
        }
        while (*v45);
        if (v41 != v20 && v41[3].i32[1] <= 0x300u)
        {
          sub_1006C9540((uint64_t)a1, 0x300u, 0);
          v19 = *v20;
        }
        if (v19)
        {
          v46 = a1 + 48;
          do
          {
            v47 = *(_DWORD *)(*(_QWORD *)&v19 + 28);
            v48 = v47 >= 0x400;
            if (v47 >= 0x400)
              v49 = (uint32x2_t *)v19;
            else
              v49 = (uint32x2_t *)(*(_QWORD *)&v19 + 8);
            if (v48)
              v46 = (uint32x2_t *)v19;
            v19 = *v49;
          }
          while (*v49);
          if (v46 != v20 && v46[3].i32[1] <= 0x400u)
            sub_1006C9540((uint64_t)a1, 0x400u, 0);
        }
      }
      a1[35].i8[2] = 0;
      return sub_100034234((uint64_t)v51);
    }
LABEL_70:
    v35 = qword_1009997F0;
    if (!os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
      return sub_100034234((uint64_t)v51);
    v36 = sub_10049B4F4(&v52);
    *(_DWORD *)buf = 136315394;
    v55 = *(double *)&v36;
    v56 = 1024;
    LODWORD(v57) = a5;
    v37 = "Bandwidth: A2DP event %s, not counted as bandwidth. BTResult %d";
    goto LABEL_74;
  }
  if (a3 == 1)
  {
    if ((a4 - 11) < 2)
      return sub_100034234((uint64_t)v51);
    if (!a5 && a4 == 101)
    {
      if (qword_10097AA40 != -1)
        dispatch_once(&qword_10097AA40, &stru_100940EB8);
      v10 = sub_1004CD5FC((uint64_t)off_10097AA38, a2);
      if (v10)
      {
        v11 = sub_10026BB2C(v10 + 400);
        v12 = qword_1009997F0;
        if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134217984;
          v55 = (double)v11 * 0.625;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Bandwidth: HFP Connection has a transmission rate of %fMS", buf, 0xCu);
        }
        if (v11 == 12)
          v13 = 512;
        else
          v13 = 256;
        if (v11 <= 12)
          v14 = v13;
        else
          v14 = 2560;
        sub_1006C9540((uint64_t)a1, v14, 1);
      }
      else
      {
        sub_1006C9540((uint64_t)a1, 0x100u, 1);
        v39 = qword_1009997F0;
        if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
        {
          if (a2)
          {
            sub_10043E5F8(a2, buf);
            sub_10071C8B8();
          }
          else
          {
            sub_10071C878((uint64_t)v60, v39, v40);
          }
        }
      }
      return sub_100034234((uint64_t)v51);
    }
    if (!a5 && a4 == 102)
    {
      v27 = 0;
      v28 = a1 + 48;
      do
      {
        v29 = (uint32x2_t *)*v28;
        if (*v28)
        {
          v30 = dword_100743888[v27];
          v31 = a1 + 48;
          do
          {
            v32 = v29[3].u32[1];
            v33 = v32 >= v30;
            if (v32 >= v30)
              v34 = (uint32x2_t **)v29;
            else
              v34 = (uint32x2_t **)&v29[1];
            if (v33)
              v31 = v29;
            v29 = *v34;
          }
          while (*v34);
          if (v31 != v28 && v30 >= v31[3].i32[1])
            sub_1006C9540((uint64_t)a1, v30, 0);
        }
        ++v27;
      }
      while (v27 != 3);
      return sub_100034234((uint64_t)v51);
    }
    v35 = qword_1009997F0;
    if (!os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
      return sub_100034234((uint64_t)v51);
    v38 = sub_10049B4F4(&v52);
    *(_DWORD *)buf = 136315394;
    v55 = *(double *)&v38;
    v56 = 1024;
    LODWORD(v57) = a5;
    v37 = "Bandwidth: HFP event %s, not counted as bandwidth. BTResult %d";
LABEL_74:
    _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, v37, buf, 0x12u);
    return sub_100034234((uint64_t)v51);
  }
  v16 = qword_1009997F0;
  if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
  {
    v17 = sub_10049B308(&v53);
    v18 = sub_10049B4F4(&v52);
    *(_DWORD *)buf = 136315650;
    v55 = *(double *)&v17;
    v56 = 2080;
    v57 = v18;
    v58 = 1024;
    v59 = a5;
    _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Bandwidth: No matching bandwidth item for serviceID %s, eventID %s, BTResult %d", buf, 0x1Cu);
  }
  return sub_100034234((uint64_t)v51);
}

void sub_1006C9F54(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_100034234((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1006C9F90(uint64_t a1, uint64_t a2, int a3, int a4)
{
  unsigned int v8;
  NSObject *v9;
  void **v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  _QWORD v15[5];
  void *__p;
  char v17;
  _QWORD v18[2];
  uint8_t buf[4];
  void **v20;
  __int16 v21;
  double v22;

  v18[0] = 0;
  v18[1] = 0;
  sub_10003415C((uint64_t)v18, a1 + 80);
  if (a3 == 0x10000)
  {
    if (a4 == 802)
    {
      if (*(_BYTE *)(a1 + 283))
      {
        *(_BYTE *)(a1 + 283) = 0;
        v12 = *(_DWORD *)(a1 + 316);
        if (v12 == 1280 || v12 == 1792 || v12 == 1536)
        {
          sub_1006C9540(a1, v12, 0);
        }
        else if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
        {
          sub_1000217F4(a2);
          sub_10071C968();
        }
      }
    }
    else if (a4 == 801 && !*(_BYTE *)(a1 + 283))
    {
      if (qword_100977908 != -1)
        dispatch_once(&qword_100977908, &stru_100940ED8);
      v8 = sub_100535108(qword_100977900);
      v9 = qword_1009997F0;
      if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
      {
        sub_1000217F4(a2);
        v10 = v17 >= 0 ? &__p : (void **)__p;
        *(_DWORD *)buf = 136315394;
        v20 = v10;
        v21 = 2048;
        v22 = (double)v8 * 1.25;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Bandwidth: LEA Streaming Connection for device %s, connectionInterval %fms", buf, 0x16u);
        if (v17 < 0)
          operator delete(__p);
      }
      if (v8 != 3)
      {
        if (v8 == 6)
        {
          v11 = 1792;
          goto LABEL_28;
        }
        if (v8 == 4)
        {
          v11 = 1536;
LABEL_28:
          sub_1006C9540(a1, v11, 1);
          *(_BYTE *)(a1 + 283) = 1;
          goto LABEL_29;
        }
        if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
          sub_10071C93C();
      }
      v11 = 1280;
      goto LABEL_28;
    }
  }
LABEL_29:
  v13 = sub_10006BBEC();
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  v15[2] = sub_1006CA238;
  v15[3] = &unk_100917378;
  v15[4] = a1;
  sub_100041A34(v13, v15);
  return sub_100034234((uint64_t)v18);
}

void sub_1006CA210(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  sub_100034234((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1006CA238(uint64_t a1)
{
  return sub_1006C466C(*(uint32x2_t **)(a1 + 32));
}

uint64_t sub_1006CA240(uint64_t a1, void *a2, int a3, int a4)
{
  _QWORD *v8;
  _QWORD *v9;
  unint64_t v10;
  BOOL v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t *v14;
  unint64_t v15;
  BOOL v16;
  _QWORD *v17;
  NSObject *v18;
  void **v19;
  uint64_t v20;
  _QWORD v22[5];
  void *__p[2];
  char v24;
  _QWORD v25[2];
  uint8_t buf[4];
  void **v27;

  v25[0] = 0;
  v25[1] = 0;
  sub_10003415C((uint64_t)v25, a1 + 80);
  if (a2)
  {
    if (a4)
    {
      if (a3)
      {
        v8 = *(_QWORD **)(a1 + 336);
        if (!v8)
          goto LABEL_15;
        v9 = (_QWORD *)(a1 + 336);
        do
        {
          v10 = v8[4];
          v11 = v10 >= (unint64_t)a2;
          if (v10 >= (unint64_t)a2)
            v12 = v8;
          else
            v12 = v8 + 1;
          if (v11)
            v9 = v8;
          v8 = (_QWORD *)*v12;
        }
        while (*v12);
        if (v9 != (_QWORD *)(a1 + 336) && v9[4] <= (unint64_t)a2)
        {
          if (*((_DWORD *)v9 + 10) == a3)
            return sub_100034234((uint64_t)v25);
          *((_DWORD *)v9 + 10) = a3;
        }
        else
        {
LABEL_15:
          __p[0] = a2;
          LODWORD(__p[1]) = a3;
          sub_1006CC3D0((uint64_t **)(a1 + 328), (unint64_t *)__p, __p);
        }
        goto LABEL_38;
      }
      v18 = qword_1009997F0;
      if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
      {
        sub_10043F6EC((uint64_t)a2, (uint64_t)__p);
        v19 = v24 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)buf = 136315138;
        v27 = v19;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Bandwidth: Not adding Classic Connection %s to Classic Connection Map, waiting on an update", buf, 0xCu);
        if (v24 < 0)
          operator delete(__p[0]);
      }
    }
    else
    {
      v13 = *(_QWORD **)(a1 + 336);
      if (v13)
      {
        v14 = (uint64_t *)(a1 + 336);
        do
        {
          v15 = v13[4];
          v16 = v15 >= (unint64_t)a2;
          if (v15 >= (unint64_t)a2)
            v17 = v13;
          else
            v17 = v13 + 1;
          if (v16)
            v14 = v13;
          v13 = (_QWORD *)*v17;
        }
        while (*v17);
        if (v14 != (uint64_t *)(a1 + 336) && v14[4] <= (unint64_t)a2)
        {
          sub_1000040CC((uint64_t **)(a1 + 328), v14);
          operator delete(v14);
LABEL_38:
          if (a3 <= 24)
          {
            *(_BYTE *)(a1 + 284) = 1;
            v20 = sub_10006BBEC();
            v22[0] = _NSConcreteStackBlock;
            v22[1] = 3221225472;
            v22[2] = sub_1006CA4A8;
            v22[3] = &unk_100917378;
            v22[4] = a1;
            sub_100041A34(v20, v22);
          }
        }
      }
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
  {
    sub_10071C9C0();
  }
  return sub_100034234((uint64_t)v25);
}

void sub_1006CA484(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  sub_100034234((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1006CA4A8(uint64_t a1)
{
  return sub_1006C466C(*(uint32x2_t **)(a1 + 32));
}

void sub_1006CA4B0(uint64_t a1, void *a2, int a3, int a4)
{
  id v7;
  void *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  BOOL v13;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t *v16;
  unint64_t v17;
  BOOL v18;
  _QWORD *v19;
  NSObject *v20;
  void **v21;
  uint64_t v22;
  _QWORD v23[5];
  void *__p[2];
  char v25;
  _QWORD v26[2];
  uint8_t buf[4];
  void **v28;

  v7 = a2;
  v26[0] = 0;
  v26[1] = 0;
  sub_10003415C((uint64_t)v26, a1 + 80);
  if (v7)
  {
    if (qword_1009778C8 != -1)
      dispatch_once(&qword_1009778C8, &stru_100940EF8);
    v8 = (void *)sub_1000589DC((uint64_t)off_1009778C0, v7, 0);
    v9 = (uint64_t)v8;
    if (a4)
    {
      if (a3)
      {
        v10 = *(_QWORD **)(a1 + 360);
        if (!v10)
          goto LABEL_17;
        v11 = (_QWORD *)(a1 + 360);
        do
        {
          v12 = v10[4];
          v13 = v12 >= (unint64_t)v8;
          if (v12 >= (unint64_t)v8)
            v14 = v10;
          else
            v14 = v10 + 1;
          if (v13)
            v11 = v10;
          v10 = (_QWORD *)*v14;
        }
        while (*v14);
        if (v11 != (_QWORD *)(a1 + 360) && (unint64_t)v8 >= v11[4])
        {
          if (*((_DWORD *)v11 + 10) == a3)
            goto LABEL_42;
          *((_DWORD *)v11 + 10) = a3;
        }
        else
        {
LABEL_17:
          __p[0] = v8;
          LODWORD(__p[1]) = a3;
          sub_1006CC3D0((uint64_t **)(a1 + 352), (unint64_t *)__p, __p);
        }
        goto LABEL_40;
      }
      v20 = qword_1009997F0;
      if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
      {
        sub_1000217F4(v9);
        v21 = v25 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)buf = 136315138;
        v28 = v21;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Bandwidth: Not adding Le Connection %s to Le Connection Map, waiting on an update", buf, 0xCu);
        if (v25 < 0)
          operator delete(__p[0]);
      }
    }
    else
    {
      v15 = *(_QWORD **)(a1 + 360);
      if (v15)
      {
        v16 = (uint64_t *)(a1 + 360);
        do
        {
          v17 = v15[4];
          v18 = v17 >= (unint64_t)v8;
          if (v17 >= (unint64_t)v8)
            v19 = v15;
          else
            v19 = v15 + 1;
          if (v18)
            v16 = v15;
          v15 = (_QWORD *)*v19;
        }
        while (*v19);
        if (v16 != (uint64_t *)(a1 + 360) && (unint64_t)v8 >= v16[4])
        {
          sub_1000040CC((uint64_t **)(a1 + 352), v16);
          operator delete(v16);
LABEL_40:
          if (a3 <= 12)
          {
            *(_BYTE *)(a1 + 284) = 1;
            v22 = sub_10006BBEC();
            v23[0] = _NSConcreteStackBlock;
            v23[1] = 3221225472;
            v23[2] = sub_1006CA774;
            v23[3] = &unk_100917378;
            v23[4] = a1;
            sub_100041A34(v22, v23);
          }
        }
      }
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_ERROR))
  {
    sub_10071C9EC();
  }
LABEL_42:
  sub_100034234((uint64_t)v26);

}

void sub_1006CA744(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  void *v9;
  va_list va;

  va_start(va, a9);
  sub_100034234((uint64_t)va);

  _Unwind_Resume(a1);
}

uint64_t sub_1006CA774(uint64_t a1)
{
  return sub_1006C466C(*(uint32x2_t **)(a1 + 32));
}

void sub_1006CA77C(uint32x2_t *a1)
{
  NSObject *v2;
  uint32x2_t *v3;
  __int32 v4;
  int v5;
  NSObject *v6;
  uint8_t *v7;
  double v8;
  NSObject *v9;
  uint8_t *v10;
  double v11;
  NSObject *v12;
  _BOOL4 v13;
  uint8_t *v14;
  double v15;
  uint8_t *v16;
  double v17;
  uint32x2_t *v18;
  uint32x2_t *v19;
  BOOL v20;
  uint32x2_t *v21;
  int v22;
  NSObject *v23;
  double v24;
  uint8_t *v25;
  NSObject *v26;
  double v27;
  uint8_t *v28;
  NSObject *v29;
  _BOOL4 v30;
  double v31;
  uint8_t *v32;
  double v33;
  uint8_t *v34;
  uint32x2_t *v35;
  uint32x2_t *v36;
  uint32x2_t v37;
  unsigned int v38;
  uint8_t buf[8];
  char v40;
  uint8_t v41[4];
  uint8_t *v42;
  __int16 v43;
  double v44;

  a1[38] = 0;
  a1[39].i32[0] = 0;
  a1[37].i32[0] = 0;
  a1[36].i32[0] -= a1[36].i32[1];
  v2 = qword_1009997F0;
  if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Bandwidth: Calculating all non audio connections", buf, 2u);
  }
  v3 = (uint32x2_t *)a1[44];
  if (v3 == &a1[45])
  {
    v4 = 0;
  }
  else
  {
    v4 = 0;
    do
    {
      v5 = v3[5].i32[0];
      if (v5 > 8)
      {
        if (v5 == 9)
        {
          v9 = qword_1009997F0;
          if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
          {
            sub_1000217F4(*(_QWORD *)&v3[4]);
            v10 = buf;
            if (v40 < 0)
              v10 = *(uint8_t **)buf;
            v11 = (double)v3[5].i32[0] * 1.25;
            *(_DWORD *)v41 = 136315394;
            v42 = v10;
            v43 = 2048;
            v44 = v11;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Bandwidth: Le Connection %s with interval %fms logged", v41, 0x16u);
            if (v40 < 0)
              operator delete(*(void **)buf);
          }
          v4 += 128;
          ++a1[38].i32[1];
        }
        else
        {
          v12 = qword_1009997F0;
          v13 = os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT);
          if (v5 < 0xD)
          {
            if (v13)
            {
              sub_1000217F4(*(_QWORD *)&v3[4]);
              v16 = buf;
              if (v40 < 0)
                v16 = *(uint8_t **)buf;
              v17 = (double)v3[5].i32[0] * 1.25;
              *(_DWORD *)v41 = 136315394;
              v42 = v16;
              v43 = 2048;
              v44 = v17;
              _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Bandwidth: Le Connection %s with interval %fms logged", v41, 0x16u);
              if (v40 < 0)
                operator delete(*(void **)buf);
            }
            v4 += 42;
            ++a1[39].i32[0];
          }
          else if (v13)
          {
            sub_1000217F4(*(_QWORD *)&v3[4]);
            v14 = buf;
            if (v40 < 0)
              v14 = *(uint8_t **)buf;
            v15 = (double)v3[5].i32[0] * 1.25;
            *(_DWORD *)v41 = 136315394;
            v42 = v14;
            v43 = 2048;
            v44 = v15;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Warning: Bandwidth: Le connection %s with interval %fms, has a greater interval than 15ms.  Not counting as bandwidth", v41, 0x16u);
            if (v40 < 0)
              operator delete(*(void **)buf);
          }
        }
      }
      else
      {
        v6 = qword_1009997F0;
        if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
        {
          sub_1000217F4(*(_QWORD *)&v3[4]);
          v7 = buf;
          if (v40 < 0)
            v7 = *(uint8_t **)buf;
          v8 = (double)v3[5].i32[0] * 1.25;
          *(_DWORD *)v41 = 136315394;
          v42 = v7;
          v43 = 2048;
          v44 = v8;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Bandwidth: Le Connection %s with interval %fms logged", v41, 0x16u);
          if (v40 < 0)
            operator delete(*(void **)buf);
        }
        v4 += 170;
        ++a1[38].i32[0];
      }
      v18 = (uint32x2_t *)v3[1];
      if (v18)
      {
        do
        {
          v19 = v18;
          v18 = (uint32x2_t *)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          v19 = (uint32x2_t *)v3[2];
          v20 = *v19 == (_QWORD)v3;
          v3 = v19;
        }
        while (!v20);
      }
      v3 = v19;
    }
    while (v19 != &a1[45]);
  }
  v21 = (uint32x2_t *)a1[41];
  if (v21 != &a1[42])
  {
    do
    {
      v22 = v21[5].i32[0];
      if (v22 > 17)
      {
        if (v22 == 18)
        {
          v26 = qword_1009997F0;
          if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
          {
            sub_10043F6EC(*(_QWORD *)&v21[4], (uint64_t)buf);
            v27 = (double)v21[5].i32[0];
            v28 = v40 >= 0 ? buf : *(uint8_t **)buf;
            *(_DWORD *)v41 = 136315394;
            v42 = v28;
            v43 = 2048;
            v44 = v27 * 0.625;
            _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Bandwidth: Classic Connection %s with interval %fms logged", v41, 0x16u);
            if (v40 < 0)
              operator delete(*(void **)buf);
          }
          v4 += 128;
          ++a1[38].i32[1];
        }
        else
        {
          v29 = qword_1009997F0;
          v30 = os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT);
          if (v22 < 0x19)
          {
            if (v30)
            {
              sub_10043F6EC(*(_QWORD *)&v21[4], (uint64_t)buf);
              v33 = (double)v21[5].i32[0];
              v34 = v40 >= 0 ? buf : *(uint8_t **)buf;
              *(_DWORD *)v41 = 136315394;
              v42 = v34;
              v43 = 2048;
              v44 = v33 * 0.625;
              _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "Bandwidth: Classic Connection %s with interval %fms logged", v41, 0x16u);
              if (v40 < 0)
                operator delete(*(void **)buf);
            }
            v4 += 42;
            ++a1[39].i32[0];
          }
          else if (v30)
          {
            sub_10043F6EC(*(_QWORD *)&v21[4], (uint64_t)buf);
            v31 = (double)v21[5].i32[0];
            v32 = v40 >= 0 ? buf : *(uint8_t **)buf;
            *(_DWORD *)v41 = 136315394;
            v42 = v32;
            v43 = 2048;
            v44 = v31 * 0.625;
            _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "Warning: Bandwidth: Classic Connection %s with interval %fms, has a greater interval than 15ms.  Not counting as bandwidth", v41, 0x16u);
            if (v40 < 0)
              operator delete(*(void **)buf);
          }
        }
      }
      else
      {
        v23 = qword_1009997F0;
        if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
        {
          sub_10043F6EC(*(_QWORD *)&v21[4], (uint64_t)buf);
          v24 = (double)v21[5].i32[0];
          v25 = v40 >= 0 ? buf : *(uint8_t **)buf;
          *(_DWORD *)v41 = 136315394;
          v42 = v25;
          v43 = 2048;
          v44 = v24 * 0.625;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Bandwidth: Classic Connection %s with interval %fms logged", v41, 0x16u);
          if (v40 < 0)
            operator delete(*(void **)buf);
        }
        v4 += 170;
        ++a1[38].i32[0];
      }
      v35 = (uint32x2_t *)v21[1];
      if (v35)
      {
        do
        {
          v36 = v35;
          v35 = (uint32x2_t *)*v35;
        }
        while (v35);
      }
      else
      {
        do
        {
          v36 = (uint32x2_t *)v21[2];
          v20 = *v36 == (_QWORD)v21;
          v21 = v36;
        }
        while (!v20);
      }
      v21 = v36;
    }
    while (v36 != &a1[42]);
  }
  a1[36].i32[0] += v4;
  a1[36].i32[1] = v4;
  v37 = vmin_u32(a1[38], (uint32x2_t)0x300000003);
  a1[38] = v37;
  v38 = a1[39].u32[0];
  if (v38 >= 3)
    v38 = 3;
  a1[39].i32[0] = v38;
  if (v37.i32[0])
    a1[37].i32[0] |= v37.i32[0] << 20;
  if (v37.i32[1])
    a1[37].i32[0] |= v37.i32[1] << 22;
  if (v38)
    a1[37].i32[0] |= v38 << 24;
  a1[35].i8[4] = 0;
}

void sub_1006CAE44(uint64_t a1, unsigned int a2)
{
  NSObject *v4;
  xpc_object_t v5;
  _DWORD v6[2];

  v4 = qword_1009997F0;
  if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
  {
    v6[0] = 67109120;
    v6[1] = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Sending Desense State %d WCM", (uint8_t *)v6, 8u);
  }
  v5 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_uint64(v5, "kWCMBTUSBDesenseState", a2);
  sub_1006C4A48(a1, 0x204uLL, v5);
  xpc_release(v5);
}

void sub_1006CAF2C(uint64_t a1, uint64_t a2, unsigned int a3)
{
  xpc_object_t v6;
  uint64_t v7;

  v6 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_uint64(v6, "kWCMBTMetricsReport_Classic_RSSI", *(__int16 *)(a2 + 16));
  xpc_dictionary_set_uint64(v6, "kWCMBTMetricsReport_LE_RSSI", *(__int16 *)(a2 + 18));
  xpc_dictionary_set_uint64(v6, "kWCMBTMetricsReportLeSuccessfulTxCount", *(unsigned __int16 *)(a2 + 21));
  xpc_dictionary_set_uint64(v6, "kWCMBTMetricsReportLeReTxCount", *(unsigned __int16 *)(a2 + 23));
  xpc_dictionary_set_uint64(v6, "kWCMBTMetricsReportLeSuccessfulRxCount", *(unsigned __int16 *)(a2 + 25));
  xpc_dictionary_set_uint64(v6, "kWCMBTMetricsReportLeRxErrorCount", *(unsigned __int16 *)(a2 + 27));
  xpc_dictionary_set_uint64(v6, "kWCMBTMetricsReportClassicSuccessfulTxCount", *(unsigned __int16 *)(a2 + 30));
  xpc_dictionary_set_uint64(v6, "kWCMBTMetricsReportClassicReTxCount", *(unsigned __int16 *)(a2 + 32));
  xpc_dictionary_set_uint64(v6, "kWCMBTMetricsReportClassicSuccessfulRxCount", *(unsigned __int16 *)(a2 + 34));
  xpc_dictionary_set_uint64(v6, "kWCMBTMetricsReportClassicRxErrorCount", *(unsigned __int16 *)(a2 + 36));
  xpc_dictionary_set_uint64(v6, "kWCMBTMetricsReportLeCoexDenialCount", *(unsigned __int16 *)(a2 + 12));
  xpc_dictionary_set_uint64(v6, "kWCMBTMetricsReportClassicCoexDenialCount", *(unsigned __int16 *)(a2 + 14));
  xpc_dictionary_set_uint64(v6, "kWCMBTMetricsReport_flushCount", a3);
  if (*(_BYTE *)(a2 + 29))
    v7 = 2;
  else
    v7 = 1;
  xpc_dictionary_set_uint64(v6, "kWCMBTMetricsReport_Active_PHY", v7);
  sub_1006C4A48(a1, 0x200uLL, v6);
  xpc_release(v6);
}

void sub_1006CB0A0(uint64_t a1, unsigned int a2, unsigned int a3)
{
  NSObject *v6;
  xpc_object_t v7;
  _DWORD v8[2];
  __int16 v9;
  unsigned int v10;

  v6 = qword_1009997F0;
  if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
  {
    v8[0] = 67109376;
    v8[1] = a2;
    v9 = 1024;
    v10 = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "sendPhyReport: %d, %d", (uint8_t *)v8, 0xEu);
  }
  v7 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_uint64(v7, "kWCMBTPhyReport_LE_PHY_RATE", a3);
  xpc_dictionary_set_uint64(v7, "kWCMBTPhyReport_CLASSIC_PHY_RATE", a2);
  sub_1006C4A48(a1, 0x201uLL, v7);
  xpc_release(v7);
}

void sub_1006CB1AC(uint32x2_t *a1, unsigned __int8 *a2, unsigned int a3, int a4, int a5)
{
  uint64_t v8;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  unsigned int v14;
  uint64_t v15;

  v8 = (uint64_t)a2;
  if (a2)
    a2 = (unsigned __int8 *)(((unint64_t)a2[128] << 40) | ((unint64_t)a2[129] << 32) | ((unint64_t)a2[130] << 24) | ((unint64_t)a2[131] << 16) | ((unint64_t)a2[132] << 8) | a2[133]);
  if (a4 > 109)
  {
    if (a4 > 200)
    {
      if (a4 == 201)
      {
        v10 = 2;
        v11 = a3;
        v12 = 201;
        goto LABEL_22;
      }
      if (a4 == 202)
      {
        v10 = 2;
        v11 = a3;
        v12 = 202;
        goto LABEL_15;
      }
    }
    else
    {
      if (a4 == 110)
      {
        v10 = 4;
        v11 = a3;
        v12 = 110;
        goto LABEL_22;
      }
      if (a4 == 111)
      {
        v10 = 4;
        v11 = a3;
        v12 = 111;
LABEL_22:
        v13 = a5;
        v14 = 1;
        goto LABEL_23;
      }
    }
LABEL_27:
    if ((a4 - 3) > 0xFFFFFFFD)
      return;
    goto LABEL_24;
  }
  if ((a4 - 11) < 2)
  {
    sub_1006C8A48((uint64_t)a1, (unint64_t)a2, a3, a4, a5);
    if (v8 && a3 == 32)
    {
      v15 = sub_10044FDAC(v8);
      (*(void (**)(uint32x2_t *, uint64_t, uint64_t, BOOL))(*(_QWORD *)a1 + 72))(a1, v8, v15, a4 == 11);
      return;
    }
    goto LABEL_24;
  }
  if (a4 == 101)
  {
    v10 = 1;
    v11 = a3;
    v12 = 101;
    goto LABEL_22;
  }
  if (a4 != 102)
    goto LABEL_27;
  v10 = 1;
  v11 = a3;
  v12 = 102;
LABEL_15:
  v13 = a5;
  v14 = 0;
LABEL_23:
  sub_1006C8E48((uint64_t)a1, (uint64_t)a2, v10, v11, v12, v13, v14);
LABEL_24:
  if (a3 == 16 || a3 == 1)
    sub_1006C99B0(a1, v8, a3, a4, a5);
}

void sub_1006CB390(uint64_t a1, unsigned __int8 *a2, unsigned int a3, int a4, int a5)
{
  sub_1006CB1AC((uint32x2_t *)(a1 - 8), a2, a3, a4, a5);
}

void sub_1006CB398(id a1)
{
  void *v1;
  void *v2;
  void *v3;
  const __CFString *v4;
  void *v5;

  v4 = CFSTR("NUMBER_OF_LE_CONNECTIONS");
  if (qword_100977B40 != -1)
    dispatch_once(&qword_100977B40, &stru_100940E18);
  v1 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *((unsigned int *)off_100977B38 + 40)));
  v5 = v1;
  v2 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v5, &v4, 1));

  v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSNotificationCenter defaultCenter](NSNotificationCenter, "defaultCenter"));
  objc_msgSend(v3, "postNotificationName:object:userInfo:", CFSTR("com.apple.bluetooth.leconnection"), 0, v2);

}

void sub_1006CB49C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1006CB4CC(uint64_t a1, void *a2, int a3)
{
  id v5;
  uint64_t v6;
  id v7;
  _QWORD v8[4];
  id v9;
  uint64_t v10;
  int v11;

  v5 = a2;
  v6 = sub_10006BBEC();
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_1006CB584;
  v8[3] = &unk_100919818;
  v10 = a1;
  v7 = v5;
  v9 = v7;
  v11 = a3;
  sub_100041A34(v6, v8);

}

void sub_1006CB564(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;

  _Unwind_Resume(a1);
}

uint64_t sub_1006CB584(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  unsigned __int8 v8[16];

  v2 = *(_QWORD *)(a1 + 40);
  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_100940EF8);
  v3 = sub_1000589DC((uint64_t)off_1009778C0, *(void **)(a1 + 32), 0);
  sub_1006C8A48(v2, v3, 0x8000u, 0xBu, *(_DWORD *)(a1 + 48));
  v4 = sub_10006BBEC();
  sub_100041A34(v4, &stru_100940D98);
  if (qword_1009778A8 != -1)
    dispatch_once(&qword_1009778A8, &stru_100940DF8);
  v5 = off_1009778A0;
  sub_100030BCC(v8, *(_QWORD *)(a1 + 32));
  v6 = sub_1006249C4((uint64_t)v5, v8);
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, uint64_t))(*(_QWORD *)v2 + 88))(v2, *(_QWORD *)(a1 + 32), v6, 1);
}

void sub_1006CB6A8(uint64_t a1, void *a2, int a3)
{
  sub_1006CB4CC(a1 - 32, a2, a3);
}

void sub_1006CB6B0(uint64_t a1, void *a2, int a3)
{
  id v5;
  uint64_t v6;
  id v7;
  _QWORD v8[4];
  id v9;
  uint64_t v10;
  int v11;

  v5 = a2;
  v6 = sub_10006BBEC();
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_1006CB768;
  v8[3] = &unk_100919818;
  v10 = a1;
  v7 = v5;
  v9 = v7;
  v11 = a3;
  sub_100041A34(v6, v8);

}

void sub_1006CB748(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;

  _Unwind_Resume(a1);
}

uint64_t sub_1006CB768(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;

  v2 = *(_QWORD *)(a1 + 40);
  if (qword_1009778C8 != -1)
    dispatch_once(&qword_1009778C8, &stru_100940EF8);
  v3 = sub_1000589DC((uint64_t)off_1009778C0, *(void **)(a1 + 32), 0);
  sub_1006C8A48(v2, v3, 0x8000u, 0xCu, *(_DWORD *)(a1 + 48));
  v4 = sub_10006BBEC();
  sub_100041A34(v4, &stru_100940D98);
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v2 + 88))(v2, *(_QWORD *)(a1 + 32), 0, 0);
}

void sub_1006CB804(uint64_t a1, void *a2, int a3)
{
  sub_1006CB6B0(a1 - 32, a2, a3);
}

void sub_1006CB80C(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;

  v5 = a2;
  v6 = a1;
  if (a4 == 4)
  {
    if (a3)
      v10 = 803;
    else
      v10 = 804;
    v8 = 4;
    v9 = 0x400000;
  }
  else
  {
    if (a4 != 3)
      return;
    if (a3)
      v7 = 801;
    else
      v7 = 802;
    sub_1006C9F90(a1, a2, 0x10000, v7);
    a1 = v6;
    a2 = v5;
    v8 = 3;
    v9 = 0x10000;
    v10 = v7;
  }
  sub_1006C8E48(a1, a2, v8, v9, v10, 0, a3);
}

void sub_1006CB8B4(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  sub_1006CB80C(a1 - 40, a2, a3, a4);
}

void sub_1006CB8C0(uint64_t a1)
{
  sub_1006C4540(a1 - 24);
}

uint64_t sub_1006CB8C8(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 452) = a2;
  *(_QWORD *)(result + 460) = a3;
  return result;
}

uint64_t sub_1006CB8D4(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(result + 404) = a2;
  *(_QWORD *)(result + 412) = a3;
  return result;
}

uint64_t **sub_1006CB8E8(uint64_t a1, unsigned int a2, unsigned int a3)
{
  xpc_object_t v6;
  NSObject *v7;
  const char *v8;
  const char *v9;
  uint64_t **result;
  uint64_t *v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  const char *v18;

  v14 = a2;
  v6 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_int64(v6, "kWCMBTLeDiscoveryScan_State", a3);
  xpc_dictionary_set_int64(v6, "kWCMBTLeDiscoveryScan_UseCase", 1);
  v7 = qword_1009997F0;
  if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
  {
    v8 = sub_100037D34(a2);
    v9 = "false";
    if (a3)
      v9 = "true";
    *(_DWORD *)buf = 136315394;
    v16 = v8;
    v17 = 2080;
    v18 = v9;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Sending Notification to WiFi for CBUseCase %s Scanning Started %s", buf, 0x16u);
  }
  sub_1006C4A48(a1, 0x206uLL, v6);
  result = (uint64_t **)(a1 + 400);
  v11 = *(uint64_t **)(a1 + 408);
  if ((a3 & 1) != 0)
  {
    for (; v11; v11 = (uint64_t *)*v11)
    {
      v12 = *((_DWORD *)v11 + 7);
      if (v12 <= a2)
      {
        if (v12 >= a2)
          return result;
        ++v11;
      }
    }
    return sub_10005C754(result, &v14, &v14);
  }
  else
  {
    while (v11)
    {
      v13 = *((_DWORD *)v11 + 7);
      if (v13 <= a2)
      {
        if (v13 >= a2)
          return (uint64_t **)sub_1006CC550((uint64_t)result, &v14);
        ++v11;
      }
      v11 = (uint64_t *)*v11;
    }
  }
  return result;
}

uint64_t **sub_1006CBA7C(uint64_t a1, unsigned int a2, unsigned int a3)
{
  return sub_1006CB8E8(a1 - 64, a2, a3);
}

void sub_1006CBA84(uint64_t a1)
{
  NSObject *v2;
  _BYTE *v3;
  const char *v4;
  _BYTE __p[12];
  char v6;
  uint8_t buf[4];
  _BYTE *v8;

  v2 = qword_1009997F0;
  if (os_log_type_enabled((os_log_t)qword_1009997F0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__p = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: ------------------ Coex Manager -------------------", __p, 2u);
    v2 = qword_1009997F0;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    sub_100021AE4(a1 + 452);
    if (v6 >= 0)
      v3 = __p;
    else
      v3 = *(_BYTE **)__p;
    *(_DWORD *)buf = 136446210;
    v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: %{public}s", buf, 0xCu);
    if (v6 < 0)
      operator delete(*(void **)__p);
    v2 = qword_1009997F0;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v4 = "Enabled";
    if (!*(_BYTE *)(a1 + 448))
      v4 = "Disabled";
    *(_DWORD *)__p = 136446210;
    *(_QWORD *)&__p[4] = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "statedump: Grant RC2 State: %{public}s", __p, 0xCu);
  }
}

char *sub_1006CBC1C(uint64_t a1, char *__src, char *a3)
{
  char *v3;
  char *v4;
  char *v6;
  unint64_t v7;
  uint64_t v8;
  char *v9;
  char *v10;
  _QWORD *v11;
  uint64_t v12;
  char *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  char *v20;
  unint64_t v21;
  unint64_t v22;
  char *v23;
  uint64_t v24;
  void *__p;
  char *v27;
  char *v28;
  char *v29;
  uint64_t v30;

  v3 = a3;
  v4 = __src;
  v6 = *(char **)(a1 + 8);
  v8 = a1 + 16;
  v7 = *(_QWORD *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    v13 = *(char **)a1;
    v14 = ((uint64_t)&v6[-*(_QWORD *)a1] >> 3) + 1;
    if (v14 >> 61)
      abort();
    v15 = __src - v13;
    v16 = (__src - v13) >> 3;
    v17 = v7 - (_QWORD)v13;
    if (v17 >> 2 > v14)
      v14 = v17 >> 2;
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8)
      v18 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v18 = v14;
    v30 = a1 + 16;
    if (v18)
      v19 = (char *)sub_10007ABA0(a1 + 16, v18);
    else
      v19 = 0;
    v20 = &v19[8 * v16];
    __p = v19;
    v27 = v20;
    v28 = v20;
    v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4)
          v22 = 1;
        else
          v22 = v15 >> 2;
        v23 = (char *)sub_10007ABA0(v8, v22);
        v20 = &v23[8 * (v22 >> 2)];
        __p = v23;
        v27 = v20;
        v29 = &v23[8 * v24];
        if (v19)
          operator delete(v19);
      }
      else
      {
        v21 = v16 + 2;
        if (v16 >= -1)
          v21 = v16 + 1;
        v20 -= 8 * (v21 >> 1);
        v27 = v20;
      }
    }
    *(_QWORD *)v20 = *(_QWORD *)v3;
    v28 = v20 + 8;
    v4 = sub_10007AADC((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27)
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8;
    if (__p)
      operator delete(__p);
  }
  else if (__src == v6)
  {
    *(_QWORD *)__src = *(_QWORD *)a3;
    *(_QWORD *)(a1 + 8) = __src + 8;
  }
  else
  {
    v9 = __src + 8;
    v10 = v6 - 8;
    v11 = *(_QWORD **)(a1 + 8);
    while (v10 < v6)
    {
      v12 = *(_QWORD *)v10;
      v10 += 8;
      *v11++ = v12;
    }
    *(_QWORD *)(a1 + 8) = v11;
    if (v6 != v9)
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    if (v4 <= v3)
      v3 += 8 * (*(_QWORD *)(a1 + 8) > (unint64_t)v3);
    *(_QWORD *)v4 = *(_QWORD *)v3;
  }
  return v4;
}

void sub_1006CBE20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1006CBE58(id a1)
{
  operator new();
}

void sub_1006CBE98()
{
  operator delete();
}

void sub_1006CBEBC(id a1)
{
  operator new();
}

void sub_1006CBEFC()
{
  operator delete();
}

void sub_1006CBF20(id a1)
{
  operator new();
}

void sub_1006CBF60()
{
  operator delete();
}

void sub_1006CBF84(id a1)
{
  operator new();
}

void sub_1006CC09C()
{
  operator delete();
}

void sub_1006CC0C0(id a1)
{
  operator new();
}

void sub_1006CC100()
{
  operator delete();
}

void sub_1006CC124(id a1)
{
  operator new();
}

void sub_1006CC164()
{
  operator delete();
}

void sub_1006CC188(id a1)
{
  operator new();
}

void sub_1006CC1C8()
{
  operator delete();
}

void sub_1006CC1EC(id a1)
{
  operator new();
}

void sub_1006CC22C()
{
  operator delete();
}

uint64_t *sub_1006CC250(uint64_t **a1, unsigned int *a2, uint64_t *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  unsigned int v7;
  uint64_t **v8;
  unsigned int v9;
  uint64_t *v10;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    v7 = *a2;
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v5;
        v9 = *((_DWORD *)v5 + 7);
        if (v7 >= v9)
          break;
        v5 = *v8;
        v6 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (v9 >= v7)
        break;
      v5 = v8[1];
      if (!v5)
      {
        v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v8 = a1 + 1;
LABEL_10:
    v10 = (uint64_t *)operator new(0x28uLL);
    *(uint64_t *)((char *)v10 + 28) = *a3;
    sub_100004078(a1, (uint64_t)v8, v6, v10);
    return v10;
  }
  return (uint64_t *)v8;
}

void sub_1006CC308(id a1)
{
  operator new();
}

void sub_1006CC348()
{
  operator delete();
}

void sub_1006CC36C(id a1)
{
  operator new();
}

void sub_1006CC3AC()
{
  operator delete();
}

uint64_t **sub_1006CC3D0(uint64_t **a1, unint64_t *a2, _OWORD *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  unint64_t v7;
  uint64_t **v8;
  unint64_t v9;
  uint64_t *v10;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    v7 = *a2;
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v5;
        v9 = v5[4];
        if (v7 >= v9)
          break;
        v5 = *v8;
        v6 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (v9 >= v7)
        break;
      v5 = v8[1];
      if (!v5)
      {
        v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v8 = a1 + 1;
LABEL_10:
    v10 = (uint64_t *)operator new(0x30uLL);
    *((_OWORD *)v10 + 2) = *a3;
    sub_100004078(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }
  return v8;
}

void sub_1006CC488(id a1)
{
  operator new();
}

void sub_1006CC4C8()
{
  operator delete();
}

void sub_1006CC4EC(id a1)
{
  operator new();
}

void sub_1006CC52C()
{
  operator delete();
}

uint64_t sub_1006CC550(uint64_t a1, unsigned int *a2)
{
  uint64_t v2;
  unsigned int v3;
  uint64_t v4;
  unsigned int v5;
  BOOL v6;
  uint64_t *v7;

  v2 = *(_QWORD *)(a1 + 8);
  if (!v2)
    return 0;
  v3 = *a2;
  v4 = a1 + 8;
  do
  {
    v5 = *(_DWORD *)(v2 + 28);
    v6 = v5 >= v3;
    if (v5 >= v3)
      v7 = (uint64_t *)v2;
    else
      v7 = (uint64_t *)(v2 + 8);
    if (v6)
      v4 = v2;
    v2 = *v7;
  }
  while (*v7);
  if (v4 == a1 + 8 || v3 < *(_DWORD *)(v4 + 28))
    return 0;
  sub_1000040CC((uint64_t **)a1, (uint64_t *)v4);
  operator delete((void *)v4);
  return 1;
}

uint64_t sub_1006CC5C8(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v4 = a1 + 24;
  *(_QWORD *)(a1 + 16) = v3;
  if (*(char *)(a1 + 111) < 0)
    operator delete(*(void **)(a1 + 88));
  std::streambuf::~streambuf(v4);
  std::ios::~ios(a1 + 128);
  return a1;
}

uint64_t sub_1006CC650(uint64_t result)
{
  *(_BYTE *)(result + 24) = 0;
  return result;
}

ctu::TextConverter *ctu::TextConverter::TextConverter(ctu::TextConverter *this)
{
  _DWORD *v2;

  v2 = operator new(0x38uLL);
  v2[2] = 0;
  *((_QWORD *)v2 + 2) = 0;
  *((_BYTE *)v2 + 24) = 0;
  *(_QWORD *)v2 = &off_1009413F0;
  *((_QWORD *)v2 + 5) = 0;
  *((_QWORD *)v2 + 6) = 0;
  *((_QWORD *)v2 + 4) = 0;
  *(_QWORD *)this = v2;
  *((_QWORD *)this + 1) = v2;
  return this;
}

void ctu::TextConverter::~TextConverter(ctu::TextConverter *this)
{
  _QWORD *v2;

  v2 = *(_QWORD **)this;
  if (v2)
  {
    do
    {
      *(_QWORD *)this = v2[2];
      (*(void (**)(_QWORD *))(*v2 + 8))(v2);
      v2 = *(_QWORD **)this;
    }
    while (*(_QWORD *)this);
  }
}

uint64_t ctu::TextConverter::setSource(uint64_t this, const char *a2, int a3)
{
  uint64_t v3;
  _QWORD *v4;

  v3 = *(_QWORD *)(this + 8);
  *(_DWORD *)(v3 + 8) = a3;
  *(_QWORD *)(v3 + 32) = a2;
  *(_QWORD *)(v3 + 40) = 0;
  *(_QWORD *)(v3 + 48) = a3;
  v4 = *(_QWORD **)this;
  if (*(_QWORD *)this)
  {
    do
    {
      this = (*(uint64_t (**)(_QWORD *))(*v4 + 24))(v4);
      v4 = (_QWORD *)v4[2];
    }
    while (v4);
  }
  return this;
}

_DWORD *ctu::TextConverter::pushConversion(_QWORD *a1, int a2, int a3, int a4, int a5)
{
  _DWORD *result;
  _DWORD *v9;
  uint64_t (**v10)();
  _DWORD *v11;
  uint64_t (**v12)();
  _DWORD *v13;
  _DWORD *v14;
  _DWORD *v15;
  _DWORD *v16;
  _DWORD *v17;
  _DWORD *v18;
  _DWORD *v20;
  _DWORD *v21;
  _DWORD *v22;
  _DWORD *v23;
  uint64_t (**v24)();
  _DWORD *v25;
  _DWORD *v26;
  _DWORD *v27;
  _DWORD *v28;
  int v29;
  _DWORD *v30;
  _DWORD *v31;
  _DWORD *v32;
  _DWORD *v33;

  switch(a2)
  {
    case 0:
      result = operator new(0x28uLL);
      v9 = (_DWORD *)*a1;
      result[2] = 0;
      *((_QWORD *)result + 2) = v9;
      *((_BYTE *)result + 24) = 0;
      v10 = &off_100940FE0;
      goto LABEL_25;
    case 1:
      result = operator new(0x20uLL);
      v11 = (_DWORD *)*a1;
      result[2] = 0;
      *((_QWORD *)result + 2) = v11;
      *((_BYTE *)result + 24) = 0;
      v12 = &off_100941010;
      goto LABEL_29;
    case 2:
      result = operator new(0x20uLL);
      v13 = (_DWORD *)*a1;
      result[2] = 0;
      *((_QWORD *)result + 2) = v13;
      *((_BYTE *)result + 24) = 0;
      v12 = &off_100941040;
      goto LABEL_29;
    case 3:
      result = operator new(0x40uLL);
      v14 = (_DWORD *)*a1;
      result[2] = 0;
      *((_QWORD *)result + 2) = v14;
      *((_BYTE *)result + 24) = 0;
      *(_QWORD *)result = &off_100941070;
      result[13] = 0;
      result[14] = 0;
      goto LABEL_30;
    case 4:
      result = operator new(0x28uLL);
      v15 = (_DWORD *)*a1;
      result[2] = 0;
      *((_QWORD *)result + 2) = v15;
      *((_BYTE *)result + 24) = 0;
      *(_QWORD *)result = &off_1009410D0;
      result[7] = 0;
      result[8] = 0;
      result[9] = (7 - a3) % 7;
      goto LABEL_30;
    case 5:
      result = operator new(0x30uLL);
      v16 = (_DWORD *)*a1;
      result[2] = 0;
      *((_QWORD *)result + 2) = v16;
      *((_BYTE *)result + 24) = 0;
      *(_QWORD *)result = &off_1009410A0;
      result[7] = a3;
      *((_QWORD *)result + 4) = 0;
      goto LABEL_23;
    case 6:
      result = operator new(0x30uLL);
      v17 = (_DWORD *)*a1;
      result[2] = 0;
      *((_QWORD *)result + 2) = v17;
      *((_BYTE *)result + 24) = 0;
      result[7] = a3;
      *((_QWORD *)result + 4) = 0;
      *((_WORD *)result + 20) = 0;
      v12 = &off_100941100;
      goto LABEL_29;
    case 7:
      result = operator new(0x28uLL);
      v18 = (_DWORD *)*a1;
      result[2] = 0;
      *((_QWORD *)result + 2) = v18;
      *((_BYTE *)result + 24) = 0;
      *(_QWORD *)result = &off_100941220;
      result[7] = -1;
      result[8] = a3;
      goto LABEL_30;
    case 8:
      result = operator new(0x28uLL);
      v20 = (_DWORD *)*a1;
      result[2] = 0;
      *((_QWORD *)result + 2) = v20;
      *((_BYTE *)result + 24) = 0;
      *(_QWORD *)result = &off_100941250;
      result[7] = a3;
      result[8] = a5;
      goto LABEL_30;
    case 9:
      result = operator new(0x20uLL);
      v21 = (_DWORD *)*a1;
      result[2] = 0;
      *((_QWORD *)result + 2) = v21;
      *((_BYTE *)result + 24) = 0;
      v12 = &off_100941300;
      goto LABEL_29;
    case 10:
      result = operator new(0x30uLL);
      v22 = (_DWORD *)*a1;
      result[2] = 0;
      *((_QWORD *)result + 2) = v22;
      *((_BYTE *)result + 24) = 0;
      *(_QWORD *)result = &off_100941330;
      *((_QWORD *)result + 4) = 0;
      result[10] = 0;
      goto LABEL_30;
    case 11:
      result = operator new(0x20uLL);
      v23 = (_DWORD *)*a1;
      result[2] = 0;
      *((_QWORD *)result + 2) = v23;
      *((_BYTE *)result + 24) = 0;
      v24 = &off_100941360;
      goto LABEL_16;
    case 12:
      result = operator new(0x20uLL);
      v25 = (_DWORD *)*a1;
      result[2] = 0;
      *((_QWORD *)result + 2) = v25;
      *((_BYTE *)result + 24) = 0;
      v24 = &off_100941390;
LABEL_16:
      *(_QWORD *)result = v24;
      *((_WORD *)result + 13) = a3;
      goto LABEL_30;
    case 13:
      result = operator new(0x20uLL);
      v26 = (_DWORD *)*a1;
      result[2] = 0;
      *((_QWORD *)result + 2) = v26;
      *((_BYTE *)result + 24) = 0;
      v12 = &off_1009412D0;
      goto LABEL_29;
    case 14:
      result = operator new(0x20uLL);
      v27 = (_DWORD *)*a1;
      result[2] = 0;
      *((_QWORD *)result + 2) = v27;
      *((_BYTE *)result + 24) = 0;
      v12 = &off_1009413C0;
      goto LABEL_29;
    case 15:
      result = operator new(0x30uLL);
      v28 = (_DWORD *)*a1;
      result[2] = 0;
      *((_QWORD *)result + 2) = v28;
      *((_BYTE *)result + 24) = 0;
      *(_QWORD *)result = &off_100941130;
      result[7] = 0;
      result[8] = 0;
      if (a3 <= 0)
        v29 = -(-a3 & 7);
      else
        v29 = a3 & 7;
      result[9] = v29;
LABEL_23:
      *((_BYTE *)result + 40) = 0;
      goto LABEL_30;
    case 16:
      result = operator new(0x28uLL);
      v30 = (_DWORD *)*a1;
      result[2] = 0;
      *((_QWORD *)result + 2) = v30;
      *((_BYTE *)result + 24) = 0;
      v10 = &off_100941160;
LABEL_25:
      *(_QWORD *)result = v10;
      result[7] = 0;
      result[8] = 0;
      goto LABEL_30;
    case 17:
      result = operator new(0x20uLL);
      v31 = (_DWORD *)*a1;
      result[2] = 0;
      *((_QWORD *)result + 2) = v31;
      *((_BYTE *)result + 24) = 0;
      v12 = &off_100941190;
      goto LABEL_29;
    case 18:
      result = operator new(0x20uLL);
      v32 = (_DWORD *)*a1;
      result[2] = 0;
      *((_QWORD *)result + 2) = v32;
      *((_BYTE *)result + 24) = 0;
      v12 = &off_1009411C0;
      goto LABEL_29;
    case 19:
      result = operator new(0x20uLL);
      v33 = (_DWORD *)*a1;
      result[2] = 0;
      *((_QWORD *)result + 2) = v33;
      *((_BYTE *)result + 24) = 0;
      v12 = &off_1009411F0;
LABEL_29:
      *(_QWORD *)result = v12;
LABEL_30:
      *a1 = result;
      break;
    default:
      result = (_DWORD *)*a1;
      break;
  }
  result[2] = a4;
  return result;
}

void ctu::TextConverter::readChars(ctu::TextConverter *this@<X0>, uint64_t a2@<X1>, std::string *a3@<X8>)
{
  uint64_t v3;
  int v6;

  a3->__r_.__value_.__r.__words[0] = 0;
  a3->__r_.__value_.__l.__size_ = 0;
  a3->__r_.__value_.__r.__words[2] = 0;
  if (a2)
  {
    v3 = a2;
    do
    {
      v6 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)this + 16))(*(_QWORD *)this);
      if (v6 == -1)
        break;
      std::string::push_back(a3, v6);
      --v3;
    }
    while (v3);
  }
}

void sub_1006CCB74(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1006CCB90(uint64_t a1)
{
  int v1;
  uint64_t result;
  int v4;

  v1 = *(_DWORD *)(a1 + 8);
  if (!v1)
    return 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 8) = v1 - 1;
  result = *(unsigned int *)(a1 + 28);
  if ((_DWORD)result == -1)
    return result;
  v4 = *(_DWORD *)(a1 + 32);
  if (v4)
  {
    *(_DWORD *)(a1 + 32) = v4 - 1;
    if (v4 != 2)
      return a0123456789abcd_2[result & 0xF];
  }
  else
  {
    result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
    *(_DWORD *)(a1 + 28) = result;
    if ((_DWORD)result == -1)
      return result;
    *(_DWORD *)(a1 + 32) = 1;
  }
  LODWORD(result) = result >> 4;
  return a0123456789abcd_2[result & 0xF];
}

uint64_t sub_1006CCC24(uint64_t result)
{
  *(_DWORD *)(result + 28) = 0;
  *(_DWORD *)(result + 32) = 0;
  *(_BYTE *)(result + 24) = 0;
  return result;
}

uint64_t sub_1006CCC30(uint64_t a1)
{
  int v1;
  int v3;
  int v4;
  int v7;
  int v8;
  int v9;

  v1 = *(_DWORD *)(a1 + 8);
  if (!v1)
    return 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 8) = v1 - 1;
  v3 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
  v4 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
  if (v3 == -1 || v4 == -1)
    return 0xFFFFFFFFLL;
  if (v3 - 65 >= 6)
    v7 = 0;
  else
    v7 = (char)v3 - 55;
  if (v3 - 97 <= 5)
    v7 = (char)v3 - 87;
  if (v3 - 48 <= 9)
    v7 = (char)v3 - 48;
  v8 = 16 * v7;
  if (v4 - 65 >= 6)
    v9 = 0;
  else
    v9 = (char)v4 - 55;
  if (v4 - 97 <= 5)
    v9 = (char)v4 - 87;
  if (v4 - 48 <= 9)
    v9 = (char)v4 - 48;
  return v9 | v8;
}

uint64_t sub_1006CCD0C(uint64_t a1)
{
  int v1;
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v9;
  int v10;
  int v11;
  int v14;
  int v15;
  int v16;
  int v17;
  int v21;
  int v22;
  int v23;
  int v24;
  unsigned int v30;
  int v31;
  unsigned int v32;

  v1 = *(_DWORD *)(a1 + 8);
  if (!v1)
    return 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 8) = v1 - 1;
  v3 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
  v4 = v3;
  if ((_DWORD)v3 != -1 && (v3 & 0x80) != 0)
  {
    if ((v3 & 0x20) == 0)
    {
      v5 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
      if (v5 == -1)
        return 0xFFFFFFFFLL;
      else
        return v5 & 0x3F | ((v4 & 0x1F) << 6);
    }
    if ((v3 & 0x10) == 0)
    {
      v6 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
      v7 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
      if (v6 != -1 && v7 != -1)
        return ((v4 & 0xF) << 12) | ((v6 & 0x3F) << 6) | v7 & 0x3F;
      return 0xFFFFFFFFLL;
    }
    if ((v3 & 8) != 0)
    {
      if ((v3 & 4) != 0)
      {
        if ((v3 & 2) != 0)
          return 0;
        v21 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
        v22 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
        v23 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
        v24 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
        v11 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
        if (v21 == -1 || v22 == -1 || v23 == -1 || v24 == -1 || v11 == -1)
          return 0xFFFFFFFFLL;
        v14 = ((v4 & 1) << 30) | ((v21 & 0x3F) << 24) | ((v22 & 0x3F) << 18) | ((v23 & 0x3F) << 12) | ((v24 & 0x3F) << 6);
      }
      else
      {
        v15 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
        v16 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
        v17 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
        v11 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
        if (v15 == -1 || v16 == -1 || v17 == -1 || v11 == -1)
          return 0xFFFFFFFFLL;
        v14 = ((v4 & 3) << 24) | ((v15 & 0x3F) << 18) | ((v16 & 0x3F) << 12) | ((v17 & 0x3F) << 6);
      }
    }
    else
    {
      v9 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
      v10 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
      v11 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
      if (v9 == -1 || v10 == -1 || v11 == -1)
        return 0xFFFFFFFFLL;
      v14 = ((v4 & 7) << 18) | ((v9 & 0x3F) << 12) | ((v10 & 0x3F) << 6);
    }
    v30 = v14 & 0xFFFFFFC0 | v11 & 0x3F;
    v31 = v30 - 0x10000;
    v32 = v30 - 64513;
    if (v31 >= 0)
      v32 = v31;
    return ((v32 >> 10 << 16) - 671088640) | (v31 - (v32 & 0xFFFFFC00) + 56320);
  }
  return v4;
}

uint64_t sub_1006CCF84(uint64_t a1)
{
  int v1;
  int v3;
  uint64_t result;
  unsigned int v5;
  int v6;

  v1 = *(_DWORD *)(a1 + 8);
  if (!v1)
    return 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 8) = v1 - 1;
  v3 = *(_DWORD *)(a1 + 52);
  if (*(_DWORD *)(a1 + 56) == v3)
  {
    result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
    if ((_DWORD)result == -1)
      return result;
    v5 = ((result >> 6) & 0x3FFFC00) + (unsigned __int16)result - 56613888;
    if (result >> 26 != 54)
      v5 = result;
    if ((v5 & 0x7C000000) != 0)
    {
      *(int8x16_t *)(a1 + 28) = vorrq_s8(vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v5), (uint32x4_t)xmmword_100744960), (int8x16_t)xmmword_100744970), (int8x16_t)xmmword_100744980);
      *(_DWORD *)(a1 + 44) = (v5 >> 6) & 0x3F | 0x80;
      *(_DWORD *)(a1 + 48) = v5 & 0x3F | 0x80;
      v6 = 6;
    }
    else if ((v5 & 0x3E00000) != 0)
    {
      *(int8x16_t *)(a1 + 28) = vorrq_s8(vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v5), (uint32x4_t)xmmword_100744990), (int8x16_t)xmmword_1007449A0), (int8x16_t)xmmword_1007449B0);
      *(_DWORD *)(a1 + 44) = v5 & 0x3F | 0x80;
      v6 = 5;
    }
    else if ((v5 & 0x1F0000) != 0)
    {
      *(int8x8_t *)(a1 + 28) = vorr_s8(vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v5), (uint32x2_t)0xFFFFFFF4FFFFFFEELL), (int8x8_t)0x3F00000007), (int8x8_t)0x80000000F0);
      *(_DWORD *)(a1 + 36) = (v5 >> 6) & 0x3F | 0x80;
      *(_DWORD *)(a1 + 40) = v5 & 0x3F | 0x80;
      v6 = 4;
    }
    else if ((v5 & 0xF800) != 0)
    {
      *(int8x8_t *)(a1 + 28) = vorr_s8(vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v5), (uint32x2_t)0xFFFFFFFAFFFFFFF4), (int8x8_t)0x3F0000000FLL), (int8x8_t)0x80000000E0);
      *(_DWORD *)(a1 + 36) = v5 & 0x3F | 0x80;
      v6 = 3;
    }
    else if ((v5 & 0xFF80) != 0)
    {
      *(_DWORD *)(a1 + 28) = (v5 >> 6) & 0x1F | 0xC0;
      *(_DWORD *)(a1 + 32) = v5 & 0x3F | 0x80;
      v6 = 2;
    }
    else
    {
      *(_DWORD *)(a1 + 28) = (char)v5;
      v6 = 1;
    }
    v3 = 0;
    *(_DWORD *)(a1 + 56) = v6;
  }
  *(_DWORD *)(a1 + 52) = v3 + 1;
  return *(unsigned int *)(a1 + 4 * v3 + 28);
}

uint64_t sub_1006CD178(uint64_t result)
{
  *(_DWORD *)(result + 52) = 0;
  *(_DWORD *)(result + 56) = 0;
  *(_BYTE *)(result + 24) = 0;
  return result;
}

uint64_t sub_1006CD184(uint64_t a1)
{
  int v1;
  int v3;
  int v4;
  int v5;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  int v11;

  v1 = *(_DWORD *)(a1 + 8);
  if (!v1)
    return 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 8) = v1 - 1;
  if (*(_BYTE *)(a1 + 40))
  {
    v3 = *(_DWORD *)(a1 + 36);
    goto LABEL_8;
  }
  if (!*(_DWORD *)(a1 + 28))
  {
    v4 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
    *(_DWORD *)(a1 + 32) = v4;
    if (v4 != -1)
      goto LABEL_7;
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 32) = 0;
LABEL_7:
  v3 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
  *(_DWORD *)(a1 + 36) = v3;
  *(_BYTE *)(a1 + 40) = 1;
LABEL_8:
  v5 = *(_DWORD *)(a1 + 32);
  if (v5 == -1 && v3 == -1)
    return 0xFFFFFFFFLL;
  v7 = *(_DWORD *)(a1 + 28);
  v8 = v5 >> v7;
  v9 = (v3 << (7 - v7));
  if (v3 == -1)
    v9 = 0;
  v10 = v9 | v8;
  *(_DWORD *)(a1 + 28) = v7 + 1;
  if (v7 == 6)
  {
    *(_DWORD *)(a1 + 28) = 0;
    v11 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
    *(_DWORD *)(a1 + 32) = v11;
    if (v11 == -1)
      goto LABEL_20;
    goto LABEL_19;
  }
  *(_DWORD *)(a1 + 32) = v3;
  if (v3 != -1)
  {
LABEL_19:
    v11 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
LABEL_20:
    *(_DWORD *)(a1 + 36) = v11;
  }
  return v10;
}

uint64_t sub_1006CD29C(uint64_t result)
{
  *(_BYTE *)(result + 24) = 0;
  *(_QWORD *)(result + 28) = 0;
  *(_QWORD *)(result + 33) = 0;
  return result;
}

uint64_t sub_1006CD2AC(uint64_t a1)
{
  int v1;
  int v3;
  uint64_t result;
  int v5;
  int v6;
  int v7;

  v1 = *(_DWORD *)(a1 + 8);
  if (!v1)
    return 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 8) = v1 - 1;
  v3 = *(_DWORD *)(a1 + 32);
  if (v3 >= 7)
  {
    v6 = *(_DWORD *)(a1 + 28);
LABEL_10:
    result = v6 & 0x7F;
    *(_DWORD *)(a1 + 28) = v6 >> 7;
    *(_DWORD *)(a1 + 32) = v3 - 7;
  }
  else
  {
    while (1)
    {
      result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
      if ((_DWORD)result == -1)
        break;
      v5 = *(_DWORD *)(a1 + 32);
      v6 = *(_DWORD *)(a1 + 28) | ((_DWORD)result << v5);
      v3 = v5 + 8;
      *(_DWORD *)(a1 + 28) = v6;
      *(_DWORD *)(a1 + 32) = v3;
      v7 = *(_DWORD *)(a1 + 36);
      if (v7)
      {
        v6 >>= v7;
        v3 -= v7;
        *(_DWORD *)(a1 + 28) = v6;
        *(_QWORD *)(a1 + 32) = v3;
      }
      if (v3 >= 7)
        goto LABEL_10;
    }
  }
  return result;
}

uint64_t sub_1006CD350(uint64_t result)
{
  *(_DWORD *)(result + 28) = 0;
  *(_DWORD *)(result + 32) = 0;
  *(_BYTE *)(result + 24) = 0;
  return result;
}

uint64_t sub_1006CD35C(uint64_t a1)
{
  uint64_t result;

  result = sub_1006CD184(a1);
  if ((_DWORD)result != -1)
  {
    if (*(_DWORD *)(a1 + 32) == -1)
    {
      if ((result & 0xFFFFFFFE) == 0x1A && !*(_BYTE *)(a1 + 41))
        *(_DWORD *)(a1 + 32) = 13;
    }
    else if (*(_DWORD *)(a1 + 36) == -1 && *(_DWORD *)(a1 + 28) == 6)
    {
      *(_DWORD *)(a1 + 36) = 13;
      *(_BYTE *)(a1 + 41) = 1;
    }
  }
  return result;
}

uint64_t sub_1006CD3D8(uint64_t result)
{
  *(_BYTE *)(result + 24) = 0;
  *(_QWORD *)(result + 28) = 0;
  *(_QWORD *)(result + 33) = 0;
  return result;
}

uint64_t sub_1006CD3E8(uint64_t a1)
{
  int v1;
  int v3;
  int v4;
  uint64_t result;
  int v6;
  int v7;

  v1 = *(_DWORD *)(a1 + 8);
  if (!v1)
    return 0xFFFFFFFFLL;
  v3 = v1 - 1;
  *(_DWORD *)(a1 + 8) = v3;
  if (!*(_BYTE *)(a1 + 40) && *(_DWORD *)(a1 + 36))
  {
    if (v3)
    {
      result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
      *(_DWORD *)(a1 + 28) = result;
      if ((_DWORD)result == -1)
        return result;
      *(_DWORD *)(a1 + 32) = 8 - *(_DWORD *)(a1 + 36);
      goto LABEL_3;
    }
    return 0xFFFFFFFFLL;
  }
LABEL_3:
  *(_BYTE *)(a1 + 40) = 1;
  v4 = *(_DWORD *)(a1 + 32);
  if (v4 >= 7)
  {
    v6 = *(_DWORD *)(a1 + 28);
  }
  else
  {
    result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
    if ((_DWORD)result == -1)
      return result;
    v4 = *(_DWORD *)(a1 + 32) + 8;
    v6 = result | (*(_DWORD *)(a1 + 28) << 8);
    *(_DWORD *)(a1 + 28) = v6;
  }
  v7 = v4 - 7;
  result = (v6 >> v7) & 0x7F;
  *(_DWORD *)(a1 + 32) = v7;
  return result;
}

uint64_t sub_1006CD4B4(uint64_t result)
{
  *(_DWORD *)(result + 28) = 0;
  *(_DWORD *)(result + 32) = 0;
  *(_BYTE *)(result + 40) = 0;
  *(_BYTE *)(result + 24) = 0;
  return result;
}

uint64_t sub_1006CD4C4(uint64_t a1)
{
  int v1;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  uint64_t result;
  int v9;

  v1 = *(_DWORD *)(a1 + 8);
  if (!v1)
    return 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 8) = v1 - 1;
  v3 = *(_DWORD *)(a1 + 32);
  if (v3 >= 8)
  {
    v7 = *(_DWORD *)(a1 + 28);
LABEL_8:
    v9 = v3 - 8;
    result = (v7 >> v9);
    *(_DWORD *)(a1 + 32) = v9;
  }
  else
  {
    while (1)
    {
      v4 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
      v5 = *(_DWORD *)(a1 + 28);
      if (v4 == -1)
        break;
      v6 = *(_DWORD *)(a1 + 32);
      v3 = v6 + 7;
      v7 = v4 & 0x7F | (v5 << 7);
      *(_DWORD *)(a1 + 28) = v7;
      *(_DWORD *)(a1 + 32) = v6 + 7;
      if (v6 >= 1)
        goto LABEL_8;
    }
    result = (v5 << (8 - *(_DWORD *)(a1 + 32)));
    *(_DWORD *)(a1 + 8) = 0;
  }
  return result;
}

uint64_t sub_1006CD56C(uint64_t result)
{
  *(_DWORD *)(result + 28) = 0;
  *(_DWORD *)(result + 32) = 0;
  *(_BYTE *)(result + 24) = 0;
  return result;
}

uint64_t sub_1006CD578(uint64_t a1)
{
  int v1;
  uint64_t result;

  v1 = *(_DWORD *)(a1 + 8);
  if (!v1)
    return 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 8) = v1 - 1;
  result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
  if ((_DWORD)result != -1 && result >= 0x80)
  {
    *(_BYTE *)(a1 + 24) = 1;
    return 32;
  }
  return result;
}

uint64_t sub_1006CD5D8(uint64_t a1)
{
  int v1;

  v1 = *(_DWORD *)(a1 + 8);
  if (!v1)
    return 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 8) = v1 - 1;
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
}

uint64_t sub_1006CD600(uint64_t a1)
{
  int v1;

  v1 = *(_DWORD *)(a1 + 8);
  if (!v1)
    return 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 8) = v1 - 1;
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
}

uint64_t sub_1006CD628(uint64_t a1)
{
  int v1;
  uint64_t result;
  unsigned int v4;
  BOOL v5;
  unsigned __int8 *v7;

  v1 = *(_DWORD *)(a1 + 8);
  if (!v1)
    return 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 8) = v1 - 1;
  result = *(unsigned int *)(a1 + 28);
  if ((_DWORD)result != -1)
  {
    *(_DWORD *)(a1 + 28) = -1;
    return result;
  }
  result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
  if ((_DWORD)result != -1)
  {
    if ((result & 0x80000000) == 0)
    {
      v4 = *(_DWORD *)(a1 + 32);
      if (result < 0x100 || (result <= 0x17F ? (v5 = v4 == 2) : (v5 = 0), v5))
      {
        if (v4 == 3)
          v4 = 0;
        v7 = (unsigned __int8 *)*(&off_100941618 + v4) + result;
      }
      else if ((result - 896) <= 0x4F && v4 == 3)
      {
        v7 = (unsigned __int8 *)&unk_100743E6B + (result - 896);
      }
      else
      {
        if ((result - 912) > 0x1F)
        {
          if ((_DWORD)result == 8364)
          {
            LOBYTE(result) = -27;
            goto LABEL_24;
          }
          goto LABEL_28;
        }
        v7 = (unsigned __int8 *)&unk_100743EBB + (result - 912);
      }
      result = *v7;
      if ((_DWORD)result != 255)
      {
        if ((result & 0x80) != 0)
        {
LABEL_24:
          *(_DWORD *)(a1 + 28) = result & 0x7F;
          return 27;
        }
        return result;
      }
    }
LABEL_28:
    *(_BYTE *)(a1 + 24) = 1;
    return 32;
  }
  return result;
}

uint64_t sub_1006CD73C(uint64_t result)
{
  *(_DWORD *)(result + 28) = -1;
  *(_BYTE *)(result + 24) = 0;
  return result;
}

uint64_t sub_1006CD74C(uint64_t a1)
{
  int v2;
  uint64_t result;
  uint64_t v4;
  int v5;

  do
  {
    v2 = *(_DWORD *)(a1 + 8);
    if (!v2)
      return 0xFFFFFFFFLL;
    *(_DWORD *)(a1 + 8) = v2 - 1;
    result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
    if ((_DWORD)result == -1)
      return result;
  }
  while ((result & 0x80) != 0);
  v4 = (uint64_t)*(&off_100941270 + *(unsigned int *)(a1 + 32));
  if ((_DWORD)result != 27)
    return *(__int16 *)(v4 + 2 * (int)result);
  result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
  if ((_DWORD)result != -1)
  {
    v5 = (unsigned __int16)off_100941298[*(unsigned int *)(a1 + 28)][(int)result];
    if (v5 == 32)
      LOWORD(v5) = *(_WORD *)(v4 + 2 * (int)result);
    return (__int16)v5;
  }
  return result;
}

uint64_t sub_1006CD7FC(uint64_t a1)
{
  uint64_t v2;
  int v3;
  uint64_t result;

  v2 = a1;
  do
  {
    if (*(_BYTE *)(v2 + 24))
      return 0xFFFFFFFFLL;
    v2 = *(_QWORD *)(v2 + 16);
  }
  while (v2);
  v3 = *(_DWORD *)(a1 + 8);
  if (!v3)
    return 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 8) = v3 - 1;
  result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
  if ((_DWORD)result != -1 && (result & 0x80) != 0)
    *(_BYTE *)(a1 + 24) = 1;
  return result;
}

uint64_t sub_1006CD868(uint64_t a1)
{
  int v1;
  uint64_t v3;
  unsigned int v4;
  int v5;
  int v6;
  unsigned int v7;

  v1 = *(_DWORD *)(a1 + 8);
  if (!v1)
    return 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 8) = v1 - 1;
  v3 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
  if ((_DWORD)v3 != -1)
  {
    v4 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
    if (v4 == -1)
      return 0xFFFFFFFFLL;
    v3 = v4 | ((_DWORD)v3 << 8);
    if (v3 >> 10 == 54)
    {
      v5 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
      if (v5 != -1)
      {
        v6 = v5;
        v7 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
        if (v7 != -1)
          return (v6 << 8) | ((_DWORD)v3 << 16) | v7;
      }
      return 0xFFFFFFFFLL;
    }
  }
  return v3;
}

uint64_t sub_1006CD92C(uint64_t result)
{
  int v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *(_DWORD *)(result + 8);
  if (!v1)
    return 0xFFFFFFFFLL;
  v2 = result;
  *(_DWORD *)(result + 8) = v1 - 1;
  v3 = *(_QWORD *)(result + 32);
  if (!v3)
  {
    result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(result + 16) + 16))(*(_QWORD *)(result + 16));
    *(_DWORD *)(v2 + 40) = result;
    if ((_DWORD)result == -1)
      return result;
    if (result >> 27 == 27)
    {
      *(_QWORD *)(v2 + 32) = 3;
      return BYTE3(result);
    }
    *(_QWORD *)(v2 + 32) = 1;
    return BYTE1(result);
  }
  *(_QWORD *)(result + 32) = v3 - 1;
  switch(v3)
  {
    case 2:
      LODWORD(result) = *(_DWORD *)(result + 40);
      return BYTE1(result);
    case 3:
      return *(unsigned __int8 *)(result + 42);
    case 4:
      LODWORD(result) = *(_DWORD *)(result + 40);
      return BYTE3(result);
  }
  return *(unsigned __int8 *)(result + 40);
}

uint64_t sub_1006CD9EC(uint64_t result)
{
  *(_QWORD *)(result + 32) = 0;
  *(_DWORD *)(result + 40) = 0;
  *(_BYTE *)(result + 24) = 0;
  return result;
}

uint64_t sub_1006CD9FC(uint64_t a1)
{
  int v1;
  uint64_t result;
  int v4;

  v1 = *(_DWORD *)(a1 + 8);
  if (!v1)
    return 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 8) = v1 - 1;
  result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
  if ((_DWORD)result != -1)
  {
    if ((int)result > 255)
    {
      v4 = result - *(unsigned __int16 *)(a1 + 26);
      if (v4 >= 128)
        return 32;
      else
        return v4 | 0x80u;
    }
    else
    {
      return byte_100743900[(int)result];
    }
  }
  return result;
}

uint64_t sub_1006CDA78(uint64_t result)
{
  *(_BYTE *)(result + 24) = 0;
  return result;
}

uint64_t sub_1006CDA80(uint64_t a1)
{
  int v1;
  uint64_t result;
  const __int16 *v4;

  v1 = *(_DWORD *)(a1 + 8);
  if (!v1)
    return 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 8) = v1 - 1;
  result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
  if ((_DWORD)result == -1)
    return result;
  if ((int)result > 127)
    return (result & 0x7F) + *(unsigned __int16 *)(a1 + 26);
  if ((_DWORD)result == 27)
  {
    result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
    if ((_DWORD)result == -1)
      return result;
    v4 = asc_100743B00;
  }
  else
  {
    v4 = (const __int16 *)&unk_100743A00;
  }
  return v4[(int)result];
}

uint64_t sub_1006CDB1C(uint64_t result)
{
  *(_BYTE *)(result + 24) = 0;
  return result;
}

uint64_t sub_1006CDB24(uint64_t a1)
{
  int v1;
  int v3;
  int v4;
  CFIndex v5;
  uint64_t CharacterAtIndex;
  const __CFString *v7;
  const __CFString *v8;
  UInt8 bytes;
  char v11;

  v1 = *(_DWORD *)(a1 + 8);
  if (!v1)
    return 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 8) = v1 - 1;
  v3 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
  if (v3 == -1)
    return 0xFFFFFFFFLL;
  v11 = -86;
  bytes = v3;
  if (v3 >= 128)
  {
    v4 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
    if (v4 != -1)
    {
      v11 = v4;
      v5 = 2;
      goto LABEL_8;
    }
    return 0xFFFFFFFFLL;
  }
  v5 = 1;
LABEL_8:
  v7 = CFStringCreateWithBytes(kCFAllocatorDefault, &bytes, v5, 0x422u, 0);
  if (!v7)
    return 9633;
  v8 = v7;
  CharacterAtIndex = CFStringGetCharacterAtIndex(v7, 0);
  CFRelease(v8);
  return CharacterAtIndex;
}

uint64_t sub_1006CDBF8(uint64_t a1)
{
  int v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *(_DWORD *)(a1 + 8);
  if (!v1)
    return 0xFFFFFFFFLL;
  *(_DWORD *)(a1 + 8) = v1 - 1;
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 40) = v3 + 1;
  return *(unsigned __int8 *)(v2 + v3);
}

uint64_t sub_1006CDC24(uint64_t result)
{
  *(_QWORD *)(result + 40) = 0;
  *(_BYTE *)(result + 24) = 0;
  return result;
}

void sub_1006CDCD8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Sniff/Active mode change ignored, couldn't find device", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006CDD04()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Enter Advanced Sniff ignored - Couldn't find the connection handle", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006CDD30()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Advanced Sniff mode change ignored, connection invalid", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006CDD5C(unsigned __int8 a1, int a2, os_log_t log)
{
  _DWORD v3[2];
  __int16 v4;
  int v5;

  v3[0] = 67109376;
  v3[1] = a2;
  v4 = 1024;
  v5 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Advanced Sniff mode change ignored, duplicate mode: %d, maxAge %d", (uint8_t *)v3, 0xEu);
}

void sub_1006CDDE4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Exit Advanced Sniff ignored - Couldn't find device", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006CDE10(unint64_t a1, NSObject *a2)
{
  int v3;
  uint64_t v4;
  _DWORD v5[2];

  v3 = *(unsigned __int8 *)sub_100097224(a1);
  v5[0] = 67109120;
  v5[1] = v3;
  sub_100097200((void *)&_mh_execute_header, a2, v4, "Exit Advanced Sniff ignored, link not in Advanced Sniff, mode :%d", (uint8_t *)v5);
  sub_100097218();
}

void sub_1006CDE88()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Exit Advanced Sniff ignored - Couldn't find the connection handle", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006CDEB4()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[8];

  sub_100097230();
  sub_100097200((void *)&_mh_execute_header, v0, v1, "Exit Advanced Sniff command failed - reason: %d", v2);
  sub_10007266C();
}

void sub_1006CDF18()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Enter Advanced Sniff ignored - Couldn't find device", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006CDF44()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Enter Advanced Sniff ignored, link already in AdvancedSniff", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006CDF70(unint64_t a1, NSObject *a2)
{
  int v3;
  uint64_t v4;
  _DWORD v5[2];

  v3 = *(unsigned __int8 *)sub_100097224(a1);
  v5[0] = 67109120;
  v5[1] = v3;
  sub_100097200((void *)&_mh_execute_header, a2, v4, "Enter Advanced Sniff fail with link in invalid mode: %d", (uint8_t *)v5);
  sub_100097218();
}

void sub_1006CDFE8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Enter Advanced Sniff fail - Couldn't find the connection handle", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006CE014()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[8];

  sub_100097230();
  sub_100097200((void *)&_mh_execute_header, v0, v1, "Advanced Sniff Exit command failed - reason: %d", v2);
  sub_10007266C();
}

void sub_1006CE078()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[8];

  sub_100097230();
  sub_100097200((void *)&_mh_execute_header, v0, v1, "Advanced Sniff Reconfig command failed - reason: %d", v2);
  sub_10007266C();
}

void sub_1006CE0DC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Advanced Sniff band switch, BSM invalid input device or no device connected", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006CE108()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Advanced Sniff band switch, BSM input device and ALM device out of sync", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006CE134()
{
  errx(1, "Failed to register the Bluetooth daemon listeners\n");
}

void sub_1006CE14C(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (sub_100098F64())
    sub_100098F50((void *)&_mh_execute_header, v2, v3, "%s: No valid serial port found (tried cu.bluetooth and uart.bluetooth)\n", v4, v5, v6, v7, 2u);
  *a1 = "%s: No valid serial port found (tried cu.bluetooth and uart.bluetooth)\n";
  sub_100072694();
}

void sub_1006CE1E0(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (sub_100098F64())
    sub_100098F50((void *)&_mh_execute_header, v2, v3, "%s: Not a valid MAC address (all 00s).\n", v4, v5, v6, v7, 2u);
  *a1 = "%s: Not a valid MAC address (all 00s).\n";
  sub_100072694();
}

void sub_1006CE274(int *a1, uint64_t a2, NSObject *a3)
{
  int v3;

  v3 = *a1;
  *(_DWORD *)a2 = 67109120;
  *(_DWORD *)(a2 + 4) = v3;
  sub_100072674((void *)&_mh_execute_header, a2, a3, "### _CS_DARWIN_USER_TEMP_DIR failed: %d", (uint8_t *)a2);
}

void sub_1006CE2B0(int *a1, uint64_t a2, NSObject *a3)
{
  int v3;

  v3 = *a1;
  *(_DWORD *)a2 = 67109120;
  *(_DWORD *)(a2 + 4) = v3;
  sub_100072674((void *)&_mh_execute_header, a2, a3, "### _set_user_dir_suffix failed: %d", (uint8_t *)a2);
}

void sub_1006CE2EC(uint64_t a1, int a2, NSObject *a3)
{
  *(_DWORD *)a1 = 67109120;
  *(_DWORD *)(a1 + 4) = a2;
  sub_100072674((void *)&_mh_execute_header, a2, a3, "Failed to update Dynamic Store. BTLocalDeviceGetModulePower returned %d", (uint8_t *)a1);
}

void sub_1006CE324(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a2, a3, "Update Dynamic Store failed with error %s", a5, a6, a7, a8, 2u);
}

void sub_1006CE38C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a2, a3, "%s: Unable to match bluetooth service in device tree.\n", a5, a6, a7, a8, 2u);
}

void sub_1006CE3F4(uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

void sub_1006CE414(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "Adaptive Latency Invalid Device", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006CE444(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "Low Latency Game decideLowLatencyGameState skipped", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006CE474(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "Adaptive Latency Headset Feedback, Invalid Device return", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006CE4A4(uint64_t a1, NSObject *a2)
{
  int v2;
  _DWORD v3[2];

  v2 = *(unsigned __int16 *)(a1 + 32);
  v3[0] = 67109120;
  v3[1] = v2;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Adaptive Latency Headset DSP critical: %d", (uint8_t *)v3, 8u);
  sub_10007266C();
}

void sub_1006CE518(int a1, NSObject *a2)
{
  _DWORD v2[2];
  __int16 v3;
  int v4;

  v2[0] = 67109376;
  v2[1] = 200;
  v3 = 1024;
  v4 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Failed to initialize the packet flush timeout to %d with error %{bluetooth:OI_STATUS}u", (uint8_t *)v2, 0xEu);
  sub_1000726A0();
}

void sub_1006CE598(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a2, a3, "Updated currentJitterBuffer. invalid device param: %p", a5, a6, a7, a8, 0);
  sub_1000726A0();
}

void sub_1006CE600(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1000726A8((void *)&_mh_execute_header, a2, a3, "Spatial found device: %@", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006CE664(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1000726A8((void *)&_mh_execute_header, a2, a3, "Spatial found no match device: %@", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006CE6C8(uint64_t a1, uint64_t a2, os_log_t log)
{
  int v3;
  uint64_t v4;
  __int16 v5;
  uint64_t v6;

  v3 = 138412546;
  v4 = a1;
  v5 = 2080;
  v6 = a2;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "Spatial lost device: %@ (%s)", (uint8_t *)&v3, 0x16u);
  sub_1000726A0();
}

void sub_1006CE748(os_log_t log)
{
  uint8_t v1[16];

  *(_WORD *)v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Something went wrong, mismatch detected with spatialInteractionDeviceTimestamp array, removing them", v1, 2u);
}

void sub_1006CE788(uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0)
    sub_1000726B8((void **)a1);
}

void sub_1006CE7A4()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E74BC();
  sub_1000726E0();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006CE80C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1000E74BC();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, 2u);
  sub_100072694();
}

void sub_1006CE888()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "applebt_rx_main: Exiting rx thread\n", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006CE8B4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "applebt_rx_main: btdev is NULL or not opened\n", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006CE8E0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "applebt_rx_main: applebt_hci_read DEVICE_ERROR - probably Recovery is in progress\n", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006CE90C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "applebt_rx_main: applebt_hci_read NO_MEMORY - driver not READY, failed to allocate shared memory blocks\n", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006CE938()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "applebt_rx_main: applebt_hci_read DEVICE_OFFLINE - device was powered off\n", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006CE964()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "applebt_rx_main: applebt_hci_close returned 0x%08X\n", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006CE9C4(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a2, a3, "applebt_rx_main: applebt_read_crash_info returned unsupported result size=%zu\n", a5, a6, a7, a8, 0);
  sub_1000726A0();
}

void sub_1006CEA2C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E9140();
  sub_1000E9130((void *)&_mh_execute_header, v0, v1, "applebt_rx_main: applebt_read_crash_info succeeds, read result=0x%08X new format(size=%zu)\n", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006CEA90()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E9140();
  sub_1000E9130((void *)&_mh_execute_header, v0, v1, "applebt_rx_main: applebt_read_crash_info succeeds, read result=0x%08X old format(size=%zu)\n", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006CEAF4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "applebt_rx_main: applebt_read_crash_info returned fatal error, read result=0x%08X\n", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006CEB54()
{
  int v0;
  os_log_t v1;
  uint8_t v2[8];
  __int16 v3;
  int v4;

  sub_100097230();
  v3 = 1024;
  v4 = v0;
  _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "applebt_rx_main: applebt_hci_read returned fatal error, read result=0x%08X pipes result=0x%08X - closing HCI device and aborting\n", v2, 0xEu);
  sub_1000726A0();
}

void sub_1006CEBD0(int a1, int a2, NSObject *a3)
{
  int v5;
  const char *v6;
  __int16 v7;
  const char *v8;

  v5 = 136315394;
  v6 = sub_1001A2DD4(a1);
  v7 = 2080;
  v8 = sub_1001A2DD4(a2);
  _os_log_error_impl((void *)&_mh_execute_header, a3, OS_LOG_TYPE_ERROR, "applebt_rx_main: applebt_hci_read failures, read result=%s pipes result=%s\n", (uint8_t *)&v5, 0x16u);
}

void sub_1006CEC7C(uint8_t *buf, unsigned __int8 *a2, int *a3, os_log_t log)
{
  int v4;

  v4 = *a2 + 1;
  *(_DWORD *)buf = 67109120;
  *a3 = v4;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "applebt_rx_main: resetting next seq_num to %d\n", buf, 8u);
}

void sub_1006CECCC(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a2, a3, "applebt_set_hci_packet_attrs_from_footer: bt_packet_attr_decode error=0x%zX", a5, a6, a7, a8, 0);
  sub_1000726A0();
}

void sub_1006CED30()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "applebt_transport_terminate: pthread_join returned 0x%08X\n", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006CED90()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "applebt_transport_terminate: applebt_hci_close returned 0x%08X\n", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006CEDF0(uint8_t *a1, _QWORD *a2, NSObject *a3)
{
  void *v6;

  v6 = sub_100054494();
  *(_DWORD *)a1 = 136446210;
  *a2 = v6;
  _os_log_error_impl((void *)&_mh_execute_header, a3, OS_LOG_TYPE_ERROR, "%{public}s", a1, 0xCu);
}

void sub_1006CEE54()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1000E74BC();
  sub_100072720((void *)&_mh_execute_header, v0, v1, "%{public}s", v2, v3, v4, v5, 2u);
  sub_100072694();
}

void sub_1006CEEC0()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E74BC();
  sub_1000EEFE4();
  sub_100072720((void *)&_mh_execute_header, v0, v1, "%{public}s", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006CEF28(NSObject *a1)
{
  int v2;
  void *v3;
  __int16 v4;
  int v5;

  v2 = 136446466;
  v3 = sub_100054494();
  v4 = 1024;
  v5 = 0xFFFF;
  _os_log_error_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_ERROR, "%{public}s (status=%{bluetooth:OI_STATUS}u)", (uint8_t *)&v2, 0x12u);
}

void sub_1006CEFC0()
{
  NSObject *v0;
  uint8_t *v1;
  void *v2;

  v2 = sub_1000FB304();
  sub_1000FB320((uint64_t)v2, 4.8751e-34);
  sub_1000FB2FC((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%{public}s", v1);
  sub_1000FB314();
}

uint64_t sub_1006CF008(NSObject *a1, char a2)
{
  uint8_t v5[24];

  sub_1000E74BC();
  sub_1000726E0();
  _os_log_error_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_ERROR, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v5, 0x12u);
  return a2 & 1;
}

void sub_1006CF090(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "Unknown ControllerChipset type passed-in.", a5, a6, a7, a8, 0);
}

void sub_1006CF0C4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "Failed to determine ControllerChipset type.", a5, a6, a7, a8, 0);
}

void sub_1006CF0F8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1001084D0();
  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006CF16C(int a1, int a2, os_log_t log)
{
  _DWORD v3[2];
  __int16 v4;
  int v5;

  v3[0] = 67109376;
  v3[1] = a1;
  v4 = 1024;
  v5 = a2;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "HCILiteEventFilter buffer is smaller than expected. %ul < %ul", (uint8_t *)v3, 0xEu);
  sub_1000726A0();
}

void sub_1006CF1EC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006CF26C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006CF2EC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006CF36C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006CF3EC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "BYTESTREAM_CHECK_ERROR (%s)", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006CF45C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1001084D0();
  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006CF4D0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006CF554(int a1, int a2)
{
  NSObject *v2;
  _DWORD v3[2];
  __int16 v4;
  int v5;
  const char *v6;

  v3[0] = 67109634;
  v3[1] = a1;
  v4 = 1024;
  v5 = a2;
  sub_1001084C4();
  v6 = "_Bool Filter_OI_DHCI_RETURN_LINK_KEYS_EVENT(OI_BYTE_STREAM *)";
  sub_1001084A8((void *)&_mh_execute_header, v2, (uint64_t)v2, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", (uint8_t *)v3);
  sub_1000726A0();
}

void sub_1006CF5DC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "BYTESTREAM_CHECK_ERROR (%s)", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006CF64C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006CF6CC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006CF74C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006CF7CC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006CF84C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006CF8D0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006CF950(int a1, int a2)
{
  NSObject *v2;
  _DWORD v3[2];
  __int16 v4;
  int v5;
  const char *v6;

  v3[0] = 67109634;
  v3[1] = a1;
  v4 = 1024;
  v5 = a2;
  sub_1001084C4();
  v6 = "_Bool Filter_OI_DHCI_CONNECTIONLESS_PERIPHERAL_BROADCAST_RECEIVE_EVENT(OI_BYTE_STREAM *)";
  sub_1001084A8((void *)&_mh_execute_header, v2, (uint64_t)v2, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", (uint8_t *)v3);
  sub_1000726A0();
}

void sub_1006CF9D8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "BYTESTREAM_CHECK_ERROR (%s)", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006CFA48()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1001084D0();
  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006CFABC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1001084D0();
  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006CFB30()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006CFBB0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006CFC30()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1001084D0();
  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006CFCA4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1001084D0();
  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006CFD18()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006CFD98(int a1, int a2)
{
  NSObject *v2;
  _DWORD v3[2];
  __int16 v4;
  int v5;
  const char *v6;

  v3[0] = 67109634;
  v3[1] = a1;
  v4 = 1024;
  v5 = a2;
  sub_1001084C4();
  v6 = "_Bool Filter_OI_DHCI_CMD_ID_CREATE_PHYSICAL_LINK_OPCODE(OI_BYTE_STREAM *)";
  sub_1001084A8((void *)&_mh_execute_header, v2, (uint64_t)v2, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", (uint8_t *)v3);
  sub_1000726A0();
}

void sub_1006CFE20(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "BYTESTREAM_CHECK_ERROR (%s)", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006CFE90()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006CFF10(int a1, int a2)
{
  NSObject *v2;
  _DWORD v3[2];
  __int16 v4;
  int v5;
  const char *v6;

  v3[0] = 67109634;
  v3[1] = a1;
  v4 = 1024;
  v5 = a2;
  sub_1001084C4();
  v6 = "_Bool Filter_OI_DHCI_CMD_ID_ACCEPT_PHYSICAL_LINK_OPCODE(OI_BYTE_STREAM *)";
  sub_1001084A8((void *)&_mh_execute_header, v2, (uint64_t)v2, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", (uint8_t *)v3);
  sub_1000726A0();
}

void sub_1006CFF98(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "BYTESTREAM_CHECK_ERROR (%s)", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006D0008()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006D0088()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006D0108()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006D0188()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1001084D0();
  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006D01FC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006D027C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006D02FC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006D037C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006D03FC(int a1, int a2)
{
  NSObject *v2;
  _DWORD v3[2];
  __int16 v4;
  int v5;
  const char *v6;

  v3[0] = 67109634;
  v3[1] = a1;
  v4 = 1024;
  v5 = a2;
  sub_1001084C4();
  v6 = "_Bool Filter_OI_DHCI_CMD_ID_LE_SET_EXTENDED_ADVERTISING_DATA_OPCODE(OI_BYTE_STREAM *)";
  sub_1001084A8((void *)&_mh_execute_header, v2, (uint64_t)v2, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", (uint8_t *)v3);
  sub_1000726A0();
}

void sub_1006D0484(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "BYTESTREAM_CHECK_ERROR (%s)", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006D04F4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006D0574(int a1, int a2)
{
  NSObject *v2;
  _DWORD v3[2];
  __int16 v4;
  int v5;
  const char *v6;

  v3[0] = 67109634;
  v3[1] = a1;
  v4 = 1024;
  v5 = a2;
  sub_1001084C4();
  v6 = "_Bool Filter_OI_DHCI_CMD_ID_LE_SET_EXTENDED_SCAN_RESPONSE_DATA_OPCODE(OI_BYTE_STREAM *)";
  sub_1001084A8((void *)&_mh_execute_header, v2, (uint64_t)v2, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", (uint8_t *)v3);
  sub_1000726A0();
}

void sub_1006D05FC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "BYTESTREAM_CHECK_ERROR (%s)", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006D066C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006D06EC(int a1, int a2)
{
  NSObject *v2;
  _DWORD v3[2];
  __int16 v4;
  int v5;
  const char *v6;

  v3[0] = 67109634;
  v3[1] = a1;
  v4 = 1024;
  v5 = a2;
  sub_1001084C4();
  v6 = "_Bool Filter_OI_DHCI_CMD_ID_LE_SET_PERIODIC_ADVERTISING_DATA_OPCODE(OI_BYTE_STREAM *)";
  sub_1001084A8((void *)&_mh_execute_header, v2, (uint64_t)v2, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", (uint8_t *)v3);
  sub_1000726A0();
}

void sub_1006D0774(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "BYTESTREAM_CHECK_ERROR (%s)", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006D07E4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006D0864()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1001084D0();
  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006D08D8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1001084D0();
  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006D094C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006D09D0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006D0A54(int a1, int a2)
{
  NSObject *v2;
  _DWORD v3[2];
  __int16 v4;
  int v5;
  const char *v6;

  v3[0] = 67109634;
  v3[1] = a1;
  v4 = 1024;
  v5 = a2;
  sub_1001084C4();
  v6 = "_Bool Filter_OI_DHCI_WRITE_STORED_LINK_KEY_OPCODE(OI_BYTE_STREAM *)";
  sub_1001084A8((void *)&_mh_execute_header, v2, (uint64_t)v2, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", (uint8_t *)v3);
  sub_1000726A0();
}

void sub_1006D0ADC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "BYTESTREAM_CHECK_ERROR (%s)", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006D0B4C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006D0BCC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1001084D0();
  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006D0C40()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006D0CC0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006D0D40()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006D0DC4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006D0E48(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "BYTESTREAM_CHECK_ERROR (%s)", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006D0EB8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1001084D0();
  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006D0F2C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1001084D0();
  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006D0FA0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006D1020()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1001084D0();
  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006D1094()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006D1118()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1001084D0();
  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006D118C(int a1, int a2)
{
  NSObject *v2;
  _DWORD v3[2];
  __int16 v4;
  int v5;
  const char *v6;

  v3[0] = 67109634;
  v3[1] = a1;
  v4 = 1024;
  v5 = a2;
  sub_1001084C4();
  v6 = "_Bool Filter_LE_EXTENDED_ADVERTISING_REPORT_SUBEVENT(OI_BYTE_STREAM *)";
  sub_1001084A8((void *)&_mh_execute_header, v2, (uint64_t)v2, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", (uint8_t *)v3);
  sub_1000726A0();
}

void sub_1006D1214(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "BYTESTREAM_CHECK_ERROR (%s)", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006D1284()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006D1304(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "BYTESTREAM_CHECK_ERROR (%s)", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006D1374()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006D13F4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1001084D0();
  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006D1468()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1001084D0();
  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006D14DC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006D155C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006D15DC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006D165C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006D16DC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1001084D0();
  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006D1750()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1001084D0();
  sub_1001084B4();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "HCILite filtering. Buffer is smaller than expected. %ul < %ul (%s)", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006D17C4()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10010B398();
  sub_1000E74BC();
  sub_10010B380();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006D182C()
{
  uint64_t v0;

  perror("Failed to CreateThread ");
  v0 = sub_100112D60(108);
  sub_1006D1848(v0);
}

void sub_1006D1848(uint64_t a1)
{
  void (*v2)(const char *, uint64_t);
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v2 = (void (*)(const char *, uint64_t))dlsym((void *)0xFFFFFFFFFFFFFFFFLL, "WriteStackshotReport_stdc");
  if (v2)
    v2("BT Stack Stuck", 3172327085);
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  if (!byte_10097FAC8)
    __strlcpy_chk(&byte_10097FAC8, "unknown", 64, 64);
  snprintf((char *)a1, 0x80uLL, "Stack watchdog timeout on thread: %s", &byte_10097FAC8);
  qword_10097BA60 = a1;
  sub_100253320((uint64_t)"Watchdog_Timer - Stack Mutex try lock failed and watchdog has struck twice -- abort\n", v3, v4, v5, v6, v7, v8, v9, v10);
  sub_100112D5C();
  abort();
}

void sub_1006D1900()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E74BC();
  sub_1001191B8();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006D1968()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E74BC();
  sub_1001191D4();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006D19D0()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E74BC();
  sub_1001191F0();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006D1A38()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to open directory", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D1A64()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v0 = sub_10011E980();
  sub_10011E964(v0);
  sub_10011E96C((void *)&_mh_execute_header, v1, v2, "Failed to create directory %s %s", v3, v4, v5, v6, 2u);
  sub_100072694();
}

void sub_1006D1AE8()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v0 = sub_10011E980();
  sub_10011E964(v0);
  sub_10011E96C((void *)&_mh_execute_header, v1, v2, "Failed to create Log directory %s %s", v3, v4, v5, v6, 2u);
  sub_100072694();
}

void sub_1006D1B68(int a1, NSObject *a2)
{
  _DWORD v2[2];

  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Error starting PacketLogger XPC service, error: %d", (uint8_t *)v2, 8u);
  sub_10007266C();
}

void sub_1006D1BD8()
{
  os_log_t v0;
  uint8_t v1[24];

  sub_1000EEFE4();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Set header to %s", v1, 0xCu);
  sub_1000726A0();
}

void sub_1006D1C44()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Error invalid length", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D1C70(NSObject *a1)
{
  int *v2;
  uint64_t v3;
  uint8_t v4[24];

  v2 = sub_10011E980();
  sub_10011E964(v2);
  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, a1, v3, "Failed to open file for writing: %s", v4);
  sub_100072694();
}

void sub_1006D1CE4(NSObject *a1)
{
  uint64_t v2;
  uint8_t v3[24];

  sub_100054494();
  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, a1, v2, "%{public}s", v3);
  sub_100072694();
}

void sub_1006D1D58(NSObject *a1)
{
  int *v2;
  uint64_t v3;
  uint8_t v4[24];

  v2 = sub_10011E980();
  sub_10011E964(v2);
  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, a1, v3, "Failed to open new file for writing: %s", v4);
  sub_100072694();
}

void sub_1006D1DCC(uint8_t *buf, _BYTE *a2, os_log_t log)
{
  *buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Failed to stat file", buf, 2u);
}

void sub_1006D1E08(uint64_t a1, NSObject *a2)
{
  uint64_t v4;
  int *v5;
  int v6;
  uint64_t v7;
  __int16 v8;
  uint64_t v9;
  __int16 v10;
  char *v11;

  v4 = qword_100981498;
  v5 = __error();
  v6 = 136315650;
  v7 = v4;
  v8 = 2080;
  v9 = a1;
  v10 = 2080;
  v11 = sub_10011E964(v5);
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Failed to rename file %s->%s %s", (uint8_t *)&v6, 0x20u);
}

void sub_1006D1EBC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Bluetooth Profile Required", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D1EE8()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "Error with PacketLogger connection %{public}s", v2);
  sub_1000726A0();
}

void sub_1006D1F4C()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "Error with PacketLogger connection %s", v2);
  sub_1000726A0();
}

void sub_1006D1FB0(NSObject *a1)
{
  int v2;
  void *v3;

  v2 = 136446210;
  v3 = sub_1000E74BC();
  _os_log_error_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_ERROR, "%{public}s", (uint8_t *)&v2, 0xCu);
  sub_100072694();
}

void sub_1006D202C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100054494();
  sub_1000726E0();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006D2098()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "applebt_mgmt_connect: IOServiceOpen returned 0x%08X\n", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D20F8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "applebt_set_trace_mode: IOConnectCallMethod returned 0x%08X\n", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D2158()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "applebt_set_trace_mode: applebt_mgmt_connect returned 0x%08X\n", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D21B8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "applebt_set_trace_level: IOConnectCallMethod returned 0x%08X\n", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D2218()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "applebt_set_trace_level: applebt_mgmt_connect returned 0x%08X\n", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D2278()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "applebt_set_trace_mask: IOConnectCallMethod returned 0x%08X\n", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D22D8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "applebt_set_trace_mask: applebt_mgmt_connect returned 0x%08X\n", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D2338()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "applebt_set_capture_timeout: IOConnectCallMethod returned 0x%08X\n", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D2398()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "applebt_set_capture_timeout: applebt_mgmt_connect returned 0x%08X\n", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D23F8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "applebt_trigger_capture: IOConnectCallMethod returned 0x%08X\n", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D2458()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "applebt_trigger_capture: applebt_mgmt_connect returned 0x%08X\n", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D24B8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "applebt_general_debug: IOConnectCallMethod returned 0x%08X\n", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D2518()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "applebt_general_debug: applebt_mgmt_connect returned 0x%08X\n", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D2578()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "applebt_read_crash_info: IOConnectCallMethod returned 0x%08X\n", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D25D8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "applebt_read_crash_info: applebt_mgmt_connect returned 0x%08X\n", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D2638()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E74BC();
  sub_100154668();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006D26A0(NSObject *a1)
{
  uint8_t v2[12];
  __int16 v3;
  int v4;

  sub_1000E74BC();
  sub_1000EEFE4();
  v3 = 1024;
  v4 = 0xFFFF;
  _os_log_error_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_ERROR, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, 0x12u);
  sub_100072694();
}

void sub_1006D2728()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E74BC();
  sub_10010B380();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006D2794()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E74BC();
  sub_10016574C();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006D2804()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E74BC();
  sub_10016574C();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006D2874()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E74BC();
  sub_10016F55C();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006D28DC()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E74BC();
  sub_10016574C();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006D294C()
{
  NSObject *v0;
  _QWORD *v1;
  uint8_t *v2;
  void *v3;

  v3 = sub_1000FB304();
  *(_DWORD *)v2 = 136446210;
  *v1 = v3;
  sub_1000FB2FC((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%{public}s", v2);
  sub_1000FB314();
}

void sub_1006D2998()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1000E74BC();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, 2u);
  sub_100072694();
}

void sub_1006D2A14()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E74BC();
  sub_10017FAEC();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006D2A7C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E74BC();
  sub_10016574C();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006D2AE8()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E74BC();
  sub_10016574C();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006D2B58()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E74BC();
  sub_10016574C();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006D2BC8()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E74BC();
  sub_10016574C();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006D2C38()
{
  _QWORD *v0;
  _DWORD *v1;
  void *v2;
  uint64_t v3;
  uint64_t v4;

  v2 = sub_1000FB304();
  *v1 = 136446210;
  *v0 = v2;
  sub_100184790((void *)&_mh_execute_header, v3, v4, "%{public}s");
  sub_1000FB314();
}

void sub_1006D2C78()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E74BC();
  sub_10016574C();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006D2CE8(NSObject *a1)
{
  int v2;
  void *v3;

  v2 = 136446210;
  v3 = sub_100054494();
  _os_log_error_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_ERROR, "%{public}s", (uint8_t *)&v2, 0xCu);
}

void sub_1006D2D70()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1000E74BC();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, 2u);
  sub_100072694();
}

void sub_1006D2DEC()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E74BC();
  sub_10016574C();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006D2E5C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E74BC();
  sub_10019CB08();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006D2EC4()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E74BC();
  sub_1000EEFE4();
  sub_10019ED20((void *)&_mh_execute_header, v0, v1, "%{public}s", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006D2F2C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1000E74BC();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, 2u);
  sub_100072694();
}

void sub_1006D2FA8()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E74BC();
  sub_1001A289C();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006D3010()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E74BC();
  sub_1001A2864();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006D3078()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E74BC();
  sub_1001A2848();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006D30E0()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E74BC();
  sub_10016574C();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006D3150()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E74BC();
  sub_10016574C();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006D31C0()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E74BC();
  sub_1001A28B8();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006D3228()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E74BC();
  sub_1001A28D4();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006D3290()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E74BC();
  sub_1001A2880();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006D32F8()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E74BC();
  sub_1001A28F0();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006D3360()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10010B398();
  sub_1001A3CDC(v0);
  sub_1001A3CC4();
  sub_1000726FC((void *)&_mh_execute_header, v1, v2, "applebt_hci_open: IOConnectCallMethod returned (0x%08X, %s)\n", v3, v4, v5, v6, v7);
  sub_100072694();
}

void sub_1006D33C8(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "applebt_hci_open: applebt_hci_connect returned 0x%08X\n", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006D342C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "applebt_hci_connect: IOServiceOpen returned 0x%08X\n", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006D3490(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "applebt_hci_connect: IOServiceAddMatchingNotification returned 0x%08X\n", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006D34F4()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10010B398();
  sub_1001A3CDC(v0);
  sub_1001A3CC4();
  sub_1000726FC((void *)&_mh_execute_header, v1, v2, "applebt_hci_close: IOConnectCallMethod returned (0x%08X, %s), closing connection\n", v3, v4, v5, v6, v7);
  sub_100072694();
}

void sub_1006D355C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "applebt_hci_close: Not opened\n", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D3588()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10010B398();
  sub_1001A3CDC(v0);
  sub_1001A3CC4();
  sub_1000726FC((void *)&_mh_execute_header, v1, v2, "applebt_hci_transport_reset: IOConnectCallMethod returned (0x%08X, %s)\n", v3, v4, v5, v6, v7);
  sub_100072694();
}

void sub_1006D35F0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "applebt_hci_transport_reset: Not opened\n", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D361C()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10010B398();
  sub_1001A3CDC(v0);
  sub_1001A3CC4();
  sub_1000726FC((void *)&_mh_execute_header, v1, v2, "applebt_hci_write: IOConnectCallMethod returned (0x%08X, %s)\n", v3, v4, v5, v6, v7);
  sub_100072694();
}

void sub_1006D3684()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "applebt_hci_write: Not opened\n", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D36B0()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10010B398();
  sub_1001A3CDC(v0);
  sub_1001A3CC4();
  sub_1000726FC((void *)&_mh_execute_header, v1, v2, "applebt_hci_read: IOConnectCallMethod returned (0x%08X, %s)\n", v3, v4, v5, v6, v7);
  sub_100072694();
}

void sub_1006D3718()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "applebt_hci_read: Not opened\n", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D3744()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "applebt_hci_pipes_info: service not opened\n", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D3770()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E74BC();
  sub_1001E2CB4();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006D37D8()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E74BC();
  sub_1001E2C98();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006D3840(NSObject *a1)
{
  uint8_t v2[24];

  sub_1000E74BC();
  sub_1000EEFE4();
  _os_log_fault_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_FAULT, "%{public}s", v2, 0xCu);
  sub_100072694();
}

void sub_1006D38B8()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E74BC();
  sub_10016574C();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006D3928()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E74BC();
  sub_10016574C();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006D3998()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E74BC();
  sub_100204FC4();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006D3A00()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E74BC();
  sub_100204FA8();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006D3A68()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1000E74BC();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, 2u);
  sub_100072694();
}

void sub_1006D3AE4(NSObject *a1)
{
  int v2;
  void *v3;

  v2 = 136446210;
  v3 = sub_1000E74BC();
  _os_log_fault_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_FAULT, "%{public}s", (uint8_t *)&v2, 0xCu);
  sub_100072694();
}

void sub_1006D3B60()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1000E74BC();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, 2u);
  sub_100072694();
}

void sub_1006D3BDC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t vars0;

  sub_100253320((uint64_t)"failed to allocate memory for tx_buff", a2, a3, a4, a5, a6, a7, a8, vars0);
  __break(1u);
}

void sub_1006D3BF4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t vars0;

  sub_100253320((uint64_t)"Virtual transport failed to create HCI transport\n", a2, a3, a4, a5, a6, a7, a8, vars0);
  sub_100240454(v8, v9, v10, v11, v12, v13, v14, v15);
  __break(1u);
}

void sub_1006D3C10(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t vars0;

  sub_100253320((uint64_t)"BTVirtual transport free SCO transport failed\n", a2, a3, a4, a5, a6, a7, a8, vars0);
  __break(1u);
}

void sub_1006D3C28(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t vars0;

  sub_100253320((uint64_t)"BTVirtual transport free ACL transport failed\n", a2, a3, a4, a5, a6, a7, a8, vars0);
  __break(1u);
}

void sub_1006D3C40(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t vars0;

  sub_100253320((uint64_t)"BTVirtual transport free HCI transport failed\n", a2, a3, a4, a5, a6, a7, a8, vars0);
  __break(1u);
}

void sub_1006D3C58()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000E74BC();
  sub_10016574C();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "%{public}s (status=%{bluetooth:OI_STATUS}u)", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006D3CC8(NSObject *a1)
{
  int v2;
  void *v3;
  __int16 v4;
  int v5;

  v2 = 136446466;
  v3 = sub_100054494();
  v4 = 1024;
  v5 = 1023;
  _os_log_error_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_ERROR, "%{public}s (status=%{bluetooth:OI_STATUS}u)", (uint8_t *)&v2, 0x12u);
}

void sub_1006D3D60(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "Failed to Clear lpm2 flag with error %@", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006D3DC8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "Failed to Clear lpm1 flag with error %@", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006D3E30(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "Failed to set all flags with error %@", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006D3E98()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "Failed to set all flags with error %@", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006D3EF8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to create a LPM notification token", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D3F24()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "LPM is not supported", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D3F50()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Altough lpm1Flag is enabled, power reason is not critical battery.", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D3F7C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to enter LPM.", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D3FA8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to start HCI tracing.", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D3FD4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Transport layer initialization failed.", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D4000()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to configure hostless mode with error %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D4060()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "System is still SLEEP!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D408C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to prepare VSC commands with error %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D40EC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Wifi is still ON!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D4118()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "We don't have offline ADV data yet", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D4144(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "Failed to notify %s, notification token is invalid", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006D41B4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_100262284();
  sub_1000E9130((void *)&_mh_execute_header, v0, v1, "Failed to notify %s, notify_post returned %d", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006D4220()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_100262284();
  sub_1000E9130((void *)&_mh_execute_header, v0, v1, "Failed to notify %s, notify_set_state returned %d", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006D428C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "No peripheral is found when LPM_CONFIG_FLAG_BIT_DEBUG_MODE_USE_VSC is set.", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D42B8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BA_LPEM feature is off.", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D42E4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "lpmFlag is not enabled. Failed to enter LPM.", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D4310()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to set IOPMUBootLPMFWOK flag", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D433C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a2, a3, "Failed to get %s flag", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006D43B8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a1, a3, "LPM stack shutdown timeout after %ds.", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006D4424(_BYTE *a1, _BYTE *a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_100262274(a1, a2);
  sub_100072750((void *)&_mh_execute_header, v2, (uint64_t)v2, "No command response is returned.", v3);
}

void sub_1006D4450(_BYTE *a1, _BYTE *a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_100262274(a1, a2);
  sub_100072750((void *)&_mh_execute_header, v2, (uint64_t)v2, "Output from LPM_output_buffer should be less than LPM_STR_BUF_MAX_LEN", v3);
}

void sub_1006D447C(_BYTE *a1, _BYTE *a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_100262274(a1, a2);
  sub_100072750((void *)&_mh_execute_header, v2, (uint64_t)v2, "Unable to scan bytes", v3);
}

void sub_1006D44A8(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "Command complete with HCI status: %u", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006D4510(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006D4580(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006D45F0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006D4660(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006D46D0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006D4740(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006D47B0(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "SET_HOSTLESS_MODE command complete with HCI status: %u", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006D4818(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006D4888(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006D48F8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006D4968(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006D49D8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006D4A48(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006D4AB8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Invalid offline adv data", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D4AE4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Exceed max number of peripherals.", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D4B10()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "No address is found for %@", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006D4B70()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "No irk or ltk is found for %@", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006D4BD0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "Device %@ is not paired", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006D4C30()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "Device %@ exists.", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006D4C90()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "Device %@ doesn't exist.", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006D4CF0()
{
  os_log_t v0;
  uint8_t v1[8];
  __int16 v2;
  int v3;

  sub_100097230();
  v2 = 1024;
  v3 = 2;
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "setOfflineAdvertisingDataAndPayload set %d invalid, we only have %d sets", v1, 0xEu);
  sub_1000726A0();
}

void sub_1006D4D6C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "Could not find service: %s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006D4DDC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Invalid iterator", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D4E08()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Error retrieving services : %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D4E68()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Invalid size input report", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D4E94(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "No HID devices are ready, discarding input report (ID %u)", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006D4EFC(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "Unknown input report ID %u. I don't know to which keyhole it belongs to, so discarding", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006D4F60(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "The HID device that handles report ID %u isn't ready, discarding input report", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006D4FC4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to create Management HID device", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D4FF0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to create Keyboard HID device", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D501C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to create Mesa HID device", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D5048()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to create Accelerometer HID device", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D5074(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "above error for csCreateConfigID", a5, a6, a7, a8, 0);
}

void sub_1006D50A8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "Error for getting the status", a5, a6, a7, a8, 0);
}

void sub_1006D50DC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BTLQ Cannot add Link Quality Data, invalid device", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D5108()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  uint8_t *v4;
  uint64_t v5;
  char v6;
  char v7;
  uint64_t v8;

  sub_10007276C();
  if (v6 != v7)
    v8 = v5;
  else
    v8 = v1;
  *(_DWORD *)v2 = 136315138;
  *(_QWORD *)(v2 + 4) = v8;
  sub_100265C78((void *)&_mh_execute_header, v2, v3, "BTLQ Cannot remove Link Quality Data, device (%s) not existing", v4);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006D5154()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BTLQ Cannot set Link Quality Data, invalid device", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D5180()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BTLQ Cannot set Link Quality Data, invalid data type", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D51AC()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  uint8_t *v4;
  uint64_t v5;
  char v6;
  char v7;
  uint64_t v8;

  sub_10007276C();
  if (v6 != v7)
    v8 = v5;
  else
    v8 = v1;
  *(_DWORD *)v2 = 136315138;
  *(_QWORD *)(v2 + 4) = v8;
  sub_100265C78((void *)&_mh_execute_header, v2, v3, "BTLQ Cannot set Link Quality Data, device (%s) not existing", v4);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006D51F8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BTLQ Cannot get Link Quality Data, invalid data", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D5224()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  uint8_t *v4;
  uint64_t v5;
  char v6;
  char v7;
  uint64_t v8;

  sub_10007276C();
  if (v6 != v7)
    v8 = v5;
  else
    v8 = v1;
  *(_DWORD *)v2 = 136315138;
  *(_QWORD *)(v2 + 4) = v8;
  sub_100265C78((void *)&_mh_execute_header, v2, v3, "BTLQ Cannot update Link Quality Data, device (%s) not existing", v4);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006D5270(uint64_t a1, NSObject *a2)
{
  const char *v2;
  int v3;
  const char *v4;

  v2 = "stats";
  if (!a1)
    v2 = "device";
  v3 = 136315138;
  v4 = v2;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "BTLQ Cannot update Link Quality Data, invalid %s", (uint8_t *)&v3, 0xCu);
}

void sub_1006D52FC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "[BTVCBonjourService] Unable to start BTVCBonjourServiceAdvertiser", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D5328()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "[BTVCBonjourService] advertiser failed", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D5354()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "[BTVCBonjourService] Unable to start the browser", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D5380(char a1, NSObject *a2)
{
  _DWORD v2[2];

  v2[0] = 67109120;
  v2[1] = a1 & 1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "[BTVCBonjourService] Got nil connection (isAdvToBrowserConnection : %d)", (uint8_t *)v2, 8u);
  sub_10007266C();
}

void sub_1006D53F4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "[BTVCBonjourService] Failed to create endpoint for connection %@", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006D5454()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "[BTVCBonjourService] Did not get remoteUniqueIDString from endpoint %@", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006D54B4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_10026A568(a1, a2, a3, 5.778e-34);
  sub_10026A55C((void *)&_mh_execute_header, v5, v3, "[BTVCBonjourService] Established [%@] connection for endpoint %@", v4);
}

void sub_1006D5500(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_10026A568(a1, a2, a3, 5.778e-34);
  sub_10026A55C((void *)&_mh_execute_header, v5, v3, "[BTVCBonjourService] [%@] connection closed for endpoint %@", v4);
}

void sub_1006D554C()
{
  NSObject *v0;
  uint8_t v1[24];

  sub_10026A5B8();
  sub_10026A55C((void *)&_mh_execute_header, v0, (uint64_t)v0, "[BTVCBonjourService] Unable to deserialize data: %@, for endpoint %@", v1);
  sub_1000726A0();
}

void sub_1006D55B4()
{
  NSObject *v0;
  uint8_t v1[24];

  sub_10026A5B8();
  sub_10026A55C((void *)&_mh_execute_header, v0, (uint64_t)v0, "[BTVCBonjourService] Received browser endpoint message %@ from endpoint %@ without uuid", v1);
  sub_1000726A0();
}

void sub_1006D561C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "[BTVCBonjourService] Unable to send message, failed to serialize payload %@", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006D567C()
{
  uint64_t v0;
  os_log_t v1;

  sub_10026A588();
  sub_10026A5A4((void *)&_mh_execute_header, v0, v1, "[BTVCBonjourService] Unable to send message %@ with type %@ to deviceID %@ (Invalid params)");
}

void sub_1006D56EC()
{
  uint64_t v0;
  os_log_t v1;

  sub_10026A588();
  sub_10026A5A4((void *)&_mh_execute_header, v0, v1, "[BTVCBonjourService] Failed to send data %@ to device %@, error %@");
}

void sub_1006D5758()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "[BTVCBonjourService] Empty uniqueID!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D5784()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "[BTVCBonjourService] Unable to find endpoint for deviceID %@", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006D57E4(uint64_t a1)
{
  void **v2;

  sub_1005D4204(a1 + 192);
  v2 = (void **)(a1 + 152);
  sub_10026BD18(&v2);

  if (*(char *)(a1 + 127) < 0)
    operator delete(*(void **)(a1 + 104));
}

void sub_1006D5838(os_log_t log)
{
  uint8_t v1[16];

  *(_WORD *)v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "SCO disconnect stack event never fired, cleaning up route change state", v1, 2u);
}

void sub_1006D5878(uint64_t a1, uint64_t a2, NSObject *a3)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  uint64_t v7;

  v3 = *(_QWORD *)(a1 + 8);
  v4 = 136446466;
  v5 = v3;
  v6 = 2082;
  v7 = a2;
  sub_10026A55C((void *)&_mh_execute_header, a3, (uint64_t)a3, "XPCServiceConnection (%{public}s) event: %{public}s", (uint8_t *)&v4);
  sub_1000726A0();
}

void sub_1006D58F4(uint64_t a1, xpc_object_t xdict, NSObject *a3)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  __int16 v8;
  const char *string;

  v4 = *(_QWORD *)(a1 + 8);
  v6 = 136446466;
  v7 = v4;
  v8 = 2082;
  string = xpc_dictionary_get_string(xdict, _xpc_error_key_description);
  sub_10026A55C((void *)&_mh_execute_header, a3, v5, "XPCServiceConnection (%{public}s) error: %{public}s", (uint8_t *)&v6);
}

void sub_1006D5998(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a2, a3, "XPCServiceConnection (%{public}s) interrupted", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006D5A00(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a2, a3, "XPCServiceConnection (%{public}s) invalidated", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006D5A68(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006D5AD8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006D5B48(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "Please override showConnectOSD() in subclasses", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006D5B78(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "The HID device hasn't fully opened yet, discarding input report", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006D5BA8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "Failed to create HID device", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006D5BD8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Classic Unknown CB MsgID %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D5C38(int a1, NSObject *a2)
{
  _DWORD v2[2];
  __int16 v3;
  int v4;

  v2[0] = 67109376;
  v2[1] = a1;
  v3 = 1024;
  v4 = 20161219;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "CoreBluetooth version %d differs from bluetoothd version %d", (uint8_t *)v2, 0xEu);
  sub_1000726A0();
}

void sub_1006D5CBC(char *a1, _QWORD *a2, NSObject *a3)
{
  int v3;
  _QWORD *v4;

  if (*a1 < 0)
    a2 = (_QWORD *)*a2;
  v3 = 136446210;
  v4 = a2;
  sub_100072744((void *)&_mh_execute_header, a3, (uint64_t)a3, "Duplicate XPC check-in from session \"%{public}s\"", (uint8_t *)&v3);
  sub_1000726A0();
}

void sub_1006D5D34()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Bluetooth discovery Handle Inquiry Msg: args is nil", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D5D60(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "Not yet implemented: %s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006D5DD0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "Not yet implemented: %s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006D5E40(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "Not yet implemented: %s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006D5EB0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "Not yet implemented: %s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006D5F20(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "Not yet implemented: %s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006D5F90()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "handlePairingAgentRespondToPairing: Cannot accept out-of-band pairing request for classic connections", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D5FBC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "handlePairingAgentRespondToPairing: Cannot identify classic device corresponding to device\"%@\"", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006D601C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "handlePairingAgentRespondToPairing: Cannot accept passkey pairing request without passkey", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D6048()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "handleSetPeerState, invalid peer", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D6074()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "handleGetPeerState - can't get AccessoryManager", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D60A0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to add service to local sdp", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D60CC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "L2CAP psm allocation failed: 0x%x", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D612C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Service already exist", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D6158(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "%s: Not available on this OS", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006D61C8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Bluetooth discoveryStatus: unknown status type %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D6228()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Bluetooth discoveryEvent: unknown event type %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D6288()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "startInquiry: Failed to create a discovery agent.", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D62B4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "Unparseable name bytes \"%@\"", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006D6314(void *a1, uint64_t a2, NSObject *a3)
{
  *(_DWORD *)a2 = 138412290;
  *(_QWORD *)(a2 + 4) = a1;
  sub_100072744((void *)&_mh_execute_header, a3, (uint64_t)a3, "Unparseable name change for the device \"%@\"", (uint8_t *)a2);

}

void sub_1006D6360()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "deviceNameUpdated: failed to get device uuid for %{public}@", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006D63C0()
{
  os_log_t v0;
  uint8_t v1[24];

  sub_1000EEFE4();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Sending a name-change XPC message for the device \"%{public}@\"", v1, 0xCu);
  sub_1000726A0();
}

void sub_1006D642C(char *a1, uint64_t a2, NSObject *a3)
{
  char *v4;

  if (a1[23] >= 0)
    v4 = a1;
  else
    v4 = *(char **)a1;
  *(_DWORD *)a2 = 136446210;
  *(_QWORD *)(a2 + 4) = v4;
  sub_100072744((void *)&_mh_execute_header, a3, (uint64_t)a3, "deviceInfoChanged: failed to get device uuid for %{public}s", (uint8_t *)a2);
  if (a1[23] < 0)
    operator delete(*(void **)a1);
}

void sub_1006D6494()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to register psm with result 0x%x", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D64F4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "addServiceDataToLocalSDP: service record data is nil", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D6520()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "addServiceDataToLocalSDP: service record data is empty", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D654C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "addServiceDataToLocalSDP: can't allocate SDP attributes", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D6578(uint8_t *a1, _BYTE *a2, NSObject *a3)
{
  *a1 = 0;
  *a2 = 0;
  sub_100072750((void *)&_mh_execute_header, a3, (uint64_t)a3, "addServiceDataToLocalSDP: null uuids", a1);
}

void sub_1006D65AC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "addServiceDataToLocalSDP: Error could not add service record %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D660C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Service must include a UUID", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D6638()
{
  int v0;
  os_log_t v1;
  uint8_t v2[12];
  __int16 v3;
  int v4;

  sub_1000EEFE4();
  v3 = 1024;
  v4 = v0;
  _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "There is already a service handling %@ with handle %X", v2, 0x12u);
  sub_1000726A0();
}

void sub_1006D66B4(uint8_t *a1, _BYTE *a2, NSObject *a3)
{
  *a1 = 0;
  *a2 = 0;
  sub_100072750((void *)&_mh_execute_header, a3, (uint64_t)a3, "addServiceDataToLocalSDP: Currently not validating 16Byte UUIDs", a1);
}

void sub_1006D66E8(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "addServiceDataToLocalSDP: Failed to parse attributeID: 0x%X", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006D6750(uint64_t a1, NSObject *a2)
{
  void **v3;
  void *__p[2];
  char v5;
  uint8_t buf[4];
  void **v7;

  sub_10043F6EC(a1, (uint64_t)__p);
  if (v5 >= 0)
    v3 = __p;
  else
    v3 = (void **)__p[0];
  *(_DWORD *)buf = 136315138;
  v7 = v3;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "addStaleAACPConnReqDev : device \"%s\" is already in the stale AACP connection device list", buf, 0xCu);
  if (v5 < 0)
    operator delete(__p[0]);
}

void sub_1006D680C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8751e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "No AACP connection for device %{public}s", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006D6858()
{
  uint64_t v0;
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;
  int v6;
  _QWORD *v7;

  sub_1002A8288();
  if (v6 >= 0)
    v7 = v1;
  else
    v7 = (_QWORD *)*v1;
  *(_DWORD *)v2 = 136446466;
  *(_QWORD *)(v2 + 4) = v7;
  *(_WORD *)(v2 + 12) = 1024;
  *(_DWORD *)(v2 + 14) = v3;
  sub_1002A827C((void *)&_mh_execute_header, v5, v3, "connecting to %{public}s failed, result %d", v4);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006D68BC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "getBatteryInfo was not sent successfully. Result Error Code %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D691C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "setRemoteDeviceName was not sent successfully. Result Error Code %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D697C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "sendControlCommand: No stack", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D69A8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "sendControlCommand: Unknown request type", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D69D4(char *a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  char *v6;
  NSObject *v7;
  uint8_t *v8;

  if (a1[23] >= 0)
    v6 = a1;
  else
    v6 = *(char **)a1;
  sub_1002A8194(a2, (uint64_t)v6, 4.8751e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "No AACP connection for device %{public}s", v8);
  if (a1[23] < 0)
    operator delete(*(void **)a1);
  *a4 = qword_1009997D0;
  sub_1000DE5DC();
}

void sub_1006D6A48(uint64_t a1, uint64_t a2, NSObject *a3)
{
  int v3;

  LOWORD(v3) = 1024;
  HIWORD(v3) = *(unsigned __int8 *)(a2 + 9);
  sub_1002A8220((void *)&_mh_execute_header, a2, a3, "Set ListeningMode : for in-ear support audio headsets, ANC mode cannot be enabled if both sides are not in-ear: primary bud = %d , secondary bud = %d", 67109376, v3);
  sub_1000726A0();
}

void sub_1006D6AC0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "sendControlCommand: Deprecated magnet settings sync for double click interval", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D6AEC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "sendControlCommand: Deprecated magnet settings sync for click hold interval", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D6B18()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "sendControlCommand: Deprecated iCloud/magnet settings sync for One Bud ANC mode", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D6B44()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Set HRM enable / disable not supported", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D6B70()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Received invalid device address", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D6B9C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8751e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "updateKeys: no AACP connection for device %{public}s", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006D6BE8()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8751e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "requestKeys: no AACP connection for device %{public}s", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006D6C34()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8751e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "sendSetupCommand: no AACP connection for device %{public}s", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006D6C80()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[10];
  int v3;

  sub_1001084D0();
  v3 = 998;
  sub_1002A8234((void *)&_mh_execute_header, v0, v1, "Relay message length -> %d exceeds MTU -> %d", v2);
  sub_1000726A0();
}

void sub_1006D6CEC()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8751e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "No valid AACP Connection for the target device %{public}s", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006D6D38()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Relay message request was not sent successfully. Result Error Code %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D6D98()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[10];
  int v3;

  sub_1001084D0();
  v3 = 2;
  sub_1002A8234((void *)&_mh_execute_header, v0, v1, "Number of connections in list -> %d exceeds maximum supported -> %d", v2);
  sub_1000726A0();
}

void sub_1006D6E04()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Update request for connection priority list was not sent successfully. Result Error Code %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D6E64()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "unknown connectin priority list request type : reqType %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D6EC4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Reject TiPi connectin priority list request as a result of pending one", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D6EF0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "GAPA alert not available", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D6F1C()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "GAPA user responded with unknown response %ld", v2);
  sub_1000726A0();
}

void sub_1006D6F80()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "GAPA URL string is malformed", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D6FAC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "setDeviceStateOnPeerSrc: No AACP connection", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D6FD8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "getTipiTable: No AACP connection", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D7004()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "getTipiTable: Failed to send, result %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D7064()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed sending call management configuration to buds ", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D7090()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8751e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "Device %{public}s has empty UUID", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006D70DC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "No device found, cannot check if AACP Config Jitter Buffer is supported", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D7108()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "internalSetupAACP: No AACP connection", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D7134()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed registration for MKB first unlock notification with error : %u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D7194()
{
  os_log_t v0;
  uint8_t v1[16];

  sub_10009720C();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Received MKB first unlock notification, but MKBDeviceUnlockedSinceBoot returns 0", v1, 2u);
  sub_10007266C();
}

void sub_1006D71CC(uint64_t a1, NSObject *a2, uint64_t a3)
{
  *(_DWORD *)a1 = 136446210;
  *(_QWORD *)(a1 + 4) = "null";
  sub_100072744((void *)&_mh_execute_header, a2, a3, "getInEarStatus: No AACP connection for %{public}s", (uint8_t *)a1);
}

void sub_1006D720C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8751e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "getInEarStatus: No AACP connection for %{public}s", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006D7258()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "getPrimaryBudSide: No device", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D7284()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8751e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "getPrimaryBudSide: No AACP connection for %{public}s", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006D72D0(void *a1, char *a2, uint64_t a3, NSObject *a4)
{
  char *v6;

  if (a2[23] >= 0)
    v6 = a2;
  else
    v6 = *(char **)a2;
  *(_DWORD *)a3 = 138543618;
  *(_QWORD *)(a3 + 4) = a1;
  *(_WORD *)(a3 + 12) = 2080;
  *(_QWORD *)(a3 + 14) = v6;
  sub_10026A55C((void *)&_mh_execute_header, a4, a3, "Magnet link disconnect from \"%{public}@\" does not match connected magnet \"%s\"", (uint8_t *)a3);
  if (a2[23] < 0)
    operator delete(*(void **)a2);

  sub_1000DE5DC();
}

void sub_1006D7350()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "easyUnpair: No stack", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D737C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "sendSmartRoutingInformation: Stack not ready", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D73A8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "sendSmartRoutingInformation: Failed to send SR info message with status = %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D7408()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "sendConversationDetectMessage: Stack not ready", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D7434()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "sendConversationDetectMessage: Failed to send CD Message with status = %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D7494()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "sendFeatureProxCardStatusUpdate: Stack not ready", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D74C0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "sendFeatureProxCardStatusUpdate: Failed to send feature prox card status update with status = %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D7520()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "sendSourceContextMessage: Stack not ready", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D754C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "sendSourceContextMessage: Failed to send source context message with status = %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D75AC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "sendAdaptiveVolumeMessage: Stack not ready", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D75D8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "sendAdaptiveVolumeMessage: Failed to send adaptive volume message with status = %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D7638()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "sendPMEConfigMessage: Stack not ready", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D7664()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "sendPMEConfigMessage: Failed to send PME config message with status = %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D76C4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "sendUARPData: Stack not ready", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D76F0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "sendUARPData: Failed to send uarp message to buds with status = %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D7750(uint64_t a1, NSObject *a2)
{
  id v3;
  void *v4;
  uint64_t v5;
  uint8_t v6[24];

  v3 = sub_100649588(a1);
  v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, a2, v5, "No device found for a disconnect event from \"%@\"", v6);

}

void sub_1006D77DC()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8149e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "No active connection for a disconnect event from  device \"%s\"", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006D7828()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "sendEvent: No AACP connection", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D7854(uint8_t *a1, _BYTE *a2, NSObject *a3)
{
  *a1 = 0;
  *a2 = 0;
  sub_100072750((void *)&_mh_execute_header, a3, (uint64_t)a3, "sendEASessionPacket: No existing open BTEASession", a1);
}

void sub_1006D7888()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "publishAccRemoteFirmware: No AACP connection", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D78B4(uint64_t a1, NSObject *a2)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  void *v13;
  char v14;
  uint8_t v15[24];

  sub_1002A81D4(a1, (uint64_t)a2);
  sub_1002A8180();
  sub_1002A81E0();
  sub_100072744((void *)&_mh_execute_header, a2, v3, "publishAccRemoteFirmware: Failed to create address string for \"%{public}s\"", v15);
  if (v14 < 0)
    sub_1002A81CC(v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);
  sub_1002A81A0();
}

void sub_1006D793C(uint64_t a1, NSObject *a2)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  void *v13;
  char v14;
  uint8_t v15[24];

  sub_1002A81D4(a1, (uint64_t)a2);
  sub_1002A8180();
  sub_1002A81E0();
  sub_100072744((void *)&_mh_execute_header, a2, v3, "publishAccRemoteFirmware: Failed to create CoreAccessories connection for device %{public}s", v15);
  if (v14 < 0)
    sub_1002A81CC(v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);
  sub_1002A81A0();
}

void sub_1006D79C4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "publishAccRemoteFirmware: No FWUP session", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D79F0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "publishAccRemoteFirmware: No FWUP endpoint", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D7A1C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8751e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "publishAccRemoteFirmware: Failed to create CoreAccessories certificate endpoint for %{public}s", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006D7A68()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8751e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "publishAccRemoteFirmware: No serial numbers for %{public}s", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006D7AB4(uint64_t a1, NSObject *a2)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  void *v13;
  char v14;
  uint8_t v15[24];

  sub_1002A81D4(a1, (uint64_t)a2);
  sub_1002A8180();
  sub_1002A81E0();
  sub_100072744((void *)&_mh_execute_header, a2, v3, "publishAccRemoteFirmware: Failed to create CoreAccessories auth endpoint for device %{public}s", v15);
  if (v14 < 0)
    sub_1002A81CC(v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);
  sub_1002A81A0();
}

void sub_1006D7B3C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "publishAccRemoteFirmware: Could not find serial number", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D7B68(NSObject *a1)
{
  uint64_t v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  void *v12;
  char v13;
  uint8_t v14[24];

  sub_1002A8204((uint64_t)a1);
  sub_1002A8180();
  sub_1002A81E0();
  sub_100072744((void *)&_mh_execute_header, a1, v2, "batteryDataInfoEvent: No device for %{public}s", v14);
  if (v13 < 0)
    sub_1002A81CC(v3, v4, v5, v6, v7, v8, v9, v10, v11, v12);
  sub_1002A81A0();
}

void sub_1006D7BF0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "batteryDataInfoEvent: No AACP connection", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D7C1C(NSObject *a1)
{
  uint64_t v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  void *v12;
  char v13;
  uint8_t v14[24];

  sub_1002A8204((uint64_t)a1);
  sub_1002A8180();
  sub_1002A81E0();
  sub_100072744((void *)&_mh_execute_header, a1, v2, "inEarStateInfoEvent: No device for %{public}s", v14);
  if (v13 < 0)
    sub_1002A81CC(v3, v4, v5, v6, v7, v8, v9, v10, v11, v12);
  sub_1002A81A0();
}

void sub_1006D7CA4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "inEarStateInfoEvent: No AACP connection", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D7CD0(NSObject *a1)
{
  uint64_t v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  void *v12;
  char v13;
  uint8_t v14[24];

  sub_1002A8204((uint64_t)a1);
  sub_1002A8180();
  sub_1002A81E0();
  sub_100072744((void *)&_mh_execute_header, a1, v2, "roleStateInfoEvent: No device for %{public}s", v14);
  if (v13 < 0)
    sub_1002A81CC(v3, v4, v5, v6, v7, v8, v9, v10, v11, v12);
  sub_1002A81A0();
}

void sub_1006D7D58()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "roleStateInfoEvent: No AACP connection", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D7D84()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8751e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "No valid AACP Connection for the addr %{public}s", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006D7DD0()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8149e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "No connection exists to notify remote stream state for %s", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006D7E1C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8149e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "No connection exists to set remote stream state for %s", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006D7E68()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Received ack for connection prioirty list request, but no request in the queue", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D7E94()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Received ack for TiPi connection prioirty list request, but no request in the queue", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D7EC0(uint64_t *a1, unsigned __int16 *a2, uint8_t *buf, os_log_t log)
{
  uint64_t *v5;
  int v6;

  if (*((char *)a1 + 23) >= 0)
    v5 = a1;
  else
    v5 = (uint64_t *)*a1;
  v6 = *a2;
  *(_DWORD *)buf = 136446466;
  *(_QWORD *)(buf + 4) = v5;
  *((_WORD *)buf + 6) = 1024;
  *(_DWORD *)(buf + 14) = v6;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "Received AACP_CUSTOM_MESSAGE_TYPE_SENSOR_V2 message from %{public}s: len %u", buf, 0x12u);
  if (*((char *)a1 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006D7F3C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "publishW1RemoteFirmware: No AACP connection", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D7F68(uint64_t a1, NSObject *a2)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  void *v13;
  char v14;
  uint8_t v15[24];

  sub_1002A8214(a1, (uint64_t)a2);
  sub_1002A8180();
  sub_1002A81AC();
  sub_10026A55C((void *)&_mh_execute_header, a2, v3, "publishW1RemoteFirmware: Failed to create address string for \"%{private, mask.hash}s\"", v15);
  if (v14 < 0)
    sub_1002A81CC(v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);
  sub_1002A81A0();
}

void sub_1006D7FF0(uint64_t a1, NSObject *a2)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  void *v13;
  char v14;
  uint8_t v15[24];

  sub_1002A8214(a1, (uint64_t)a2);
  sub_1002A8180();
  sub_1002A81AC();
  sub_10026A55C((void *)&_mh_execute_header, a2, v3, "publishW1RemoteFirmware: Failed to create firmware version string for \"%{private, mask.hash}s\"", v15);
  if (v14 < 0)
    sub_1002A81CC(v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);
  sub_1002A81A0();
}

void sub_1006D8078(uint64_t a1, NSObject *a2)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  void *v13;
  char v14;
  uint8_t v15[24];

  sub_1002A8214(a1, (uint64_t)a2);
  sub_1002A8180();
  sub_1002A81AC();
  sub_10026A55C((void *)&_mh_execute_header, a2, v3, "publishW1RemoteFirmware: Failed to create hardware version string for \"%{private, mask.hash}s\"", v15);
  if (v14 < 0)
    sub_1002A81CC(v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);
  sub_1002A81A0();
}

void sub_1006D8100(uint64_t a1, NSObject *a2)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  void *v13;
  char v14;
  uint8_t v15[24];

  sub_1002A8214(a1, (uint64_t)a2);
  sub_1002A8180();
  sub_1002A81AC();
  sub_10026A55C((void *)&_mh_execute_header, a2, v3, "publishW1RemoteFirmware: Failed to create CoreAcc connection for \"%{private, mask.hash}s\"", v15);
  if (v14 < 0)
    sub_1002A81CC(v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);
  sub_1002A81A0();
}

void sub_1006D8188(uint64_t a1, NSObject *a2)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  void *v13;
  char v14;
  uint8_t v15[24];

  sub_1002A8214(a1, (uint64_t)a2);
  sub_1002A8180();
  sub_1002A81AC();
  sub_10026A55C((void *)&_mh_execute_header, a2, v3, "publishW1RemoteFirmware: Failed to create CoreAcc endpoint for \"%{private, mask.hash}s\"", v15);
  if (v14 < 0)
    sub_1002A81CC(v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);
  sub_1002A81A0();
}

void sub_1006D8210(NSObject *a1)
{
  uint64_t v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  void *v12;
  char v13;
  uint8_t v14[24];

  sub_1002A8204((uint64_t)a1);
  sub_1002A8180();
  sub_1002A81E0();
  sub_100072744((void *)&_mh_execute_header, a1, v2, "controlCommandEvent: No device for %{public}s", v14);
  if (v13 < 0)
    sub_1002A81CC(v3, v4, v5, v6, v7, v8, v9, v10, v11, v12);
  sub_1002A81A0();
}

void sub_1006D8298()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "controlCommandEvent: No AACP connection", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D82C4()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8751e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "versionInfoEvent: No AACP connection for %{public}s", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006D8310()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "versionInfoEvent: Unexpected message version %u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D8370()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "versionInfoEvent: Message too short (len %d)", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D83D0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "versionInfoEvent: Disallowed session index %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D8430()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "versionInfoEvent: No CoreAcc connection", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D845C(uint64_t *a1, NSObject *a2, uint64_t a3)
{
  uint64_t v3;
  int v4;
  uint64_t v5;

  v3 = *a1;
  v4 = 138412290;
  v5 = v3;
  sub_100072744((void *)&_mh_execute_header, a2, a3, "versionInfoEvent: Error destroying connection %@", (uint8_t *)&v4);
  sub_1000726A0();
}

void sub_1006D84C8(uint64_t a1, int *a2, uint64_t a3, NSObject *a4)
{
  int v4;

  v4 = *a2;
  *(_DWORD *)a3 = 138412546;
  *(_QWORD *)(a3 + 4) = a1;
  *(_WORD *)(a3 + 12) = 1024;
  *(_DWORD *)(a3 + 14) = v4;
  sub_1002A827C((void *)&_mh_execute_header, a4, a3, "versionInfoEvent: Could not open %@ (errno %d))", (uint8_t *)a3);
}

void sub_1006D8518()
{
  uint64_t v0;
  os_log_t v1;
  int v2;
  int v3;

  sub_1002A82B8();
  sub_1002A8220((void *)&_mh_execute_header, v0, v1, "versionInfoEvent: string in version info is too long, count %d, stringIndex %d", v2, v3);
  sub_1000726A0();
}

void sub_1006D8578()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "versionInfoEvent: Could not retrieve key", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D85A4(uint64_t a1, NSObject *a2)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  void *v13;
  char v14;
  uint8_t v15[24];

  sub_1002A81D4(a1, (uint64_t)a2);
  sub_1002A8180();
  sub_1002A81E0();
  sub_100072744((void *)&_mh_execute_header, a2, v3, "eaSessionDataEvent: No AACP connection for %{public}s", v15);
  if (v14 < 0)
    sub_1002A81CC(v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);
  sub_1002A81A0();
}

void sub_1006D8628(uint64_t a1, NSObject *a2)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  void *v13;
  char v14;
  uint8_t v15[24];

  sub_1002A81D4(a1, (uint64_t)a2);
  sub_1002A8180();
  sub_1002A81E0();
  sub_100072744((void *)&_mh_execute_header, a2, v3, "eaSessionDataEvent: Received data from device %{public}s without open EA session; dropping data",
    v15);
  if (v14 < 0)
    sub_1002A81CC(v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);
  sub_1002A81A0();
}

void sub_1006D86AC(uint64_t a1, NSObject *a2)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  void *v13;
  char v14;
  uint8_t v15[24];

  sub_1002A81D4(a1, (uint64_t)a2);
  sub_1002A8180();
  sub_1002A81E0();
  sub_100072744((void *)&_mh_execute_header, a2, v3, "eaSessionDataEvent: Failed to process data from device %{public}s", v15);
  if (v14 < 0)
    sub_1002A81CC(v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);
  sub_1002A81A0();
}

void sub_1006D8730(uint64_t a1, NSObject *a2)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  void *v13;
  char v14;
  uint8_t v15[24];

  sub_1002A81D4(a1, (uint64_t)a2);
  sub_1002A8180();
  sub_1002A81E0();
  sub_100072744((void *)&_mh_execute_header, a2, v3, "authenticationDataEvent: No AACP connection for device %{public}s", v15);
  if (v14 < 0)
    sub_1002A81CC(v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);
  sub_1002A81A0();
}

void sub_1006D87B4(uint64_t a1, NSObject *a2)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  void *v13;
  char v14;
  uint8_t v15[24];

  sub_1002A81D4(a1, (uint64_t)a2);
  sub_1002A8180();
  sub_1002A81E0();
  sub_100072744((void *)&_mh_execute_header, a2, v3, "authenticationDataEvent: No auth endpoint for device %{public}s", v15);
  if (v14 < 0)
    sub_1002A81CC(v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);
  sub_1002A81A0();
}

void sub_1006D8838(uint64_t a1, NSObject *a2)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  void *v13;
  char v14;
  uint8_t v15[24];

  sub_1002A81D4(a1, (uint64_t)a2);
  sub_1002A8180();
  sub_1002A81E0();
  sub_100072744((void *)&_mh_execute_header, a2, v3, "authenticationDataEvent: Failed to process data from device %{public}s", v15);
  if (v14 < 0)
    sub_1002A81CC(v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);
  sub_1002A81A0();
}

void sub_1006D88BC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "updateCertificates: did not expect to receive data for a new certificate", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D88E8()
{
  uint64_t v0;
  os_log_t v1;
  int v2;
  int v3;

  sub_1002A82B8();
  sub_1002A8220((void *)&_mh_execute_header, v0, v1, "updateCertificates: unexpected sequence number. expected %d, actual %d", v2, v3);
  sub_1000726A0();
}

void sub_1006D8948()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "AACPClient::getGyroInformationMessageEvent - Unexpected size of received data (%lu)", v2);
  sub_1000726A0();
}

void sub_1006D89AC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "AACPClient::getGyroInformationMessageEvent - Unexpected gyroInfoVersion (%u)", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D8A0C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "AACPClient::getBTEventHistoryListMessageEvent: Unsupported version %u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D8A6C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "AACPClient::getBTEventHistoryListMessageEvent: BTEventHistoryList did not have expected number of entries", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D8A98()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "contextMessageRecvEvent: No AACP connection", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D8AC4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "tipiTableEvent: No AACP connection", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D8AF0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "sensorStreamingConfigMessageRecvEvent: No AACP connection", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D8B1C()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1002A829C();
  sub_1002A827C((void *)&_mh_execute_header, v0, v1, "gapaResponseEvent: No AACP connection for %.6P", v2);
  sub_1000726A0();
}

void sub_1006D8B80()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1002A829C();
  sub_1002A827C((void *)&_mh_execute_header, v0, v1, "gapaResponseEvent: No device for %.6P", v2);
  sub_1000726A0();
}

void sub_1006D8BE4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "gapaResponseEvent: Failed to publish kCFACCProperties_Endpoint_AudioProduct_AuthResponse", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D8C10()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  uint8_t *v4;
  uint64_t v5;
  char v6;
  char v7;
  uint64_t v8;

  sub_10007276C();
  if (v6 != v7)
    v8 = v5;
  else
    v8 = v1;
  *(_DWORD *)v2 = 141558275;
  *(_QWORD *)(v2 + 4) = 1752392040;
  *(_WORD *)(v2 + 12) = 2081;
  *(_QWORD *)(v2 + 14) = v8;
  sub_10026A55C((void *)&_mh_execute_header, v3, (uint64_t)v3, "Unable to rename device %{private, mask.hash}s", v4);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006D8C74()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "getCurrentCalls failed", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D8CA0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "unPublishW1RemoteFirmware: No AACP connection", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D8CCC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "unPublishW1RemoteFirmware: Error destroying connection", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D8CF8()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "getConnAndDevice: No AACP connection for connection %@", v2);
  sub_1000726A0();
}

void sub_1006D8D5C()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "getConnAndDevice: No Device for connection %@", v2);
  sub_1000726A0();
}

void sub_1006D8DC0()
{
  NSObject *v0;
  uint8_t v1[24];

  sub_1002A8240();
  sub_10026A55C((void *)&_mh_execute_header, v0, (uint64_t)v0, "getConnAndDevice: UUIDs %@ and %@ do not match", v1);
  sub_1000726A0();
}

void sub_1006D8E30()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "publishAccRemoteFirmware auth data: No AACP connection for connection %@; dropping data",
    v2);
  sub_1000726A0();
}

void sub_1006D8E94()
{
  NSObject *v0;
  uint8_t v1[24];

  sub_1002A8240();
  sub_10026A55C((void *)&_mh_execute_header, v0, (uint64_t)v0, "publishAccRemoteFirmware auth data: UUIDs %@ and %@ do not match", v1);
  sub_1000726A0();
}

void sub_1006D8F00()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "publishAccRemoteFirmware EA data: No AACP connection for connection %@; dropping data",
    v2);
  sub_1000726A0();
}

void sub_1006D8F64()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "publishAccRemoteFirmware EA property: No AACP connection for connection %@", v2);
  sub_1000726A0();
}

void sub_1006D8FC8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Dismiss invalid GAPA challenge value is NULL", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D8FF4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "publishAccRemoteFirmware GAPA handler: no CFDictionaryRef", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D9020()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "publishAccRemoteFirmware GAPA handler: no AuthData", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D904C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_1002A82E0();
  sub_1002A81EC(v0, v1, v2, 3.8521e-34);
  sub_10026A55C((void *)&_mh_execute_header, v5, v3, "publishAccRemoteFirmware GAPA handler: Invalid type ID (%lu) expecting CFDataRef (%lu)", v4);
}

void sub_1006D9084()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_1002A82E0();
  sub_1002A81EC(v0, v1, v2, 3.8521e-34);
  sub_10026A55C((void *)&_mh_execute_header, v5, v3, "publishAccRemoteFirmware GAPA handler: Invalid type ID (%lu) expecting CFDictionaryRef (%lu)", v4);
}

void sub_1006D90BC()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "publishAccRemoteFirmware GAPA handler: Expecting 1 element got %ld", v2);
  sub_1000726A0();
}

void sub_1006D9120()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_1002A82E0();
  sub_1002A81EC(v0, v1, v2, 3.8521e-34);
  sub_10026A55C((void *)&_mh_execute_header, v5, v3, "publishAccRemoteFirmware GAPA handler: Invalid type ID (%lu) expecting CFArrayRef (%lu)", v4);
}

void sub_1006D9158()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Invalid GAPAAuthState=%d dismiss challenge", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D91B8()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_1002A82E0();
  sub_1002A81EC(v0, v1, v2, 3.8521e-34);
  sub_10026A55C((void *)&_mh_execute_header, v5, v3, "publishAccRemoteFirmware GAPA handler: Invalid type ID (%lu) expecting CFNumberRef (%lu)", v4);
}

void sub_1006D91F0()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "publishAccRemoteFirmware cert required handler: No AACP connection for connection %@", v2);
  sub_1000726A0();
}

void sub_1006D9254()
{
  NSObject *v0;
  uint8_t v1[24];

  sub_1002A8240();
  sub_10026A55C((void *)&_mh_execute_header, v0, (uint64_t)v0, "publishAccRemoteFirmware cert required handler: UUIDs %@ and %@ do not match", v1);
  sub_1000726A0();
}

void sub_1006D92C0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "unPublishAccRemoteFirmware: No AACP connection", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D92EC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "unPublishAccRemoteFirmware: Error destroying connection", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D9318()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "AACPConnection: failed to retrieve pid, setting to 0", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D9344(uint64_t a1, id *a2)
{
  void *v4;
  void *v5;

  sub_10001A82C(a1 + 704, *(_QWORD **)(a1 + 712));
  v4 = *(void **)(a1 + 680);
  if (v4)
  {
    *(_QWORD *)(a1 + 688) = v4;
    operator delete(v4);
  }
  sub_1002A4270((_QWORD *)(a1 + 632));

  sub_100069BDC(a1 + 536);
  v5 = *(void **)(a1 + 504);
  if (v5)
  {
    *(_QWORD *)(a1 + 512) = v5;
    operator delete(v5);
  }
  sub_100069BDC(a1 + 440);
  sub_10002074C((_QWORD *)(a1 + 416));

  if (*(char *)(a1 + 79) < 0)
    operator delete(*(void **)(a1 + 56));
  else
    sub_1000DE5DC();
}

void sub_1006D93D4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "dispatchCertificates: No CoreAcc connection", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D9400()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "dispatchCertificates: No cert endpoint", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D942C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "dispatchCertificates: No certificates", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D9458(uint64_t a1, uint64_t a2, NSObject *a3)
{
  *(_DWORD *)a1 = 134217984;
  *(_QWORD *)(a1 + 4) = a2;
  sub_100072744((void *)&_mh_execute_header, a3, (uint64_t)a3, "dispatchCertificates: Failed to publish %lu certificates", (uint8_t *)a1);
}

void sub_1006D9494(NSObject *a1, uint64_t a2, uint64_t a3)
{
  int v3;
  uint64_t v4;

  v3 = 134217984;
  v4 = 0x4000000000000000;
  sub_100072744((void *)&_mh_execute_header, a1, a3, "No response for TiPi connectin priority list request from Wx within %f seconds, reset pending flag", (uint8_t *)&v3);
  sub_1000726A0();
}

void sub_1006D9504()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Invalid handle(s)", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D9530()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Get battery info was not sent successfully. Result Error Code %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D9590()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Get in ear state info was not sent successfully. Result Error Code %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D95F0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Get role state info was not sent successfully. Result Error Code %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D9650()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Timestamp not sent successfully. Result Error Code %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D96B0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "session state was not sent successfully. Result Error Code %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D9710()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "keys were not sent successfully. Result Error Code %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D9770()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "keys were not requested successfully. Result Error Code %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D97D0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Disconnect was not sent successfully. Result Error Code %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D9830()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "setup command was not sent successfully. Result Error Code %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D9890()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "initAVRCPFastConnectL2CAP error creating AVRCP signal", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D98BC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "composeAACPDescriptor error getting signaling L2CAP data", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D98E8(uint8_t *a1, _BYTE *a2, NSObject *a3)
{
  *a1 = 0;
  *a2 = 0;
  sub_100072750((void *)&_mh_execute_header, a3, (uint64_t)a3, "parseAACPDescriptor L2CAP signal channel not found", a1);
}

void sub_1006D991C()
{
  uint64_t v0;
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_1002A8288();
  sub_1002A8258(v1, v2, v3, 3.8521e-34);
  sub_1002A82D0((void *)&_mh_execute_header, "parseAACPSetupComplete %lu new events added for %{private}s", v4, v5);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006D9960()
{
  uint64_t v0;
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_1002A8288();
  sub_1002A8258(v1, v2, v3, 3.8521e-34);
  sub_1002A82D0((void *)&_mh_execute_header, "fastConnectAACPCleanup: cleaning up AACP Event queue of size %lu for %{private}s", v4, v5);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006D99A4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072784((void *)&_mh_execute_header, v0, v1, "error = %d while initializing the mutex", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D9A04()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072784((void *)&_mh_execute_header, v0, v1, "error = %d while calling destructor of mutex", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D9A64()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072784((void *)&_mh_execute_header, v0, v1, "error = %d while trying to lock the mutex", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D9AC4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072784((void *)&_mh_execute_header, v0, v1, "error = %d while trying to unlock the mutex", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D9B24(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
}

void sub_1006D9B98(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
}

void sub_1006D9C0C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072784((void *)&_mh_execute_header, v0, v1, "error = %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D9C6C(NSObject *a1, uint64_t a2, uint64_t a3)
{
  int v3;
  const char *v4;

  v3 = 136446210;
  v4 = "transport != LE_TRANSPORT";
  sub_1002B54DC((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", (uint8_t *)&v3);
  sub_1000726A0();
}

void sub_1006D9CE0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to initialize transport switching!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D9D0C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "User forced upgrade forever !", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D9D38()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "User forced enable AWDL transport !", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D9D64()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to initialize companion link!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D9D90()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1002B54F8(__stack_chk_guard);
  sub_100072684((void *)&_mh_execute_header, v0, v1, "Failed to create session for application \"%{public}s\"", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006D9DF4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1002B54F8(__stack_chk_guard);
  sub_100072684((void *)&_mh_execute_header, v0, v1, "Ignoring registration from application \"%{public}s\" as local device does not support scalable pipes", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006D9E58()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_1002B54DC((void *)&_mh_execute_header, v0, v1, "Endpoint \"%{public}s\" has been unregistered with pipes remaining!", v2);
  sub_1000726A0();
}

void sub_1006D9EC8()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8751e-34);
  sub_1002B54DC((void *)&_mh_execute_header, v7, (uint64_t)v7, "Couldn't find a registered scalable pipe for session \"%{public}s\"", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006D9F14()
{
  uint64_t v0;
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_1002B5510();
  sub_100072794(v1, v2, v3, 4.8752e-34);
  sub_1002B54E8((void *)&_mh_execute_header, "Failed to register endpoint \"%{public}s\" as it is already registered by session \"%{public}s\"", v4, v5);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006D9F58()
{
  uint64_t v0;
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_1002B5510();
  sub_100072794(v1, v2, v3, 4.8752e-34);
  sub_1002B54E8((void *)&_mh_execute_header, "Failed to register endpoint \"%{public}s\" as it is already pending registration by session \"%{public}s\"", v4, v5);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006D9F9C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Set link-requirements attempting to configure an invalid handle", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006D9FC8(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "Failed to enable ePA/beamforming VSE logging for Magnet with error %d", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006DA02C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "Failed to disable beamforming VSE logging for Magnet with error %d", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006DA090(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "Failed to start scalable pipe negotiation with result %{bluetooth:OI_STATUS}u", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006DA0F4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "Connection manager wasn't tracking a connection handle for device \"%{public}@\". Did we already disconnect ?", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006DA154(NSObject *a1, uint64_t a2, uint64_t a3)
{
  int v3;
  const char *v4;

  v3 = 136446210;
  v4 = "fUpgradeAssertion == NULL";
  sub_1002B54DC((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", (uint8_t *)&v3);
  sub_1000726A0();
}

void sub_1006DA1C8(const unsigned __int8 *a1, NSObject *a2)
{
  id v3;
  void *v4;
  uint8_t v5[24];

  v3 = sub_100030DF4(a1);
  v4 = (void *)objc_claimAutoreleasedReturnValue(v3);
  sub_1000EEFE4();
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Trying to switch our key derivation method for device \"%{public}@\"", v5, 0xCu);

  sub_100072694();
}

void sub_1006DA254()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Classic encryption failed to an unknown device", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DA280(unsigned __int8 a1, NSObject *a2)
{
  _DWORD v3[2];
  __int16 v4;
  int v5;

  v3[0] = 67109376;
  v3[1] = a1;
  v4 = 1024;
  v5 = sub_1000F2560();
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Transport upgrade to classic failed due to security error. peerCLVersion=%d localVersion=%d", (uint8_t *)v3, 0xEu);
  sub_100072694();
}

void sub_1006DA318(_QWORD *a1, char a2, NSObject *a3)
{
  _QWORD *v3;
  int v4;
  _QWORD *v5;

  v3 = (_QWORD *)*a1;
  if ((a2 & 1) == 0)
    v3 = a1;
  v4 = 136446210;
  v5 = v3;
  sub_1002B54DC((void *)&_mh_execute_header, a3, (uint64_t)a3, "Attempting to complete pending registration of endpoint \"%{public}s\" for non-existent session", (uint8_t *)&v4);
  sub_1000726A0();
}

void sub_1006DA390()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_1002B54DC((void *)&_mh_execute_header, v0, v1, "Endpoint \"%{public}s\" has been unregistered but wasn't marked as a zombie!", v2);
  sub_1000726A0();
}

void sub_1006DA3F4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "LE disconnect failed, can not recover pipe/handle mismatch, aborting", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DA420()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to create a nexus provider", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DA44C(os_log_t log)
{
  int v1;
  const char *v2;

  v1 = 136446210;
  v2 = "Enable";
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "%{public}s cross layer logs", (uint8_t *)&v1, 0xCu);
  sub_1000726A0();
}

void sub_1006DA4C8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006DA538()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC0AC();
  __error();
  sub_1002BC06C();
  sub_1002BC058((void *)&_mh_execute_header, v0, v1, "Failed to create read dispatch source for pipe 0x%04x with result %d", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006DA5AC()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC0AC();
  __error();
  sub_1002BC06C();
  sub_1002BC058((void *)&_mh_execute_header, v0, v1, "Failed to create write dispatch source for pipe 0x%04x with result %d", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006DA620()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC0AC();
  __error();
  sub_1002BC06C();
  sub_1002BC058((void *)&_mh_execute_header, v0, v1, "Failed to create socket pair for pipe 0x%04x with result %d", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006DA694()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC094();
  sub_100072784((void *)&_mh_execute_header, v0, v1, "Pipe 0x%04x is already registered in registerSocketInternal", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DA6F8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC0A0();
  sub_1002BC094();
  sub_100072784((void *)&_mh_execute_header, v0, v1, "Wasn't tracking a pipe info for pipe 0x%04x", v2, v3, v4, v5, v6);
  sub_10007266C();
}

BOOL sub_1006DA758(NSObject *a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  return *a2 == 0;
}

void sub_1006DA7E4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006DA854()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC094();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Got send data event for non-existant pipe 0x%04x", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DA8B8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "NetworkRelayParserReadAvailable self is null", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DA8E4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC094();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Got output available data event for non-existant pipe 0x%04x", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DA948(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a2, a3, "NRBluetoothPacketParserCreate is null for pipeUUID %s  registered in registerNetworkRelayPipe", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006DA9B0(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a2, a3, "NRBluetoothPacketParserCreateReadContext is null for pipeUUID %s  registered in registerNetworkRelayPipe", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006DAA18(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a2, a3, "NRBluetoothPacketParserCreateWriteContext is null for pipeUUID %s  registered in registerNetworkRelayPipe", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006DAA80()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC094();
  sub_100072784((void *)&_mh_execute_header, v0, v1, "Pipe 0x%04x is already registered in registerNetworkRelayPipe", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DAAE4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC094();
  sub_100072784((void *)&_mh_execute_header, v0, v1, "Failed to unregister pipe 0x%04x, as it wasn't registered", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DAB48()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC0AC();
  __error();
  sub_1002BC06C();
  sub_1002BC058((void *)&_mh_execute_header, v0, v1, "Failed to create read dispatch source for pipe 0x%04x with result %d", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006DABBC()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC0AC();
  __error();
  sub_1002BC06C();
  sub_1002BC058((void *)&_mh_execute_header, v0, v1, "Failed to create write dispatch source for pipe 0x%04x with result %d", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006DAC30(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "Setting custom MTU size of  %u", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006DAC94(NSObject *a1)
{
  int *v2;
  char *v3;
  int v4;
  char *v5;

  v2 = __error();
  v3 = strerror(*v2);
  v4 = 136315138;
  v5 = v3;
  _os_log_fault_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_FAULT, "serverChannel is NULL, error is %s", (uint8_t *)&v4, 0xCu);
  sub_100072694();
}

void sub_1006DAD20()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC094();
  sub_100072784((void *)&_mh_execute_header, v0, v1, "Pipe 0x%04x is already registered in registerSkywalkPipe", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DAD84(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "BT_CL_WriteRaw failed with status %d", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006DADE8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "pd already got freed up, return", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DAE14()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC0A0();
  sub_1002BC094();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Dropping stack data for non-existant pipe 0x%04x", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DAE74()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  __error();
  sub_1002BC06C();
  sub_1002BC058((void *)&_mh_execute_header, v0, v1, "Failed to send data to socket on pipe 0x%04x with result %d", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006DAEE8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to grab a slot for data", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DAF14(_BYTE *a1, _BYTE *a2)
{
  int v2;
  os_log_t v3;
  uint8_t *v4;

  sub_100262274(a1, a2);
  sub_1002BC084((void *)&_mh_execute_header, v2, v3, "Mismatch in # of bytes set for txLen", v4);
}

void sub_1006DAF3C(_BYTE *a1, _BYTE *a2)
{
  int v2;
  os_log_t v3;
  uint8_t *v4;

  sub_100262274(a1, a2);
  sub_1002BC084((void *)&_mh_execute_header, v2, v3, "Tx : Failed to set metadata on tx packet", v4);
}

void sub_1006DAF64(_BYTE *a1, _BYTE *a2)
{
  int v2;
  os_log_t v3;
  uint8_t *v4;

  sub_100262274(a1, a2);
  sub_1002BC084((void *)&_mh_execute_header, v2, v3, "Tx : Failed to set buflet data length", v4);
}

void sub_1006DAF8C(_BYTE *a1, _BYTE *a2)
{
  int v2;
  os_log_t v3;
  uint8_t *v4;

  sub_100262274(a1, a2);
  sub_1002BC084((void *)&_mh_execute_header, v2, v3, "buflet data limit exceeds UINT16_MAX", v4);
}

void sub_1006DAFB4(_BYTE *a1, _BYTE *a2)
{
  int v2;
  os_log_t v3;
  uint8_t *v4;

  sub_100262274(a1, a2);
  sub_1002BC084((void *)&_mh_execute_header, v2, v3, "Failed to fetch buflet from txSlotPacket", v4);
}

void sub_1006DAFDC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006DB04C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "We lost our CRC bytes length:%u", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006DB0B0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC094();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Got stack ready for data event for non-existant pipe 0x%04x", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DB114(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "Read zero bytes from socket on pipe 0x%04x", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006DB178()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  __error();
  sub_1002BC0B8();
  sub_1002BC058((void *)&_mh_execute_header, v0, v1, "Received error %d from socket on pipe 0x%04x", v2, v3, v4, v5, v6);
  sub_100072694();
}

void sub_1006DB1F4(_BYTE *a1, _BYTE *a2)
{
  os_log_t v2;
  uint8_t *v3;

  sub_100262274(a1, a2);
  _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "No data to write", v3, 2u);
}

void sub_1006DB228(_BYTE *a1, _BYTE *a2)
{
  int v2;
  os_log_t v3;
  uint8_t *v4;

  sub_100262274(a1, a2);
  sub_1002BC084((void *)&_mh_execute_header, v2, v3, "Failed to fetch buflet from rxSlotPacket", v4);
}

void sub_1006DB250(_BYTE *a1, _BYTE *a2)
{
  int v2;
  os_log_t v3;
  uint8_t *v4;

  sub_100262274(a1, a2);
  sub_1002BC084((void *)&_mh_execute_header, v2, v3, "Skywalk pipes are only supported for CL", v4);
}

void sub_1006DB278(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006DB2E8()
{
  int v0;
  os_log_t v1;
  uint8_t v2[10];
  int v3;

  sub_1002BC0B8();
  v3 = v0;
  _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "Failed to transmit network relay data from socket on pipe 0x%04x with result %{bluetooth:OI_STATUS}u", v2, 0xEu);
  sub_1000726A0();
}

void sub_1006DB360()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Transport Disconnected", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DB38C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006DB404(uint64_t a1, unsigned int a2, NSObject *a3)
{
  uint64_t v3;
  const char *v4;
  const char *v5;
  int v6;
  const char *v7;
  __int16 v8;
  const char *v9;

  v3 = *(int *)(a1 + 48);
  if (v3 >= 5)
    v4 = "Unknown BSM State";
  else
    v4 = off_100923070[v3];
  if (a2 >= 5)
    v5 = "Unknown BSM State";
  else
    v5 = off_100923070[a2];
  v6 = 136446466;
  v7 = v4;
  v8 = 2082;
  v9 = v5;
  sub_1002C361C((void *)&_mh_execute_header, a3, (uint64_t)a3, "BandSwitchManager: INVALID STATE TRANSITION %{public}s -> %{public}s", (uint8_t *)&v6);
}

void sub_1006DB4BC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BandSwitchManager: Received duplicate AoS disablement for the same device. Ignoring", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DB4E8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BandSwitchManager: Received duplicate AoS enablement for the same device. Ignoring", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DB514()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BandSwitchManager: Only 1 AoS device can be enabled at a time", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DB540()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Ignoring AoS events as Device is missing or already disconnected", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DB56C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BandSwitchManager: Overriding Debounce failed. Using default", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DB598(unsigned int a1, NSObject *a2, uint64_t a3)
{
  const char *v3;
  int v4;
  const char *v5;
  __int16 v6;
  const char *v7;

  if (a1 > 3)
    v3 = "Unknown BSM State";
  else
    v3 = off_100923050[a1];
  v4 = 136315394;
  v5 = "BOOL BT::BandSwitchManager::BSMHRBBandEnable(OI_BD_ADDR *, uint8_t)";
  v6 = 2082;
  v7 = v3;
  sub_1002C361C((void *)&_mh_execute_header, a2, a3, "%s was called from %{public}s", (uint8_t *)&v4);
}

void sub_1006DB638()
{
  os_log_t v0;
  uint8_t v1[16];

  sub_10009720C();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Received a BandChanged CB for a device that bluetoothd isn't aware of", v1, 2u);
  sub_10007266C();
}

void sub_1006DB670()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Received a BandChanged CB for a device that BSM isn't aware of", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DB69C(uint64_t a1, NSObject *a2)
{
  void **v3;
  void *__p[2];
  char v5;
  uint8_t buf[4];
  void **v7;

  sub_10043E5F8(a1, __p);
  if (v5 >= 0)
    v3 = __p;
  else
    v3 = (void **)__p[0];
  *(_DWORD *)buf = 136446210;
  v7 = v3;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Received an Allowed Band CB for device %{public}s that BSM isn't aware of", buf, 0xCu);
  if (v5 < 0)
    operator delete(__p[0]);
}

void sub_1006DB74C(void *a1, NSObject *a2)
{
  uint64_t v3;
  uint8_t v4[24];

  xpc_dictionary_get_string(a1, _xpc_error_key_description);
  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, a2, v3, "XPC connection error: %{public}s", v4);
  sub_100072694();
}

void sub_1006DB7CC()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "Unexpected XPC connection event: %{public}@", v2);
  sub_1000726A0();
}

void sub_1006DB830()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to allocate security task - using framework-provided bundle identifier!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DB85C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to retrieve signing ID - using framework-provided bundle identifier!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DB888(void *a1, NSObject *a2)
{
  uint64_t v3;
  uint8_t v4[24];

  sub_1002C3FAC(a1);
  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, a2, v3, "XPC object is not an integer (type is %{public}@)", v4);
  sub_100072694();
}

void sub_1006DB8F8(void *a1, NSObject *a2)
{
  uint64_t v3;
  uint8_t v4[24];

  sub_1002C3FAC(a1);
  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, a2, v3, "XPC object is neither data nor null (type is %{public}@)", v4);
  sub_100072694();
}

void sub_1006DB968(void *a1, NSObject *a2)
{
  uint64_t v3;
  uint8_t v4[24];

  sub_1002C3FAC(a1);
  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, a2, v3, "XPC object is not a data (type is %{public}@)", v4);
  sub_100072694();
}

void sub_1006DB9D8(void *a1, NSObject *a2)
{
  uint64_t v3;
  uint8_t v4[24];

  sub_1002C3FAC(a1);
  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, a2, v3, "XPC object is not an array (type is %{public}@)", v4);
  sub_100072694();
}

void sub_1006DBA48()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "Unable to convert key %s to String", v2);
  sub_1000726A0();
}

void sub_1006DBAAC()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "Unable to convert key %s to Number", v2);
  sub_1000726A0();
}

void sub_1006DBB10()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "Unable to convert key %s to BOOL", v2);
  sub_1000726A0();
}

void sub_1006DBB74()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to convert array object to NSUUID", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DBBA0()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "Unable to convert key %s to Array", v2);
  sub_1000726A0();
}

void sub_1006DBC04()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to convert array object to NSData", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DBC30()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to convert array object to NSNumber", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DBC5C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
}

void sub_1006DBCD0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "SDP data element extraction error at ALT", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006DBD00(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "Serialization: failed inside SEQ", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006DBD30(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "Serialization: failed inside ALT", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006DBD60()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Shared memory has not been allocated yet, deferring read", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DBD8C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "AudioRingBuffer::readFrameInternal, frame header cannot be wrapped around", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DBDB8(uint64_t a1, uint64_t a2)
{
  __int16 v2;
  uint64_t v3;
  os_log_t v4;
  uint64_t v5;
  uint64_t v6;

  if (*(_QWORD *)a2)
    atomic_load((unint64_t *)(*(_QWORD *)a2 + 24));
  sub_1002C5C74();
  HIWORD(v6) = v2;
  sub_1000727B8((void *)&_mh_execute_header, v3, v4, "AudioRingBuffer::readFrameInternal, frame length(%lu) bigger than available buffer length (%lu)", v5, v6);
}

void sub_1006DBE34()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Shared memory has not been allocated yet, deferring write", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DBE60(uint64_t a1)
{
  uint64_t v1;
  os_log_t v2;
  uint64_t v3;
  uint64_t v4;

  atomic_load((unint64_t *)(*(_QWORD *)a1 + 24));
  sub_1002C5C74();
  HIWORD(v4) = v1;
  sub_1000727B8((void *)&_mh_execute_header, v1, v2, "Shared memory size (%lu bytes available) has less than requested buffer length (%lu), deferring write", v3, v4);
}

void sub_1006DBEDC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "AudioRingBuffer::writeFrameHeader, frame header cannot be wrapped around", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DBF08(uint64_t a1, NSObject *a2)
{
  _QWORD *v2;
  int v3;
  _QWORD *v4;

  v2 = (_QWORD *)(a1 + 56);
  if (*(char *)(a1 + 79) < 0)
    v2 = (_QWORD *)*v2;
  v3 = 136446210;
  v4 = v2;
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "\"%{public}s\" has insufficient entitlements to send MBFramework XPC messages", (uint8_t *)&v3, 0xCu);
  sub_1000726A0();
}

void sub_1006DBF88()
{
  os_log_t v0;
  uint8_t v1[24];

  sub_1000727CC();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "Unable to handle MBFramework XPC message \"%{public}s\" from session \"%{public}s\"", v1, 0x16u);
  sub_1000726A0();
}

void sub_1006DC008()
{
  os_log_t v0;
  uint8_t v1[24];

  sub_1000727CC();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Sending XPC message \"%{public}s\" to session \"%{public}s\"", v1, 0x16u);
  sub_1000726A0();
}

void sub_1006DC088(os_log_t log)
{
  uint8_t v1[16];

  *(_WORD *)v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "XPC message with XPC_TYPE_ERROR", v1, 2u);
}

void sub_1006DC0C8(unsigned __int8 a1, NSObject *a2)
{
  int v2;
  const char *v3;
  __int16 v4;
  int v5;

  v2 = 136315394;
  v3 = "BTVirtualHCIEventPacket";
  v4 = 1024;
  v5 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "%s: opCode 0x%04X, malloc failed", (uint8_t *)&v2, 0x12u);
}

void sub_1006DC154()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Received equal Zero keys in master key blob received", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DC180(uint64_t a1, NSObject *a2)
{
  int v2;
  uint64_t v3;

  v2 = 134217984;
  v3 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Received wrong length of keys in master key blob: %zu", (uint8_t *)&v2, 0xCu);
  sub_1000726A0();
}

void sub_1006DC1F0(unsigned __int8 a1, NSObject *a2)
{
  _DWORD v2[2];

  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Received wrong number of keys in master key blob received %d, Expected : 2", (uint8_t *)v2, 8u);
  sub_10007266C();
}

void sub_1006DC264()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Received invalid key blob from cloud kit, Generating master keys to the cloudKit", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DC290()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Received invalid device info blob  from cloud kit", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DC2BC()
{
  uint64_t v0;
  os_log_t v1;
  uint64_t v2;
  uint64_t v3;

  sub_1002CB84C();
  sub_1000727B8((void *)&_mh_execute_header, v0, v1, "Received wrong len for deviceinfo blob.  Received length %lu, Expected lengths: %lu", v2, v3);
  sub_1000726A0();
}

void sub_1006DC31C(uint64_t a1, NSObject *a2)
{
  _DWORD v2[2];
  __int16 v3;
  uint64_t v4;

  v2[0] = 68157954;
  v2[1] = 16;
  v3 = 2096;
  v4 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "upgradeDeviceToManatee Acc Master Hint:%.16P", (uint8_t *)v2, 0x12u);
  sub_1000726A0();
}

void sub_1006DC39C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Client Received invalid key blob from cloud kit, Generating master keys to the cloudKit", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DC3C8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Client Received invalid key length from cloud kit.", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DC3F4()
{
  uint64_t v0;
  os_log_t v1;
  uint64_t v2;
  uint64_t v3;

  sub_1002CB84C();
  sub_1000727B8((void *)&_mh_execute_header, v0, v1, "XPC Received wrong len for deviceinfo blob.  Received length %lu, Expected lengths: %lu", v2, v3);
  sub_1000726A0();
}

void sub_1006DC45C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002D1A88(__stack_chk_guard);
  sub_1000727E4();
  sub_1002D1A78((void *)&_mh_execute_header, v0, v1, "[BTVCLinkAdvertiser] ### Activate with unsupported type: %ld (%s)\n", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006DC4D8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1000727FC((void *)&_mh_execute_header, a1, a3, "[BTVCLinkAdvertiser] Invalidated\n", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006DC508()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002D1A88(__stack_chk_guard);
  sub_1000727E4();
  sub_1002D1A78((void *)&_mh_execute_header, v0, v1, "[BTVCLinkAdvertiser] ### Invalidate unsupported type: %ld (%s)\n", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006DC584(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1000727FC((void *)&_mh_execute_header, a1, a3, "[BTVCLinkAdvertiser] Invalidating\n", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006DC5B4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002D1A88(__stack_chk_guard);
  sub_1000727E4();
  sub_1002D1A78((void *)&_mh_execute_header, v0, v1, "[BTVCLinkAdvertiser] ### Restart unsupported type: %ld (%s)\n", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006DC630(char a1, NSObject *a2)
{
  const char *v2;
  int v3;
  const char *v4;

  v2 = "";
  if ((a1 & 1) != 0)
    v2 = "(force)";
  v3 = 136315138;
  v4 = v2;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "[BTVCLinkAdvertiser] RestartIfNeeded %s\n", (uint8_t *)&v3, 0xCu);
  sub_1000726A0();
}

void sub_1006DC6B8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1000727FC((void *)&_mh_execute_header, a1, a3, "[BTVCLinkAdvertiser] Skipping redundant advertiser update\n", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006DC6F0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "Audio Device properties copy failed, cannot send publish message", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006DC720(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Audio interval is invalid (%llu)", a5, a6, a7, a8, 0);
  sub_1000726A0();
}

void sub_1006DC788(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a2, a3, "Unable to create a xpc object from fProperties after adding %s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006DC7EC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006DC85C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006DC8CC(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a2, a3, "write Audio Frame invalid len %zu", a5, a6, a7, a8, 0);
  sub_1000726A0();
}

void sub_1006DC930(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a2, a3, "Unhandled property update: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006DC994(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "Unhandled command: %u", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006DC9F8(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "Unhandled message: %u", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006DCA5C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006DCACC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006DCB3C(uint64_t a1)
{
  void *v2;
  std::__shared_weak_count *v3;

  sub_100069BDC(a1 + 224);
  sub_10001A82C(a1 + 200, *(_QWORD **)(a1 + 208));
  sub_10009F88C(a1 + 176);
  v2 = *(void **)(a1 + 136);
  if (v2)
  {
    *(_QWORD *)(a1 + 144) = v2;
    operator delete(v2);
  }
  sub_10001A82C(a1 + 104, *(_QWORD **)(a1 + 112));

  v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
    std::__shared_weak_count::__release_weak(v3);
}

void sub_1006DCBAC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "Audio Timesync: Invalid mAudioTimeSyncClock", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006DCBDC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "Audio Timesync: Invalid mCoreTimeSyncManager", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006DCC0C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "Audio Timesync: Cannot trigger Time Sync, invalid state", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006DCC3C(uint64_t a1, NSObject *a2)
{
  int v2;
  uint64_t v3;

  v2 = 138412290;
  v3 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Audio Timesync: - addTimestampWithMachAbsolute Error:%@", (uint8_t *)&v2, 0xCu);
}

void sub_1006DCCB0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Ignoring invalid override value (%d) for connection grace period - must be greater than 5s", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DCD10()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "TCC not available", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DCD3C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Session not found in AppSessionMap", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DCD68()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "registerAppSession: _registerAppInternal Invalid state", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DCD94()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Cannot register for offline ADV key requests, feature is not enabled", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DCDC0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "App restoration is forced disabled", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DCDEC()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "Failed to create session for application \"%{public}@\"", v2);
  sub_1000726A0();
}

void sub_1006DCE50()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Session is really AppSessionTypeEither!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DCE7C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8751e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "Failed to create session info for session \"%{public}s\"", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006DCEC8(unsigned int a1, uint64_t a2, NSObject *a3)
{
  const __CFString *v3;
  int v4;
  const __CFString *v5;
  __int16 v6;
  uint64_t v7;

  if (a1 > 3)
    v3 = CFSTR("Unknown");
  else
    v3 = (const __CFString *)*((_QWORD *)&off_100924F30 + (int)a1);
  v4 = 138543618;
  v5 = v3;
  v6 = 2048;
  v7 = a2;
  sub_10026A55C((void *)&_mh_execute_header, a3, (uint64_t)a3, "Couldn't find a registered %{public}@ app for invalid session '%p'", (uint8_t *)&v4);
  sub_1000726A0();
}

void sub_1006DCF60()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "Unexpected invalid session for application \"%{public}@\"", v2);
  sub_1000726A0();
}

void sub_1006DCFC4()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8751e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "Overriding background support for TCC-disabled session \"%{public}s\"", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006DD010()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to stop tracking for a session because there is no central session exist", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DD03C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "unpublishAllServicesForApp: Invalid session", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DD068(uint64_t a1)
{
  int v1;
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  uint8_t v23;

  sub_1002F760C(a1, __stack_chk_guard, v15);
  sub_1002A8180();
  sub_1002A81E0();
  sub_1002F761C((void *)&_mh_execute_header, v1, v2, "Couldn't find a registered app for session \"%{public}s\"", v3, v4, v5, v6, v16, v18, v20, v21, v23);
  if (v22 < 0)
    sub_1002A81CC(v7, v8, v9, v10, v11, v12, v13, v14, v17, v19);
  sub_1002A81A0();
}

void sub_1006DD0E0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Classic pairing agent doesn't exist", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DD10C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8751e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "Session %{public}s is AppSessionTypeEither!", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006DD158()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007280C((void *)&_mh_execute_header, v0, v1, "appSessionResurrected: Invalid state", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DD184()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "retrieveServicesForApp: Invalid session", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DD1B0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007280C((void *)&_mh_execute_header, v0, v1, "appSessionTerminated: Invalid state", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DD1DC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to create classic pairing agent", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DD208()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Classic pairing agent already exist", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DD234(uint64_t a1, NSObject *a2)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  char v15;
  uint8_t v16[24];

  sub_1002F760C(a1, __stack_chk_guard, v12);
  sub_1002A8180();
  sub_1002A81E0();
  sub_100072744((void *)&_mh_execute_header, a2, v3, "Ignoring response as session \"%{public}s\" does not support programmatic pairing", v16);
  if (v15 < 0)
    sub_1002A81CC(v4, v5, v6, v7, v8, v9, v10, v11, v13, v14);
  sub_1002A81A0();
}

void sub_1006DD2B4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "connectDeviceForApp: Invalid session", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DD2E0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "connectDeviceForApp: Unexpected session type '%d'", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DD340()
{
  uint64_t v0;
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_1002F75F8();
  sub_1002F75D4(v1, v2, v3, 4.8752e-34);
  sub_1002A82D0((void *)&_mh_execute_header, "connectDeviceForApp : Notifying listeners that %{public}s is interested in %{public}@", v4, v5);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006DD384(uint64_t *a1, NSObject *a2, uint64_t a3)
{
  uint64_t v3;
  int v4;
  uint64_t v5;

  v3 = *a1;
  v4 = 138543362;
  v5 = v3;
  sub_100072744((void *)&_mh_execute_header, a2, a3, "%{public}@ exceed max number of LE connection request limit per App.", (uint8_t *)&v4);
  sub_1000726A0();
}

void sub_1006DD3F0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "updateAppConnectOptionsForDevice invalid parameters", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DD41C()
{
  uint64_t v0;
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;
  int v6;
  _QWORD *v7;

  sub_1002F75F8();
  if (v6 >= 0)
    v7 = v1;
  else
    v7 = (_QWORD *)*v1;
  *(_DWORD *)v3 = 136315394;
  *(_QWORD *)(v3 + 4) = v7;
  *(_WORD *)(v3 + 12) = 2112;
  *(_QWORD *)(v3 + 14) = v2;
  sub_10026A55C((void *)&_mh_execute_header, v5, v3, "App %s is not interested in %@", v4);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006DD480()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "disconnectDeviceForApp invalid parameters", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DD4AC()
{
  uint64_t v0;
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_1002F75F8();
  sub_1002F75D4(v1, v2, v3, 4.8752e-34);
  sub_1002A82D0((void *)&_mh_execute_header, "disconnectDeviceForApp : Notifying listeners that %{public}s is not interested in %{public}@", v4, v5);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006DD4F0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "disconnectDeviceForApp: invalid session type", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DD51C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to start tracking because there is no central session exist", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DD548()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to start tracking because this session is not scanning", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DD574()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to stop tracking because there is no central session exist", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DD5A0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "stopAdvertisingForApp: Invalid session", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DD5CC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "setConnectionLatency: Invalid Session", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DD5F8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "respondToATTRequest: Invalid Session", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DD624()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "sendUpdateForValue: Invalid Session", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DD650()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "registerForConnectionEventsWithOptions: Invalid Session", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DD67C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC094();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "App session changed to  %d, but the session is no longer valid", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DD6E0()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "Could not find foreground app to handle queued pairing request for device \"%{public}@\"", v2);
  sub_1000726A0();
}

void sub_1006DD744()
{
  uint64_t v0;
  _QWORD *v1;
  uint64_t v2;
  int v3;
  uint8_t *v4;
  NSObject *v5;

  sub_1002A8288();
  sub_1002F7630(v1, v2, v3, 1.5047e-36);
  sub_1002F7654((void *)&_mh_execute_header, "Unable to read attribute ID 0x%0x for inactive session \"%{public}s\"", v4, v5);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006DD788()
{
  uint64_t v0;
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_1002F75F8();
  sub_1002F75D4(v1, v2, v3, 4.8752e-34);
  sub_1002A82D0((void *)&_mh_execute_header, "getAttributeValue Notifying listeners that %{public}s is interested in %{public}@", v4, v5);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006DD7CC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002F7680();
  sub_1002BC094();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Unable to find session for attribute ID 0x%x", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DD82C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007280C((void *)&_mh_execute_header, v0, v1, "Cannot send empty write request!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DD858()
{
  uint64_t v0;
  _QWORD *v1;
  uint64_t v2;
  int v3;
  uint8_t *v4;
  NSObject *v5;

  sub_1002A8288();
  sub_1002F7630(v1, v2, v3, 1.5047e-36);
  sub_1002F7654((void *)&_mh_execute_header, "Unable to write attribute ID 0x%0x for inactive session \"%{public}s\"", v4, v5);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006DD89C()
{
  uint64_t v0;
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_1002F75F8();
  sub_1002F75D4(v1, v2, v3, 4.8752e-34);
  sub_1002A82D0((void *)&_mh_execute_header, "setAttributeValues Notifying listeners that %{public}s is interested in %{public}@", v4, v5);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006DD8E0(uint64_t a1, NSObject *a2)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  void *v13;
  char v14;
  uint8_t buf[12];
  __int16 v16;
  uint64_t v17;

  sub_1000340DC(*(_QWORD *)(a1 + 40), (uint64_t)&v13);
  sub_1002A81E0();
  v16 = 2114;
  v17 = v3;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "deviceSubscribedNotification Notifying listeners that %{public}s is interested in %{public}@", buf, 0x16u);
  if (v14 < 0)
    sub_1002A81CC(v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);
}

void sub_1006DD9AC()
{
  uint64_t v0;
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_1002F75F8();
  sub_1002F75D4(v1, v2, v3, 4.8752e-34);
  sub_1002A82D0((void *)&_mh_execute_header, "deviceSubscribedNotification Notifying listeners that %{public}s is interested in %{public}@", v4, v5);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006DD9F0()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "Could not find session to handle pairing request for device \"%{public}@\"", v2);
  sub_1000726A0();
}

void sub_1006DDA54()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8751e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "Trying to dispatch a pairing request to a session (%{public}s) without an XPC connection", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006DDAA0()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "Rejecting OOB pairing for device \"%{public}@\"", v2);
  sub_1000726A0();
}

void sub_1006DDB04(uint64_t a1, uint64_t *a2, uint64_t a3, NSObject *a4)
{
  uint64_t *v5;

  if (*((char *)a2 + 23) >= 0)
    v5 = a2;
  else
    v5 = (uint64_t *)*a2;
  *(_DWORD *)a3 = 138543618;
  *(_QWORD *)(a3 + 4) = a1;
  *(_WORD *)(a3 + 12) = 2082;
  *(_QWORD *)(a3 + 14) = v5;
  sub_10026A55C((void *)&_mh_execute_header, a4, a3, "Device \"%{public}@\" with invalid security keys connected for session \"%{public}s\", reporting.", (uint8_t *)a3);
  if (*((char *)a2 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006DDB74()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Received a system keybag unlocked notification, but the system is still locked", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DDBA0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "No restoration data to read", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DDBCC()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "Reading state restoration data failed with error %{public}@", v2);
  sub_1000726A0();
}

void sub_1006DDC30()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "UN: notifyDeviceConnected Can't create BT UUID", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DDC5C(uint64_t a1, NSObject *a2)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  void *v13;
  char v14;
  uint8_t v15[24];

  sub_10043F6EC(a1, (uint64_t)&v13);
  sub_1002A8180();
  sub_1002A81E0();
  sub_1002F7674((void *)&_mh_execute_header, a2, v3, "Device %{public}s is incoming, send an automatic connected notice", v15);
  if (v14 < 0)
    sub_1002A81CC(v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);
  sub_1002A81A0();
}

void sub_1006DDCE8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "UN: pairing failed %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DDD48(uint8_t *buf, _BYTE *a2, os_log_t log)
{
  *buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Session is AppSessionTypeEither", buf, 2u);
}

void sub_1006DDD84()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "Session Resurrected but pending TCC <%{public}@>", v2);
  sub_1000726A0();
}

void sub_1006DDDE8()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "Session Resurrected by not live <%{public}@>", v2);
  sub_1000726A0();
}

void sub_1006DDE4C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_1002F7664((void *)&_mh_execute_header, v0, v1, "AppManager::requestOfflineAdvertisingData reason %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DDEAC()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8149e-34);
  sub_1002F7674((void *)&_mh_execute_header, v7, (uint64_t)v7, "AppManager::updatedFindMyDevices session:%s", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006DDEF8()
{
  os_log_t v0;
  uint8_t v1[24];

  sub_1000EEFE4();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Attempting to remove %{public}@ from  classic gatt device list with it wasn't originally tracked!", v1, 0xCu);
  sub_1000726A0();
}

void sub_1006DDF64()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "AppManager is being asked to keep track of a nil classic device!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DDF90()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "Cannot get GATT transport for device %{public}@", v2);
  sub_1000726A0();
}

void sub_1006DDFF4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "FastLEConnection:enableFastLeConnectionWithDataToDevice Invalid session", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DE020()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "FastLEConnection:enableFastLeConnectionWithDataToDevice Invalid session type", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DE04C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "FastLEConnection:enableFastLeConnectionWithDataToDevice Device already used by another session", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DE080(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "MobileAsset not available on this platform", a5, a6, a7, a8, 0);
}

void sub_1006DE0B4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "com.apple.bluetooth.mobileassets failed setting state to done", a5, a6, a7, a8, 0);
}

void sub_1006DE0E8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "Attempting to send publish msg with a null properties dictionary!", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006DE118(int *a1, NSObject *a2)
{
  int v2;
  _DWORD v3[2];

  v2 = *a1;
  v3[0] = 67109120;
  v3[1] = v2;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "XPC publish msg create for deviceType %d failed", (uint8_t *)v3, 8u);
  sub_10007266C();
}

void sub_1006DE18C(uint64_t a1, NSObject *a2)
{
  int v2;
  uint64_t v3;

  v2 = 136315138;
  v3 = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "XpcAudioPluginDevice sendPropertyUpdatedMsg for property %s", (uint8_t *)&v2, 0xCu);
  sub_1000726A0();
}

void sub_1006DE1FC(uint64_t *a1, NSObject *a2)
{
  uint64_t v2;
  int v3;
  uint64_t v4;

  v2 = *a1;
  v3 = 136315138;
  v4 = v2;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "XPC msg create for %s failed", (uint8_t *)&v3, 0xCu);
  sub_1000726A0();
}

void sub_1006DE270(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1002F7664((void *)&_mh_execute_header, a2, a3, "XpcAudioPluginDevice sendMsg for property %d", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006DE2D4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "Plugin device is no longer published, cannot send close msg", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006DE304(unsigned __int8 *a1, uint64_t a2, os_log_t log)
{
  unsigned __int8 v3;
  unsigned __int8 v4;
  _DWORD v5[2];
  __int16 v6;
  int v7;

  v3 = atomic_load(a1);
  v4 = atomic_load((unsigned __int8 *)(a2 + 41));
  v5[0] = 67109376;
  v5[1] = v3 & 1;
  v6 = 1024;
  v7 = v4 & 1;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Dropping XPC message to XpcAudioPluginDevice. Invalid transitioning state (fIsPublished %d, fIsClosing %d)", (uint8_t *)v5, 0xEu);
  sub_1000726A0();
}

void sub_1006DE398(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1002F7664((void *)&_mh_execute_header, a2, a3, "Received XpcAudioPluginDevice handleMsg %d", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006DE3FC(NSObject *a1, uint64_t a2, uint64_t a3)
{
  uint8_t v3[16];

  *(_WORD *)v3 = 0;
  sub_1002FD8D4((void *)&_mh_execute_header, a1, a3, "Attempted to store an address of 00:00:00:00:00:00 into keychain", v3);
  sub_10007266C();
}

void sub_1006DE430(uint64_t a1, CFTypeRef cf, NSObject *a3)
{
  _DWORD v4[2];
  __int16 v5;
  uint64_t v6;
  __int16 v7;
  CFTypeID v8;
  __int16 v9;
  CFTypeID TypeID;

  v4[0] = 68158466;
  v4[1] = 6;
  v5 = 2096;
  v6 = a1;
  v7 = 2048;
  v8 = CFGetTypeID(cf);
  v9 = 2048;
  TypeID = CFDictionaryGetTypeID();
  _os_log_error_impl((void *)&_mh_execute_header, a3, OS_LOG_TYPE_ERROR, "datrStructure for device %{bluetooth:BD_ADDR}.6P) invalid %ld (expected %ld)", (uint8_t *)v4, 0x26u);
}

void sub_1006DE4F4()
{
  uint64_t v0;
  os_log_t v1;

  sub_1002FD8BC();
  sub_1002FD8A8((void *)&_mh_execute_header, v0, v1, "Failed to add attributes to keychain for device %{public}s with result %d. File a radar to Bluetooth (new bugs) | iOS");
  sub_1000726A0();
}

void sub_1006DE554()
{
  uint64_t v0;
  os_log_t v1;

  sub_1002FD8BC();
  sub_1002FD8A8((void *)&_mh_execute_header, v0, v1, "failed to update keychain data for device %{public}s with result %d. trying to add it now");
  sub_1000726A0();
}

void sub_1006DE5B4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a1, a3, "_BTKCGetDataCopy returned %d and _data is NULL", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006DE61C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to query keychain with result %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DE67C()
{
  os_log_t v0;
  uint8_t v1[8];

  sub_100097230();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Invalid security key type %d", v1, 8u);
  sub_10007266C();
}

void sub_1006DE6E8(NSObject *a1, uint64_t a2, uint64_t a3)
{
  uint8_t v3[16];

  *(_WORD *)v3 = 0;
  sub_100072750((void *)&_mh_execute_header, a1, a3, "Failed to create query dictionary for LE addresses", v3);
  sub_10007266C();
}

void sub_1006DE71C(uint8_t *a1, _BYTE *a2, NSObject *a3)
{
  *a1 = 0;
  *a2 = 0;
  sub_1002FD8D4((void *)&_mh_execute_header, a3, (uint64_t)a3, "Could not find address from keychain!", a1);
}

void sub_1006DE750(uint8_t *a1, _BYTE *a2, NSObject *a3)
{
  *a1 = 0;
  *a2 = 0;
  sub_100072750((void *)&_mh_execute_header, a3, (uint64_t)a3, "Address is zero! Skipping", a1);
}

void sub_1006DE784(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006DE7F4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006DE864()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Could not erase LE Data from local keychain with result %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DE8C4(NSObject *a1, uint64_t a2, uint64_t a3)
{
  uint8_t v3[16];

  *(_WORD *)v3 = 0;
  sub_100072750((void *)&_mh_execute_header, a1, a3, "Cannot deleteAllDataForService with invalid service name", v3);
  sub_10007266C();
}

void sub_1006DE8F8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006DE968(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006DE9D8()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[16];

  sub_10009720C();
  sub_100072750((void *)&_mh_execute_header, v0, v1, "HFP ring threshold mode fAudioDevice invalid", v2);
  sub_10007266C();
}

void sub_1006DEA08(uint64_t *a1, NSObject *a2)
{
  uint64_t v2;
  int v3;
  uint64_t v4;

  v2 = *a1;
  v3 = 134217984;
  v4 = v2;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "HFP ring threshold mode device invalid %p", (uint8_t *)&v3, 0xCu);
  sub_1000726A0();
}

void sub_1006DEA7C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006DEAEC(uint8_t *a1, _QWORD *a2, NSObject *a3)
{
  *(_DWORD *)a1 = 136446210;
  *a2 = "fAudioBytesOutstanding <= MAX_VOICE_SIZE_IN_BYTES";
  sub_1002B54DC((void *)&_mh_execute_header, a3, (uint64_t)a3, "Assertion failed: %{public}s", a1);
}

void sub_1006DEB30(uint8_t *a1, _BYTE *a2, NSObject *a3)
{
  *a1 = 0;
  *a2 = 0;
  sub_100072750((void *)&_mh_execute_header, a3, (uint64_t)a3, "No Sco Connection handle to write to", a1);
}

void sub_1006DEB64(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006DEBD4(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "Insufficient Buffer Length: %d", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006DEC38()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_1000727FC((void *)&_mh_execute_header, v0, v1, "HF read fail first", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DEC64()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_1000727FC((void *)&_mh_execute_header, v0, v1, "HF read fail second", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DEC90(uint64_t a1, uint64_t a2, os_log_t log)
{
  int v3;
  uint64_t v4;
  __int16 v5;
  uint64_t v6;

  v3 = 134218240;
  v4 = a1;
  v5 = 2048;
  v6 = a2;
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "wrote %ld bytes to audio buffer when max size is %zu", (uint8_t *)&v3, 0x16u);
  sub_1000726A0();
}

void sub_1006DED10(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006DED80()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_1000727FC((void *)&_mh_execute_header, v0, v1, "HF (AAC) read fail", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DEDAC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_1000727FC((void *)&_mh_execute_header, v0, v1, "First read failed", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DEDD8(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "getMinAudioFrame unsupported codec %u", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006DEE3C()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[16];

  sub_10009720C();
  sub_100072750((void *)&_mh_execute_header, v0, v1, "AudioDevice is gone can't run handleOverwaitDetection", v2);
  sub_10007266C();
}

void sub_1006DEE6C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC094();
  sub_1002F7664((void *)&_mh_execute_header, v0, v1, "is4387C0 = %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DEED8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC094();
  sub_1002F7664((void *)&_mh_execute_header, v0, v1, "is4387C2 = %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DEF44()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC094();
  sub_1002F7664((void *)&_mh_execute_header, v0, v1, "is4388B0 = %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DEFB0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC094();
  sub_1002F7664((void *)&_mh_execute_header, v0, v1, "is4388C0 = %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DF01C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC094();
  sub_1002F7664((void *)&_mh_execute_header, v0, v1, "is4388C2 = %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DF088()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC094();
  sub_1002F7664((void *)&_mh_execute_header, v0, v1, "is4399B0 = %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DF0F4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC094();
  sub_1002F7664((void *)&_mh_execute_header, v0, v1, "is4399C2 = %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DF160()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC094();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "blob mask configuration unsupported for this HW for PCF UUID (blobLen=%d)", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DF1C4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "setEnhancedMatchingRuleExtendedBlobAndMask failed with error %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DF224()
{
  uint64_t v0;
  os_log_t v1;

  sub_100097230();
  sub_1002A8220((void *)&_mh_execute_header, v0, v1, "Invalid %{bluetooth:OI_STATUS}u, %d,");
  sub_1000726A0();
}

void sub_1006DF290()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Connection lookup failed with %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DF2F0(uint64_t a1, NSObject *a2)
{
  void *p_p;
  void *__p;
  char v5;
  uint8_t buf[4];
  void *v7;

  sub_10064960C(a1);
  if (v5 >= 0)
    p_p = &__p;
  else
    p_p = __p;
  *(_DWORD *)buf = 136315138;
  v7 = p_p;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Scan Core Classic Connection Event: No device found for bt address: %s", buf, 0xCu);
  if (v5 < 0)
    operator delete(__p);
}

void sub_1006DF3A0(_DWORD *a1, NSObject *a2)
{
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  _DWORD v13[2];
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  __int16 v28;
  int v29;
  __int16 v30;
  int v31;
  __int16 v32;
  int v33;

  v2 = *(unsigned __int8 *)a1;
  v3 = a1[1];
  v4 = a1[2];
  v5 = a1[3];
  v6 = a1[4];
  v7 = a1[5];
  v8 = a1[6];
  v9 = a1[7];
  v10 = a1[8];
  v12 = a1[9];
  v11 = a1[10];
  v13[0] = 67111680;
  v13[1] = v2;
  v14 = 1024;
  v15 = v3;
  v16 = 1024;
  v17 = v4;
  v18 = 1024;
  v19 = v5;
  v20 = 1024;
  v21 = v6;
  v22 = 1024;
  v23 = v7;
  v24 = 1024;
  v25 = v8;
  v26 = 1024;
  v27 = v9;
  v28 = 1024;
  v29 = v10;
  v30 = 1024;
  v31 = v12;
  v32 = 1024;
  v33 = v11;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "vseScanCoreBTLEStatsExtendedEvent: numAuxTries %u totalBTSCInquiryScanTime %u IDPackets %u totalTimeConnectionScan MCeLNAOn %u MCeLNABypass %u SCeLNAOn %u SCeLNABypass %u numConnectionCompleteAdvs MCeLNAOn %u MCeLNABypass %u SCeLNAOn %u SCeLNABypass %u", (uint8_t *)v13, 0x44u);
}

void sub_1006DF480(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006DF4F0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "(BTPowerLog): Not sending enhanced profile stats!", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006DF520(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "Failed to attach to BTDebug service", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006DF550()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "BTDebugDriver logging enable failed with status %x", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DF5B0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC094();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "readPowerCapState: Invalid length from VSCEvent(%d)", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DF614()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC094();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "enhancedReadPowerCapState: Invalid length from VSCEvent(%d)", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DF678()
{
  os_log_t v0;
  uint8_t v1[8];

  sub_100097230();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Unknown chipset %d", v1, 8u);
  sub_10007266C();
}

void sub_1006DF6E4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "Error finding MaxSharingNearbyInvitationHostConnections value for current device", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006DF714(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a1, a3, "Get Lpeam data length is not %d", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006DF780(int a1, NSObject *a2)
{
  _DWORD v2[2];
  __int16 v3;
  int v4;

  v2[0] = 67109376;
  v2[1] = 0;
  v3 = 1024;
  v4 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Read controller RAM error with invalid length, status = %{bluetooth:OI_STATUS}u, length = %d", (uint8_t *)v2, 0xEu);
  sub_1000726A0();
}

void sub_1006DF7FC(unsigned __int8 a1, uint64_t a2, NSObject *a3)
{
  uint64_t v3;
  uint64_t v4;

  LODWORD(v3) = 67109376;
  HIDWORD(v3) = a2;
  LOWORD(v4) = 1024;
  *(_DWORD *)((char *)&v4 + 2) = a1;
  sub_1002A8220((void *)&_mh_execute_header, a2, a3, "Read controller RAM error, status = %{bluetooth:OI_STATUS}u, length = %d", v3, v4);
  sub_1000726A0();
}

void sub_1006DF870()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Read controller RAM error, invalid length %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DF8D0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC094();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "readControllerRam: Invalid length from VSCEvent(%d)", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DF934()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Error in loadMSFFileCB: CRCFlag: %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006DF994(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006DFA04(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006DFA74(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006DFAE4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006DFB54(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006DFBC4(os_log_t log)
{
  int v1;
  const char *v2;

  v1 = 136446210;
  v2 = "fPowerAssertion == NULL";
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", (uint8_t *)&v1, 0xCu);
  sub_1000726A0();
}

void sub_1006DFC40(uint64_t a1, uint64_t a2, os_log_t log)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  uint64_t v7;

  v3 = *(_QWORD *)(a1 + 48);
  v4 = 136446466;
  v5 = v3;
  v6 = 2048;
  v7 = a2;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "BlueTool failed to run %{public}s script with result %ld", (uint8_t *)&v4, 0x16u);
  sub_1000726A0();
}

void sub_1006DFCC4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007266C();
}

void sub_1006DFCF0(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a2, a3, "BlueTool timed out running %{public}s script!", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006DFD58(uint64_t a1, NSObject *a2)
{
  int v2;
  uint64_t v3;

  v2 = 134217984;
  v3 = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "Crashloop detection initial timestamp: %llu", (uint8_t *)&v2, 0xCu);
  sub_1000726A0();
}

void sub_1006DFDC8(uint64_t a1, int a2, NSObject *a3)
{
  _DWORD v3[2];
  __int16 v4;
  uint64_t v5;

  v3[0] = 67109376;
  v3[1] = a2;
  v4 = 2048;
  v5 = a1 - qword_100991D80;
  sub_10032187C((void *)&_mh_execute_header, a3, (uint64_t)a3, "Crashloop detected %u errors in %llu", (uint8_t *)v3);
  sub_1000726A0();
}

void sub_1006DFE4C(os_log_t log)
{
  _DWORD v1[2];

  v1[0] = 67109120;
  v1[1] = 0;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "Crashloop detection reset, threshold timeout reached. Error count: %u", (uint8_t *)v1, 8u);
  sub_10007266C();
}

void sub_1006DFEC0(uint64_t a1, NSObject *a2, uint64_t a3)
{
  _DWORD v3[2];
  __int16 v4;
  uint64_t v5;

  v3[0] = 67109376;
  v3[1] = dword_100991D78;
  v4 = 2048;
  v5 = a1;
  sub_10032187C((void *)&_mh_execute_header, a2, a3, "Crashloop detection (%u) timestamp: %llu", (uint8_t *)v3);
  sub_1000726A0();
}

void sub_1006DFF3C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a2, a3, "BlueTool timed out running \"%{public}s\" command", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006DFFA4()
{
  os_log_t v0;
  uint8_t v1[16];

  sub_10009720C();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Unable to get firmware image file buffer", v1, 2u);
  sub_10007266C();
}

void sub_1006DFFDC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "'defaults write' disabled booting chipset simple and fast", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E0008()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Could not create date", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E0034()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Could not create a wake request dictionary", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E0060()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Could not schedule a wakeup ...", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E008C(int *a1, uint64_t a2, NSObject *a3)
{
  int v3;

  v3 = *a1;
  *(_DWORD *)a2 = 67109120;
  *(_DWORD *)(a2 + 4) = v3;
  sub_100097200((void *)&_mh_execute_header, a3, (uint64_t)a3, "openpty failed with errno %d", (uint8_t *)a2);
}

void sub_1006E00CC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "No such device, can't read from the tty", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006E00FC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "Failed to send data to the stack", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006E012C(int *a1, uint64_t a2, NSObject *a3)
{
  int v3;

  v3 = *a1;
  *(_DWORD *)a2 = 67109120;
  *(_DWORD *)(a2 + 4) = v3;
  sub_100097200((void *)&_mh_execute_header, a3, (uint64_t)a3, "Error reading - errno is %d", (uint8_t *)a2);
}

void sub_1006E016C(NSObject *a1)
{
  int v2;
  uint64_t v3;
  _DWORD v4[2];

  v2 = *__error();
  v4[0] = 67109120;
  v4[1] = v2;
  sub_100097200((void *)&_mh_execute_header, a1, v3, "Failed writing to com port - errno is %d", (uint8_t *)v4);
}

void sub_1006E01F0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to set diversity coex HAA maps", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E021C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to set diversity cell coex configuration", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E0248(os_log_t log, double a2)
{
  int v2;
  double v3;

  v2 = 134217984;
  v3 = a2;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Invalid sampling rate %f for acoustic tuning", (uint8_t *)&v2, 0xCu);
}

void sub_1006E02C0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to start HCI tracing", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E02EC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Invalid HCI tracing parameters specified.  Using defaults", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E0318(int a1, NSObject *a2)
{
  _DWORD v2[2];
  __int16 v3;
  int v4;
  __int16 v5;
  int v6;

  v2[0] = 67109632;
  v2[1] = a1;
  v3 = 1024;
  v4 = 0;
  v5 = 1024;
  v6 = 3;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "SPMI Debug Control %d outside (%d,%d)", (uint8_t *)v2, 0x14u);
}

void sub_1006E03A4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to attach to BTDebug service", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E03D0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to attach to BTDebug service, skipping PCIe core dump", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E03FC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to create completion group for PCIe core dump", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E0428()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Timeout waiting for PCIe core dump completion", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E0454(int a1, NSObject *a2)
{
  _DWORD v2[2];

  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Issuing PCIe core dump request failed with 0x%08X", (uint8_t *)v2, 8u);
  sub_10007266C();
}

void sub_1006E04C4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
}

void sub_1006E0538(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
}

void sub_1006E05AC(os_log_t log)
{
  uint8_t v1[16];

  *(_WORD *)v1 = 0;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "QoS Config Flag Enabled", v1, 2u);
  sub_10007266C();
}

void sub_1006E05E8()
{
  os_log_t v0;
  uint8_t v1[8];

  sub_100097230();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Unknown VSC (BD_SUPPORTED_VSC): %d", v1, 8u);
  sub_10007266C();
}

void sub_1006E0654(uint64_t a1, NSObject *a2)
{
  int v3;
  const char *v4;

  v3 = 136446210;
  v4 = sub_100334CB8(a1);
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Command is already outstanding %{public}s", (uint8_t *)&v3, 0xCu);
  sub_100072694();
}

void sub_1006E06D0(uint64_t a1, NSObject *a2)
{
  int v3;
  const char *v4;

  v3 = 136446210;
  v4 = sub_100334CB8(a1);
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Stack is not ready, cannot send %{public}s", (uint8_t *)&v3, 0xCu);
  sub_100072694();
}

void sub_1006E074C()
{
  os_log_t v0;
  uint8_t v1[8];

  sub_100097230();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Invalid VSC Index %d", v1, 8u);
  sub_10007266C();
}

void sub_1006E07B8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to register the vendor callback with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E0818(uint64_t a1, int a2, NSObject *a3)
{
  int v5;
  const char *v6;
  __int16 v7;
  int v8;

  v5 = 136446466;
  v6 = sub_100334CB8(a1);
  v7 = 1024;
  v8 = a2;
  _os_log_error_impl((void *)&_mh_execute_header, a3, OS_LOG_TYPE_ERROR, "%{public}s failed with result %{bluetooth:OI_STATUS}u", (uint8_t *)&v5, 0x12u);
  sub_100072694();
}

void sub_1006E08A4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to register the reportDeviceErrorCB with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E0904()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to register the reportTransportErrorCb with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E0964()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Unknown chipset range 0x%x, returning reserved voice buffer as false", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E09C4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E0A34(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_100337DB4(a1, a2, 4.8149e-34);
  sub_100072744((void *)&_mh_execute_header, v2, (uint64_t)v2, "Failed to compile SQL statement with error \"%s\"", v3);
}

void sub_1006E0A6C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E0ADC(sqlite3 **a1, NSObject *a2)
{
  const char *v3;
  uint64_t v4;
  int v5;
  const char *v6;

  v3 = sqlite3_errmsg(*a1);
  v5 = 136315138;
  v6 = v3;
  sub_100072744((void *)&_mh_execute_header, a2, v4, "Failed to retrieve device info as there was an error executing lookup: \"%s\"", (uint8_t *)&v5);
  sub_100072694();
}

void sub_1006E0B58(uint64_t a1, uint64_t a2)
{
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  uint8_t v23;

  sub_1002A81D4(a1, a2);
  sub_1002A8180();
  sub_1002A81E0();
  sub_100337DC0((void *)&_mh_execute_header, v2, v3, "Comparing friendly name: NULL Friendly Name for Device %{public}s, skipping name matching.", v4, v5, v6, v7, v16, v18, v20, v21, v23);
  if (v22 < 0)
    sub_1002A81CC(v8, v9, v10, v11, v12, v13, v14, v15, v17, v19);
  sub_1002A81A0();
}

void sub_1006E0BD8(uint64_t a1, NSObject *a2)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  void *v13;
  char v14;
  uint8_t v15[24];

  sub_1002A81D4(a1, (uint64_t)a2);
  sub_1002A8180();
  sub_1002A81E0();
  sub_100072744((void *)&_mh_execute_header, a2, v3, "Unknown error encountered when searching database for make name of device %{public}s", v15);
  if (v14 < 0)
    sub_1002A81CC(v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);
  sub_1002A81A0();
}

void sub_1006E0C60(sqlite3 **a1, NSObject *a2)
{
  const char *v3;
  uint64_t v4;
  int v5;
  const char *v6;

  v3 = sqlite3_errmsg(*a1);
  v5 = 136315138;
  v6 = v3;
  sub_100072744((void *)&_mh_execute_header, a2, v4, "Failed to retrieve device info as there was an error executing lookup: \"%s\"", (uint8_t *)&v5);
  sub_100072694();
}

void sub_1006E0CE0(uint64_t a1, uint64_t a2)
{
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  uint8_t v23;

  sub_1002A81D4(a1, a2);
  sub_1002A8180();
  sub_1002A81E0();
  sub_100337DC0((void *)&_mh_execute_header, v2, v3, "Comparing friendly name: NULL Friendly Name for Device %{public}s, skipping name matching.", v4, v5, v6, v7, v16, v18, v20, v21, v23);
  if (v22 < 0)
    sub_1002A81CC(v8, v9, v10, v11, v12, v13, v14, v15, v17, v19);
  sub_1002A81A0();
}

void sub_1006E0D60(uint64_t a1, NSObject *a2)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  void *v13;
  char v14;
  uint8_t v15[24];

  sub_1002A81D4(a1, (uint64_t)a2);
  sub_1002A8180();
  sub_1002A81E0();
  sub_100072744((void *)&_mh_execute_header, a2, v3, "Unknown error encountered when searching database for make group of device %{public}s", v15);
  if (v14 < 0)
    sub_1002A81CC(v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);
  sub_1002A81A0();
}

void sub_1006E0DE8(sqlite3 **a1, NSObject *a2)
{
  const char *v3;
  uint64_t v4;
  int v5;
  const char *v6;

  v3 = sqlite3_errmsg(*a1);
  v5 = 136315138;
  v6 = v3;
  sub_100072744((void *)&_mh_execute_header, a2, v4, "Failed to retrieve device info as there was an error executing lookup: \"%s\"", (uint8_t *)&v5);
  sub_100072694();
}

void sub_1006E0E68(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_100337DB4(a1, a2, 4.8149e-34);
  sub_100072744((void *)&_mh_execute_header, v2, (uint64_t)v2, "Failed to bind values with error \"%s\"", v3);
}

void sub_1006E0EA0(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_100337DB4(a1, a2, 4.8149e-34);
  sub_100072744((void *)&_mh_execute_header, v2, (uint64_t)v2, "Failed to open device database with error \"%s\"", v3);
}

void sub_1006E0ED8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E0F48()
{
  os_log_t v0;
  uint8_t v1[16];

  sub_10009720C();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Settings are not nil after unpairing", v1, 2u);
  sub_10007266C();
}

void sub_1006E0F80(uint64_t a1, NSObject *a2)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  void *v13;
  char v14;
  uint8_t v15[24];

  sub_10043F78C(a1, (uint64_t)&v13);
  sub_1002A8180();
  sub_1002A81E0();
  sub_100072744((void *)&_mh_execute_header, a2, v3, "System has not passed first unlock (or device prefs not read yet). Do not delete device %s", v15);
  if (v14 < 0)
    sub_1002A81CC(v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);
  sub_1002A81A0();
}

void sub_1006E1010(uint64_t a1, NSObject *a2)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  void *v13;
  char v14;
  uint8_t v15[24];

  sub_1002A81D4(a1, (uint64_t)a2);
  sub_1002A8180();
  sub_1002A81E0();
  sub_100072744((void *)&_mh_execute_header, a2, v3, "Detected bluetooth name issue : Unable to read name for %{public}s", v15);
  if (v14 < 0)
    sub_1002A81CC(v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);
  sub_1002A81A0();
}

void sub_1006E1098(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E1108(char *a1, uint64_t a2, NSObject *a3)
{
  char *v4;

  if (a1[23] >= 0)
    v4 = a1;
  else
    v4 = *(char **)a1;
  *(_DWORD *)a2 = 136446210;
  *(_QWORD *)(a2 + 4) = v4;
  sub_100072744((void *)&_mh_execute_header, a3, (uint64_t)a3, "%{public}s has no tags", (uint8_t *)a2);
  if (a1[23] < 0)
    operator delete(*(void **)a1);
}

void sub_1006E1170()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Unable to allocate memory for SDP records returning", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E119C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Inconsistency in SDP records parsing found, wiping device cache", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E11C8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Detected SDP read version failed, writing version", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E11F4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "SDP Cache version invalid, wiping cache", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E1220()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Input attributes not EMPTY", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E124C(uint64_t a1, NSObject *a2, uint64_t a3)
{
  int v3;
  uint64_t v4;

  v3 = 134217984;
  v4 = a1;
  sub_100072744((void *)&_mh_execute_header, a2, a3, "rdar://problem/66432832 attempting to write descriptorSize: %zu", (uint8_t *)&v3);
  sub_1000726A0();
}

void sub_1006E12B4(uint64_t *a1, NSObject *a2, uint64_t a3)
{
  uint64_t v3;
  int v4;
  uint64_t v5;

  v3 = *a1;
  v4 = 134217984;
  v5 = v3;
  sub_100072744((void *)&_mh_execute_header, a2, a3, "rdar://problem/66432832 size mismatch, descriptorSize: %zu", (uint8_t *)&v4);
  sub_1000726A0();
}

void sub_1006E1320(uint64_t a1, NSObject *a2, uint64_t a3)
{
  int v3;
  uint64_t v4;

  v3 = 134217984;
  v4 = a1;
  sub_100072744((void *)&_mh_execute_header, a2, a3, "rdar://problem/66432832 read descriptorSize: %zu from disk", (uint8_t *)&v3);
  sub_1000726A0();
}

void sub_1006E1388()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "writeAACPVersionInfo: Invalid input", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E13B4(uint64_t a1, NSObject *a2)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  void *v13;
  char v14;
  uint8_t v15[24];

  sub_1002A81D4(a1, (uint64_t)a2);
  sub_1002A8180();
  sub_1002A81E0();
  sub_100072744((void *)&_mh_execute_header, a2, v3, "Failed to read CaseInfo fw version for device: %{private}s", v15);
  if (v14 < 0)
    sub_1002A81CC(v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);
  sub_1002A81A0();
}

void sub_1006E1438(uint64_t a1, NSObject *a2)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  void *v13;
  char v14;
  uint8_t v15[24];

  sub_1002A81D4(a1, (uint64_t)a2);
  sub_1002A8180();
  sub_1002A81E0();
  sub_100072744((void *)&_mh_execute_header, a2, v3, "Failed to read CaseInfo message version for device: %{private}s", v15);
  if (v14 < 0)
    sub_1002A81CC(v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);
  sub_1002A81A0();
}

void sub_1006E14BC(uint64_t a1, NSObject *a2)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  void *v13;
  char v14;
  uint8_t v15[24];

  sub_1002A81D4(a1, (uint64_t)a2);
  sub_1002A8180();
  sub_1002A81E0();
  sub_100072744((void *)&_mh_execute_header, a2, v3, "Did not write DID info for %{public}s to disk", v15);
  if (v14 < 0)
    sub_1002A81CC(v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);
  sub_1002A81A0();
}

void sub_1006E1540()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007280C((void *)&_mh_execute_header, v0, v1, "Shouldn't be trying to persist device without a UUID!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E156C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Ignoring invalid override value (%d) for max number of seen devices to be cached on disk", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E15CC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Ignoring invalid override value (%d) for max number of connected devices to be cached on disk", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E162C(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_100337DB4(a1, a2, 4.8751e-34);
  sub_100072744((void *)&_mh_execute_header, v2, (uint64_t)v2, "Failed to load '%{public}s' cache", v3);
}

void sub_1006E1664()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed registration for MKB first unlock notification with error : %u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E16C4(id *a1, NSObject *a2)
{
  uint64_t v3;
  uint8_t v4[24];

  objc_msgSend(*a1, "friendlyNameForType:", 1);
  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, a2, v3, "Failed to load '%{public}s' cache", v4);
  sub_100347680();
}

void sub_1006E1744()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007280C((void *)&_mh_execute_header, v0, v1, "Received MKB first unlock notification, but MKBDeviceUnlockedSinceBoot returns 0", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E1770(void *a1, uint64_t a2, uint64_t a3, NSObject *a4)
{
  *(_DWORD *)a2 = 67109378;
  *(_DWORD *)(a2 + 4) = a3;
  *(_WORD *)(a2 + 8) = 2114;
  *(_QWORD *)(a2 + 10) = a1;
  sub_1002A827C((void *)&_mh_execute_header, a4, a3, "Found %d stale paired device(s) with address %{public}@", (uint8_t *)a2);

  sub_1000DE5DC();
}

void sub_1006E17C8()
{
  void *v0;
  void *v1;
  uint64_t v2;
  uint64_t v3;
  uint8_t *v4;
  os_log_t v5;

  sub_1003476B0();
  v1 = v0;
  *(_DWORD *)v2 = 138543618;
  *(_QWORD *)(v2 + 4) = v3;
  *(_WORD *)(v2 + 12) = 2114;
  *(_QWORD *)(v2 + 14) = v0;
  _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Rebuilding missing paired device \"%{public}@\" (%{public}@) from keychain data", v4, 0x16u);

  sub_1000DE5DC();
}

void sub_1006E1824(void *a1, uint64_t a2)
{
  NSObject *v3;
  uint8_t *v4;

  sub_100337DB4((uint64_t)a1, a2, 5.8381e-34);
  sub_100072744((void *)&_mh_execute_header, v3, (uint64_t)v3, "Attempting to recover paired device address %{public}@ without backup UUID - previous UUID will be invalidated", v4);

  sub_1000DE5DC();
}

void sub_1006E1868(void **a1, NSObject *a2)
{
  void *v3;
  id v4;
  uint64_t v5;
  int v6;
  void *v7;

  v3 = *a1;
  v6 = 138543362;
  v7 = v3;
  v4 = v3;
  sub_100072744((void *)&_mh_execute_header, a2, v5, "Unable to locate device \"%{public}@\" in disk caches", (uint8_t *)&v6);

  sub_100347680();
}

void sub_1006E18F4()
{
  int *v0;
  int v1;
  uint64_t v2;
  uint64_t v3;
  uint8_t *v4;
  os_log_t v5;

  sub_1003476B0();
  v1 = *v0;
  *(_DWORD *)v2 = 136446722;
  *(_QWORD *)(v2 + 4) = v3;
  *(_WORD *)(v2 + 12) = 1024;
  *(_DWORD *)(v2 + 14) = v1;
  *(_WORD *)(v2 + 18) = 1024;
  *(_DWORD *)(v2 + 20) = 2;
  _os_log_fault_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "'%{public}s' database version (v%d) is not valid (current version is v%d)", v4, 0x18u);
}

void sub_1006E1954()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint8_t *v3;
  NSObject *v4;

  sub_1003476B0();
  sub_100347698(v0, v1, v2, 4.8752e-34);
  sub_100347688((void *)&_mh_execute_header, "Found table-less '%{public}s' cache at \"%s\"", v3, v4);
}

void sub_1006E1988()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint8_t *v3;
  NSObject *v4;

  sub_1003476B0();
  sub_100347698(v0, v1, v2, 4.8752e-34);
  sub_100347688((void *)&_mh_execute_header, "Found corrupt '%{public}s' cache at \"%s\"", v3, v4);
}

void sub_1006E19BC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007280C((void *)&_mh_execute_header, v0, v1, "Found legacy plist on device with new cache - did migration fail?", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E19E8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Cache has not been loaded", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E1A14()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to find the maximum last seen time", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E1A40()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to count the number of last connected devices", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E1A6C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to count the number of last seen devices", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E1A98()
{
  uint64_t v0;
  os_log_t v1;

  sub_1000EEFE4();
  sub_1000727B8((void *)&_mh_execute_header, v0, v1, "Error converting Extended Properties dict to JSON: %@ - %@");
  sub_1000726A0();
}

void sub_1006E1B04()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "Extended Properties dict can not be converted to JSON: %@", v2);
  sub_1000726A0();
}

void sub_1006E1B68()
{
  uint64_t v0;
  os_log_t v1;
  int v2;

  v2 = 136446722;
  sub_10007281C();
  sub_10026A5A4((void *)&_mh_execute_header, v0, v1, "%{public}s - JSON â€˜%@â€™not a dictionary: %@", v2);
  sub_100347680();
}

void sub_1006E1BD4()
{
  uint64_t v0;
  os_log_t v1;
  int v2;

  v2 = 136446722;
  sub_10007281C();
  sub_10026A5A4((void *)&_mh_execute_header, v0, v1, "%{public}s - JSON â€˜%@â€™ conversion error: %@", v2);
  sub_100347680();
}

void sub_1006E1C40()
{
  uint64_t v0;
  os_log_t v1;
  int v2;

  v2 = 136446722;
  sub_10007281C();
  sub_10026A5A4((void *)&_mh_execute_header, v0, v1, "%{public}s - JSON â€˜%@â€™not a dictionary: %@", v2);
  sub_100347680();
}

void sub_1006E1CAC()
{
  uint64_t v0;
  os_log_t v1;
  int v2;

  v2 = 136446722;
  sub_10007281C();
  sub_10026A5A4((void *)&_mh_execute_header, v0, v1, "%{public}s - JSON â€˜%@â€™ conversion error: %@", v2);
  sub_100347680();
}

void sub_1006E1D18()
{
  uint64_t v0;
  os_log_t v1;
  int v2;

  v2 = 136446722;
  sub_10007281C();
  sub_10026A5A4((void *)&_mh_execute_header, v0, v1, "%{public}s - JSON â€˜%@â€™not a dictionary: %@", v2);
  sub_100347680();
}

void sub_1006E1D84()
{
  uint64_t v0;
  os_log_t v1;
  int v2;

  v2 = 136446722;
  sub_10007281C();
  sub_10026A5A4((void *)&_mh_execute_header, v0, v1, "%{public}s - JSON â€˜%@â€™ conversion error: %@", v2);
  sub_100347680();
}

void sub_1006E1DF0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Could not store custom properties - UUID is null", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E1E1C()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "customPropertiesJSONFromDevice: failed to build statement with %@", v2);
  sub_1000726A0();
}

void sub_1006E1E80(char a1, uint64_t a2, NSObject *a3)
{
  const char *v3;
  const char *v4;
  __int128 v5;

  v3 = "device is null";
  v4 = "";
  if ((a1 & 1) != 0)
    v3 = "";
  if ((a2 & 1) == 0)
    v4 = "database is null";
  LODWORD(v5) = 136315394;
  *(_QWORD *)((char *)&v5 + 4) = v3;
  WORD6(v5) = 2080;
  HIWORD(v5) = (_WORD)v4;
  sub_1000727B8((void *)&_mh_execute_header, a2, a3, "Could not store custom properties - %s %s", (const char *)v5, *((const char **)&v5 + 1));
  sub_1000726A0();
}

void sub_1006E1F18()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "custom db read error %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E1F78()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Could not load custom properties - UUID is null", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E1FA4(int a1, NSObject *a2, uint64_t a3)
{
  int v3;
  const char *v4;
  __int16 v5;
  int v6;

  v3 = 136315394;
  v4 = "-[LeDeviceCache readDeviceFromDatabase:statement:]";
  v5 = 1024;
  v6 = a1;
  sub_1002A827C((void *)&_mh_execute_header, a2, a3, "%s step failed with result:%d", (uint8_t *)&v3);
  sub_1000726A0();
}

void sub_1006E2020()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint8_t *v3;
  NSObject *v4;

  sub_1003476B0();
  *(_DWORD *)v0 = 136446466;
  *(_QWORD *)(v0 + 4) = v1;
  *(_WORD *)(v0 + 12) = 2082;
  *(_QWORD *)(v0 + 14) = v2;
  sub_100347688((void *)&_mh_execute_header, "Database returned invalid uuid for device address %{public}s (%{public}s)", v3, v4);
}

void sub_1006E2064(uint64_t a1, uint64_t a2)
{
  os_log_t v2;
  uint8_t *v3;

  sub_100337DB4(a1, a2, 4.8751e-34);
  _os_log_fault_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_FAULT, "Database returned empty address for device \"%{public}s\"", v3, 0xCu);
}

void sub_1006E20A4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "evictIsNeeded found null UUID", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E20D0(uint64_t *a1, uint64_t a2)
{
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  uint64_t v8;
  void *__p;
  void *__pa;
  uint64_t v11;
  uint64_t v12;
  char v13;

  sub_1002A81D4(*a1, a2);
  sub_1002A8180();
  sub_100072838((void *)&_mh_execute_header, v2, v3, "Failed to page device %{public}s for CATT", v4, v5, v6, v7, v8, (uint64_t)__p, v11, v12, 2u);
  if (v13 < 0)
    operator delete(__pa);
  sub_1002A81A0();
}

void sub_1006E215C(uint64_t *a1, uint64_t a2)
{
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  uint64_t v8;
  void *__p;
  void *__pa;
  uint64_t v11;
  uint64_t v12;
  char v13;

  sub_1002A81D4(*a1, a2);
  sub_1002A8180();
  sub_100072838((void *)&_mh_execute_header, v2, v3, "CATT already connected to %{public}s", v4, v5, v6, v7, v8, (uint64_t)__p, v11, v12, 2u);
  if (v13 < 0)
    operator delete(__pa);
  sub_1002A81A0();
}

void sub_1006E21E8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "No callback defined", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E2214()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to create a MIS client", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E2240()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "MIS doesn't allow more connections", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E226C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Could not get interface", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E2298()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Callback already defined", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E22C4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Could not get local address", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E22F0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Error unregistering with MIS", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E231C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Error stopping MIS", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E2348()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Error unregistering the last host", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E2374()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to add a host", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E23A0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BTStackReceiveCallBack is NULL", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E23CC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Could not get io_interface", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E23F8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to get the interface name", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E2424()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to start MIS", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E2450()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Could not _SCNetworkInterfaceCreateWithIONetworkInterfaceObject: %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E24B0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Could not get SCPreferencesCreate: %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E2510()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Could not SCPreferencesLock: %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E2570()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Could not SCNetworkSetCopyCurrent: %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E25D0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "No service", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E25FC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Could not SCNetworkSetCopyAll: %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E265C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Could not SCNetworkSetAddService: %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E26BC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Could not SCPreferencesCommitChanges: %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E271C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Could not SCPreferencesApplyChanges: %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E277C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Could not SCNetworkSetEstablishDefaultInterfaceConfiguration: %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E27DC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Error: Could not SCNetworkServiceAddProtocolType: %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E283C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Error: Could not SCNetworkProtocolSetConfiguration: %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E289C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "%s: fReadCompletionBlock is invalid", a5, a6, a7, a8, 2u);
}

void sub_1006E2910(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "%s: fReadCompletionBlock is invalid", a5, a6, a7, a8, 2u);
}

void sub_1006E2984(int a1, uint8_t *buf, os_log_t log)
{
  *(_DWORD *)buf = 67109120;
  *((_DWORD *)buf + 1) = a1;
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Unknown platform 0x%08x detected", buf, 8u);
}

void sub_1006E29C8()
{
  uint64_t v0;
  os_log_t v1;

  sub_10026A5B8();
  sub_1000727B8((void *)&_mh_execute_header, v0, v1, "Error fetching group matching %@: %@");
  sub_1000726A0();
}

void sub_1006E2A28(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E2A98()
{
  uint64_t v0;
  os_log_t v1;

  sub_10026A5B8();
  sub_1000727B8((void *)&_mh_execute_header, v0, v1, "Error fetching contacts matching %@: %@");
  sub_1000726A0();
}

void sub_1006E2AF8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E2B68(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "Couldn't retrieve own number -- using placeholder", a5, a6, a7, a8, 0);
}

void sub_1006E2B9C(uint64_t a1, NSObject *a2)
{
  int v2;
  uint64_t v3;

  v2 = 138412290;
  v3 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Error in retrieving meCard : %@", (uint8_t *)&v2, 0xCu);
  sub_1000726A0();
}

void sub_1006E2C0C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "Failed to resize phonebook image", a5, a6, a7, a8, 0);
}

void sub_1006E2C48(uint64_t a1, xpc_object_t xdict, NSObject *a3)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  __int16 v7;
  const char *string;

  v4 = *(_QWORD *)(a1 + 40);
  v5 = 136446466;
  v6 = v4;
  v7 = 2082;
  string = xpc_dictionary_get_string(xdict, _xpc_error_key_description);
  _os_log_error_impl((void *)&_mh_execute_header, a3, OS_LOG_TYPE_ERROR, "XPC error for message %{public}s: %{public}s", (uint8_t *)&v5, 0x16u);
}

void sub_1006E2CF4(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a2, a3, "XPC server error: %{public}s\n", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E2D58(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a2, a3, "Unexpected XPC server event: %{public}s\n", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E2DBC(os_log_t log)
{
  uint8_t v1[16];

  *(_WORD *)v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Error, unable to sendMsg due to no available xpc client connections", v1, 2u);
  sub_10007266C();
}

void sub_1006E2DF8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007280C((void *)&_mh_execute_header, a1, a3, "[AudioDeviceManager sendMsg:] BTAudioMsgIdClose, uid is empty", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006E2E28(char *a1, _QWORD *a2, os_log_t log)
{
  int v3;
  _QWORD *v4;

  if (*a1 < 0)
    a2 = (_QWORD *)*a2;
  v3 = 136446210;
  v4 = a2;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "Handle incoming xpc message for %{public}s", (uint8_t *)&v3, 0xCu);
  sub_1000726A0();
}

void sub_1006E2EA8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007280C((void *)&_mh_execute_header, a1, a3, "[AudioDeviceManager getDeviceForUID:] uid is empty", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006E2ED8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "PurpleMetrics not available", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E2F04(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100394D3C((void *)&_mh_execute_header, a2, a3, "BT Stats for metric '%@' sent to CoreAnalytics with result %u", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E2F78()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "addExpandedArrayToDictionary: Invalid value for bytesPerEntry: %u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E2FD8(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100394D3C((void *)&_mh_execute_header, a2, a3, "Headtracking setting submitting following CA metric: HeadTrackingTransition:%s WxProductID:%u", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E305C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "sendAccessoryEventMetricCA: Unknown Accessory Event (%u).", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E30BC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E312C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E319C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E320C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E327C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E32EC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC094();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "sendAccessoryEventMetricCA: Gyro Bias Calibration - error code %u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E3354()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC094();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "sendAccessoryEventMetricCA: Gyro Bias Calibration - Invalid version %u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E33B8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E3428(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E3498(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E3508(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E3578(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E35E8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E3658(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E36C8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E3738()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC094();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "sendAccessoryEventMetricCA: Unexpected metric ID %u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E379C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "sendAccessoryEventMetricCA: PurpleMetrics not available", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E37C8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC094();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "sendAACPMetricCA: Failed to retrieve event type for event name %u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E3830()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "accessoryEventNameToEventType: Unknown Accessory Event (%u)", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E3890()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC094();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Invalid eventType = %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E38F4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC094();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Invalid number of days (%d) for BT power state metrics monitor, stop metrics monitoring", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E3958()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC094();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "writeBTPowerStateMonitorNumOfDays failed : Invalid numOfDays = %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E39BC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "ConvertToBiomeSessionState returning default", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E39E8(uint64_t a1, uint64_t a2, os_log_t log)
{
  const char *v3;
  int v4;
  const char *v5;
  __int16 v6;
  uint64_t v7;

  v3 = "is nil,";
  if (a1)
    v3 = "is initialized,";
  v4 = 136315394;
  v5 = v3;
  v6 = 2112;
  v7 = a2;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Invalid parameters passed to readStoredMetricValue. metricValues:%s metricsToRead:%@", (uint8_t *)&v4, 0x16u);
  sub_1000726A0();
}

void sub_1006E3A80(void *a1, uint64_t a2, NSObject *a3)
{
  *(_DWORD *)a2 = 138412290;
  *(_QWORD *)(a2 + 4) = a1;
  sub_100072744((void *)&_mh_execute_header, a3, (uint64_t)a3, "GAPAPairingMetricUniqueIdSalt writePrefKey failed: %@", (uint8_t *)a2);

  sub_1000DE5DC();
}

void sub_1006E3AC8(char *a1, uint64_t a2, NSObject *a3)
{
  char *v4;

  if (a1[23] >= 0)
    v4 = a1;
  else
    v4 = *(char **)a1;
  *(_DWORD *)a2 = 136315138;
  *(_QWORD *)(a2 + 4) = v4;
  sub_100072744((void *)&_mh_execute_header, a3, (uint64_t)a3, "getGAPATimingPoint addr=%s does not exist", (uint8_t *)a2);
  if (a1[23] < 0)
    operator delete(*(void **)a1);
  sub_1000DE5DC();
}

void sub_1006E3B2C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC094();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "ACL disconnected unable to set GAPA timing for timing point %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E3B90(void *a1, uint8_t *buf, os_log_t log)
{
  *(_DWORD *)buf = 138412290;
  *(_QWORD *)(buf + 4) = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "Audio Route Transition Metrics %@ ", buf, 0xCu);

  sub_1000DE5DC();
}

void sub_1006E3BE0()
{
  os_log_t v0;
  uint8_t v1[16];

  sub_10009720C();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Ignoring Audio Route Transition metrics from the same address", v1, 2u);
  sub_10007266C();
}

void sub_1006E3C18(uint8_t *buf, _BYTE *a2, os_log_t log)
{
  *buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Error in Metrics: fLEDailyStats[key][0] is nil.", buf, 2u);
}

void sub_1006E3C54(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072734((void *)&_mh_execute_header, a1, a3, "%s -- LM Handle is invalid %d (0x%04x)", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E3CD8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "%s -- inLMHandle is 0x00 and connection handle is NULL", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E3D48()
{
  int v0;
  os_log_t v1;
  uint8_t v2[8];
  __int16 v3;
  int v4;

  sub_1002BC094();
  v3 = 1024;
  v4 = v0;
  _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "calculateAndSendHIDLatencyStatsData -- unknown HIDType (%d) for handle 0x%04x", v2, 0xEu);
  sub_1000726A0();
}

void sub_1006E3DCC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "%s -- incoming HID Latency Stat data pointer is NULL ", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E3E3C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_100394D20();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "%s -- Did not find stored HID Latency Statistics data for LM Handle %d (0x%04x)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006E3EAC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "%s -- invalid HID LatencyStats parameter ", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E3F1C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "%s -- malloc() failed ", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E3F8C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "%s -- incoming HID Latency Stat data pointer is NULL ", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E3FFC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "%s -- incoming HID Latency Stat data pointer is NULL ", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E406C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "%s -- incoming HID Latency Stat data pointer is NULL ", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E40DC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_100394D20();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "%s -- No previous stored HID Latency Statistics data for LM Handle %d (0x%04x)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006E414C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "%s -- incoming HID Latency Stat data pointer is NULL ", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E41BC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "%s -- invalid Phy Stats parameter ", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E422C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "%s -- malloc() failed ", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E429C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "%s -- invalid Phy Stats parameter ", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E430C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_100394D20();
  sub_100072734((void *)&_mh_execute_header, v0, v1, "%s -- No previous stored HID Latency data for LM Handle %d (0x%04x)", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006E437C(uint64_t a1, uint8_t *buf, os_log_t log)
{
  uint64_t v4;

  v4 = *(unsigned __int8 *)(a1 + 23);
  if ((v4 & 0x80u) != 0)
    v4 = *(_QWORD *)(a1 + 8);
  *(_DWORD *)buf = 134217984;
  *(_QWORD *)(buf + 4) = v4;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Unexpected pincode length of %lu", buf, 0xCu);
  if (*(char *)(a1 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006E43E8()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[8];

  sub_100097230();
  sub_100097200((void *)&_mh_execute_header, v0, v1, "Failed to write local address to keychain with result %d", v2);
  sub_10007266C();
}

void sub_1006E444C()
{
  uint64_t v0;
  _QWORD *v1;
  uint64_t v2;
  int v3;
  uint8_t *v4;
  NSObject *v5;

  sub_1002A8288();
  sub_10007284C(v1, v2, v3, 4.8752e-34);
  sub_1002F7654((void *)&_mh_execute_header, "Failed to write link key data for device %{public}s to keychain with result %d", v4, v5);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006E4490()
{
  uint64_t v0;
  _QWORD *v1;
  uint64_t v2;
  int v3;
  uint8_t *v4;
  NSObject *v5;

  sub_1002A8288();
  sub_10007284C(v1, v2, v3, 4.8752e-34);
  sub_1002F7654((void *)&_mh_execute_header, "Failed to write link key type for device %{public}s to keychain with result %d", v4, v5);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006E44D4(uint64_t a1, NSObject *a2)
{
  uint64_t v3;
  uint8_t v4[8];

  sub_1005A9764(a1);
  sub_100097230();
  sub_100097200((void *)&_mh_execute_header, a2, v3, "Invalid Keytype %d", v4);
  sub_100097218();
}

void sub_1006E4548(uint64_t *a1, uint64_t a2, uint8_t *buf, os_log_t log)
{
  uint64_t *v5;

  if (*((char *)a1 + 23) >= 0)
    v5 = a1;
  else
    v5 = (uint64_t *)*a1;
  *(_DWORD *)buf = 136446466;
  *(_QWORD *)(buf + 4) = v5;
  *((_WORD *)buf + 6) = 2080;
  *(_QWORD *)(buf + 14) = a2;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Failed to parse malformed magic key for device %{public}s - data was %s", buf, 0x16u);
  if (*((char *)a1 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006E45C0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072784((void *)&_mh_execute_header, v0, v1, "Failed to set cloud master keys! res = %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E4620()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072784((void *)&_mh_execute_header, v0, v1, "Failed to set cloud address keys! res = %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E4680()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072784((void *)&_mh_execute_header, v0, v1, "Failed to set cloud IRK keys! res = %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E46E8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "Error parsing XPC Args", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006E4718(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "Failed to copy signing ID. ManagedConfigOverride state is false.", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006E4748()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "handleHIDEvent:forService: failed because event is nil", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E4774()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "handleHIDEvent:forService: failed because service is nil", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E47A0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "handleHIDEvent (Telemetry) invalid telemetry interval", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E47CC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "handleHIDEvent (rssiDetectReport) invalid maxRssi value", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E47F8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "Calling %s when not activated.", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E4868()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "readAopCaches: _fastpathGlue is not valid", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E4894(unsigned __int8 a1, unsigned __int8 a2, os_log_t log)
{
  _DWORD v3[2];
  __int16 v4;
  int v5;

  v3[0] = 67109376;
  v3[1] = a2;
  v4 = 1024;
  v5 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "### readAopCaches: handleIndex %d hi %d", (uint8_t *)v3, 0xEu);
  sub_1000726A0();
}

void sub_1006E491C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "readAopCaches: getReport::BtProxCtxCacheFetch failed %@", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E497C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "_retrieveServiceState error", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E49A8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "_retrieveSectionsConfiguration returned an empty table", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E49D4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "Failed to send report. Error: %@", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E4A34(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "Calling %s when not activated.", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E4AA4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "AOP Interface Not Initialized", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E4AD0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "AOPBluetooth service not present or misbehaving!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E4AFC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "Failed to set service state. Error: %@", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E4B5C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "Failed to get service state report. Error: %@", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E4BBC(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "IORegistryEntryGetRegistryEntryID failed. Error: %d", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006E4C20(uint8_t *buf, _BYTE *a2, os_log_t log)
{
  *buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "unexpected child class", buf, 2u);
}

void sub_1006E4C5C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "IORegistryEntryGetChildIterator failed 0x%0x", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006E4CC0(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "IORegistryEntryGetParentEntry failed 0x%0x", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006E4D24()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "Failed to open device. Error: %@", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E4D84(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "Calling %s when not activated.", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006E4DF4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "AOPBluetooth HID reset handler", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E4E20()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "AOPBluetooth HID cancel handler", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E4E4C(unsigned __int8 *a1, uint64_t a2, os_log_t log)
{
  int v3;
  _DWORD v4[2];
  __int16 v5;
  uint64_t v6;

  v3 = *a1;
  v4[0] = 67109378;
  v4[1] = v3;
  v5 = 2112;
  v6 = a2;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Send report to AOP (type %d) failed. Error: %@", (uint8_t *)v4, 0x12u);
  sub_1000726A0();
}

void sub_1006E4ED0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "Failed to receive ServiceState report. Error: %@", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E4F30()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "Failed to receive Telemetry report. Error: %@", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E4F90()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "Failed to receive MatchTableConf report. Error: %@", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E4FF0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "Failed to receive BtProxCtxCacheFetch report. Error: %@", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E5050()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "Failed to receive TypeToRssiThresholdMapFetch report. Error: %@", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E50B0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "Failed to receive LogVerbose report. Error: %@", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E5110()
{
  int v0;
  os_log_t v1;
  uint8_t v2[12];
  __int16 v3;
  int v4;

  sub_1000EEFE4();
  v3 = 1024;
  v4 = v0;
  _os_log_debug_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEBUG, "MBFXPC LOG: BTLocalDeviceMsgHandler::BTLocalDeviceStatusEventCallbackHandler() %p, fCallbacksRegistered:%d", v2, 0x12u);
  sub_1000726A0();
}

void sub_1006E518C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetDefaultMsg sessionID:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E51EC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceAddCallbacksMsg localDeviceId:%llx ", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E524C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "could find callbacks", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E5278()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceRemoveCallbacksMsg localDeviceId:%llx ", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E52D8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceMaskCallbacksMsg localDeviceId:%llx ", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E5338(int *a1, NSObject *a2)
{
  int v2;
  _DWORD v3[2];

  v2 = *a1;
  v3[0] = 67109120;
  v3[1] = v2;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetModulePowerMsg bluetooth power state: %x", (uint8_t *)v3, 8u);
  sub_10007266C();
}

void sub_1006E53AC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetModulePowerMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E540C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetSpatialPlatformSupportMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E546C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDevicePowerResetMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E54CC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetAirplaneModeStatusMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E552C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetAddressStringMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E558C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetNameMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E55EC()
{
  uint64_t v0;
  os_log_t v1;
  uint64_t v2;
  uint64_t v3;

  sub_1002CB84C();
  sub_1003A7A14((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceSetDiscoverableMsg localDeviceId:%llx discoverable:%llx", v2, v3);
  sub_1000726A0();
}

void sub_1006E564C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetDiscoverableMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E56AC()
{
  uint64_t v0;
  os_log_t v1;
  uint64_t v2;
  uint64_t v3;

  sub_1002CB84C();
  sub_1003A7A14((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceSetConnectableMsg localDeviceId:%llx discoverable:%llx", v2, v3);
  sub_1000726A0();
}

void sub_1006E570C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetConnectableMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E576C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetPairedDevicesMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E57CC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetConnectionStatusMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E582C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetConnectedDevicesMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E588C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetConnectingDevicesMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E58EC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetAdvertisingStatusMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E594C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetScanningMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E59AC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetDUTModeEnabledMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E5A0C()
{
  uint64_t v0;
  os_log_t v1;
  uint64_t v2;
  uint64_t v3;

  sub_1002CB84C();
  sub_1003A7A14((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceEnableLeRxTestModeMsg localDeviceId:%llx testFrequency:%llx", v2, v3);
  sub_1000726A0();
}

void sub_1006E5A6C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceDisableLeTestModeMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E5ACC()
{
  uint64_t v0;
  os_log_t v1;
  uint64_t v2;
  uint64_t v3;

  sub_1002CB84C();
  sub_1003A7A14((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceSupportsServiceMsg localDeviceId:%llx service:%llx", v2, v3);
  sub_1000726A0();
}

void sub_1006E5B2C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceAdvertiseDataMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E5B8C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceRemoveDataMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E5BEC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceRegisterForPowerUpdatesMsg localDeviceId:%llx ", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E5C4C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceUnregisterForPowerUpdatesMsg localDeviceId:%llx ", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E5CAC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceReadPowerConsumptionMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E5D0C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceRegisterForPowerProfileStatisticsMsg localDeviceId:%llx ", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E5D6C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceUnregisterForPowerProfileStatisticsMsg localDeviceId:%llx ", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E5DCC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceReadPowerProfileStatisticsMsg deviceID:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E5E2C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceReadEnhancedPowerProfileStatisticsMsg deviceID:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E5E8C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceReadTransportSwitchStatisticsMsg deviceID:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E5EEC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceReadDetailedPowerProfileStatisticsMsg deviceID:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E5F4C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceStartHCITracesMsg deviceID:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E5FAC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceStopHCITracesMsg deviceID:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E600C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceShowPowerPromptMsg deviceID:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E606C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceSetAFHMapMsg deviceID:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E60CC()
{
  os_log_t v0;
  uint8_t v1[16];

  sub_10009720C();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Incorrect AFH Size received over XPC", v1, 2u);
  sub_10007266C();
}

void sub_1006E6104()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceReadAFHMapMsg deviceID:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E6164()
{
  os_log_t v0;
  uint8_t v1[16];

  sub_10009720C();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "BTLocalDeviceMsgHandler::handleBTLocalDeviceSetDelayedWakeMsg", v1, 2u);
  sub_10007266C();
}

void sub_1006E619C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceSetDenylistEnabledMsg localDeviceID:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E61FC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetDenylistEnabledMsg deviceID:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E625C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetDeviceNamesThatMayBeDenylistedMsg deviceID:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E62BC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceGetSharingAddressesMsg deviceID:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E631C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceIsSharingEnabledMsg deviceID:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E637C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceDumpExposureNotificationDatabaseMsg localDeviceId:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E63DC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceLinkQualityGetDataMsg sessionID:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E643C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceMsgHandler::handleBTLocalDeviceCallScreeningMsg localDeviceID:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E649C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "MBFXPC LOG: BTLocalDeviceMsgHandler::~BTLocalDeviceMsgHandler() %p", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E64FC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "MBFXPC LOG: BTLocalDeviceMsgHandler::handleDisconnection() %p", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E655C(int a1, NSObject *a2)
{
  _DWORD v2[2];

  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Unknown device class %d.  Using default service set", (uint8_t *)v2, 8u);
}

void sub_1006E65D0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "registerSmartCoverStateObserver failed -- observability is nil", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E65FC()
{
  os_log_t v0;
  uint8_t v1[16];

  sub_10009720C();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Screen undimmed", v1, 2u);
  sub_10007266C();
}

void sub_1006E6634(uint64_t *a1, NSObject *a2)
{
  uint64_t v2;
  int v3;
  uint64_t v4;

  v2 = *a1;
  v3 = 134217984;
  v4 = v2;
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Failed to find the system container: %llu", (uint8_t *)&v3, 0xCu);
  sub_1000726A0();
}

void sub_1006E66A8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Couldn't create a dynamic store", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E66D4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Netrb Framework not available", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E6700()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "MobileWifi Framework not available", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E672C(int a1, NSObject *a2, uint64_t a3, double a4)
{
  int v4;
  uint64_t v5;
  __int16 v6;
  int v7;

  v4 = 134218240;
  v5 = (uint64_t)a4;
  v6 = 1024;
  v7 = a1;
  sub_1002A827C((void *)&_mh_execute_header, a2, a3, "Detected that BT did not sleep during AP sleep of %lld seconds, but not restarting due to %d connections", (uint8_t *)&v4);
  sub_1000726A0();
}

void sub_1006E67A4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Read power profile statistics not available for unknown chipset", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E67D0(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "Failed registration for MKB first unlock notification with error : %u", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006E6834()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "CoreAudio Framework not available", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E6860()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "CarKit Framework not available", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E688C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "CoreMotion Framework not available", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E68B8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Device orientation not available", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E68E4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "No HWIdentifiers property", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E6910()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to get chipset(C) from HWIdentifiers property", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E693C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Setting HWIdentifiers has failed", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E6968()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "No HWIdentifiers set, attemping to set HWIdentifiers...", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E6994()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to get HWIdentifiers property, while trying to pull chipset", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E69C0(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "Failed to get HWIdentifiers property, while trying to pull %c: ", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006E6A28(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "Failed to get %c property from HWIdentifiers", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006E6A90(char *a1, _QWORD *a2, NSObject *a3)
{
  int v3;
  _QWORD *v4;

  if (*a1 < 0)
    a2 = (_QWORD *)*a2;
  v3 = 136315138;
  v4 = a2;
  sub_100072744((void *)&_mh_execute_header, a3, (uint64_t)a3, "Something went wrong fetching values from HWIdentifiers, we can't extract file names with extension: %s", (uint8_t *)&v3);
  sub_1000726A0();
}

void sub_1006E6B08(char *a1, _QWORD *a2, NSObject *a3)
{
  int v3;
  _QWORD *v4;

  if (*a1 < 0)
    a2 = (_QWORD *)*a2;
  v3 = 136315138;
  v4 = a2;
  sub_100072744((void *)&_mh_execute_header, a3, (uint64_t)a3, "No %s file found from HWIdentifiers", (uint8_t *)&v3);
  sub_1000726A0();
}

void sub_1006E6B80()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "possible memory corruption on SKU?", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E6BAC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "bluetooth-pcie service not found", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E6BD8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "IOName typeref not found", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E6C04()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Error reading IOName to buffer", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E6C30()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "Unmapped device id %s from IOName", v2);
  sub_1000726A0();
}

void sub_1006E6C94(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v4;
  uint8_t *v5;
  NSObject *v6;

  sub_1003BA79C(a1, (uint64_t)a2, a3, 5.778e-34);
  sub_10026A55C((void *)&_mh_execute_header, v6, v4, "Error occured when looking into %@ directory: %@", v5);

  sub_1000DE5DC();
}

void sub_1006E6CDC(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint8_t *v5;
  os_log_t v6;

  sub_1003BA79C((uint64_t)a1, a2, a3, 5.7781e-34);
  *(_WORD *)(v4 + 22) = 1024;
  *(_DWORD *)(v4 + 24) = 255;
  _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "File: %@ found by regex: %@ is over the %d char file name limit", v5, 0x1Cu);

  sub_1000DE5DC();
}

void sub_1006E6D3C()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "Multiple matching filenames detected. Picking highest version out of these filenames: %@", v2);
  sub_1000726A0();
}

void sub_1006E6DA0(void *a1, void *a2, uint64_t a3)
{
  uint64_t v5;
  uint8_t *v6;
  NSObject *v7;

  sub_1003BA79C((uint64_t)a1, (uint64_t)a2, a3, 5.778e-34);
  sub_10026A55C((void *)&_mh_execute_header, v7, v5, "Error occured when picking out highest version filename, returning end of the filenameArray: %@  Error: %@", v6);

  sub_1000DE5DC();
}

void sub_1006E6DF0()
{
  int v0;
  NSObject *v1;
  uint8_t v2[12];
  __int16 v3;
  int v4;

  sub_1003BA7B4(__stack_chk_guard);
  sub_1000EEFE4();
  v3 = 1024;
  v4 = v0;
  sub_1002A827C((void *)&_mh_execute_header, v1, (uint64_t)v1, "Filesize for %s of size: %d does not look right", v2);
  sub_1000726A0();
}

void sub_1006E6E70()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1003BA7B4(__stack_chk_guard);
  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "Could not allocate memory for reading file: %s", v2);
  sub_1000726A0();
}

void sub_1006E6EDC()
{
  uint64_t v0;
  NSObject *v1;
  uint8_t v2[12];
  __int16 v3;
  uint64_t v4;

  sub_1003BA7B4(__stack_chk_guard);
  sub_1000EEFE4();
  v3 = 2048;
  v4 = v0;
  sub_10026A55C((void *)&_mh_execute_header, v1, (uint64_t)v1, "File: %s reading error: only %lu could be read", v2);
  sub_1000726A0();
}

void sub_1006E6F5C()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1003BA7B4(__stack_chk_guard);
  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "File: %s can not be opened", v2);
  sub_1000726A0();
}

void sub_1006E6FC8(NSObject *a1, uint64_t a2, uint64_t a3)
{
  int v3;
  const char *v4;

  v3 = 136315138;
  v4 = "copyFileWithExtensionToBuffer";
  sub_100072744((void *)&_mh_execute_header, a1, a3, "Invalid extension inputted to %s", (uint8_t *)&v3);
  sub_1000726A0();
}

void sub_1006E703C(char *a1, _QWORD *a2, os_log_t log)
{
  int v3;
  _QWORD *v4;
  __int16 v5;
  const char *v6;
  __int16 v7;
  const char *v8;

  if (*a1 < 0)
    a2 = (_QWORD *)*a2;
  v3 = 136315650;
  v4 = a2;
  v5 = 2080;
  v6 = " fileSize";
  v7 = 2080;
  v8 = "copyFileWithExtensionToBuffer";
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Invalid %s pointer for extension %s in %s", (uint8_t *)&v3, 0x20u);
}

void sub_1006E70E4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "SKU could not be determined", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E7110()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007280C((void *)&_mh_execute_header, v0, v1, "Incorrect size received over XPC", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E713C()
{
  os_log_t v0;
  uint8_t v1[16];

  sub_10009720C();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "BTDeviceMsgHandler::handleBTDeviceAddressToStringMsg", v1, 2u);
  sub_10007266C();
}

void sub_1006E7174()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceAddressFromStringMsg %s", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E71D4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceFromAddressMsg sessionID:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E7234()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007280C((void *)&_mh_execute_header, v0, v1, "Incorrect Address Size received over XPC", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E7260()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceFromIdentifierMsg sessionID:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E72C0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetAddressStringMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E7320()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetDeviceTypeMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E7380()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetDeviceClassMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E73E0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetDefaultNameMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E7440()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetNameMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E74A0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetProductNameMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E7500()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceSetUserNameMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E7560()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetSyncSettingsMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E75C0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceSetSyncSettingsMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E7620()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetGroupsMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E7680()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceSetGroupMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E76E0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetPairingStatusMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E7740()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetCloudPairingStatusMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E77A0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetMagicPairingStatusMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E7800()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetConnectionStatusMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E7860()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceIsAppleAudioDeviceMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E78C0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceSupportsHSMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E7920()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceIsProControllerMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E7980()
{
  uint64_t v0;
  os_log_t v1;
  uint8_t v2[12];
  __int16 v3;
  uint64_t v4;

  sub_1000EEFE4();
  v3 = 2048;
  v4 = v0;
  _os_log_debug_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEBUG, "BTDeviceMsgHandler::handleBTDeviceServiceAddCallbacksMsg session:%llx cbid:%llx", v2, 0x16u);
  sub_1000726A0();
}

void sub_1006E79FC()
{
  os_log_t v0;
  uint8_t v1[16];

  sub_10009720C();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "could find callbacks", v1, 2u);
  sub_10007266C();
}

void sub_1006E7A34()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceServiceRemoveCallbacksMsg session:%llx ", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E7A94()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceConnectMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E7AF4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceConnectServicesMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E7B54()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceConnectServicesWithParametersMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E7BB4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceDisconnectMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E7C14()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceDisconnectServicesMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E7C74()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetConnectedServicesMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E7CD4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetSupportedServicesMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E7D34()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceSetServiceSettingsMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E7D94()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetServiceSettingsMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E7DF4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceSetVirtualTypeMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E7E54()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetVirtualTypeMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E7EB4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetComPortForServiceMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E7F14()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetComPortForServiceWithSandboxExtensionMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E7F74()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceMatchesAdvertisedKeyMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E7FD4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetAdvertisedValueForKeyMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E8034()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetDeviceIdMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E8094()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceSetHIDPropertiesMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E80F4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDevicePhysicalLinkDisconnectMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E8154()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceConfigureLinkKeyMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E81B4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceIsTemporaryPairedMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E8214()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceIsWirelessSplitterSupportedMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E8274()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceIsTemporaryPairedNotInContactsMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E82D4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetLowSecurityStatusMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E8334()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetHIDDeviceBehaviorMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E8394()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceSetHijackAudioRouteMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E83F4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceSetACLHighPriorityMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E8454()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceIsCentralMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E84B4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceGetUserSelectedDeviceTypeMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E8514()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceSetUserSelectedDeviceTypeMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E8574(int *a1, uint64_t a2, os_log_t log)
{
  int v3;
  const char *v4;
  int v5;
  uint64_t v6;
  __int16 v7;
  int v8;
  __int16 v9;
  const char *v10;

  v3 = *a1;
  v4 = "non-genuine";
  v5 = 134218498;
  v6 = a2;
  if (v3 == -1)
    v4 = "genuine";
  v7 = 1024;
  v8 = v3;
  v9 = 2080;
  v10 = v4;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "BTDeviceMsgHandler::handleBTDeviceIsGenuineAirPodsMsg device:%llx genuine:%u (%s)", (uint8_t *)&v5, 0x1Cu);
}

void sub_1006E8620()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "BTDeviceMsgHandler::handleBTDeviceIsGenuineAirPodsMsg device:%llx", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006E8680()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "deleteOldLogFiles: Unable to get directory contents: %@", v2);
  sub_1000726A0();
}

void sub_1006E86E4(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "getCrashAnalyticsSamplingRate: Out of range pref %d", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006E8748()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "initializeAccessoryLoggingSession: No stack", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E8774()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "initializeAccessoryLoggingSession: Null device", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E87A0()
{
  uint64_t v0;
  id v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_1003CD7D8();
  v1 = sub_1003CD7A4(v0);
  sub_10010B380();
  sub_1000726FC((void *)&_mh_execute_header, v2, v3, "initializeAccessoryLoggingSession: Buddy command to %{public}@ for checking crash log failed; error = %d",
    v4,
    v5,
    v6,
    v7,
    v8);

  sub_100072870();
}

void sub_1006E8818(int *a1, uint64_t a2, NSObject *a3)
{
  int v3;

  v3 = *a1;
  *(_DWORD *)a2 = 67109120;
  *(_DWORD *)(a2 + 4) = v3;
  sub_100097200((void *)&_mh_execute_header, a3, (uint64_t)a3, "Accessory power log file open failure -> %d", (uint8_t *)a2);
}

void sub_1006E8858()
{
  uint64_t v0;
  id v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_1003CD7D8();
  v1 = sub_1003CD7A4(v0);
  sub_10010B380();
  sub_1000726FC((void *)&_mh_execute_header, v2, v3, "Buddy command to %{public}@ failed; error = %d",
    v4,
    v5,
    v6,
    v7,
    v8);

  sub_100072870();
}

void sub_1006E88D0()
{
  uint64_t v0;
  id v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_1003CD7D8();
  v1 = sub_1003CD7A4(v0);
  sub_10010B380();
  sub_1000726FC((void *)&_mh_execute_header, v2, v3, "Send TimeStamp Request Periodically to %{public}@ failed; error = %d",
    v4,
    v5,
    v6,
    v7,
    v8);

  sub_100072870();
}

void sub_1006E8948()
{
  uint64_t v0;
  id v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_1003CD7D8();
  v1 = sub_1003CD7A4(v0);
  sub_10010B380();
  sub_1000726FC((void *)&_mh_execute_header, v2, v3, "Send Diagnostics Request Periodically to %{public}@ failed; error = %d",
    v4,
    v5,
    v6,
    v7,
    v8);

  sub_100072870();
}

void sub_1006E89C0(uint64_t a1)
{
  id v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  v1 = sub_1003CD7A4(a1);
  sub_1003CD7EC();
  sub_1000726FC((void *)&_mh_execute_header, v2, v3, "initializeAccessoryLoggingSession: Session for %{public}@ already exists in unexpected state %d", v4, v5, v6, v7, v8);

  sub_100072870();
}

void sub_1006E8A40()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "sendTimestamp: No stack", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E8A6C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint8_t v14;

  sub_1003CD7B0(a1, a2, a3, a4, a5, a6, a7, a8);
  sub_1003CD784();
  sub_10011E96C((void *)&_mh_execute_header, v8, v9, "sendTimestamp: Invalid address %{private, mask.hash}s", v10, v11, v12, v13, v14);
  sub_100072694();
}

void sub_1006E8AD4(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint8_t v10[24];

  sub_10025304C(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, a2, v9, "sendTimestamp: No device found for %s", v10);
  sub_100072694();
}

void sub_1006E8B4C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "sendLogCommand: No stack", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E8B78(uint64_t a1, uint64_t a2, NSObject *a3)
{
  *(_DWORD *)a2 = 136315138;
  *(_QWORD *)(a2 + 4) = a1;
  sub_100072744((void *)&_mh_execute_header, a3, (uint64_t)a3, "sendLogCommand: No device found for %s", (uint8_t *)a2);
}

void sub_1006E8BB4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "sendLogCommand: AccessoryLoggingManager currently busy", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E8BE0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "sendLogCommand: This request is not allowed", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E8C0C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "collectDebugData: No stack", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E8C38()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "collectDebugData: No AACP connection to a W1 accessory", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E8C64(uint64_t a1, uint64_t a2, NSObject *a3)
{
  *(_DWORD *)a2 = 136315138;
  *(_QWORD *)(a2 + 4) = a1;
  sub_100072744((void *)&_mh_execute_header, a3, (uint64_t)a3, "collectDebugData: No device found for %s", (uint8_t *)a2);
}

void sub_1006E8CA0(uint64_t a1, NSObject *a2)
{
  id v3;
  uint64_t v4;
  uint8_t v5[24];

  v3 = *(id *)(*(_QWORD *)(a1 + 40) + 8);
  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, a2, v4, "startInactivityTimer: Timeout period for %{public}@ ended, returning no files", v5);

  sub_100072694();
}

void sub_1006E8D28()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "finishSession: Null session", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E8D54()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "finishSession: Finished retrieving accessory logs, but cannot invoke non-iOS or non-internal pop-up", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E8D80()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Send RequestPeriodically to device was not sent successfully. Result Error Code %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E8DE0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Send CancelRequestPeriodically to device was not sent successfully. Result Error Code %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E8E40()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "syncLogOnDemandEvent: No stack", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E8E6C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "syncLogOnDemandEvent: No AACP connection", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E8E98()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "syncLogOnDemandEvent: AccessoryLoggingManager called when busy", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E8EC4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "syncLogOnDemandEvent: This request is not allowed", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E8EF0(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  unsigned int v4;
  BOOL v5;
  int v6;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint8_t v14;

  v1 = *(_QWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 48);
  if (v1 != v2)
  {
    v3 = 0;
    do
    {
      v4 = *(unsigned __int8 *)(*(_QWORD *)v1 + 40);
      v5 = v4 > 8;
      v6 = (1 << v4) & 0x182;
      if (!v5 && v6 != 0)
        ++v3;
      v1 += 8;
    }
    while (v1 != v2);
  }
  sub_1002BC094();
  sub_100072710((void *)&_mh_execute_header, v8, v9, "syncLogOnDemandEvent: Accessory retrieval timed out with %d remaining session(s); sending files now",
    v10,
    v11,
    v12,
    v13,
    v14);
  sub_10007266C();
}

void sub_1006E8F9C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "purgeCallback: No current callback from sysdiagnose", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E8FC8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "removeAccessoryLoggingSession: Session not found", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E8FF4(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_1003CD7B8(a1, a2, 7.2225e-34);
  sub_10026A55C((void *)&_mh_execute_header, v2, (uint64_t)v2, "recvLoggingHandler: Invalid address %{private, mask.hash}s", v3);
}

void sub_1006E902C()
{
  uint64_t v0;
  id v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_1003CD7D8();
  v1 = sub_1003CD7A4(v0);
  sub_10010B380();
  sub_1000726FC((void *)&_mh_execute_header, v2, v3, "recvLoggingHandler: %{public}@ sent invalid logging type = %d", v4, v5, v6, v7, v8);

  sub_100072870();
}

void sub_1006E90A4(uint64_t a1, NSObject *a2)
{
  id v3;
  uint64_t v4;
  uint8_t v5[24];

  v3 = sub_1003CD7A4(a1);
  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, a2, v4, "recvLoggingHandler: Ignoring log data from %{public}@", v5);

  sub_100072694();
}

void sub_1006E9120(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint8_t v14;

  sub_1003CD7B0(a1, a2, a3, a4, a5, a6, a7, a8);
  sub_1003CD784();
  sub_10011E96C((void *)&_mh_execute_header, v8, v9, "recvW1SCPLogHandler: Invalid address %{private, mask.hash}s", v10, v11, v12, v13, v14);
  sub_100072694();
}

void sub_1006E9188(uint64_t a1)
{
  id v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  v1 = sub_1003CD7A4(a1);
  sub_1003CD7EC();
  sub_1000726FC((void *)&_mh_execute_header, v2, v3, "recvW1SCPLogHandler: %{public}@ productId = %d unsupported for SCP logging", v4, v5, v6, v7, v8);

  sub_100072870();
}

void sub_1006E9204(NSObject *a1)
{
  uint64_t v2;
  uint8_t v3[8];

  sub_1003CD7E4();
  sub_1002BC094();
  sub_100097200((void *)&_mh_execute_header, a1, v2, "recvW1SCPLogHandler: SCP log file open failure -> %d", v3);
  sub_1000726A0();
}

void sub_1006E927C(NSObject *a1)
{
  uint64_t v2;
  uint8_t v3[8];

  sub_1003CD7E4();
  sub_1002BC094();
  sub_100097200((void *)&_mh_execute_header, a1, v2, "DebugData log file open failure -> %d", v3);
  sub_1000726A0();
}

void sub_1006E92F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint8_t v14;

  sub_10025304C(a1, a2, a3, a4, a5, a6, a7, a8);
  sub_1003CD784();
  sub_10011E96C((void *)&_mh_execute_header, v8, v9, "recvW1AppDiagnosticsHandler: Invalid address %{private, mask.hash}s", v10, v11, v12, v13, v14);
  sub_100072694();
}

void sub_1006E9364(NSObject *a1)
{
  uint64_t v2;
  uint8_t v3[8];

  __error();
  sub_1002BC094();
  sub_100097200((void *)&_mh_execute_header, a1, v2, "recvW1AppDiagnosticsHandler: AppDiag log file open failure -> %d", v3);
  sub_1000726A0();
}

void sub_1006E93E4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Buddy command was not sent successfully. Result Error Code %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E9444()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Send Power Logging Request Periodically to device was not sent successfully. Result Error Code %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E94A4(NSObject *a1)
{
  uint64_t v2;
  uint8_t v3[8];

  sub_1003CD7E4();
  sub_1002BC094();
  sub_100097200((void *)&_mh_execute_header, a1, v2, "Power log file open failure -> %d", v3);
  sub_1000726A0();
}

void sub_1006E951C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Send the Buddy Power command to Right Bud was not sent successfully. Result Error Code %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E957C()
{
  uint64_t v0;
  id v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_1003CD7D8();
  v1 = sub_1003CD7A4(v0);
  sub_10010B380();
  sub_1000726FC((void *)&_mh_execute_header, v2, v3, "recvW1CrashTraceHandler: Failed to send buddy command to to %{public}@, error = %d", v4, v5, v6, v7, v8);

  sub_100072870();
}

void sub_1006E95F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint8_t v14;

  sub_1003CD7B0(a1, a2, a3, a4, a5, a6, a7, a8);
  sub_1003CD784();
  sub_10011E96C((void *)&_mh_execute_header, v8, v9, "recvLogHandler: Invalid address %{private, mask.hash}s", v10, v11, v12, v13, v14);
  sub_100072694();
}

void sub_1006E965C(uint64_t a1)
{
  id v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  v1 = sub_1003CD7A4(a1);
  sub_10016574C();
  sub_1000726FC((void *)&_mh_execute_header, v2, v3, "recvLogHandler: Log data for %{public}@ shorter than %d byte header", v4, v5, v6, v7, v8);

  sub_100072694();
}

void sub_1006E96D8()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  __error();
  sub_1000726FC((void *)&_mh_execute_header, v0, v1, "recvLogHandler: Could not open file %@ (error = %d)", v2, v3, v4, v5, 2u);
  sub_100072694();
}

void sub_1006E9760()
{
  uint64_t v0;
  id v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_1003CD7D8();
  v1 = sub_1003CD7A4(v0);
  sub_10010B380();
  sub_1000726FC((void *)&_mh_execute_header, v2, v3, "recvLogHandler: No open log file for %{public}@ (packetSeqNum = %d)", v4, v5, v6, v7, v8);

  sub_100072870();
}

void sub_1006E97D8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC094();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "recvLogHandler: Unrecognized requester value %u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E983C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "recvLogHandler: No recognized byte for radar requester", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E9868()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "recvLogHandler: No data received", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E9894()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "retransBuddyCMD: No stack", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E98C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint8_t v14;

  sub_1003CD7B0(a1, a2, a3, a4, a5, a6, a7, a8);
  sub_1003CD784();
  sub_10011E96C((void *)&_mh_execute_header, v8, v9, "retransBuddyCMD: Invalid address %{private, mask.hash}s", v10, v11, v12, v13, v14);
  sub_100072694();
}

void sub_1006E9928(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  sub_10025304C(a1 + 409, a2, a3, a4, a5, a6, a7, a8);
  sub_1000726FC((void *)&_mh_execute_header, v8, v9, "retransBuddyCMD: Buddy retransmission hit the max limit of retries. Buddy CMD type -> %d, Remote addr -> addr \"%s\" ", v10, v11, v12, v13, 2u);
  sub_100072694();
}

void sub_1006E99B0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Sync crash log with buddy comamnd failed as test mode cannot be enabled", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E99DC(NSObject *a1)
{
  uint64_t v2;
  uint8_t v3[8];

  sub_1003CD7E4();
  sub_1002BC094();
  sub_100097200((void *)&_mh_execute_header, a1, v2, "Accessory crash binary log file open failure -> %d", v3);
  sub_1000726A0();
}

void sub_1006E9A54(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint8_t v14;

  sub_1003CD7B0(a1, a2, a3, a4, a5, a6, a7, a8);
  sub_1003CD784();
  sub_10011E96C((void *)&_mh_execute_header, v8, v9, "syncW1CrashLogHandler: Invalid address %{private, mask.hash}s", v10, v11, v12, v13, v14);
  sub_100072694();
}

void sub_1006E9ABC(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_1003CD7B8(a1, a2, 7.2225e-34);
  sub_10026A55C((void *)&_mh_execute_header, v2, (uint64_t)v2, "recvCrashAvailableHandler: Invalid address %{private, mask.hash}s", v3);
}

void sub_1006E9AF4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint8_t v14;

  sub_1003CD7B0(a1, a2, a3, a4, a5, a6, a7, a8);
  sub_1003CD784();
  sub_10011E96C((void *)&_mh_execute_header, v8, v9, "recvLogCompleteHandler: Invalid address %{private, mask.hash}s", v10, v11, v12, v13, v14);
  sub_100072694();
}

void sub_1006E9B5C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint8_t v14;

  sub_1003CD7B0(a1, a2, a3, a4, a5, a6, a7, a8);
  sub_1003CD784();
  sub_10011E96C((void *)&_mh_execute_header, v8, v9, "recvLogForceSendHandler: Invalid address %{private, mask.hash}s", v10, v11, v12, v13, v14);
  sub_100072694();
}

void sub_1006E9BC4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint8_t v14;

  sub_1003CD7B0(a1, a2, a3, a4, a5, a6, a7, a8);
  sub_1003CD784();
  sub_10011E96C((void *)&_mh_execute_header, v8, v9, "recvFileRadarRequestHandler: Invalid address %{private, mask.hash}s", v10, v11, v12, v13, v14);
  sub_100072694();
}

void sub_1006E9C2C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "recvFileRadarRequestHandler: Cannot retrieve logs from this accessory", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E9C58()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "recvAwdHandler: Invalid AWD packet of length %u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E9CB8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "recvAwdHandler: Unrecognized AWD data type: %u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E9D18()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Unsupported AccessoryLogType: %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E9D78()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Unsupported AccessoryLogDevice: %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E9DD8(uint64_t *a1, uint64_t a2, NSObject *a3)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  uint64_t v7;

  v3 = *a1;
  v4 = 138412546;
  v5 = v3;
  v6 = 2112;
  v7 = a2;
  sub_10026A55C((void *)&_mh_execute_header, a3, (uint64_t)a3, "closeCurrentLogFile: Could not rename file %@ (error = %@)", (uint8_t *)&v4);
  sub_1000726A0();
}

void sub_1006E9E54()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC094();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "parseCrashLogMetadata: Invalid length %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006E9EB8(int a1, NSObject *a2, uint64_t a3)
{
  _DWORD v3[2];
  __int16 v4;
  int v5;

  v3[0] = 67109376;
  v3[1] = 0;
  v4 = 1024;
  v5 = a1;
  sub_1002A8234((void *)&_mh_execute_header, a2, a3, "parseCrashLogMetadata: Invalid crash log length %d for log number %d", (uint8_t *)v3);
  sub_1000726A0();
}

void sub_1006E9F2C()
{
  int v0;
  NSObject *v1;
  uint8_t v2[10];
  int v3;

  sub_1002BC0B8();
  v3 = v0;
  sub_1002A8234((void *)&_mh_execute_header, v1, (uint64_t)v1, "parseCrashLogMetadata: Unprintable character %d in core name for log number %d", v2);
  sub_1000726A0();
}

void sub_1006E9F9C()
{
  int v0;
  NSObject *v1;
  uint8_t v2[10];
  int v3;

  sub_1002BC0B8();
  v3 = v0;
  sub_1002A8234((void *)&_mh_execute_header, v1, (uint64_t)v1, "parseCrashLogMetadata: Length %d doesn't match num crash logs %d", v2);
  sub_1000726A0();
}

void sub_1006EA010()
{
  uint64_t v0;
  NSObject *v1;
  uint8_t v2[12];
  __int16 v3;
  uint64_t v4;

  sub_1000EEFE4();
  v3 = 2112;
  v4 = v0;
  sub_10026A55C((void *)&_mh_execute_header, v1, (uint64_t)v1, "processCrashInstanceForAnalytics: Could not produce output JSON for %@, error %@", v2);
  sub_1000726A0();
}

void sub_1006EA084()
{
  int v0;
  NSObject *v1;
  uint8_t v2[14];
  int v3;

  sub_10016574C();
  v3 = v0;
  sub_1002A827C((void *)&_mh_execute_header, v1, (uint64_t)v1, "processCrashInstanceForAnalytics: Leftover metadata for %@ after %d chunks", v2);
  sub_1000726A0();
}

void sub_1006EA0F0(uint8_t *buf, _BYTE *a2, os_log_t log)
{
  *buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "processCrashInstanceForAnalytics: Could not create chunk", buf, 2u);
}

void sub_1006EA12C(int a1, uint64_t a2, NSObject *a3)
{
  int v3;
  uint64_t v4;
  __int16 v5;
  int v6;

  v3 = 138412546;
  v4 = a2;
  v5 = 1024;
  v6 = a1;
  sub_1002A827C((void *)&_mh_execute_header, a3, (uint64_t)a3, "processCrashInstanceForAnalytics: Ran out of metadata for %@ on chunk %d", (uint8_t *)&v3);
  sub_1000726A0();
}

void sub_1006EA1A4()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "processCrashLogForAnalytics: Could not decode %@", v2);
  sub_1000726A0();
}

void sub_1006EA208()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "processCrashLogForAnalytics: Could not find crash log sections in %@", v2);
  sub_1000726A0();
}

void sub_1006EA26C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "triggerW1AWDDiagnosticsEvent: No stack", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EA298()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "triggerW1AWDDiagnosticsEvent: No AACP connection to a W1 accessory", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EA2C4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "triggerW1AWDDiagnosticsEvent: AACP_CUSTOM_MESSAGE_TYPE_APP_DIAGNOSTICS was not sent successfully. Result Error Code %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EA324()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "triggerW1AWDDiagnosticsEvent: This request is only available in iOS with Internal Build", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EA350()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "retransBuddyCMD: No AACP connection to a W1 accessory", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EA37C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "retransBuddyCMD: Buddy command was not sent successfully, error: %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EA3DC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "No valid connection for current addr", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EA408()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Invalid buddy command type : %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EA468()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Not supported log type to be converted %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EA4C8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "sendLogCompleteCallback: deviceForCallback expected not to be NULL", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EA4F4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "[BTVCLinkAgent] ### Ignoring update before activate\n", a5, a6, a7, a8, 0);
}

void sub_1006EA528(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "[BTVCLinkAgent] ### Ignoring reset before activate\n", a5, a6, a7, a8, 0);
}

void sub_1006EA55C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "%s, _bleBTVCLinkAdvertiser is not initialized", a5, a6, a7, a8, 2u);
}

void sub_1006EA5D0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a1, a3, "%s, _bleBTVCLinkScanner is not initialized", a5, a6, a7, a8, 2u);
}

void sub_1006EA644()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "LE_GetNextAvailableLePSM failed with error %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EA6A4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007280C((void *)&_mh_execute_header, v0, v1, "pid cannot be 0", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EA6D0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007280C((void *)&_mh_execute_header, v0, v1, "Listener cannot be NULL", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EA6FC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007280C((void *)&_mh_execute_header, v0, v1, "Session cannot be NULL", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EA728()
{
  os_log_t v0;
  uint8_t v1[24];

  sub_1003D7FC4();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "L2CAP Channel 0x%04x for session type %d has been unregistered with pipes remaining!", v1, 0xEu);
  sub_1000726A0();
}

void sub_1006EA7A0(void *a1, uint64_t a2, NSObject *a3)
{
  *(_DWORD *)a2 = 138543362;
  *(_QWORD *)(a2 + 4) = a1;
  sub_100072744((void *)&_mh_execute_header, a3, (uint64_t)a3, "Classic devices doesn't exist for %{public}@", (uint8_t *)a2);

}

void sub_1006EA7EC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1003D7FDC();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "No service UUID exist for classic PSM: 0x%x", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EA84C(const unsigned __int8 *a1, NSObject *a2)
{
  uint64_t v3;
  void **v4;
  void *__p[2];
  char v6;
  int v7;
  void **v8;

  sub_1003D2DB4(a1, __p);
  if (v6 >= 0)
    v4 = __p;
  else
    v4 = (void **)__p[0];
  v7 = 136446210;
  v8 = v4;
  sub_100072744((void *)&_mh_execute_header, a2, v3, "Already connected to device %{public}s", (uint8_t *)&v7);
  if (v6 < 0)
    operator delete(__p[0]);
}

void sub_1006EA8F8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007280C((void *)&_mh_execute_header, v0, v1, "psm cannot be 0", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EA924(NSObject *a1)
{
  uint64_t v2;
  int v3;
  void *v4;

  v3 = 136446210;
  v4 = sub_100054494();
  sub_100072744((void *)&_mh_execute_header, a1, v2, "%{public}s", (uint8_t *)&v3);
  sub_100072694();
}

void sub_1006EA99C()
{
  uint64_t v0;
  os_log_t v1;
  int v2;
  int v3;

  sub_1003D7FC4();
  sub_1002A8220((void *)&_mh_execute_header, v0, v1, "Could not find a session, endpoint or pipe for cid:%d PSM:%d", v2, v3);
  sub_1000726A0();
}

void sub_1006EAA04()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "LE_L2CAP_Accept failed with status %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EAA64(_DWORD *a1, NSObject *a2)
{
  uint64_t v3;
  int v4;
  uint64_t v5;

  v4 = 134217984;
  v5 = sub_10019AFA0(a1);
  sub_100072744((void *)&_mh_execute_header, a2, v3, "Connection manager wasn't tracking a device for connection handle %p!", (uint8_t *)&v4);
  sub_100072694();
}

void sub_1006EAAE0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1003D7FDC();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Could not find a session, endpoint or pipe for cid:%d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EAB40()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "L2CAP Channel connect failure %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EABA0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Can't find service UUID associated with psm:0x%x", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EAC00()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "A2DP callback registration failed with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EAC60()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "A2DP callback deregistration failed with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EACC0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1003D7FDC();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "No device was found for a2dpHandle %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EAD20()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to connect - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EAD80(uint64_t a1, NSObject *a2)
{
  uint64_t v3;
  void **v4;
  void *__p[2];
  char v6;
  int v7;
  void **v8;

  sub_10043E5F8(a1, __p);
  if (v6 >= 0)
    v4 = __p;
  else
    v4 = (void **)__p[0];
  v7 = 136446210;
  v8 = v4;
  sub_100072744((void *)&_mh_execute_header, a2, v3, "Audio sink service not supported by device %{public}s", (uint8_t *)&v7);
  if (v6 < 0)
    operator delete(__p[0]);
}

void sub_1006EAE2C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Attempting to disconnect from invalid device", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EAE58()
{
  uint64_t v0;
  _QWORD *v1;
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint8_t *v5;
  NSObject *v6;

  sub_1002A8288();
  sub_10007284C(v1, v2, v3, 4.8752e-34);
  sub_1002A827C((void *)&_mh_execute_header, v6, v4, "Failed to disconnect A2DP profile from device %{public}s with result %{bluetooth:OI_STATUS}u", v5);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006EAEA0()
{
  uint64_t v0;
  _QWORD *v1;
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint8_t *v5;
  NSObject *v6;

  sub_1002A8288();
  sub_10007284C(v1, v2, v3, 4.8752e-34);
  sub_1002A827C((void *)&_mh_execute_header, v6, v4, "Failed to close the streaming channel from device %{public}s with result %{bluetooth:OI_STATUS}u", v5);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006EAEE8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1003D7FDC();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "No audio device was found for a2dpHandle %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EAF48()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to find AVDTP version", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EAF74()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "No a2dpHandle found for streamHandle %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EAFD4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_1000727FC((void *)&_mh_execute_header, v0, v1, "isStreamingAudioToDevice: Unable to retrieve handle for device.", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EB000()
{
  os_log_t v0;
  uint8_t v1[8];

  sub_1002BC094();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "isStreamingAudioToDevice: Non-null A2DPAudioDevice retrieved. Streaming State: %d", v1, 8u);
  sub_10007266C();
}

void sub_1006EB070()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_1000727FC((void *)&_mh_execute_header, v0, v1, "isStreamingAudioToDevice: Non-zero handle retrieved.", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EB09C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to start streaming as stream handle was null", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EB0C8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to start streaming as device was null", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EB0F4(uint64_t *a1, NSObject *a2, uint64_t a3)
{
  uint64_t v3;
  int v4;
  uint64_t v5;

  v3 = *a1;
  v4 = 134217984;
  v5 = v3;
  sub_100072744((void *)&_mh_execute_header, a2, a3, "Invalid sampling rate %f for acoustic tuning", (uint8_t *)&v4);
  sub_1000726A0();
}

void sub_1006EB160()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[10];
  uint64_t v3;

  sub_1003ED724();
  v3 = 2000;
  sub_1002A827C((void *)&_mh_execute_header, v0, v1, "Failed to suspend A2DP stream with result %{bluetooth:OI_STATUS}u - trying again in %llu seconds", v2);
  sub_1000726A0();
}

void sub_1006EB1CC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to suspend stream with result - %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EB22C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to start streaming with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EB28C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "OI_HCI_ReadClock failed: returned %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EB2EC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Streaming state is pending response, can't call avdtp start multiple times", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EB318()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8751e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "Failed to find compatible stream configuration for device %{public}s - disconnecting", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006EB364()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to set stream configuration with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EB3C4(_BYTE *a1, NSObject *a2)
{
  const char *v2;
  int v3;
  const char *v4;

  if (*a1)
    v2 = "On";
  else
    v2 = "Off";
  v3 = 136315138;
  v4 = v2;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "Publish AccessHeadTrack to BTHAL: %s", (uint8_t *)&v3, 0xCu);
  sub_1000726A0();
}

void sub_1006EB450()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "AVDTP send error %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EB4B0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Fail to dequeue head: status %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EB510()
{
  uint64_t v0;
  NSObject *v1;
  uint8_t v2[10];
  uint64_t v3;

  sub_1003ED724();
  v3 = v0;
  sub_1002A827C((void *)&_mh_execute_header, v1, (uint64_t)v1, "A2DP packet flushed: Audio Queue full, remove oldest and insert sequence=%d (latest), timestamp=%llu", v2);
  sub_1000726A0();
}

void sub_1006EB57C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to discover stream endpoints with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EB5DC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to accept connection attempt - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EB63C()
{
  uint64_t v0;
  _QWORD *v1;
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint8_t *v5;
  NSObject *v6;

  sub_1002A8288();
  sub_1002F7630(v1, v2, v3, 1.5047e-36);
  sub_1002A827C((void *)&_mh_execute_header, v6, v4, "SDP query failed with error %d, aborting A2DP setup to %{public}s", v5);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006EB684()
{
  uint64_t v0;
  _QWORD *v1;
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint8_t *v5;
  NSObject *v6;

  sub_1002A8288();
  sub_10007284C(v1, v2, v3, 4.8752e-34);
  sub_1002A827C((void *)&_mh_execute_header, v6, v4, "Failed to lookup AVDTP handle for device %{public}s with status %{bluetooth:OI_STATUS}u", v5);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006EB6CC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006EB73C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006EB7AC()
{
  uint64_t v0;
  _QWORD *v1;
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint8_t *v5;
  NSObject *v6;

  sub_1002A8288();
  sub_10007284C(v1, v2, v3, 4.8752e-34);
  sub_1002A827C((void *)&_mh_execute_header, v6, v4, "Connection to device %{public}s failed - result was %{bluetooth:OI_STATUS}u", v5);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006EB7F4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Bad48KHzCodecs: Cannot set user defined A2DP Sample Rate for our endpoints to %d Hz", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EB854()
{
  os_log_t v0;
  uint8_t v1[16];

  sub_10009720C();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "No A2DP Handle found", v1, 2u);
  sub_10007266C();
}

void sub_1006EB88C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8751e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "Couldn't find any valid stream endpoint IDs for device %{public}s - disconnecting", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006EB8D8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to get all capabilities with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EB938()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to get capabilities with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EB998(uint64_t a1, int a2)
{
  NSObject *v2;
  uint8_t *v3;

  *(_QWORD *)(sub_1003ED6D4(a1, a2, 1.5047e-36) + 10) = "null";
  sub_1002A827C((void *)&_mh_execute_header, v2, (uint64_t)v2, "Received endpoint discovery failure with result %d on device %{public}s", v3);
}

void sub_1006EB9DC()
{
  uint64_t v0;
  _QWORD *v1;
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint8_t *v5;
  NSObject *v6;

  sub_1002A8288();
  sub_1002F7630(v1, v2, v3, 1.5047e-36);
  sub_1002A827C((void *)&_mh_execute_header, v6, v4, "Received endpoint discovery failure with result %d on device %{public}s", v5);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006EBA24()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to accept stream configuration with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EBA84()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to reject stream configuration with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EBAE4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1003D7FDC();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Rejecting the suggested stream configuration from a2dpHandle %d as we were unable to select it", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EBB44()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Device has gone away, skipping setting config", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EBB70()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to open stream with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EBBD0(uint64_t a1, int a2)
{
  NSObject *v2;
  uint8_t *v3;

  *(_QWORD *)(sub_1003ED6D4(a1, a2, 1.5047e-36) + 10) = "null";
  sub_1002A827C((void *)&_mh_execute_header, v2, (uint64_t)v2, "Received set stream configuration failure with result %u on device %{public}s", v3);
}

void sub_1006EBC14()
{
  uint64_t v0;
  _QWORD *v1;
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint8_t *v5;
  NSObject *v6;

  sub_1002A8288();
  sub_1002F7630(v1, v2, v3, 1.5047e-36);
  sub_1002A827C((void *)&_mh_execute_header, v6, v4, "Received set stream configuration failure with result %u on device %{public}s", v5);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006EBC5C(uint64_t a1, int a2)
{
  NSObject *v2;
  uint8_t *v3;

  *(_QWORD *)(sub_1003ED6D4(a1, a2, 1.5047e-36) + 10) = "null";
  sub_1002A827C((void *)&_mh_execute_header, v2, (uint64_t)v2, "Received get configuration failure with result %u on device %{public}s", v3);
}

void sub_1006EBCA0()
{
  uint64_t v0;
  _QWORD *v1;
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint8_t *v5;
  NSObject *v6;

  sub_1002A8288();
  sub_1002F7630(v1, v2, v3, 1.5047e-36);
  sub_1002A827C((void *)&_mh_execute_header, v6, v4, "Received get configuration failure with result %u on device %{public}s", v5);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006EBCE8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to accept stream open command with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EBD48()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8751e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "A disconnection is pending for device %{public}s -- disconnecting", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006EBD94()
{
  uint64_t v0;
  _QWORD *v1;
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint8_t *v5;
  NSObject *v6;

  sub_1002A8288();
  sub_1002F7630(v1, v2, v3, 1.5047e-36);
  sub_1002A827C((void *)&_mh_execute_header, v6, v4, "Failed to open streaming channel failure with result %u on device %{public}s", v5);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006EBDDC(uint64_t a1, int a2)
{
  NSObject *v2;
  uint8_t *v3;

  *(_QWORD *)(sub_1003ED6D4(a1, a2, 1.5047e-36) + 10) = "null";
  sub_1002A827C((void *)&_mh_execute_header, v2, (uint64_t)v2, "Failed to open streaming channel failure with result %u on device %{public}s", v3);
}

void sub_1006EBE20()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Wireless Splitter not able to locate last connected audio device", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EBE4C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Wireless Splitter device object is gone..", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EBE78()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to send security control response with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EBED8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed send start response with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EBF38()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Invalid handles were passed from the stack", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EBF64()
{
  uint64_t v0;
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t *v5;
  NSObject *v6;

  sub_1003ED70C();
  sub_1003ED6E8(1.5047e-36, v1, v2, v3);
  sub_1002A827C((void *)&_mh_execute_header, v6, v4, "Failed to start streaming procedure with result %u on device %{public}s - disconnecting", v5);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006EBFAC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC094();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Start failed, no handles, error=%{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EC010()
{
  uint64_t v0;
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t *v5;
  NSObject *v6;

  sub_1003ED70C();
  sub_1003ED6E8(1.5047e-36, v1, v2, v3);
  sub_1002A827C((void *)&_mh_execute_header, v6, v4, "Failed to suspend stream with result %u on device %{public}s, initiate device disconnection", v5);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006EC058()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "TransitionCfm - invalid handles were passed from the stack", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EC084()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to send reconfigure response with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EC0E4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Received abort stream request after device disconnected", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EC110()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Received delay report on handle %d for a device that is already disconnected", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EC170()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Dynamic Latency incorrect dynamicLatencyJitterBuffer value", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EC19C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Dynamic Latency controller flush timeout failed with with error %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EC1FC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Adaptive Latency controller flush timeout failed with with error %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EC25C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Piconet clock read error %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EC2BC()
{
  uint64_t v0;
  NSObject *v1;
  uint8_t v2[8];
  __int16 v3;
  uint64_t v4;

  sub_1002BC094();
  v3 = 2048;
  v4 = v0;
  sub_1002A827C((void *)&_mh_execute_header, v1, (uint64_t)v1, "A2DP packet flushed: L2CAP (chip) flush occured. Current sequence=%d, timestamp=%llu", v2);
  sub_1000726A0();
}

void sub_1006EC334()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "listenModeSupport is null, returning with error BT_ERROR_INVALID_ARGUMENT", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EC360()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to configure Software Volume error %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EC3C0(int a1, NSObject *a2, uint64_t a3)
{
  _DWORD v3[2];
  __int16 v4;
  int v5;

  v3[0] = 67109376;
  v3[1] = 500;
  v4 = 1024;
  v5 = a1;
  sub_1002A8234((void *)&_mh_execute_header, a2, a3, "Failed to configure jitter buffer to 0x%x with error %{bluetooth:OI_STATUS}u", (uint8_t *)v3);
  sub_1000726A0();
}

void sub_1006EC438()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1003D7FDC();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "setAllowsAutoRoute find audio device handle failed %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EC498()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1003D7FDC();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "setAudioRouteHidden find audio device handle failed %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EC4F8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1003D7FDC();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "setHijackAudioRoute Failed to find audio device with hanlde %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EC558()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1003D7FDC();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "setTipiConnection Failed to find audio device with handle %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EC5B8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1003D7FDC();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "setUserSelectedDeviceType Failed to find audio device with handle %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EC618()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC094();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Audio Timesync: Audio delivery failed: %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EC67C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to send volume ramp end message device is null", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EC6A8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to send volume ramp end message error %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EC708()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to send manual volume update message device is null", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EC734()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to send manual volume update message error %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EC794()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Spatial Audio Mode: invalid device", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EC7C0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to configure PME On Buds error %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EC820()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Device disconnected in dispatched audioErrorNeedsDisconnect", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EC84C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8751e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "Detected error from the plugin, disconnecting audio device %{public}s", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006EC898()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Could not transition given stream state:%d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EC8F8()
{
  int v0;
  NSObject *v1;
  uint8_t v2[8];
  __int16 v3;
  int v4;

  sub_1002BC094();
  v3 = 1024;
  v4 = v0;
  sub_1002A8234((void *)&_mh_execute_header, v1, (uint64_t)v1, "Failed to configure jitter buffer to 0x%x with error %{bluetooth:OI_STATUS}u", v2);
  sub_1000726A0();
}

void sub_1006EC970()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1003D7FDC();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Dynamic Latency audio / device object does not exist for handle %d ", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EC9D0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Adaptive Latency adaptiveLatencyAudioModification invalid device", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EC9FC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "initA2DPFastConnect error creating A2DP media", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ECA28()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "composeA2DPDescriptor out of memory", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ECA54()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "composeA2DPDescriptor error getting media L2CAP data", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ECA80()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "composeA2DPDescriptor error getting signaling L2CAP data", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ECAAC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "composeA2DPDescriptor endpoints error", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ECAD8(_BYTE *a1, _BYTE *a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_100262274(a1, a2);
  sub_100072750((void *)&_mh_execute_header, v2, (uint64_t)v2, "parseA2DPDescriptor L2CAP signal channel not found", v3);
}

void sub_1006ECB04()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "parseA2DPEndpoints - No endpoints in descriptor", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ECB30()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "parseA2DPEndpoints - Error allocating Discovery Rsp Info", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ECB5C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "parseA2DPEndpoints Error Endpoint Info contains extra %d bytes", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ECBBC(_BYTE *a1, _BYTE *a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_100262274(a1, a2);
  sub_100072750((void *)&_mh_execute_header, v2, (uint64_t)v2, "parseA2DPEndpoints Endpoint Caps Parse ERROR", v3);
}

void sub_1006ECBE8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC094();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "parseA2DPEndpoints - Error Finding A2DP Handle for CID  %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ECC4C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "SelectStreamConfigFastConnect Invalid stream state %d, cannot select stream config unless in CONNECTING or INVALID state", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ECCAC()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8751e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "SelectStreamConfigFastConnectFailed to find compatible stream configuration for device %{public}s - disconnecting", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006ECCF8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "SelectStreamConfigFastConnect Failed to set stream configuration with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ECD58(uint64_t a1, NSObject *a2, uint64_t a3)
{
  *(_DWORD *)a1 = 136446210;
  *(_QWORD *)(a1 + 4) = "null";
  sub_100072744((void *)&_mh_execute_header, a2, a3, "fastConnectA2DPSetupComplete Failed to open streaming channel failure on device %{public}s", (uint8_t *)a1);
}

void sub_1006ECD98()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8751e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "fastConnectA2DPSetupComplete Failed to open streaming channel failure on device %{public}s", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006ECDE4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC094();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "No audio device was found for a2dpHandle %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ECE48()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to read BT clock", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ECE74()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to create DIS UDI For Medical Devices value!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ECEA0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to create DIS PNP ID value!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ECECC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to create DIS Regulatory data value!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ECEF8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to create DIS System ID value!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ECF24()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to create DIS SW Revision value!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ECF50()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to create DIS FW Revision value!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ECF7C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to create DIS HW Revision value!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ECFA8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to create DIS Serial Number value!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ECFD4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to create DIS Model Number Name value!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ED000()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to create DIS MFGR Name value!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ED02C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to create product type number value!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ED058()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to create manufacturer name value!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ED084()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to create GAP device name value!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ED0B0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007280C((void *)&_mh_execute_header, v0, v1, "GattServer expects that it's always GAP, followed by GATT!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ED0DC(char a1, NSObject *a2, uint64_t a3)
{
  const char *v3;
  int v4;
  const char *v5;

  v3 = "GATT";
  if ((a1 & 1) != 0)
    v3 = "GAP";
  v4 = 136446210;
  v5 = v3;
  sub_100072744((void *)&_mh_execute_header, a2, a3, "Failed to publish %{public}s service!", (uint8_t *)&v4);
  sub_1000726A0();
}

void sub_1006ED15C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to initialize GATT database!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ED188()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "dummy DIS already published, cannot register a new one", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ED1B4()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8751e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "Application is trying to publish a characteristic value with reserved UUID %{public}s", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006ED200()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to add characteristic descriptor with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ED260()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to add characteristic with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ED2C0(char a1, NSObject *a2, uint64_t a3)
{
  const char *v3;
  int v4;
  const char *v5;

  v3 = "notify";
  if ((a1 & 0x10) == 0)
    v3 = "indicate";
  v4 = 136446210;
  v5 = v3;
  sub_100072744((void *)&_mh_execute_header, a2, a3, "Characteristic set for %{public}s without client configuration descriptor!", (uint8_t *)&v4);
  sub_1000726A0();
}

void sub_1006ED340()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Characteristic set for broadcast without server configuration descriptor!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ED36C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Characteristic set for extended property without extended property descriptor!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ED398()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Duplicate User Description descriptor found!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ED3C4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Duplicate Presentation Format descriptor found!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ED3F0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Cached characteristics cannot have any write permissions!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ED41C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Cached characteristics cannot have any properties other than \"read-only\"!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ED448()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Can't register an included service that references an unknown service!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ED474()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to add included service with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ED4D4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to add service with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ED534(int *a1, NSObject *a2)
{
  int v2;
  _DWORD v3[2];

  v2 = *a1;
  v3[0] = 67109120;
  v3[1] = v2;
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Couldn't find service attribute with ID 0x%x!", (uint8_t *)v3, 8u);
  sub_10007266C();
}

void sub_1006ED5A8(uint64_t *a1, uint64_t a2, int a3, NSObject *a4)
{
  uint64_t *v5;

  if (*((char *)a1 + 23) >= 0)
    v5 = a1;
  else
    v5 = (uint64_t *)*a1;
  *(_DWORD *)a2 = 136446466;
  *(_QWORD *)(a2 + 4) = v5;
  *(_WORD *)(a2 + 12) = 1024;
  *(_DWORD *)(a2 + 14) = a3;
  sub_1002F7654((void *)&_mh_execute_header, "Failed to re-publish service %{public}s with result %d!", (uint8_t *)a2, a4);
  if (*((char *)a1 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006ED614(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "Transaction %d not in pending transaction map - probably timed out!", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006ED67C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "Unable to find error attribute with ID 0x%x!", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006ED6E4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Unable to find characteristic with ID 0x%x!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ED744()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8751e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "Unable to find Client Characteristic Configuration Descriptor for %{public}s!", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006ED790()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8751e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "No subscribed devices for %{public}s!", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006ED7DC()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8751e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "Ignoring update for session \"%{public}s\" as there is already one queued", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006ED828(uint8_t *buf, _BYTE *a2, os_log_t log)
{
  *buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Client config went away while waiting to send update!", buf, 2u);
}

void sub_1006ED864()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Transaction %d not in pending transaction map!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ED8C4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Transaction %d timed out waiting on response", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ED924()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Session not found in fDeviceSessions", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006ED950(uint64_t a1, NSObject *a2)
{
  int v2;
  const char *v3;
  __int16 v4;
  uint64_t v5;

  v2 = 136315394;
  v3 = "indicationConfirmed";
  v4 = 2114;
  v5 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "%s - Unexpected Response - Device:%{public}@", (uint8_t *)&v2, 0x16u);
  sub_1000726A0();
}

void sub_1006ED9D4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Connection doesn't have any prepared writes queued!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EDA00()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Denying value read as characteristic is not readable!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EDA2C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007280C((void *)&_mh_execute_header, v0, v1, "GATT/GAP service data should always be cached!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EDA58()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Couldn't find attribute!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EDA84()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Denying value write as characteristic is not writeable!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EDAB0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Refusing Prepare Write Request as no \"reliable write\" extended property was specified for this characteristic", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EDADC(uint64_t a1, uint64_t a2, uint64_t a3, NSObject *a4)
{
  *(_DWORD *)a3 = 67109376;
  *(_DWORD *)(a3 + 4) = 512;
  *(_WORD *)(a3 + 8) = 2048;
  *(_QWORD *)(a3 + 10) = a1 + a2 - 512;
  sub_1002F7654((void *)&_mh_execute_header, "Refusing Prepare Write Request as it would exceed the maximum amount of data queued (%u) for this connection by %lu byte(s)", (uint8_t *)a3, a4);
}

void sub_1006EDB30()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Refusing Prepare Write Request as the service doesn't match the other requests in the queue", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EDB5C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Refusing Prepare Write Request to configuration descriptor", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EDB88(uint64_t a1, NSObject *a2, uint64_t a3)
{
  int v3;
  uint64_t v4;

  v3 = 136446210;
  v4 = a1;
  sub_100072744((void *)&_mh_execute_header, a2, a3, "Not allowed to set configuration descriptor to \"%{public}s\"", (uint8_t *)&v3);
  sub_1000726A0();
}

void sub_1006EDBF0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Denying partial write to configuration descriptor (are you kidding me?)", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EDC1C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "GattServer, ATT db is NULL!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EDC48(os_log_t log)
{
  int v1;
  const char *v2;

  v1 = 136446210;
  v2 = "deviceItr == fDeviceSessions.end()";
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", (uint8_t *)&v1, 0xCu);
  sub_1000726A0();
}

void sub_1006EDCC4(uint64_t a1, NSObject *a2, uint64_t a3)
{
  int v3;
  uint64_t v4;

  v3 = 138543362;
  v4 = a1;
  sub_100072744((void *)&_mh_execute_header, a2, a3, "GattServer disconnected but cannot find session for device \"%{public}@\"", (uint8_t *)&v3);
  sub_1000726A0();
}

void sub_1006EDD2C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100410044(__stack_chk_guard);
  sub_100410038();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "%{public}@ is NOT in the allowed CBCentralSession list for scanning. Please file a radar for CoreBluetooth - Framework Onboarding | All component.", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006EDD8C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100410050(__stack_chk_guard);
  sub_100410038();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "%{public}@ does not provide CBUseCase in scanForPeripheralsWithServices.", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006EDDEC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100410044(__stack_chk_guard);
  sub_100410038();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "%{public}@ is in the allowed CBCentralSession list for scanning.", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006EDE4C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "Failed to write CL Raw Data with result %d", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006EDEB0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "CL is not ready yet for device %{public}@", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006EDF10(uint64_t *a1, uint64_t a2, uint64_t a3, NSObject *a4)
{
  uint64_t *v5;

  if (*((char *)a1 + 23) >= 0)
    v5 = a1;
  else
    v5 = (uint64_t *)*a1;
  *(_DWORD *)a3 = 136446466;
  *(_QWORD *)(a3 + 4) = v5;
  *(_WORD *)(a3 + 12) = 2114;
  *(_QWORD *)(a3 + 14) = a2;
  sub_10026A55C((void *)&_mh_execute_header, a4, a3, "%{public}s can't send data to %{public}@ since its not connected", (uint8_t *)a3);
  if (*((char *)a1 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006EDF80()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "IRK needs to be 16 bytes", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EDFAC(uint64_t a1, uint64_t *a2, uint64_t a3, NSObject *a4)
{
  uint64_t *v5;

  if (*((char *)a2 + 23) >= 0)
    v5 = a2;
  else
    v5 = (uint64_t *)*a2;
  *(_DWORD *)a3 = 138543618;
  *(_QWORD *)(a3 + 4) = a1;
  *(_WORD *)(a3 + 12) = 2082;
  *(_QWORD *)(a3 + 14) = v5;
  sub_10026A55C((void *)&_mh_execute_header, a4, a3, "Device \"%{public}@\" for session \"%{public}s\" is disconnecting, lets wait for it to disconnect and try again", (uint8_t *)a3);
  if (*((char *)a2 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006EE01C(char a1, NSObject *a2)
{
  _DWORD v2[2];

  v2[0] = 67109120;
  v2[1] = a1 & 1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "Skipping Built In Service Detection Status %d", (uint8_t *)v2, 8u);
  sub_10007266C();
}

void sub_1006EE090()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100410050(__stack_chk_guard);
  sub_100410038();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "Device \"%{public}@\" is already connected with no GATT support, cannot enable GATT for this connection", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006EE0F0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Ignoring delayed connection for application that does not support backgrounding", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EE11C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100410044(__stack_chk_guard);
  sub_100410038();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "%{public}@ is NOT in the allowed CBCentralSession list for connection.", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006EE17C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100410050(__stack_chk_guard);
  sub_100410038();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "%{public}@ does not provide CBUseCase in connectPeripheral.", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006EE1DC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100410044(__stack_chk_guard);
  sub_100410038();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "%{public}@ is in the allowed CBCentralSession list for connection.", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006EE23C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "setupDeviceConnectionPriority could not find a valid use case, we should not be here, file a bug to Bluetooth new bugs | iOS !", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EE268()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "External Lock devices got wrong tag HasTS", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EE294()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "Forcing disconnection of device \"%{public}@\"", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006EE2F4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Invalid device", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EE320(char a1, uint64_t a2, os_log_t log)
{
  int v3;
  _DWORD v4[2];
  __int16 v5;
  int v6;

  v3 = *(unsigned __int8 *)(*(_QWORD *)a2 + 304);
  v4[0] = 67109376;
  v4[1] = a1 & 1;
  v5 = 1024;
  v6 = v3;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "moreAvailable=%d, isFromADVBuffer=%d", (uint8_t *)v4, 0xEu);
  sub_1000726A0();
}

void sub_1006EE3AC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "Session cannot access device %@ because of Manufacturer data", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006EE40C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "Session cannot access device %@ because of service data", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006EE46C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "Session cannot access device %@ because of hashed service UUID", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006EE4CC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "Session cannot access device %@ because of service UUID", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006EE52C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "Session cannot access device %@", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006EE58C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "Could not find a device address for device %{public}@", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006EE5EC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "RestoreFromData - Central - NSKeyedUnarchiver Error:%{public}@", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006EE64C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to unarchive bundleIdentifier or restoration identifier", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EE678()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Bad restore connect peripherals item (non-data)", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EE6A4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Bad restore connect peripherals type (non-set)", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EE6D0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Inconsistent scanning state of restored session", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EE6FC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Bad restore scan service item (non-data)", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EE728()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Bad restore scan service type (non-set)", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EE754()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100410044(__stack_chk_guard);
  sub_100410038();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "%@ is not pending continueAfterRestore", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006EE7B4()
{
  NSObject *v0;
  uint8_t v1[24];

  sub_1002A8240();
  sub_10026A55C((void *)&_mh_execute_header, v0, (uint64_t)v0, "canSessionScanForService %@ %@", v1);
  sub_1000726A0();
}

void sub_1006EE820()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "FastLEConnection:CBCentralSession::enableFastLeConnectionWithDataToDevice invalid version specified", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EE84C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "FastLEConnection:CBCentralSession::enableFastLeConnectionWithDataToDevice enabling using setControllerInfoForDevice returned %d", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006EE8B0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a1, a3, "FastLEConnection:CBCentralSession::enableFastLeConnectionWithDataToDevice reached limit of up to %d devices for this SPI", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006EE91C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "FastLEConnection:CBCentralSession::enableFastLeConnectionWithDataToDevice invalid data specified", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EE948()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "FastLEConnection:CBCentralSession::enableFastLeConnectionWithDataToDevice device already has Fast LE Connection enabled from another source", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EE974(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "FastLEConnection:CBCentralSession::enableFastLeConnectionWithDataToDevice disabling using setControllerInfoForDevice returned %d", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006EE9D8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "FastLEConnection:CBCentralSession::enableFastLeConnectionWithDataToDevice cannot disable Fast LE Connection to a device this session never enabled", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EEA04()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "FastLEConnection:CBCentralSession::enableFastLeConnectionWithDataToDevice Fast LE Connection with no LTK is unsupported", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EEA30()
{
  uint64_t v0;
  os_log_t v1;
  uint8_t v2[12];
  __int16 v3;
  uint64_t v4;

  sub_100410044(__stack_chk_guard);
  sub_100410038();
  v3 = 2114;
  v4 = v0;
  _os_log_debug_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEBUG, "session %{public}@ device %{public}@ evicted", v2, 0x16u);
  sub_1000726A0();
}

void sub_1006EEAAC(unsigned __int16 a1, uint64_t *a2, uint8_t *buf, os_log_t log)
{
  uint64_t *v5;

  if (*((char *)a2 + 23) >= 0)
    v5 = a2;
  else
    v5 = (uint64_t *)*a2;
  *(_DWORD *)buf = 67109378;
  *((_DWORD *)buf + 1) = a1;
  *((_WORD *)buf + 4) = 2082;
  *(_QWORD *)(buf + 10) = v5;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Couldn't find service ID 0x%x for session \"%{public}s\"", buf, 0x12u);
  if (*((char *)a2 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006EEB28()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100410044(__stack_chk_guard);
  sub_100410038();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "%{public}@ is NOT in the allowed CBPeripheralSession list for advertising. Please file a radar for CoreBluetooth - Framework Onboarding | All component.", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006EEB88(uint64_t a1, NSObject *a2)
{
  void **v3;
  void *__p[2];
  char v5;
  uint8_t buf[4];
  void **v7;

  sub_1000340DC(a1, (uint64_t)__p);
  if (v5 >= 0)
    v3 = __p;
  else
    v3 = (void **)__p[0];
  *(_DWORD *)buf = 136446210;
  v7 = v3;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Failed to start advertising as session \"%{public}s\" is already advertising!", buf, 0xCu);
  if (v5 < 0)
    operator delete(__p[0]);
}

void sub_1006EEC3C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100410050(__stack_chk_guard);
  sub_100410038();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "%{public}@ does not provide CBUseCase in startAdvertising.", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006EEC9C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100410044(__stack_chk_guard);
  sub_100410038();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "%{public}@ is in the allowed CBPeripheralSession list for advertising.", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006EECFC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_100072684((void *)&_mh_execute_header, v0, v1, "RestoreFromData - Peripheral - NSKeyedUnarchiver Error:%{public}@", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006EED5C(os_log_t log)
{
  uint8_t v1[16];

  *(_WORD *)v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Must specify both a key and a value", v1, 2u);
}

void sub_1006EED9C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "Failed to generate LTK with result %{bluetooth:OI_STATUS}u", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006EEE00(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "Failed to generate DIV with result %{bluetooth:OI_STATUS}u", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006EEE64(int a1, NSObject *a2)
{
  _DWORD v2[2];

  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Failed to generate DHK with result %{bluetooth:OI_STATUS}u", (uint8_t *)v2, 8u);
  sub_10007266C();
}

void sub_1006EEED4(os_log_t log)
{
  int v1;
  const char *v2;

  v1 = 136315138;
  v2 = "activate";
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "%s: Network.Framework is not available", (uint8_t *)&v1, 0xCu);
}

void sub_1006EEF54(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "Length of AVDTP Codec Info is too short for Apple Vendor-Specific Codec", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006EEF84()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1004169B8(__stack_chk_guard);
  sub_100072684((void *)&_mh_execute_header, v0, v1, "Invalid stream configuration - no remote config for codec type %s", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006EF034()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_1004169B8(__stack_chk_guard);
  sub_100072684((void *)&_mh_execute_header, v0, v1, "Invalid stream configuration - no local config for codec type %s", v2, v3, v4, v5, 2u);
  sub_1000726A0();
}

void sub_1006EF0E4()
{
  NSObject *v0;
  uint8_t v1[24];

  sub_1002A82B8();
  sub_1002A8234((void *)&_mh_execute_header, v0, (uint64_t)v0, "local sampling rate support 0x%02x, does not match remote 0x%02x", v1);
  sub_1000726A0();
}

void sub_1006EF14C()
{
  NSObject *v0;
  uint8_t v1[24];

  sub_1002A82B8();
  sub_1002A8234((void *)&_mh_execute_header, v0, (uint64_t)v0, "local channel mode support 0x%02x, does not match remote 0x%02x", v1);
  sub_1000726A0();
}

void sub_1006EF1B4()
{
  os_log_t v0;
  uint8_t v1[8];

  sub_1002BC094();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Accepting remote UNKNOWN A2DP codec %x", v1, 8u);
  sub_10007266C();
}

void sub_1006EF224()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC094();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Ignoring sink's SBC Maximum Bitpool Value of %d because it is too low", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EF288(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "Cannot set SBC Bitpool to value specified", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006EF2B8(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "GetPreferredSampleRate: Cannot set user defined A2DP Sample Rate to %d Hz", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006EF31C()
{
  uint64_t v0;
  os_log_t v1;
  uint64_t v2;
  int v3;
  int v4;

  sub_100416964();
  sub_100416988((void *)&_mh_execute_header, v0, v1, "Sink requested AAC_LC max bitrate of %lu outside the range of minimum bitrate %d and platform default of %d. Setting bitrate to platform default.", v2, v3, v4);
  sub_1000726A0();
}

void sub_1006EF37C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC094();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Invalid stream configuration - no remote config for codec type %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EF3E0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1002BC094();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Invalid stream configuration - no local config for codec type %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EF444()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1004169B8(__stack_chk_guard);
  sub_10041699C();
  sub_1002A8234((void *)&_mh_execute_header, v0, v1, "Cannot set AAC-LC bitrate lower than %d kbps. Using default bitrate of %d", v2);
  sub_1000726A0();
}

void sub_1006EF4A8()
{
  uint64_t v0;
  os_log_t v1;
  uint64_t v2;
  int v3;
  int v4;

  sub_100416964();
  sub_100416988((void *)&_mh_execute_header, v0, v1, "Sink max requested AAC-LC bitrate of %lu is outside the range of minimum bitrate %d and platform default of %d. Setting bitrate to platform default.", v2, v3, v4);
  sub_1000726A0();
}

void sub_1006EF508()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1004169B8(__stack_chk_guard);
  sub_10041699C();
  sub_1002A8234((void *)&_mh_execute_header, v0, v1, "Cannot set AAC-ELD bitrate lower than %d kbps. Using default bitrate of %d", v2);
  sub_1000726A0();
}

void sub_1006EF56C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "Found unknown AVDTP codec type 0x%x", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006EF5D0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a1, a3, "Found unknown AVDTP_CODEC_VENDOR_SPECIFIC codec type 0x%x", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006EF63C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to register as an A2DP source with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EF69C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to register local stream endpoint with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EF6FC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to deregister local stream endpoint with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EF75C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to deregister as an A2DP source with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EF7BC()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v0 = sub_10011E980();
  sub_10011E964(v0);
  sub_100072720((void *)&_mh_execute_header, v1, v2, "iconv_open failed: %s", v3, v4, v5, v6, 2u);
  sub_100072694();
}

void sub_1006EF82C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "unexpected pointer arithmetic result", a5, a6, a7, a8, 0);
}

void sub_1006EF860(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "iconv failed, not enough room in output buffer", a5, a6, a7, a8, 0);
}

void sub_1006EF894()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v0 = sub_10011E980();
  sub_10011E964(v0);
  sub_100072720((void *)&_mh_execute_header, v1, v2, "iconv failed with unexpected error: %s", v3, v4, v5, v6, 2u);
  sub_100072694();
}

void sub_1006EF904()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v0 = sub_10011E980();
  sub_10011E964(v0);
  sub_100072720((void *)&_mh_execute_header, v1, v2, "iconv_close failed: %s", v3, v4, v5, v6, 2u);
  sub_100072694();
}

void sub_1006EF974()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_1000727FC((void *)&_mh_execute_header, v0, v1, "IsENADVBuffer Packet", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EF9A0(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a2, a3, "Ignoring invalid service data received from device %@", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006EFA04()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to set address will change callbacks with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EFA64()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to set address change callbacks with result %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EFAC4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_1000727FC((void *)&_mh_execute_header, v0, v1, "ContactTracingManager Power : We're going to sleep!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EFAF0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "refreshCurrentAdvertisingPayload payloadBytesLen:%d or payloadBytes is NULL", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EFB50()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "refreshCurrentAdvertisingPayload encryptAEM failed %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EFBB0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "refreshCurrentAdvertisingPayload getCurrentTEK failed %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EFC10()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "CCRandomGenerateBytes failed: %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EFC70()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to get session from sessionHandle", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EFC9C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to start advertising with result :%d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EFCFC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to start scanning with result :%d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EFD5C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a2, a3, "Failed to create session for exposure notification for %@", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006EFDC0(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a2, a3, "session %@ is already using this manager", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006EFE28()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Exposure Notification is not allowed on this device", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EFE54()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Invalid session", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EFE80(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a2, a3, "Failed to detach session %@", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006EFEE8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to stop advertising with result :%d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EFF48()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to stop scanning with result :%d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006EFFA8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "decryptAEM retrieveTxPowerFromEncryptedEAM failed with error:%d returning attn=0xFF", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F0008(uint8_t *buf, _BYTE *a2, os_log_t log)
{
  *buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Report with invalid RSSI found (127)", buf, 2u);
}

void sub_1006F0044()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "CDContext Framework not available", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F0070()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "accessiblityHeadTrackingChanged no valid device", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F009C(uint64_t a1, NSObject *a2, uint64_t a3)
{
  *(_DWORD *)a1 = 136446210;
  *(_QWORD *)(a1 + 4) = "(NULL)";
  sub_100072744((void *)&_mh_execute_header, a2, a3, "Couldn't find accessory manager for session %{public}s", (uint8_t *)a1);
}

void sub_1006F00DC(char *a1, uint64_t a2, NSObject *a3)
{
  char *v4;

  if (a1[23] >= 0)
    v4 = a1;
  else
    v4 = *(char **)a1;
  *(_DWORD *)a2 = 136446210;
  *(_QWORD *)(a2 + 4) = v4;
  sub_100072744((void *)&_mh_execute_header, a3, (uint64_t)a3, "Couldn't find accessory manager for session %{public}s", (uint8_t *)a2);
  if (a1[23] < 0)
    operator delete(*(void **)a1);
}

void sub_1006F0144(uint64_t a1, uint64_t a2)
{
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  char v22;

  sub_1002A81D4(a1, a2);
  sub_1002A8180();
  sub_100072838((void *)&_mh_execute_header, v2, v3, "Device %{public}s is an unknown accessory", v4, v5, v6, v7, v16, v18, v20, v21, 2u);
  if (v22 < 0)
    sub_1002A81CC(v8, v9, v10, v11, v12, v13, v14, v15, v17, v19);
  sub_1002A81A0();
}

void sub_1006F01C8(uint64_t a1, uint64_t a2)
{
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  char v22;

  sub_1002A81D4(a1, a2);
  sub_1002A8180();
  sub_100072838((void *)&_mh_execute_header, v2, v3, "Device %{public}s is an unknown accessory", v4, v5, v6, v7, v16, v18, v20, v21, 2u);
  if (v22 < 0)
    sub_1002A81CC(v8, v9, v10, v11, v12, v13, v14, v15, v17, v19);
  sub_1002A81A0();
}

void sub_1006F024C(uint64_t a1, uint64_t a2)
{
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  char v22;

  sub_1002A81D4(a1, a2);
  sub_1002A8180();
  sub_100072838((void *)&_mh_execute_header, v2, v3, "Device %{public}s is an unknown accessory", v4, v5, v6, v7, v16, v18, v20, v21, 2u);
  if (v22 < 0)
    sub_1002A81CC(v8, v9, v10, v11, v12, v13, v14, v15, v17, v19);
  sub_1002A81A0();
}

void sub_1006F02CC(int a1, NSObject *a2)
{
  _DWORD v2[2];

  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "sensorStreamingConfigMsgReceived sendToAccessoryEventCallback with result %d", (uint8_t *)v2, 8u);
  sub_10007266C();
}

void sub_1006F033C(int a1, NSObject *a2)
{
  _DWORD v2[2];

  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "remoteStreamUpdate: unknown stream state %d ", (uint8_t *)v2, 8u);
  sub_10007266C();
}

void sub_1006F03AC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Audio Timesync: Cannot enable remote time sync, invalid device", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F03D8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Audio Timesync: not supported Apple Device, return not supported", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F0404()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Audio Timesync: non-Apple Device, return not supported", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F0430()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to get paired devices list", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F045C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Invalid handle(s)", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F0488()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to get accessory manager handle", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F04B4()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  int v7;
  os_log_t v8;
  uint8_t *v9;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_10042ECD8(v2, v6, 7.2225e-34);
  sub_10042ED08((void *)&_mh_execute_header, v7, v8, "Address %{private, mask.hash}s not valid or device has disconnected", v9);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006F04FC()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  int v7;
  os_log_t v8;
  uint8_t *v9;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_10042ECD8(v2, v6, 7.2225e-34);
  sub_10042ED08((void *)&_mh_execute_header, v7, v8, "Failed to get device %{private, mask.hash}s", v9);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006F0544(uint64_t *a1, uint8_t *buf, int a3, os_log_t log)
{
  uint64_t *v5;

  if (*((char *)a1 + 23) >= 0)
    v5 = a1;
  else
    v5 = (uint64_t *)*a1;
  *(_DWORD *)buf = 141558531;
  *(_QWORD *)(buf + 4) = 1752392040;
  *((_WORD *)buf + 6) = 2081;
  *(_QWORD *)(buf + 14) = v5;
  *((_WORD *)buf + 11) = 1024;
  *((_DWORD *)buf + 6) = a3;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Failed to register device %{private, mask.hash}s - result was %d", buf, 0x1Cu);
  if (*((char *)a1 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006F05D0()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  int v7;
  os_log_t v8;
  uint8_t *v9;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_10042ECD8(v2, v6, 7.2225e-34);
  sub_10042ED08((void *)&_mh_execute_header, v7, v8, "Failed to get device handle for device %{private, mask.hash}s", v9);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006F0618()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to get device handle", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F0644()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Invalid argument", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F0670()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Invalid arguments", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F069C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Device not yet first unlocked yet, cannot retrieve capabilities", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F06C8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "TimeSyncEnable: Invalid handle", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F06F4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "TimeSyncEnable: Stack not ready", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F0720()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "TimeSyncEnable: Invalid accessory manager handle", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F074C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "TimeSyncEnable: Invalid role", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F0778()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "TimeSyncEnable: AACP not supported", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F07A4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "TimeSyncEnable: Invalid argument", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F07D0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "TimeSyncEnable: Time Sync not supported", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F07FC(uint64_t a1, NSObject *a2, uint64_t a3)
{
  int v3;
  uint64_t v4;

  v3 = 138412290;
  v4 = a1;
  sub_100072744((void *)&_mh_execute_header, a2, a3, "BTAccessoryManagerGetAccessoryInfo json error: %@", (uint8_t *)&v3);
  sub_1000726A0();
}

void sub_1006F0864(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "Spatial Mode invalid: %u", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006F08C8(uint64_t a1)
{
  int v1;
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  uint8_t v23;

  sub_10042ECF8(a1, __stack_chk_guard, v15);
  sub_1002A8180();
  sub_1002A81E0();
  sub_100072838((void *)&_mh_execute_header, v1, v2, "BTAccessoryManagerGetSpatialAudioPlatformSupport:  \"%{public}s\" Does not support spatial", v3, v4, v5, v6, v16, v18, v20, v21, v23);
  if (v22 < 0)
    sub_1002A81CC(v7, v8, v9, v10, v11, v12, v13, v14, v17, v19);
  sub_1002A81A0();
}

void sub_1006F0940(uint64_t a1)
{
  int v1;
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  uint8_t v23;

  sub_10042ECF8(a1, __stack_chk_guard, v15);
  sub_1002A8180();
  sub_1002A81E0();
  sub_100072838((void *)&_mh_execute_header, v1, v2, "BTAccessoryManagerGetStereoHFPSupport:  \"%{public}s\" supports non-headtracked spatial", v3, v4, v5, v6, v16, v18, v20, v21, v23);
  if (v22 < 0)
    sub_1002A81CC(v7, v8, v9, v10, v11, v12, v13, v14, v17, v19);
  sub_1002A81A0();
}

void sub_1006F09B8(uint64_t a1)
{
  int v1;
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  uint8_t v23;

  sub_10042ECF8(a1, __stack_chk_guard, v15);
  sub_1002A8180();
  sub_1002A81E0();
  sub_100072838((void *)&_mh_execute_header, v1, v2, "BTAccessoryManagerGetStereoHFPSupport:  \"%{public}s\" Does not support spatial", v3, v4, v5, v6, v16, v18, v20, v21, v23);
  if (v22 < 0)
    sub_1002A81CC(v7, v8, v9, v10, v11, v12, v13, v14, v17, v19);
  sub_1002A81A0();
}

void sub_1006F0A30()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Prox Card Status: Prox Card Status not read yet", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F0A5C(uint64_t a1)
{
  int v1;
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  uint8_t v23;

  sub_10042ECF8(a1, __stack_chk_guard, v15);
  sub_1002A8180();
  sub_1002A81E0();
  sub_100072838((void *)&_mh_execute_header, v1, v2, "BTAccessoryManagerGetDeviceSoundProfileSupport:  \"%{public}s\" Does not support Spatial Profile", v3, v4, v5, v6, v16, v18, v20, v21, v23);
  if (v22 < 0)
    sub_1002A81CC(v7, v8, v9, v10, v11, v12, v13, v14, v17, v19);
  sub_1002A81A0();
}

void sub_1006F0AD4(uint64_t a1)
{
  int v1;
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  uint8_t v23;

  sub_10042ECF8(a1, __stack_chk_guard, v15);
  sub_1002A8180();
  sub_1002A81E0();
  sub_100072838((void *)&_mh_execute_header, v1, v2, "BTAccessoryManagerGetDeviceSoundProfileAllowed:  \"%{public}s\" Does not support spatial", v3, v4, v5, v6, v16, v18, v20, v21, v23);
  if (v22 < 0)
    sub_1002A81CC(v7, v8, v9, v10, v11, v12, v13, v14, v17, v19);
  sub_1002A81A0();
}

void sub_1006F0B4C(uint64_t a1)
{
  int v1;
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  uint8_t v23;

  sub_10042ECF8(a1, __stack_chk_guard, v15);
  sub_1002A8180();
  sub_1002A81E0();
  sub_100072838((void *)&_mh_execute_header, v1, v2, "BTAccessoryManagerSetDeviceSoundProfileAllowed:  \"%{public}s\" Does not support spatial", v3, v4, v5, v6, v16, v18, v20, v21, v23);
  if (v22 < 0)
    sub_1002A81CC(v7, v8, v9, v10, v11, v12, v13, v14, v17, v19);
  sub_1002A81A0();
}

void sub_1006F0BC4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BTAccessoryManagerGetAdaptiveLatencyJitterBufferLevel, Device handle not found", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F0BF0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Device not support adaptive latency", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F0C1C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BTAccessoryManagerGetSensorStreamingFrequency - Invalid device handle", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F0C48()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BTAccessoryManagerGetSensorStreamingFrequency - No device for handle", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F0C74()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BTAccessoryManagerGetGyroInformation - Invalid device handle", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F0CA0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BTAccessoryManagerGetGyroInformation - No device for handle", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F0CCC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BTAccessoryManagerGetWirelessSharingSpatial - Invalid device handle", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F0CF8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BTAccessoryManagerGetWirelessSharingSpatial - No device for handle", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F0D24(uint64_t a1, NSObject *a2, uint64_t a3)
{
  int v3;
  uint64_t v4;

  v3 = 138412290;
  v4 = a1;
  sub_100072744((void *)&_mh_execute_header, a2, a3, "BTAccessoryManagerGetCaseSerialNumbersForAppleProductId json error: %@", (uint8_t *)&v3);
  sub_1000726A0();
}

void sub_1006F0D8C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1002F7664((void *)&_mh_execute_header, a2, a3, "BTAccessoryManagerGetCaseSerialNumbersForAppleProductId entered BT API productId %d", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006F0DF4(uint64_t a1, NSObject *a2, uint64_t a3)
{
  int v3;
  uint64_t v4;

  v3 = 138412290;
  v4 = a1;
  sub_100072744((void *)&_mh_execute_header, a2, a3, "BTAccessoryManagerGetCaseSerialNumbersForAppleProductIds json error: %@", (uint8_t *)&v3);
  sub_1000726A0();
}

void sub_1006F0E5C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1002F7664((void *)&_mh_execute_header, a2, a3, "BTAccessoryManagerGetCaseSerialNumbersForAppleProductIds entered BT API numProductIds %u", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006F0EC4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BTAccessoryManagerGetPrimaryBudSide - Invalid device handle", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F0EF0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BTAccessoryManagerGetPrimaryBudSide - No device for handle", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F0F1C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BTAccessoryManagerGetHeadphoneFeatureValue - Invalid device handle", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F0F48()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BTAccessoryManagerGetHeadphoneFeatureValue - No device for handle", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F0F74(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "BTAccessoryManagerGetHeadphoneFeatureValue - Invalid Type: %d", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006F0FD8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BTAccessoryManagerSetHeadphoneFeatureValue - Invalid device handle", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F1004()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BTAccessoryManagerSetHeadphoneFeatureValue - No device for handle", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F1030(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "BTAccessoryManagerSetHeadphoneFeatureValue - Invalid Type: %d", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006F1094()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to register SDP service record - result was %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F10F4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to register RFCOMM server - result was %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F1154(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a1, a3, "Failed to deregister RFCOMM server - result was %d", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006F11C0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Cannot connect to NULL device", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F11EC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "No rfcomm channel found for this profile", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F1218()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Braille connection failed - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F1278(uint64_t a1, uint64_t a2)
{
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  uint64_t v8;
  void *__p;
  void *__pa;
  uint64_t v11;
  uint64_t v12;
  char v13;

  sub_1002A81D4(a1, a2);
  sub_1002A8180();
  sub_100072838((void *)&_mh_execute_header, v2, v3, "Braille service not supported by device %{public}s", v4, v5, v6, v7, v8, (uint64_t)__p, v11, v12, 2u);
  if (v13 < 0)
    operator delete(__pa);
  sub_1002A81A0();
}

void sub_1006F1300()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Error retrieving BD_ADDR from handle - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F1360()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to disconnect - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F13C0(char a1, int a2, os_log_t log)
{
  const char *v3;
  int v4;
  const char *v5;
  __int16 v6;
  int v7;

  v3 = "accept";
  if ((a1 & 1) == 0)
    v3 = "deny";
  v4 = 136315394;
  v5 = v3;
  v6 = 1024;
  v7 = a2;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Failed to %s connection attempt - result was %d", (uint8_t *)&v4, 0x12u);
}

void sub_1006F145C(uint64_t a1, uint64_t a2)
{
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  uint64_t v8;
  void *__p;
  void *__pa;
  uint64_t v11;
  uint64_t v12;
  char v13;

  sub_1002A81D4(a1, a2);
  sub_1002A8180();
  sub_100072838((void *)&_mh_execute_header, v2, v3, "Failed to open serial port for braille connection to device %{public}s", v4, v5, v6, v7, v8, (uint64_t)__p, v11, v12, 2u);
  if (v13 < 0)
    operator delete(__pa);
  sub_1002A81A0();
}

void sub_1006F14E0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Cannot write to NULL device", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F150C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Cannot read from NULL device", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F1538()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to send data to BT device - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F1598()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Invalid write - result was %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F15F8(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "Failed to accept connection attempt - result was %{bluetooth:OI_STATUS}u", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006F165C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "Att device map is invalid", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006F168C(char *a1, uint8_t *buf, int a3, os_log_t log)
{
  char *v5;

  if (a1[23] >= 0)
    v5 = a1;
  else
    v5 = *(char **)a1;
  *(_DWORD *)buf = 136446466;
  *(_QWORD *)(buf + 4) = v5;
  *((_WORD *)buf + 6) = 1024;
  *(_DWORD *)(buf + 14) = a3;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "GATT Failed to disconnect GATT profile from device %{public}s with result %{bluetooth:OI_STATUS}u", buf, 0x12u);
  if (a1[23] < 0)
    operator delete(*(void **)a1);
}

void sub_1006F170C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007265C((void *)&_mh_execute_header, a1, a3, "Not making outgoing CATT connection", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006F173C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072710((void *)&_mh_execute_header, a2, a3, "GATT failed to connect - result was %{bluetooth:OI_STATUS}u", a5, a6, a7, a8, 0);
  sub_10007266C();
}

void sub_1006F17A0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BTDeviceConnectServicesWithParameters Error, BTDeviceConnectServicesWithParameters parameters are invalid", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F17CC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Error, BTDeviceConnectServicesWithParameters setting key failed", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F17F8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BTDeviceConnectServicesWithParameters, BTDeviceConnectNormalMode", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F1824()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Guest Pairing: Cannot pair with mode, feature not enabled", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F1850(char a1, NSObject *a2)
{
  const char *v2;
  int v3;
  const char *v4;

  v2 = "not found.";
  if ((a1 & 1) != 0)
    v2 = "found.";
  v3 = 136315138;
  v4 = v2;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Error, BTDeviceConfigureLinkKey device not found or linkkey %s ", (uint8_t *)&v3, 0xCu);
}

void sub_1006F18DC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Error, BTDeviceIsTemporaryPaired device not found", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F1908()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Error, BTDeviceIsTemporaryPairedNotInContacts device not found", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F1934()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Error, BTDeviceSetHijackAudioRoute device not found", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F1960()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Error, BTDeviceSetACLHighPriority device not found", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F198C(uint8_t *buf, NSObject *a2)
{
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)(buf + 4) = "(NULL)";
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Failed to get default local device for session %{public}s", buf, 0xCu);
}

void sub_1006F19D4(uint64_t a1, uint64_t a2, NSObject *a3)
{
  void **v5;
  void *__p[2];
  char v7;

  sub_1000340DC(a1, (uint64_t)__p);
  if (v7 >= 0)
    v5 = __p;
  else
    v5 = (void **)__p[0];
  *(_DWORD *)a2 = 136446210;
  *(_QWORD *)(a2 + 4) = v5;
  _os_log_error_impl((void *)&_mh_execute_header, a3, OS_LOG_TYPE_ERROR, "Failed to get default local device for session %{public}s", (uint8_t *)a2, 0xCu);
  if (v7 < 0)
    operator delete(__p[0]);
}

void sub_1006F1A64()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Invalid DeviceManager handle", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F1A90()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceRegisterForPowerUpdates - BT_ERROR_INVALID_HANDLE", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F1ABC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceUnregisterForPowerUpdates - BT_ERROR_INVALID_HANDLE", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F1AE8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceReadPowerConsumption - BT_ERROR_INVALID_HANDLE", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F1B14()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceRegisterForPowerProfileStatistics - BT_ERROR_INVALID_HANDLE", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F1B40()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceUnregisterForPowerProfileStatistics - BT_ERROR_INVALID_HANDLE", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F1B6C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceReadPowerProfileStatistics - BT_ERROR_INVALID_HANDLE", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F1B98()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceReadEnhancedPowerProfileStatistics - BT_ERROR_INVALID_HANDLE", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F1BC4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceReadTransportSwitchStatistics - BT_ERROR_INVALID_HANDLE", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F1BF0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceReadDetailedPowerProfileStatistics - BT_ERROR_INVALID_HANDLE", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F1C1C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BTStartHCITraces - BT_ERROR_INVALID_HANDLE", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F1C48()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BTStopHCITraces - BT_ERROR_INVALID_HANDLE", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F1C74()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceShowPowerPrompt - BT_ERROR_INVALID_HANDLE", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F1CA0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceSetAFHMap - BT_ERROR_INVALID_HANDLE", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F1CCC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BTLocalDeviceReadAFHMap - BT_ERROR_INVALID_HANDLE", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F1CF8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BTLQ Cannot get BT Link Quality Data, invalid data", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F1D24()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BTLQ Cannot get BT Link Quality Data, invalid audioLinkManager", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F1D50(uint64_t a1)
{
  void *v2;

  sub_100069BDC(a1 + 56);
  v2 = *(void **)(a1 + 32);
  if (v2)
  {
    *(_QWORD *)(a1 + 40) = v2;
    operator delete(v2);
  }
}

void sub_1006F1D8C(int a1, NSObject *a2)
{
  _DWORD v2[2];

  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Received connection result without a matching attempt for service 0x%08x", (uint8_t *)v2, 8u);
}

void sub_1006F1E00(char *a1, uint8_t *buf, os_log_t log)
{
  char *v4;

  if (a1[23] >= 0)
    v4 = a1;
  else
    v4 = *(char **)a1;
  *(_DWORD *)buf = 136446210;
  *(_QWORD *)(buf + 4) = v4;
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "We got a disconnection result without a previous connection for service %{public}s", buf, 0xCu);
  if (a1[23] < 0)
    operator delete(*(void **)a1);
}

void sub_1006F1E70()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Map settings exist on first pairing!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F1E9C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Identification - build updated wiping secondary hash", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F1EC8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Identification - build updated wiping primary hash", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F1EF4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "System has not passed first unlock. Do not read/write device prefs", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F1F20()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Identification - Failed to read primary hash data from disk", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F1F4C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Identification - System has not passed first unlock, returning", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F1F78()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[10];
  uint64_t v3;

  sub_100457778();
  v3 = 2;
  sub_1002A827C((void *)&_mh_execute_header, v0, v1, "Apple supported feature version size is %d. Expected %lu", v2);
  sub_1000726A0();
}

void sub_1006F1FE4()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[10];
  uint64_t v3;

  sub_100457778();
  v3 = 8;
  sub_1002A827C((void *)&_mh_execute_header, v0, v1, "Apple extended feature ID1 size is %d. Expected %lu", v2);
  sub_1000726A0();
}

void sub_1006F2050()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[10];
  uint64_t v3;

  sub_100457778();
  v3 = 4;
  sub_1002A827C((void *)&_mh_execute_header, v0, v1, "Apple supported feature ID0 size is %d. Expected %lu", v2);
  sub_1000726A0();
}

void sub_1006F20BC(uint64_t a1, NSObject *a2)
{
  uint64_t v3;
  void **v4;
  void *__p[2];
  char v6;
  int v7;
  void **v8;

  sub_10043E5F8(a1, __p);
  if (v6 >= 0)
    v4 = __p;
  else
    v4 = (void **)__p[0];
  v7 = 136446210;
  v8 = v4;
  sub_100072744((void *)&_mh_execute_header, a2, v3, "Invalid operation. Trying to set HIDBehavior for %{public}s", (uint8_t *)&v7);
  if (v6 < 0)
    operator delete(__p[0]);
}

void sub_1006F2164()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  uint8_t *v4;
  uint64_t v5;
  char v6;
  char v7;
  uint64_t v8;

  sub_10007276C();
  if (v6 != v7)
    v8 = v5;
  else
    v8 = v1;
  *(_DWORD *)v2 = 136446210;
  *(_QWORD *)(v2 + 4) = v8;
  sub_100072744((void *)&_mh_execute_header, v3, (uint64_t)v3, "Failed to invoke Single Shot Role Switch WAR for %{public}s", v4);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006F21B4()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  uint8_t *v4;
  uint64_t v5;
  char v6;
  char v7;
  uint64_t v8;

  sub_10007276C();
  if (v6 != v7)
    v8 = v5;
  else
    v8 = v1;
  *(_DWORD *)v2 = 136446210;
  *(_QWORD *)(v2 + 4) = v8;
  sub_100072744((void *)&_mh_execute_header, v3, (uint64_t)v3, "could not write SDP record for device %{public}s", v4);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006F2204()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "System has not passed first unlock (or device prefs not read yet). Do not read/write device prefs", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F2230()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Invalid batteryID: %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F2290()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "BattStatus: Invalid status pointer", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F22BC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Invalid battery level %d provided", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F231C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Identification - class of device is 0, not generating", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F2348()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to write secondary hash to disk", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F2374()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to write primary hash data to disk", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F23A0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to write primary hash to disk", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F23CC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "OI_DEVMGR_GetRemoteSupportedFeatures fails with %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F242C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "HIDIdentification - No name available to make a match", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F2458(uint64_t a1, NSObject *a2, uint64_t a3)
{
  int v3;
  uint64_t v4;

  v3 = 138412290;
  v4 = a1;
  sub_100072744((void *)&_mh_execute_header, a2, a3, "Error APPLE_AUDIO_DEVICE_NAME bad format string: %@", (uint8_t *)&v3);
  sub_1000726A0();
}

void sub_1006F24C0(NSObject *a1, uint64_t a2, uint64_t a3)
{
  int v3;
  const char *v4;

  v3 = 136446210;
  v4 = "static void BT::Device::updateWithCurrentUserGivenName(Device *)_block_invoke";
  sub_100072744((void *)&_mh_execute_header, a1, a3, "Error occured %{public}s while trying to localize the device name with user name", (uint8_t *)&v3);
  sub_1000726A0();
}

void sub_1006F2534(NSObject *a1, uint64_t a2, uint64_t a3)
{
  int v3;
  const char *v4;

  v3 = 136446210;
  v4 = "static void BT::Device::updateWithCurrentUserGivenName(Device *)_block_invoke";
  sub_100072744((void *)&_mh_execute_header, a1, a3, "Error occurred %{public}s users name was returned empty or null", (uint8_t *)&v3);
  sub_1000726A0();
}

void sub_1006F25A8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to read primary hash data from disk", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F25D4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "blockIncomingConnections Failed", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F2600()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "No incoming call to answer", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F262C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "No incoming call to reject", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F2658()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "No active call to disconnect", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F2684()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "No held call to disconnect", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F26B0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "No call to hold or resume", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F26DC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "The TU call doesn't support holding", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F2708()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "The TU calls don't support grouping", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F2734()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "No held and active calls to create a conference", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F2760()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "No call to disconnect", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F278C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "No call to leave the conference", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F27B8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "The TU call doesn't support ungrouping", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F27E4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "The TU call isn't conferenced", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F2810()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to play DMTF tone", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F283C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a2, a3, "Failed to %{public}s EC/NR", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006F28B8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Adding virtual call to unempty call list - this will likely cause call state issues", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F28E4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "A virtual call already exists", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F2910()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "A virtual call doesn't exist", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F293C(uint64_t a1, char a2, os_log_t log)
{
  int v3;
  uint64_t v4;
  __int16 v5;
  int v6;

  v3 = 138412546;
  v4 = a1;
  v5 = 1024;
  v6 = a2 & 1;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Did not find TU call to set Call Screening %@ to value:%d", (uint8_t *)&v3, 0x12u);
  sub_1000726A0();
}

void sub_1006F29C0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Could not get the operator status", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F29EC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Could not get registration status", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F2A18()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Could not get signal strength", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F2A44()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Could not get the subscriber number", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F2A70()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Could not get the IMSI", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F2A9C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Could not get the IMEI", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F2AC8(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100072684((void *)&_mh_execute_header, a2, a3, "Could not get the mobile country code identifier: %@", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006F2B2C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Could not get the Tx state", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F2B58(uint8_t *a1, _BYTE *a2, NSObject *a3)
{
  *a1 = 0;
  *a2 = 0;
  sub_100072750((void *)&_mh_execute_header, a3, (uint64_t)a3, "Invalid Device Address, skip device read", a1);
}

void sub_1006F2B8C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8751e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "Removing Device Support Information for %{public}s", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006F2BD8()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8751e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "Removing Cloud Magic Settings for %{public}s", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006F2C24()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8751e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "Removing Device Record for %{public}s", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006F2C70()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8751e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "Removing Magic pairing device %{public}s from device list failed", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006F2CBC()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8149e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "Cloud asked to unpair, dont easy unpair right now: %s", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006F2D08()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to write magic pairing device information to storage with error %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F2D68()
{
  uint64_t v0;
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_1002F75F8();
  sub_10046E954(v1, v2, v3, 4.8752e-34);
  sub_1002B54E8((void *)&_mh_execute_header, "[MP-] Error removing cloud record for %{public}s with error: %@", v4, v5);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006F2DAC()
{
  uint64_t v0;
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_1002F75F8();
  sub_10046E954(v1, v2, v3, 4.8752e-34);
  sub_1002B54E8((void *)&_mh_execute_header, "[MP-] Error removing new cloud magic settings record for %{public}s with error: %@", v4, v5);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006F2DF0()
{
  uint64_t v0;
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_1002F75F8();
  sub_10046E954(v1, v2, v3, 4.8752e-34);
  sub_1002B54E8((void *)&_mh_execute_header, "[MP-] Error removing Device Support Information for %{public}s with error: %@", v4, v5);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006F2E34()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Cannot reset magic pairing not initialized", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F2E60()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "No magic pairing device to reset", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F2E8C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Cloud main account keys are not available", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F2EB8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to reset AccKeys", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F2EE4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to encrypt fAccHint: %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F2F44()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to encrypt fAccKey: %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F2FA4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Invalid Device Address", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F2FD0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Cloud master accessory key is not available", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F2FFC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to init AccKeys", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F3028()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Cloud master accessory key is not available, dont generate cloudIRK", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F3054()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_10007266C();
}

void sub_1006F30B4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to encrypt fMasterAccKey: %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F3114()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Failed to encrypt fMasterAccHint: %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F3174()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Cloud master IRK is not available so generate it", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F31A0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Update IRK: Invalid Device Address", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F31CC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Update Enc Key: Invalid Device Address", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F31F8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Update Ratchet: Invalid Device Address", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F3224()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Error generating RatchetAccKey: %{bluetooth:OI_STATUS}u", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F3284()
{
  NSObject *v0;
  uint8_t v1[24];

  sub_1002CB84C();
  sub_10026A55C((void *)&_mh_execute_header, v0, (uint64_t)v0, "Keys did not change Cloud keys AccKeyPtr %p, HintPtr %p", v1);
  sub_1000726A0();
}

void sub_1006F32EC()
{
  uint64_t v0;
  os_log_t v1;

  sub_10046E978();
  sub_10046E9A8((void *)&_mh_execute_header, v0, v1, "Keys did not change Cloud keys AccKeyPtr %.16P, HintPtr %.16P");
}

void sub_1006F3350()
{
  NSObject *v0;
  uint8_t v1[24];

  sub_1002CB84C();
  sub_10026A55C((void *)&_mh_execute_header, v0, (uint64_t)v0, "Invalid/Equal keys AccKeyPtr %p, HintPtr %p", v1);
  sub_1000726A0();
}

void sub_1006F33B8()
{
  uint64_t v0;
  os_log_t v1;

  sub_10046E978();
  sub_10046E9A8((void *)&_mh_execute_header, v0, v1, "Invalid/Equal Cloud keys AccKeyPtr %.16P, HintPtr %.16P");
}

void sub_1006F341C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Magic Pairing master keys are available. Let's fetch Magic Paired Devices!", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F3448()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_10007266C();
}

void sub_1006F34A8(uint8_t *a1, _BYTE *a2, NSObject *a3)
{
  *a1 = 0;
  *a2 = 0;
  sub_100072750((void *)&_mh_execute_header, a3, (uint64_t)a3, "Invalid Device Address, Skip Record", a1);
}

void sub_1006F34DC()
{
  uint64_t v0;
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_1002F75F8();
  sub_10046E954(v1, v2, v3, 4.8752e-34);
  sub_1002B54E8((void *)&_mh_execute_header, "[MP] Error removing cloud device, %{public}s with error: %@", v4, v5);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006F3520()
{
  uint64_t v0;
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_1002F75F8();
  sub_10046E954(v1, v2, v3, 4.8752e-34);
  sub_1002B54E8((void *)&_mh_execute_header, "[MP] Error removing new cloud magic settings, %{public}s with error: %@", v4, v5);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006F3564()
{
  uint64_t v0;
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_1002F75F8();
  sub_10046E954(v1, v2, v3, 4.8752e-34);
  sub_1002B54E8((void *)&_mh_execute_header, "[MP] Error removing cloud info settings, %{public}s with error: %@", v4, v5);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006F35A8(uint64_t a1, NSObject *a2)
{
  int v2;
  _DWORD v3[2];

  v2 = *(unsigned __int8 *)(a1 + 241);
  v3[0] = 67109120;
  v3[1] = v2;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "updateAACPVersionInfo: Invalid device or not signed in %d ", (uint8_t *)v3, 8u);
  sub_10007266C();
}

void sub_1006F361C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "updateAACPVersionInfo: BTAddressFromString failed", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F3648()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "updateAACPVersionInfo: getDevice failed", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F3674()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "updateAACPVersionInfo: Could not create cloudDevice", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F36A0()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8751e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "updateAACPVersionInfo: No valid versionInfo for %{public}s", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006F36EC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "updateAACPVersionInfo: Unable to update pid/vid for cloudDevice", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F3718()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "updateAACPVersionInfo: Error retrieving cloudDevice: %@", v2);
  sub_1000726A0();
}

void sub_1006F377C()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "updateAACPVersionInfo: cloudDevice createError: %@", v2);
  sub_1000726A0();
}

void sub_1006F37E0()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "updateAACPVersionInfo: Error retrieving deviceSupportInformation: %@", v2);
  sub_1000726A0();
}

void sub_1006F3844()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "updateAACPVersionInfo: deviceSupportInformation createError %@", v2);
  sub_1000726A0();
}

void sub_1006F38A8()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "updateAACPVersionInfo: deviceSupportInformation modifyError error %@", v2);
  sub_1000726A0();
}

void sub_1006F390C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8751e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "updateCaseInfo: No valid caseInfo for %{public}s", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006F3958()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "updateCaseInfo: Error retrieving deviceSupportInformation: %@", v2);
  sub_1000726A0();
}

void sub_1006F39BC()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "updateCaseInfo: createError %@", v2);
  sub_1000726A0();
}

void sub_1006F3A20()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "updateCaseInfo: modifyError %@", v2);
  sub_1000726A0();
}

void sub_1006F3A84()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "CloudSync: writeMagicPairingSettingToCloud, MagicSettings: %@", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006F3AE4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000EEFE4();
  sub_1000726A8((void *)&_mh_execute_header, v0, v1, "CloudSync: writeMagicPairingSettingToCloud, CloudDevice: %@", v2, v3, v4, v5, v6);
  sub_1000726A0();
}

void sub_1006F3B44()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "writeMagicPairingSettingToCloud: cloudDevice createError: %@", v2);
  sub_1000726A0();
}

void sub_1006F3BA8()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000EEFE4();
  sub_100072744((void *)&_mh_execute_header, v0, v1, "Magic Setting create cloud device failed: %@", v2);
  sub_1000726A0();
}

void sub_1006F3C0C()
{
  uint64_t v0;
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_1002F75F8();
  sub_10046E954(v1, v2, v3, 4.8752e-34);
  sub_1002B54E8((void *)&_mh_execute_header, "[Pairing] Unable to fetch magic settings: %{public}s, Error: %@", v4, v5);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006F3C50()
{
  uint64_t v0;
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_1002F75F8();
  sub_10046E954(v1, v2, v3, 4.8752e-34);
  sub_1002B54E8((void *)&_mh_execute_header, "[Pairing] Unable to fetch cloud device: %{public}s, Error: %@", v4, v5);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006F3C94()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Failed to update cloud with current device list.", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F3CC0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Received invalid device address", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F3CEC(char *a1, _QWORD *a2, NSObject *a3)
{
  int v3;
  _QWORD *v4;

  if (*a1 < 0)
    a2 = (_QWORD *)*a2;
  v3 = 136315138;
  v4 = a2;
  sub_100072744((void *)&_mh_execute_header, a3, (uint64_t)a3, "Cannot find device or device not paired for address: %s", (uint8_t *)&v3);
  sub_1000726A0();
}

void sub_1006F3D64()
{
  uint64_t v0;
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_1002F75F8();
  sub_10046E954(v1, v2, v3, 4.8752e-34);
  sub_1002B54E8((void *)&_mh_execute_header, "Unable to fetch FM Status for %{public}s due to %@", v4, v5);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006F3DA8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "[deviceInfoChanged] Account not signed in.", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F3DD4()
{
  uint64_t v0;
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_1002F75F8();
  sub_10046E954(v1, v2, v3, 4.8752e-34);
  sub_1002B54E8((void *)&_mh_execute_header, "[3rd] Failed to remove cloud record for %{public}s with error: %@", v4, v5);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006F3E18()
{
  uint64_t v0;
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_1002F75F8();
  sub_10046E954(v1, v2, v3, 4.8752e-34);
  sub_1002B54E8((void *)&_mh_execute_header, "[3rd] Failed to create cloud record for %{public}s with error: %@", v4, v5);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006F3E5C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100097230();
  sub_100072710((void *)&_mh_execute_header, v0, v1, "Magic Pairing error disconnect failed with status %d", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F3EBC()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8751e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "Magic Pairing failed, force disconnecting device %{public}s", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006F3F08()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  char v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t *v8;

  sub_10007276C();
  if (v4 != v5)
    v6 = v3;
  else
    v6 = v1;
  sub_1002A8194(v2, v6, 4.8751e-34);
  sub_100072744((void *)&_mh_execute_header, v7, (uint64_t)v7, "Magic paired device for %{public}s not found", v8);
  if (*(char *)(v0 + 23) < 0)
    sub_100265C88();
  sub_1000DE5DC();
}

void sub_1006F3F54(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1000E9130((void *)&_mh_execute_header, a2, a3, "upgradeToManatee Acc Master Hint:%.16P", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006F3FCC(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1000E9130((void *)&_mh_execute_header, a2, a3, "upgradeToManatee Acc Master Key:%.16P", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006F4040()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Error upgrading to Manatee: No Master or Hint Key available", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F406C(int a1, NSObject *a2)
{
  _DWORD v2[2];

  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Failed registration for MKB first unlock notification with error : %u", (uint8_t *)v2, 8u);
  sub_10007266C();
}

void sub_1006F40DC()
{
  os_log_t v0;
  uint8_t v1[16];

  sub_10009720C();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "DeviceManager: Received MKB first unlock notification, but MKBDeviceUnlockedSinceBoot returns 0", v1, 2u);
  sub_10007266C();
}

void sub_1006F4114(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006F4184(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10007275C((void *)&_mh_execute_header, a1, a3, "Assertion failed: %{public}s", a5, a6, a7, a8, 2u);
  sub_1000726A0();
}

void sub_1006F41F4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Spatial: getSpatialAllowed: System has not passed first unlock. Do not read/write device prefs", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F4220()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "System has not passed first unlock. Do not read/write device prefs", v2, v3, v4, v5, v6);
  sub_10007266C();
}

void sub_1006F424C(uint64_t a1, NSObject *a2)
{
  int v2;
  _DWORD v3[2];

  v2 = *(unsigned __int8 *)(a1 + 136);
  v3[0] = 67109120;
  v3[1] = v2;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "Is incompatible Hid device connected: %u", (uint8_t *)v3, 8u);
  sub_10007266C();
}

void sub_1006F42C0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10009720C();
  sub_10007265C((void *)&_mh_execute_header, v0, v1, "Wireless Splitter error, unable to locate guestDevice after power on", v2, v3, v4, v5, v6);
  sub_10007266C();
}

