void sub_100003774(int *a1, int a2)
{
  NSObject *v3;
  int v4;
  const char *v5;

  *a1 = a2;
  if (dword_10008BA20)
  {
    v3 = ne_log_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4 = 136315138;
      v5 = sub_10003D5F8(0, 0, a2);
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "state changed to: %s\n", (uint8_t *)&v4, 0xCu);
    }
  }
}

uint64_t sub_100003834(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  NSObject *v7;
  _BOOL8 v8;
  uint64_t v9;
  NSObject *v10;
  _QWORD *v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  NSObject *v15;
  NSObject *v16;

  v4 = 0;
  v5 = *(_DWORD *)(a1 + 16);
  if (v5 <= 5439)
  {
    if (v5 > 5220)
    {
      if (v5 == 5221)
      {
        if (sub_100017320(a1, a2))
          return 0;
      }
      else
      {
        if (v5 != 5281)
          return v4;
        if (sub_10001269C(a1, (uint64_t)a2))
          return 0;
      }
    }
    else if (v5 == 5217)
    {
      if (sub_100015E94(a1, (uint64_t)a2))
        return 0;
    }
    else
    {
      if (v5 != 5219)
        return v4;
      if (sub_1000166E0(a1, (uint64_t)a2))
        return 0;
    }
    goto LABEL_34;
  }
  if (v5 <= 5475)
  {
    if (v5 == 5440)
    {
      v9 = sub_1000177B4(a1, (uint64_t)a2);
      if ((_DWORD)v9)
      {
        v4 = v9;
        if (!dword_10008BA20)
          goto LABEL_48;
        v10 = ne_log_obj(v9);
        v8 = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
        if (v8)
LABEL_26:
          sub_100055148();
LABEL_45:
        if (dword_10008BA20)
        {
          v16 = ne_log_obj(v8);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
            sub_1000550B8();
        }
        goto LABEL_48;
      }
    }
    else
    {
      if (v5 != 5474)
        return v4;
      if (sub_100017F50(a1, (uint64_t)a2))
        return 0;
    }
LABEL_34:
    v11 = *(_QWORD **)(a1 + 128);
    if (v11)
    {
      sub_10003F318(v11);
      *(_QWORD *)(a1 + 128) = 0;
    }
    v12 = *(unsigned int *)(a1 + 120);
    if ((_DWORD)v12)
    {
      v12 = sub_10003A6F0(v12);
      *(_DWORD *)(a1 + 120) = 0;
    }
    if (dword_10008BA20)
    {
      v13 = ne_log_obj(v12);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
        sub_100055110();
    }
    v14 = sub_100003AE4(a1, (uint64_t)a2);
    if ((_DWORD)v14)
    {
      v4 = v14;
      if (dword_10008BA20)
      {
        v15 = ne_log_obj(v14);
        v8 = os_log_type_enabled(v15, OS_LOG_TYPE_ERROR);
        if (v8)
          sub_1000550E4();
        goto LABEL_45;
      }
LABEL_48:
      sub_10004AACC(a1);
      return v4;
    }
    if ((*(_BYTE *)(a1 + 17) & 0x20) != 0)
      sub_1000227C4(a1);
    return 0;
  }
  switch(v5)
  {
    case 5476:
      if (sub_100018754(a1, a2))
        return 0;
      goto LABEL_34;
    case 5504:
      v6 = sub_100013928(a1, (uint64_t)a2);
      if ((_DWORD)v6)
      {
        v4 = v6;
        if (!dword_10008BA20)
          goto LABEL_48;
        v7 = ne_log_obj(v6);
        v8 = os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
        if (v8)
          goto LABEL_26;
        goto LABEL_45;
      }
      goto LABEL_34;
    case 5538:
      if (sub_100014964(a1, a2))
        return 0;
      goto LABEL_34;
  }
  return v4;
}

uint64_t sub_100003AE4(uint64_t a1, uint64_t a2)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  int v6;

  v3 = *(_DWORD *)(a1 + 16);
  v4 = 0xFFFFFFFFLL;
  if (v3 > 5440)
  {
    if (v3 <= 5444)
    {
      if (v3 == 5441)
      {
        v5 = sub_100017B34(a1, a2);
        goto LABEL_22;
      }
      if (v3 == 5443)
      {
        v5 = sub_1000183FC(a1, a2);
        goto LABEL_22;
      }
    }
    else
    {
      switch(v3)
      {
        case 5445:
          v5 = sub_100018C9C(a1, a2);
          goto LABEL_22;
        case 5505:
          v5 = sub_100013F18(a1, a2);
          goto LABEL_22;
        case 5507:
          v5 = sub_100014E98(a1, a2);
          goto LABEL_22;
      }
    }
LABEL_23:
    v6 = sub_10000A9C8(a1);
    sub_1000487BC((unsigned __int16)v4, 0, v6, 0, 0);
    return v4;
  }
  switch(v3)
  {
    case 5184:
      v5 = sub_100015A78(a1, a2);
      break;
    case 5185:
    case 5187:
    case 5189:
      goto LABEL_23;
    case 5186:
      v5 = sub_10001623C(a1, a2);
      break;
    case 5188:
      v5 = sub_100016C20(a1, a2);
      break;
    case 5190:
      v5 = sub_100017728(a1);
      break;
    default:
      if (v3 == 5248)
      {
        v5 = sub_100012084(a1, a2);
      }
      else
      {
        if (v3 != 5250)
          goto LABEL_23;
        v5 = sub_1000131EC(a1, a2);
      }
      break;
  }
LABEL_22:
  v4 = v5;
  if ((_DWORD)v5)
    goto LABEL_23;
  return v4;
}

uint64_t sub_100003C48(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  int v5;
  uint64_t v6;
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  _QWORD *v11;
  uint64_t v12;
  NSObject *v13;
  NSObject *v14;

  result = 0;
  v5 = *(_DWORD *)(a1 + 56);
  v6 = 0xFFFFFFFFLL;
  if (v5 <= 6591)
  {
    switch(v5)
    {
      case 6369:
        result = sub_10001D128(a1, a2);
        break;
      case 6371:
        result = sub_10001E178(a1, a2);
        break;
      case 6384:
        return result;
      default:
        goto LABEL_19;
    }
  }
  else
  {
    if (v5 > 6639)
    {
      if (v5 != 6640 && v5 != 10240)
        goto LABEL_19;
      return result;
    }
    if (v5 == 6592)
    {
      result = sub_10001E61C(a1, a2);
    }
    else
    {
      if (v5 != 6626)
        goto LABEL_19;
      result = sub_10001FEC4(a1, a2);
    }
  }
  v6 = result;
  if ((_DWORD)result)
  {
LABEL_19:
    if (dword_10008BA20)
    {
      v8 = ne_log_obj(result);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_100055148();
    }
    if ((_DWORD)v6 == -1)
      sub_10003B334();
    v9 = sub_10001B184(*(_QWORD *)(a1 + 256), v6, 0);
LABEL_25:
    if (dword_10008BA20)
    {
      v10 = ne_log_obj(v9);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_100055174();
    }
    goto LABEL_28;
  }
  v11 = *(_QWORD **)(a1 + 80);
  if (v11)
  {
    sub_10003F318(v11);
    *(_QWORD *)(a1 + 80) = 0;
  }
  else if (*(_DWORD *)(a1 + 56) != 6593)
  {
    if (dword_10008BA20)
    {
      v14 = ne_log_obj(0);
      v9 = os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
      if ((_DWORD)v9)
        sub_1000551A0();
      v6 = 0xFFFFFFFFLL;
      goto LABEL_25;
    }
    v6 = 0xFFFFFFFFLL;
    goto LABEL_28;
  }
  v12 = *(unsigned int *)(a1 + 68);
  if ((_DWORD)v12)
  {
    sub_10003A6F0(v12);
    *(_DWORD *)(a1 + 68) = 0;
  }
  if (*(_DWORD *)(a1 + 56) == 6344)
    return 0;
  result = sub_100003E8C(a1, (uint64_t)a2);
  if ((_DWORD)result)
  {
    v6 = result;
    if (dword_10008BA20)
    {
      v13 = ne_log_obj(result);
      v9 = os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
      if ((_DWORD)v9)
        sub_1000550E4();
      goto LABEL_25;
    }
LABEL_28:
    sub_10004A9EC((_QWORD *)a1);
    return v6;
  }
  return result;
}

uint64_t sub_100003E8C(uint64_t a1, uint64_t a2)
{
  int v2;

  v2 = *(_DWORD *)(a1 + 56);
  if (v2 > 6594)
  {
    switch(v2)
    {
      case 6595:
        return sub_10002020C(a1, a2);
      case 6596:
        return sub_100020554(a1);
      case 6608:
        return sub_10001F6E4(a1, a2);
    }
  }
  else
  {
    switch(v2)
    {
      case 6338:
        return sub_10001DD08(a1, a2);
      case 6352:
        return sub_10001CA7C(a1, a2);
      case 6593:
        return sub_10001F5E0(a1);
    }
  }
  return 0xFFFFFFFFLL;
}

void sub_100003F04(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 2u);
}

BOOL sub_100003F28(int a1)
{
  return sub_100003F44(a1) != 0;
}

char **sub_100003F44(int a1)
{
  uint64_t v1;
  char **v2;
  NSObject *v3;

  v1 = 0;
  while (1)
  {
    v2 = &(&off_100088000)[v1];
    if (*((_DWORD *)&off_100088000 + 2 * v1 + 3) == a1)
      break;
    v1 += 7;
    if (v1 == 35)
      return 0;
  }
  if (dword_10008BA20)
  {
    v3 = ne_log_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
      sub_1000551CC();
  }
  return v2;
}

uint64_t sub_100003FC4(int a1)
{
  uint64_t v1;

  v1 = 0;
  while (LODWORD((&off_100088000)[v1 + 1]) != a1)
  {
    v1 += 7;
    if (v1 == 35)
      return 0xFFFFFFFFLL;
  }
  return *((unsigned int *)&off_100088000 + 2 * v1 + 3);
}

uint64_t sub_100003FFC(int a1)
{
  char **v1;
  uint64_t (*v2)(void);

  v1 = sub_100003F44(a1);
  if (v1 && (v2 = (uint64_t (*)(void))v1[5]) != 0)
    return v2();
  else
    return 0;
}

const char *sub_100004028(int a1)
{
  char **v1;

  v1 = sub_100003F44(a1);
  if (v1)
    return *v1;
  else
    return "*UNKNOWN*";
}

uint64_t sub_100004050(int a1, uint64_t a2)
{
  char **v3;

  v3 = sub_100003F44(a1);
  if (v3 && v3[5])
    return ((uint64_t (*)(uint64_t))v3[6])(a2);
  else
    return 0;
}

uint64_t sub_100004094(int a1)
{
  uint64_t v1;

  v1 = 0;
  while (LODWORD((&off_100084950)[v1 + 1]) != a1)
  {
    v1 += 7;
    if (v1 == 35)
      return 0xFFFFFFFFLL;
  }
  return *((unsigned int *)&off_100084950 + 2 * v1 + 3);
}

uint64_t sub_1000040CC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  NSObject *v7;

  v5 = 0;
  while (*((_DWORD *)&off_100084950 + 2 * v5 + 3) != (_DWORD)a1)
  {
    v5 += 7;
    if (v5 == 35)
      return 0;
  }
  if (dword_10008BA20)
  {
    v7 = ne_log_obj(a1);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      sub_10005522C();
  }
  return ((uint64_t (*)(uint64_t, uint64_t))(&off_100084950)[v5 + 6])(a2, a3);
}

BOOL sub_100004174(int a1)
{
  return sub_100004190(a1) != 0;
}

char **sub_100004190(int a1)
{
  uint64_t v1;
  char **v2;
  NSObject *v3;

  v1 = 0;
  while (1)
  {
    v2 = &(&off_100088118)[v1];
    if (*((_DWORD *)&off_100088118 + 2 * v1 + 3) == a1)
      break;
    v1 += 7;
    if (v1 == 21)
      return 0;
  }
  if (dword_10008BA20)
  {
    v3 = ne_log_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
      sub_10005528C();
  }
  return v2;
}

uint64_t sub_100004210(int a1)
{
  uint64_t v1;

  v1 = 0;
  while (LODWORD((&off_100088118)[v1 + 1]) != a1)
  {
    v1 += 7;
    if (v1 == 21)
      return 0xFFFFFFFFLL;
  }
  return *((unsigned int *)&off_100088118 + 2 * v1 + 3);
}

uint64_t sub_100004248(int a1, uint64_t a2)
{
  char **v3;
  char *v4;

  v3 = sub_100004190(a1);
  if (v3 && (v4 = v3[6]) != 0)
    return ((uint64_t (*)(uint64_t))v4)(a2);
  else
    return 0xFFFFFFFFLL;
}

uint64_t sub_100004288(int a1)
{
  char **v1;

  v1 = sub_100004190(a1);
  if (v1)
    return *((unsigned int *)v1 + 4);
  else
    return 0xFFFFFFFFLL;
}

const char *sub_1000042AC(int a1)
{
  char **v1;

  v1 = sub_100004190(a1);
  if (v1)
    return *v1;
  else
    return "*UNKNOWN*";
}

uint64_t sub_1000042D4(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char **v7;
  char *v8;

  v7 = sub_100004190(a1);
  if (v7 && (v8 = v7[4]) != 0)
    return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))v8)(a2, a3, a4);
  else
    return 0;
}

uint64_t sub_100004330(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char **v7;
  char *v8;

  v7 = sub_100004190(a1);
  if (v7 && (v8 = v7[3]) != 0)
    return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))v8)(a2, a3, a4);
  else
    return 0;
}

uint64_t sub_10000438C(int a1)
{
  uint64_t v1;

  v1 = 0;
  while (LODWORD((&off_100084A68)[v1 + 1]) != a1)
  {
    v1 += 7;
    if (v1 == 42)
      return 0xFFFFFFFFLL;
  }
  return *((unsigned int *)&off_100084A68 + 2 * v1 + 3);
}

uint64_t sub_1000043C4(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  NSObject *v5;

  v3 = 0;
  while (*((_DWORD *)&off_100084A68 + 2 * v3 + 3) != (_DWORD)a1)
  {
    v3 += 7;
    if (v3 == 42)
      return 0xFFFFFFFFLL;
  }
  if (dword_10008BA20)
  {
    v5 = ne_log_obj(a1);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      sub_10005528C();
  }
  return ((uint64_t (*)(uint64_t))(&off_100084A68)[v3 + 6])(a2);
}

uint64_t sub_100004464(int a1)
{
  uint64_t v1;

  v1 = 0;
  while (LODWORD((&off_100084BB8)[v1 + 1]) != a1)
  {
    v1 += 7;
    if (v1 == 56)
      return 0xFFFFFFFFLL;
  }
  return *((unsigned int *)&off_100084BB8 + 2 * v1 + 3);
}

uint64_t sub_10000449C(uint64_t a1)
{
  uint64_t v1;
  NSObject *v3;

  v1 = 0;
  while (*((_DWORD *)&off_100084BB8 + 2 * v1 + 3) != (_DWORD)a1)
  {
    v1 += 7;
    if (v1 == 56)
      return 0xFFFFFFFFLL;
  }
  if (dword_10008BA20)
  {
    v3 = ne_log_obj(a1);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
      sub_10005522C();
  }
  return ((uint64_t (*)(void))(&off_100084BB8)[v1 + 5])();
}

uint64_t sub_10000452C(int a1)
{
  uint64_t v1;

  v1 = 0;
  while (LODWORD((&off_100084D78)[v1 + 1]) != a1)
  {
    v1 += 2;
    if (v1 == 6)
      return 0xFFFFFFFFLL;
  }
  return *((unsigned int *)&off_100084D78 + 2 * v1 + 3);
}

BOOL sub_100004564(uint64_t a1)
{
  return sub_100004580(a1) != 0;
}

char **sub_100004580(uint64_t a1)
{
  uint64_t v1;
  char **v2;
  NSObject *v3;

  v1 = 0;
  while (1)
  {
    v2 = &(&off_1000881C0)[v1];
    if (*((_DWORD *)&off_1000881C0 + 2 * v1 + 3) == (_DWORD)a1)
      break;
    v1 += 3;
    if (v1 == 24)
      return 0;
  }
  if (dword_10008BA20)
  {
    v3 = ne_log_obj(a1);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
      sub_10005522C();
  }
  return v2;
}

uint64_t sub_100004600(int a1)
{
  uint64_t v1;

  v1 = 0;
  while (LODWORD((&off_1000881C0)[v1 + 1]) != a1)
  {
    v1 += 3;
    if (v1 == 24)
      return 0xFFFFFFFFLL;
  }
  return *((unsigned int *)&off_1000881C0 + 2 * v1 + 3);
}

char **sub_100004638(uint64_t a1)
{
  char **result;

  result = sub_100004580(a1);
  if (result)
    return (char **)result[2];
  return result;
}

const char *sub_100004654(uint64_t a1)
{
  char **v1;

  v1 = sub_100004580(a1);
  if (v1)
    return *v1;
  else
    return "*UNKNOWN*";
}

uint64_t sub_10000467C(int a1)
{
  uint64_t v1;

  v1 = 0;
  while (LODWORD((&off_100084DA8)[v1 + 1]) != a1)
  {
    v1 += 2;
    if (v1 == 32)
      return 0xFFFFFFFFLL;
  }
  return *((unsigned int *)&off_100084DA8 + 2 * v1 + 3);
}

const char *sub_1000046B4(int a1)
{
  uint64_t v2;
  const char *result;

  v2 = 0;
  result = "*UNKNOWN*";
  while (*((_DWORD *)&off_100084DA8 + 2 * v2 + 3) != a1)
  {
    v2 += 2;
    if (v2 == 32)
      return result;
  }
  return (&off_100084DA8)[v2];
}

uint64_t sub_1000046F4(int a1, int a2)
{
  if (a1 != 3 && a1 || (a2 - 4) > 9)
    return 0;
  else
    return dword_100069DC4[a2 - 4];
}

uint64_t sub_100004724(uint64_t result, unsigned int a2, uint64_t a3)
{
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  NSObject *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;

  if ((_DWORD)result && (v4 = result, (_DWORD)result != 3))
  {
    if (dword_10008BA20)
    {
      v12 = ne_log_obj(result);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        sub_1000552EC(v4, v12, v13, v14, v15, v16, v17, v18);
    }
  }
  else if (a2 <= 0xD && ((1 << a2) & 0x30D0) != 0)
  {
    if ((a3 & 7) != 0)
    {
      if (dword_10008BA20)
      {
        v5 = ne_log_obj(result);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
          sub_1000553B0(a3, v5, v6, v7, v8, v9, v10, v11);
      }
    }
    else
    {
      switch(a2)
      {
        case 4u:
          if ((a3 - 40) < 0x7D1)
            return 0;
          goto LABEL_29;
        case 6u:
          if ((a3 - 40) < 0x59)
            return 0;
          goto LABEL_29;
        case 7u:
          if ((a3 - 40) < 0x199)
            return 0;
          goto LABEL_29;
        case 0xCu:
          result = 0;
          if ((_DWORD)a3 == 128 || (_DWORD)a3 == 192 || (_DWORD)a3 == 256)
            return result;
          goto LABEL_29;
        case 0xDu:
          if ((a3 - 40) < 0xD9)
            return 0;
LABEL_29:
          if (dword_10008BA20)
          {
            v27 = ne_log_obj(result);
            if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
              sub_100055380(v27, v28, v29, v30, v31, v32, v33, v34);
          }
          break;
        default:
          goto LABEL_15;
      }
    }
  }
  else
  {
LABEL_15:
    if (!(_DWORD)a3)
      return 0;
    if (dword_10008BA20)
    {
      v19 = ne_log_obj(result);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        sub_100055350(v19, v20, v21, v22, v23, v24, v25, v26);
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_1000048CC(int a1, int a2)
{
  uint64_t i;
  char **v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  switch(a1)
  {
    case 0:
      for (i = 0; i != 42; i += 7)
      {
        v3 = &(&off_100084A68)[i];
        if (LODWORD((&off_100084A68)[i + 1]) == a2)
          return *((unsigned int *)v3 + 3);
      }
      return 0xFFFFFFFFLL;
    case 1:
      v4 = 0;
      while (1)
      {
        v3 = &(&off_100084BB8)[v4];
        if (LODWORD((&off_100084BB8)[v4 + 1]) == a2)
          break;
        v4 += 7;
        if (v4 == 56)
          return 0xFFFFFFFFLL;
      }
      return *((unsigned int *)v3 + 3);
    case 2:
      v5 = 0;
      while (1)
      {
        v3 = &(&off_100084D78)[v5];
        if (LODWORD((&off_100084D78)[v5 + 1]) == a2)
          break;
        v5 += 2;
        if (v5 == 6)
          return 0xFFFFFFFFLL;
      }
      return *((unsigned int *)v3 + 3);
    case 3:
      v6 = 0;
      while (1)
      {
        v3 = &(&off_100088118)[v6];
        if (LODWORD((&off_100088118)[v6 + 1]) == a2)
          break;
        v6 += 7;
        if (v6 == 21)
          return 0xFFFFFFFFLL;
      }
      return *((unsigned int *)v3 + 3);
    case 4:
      v7 = 0;
      while (1)
      {
        v3 = &(&off_100088000)[v7];
        if (LODWORD((&off_100088000)[v7 + 1]) == a2)
          break;
        v7 += 7;
        if (v7 == 35)
          return 0xFFFFFFFFLL;
      }
      return *((unsigned int *)v3 + 3);
    case 5:
      v8 = 0;
      while (1)
      {
        v3 = &(&off_1000881C0)[v8];
        if (LODWORD((&off_1000881C0)[v8 + 1]) == a2)
          break;
        v8 += 3;
        if (v8 == 24)
          return 0xFFFFFFFFLL;
      }
      return *((unsigned int *)v3 + 3);
    case 6:
      v9 = 0;
      break;
    default:
      return 0xFFFFFFFFLL;
  }
  while (1)
  {
    v3 = &(&off_100084DA8)[v9];
    if (LODWORD((&off_100084DA8)[v9 + 1]) == a2)
      break;
    v9 += 2;
    if (v9 == 32)
      return 0xFFFFFFFFLL;
  }
  return *((unsigned int *)v3 + 3);
}

uint64_t sub_100004A34(unsigned int a1)
{
  if (a1 > 6)
    return 0xFFFFFFFFLL;
  else
    return dword_100069DEC[a1];
}

void sub_100004A54(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 0xCu);
}

void sub_100004A6C(uint64_t a1@<X8>)
{
  uint64_t v1;

  *(_QWORD *)(v1 - 8) = a1;
}

void sub_100004A84(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 8u);
}

SecCertificateRef sub_100004A94(uint64_t a1)
{
  const __CFData *v1;
  const __CFData *v2;
  SecCertificateRef v3;
  NSObject *v4;

  v1 = CFDataCreateWithBytesNoCopy(0, *(const UInt8 **)(a1 + 8), *(_QWORD *)a1, kCFAllocatorNull);
  if (v1)
  {
    v2 = v1;
    v3 = SecCertificateCreateWithData(0, v1);
    CFRelease(v2);
    if (v3)
      return v3;
  }
  else
  {
    v3 = 0;
  }
  if (dword_10008BA20)
  {
    v4 = ne_log_obj(v1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      sub_100055414();
  }
  return v3;
}

uint64_t sub_100004B2C(uint64_t a1)
{
  uint64_t v2;
  double Current;
  CFAbsoluteTime v4;
  uint64_t IsValid;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  const __CFDate *v9;
  double v10;
  CFAbsoluteTime v11;
  const __CFDate *v12;
  double v13;
  CFAbsoluteTime v14;
  const __CFDate *v15;
  __CFCalendar *v16;
  __CFCalendar *v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  NSObject *v21;
  NSObject *v22;
  NSObject *v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint8_t buf[4];
  int v29;
  __int16 v30;
  int v31;
  __int16 v32;
  int v33;
  __int16 v34;
  int v35;
  __int16 v36;
  int v37;

  Current = CFAbsoluteTimeGetCurrent();
  if (Current == 0.0)
  {
    if (dword_10008BA20)
    {
      v8 = ne_log_obj(v2);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_100055498();
    }
    return 5;
  }
  v4 = Current;
  IsValid = SecCertificateIsValid(a1);
  if (!(_DWORD)IsValid)
  {
    v9 = CFDateCreate(0, v4);
    v10 = SecCertificateNotValidBefore(a1);
    v11 = v10;
    if (v10 == 0.0)
      v12 = 0;
    else
      v12 = CFDateCreate(0, v10);
    v13 = SecCertificateNotValidAfter(a1);
    v14 = v13;
    if (v13 == 0.0)
      v15 = 0;
    else
      v15 = CFDateCreate(0, v13);
    v26 = 0;
    v27 = 0;
    v25 = 0;
    v16 = CFCalendarCreateWithIdentifier(kCFAllocatorDefault, kCFGregorianCalendar);
    if (v16)
    {
      v17 = v16;
      if (v11 != 0.0)
      {
        v18 = CFCalendarDecomposeAbsoluteTime(v16, v11, "yMdHm", (char *)&v27 + 4, &v27, (char *)&v26 + 4, &v26, &v25);
        if (dword_10008BA20)
        {
          v19 = ne_log_obj(v18);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 67110144;
            v29 = HIDWORD(v27);
            v30 = 1024;
            v31 = v27;
            v32 = 1024;
            v33 = HIDWORD(v26);
            v34 = 1024;
            v35 = v26;
            v36 = 1024;
            v37 = v25;
            _os_log_debug_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "Certificate not valid before yr %d, mon %d, days %d, hours %d, min %d\n", buf, 0x20u);
          }
        }
      }
      if (v14 != 0.0)
      {
        v20 = CFCalendarDecomposeAbsoluteTime(v17, v14, "yMdHm", (char *)&v27 + 4, &v27, (char *)&v26 + 4, &v26, &v25);
        if (dword_10008BA20)
        {
          v21 = ne_log_obj(v20);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 67110144;
            v29 = HIDWORD(v27);
            v30 = 1024;
            v31 = v27;
            v32 = 1024;
            v33 = HIDWORD(v26);
            v34 = 1024;
            v35 = v26;
            v36 = 1024;
            v37 = v25;
            _os_log_debug_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEBUG, "Certificate not valid after yr %d, mon %d, days %d, hours %d, min %d\n", buf, 0x20u);
          }
        }
      }
      CFRelease(v17);
    }
    if (!v9)
      goto LABEL_36;
    if (v12 && CFDateCompare(v9, v12, 0) == kCFCompareLessThan)
    {
      if (dword_10008BA20)
      {
        v24 = ne_log_obj(-1);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          sub_10005546C();
      }
      v7 = 1;
      goto LABEL_47;
    }
    if (v15 && CFDateCompare(v9, v15, 0) == kCFCompareGreaterThan)
    {
      if (dword_10008BA20)
      {
        v22 = ne_log_obj(1);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          sub_100055440();
      }
      v7 = 2;
    }
    else
    {
LABEL_36:
      v7 = 0;
    }
    if (!v12)
    {
      if (!v15)
        goto LABEL_40;
      goto LABEL_39;
    }
LABEL_47:
    CFRelease(v12);
    if (!v15)
    {
LABEL_40:
      if (v9)
        CFRelease(v9);
      return v7;
    }
LABEL_39:
    CFRelease(v15);
    goto LABEL_40;
  }
  if (!dword_10008BA20)
    return 0;
  v6 = ne_log_obj(IsValid);
  v7 = 0;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Certificate expiration date is OK\n", buf, 2u);
    return 0;
  }
  return v7;
}

uint64_t sub_100004F48(uint64_t a1, uint64_t a2, void *a3, SecKeyRef *a4)
{
  int *v7;
  const __CFDictionary *v8;
  BOOL v9;
  const __CFDictionary *v10;
  SecPolicyRef v11;
  NSObject *v12;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  NSObject *v18;
  const void **v19;
  const void **v20;
  SecCertificateRef v21;
  int v22;
  CFIndex v23;
  CFArrayRef v24;
  CFArrayRef v25;
  unsigned int v26;
  uint64_t v27;
  SecTrustResultType v28;
  SecCertificateRef v29;
  BOOL v30;
  uint64_t v31;
  int *v32;
  NSObject *v33;
  int v34;
  NSObject *v35;
  uint64_t v36;
  NSObject *v37;
  _BOOL4 v38;
  NSObject *v39;
  NSObject *v40;
  NSObject *v41;
  NSObject *v42;
  NSObject *v43;
  NSObject *v44;
  NSObject *v45;
  NSObject *v46;
  NSObject *v47;
  const __CFArray *v48;
  const __CFArray *v49;
  CFTypeID Count;
  uint64_t v51;
  NSObject *v52;
  CFIndex v53;
  const __CFDictionary *v54;
  CFTypeID v55;
  const __CFString *Value;
  const __CFString *v57;
  CFTypeID v58;
  const char *CStringPtr;
  const char *v60;
  const __CFString *v61;
  CFTypeID v62;
  CFTypeID v63;
  NSObject *v64;
  NSObject *v65;
  void *v66;
  NSObject *v67;
  uint64_t v68;
  NSObject *v69;
  NSObject *log;
  const __CFArray *v71;
  SecTrustResultType result;
  _BYTE keys[12];
  void *values;

  *(_QWORD *)keys = kSecPolicyName;
  values = a3;
  v7 = &dword_10008BA20;
  if (!a3)
  {
LABEL_11:
    v11 = SecPolicyCreateWithProperties(kSecPolicyAppleIPsec, 0);
    goto LABEL_12;
  }
  v8 = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v8)
    v9 = 1;
  else
    v9 = dword_10008BA20 == 0;
  if (!v9)
  {
    v12 = ne_log_obj(v8);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      sub_100055874();
    goto LABEL_11;
  }
  v10 = v8;
  v11 = SecPolicyCreateWithProperties(kSecPolicyAppleIPsec, v8);
  if (v10)
    CFRelease(v10);
LABEL_12:
  v14 = 0xFFFFFFFFLL;
  if (!a1 || !a2)
    return v14;
  v15 = 0;
  v16 = -1;
  v17 = a2;
  do
  {
    v17 = *(_QWORD *)(v17 + 40);
    ++v16;
    v15 += 8;
  }
  while (v17);
  if (v16)
  {
    if (dword_10008BA20)
    {
      v18 = ne_log_obj(0xFFFFFFFFLL);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        sub_1000557EC(v16 + 1, v18);
    }
  }
  v19 = (const void **)CFAllocatorAllocate(0, v15, 0);
  if (!v19)
    return 0xFFFFFFFFLL;
  v20 = v19;
  bzero(v19, v15);
  v21 = sub_100004A94(a1 + 8);
  *v20 = v21;
  if (!v21)
  {
    v23 = 0;
    v22 = 0;
    do
    {
LABEL_32:
      if (a2 != a1)
      {
        v29 = sub_100004A94(a2 + 8);
        v20[v23] = v29;
        if (v29)
        {
          if (!*(_DWORD *)(a2 + 32))
          {
            v31 = sub_100004B2C((uint64_t)v29);
            *(_DWORD *)(a2 + 32) = v31;
            if ((_DWORD)v31)
            {
              v32 = v7;
              if (*v7)
              {
                v33 = ne_log_obj(v31);
                if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
                {
                  v34 = *(_DWORD *)(a2 + 32);
                  *(_DWORD *)keys = 67109120;
                  *(_DWORD *)&keys[4] = v34;
                  _os_log_error_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "other certificate in chain failed date verification: %d.\n", keys, 8u);
                }
              }
              v7 = v32;
              if (!v22)
                v22 = *(_DWORD *)(a2 + 32);
            }
          }
          ++v23;
        }
      }
      a2 = *(_QWORD *)(a2 + 40);
      if (a2)
        v30 = v23 <= v16;
      else
        v30 = 0;
    }
    while (v30);
    goto LABEL_25;
  }
  if (*(_DWORD *)(a1 + 32))
  {
    v22 = 0;
  }
  else
  {
    v36 = sub_100004B2C((uint64_t)v21);
    v22 = v36;
    *(_DWORD *)(a1 + 32) = v36;
    if ((_DWORD)v36)
    {
      if (dword_10008BA20)
      {
        v37 = ne_log_obj(v36);
        v38 = os_log_type_enabled(v37, OS_LOG_TYPE_ERROR);
        v22 = *(_DWORD *)(a1 + 32);
        if (v38)
        {
          *(_DWORD *)keys = 67109120;
          *(_DWORD *)&keys[4] = v22;
          _os_log_error_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, "host certificate failed date verification: %d.\n", keys, 8u);
          v22 = *(_DWORD *)(a1 + 32);
        }
      }
    }
  }
  v23 = 1;
  if (v16)
    goto LABEL_32;
LABEL_25:
  values = 0;
  result = kSecTrustResultInvalid;
  v24 = CFArrayCreate(0, v20, v23, &kCFTypeArrayCallBacks);
  if (v24)
  {
    v25 = v24;
    v26 = SecTrustCreateWithCertificates(v24, v11, (SecTrustRef *)&values);
    if (!v26)
    {
      v27 = SecTrustEvaluate((SecTrustRef)values, &result);
      v26 = v27;
      if (!(_DWORD)v27)
      {
        v28 = result;
        if (result == kSecTrustResultProceed || result == kSecTrustResultUnspecified)
        {
          v26 = 0;
          *a4 = SecTrustCopyPublicKey((SecTrustRef)values);
        }
        else
        {
          if (*v7)
          {
            v39 = ne_log_obj(v27);
            v27 = os_log_type_enabled(v39, OS_LOG_TYPE_ERROR);
            if ((_DWORD)v27)
              sub_1000557C0();
            v28 = result;
          }
          switch(v28)
          {
            case kSecTrustResultInvalid:
              if (*v7)
              {
                v40 = ne_log_obj(v27);
                if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
                  sub_10005568C();
              }
              break;
            case kSecTrustResultProceed:
              if (*v7)
              {
                v41 = ne_log_obj(v27);
                if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
                  sub_1000556B8();
              }
              break;
            case kSecTrustResultDeny:
              if (*v7)
              {
                v43 = ne_log_obj(v27);
                if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
                  sub_1000556E4();
              }
              break;
            case kSecTrustResultUnspecified:
              if (*v7)
              {
                v44 = ne_log_obj(v27);
                if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
                  sub_100055710();
              }
              break;
            case kSecTrustResultRecoverableTrustFailure:
              if (*v7)
              {
                v45 = ne_log_obj(v27);
                if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
                  sub_10005573C();
              }
              break;
            case kSecTrustResultFatalTrustFailure:
              if (*v7)
              {
                v46 = ne_log_obj(v27);
                if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
                  sub_100055768();
              }
              break;
            case kSecTrustResultOtherError:
              if (*v7)
              {
                v47 = ne_log_obj(v27);
                if (os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG))
                  sub_100055794();
              }
              break;
            default:
              if (*v7)
              {
                v42 = ne_log_obj(v27);
                if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
                  sub_100055618((int *)&result, v42);
              }
              break;
          }
          v48 = SecTrustCopyProperties((SecTrustRef)values);
          if (v48)
          {
            v49 = v48;
            Count = CFArrayGetCount(v48);
            v51 = Count;
            if (*v7)
            {
              v52 = ne_log_obj(Count);
              Count = os_log_type_enabled(v52, OS_LOG_TYPE_ERROR);
              if ((_DWORD)Count)
                sub_1000555EC();
            }
            if (v51 >= 1)
            {
              v53 = 0;
              v71 = v49;
              do
              {
                Count = (CFTypeID)CFArrayGetValueAtIndex(v49, v53);
                if (Count)
                {
                  v54 = (const __CFDictionary *)Count;
                  v55 = CFGetTypeID((CFTypeRef)Count);
                  Count = CFDictionaryGetTypeID();
                  if (v55 == Count)
                  {
                    Value = (const __CFString *)CFDictionaryGetValue(v54, kSecPropertyKeyType);
                    if (Value)
                    {
                      v57 = Value;
                      v58 = CFGetTypeID(Value);
                      v9 = v58 == CFStringGetTypeID();
                      v49 = v71;
                      if (v9)
                      {
                        CStringPtr = CFStringGetCStringPtr(v57, 0);
                        if (CStringPtr)
                        {
                          if (dword_10008BA20)
                          {
                            v60 = CStringPtr;
                            log = ne_log_obj(CStringPtr);
                            if (os_log_type_enabled(log, OS_LOG_TYPE_ERROR))
                            {
                              *(_DWORD *)keys = 136315138;
                              *(_QWORD *)&keys[4] = v60;
                              _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "type = %s.\n", keys, 0xCu);
                            }
                          }
                        }
                      }
                    }
                    Count = (CFTypeID)CFDictionaryGetValue(v54, kSecPropertyKeyValue);
                    if (Count)
                    {
                      v61 = (const __CFString *)Count;
                      v62 = CFGetTypeID((CFTypeRef)Count);
                      Count = CFStringGetTypeID();
                      v9 = v62 == Count;
                      v49 = v71;
                      if (v9)
                      {
                        Count = (CFTypeID)CFStringGetCStringPtr(v61, 0);
                        if (Count)
                        {
                          if (dword_10008BA20)
                          {
                            v63 = Count;
                            v64 = ne_log_obj(Count);
                            Count = os_log_type_enabled(v64, OS_LOG_TYPE_ERROR);
                            if ((_DWORD)Count)
                            {
                              *(_DWORD *)keys = 136315138;
                              *(_QWORD *)&keys[4] = v63;
                              _os_log_error_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_ERROR, "value = %s.\n", keys, 0xCu);
                            }
                          }
                        }
                      }
                    }
                  }
                }
                ++v53;
              }
              while (v51 != v53);
            }
            v7 = &dword_10008BA20;
            if (dword_10008BA20)
            {
              v65 = ne_log_obj(Count);
              if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
                sub_1000555C0();
            }
            CFRelease(v49);
          }
          v26 = -1;
        }
      }
    }
    CFRelease(v25);
    v66 = values;
    if (values)
      CFRelease(values);
    if (v26 - 1 > 0xFFFFFFFD)
      goto LABEL_118;
    if (*v7)
    {
      v67 = ne_log_obj(v66);
      if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
        sub_100055558();
    }
  }
  else if (*v7)
  {
    v35 = ne_log_obj(0);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      sub_10005552C();
  }
  v26 = -1;
LABEL_118:
  while (v23)
    CFRelease(v20[--v23]);
  CFAllocatorDeallocate(0, v20);
  if (v11)
    CFRelease(v11);
  if (v26 - 1 <= 0xFFFFFFFD)
  {
    if (*v7)
    {
      v69 = ne_log_obj(v68);
      if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
        sub_1000554C4();
    }
    return 0xFFFFFFFFLL;
  }
  if ((v22 - 1) < 2)
    return 0xFFFFFFFFLL;
  else
    return v26;
}

const char *sub_100005760(int a1)
{
  const char *result;

  switch(a1)
  {
    case -25318:
      result = "errSecCreateChainFailed";
      break;
    case -25317:
      result = "errSecDataNotModifiable";
      break;
    case -25316:
      result = "errSecDataNotAvailable";
      break;
    case -25315:
      result = "errSecInteractionRequired";
      break;
    case -25314:
      result = "errSecNoPolicyModule";
      break;
    case -25313:
      result = "errSecNoCertificateModule";
      break;
    case -25312:
      result = "errSecNoStorageModule";
      break;
    case -25311:
      result = "errSecKeySizeNotAllowed";
      break;
    case -25310:
      result = "errSecWrongSecVersion";
      break;
    case -25309:
      result = "errSecReadOnlyAttr";
      break;
    case -25308:
      result = "errSecInteractionNotAllowed";
      break;
    case -25307:
      result = "errSecNoDefaultKeychain";
      break;
    case -25306:
      result = "errSecNoSuchClass";
      break;
    case -25305:
      result = "errSecInvalidSearchRef";
      break;
    case -25304:
      result = "errSecInvalidItemRef";
      break;
    case -25303:
      result = "errSecNoSuchAttr";
      break;
    case -25302:
      result = "errSecDataTooLarge";
      break;
    case -25301:
      result = "errSecBufferTooSmall";
      break;
    case -25300:
      result = "errSecItemNotFound";
      break;
    case -25299:
      result = "errSecDuplicateItem";
      break;
    case -25298:
      result = "errSecInvalidCallback";
      break;
    case -25297:
      result = "errSecDuplicateCallback";
      break;
    case -25296:
      result = "errSecDuplicateKeychain";
      break;
    case -25295:
      result = "errSecInvalidKeychain";
      break;
    case -25294:
      result = "errSecNoSuchKeychain";
      break;
    case -25293:
      result = "errSecAuthFailed";
      break;
    case -25292:
      result = "errSecReadOnly";
      break;
    case -25291:
      result = "errSecNotAvailable";
      break;
    case -25290:
    case -25289:
    case -25288:
    case -25287:
    case -25286:
    case -25285:
    case -25284:
    case -25283:
    case -25282:
    case -25281:
    case -25280:
    case -25279:
    case -25278:
    case -25277:
    case -25276:
    case -25275:
    case -25274:
    case -25273:
    case -25272:
    case -25271:
    case -25270:
    case -25269:
    case -25268:
    case -25267:
    case -25266:
    case -25265:
    case -25264:
    case -25263:
    case -25262:
    case -25261:
    case -25260:
    case -25259:
    case -25258:
    case -25257:
    case -25256:
    case -25255:
    case -25254:
    case -25253:
    case -25252:
    case -25251:
    case -25250:
    case -25249:
    case -25248:
    case -25247:
    case -25246:
    case -25245:
      goto LABEL_5;
    case -25244:
      result = "errSecInvalidOwnerEdit";
      break;
    case -25243:
      result = "errSecNoAccessForItem";
      break;
    case -25242:
      result = "errSecInvalidTrustSetting";
      break;
    case -25241:
      result = "errSecPolicyNotFound";
      break;
    case -25240:
      result = "errSecACLNotSimple";
      break;
    default:
      if (a1)
LABEL_5:
        result = "<unknown>";
      else
        result = "noErr";
      break;
  }
  return result;
}

uint64_t sub_100005930(__SecKey *a1, uint64_t a2, uint64_t a3, int a4)
{
  SecPadding v4;

  if (a4)
    v4 = 32770;
  else
    v4 = 1;
  return SecKeyRawVerify(a1, v4, *(const uint8_t **)(a2 + 8), *(_QWORD *)a2, *(const uint8_t **)(a3 + 8), *(_QWORD *)a3);
}

size_t *sub_100005950(void *a1, uint64_t a2)
{
  const __CFDictionary *v3;
  const __CFDictionary *v4;
  OSStatus v5;
  OSStatus v6;
  size_t *v7;
  SecKeyRef v8;
  NSObject *v9;
  SecKeyRef privateKeyRef;
  CFTypeRef result;
  void *values[4];
  void *keys[4];

  privateKeyRef = 0;
  result = 0;
  keys[0] = (void *)kSecReturnRef;
  keys[1] = (void *)kSecValuePersistentRef;
  keys[2] = (void *)kSecClass;
  keys[3] = (void *)kSecUseSystemKeychain;
  values[0] = kCFBooleanTrue;
  values[1] = a1;
  values[2] = (void *)kSecClassIdentity;
  values[3] = kCFBooleanTrue;
  v3 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 4, 0, 0);
  v4 = v3;
  if (v3)
  {
    v5 = SecItemCopyMatching(v3, &result);
    if (v5 || (v5 = SecIdentityCopyPrivateKey((SecIdentityRef)result, &privateKeyRef)) != 0)
    {
      v6 = v5;
      v7 = 0;
    }
    else
    {
      v7 = sub_10003F1F8(0x400uLL);
      if (v7)
        v6 = SecKeyRawSign(privateKeyRef, 1u, *(const uint8_t **)(a2 + 8), *(_QWORD *)a2, (uint8_t *)v7[1], v7);
      else
        v6 = 0;
    }
  }
  else
  {
    v7 = 0;
    v6 = -1;
  }
  if (result)
    CFRelease(result);
  v8 = privateKeyRef;
  if (privateKeyRef)
    CFRelease(privateKeyRef);
  if (v4)
    CFRelease(v4);
  if (v6 && v7)
  {
    sub_10003F318(v7);
    v7 = 0;
  }
  if ((v6 + 1) >= 2)
  {
    if (dword_10008BA20)
    {
      v9 = ne_log_obj(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_1000558A0();
    }
  }
  return v7;
}

_QWORD *sub_100005B10(void *a1, _DWORD *a2)
{
  const __CFDictionary *v3;
  const __CFDictionary *v4;
  OSStatus v5;
  CFIndex v6;
  const __CFData *v7;
  _QWORD *v8;
  SecCertificateRef v9;
  NSObject *v10;
  const __CFData *v12;
  size_t Length;
  _QWORD *v14;
  CFTypeRef result;
  SecCertificateRef certificateRef;
  void *values[4];
  void *keys[4];
  CFRange v19;

  result = 0;
  certificateRef = 0;
  keys[0] = (void *)kSecReturnRef;
  keys[1] = (void *)kSecValuePersistentRef;
  keys[2] = (void *)kSecClass;
  keys[3] = (void *)kSecUseSystemKeychain;
  values[0] = kCFBooleanTrue;
  values[1] = a1;
  values[2] = (void *)kSecClassIdentity;
  values[3] = kCFBooleanTrue;
  v3 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 4, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v4 = v3;
  if (!v3)
  {
    v7 = 0;
    v8 = 0;
    LODWORD(v6) = -1;
    goto LABEL_7;
  }
  v5 = SecItemCopyMatching(v3, &result);
  if (v5 || (v5 = SecIdentityCopyCertificate((SecIdentityRef)result, &certificateRef)) != 0)
  {
    LODWORD(v6) = v5;
    v7 = 0;
LABEL_5:
    v8 = 0;
    goto LABEL_7;
  }
  v12 = SecCertificateCopyData(certificateRef);
  v7 = v12;
  if (v12)
  {
    Length = CFDataGetLength(v12);
    v6 = Length;
    if (!Length)
      goto LABEL_5;
    v14 = sub_10003F1F8(Length);
    v8 = v14;
    if (v14)
    {
      v19.location = 0;
      v19.length = v6;
      CFDataGetBytes(v7, v19, (UInt8 *)v14[1]);
      if (a2)
      {
        LODWORD(v6) = 0;
        *a2 = sub_100004B2C((uint64_t)certificateRef);
        goto LABEL_7;
      }
    }
  }
  else
  {
    v8 = 0;
  }
  LODWORD(v6) = 0;
LABEL_7:
  if (result)
    CFRelease(result);
  v9 = certificateRef;
  if (certificateRef)
    CFRelease(certificateRef);
  if (v4)
    CFRelease(v4);
  if (v7)
    CFRelease(v7);
  if ((v6 + 1) >= 2)
  {
    if (dword_10008BA20)
    {
      v10 = ne_log_obj(v9);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_100055908();
    }
  }
  return v8;
}

void sub_100005D10(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 2u);
}

void sub_100005D20(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x12u);
}

const char *sub_100005D58(int a1)
{
  return sub_100005760(a1);
}

uint64_t *sub_100005D6C(CCOperation a1, CCAlgorithm a2, CCOptions a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t *v12;
  uint64_t *v13;
  CCCryptorStatus v14;
  CCCryptorStatus v15;
  NSObject *v16;
  NSObject *v18;
  uint64_t v20;
  size_t v21;
  uint8_t buf[4];
  CCOperation v23;
  __int16 v24;
  CCAlgorithm v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  size_t v29;

  v21 = 0;
  v12 = sub_10003F1F8(*(_QWORD *)a4);
  v13 = v12;
  if (v12)
  {
    v14 = CCCrypt(a1, a2, a3, *(const void **)(a5 + 8), *(_QWORD *)a5, *(const void **)(a6 + 8), *(const void **)(a4 + 8), *(_QWORD *)a4, (void *)v12[1], *v12, &v21);
    if (v14)
    {
      if (dword_10008BA20)
      {
        v15 = v14;
        v16 = ne_log_obj();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109632;
          v23 = a1;
          v24 = 1024;
          v25 = a2;
          v26 = 1024;
          LODWORD(v27) = v15;
          _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "crypt %d %d error. status %d.\n", buf, 0x14u);
        }
      }
      sub_10003F318(v13);
      return 0;
    }
    else if (*v13 != v21 && dword_10008BA20 != 0)
    {
      v18 = ne_log_obj();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        v20 = *v13;
        *(_DWORD *)buf = 67109888;
        v23 = a1;
        v24 = 1024;
        v25 = a2;
        v26 = 2048;
        v27 = v20;
        v28 = 2048;
        v29 = v21;
        _os_log_error_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "crypt %d %d length mismatch. expected: %zd. got: %zd.\n", buf, 0x22u);
      }
    }
  }
  return v13;
}

uint64_t *sub_100005F44(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100005D6C(0, 1u, 0, a1, a2, a3);
}

uint64_t *sub_100005F60(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100005D6C(1u, 1u, 0, a1, a2, a3);
}

uint64_t sub_100005F7C()
{
  return 0;
}

uint64_t sub_100005F84(int a1)
{
  if ((a1 & 0xFFFFFFBF) != 0)
    return 0xFFFFFFFFLL;
  else
    return 64;
}

uint64_t *sub_100005F94(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100005D6C(0, 2u, 0, a1, a2, a3);
}

uint64_t *sub_100005FB0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100005D6C(1u, 2u, 0, a1, a2, a3);
}

uint64_t sub_100005FCC()
{
  return 0;
}

uint64_t sub_100005FD4(int a1)
{
  BOOL v1;

  if (a1)
    v1 = a1 == 192;
  else
    v1 = 1;
  if (v1)
    return 192;
  else
    return 0xFFFFFFFFLL;
}

uint64_t *sub_100005FE8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100005D6C(0, 0, 0, a1, a2, a3);
}

uint64_t *sub_100006004(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100005D6C(1u, 0, 0, a1, a2, a3);
}

uint64_t sub_100006020(uint64_t result)
{
  int v1;
  unint64_t v2;
  unsigned int v3;
  unsigned int v4;

  HIDWORD(v2) = result;
  LODWORD(v2) = result;
  v1 = v2 >> 6;
  v3 = v1 - 2;
  if (v1)
    v4 = -1;
  else
    v4 = 128;
  if (v3 >= 3)
    return v4;
  else
    return result;
}

uint64_t sub_100006044()
{
  return 0;
}

uint64_t sub_10000604C()
{
  return 0;
}

uint64_t sub_100006054()
{
  return 0;
}

_QWORD *sub_10000605C(uint64_t a1, uint64_t a2)
{
  CCHmacContext *v4;

  v4 = (CCHmacContext *)malloc_type_malloc(0x180uLL, 0x10000400F47AF14uLL);
  CCHmacInit(v4, 4u, *(const void **)(a1 + 8), *(_QWORD *)a1);
  CCHmacUpdate(v4, *(const void **)(a2 + 8), *(_QWORD *)a2);
  return sub_100006110(v4);
}

CCHmacContext *sub_1000060BC(uint64_t a1)
{
  CCHmacContext *v2;

  v2 = (CCHmacContext *)malloc_type_malloc(0x180uLL, 0x10000400F47AF14uLL);
  CCHmacInit(v2, 4u, *(const void **)(a1 + 8), *(_QWORD *)a1);
  return v2;
}

void sub_100006104(CCHmacContext *a1, uint64_t a2)
{
  CCHmacUpdate(a1, *(const void **)(a2 + 8), *(_QWORD *)a2);
}

_QWORD *sub_100006110(CCHmacContext *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = sub_10003F1F8(0x40uLL);
  v3 = v2;
  if (v2)
  {
    CCHmacFinal(a1, (void *)v2[1]);
    *v3 = 64;
    free(a1);
  }
  return v3;
}

_QWORD *sub_10000615C(uint64_t a1, uint64_t a2)
{
  CCHmacContext *v4;

  v4 = (CCHmacContext *)malloc_type_malloc(0x180uLL, 0x10000400F47AF14uLL);
  CCHmacInit(v4, 3u, *(const void **)(a1 + 8), *(_QWORD *)a1);
  CCHmacUpdate(v4, *(const void **)(a2 + 8), *(_QWORD *)a2);
  return sub_100006210(v4);
}

CCHmacContext *sub_1000061BC(uint64_t a1)
{
  CCHmacContext *v2;

  v2 = (CCHmacContext *)malloc_type_malloc(0x180uLL, 0x10000400F47AF14uLL);
  CCHmacInit(v2, 3u, *(const void **)(a1 + 8), *(_QWORD *)a1);
  return v2;
}

void sub_100006204(CCHmacContext *a1, uint64_t a2)
{
  CCHmacUpdate(a1, *(const void **)(a2 + 8), *(_QWORD *)a2);
}

_QWORD *sub_100006210(CCHmacContext *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = sub_10003F1F8(0x30uLL);
  v3 = v2;
  if (v2)
  {
    CCHmacFinal(a1, (void *)v2[1]);
    *v3 = 48;
    free(a1);
  }
  return v3;
}

_QWORD *sub_10000625C(uint64_t a1, uint64_t a2)
{
  CCHmacContext *v4;

  v4 = (CCHmacContext *)malloc_type_malloc(0x180uLL, 0x10000400F47AF14uLL);
  CCHmacInit(v4, 2u, *(const void **)(a1 + 8), *(_QWORD *)a1);
  CCHmacUpdate(v4, *(const void **)(a2 + 8), *(_QWORD *)a2);
  return sub_100006310(v4);
}

CCHmacContext *sub_1000062BC(uint64_t a1)
{
  CCHmacContext *v2;

  v2 = (CCHmacContext *)malloc_type_malloc(0x180uLL, 0x10000400F47AF14uLL);
  CCHmacInit(v2, 2u, *(const void **)(a1 + 8), *(_QWORD *)a1);
  return v2;
}

void sub_100006304(CCHmacContext *a1, uint64_t a2)
{
  CCHmacUpdate(a1, *(const void **)(a2 + 8), *(_QWORD *)a2);
}

_QWORD *sub_100006310(CCHmacContext *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = sub_10003F1F8(0x20uLL);
  v3 = v2;
  if (v2)
  {
    CCHmacFinal(a1, (void *)v2[1]);
    *v3 = 32;
    free(a1);
  }
  return v3;
}

_QWORD *sub_10000635C(uint64_t a1, uint64_t a2)
{
  CCHmacContext *v4;

  v4 = (CCHmacContext *)malloc_type_malloc(0x180uLL, 0x10000400F47AF14uLL);
  CCHmacInit(v4, 0, *(const void **)(a1 + 8), *(_QWORD *)a1);
  CCHmacUpdate(v4, *(const void **)(a2 + 8), *(_QWORD *)a2);
  return sub_100006410(v4);
}

CCHmacContext *sub_1000063BC(uint64_t a1)
{
  CCHmacContext *v2;

  v2 = (CCHmacContext *)malloc_type_malloc(0x180uLL, 0x10000400F47AF14uLL);
  CCHmacInit(v2, 0, *(const void **)(a1 + 8), *(_QWORD *)a1);
  return v2;
}

void sub_100006404(CCHmacContext *a1, uint64_t a2)
{
  CCHmacUpdate(a1, *(const void **)(a2 + 8), *(_QWORD *)a2);
}

_QWORD *sub_100006410(CCHmacContext *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = sub_10003F1F8(0x14uLL);
  v3 = v2;
  if (v2)
  {
    CCHmacFinal(a1, (void *)v2[1]);
    *v3 = 20;
    free(a1);
  }
  return v3;
}

_QWORD *sub_10000645C(uint64_t a1, uint64_t a2)
{
  CCHmacContext *v4;

  v4 = (CCHmacContext *)malloc_type_malloc(0x180uLL, 0x10000400F47AF14uLL);
  CCHmacInit(v4, 1u, *(const void **)(a1 + 8), *(_QWORD *)a1);
  CCHmacUpdate(v4, *(const void **)(a2 + 8), *(_QWORD *)a2);
  return sub_100006510(v4);
}

CCHmacContext *sub_1000064BC(uint64_t a1)
{
  CCHmacContext *v2;

  v2 = (CCHmacContext *)malloc_type_malloc(0x180uLL, 0x10000400F47AF14uLL);
  CCHmacInit(v2, 1u, *(const void **)(a1 + 8), *(_QWORD *)a1);
  return v2;
}

void sub_100006504(CCHmacContext *a1, uint64_t a2)
{
  CCHmacUpdate(a1, *(const void **)(a2 + 8), *(_QWORD *)a2);
}

_QWORD *sub_100006510(CCHmacContext *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = sub_10003F1F8(0x10uLL);
  v3 = v2;
  if (v2)
  {
    CCHmacFinal(a1, (void *)v2[1]);
    *v3 = 16;
    free(a1);
  }
  return v3;
}

_QWORD *sub_10000655C(uint64_t a1, uint64_t a2)
{
  CCHmacContext *v4;

  v4 = (CCHmacContext *)malloc_type_malloc(0x180uLL, 0x10000400F47AF14uLL);
  CCHmacInit(v4, 0, *(const void **)(a1 + 8), *(_QWORD *)a1);
  CCHmacUpdate(v4, *(const void **)(a2 + 8), *(_QWORD *)a2);
  return sub_100006610(v4);
}

CCHmacContext *sub_1000065BC(uint64_t a1)
{
  CCHmacContext *v2;

  v2 = (CCHmacContext *)malloc_type_malloc(0x180uLL, 0x10000400F47AF14uLL);
  CCHmacInit(v2, 0, *(const void **)(a1 + 8), *(_QWORD *)a1);
  return v2;
}

void sub_100006604(CCHmacContext *a1, uint64_t a2)
{
  CCHmacUpdate(a1, *(const void **)(a2 + 8), *(_QWORD *)a2);
}

_QWORD *sub_100006610(CCHmacContext *a1)
{
  CCHmacContext *v2;
  CCHmacContext *v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  CCHmacContext *v7;

  v2 = (CCHmacContext *)malloc_type_malloc(0x14uLL, 0x16DB4ACAuLL);
  if (!v2)
    return 0;
  v3 = v2;
  v4 = sub_10003F1F8(0xCuLL);
  if (v4)
  {
    CCHmacFinal(a1, v3);
    v5 = v4[1];
    v6 = *(_QWORD *)v3->ctx;
    *(_DWORD *)(v5 + 8) = v3->ctx[2];
    *(_QWORD *)v5 = v6;
    *v4 = 12;
    free(v3);
    v7 = a1;
  }
  else
  {
    v7 = v3;
  }
  free(v7);
  return v4;
}

_QWORD *sub_1000066A8(uint64_t a1, uint64_t a2)
{
  CCHmacContext *v4;

  v4 = (CCHmacContext *)malloc_type_malloc(0x180uLL, 0x10000400F47AF14uLL);
  CCHmacInit(v4, 1u, *(const void **)(a1 + 8), *(_QWORD *)a1);
  CCHmacUpdate(v4, *(const void **)(a2 + 8), *(_QWORD *)a2);
  return sub_100006750(v4);
}

CCHmacContext *sub_100006708(uint64_t a1)
{
  CCHmacContext *v2;

  v2 = (CCHmacContext *)malloc_type_malloc(0x180uLL, 0x10000400F47AF14uLL);
  CCHmacInit(v2, 1u, *(const void **)(a1 + 8), *(_QWORD *)a1);
  return v2;
}

_QWORD *sub_100006750(CCHmacContext *a1)
{
  CCHmacContext *v2;
  CCHmacContext *v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  CCHmacContext *v7;

  v2 = (CCHmacContext *)malloc_type_malloc(0x10uLL, 0xCCDBC132uLL);
  if (!v2)
    return 0;
  v3 = v2;
  v4 = sub_10003F1F8(0xCuLL);
  if (v4)
  {
    CCHmacFinal(a1, v3);
    v5 = v4[1];
    v6 = *(_QWORD *)v3->ctx;
    *(_DWORD *)(v5 + 8) = v3->ctx[2];
    *(_QWORD *)v5 = v6;
    *v4 = 12;
    free(v3);
    v7 = a1;
  }
  else
  {
    v7 = v3;
  }
  free(v7);
  return v4;
}

CC_SHA512_CTX *sub_1000067E8()
{
  CC_SHA512_CTX *v0;

  v0 = (CC_SHA512_CTX *)malloc_type_malloc(0xD0uLL, 0x10000400F93440CuLL);
  CC_SHA512_Init(v0);
  return v0;
}

uint64_t sub_100006824(CC_SHA512_CTX *a1, uint64_t a2)
{
  return CC_SHA512_Update(a1, *(const void **)(a2 + 8), *(_DWORD *)a2);
}

_QWORD *sub_100006834(CC_SHA512_CTX *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = sub_10003F1F8(0x40uLL);
  v3 = v2;
  if (v2)
  {
    CC_SHA512_Final((unsigned __int8 *)v2[1], a1);
    free(a1);
  }
  return v3;
}

_QWORD *sub_100006878(uint64_t a1)
{
  CC_SHA512_CTX *v2;

  v2 = (CC_SHA512_CTX *)malloc_type_malloc(0xD0uLL, 0x10000400F93440CuLL);
  CC_SHA512_Init(v2);
  CC_SHA512_Update(v2, *(const void **)(a1 + 8), *(_DWORD *)a1);
  return sub_100006834(v2);
}

uint64_t sub_1000068C8()
{
  return 512;
}

CC_SHA512_CTX *sub_1000068D0()
{
  CC_SHA512_CTX *v0;

  v0 = (CC_SHA512_CTX *)malloc_type_malloc(0xD0uLL, 0x10000400F93440CuLL);
  CC_SHA384_Init(v0);
  return v0;
}

uint64_t sub_10000690C(CC_SHA512_CTX *a1, uint64_t a2)
{
  return CC_SHA384_Update(a1, *(const void **)(a2 + 8), *(_DWORD *)a2);
}

_QWORD *sub_10000691C(CC_SHA512_CTX *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = sub_10003F1F8(0x30uLL);
  v3 = v2;
  if (v2)
  {
    CC_SHA384_Final((unsigned __int8 *)v2[1], a1);
    free(a1);
  }
  return v3;
}

_QWORD *sub_100006960(uint64_t a1)
{
  CC_SHA512_CTX *v2;

  v2 = (CC_SHA512_CTX *)malloc_type_malloc(0xD0uLL, 0x10000400F93440CuLL);
  CC_SHA384_Init(v2);
  CC_SHA384_Update(v2, *(const void **)(a1 + 8), *(_DWORD *)a1);
  return sub_10000691C(v2);
}

uint64_t sub_1000069B0()
{
  return 384;
}

CC_SHA256_CTX *sub_1000069B8()
{
  CC_SHA256_CTX *v0;

  v0 = (CC_SHA256_CTX *)malloc_type_malloc(0x68uLL, 0x1000040ED882C02uLL);
  CC_SHA256_Init(v0);
  return v0;
}

uint64_t sub_1000069F4(CC_SHA256_CTX *a1, uint64_t a2)
{
  return CC_SHA256_Update(a1, *(const void **)(a2 + 8), *(_DWORD *)a2);
}

_QWORD *sub_100006A04(CC_SHA256_CTX *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = sub_10003F1F8(0x20uLL);
  v3 = v2;
  if (v2)
  {
    CC_SHA256_Final((unsigned __int8 *)v2[1], a1);
    free(a1);
  }
  return v3;
}

_QWORD *sub_100006A48(uint64_t a1)
{
  CC_SHA256_CTX *v2;

  v2 = (CC_SHA256_CTX *)malloc_type_malloc(0x68uLL, 0x1000040ED882C02uLL);
  CC_SHA256_Init(v2);
  CC_SHA256_Update(v2, *(const void **)(a1 + 8), *(_DWORD *)a1);
  return sub_100006A04(v2);
}

uint64_t sub_100006A98()
{
  return 256;
}

CC_SHA1_CTX *sub_100006AA0()
{
  CC_SHA1_CTX *v0;

  v0 = (CC_SHA1_CTX *)malloc_type_malloc(0x60uLL, 0x1000040565EDBD2uLL);
  CC_SHA1_Init(v0);
  return v0;
}

uint64_t sub_100006ADC(CC_SHA1_CTX *a1, uint64_t a2)
{
  return CC_SHA1_Update(a1, *(const void **)(a2 + 8), *(_DWORD *)a2);
}

_QWORD *sub_100006AEC(CC_SHA1_CTX *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = sub_10003F1F8(0x14uLL);
  v3 = v2;
  if (v2)
  {
    CC_SHA1_Final((unsigned __int8 *)v2[1], a1);
    free(a1);
  }
  return v3;
}

_QWORD *sub_100006B30(uint64_t a1)
{
  CC_SHA1_CTX *v2;

  v2 = (CC_SHA1_CTX *)malloc_type_malloc(0x60uLL, 0x1000040565EDBD2uLL);
  CC_SHA1_Init(v2);
  CC_SHA1_Update(v2, *(const void **)(a1 + 8), *(_DWORD *)a1);
  return sub_100006AEC(v2);
}

uint64_t sub_100006B80()
{
  return 160;
}

CC_MD5_CTX *sub_100006B88()
{
  CC_MD5_CTX *v0;

  v0 = (CC_MD5_CTX *)malloc_type_malloc(0x5CuLL, 0x100004034A301B9uLL);
  CC_MD5_Init(v0);
  return v0;
}

uint64_t sub_100006BC4(CC_MD5_CTX *a1, uint64_t a2)
{
  return CC_MD5_Update(a1, *(const void **)(a2 + 8), *(_DWORD *)a2);
}

_QWORD *sub_100006BD4(CC_MD5_CTX *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = sub_10003F1F8(0x10uLL);
  v3 = v2;
  if (v2)
  {
    CC_MD5_Final((unsigned __int8 *)v2[1], a1);
    free(a1);
  }
  return v3;
}

_QWORD *sub_100006C18(uint64_t a1)
{
  CC_MD5_CTX *v2;

  v2 = (CC_MD5_CTX *)malloc_type_malloc(0x5CuLL, 0x100004034A301B9uLL);
  CC_MD5_Init(v2);
  CC_MD5_Update(v2, *(const void **)(a1 + 8), *(_DWORD *)a1);
  return sub_100006BD4(v2);
}

uint64_t sub_100006C68()
{
  return 128;
}

_QWORD *sub_100006C70(unsigned int a1)
{
  size_t v1;
  _QWORD *v2;

  v1 = a1;
  v2 = sub_10003F1F8(a1);
  if (v2 && SecRandomCopyBytes(kSecRandomDefault, v1, (void *)v2[1]))
  {
    sub_10003F318(v2);
    return 0;
  }
  return v2;
}

uint64_t sub_100006CC8()
{
  _QWORD *v0;
  uint64_t v1;

  v0 = sub_100006C70(4u);
  v1 = *(unsigned int *)v0[1];
  sub_10003F318(v0);
  return v1;
}

_QWORD *sub_100006CF8()
{
  _QWORD *result;

  result = malloc_type_calloc(0x10uLL, 1uLL, 0x46AAAA86uLL);
  *result = 0;
  result[1] = result;
  return result;
}

_QWORD *sub_100006D20(uint64_t *a1, uint64_t a2)
{
  _QWORD *result;
  uint64_t v5;
  _QWORD *v6;

  result = malloc_type_calloc(0x18uLL, 1uLL, 0x9D051F30uLL);
  *result = a2;
  v5 = *a1;
  result[1] = *a1;
  if (v5)
    v6 = (_QWORD *)(v5 + 16);
  else
    v6 = a1 + 1;
  *v6 = result + 1;
  *a1 = (uint64_t)result;
  result[2] = a1;
  return result;
}

_QWORD *sub_100006D80(uint64_t a1, uint64_t a2)
{
  _QWORD *result;
  _QWORD *v5;

  result = malloc_type_calloc(0x18uLL, 1uLL, 0xD063D6B9uLL);
  result[1] = 0;
  *result = a2;
  v5 = *(_QWORD **)(a1 + 8);
  result[2] = v5;
  *v5 = result;
  *(_QWORD *)(a1 + 8) = result + 1;
  return result;
}

uint64_t sub_100006DD0(_QWORD *a1, uint64_t (*a2)(_QWORD, uint64_t), uint64_t a3)
{
  _QWORD *v3;
  uint64_t result;

  v3 = (_QWORD *)*a1;
  if (!*a1)
    return 0;
  while (1)
  {
    result = a2(*v3, a3);
    if (result)
      break;
    v3 = (_QWORD *)v3[1];
    if (!v3)
      return 0;
  }
  return result;
}

uint64_t sub_100006E1C(_QWORD *a1, _QWORD *a2)
{
  _QWORD *v2;

  if (a1)
  {
    v2 = (_QWORD *)*a1;
    if (!a2)
    {
      if (!v2)
        return 0;
      return *v2;
    }
  }
  else
  {
    if (!a2)
      return 0;
    v2 = (_QWORD *)*a2;
    if (*a2)
      v2 = (_QWORD *)v2[1];
  }
  *a2 = v2;
  if (v2)
    return *v2;
  return 0;
}

void sub_100006E58(_QWORD *a1, void (*a2)(_QWORD))
{
  _QWORD *i;
  uint64_t v5;
  _QWORD *v6;

  for (i = **(_QWORD ***)(a1[1] + 8); i; i = **(_QWORD ***)(a1[1] + 8))
  {
    v5 = i[1];
    v6 = (_QWORD *)i[2];
    if (v5)
    {
      *(_QWORD *)(v5 + 16) = v6;
      v6 = (_QWORD *)i[2];
    }
    else
    {
      a1[1] = v6;
    }
    *v6 = v5;
    if (a2)
      a2(*i);
    free(i);
  }
  free(a1);
}

_QWORD *sub_100006ED4()
{
  uint64_t v0;
  _QWORD *result;
  _QWORD *v2;

  v0 = qword_10008B848;
  result = *(_QWORD **)(qword_10008B848 + 120);
  if (result)
  {
    do
    {
      v2 = (_QWORD *)*result;
      sub_100006F18(result);
      result = v2;
    }
    while (v2);
    v0 = qword_10008B848;
  }
  *(_QWORD *)(v0 + 120) = 0;
  return result;
}

void sub_100006F18(_QWORD *a1)
{
  void *v2;
  void *v3;

  v2 = (void *)a1[1];
  if (v2)
    free(v2);
  v3 = (void *)a1[5];
  if (v3)
    free(v3);
  free(a1);
}

uint64_t *sub_100006F50(const sockaddr *a1, int a2)
{
  uint64_t *i;
  const sockaddr *v5;
  char __s2[1025];
  char __s1[1025];

  i = 0;
  if (!getnameinfo(a1, a1->sa_len, __s1, 0x401u, 0, 0, 2))
  {
    for (i = *(uint64_t **)(qword_10008B848 + 120); i; i = (uint64_t *)*i)
    {
      v5 = (const sockaddr *)i[1];
      if (v5 && (a2 != 0) == (*((_DWORD *)i + 8) != 0) && a1->sa_family == v5->sa_family)
      {
        if (getnameinfo(v5, v5->sa_len, __s2, 0x401u, 0, 0, 2))
          return 0;
        if (!strcmp(__s1, __s2))
          return i;
      }
    }
  }
  return i;
}

void sub_100007074()
{
  void *v0;
  uint64_t *i;
  ifaddrs *v2;
  const char *v3;
  sockaddr *ifa_addr;
  int sa_family;
  const char *ifa_name;
  int v8;
  const char *v9;
  uint64_t v10;
  NSObject *v11;
  __int128 v12;
  uint64_t v13;
  uint64_t *v14;
  __int128 *v15;
  _QWORD *v16;
  _QWORD *v17;
  const sockaddr *v18;
  const sockaddr *v19;
  char *v20;
  uint64_t v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  NSObject *v25;
  char *v26;
  char *v27;
  char *v28;
  ifaddrs *v29;
  NSObject *v30;
  NSObject *v31;
  NSObject *v32;
  NSObject *v33;
  NSObject *v34;
  NSObject *v35;
  ifaddrs *v36;
  uint8_t v37;
  _BYTE v38[14];
  char v39[1025];
  uint8_t buf[48];
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;

  v36 = 0;
  v0 = (void *)getifaddrs(&v36);
  if ((_DWORD)v0)
  {
    if (dword_10008BA20)
    {
      v30 = ne_log_obj(v0);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        sub_100055AE4(v30);
    }
    goto LABEL_74;
  }
  for (i = *(uint64_t **)(qword_10008B848 + 120); i; i = (uint64_t *)*i)
    *((_DWORD *)i + 9) = 0;
  v2 = v36;
  if (!v36)
  {
    v29 = 0;
    goto LABEL_55;
  }
  v3 = "llw";
  do
  {
    ifa_addr = v2->ifa_addr;
    sa_family = ifa_addr->sa_family;
    if (sa_family != 30 && sa_family != 2)
      goto LABEL_52;
    ifa_name = v2->ifa_name;
    if (ifa_name)
    {
      v0 = strnstr(v2->ifa_name, "awdl", 0x10uLL);
      if (v0)
        goto LABEL_52;
      v0 = strnstr(ifa_name, v3, 0x10uLL);
      if (v0)
        goto LABEL_52;
      ifa_name = v2->ifa_name;
      ifa_addr = v2->ifa_addr;
      sa_family = ifa_addr->sa_family;
    }
    if (sa_family != 2)
    {
      if (sa_family != 30)
        goto LABEL_49;
      v0 = (void *)socket(30, 2, 0);
      if ((_DWORD)v0 == -1)
      {
        if (dword_10008BA20)
        {
          v23 = ne_log_obj(v0);
          v0 = (void *)os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
          if ((_DWORD)v0)
            sub_100055A20();
        }
        goto LABEL_49;
      }
      v8 = (int)v0;
      v9 = v3;
      v10 = fcntl((int)v0, 4, 4);
      if ((_DWORD)v10 == -1)
      {
        if (dword_10008BA20)
        {
          v11 = ne_log_obj(v10);
          if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
            sub_100055AA8(&v37, v38, v11);
        }
      }
      v54 = 0u;
      v55 = 0u;
      v52 = 0u;
      v53 = 0u;
      v50 = 0u;
      v51 = 0u;
      v48 = 0u;
      v49 = 0u;
      v46 = 0u;
      v47 = 0u;
      v44 = 0u;
      v45 = 0u;
      v42 = 0u;
      v43 = 0u;
      v41 = 0u;
      memset(buf, 0, sizeof(buf));
      __strlcpy_chk(buf, ifa_name, 16, 16);
      v12 = *(_OWORD *)&ifa_addr->sa_data[10];
      *(sockaddr *)&buf[16] = *ifa_addr;
      *(_OWORD *)&buf[28] = v12;
      v13 = ioctl(v8, 0xC1206949uLL, buf);
      if ((v13 & 0x80000000) != 0)
      {
        v3 = v9;
        if (dword_10008BA20)
        {
          v24 = ne_log_obj(v13);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
            sub_100055A64();
        }
        v0 = (void *)close(v8);
LABEL_49:
        if (dword_10008BA20)
        {
          v25 = ne_log_obj(v0);
          v0 = (void *)os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG);
          if ((_DWORD)v0)
          {
            v26 = v2->ifa_name;
            v27 = sub_10003C8A0(v2->ifa_addr);
            *(_DWORD *)buf = 136315394;
            *(_QWORD *)&buf[4] = v26;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = v27;
            _os_log_debug_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEBUG, "unsuitable address: %s %s\n", buf, 0x16u);
          }
        }
        goto LABEL_52;
      }
      v0 = (void *)close(v8);
      v3 = v9;
      if ((buf[16] & 0x1D) != 0)
        goto LABEL_49;
      ifa_addr = v2->ifa_addr;
    }
    v14 = sub_100006F50(ifa_addr, 0);
    if (v14)
    {
      v15 = (__int128 *)v14;
      *((_DWORD *)v14 + 9) = 1;
      v0 = sub_100006F50(v2->ifa_addr, 1);
      if (v0)
      {
        *((_DWORD *)v0 + 9) = 1;
        goto LABEL_52;
      }
      v0 = (void *)sub_10003FD00();
      if ((_DWORD)v0)
      {
        v0 = sub_100007618(v15);
        if (v0)
          goto LABEL_44;
        if (dword_10008BA20)
        {
          v35 = ne_log_obj(0);
          if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
            goto LABEL_73;
        }
        goto LABEL_74;
      }
    }
    else
    {
      v16 = sub_100007750();
      if (!v16)
      {
        if (dword_10008BA20)
        {
          v31 = ne_log_obj(0);
          if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
            sub_100055970();
        }
        goto LABEL_74;
      }
      v17 = v16;
      v18 = (const sockaddr *)sub_10003C6F8(&v2->ifa_addr->sa_len);
      v17[1] = v18;
      if (!v18)
      {
        if (dword_10008BA20)
        {
          v32 = ne_log_obj(0);
          if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
            sub_10005599C();
        }
        goto LABEL_74;
      }
      v19 = v18;
      v20 = strdup(v2->ifa_name);
      v17[5] = v20;
      if (!v20)
      {
        if (dword_10008BA20)
        {
          v33 = ne_log_obj(0);
          if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
            sub_1000559C8();
        }
        goto LABEL_74;
      }
      *((_DWORD *)v17 + 9) = 1;
      v21 = getnameinfo(v19, v19->sa_len, v39, 0x401u, 0, 0, 2);
      if ((_DWORD)v21)
        v21 = __strlcpy_chk(v39, "(invalid)", 1025, 1025);
      if (dword_10008BA20)
      {
        v22 = ne_log_obj(v21);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
        {
          v28 = v2->ifa_name;
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)&buf[4] = v39;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = v28;
          _os_log_debug_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEBUG, "my interface: %s (%s)\n", buf, 0x16u);
        }
      }
      *v17 = *(_QWORD *)(qword_10008B848 + 120);
      *(_QWORD *)(qword_10008B848 + 120) = v17;
      v0 = (void *)sub_10003FD00();
      if ((_DWORD)v0)
      {
        v0 = sub_100007618((__int128 *)v17);
        if (v0)
        {
LABEL_44:
          *((_DWORD *)v0 + 8) = 1;
          goto LABEL_52;
        }
        if (dword_10008BA20)
        {
          v34 = ne_log_obj(0);
          if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
LABEL_73:
            sub_1000559F4();
        }
LABEL_74:
        exit(1);
      }
    }
LABEL_52:
    v2 = v2->ifa_next;
  }
  while (v2);
  v29 = v36;
LABEL_55:
  freeifaddrs(v29);
}

_QWORD *sub_100007618(__int128 *a1)
{
  _OWORD *v2;
  _QWORD *v3;
  __int128 v4;
  __int128 v5;
  void *v6;
  const char *v7;
  char *v8;
  NSObject *v9;
  NSObject *v10;
  NSObject *v11;

  v2 = malloc_type_calloc(1uLL, 0x30uLL, 0x1030040DBADB428uLL);
  if (!v2)
  {
    if (dword_10008BA20)
    {
      v9 = ne_log_obj(0);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_100055B64();
    }
    return 0;
  }
  v3 = v2;
  v4 = *a1;
  v5 = a1[2];
  v2[1] = a1[1];
  v2[2] = v5;
  *v2 = v4;
  v6 = sub_10003C6F8(*((unsigned __int8 **)a1 + 1));
  v3[1] = v6;
  if (!v6)
  {
    if (dword_10008BA20)
    {
      v10 = ne_log_obj(0);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_100055B90();
    }
    goto LABEL_16;
  }
  v7 = (const char *)*((_QWORD *)a1 + 5);
  if (v7)
  {
    v8 = strdup(v7);
    v3[5] = v8;
    if (!v8)
    {
      if (dword_10008BA20)
      {
        v11 = ne_log_obj(0);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          sub_100055BBC();
      }
      free((void *)v3[1]);
LABEL_16:
      free(v3);
      return 0;
    }
  }
  v3[3] = 0;
  *((_DWORD *)v3 + 4) = -1;
  *v3 = *(_QWORD *)a1;
  *(_QWORD *)a1 = v3;
  return v3;
}

_QWORD *sub_100007750()
{
  _QWORD *v0;
  _QWORD *v1;
  NSObject *v2;

  v0 = malloc_type_calloc(1uLL, 0x30uLL, 0x1030040DBADB428uLL);
  v1 = v0;
  if (v0)
  {
    v0[3] = 0;
    *v0 = 0;
    v0[1] = 0;
    *((_DWORD *)v0 + 4) = -1;
  }
  else if (dword_10008BA20)
  {
    v2 = ne_log_obj(0);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_100055B64();
  }
  return v1;
}

uint64_t sub_1000077D4(_WORD *a1)
{
  NSObject *v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (dword_10008BA20)
  {
    v1 = ne_log_obj(a1);
    a1 = (_WORD *)os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG);
    if ((_DWORD)a1)
      sub_100055C4C();
  }
  v2 = *(uint64_t **)(qword_10008B848 + 120);
  if (v2)
  {
    LODWORD(v3) = 0;
    do
    {
      if (*((_DWORD *)v2 + 8))
        v4 = 18;
      else
        v4 = 16;
      a1 = sub_10003D350(v2[1], *(unsigned __int16 *)(qword_10008B848 + v4));
      v3 = (v3 + 1);
      v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    v3 = 0;
  }
  if (dword_10008BA20)
  {
    v5 = ne_log_obj(a1);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      sub_100055BE8(v3, v5, v6, v7, v8, v9, v10, v11);
  }
  return 0;
}

uint64_t sub_1000078AC(unint64_t a1)
{
  _QWORD *v1;
  _QWORD *v3;
  unint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  int v8;
  NSObject *v9;
  uint8_t v11[4];
  int v12;

  v1 = *(_QWORD **)(qword_10008B848 + 120);
  if (v1)
  {
    v3 = 0;
    do
    {
      v5 = v1 + 1;
      v4 = v1[1];
      if (v4)
      {
        v6 = sub_10003B380(a1, v4);
        if (!(_DWORD)v6)
        {
          v7 = v1;
          if (!v3)
            goto LABEL_6;
          v8 = *(unsigned __int8 *)(*v5 + 1);
          if (v8 == 30 || v8 == 2)
          {
            if (*(_WORD *)(*v5 + 2) == 500)
              v7 = v1;
            else
              v7 = v3;
            goto LABEL_6;
          }
          if (dword_10008BA20)
          {
            v9 = ne_log_obj(v6);
            if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
              sub_100055C78(v11, (uint64_t)(v1 + 1), &v12, v9);
          }
        }
      }
      v7 = v3;
LABEL_6:
      v1 = (_QWORD *)*v1;
      v3 = v7;
    }
    while (v1);
  }
  return 62465;
}

_QWORD *sub_1000079D0(_QWORD *result, _QWORD *a2)
{
  *result = *a2;
  *a2 = result;
  return result;
}

uint64_t sub_1000079E0()
{
  _WORD *v0;
  uint64_t v1;

  sub_100007074();
  sub_100024030();
  v1 = sub_1000077D4(v0);
  return sub_100023318(v1);
}

uint64_t sub_1000079FC()
{
  _WORD *v0;

  if (!*(_QWORD *)(qword_10008B848 + 120) && *(_DWORD *)(qword_10008B848 + 112) == 1)
  {
    sub_100007074();
    sub_1000077D4(v0);
  }
  return 0;
}

uint64_t sub_100007A38(unsigned __int8 *__s1)
{
  unsigned __int8 *v1;
  _QWORD *v2;
  _QWORD *v3;
  unsigned __int8 *v4;
  size_t v5;
  NSObject *v7;
  uint64_t v8;

  v1 = __s1;
  v2 = *(_QWORD **)(qword_10008B848 + 120);
  if (v2)
  {
    v3 = 0;
    do
    {
      v4 = (unsigned __int8 *)v2[1];
      if (v4)
      {
        if (v1[1] == v4[1])
        {
          v5 = *v1;
          v3 = v2;
          if ((_DWORD)v5 == *v4)
          {
            __s1 = (unsigned __int8 *)memcmp(v1, v4, v5);
            v3 = v2;
            if (!(_DWORD)__s1)
            {
              v3 = v2;
              return *((unsigned int *)v3 + 4);
            }
          }
        }
      }
      v2 = (_QWORD *)*v2;
    }
    while (v2);
    if (!v3)
      goto LABEL_10;
    return *((unsigned int *)v3 + 4);
  }
  else
  {
LABEL_10:
    if (dword_10008BA20)
    {
      v7 = ne_log_obj(__s1);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_100055CC0((uint64_t)v1, v7, v8);
    }
    return 0xFFFFFFFFLL;
  }
}

void sub_100007AFC()
{
  ssize_t v0;
  int *v1;
  NSObject *v2;
  NSObject *v3;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _OWORD v12[70];

  memset(v12, 0, 512);
  while (1)
  {
    v0 = read(*(_DWORD *)(qword_10008B848 + 36), v12, 0x45CuLL);
    if ((v0 & 0x80000000) == 0)
      break;
    v1 = __error();
    if (*v1 != 4)
    {
      if (dword_10008BA20)
      {
        v2 = ne_log_obj(v1);
        if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
          sub_100055D2C();
      }
      return;
    }
  }
  if (v0 >= LOWORD(v12[0]))
  {
    if (BYTE3(v12[0]) <= 0xEu && ((1 << SBYTE3(v12[0])) & 0x7004) != 0)
    {
      if (dword_10008BA20)
      {
        v5 = ne_log_obj(v0);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
          sub_100055DC8((uint64_t)v12 + 3, v5, v6, v7, v8, v9, v10, v11);
      }
      sub_1000079E0();
    }
  }
  else if (dword_10008BA20)
  {
    v3 = ne_log_obj(v0);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
      sub_100055D9C();
  }
}

void sub_100007C84()
{
  dispatch_source_cancel(*(dispatch_source_t *)(qword_10008B848 + 56));
  *(_QWORD *)(qword_10008B848 + 56) = 0;
}

uint64_t sub_100007CB8()
{
  uint64_t v0;
  uint64_t v1;
  NSObject *v3;
  NSObject *v4;
  int v5;
  NSObject *v6;
  NSObject *v8;
  NSObject *v9;
  _QWORD handler[4];
  int v11;

  v0 = socket(17, 3, 0);
  *(_DWORD *)(qword_10008B848 + 36) = v0;
  if ((v0 & 0x80000000) != 0)
  {
    if (dword_10008BA20)
    {
      v8 = ne_log_obj(v0);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        sub_100055E30();
    }
  }
  else
  {
    v1 = fcntl(v0, 4, 4);
    if ((_DWORD)v1 == -1 && dword_10008BA20 != 0)
    {
      v3 = ne_log_obj(v1);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
        sub_100055ECC();
    }
    v4 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, *(int *)(qword_10008B848 + 36), 0, (dispatch_queue_t)&_dispatch_main_q);
    *(_QWORD *)(qword_10008B848 + 56) = v4;
    if (v4)
    {
      dispatch_source_set_event_handler_f(v4, (dispatch_function_t)sub_100007AFC);
      v5 = *(_DWORD *)(qword_10008B848 + 36);
      v6 = *(NSObject **)(qword_10008B848 + 56);
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 0x40000000;
      handler[2] = sub_100007E38;
      handler[3] = &unk_100084EA8;
      v11 = v5;
      dispatch_source_set_cancel_handler(v6, handler);
      dispatch_resume(*(dispatch_object_t *)(qword_10008B848 + 56));
      return 0;
    }
    if (dword_10008BA20)
    {
      v9 = ne_log_obj(0);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
        sub_100055EA0();
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100007E38(uint64_t a1)
{
  return close(*(_DWORD *)(a1 + 32));
}

char *sub_100007E40(int *a1)
{
  return strerror(*a1);
}

void sub_100007E48(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_debug_impl(a1, v9, OS_LOG_TYPE_DEBUG, a4, &a9, 0xCu);
}

void sub_100007E5C(void *a1, uint64_t a2, uint64_t a3, const char *a4)
{
  NSObject *v4;
  uint8_t *v5;

  _os_log_error_impl(a1, v4, OS_LOG_TYPE_ERROR, a4, v5, 0xCu);
}

void sub_100007E70(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 8u);
}

int *sub_100007E80()
{
  return __error();
}

void sub_100007E90(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 8u);
}

int *sub_100007EA8()
{
  return __error();
}

uint64_t sub_100007EB0(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v4;

  if (a1)
    return sub_100007F0C(a1, a2);
  v4 = qword_10008C6D0;
  if (!qword_10008C6D0)
    return 0;
  while (1)
  {
    result = sub_100007F0C(v4, a2);
    if (result)
      break;
    v4 = *(_QWORD *)(v4 + 1712);
    if (!v4)
      return 0;
  }
  return result;
}

uint64_t sub_100007F0C(uint64_t a1, _QWORD *a2)
{
  uint64_t result;

  for (result = *(_QWORD *)(a1 + 1696); result; result = *(_QWORD *)(result + 456))
  {
    if ((*(_BYTE *)(result + 17) & 0x40) == 0 && *(_QWORD *)result == *a2 && *(_QWORD *)(result + 8) == a2[1])
      break;
  }
  return result;
}

uint64_t sub_100007F3C(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v4;

  if (a1)
    return sub_100007F98(a1, a2);
  v4 = qword_10008C6D0;
  if (!qword_10008C6D0)
    return 0;
  while (1)
  {
    result = sub_100007F98(v4, a2);
    if (result)
      break;
    v4 = *(_QWORD *)(v4 + 1712);
    if (!v4)
      return 0;
  }
  return result;
}

uint64_t sub_100007F98(uint64_t a1, _QWORD *a2)
{
  uint64_t result;

  for (result = *(_QWORD *)(a1 + 1696); result; result = *(_QWORD *)(result + 456))
  {
    if ((*(_BYTE *)(result + 17) & 0x40) == 0 && *(_QWORD *)result == *a2)
      break;
  }
  return result;
}

uint64_t sub_100007FC4(uint64_t a1, const sockaddr *a2, const sockaddr *a3)
{
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  _BOOL8 v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v15;
  int v16;
  uint64_t *v17;
  int v18;
  uint64_t *v19;

  v5 = a1;
  if (dword_10008BA20)
  {
    v6 = ne_log_obj(a1);
    a1 = os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG);
    if ((_DWORD)a1)
      sub_1000560D0();
    if (dword_10008BA20)
    {
      v7 = ne_log_obj(a1);
      a1 = os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)a1)
        sub_100056060(a2);
      if (dword_10008BA20)
      {
        v8 = ne_log_obj(a1);
        a1 = os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG);
        if ((_DWORD)a1)
          sub_100055FF0(a3);
      }
    }
  }
  v9 = *(_QWORD *)(v5 + 1696);
  if (v9)
  {
    while (1)
    {
      if ((*(_BYTE *)(v9 + 17) & 0x40) == 0)
      {
        if (dword_10008BA20)
        {
          v10 = ne_log_obj(a1);
          v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG);
          if (v11)
            sub_100055FA0(&v18, v9, &v19);
          if (dword_10008BA20)
          {
            v12 = ne_log_obj(v11);
            if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
              sub_100055F50(&v16, v9, &v17);
          }
        }
        a1 = sub_10003B5A0((unint64_t)a2, *(_QWORD *)(v9 + 56));
        if (!(_DWORD)a1)
        {
          a1 = sub_10003B5A0((unint64_t)a3, *(_QWORD *)(v9 + 48));
          if (!(_DWORD)a1)
            break;
        }
      }
      v9 = *(_QWORD *)(v9 + 456);
      if (!v9)
        goto LABEL_21;
    }
    if (dword_10008BA20)
    {
      v15 = ne_log_obj(a1);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
        sub_100055F24();
    }
  }
  else
  {
LABEL_21:
    if (dword_10008BA20)
    {
      v13 = ne_log_obj(a1);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
        sub_100055EF8();
    }
    return 0;
  }
  return v9;
}

uint64_t sub_1000081C8(uint64_t a1, unint64_t a2, unint64_t a3)
{
  uint64_t result;
  uint64_t v6;

  if (a1)
    return sub_10000823C(a1, a2, a3);
  v6 = qword_10008C6D0;
  if (!qword_10008C6D0)
    return 0;
  while (1)
  {
    result = sub_10000823C(v6, a2, a3);
    if (result)
      break;
    v6 = *(_QWORD *)(v6 + 1712);
    if (!v6)
      return 0;
  }
  return result;
}

uint64_t sub_10000823C(uint64_t a1, unint64_t a2, unint64_t a3)
{
  uint64_t i;

  for (i = *(_QWORD *)(a1 + 1696); i; i = *(_QWORD *)(i + 456))
  {
    if ((*(_BYTE *)(i + 17) & 0x40) == 0
      && !sub_10003B380(a2, *(_QWORD *)(i + 56))
      && !sub_10003B380(a3, *(_QWORD *)(i + 48)))
    {
      break;
    }
  }
  return i;
}

uint64_t sub_1000082A0(uint64_t a1, unint64_t a2)
{
  uint64_t i;
  int v5;

  for (i = *(_QWORD *)(a1 + 1696); i; i = *(_QWORD *)(i + 456))
  {
    if ((*(_BYTE *)(i + 17) & 0x40) == 0)
    {
      if (*(_BYTE *)(a2 + 1) == 2 && *(_DWORD *)(i + 28))
      {
        v5 = 0;
        nw_nat64_extract_v4(i + 28, *(_QWORD *)(i + 48) + 8, &v5);
        if (*(_DWORD *)(a2 + 4) == v5)
          return i;
      }
      else if (!sub_10003B380(a2, *(_QWORD *)(i + 48)))
      {
        return i;
      }
    }
  }
  return i;
}

uint64_t sub_100008330(uint64_t a1, unint64_t a2)
{
  uint64_t result;
  uint64_t v4;

  if (a1)
    return sub_1000082A0(a1, a2);
  v4 = qword_10008C6D0;
  if (!qword_10008C6D0)
    return 0;
  while (1)
  {
    result = sub_1000082A0(v4, a2);
    if (result)
      break;
    v4 = *(_QWORD *)(v4 + 1712);
    if (!v4)
      return 0;
  }
  return result;
}

uint64_t sub_10000838C(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 440) + 1696);
  if (!v1)
    return 1;
  while (1)
  {
    if ((*(_BYTE *)(v1 + 432) & 2) == 0 && (*(_BYTE *)(v1 + 17) & 0x40) == 0)
    {
      result = sub_10003B5A0(*(_QWORD *)(a1 + 48), *(_QWORD *)(v1 + 48));
      if (v1 != a1 && !(_DWORD)result)
        break;
    }
    v1 = *(_QWORD *)(v1 + 456);
    if (!v1)
      return 1;
  }
  return result;
}

_BYTE *sub_1000083E8(char a1)
{
  _BYTE *v2;
  _BYTE *v3;
  NSObject *v4;
  __int16 v6[8];

  v2 = malloc_type_calloc(1uLL, 0x1D8uLL, 0x10A0040AC7A52B7uLL);
  v3 = v2;
  if (v2)
  {
    v2[80] = a1;
    *((_DWORD *)v2 + 92) = 0;
    *((_QWORD *)v2 + 47) = 0;
    *((_QWORD *)v2 + 48) = 0;
    *((_DWORD *)v2 + 98) = 0;
    v2[432] &= ~2u;
    if (dword_10008BA20)
    {
      v4 = ne_log_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        v6[0] = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "New Phase 1\n", (uint8_t *)v6, 2u);
      }
    }
  }
  return v3;
}

void sub_10000849C(uint64_t a1)
{
  void *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  void *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  _QWORD *v24;
  _QWORD *v25;
  _QWORD *v26;
  _QWORD *v27;
  _QWORD *v28;
  _QWORD *v29;
  _QWORD *v30;
  _QWORD *v31;
  _QWORD *v32;
  _QWORD *v33;
  _QWORD *v34;
  _QWORD *v35;
  _QWORD *v36;

  if (a1)
  {
    v2 = *(void **)(a1 + 88);
    if (v2)
    {
      free(v2);
      *(_QWORD *)(a1 + 88) = 0;
    }
    if (*(_QWORD *)(a1 + 408))
      sub_1000446C4(a1);
    v3 = *(_QWORD **)(a1 + 424);
    if (v3)
    {
      sub_10003F318(v3);
      *(_QWORD *)(a1 + 424) = 0;
    }
    v4 = *(unsigned int *)(a1 + 388);
    if ((_DWORD)v4)
    {
      sub_10003A6F0(v4);
      *(_DWORD *)(a1 + 388) = 0;
    }
    v5 = *(unsigned int *)(a1 + 392);
    if ((_DWORD)v5)
    {
      sub_10003A6F0(v5);
      *(_DWORD *)(a1 + 392) = 0;
    }
    v6 = *(void **)(a1 + 48);
    if (v6)
    {
      free(v6);
      *(_QWORD *)(a1 + 48) = 0;
    }
    v7 = *(void **)(a1 + 56);
    if (v7)
    {
      free(v7);
      *(_QWORD *)(a1 + 56) = 0;
    }
    v8 = *(_QWORD **)(a1 + 72);
    if (v8)
    {
      sub_100038AD0(v8);
      *(_QWORD *)(a1 + 72) = 0;
    }
    sub_10003A744(a1);
    v9 = *(unsigned int *)(a1 + 112);
    if ((_DWORD)v9)
    {
      sub_10003A6F0(v9);
      *(_DWORD *)(a1 + 112) = 0;
    }
    v10 = *(unsigned int *)(a1 + 116);
    if ((_DWORD)v10)
    {
      sub_10003A6F0(v10);
      *(_DWORD *)(a1 + 116) = 0;
    }
    v11 = *(unsigned int *)(a1 + 120);
    if ((_DWORD)v11)
    {
      sub_10003A6F0(v11);
      *(_DWORD *)(a1 + 120) = 0;
    }
    v12 = *(_QWORD **)(a1 + 128);
    if (v12)
    {
      sub_10003F318(v12);
      *(_QWORD *)(a1 + 128) = 0;
    }
    v13 = *(_QWORD **)(a1 + 144);
    if (v13)
    {
      sub_10003F318(v13);
      *(_QWORD *)(a1 + 144) = 0;
    }
    v14 = *(_QWORD **)(a1 + 152);
    if (v14)
    {
      sub_10003F318(v14);
      *(_QWORD *)(a1 + 152) = 0;
    }
    v15 = *(_QWORD **)(a1 + 160);
    if (v15)
    {
      sub_10003F318(v15);
      *(_QWORD *)(a1 + 160) = 0;
    }
    v16 = *(_QWORD **)(a1 + 168);
    if (v16)
    {
      sub_10003F318(v16);
      *(_QWORD *)(a1 + 168) = 0;
    }
    v17 = *(_QWORD **)(a1 + 176);
    if (v17)
    {
      sub_10003F318(v17);
      *(_QWORD *)(a1 + 176) = 0;
    }
    v18 = *(_QWORD **)(a1 + 184);
    if (v18)
    {
      sub_10003F318(v18);
      *(_QWORD *)(a1 + 184) = 0;
    }
    v19 = *(_QWORD **)(a1 + 192);
    if (v19)
    {
      sub_10003F318(v19);
      *(_QWORD *)(a1 + 192) = 0;
    }
    v20 = *(_QWORD **)(a1 + 200);
    if (v20)
    {
      sub_10003F318(v20);
      *(_QWORD *)(a1 + 200) = 0;
    }
    v21 = *(_QWORD **)(a1 + 208);
    if (v21)
    {
      sub_10003F318(v21);
      *(_QWORD *)(a1 + 208) = 0;
    }
    v22 = *(_QWORD **)(a1 + 216);
    if (v22)
    {
      sub_10003F318(v22);
      *(_QWORD *)(a1 + 216) = 0;
    }
    v23 = *(_QWORD **)(a1 + 224);
    if (v23)
    {
      sub_10003F318(v23);
      *(_QWORD *)(a1 + 224) = 0;
    }
    v24 = *(_QWORD **)(a1 + 232);
    if (v24)
    {
      sub_10003F318(v24);
      *(_QWORD *)(a1 + 232) = 0;
    }
    v25 = *(_QWORD **)(a1 + 240);
    if (v25)
    {
      sub_10003F318(v25);
      *(_QWORD *)(a1 + 240) = 0;
    }
    v26 = *(_QWORD **)(a1 + 248);
    if (v26)
    {
      sub_10003F318(v26);
      *(_QWORD *)(a1 + 248) = 0;
    }
    v27 = *(_QWORD **)(a1 + 256);
    if (v27)
    {
      sub_10003F318(v27);
      *(_QWORD *)(a1 + 256) = 0;
    }
    v28 = *(_QWORD **)(a1 + 264);
    if (v28)
    {
      sub_10003F318(v28);
      *(_QWORD *)(a1 + 264) = 0;
    }
    v29 = *(_QWORD **)(a1 + 272);
    if (v29)
    {
      sub_10003F318(v29);
      *(_QWORD *)(a1 + 272) = 0;
    }
    sub_10002BC70(*(_QWORD **)(a1 + 280));
    *(_QWORD *)(a1 + 280) = 0;
    sub_10002BC70(*(_QWORD **)(a1 + 288));
    *(_QWORD *)(a1 + 288) = 0;
    sub_10002BC70(*(_QWORD **)(a1 + 296));
    *(_QWORD *)(a1 + 296) = 0;
    sub_10002BC70(*(_QWORD **)(a1 + 304));
    *(_QWORD *)(a1 + 304) = 0;
    v30 = *(_QWORD **)(a1 + 312);
    if (v30)
    {
      sub_10003F318(v30);
      *(_QWORD *)(a1 + 312) = 0;
    }
    v31 = *(_QWORD **)(a1 + 320);
    if (v31)
    {
      sub_10003F318(v31);
      *(_QWORD *)(a1 + 320) = 0;
    }
    v32 = *(_QWORD **)(a1 + 72);
    if (v32)
      sub_100038AD0(v32);
    v33 = *(_QWORD **)(a1 + 328);
    if (v33)
    {
      sub_10002DA18(v33);
      *(_QWORD *)(a1 + 328) = 0;
    }
    v34 = *(_QWORD **)(a1 + 336);
    if (v34)
    {
      sub_10003F318(v34);
      *(_QWORD *)(a1 + 336) = 0;
    }
    v35 = *(_QWORD **)(a1 + 344);
    if (v35)
    {
      sub_10003F318(v35);
      *(_QWORD *)(a1 + 344) = 0;
    }
    v36 = *(_QWORD **)(a1 + 64);
    if (v36)
    {
      sub_100038B84(v36);
      *(_QWORD *)(a1 + 64) = 0;
    }
    if (*(_QWORD *)(a1 + 136))
      SecDHDestroy();
    free((void *)a1);
  }
}

void sub_100008744(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v4;
  NSObject *v5;
  __int128 *v6;
  NSObject *v7;
  const char *v8;
  NSObject *v9;
  __int128 *v10;
  NSObject *v11;
  __int128 *v12;
  uint8_t buf[4];
  __int128 *v14;

  v2 = *(_QWORD *)(a1 + 1696);
  while (v2)
  {
    v4 = v2;
    v2 = *(_QWORD *)(v2 + 456);
    if (a2)
    {
      a1 = *(_QWORD *)(v4 + 440);
      if (a1 && (*(_WORD *)(a1 + 264) & 0x20) == 0 && (*(_BYTE *)(a1 + 280) & 4) != 0)
      {
        if (!dword_10008BA20)
          continue;
        v11 = ne_log_obj(a1);
        a1 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
        if (!(_DWORD)a1)
          continue;
        v12 = sub_100023E84(v4, 0);
        *(_DWORD *)buf = 136315138;
        v14 = v12;
        v7 = v11;
        v8 = "Skipping Phase 1 %s that's asserted...\n";
LABEL_23:
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v8, buf, 0xCu);
        continue;
      }
      if ((*(_BYTE *)(v4 + 17) & 0x20) != 0)
      {
        a1 = sub_10004D90C(a1);
        if ((_DWORD)a1 || (a1 = sub_10004D984(*(_QWORD *)(v4 + 440)), (_DWORD)a1))
        {
          if (!dword_10008BA20)
            continue;
          v5 = ne_log_obj(a1);
          a1 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
          if (!(_DWORD)a1)
            continue;
          v6 = sub_100023E84(v4, 0);
          *(_DWORD *)buf = 136315138;
          v14 = v6;
          v7 = v5;
          v8 = "Skipping Phase 1 %s that's established... because it's needed by children Phase 2s\n";
          goto LABEL_23;
        }
LABEL_13:
        if (dword_10008BA20)
        {
          v9 = ne_log_obj(a1);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            v10 = sub_100023E84(v4, 0);
            *(_DWORD *)buf = 136315138;
            v14 = v10;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Got a Phase 1 %s to flush...\n", buf, 0xCu);
          }
        }
        sub_10001A528(v4);
      }
    }
    else if ((*(_BYTE *)(v4 + 17) & 0x20) != 0)
    {
      goto LABEL_13;
    }
    sub_10004CC10(*(_QWORD *)(v4 + 440), (uint64_t)off_100088500[0]);
    a1 = sub_10004AACC(v4);
  }
}

uint64_t sub_100008954(uint64_t a1)
{
  int v1;
  NSObject *v2;
  uint64_t result;
  uint64_t v4;
  _DWORD v5[2];

  v1 = a1;
  if (dword_10008BA20)
  {
    v2 = ne_log_obj(a1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      v5[0] = 67109120;
      v5[1] = v1;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Flushing Phase 1 handles: ignore_estab_or_assert %d...\n", (uint8_t *)v5, 8u);
    }
  }
  result = qword_10008C6D0;
  if (qword_10008C6D0)
  {
    do
    {
      v4 = *(_QWORD *)(result + 1712);
      sub_100008744(result, v1);
      result = v4;
    }
    while (v4);
  }
  return result;
}

uint64_t sub_100008A20(int a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = qword_10008C6D0;
  if (!qword_10008C6D0)
    return 0;
  while (1)
  {
    v2 = *(_QWORD *)(v1 + 1704);
    if (v2)
      break;
LABEL_5:
    v1 = *(_QWORD *)(v1 + 1712);
    if (!v1)
      return 0;
  }
  while (*(_DWORD *)(v2 + 52) != a1)
  {
    v2 = *(_QWORD *)(v2 + 296);
    if (!v2)
      goto LABEL_5;
  }
  return v2;
}

uint64_t sub_100008A60(int a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = qword_10008C6D0;
  if (!qword_10008C6D0)
    return 0;
  while (1)
  {
    v2 = *(_QWORD *)(v1 + 1704);
    if (v2)
      break;
LABEL_5:
    v1 = *(_QWORD *)(v1 + 1712);
    if (!v1)
      return 0;
  }
  while (*(_DWORD *)(v2 + 100) != a1)
  {
    v2 = *(_QWORD *)(v2 + 296);
    if (!v2)
      goto LABEL_5;
  }
  return v2;
}

uint64_t sub_100008AA0(uint64_t a1, int a2)
{
  uint64_t result;

  for (result = *(_QWORD *)(*(_QWORD *)(a1 + 440) + 1704); result; result = *(_QWORD *)(result + 296))
  {
    if (*(_DWORD *)(result + 108) == a2 && (*(_BYTE *)(result + 264) & 4) == 0)
      break;
  }
  return result;
}

uint64_t sub_100008ACC(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;

  v1 = *(_QWORD *)(a1 + 448);
  if (v1)
  {
    result = 0;
    while (!result)
    {
      result = v1;
      v1 = *(_QWORD *)(v1 + 296);
      if (!v1)
        return result;
    }
  }
  return 0;
}

uint64_t sub_100008AF8(unint64_t a1, unint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  uint8_t v12[16];

  v3 = qword_10008C6D0;
  while (v3)
  {
    v7 = *(_QWORD *)(v3 + 1704);
    v3 = *(_QWORD *)(v3 + 1712);
    while (v7)
    {
      v8 = v7;
      v7 = *(_QWORD *)(v7 + 296);
      if (*(_DWORD *)(v8 + 52) == a3 && !sub_10003B5A0(a1, *(_QWORD *)v8))
      {
        v9 = sub_10003B5A0(a2, *(_QWORD *)(v8 + 8));
        if (!(_DWORD)v9)
        {
          if ((*(_BYTE *)(v8 + 57) & 0x60) != 0
            || *(_DWORD *)(v8 + 72)
            || *(_DWORD *)(v8 + 64)
            || *(_DWORD *)(v8 + 68)
            || *(_DWORD *)(v8 + 96))
          {
            return v8;
          }
          if (dword_10008BA20)
          {
            v10 = ne_log_obj(v9);
            if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)v12 = 0;
              _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Zombie ph2 found, expiring it\n", v12, 2u);
            }
          }
          sub_1000250DC((_QWORD *)v8);
        }
      }
    }
  }
  return 0;
}

_QWORD *sub_100008C2C(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t v4;
  _QWORD *result;
  uint64_t v6;
  uint64_t v7;
  uint64_t i;
  uint64_t v9;

  v4 = qword_10008C6D0;
  if (qword_10008C6D0)
  {
    while (1)
    {
      result = *(_QWORD **)(v4 + 1704);
      if (result)
        break;
LABEL_17:
      v4 = *(_QWORD *)(v4 + 1712);
      if (!v4)
        return 0;
    }
    while (1)
    {
      v7 = result[15];
      v6 = result[16];
      if (v7)
      {
        if (v6)
          goto LABEL_11;
        for (i = *(_QWORD *)(v7 + 32); i; i = *(_QWORD *)(i + 72))
        {
          if (*(_DWORD *)i != a3)
            break;
          if (*(_DWORD *)(i + 24) == a4)
            return result;
        }
      }
      else if (v6)
      {
LABEL_11:
        v9 = *(_QWORD *)(v6 + 32);
        if (v9)
        {
          while (*(_DWORD *)v9 == a3)
          {
            if (*(_DWORD *)(v9 + 24) == a4 || *(_DWORD *)(v9 + 28) == a4)
              return result;
            v9 = *(_QWORD *)(v9 + 72);
            if (!v9)
              break;
          }
        }
      }
      result = (_QWORD *)result[37];
      if (!result)
        goto LABEL_17;
    }
  }
  return 0;
}

_QWORD *sub_100008CCC(uint64_t a1, uint64_t a2, int a3, int a4, _DWORD *a5)
{
  uint64_t v5;
  _QWORD *result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;

  v5 = qword_10008C6D0;
  if (qword_10008C6D0)
  {
    while (1)
    {
      result = *(_QWORD **)(v5 + 1704);
      if (result)
        break;
LABEL_18:
      v5 = *(_QWORD *)(v5 + 1712);
      if (!v5)
        return 0;
    }
    while (1)
    {
      v8 = result[15];
      v7 = result[16];
      if (v8)
      {
        if (v7)
          goto LABEL_12;
        v9 = *(_QWORD *)(v8 + 32);
        if (v9)
        {
          while (*(_DWORD *)v9 == a3)
          {
            v10 = *(_DWORD *)(v9 + 24);
            if (v10 == a4)
              goto LABEL_20;
            if (*(_DWORD *)(v9 + 28) == a4)
              goto LABEL_22;
            v9 = *(_QWORD *)(v9 + 72);
            if (!v9)
              break;
          }
        }
      }
      else if (v7)
      {
LABEL_12:
        v9 = *(_QWORD *)(v7 + 32);
        if (v9)
        {
          while (1)
          {
            if (*(_DWORD *)v9 != a3)
              goto LABEL_17;
            v10 = *(_DWORD *)(v9 + 24);
            if (v10 == a4)
              break;
            if (*(_DWORD *)(v9 + 28) == a4)
            {
LABEL_22:
              if (!a5)
                return result;
              goto LABEL_23;
            }
            v9 = *(_QWORD *)(v9 + 72);
            if (!v9)
              goto LABEL_17;
          }
LABEL_20:
          if (!a5)
            return result;
          v10 = *(_DWORD *)(v9 + 28);
LABEL_23:
          *a5 = v10;
          return result;
        }
      }
LABEL_17:
      result = (_QWORD *)result[37];
      if (!result)
        goto LABEL_18;
    }
  }
  return 0;
}

_BYTE *sub_100008D90(char a1, int a2)
{
  _BYTE *v4;
  _BYTE *v5;
  NSObject *v6;
  __int16 v8[8];

  v4 = malloc_type_calloc(1uLL, 0x148uLL, 0x10A00406469B766uLL);
  v5 = v4;
  if (v4)
  {
    v4[61] = a1;
    *((_DWORD *)v4 + 12) = a2;
    v4[264] &= ~2u;
    if (dword_10008BA20)
    {
      v6 = ne_log_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        v8[0] = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "New Phase 2\n", (uint8_t *)v8, 2u);
      }
    }
  }
  return v5;
}

void sub_100008E48(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t i;
  uint64_t *v6;
  void *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  _QWORD *v19;

  sub_10003A744(a1);
  *(_QWORD *)(a1 + 64) = 0;
  v2 = *(_QWORD **)(a1 + 80);
  if (v2)
  {
    sub_10003F318(v2);
    *(_QWORD *)(a1 + 80) = 0;
  }
  v3 = *(_QWORD **)(a1 + 88);
  if (v3)
  {
    sub_10003F318(v3);
    *(_QWORD *)(a1 + 88) = 0;
  }
  v4 = *(_QWORD *)(a1 + 120);
  if (v4)
  {
    for (i = *(_QWORD *)(v4 + 32); i; i = *(_QWORD *)(i + 72))
      *(_DWORD *)(i + 24) = 0;
  }
  v6 = *(uint64_t **)(a1 + 128);
  if (v6)
  {
    sub_100036158(v6);
    *(_QWORD *)(a1 + 128) = 0;
  }
  v7 = *(void **)(a1 + 136);
  if (v7)
  {
    sub_100034F18(v7);
    free(*(void **)(a1 + 136));
    *(_QWORD *)(a1 + 136) = 0;
  }
  v8 = *(_QWORD **)(a1 + 152);
  if (v8)
  {
    sub_10002957C(v8);
    *(_QWORD *)(a1 + 152) = 0;
  }
  v9 = *(_QWORD **)(a1 + 160);
  if (v9)
  {
    sub_10003F318(v9);
    *(_QWORD *)(a1 + 160) = 0;
  }
  v10 = *(_QWORD **)(a1 + 168);
  if (v10)
  {
    sub_10003F318(v10);
    *(_QWORD *)(a1 + 168) = 0;
  }
  v11 = *(_QWORD **)(a1 + 176);
  if (v11)
  {
    sub_10003F318(v11);
    *(_QWORD *)(a1 + 176) = 0;
  }
  v12 = *(_QWORD **)(a1 + 184);
  if (v12)
  {
    sub_10003F318(v12);
    *(_QWORD *)(a1 + 184) = 0;
  }
  v13 = *(_QWORD **)(a1 + 192);
  if (v13)
  {
    sub_10003F318(v13);
    *(_QWORD *)(a1 + 192) = 0;
  }
  v14 = *(_QWORD **)(a1 + 200);
  if (v14)
  {
    sub_10003F318(v14);
    *(_QWORD *)(a1 + 200) = 0;
  }
  v15 = *(_QWORD **)(a1 + 208);
  if (v15)
  {
    sub_10003F318(v15);
    *(_QWORD *)(a1 + 208) = 0;
  }
  v16 = *(_QWORD **)(a1 + 216);
  if (v16)
  {
    sub_10003F318(v16);
    *(_QWORD *)(a1 + 216) = 0;
  }
  v17 = *(_QWORD **)(a1 + 224);
  if (v17)
  {
    sub_10003F318(v17);
    *(_QWORD *)(a1 + 224) = 0;
  }
  v18 = *(_QWORD **)(a1 + 232);
  if (v18)
  {
    sub_10003F318(v18);
    *(_QWORD *)(a1 + 232) = 0;
  }
  v19 = *(_QWORD **)(a1 + 240);
  if (v19)
  {
    sub_10002DA18(v19);
    *(_QWORD *)(a1 + 240) = 0;
  }
}

void sub_100008F90(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  uint64_t *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;

  sub_100008E48(a1);
  if (*(_QWORD *)a1)
  {
    free(*(void **)a1);
    *(_QWORD *)a1 = 0;
  }
  v2 = *(void **)(a1 + 8);
  if (v2)
  {
    free(v2);
    *(_QWORD *)(a1 + 8) = 0;
  }
  v3 = *(void **)(a1 + 32);
  if (v3)
  {
    free(v3);
    *(_QWORD *)(a1 + 32) = 0;
  }
  v4 = *(void **)(a1 + 40);
  if (v4)
  {
    free(v4);
    *(_QWORD *)(a1 + 40) = 0;
  }
  v5 = *(uint64_t **)(a1 + 120);
  if (v5)
  {
    sub_100036158(v5);
    *(_QWORD *)(a1 + 120) = 0;
  }
  v6 = *(_QWORD **)(a1 + 112);
  if (v6)
  {
    sub_10003A2CC(v6);
    *(_QWORD *)(a1 + 112) = 0;
  }
  v7 = *(_QWORD **)(a1 + 192);
  if (v7)
  {
    sub_10003F318(v7);
    *(_QWORD *)(a1 + 192) = 0;
  }
  v8 = *(_QWORD **)(a1 + 200);
  if (v8)
  {
    sub_10003F318(v8);
    *(_QWORD *)(a1 + 200) = 0;
  }
  v9 = *(_QWORD **)(a1 + 280);
  if (v9)
  {
    sub_10003F318(v9);
    *(_QWORD *)(a1 + 280) = 0;
  }
  v10 = *(_QWORD **)(a1 + 288);
  if (v10)
  {
    sub_10003F318(v10);
    *(_QWORD *)(a1 + 288) = 0;
  }
  v11 = *(unsigned int *)(a1 + 64);
  if ((_DWORD)v11)
  {
    sub_10003A6F0(v11);
    *(_DWORD *)(a1 + 64) = 0;
  }
  v12 = *(unsigned int *)(a1 + 68);
  if ((_DWORD)v12)
    sub_10003A6F0(v12);
  free((void *)a1);
}

void sub_100009070(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v4;
  int v5;
  uint64_t v6;
  int v7;
  NSObject *v8;
  NSObject *v9;
  const char *v10;
  NSObject *v11;
  int v12;
  NSObject *v13;
  NSObject *v14;
  uint8_t buf[4];
  int v16;

  v2 = *(_QWORD *)(a1 + 1704);
  while (v2)
  {
    v4 = v2;
    v2 = *(_QWORD *)(v2 + 296);
    if ((*(_BYTE *)(v4 + 264) & 2) != 0)
      continue;
    v5 = *(_DWORD *)(v4 + 56);
    if ((v5 & 0x4000) != 0)
      continue;
    if (a2)
    {
      v6 = *(_QWORD *)(v4 + 272);
      if (v6 && (*(_WORD *)(v6 + 264) & 0x20) == 0 && (*(_BYTE *)(v6 + 280) & 4) != 0)
      {
        if (!dword_10008BA20)
          continue;
        v14 = ne_log_obj(a1);
        a1 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
        if (!(_DWORD)a1)
          continue;
        *(_WORD *)buf = 0;
        v9 = v14;
        v10 = "skipping phase2 handle that's asserted...\n";
LABEL_26:
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v10, buf, 2u);
        continue;
      }
      v7 = dword_10008BA20;
      if ((v5 & 0x2000) != 0)
      {
        if (!dword_10008BA20)
          continue;
        v8 = ne_log_obj(a1);
        a1 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
        if (!(_DWORD)a1)
          continue;
        *(_WORD *)buf = 0;
        v9 = v8;
        v10 = "skipping ph2 handler that's established...\n";
        goto LABEL_26;
      }
    }
    else
    {
      v7 = dword_10008BA20;
      if ((v5 & 0x2000) != 0)
      {
        if (dword_10008BA20)
        {
          v13 = ne_log_obj(a1);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "got an established ph2 handler to flush...\n", buf, 2u);
          }
        }
        sub_10001AA88(v4);
        goto LABEL_20;
      }
    }
    if (v7)
    {
      v11 = ne_log_obj(a1);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        v12 = *(_DWORD *)(v4 + 56);
        *(_DWORD *)buf = 67109120;
        v16 = v12;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "got a ph2 handler to flush (state %d)\n", buf, 8u);
      }
    }
LABEL_20:
    sub_10004CC10(*(_QWORD *)(v4 + 272), (uint64_t)off_100088500[0]);
    sub_100026C5C((uint64_t *)v4);
    a1 = sub_10004A9EC((_QWORD *)v4);
  }
}

uint64_t sub_10000928C(uint64_t a1)
{
  int v1;
  NSObject *v2;
  uint64_t result;
  uint64_t v4;
  _DWORD v5[2];

  v1 = a1;
  if (dword_10008BA20)
  {
    v2 = ne_log_obj(a1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      v5[0] = 67109120;
      v5[1] = v1;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "flushing ph2 handles: ignore_estab_or_assert %d...\n", (uint8_t *)v5, 8u);
    }
  }
  result = qword_10008C6D0;
  if (qword_10008C6D0)
  {
    do
    {
      v4 = *(_QWORD *)(result + 1712);
      sub_100009070(result, v1);
      result = v4;
    }
    while (v4);
  }
  return result;
}

uint64_t sub_100009358(uint64_t result, unint64_t a2, int a3)
{
  uint64_t v3;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  uint8_t v14[16];

  v3 = qword_10008C6D0;
  if (qword_10008C6D0)
  {
    v6 = result;
    do
    {
      v7 = *(_QWORD *)(v3 + 1704);
      v3 = *(_QWORD *)(v3 + 1712);
LABEL_4:
      while (v7)
      {
        v8 = v7;
        v7 = *(_QWORD *)(v7 + 296);
        if ((*(_BYTE *)(v8 + 264) & 2) == 0
          && (*(_BYTE *)(v8 + 57) & 0x40) == 0
          && (*(_QWORD *)(v8 + 120) || *(_QWORD *)(v8 + 128)))
        {
          result = sub_10003B380(v6, *(_QWORD *)v8);
          if (!(_DWORD)result)
          {
            result = sub_10003B380(a2, *(_QWORD *)(v8 + 8));
            if (!(_DWORD)result)
            {
              v9 = *(_QWORD *)(v8 + 128);
              if (v9)
              {
                v10 = *(_QWORD *)(v9 + 32);
                if (v10)
                {
                  while (*(_DWORD *)v10 != a3)
                  {
                    v10 = *(_QWORD *)(v10 + 72);
                    if (!v10)
                      goto LABEL_4;
                  }
                  goto LABEL_21;
                }
              }
              else
              {
                v11 = *(_QWORD *)(v8 + 120);
                if (v11)
                {
                  v12 = *(_QWORD *)(v11 + 32);
                  if (v12)
                  {
                    while (*(_DWORD *)v12 != a3)
                    {
                      v12 = *(_QWORD *)(v12 + 72);
                      if (!v12)
                        goto LABEL_4;
                    }
LABEL_21:
                    if (dword_10008BA20)
                    {
                      v13 = ne_log_obj(result);
                      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_WORD *)v14 = 0;
                        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "deleteallph2: got a ph2 handler...\n", v14, 2u);
                      }
                    }
                    if ((*(_BYTE *)(v8 + 57) & 0x20) != 0)
                      sub_10001AA88(v8);
                    sub_10004CC10(*(_QWORD *)(v8 + 272), (uint64_t)off_100088500[0]);
                    result = sub_10004A9EC((_QWORD *)v8);
                  }
                }
              }
            }
          }
        }
      }
    }
    while (v3);
  }
  return result;
}

uint64_t sub_1000094DC(uint64_t result, unint64_t a2)
{
  uint64_t v2;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  uint8_t v8[16];

  v2 = qword_10008C6D0;
  if (qword_10008C6D0)
  {
    v4 = result;
    do
    {
      v5 = *(_QWORD *)(v2 + 1696);
      v2 = *(_QWORD *)(v2 + 1712);
      while (v5)
      {
        v6 = v5;
        v5 = *(_QWORD *)(v5 + 456);
        result = sub_10003B380(v4, *(_QWORD *)(v6 + 56));
        if (!(_DWORD)result)
        {
          result = sub_10003B380(a2, *(_QWORD *)(v6 + 48));
          if (!(_DWORD)result)
          {
            if (dword_10008BA20)
            {
              v7 = ne_log_obj(result);
              if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)v8 = 0;
                _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "deleteallph1: got a ph1 handler...\n", v8, 2u);
              }
            }
            if ((*(_BYTE *)(v6 + 17) & 0x20) != 0)
              sub_10001A528(v6);
            sub_10004CC10(*(_QWORD *)(v6 + 440), (uint64_t)off_100088500[0]);
            result = sub_10004AACC(v6);
          }
        }
      }
    }
    while (v2);
  }
  return result;
}

unint64_t *sub_1000095F0(unint64_t a1)
{
  unint64_t *v1;

  v1 = (unint64_t *)qword_100088538;
  if (qword_100088538)
  {
    do
    {
      if (!sub_10003B5A0(a1, *v1))
        break;
      v1 = (unint64_t *)v1[1];
    }
    while (v1);
  }
  return v1;
}

uint64_t sub_100009634(unsigned __int8 *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;
  uint64_t v5;
  uint64_t result;
  NSObject *v7;

  v2 = malloc_type_calloc(1uLL, 0x18uLL, 0xA0040E93CF5C4uLL);
  if (!v2)
    return 0xFFFFFFFFLL;
  v3 = v2;
  v4 = sub_10003C6F8(a1);
  *v3 = v4;
  if (!v4)
  {
    if (dword_10008BA20)
    {
      v7 = ne_log_obj(0);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_1000560FC();
    }
    free(v3);
    return 0xFFFFFFFFLL;
  }
  v5 = qword_100088538;
  v3[1] = qword_100088538;
  if (v5)
    *(_QWORD *)(v5 + 16) = v3 + 1;
  result = 0;
  qword_100088538 = (uint64_t)v3;
  v3[2] = &qword_100088538;
  return result;
}

void sub_1000096F0()
{
  uint64_t v0;
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;

  v0 = qword_100088538;
  if (qword_100088538)
  {
    v1 = *(_QWORD *)(qword_100088538 + 8);
    v2 = *(_QWORD **)(qword_100088538 + 16);
    if (v1)
    {
      do
      {
        v3 = v1;
        *(_QWORD *)(v1 + 16) = v2;
        **(_QWORD **)(v0 + 16) = v1;
        free(*(void **)v0);
        free((void *)v0);
        v1 = *(_QWORD *)(v3 + 8);
        v2 = *(_QWORD **)(v3 + 16);
        v0 = v3;
      }
      while (v1);
    }
    else
    {
      v3 = qword_100088538;
    }
    *v2 = 0;
    free(*(void **)v3);
    free((void *)v3);
  }
}

void sub_10000976C()
{
  qword_100088538 = 0;
}

uint64_t sub_100009778(int a1, int a2)
{
  int v2;

  if (a1 < 4)
    v2 = 1;
  else
    v2 = a1;
  return v2 * a2;
}

uint64_t sub_10000978C(const sockaddr *a1, uint64_t a2, uint64_t a3)
{
  time_t v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  const void *v9;
  uint64_t result;
  NSObject *v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  NSObject *v17;
  NSObject *v18;
  uint64_t v19;
  NSObject *v20;
  int v21;
  BOOL v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  NSObject *v26;
  uint64_t *v27;
  NSObject *v28;
  int v29;
  int v30;
  uint64_t *v31;

  v5 = time(0);
  v6 = sub_100006C18(a3);
  if (!v6)
  {
    if (dword_10008BA20)
    {
      v11 = ne_log_obj(0);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        sub_1000560FC();
    }
    return 0xFFFFFFFFLL;
  }
  v7 = v6;
  v8 = qword_100088540;
  if (!qword_100088540)
  {
LABEL_6:
    sub_10003F318(v7);
    return 0;
  }
  v9 = (const void *)v6[1];
  while (memcmp(v9, *(const void **)(*(_QWORD *)(v8 + 16) + 8), **(_QWORD **)(v8 + 16)))
  {
    v8 = *(_QWORD *)(v8 + 72);
    if (!v8)
      goto LABEL_6;
  }
  sub_10003F318(v7);
  v12 = sub_10003B380((unint64_t)a1, *(_QWORD *)v8);
  if ((_DWORD)v12)
    return 2;
  if (v5 <= *(_QWORD *)(v8 + 40))
  {
    if (dword_10008BA20)
    {
      v13 = ne_log_obj(v12);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        v30 = 136315138;
        v31 = sub_10003C570(a1);
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "the packet retransmitted in a short time from %s\n", (uint8_t *)&v30, 0xCu);
      }
    }
  }
  result = sub_100007A38(*(unsigned __int8 **)(v8 + 8));
  if ((_DWORD)result != -1)
  {
    v14 = result;
    v15 = *(_QWORD *)(v8 + 40);
    if (v15)
    {
      v16 = v5 - v15;
      if (v5 > v15 && v16 < *(_QWORD *)(v8 + 56))
      {
        if (dword_10008BA20)
        {
          v17 = ne_log_obj(result);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
            sub_100056128(v16, v17);
        }
        return 1;
      }
    }
    if (*(_DWORD *)(v8 + 64) && **(_QWORD **)(v8 + 24) >= 0x501uLL)
    {
      if (dword_10008BA20)
      {
        v18 = ne_log_obj(result);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          sub_100056260();
      }
      v19 = sub_1000157C8(v14, *(unint64_t **)(v8 + 24), *(unsigned __int8 **)(v8 + 8), *(unsigned __int8 **)v8, *(unsigned int *)(qword_10008B848 + 276), *(_DWORD *)(v8 + 64));
    }
    else
    {
      if (dword_10008BA20)
      {
        v20 = ne_log_obj(result);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          sub_1000561C4((int *)(v8 + 64), v8, v20);
      }
      v19 = sub_10003BDE0(v14, *(const void **)(*(_QWORD *)(v8 + 24) + 8), **(_QWORD **)(v8 + 24), *(unsigned __int8 **)(v8 + 8), *(unsigned __int8 **)v8, *(_DWORD *)(qword_10008B848 + 276));
    }
    if ((_DWORD)v19 != -1)
    {
      v21 = *(_DWORD *)(v8 + 32);
      v22 = __OFSUB__(v21, 1);
      v23 = v21 - 1;
      *(_DWORD *)(v8 + 32) = v23;
      if ((v23 < 0) ^ v22 | (v23 == 0))
      {
        v24 = *(_QWORD *)(v8 + 72);
        if (v24)
          *(_QWORD *)(v24 + 80) = *(_QWORD *)(v8 + 80);
        **(_QWORD **)(v8 + 80) = v24;
        sub_100009B1C((void **)v8);
        if (dword_10008BA20)
        {
          v26 = ne_log_obj(v25);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
          {
            v27 = sub_10003C570(a1);
            v30 = 136315138;
            v31 = v27;
            _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "deleted the retransmission packet to %s.\n", (uint8_t *)&v30, 0xCu);
          }
        }
      }
      else
      {
        *(_QWORD *)(v8 + 40) = v5;
        v29 = *(_DWORD *)(qword_10008B848 + 268) - v23;
        if (v29 < 4)
          v29 = 1;
        *(_QWORD *)(v8 + 56) = *(int *)(qword_10008B848 + 272) * (uint64_t)v29;
      }
      return 1;
    }
    if (dword_10008BA20)
    {
      v28 = ne_log_obj(v19);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        sub_100056198();
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

void sub_100009B1C(void **a1)
{
  void *v2;
  void *v3;
  _QWORD *v4;
  _QWORD *v5;

  v2 = *a1;
  if (v2)
    free(v2);
  v3 = a1[1];
  if (v3)
    free(v3);
  v4 = a1[2];
  if (v4)
    sub_10003F318(v4);
  v5 = a1[3];
  if (v5)
    sub_10003F318(v5);
  free(a1);
}

uint64_t sub_100009B6C(unsigned __int8 *a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  void *v12;
  uint64_t v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  NSObject *v17;
  _QWORD *v18;
  _DWORD *v19;
  uint64_t result;
  NSObject *v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  _QWORD *v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  int v29;
  int v30;
  NSObject *v31;
  NSObject *v32;

  if (!*(_DWORD *)(qword_10008B848 + 268))
    return 0;
  v12 = malloc_type_calloc(1uLL, 0x58uLL, 0x10A0040B33E3A73uLL);
  if (!v12)
  {
    if (dword_10008BA20)
    {
      v21 = ne_log_obj(0);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        sub_1000560FC();
    }
    return 0xFFFFFFFFLL;
  }
  v13 = (uint64_t)v12;
  v14 = sub_100006C18(a4);
  *(_QWORD *)(v13 + 16) = v14;
  if (!v14)
  {
    if (!dword_10008BA20)
      goto LABEL_39;
    v22 = ne_log_obj(0);
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      goto LABEL_39;
    goto LABEL_38;
  }
  v15 = sub_10003C6F8(a1);
  *(_QWORD *)v13 = v15;
  if (!v15)
  {
    if (!dword_10008BA20)
      goto LABEL_39;
    v23 = ne_log_obj(0);
    if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      goto LABEL_39;
    goto LABEL_38;
  }
  v16 = sub_10003C6F8(a2);
  *(_QWORD *)(v13 + 8) = v16;
  if (!v16)
  {
    if (!dword_10008BA20)
      goto LABEL_39;
    v24 = ne_log_obj(0);
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      goto LABEL_39;
    goto LABEL_38;
  }
  if (!a5)
  {
    v25 = sub_10003F34C(a3);
    *(_QWORD *)(v13 + 24) = v25;
    if (v25)
      goto LABEL_26;
    if (!dword_10008BA20)
      goto LABEL_39;
    v32 = ne_log_obj(0);
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      goto LABEL_39;
LABEL_38:
    sub_1000560FC();
LABEL_39:
    sub_100009B1C((void **)v13);
    return 0xFFFFFFFFLL;
  }
  if (dword_10008BA20)
  {
    v17 = ne_log_obj(v16);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      sub_1000562B8();
  }
  v18 = sub_10003F1F8(*(_QWORD *)a3 + a5);
  *(_QWORD *)(v13 + 24) = v18;
  if (!v18)
  {
    if (dword_10008BA20)
    {
      v31 = ne_log_obj(0);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
        sub_10005628C();
    }
    goto LABEL_39;
  }
  v19 = (_DWORD *)v18[1];
  *v19 = 0;
  memcpy((char *)v19 + a5, *(const void **)(a3 + 8), *(_QWORD *)a3);
LABEL_26:
  *(_DWORD *)(v13 + 32) = *(_DWORD *)(qword_10008B848 + 268);
  *(_QWORD *)(v13 + 40) = 0;
  *(_QWORD *)(v13 + 48) = time(0);
  if (a6)
    *(_DWORD *)(v13 + 64) = a6;
  v26 = qword_10008B848;
  v27 = *(_DWORD *)(qword_10008B848 + 268);
  v28 = qword_100088540;
  *(_QWORD *)(v13 + 72) = qword_100088540;
  v29 = v27 - *(_DWORD *)(v13 + 32);
  v30 = *(_DWORD *)(v26 + 272);
  if (v29 < 4)
    v29 = 1;
  *(_QWORD *)(v13 + 56) = v30 * (uint64_t)v29;
  if (v28)
    *(_QWORD *)(v28 + 80) = v13 + 72;
  result = 0;
  qword_100088540 = v13;
  *(_QWORD *)(v13 + 80) = &qword_100088540;
  return result;
}

uint64_t sub_100009E30()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;

  v0 = qword_100088540;
  if (qword_100088540)
  {
    v1 = *(_QWORD *)(qword_100088540 + 72);
    if (v1)
    {
      do
      {
        v2 = v1;
        *(_QWORD *)(v1 + 80) = *(_QWORD *)(v0 + 80);
        **(_QWORD **)(v0 + 80) = v1;
        sub_100009B1C((void **)v0);
        v1 = *(_QWORD *)(v2 + 72);
        v0 = v2;
      }
      while (v1);
    }
    else
    {
      v2 = qword_100088540;
    }
    **(_QWORD **)(v2 + 80) = 0;
    sub_100009B1C((void **)v2);
  }
  return sub_10003A744((uint64_t)&qword_100088540);
}

_QWORD *sub_100009EA0()
{
  uint64_t v0;

  v0 = *(int *)(qword_10008B848 + 272) * (uint64_t)*(int *)(qword_10008B848 + 268);
  qword_100088540 = 0;
  return sub_10003A520(v0, (uint64_t)sub_100009ED0, (uint64_t)&qword_100088540);
}

_QWORD *sub_100009ED0()
{
  time_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v0 = time(0);
  v1 = *(int *)(qword_10008B848 + 272) * (uint64_t)*(int *)(qword_10008B848 + 268);
  v2 = qword_100088540;
  if (qword_100088540)
  {
    do
    {
      v3 = *(_QWORD *)(v2 + 72);
      if (v0 - *(_QWORD *)(v2 + 48) > v1)
      {
        if (v3)
          *(_QWORD *)(v3 + 80) = *(_QWORD *)(v2 + 80);
        **(_QWORD **)(v2 + 80) = v3;
        sub_100009B1C((void **)v2);
      }
      v2 = v3;
    }
    while (v3);
  }
  return sub_10003A520(v1, (uint64_t)sub_100009ED0, (uint64_t)&qword_100088540);
}

uint64_t sub_100009F68(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (!a1)
    return 0;
  v2 = *(_QWORD *)(a1 + 1704);
  if (v2)
  {
    v3 = 0;
    do
    {
      if ((*(_BYTE *)(v2 + 264) & 2) == 0 && (*(_BYTE *)(v2 + 57) & 0x40) == 0)
      {
        sub_1000250DC((_QWORD *)v2);
        v3 = (v3 + 1);
      }
      v2 = *(_QWORD *)(v2 + 296);
    }
    while (v2);
  }
  else
  {
    v3 = 0;
  }
  v4 = *(_QWORD *)(a1 + 1696);
  while (v4)
  {
    v5 = v4;
    v4 = *(_QWORD *)(v4 + 456);
    if ((*(_BYTE *)(v5 + 432) & 2) == 0 && (*(_BYTE *)(v5 + 17) & 0x40) == 0)
    {
      sub_10004CEA8(v5);
      if ((*(_BYTE *)(v5 + 17) & 0x20) != 0)
        sub_10001A528(v5);
      sub_100022B8C(v5);
      v3 = (v3 + 1);
    }
  }
  return v3;
}

uint64_t sub_10000A01C(unint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t i;
  uint64_t v6;
  NSObject *v7;
  uint64_t j;
  uint64_t v9;
  NSObject *v10;
  uint8_t buf[4];
  const char *v13;

  v1 = qword_10008C6D0;
  if (!qword_10008C6D0)
    return 0;
  v3 = 0;
  do
  {
    v4 = v1;
    v1 = *(_QWORD *)(v1 + 1712);
    for (i = *(_QWORD *)(v4 + 1704); i; i = *(_QWORD *)(i + 296))
    {
      if ((*(_BYTE *)(i + 264) & 2) == 0 && (*(_BYTE *)(i + 57) & 0x40) == 0)
      {
        v6 = sub_10003B380(a1, *(_QWORD *)(i + 8));
        if (!(_DWORD)v6)
        {
          if (dword_10008BA20)
          {
            v7 = ne_log_obj(v6);
            if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315138;
              v13 = "ike_session_purgephXbydstaddrwop";
              _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "in %s... purging Phase 2 structures\n", buf, 0xCu);
            }
          }
          if ((*(_BYTE *)(i + 57) & 0x20) != 0)
            sub_10001AA88(i);
          sub_1000250DC((_QWORD *)i);
          v3 = (v3 + 1);
        }
      }
    }
    for (j = *(_QWORD *)(v4 + 1696); j; j = *(_QWORD *)(j + 456))
    {
      if ((*(_BYTE *)(j + 432) & 2) == 0 && (*(_BYTE *)(j + 17) & 0x40) == 0)
      {
        v9 = sub_10003B380(a1, *(_QWORD *)(j + 48));
        if (!(_DWORD)v9)
        {
          if (dword_10008BA20)
          {
            v10 = ne_log_obj(v9);
            if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315138;
              v13 = "ike_session_purgephXbydstaddrwop";
              _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "in %s... purging Phase 1 and related Phase 2 structures\n", buf, 0xCu);
            }
          }
          sub_10004CEA8(j);
          if ((*(_BYTE *)(j + 17) & 0x20) != 0)
            sub_10001A528(j);
          sub_100022B8C(j);
          v3 = (v3 + 1);
        }
      }
    }
  }
  while (v1);
  return v3;
}

_QWORD *sub_10000A210(_QWORD *result, int a2)
{
  uint64_t v2;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;

  v2 = qword_10008C6D0;
  if (qword_10008C6D0)
  {
    v4 = (int)result;
    do
    {
      v5 = v2;
      v2 = *(_QWORD *)(v2 + 1712);
      v6 = *(_QWORD *)(v5 + 1704);
      if (v6)
      {
        do
        {
          v7 = v6;
          v6 = *(_QWORD *)(v6 + 296);
          if (*(_DWORD *)(v7 + 52) == v4 && (*(_BYTE *)(v7 + 264) & 2) == 0)
          {
            v8 = *(_DWORD *)(v7 + 56);
            if ((v8 & 0x4000) == 0)
            {
              if ((v8 & 0x2000) != 0)
                sub_10001AA88(v7);
              sub_10004CC10(*(_QWORD *)(v7 + 272), (uint64_t)off_100088500[0]);
              result = sub_1000250DC((_QWORD *)v7);
            }
          }
        }
        while (v6);
        v9 = *(_QWORD *)(v5 + 1704);
        while (v9)
        {
          v10 = v9;
          v9 = *(_QWORD *)(v9 + 296);
          if (a2)
          {
            if (*(_DWORD *)(v10 + 52) == v4)
            {
              v11 = *(_QWORD *)(v10 + 272);
              if (v11)
              {
                v12 = *(_QWORD *)(v11 + 1696);
                while (v12)
                {
                  v13 = v12;
                  v12 = *(_QWORD *)(v12 + 456);
                  if ((*(_BYTE *)(v13 + 432) & 2) == 0)
                  {
                    v14 = *(_DWORD *)(v13 + 16);
                    if ((v14 & 0x4000) == 0)
                    {
                      if ((v14 & 0x2000) != 0)
                        sub_10001A528(v13);
                      result = sub_100022B8C(v13);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    while (v2);
  }
  return result;
}

uint64_t sub_10000A320(unint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t i;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  _DWORD v14[2];
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;

  v1 = qword_10008C6D0;
  if (!qword_10008C6D0)
    return 0xFFFFFFFFLL;
  v3 = 0xFFFFFFFFLL;
  do
  {
    for (i = *(_QWORD *)(v1 + 1696); i; i = *(_QWORD *)(i + 456))
    {
      v5 = sub_10003B380(a1, *(_QWORD *)(i + 48));
      if (!(_DWORD)v5)
      {
        if ((*(_BYTE *)(i + 17) & 0x20) != 0
          && (*(_BYTE *)(i + 432) & 2) == 0
          && *(_DWORD *)(i + 368)
          && *(_DWORD *)(*(_QWORD *)(i + 64) + 216))
        {
          if (*(_BYTE *)(i + 386))
          {
            if (dword_10008BA20)
            {
              v6 = ne_log_obj(v5);
              if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(v14[0]) = 0;
                _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Skipping forced-DPD for Phase 1 (dpd already in progress).\n", (uint8_t *)v14, 2u);
              }
            }
          }
          else
          {
            sub_10001C108(i);
            v3 = 0;
          }
          v12 = *(_QWORD *)(i + 440);
          if (v12)
            *(_BYTE *)(v12 + 280) |= 1u;
        }
        else if (dword_10008BA20)
        {
          v7 = ne_log_obj(v5);
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
          {
            v8 = *(_DWORD *)(i + 16);
            v9 = *(unsigned __int8 *)(i + 432) << 30 >> 31;
            v10 = *(_DWORD *)(i + 368);
            v11 = *(_DWORD *)(*(_QWORD *)(i + 64) + 216);
            v14[0] = 67109888;
            v14[1] = v8;
            v15 = 1024;
            v16 = v9;
            v17 = 1024;
            v18 = v10;
            v19 = 1024;
            v20 = v11;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Skipping forced-DPD for Phase 1 (status %d, dying %d, dpd-support %d, dpd-interval %d).\n", (uint8_t *)v14, 0x1Au);
          }
        }
      }
    }
    v1 = *(_QWORD *)(v1 + 1712);
  }
  while (v1);
  return v3;
}

void sub_10000A50C(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  NSObject *v10;
  __int128 *v11;
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  NSObject *v16;
  __int128 *v17;
  NSObject *v18;
  const char *v19;
  NSObject *v20;
  __int128 *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  NSObject *v27;
  NSObject *v28;
  NSObject *v29;
  const char *v30;
  NSObject *v31;
  uint8_t v32[8];
  _BYTE buf[24];

  v1 = qword_10008C6D0;
  while (v1)
  {
    v2 = v1;
    v1 = *(_QWORD *)(v1 + 1712);
    v3 = *(_QWORD *)(v2 + 1696);
    if (v3)
    {
      while (1)
      {
        v4 = v3;
        v3 = *(_QWORD *)(v3 + 456);
        v5 = *(_QWORD *)(v4 + 440);
        if (v5)
        {
          if ((*(_BYTE *)(v5 + 280) & 4) != 0)
            break;
        }
        if ((*(_BYTE *)(v4 + 432) & 2) == 0 && (*(_BYTE *)(v4 + 17) & 0x40) == 0)
        {
          v6 = *(_DWORD *)(v4 + 112);
          if (v6)
          {
            *(_QWORD *)v32 = 0;
            if (sub_10003A6A0(v6, v32))
            {
              if (*(uint64_t *)v32 <= qword_10008C6F0)
              {
                v7 = *(unsigned int *)(v4 + 112);
                if ((_DWORD)v7)
                {
                  sub_10003A6F0(v7);
                  *(_DWORD *)(v4 + 112) = 0;
                }
                v8 = *(unsigned int *)(v4 + 116);
                if ((_DWORD)v8)
                {
                  sub_10003A6F0(v8);
                  *(_DWORD *)(v4 + 116) = 0;
                }
                *(_BYTE *)(v4 + 432) |= 2u;
                sub_100003774((int *)(v4 + 16), 17408);
                sub_10004B64C(v4);
                v9 = sub_10003A520(1, (uint64_t)sub_100024B18, v4);
                *(_DWORD *)(v4 + 112) = (_DWORD)v9;
                if (dword_10008BA20)
                {
                  v10 = ne_log_obj(v9);
                  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
                  {
                    v11 = sub_100023E84(v4, 0);
                    *(_DWORD *)buf = 136315138;
                    *(_QWORD *)&buf[4] = v11;
                    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Phase 1 %s expired while sleeping: quick deletion.\n", buf, 0xCu);
                  }
                }
              }
            }
          }
          v12 = *(_DWORD *)(v4 + 116);
          if (v12)
          {
            *(_QWORD *)buf = 0;
            if (sub_10003A6A0(v12, buf))
            {
              if ((*(_BYTE *)(v4 + 17) & 0x40) != 0 || *(uint64_t *)buf <= qword_10008C6F0)
              {
                v13 = *(unsigned int *)(v4 + 116);
                if ((_DWORD)v13)
                {
                  sub_10003A6F0(v13);
                  *(_DWORD *)(v4 + 116) = 0;
                }
              }
            }
          }
          v14 = *(_DWORD *)(v4 + 120);
          if (v14)
          {
            *(_QWORD *)buf = 0;
            if (sub_10003A6A0(v14, buf))
            {
              if ((*(_BYTE *)(v4 + 17) & 0x40) != 0 || *(uint64_t *)buf <= qword_10008C6F0)
              {
                v15 = *(unsigned int *)(v4 + 120);
                if ((_DWORD)v15)
                {
                  sub_10003A6F0(v15);
                  *(_DWORD *)(v4 + 120) = 0;
                }
              }
            }
          }
          a1 = *(unsigned int *)(v4 + 388);
          if ((_DWORD)a1)
          {
            *(_QWORD *)buf = 0;
            a1 = sub_10003A6A0(a1, buf);
            if ((_DWORD)a1)
            {
              if ((*(_BYTE *)(v4 + 17) & 0x40) != 0 || *(uint64_t *)buf <= qword_10008C6F0)
              {
                a1 = *(unsigned int *)(v4 + 388);
                if ((_DWORD)a1)
                {
                  a1 = sub_10003A6F0(a1);
                  *(_DWORD *)(v4 + 388) = 0;
                }
              }
            }
          }
          goto LABEL_42;
        }
        if (dword_10008BA20)
        {
          v16 = ne_log_obj(a1);
          a1 = os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT);
          if ((_DWORD)a1)
          {
            v17 = sub_100023E84(v4, 0);
            *(_DWORD *)buf = 136315138;
            *(_QWORD *)&buf[4] = v17;
            v18 = v16;
            v19 = "Skipping sweep of Phase 1 %s because it's already expired.\n";
LABEL_41:
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v19, buf, 0xCu);
          }
        }
LABEL_42:
        if (!v3)
          goto LABEL_43;
      }
      if (!dword_10008BA20)
        goto LABEL_42;
      v20 = ne_log_obj(a1);
      a1 = os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT);
      if (!(_DWORD)a1)
        goto LABEL_42;
      v21 = sub_100023E84(v4, 0);
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = v21;
      v18 = v20;
      v19 = "Skipping sweep of Phase 1 %s because it's been asserted.\n";
      goto LABEL_41;
    }
LABEL_43:
    v22 = *(_QWORD *)(v2 + 1704);
    while (v22)
    {
      v23 = v22;
      v22 = *(_QWORD *)(v22 + 296);
      v24 = *(_QWORD *)(v23 + 272);
      if (v24 && (*(_BYTE *)(v24 + 280) & 4) != 0)
      {
        if (dword_10008BA20)
        {
          v31 = ne_log_obj(a1);
          a1 = os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT);
          if ((_DWORD)a1)
          {
            *(_WORD *)buf = 0;
            v29 = v31;
            v30 = "Skipping sweep of Phase 2 because it's been asserted.\n";
LABEL_67:
            _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, v30, buf, 2u);
          }
        }
      }
      else if ((*(_BYTE *)(v23 + 264) & 2) != 0 || (*(_BYTE *)(v23 + 57) & 0x40) != 0)
      {
        if (dword_10008BA20)
        {
          v28 = ne_log_obj(a1);
          a1 = os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT);
          if ((_DWORD)a1)
          {
            *(_WORD *)buf = 0;
            v29 = v28;
            v30 = "Skipping sweep of Phase 2 because it's already expired.\n";
            goto LABEL_67;
          }
        }
      }
      else
      {
        v25 = *(_DWORD *)(v23 + 64);
        if (v25)
        {
          *(_QWORD *)buf = 0;
          if (sub_10003A6A0(v25, buf))
          {
            if (*(uint64_t *)buf <= qword_10008C6F0)
            {
              sub_100003774((int *)(v23 + 56), 18432);
              *(_BYTE *)(v23 + 264) |= 2u;
              sub_1000250DC((_QWORD *)v23);
              sub_10004CC10(*(_QWORD *)(v23 + 272), (uint64_t)off_100088518[0]);
              if (dword_10008BA20)
              {
                v27 = ne_log_obj(v26);
                if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)v32 = 0;
                  _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Phase 2 expired while sleeping: quick deletion.\n", v32, 2u);
                }
              }
            }
          }
        }
        a1 = *(unsigned int *)(v23 + 68);
        if ((_DWORD)a1)
        {
          *(_QWORD *)buf = 0;
          a1 = sub_10003A6A0(a1, buf);
          if ((_DWORD)a1)
          {
            if ((*(_BYTE *)(v23 + 57) & 0x40) != 0 || *(uint64_t *)buf <= qword_10008C6F0)
            {
              a1 = *(unsigned int *)(v23 + 68);
              if ((_DWORD)a1)
              {
                a1 = sub_10003A6F0(a1);
                *(_DWORD *)(v23 + 68) = 0;
              }
            }
          }
        }
      }
    }
  }
  sub_10004E66C(a1);
}

uint64_t sub_10000A9C8(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  unsigned int v8;

  v1 = a1;
  v8 = 0;
  v2 = *(_QWORD *)(a1 + 48);
  v3 = *(unsigned __int8 *)(v2 + 1);
  if (v3 != 30)
  {
    if (v3 == 2)
      return *(unsigned int *)(v2 + 4);
    goto LABEL_9;
  }
  a1 += 28;
  if (!*(_DWORD *)(v1 + 28))
  {
LABEL_9:
    if (dword_10008BA20)
    {
      v6 = ne_log_obj(a1);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        sub_1000562E4();
    }
    return v8;
  }
  v4 = nw_nat64_extract_v4(a1, v2 + 8, &v8);
  if ((v4 & 1) == 0)
  {
    if (dword_10008BA20)
    {
      v5 = ne_log_obj(v4);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_100056350();
    }
  }
  return v8;
}

uint64_t sub_10000AAA8(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  unsigned int v8;

  v1 = a1;
  v8 = 0;
  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(unsigned __int8 *)(v2 + 1);
  if (v3 != 30)
  {
    if (v3 == 2)
      return *(unsigned int *)(v2 + 4);
    goto LABEL_9;
  }
  a1 += 16;
  if (!*(_DWORD *)(v1 + 16))
  {
LABEL_9:
    if (dword_10008BA20)
    {
      v6 = ne_log_obj(a1);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        sub_10005637C();
    }
    return v8;
  }
  v4 = nw_nat64_extract_v4(a1, v2 + 8, &v8);
  if ((v4 & 1) == 0)
  {
    if (dword_10008BA20)
    {
      v5 = ne_log_obj(v4);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_1000563E8();
    }
  }
  return v8;
}

void sub_10000AB88(void *a1, uint64_t a2, uint64_t a3, const char *a4)
{
  NSObject *v4;
  uint8_t *v5;

  _os_log_debug_impl(a1, v4, OS_LOG_TYPE_DEBUG, a4, v5, 0xCu);
}

void sub_10000AB9C(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0xEu);
}

uint64_t sub_10000ABC8(unint64_t *a1, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t i;
  uint64_t *j;
  uint64_t *v12;
  NSObject *v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  _QWORD **v17;
  NSObject *v18;
  NSObject *v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t result;
  __int16 v23[8];
  _OWORD v24[6];

  v3 = sub_10000AE28(a1, 0);
  if (!v3)
    return 0xFFFFFFFFLL;
  v4 = v3;
  v6 = a2 + 9;
  v5 = a2[9];
  if (v5)
  {
    sub_100038AD0((_QWORD *)v5);
    *v6 = 0;
  }
  v7 = 0;
  memset(v24, 0, sizeof(v24));
  while (1)
  {
    v8 = (uint64_t *)v4[v7];
    if (v8)
      break;
LABEL_10:
    if (++v7 == 256)
    {
      if (dword_100088280)
      {
        for (i = 0; i != 256; ++i)
        {
          for (j = (uint64_t *)v4[i]; j; j = (uint64_t *)j[2])
          {
            v12 = j;
            do
            {
              sub_10000C5F0(v12, *(_QWORD *)(a2[8] + 248));
              v12 = (uint64_t *)v12[3];
            }
            while (v12);
          }
        }
      }
      if (dword_10008BA20)
      {
        v13 = ne_log_obj(v5);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
          sub_100056414();
      }
      goto LABEL_39;
    }
  }
LABEL_6:
  v9 = v8;
  while (1)
  {
    v5 = (uint64_t)sub_10000B704(v9, *(_QWORD *)(a2[8] + 248), v24, *(_DWORD *)(a2[8] + 172));
    if (v5)
      break;
    v9 = (uint64_t *)v9[3];
    if (!v9)
    {
      v8 = (uint64_t *)v8[2];
      if (v8)
        goto LABEL_6;
      goto LABEL_10;
    }
  }
  v14 = v5;
  if (dword_10008BA20)
  {
    v15 = ne_log_obj(v5);
    v5 = os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG);
    if ((_DWORD)v5)
      sub_1000564BC();
  }
  v17 = (_QWORD **)(v14 + 64);
  v16 = *(_QWORD *)(v14 + 64);
  if (v16)
  {
    if (*(_QWORD *)(v16 + 8) && *(_DWORD *)(v16 + 16))
      goto LABEL_32;
    if (dword_10008BA20)
    {
      v18 = ne_log_obj(v5);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        v23[0] = 0;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "invalid DH parameter found, use default.\n", (uint8_t *)v23, 2u);
      }
    }
    sub_10002957C(*v17);
    *v17 = 0;
  }
  v5 = sub_100029AD4(*(unsigned int *)(v14 + 60), v14 + 64);
  if ((_DWORD)v5 == -1)
  {
    free((void *)v14);
    goto LABEL_39;
  }
LABEL_32:
  *v6 = v14;
  if (dword_10008BA20)
  {
    v19 = ne_log_obj(v5);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
      sub_100056440((uint64_t)(a2 + 9));
  }
  v20 = sub_10000CFCC(v9, (uint64_t)a2);
  if (v20)
  {
    v21 = v20;
    sub_10000B6A4(v4);
    result = 0;
    a2[43] = v21;
    return result;
  }
  sub_100038AD0((_QWORD *)*v6);
  *v6 = 0;
LABEL_39:
  sub_10000B6A4(v4);
  return 0xFFFFFFFFLL;
}

void *sub_10000AE28(unint64_t *a1, unsigned int a2)
{
  unint64_t v3;
  unint64_t v4;
  NSObject *v5;
  unsigned int v6;
  NSObject *v8;
  NSObject *v9;
  void *v10;
  void *v11;
  uint64_t v12;
  uint64_t i;
  unsigned int v14;
  uint64_t v15;
  NSObject *v16;
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  unsigned __int8 *v21;
  unsigned int v22;
  uint64_t v23;
  NSObject *v24;
  uint64_t v25;
  NSObject *v26;
  uint64_t v27;
  _QWORD *v28;
  _QWORD *v29;
  _QWORD *v30;
  int v31;
  int v32;
  NSObject *v33;
  int v34;
  NSObject *v35;
  const char *v36;
  uint32_t v37;
  NSObject *v38;
  int v39;
  int v40;
  NSObject *v41;
  void *v42;
  uint64_t j;
  NSObject *v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  _QWORD *v48;
  NSObject *v49;
  int v50;
  NSObject *v51;
  NSObject *v52;
  NSObject *v53;
  uint64_t v54;
  NSObject *v56;
  NSObject *v57;
  NSObject *v58;
  _QWORD *v59;
  int v60;
  uint8_t buf[4];
  _BYTE v62[10];
  int v63;

  v4 = *a1;
  v3 = a1[1];
  if (a2 <= 1)
  {
    if (v4 <= 7)
    {
      if (dword_10008BA20)
      {
        v5 = ne_log_obj(a1);
        if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
          sub_1000564EC();
      }
      return 0;
    }
    if (*(_DWORD *)v3 != 0x1000000)
    {
      if (dword_10008BA20)
      {
        v9 = ne_log_obj(a1);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          sub_1000567C4();
      }
      return 0;
    }
    v6 = bswap32(*(_DWORD *)(v3 + 4));
    if (v6 != 1)
    {
      if (v6 == 4 || v6 == 2)
      {
        if (dword_10008BA20)
        {
          v8 = ne_log_obj(a1);
          if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
            sub_100056764();
        }
      }
      else if (dword_10008BA20)
      {
        v56 = ne_log_obj(a1);
        if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
          sub_100056550();
      }
      return 0;
    }
    v3 += 8;
    LODWORD(v4) = v4 - 8;
  }
  v10 = malloc_type_calloc(1uLL, 0x800uLL, 0x2004093837F09uLL);
  if (!v10)
  {
    if (dword_10008BA20)
    {
      v41 = ne_log_obj(0);
      if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
        sub_1000565B0();
    }
    return 0;
  }
  v11 = v10;
  v12 = (uint64_t)sub_100022FCC(2, (unsigned __int8 *)v3, v4);
  if (!v12)
  {
LABEL_107:
    free(v11);
    return 0;
  }
  v60 = 0;
  v59 = (_QWORD *)v12;
  for (i = *(_QWORD *)(v12 + 8); *(_BYTE *)i == 2; i += 16)
  {
    v14 = *(_DWORD *)(i + 4);
    if (v14 <= 7)
    {
      if (dword_10008BA20)
      {
        v53 = ne_log_obj(v12);
        if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
          sub_100056668((int *)(i + 4), v53, v54);
      }
LABEL_106:
      sub_10003F318(v59);
      goto LABEL_107;
    }
    v15 = *(_QWORD *)(i + 8);
    if (dword_10008BA20)
    {
      v16 = ne_log_obj(v12);
      v12 = os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)v12)
      {
        v39 = *(unsigned __int8 *)(v15 + 4);
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)v62 = v39;
        *(_WORD *)&v62[4] = 1024;
        *(_DWORD *)&v62[6] = v14;
        _os_log_debug_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "proposal #%u len=%d\n", buf, 0xEu);
      }
    }
    if ((a2 & 0xFFFFFFFE) == 2)
    {
      if (dword_10008BA20)
      {
        v17 = ne_log_obj(v12);
        v12 = os_log_type_enabled(v17, OS_LOG_TYPE_ERROR);
        if ((_DWORD)v12)
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)v62 = a2;
          _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "unsupported mode %d\n", buf, 8u);
        }
      }
    }
    else
    {
      v12 = ((uint64_t (*)(_QWORD))off_100084EC8[a2])(*(unsigned __int8 *)(v15 + 5));
      if ((v12 & 0x80000000) == 0)
      {
        v12 = sub_10000D720(*(unsigned __int8 *)(v15 + 5), *(unsigned __int8 *)(v15 + 6));
        if ((v12 & 0x80000000) == 0)
        {
          v18 = *(unsigned __int8 *)(v15 + 6);
          if (v18 + 8 <= (unint64_t)*(int *)(i + 4))
          {
            v19 = (uint64_t)sub_100022FCC(3, (unsigned __int8 *)(v15 + v18 + 8), (bswap32(*(unsigned __int16 *)(v15 + 2)) >> 16) - v18 - 8);
            if (!v19)
              goto LABEL_106;
            v20 = (_QWORD *)v19;
            v21 = *(unsigned __int8 **)(v19 + 8);
LABEL_37:
            if (*v21 != 3)
            {
              if (!*v21)
                goto LABEL_68;
              if (!dword_10008BA20)
                goto LABEL_68;
              v33 = ne_log_obj(v19);
              if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
                goto LABEL_68;
              v34 = *v21;
              *(_DWORD *)buf = 67109120;
              *(_DWORD *)v62 = v34;
              v35 = v33;
              v36 = "Invalid payload type=%u\n";
              v37 = 8;
              goto LABEL_71;
            }
            v22 = *((_DWORD *)v21 + 1);
            if (v22 <= 7)
            {
              if (!dword_10008BA20)
                goto LABEL_68;
              v38 = ne_log_obj(v19);
              if (!os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
                goto LABEL_68;
              v40 = *((_DWORD *)v21 + 1);
              *(_DWORD *)buf = 134218240;
              *(_QWORD *)v62 = 8;
              *(_WORD *)&v62[8] = 1024;
              v63 = v40;
              v35 = v38;
              v36 = "get_transform invalid length of transform, expected %lu actual %d\n";
              v37 = 18;
LABEL_71:
              _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, v36, buf, v37);
LABEL_68:
              sub_10003F318(v20);
              continue;
            }
            v23 = *((_QWORD *)v21 + 1);
            if (dword_10008BA20)
            {
              v24 = ne_log_obj(v19);
              v19 = os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG);
              if ((_DWORD)v19)
              {
                v32 = *(unsigned __int8 *)(v23 + 4);
                *(_DWORD *)buf = 67109376;
                *(_DWORD *)v62 = v32;
                *(_WORD *)&v62[4] = 1024;
                *(_DWORD *)&v62[6] = v22;
                _os_log_debug_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEBUG, "transform #%u len=%u\n", buf, 0xEu);
              }
            }
            v25 = *(unsigned __int8 *)(v15 + 5);
            if (v25 < 5)
            {
              if (*(_BYTE *)(v15 + 5))
              {
                v19 = qword_100084EE8[v25](*(unsigned __int8 *)(v23 + 5));
                if ((v19 & 0x80000000) == 0)
                {
                  v19 = qword_100084F10[*(unsigned __int8 *)(v15 + 5)](v23);
                  if (!(_DWORD)v19)
                  {
                    v19 = (uint64_t)malloc_type_calloc(1uLL, 0x20uLL, 0x20040DC1BFBCFuLL);
                    if (!v19)
                    {
                      if (dword_10008BA20)
                      {
                        v58 = ne_log_obj(0);
                        if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
                          sub_1000565B0();
                      }
                      sub_10003F318(v20);
                      goto LABEL_106;
                    }
                    *(_QWORD *)v19 = v15;
                    *(_QWORD *)(v19 + 8) = v23;
                    v27 = *(unsigned __int8 *)(v15 + 4);
                    v28 = (_QWORD *)*((_QWORD *)v11 + v27);
                    do
                    {
                      if (!v28)
                      {
                        *((_QWORD *)v11 + v27) = v19;
                        ++v60;
                        goto LABEL_60;
                      }
                      v29 = v28;
                      v28 = (_QWORD *)v28[2];
                    }
                    while (v28);
                    if (*v29 == v15)
                    {
                      do
                      {
                        v30 = v29;
                        v29 = (_QWORD *)v29[3];
                      }
                      while (v29);
                      v30[3] = v19;
                    }
                    else
                    {
                      v29[2] = v19;
                    }
                  }
                }
              }
              else if (dword_10008BA20)
              {
                v26 = ne_log_obj(v19);
                v19 = os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT);
                if ((_DWORD)v19)
                {
LABEL_59:
                  v31 = *(unsigned __int8 *)(v15 + 5);
                  *(_DWORD *)buf = 67109120;
                  *(_DWORD *)v62 = v31;
                  _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "unsupported proto_id %u\n", buf, 8u);
                }
              }
            }
            else if (dword_10008BA20)
            {
              v26 = ne_log_obj(v19);
              v19 = os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT);
              if ((_DWORD)v19)
                goto LABEL_59;
            }
LABEL_60:
            v21 += 16;
            goto LABEL_37;
          }
          if (dword_10008BA20)
          {
            v57 = ne_log_obj(v12);
            if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
              sub_1000566E4();
          }
          goto LABEL_106;
        }
      }
    }
  }
  if (*(_BYTE *)i)
  {
    if (dword_10008BA20)
    {
      v51 = ne_log_obj(v12);
      if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
        sub_1000565DC();
    }
    goto LABEL_106;
  }
  sub_10003F318(v59);
  for (j = 0; j != 256; ++j)
  {
    if (*((_QWORD *)v11 + j))
    {
      if (dword_10008BA20)
      {
        v44 = ne_log_obj(v42);
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)v62 = j;
          _os_log_debug_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEBUG, "pair %d:\n", buf, 8u);
        }
      }
      sub_1000376E8(7, *((_QWORD *)v11 + j));
      v42 = (void *)*((_QWORD *)v11 + j);
      if (v42)
      {
        v45 = 0;
        v46 = *((_QWORD *)v11 + j);
        while (*(_QWORD *)(v46 + 8))
        {
          v47 = v46;
          do
          {
            ++v45;
            v47 = *(_QWORD *)(v47 + 24);
          }
          while (v47);
          v46 = *(_QWORD *)(v46 + 16);
          if (!v46)
            goto LABEL_91;
        }
        do
        {
          v48 = (_QWORD *)*((_QWORD *)v42 + 2);
          free(v42);
          v42 = v48;
        }
        while (v48);
        *((_QWORD *)v11 + j) = 0;
        --v60;
      }
      else
      {
        v45 = 0;
LABEL_91:
        if (dword_10008BA20)
        {
          v49 = ne_log_obj(v42);
          v42 = (void *)os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG);
          if ((_DWORD)v42)
          {
            v50 = *(unsigned __int8 *)(**((_QWORD **)v11 + j) + 4);
            *(_DWORD *)buf = 67109376;
            *(_DWORD *)v62 = v50;
            *(_WORD *)&v62[4] = 1024;
            *(_DWORD *)&v62[6] = v45;
            _os_log_debug_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEBUG, "proposal #%u: %d transform\n", buf, 0xEu);
          }
        }
      }
    }
  }
  if (v60 <= 0)
  {
    if (dword_10008BA20)
    {
      v52 = ne_log_obj(v42);
      if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
        sub_10005663C();
    }
    goto LABEL_107;
  }
  return v11;
}

void sub_10000B6A4(_QWORD *a1)
{
  uint64_t i;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;

  for (i = 0; i != 256; ++i)
  {
    v3 = (_QWORD *)a1[i];
    while (v3)
    {
      v4 = v3;
      v3 = (_QWORD *)v3[2];
      do
      {
        v5 = (_QWORD *)v4[3];
        free(v4);
        v4 = v5;
      }
      while (v5);
    }
    a1[i] = 0;
  }
  free(a1);
}

_DWORD *sub_10000B704(uint64_t *a1, uint64_t a2, _OWORD *a3, int a4)
{
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  _BOOL8 v10;
  NSObject *v11;
  _OWORD *v12;
  _OWORD *v13;
  int v14;
  uint64_t v15;
  int v16;
  NSObject *v17;
  NSObject *v18;
  NSObject *v19;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  NSObject *v25;
  BOOL v26;
  int v27;
  int v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  char *v32;
  char *v33;
  char *v34;
  NSObject *v35;
  int v36;
  int v37;
  char *v38;
  char *v39;
  char *v40;
  char *v41;
  char *v42;
  char *v43;
  _DWORD *result;
  _OWORD *v45;
  _QWORD *v46;
  _OWORD *v47;
  unint64_t v48;
  _OWORD *v49;
  int v50;
  _OWORD *v51;
  _OWORD *v52;
  uint64_t v53;
  uint64_t v54;
  unint64_t v55;
  char v56;
  char v57[15];
  char v58;
  char v59[15];
  _OWORD v60[6];
  uint8_t buf[4];
  _BYTE v62[10];
  char *v63;

  v8 = *a1;
  v7 = a1[1];
  memset(v60, 0, sizeof(v60));
  if (dword_10008BA20)
  {
    v9 = ne_log_obj(a1);
    v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG);
    if (v10)
      sub_100056910(v8);
    if (dword_10008BA20)
    {
      v11 = ne_log_obj(v10);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
        sub_10005687C(v7, v8);
    }
  }
  if (a3)
    v12 = a3;
  else
    v12 = v60;
  v12[4] = 0u;
  v12[5] = 0u;
  v12[2] = 0u;
  v12[3] = 0u;
  *v12 = 0u;
  v12[1] = 0u;
  if ((sub_10000BE4C(v7, (uint64_t)v12) & 0x80000000) != 0)
    return 0;
  if (a2)
  {
    if (a3)
      v13 = a3;
    else
      v13 = v60;
    while (1)
    {
      v14 = sub_10000C57C(*(unsigned int *)(a2 + 48));
      v15 = sub_10000C57C(*((unsigned int *)v13 + 12));
      v16 = v15;
      if (dword_10008BA20)
      {
        v17 = ne_log_obj(v15);
        v15 = os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG);
        if ((_DWORD)v15)
          sub_100056850(&v58, v59);
        if (dword_10008BA20)
        {
          v18 = ne_log_obj(v15);
          v15 = os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG);
          if ((_DWORD)v15)
          {
            v27 = *(_DWORD *)a2;
            v28 = *(_DWORD *)v12;
            *(_DWORD *)buf = 67109376;
            *(_DWORD *)v62 = v27;
            *(_WORD *)&v62[4] = 1024;
            *(_DWORD *)&v62[6] = v28;
            _os_log_debug_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEBUG, "(version = %d:%d)\n", buf, 0xEu);
          }
          if (dword_10008BA20)
          {
            v19 = ne_log_obj(v15);
            v15 = os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG);
            if ((_DWORD)v15)
            {
              v29 = *(_QWORD *)(a2 + 16);
              v30 = (char *)*((_QWORD *)v13 + 2);
              *(_DWORD *)buf = 134218240;
              *(_QWORD *)v62 = v29;
              *(_WORD *)&v62[8] = 2048;
              v63 = v30;
              _os_log_debug_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "(lifetime = %ld:%ld)\n", buf, 0x16u);
            }
            if (dword_10008BA20)
            {
              v20 = ne_log_obj(v15);
              v15 = os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG);
              if ((_DWORD)v15)
              {
                v31 = *(_QWORD *)(a2 + 32);
                v32 = (char *)*((_QWORD *)v13 + 4);
                *(_DWORD *)buf = 134218240;
                *(_QWORD *)v62 = v31;
                *(_WORD *)&v62[8] = 2048;
                v63 = v32;
                _os_log_debug_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEBUG, "(lifebyte = %zu:%zu)\n", buf, 0x16u);
              }
              if (dword_10008BA20)
              {
                v21 = ne_log_obj(v15);
                v15 = os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG);
                if ((_DWORD)v15)
                {
                  v33 = sub_10003E5D0(1, *(unsigned int *)(a2 + 40));
                  v34 = sub_10003E5D0(1, *((unsigned int *)v13 + 10));
                  *(_DWORD *)buf = 136315394;
                  *(_QWORD *)v62 = v33;
                  *(_WORD *)&v62[8] = 2080;
                  v63 = v34;
                  _os_log_debug_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEBUG, "enctype = %s:%s\n", buf, 0x16u);
                }
                if (dword_10008BA20)
                {
                  v22 = ne_log_obj(v15);
                  v15 = os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG);
                  if ((_DWORD)v15)
                  {
                    v36 = *(_DWORD *)(a2 + 44);
                    v37 = *((_DWORD *)v13 + 11);
                    *(_DWORD *)buf = 67109376;
                    *(_DWORD *)v62 = v36;
                    *(_WORD *)&v62[4] = 1024;
                    *(_DWORD *)&v62[6] = v37;
                    _os_log_debug_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEBUG, "(encklen = %d:%d)\n", buf, 0xEu);
                  }
                  if (dword_10008BA20)
                  {
                    v23 = ne_log_obj(v15);
                    v15 = os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG);
                    if ((_DWORD)v15)
                    {
                      v38 = sub_10003E5D0(2, *(unsigned int *)(a2 + 52));
                      v39 = sub_10003E5D0(2, *((unsigned int *)v13 + 13));
                      *(_DWORD *)buf = 136315394;
                      *(_QWORD *)v62 = v38;
                      *(_WORD *)&v62[8] = 2080;
                      v63 = v39;
                      _os_log_debug_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEBUG, "hashtype = %s:%s\n", buf, 0x16u);
                    }
                    if (dword_10008BA20)
                    {
                      v24 = ne_log_obj(v15);
                      v15 = os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG);
                      if ((_DWORD)v15)
                      {
                        v40 = sub_10003E5D0(3, *(unsigned int *)(a2 + 48));
                        v41 = sub_10003E5D0(3, *((unsigned int *)v13 + 12));
                        *(_DWORD *)buf = 136315394;
                        *(_QWORD *)v62 = v40;
                        *(_WORD *)&v62[8] = 2080;
                        v63 = v41;
                        _os_log_debug_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEBUG, "authmethod = %s:%s\n", buf, 0x16u);
                      }
                      if (dword_10008BA20)
                      {
                        v25 = ne_log_obj(v15);
                        v15 = os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG);
                        if ((_DWORD)v15)
                        {
                          v42 = sub_10003E5D0(4, *(unsigned int *)(a2 + 60));
                          v43 = sub_10003E5D0(4, *((unsigned int *)v13 + 15));
                          *(_DWORD *)buf = 136315394;
                          *(_QWORD *)v62 = v42;
                          *(_WORD *)&v62[8] = 2080;
                          v63 = v43;
                          _os_log_debug_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEBUG, "dh_group = %s:%s\n", buf, 0x16u);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (*((_DWORD *)v13 + 10) == *(_DWORD *)(a2 + 40))
      {
        v26 = *((_DWORD *)v13 + 12) == v14 || v16 == v14;
        if (v26
          && *((_DWORD *)v13 + 13) == *(_DWORD *)(a2 + 52)
          && *((_DWORD *)v13 + 15) == *(_DWORD *)(a2 + 60)
          && *((_DWORD *)v13 + 11) == *(_DWORD *)(a2 + 44)
          && *(_DWORD *)v12 == *(_DWORD *)a2)
        {
          break;
        }
      }
LABEL_61:
      a2 = *(_QWORD *)(a2 + 80);
      if (!a2)
        goto LABEL_65;
    }
    switch(a4)
    {
      case 1:
        break;
      case 2:
        if (*((_QWORD *)v13 + 2) > *(_QWORD *)(a2 + 16) || *((_QWORD *)v13 + 4) > *(_QWORD *)(a2 + 32))
          goto LABEL_61;
        break;
      case 3:
        v54 = *((_QWORD *)v13 + 2);
        if (v54 < *(_QWORD *)(a2 + 16))
          *(_QWORD *)(a2 + 16) = v54;
        v55 = *((_QWORD *)v13 + 4);
        if (v55 < *(_QWORD *)(a2 + 32))
          *(_QWORD *)(a2 + 32) = v55;
        break;
      case 4:
        if (*((_QWORD *)v13 + 2) != *(_QWORD *)(a2 + 16) || *((_QWORD *)v13 + 4) != *(_QWORD *)(a2 + 32))
          goto LABEL_61;
        break;
      default:
        if (dword_10008BA20)
        {
          v35 = ne_log_obj(v15);
          if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
            sub_100056824(&v56, v57);
        }
        goto LABEL_61;
    }
  }
  else
  {
    v14 = 0;
    v16 = 0;
  }
LABEL_65:
  if (a3)
    v45 = a3;
  else
    v45 = v60;
  v46 = (_QWORD *)*((_QWORD *)v45 + 8);
  if (v46)
  {
    sub_10002957C(v46);
    *((_QWORD *)v45 + 8) = 0;
  }
  result = sub_1000399A0(a2);
  if (result)
  {
    if (a4 == 3)
    {
      v51 = v60;
      if (a3)
        v52 = a3;
      else
        v52 = v60;
      v53 = *((_QWORD *)v52 + 2);
      if (v53 < *((_QWORD *)result + 2))
        *((_QWORD *)result + 2) = v53;
      if (a3)
        v51 = a3;
      v48 = *((_QWORD *)v51 + 4);
      if (v48 >= *((_QWORD *)result + 4))
        goto LABEL_78;
    }
    else
    {
      if (a4 != 2 && a4 != 1)
        goto LABEL_78;
      v47 = v60;
      if (a3)
        v47 = a3;
      *((_QWORD *)result + 2) = *((_QWORD *)v47 + 2);
      v48 = *((_QWORD *)v47 + 4);
    }
    *((_QWORD *)result + 4) = v48;
LABEL_78:
    v49 = v60;
    if (a3)
      v49 = a3;
    v50 = *((_DWORD *)v49 + 12);
    if (v50 != v14 && v16 == v14)
      result[12] = v50;
  }
  return result;
}

uint64_t sub_10000BE4C(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  void *v5;
  unsigned int v6;
  _QWORD *v7;
  _WORD *v8;
  int v9;
  unsigned __int16 *v10;
  unint64_t v11;
  int v12;
  unsigned int v13;
  int v14;
  NSObject *v15;
  unsigned __int16 *v17;
  uint64_t v18;
  size_t v19;
  _QWORD *v20;
  size_t v21;
  uint64_t v22;
  void *v23;
  size_t v24;
  uint64_t v25;
  void *v26;
  unsigned int v27;
  unsigned int v28;
  NSObject *v29;
  uint64_t v30;
  char *v31;
  char *v32;
  NSObject *v33;
  NSObject *v35;
  NSObject *v36;
  NSObject *v37;
  NSObject *v38;
  NSObject *v39;
  NSObject *v40;
  uint64_t v41;
  NSObject *v42;
  NSObject *v43;
  NSObject *v44;
  unsigned int *v45;
  int v46;
  int v47;
  char v48;
  _BYTE v49[15];
  uint8_t buf[4];
  _BYTE v51[10];
  _DWORD v52[6];

  v4 = *(unsigned __int16 *)(a1 + 2);
  *(_QWORD *)(a2 + 16) = 28800;
  *(_QWORD *)(a2 + 32) = 0;
  v5 = malloc_type_calloc(1uLL, 0x30uLL, 0x10200409D20112CuLL);
  *(_QWORD *)(a2 + 64) = v5;
  if (!v5)
    return 0xFFFFFFFFLL;
  v6 = bswap32(v4) >> 16;
  if (v6 < 9)
    return 0;
  v7 = 0;
  v47 = 0;
  v8 = 0;
  v9 = v6 - 8;
  v10 = (unsigned __int16 *)(a1 + 8);
  v45 = (unsigned int *)(a2 + 40);
  v46 = 1;
  do
  {
    v11 = v9;
    if (v9 <= 3)
    {
      if (dword_10008BA20)
      {
        v35 = ne_log_obj(v5);
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
          sub_1000569CC();
      }
      return 0xFFFFFFFFLL;
    }
    v12 = *v10;
    v13 = bswap32(v12 & 0xFFFFFF7F) >> 16;
    v14 = (v12 << 8) & 0x8000;
    if (dword_10008BA20)
    {
      v15 = ne_log_obj(v5);
      v5 = (void *)os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)v5)
      {
        v31 = sub_10003E290(v13);
        v32 = sub_10003E5D0(v13, bswap32(v10[1]) >> 16);
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)v51 = v31;
        *(_WORD *)&v51[8] = 1024;
        v52[0] = v14;
        LOWORD(v52[1]) = 2080;
        *(_QWORD *)((char *)&v52[1] + 2) = v32;
        _os_log_debug_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "type=%s, flag=0x%04x, lorv=%s\n", buf, 0x1Cu);
      }
    }
    if (v13 <= 0x10 && ((1 << v13) & 0x117C0) != 0)
    {
      v17 = v10 + 1;
      if (v14)
      {
        LODWORD(v18) = 2;
      }
      else
      {
        v18 = bswap32(*v17) >> 16;
        if (v18 + 4 > v11)
        {
          if (dword_10008BA20)
          {
            v37 = ne_log_obj(v5);
            if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 67109632;
              *(_DWORD *)v51 = v13;
              *(_WORD *)&v51[4] = 1024;
              *(_DWORD *)&v51[6] = v18;
              LOWORD(v52[0]) = 2048;
              *(_QWORD *)((char *)v52 + 2) = v11 - 4;
              _os_log_error_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, "invalid ISAKMP-SA attr(%d), attr-len %d, overall-len %lu\n", buf, 0x18u);
            }
          }
          return 0xFFFFFFFFLL;
        }
        v17 = v10 + 2;
      }
      v19 = v18;
      v20 = sub_10003F1F8(v18);
      if (!v20)
        return 0xFFFFFFFFLL;
      v7 = v20;
      v5 = memcpy((void *)v20[1], v17, v19);
    }
    switch(v13)
    {
      case 1u:
        *v45 = bswap32(v10[1]) >> 16;
        if (v14)
          goto LABEL_62;
        break;
      case 2u:
        *(_DWORD *)(a2 + 52) = bswap32(v10[1]) >> 16;
        if (!v14)
          break;
        goto LABEL_62;
      case 3u:
        *(_DWORD *)(a2 + 48) = bswap32(v10[1]) >> 16;
        if (!v14)
          break;
        goto LABEL_62;
      case 4u:
        *(_DWORD *)(a2 + 60) = bswap32(v10[1]) >> 16;
        if (!v14)
          break;
        goto LABEL_62;
      case 5u:
        if (v10[1] != 256)
          return 0xFFFFFFFFLL;
        *(_DWORD *)(*(_QWORD *)(a2 + 64) + 4) = 1;
        if (!v14)
          break;
        goto LABEL_62;
      case 6u:
        *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8) = v7;
        if (!v14)
          break;
        goto LABEL_62;
      case 7u:
        sub_10003F318(v7);
        v21 = bswap32(v10[1]) >> 16;
        if (!v14)
        {
          *(_DWORD *)(*(_QWORD *)(a2 + 64) + 16) = v21;
          LODWORD(v24) = v21;
          goto LABEL_70;
        }
        v22 = *(_QWORD *)(a2 + 64);
        *(_DWORD *)(v22 + 16) = 0;
        v23 = (void *)(v22 + 16);
        if (v21 > 4)
          return 0xFFFFFFFFLL;
        if (v21 + 4 > v11)
        {
          if (dword_10008BA20)
          {
            v39 = ne_log_obj(v23);
            if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
              sub_100056B00();
          }
          return 0xFFFFFFFFLL;
        }
        v5 = memcpy(v23, v10 + 2, v21);
        *(_DWORD *)(*(_QWORD *)(a2 + 64) + 16) = bswap32(*(_DWORD *)(*(_QWORD *)(a2 + 64) + 16));
        goto LABEL_62;
      case 8u:
        sub_10003F318(v7);
        v24 = bswap32(v10[1]) >> 16;
        if (!v14)
        {
          *(_DWORD *)(*(_QWORD *)(a2 + 64) + 20) = v24;
          goto LABEL_69;
        }
        v25 = *(_QWORD *)(a2 + 64);
        *(_DWORD *)(v25 + 20) = 0;
        v26 = (void *)(v25 + 20);
        if (v24 > 4)
          return 0xFFFFFFFFLL;
        if (v24 + 4 > v11)
        {
          if (dword_10008BA20)
          {
            v40 = ne_log_obj(v26);
            if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
              sub_100056B68();
          }
          return 0xFFFFFFFFLL;
        }
        v5 = memcpy(v26, v10 + 2, v24);
        *(_DWORD *)(*(_QWORD *)(a2 + 64) + 20) = bswap32(*(_DWORD *)(*(_QWORD *)(a2 + 64) + 20));
        goto LABEL_62;
      case 9u:
        *(_QWORD *)(*(_QWORD *)(a2 + 64) + 24) = v7;
        if (!v14)
          break;
        goto LABEL_62;
      case 0xAu:
        *(_QWORD *)(*(_QWORD *)(a2 + 64) + 32) = v7;
        if (!v14)
          break;
        goto LABEL_62;
      case 0xBu:
        v27 = bswap32(v10[1]) >> 16;
        if ((((_WORD)v27 - 1) & 0xFFFE) != 0)
          v27 = 1;
        goto LABEL_46;
      case 0xCu:
        if (v8 && (*v8 & 0xFF7F) == 0xB00)
        {
          if (v46 == 2)
          {
            *(_QWORD *)(a2 + 32) = sub_10000CAC4((uint64_t)v7);
            sub_10003F318(v7);
            if (*(_QWORD *)(a2 + 32))
            {
              v27 = 2;
LABEL_46:
              v46 = v27;
              if (v14)
                goto LABEL_62;
              break;
            }
            if (!dword_10008BA20)
              return 0xFFFFFFFFLL;
            v44 = ne_log_obj(v5);
            if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
              return 0xFFFFFFFFLL;
LABEL_103:
            sub_100056C5C();
            return 0xFFFFFFFFLL;
          }
          if (v46 == 1)
          {
            *(_QWORD *)(a2 + 16) = sub_10000CAC4((uint64_t)v7);
            sub_10003F318(v7);
            if (*(_QWORD *)(a2 + 16))
            {
              v27 = 1;
              goto LABEL_46;
            }
            if (!dword_10008BA20)
              return 0xFFFFFFFFLL;
            v43 = ne_log_obj(v5);
            if (!os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
              return 0xFFFFFFFFLL;
            goto LABEL_103;
          }
          sub_10003F318(v7);
          if (dword_10008BA20)
          {
            v42 = ne_log_obj(v41);
            if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
              sub_100056BFC();
          }
          return 0xFFFFFFFFLL;
        }
        if (dword_10008BA20
          && (v29 = ne_log_obj(v5), v5 = (void *)os_log_type_enabled(v29, OS_LOG_TYPE_ERROR), (_DWORD)v5))
        {
          sub_100056BD0(&v48, v49);
          if (v14)
          {
LABEL_62:
            v9 = v11 - 4;
            v30 = (uint64_t)(v10 + 2);
            goto LABEL_72;
          }
        }
        else
        {
LABEL_61:
          if (v14)
            goto LABEL_62;
        }
        break;
      case 0xEu:
        v28 = bswap32(v10[1]) >> 16;
        if ((v28 & 7) != 0)
        {
          if (dword_10008BA20)
          {
            v38 = ne_log_obj(v5);
            if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
              sub_100056C88();
          }
          return 0xFFFFFFFFLL;
        }
        *(_DWORD *)(a2 + 44) = v28;
        ++v47;
        if (v14)
          goto LABEL_62;
        break;
      case 0x10u:
        *(_QWORD *)(*(_QWORD *)(a2 + 64) + 40) = v7;
        if (!v14)
          break;
        goto LABEL_62;
      default:
        goto LABEL_61;
    }
    LODWORD(v24) = bswap32(v10[1]) >> 16;
LABEL_69:
    LODWORD(v21) = v24;
LABEL_70:
    v9 = v11 - v24 - 4;
    if (v9 < 0)
    {
      if (dword_10008BA20)
      {
        v36 = ne_log_obj(v5);
        if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
          sub_100056A30();
      }
      return 0xFFFFFFFFLL;
    }
    v30 = (uint64_t)v10 + v21 + 4;
LABEL_72:
    v8 = v10;
    v10 = (unsigned __int16 *)v30;
  }
  while (v9 > 0);
  if (v47 && (*v45 | 4) == 5)
  {
    if (dword_10008BA20)
    {
      v33 = ne_log_obj(v5);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
        sub_100056A9C();
    }
    return 0xFFFFFFFFLL;
  }
  return 0;
}

uint64_t sub_10000C57C(uint64_t result)
{
  unsigned int v1;

  switch((int)result)
  {
    case 65002:
      result = 65001;
      break;
    case 65003:
    case 65005:
    case 65007:
    case 65009:
      return result;
    case 65004:
      result = 65003;
      break;
    case 65006:
      result = 65005;
      break;
    case 65008:
      result = 65007;
      break;
    case 65010:
      result = 65009;
      break;
    default:
      if ((_DWORD)result == 64222)
        v1 = 64221;
      else
        v1 = result;
      if ((_DWORD)result == 64224)
        result = 64223;
      else
        result = v1;
      break;
  }
  return result;
}

void sub_10000C5F0(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  NSObject *v6;
  uint64_t v7;
  NSObject *v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  NSObject *v15;
  int v16;
  int v17;
  int v18;
  char *v19;
  int v20;
  char *v21;
  int v22;
  int v23;
  int v24;
  int v25;
  char *v26;
  char *v27;
  int v28;
  int v29;
  int v30;
  int v31;
  char *v32;
  char *v33;
  int v34;
  int v35;
  int v36;
  int v37;
  char *v38;
  char *v39;
  int v40;
  int v41;
  int v42;
  int v43;
  char *v44;
  char *v45;
  int v46;
  _OWORD v48[2];
  __int128 v49;
  __int128 v50;
  void *v51[2];
  __int128 v52;
  uint8_t buf[4];
  int v54;
  __int16 v55;
  int v56;
  __int16 v57;
  int v58;
  __int16 v59;
  int v60;
  __int16 v61;
  char *v62;
  __int16 v63;
  _BYTE v64[14];
  __int16 v65;
  int v66;

  *(_OWORD *)v51 = 0u;
  v52 = 0u;
  v49 = 0u;
  v50 = 0u;
  memset(v48, 0, sizeof(v48));
  v3 = sub_10000BE4C(a1[1], (uint64_t)v48);
  if ((v3 & 0x80000000) == 0)
  {
    if (a2)
    {
      v4 = DWORD2(v49);
      do
      {
        if ((_DWORD)v4 != *(_DWORD *)(a2 + 40) && dword_10008BA20 != 0)
        {
          v6 = ne_log_obj(v3);
          v3 = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
          if ((_DWORD)v3)
          {
            v22 = *(_DWORD *)(a2 + 4);
            v23 = *(_DWORD *)(a2 + 8);
            v24 = *(unsigned __int8 *)(*a1 + 4);
            v25 = *(unsigned __int8 *)(a1[1] + 4);
            v26 = sub_10003E5D0(1, *(unsigned int *)(a2 + 40));
            v27 = sub_10003E5D0(1, v4);
            *(_DWORD *)buf = 67110402;
            v54 = v22;
            v55 = 1024;
            v56 = v23;
            v57 = 1024;
            v58 = v24;
            v59 = 1024;
            v60 = v25;
            v61 = 2080;
            v62 = v26;
            v63 = 2080;
            *(_QWORD *)v64 = v27;
            _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "rejected enctype: DB(prop#%d:trns#%d):Peer(prop#%d:trns#%d) = %s:%s\n", buf, 0x2Eu);
          }
        }
        v7 = v50;
        if ((_DWORD)v50 != *(_DWORD *)(a2 + 48) && dword_10008BA20 != 0)
        {
          v9 = ne_log_obj(v3);
          v3 = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
          if ((_DWORD)v3)
          {
            v28 = *(_DWORD *)(a2 + 4);
            v29 = *(_DWORD *)(a2 + 8);
            v30 = *(unsigned __int8 *)(*a1 + 4);
            v31 = *(unsigned __int8 *)(a1[1] + 4);
            v32 = sub_10003E5D0(3, *(unsigned int *)(a2 + 48));
            v33 = sub_10003E5D0(3, v7);
            *(_DWORD *)buf = 67110402;
            v54 = v28;
            v55 = 1024;
            v56 = v29;
            v57 = 1024;
            v58 = v30;
            v59 = 1024;
            v60 = v31;
            v61 = 2080;
            v62 = v32;
            v63 = 2080;
            *(_QWORD *)v64 = v33;
            _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "rejected authmethod: DB(prop#%d:trns#%d):Peer(prop#%d:trns#%d) = %s:%s\n", buf, 0x2Eu);
          }
        }
        v10 = DWORD1(v50);
        if (DWORD1(v50) != *(_DWORD *)(a2 + 52))
        {
          if (dword_10008BA20)
          {
            v11 = ne_log_obj(v3);
            v3 = os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
            if ((_DWORD)v3)
            {
              v34 = *(_DWORD *)(a2 + 4);
              v35 = *(_DWORD *)(a2 + 8);
              v36 = *(unsigned __int8 *)(*a1 + 4);
              v37 = *(unsigned __int8 *)(a1[1] + 4);
              v38 = sub_10003E5D0(2, *(unsigned int *)(a2 + 52));
              v39 = sub_10003E5D0(2, v10);
              *(_DWORD *)buf = 67110402;
              v54 = v34;
              v55 = 1024;
              v56 = v35;
              v57 = 1024;
              v58 = v36;
              v59 = 1024;
              v60 = v37;
              v61 = 2080;
              v62 = v38;
              v63 = 2080;
              *(_QWORD *)v64 = v39;
              _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "rejected hashtype: DB(prop#%d:trns#%d):Peer(prop#%d:trns#%d) = %s:%s\n", buf, 0x2Eu);
            }
          }
        }
        v12 = LODWORD(v51[1]);
        if (v51[1] != *(void **)(a2 + 72))
        {
          if (dword_10008BA20)
          {
            v13 = ne_log_obj(v3);
            v3 = os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
            if ((_DWORD)v3)
            {
              v16 = *(_DWORD *)(a2 + 4);
              v46 = *(_DWORD *)(a2 + 8);
              v17 = *(unsigned __int8 *)(*a1 + 4);
              v18 = *(unsigned __int8 *)(a1[1] + 4);
              v19 = sub_10003E5D0(2, *(unsigned int *)(a2 + 72));
              v20 = *(_DWORD *)(a2 + 76);
              v21 = sub_10003E5D0(2, v12);
              *(_DWORD *)buf = 67110914;
              v54 = v16;
              v55 = 1024;
              v56 = v46;
              v57 = 1024;
              v58 = v17;
              v59 = 1024;
              v60 = v18;
              v61 = 2080;
              v62 = v19;
              v63 = 1024;
              *(_DWORD *)v64 = v20;
              *(_WORD *)&v64[4] = 2080;
              *(_QWORD *)&v64[6] = v21;
              v65 = 1024;
              v66 = HIDWORD(v51[1]);
              _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "rejected prf: DB(prop#%d:trns#%d):Peer(prop#%d:trns#%d) = %s.%d:%s.%d\n", buf, 0x3Au);
            }
          }
        }
        v14 = HIDWORD(v50);
        if (HIDWORD(v50) != *(_DWORD *)(a2 + 60))
        {
          if (dword_10008BA20)
          {
            v15 = ne_log_obj(v3);
            v3 = os_log_type_enabled(v15, OS_LOG_TYPE_ERROR);
            if ((_DWORD)v3)
            {
              v40 = *(_DWORD *)(a2 + 4);
              v41 = *(_DWORD *)(a2 + 8);
              v42 = *(unsigned __int8 *)(*a1 + 4);
              v43 = *(unsigned __int8 *)(a1[1] + 4);
              v44 = sub_10003E5D0(4, *(unsigned int *)(a2 + 60));
              v45 = sub_10003E5D0(4, v14);
              *(_DWORD *)buf = 67110402;
              v54 = v40;
              v55 = 1024;
              v56 = v41;
              v57 = 1024;
              v58 = v42;
              v59 = 1024;
              v60 = v43;
              v61 = 2080;
              v62 = v44;
              v63 = 2080;
              *(_QWORD *)v64 = v45;
              _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "rejected dh_group: DB(prop#%d:trns#%d):Peer(prop#%d:trns#%d) = %s:%s\n", buf, 0x2Eu);
            }
          }
        }
        a2 = *(_QWORD *)(a2 + 80);
      }
      while (a2);
    }
    if (v51[0])
      sub_10002957C((_QWORD *)v51[0]);
  }
}

uint64_t sub_10000CAC4(uint64_t result)
{
  NSObject *v1;

  if (result)
  {
    if (*(_QWORD *)result == 4)
      return bswap32(**(_DWORD **)(result + 8));
    if (*(_QWORD *)result == 2)
      return bswap32(**(unsigned __int16 **)(result + 8)) >> 16;
    if (dword_10008BA20)
    {
      v1 = ne_log_obj(result);
      result = os_log_type_enabled(v1, OS_LOG_TYPE_ERROR);
      if (!(_DWORD)result)
        return result;
      sub_100056CE8();
    }
    return 0;
  }
  return result;
}

uint64_t sub_10000CB50(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;

  v2 = sub_10000AE28(*(unint64_t **)(a1 + 224), 1u);
  if (!v2)
    return 0xFFFFFFFFLL;
  v3 = v2;
  v4 = (_QWORD *)sub_10000CBE4(a1, (uint64_t)v2);
  sub_10000B6A4(v3);
  if (!v4)
    return 0xFFFFFFFFLL;
  *(_QWORD *)(a1 + 232) = sub_10000CFCC(v4, *(_QWORD *)(a1 + 256));
  do
  {
    v5 = v4;
    v4 = (_QWORD *)v4[2];
    do
    {
      v6 = (_QWORD *)v5[3];
      free(v5);
      v5 = v6;
    }
    while (v6);
  }
  while (v4);
  if (*(_QWORD *)(a1 + 232))
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t sub_10000CBE4(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  NSObject *v4;
  uint64_t i;
  uint64_t v6;
  NSObject *v7;
  _BOOL4 v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  NSObject *v15;
  NSObject *v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  int *v21;
  int v22;
  uint64_t *v23;
  __int128 v24;
  _QWORD *v25;
  _QWORD *v26;
  uint64_t *v27;
  _QWORD *v28;
  NSObject *v29;
  NSObject *v30;
  char v32;
  char v33[15];
  char v34;
  char v35[15];
  char v36;
  char v37[15];
  char v38;
  char v39[15];
  char v40;
  char v41[15];
  uint8_t buf[4];
  int v43;
  __int16 v44;
  uint64_t v45;

  v3 = a1;
  *(_QWORD *)(a1 + 128) = 0;
  if (dword_10008BA20)
  {
    v4 = ne_log_obj(a1);
    a1 = os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG);
    if ((_DWORD)a1)
      sub_100056E54();
  }
  for (i = 0; i != 256; ++i)
  {
    v6 = *(_QWORD *)(a2 + 8 * i);
    if (v6)
    {
      if (dword_10008BA20)
      {
        v7 = ne_log_obj(a1);
        v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG);
        v6 = *(_QWORD *)(a2 + 8 * i);
        if (v8)
        {
          *(_DWORD *)buf = 67109376;
          v43 = i;
          v44 = 2048;
          v45 = v6;
          _os_log_debug_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "pair[%d]: %p\n", buf, 0x12u);
          v6 = *(_QWORD *)(a2 + 8 * i);
        }
      }
      sub_1000376E8(7, v6);
      v9 = *(uint64_t **)(a2 + 8 * i);
      a1 = (uint64_t)sub_100036720(v9);
      if (a1)
      {
        v10 = (uint64_t *)a1;
        v11 = a1;
        while (1)
        {
          v12 = *(_QWORD *)(v3 + 120);
          if (v12)
            break;
LABEL_23:
          v11 = *(_QWORD *)(v11 + 40);
          if (!v11)
          {
            sub_100036158(v10);
            goto LABEL_54;
          }
        }
        while (1)
        {
          if (dword_10008BA20)
          {
            v13 = ne_log_obj(a1);
            if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
              sub_100056E28(&v40, v41);
          }
          sub_100036C54(7, v11);
          if (dword_10008BA20)
          {
            v15 = ne_log_obj(v14);
            if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
              sub_100056DFC(&v38, v39);
          }
          sub_100036C54(7, v12);
          a1 = sub_100035514(*(_QWORD *)(v3 + 256), v11, v12, *(unsigned __int8 *)(v3 + 60));
          if (a1)
            break;
          if (dword_10008BA20)
          {
            v16 = ne_log_obj(0);
            a1 = os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
            if ((_DWORD)a1)
              sub_100056D78(&v36, v37);
          }
          v12 = *(_QWORD *)(v12 + 40);
          if (!v12)
            goto LABEL_23;
        }
        v17 = a1;
        sub_100036158(v10);
        if (dword_10008BA20)
        {
          v18 = ne_log_obj(a1);
          a1 = os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG);
          if ((_DWORD)a1)
            sub_100056DD0(&v34, v35);
        }
        *(_QWORD *)(v3 + 128) = v17;
        if (v9)
        {
          v19 = 0;
          while (1)
          {
            v20 = *(_QWORD *)(v17 + 32);
            if (!v20)
              break;
            while (*(_DWORD *)v20 != *(unsigned __int8 *)(*v9 + 5))
            {
              v20 = *(_QWORD *)(v20 + 72);
              if (!v20)
                goto LABEL_54;
            }
            v21 = *(int **)(v20 + 64);
            if (*((_QWORD *)v21 + 2))
              break;
            v22 = *v21;
            v23 = v9;
            while (v22 != *(unsigned __int8 *)(v23[1] + 4))
            {
              v23 = (uint64_t *)v23[3];
              if (!v23)
                goto LABEL_54;
            }
            a1 = (uint64_t)malloc_type_calloc(1uLL, 0x20uLL, 0x20040DC1BFBCFuLL);
            if (!a1)
            {
              if (dword_10008BA20)
              {
                v29 = ne_log_obj(0);
                a1 = os_log_type_enabled(v29, OS_LOG_TYPE_ERROR);
                if ((_DWORD)a1)
                  sub_100056DA4(&v32, v33);
              }
              break;
            }
            v24 = *(_OWORD *)v23;
            *(_OWORD *)a1 = *(_OWORD *)v23;
            v25 = (_QWORD *)v19;
            do
            {
              if (!v25)
              {
                v19 = a1;
                goto LABEL_48;
              }
              v26 = v25;
              v25 = (_QWORD *)v25[2];
            }
            while (v25);
            v27 = v26 + 2;
            if (*v26 == (_QWORD)v24)
            {
              do
              {
                v28 = v26;
                v26 = (_QWORD *)v26[3];
              }
              while (v26);
              v27 = v28 + 3;
            }
            *v27 = a1;
LABEL_48:
            v9 = (uint64_t *)v9[2];
            if (!v9)
            {
              if (!v19)
                break;
              return v19;
            }
          }
        }
      }
    }
LABEL_54:
    ;
  }
  if (dword_10008BA20)
  {
    v30 = ne_log_obj(a1);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      sub_100056D4C();
  }
  return 0;
}

_QWORD *sub_10000CFCC(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;
  signed int v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  int8x8_t *v8;
  int8x8_t *v9;
  int8x8_t *v10;
  const void *v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  size_t v15;
  int8x8_t *v16;
  NSObject *v17;

  v3 = a1;
  v4 = 8 * (*(_BYTE *)(a2 + 80) == 16);
  if (a1)
  {
    v5 = a1;
    do
    {
      v4 += *(unsigned __int8 *)(*v5 + 6) + (bswap32(*(unsigned __int16 *)(v5[1] + 2)) >> 16) + 8;
      v5 = (_QWORD *)v5[2];
    }
    while (v5);
  }
  v6 = sub_10003F1F8(v4);
  v7 = v6;
  if (v6)
  {
    v8 = (int8x8_t *)v6[1];
    v8->i16[1] = bswap32(v4) >> 16;
    if (*(_BYTE *)(a2 + 80) == 16)
      *v8++ = vrev32_s8(*(int8x8_t *)(*(_QWORD *)(a2 + 64) + 24));
    if (v3)
    {
      v9 = 0;
      do
      {
        v10 = v8;
        v11 = (const void *)*v3;
        v12 = *(unsigned __int8 *)(*v3 + 6);
        v13 = *(unsigned __int16 *)(v3[1] + 2);
        if (v9)
        {
          v9->i8[0] = 2;
          v11 = (const void *)*v3;
        }
        v14 = v12 + 8;
        v15 = __rev16(v13);
        memcpy(v10, v11, v12 + 8);
        v10->i8[0] = 0;
        v10->i16[1] = bswap32(v15 + v14) >> 16;
        v10->i8[7] = 1;
        bzero(&v10[1], *(unsigned __int8 *)(*v3 + 6));
        v16 = (int8x8_t *)((char *)v10 + v14);
        memcpy(v16, (const void *)v3[1], v15);
        v16->i8[0] = 0;
        v16->i16[1] = v13;
        v8 = (int8x8_t *)((char *)v16 + v15);
        v9 = v10;
        v3 = (_QWORD *)v3[2];
      }
      while (v3);
    }
  }
  else if (dword_10008BA20)
  {
    v17 = ne_log_obj(0);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      sub_100056E84();
  }
  return v7;
}

uint64_t sub_10000D148(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;
  _QWORD *v5;
  uint64_t v6;
  int v7;
  int v8;
  NSObject *v9;
  NSObject *v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  NSObject *v15;
  unsigned __int8 **v16;
  NSObject *v17;
  NSObject *v18;
  _QWORD *v19;
  _QWORD *v21;
  _QWORD *v22;
  unsigned __int8 *v23;
  uint64_t v24;
  NSObject *v26;
  int v27;
  int v28;
  NSObject *v30;
  int v31;
  NSObject *v32;
  NSObject *v33;
  NSObject *v34;
  NSObject *v35;
  _BOOL8 v36;
  NSObject *v37;
  NSObject *v38;
  NSObject *v39;
  _QWORD *v40;
  _QWORD *v41;
  _QWORD *v42;
  _QWORD *v43;
  uint8_t buf[4];
  int v45;
  __int16 v46;
  int v47;

  v2 = sub_10000AE28(*(unint64_t **)(a1 + 224), 1u);
  if (!v2)
  {
    if (dword_10008BA20)
    {
      v10 = ne_log_obj(0);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_100056EB0();
    }
    return 0xFFFFFFFFLL;
  }
  v3 = v2;
  v4 = sub_10000AE28(*(unint64_t **)(a1 + 232), 1u);
  if (!v4)
  {
    if (dword_10008BA20)
    {
      v11 = ne_log_obj(0);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        sub_100056EB0();
    }
    sub_10000B6A4(v3);
    return 0xFFFFFFFFLL;
  }
  v5 = v4;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  do
  {
    if (*((_QWORD *)v4 + v6))
    {
      v8 = v6;
      ++v7;
    }
    ++v6;
  }
  while (v6 != 256);
  if (v7 == 1)
  {
    v13 = v8;
    if (v3[v8])
      v14 = 1;
    else
      v14 = dword_10008BA20 == 0;
    if (!v14)
    {
      v15 = ne_log_obj(v4);
      v4 = (void *)os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
      if ((_DWORD)v4)
      {
        *(_DWORD *)buf = 67109120;
        v45 = 256;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "invalid proposal number:%d received.\n", buf, 8u);
      }
    }
    v16 = (unsigned __int8 **)v5[v13];
    if (v16[3])
    {
      if (dword_10008BA20)
      {
        v17 = ne_log_obj(v4);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          sub_100057034();
      }
    }
    else
    {
      v21 = (_QWORD *)v3[v13];
      if (v21)
      {
        while (2)
        {
          v22 = v21;
          while (v16[1][4] != *(unsigned __int8 *)(v22[1] + 4))
          {
            v22 = (_QWORD *)v22[3];
            if (!v22)
            {
              if (!dword_10008BA20)
                goto LABEL_33;
              v37 = ne_log_obj(v4);
              v36 = os_log_type_enabled(v37, OS_LOG_TYPE_ERROR);
              if (v36)
                sub_100057008();
              goto LABEL_76;
            }
          }
          v23 = *v16;
          v24 = *v22;
          if ((*v16)[4] != *(unsigned __int8 *)(*v22 + 4) && dword_10008BA20 != 0)
          {
            v26 = ne_log_obj(v4);
            v4 = (void *)os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT);
            v23 = *v16;
            v24 = *v22;
            if ((_DWORD)v4)
            {
              v27 = *(unsigned __int8 *)(v24 + 4);
              v28 = v23[4];
              *(_DWORD *)buf = 67109376;
              v45 = v27;
              v46 = 1024;
              v47 = v28;
              _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "proposal #%d mismatched, expected #%d.\n", buf, 0xEu);
              v23 = *v16;
              v24 = *v22;
            }
          }
          if (v23[5] == *(unsigned __int8 *)(v24 + 5))
          {
            if (v23[7] != 1 && dword_10008BA20 != 0)
            {
              v30 = ne_log_obj(v4);
              v4 = (void *)os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT);
              if ((_DWORD)v4)
              {
                v31 = (*v16)[7];
                *(_DWORD *)buf = 67109120;
                v45 = v31;
                _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "#of transform is %d, but expected 1.\n", buf, 8u);
              }
            }
            if (v16[1][5] != *(unsigned __int8 *)(v22[1] + 5))
            {
              if (dword_10008BA20)
              {
                v32 = ne_log_obj(v4);
                v4 = (void *)os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT);
                if ((_DWORD)v4)
                {
                  *(_WORD *)buf = 0;
                  _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "transform number has been modified.\n", buf, 2u);
                }
              }
            }
            if (*((unsigned __int16 *)v16[1] + 3) != *(unsigned __int16 *)(v22[1] + 6))
            {
              if (dword_10008BA20)
              {
                v33 = ne_log_obj(v4);
                if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)buf = 0;
                  _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "reserved field should be zero.\n", buf, 2u);
                }
              }
            }
            v4 = (void *)memcmp(v16[1] + 8, (const void *)(v22[1] + 8), (bswap32(*(unsigned __int16 *)(v22[1] + 2)) >> 16) - 8);
            if ((_DWORD)v4)
            {
              if (dword_10008BA20)
              {
                v34 = ne_log_obj(v4);
                v4 = (void *)os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT);
                if ((_DWORD)v4)
                {
                  *(_WORD *)buf = 0;
                  _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "attribute has been modified.\n", buf, 2u);
                }
              }
            }
            v16 = (unsigned __int8 **)v16[2];
            v21 = (_QWORD *)v21[2];
            if (v16 && v21)
              continue;
            if ((v16 != 0) != (v21 != 0))
              goto LABEL_70;
            v40 = (_QWORD *)sub_10000CBE4(a1, (uint64_t)v5);
            if (v40)
            {
              v41 = v40;
              v19 = *(_QWORD **)(a1 + 232);
              *(_QWORD *)(a1 + 232) = sub_10000CFCC(v40, *(_QWORD *)(a1 + 256));
              do
              {
                v42 = v41;
                v41 = (_QWORD *)v41[2];
                do
                {
                  v43 = (_QWORD *)v42[3];
                  free(v42);
                  v42 = v43;
                }
                while (v43);
              }
              while (v41);
              if (*(_QWORD *)(a1 + 232))
                v12 = 0;
              else
                v12 = 0xFFFFFFFFLL;
              goto LABEL_34;
            }
            goto LABEL_33;
          }
          break;
        }
        if (!dword_10008BA20)
          goto LABEL_33;
        v39 = ne_log_obj(v4);
        v36 = os_log_type_enabled(v39, OS_LOG_TYPE_ERROR);
        if (v36)
          sub_100056F8C();
      }
      else
      {
LABEL_70:
        if (!dword_10008BA20)
          goto LABEL_33;
        v35 = ne_log_obj(v4);
        v36 = os_log_type_enabled(v35, OS_LOG_TYPE_ERROR);
        if (v36)
          sub_100056F60();
      }
LABEL_76:
      if (dword_10008BA20)
      {
        v38 = ne_log_obj(v36);
        if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
          sub_100056F34();
      }
    }
  }
  else if (v7)
  {
    if (dword_10008BA20)
    {
      v18 = ne_log_obj(v4);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        sub_100056EDC();
    }
  }
  else if (dword_10008BA20)
  {
    v9 = ne_log_obj(v4);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      sub_100056F08();
  }
LABEL_33:
  v19 = 0;
  v12 = 0xFFFFFFFFLL;
LABEL_34:
  sub_10000B6A4(v5);
  sub_10000B6A4(v3);
  if (v19)
    sub_10003F318(v19);
  return v12;
}

uint64_t sub_10000D720(uint64_t a1, int a2)
{
  uint64_t result;
  NSObject *v3;
  _BOOL4 v4;
  NSObject *v5;
  NSObject *v6;
  uint8_t v7[16];

  if ((a1 - 2) < 2)
  {
    if (a2 == 4)
      return 0;
    if (dword_10008BA20)
    {
      v6 = ne_log_obj(a1);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        sub_100057060();
    }
    return 0xFFFFFFFFLL;
  }
  if ((_DWORD)a1 == 4)
  {
    result = 0;
    if (a2 == 2 || a2 == 4)
      return result;
    if (dword_10008BA20)
    {
      v5 = ne_log_obj(0);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_1000570C0();
    }
    return 0xFFFFFFFFLL;
  }
  if ((_DWORD)a1 != 1)
    return 0xFFFFFFFFLL;
  result = 0;
  if (a2)
  {
    if (dword_10008BA20)
    {
      v3 = ne_log_obj(0);
      v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
      result = 0;
      if (v4)
      {
        *(_WORD *)v7 = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "SPI size isn't zero, but IKE proposal.\n", v7, 2u);
        return 0;
      }
    }
  }
  return result;
}

uint64_t sub_10000D850(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v8;
  uint64_t v9;

  v2 = sub_10000AE28(*(unint64_t **)(a1 + 232), 1u);
  if (!v2)
    return 0xFFFFFFFFLL;
  v3 = v2;
  v4 = 0;
  while (!v2[v4])
  {
    if (++v4 == 256)
      goto LABEL_8;
  }
  v6 = (_QWORD *)v2[v4];
  if (!v6[3])
  {
    v8 = *(_QWORD *)(a1 + 128);
    while (1)
    {
      v9 = *(_QWORD *)(v8 + 32);
      if (!v9)
        break;
      while (*(_DWORD *)v9 != *(unsigned __int8 *)(*v6 + 5)
           || *(_DWORD *)(*(_QWORD *)(v9 + 64) + 4) != *(unsigned __int8 *)(v6[1] + 5))
      {
        v9 = *(_QWORD *)(v9 + 72);
        if (!v9)
          goto LABEL_8;
      }
      memcpy((void *)(*v6 + 8), (const void *)(v9 - *(_QWORD *)(v9 + 8) + 28), *(_QWORD *)(v9 + 8));
      v5 = 0;
      v6 = (_QWORD *)v6[2];
      if (!v6)
        goto LABEL_9;
    }
  }
LABEL_8:
  v5 = 0xFFFFFFFFLL;
LABEL_9:
  sub_10000B6A4(v3);
  return v5;
}

_QWORD *sub_10000D930(int *a1, unint64_t *a2)
{
  void *v3;
  void *v4;
  const void **v5;
  signed int v6;
  int *v7;
  uint64_t i;
  uint64_t j;
  unsigned __int8 *v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  _BYTE *v14;
  _BYTE *v15;
  uint64_t v16;
  uint64_t v17;
  _BYTE *v18;
  unsigned __int8 *v19;
  unsigned int v20;
  size_t v21;
  _BYTE *v22;
  NSObject *v23;
  uint64_t __n;

  v3 = sub_10000AE28(a2, 1u);
  if (v3)
  {
    v4 = v3;
    v5 = 0;
    v6 = 8;
    if (a1)
    {
      v7 = a1;
      while (*((_QWORD *)v3 + *v7))
      {
        for (i = *((_QWORD *)v7 + 4); i; i = *(_QWORD *)(i + 72))
        {
          v6 += *(_DWORD *)(i + 8) + 8;
          for (j = *(_QWORD *)(i + 64); j; j = *(_QWORD *)(j + 16))
          {
            v5 = (const void **)*((_QWORD *)v3 + *v7);
            while (1)
            {
              v10 = (unsigned __int8 *)v5[1];
              if (*(_DWORD *)j == v10[4])
                break;
              v5 = (const void **)v5[3];
              if (!v5)
                goto LABEL_39;
            }
            v6 += bswap32(*((unsigned __int16 *)v10 + 1)) >> 16;
          }
        }
        v7 = (int *)*((_QWORD *)v7 + 5);
        if (!v7)
          goto LABEL_14;
      }
      goto LABEL_39;
    }
LABEL_14:
    v11 = sub_10003F1F8(v6);
    if (!v11)
    {
      if (dword_10008BA20)
      {
        v23 = ne_log_obj(0);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          sub_100057120();
      }
LABEL_39:
      v12 = 0;
      goto LABEL_40;
    }
    v12 = v11;
    v13 = v11[1];
    *(_WORD *)(v13 + 2) = bswap32(v6) >> 16;
    if (!a1)
    {
LABEL_40:
      free(v4);
      return v12;
    }
    v14 = 0;
    v15 = (_BYTE *)(v13 + 8);
    while (1)
    {
      v16 = *((_QWORD *)a1 + 4);
      if (v16)
        break;
      v18 = v14;
LABEL_32:
      a1 = (int *)*((_QWORD *)a1 + 5);
      v14 = v18;
      if (!a1)
        goto LABEL_40;
    }
    while (1)
    {
      v17 = *(_QWORD *)(v16 + 64);
      if (v17)
        break;
      v18 = v14;
LABEL_29:
      v16 = *(_QWORD *)(v16 + 72);
      v14 = v18;
      if (!v16)
        goto LABEL_32;
    }
    __n = *((unsigned __int8 *)*v5 + 6) + 8;
    while (1)
    {
      v18 = v15;
      v5 = (const void **)*((_QWORD *)v4 + *a1);
      if (!v5)
        break;
      while (1)
      {
        v19 = (unsigned __int8 *)v5[1];
        if (*(_DWORD *)v17 == v19[4])
          break;
        v5 = (const void **)v5[3];
        if (!v5)
          goto LABEL_34;
      }
      v20 = *((unsigned __int16 *)v19 + 1);
      if (v14)
        *v14 = 2;
      v21 = __rev16(v20);
      memcpy(v15, *v5, __n);
      *v18 = 0;
      *((_WORD *)v18 + 1) = bswap32(v21 + __n) >> 16;
      v18[7] = 1;
      v22 = &v18[__n];
      memcpy(&v18[__n], v5[1], v21);
      *v22 = 0;
      *((_WORD *)v22 + 1) = v20;
      v15 = &v18[__n + v21];
      v14 = v18;
      v17 = *(_QWORD *)(v17 + 16);
      if (!v17)
        goto LABEL_29;
    }
LABEL_34:
    free(v4);
    sub_10003F318(v12);
  }
  return 0;
}

uint64_t sub_10000DB78(uint64_t a1)
{
  unsigned int v1;
  int v2;
  unsigned __int16 *v3;
  int v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  uint64_t v8;
  NSObject *v9;
  BOOL v11;
  char *v12;
  NSObject *v13;
  NSObject *v15;
  NSObject *v16;
  NSObject *v17;
  NSObject *v18;
  NSObject *v19;
  uint64_t v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  NSObject *v29;
  NSObject *v30;
  NSObject *v31;
  NSObject *v32;
  NSObject *v33;
  NSObject *v34;
  NSObject *v35;
  char *v36;
  uint8_t buf[4];
  char *v38;
  __int16 v39;
  int v40;
  __int16 v41;
  char *v42;

  v1 = bswap32(*(unsigned __int16 *)(a1 + 2)) >> 16;
  if (v1 < 9)
    return 0;
  v2 = v1 - 8;
  v3 = (unsigned __int16 *)(a1 + 8);
  while (2)
  {
    if (v2 <= 3)
    {
      if (dword_10008BA20)
      {
        v15 = ne_log_obj(a1);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          sub_10005714C();
      }
      return 0xFFFFFFFFLL;
    }
    v4 = *v3;
    v5 = bswap32(v4 & 0xFFFFFF7F) >> 16;
    v6 = (v4 << 8) & 0x8000;
    v7 = v3[1];
    v8 = __rev16(v7);
    if (dword_10008BA20)
    {
      v9 = ne_log_obj(a1);
      a1 = os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)a1)
      {
        v36 = sub_10003E290(v5);
        v12 = sub_10003E5D0(v5, v8);
        *(_DWORD *)buf = 136315650;
        v38 = v36;
        v39 = 1024;
        v40 = v6;
        v41 = 2080;
        v42 = v12;
        _os_log_debug_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "type=%s, flag=0x%04x, lorv=%s\n", buf, 0x1Cu);
      }
    }
    if (v5 > 0xF || ((1 << v5) & 0xE83E) == 0)
    {
      v11 = v6 == 0;
      if (!(v6 | v7))
      {
        if (dword_10008BA20)
        {
          v19 = ne_log_obj(a1);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
            sub_1000571B0(v5, v19, v20);
        }
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      if (!v6)
      {
        if (dword_10008BA20)
        {
          v16 = ne_log_obj(a1);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
            sub_100057668();
        }
        return 0xFFFFFFFFLL;
      }
      v11 = 0;
    }
    switch(v5)
    {
      case 1u:
        a1 = sub_100004174(v8);
        if ((_DWORD)a1)
          goto LABEL_14;
        if (dword_10008BA20)
        {
          v30 = ne_log_obj(a1);
          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
            sub_100057284();
        }
        return 0xFFFFFFFFLL;
      case 2u:
        a1 = sub_100003F28(v8);
        if ((_DWORD)a1)
          goto LABEL_14;
        if (dword_10008BA20)
        {
          v31 = ne_log_obj(a1);
          if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
            sub_100057348();
        }
        return 0xFFFFFFFFLL;
      case 3u:
        if ((int)v8 > 65000)
        {
          if ((v8 - 65001) > 9)
            goto LABEL_84;
          if (((1 << (v8 + 23)) & 0x13) == 0)
            goto LABEL_43;
          goto LABEL_14;
        }
        if (v8 <= 5)
        {
          if (((1 << v8) & 0xA) != 0)
            goto LABEL_14;
          if (((1 << v8) & 0x34) != 0)
            goto LABEL_43;
        }
        if ((_DWORD)v8 == 64221)
        {
LABEL_14:
          v2 -= 4;
          if (v11)
          {
            v2 -= v8;
            if (v2 < 0)
            {
              if (dword_10008BA20)
              {
                v17 = ne_log_obj(a1);
                if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
                  sub_1000572E4();
              }
              return 0xFFFFFFFFLL;
            }
            v3 = (unsigned __int16 *)((char *)v3 + v8 + 4);
          }
          else
          {
            v3 += 2;
          }
          if (v2 <= 0)
            return 0;
          continue;
        }
        if ((v8 - 64222) >= 3)
        {
LABEL_84:
          if (dword_10008BA20)
          {
            v35 = ne_log_obj(a1);
            if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
              sub_1000573A8();
          }
        }
        else
        {
LABEL_43:
          if (dword_10008BA20)
          {
            v13 = ne_log_obj(a1);
            if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
              sub_100057408(v8, v13);
          }
        }
        return 0xFFFFFFFFLL;
      case 4u:
        a1 = sub_100004564(v8);
        if ((_DWORD)a1)
          goto LABEL_14;
        if (dword_10008BA20)
        {
          v32 = ne_log_obj(a1);
          if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
            sub_10005747C();
        }
        return 0xFFFFFFFFLL;
      case 5u:
        if (v7 == 256)
          goto LABEL_14;
        if (dword_10008BA20)
        {
          v33 = ne_log_obj(a1);
          if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
            sub_1000574DC();
        }
        return 0xFFFFFFFFLL;
      case 6u:
      case 7u:
      case 0xCu:
      case 0xDu:
      case 0xEu:
      case 0x10u:
        goto LABEL_14;
      case 8u:
      case 9u:
      case 0xAu:
        if (dword_10008BA20)
        {
          v18 = ne_log_obj(a1);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
            sub_10005753C();
        }
        return 0xFFFFFFFFLL;
      case 0xBu:
        if ((unsigned __int16)(v8 - 1) < 2u)
          goto LABEL_14;
        if (dword_10008BA20)
        {
          v34 = ne_log_obj(a1);
          if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
            sub_10005759C();
        }
        return 0xFFFFFFFFLL;
      case 0xFu:
        if (dword_10008BA20)
        {
          v21 = ne_log_obj(a1);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
            sub_1000575FC(v21, v22, v23, v24, v25, v26, v27, v28);
        }
        return 0xFFFFFFFFLL;
      default:
        if (v5 == 0x4000)
          goto LABEL_14;
        if (dword_10008BA20)
        {
          v29 = ne_log_obj(a1);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
            sub_100057224();
        }
        return 0xFFFFFFFFLL;
    }
  }
}

uint64_t sub_10000E088(_BOOL8 a1, uint64_t a2)
{
  int v3;
  unsigned int v4;
  int v5;
  unsigned __int16 *v6;
  int v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;
  char *v15;
  char *v16;
  NSObject *v17;
  NSObject *v18;
  NSObject *v20;
  BOOL v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  NSObject *v25;
  NSObject *v26;
  NSObject *v27;
  NSObject *v28;
  NSObject *v29;
  NSObject *v30;
  NSObject *v31;
  NSObject *v32;
  NSObject *v33;
  NSObject *v34;
  NSObject *v35;
  NSObject *v36;
  int v37;
  unsigned __int8 *v38;
  char v39;
  _BYTE v40[15];
  char v41;
  _BYTE v42[15];
  uint8_t buf[4];
  char *v44;
  __int16 v45;
  int v46;
  __int16 v47;
  char *v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;

  v3 = a1;
  v4 = bswap32(*(unsigned __int16 *)(a2 + 2)) >> 16;
  v49 = 0u;
  v50 = 0u;
  v51 = 0u;
  v52 = 0u;
  if (v4 < 9)
  {
    v21 = 0;
    goto LABEL_54;
  }
  v5 = v4 - 8;
  v6 = (unsigned __int16 *)(a2 + 8);
  v38 = (unsigned __int8 *)(a2 + 5);
  while (2)
  {
    if (v5 <= 3)
    {
      if (dword_10008BA20)
      {
        v20 = ne_log_obj(a1);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          sub_1000576C8();
      }
      return 0xFFFFFFFFLL;
    }
    v7 = *v6;
    v8 = bswap32(v7 & 0xFFFFFF7F) >> 16;
    v9 = (v7 << 8) & 0x8000;
    v10 = v6[1];
    v11 = __rev16(v10);
    if (dword_10008BA20)
    {
      v12 = ne_log_obj(a1);
      a1 = os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG);
      if (a1)
      {
        v37 = v3;
        v15 = sub_10003DFA8(v8);
        v16 = sub_10003E18C(v8, v11);
        *(_DWORD *)buf = 136315650;
        v44 = v15;
        v3 = v37;
        v45 = 1024;
        v46 = v9;
        v47 = 2080;
        v48 = v16;
        _os_log_debug_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "type=%s, flag=0x%04x, lorv=%s\n", buf, 0x1Cu);
      }
    }
    if (v8 <= 0xF)
      ++*((_DWORD *)&v49 + v8);
    switch(v8)
    {
      case 1u:
        if (!v9)
        {
          if (dword_10008BA20)
          {
            v25 = ne_log_obj(a1);
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
              sub_10005799C();
          }
          return 0xFFFFFFFFLL;
        }
        if ((unsigned __int16)(v11 - 1) >= 2u)
        {
          if (dword_10008BA20)
          {
            v30 = ne_log_obj(a1);
            if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
              sub_10005759C();
          }
          return 0xFFFFFFFFLL;
        }
        goto LABEL_33;
      case 2u:
        if (v9)
        {
          if (dword_10008BA20)
          {
            v13 = ne_log_obj(a1);
            a1 = os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG);
            if (a1)
              sub_100057A58(&v39, v40);
          }
          goto LABEL_33;
        }
        if (!v10)
        {
          if (dword_10008BA20)
          {
            v33 = ne_log_obj(a1);
            if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
              sub_1000579C8();
          }
          return 0xFFFFFFFFLL;
        }
        v5 = v5 - v11 - 4;
        if (v5 < 0)
        {
          if (dword_10008BA20)
          {
            v34 = ne_log_obj(a1);
            if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
              sub_1000579F4();
          }
          return 0xFFFFFFFFLL;
        }
        v6 = (unsigned __int16 *)((char *)v6 + v11 + 4);
        goto LABEL_34;
      case 3u:
        if (!v9)
        {
          if (dword_10008BA20)
          {
            v26 = ne_log_obj(a1);
            if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
              sub_100057A84();
          }
          return 0xFFFFFFFFLL;
        }
        a1 = sub_100004564(v11);
        if (!a1)
        {
          if (dword_10008BA20)
          {
            v31 = ne_log_obj(a1);
            if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
              sub_100057AB0();
          }
          return 0xFFFFFFFFLL;
        }
LABEL_33:
        v5 -= 4;
        v6 += 2;
LABEL_34:
        if (v5 > 0)
          continue;
        v21 = DWORD1(v50) != 0;
LABEL_54:
        if (v3 == 2 && !v21)
        {
          if (dword_10008BA20)
          {
            v18 = ne_log_obj(a1);
            if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
              sub_1000577E4();
          }
          return 0xFFFFFFFFLL;
        }
        if (v3 == 3)
        {
          if (*(_BYTE *)(a2 + 5) != 11)
            v21 = 1;
          if (!v21)
          {
            if (dword_10008BA20)
            {
              v22 = ne_log_obj(a1);
              if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
                sub_1000577B8();
            }
            return 0xFFFFFFFFLL;
          }
        }
        return 0;
      case 4u:
        if (!v9)
        {
          if (dword_10008BA20)
          {
            v27 = ne_log_obj(a1);
            if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
              sub_10005772C();
          }
          return 0xFFFFFFFFLL;
        }
        if ((v11 - 1) < 2)
          goto LABEL_33;
        if ((v11 - 61443) >= 2 && (v11 - 3) > 1)
        {
          if (dword_10008BA20)
          {
            v36 = ne_log_obj(a1);
            if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
              sub_100057758();
          }
          return 0xFFFFFFFFLL;
        }
        if (dword_10008BA20)
        {
          v14 = ne_log_obj(a1);
          a1 = os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG);
          if (a1)
            sub_100057810(&v41, v42);
        }
        goto LABEL_33;
      case 5u:
        if (v9)
        {
          switch((int)v11)
          {
            case 1:
              if (v3 != 2 || *v38 == 2)
                goto LABEL_33;
              break;
            case 2:
              if (v3 != 2 || *v38 == 3)
                goto LABEL_33;
              break;
            case 3:
            case 4:
              if (dword_10008BA20)
              {
                v32 = ne_log_obj(a1);
                if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
                  sub_10005793C();
              }
              return 0xFFFFFFFFLL;
            case 5:
              if (v3 != 2 || *v38 == 5)
                goto LABEL_33;
              break;
            case 6:
              if (v3 != 2 || *v38 == 6)
                goto LABEL_33;
              break;
            case 7:
              if (v3 != 2 || *v38 == 7)
                goto LABEL_33;
              break;
            default:
              if (dword_10008BA20)
              {
                v35 = ne_log_obj(a1);
                if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
                  sub_100057868();
              }
              return 0xFFFFFFFFLL;
          }
          if (dword_10008BA20)
          {
            v17 = ne_log_obj(a1);
            if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
              sub_1000578C8(v38, v11, v17);
          }
        }
        else if (dword_10008BA20)
        {
          v28 = ne_log_obj(a1);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
            sub_10005783C();
        }
        return 0xFFFFFFFFLL;
      case 6u:
        if (v9)
          goto LABEL_33;
        if (dword_10008BA20)
        {
          v29 = ne_log_obj(a1);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
            sub_100057B10();
        }
        return 0xFFFFFFFFLL;
      case 7u:
      case 8u:
      case 9u:
        if (dword_10008BA20)
        {
          v23 = ne_log_obj(a1);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
            sub_10005753C();
        }
        return 0xFFFFFFFFLL;
      default:
        if (dword_10008BA20)
        {
          v24 = ne_log_obj(a1);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
            sub_100057224();
        }
        return 0xFFFFFFFFLL;
    }
  }
}

uint64_t sub_10000E730(uint64_t a1)
{
  unsigned int v1;
  int v2;
  unsigned __int16 *v3;
  int v4;
  unsigned int v5;
  int v6;
  unsigned int v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  NSObject *v11;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  NSObject *v24;
  NSObject *v25;
  NSObject *v26;
  NSObject *v27;
  NSObject *v28;
  NSObject *v29;
  NSObject *v30;
  NSObject *v31;
  char v32;
  _BYTE v33[15];
  char v34;
  _BYTE v35[15];
  uint8_t buf[4];
  unsigned int v37;
  __int16 v38;
  int v39;
  __int16 v40;
  int v41;
  _OWORD v42[4];

  v1 = bswap32(*(unsigned __int16 *)(a1 + 2)) >> 16;
  memset(v42, 0, sizeof(v42));
  if (v1 < 9)
    return 0;
  v2 = v1 - 8;
  v3 = (unsigned __int16 *)(a1 + 8);
  while (v2 > 3)
  {
    v4 = *v3;
    v5 = bswap32(v4 & 0xFFFFFF7F) >> 16;
    v6 = (v4 << 8) & 0x8000;
    v7 = v3[1];
    v8 = __rev16(v7);
    if (dword_10008BA20)
    {
      v9 = ne_log_obj(a1);
      a1 = os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)a1)
      {
        *(_DWORD *)buf = 67109632;
        v37 = v5;
        v38 = 1024;
        v39 = v6;
        v40 = 1024;
        v41 = v8;
        _os_log_debug_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "type=%d, flag=0x%04x, lorv=0x%04x\n", buf, 0x14u);
      }
    }
    if (v5 <= 0xF)
      ++*((_DWORD *)v42 + v5);
    switch(v5)
    {
      case 1u:
        if (!v6)
        {
          if (dword_10008BA20)
          {
            v24 = ne_log_obj(a1);
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
              sub_10005799C();
          }
          return 0xFFFFFFFFLL;
        }
        if ((unsigned __int16)(v8 - 1) >= 2u)
        {
          if (dword_10008BA20)
          {
            v27 = ne_log_obj(a1);
            if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
              sub_10005759C();
          }
          return 0xFFFFFFFFLL;
        }
        goto LABEL_27;
      case 2u:
        if (v6)
        {
          if (dword_10008BA20)
          {
            v10 = ne_log_obj(a1);
            a1 = os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG);
            if ((_DWORD)a1)
              sub_100057A58(&v32, v33);
          }
          goto LABEL_27;
        }
        if (!v7)
        {
          if (dword_10008BA20)
          {
            v29 = ne_log_obj(a1);
            if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
              sub_1000579C8();
          }
          return 0xFFFFFFFFLL;
        }
        v2 = v2 - v8 - 4;
        if (v2 < 0)
        {
          if (dword_10008BA20)
          {
            v30 = ne_log_obj(a1);
            if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
              sub_100057BA0();
          }
          return 0xFFFFFFFFLL;
        }
        v3 = (unsigned __int16 *)((char *)v3 + v8 + 4);
        goto LABEL_28;
      case 3u:
        if (!v6)
        {
          if (dword_10008BA20)
          {
            v25 = ne_log_obj(a1);
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
              sub_100057A84();
          }
          return 0xFFFFFFFFLL;
        }
        a1 = sub_100004564(v8);
        if (!(_DWORD)a1)
        {
          if (dword_10008BA20)
          {
            v28 = ne_log_obj(a1);
            if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
              sub_100057AB0();
          }
          return 0xFFFFFFFFLL;
        }
        goto LABEL_27;
      case 4u:
        if (!v6)
        {
          if (dword_10008BA20)
          {
            v26 = ne_log_obj(a1);
            if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
              sub_10005772C();
          }
          return 0xFFFFFFFFLL;
        }
        if ((v8 - 1) >= 2)
        {
          if ((v8 - 61443) >= 2 && (v8 - 3) > 1)
          {
            if (dword_10008BA20)
            {
              v31 = ne_log_obj(a1);
              if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
                sub_100057758();
            }
            return 0xFFFFFFFFLL;
          }
          if (dword_10008BA20)
          {
            v11 = ne_log_obj(a1);
            a1 = os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG);
            if ((_DWORD)a1)
              sub_100057810(&v34, v35);
          }
        }
LABEL_27:
        v2 -= 4;
        v3 += 2;
LABEL_28:
        if (v2 <= 0)
          return 0;
        break;
      case 5u:
        if (dword_10008BA20)
        {
          v16 = ne_log_obj(a1);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
            sub_100057C04(v16, v17, v18, v19, v20, v21, v22, v23);
        }
        return 0xFFFFFFFFLL;
      case 6u:
      case 7u:
      case 8u:
      case 9u:
        if (dword_10008BA20)
        {
          v14 = ne_log_obj(a1);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
            sub_10005753C();
        }
        return 0xFFFFFFFFLL;
      default:
        if (dword_10008BA20)
        {
          v15 = ne_log_obj(a1);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
            sub_100057224();
        }
        return 0xFFFFFFFFLL;
    }
  }
  if (dword_10008BA20)
  {
    v13 = ne_log_obj(a1);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      sub_100057B3C();
  }
  return 0xFFFFFFFFLL;
}

_QWORD *sub_10000EBAC(uint64_t a1)
{
  uint64_t v2;
  int v3;
  int v4;
  _QWORD *v5;
  _QWORD *v6;
  int8x8_t *v7;
  NSObject *v8;

  if (!a1)
    return 0;
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 248);
  v3 = *(unsigned __int8 *)(a1 + 80);
  v4 = sub_10000EC64(a1, 0);
  v5 = sub_10003F1F8(v4 + 8 * (v3 == 16));
  if (!v5)
  {
    if (dword_10008BA20)
    {
      v8 = ne_log_obj(0);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_100057C70();
    }
    return 0;
  }
  v6 = v5;
  if (v3 == 16)
  {
    v7 = (int8x8_t *)v5[1];
    *v7 = vrev32_s8(*(int8x8_t *)(*(_QWORD *)(v2 + 88) + 24));
    sub_10000EC64(a1, (uint64_t)&v7[1]);
  }
  return v6;
}

uint64_t sub_10000EC64(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  char v5;
  _BYTE *v6;
  uint64_t v7;
  _WORD *v8;
  uint64_t v9;
  int v10;
  _WORD *v11;
  uint64_t v12;
  uint64_t v13;
  _WORD *v14;
  unint64_t v15;
  int v16;
  _WORD *v17;
  unint64_t v18;
  uint64_t v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  _WORD *v26;
  int v27;
  uint64_t v28;
  char v30;
  unsigned int v31;
  unsigned int __src;

  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 248);
  if (a2)
  {
    *(_WORD *)a2 = 0;
    *(_BYTE *)(a2 + 4) = *(_DWORD *)(v3 + 4);
    *(_WORD *)(a2 + 5) = 1;
    v4 = a2 + 8;
  }
  else
  {
    if (!v3)
      return 8;
    v4 = 0;
  }
  v5 = 0;
  v6 = 0;
  v30 = a2 != 0;
  LODWORD(v7) = 8;
  do
  {
    if (v6)
      *v6 = 3;
    if (v4)
    {
      *(_BYTE *)v4 = 0;
      *(_BYTE *)(v4 + 4) = *(_DWORD *)(v3 + 8);
      *(_BYTE *)(v4 + 5) = 1;
      v8 = (_WORD *)(v4 + 8);
    }
    else
    {
      v8 = 0;
    }
    v9 = *(_QWORD *)(v3 + 16);
    if (v9)
    {
      __src = bswap32(v9);
      if (v9 < 0x10000)
        v10 = 8;
      else
        v10 = 12;
      if (v8)
      {
        v11 = sub_100025FE8(v8, 11, 1u);
        v12 = *(_QWORD *)(v3 + 16);
        if (v12 < 0x10000)
          v13 = (uint64_t)sub_100025FE8(v11, 12, v12);
        else
          v13 = sub_100025F98(v11, 0xCu, &__src, 4);
        v14 = (_WORD *)v13;
      }
      else
      {
        v14 = 0;
      }
    }
    else
    {
      v10 = 0;
      v14 = v8;
    }
    v15 = *(_QWORD *)(v3 + 32);
    if (v15)
    {
      v31 = bswap32(v15);
      if (v15 >> 16)
        v16 = 12;
      else
        v16 = 8;
      if (v8)
      {
        v17 = sub_100025FE8(v14, 11, 2u);
        v18 = *(_QWORD *)(v3 + 32);
        if (v18 < 0x10000)
          v19 = (uint64_t)sub_100025FE8(v17, 12, v18);
        else
          v19 = sub_100025F98(v17, 0xCu, &v31, 4);
        v14 = (_WORD *)v19;
      }
      v10 += v16;
    }
    v20 = *(_DWORD *)(v3 + 40);
    if (v20)
    {
      if (!v8)
      {
        if (*(_DWORD *)(v3 + 44))
          v10 += 8;
        else
          v10 += 4;
        goto LABEL_41;
      }
      v14 = sub_100025FE8(v14, 1, v20);
      v10 += 4;
    }
    v21 = *(_DWORD *)(v3 + 44);
    if (v21)
    {
      v10 += 4;
      if (v8)
        v14 = sub_100025FE8(v14, 14, v21);
    }
LABEL_41:
    v22 = *(unsigned int *)(v3 + 48);
    if ((_DWORD)v22)
    {
      if (!v8)
      {
        if (*(_DWORD *)(v3 + 52))
          v10 += 8;
        else
          v10 += 4;
        goto LABEL_50;
      }
      v23 = sub_10000C57C(v22);
      v14 = sub_100025FE8(v14, 3, v23);
      v10 += 4;
    }
    v24 = *(_DWORD *)(v3 + 52);
    if (v24)
    {
      v10 += 4;
      if (v8)
        v14 = sub_100025FE8(v14, 2, v24);
    }
LABEL_50:
    v25 = *(_DWORD *)(v3 + 60);
    if (v25 > 0x12)
      goto LABEL_55;
    if (((1 << v25) & 0x7C026) != 0)
    {
      v10 += 4;
      if (!v8)
        goto LABEL_55;
      v26 = v14;
      v27 = 4;
      goto LABEL_54;
    }
    if (((1 << v25) & 0x18) != 0)
    {
      v10 += 4;
      if (v8)
      {
        v26 = v14;
        v27 = 5;
        v25 = 3;
LABEL_54:
        sub_100025FE8(v26, v27, v25);
      }
    }
LABEL_55:
    v28 = (v10 + 8);
    if (v4)
      *(_WORD *)(v4 + 2) = __rev16(v28);
    v7 = (v28 + v7);
    if (a2)
      v6 = (_BYTE *)v4;
    v5 += v30;
    if (!a2)
      v28 = 0;
    v4 += v28;
    v3 = *(_QWORD *)(v3 + 80);
  }
  while (v3);
  if (a2)
  {
    *(_WORD *)(a2 + 2) = bswap32(v7) >> 16;
    *(_BYTE *)(a2 + 7) = v5;
  }
  return v7;
}

uint64_t sub_10000EF64(_QWORD *a1, int a2)
{
  int v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  void **v6;
  int *v7;
  NSObject *v8;
  void **v9;
  void **v10;
  char *v11;
  int v12;
  const void *v13;
  size_t v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  unsigned int v26;
  int v27;
  _BOOL4 v28;
  uint64_t v29;
  uint64_t v30;
  void **v31;
  char *v32;
  int v33;
  char *v34;
  _WORD *v35;
  uint64_t v36;
  int v37;
  _WORD *v38;
  signed int v39;
  _WORD *v40;
  _WORD *v41;
  unsigned int v42;
  unsigned int v43;
  size_t v44;
  void **v45;
  uint64_t result;
  NSObject *v47;
  NSObject *v48;
  NSObject *v49;
  void **v50;
  NSObject *v51;
  NSObject *v52;
  NSObject *v53;
  int v54;
  int64_t v55;
  void **v56;
  uint8_t buf[8];
  unsigned int v58;
  unsigned int __src;

  v2 = a2;
  v3 = a1;
  v4 = 16;
  if (!a2)
    v4 = 15;
  v5 = a1[v4];
  if (*((_BYTE *)a1 + 61) == 16)
  {
    a1 = sub_10003F1F8(8uLL);
    if (!a1)
    {
      if (dword_10008BA20)
      {
        v47 = ne_log_obj(0);
        if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
          sub_100057C70();
      }
      return 0xFFFFFFFFLL;
    }
    v6 = (void **)a1;
    *(_QWORD *)a1[1] = 0x100000001000000;
    if (!v5)
      goto LABEL_86;
  }
  else
  {
    v6 = 0;
    if (!v5)
    {
LABEL_86:
      result = 0;
      if (v2)
        v3[29] = v6;
      else
        v3[28] = v6;
      return result;
    }
  }
  v55 = 0;
  v54 = v2;
LABEL_9:
  v7 = *(int **)(v5 + 32);
  if (!v7)
    goto LABEL_85;
LABEL_10:
  if (*v7 == 4)
    goto LABEL_84;
  v56 = v6;
  if ((*(_BYTE *)(v3[32] + 96) & 6) == 0)
  {
    if (*((_BYTE *)v3 + 61) != 16)
      goto LABEL_105;
    goto LABEL_18;
  }
  if (dword_10008BA20)
  {
    v8 = ne_log_obj(a1);
    a1 = (_QWORD *)os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
    if ((_DWORD)a1)
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "NAT detected -> UDP encapsulation\n", buf, 2u);
    }
  }
  v7[5] = 1;
  if (*((_BYTE *)v3 + 61) == 16)
  {
    v7[4] += *(unsigned __int16 *)(*(_QWORD *)(v3[32] + 88) + 12);
LABEL_18:
    v9 = (void **)sub_10003F1F8(0xCuLL);
    if (!v9)
      goto LABEL_99;
    v10 = v9;
    v11 = (char *)v9[1];
    *v11 = 0;
    v11[4] = *(_DWORD *)v5;
    v12 = *v7;
    v11[5] = *v7;
    v11[7] = 1;
    if (v12 == 4)
    {
      v13 = (char *)v7 + 26;
      *v9 = (char *)*v9 - 2;
      v14 = 2;
    }
    else
    {
      v13 = v7 + 6;
      v14 = 4;
    }
    v11[6] = v14;
    v15 = memcpy(v11 + 8, v13, v14);
    v16 = *((_QWORD *)v7 + 8);
    if (!v16)
    {
LABEL_102:
      if (dword_10008BA20)
      {
        v51 = ne_log_obj(v15);
        if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
          sub_100057C9C();
      }
      goto LABEL_99;
    }
    v17 = 0;
    v18 = v14 | 8;
    while (*v7 == 3 && *(_DWORD *)(v16 + 4) == 11 && *(_DWORD *)(v16 + 12) == 254)
    {
LABEL_74:
      v16 = *(_QWORD *)(v16 + 16);
      if (!v16)
      {
        if (!v17)
          goto LABEL_102;
        v44 = (size_t)*v10;
        *((_WORD *)v11 + 1) = bswap32(*v10) >> 16;
        if (v56)
          v45 = sub_10003F270(v56, (size_t)*v56 + v44);
        else
          v45 = (void **)sub_10003F1F8(v44);
        v6 = v45;
        v2 = v54;
        if (!v45)
        {
          if (dword_10008BA20)
          {
            v53 = ne_log_obj(0);
            if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
              sub_100057C70();
          }
          v50 = v10;
          goto LABEL_100;
        }
        memcpy((void *)((char *)*v45 + (_QWORD)v45[1] - (char *)*v10), v10[1], (size_t)*v10);
        if (v55 && *((_BYTE *)v3 + 61) == 16)
          *((_BYTE *)v6[1] + v55) = 2;
        v55 = (_BYTE *)*v6 - (_BYTE *)*v10;
        sub_10003F318(v10);
LABEL_84:
        v7 = (int *)*((_QWORD *)v7 + 9);
        if (!v7)
        {
LABEL_85:
          v5 = *(_QWORD *)(v5 + 40);
          if (!v5)
            goto LABEL_86;
          goto LABEL_9;
        }
        goto LABEL_10;
      }
    }
    if (v17)
    {
      *(_BYTE *)v17 = 3;
      ++v11[7];
    }
    v19 = *(_QWORD *)(v5 + 8);
    if (v19 < 0x10000)
      v20 = 8;
    else
      v20 = 12;
    if (v19)
      v21 = v20;
    else
      v21 = 0;
    v22 = *(_DWORD *)(v5 + 16);
    if (v22)
    {
      v23 = v22 < 0x10000 ? 8 : 12;
      v24 = v21 + v23;
      if (v22 != 0x7FFFFFFF)
        v21 = v24;
    }
    if (*(_DWORD *)(v16 + 8))
      v25 = 8;
    else
      v25 = 4;
    v26 = v25 + v21;
    v27 = *v7;
    if (*v7 == 2)
    {
      if (*(_DWORD *)(v16 + 12) == 254)
      {
        if (dword_10008BA20)
        {
          v49 = ne_log_obj(v15);
          if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
            sub_100057D2C();
        }
        goto LABEL_98;
      }
      v26 += 4;
    }
    else if (v27 != 4)
    {
      if (v27 != 3)
      {
        if (dword_10008BA20)
        {
          v48 = ne_log_obj(v15);
          if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
            sub_100057CC8();
        }
LABEL_98:
        sub_10003F318(v10);
        goto LABEL_99;
      }
      if (*(_DWORD *)(v16 + 12) != 254)
        v26 += 4;
    }
    v28 = sub_100004564(*(unsigned int *)(v3[14] + 36));
    LODWORD(v29) = v26 + 4;
    if (v28)
      v29 = v29;
    else
      v29 = v26;
    v30 = v29 + 8;
    v31 = sub_10003F270(v10, (size_t)*v10 + v29 + 8);
    if (!v31)
      goto LABEL_99;
    v10 = v31;
    v11 = (char *)v31[1];
    v32 = &v11[v18];
    *v32 = 0;
    v33 = *(_DWORD *)(v16 + 4);
    v32[4] = *(_DWORD *)v16;
    v32[5] = v33;
    v34 = &v11[v18 + 8];
    if (*(_QWORD *)(v5 + 8))
    {
      v35 = sub_100025FE8(v34, 1, 1u);
      v36 = *(_QWORD *)(v5 + 8);
      if (v36 < 0x10000)
      {
        v34 = (char *)sub_100025FE8(v35, 2, v36);
      }
      else
      {
        __src = bswap32(v36);
        v34 = (char *)sub_100025F98(v35, 2u, &__src, 4);
      }
    }
    v37 = *(_DWORD *)(v5 + 16);
    if (v37 && v37 != 0x7FFFFFFF)
    {
      v38 = sub_100025FE8(v34, 1, 2u);
      v39 = *(_DWORD *)(v5 + 16);
      if (v39 < 0x10000)
      {
        v34 = (char *)sub_100025FE8(v38, 2, v39);
      }
      else
      {
        v58 = bswap32(v39);
        v34 = (char *)sub_100025F98(v38, 2u, &v58, 4);
      }
    }
    v40 = sub_100025FE8(v34, 4, v7[4]);
    v41 = v40;
    v42 = *(_DWORD *)(v16 + 8);
    if (v42)
      v41 = sub_100025FE8(v40, 6, v42);
    if (*v7 == 3)
    {
      v43 = *(_DWORD *)(v16 + 12);
      if (v43 != 254)
        goto LABEL_70;
    }
    else if (*v7 == 2)
    {
      v43 = *(_DWORD *)(v16 + 12);
LABEL_70:
      v41 = sub_100025FE8(v41, 5, v43);
    }
    v15 = (void *)sub_100004564(*(unsigned int *)(v3[14] + 36));
    if ((_DWORD)v15)
      v15 = sub_100025FE8(v41, 3, *(_DWORD *)(v3[14] + 36));
    v17 = (uint64_t)v10[1] + v18;
    *(_WORD *)(v17 + 2) = __rev16(v30);
    v18 += v30;
    goto LABEL_74;
  }
LABEL_105:
  if (dword_10008BA20)
  {
    v52 = ne_log_obj(a1);
    if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
      sub_100057D58();
  }
LABEL_99:
  v50 = v56;
  if (v56)
LABEL_100:
    sub_10003F318(v50);
  return 0xFFFFFFFFLL;
}

uint64_t sub_10000F574(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  BOOL v4;

  v1 = *(_QWORD *)(a1 + 120);
  if (!v1)
    return 1;
  while (1)
  {
    v2 = *(_QWORD *)(v1 + 32);
    if (v2)
      break;
LABEL_12:
    v1 = *(_QWORD *)(v1 + 40);
    if (!v1)
      return 1;
  }
  while (1)
  {
    v3 = *(_DWORD *)(v2 + 16);
    v4 = v3 == 1 || v3 == 61443;
    if (!v4 && v3 != 3)
      return 0;
    v2 = *(_QWORD *)(v2 + 72);
    if (!v2)
      goto LABEL_12;
  }
}

uint64_t sub_10000F5BC(uint64_t result)
{
  uint64_t v1;
  int v2;
  BOOL v3;

  if (result)
  {
    while (1)
    {
      v1 = *(_QWORD *)(result + 32);
      if (v1)
        break;
LABEL_11:
      result = *(_QWORD *)(result + 40);
      if (!result)
        return result;
    }
    while (1)
    {
      v2 = *(_DWORD *)(v1 + 16);
      v3 = v2 == 2 || v2 == 4;
      if (v3 || v2 == 61444)
        return 1;
      v1 = *(_QWORD *)(v1 + 72);
      if (!v1)
        goto LABEL_11;
    }
  }
  return result;
}

uint64_t sub_10000F5FC(uint64_t a1)
{
  uint64_t v1;

  if (!a1)
    return 1;
  while (1)
  {
    v1 = *(_QWORD *)(a1 + 32);
    if (v1)
      break;
LABEL_5:
    a1 = *(_QWORD *)(a1 + 40);
    if (!a1)
      return 1;
  }
  while (*(_DWORD *)(v1 + 16) == 2)
  {
    v1 = *(_QWORD *)(v1 + 72);
    if (!v1)
      goto LABEL_5;
  }
  return 0;
}

uint64_t sub_10000F634()
{
  return 28800;
}

uint64_t sub_10000F63C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  NSObject *v7;
  const char *v8;
  NSObject *v10;
  int v11;
  char *v12;
  __int16 v13;
  char *v14;
  __int16 v15;
  char *v16;

  if ((_DWORD)a1 == 2)
  {
    if (!(_DWORD)a3 || a4 | a2)
    {
      if (!dword_10008BA20)
        return 0xFFFFFFFFLL;
      v7 = ne_log_obj(a1);
      if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        return 0xFFFFFFFFLL;
      v11 = 136315650;
      v12 = sub_10003E74C(0, a2);
      v13 = 2080;
      v14 = sub_10003E74C(1, a3);
      v15 = 2080;
      v16 = sub_10003E74C(2, a4);
      v8 = "illegal algorithm defined AH enc=%s auth=%s comp=%s.\n";
      goto LABEL_25;
    }
    return 0;
  }
  if ((_DWORD)a1 == 4)
  {
    if (a3 | a2 || !(_DWORD)a4)
    {
      if (!dword_10008BA20)
        return 0xFFFFFFFFLL;
      v7 = ne_log_obj(a1);
      if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        return 0xFFFFFFFFLL;
      v11 = 136315650;
      v12 = sub_10003E74C(0, a2);
      v13 = 2080;
      v14 = sub_10003E74C(1, a3);
      v15 = 2080;
      v16 = sub_10003E74C(2, a4);
      v8 = "illegal algorithm defined IPcomp enc=%s auth=%s comp=%s.\n";
      goto LABEL_25;
    }
    return 0;
  }
  if ((_DWORD)a1 != 3)
  {
    if (dword_10008BA20)
    {
      v10 = ne_log_obj(a1);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_100057D84();
    }
    return 0xFFFFFFFFLL;
  }
  if ((_DWORD)a2 && !(_DWORD)a4)
    return 0;
  if (!dword_10008BA20)
    return 0xFFFFFFFFLL;
  v7 = ne_log_obj(a1);
  if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    return 0xFFFFFFFFLL;
  v11 = 136315650;
  v12 = sub_10003E74C(0, a2);
  v13 = 2080;
  v14 = sub_10003E74C(1, a3);
  v15 = 2080;
  v16 = sub_10003E74C(2, a4);
  v8 = "illegal algorithm defined ESP enc=%s auth=%s comp=%s.\n";
LABEL_25:
  _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, v8, (uint8_t *)&v11, 0x20u);
  return 0xFFFFFFFFLL;
}

uint64_t sub_10000F8C4(int a1)
{
  int v1;
  unsigned int v2;

  if (a1 == 50)
    v1 = 3;
  else
    v1 = -1;
  if (a1 == 51)
    v2 = 2;
  else
    v2 = v1;
  if (a1 == 108)
    return 4;
  else
    return v2;
}

uint64_t sub_10000F8F0(int a1)
{
  if ((a1 - 2) > 2)
    return 0xFFFFFFFFLL;
  else
    return dword_100069F5C[a1 - 2];
}

uint64_t sub_10000F914(_QWORD *a1, uint64_t a2)
{
  unsigned int *v2;
  unsigned int v4;
  unsigned int v5;
  BOOL v6;
  _BOOL4 v7;
  int v8;

  if (*(_QWORD *)a2 != 4)
    return 1;
  if (*a1 != 8)
    return 1;
  v2 = (unsigned int *)a1[1];
  if (v2[1] != -1)
    return 1;
  v4 = bswap32(*v2);
  v5 = bswap32(**(_DWORD **)(a2 + 8));
  v6 = v4 >= v5;
  v7 = v4 > v5;
  v8 = !v6;
  return (v7 - v8);
}

uint64_t sub_10000F96C(_QWORD *a1, _QWORD *a2)
{
  unint64_t *v2;
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  unint64_t v6;

  if (*a2 == 16 && *a1 == 32)
  {
    v2 = (unint64_t *)a1[1];
    v3 = 16;
    while (*((unsigned __int8 *)v2 + v3) == 255)
    {
      if (++v3 == 32)
      {
        v4 = (unint64_t *)a2[1];
        v5 = bswap64(*v2);
        v6 = bswap64(*v4);
        if (v5 == v6)
        {
          v5 = bswap64(v2[1]);
          v6 = bswap64(v4[1]);
          if (v5 == v6)
            return 0;
        }
        if (v5 < v6)
          return 0xFFFFFFFFLL;
        return 1;
      }
    }
  }
  return 1;
}

uint64_t sub_10000F9F8(uint64_t a1)
{
  _QWORD *v1;
  _QWORD **v3;
  NSObject *v4;
  NSObject *v5;
  uint64_t result;
  unsigned __int8 *v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v11;
  _BOOL4 v12;
  NSObject *v14;
  int v15;
  unsigned int v16;
  const char *v17;
  unsigned int v18;
  uint64_t v19;
  int v20;
  int v22;
  unsigned int v24;
  uint64_t v25;
  int *v26;
  size_t *v27;
  _QWORD *v28;
  int v29;
  size_t *v30;
  uint64_t v31;
  size_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  NSObject *v37;
  NSObject *v38;
  NSObject *v39;
  __int16 v40[8];
  _BYTE buf[14];

  v1 = *(_QWORD **)(a1 + 320);
  if (!v1)
  {
    if (dword_10008BA20)
    {
      v5 = ne_log_obj(a1);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_100057DE4();
    }
    return 0xFFFFFFFFLL;
  }
  v3 = (_QWORD **)(a1 + 320);
  if (*v1 <= 3uLL)
  {
    if (dword_10008BA20)
    {
      v4 = ne_log_obj(a1);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_100057E10();
    }
    return 18;
  }
  v7 = (unsigned __int8 *)v1[1];
  if (*(_BYTE *)(a1 + 80) == 16
    && *(_BYTE *)(a1 + 81) == 2
    && *(_DWORD *)(*(_QWORD *)(a1 + 72) + 48) == 1
    && (*(_BYTE *)(a1 + 96) & 4) == 0)
  {
    v8 = *v7;
    if ((v8 | 4) != 5)
    {
      if (dword_10008BA20)
      {
        v9 = ne_log_obj(v8);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          sub_100057E78(v7, v9);
      }
      return 18;
    }
  }
  else
  {
    v8 = *v7;
  }
  if (v8 <= 8 && ((1 << v8) & 0x1D0) != 0)
  {
    if (dword_10008BA20)
    {
      v11 = ne_log_obj(v8);
      v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
      v8 = *v7;
      if (v12)
      {
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = sub_10003E21C(v8);
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "such ID type %s is not proper.\n", buf, 0xCu);
        v8 = *v7;
      }
    }
  }
  if ((v8 | 4) == 5)
  {
    if (v7[1] == 17)
    {
      v18 = *((unsigned __int16 *)v7 + 1);
      if (v18 == 62465)
        goto LABEL_48;
      v19 = *(_QWORD *)(a1 + 48);
      v20 = *(unsigned __int8 *)(v19 + 1);
      if (v20 != 30 && v20 != 2)
      {
        if (dword_10008BA20)
        {
          v39 = ne_log_obj(v8);
          if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
            sub_100057F20();
        }
        return 18;
      }
      v22 = *(unsigned __int16 *)(v19 + 2);
      if (__rev16(v18) == v22 || dword_10008BA20 == 0)
        goto LABEL_48;
      v14 = ne_log_obj(v8);
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        goto LABEL_48;
      v24 = bswap32(*((unsigned __int16 *)v7 + 1)) >> 16;
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)&buf[4] = v22;
      *(_WORD *)&buf[8] = 1024;
      *(_DWORD *)&buf[10] = v24;
      v17 = "port %d expected, but %d\n";
      goto LABEL_47;
    }
    if (!v7[1] && *((_WORD *)v7 + 1) && dword_10008BA20 != 0)
    {
      v14 = ne_log_obj(v8);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        v15 = v7[1];
        v16 = bswap32(*((unsigned __int16 *)v7 + 1)) >> 16;
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)&buf[4] = v15;
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = v16;
        v17 = "protocol ID and Port mismatched. proto_id:%d port:%d\n";
LABEL_47:
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v17, buf, 0xEu);
      }
    }
  }
LABEL_48:
  result = sub_100006E1C(*(_QWORD **)(*(_QWORD *)(a1 + 64) + 56), 0);
  if (result)
  {
    *(_QWORD *)buf = 0;
    v25 = sub_100006E1C(*(_QWORD **)(*(_QWORD *)(a1 + 64) + 56), buf);
    if (v25)
    {
      v26 = (int *)v25;
      v27 = 0;
      v28 = v7 + 4;
      do
      {
        v29 = *v26;
        if (v29 == sub_10000FF0C(*v7))
        {
          v30 = (size_t *)*((_QWORD *)v26 + 1);
          if (!v30)
            goto LABEL_84;
          if (!v27
            || (sub_10003F318(v27), (v30 = (size_t *)*((_QWORD *)v26 + 1)) != 0)
            || (v31 = *v26, (v30 = *(size_t **)(qword_10008B848 + 8 * v31 + 176)) != 0))
          {
            v30 = sub_10003F34C((uint64_t)v30);
            v27 = v30;
            LODWORD(v31) = *v26;
          }
          else
          {
            v27 = 0;
          }
          if ((_DWORD)v31 == 4)
          {
            v32 = v27[1];
            v33 = *(unsigned __int8 *)(v32 + 1);
            if (v33 == 30)
            {
              if (**v3 == 20)
              {
                v35 = *(_QWORD *)(v32 + 8);
                v34 = *(_QWORD *)(v32 + 16);
                if (v35 == *v28 && v34 == *(_QWORD *)(v7 + 12))
                  goto LABEL_85;
              }
            }
            else if (v33 == 2 && **v3 == 8 && *(_DWORD *)(v32 + 4) == *(_DWORD *)v28)
            {
              goto LABEL_85;
            }
          }
          else
          {
            if ((_DWORD)v31 == 5)
            {
              if (dword_10008BA20)
              {
                v38 = ne_log_obj(v30);
                if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
                {
                  v40[0] = 0;
                  _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "ASN1DN ID matching not implemented - passed.\n", (uint8_t *)v40, 2u);
                }
              }
LABEL_84:
              if (!v27)
                return 0;
LABEL_85:
              sub_10003F318(v27);
              return 0;
            }
            if (!memcmp((const void *)v27[1], v7 + 4, *v27))
              goto LABEL_85;
          }
        }
        v25 = sub_100006E1C(0, buf);
        v26 = (int *)v25;
      }
      while (v25);
      if (v27)
        sub_10003F318(v27);
    }
    if (dword_10008BA20)
    {
      v37 = ne_log_obj(v25);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
        sub_100057EF0();
    }
    if (*(_DWORD *)(*(_QWORD *)(a1 + 64) + 136))
      return 18;
    return 0;
  }
  return result;
}

uint64_t sub_10000FF0C(uint64_t a1)
{
  int v1;
  int v2;
  NSObject *v3;
  int v5;
  char *v6;

  v1 = a1;
  v2 = a1 - 1;
  if ((a1 - 1) < 0xB && ((0x53Fu >> v2) & 1) != 0)
    return dword_100069F68[v2];
  if (dword_10008BA20)
  {
    v3 = ne_log_obj(a1);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v5 = 136315138;
      v6 = sub_10003E21C(v1);
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Inproper idtype:%s in this function.\n", (uint8_t *)&v5, 0xCu);
    }
  }
  return 4;
}

uint64_t sub_10000FFE8(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t *v7;
  int v8;
  const void *v9;
  size_t v10;
  int v11;
  __int16 v12;
  size_t *v13;
  size_t *v14;
  unint64_t *v15;
  unint64_t *v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t *v19;
  char v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  NSObject *v25;
  _BOOL8 v26;
  NSObject *v27;
  NSObject *v28;
  uint64_t result;
  NSObject *v30;
  uint64_t v31;
  SecCertificateRef v32;
  SecCertificateRef v33;
  const __CFData *v34;
  const __CFData *v35;
  int Length;
  const UInt8 *BytePtr;
  size_t v38;
  size_t *v39;
  NSObject *v40;
  NSObject *v41;
  NSObject *v42;
  const __CFData *v43;
  NSObject *v44;
  NSObject *v45;
  uint64_t v46;
  uint64_t v47;

  v46 = 0;
  v47 = 0;
  v2 = *(_QWORD *)(a1 + 64);
  v3 = *(unsigned int *)(v2 + 32);
  switch((int)v3)
  {
    case 1:
      v4 = *(_QWORD *)(v2 + 40);
      if (!v4)
      {
        v4 = *(_QWORD *)(qword_10008B848 + 184);
        if (!v4)
          goto LABEL_70;
      }
      v5 = 2;
      goto LABEL_29;
    case 2:
      v4 = *(_QWORD *)(v2 + 40);
      if (!v4)
      {
        v4 = *(_QWORD *)(qword_10008B848 + 192);
        if (!v4)
          goto LABEL_70;
      }
      v5 = 3;
      goto LABEL_29;
    case 3:
    case 8:
      v4 = *(_QWORD *)(v2 + 40);
      if (!v4)
      {
        v4 = *(_QWORD *)(qword_10008B848 + 8 * v3 + 176);
        if (!v4)
          goto LABEL_70;
      }
      v5 = 11;
      goto LABEL_29;
    case 4:
      v6 = *(_QWORD *)(v2 + 40);
      if (!v6)
        goto LABEL_13;
      v7 = *(uint64_t **)(v6 + 8);
      if (!v7)
        goto LABEL_13;
      goto LABEL_14;
    case 5:
      v4 = *(_QWORD *)(v2 + 40);
      if (v4)
      {
        v5 = 9;
LABEL_29:
        v4 = (uint64_t)sub_10003F34C(v4);
        if (v4)
        {
          v14 = (size_t *)v4;
          v11 = 0;
          v12 = 0;
          goto LABEL_31;
        }
      }
      else
      {
        v31 = sub_10002B67C(a1);
        if ((v31 & 0x80000000) != 0)
        {
          if (!dword_10008BA20)
            return 0xFFFFFFFFLL;
          v40 = ne_log_obj(v31);
          v26 = os_log_type_enabled(v40, OS_LOG_TYPE_ERROR);
          if (v26)
            sub_10005800C();
          goto LABEL_42;
        }
        v32 = sub_100004A94(*(_QWORD *)(a1 + 280) + 8);
        if (v32)
        {
          v33 = v32;
          v34 = (const __CFData *)j__SecCertificateCopySubjectSequence();
          if (v34)
          {
            v35 = v34;
            Length = CFDataGetLength(v34);
            BytePtr = CFDataGetBytePtr(v35);
            v38 = Length;
            v39 = sub_10003F1F8(Length);
            if (v39)
            {
              v14 = v39;
              memcpy((void *)v39[1], BytePtr, v38);
              CFRelease(v33);
              CFRelease(v35);
              v11 = 0;
              v12 = 0;
              v5 = 9;
              goto LABEL_31;
            }
            if (dword_10008BA20)
            {
              v44 = ne_log_obj(0);
              if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
                sub_100058064();
            }
            CFRelease(v33);
            v43 = v35;
          }
          else
          {
            if (dword_10008BA20)
            {
              v42 = ne_log_obj(0);
              if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
                sub_100058064();
            }
            v43 = v33;
          }
          CFRelease(v43);
        }
        else
        {
          if (!dword_10008BA20)
            return 0;
          v41 = ne_log_obj(0);
          v4 = os_log_type_enabled(v41, OS_LOG_TYPE_ERROR);
          if ((_DWORD)v4)
            sub_100058038();
        }
      }
LABEL_70:
      if (!dword_10008BA20)
        return 0;
      v45 = ne_log_obj(v4);
      result = os_log_type_enabled(v45, OS_LOG_TYPE_ERROR);
      if ((_DWORD)result)
      {
        sub_100057FE0();
        return 0;
      }
      return result;
    default:
LABEL_13:
      v7 = *(uint64_t **)(a1 + 56);
LABEL_14:
      v8 = *((unsigned __int8 *)v7 + 1);
      if (v8 == 2)
        goto LABEL_18;
      if (v8 != 30)
      {
        if (!dword_10008BA20)
          return 0xFFFFFFFFLL;
        v27 = ne_log_obj(a1);
        v26 = os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
        if (v26)
          sub_100057FB4();
LABEL_42:
        if (dword_10008BA20)
        {
          v28 = ne_log_obj(v26);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
            sub_100057F88();
        }
        return 0xFFFFFFFFLL;
      }
      if (*(_DWORD *)(a1 + 28))
      {
        v47 = 0;
        LOWORD(v46) = 528;
        WORD1(v46) = *((_WORD *)v7 + 1);
        HIDWORD(v46) = 0;
        v7 = &v46;
LABEL_18:
        v9 = (char *)v7 + 4;
        v5 = 1;
        v10 = 4;
      }
      else
      {
        v9 = v7 + 1;
        v5 = 5;
        v10 = 16;
      }
      if (*(_BYTE *)(a1 + 80) == 16)
        v11 = -201261056;
      else
        v11 = 0;
      if (*(_BYTE *)(a1 + 80) == 16)
        v12 = 4352;
      else
        v12 = 0;
      v13 = sub_10003F1F8(v10);
      if (v13)
      {
        v14 = v13;
        memcpy((void *)v13[1], v9, *v13);
LABEL_31:
        v15 = sub_10003F1F8(*v14 + 4);
        if (v15)
        {
          v16 = v15;
          *(_DWORD *)v15[1] = v11 & 0xFFFF0000 | v12 & 0x1F00 | v5;
          memcpy((void *)(v15[1] + 4), (const void *)v14[1], *v14);
          *(_QWORD *)(a1 + 312) = v16;
          if (dword_1000882C8 >= 7)
          {
            v19 = v16;
            v18 = *v16;
            v17 = v19[1];
            v20 = sub_10003E21C(v5);
            sub_10003372C(7, v17, v18, "use ID type of %s\n", v21, v22, v23, v24, v20);
          }
          sub_10003F318(v14);
          return 0;
        }
        if (dword_10008BA20)
        {
          v25 = ne_log_obj(0);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
            sub_100057FE0();
        }
        sub_10003F318(v14);
        goto LABEL_42;
      }
      if (dword_10008BA20)
      {
        v30 = ne_log_obj(0);
        result = os_log_type_enabled(v30, OS_LOG_TYPE_ERROR);
        if (!(_DWORD)result)
          return result;
        sub_100057FE0();
      }
      return 0;
  }
}

uint64_t sub_100010490(void ***a1, int a2, uint64_t a3)
{
  return sub_100010498(a1, a2, a3, 0);
}

uint64_t sub_100010498(void ***a1, int a2, uint64_t a3, unsigned int a4)
{
  void **v5;
  NSObject *v7;
  NSObject *v8;
  void **v9;
  uint64_t result;
  _BYTE *v11;
  void *v12;
  void **v13;
  FILE *v14;
  FILE *v15;
  int v16;
  int v17;
  int v18;
  void **v19;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  _BYTE __ptr[512];

  if (a3)
  {
    v5 = 0;
    switch(a2)
    {
      case 1:
      case 2:
        if (*(_QWORD *)a3 > 1uLL)
          goto LABEL_11;
        if (dword_10008BA20)
        {
          v7 = ne_log_obj(a1);
          if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
            sub_10005810C();
        }
        return 0xFFFFFFFFLL;
      case 3:
        if (a4 >= 2)
        {
          if (a4 == 2)
          {
            v9 = (void **)sub_10003F1F8(*(_QWORD *)a3 - 1);
            if (v9)
            {
LABEL_12:
              v5 = v9;
              memcpy(v9[1], *(const void **)(a3 + 8), (size_t)*v9);
              goto LABEL_13;
            }
            if (dword_10008BA20)
            {
              v21 = ne_log_obj(0);
              if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
                sub_100058218();
            }
          }
          else if (dword_10008BA20)
          {
            v22 = ne_log_obj(a1);
            if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
              sub_100058188();
          }
        }
        else
        {
          v14 = fopen(*(const char **)(a3 + 8), "r");
          if (v14)
          {
            v15 = v14;
            v16 = fread(__ptr, 1uLL, 0x200uLL, v14);
            if (!v16)
            {
              v5 = 0;
LABEL_47:
              fclose(v15);
              goto LABEL_13;
            }
            v17 = 0;
            v5 = 0;
            while (1)
            {
              v18 = v16 + v17;
              v19 = sub_10003F270(v5, v16 + v17);
              if (!v19)
                break;
              v5 = v19;
              memcpy((char *)v19[1] + v17, __ptr, v16);
              v16 = fread(__ptr, 1uLL, 0x200uLL, v15);
              v17 = v18;
              if (!v16)
                goto LABEL_47;
            }
            fclose(v15);
          }
          else if (dword_10008BA20)
          {
            v24 = ne_log_obj(0);
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
              sub_1000581B4();
          }
        }
        return 0xFFFFFFFFLL;
      case 4:
        if (!*(_QWORD *)a3)
        {
          v5 = 0;
          goto LABEL_13;
        }
        v11 = sub_10003CC48(*(const char **)(a3 + 8), 0);
        if (v11)
        {
          v12 = v11;
          v13 = (void **)sub_10003F1F8(*v11);
          if (v13)
          {
            v5 = v13;
            memcpy(v13[1], v12, (size_t)*v13);
            free(v12);
LABEL_13:
            result = 0;
            *a1 = v5;
            return result;
          }
          free(v12);
        }
        else if (dword_10008BA20)
        {
          v23 = ne_log_obj(0);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
            sub_100058244();
        }
        break;
      case 5:
        if (dword_10008BA20)
        {
          v20 = ne_log_obj(a1);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
            sub_1000582A8();
        }
        return 0xFFFFFFFFLL;
      case 6:
      case 8:
LABEL_11:
        v9 = (void **)sub_10003F1F8(*(_QWORD *)a3 - 1);
        if (v9)
          goto LABEL_12;
        return 0xFFFFFFFFLL;
      default:
        goto LABEL_13;
    }
  }
  else
  {
    if ((a2 - 1) > 1)
      return 0;
    if (dword_10008BA20)
    {
      v8 = ne_log_obj(a1);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_100058090();
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_10001080C(uint64_t a1)
{
  uint64_t *v2;
  uint64_t *v3;
  unsigned __int8 *v4;
  __int128 *v5;
  unsigned int v6;
  size_t *v7;
  int v8;
  uint64_t v10;
  __int128 *v11;
  unsigned __int8 *v12;
  unint64_t v13;
  char v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  size_t *v20;
  unsigned __int8 *v21;
  unint64_t v22;
  char v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  NSObject *v29;
  NSObject *v30;
  NSObject *v31;
  _QWORD *v32;
  __int128 v33;
  __int128 v34;

  v2 = sub_100034EA0(*(_DWORD *)(a1 + 52));
  if (!v2)
  {
    if (dword_10008BA20)
    {
      v29 = ne_log_obj(0);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        sub_1000582D8();
    }
    return 0xFFFFFFFFLL;
  }
  v3 = v2;
  v34 = 0uLL;
  v4 = (unsigned __int8 *)(v2 + 2);
  v5 = (__int128 *)(v2 + 3);
  v6 = *((unsigned __int8 *)v2 + 280);
  if (*((_BYTE *)v2 + 153) == 30 && *(_DWORD *)(a1 + 16))
  {
    v5 = &v34;
    HIDWORD(v34) = 0;
    *(_QWORD *)((char *)&v34 + 4) = 0;
    LOWORD(v34) = 528;
    WORD1(v34) = *((_WORD *)v2 + 13);
    inet_pton(2, "192.168.2.2", (char *)&v34 + 4);
    v6 = 32;
  }
  v7 = sub_100010ADC((uint64_t)v5, v6, *((unsigned __int16 *)v3 + 141));
  *(_QWORD *)(a1 + 192) = v7;
  if (!v7)
  {
    if (dword_10008BA20)
    {
      v30 = ne_log_obj(0);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        sub_10005833C(v4, v30);
    }
    return 0xFFFFFFFFLL;
  }
  v8 = *(unsigned __int8 *)v7[1];
  if ((v8 == 4 || v8 == 1) && *(_BYTE *)(a1 + 60) == 1)
  {
    v10 = *(_QWORD *)(a1 + 256);
    if (v10)
    {
      if ((*(_BYTE *)(v10 + 96) & 2) != 0)
      {
        if (*(_QWORD *)(qword_10008B848 + 296))
        {
          sub_10003F318(v7);
          v7 = sub_10003F34C(*(_QWORD *)(qword_10008B848 + 296));
          *(_QWORD *)(a1 + 192) = v7;
          if (!v7)
            return 0xFFFFFFFFLL;
        }
      }
    }
  }
  v11 = (__int128 *)(v3 + 19);
  if (dword_1000882C8 >= 7)
  {
    v13 = *v7;
    v12 = (unsigned __int8 *)v7[1];
    v14 = sub_10003E21C(*v12);
    sub_10003372C(7, (uint64_t)v12, v13, "use local ID type %s\n", v15, v16, v17, v18, v14);
  }
  v33 = 0uLL;
  v19 = *((unsigned __int8 *)v3 + 281);
  if (*((_BYTE *)v3 + 153) == 30 && *(_DWORD *)(a1 + 16))
  {
    v11 = &v33;
    HIDWORD(v33) = 0;
    *(_QWORD *)((char *)&v33 + 4) = 0;
    LOWORD(v33) = 528;
    WORD1(v33) = *((_WORD *)v3 + 77);
    nw_nat64_extract_v4(a1 + 16, v3 + 20, (char *)&v33 + 4);
    v19 = 32;
  }
  v20 = sub_100010ADC((uint64_t)v11, v19, *((unsigned __int16 *)v3 + 141));
  *(_QWORD *)(a1 + 200) = v20;
  if (!v20)
  {
    if (dword_10008BA20)
    {
      v31 = ne_log_obj(0);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
        sub_10005833C(v4, v31);
    }
    v32 = *(_QWORD **)(a1 + 192);
    if (v32)
    {
      sub_10003F318(v32);
      *(_QWORD *)(a1 + 192) = 0;
    }
    return 0xFFFFFFFFLL;
  }
  if (dword_1000882C8 >= 7)
  {
    v22 = *v20;
    v21 = (unsigned __int8 *)v20[1];
    v23 = sub_10003E21C(*v21);
    sub_10003372C(7, (uint64_t)v21, v22, "use remote ID type %s\n", v24, v25, v26, v27, v23);
  }
  return 0;
}

size_t *sub_100010ADC(uint64_t a1, unsigned int a2, int a3)
{
  unsigned int v4;
  int v5;
  unsigned int v6;
  char v7;
  NSObject *v8;
  const void *v9;
  size_t v10;
  __int16 v11;
  size_t *v12;
  size_t *v13;
  size_t v14;
  char v15;
  size_t v16;
  _BYTE *v17;
  uint64_t v18;
  NSObject *v19;
  NSObject *v20;
  NSObject *v21;

  v4 = a2;
  v5 = *(unsigned __int8 *)(a1 + 1);
  if (v5 != 30)
  {
    if (v5 != 2)
    {
      if (dword_10008BA20)
      {
        v8 = ne_log_obj(a1);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
          sub_1000583B0();
      }
      return 0;
    }
    if (a2 == 32)
    {
      v6 = 0;
      v7 = 1;
LABEL_12:
      v9 = (const void *)(a1 + 4);
      v10 = 4;
      goto LABEL_16;
    }
    if (a2 < 0x20)
    {
      v7 = 4;
      v6 = 4;
      goto LABEL_12;
    }
    if (!dword_10008BA20)
      return 0;
    v20 = ne_log_obj(a1);
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      return 0;
LABEL_33:
    sub_100058410();
    return 0;
  }
  if (a2 == 128)
  {
    v6 = 0;
    v7 = 5;
  }
  else
  {
    if (a2 >= 0x80)
    {
      if (!dword_10008BA20)
        return 0;
      v21 = ne_log_obj(a1);
      if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        return 0;
      goto LABEL_33;
    }
    v6 = 16;
    v7 = 6;
  }
  v9 = (const void *)(a1 + 8);
  v10 = 16;
LABEL_16:
  v11 = *(_WORD *)(a1 + 2);
  v12 = sub_10003F1F8(v10 + v6 + 4);
  if (!v12)
  {
    if (dword_10008BA20)
    {
      v19 = ne_log_obj(0);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        sub_100057FE0();
    }
    return 0;
  }
  v13 = v12;
  bzero((void *)v12[1], *v12);
  v14 = v13[1];
  *(_BYTE *)v14 = v7;
  if (a3 == 255)
    v15 = 0;
  else
    v15 = a3;
  *(_BYTE *)(v14 + 1) = v15;
  *(_WORD *)(v14 + 2) = v11;
  memcpy((void *)(v14 + 4), v9, v10);
  if (v6)
  {
    v16 = v13[1];
    v17 = (_BYTE *)(v16 + v10 + 4);
    if (v4 >= 8)
    {
      v18 = (v4 - 8) >> 3;
      memset(v17, 255, v18 + 1);
      v17 = (_BYTE *)(v10 + v18 + v16 + 5);
      v4 &= 7u;
    }
    if (v4)
      *v17 = -1 << (8 - v4);
  }
  return v13;
}

size_t *sub_100010CFC(uint64_t a1, uint64_t a2, int a3)
{
  int v3;
  char v7;
  size_t v8;
  NSObject *v9;
  size_t *v10;
  size_t *v11;
  size_t v12;
  char v13;
  NSObject *v14;
  NSObject *v15;

  v3 = *(unsigned __int8 *)(a1 + 1);
  if (v3 != *(unsigned __int8 *)(a2 + 1))
  {
    if (dword_10008BA20)
    {
      v9 = ne_log_obj(a1);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_100058470();
    }
    return 0;
  }
  if (v3 == 2)
  {
    v7 = 7;
    v8 = 4;
  }
  else
  {
    if (v3 != 30)
    {
      if (dword_10008BA20)
      {
        v14 = ne_log_obj(a1);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
          sub_1000583B0();
      }
      return 0;
    }
    v7 = 8;
    v8 = 16;
  }
  v10 = sub_10003F1F8((2 * v8) | 4);
  if (!v10)
  {
    if (dword_10008BA20)
    {
      v15 = ne_log_obj(0);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        sub_100057FE0();
    }
    return 0;
  }
  v11 = v10;
  bzero((void *)v10[1], *v10);
  v12 = v11[1];
  *(_BYTE *)v12 = v7;
  if (a3 == 255)
    v13 = 0;
  else
    v13 = a3;
  *(_BYTE *)(v12 + 1) = v13;
  *(_WORD *)(v12 + 2) = *(_WORD *)(a1 + 2);
  memcpy((void *)(v12 + 4), (const void *)(a1 + 4), v8);
  memcpy((void *)(v11[1] + v8 + 4), (const void *)(a2 + 4), v8);
  return v11;
}

uint64_t sub_100010E6C(unint64_t *a1, uint64_t a2, _BYTE *a3, __int16 *a4, int a5)
{
  unsigned __int8 *v5;
  int v6;
  unsigned int v8;
  unint64_t v9;
  uint64_t result;
  NSObject *v11;
  unint64_t v12;
  int v13;
  unsigned int v14;
  unsigned __int8 *v15;
  unsigned int v16;
  int v17;
  char v18;
  unsigned int v19;
  BOOL v20;
  __int16 v21;

  v5 = (unsigned __int8 *)a1[1];
  v6 = *v5;
  if ((v6 - 5) < 2)
  {
    *(_WORD *)a2 = 7708;
    *(_WORD *)(a2 + 2) = *((_WORD *)v5 + 1);
    *(_OWORD *)(a2 + 8) = *(_OWORD *)(v5 + 4);
  }
  else
  {
    if (v6 != 4 && v6 != 1)
    {
      if (dword_10008BA20)
      {
        v11 = ne_log_obj(a1);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          sub_10005849C();
      }
      return 18;
    }
    *(_WORD *)a2 = 528;
    *(_WORD *)(a2 + 2) = *((_WORD *)v5 + 1);
    *(_DWORD *)(a2 + 4) = *((_DWORD *)v5 + 1);
  }
  LOBYTE(v8) = 0;
  switch(*v5)
  {
    case 1u:
      LOBYTE(v8) = 32;
      goto LABEL_34;
    case 4u:
    case 6u:
      if (*v5 == 6)
        v9 = 16;
      else
        v9 = 4;
      if (*a1 < v9)
        return 0xFFFFFFFFLL;
      v12 = a1[1];
      v13 = *(unsigned __int8 *)(v12 + v9 + 4);
      if (v13 != 255)
      {
        LOBYTE(v8) = 0;
        goto LABEL_27;
      }
      v14 = 8 * v9;
      v15 = (unsigned __int8 *)(v9 + v12 + 5);
      v16 = 8;
      while (1)
      {
        v8 = v16;
        if (v16 >= v14)
          break;
        v17 = *v15++;
        v13 = v17;
        v16 += 8;
        if (v17 != 255)
          goto LABEL_31;
      }
      v13 = 255;
LABEL_31:
      if (v8 < v14)
      {
        if (v13 == 255)
        {
          v18 = 0;
LABEL_29:
          LOBYTE(v8) = v8 + v18 + 8;
          goto LABEL_34;
        }
LABEL_27:
        v18 = 0;
        v19 = v13 ^ 0xFF;
        do
        {
          --v18;
          v20 = v19 > 1;
          v19 >>= 1;
        }
        while (v20);
        goto LABEL_29;
      }
LABEL_34:
      *a3 = v8;
      if (a5 != 16)
        return 0;
      result = 0;
      v21 = v5[1];
      if (!v5[1])
        v21 = 255;
      *a4 = v21;
      return result;
    case 5u:
      LOBYTE(v8) = 0x80;
      goto LABEL_34;
    default:
      goto LABEL_34;
  }
}

_BYTE *sub_10001102C(uint64_t a1)
{
  unsigned __int8 *v1;
  int v2;
  int v4;
  int v5;
  int v6;
  NSObject *v7;
  NSObject *v8;
  unint64_t v9;
  int v10;
  unsigned int v11;
  unsigned __int8 *v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  char *v16;
  unsigned int v17;
  int v18;
  char *v19;
  char *v20;
  unsigned int v21;
  int v22;
  char *v23;
  int v24;
  unsigned int v25;
  BOOL v26;
  _BYTE *v27;
  _BYTE *v28;
  sockaddr v30[8];

  v1 = *(unsigned __int8 **)(a1 + 8);
  memset(v30, 0, sizeof(v30));
  v2 = *v1;
  switch(*v1)
  {
    case 1u:
    case 4u:
    case 7u:
      *(_WORD *)&v30[0].sa_len = 528;
      *(_DWORD *)&v30[0].sa_data[2] = *((_DWORD *)v1 + 1);
      goto LABEL_8;
    case 2u:
    case 3u:
LABEL_10:
      if (*(_DWORD *)a1 - 4 >= 512)
        v6 = 512;
      else
        v6 = *(_DWORD *)a1 - 4;
      __memcpy_chk(&qword_100088548, v1 + 4, v6, 512);
      goto LABEL_48;
    case 5u:
    case 6u:
    case 8u:
      *(_WORD *)&v30[0].sa_len = 7708;
      *(sockaddr *)&v30[0].sa_data[6] = *(sockaddr *)(v1 + 4);
      if (v30[0].sa_data[6] == 254 && (v30[0].sa_data[7] & 0xC0) == 0x80)
        v4 = *((_DWORD *)v1 + 6);
      else
        v4 = 0;
      *(_DWORD *)&v30[1].sa_data[6] = v4;
LABEL_8:
      switch(v2)
      {
        case 1:
        case 5:
          sub_10003C8A0(v30);
          v5 = snprintf((char *)&qword_100088548, 0x200uLL, "%s");
          goto LABEL_47;
        case 2:
        case 3:
          goto LABEL_10;
        case 4:
        case 6:
          if (v2 == 6)
            v9 = 16;
          else
            v9 = 4;
          if (*(_QWORD *)a1 < v9)
            goto LABEL_49;
          v10 = v1[v9 + 4];
          if (v10 != 255)
            goto LABEL_40;
          v11 = 8 * v9;
          v12 = &v1[v9 + 5];
          v13 = 8;
          break;
        case 7:
          v16 = sub_10003C8A0(v30);
          v17 = snprintf((char *)&qword_100088548, 0x200uLL, "%s-", v16);
          v6 = v17;
          v18 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 8);
          *(_DWORD *)&v30[0].sa_len = 528;
          *(_DWORD *)&v30[0].sa_data[2] = v18;
          if ((v17 & 0x80000000) != 0)
            goto LABEL_50;
          v19 = (char *)&qword_100088548 + v17;
          goto LABEL_39;
        case 8:
          v20 = sub_10003C8A0(v30);
          v21 = snprintf((char *)&qword_100088548, 0x200uLL, "%s-", v20);
          v6 = v21;
          *(_DWORD *)&v30[0].sa_len = 7708;
          *(sockaddr *)&v30[0].sa_data[6] = *(sockaddr *)(*(_QWORD *)(a1 + 8) + 20);
          if (v30[0].sa_data[6] == 254 && (v30[0].sa_data[7] & 0xC0) == 0x80)
            v22 = *((_DWORD *)v1 + 6);
          else
            v22 = 0;
          *(_DWORD *)&v30[1].sa_data[6] = v22;
          if ((v21 & 0x80000000) != 0)
            goto LABEL_50;
          v19 = (char *)&qword_100088548 + v21;
LABEL_39:
          v23 = sub_10003C8A0(v30);
          v6 += snprintf(v19, 512 - v6, "%s", v23);
          goto LABEL_48;
        case 9:
        case 10:
          goto LABEL_14;
        case 11:
          goto LABEL_18;
        default:
          goto LABEL_19;
      }
      break;
    case 9u:
    case 0xAu:
LABEL_14:
      if (dword_10008BA20)
      {
        v7 = ne_log_obj(a1);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
          sub_10005855C();
      }
      strcpy((char *)&qword_100088548, "<ASN1-DN>");
      v6 = 9;
      goto LABEL_50;
    case 0xBu:
LABEL_18:
      strcpy((char *)&qword_100088548, "<KEY-ID>");
      v6 = 8;
      goto LABEL_50;
    default:
LABEL_19:
      if (dword_10008BA20)
      {
        v8 = ne_log_obj(a1);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
          sub_1000584FC();
      }
      goto LABEL_49;
  }
  while (1)
  {
    v14 = v13;
    if (v13 >= v11)
      break;
    v15 = *v12++;
    v10 = v15;
    v13 += 8;
    if (v15 != 255)
      goto LABEL_44;
  }
  v10 = 255;
LABEL_44:
  if (v14 < v11 && v10 != 255)
  {
LABEL_40:
    v24 = 0;
    v25 = v10 ^ 0xFF;
    do
    {
      --v24;
      v26 = v25 > 1;
      v25 >>= 1;
    }
    while (v26);
  }
  sub_10003C8A0(v30);
  v5 = snprintf((char *)&qword_100088548, 0x200uLL, "%s/%i");
LABEL_47:
  v6 = v5;
LABEL_48:
  if (!v6)
  {
LABEL_49:
    LODWORD(qword_100088548) = 4079420;
    v6 = 3;
  }
LABEL_50:
  v27 = malloc_type_malloc(v6 + 1, 0xD287029BuLL);
  v28 = v27;
  if (v27)
  {
    memcpy(v27, &qword_100088548, v6);
    v28[v6] = 0;
  }
  return v28;
}

uint64_t sub_100011444(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t result;
  unsigned int v6;
  _QWORD *v7;
  unsigned int v8;
  uint64_t v11;
  _WORD *v12;
  int v13;
  unsigned __int16 *v14;
  unint64_t v15;
  int v16;
  unsigned int v17;
  int v18;
  NSObject *v19;
  unsigned int v20;
  _DWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  int v24;
  unsigned int v25;
  int v26;
  unsigned int v27;
  unsigned int v28;
  uint64_t v29;
  NSObject *v30;
  NSObject *v31;
  uint64_t v32;
  _DWORD *v33;
  char *v34;
  char *v35;
  size_t v36;
  _QWORD *v37;
  unsigned int v38;
  int v39;
  NSObject *v40;
  NSObject *v41;
  NSObject *v42;
  NSObject *v43;
  NSObject *v44;
  NSObject *v45;
  NSObject *v46;
  uint64_t v47;
  NSObject *v48;
  NSObject *v49;
  NSObject *v50;
  NSObject *v51;
  NSObject *v52;
  NSObject *v53;
  NSObject *v54;
  _QWORD *v55;
  _DWORD *v56;
  int v57;
  char v58;
  _BYTE v59[15];
  uint8_t buf[4];
  char *v61;
  __int16 v62;
  int v63;
  __int16 v64;
  char *v65;

  result = 0;
  *a4 = *(unsigned __int8 *)(a1 + 4);
  a4[1] = *(unsigned __int8 *)(a1 + 5);
  v6 = *(unsigned __int16 *)(a1 + 2);
  *(_QWORD *)(a2 + 8) = 28800;
  v7 = (_QWORD *)(a2 + 8);
  *(_DWORD *)(a2 + 16) = 0;
  a4[3] = 254;
  v8 = bswap32(v6) >> 16;
  if (v8 >= 9)
  {
    v11 = a2;
    v12 = 0;
    v13 = v8 - 8;
    v14 = (unsigned __int16 *)(a1 + 8);
    v56 = (_DWORD *)(a2 + 16);
    v57 = 1;
    while (1)
    {
      v15 = v13;
      if (v13 <= 3)
        break;
      v16 = *v14;
      v17 = bswap32(v16 & 0xFFFFFF7F) >> 16;
      v18 = (v16 << 8) & 0x8000;
      if (dword_10008BA20)
      {
        v19 = ne_log_obj(result);
        result = os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG);
        if ((_DWORD)result)
        {
          v55 = v7;
          v32 = v11;
          v33 = a3;
          v34 = sub_10003DFA8(v17);
          v35 = sub_10003E18C(v17, bswap32(v14[1]) >> 16);
          *(_DWORD *)buf = 136315650;
          v61 = v34;
          a3 = v33;
          v11 = v32;
          v7 = v55;
          v62 = 1024;
          v63 = v18;
          v64 = 2080;
          v65 = v35;
          _os_log_debug_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "type=%s, flag=0x%04x, lorv=%s\n", buf, 0x1Cu);
        }
      }
      switch(v17)
      {
        case 1u:
          v20 = bswap32(v14[1]);
          if ((unsigned __int16)(HIWORD(v20) - 1) > 1u)
          {
            if (dword_10008BA20)
            {
              v31 = ne_log_obj(result);
              result = os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT);
              if ((_DWORD)result)
              {
                *(_WORD *)buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "invalid life duration type. use default\n", buf, 2u);
              }
            }
            goto LABEL_54;
          }
          v57 = HIWORD(v20);
          if (v18)
            goto LABEL_56;
          goto LABEL_28;
        case 2u:
          if (v12 && (*v12 & 0xFF7F) == 0x100)
          {
            if (v18)
            {
              v21 = a3;
              v22 = sub_10003F1F8(2uLL);
              if (!v22)
              {
                if (!dword_10008BA20)
                  return 0xFFFFFFFFLL;
                v46 = ne_log_obj(0);
                if (!os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
                  return 0xFFFFFFFFLL;
                goto LABEL_82;
              }
              v23 = v22;
              *(_WORD *)v22[1] = v14[1];
            }
            else
            {
              v36 = bswap32(v14[1]) >> 16;
              if (v36 + 4 > v15)
              {
                if (dword_10008BA20)
                {
                  v51 = ne_log_obj(result);
                  if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
                    sub_100058658(v15, v36, v51);
                }
                return 0xFFFFFFFFLL;
              }
              v21 = a3;
              v37 = sub_10003F1F8(v36);
              if (!v37)
              {
                if (!dword_10008BA20)
                  return 0xFFFFFFFFLL;
                v52 = ne_log_obj(0);
                if (!os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
                  return 0xFFFFFFFFLL;
LABEL_82:
                sub_1000586EC();
                return 0xFFFFFFFFLL;
              }
              v23 = v37;
              memcpy((void *)v37[1], v14 + 2, v36);
            }
            if (v57 == 2)
            {
              v39 = sub_10000CAC4((uint64_t)v23);
              sub_10003F318(v23);
              if (!v39)
              {
                if (!dword_10008BA20)
                  return 0xFFFFFFFFLL;
                v50 = ne_log_obj(result);
                if (!os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
                  return 0xFFFFFFFFLL;
LABEL_88:
                sub_100056C5C();
                return 0xFFFFFFFFLL;
              }
              if (*v56)
              {
                if (*v56 != v39)
                {
                  if (dword_10008BA20)
                  {
                    v53 = ne_log_obj(result);
                    if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
                      sub_10005878C();
                  }
                  return 0xFFFFFFFFLL;
                }
                a3 = v21;
                v57 = 2;
              }
              else
              {
                *v56 = v39;
                v57 = 2;
                a3 = v21;
              }
              if (v18)
                goto LABEL_56;
            }
            else
            {
              if (v57 != 1)
              {
                sub_10003F318(v23);
                if (dword_10008BA20)
                {
                  v48 = ne_log_obj(v47);
                  if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
                    sub_100056BFC();
                }
                return 0xFFFFFFFFLL;
              }
              v38 = sub_10000CAC4((uint64_t)v23);
              sub_10003F318(v23);
              if (!v38)
              {
                if (!dword_10008BA20)
                  return 0xFFFFFFFFLL;
                v49 = ne_log_obj(result);
                if (!os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
                  return 0xFFFFFFFFLL;
                goto LABEL_88;
              }
              if (*v7 != 28800)
              {
                if (*v7 != v38)
                {
                  if (dword_10008BA20)
                  {
                    v54 = ne_log_obj(result);
                    if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
                      sub_100058718();
                  }
                  return 0xFFFFFFFFLL;
                }
                a3 = v21;
LABEL_54:
                v57 = 1;
                goto LABEL_55;
              }
              *v7 = v38;
              v57 = 1;
              a3 = v21;
              if (v18)
                goto LABEL_56;
            }
          }
          else
          {
            if (!dword_10008BA20)
              goto LABEL_55;
            v30 = ne_log_obj(result);
            result = os_log_type_enabled(v30, OS_LOG_TYPE_ERROR);
            if (!(_DWORD)result)
              goto LABEL_55;
            sub_100056BD0(&v58, v59);
            if (v18)
              goto LABEL_56;
          }
          goto LABEL_28;
        case 3u:
          v24 = *(_DWORD *)(v11 + 20);
          v25 = bswap32(v14[1]) >> 16;
          if (!v24)
          {
            *(_DWORD *)(v11 + 20) = v25;
            if (v18)
              goto LABEL_56;
            goto LABEL_28;
          }
          if (v24 != v25)
          {
            if (dword_10008BA20)
            {
              v45 = ne_log_obj(result);
              if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
                sub_1000587F0();
            }
            return 0xFFFFFFFFLL;
          }
LABEL_55:
          if (!v18)
            goto LABEL_28;
          goto LABEL_56;
        case 4u:
          v26 = a3[4];
          v27 = bswap32(v14[1]) >> 16;
          if (v26 && v26 != v27)
          {
            if (dword_10008BA20)
            {
              v42 = ne_log_obj(result);
              if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
                sub_10005881C();
            }
            return 0xFFFFFFFFLL;
          }
          a3[4] = v27;
          if (!v18)
            goto LABEL_28;
          goto LABEL_56;
        case 5u:
          if (a4[3] != 254)
          {
            if (dword_10008BA20)
            {
              v43 = ne_log_obj(result);
              if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
                sub_100058848();
            }
            return 0xFFFFFFFFLL;
          }
          a4[3] = bswap32(v14[1]) >> 16;
          if (!v18)
            goto LABEL_28;
          goto LABEL_56;
        case 6u:
          if (*a3 != 3)
          {
            if (dword_10008BA20)
            {
              v44 = ne_log_obj(result);
              if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
                sub_100058874();
            }
            return 0xFFFFFFFFLL;
          }
          a4[2] = bswap32(v14[1]) >> 16;
          if (v18)
          {
LABEL_56:
            v13 = v15 - 4;
            v29 = (uint64_t)(v14 + 2);
          }
          else
          {
LABEL_28:
            v28 = bswap32(v14[1]);
            v29 = (uint64_t)v14 + HIWORD(v28) + 4;
            v13 = v15 - HIWORD(v28) - 4;
            if (v13 < 0)
            {
              if (dword_10008BA20)
              {
                v41 = ne_log_obj(result);
                if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
                  sub_1000585EC();
              }
              return 0xFFFFFFFFLL;
            }
          }
          v12 = v14;
          v14 = (unsigned __int16 *)v29;
          if (v13 <= 0)
            return 0;
          break;
        default:
          goto LABEL_55;
      }
    }
    if (dword_10008BA20)
    {
      v40 = ne_log_obj(result);
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
        sub_100058588();
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t sub_100011BCC(uint64_t a1)
{
  NSObject *v2;

  if ((a1 - 1) < 7)
    return dword_100069F94[(int)a1 - 1];
  if (dword_10008BA20)
  {
    v2 = ne_log_obj(a1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1000588A0();
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100011C3C(unsigned int a1)
{
  if (a1 > 5)
    return 255;
  else
    return dword_100069F44[a1];
}

uint64_t sub_100011C5C(uint64_t a1)
{
  NSObject *v2;

  if ((_DWORD)a1 == 1)
    return 0;
  if (dword_10008BA20)
  {
    v2 = ne_log_obj(a1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_100058900();
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100011CC0(uint64_t a1)
{
  NSObject *v2;

  if ((a1 - 2) < 3)
    return 0;
  if (dword_10008BA20)
  {
    v2 = ne_log_obj(a1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_100058960();
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100011D28(uint64_t a1)
{
  NSObject *v2;

  if ((_DWORD)a1 == 1)
    return 0;
  if (dword_10008BA20)
  {
    v2 = ne_log_obj(a1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1000589C0();
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100011D8C(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;

  if (a1 > 7)
    goto LABEL_14;
  if (((1 << a1) & 0xEC) != 0)
    return 0;
  if ((_DWORD)a1 == 4)
  {
    if (dword_10008BA20)
    {
      v2 = ne_log_obj(a1);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_100058A8C(v2, v3, v4, v5, v6, v7, v8, v9);
    }
  }
  else
  {
LABEL_14:
    if (dword_10008BA20)
    {
      v10 = ne_log_obj(a1);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_100058A2C();
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100011E3C(unsigned int a1)
{
  uint64_t result;
  NSObject *v3;
  NSObject *v4;

  result = 0;
  if (a1 <= 0xC)
  {
    if (((1 << a1) & 0x18DC) != 0)
      return result;
    if (((1 << a1) & 0x722) != 0)
    {
      if (dword_10008BA20)
      {
        v3 = ne_log_obj(0);
        if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
          sub_100058B58();
      }
      return 0xFFFFFFFFLL;
    }
  }
  if (a1 != 253)
  {
    if (dword_10008BA20)
    {
      v4 = ne_log_obj(0);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_100058AF8();
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t sub_100011EF8(uint64_t a1)
{
  NSObject *v2;

  if ((a1 - 1) < 3)
    return 0;
  if (dword_10008BA20)
  {
    v2 = ne_log_obj(a1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_100058BB8();
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100011F60(uint64_t a1)
{
  return sub_10000E088(2, a1);
}

uint64_t sub_100011F6C(uint64_t a1)
{
  return sub_10000E088(3, a1);
}

void sub_100011F78(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 2u);
}

_BYTE *sub_100011F90(_BYTE *result, _BYTE *a2)
{
  *result = 0;
  *a2 = 0;
  return result;
}

void sub_100011FA0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, a5, 2u);
}

void sub_100011FAC(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0xCu);
}

void sub_100011FD4(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0xEu);
}

void sub_100011FE0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0x12u);
}

uint64_t sub_100012084(uint64_t a1, uint64_t a2)
{
  int *v2;
  NSObject *v3;
  NSObject *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t i;
  _QWORD *v10;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void **v18;
  int v19;
  BOOL v20;
  BOOL v21;
  NSObject *v23;
  NSObject *v24;
  _QWORD *v25;
  NSObject *v26;
  NSObject *v27;
  NSObject *v28;
  NSObject *v29;
  NSObject *v30;
  NSObject *v31;
  _QWORD *v32;
  char v33;
  NSObject *v34;
  _QWORD *v35;
  _QWORD *v36;
  _QWORD *v37;
  uint64_t **v38;
  uint64_t **v39;
  uint64_t v40;
  NSObject *v41;
  NSObject *v42;
  uint64_t **v43;
  _OWORD v44[6];

  v43 = 0;
  memset(v44, 0, sizeof(v44));
  v2 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) != 5248)
  {
    if (dword_10008BA20)
    {
      v4 = ne_log_obj(a1);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_100058E84();
    }
    goto LABEL_9;
  }
  if (a2)
  {
    if (dword_10008BA20)
    {
      v3 = ne_log_obj(a1);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        sub_100058E58();
    }
LABEL_9:
    v5 = 0;
    v6 = 0;
    v7 = 0;
    v8 = 0xFFFFFFFFLL;
    goto LABEL_10;
  }
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  sub_100026198((_QWORD *)a1, *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56));
  v13 = sub_10000FFE8(a1);
  if ((v13 & 0x80000000) != 0)
  {
    if (dword_10008BA20)
    {
      v26 = ne_log_obj(v13);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        sub_100058C18();
    }
    goto LABEL_9;
  }
  v14 = sub_10000EBAC(a1);
  *(_QWORD *)(a1 + 336) = v14;
  if (!v14)
  {
    if (dword_10008BA20)
    {
      v27 = ne_log_obj(0);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        sub_100058C44();
    }
    goto LABEL_9;
  }
  v15 = a1 + 64;
  v16 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 192);
  if (!v16)
  {
    if (dword_10008BA20)
    {
      v28 = ne_log_obj(0);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        sub_100058C70();
    }
    goto LABEL_9;
  }
  v17 = sub_1000297D4(v16, (size_t **)(a1 + 152), (_QWORD *)(a1 + 136));
  if ((v17 & 0x80000000) != 0)
  {
    if (dword_10008BA20)
    {
      v29 = ne_log_obj(v17);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        sub_100058C9C();
    }
    goto LABEL_9;
  }
  v18 = (void **)sub_100006C70(*(_DWORD *)(*(_QWORD *)(a1 + 64) + 140));
  *(_QWORD *)(a1 + 176) = v18;
  if (!v18)
  {
    if (dword_10008BA20)
    {
      v30 = ne_log_obj(0);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        sub_100058CC8();
    }
    goto LABEL_9;
  }
  v19 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v15 + 248) + 48);
  if (!*(_QWORD *)(*(_QWORD *)v15 + 272) || v19 != 65001)
  {
    v20 = (v19 - 65005) > 4 || ((1 << (v19 + 19)) & 0x15) == 0;
    v21 = !v20 || v19 == 65500;
    if (!v21 && v19 != 64221)
    {
      v5 = 0;
LABEL_46:
      v6 = 0;
      goto LABEL_47;
    }
  }
  v5 = sub_10003EFDC(16);
  if (!v5)
  {
    if (dword_10008BA20)
    {
      v23 = ne_log_obj(0);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        sub_100058E2C();
    }
  }
  v18 = (void **)sub_10003EFDC(17);
  v6 = v18;
  if (!v18 && dword_10008BA20)
  {
    v24 = ne_log_obj(0);
    v18 = (void **)os_log_type_enabled(v24, OS_LOG_TYPE_ERROR);
    if ((_DWORD)v18)
      sub_100058E00();
    goto LABEL_46;
  }
LABEL_47:
  if (!*(_DWORD *)(*(_QWORD *)v15 + 148))
  {
LABEL_70:
    v25 = 0;
    goto LABEL_71;
  }
  v18 = (void **)sub_10003EFDC(18);
  if (v18)
  {
    v18 = sub_100015718(v18, 0x80000000);
    v25 = v18;
  }
  else
  {
    v25 = 0;
  }
  if (!v25 && dword_10008BA20)
  {
    v31 = ne_log_obj(v18);
    v18 = (void **)os_log_type_enabled(v31, OS_LOG_TYPE_ERROR);
    if ((_DWORD)v18)
      sub_100058DD4();
    goto LABEL_70;
  }
LABEL_71:
  if (*(_DWORD *)(*(_QWORD *)v15 + 120)
    && (v18 = (void **)sub_10002CBE8(*(_DWORD *)(*(_QWORD *)(*(_QWORD *)v15 + 248) + 48)), (_DWORD)v18))
  {
    v18 = (void **)sub_10002C9DC(a1);
    if (!v18)
    {
      if (dword_10008BA20)
      {
        v42 = ne_log_obj(0);
        if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
          sub_100058DA8();
      }
      v7 = 0;
      v8 = 0xFFFFFFFFLL;
      goto LABEL_105;
    }
    v32 = v18;
    v33 = 0;
  }
  else
  {
    v32 = 0;
    v33 = 1;
  }
  if (dword_10008BA20)
  {
    v34 = ne_log_obj(v18);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
      sub_100058D20(a1 + 64, v34);
  }
  v35 = sub_10002662C(0, *(_QWORD *)(a1 + 336), 1);
  v36 = sub_10002662C(v35, *(_QWORD *)(a1 + 152), 4);
  v37 = sub_10002662C(v36, *(_QWORD *)(a1 + 176), 10);
  v38 = (uint64_t **)sub_10002662C(v37, *(_QWORD *)(a1 + 312), 5);
  v39 = v38;
  v43 = v38;
  if ((v33 & 1) == 0)
  {
    v39 = (uint64_t **)sub_10002662C(v38, (uint64_t)v32, 7);
    v43 = v39;
  }
  if (v25)
  {
    v39 = (uint64_t **)sub_10002662C(v39, (uint64_t)v25, 13);
    v43 = v39;
  }
  if (*(_DWORD *)(*(_QWORD *)v15 + 176))
  {
    v39 = (uint64_t **)sub_10003FD38(v39, v44);
    v43 = v39;
  }
  if (v5)
  {
    v39 = (uint64_t **)sub_10002662C(v39, (uint64_t)v5, 13);
    v43 = v39;
  }
  if (v6)
  {
    v39 = (uint64_t **)sub_10002662C(v39, (uint64_t)v6, 13);
    v43 = v39;
  }
  if (*(_DWORD *)(*(_QWORD *)v15 + 208))
  {
    v7 = sub_10003EFDC(19);
    if (v7)
      v43 = (uint64_t **)sub_10002662C(v39, (uint64_t)v7, 13);
  }
  else
  {
    v7 = 0;
  }
  *(_QWORD *)(a1 + 128) = sub_100026684(&v43, a1);
  *(_DWORD *)(a1 + 124) = *(_DWORD *)(*(_QWORD *)(a1 + 64) + 200);
  v40 = sub_100024360(a1);
  if ((_DWORD)v40 == -1)
  {
    if (dword_10008BA20)
    {
      v41 = ne_log_obj(v40);
      if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
        sub_100058CF4();
    }
    v8 = 0xFFFFFFFFLL;
  }
  else
  {
    sub_100003774(v2, 5281);
    v8 = 0;
  }
  if (v32)
    sub_10003F318(v32);
LABEL_105:
  if (v25)
    sub_10003F318(v25);
LABEL_10:
  for (i = 0; i != 96; i += 8)
  {
    v10 = *(_QWORD **)((char *)v44 + i);
    if (!v10)
      break;
    sub_10003F318(v10);
  }
  if (v5)
    sub_10003F318(v5);
  if (v6)
    sub_10003F318(v6);
  if (v7)
    sub_10003F318(v7);
  return v8;
}

uint64_t sub_10001269C(uint64_t a1, uint64_t a2)
{
  int *v3;
  _QWORD *v5;
  _QWORD *v6;
  unsigned __int8 *v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  void *v12;
  uint64_t *v13;
  uint64_t *v14;
  int v15;
  NSObject *v16;
  NSObject *v17;
  NSObject *v18;
  NSObject *v19;
  char v20;
  uint64_t v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  uint64_t v25;
  NSObject *v26;
  NSObject *v27;
  NSObject *v28;
  NSObject *v29;
  NSObject *v30;
  NSObject *v31;
  NSObject *v32;
  NSObject *v33;
  NSObject *v34;
  _QWORD *v35;
  _QWORD *v36;
  _QWORD *v37;
  _QWORD *v38;
  NSObject *v40;
  uint64_t v41;
  _QWORD *v42;
  NSObject *v43;
  __int128 *v44;
  uint64_t i;
  uint64_t v46;
  int v47;
  NSObject *v48;
  int v49;
  const char *v50;
  uint64_t v51;
  _QWORD *v52;
  NSObject *v53;
  const char *v54;
  int v55;
  const char *v56;
  const char *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  NSObject *v63;
  NSObject *v64;
  NSObject *v65;
  NSObject *v66;
  NSObject *v67;
  NSObject *v68;
  _QWORD *v69;
  int v70;
  size_t **v71;
  char v72;
  _BYTE v73[15];
  char v74;
  _BYTE v75[7];
  uint64_t v76;
  uint64_t *v77;
  void *v78;
  uint8_t buf[4];
  _BYTE v80[18];
  __int16 v81;
  const char *v82;

  v76 = 0;
  v77 = &v76;
  v78 = 0;
  v3 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) != 5281)
  {
    if (dword_10008BA20)
    {
      v18 = ne_log_obj(a1);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        sub_100058E84();
    }
    goto LABEL_49;
  }
  v5 = sub_1000232C8(a2);
  if (!v5)
  {
    if (dword_10008BA20)
    {
      v19 = ne_log_obj(0);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        sub_100058EE4();
    }
LABEL_49:
    v20 = 0;
    v21 = 0xFFFFFFFFLL;
    goto LABEL_93;
  }
  v6 = v5;
  v7 = (unsigned __int8 *)v5[1];
  *(_QWORD *)(a1 + 352) = 0;
  if (*v7 != 1)
  {
    if (dword_10008BA20)
    {
      v22 = ne_log_obj(v5);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        sub_1000592B8();
    }
    goto LABEL_91;
  }
  v8 = sub_1000263B8((size_t **)&v78, *((_QWORD *)v7 + 1));
  if ((v8 & 0x80000000) != 0)
  {
    if (dword_10008BA20)
    {
      v23 = ne_log_obj(v8);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        sub_100058F10();
    }
    goto LABEL_91;
  }
  v69 = v6;
  v70 = 0;
  v9 = 0;
  v71 = (size_t **)(a1 + 184);
  while (2)
  {
    v7 += 16;
    v10 = *v7;
    switch(*v7)
    {
      case 0u:
        if (v70)
          v8 = (uint64_t)sub_10002BBF4((_QWORD *)a1);
        v6 = v69;
        if (!*(_QWORD *)(a1 + 160) || !*v71)
        {
          if (dword_10008BA20)
          {
            v33 = ne_log_obj(v8);
            if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
              sub_100058FA0();
          }
          goto LABEL_91;
        }
        v25 = sub_10000F9F8(a1);
        if ((_DWORD)v25)
        {
          if (dword_10008BA20)
          {
            v26 = ne_log_obj(v25);
            if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
              sub_1000590D4();
          }
          goto LABEL_91;
        }
        v41 = sub_10000ABC8((unint64_t *)v78, (_QWORD *)a1);
        if ((v41 & 0x80000000) != 0)
        {
          if (dword_10008BA20)
          {
            v63 = ne_log_obj(v41);
            if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
              sub_100058FCC();
          }
          goto LABEL_91;
        }
        v42 = *(_QWORD **)(a1 + 344);
        if (v42)
        {
          sub_10003F318(v42);
          *(_QWORD *)(a1 + 344) = 0;
        }
        *(_QWORD *)(a1 + 8) = *(_QWORD *)(*(_QWORD *)(a2 + 8) + 8);
        if ((*(_BYTE *)(a1 + 96) & 1) != 0)
        {
          if (dword_10008BA20)
          {
            v43 = ne_log_obj(v42);
            v42 = (_QWORD *)os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT);
            if ((_DWORD)v42)
            {
              v44 = sub_10003EDD8(**(_DWORD **)(a1 + 88));
              *(_DWORD *)buf = 136315138;
              *(_QWORD *)v80 = v44;
              _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "Selected NAT-T version: %s\n", buf, 0xCu);
            }
          }
          *(_DWORD *)(a1 + 96) |= 6u;
          for (i = v76; v76; i = v76)
          {
            v46 = sub_10003F610(a1, *(_QWORD *)(i + 8), *(_DWORD *)i);
            if (dword_10008BA20)
            {
              v47 = v46;
              v48 = ne_log_obj(v46);
              if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
              {
                v49 = *(_DWORD *)i - 1;
                if (v47)
                  v50 = "verified";
                else
                  v50 = "doesn't match";
                *(_DWORD *)buf = 67109378;
                *(_DWORD *)v80 = v49;
                *(_WORD *)&v80[4] = 2080;
                *(_QWORD *)&v80[6] = v50;
                _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "NAT-D payload #%d %s\n", buf, 0x12u);
              }
            }
            sub_10003F318(*(_QWORD **)(i + 8));
            v51 = *(_QWORD *)(i + 16);
            v52 = *(_QWORD **)(i + 24);
            if (v51)
            {
              *(_QWORD *)(v51 + 24) = v52;
              v52 = *(_QWORD **)(i + 24);
            }
            else
            {
              v77 = *(uint64_t **)(i + 24);
            }
            *v52 = v51;
            free((void *)i);
          }
          if (dword_10008BA20)
          {
            v53 = ne_log_obj(v42);
            if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
            {
              v54 = "detected:";
              v55 = *(_DWORD *)(a1 + 96);
              v56 = "ME ";
              if ((v55 & 6) == 0)
                v54 = "not detected";
              if ((v55 & 2) == 0)
                v56 = (const char *)&unk_10007E079;
              *(_DWORD *)buf = 136315650;
              *(_QWORD *)v80 = v54;
              *(_WORD *)&v80[8] = 2080;
              *(_QWORD *)&v80[10] = v56;
              if ((v55 & 4) != 0)
                v57 = "PEER";
              else
                v57 = (const char *)&unk_10007E079;
              v81 = 2080;
              v82 = v57;
              _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "NAT %s %s%s\n", buf, 0x20u);
            }
          }
          v6 = v69;
          if ((*(_BYTE *)(a1 + 96) & 6) != 0)
            sub_10003FB84(a1);
          sub_10004E490(a1);
        }
        v58 = sub_1000295D8(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 192), *(_QWORD **)(a1 + 160), (_QWORD **)(a1 + 168), (_QWORD *)(a1 + 136));
        if ((v58 & 0x80000000) != 0)
        {
          if (dword_10008BA20)
          {
            v64 = ne_log_obj(v58);
            if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
              sub_100058FF8();
          }
          goto LABEL_91;
        }
        v59 = sub_10002CDB4(a1);
        if ((v59 & 0x80000000) != 0)
        {
          if (dword_10008BA20)
          {
            v65 = ne_log_obj(v59);
            if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
              sub_100059024();
          }
          goto LABEL_91;
        }
        v60 = sub_10002D170(a1);
        if ((v60 & 0x80000000) != 0)
        {
          if (dword_10008BA20)
          {
            v66 = ne_log_obj(v60);
            if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
              sub_100059050();
          }
          goto LABEL_91;
        }
        v61 = sub_10002D418((_QWORD *)a1);
        if ((v61 & 0x80000000) != 0)
        {
          if (!dword_10008BA20)
            goto LABEL_91;
          v67 = ne_log_obj(v61);
          if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
            sub_10005907C();
          goto LABEL_110;
        }
        v62 = sub_10002D814(a1);
        if ((v62 & 0x80000000) != 0)
        {
          if (dword_10008BA20)
          {
            v68 = ne_log_obj(v62);
            if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
              sub_1000590A8();
          }
          goto LABEL_110;
        }
        v21 = sub_10002AC24(a1);
        if ((_DWORD)v21 == -1)
        {
          v20 = 0;
          goto LABEL_92;
        }
        if (!(_DWORD)v21)
        {
          sub_10002CACC(a1);
          sub_100003774(v3, 5250);
          v20 = 1;
          sub_100048B0C(1, 1, a1, 0);
          goto LABEL_92;
        }
        sub_10001B184(a1, v21, 0);
        goto LABEL_91;
      case 1u:
      case 2u:
      case 3u:
      case 0xCu:
      case 0xEu:
      case 0x10u:
      case 0x11u:
      case 0x12u:
      case 0x13u:
        goto LABEL_56;
      case 4u:
        v8 = sub_1000263B8((size_t **)(a1 + 160), *((_QWORD *)v7 + 1));
        if ((v8 & 0x80000000) == 0)
          continue;
        if (!dword_10008BA20)
          goto LABEL_110;
        v27 = ne_log_obj(v8);
        v6 = v69;
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
          sub_100059100();
        goto LABEL_91;
      case 5u:
        v8 = sub_1000263B8((size_t **)(a1 + 320), *((_QWORD *)v7 + 1));
        if ((v8 & 0x80000000) == 0)
          continue;
        if (!dword_10008BA20)
          goto LABEL_110;
        v28 = ne_log_obj(v8);
        v6 = v69;
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
          sub_100059158();
        goto LABEL_91;
      case 6u:
        v8 = sub_10002C614(a1, *((_QWORD *)v7 + 1));
        if ((v8 & 0x80000000) != 0)
        {
          if (dword_10008BA20)
          {
            v29 = ne_log_obj(v8);
            v6 = v69;
            if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
              sub_1000591B0();
            goto LABEL_91;
          }
LABEL_110:
          v20 = 0;
          v21 = 0xFFFFFFFFLL;
          v6 = v69;
          goto LABEL_92;
        }
        v70 = 1;
        continue;
      case 7u:
        v8 = sub_10002C8BC(a1, *((_QWORD *)v7 + 1));
        if ((v8 & 0x80000000) == 0)
          continue;
        if (!dword_10008BA20)
          goto LABEL_110;
        v30 = ne_log_obj(v8);
        v6 = v69;
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
          sub_100059184();
        goto LABEL_91;
      case 8u:
        *(_QWORD *)(a1 + 352) = *((_QWORD *)v7 + 1);
        continue;
      case 9u:
        v8 = sub_1000263B8((size_t **)(a1 + 272), *((_QWORD *)v7 + 1));
        if ((v8 & 0x80000000) == 0)
          continue;
        if (!dword_10008BA20)
          goto LABEL_110;
        v31 = ne_log_obj(v8);
        v6 = v69;
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
          sub_1000591DC();
        goto LABEL_91;
      case 0xAu:
        v8 = sub_1000263B8(v71, *((_QWORD *)v7 + 1));
        if ((v8 & 0x80000000) == 0)
          continue;
        if (!dword_10008BA20)
          goto LABEL_110;
        v32 = ne_log_obj(v8);
        v6 = v69;
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
          sub_10005912C();
        goto LABEL_91;
      case 0xBu:
        sub_10001BBF4(*((_QWORD *)v7 + 1), a1);
        continue;
      case 0xDu:
        v8 = sub_10003F06C(*((_QWORD *)v7 + 1));
        v15 = v8;
        if (*(_DWORD *)(*(_QWORD *)(a1 + 64) + 176))
        {
          v8 = sub_10003F41C(v8);
          if ((_DWORD)v8)
            sub_10003FC4C(a1, v15);
        }
        switch(v15)
        {
          case 16:
            **(_DWORD **)(a1 + 408) |= 1u;
            break;
          case 17:
            **(_DWORD **)(a1 + 408) |= 2u;
            break;
          case 18:
            v8 = sub_1000151DC(*((_QWORD *)v7 + 1));
            if ((v8 & 0x80000000) != 0)
            {
              if (dword_10008BA20)
              {
                v16 = ne_log_obj(v8);
                v8 = os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG);
                if ((_DWORD)v8)
                  sub_100059234(&v72, v73);
              }
              *(_DWORD *)(a1 + 100) = 1;
            }
            break;
          case 19:
            if (*(_DWORD *)(*(_QWORD *)(a1 + 64) + 208))
            {
              *(_DWORD *)(a1 + 368) = 1;
              if (dword_10008BA20)
              {
                v17 = ne_log_obj(v8);
                v8 = os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG);
                if ((_DWORD)v8)
                  sub_100059208(&v74, v75);
              }
            }
            break;
          default:
            continue;
        }
        continue;
      case 0xFu:
      case 0x14u:
        goto LABEL_10;
      default:
        if (v10 != 130)
        {
LABEL_56:
          if (dword_10008BA20)
          {
            v24 = ne_log_obj(v8);
            v6 = v69;
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
              sub_100058F3C();
            goto LABEL_91;
          }
          goto LABEL_110;
        }
LABEL_10:
        if ((*(_BYTE *)(a1 + 96) & 1) == 0)
          continue;
        v11 = *(_QWORD *)(a1 + 88);
        if (!v11 || *(unsigned __int16 *)(v11 + 14) != v10)
          continue;
        v12 = malloc_type_malloc(0x20uLL, 0x10A00400E9F9246uLL);
        if (v12)
        {
          v13 = (uint64_t *)v12;
          *((_QWORD *)v12 + 1) = 0;
          v8 = sub_1000263B8((size_t **)v12 + 1, *((_QWORD *)v7 + 1));
          if ((v8 & 0x80000000) != 0)
          {
            if (dword_10008BA20)
            {
              v40 = ne_log_obj(v8);
              if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
                sub_10005928C();
            }
            free(v13);
            goto LABEL_110;
          }
          *(_DWORD *)v13 = v9;
          v13[2] = 0;
          ++v9;
          v14 = v77;
          v13[3] = (uint64_t)v77;
          *v14 = (uint64_t)v13;
          v77 = v13 + 2;
          continue;
        }
        if (!dword_10008BA20)
          goto LABEL_110;
        v34 = ne_log_obj(0);
        v6 = v69;
        if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
          sub_100059260();
LABEL_91:
        v20 = 0;
        v21 = 0xFFFFFFFFLL;
LABEL_92:
        sub_10003F318(v6);
LABEL_93:
        if (v78)
          sub_10003F318(v78);
        if ((v20 & 1) == 0)
        {
          v35 = *(_QWORD **)(a1 + 160);
          if (v35)
          {
            sub_10003F318(v35);
            *(_QWORD *)(a1 + 160) = 0;
          }
          v36 = *(_QWORD **)(a1 + 184);
          if (v36)
          {
            sub_10003F318(v36);
            *(_QWORD *)(a1 + 184) = 0;
          }
          v37 = *(_QWORD **)(a1 + 320);
          if (v37)
          {
            sub_10003F318(v37);
            *(_QWORD *)(a1 + 320) = 0;
          }
          sub_10002BC70(*(_QWORD **)(a1 + 288));
          *(_QWORD *)(a1 + 288) = 0;
          sub_10002BC70(*(_QWORD **)(a1 + 296));
          *(_QWORD *)(a1 + 296) = 0;
          v38 = *(_QWORD **)(a1 + 272);
          if (v38)
          {
            sub_10003F318(v38);
            *(_QWORD *)(a1 + 272) = 0;
          }
          sub_10002BC70(*(_QWORD **)(a1 + 304));
          *(_QWORD *)(a1 + 304) = 0;
        }
        return v21;
    }
  }
}

uint64_t sub_1000131EC(uint64_t a1, uint64_t a2)
{
  int v2;
  int *v3;
  NSObject *v6;
  uint64_t **v7;
  uint64_t v8;
  int v9;
  BOOL v10;
  uint64_t **v11;
  NSObject *v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  int v18;
  _QWORD *v19;
  _QWORD *v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  _QWORD *v26;
  int v27;
  uint64_t v28;
  NSObject *v29;
  NSObject *v30;
  _QWORD *v31;
  _QWORD *v32;
  uint64_t v33;
  int v34;
  size_t *v37;
  size_t *v38;
  uint64_t v39;
  _QWORD *v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  size_t *v44;
  size_t *v45;
  uint64_t v46;
  uint64_t v47;
  _QWORD *v48;
  uint64_t v49;
  NSObject *v50;
  NSObject *v51;
  NSObject *v52;
  NSObject *v53;
  NSObject *v54;
  NSObject *v55;
  NSObject *v57;
  _QWORD *v58;
  NSObject *v59;
  _QWORD *v60;
  uint64_t v61;
  NSObject *v62;
  NSObject *v63;
  unsigned int v64;
  unsigned int v65;
  uint8_t buf[8];
  uint64_t **v67;

  v3 = (int *)(a1 + 16);
  v2 = *(_DWORD *)(a1 + 16);
  v67 = 0;
  if (v2 != 5250)
  {
    if (dword_10008BA20)
    {
      v12 = ne_log_obj(a1);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        sub_100058E84();
    }
    return 0xFFFFFFFFLL;
  }
  if (dword_10008BA20)
  {
    v6 = ne_log_obj(a1);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      sub_100059558();
  }
  v7 = (uint64_t **)sub_10002A470(a1, 1);
  *(_QWORD *)(a1 + 256) = v7;
  if (!v7)
  {
    if (dword_10008BA20)
    {
      v13 = ne_log_obj(0);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        sub_100059320();
    }
    return 0xFFFFFFFFLL;
  }
  v8 = (uint64_t)v7;
  v9 = *(_DWORD *)(*(_QWORD *)(a1 + 72) + 48);
  if (*(_QWORD *)(*(_QWORD *)(a1 + 64) + 272))
    v10 = v9 == 65001;
  else
    v10 = 0;
  if (v10)
    goto LABEL_28;
  v11 = 0;
  if (v9 <= 64220)
  {
    if (v9 == 1)
      goto LABEL_28;
    if (v9 != 3)
      goto LABEL_30;
    goto LABEL_23;
  }
  switch(v9)
  {
    case 65500:
LABEL_28:
      v17 = 0;
      v18 = 8;
LABEL_29:
      v7 = (uint64_t **)sub_10002662C(v17, v8, v18);
      v11 = v7;
      v67 = v7;
      break;
    case 65005:
LABEL_23:
      v14 = sub_10002B67C(a1);
      if ((v14 & 0x80000000) != 0)
      {
        if (dword_10008BA20)
        {
          v53 = ne_log_obj(v14);
          if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
            sub_100059500();
        }
        return 0xFFFFFFFFLL;
      }
      v15 = sub_10002B990((_QWORD *)a1);
      if ((v15 & 0x80000000) != 0)
      {
        if (dword_10008BA20)
        {
          v55 = ne_log_obj(v15);
          if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
            sub_10005952C();
        }
        return 0xFFFFFFFFLL;
      }
      v16 = *(_QWORD *)(a1 + 280);
      if (v16 && *(_DWORD *)(*(_QWORD *)(a1 + 64) + 116))
        v17 = sub_10002662C(0, *(_QWORD *)(v16 + 24), 6);
      else
        v17 = 0;
      v8 = *(_QWORD *)(a1 + 264);
      v18 = 9;
      goto LABEL_29;
    case 64221:
      goto LABEL_28;
  }
LABEL_30:
  if ((*(_BYTE *)(a1 + 96) & 1) == 0)
  {
    v19 = 0;
    v20 = 0;
    goto LABEL_48;
  }
  if (dword_10008BA20)
  {
    v21 = ne_log_obj(v7);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Adding remote and local NAT-D payloads.\n", buf, 2u);
    }
  }
  v22 = sub_10003F42C(a1, *(_QWORD *)(a1 + 48));
  if (!v22)
  {
    if (dword_10008BA20)
    {
      v29 = ne_log_obj(0);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        sub_100059498((const sockaddr **)(a1 + 48));
    }
    return 0xFFFFFFFFLL;
  }
  v19 = (_QWORD *)v22;
  v23 = sub_10003F42C(a1, *(_QWORD *)(a1 + 56));
  if (!v23)
  {
    if (dword_10008BA20)
    {
      v30 = ne_log_obj(0);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        sub_100059498((const sockaddr **)(a1 + 56));
    }
    v31 = 0;
    v32 = 0;
    v20 = 0;
    v33 = 0xFFFFFFFFLL;
    goto LABEL_112;
  }
  v20 = (_QWORD *)v23;
  v24 = *(_QWORD *)(a1 + 88);
  v25 = *(unsigned __int16 *)(v24 + 14);
  if (*(_DWORD *)v24 == 14)
  {
    v26 = sub_10002662C(v11, v23, v25);
    v27 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 88) + 14);
    v28 = (uint64_t)v19;
  }
  else
  {
    v26 = sub_10002662C(v11, (uint64_t)v19, v25);
    v27 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 88) + 14);
    v28 = (uint64_t)v20;
  }
  v11 = (uint64_t **)sub_10002662C(v26, v28, v27);
  v67 = v11;
LABEL_48:
  if ((~**(_DWORD **)(a1 + 408) & 3) != 0)
  {
    v32 = 0;
    v31 = 0;
    goto LABEL_63;
  }
  v34 = *(_DWORD *)(*(_QWORD *)(a1 + 72) + 48);
  if ((v34 != 65001 || *(_QWORD *)(*(_QWORD *)(a1 + 64) + 272) == 0) && v34 == 64221)
  {
    v44 = sub_10002CC0C((size_t *)a1);
    if (v44)
    {
      v45 = v44;
      v46 = sub_100029C14(*(_QWORD *)(a1 + 192), (uint64_t)v44, a1);
      if (v46)
      {
        v47 = v46;
        sub_10003F318(v45);
        v64 = *(_DWORD *)(*(_QWORD *)(a1 + 64) + 24);
        v48 = sub_10003F1F8(*(_QWORD *)v47 + 24);
        if (v48)
        {
          v32 = v48;
          *(_QWORD *)v48[1] = bswap32(v64) | 0x379E100100000000;
          v49 = v48[1];
          *(_OWORD *)(v49 + 8) = *(_OWORD *)a1;
          memcpy((void *)(v49 + 24), *(const void **)(v47 + 8), *(_QWORD *)v47);
          sub_10003F318((_QWORD *)v47);
          v11 = (uint64_t **)sub_10002662C(v11, (uint64_t)v32, 11);
          v67 = v11;
          goto LABEL_57;
        }
        if (dword_10008BA20)
        {
          v59 = ne_log_obj(0);
          if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
            sub_1000593E8();
        }
        v58 = (_QWORD *)v47;
      }
      else
      {
        if (dword_10008BA20)
        {
          v57 = ne_log_obj(0);
          if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
            sub_1000593BC();
        }
        v58 = v45;
      }
      sub_10003F318(v58);
    }
    else if (dword_10008BA20)
    {
      v54 = ne_log_obj(0);
      if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
        sub_10005934C(a1);
    }
    v32 = 0;
    goto LABEL_109;
  }
  v32 = 0;
LABEL_57:
  if ((*(_BYTE *)(a1 + 432) & 1) == 0
    && *(_DWORD *)(*(_QWORD *)(a1 + 64) + 168)
    && !sub_1000095F0(*(_QWORD *)(a1 + 48)))
  {
    v65 = *(_DWORD *)(*(_QWORD *)(a1 + 64) + 24);
    v60 = sub_10003F1F8(0x18uLL);
    if (v60)
    {
      v31 = v60;
      *(_QWORD *)v60[1] = bswap32(v65) | 0x260100100000000;
      *(_OWORD *)(v60[1] + 8) = *(_OWORD *)a1;
      v67 = (uint64_t **)sub_10002662C(v11, (uint64_t)v60, 11);
      v61 = sub_100009634(*(unsigned __int8 **)(a1 + 48));
      if ((_DWORD)v61 == -1)
      {
        if (dword_10008BA20)
        {
          v62 = ne_log_obj(v61);
          if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
            sub_10005946C();
        }
      }
      goto LABEL_61;
    }
    if (dword_10008BA20)
    {
      v63 = ne_log_obj(0);
      if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
        sub_1000593E8();
    }
LABEL_109:
    v31 = 0;
    goto LABEL_110;
  }
  v31 = 0;
LABEL_61:
  *(_BYTE *)(a1 + 82) |= 1u;
LABEL_63:
  v37 = sub_100026684(&v67, a1);
  *(_QWORD *)(a1 + 128) = v37;
  if ((~**(_DWORD **)(a1 + 408) & 3) == 0)
  {
    v38 = sub_10002E3DC(a1, (uint64_t)v37, *(_QWORD *)(*(_QWORD *)(a1 + 328) + 8), **(_QWORD **)(a1 + 328));
    if (!v38)
    {
      if (dword_10008BA20)
      {
        v52 = ne_log_obj(0);
        if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
          sub_100059414();
      }
      goto LABEL_110;
    }
    v37 = v38;
    sub_10003F318(*(_QWORD **)(a1 + 128));
    *(_QWORD *)(a1 + 128) = v37;
  }
  v39 = sub_1000240A4(a1, v37);
  if ((v39 & 0x80000000) != 0)
  {
    if (dword_10008BA20)
    {
      v50 = ne_log_obj(v39);
      if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
        sub_100058CF4();
    }
  }
  else
  {
    v40 = *(_QWORD **)(a1 + 128);
    if (*(_DWORD *)(a1 + 100) && *v40 >= 0x501uLL)
    {
      v41 = 0;
      LODWORD(v42) = *(_DWORD *)(a1 + 96);
    }
    else
    {
      v42 = *(unsigned int *)(a1 + 96);
      v41 = (v42 >> 3) & 4;
    }
    v43 = sub_100009B6C(*(unsigned __int8 **)(a1 + 48), *(unsigned __int8 **)(a1 + 56), (uint64_t)v40, a2, v41, (v42 >> 5) & 1);
    if ((_DWORD)v43 != -1)
    {
      *(_BYTE *)(a1 + 82) |= 1u;
      sub_100003774(v3, 9216);
      v33 = 0;
      goto LABEL_111;
    }
    if (dword_10008BA20)
    {
      v51 = ne_log_obj(v43);
      if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
        sub_100059440();
    }
  }
LABEL_110:
  v33 = 0xFFFFFFFFLL;
LABEL_111:
  if (v19)
LABEL_112:
    sub_10003F318(v19);
  if (v20)
    sub_10003F318(v20);
  if (v32)
    sub_10003F318(v32);
  if (v31)
    sub_10003F318(v31);
  return v33;
}

uint64_t sub_100013928(uint64_t a1, uint64_t a2)
{
  int *v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  unsigned __int8 *v9;
  int v10;
  NSObject *v11;
  int v12;
  int *v13;
  int v14;
  NSObject *v15;
  NSObject *v16;
  int v17;
  NSObject *v18;
  NSObject *v19;
  NSObject *v20;
  uint64_t v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  _QWORD *v25;
  _QWORD *v26;
  _QWORD *v27;
  _QWORD *v28;
  NSObject *v30;
  __int128 *v31;
  uint64_t v32;
  NSObject *v33;
  NSObject *v34;
  NSObject *v35;
  NSObject *v36;
  NSObject *v37;
  NSObject *v38;
  char v39;
  _BYTE v40[15];
  char v41;
  _BYTE v42[15];
  uint8_t buf[4];
  __int128 *v44;
  uint8_t v45[4];
  char *v46;

  v3 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) == 5504)
  {
    v4 = sub_1000232C8(a2);
    if (v4)
    {
      v5 = v4;
      v6 = v4[1];
      if (*(_BYTE *)v6 == 1)
      {
        v7 = sub_1000263B8((size_t **)(a1 + 336), *(_QWORD *)(v6 + 8));
        if ((v7 & 0x80000000) != 0)
        {
          if (dword_10008BA20)
          {
            v23 = ne_log_obj(v7);
            if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
              sub_100058F10();
          }
        }
        else
        {
          v10 = *(unsigned __int8 *)(v6 + 16);
          v9 = (unsigned __int8 *)(v6 + 16);
          v8 = v10;
          if (v10)
          {
            while (2)
            {
              if (dword_10008BA20)
              {
                v11 = ne_log_obj(v7);
                v7 = os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG);
                if ((_DWORD)v7)
                  sub_100059588(v45, v9, &v46, v11);
                v8 = *v9;
              }
              switch(v8)
              {
                case 4:
                  v7 = sub_1000263B8((size_t **)(a1 + 160), *((_QWORD *)v9 + 1));
                  if ((v7 & 0x80000000) == 0)
                    goto LABEL_35;
                  if (dword_10008BA20)
                  {
                    v34 = ne_log_obj(v7);
                    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
                      sub_100059100();
                  }
                  goto LABEL_58;
                case 5:
                  v7 = sub_1000263B8((size_t **)(a1 + 320), *((_QWORD *)v9 + 1));
                  if ((v7 & 0x80000000) == 0)
                    goto LABEL_35;
                  if (dword_10008BA20)
                  {
                    v35 = ne_log_obj(v7);
                    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
                      sub_100059158();
                  }
                  goto LABEL_58;
                case 7:
                  v7 = sub_10002C8BC(a1, *((_QWORD *)v9 + 1));
                  if ((v7 & 0x80000000) == 0)
                    goto LABEL_35;
                  if (dword_10008BA20)
                  {
                    v36 = ne_log_obj(v7);
                    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
                      sub_100059184();
                  }
                  goto LABEL_58;
                case 10:
                  v7 = sub_1000263B8((size_t **)(a1 + 184), *((_QWORD *)v9 + 1));
                  if ((v7 & 0x80000000) == 0)
                    goto LABEL_35;
                  if (dword_10008BA20)
                  {
                    v37 = ne_log_obj(v7);
                    if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
                      sub_10005912C();
                  }
                  goto LABEL_58;
                case 13:
                  v7 = sub_10003F06C(*((_QWORD *)v9 + 1));
                  v12 = v7;
                  if (*(_DWORD *)(*(_QWORD *)(a1 + 64) + 176) && (v7 = sub_10003F41C(v7), (_DWORD)v7))
                  {
                    sub_10003FC4C(a1, v12);
                  }
                  else
                  {
                    switch(v12)
                    {
                      case 16:
                        v13 = *(int **)(a1 + 408);
                        v14 = *v13 | 1;
                        goto LABEL_25;
                      case 17:
                        v13 = *(int **)(a1 + 408);
                        v14 = *v13 | 2;
LABEL_25:
                        *v13 = v14;
                        break;
                      case 18:
                        v7 = sub_1000151DC(*((_QWORD *)v9 + 1));
                        if ((v7 & 0x80000000) != 0)
                        {
                          if (dword_10008BA20)
                          {
                            v15 = ne_log_obj(v7);
                            v7 = os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG);
                            if ((_DWORD)v7)
                              sub_100059234(&v39, v40);
                          }
                          *(_DWORD *)(a1 + 100) = 1;
                        }
                        break;
                      case 19:
                        if (*(_DWORD *)(*(_QWORD *)(a1 + 64) + 208))
                        {
                          *(_DWORD *)(a1 + 368) = 1;
                          if (dword_10008BA20)
                          {
                            v16 = ne_log_obj(v7);
                            v7 = os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG);
                            if ((_DWORD)v7)
                              sub_100059208(&v41, v42);
                          }
                        }
                        break;
                      default:
                        break;
                    }
                  }
LABEL_35:
                  v17 = v9[16];
                  v9 += 16;
                  v8 = v17;
                  if (!v17)
                    break;
                  continue;
                default:
                  if (dword_10008BA20)
                  {
                    v33 = ne_log_obj(v7);
                    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
                      sub_100058F3C();
                  }
                  goto LABEL_58;
              }
              break;
            }
          }
          if (*(_QWORD *)(a1 + 160) && *(_QWORD *)(a1 + 184))
          {
            v21 = sub_10000F9F8(a1);
            if ((_DWORD)v21)
            {
              if (dword_10008BA20)
              {
                v22 = ne_log_obj(v21);
                if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
                  sub_1000590D4();
              }
            }
            else
            {
              if ((*(_BYTE *)(a1 + 96) & 1) != 0)
              {
                if (dword_10008BA20)
                {
                  v30 = ne_log_obj(v21);
                  if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
                  {
                    v31 = sub_10003EDD8(**(_DWORD **)(a1 + 88));
                    *(_DWORD *)buf = 136315138;
                    v44 = v31;
                    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "Selected NAT-T version: %s\n", buf, 0xCu);
                  }
                }
                sub_10004E490(a1);
              }
              v32 = sub_10000ABC8(*(unint64_t **)(a1 + 336), (_QWORD *)a1);
              if ((v32 & 0x80000000) == 0)
              {
                sub_10002CACC(a1);
                sub_100003774(v3, 5505);
                sub_10003F318(v5);
                return 0;
              }
              if (dword_10008BA20)
              {
                v38 = ne_log_obj(v32);
                if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
                  sub_100058FCC();
              }
            }
          }
          else if (dword_10008BA20)
          {
            v24 = ne_log_obj(v7);
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
              sub_100058FA0();
          }
        }
      }
      else if (dword_10008BA20)
      {
        v20 = ne_log_obj(v4);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          sub_1000592B8();
      }
LABEL_58:
      sub_10003F318(v5);
    }
    else if (dword_10008BA20)
    {
      v19 = ne_log_obj(0);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        sub_100058EE4();
    }
  }
  else if (dword_10008BA20)
  {
    v18 = ne_log_obj(a1);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      sub_100058E84();
  }
  v25 = *(_QWORD **)(a1 + 336);
  if (v25)
  {
    sub_10003F318(v25);
    *(_QWORD *)(a1 + 336) = 0;
  }
  v26 = *(_QWORD **)(a1 + 160);
  if (v26)
  {
    sub_10003F318(v26);
    *(_QWORD *)(a1 + 160) = 0;
  }
  v27 = *(_QWORD **)(a1 + 184);
  if (v27)
  {
    sub_10003F318(v27);
    *(_QWORD *)(a1 + 184) = 0;
  }
  v28 = *(_QWORD **)(a1 + 320);
  if (v28)
  {
    sub_10003F318(v28);
    *(_QWORD *)(a1 + 320) = 0;
  }
  sub_10002BC70(*(_QWORD **)(a1 + 304));
  *(_QWORD *)(a1 + 304) = 0;
  return 0xFFFFFFFFLL;
}

uint64_t sub_100013F18(uint64_t a1, uint64_t a2)
{
  int *v2;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  char v15;
  NSObject *v16;
  NSObject *v17;
  NSObject *v18;
  NSObject *v19;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  _QWORD *v25;
  NSObject *v26;
  uint64_t v27;
  _QWORD *v29;
  NSObject *v30;
  uint64_t v31;
  _QWORD *v32;
  _QWORD *v33;
  NSObject *v34;
  _QWORD *v35;
  _QWORD *v36;
  _QWORD *v37;
  NSObject *v38;
  NSObject *v39;
  int v40;
  uint64_t **v41;
  uint64_t v42;
  uint64_t v43;
  BOOL v44;
  NSObject *v45;
  _QWORD *v46;
  _QWORD *v47;
  _QWORD *v48;
  _QWORD *v49;
  _QWORD *v50;
  uint64_t v51;
  int v52;
  NSObject *v53;
  _QWORD *v54;
  NSObject *v55;
  _QWORD *v56;
  _QWORD *v57;
  _QWORD *v58;
  int v59;
  NSObject *v60;
  _QWORD *v61;
  _QWORD *v62;
  _QWORD *v63;
  uint64_t v64;
  int v65;
  _QWORD *v66;
  int v67;
  uint64_t v68;
  uint64_t v69;
  _QWORD *v70;
  uint64_t v71;
  unint64_t v72;
  uint64_t v73;
  NSObject *v74;
  NSObject *v75;
  NSObject *v76;
  NSObject *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint8_t v81[16];
  uint8_t buf[8];
  uint64_t **v83;

  v83 = 0;
  v2 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) != 5505)
  {
    if (dword_10008BA20)
    {
      v16 = ne_log_obj(a1);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        sub_100058E84();
    }
    return 0xFFFFFFFFLL;
  }
  sub_100026198((_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56));
  v5 = sub_10000FFE8(a1);
  if ((v5 & 0x80000000) != 0)
  {
    if (dword_10008BA20)
    {
      v17 = ne_log_obj(v5);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        sub_100058C18();
    }
    return 0xFFFFFFFFLL;
  }
  v6 = sub_1000297D4(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 192), (size_t **)(a1 + 152), (_QWORD *)(a1 + 136));
  if ((v6 & 0x80000000) != 0)
  {
    if (dword_10008BA20)
    {
      v18 = ne_log_obj(v6);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        sub_100058C9C();
    }
    return 0xFFFFFFFFLL;
  }
  v7 = sub_100006C70(*(_DWORD *)(*(_QWORD *)(a1 + 64) + 140));
  *(_QWORD *)(a1 + 176) = v7;
  if (!v7)
  {
    if (dword_10008BA20)
    {
      v19 = ne_log_obj(0);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        sub_100058CC8();
    }
    return 0xFFFFFFFFLL;
  }
  v8 = sub_1000295D8(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 64), *(_QWORD **)(a1 + 160), (_QWORD **)(a1 + 168), (_QWORD *)(a1 + 136));
  if ((v8 & 0x80000000) != 0)
  {
    if (dword_10008BA20)
    {
      v20 = ne_log_obj(v8);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        sub_100058FF8();
    }
    return 0xFFFFFFFFLL;
  }
  v9 = sub_10002CDB4(a1);
  if ((v9 & 0x80000000) != 0)
  {
    if (dword_10008BA20)
    {
      v21 = ne_log_obj(v9);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        sub_100059024();
    }
    return 0xFFFFFFFFLL;
  }
  v10 = sub_10002D170(a1);
  if ((v10 & 0x80000000) != 0)
  {
    if (dword_10008BA20)
    {
      v22 = ne_log_obj(v10);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        sub_100059050();
    }
    return 0xFFFFFFFFLL;
  }
  v11 = sub_10002D418((_QWORD *)a1);
  if ((v11 & 0x80000000) != 0)
  {
    if (dword_10008BA20)
    {
      v23 = ne_log_obj(v11);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        sub_10005907C();
    }
    return 0xFFFFFFFFLL;
  }
  v12 = sub_10002D814(a1);
  if ((v12 & 0x80000000) != 0)
  {
    if (dword_10008BA20)
    {
      v24 = ne_log_obj(v12);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        sub_1000590A8();
    }
    return 0xFFFFFFFFLL;
  }
  if (dword_10008BA20)
  {
    v13 = ne_log_obj(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      sub_100059724();
  }
  v14 = sub_10002A470(a1, 1);
  *(_QWORD *)(a1 + 256) = v14;
  if (!v14)
  {
    if (dword_10008BA20)
    {
      v26 = ne_log_obj(0);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        sub_1000595F0();
    }
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)(*(_QWORD *)(a1 + 64) + 120))
  {
    v14 = sub_10002CBE8(*(_DWORD *)(*(_QWORD *)(a1 + 72) + 48));
    if ((_DWORD)v14)
    {
      v14 = (uint64_t)sub_10002C9DC(a1);
      if (v14)
      {
        v79 = v14;
        v15 = 0;
        goto LABEL_46;
      }
      if (dword_10008BA20)
      {
        v38 = ne_log_obj(0);
        if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
          sub_1000596F8();
      }
      return 0xFFFFFFFFLL;
    }
  }
  v79 = 0;
  v15 = 1;
LABEL_46:
  if ((*(_BYTE *)(a1 + 96) & 1) != 0)
  {
    v29 = sub_10003EFDC(**(unsigned int **)(a1 + 88));
    v80 = (uint64_t)v29;
    if (dword_10008BA20)
    {
      v30 = ne_log_obj(v29);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "Adding remote and local NAT-D payloads.\n", buf, 2u);
      }
    }
    v31 = sub_10003F42C(a1, *(_QWORD *)(a1 + 48));
    if (v31)
    {
      v25 = (_QWORD *)v31;
      v14 = sub_10003F42C(a1, *(_QWORD *)(a1 + 56));
      v78 = v14;
      if (v14)
        goto LABEL_58;
      if (dword_10008BA20)
      {
        v45 = ne_log_obj(0);
        v35 = (_QWORD *)v80;
        if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
          sub_100059498((const sockaddr **)(a1 + 56));
        v36 = 0;
        v37 = 0;
LABEL_96:
        v46 = 0;
        v32 = 0;
        v33 = 0;
LABEL_155:
        v27 = 0xFFFFFFFFLL;
        v54 = (_QWORD *)v79;
        goto LABEL_160;
      }
      v36 = 0;
      v37 = 0;
    }
    else
    {
      if (dword_10008BA20)
      {
        v34 = ne_log_obj(0);
        v35 = (_QWORD *)v80;
        if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
          sub_100059498((const sockaddr **)(a1 + 48));
        v36 = 0;
        v37 = 0;
        v25 = 0;
        goto LABEL_96;
      }
      v36 = 0;
      v37 = 0;
      v25 = 0;
    }
    v46 = 0;
    v32 = 0;
    v33 = 0;
    goto LABEL_104;
  }
  v80 = 0;
  v25 = 0;
  v78 = 0;
LABEL_58:
  if (*(_DWORD *)(a1 + 368) && *(_DWORD *)(*(_QWORD *)(a1 + 64) + 208))
  {
    v14 = (uint64_t)sub_10003EFDC(19);
    v32 = (_QWORD *)v14;
  }
  else
  {
    v32 = 0;
  }
  if (*(_DWORD *)(a1 + 100))
  {
    v14 = (uint64_t)sub_10003EFDC(18);
    if (v14)
    {
      v14 = (uint64_t)sub_100015718((void **)v14, 0x80000000);
      v33 = (_QWORD *)v14;
    }
    else
    {
      v33 = 0;
    }
    if (v33 || !dword_10008BA20)
      goto LABEL_78;
    v39 = ne_log_obj(v14);
    v14 = os_log_type_enabled(v39, OS_LOG_TYPE_ERROR);
    if ((_DWORD)v14)
      sub_1000596CC();
  }
  v33 = 0;
LABEL_78:
  v40 = *(_DWORD *)(*(_QWORD *)(a1 + 72) + 48);
  if (*(_QWORD *)(*(_QWORD *)(a1 + 64) + 272) && v40 == 65001)
  {
    v41 = 0;
    goto LABEL_114;
  }
  v41 = 0;
  if (v40 <= 64221)
  {
    if (v40 == 1)
    {
LABEL_97:
      v47 = sub_10002662C(0, *(_QWORD *)(a1 + 344), 1);
      v48 = sub_10002662C(v47, *(_QWORD *)(a1 + 152), 4);
      v49 = sub_10002662C(v48, *(_QWORD *)(a1 + 176), 10);
      v50 = sub_10002662C(v49, *(_QWORD *)(a1 + 312), 5);
      v51 = *(_QWORD *)(a1 + 256);
      v52 = 8;
LABEL_112:
      v14 = (uint64_t)sub_10002662C(v50, v51, v52);
      v41 = (uint64_t **)v14;
      v83 = (uint64_t **)v14;
      if ((v15 & 1) == 0)
      {
        v14 = (uint64_t)sub_10002662C((_QWORD *)v14, v79, 7);
        v41 = (uint64_t **)v14;
        v83 = (uint64_t **)v14;
      }
LABEL_114:
      v59 = **(_DWORD **)(a1 + 408);
      if ((v59 & 1) == 0)
      {
        v36 = 0;
        goto LABEL_121;
      }
      if (dword_10008BA20)
      {
        v60 = ne_log_obj(v14);
        if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)v81 = 0;
          _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "Adding xauth VID payload.\n", v81, 2u);
        }
      }
      v61 = sub_10003EFDC(16);
      if (v61)
      {
        v36 = v61;
        v41 = (uint64_t **)sub_10002662C(v41, (uint64_t)v61, 13);
        v83 = v41;
        v59 = **(_DWORD **)(a1 + 408);
LABEL_121:
        if ((v59 & 2) == 0)
        {
          v37 = 0;
          goto LABEL_125;
        }
        v62 = sub_10003EFDC(17);
        if (v62)
        {
          v37 = v62;
          v41 = (uint64_t **)sub_10002662C(v41, (uint64_t)v62, 13);
          v83 = v41;
LABEL_125:
          if (v80)
          {
            v63 = sub_10002662C(v41, v80, 13);
            v64 = *(_QWORD *)(a1 + 88);
            v65 = *(unsigned __int16 *)(v64 + 14);
            if (*(_DWORD *)v64 == 14)
            {
              v66 = sub_10002662C(v63, v78, v65);
              v67 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 88) + 14);
              v68 = (uint64_t)v25;
            }
            else
            {
              v66 = sub_10002662C(v63, (uint64_t)v25, v65);
              v67 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 88) + 14);
              v68 = v78;
            }
            v41 = (uint64_t **)sub_10002662C(v66, v68, v67);
            v83 = v41;
          }
          if (v33)
          {
            v41 = (uint64_t **)sub_10002662C(v41, (uint64_t)v33, 13);
            v83 = v41;
          }
          if (v32)
            v83 = (uint64_t **)sub_10002662C(v41, (uint64_t)v32, 13);
          *(_QWORD *)(a1 + 128) = sub_100026684(&v83, a1);
          *(_DWORD *)(a1 + 124) = *(_DWORD *)(*(_QWORD *)(a1 + 64) + 200);
          v69 = sub_100024360(a1);
          if ((_DWORD)v69 == -1)
          {
            if (dword_10008BA20)
            {
              v74 = ne_log_obj(v69);
              v35 = (_QWORD *)v80;
              v46 = (_QWORD *)v78;
              if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
                sub_100058CF4();
              goto LABEL_155;
            }
          }
          else
          {
            v70 = *(_QWORD **)(a1 + 128);
            if (*(_DWORD *)(a1 + 100) && *v70 >= 0x501uLL)
            {
              v71 = 0;
              LODWORD(v72) = *(_DWORD *)(a1 + 96);
            }
            else
            {
              v72 = *(unsigned int *)(a1 + 96);
              v71 = (v72 >> 3) & 4;
            }
            v73 = sub_100009B6C(*(unsigned __int8 **)(a1 + 48), *(unsigned __int8 **)(a1 + 56), (uint64_t)v70, a2, v71, (v72 >> 5) & 1);
            if ((_DWORD)v73 != -1)
            {
              sub_100003774(v2, 5538);
              sub_100048B0C(1, 0, a1, 0);
              v27 = 0;
LABEL_159:
              v54 = (_QWORD *)v79;
              v35 = (_QWORD *)v80;
              v46 = (_QWORD *)v78;
              goto LABEL_160;
            }
            if (dword_10008BA20)
            {
              v76 = ne_log_obj(v73);
              v35 = (_QWORD *)v80;
              v46 = (_QWORD *)v78;
              if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
                sub_10005961C();
              goto LABEL_155;
            }
          }
LABEL_158:
          v27 = 0xFFFFFFFFLL;
          goto LABEL_159;
        }
        if (dword_10008BA20)
        {
          v77 = ne_log_obj(0);
          v35 = (_QWORD *)v80;
          v46 = (_QWORD *)v78;
          if (os_log_type_enabled(v77, OS_LOG_TYPE_ERROR))
            sub_100059648();
          goto LABEL_154;
        }
LABEL_157:
        v37 = 0;
        goto LABEL_158;
      }
      if (dword_10008BA20)
      {
        v75 = ne_log_obj(0);
        v35 = (_QWORD *)v80;
        v46 = (_QWORD *)v78;
        if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
          sub_100059674();
LABEL_147:
        v36 = 0;
LABEL_154:
        v37 = 0;
        goto LABEL_155;
      }
LABEL_156:
      v36 = 0;
      goto LABEL_157;
    }
    if (v40 != 3)
      goto LABEL_114;
  }
  else if (v40 != 64222 && v40 != 65006)
  {
    if (v40 != 65002)
      goto LABEL_114;
    goto LABEL_97;
  }
  v42 = sub_10002B67C(a1);
  if ((v42 & 0x80000000) != 0)
  {
    if (dword_10008BA20)
    {
      v53 = ne_log_obj(v42);
      v35 = (_QWORD *)v80;
      v46 = (_QWORD *)v78;
      if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
        sub_1000596A0();
      goto LABEL_147;
    }
    goto LABEL_156;
  }
  v43 = sub_10002B990((_QWORD *)a1);
  if ((v43 & 0x80000000) == 0)
  {
    if (*(_QWORD *)(a1 + 280))
      v44 = *(_DWORD *)(*(_QWORD *)(a1 + 64) + 116) == 0;
    else
      v44 = 1;
    v56 = sub_10002662C(0, *(_QWORD *)(a1 + 344), 1);
    v57 = sub_10002662C(v56, *(_QWORD *)(a1 + 152), 4);
    v58 = sub_10002662C(v57, *(_QWORD *)(a1 + 176), 10);
    v50 = sub_10002662C(v58, *(_QWORD *)(a1 + 312), 5);
    if (!v44)
      v50 = sub_10002662C(v50, *(_QWORD *)(*(_QWORD *)(a1 + 280) + 24), 6);
    v51 = *(_QWORD *)(a1 + 264);
    v52 = 9;
    goto LABEL_112;
  }
  v46 = (_QWORD *)v78;
  if (dword_10008BA20)
  {
    v55 = ne_log_obj(v43);
    v35 = (_QWORD *)v80;
    if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
      sub_10005952C();
    goto LABEL_147;
  }
  v36 = 0;
  v37 = 0;
LABEL_104:
  v27 = 0xFFFFFFFFLL;
  v54 = (_QWORD *)v79;
  v35 = (_QWORD *)v80;
LABEL_160:
  if (v54)
    sub_10003F318(v54);
  if (v36)
    sub_10003F318(v36);
  if (v37)
    sub_10003F318(v37);
  if (v35)
    sub_10003F318(v35);
  if (v25)
    sub_10003F318(v25);
  if (v46)
    sub_10003F318(v46);
  if (v32)
    sub_10003F318(v32);
  if (v33)
    sub_10003F318(v33);
  return v27;
}

uint64_t sub_100014964(uint64_t a1, _QWORD *a2)
{
  int *v3;
  _QWORD *v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  unsigned __int8 *v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  NSObject *v16;
  const char *v17;
  NSObject *v18;
  char v19;
  NSObject *v20;
  const char *v21;
  int v22;
  const char *v23;
  const char *v24;
  _QWORD *v25;
  uint64_t v26;
  NSObject *v27;
  NSObject *v28;
  NSObject *v29;
  NSObject *v30;
  NSObject *v31;
  _QWORD *v32;
  _QWORD *v34;
  void *v35;
  uint8_t buf[4];
  _BYTE v37[18];
  __int16 v38;
  const char *v39;

  v3 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) != 5538)
  {
    if (dword_10008BA20)
    {
      v5 = ne_log_obj(a1);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_100058E84();
    }
    goto LABEL_7;
  }
  if ((*(_BYTE *)(a2[1] + 19) & 1) != 0)
  {
    v4 = sub_10002E000(a1, a2, **(_QWORD **)(a1 + 328), *(_QWORD *)(*(_QWORD *)(a1 + 328) + 8));
    if (v4)
      goto LABEL_9;
    if (dword_10008BA20)
    {
      v27 = ne_log_obj(0);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        sub_1000597D8();
    }
LABEL_7:
    v6 = 0xFFFFFFFFLL;
    goto LABEL_77;
  }
  v4 = sub_10003F34C((uint64_t)a2);
LABEL_9:
  v7 = (uint64_t)sub_1000232C8((uint64_t)v4);
  if (!v7)
  {
    if (dword_10008BA20)
    {
      v18 = ne_log_obj(0);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        sub_100058EE4();
    }
    v19 = 0;
    v6 = 0xFFFFFFFFLL;
    if (v4)
      goto LABEL_75;
    goto LABEL_76;
  }
  v8 = 0;
  v9 = 0;
  *(_QWORD *)(a1 + 352) = 0;
  v34 = (_QWORD *)v7;
  v10 = *(unsigned __int8 **)(v7 + 8);
  while (2)
  {
    v11 = *v10;
    switch(*v10)
    {
      case 6u:
        v7 = sub_10002C614(a1, *((_QWORD *)v10 + 1));
        if ((v7 & 0x80000000) == 0)
        {
          v9 = 1;
          goto LABEL_32;
        }
        if (!dword_10008BA20)
          goto LABEL_73;
        v29 = ne_log_obj(v7);
        v25 = v34;
        if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
          sub_100059754();
        goto LABEL_69;
      case 7u:
      case 0xAu:
      case 0xCu:
      case 0xEu:
      case 0xFu:
      case 0x10u:
      case 0x11u:
      case 0x12u:
      case 0x13u:
        goto LABEL_58;
      case 8u:
        *(_QWORD *)(a1 + 352) = *((_QWORD *)v10 + 1);
        goto LABEL_32;
      case 9u:
        v7 = sub_1000263B8((size_t **)(a1 + 272), *((_QWORD *)v10 + 1));
        if ((v7 & 0x80000000) == 0)
          goto LABEL_32;
        if (!dword_10008BA20)
          goto LABEL_73;
        v30 = ne_log_obj(v7);
        v25 = v34;
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
          sub_100059780();
        goto LABEL_69;
      case 0xBu:
        sub_10001BBF4(*((_QWORD *)v10 + 1), a1);
        goto LABEL_32;
      case 0xDu:
        v7 = sub_10003F06C(*((_QWORD *)v10 + 1));
        goto LABEL_32;
      case 0x14u:
        goto LABEL_15;
      default:
        if (v11 == 130)
        {
LABEL_15:
          if ((*(_BYTE *)(a1 + 96) & 1) != 0)
          {
            v12 = *(_QWORD *)(a1 + 88);
            if (v12)
            {
              if (*(unsigned __int16 *)(v12 + 14) == v11)
              {
                v35 = 0;
                v13 = sub_1000263B8((size_t **)&v35, *((_QWORD *)v10 + 1));
                if ((v13 & 0x80000000) != 0)
                {
                  if (dword_10008BA20)
                  {
                    v31 = ne_log_obj(v13);
                    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
                      sub_1000597AC();
                  }
LABEL_73:
                  v19 = 0;
                  v6 = 0xFFFFFFFFLL;
                  v25 = v34;
                  goto LABEL_74;
                }
                if (!v8)
                  *(_DWORD *)(a1 + 96) |= 6u;
                v14 = sub_10003F610(a1, (uint64_t)v35, v8);
                if (dword_10008BA20)
                {
                  v15 = v14;
                  v16 = ne_log_obj(v14);
                  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 67109378;
                    v17 = "verified";
                    if (!v15)
                      v17 = "doesn't match";
                    *(_DWORD *)v37 = v8;
                    *(_WORD *)&v37[4] = 2080;
                    *(_QWORD *)&v37[6] = v17;
                    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "NAT-D payload #%d %s\n", buf, 0x12u);
                  }
                }
                ++v8;
                sub_10003F318(v35);
              }
            }
          }
LABEL_32:
          v10 += 16;
          continue;
        }
        if (*v10)
        {
LABEL_58:
          if (!dword_10008BA20)
            goto LABEL_73;
          v28 = ne_log_obj(v7);
          v25 = v34;
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
            sub_100058F3C();
        }
        else
        {
          if ((*(_BYTE *)(a1 + 96) & 1) != 0)
          {
            if (dword_10008BA20)
            {
              v20 = ne_log_obj(v7);
              if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
              {
                v21 = "detected:";
                v22 = *(_DWORD *)(a1 + 96);
                v23 = "ME ";
                if ((v22 & 6) == 0)
                  v21 = "not detected";
                if ((v22 & 2) == 0)
                  v23 = (const char *)&unk_10007E079;
                *(_DWORD *)buf = 136315650;
                *(_QWORD *)v37 = v21;
                *(_WORD *)&v37[8] = 2080;
                *(_QWORD *)&v37[10] = v23;
                if ((v22 & 4) != 0)
                  v24 = "PEER";
                else
                  v24 = (const char *)&unk_10007E079;
                v38 = 2080;
                v39 = v24;
                _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "NAT %s %s%s\n", buf, 0x20u);
              }
            }
          }
          v25 = v34;
          if (v9)
            sub_10002BBF4((_QWORD *)a1);
          v26 = sub_10002AC24(a1);
          v6 = v26;
          if ((_DWORD)v26 == -1)
          {
            v19 = 0;
            goto LABEL_74;
          }
          if (!(_DWORD)v26)
          {
            sub_100003774(v3, 5507);
            v19 = 1;
            goto LABEL_74;
          }
          sub_10001B184(a1, v26, 0);
        }
LABEL_69:
        v19 = 0;
        v6 = 0xFFFFFFFFLL;
LABEL_74:
        sub_10003F318(v25);
        if (v4)
LABEL_75:
          sub_10003F318(v4);
LABEL_76:
        if ((v19 & 1) == 0)
        {
LABEL_77:
          sub_10002BC70(*(_QWORD **)(a1 + 288));
          *(_QWORD *)(a1 + 288) = 0;
          sub_10002BC70(*(_QWORD **)(a1 + 296));
          *(_QWORD *)(a1 + 296) = 0;
          v32 = *(_QWORD **)(a1 + 272);
          if (v32)
          {
            sub_10003F318(v32);
            *(_QWORD *)(a1 + 272) = 0;
          }
        }
        return v6;
    }
  }
}

uint64_t sub_100014E98(uint64_t a1, uint64_t a2)
{
  int *v2;
  NSObject *v5;

  v2 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) == 5507)
  {
    if ((*(_BYTE *)(*(_QWORD *)(a2 + 8) + 19) & 1) != 0)
      memcpy(*(void **)(**(_QWORD **)(a1 + 328) + 8), *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 328) + 8) + 8), ***(_QWORD ***)(a1 + 328));
    *(_BYTE *)(a1 + 82) |= 1u;
    sub_100003774(v2, 9216);
    return 0;
  }
  else
  {
    if (dword_10008BA20)
    {
      v5 = ne_log_obj(a1);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_100058E84();
    }
    return 0xFFFFFFFFLL;
  }
}

void sub_100014F40(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

uint64_t *sub_100014F54(const sockaddr **a1)
{
  return sub_10003C570(*a1);
}

void sub_100014F88(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0xEu);
}

uint64_t sub_100014F98(uint64_t a1, unint64_t *a2)
{
  int v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  unint64_t v10;
  _BYTE *v11;
  size_t v12;
  size_t *v13;
  size_t *v14;
  size_t v15;
  size_t *v16;
  size_t *v17;
  _DWORD *v18;
  uint64_t v19;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  NSObject *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char v39;

  v4 = *(_DWORD *)(a1 + 96);
  v5 = sub_100007A38(*(unsigned __int8 **)(a1 + 56));
  if ((_DWORD)v5 == -1)
    return 0xFFFFFFFFLL;
  v6 = *a2;
  if (*a2)
  {
    v7 = v5;
    LODWORD(v8) = 0;
    v9 = v4 & 0x20;
    v10 = (unint64_t)(v4 & 0x20) >> 3;
    v11 = (_BYTE *)a2[1];
    v39 = v11[18];
    while (1)
    {
      v12 = v6 >= 0x4DC ? 1244 : v6;
      v13 = sub_10003F1F8(v12 + 36);
      if (!v13)
        break;
      v14 = v13;
      v8 = (v8 + 1);
      sub_100026520((uint64_t)v13, a1, 132);
      v15 = v14[1];
      *(_BYTE *)(v15 + 18) = v39;
      *(_WORD *)(v15 + 28) = 0;
      *(_WORD *)(v15 + 30) = bswap32(v12 + 8) >> 16;
      *(_WORD *)(v15 + 32) = 256;
      *(_BYTE *)(v15 + 34) = v8;
      *(_BYTE *)(v15 + 35) = v6 < 0x4DD;
      memcpy((void *)(v15 + 36), v11, v12);
      if (v9)
      {
        v16 = sub_10003F1F8(*v14 + v10);
        if (!v16)
        {
          if (dword_10008BA20)
          {
            v30 = ne_log_obj(0);
            if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
              sub_10005990C(v30, v31, v32, v33, v34, v35, v36, v37);
          }
          goto LABEL_27;
        }
        v17 = v16;
        v18 = (_DWORD *)v16[1];
        *v18 = 0;
        memcpy((char *)v18 + v10, (const void *)v14[1], *v14);
        sub_10003F318(v14);
        v14 = v17;
      }
      v19 = sub_10003BDE0(v7, (const void *)v14[1], *v14, *(unsigned __int8 **)(a1 + 56), *(unsigned __int8 **)(a1 + 48), *(_DWORD *)(qword_10008B848 + 276));
      if ((_DWORD)v19 == -1)
      {
        if (dword_10008BA20)
        {
          v22 = ne_log_obj(v19);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
            sub_10005989C(v22, v23, v24, v25, v26, v27, v28, v29);
        }
LABEL_27:
        sub_10003F318(v14);
        return 0xFFFFFFFFLL;
      }
      sub_10003F318(v14);
      v11 += v12;
      v6 -= v12;
      if (!v6)
        goto LABEL_15;
    }
    if (dword_10008BA20)
    {
      v21 = ne_log_obj(0);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        sub_100059870();
    }
    return 0xFFFFFFFFLL;
  }
  v8 = 0;
LABEL_15:
  if (dword_10008BA20)
  {
    v20 = ne_log_obj(v5);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      sub_100059804();
  }
  return v8;
}

uint64_t sub_1000151DC(uint64_t a1)
{
  return bswap32(*(_DWORD *)(a1 + (((uint64_t)(int)sub_100006C68() >> 3) & 0xFFFFFFFFFFFFFFFCLL) + 4));
}

uint64_t sub_100015210(uint64_t a1, _QWORD *a2)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  NSObject *v6;
  size_t *v8;
  size_t *v9;
  _OWORD *v10;
  _QWORD *v11;
  uint64_t result;
  uint64_t v13;
  int v14;
  int v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  _QWORD *v20;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  NSObject *v29;
  NSObject *v30;
  int v31;
  int v32;
  int v33;
  const char *v34;
  __int16 v35;
  int v36;
  __int16 v37;
  int v38;
  __int16 v39;
  int v40;

  if (*a2 <= 0x23uLL)
  {
    if (dword_10008BA20)
    {
      v2 = ne_log_obj(a1);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_10005997C();
    }
    return 0xFFFFFFFFLL;
  }
  v3 = a2[1];
  v4 = bswap32(*(unsigned __int16 *)(v3 + 30)) >> 16;
  if (*a2 < (unint64_t)(v4 + 28) || v4 <= 8)
  {
    if (dword_10008BA20)
    {
      v6 = ne_log_obj(a1);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        sub_1000599A8();
    }
    return 0xFFFFFFFFLL;
  }
  v8 = sub_10003F1F8(v4 - 8);
  if (!v8)
  {
    if (dword_10008BA20)
    {
      v29 = ne_log_obj(0);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        sub_100059870();
    }
    return 0xFFFFFFFFLL;
  }
  v9 = v8;
  v10 = malloc_type_malloc(0x20uLL, 0x102004035CFEAE3uLL);
  if (!v10)
  {
    if (dword_10008BA20)
    {
      v30 = ne_log_obj(0);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        sub_100059870();
    }
    sub_10003F318(v9);
    return 0xFFFFFFFFLL;
  }
  v11 = v10;
  *v10 = 0u;
  v10[1] = 0u;
  result = (uint64_t)memcpy((void *)v9[1], (const void *)(v3 + 36), *v9);
  v14 = *(unsigned __int8 *)(v3 + 34);
  v13 = v3 + 34;
  *(_DWORD *)v11 = v14;
  v15 = *(_BYTE *)(v13 + 1) & 1;
  *((_DWORD *)v11 + 1) = v15;
  v11[2] = 0;
  v11[3] = v9;
  *((_WORD *)v11 + 4) = bswap32(*(unsigned __int16 *)(v13 - 2)) >> 16;
  if (!dword_10008BA20
    || (v16 = ne_log_obj(result),
        result = os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG),
        v15 = *((_DWORD *)v11 + 1),
        !(_DWORD)result))
  {
    if (!v15)
      goto LABEL_18;
    goto LABEL_17;
  }
  v31 = *(_DWORD *)v11;
  v32 = *((unsigned __int16 *)v11 + 4);
  v33 = 136315906;
  v34 = "isakmp_frag_extract";
  v35 = 1024;
  v36 = v31;
  v37 = 1024;
  v38 = v32;
  v39 = 1024;
  v40 = v15;
  _os_log_debug_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "%s: received fragment #%d  frag ID=%d  last frag=%d\n", (uint8_t *)&v33, 0x1Eu);
  v15 = *((_DWORD *)v11 + 1);
  if (v15)
LABEL_17:
    v15 = *(_DWORD *)v11;
LABEL_18:
  v17 = *(_QWORD *)(a1 + 104);
  if (v17)
  {
    v18 = *(_QWORD *)(a1 + 104);
    while (*(_DWORD *)v18 != *(_DWORD *)v11)
    {
      if (*(_DWORD *)(v18 + 4))
        v15 = *(_DWORD *)v18;
      v18 = *(_QWORD *)(v18 + 16);
      if (!v18)
        goto LABEL_24;
    }
    sub_10003F318((_QWORD *)v11[3]);
    free(v11);
    return 0;
  }
LABEL_24:
  v11[2] = v17;
  *(_QWORD *)(a1 + 104) = v11;
  if (!v15)
    return 0;
  if (v15 >= 1)
  {
    v19 = 1;
    do
    {
      v20 = v11;
      while (*(_DWORD *)v20 != v19)
      {
        result = 0;
        v20 = (_QWORD *)v20[2];
        if (!v20)
          return result;
      }
    }
    while (v19++ != v15);
  }
  if (dword_10008BA20)
  {
    v22 = ne_log_obj(result);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
      sub_1000599D4(v13, v22, v23, v24, v25, v26, v27, v28);
  }
  return 1;
}

_QWORD *sub_100015534(uint64_t a1)
{
  uint64_t v2;
  size_t v3;
  int v4;
  int v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  char *v9;
  int v10;
  uint64_t v11;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;

  v2 = *(_QWORD *)(a1 + 104);
  if (!v2)
  {
    if (!dword_10008BA20)
    {
      v8 = 0;
LABEL_34:
      *(_QWORD *)(a1 + 104) = 0;
      return v8;
    }
    v14 = ne_log_obj(a1);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      sub_100059A50();
    goto LABEL_29;
  }
  v3 = 0;
  v4 = 0;
  v5 = 0;
  do
  {
    if (*(_DWORD *)v2 > v5 && *(_DWORD *)(v2 + 4))
      v5 = *(_DWORD *)v2;
    v6 = v2 + 16;
    v2 = *(_QWORD *)(v2 + 16);
    v3 += **(_QWORD **)(v6 + 8);
    ++v4;
  }
  while (v2);
  v7 = sub_10003F1F8(v3);
  if (!v7)
  {
    if (dword_10008BA20)
    {
      v16 = ne_log_obj(0);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        sub_100059870();
    }
LABEL_29:
    v8 = 0;
LABEL_30:
    v17 = *(_QWORD *)(a1 + 104);
    if (v17)
    {
      do
      {
        v18 = *(_QWORD *)(v17 + 16);
        sub_10003F318(*(_QWORD **)(v17 + 24));
        free((void *)v17);
        v17 = v18;
      }
      while (v18);
    }
    goto LABEL_34;
  }
  v8 = v7;
  if (v5 < 1)
  {
LABEL_16:
    if (dword_10008BA20)
    {
      v13 = ne_log_obj(v7);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
        sub_100059A7C();
    }
    goto LABEL_30;
  }
  v9 = (char *)v7[1];
  v10 = 1;
LABEL_10:
  v11 = *(_QWORD *)(a1 + 104);
  do
  {
    if (*(_DWORD *)v11 == v10)
    {
      v7 = memcpy(v9, *(const void **)(*(_QWORD *)(v11 + 24) + 8), **(_QWORD **)(v11 + 24));
      v9 += **(_QWORD **)(v11 + 24);
      if (v10++ == v5)
        goto LABEL_16;
      goto LABEL_10;
    }
    v11 = *(_QWORD *)(v11 + 16);
  }
  while (v11);
  if (dword_10008BA20)
  {
    v15 = ne_log_obj(v7);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      sub_100059AE8(v10, v15);
  }
  sub_10003F318(v8);
  return 0;
}

void **sub_100015718(void **a1, unsigned int a2)
{
  int v4;
  char *v5;
  void **v6;
  NSObject *v8;

  v4 = sub_100006C68();
  v5 = (char *)*a1;
  if (*a1 != (void *)(v4 >> 3))
    goto LABEL_4;
  v6 = sub_10003F270(a1, (size_t)(v5 + 4));
  if (v6)
  {
    a1 = v6;
    *(_DWORD *)&v5[(_QWORD)v6[1]] = 0;
LABEL_4:
    *(_DWORD *)((char *)a1[1] + ((uint64_t)v4 >> 3)) |= bswap32(a2);
    return a1;
  }
  if (dword_10008BA20)
  {
    v8 = ne_log_obj(0);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      sub_100059870();
  }
  return 0;
}

uint64_t sub_1000157C8(uint64_t a1, unint64_t *a2, unsigned __int8 *a3, unsigned __int8 *a4, uint64_t a5, char a6)
{
  unint64_t v6;
  uint64_t v10;
  uint64_t v11;
  int v12;
  char *v13;
  size_t v14;
  size_t *v15;
  size_t *v16;
  size_t v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  unsigned __int8 *v21;
  unsigned __int8 *v22;
  uint64_t v23;
  size_t *v24;
  size_t *v25;
  _DWORD *v26;
  uint64_t v27;
  NSObject *v28;
  NSObject *v29;
  NSObject *v30;
  NSObject *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v40;
  uint64_t v41;
  unsigned int v42;
  char *v43;

  v6 = *a2;
  if (*a2)
  {
    v10 = a1;
    LODWORD(v11) = 0;
    v12 = a6 & 1;
    v41 = (4 * v12);
    v13 = (char *)a2[1];
    v43 = v13;
    v40 = v12;
    while (1)
    {
      v14 = v6 >= 0x4DC ? 1244 : v6;
      v15 = sub_10003F1F8(v14 + 36);
      if (!v15)
        break;
      v16 = v15;
      v11 = (v11 + 1);
      v17 = v15[1];
      v18 = *(_OWORD *)v43;
      v19 = *((_QWORD *)v43 + 2);
      *(_DWORD *)(v17 + 24) = *((_DWORD *)v43 + 6);
      *(_QWORD *)(v17 + 16) = v19;
      *(_OWORD *)v17 = v18;
      *(_DWORD *)(v17 + 24) = bswap32(*(_DWORD *)v15);
      *(_BYTE *)(v17 + 16) = -124;
      *(_WORD *)(v17 + 28) = 0;
      *(_WORD *)(v17 + 30) = bswap32(v14 + 8) >> 16;
      *(_WORD *)(v17 + 32) = 256;
      *(_BYTE *)(v17 + 34) = v11;
      *(_BYTE *)(v17 + 35) = v6 < 0x4DD;
      memcpy((void *)(v17 + 36), v13, v14);
      if (v12)
      {
        v42 = v11;
        v20 = v10;
        v21 = a3;
        v22 = a4;
        v23 = a5;
        v24 = sub_10003F1F8(*v16 + v41);
        if (!v24)
        {
          if (dword_10008BA20)
          {
            v31 = ne_log_obj(0);
            if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
              sub_100059BF0(v31, v32, v33, v34, v35, v36, v37, v38);
          }
          goto LABEL_26;
        }
        v25 = v24;
        v26 = (_DWORD *)v24[1];
        *v26 = 0;
        memcpy((char *)v26 + v41, (const void *)v16[1], *v16);
        sub_10003F318(v16);
        v16 = v25;
        a5 = v23;
        a4 = v22;
        a3 = v21;
        v10 = v20;
        v11 = v42;
        v12 = v40;
      }
      v27 = sub_10003BDE0(v10, (const void *)v16[1], *v16, a3, a4, a5);
      if ((_DWORD)v27 == -1)
      {
        if (dword_10008BA20)
        {
          v30 = ne_log_obj(v27);
          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
            sub_100059BC4();
        }
LABEL_26:
        sub_10003F318(v16);
        return 0xFFFFFFFFLL;
      }
      sub_10003F318(v16);
      v13 += v14;
      v6 -= v14;
      if (!v6)
        goto LABEL_14;
    }
    if (dword_10008BA20)
    {
      v29 = ne_log_obj(0);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        sub_100059870();
    }
    return 0xFFFFFFFFLL;
  }
  else
  {
    v11 = 0;
LABEL_14:
    if (dword_10008BA20)
    {
      v28 = ne_log_obj(a1);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
        sub_100059B58();
    }
  }
  return v11;
}

void sub_100015A44(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 0x12u);
}

void sub_100015A54(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

uint64_t sub_100015A78(uint64_t a1, uint64_t a2)
{
  int *v2;
  NSObject *v3;
  NSObject *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t i;
  _QWORD *v10;
  _QWORD *v13;
  uint64_t **v14;
  uint64_t **v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  BOOL v19;
  BOOL v20;
  BOOL v21;
  _QWORD *v22;
  NSObject *v23;
  NSObject *v24;
  _QWORD *v25;
  NSObject *v26;
  void **v27;
  void **v28;
  NSObject *v29;
  uint64_t v30;
  NSObject *v31;
  uint64_t **v32;
  _OWORD v33[6];

  v32 = 0;
  memset(v33, 0, sizeof(v33));
  v2 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) != 5184)
  {
    if (dword_10008BA20)
    {
      v4 = ne_log_obj(a1);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_100058E84();
    }
    goto LABEL_9;
  }
  if (a2)
  {
    if (dword_10008BA20)
    {
      v3 = ne_log_obj(a1);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        sub_100059CE4();
    }
LABEL_9:
    v5 = 0;
    v6 = 0;
    v7 = 0;
    v8 = 0xFFFFFFFFLL;
    goto LABEL_10;
  }
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  sub_100026198((_QWORD *)a1, *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56));
  v13 = sub_10000EBAC(a1);
  *(_QWORD *)(a1 + 336) = v13;
  if (!v13)
  {
    if (dword_10008BA20)
    {
      v23 = ne_log_obj(0);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        sub_100059C60();
    }
    goto LABEL_9;
  }
  v14 = (uint64_t **)sub_10002662C(0, (uint64_t)v13, 1);
  v15 = v14;
  v32 = v14;
  v16 = *(_QWORD *)(a1 + 64);
  if (*(_DWORD *)(v16 + 176))
  {
    v15 = (uint64_t **)sub_10003FD38(v14, v33);
    v32 = v15;
    v16 = *(_QWORD *)(a1 + 64);
  }
  v17 = *(_QWORD *)(v16 + 272);
  v18 = *(_DWORD *)(*(_QWORD *)(v16 + 248) + 48);
  if (v17 && v18 == 65001
    || ((v18 - 65005) <= 4 ? (v19 = ((1 << (v18 + 19)) & 0x15) == 0) : (v19 = 1),
        v19 ? (v20 = v18 == 65500) : (v20 = 1),
        !v20 ? (v21 = v18 == 64221) : (v21 = 1),
        v21))
  {
    v22 = sub_10003EFDC(16);
    v7 = v22;
    if (v22)
    {
      v15 = (uint64_t **)sub_10002662C(v15, (uint64_t)v22, 13);
      v32 = v15;
    }
    else if (dword_10008BA20)
    {
      v24 = ne_log_obj(0);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        sub_100059CB8();
    }
    v25 = sub_10003EFDC(17);
    if (v25)
    {
      v6 = v25;
      v15 = (uint64_t **)sub_10002662C(v15, (uint64_t)v25, 13);
      v32 = v15;
      goto LABEL_50;
    }
    if (dword_10008BA20)
    {
      v26 = ne_log_obj(0);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        sub_100059C8C();
    }
  }
  else
  {
    v7 = 0;
  }
  v6 = 0;
LABEL_50:
  if (*(_DWORD *)(*(_QWORD *)(a1 + 64) + 148))
  {
    v27 = (void **)sub_10003EFDC(18);
    if (v27)
    {
      v28 = sub_100015718(v27, 0x80000000);
      v15 = (uint64_t **)sub_10002662C(v15, (uint64_t)v28, 13);
      v32 = v15;
      goto LABEL_57;
    }
    if (dword_10008BA20)
    {
      v29 = ne_log_obj(0);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        sub_1000596CC();
    }
  }
  v28 = 0;
LABEL_57:
  if (*(_DWORD *)(*(_QWORD *)(a1 + 64) + 208))
  {
    v5 = sub_10003EFDC(19);
    if (v5)
      v32 = (uint64_t **)sub_10002662C(v15, (uint64_t)v5, 13);
  }
  else
  {
    v5 = 0;
  }
  *(_QWORD *)(a1 + 128) = sub_100026684(&v32, a1);
  *(_DWORD *)(a1 + 124) = *(_DWORD *)(*(_QWORD *)(a1 + 64) + 200);
  v30 = sub_100024360(a1);
  if ((_DWORD)v30 != -1)
  {
    sub_100003774(v2, 5217);
    v8 = 0;
    if (!v28)
      goto LABEL_10;
    goto LABEL_68;
  }
  if (dword_10008BA20)
  {
    v31 = ne_log_obj(v30);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      sub_100058CF4();
  }
  v8 = 0xFFFFFFFFLL;
  if (v28)
LABEL_68:
    sub_10003F318(v28);
LABEL_10:
  for (i = 0; i != 96; i += 8)
  {
    v10 = *(_QWORD **)((char *)v33 + i);
    if (!v10)
      break;
    sub_10003F318(v10);
  }
  if (v7)
    sub_10003F318(v7);
  if (v6)
    sub_10003F318(v6);
  if (v5)
    sub_10003F318(v5);
  return v8;
}

uint64_t sub_100015E94(uint64_t a1, uint64_t a2)
{
  int *v2;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t i;
  int v9;
  int *v10;
  int v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;
  uint64_t v15;
  NSObject *v16;
  NSObject *v17;
  __int128 *v18;
  uint64_t v19;
  _QWORD *v20;
  NSObject *v21;
  NSObject *v22;
  NSObject *v23;
  uint8_t v25;
  _BYTE v26[7];
  void *v27;
  uint8_t buf[4];
  __int128 *v29;

  v27 = 0;
  v2 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) != 5217)
  {
    if (dword_10008BA20)
    {
      v13 = ne_log_obj(a1);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        sub_100058E84();
    }
    goto LABEL_28;
  }
  v4 = sub_1000232C8(a2);
  if (!v4)
  {
    if (dword_10008BA20)
    {
      v14 = ne_log_obj(0);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        sub_100058EE4();
    }
LABEL_28:
    v15 = 0xFFFFFFFFLL;
    goto LABEL_53;
  }
  v5 = v4;
  v6 = v4[1];
  if (*(_BYTE *)v6 == 1)
  {
    v7 = sub_1000263B8((size_t **)&v27, *(_QWORD *)(v6 + 8));
    if ((v7 & 0x80000000) != 0)
    {
      if (dword_10008BA20)
      {
        v21 = ne_log_obj(v7);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          sub_100058F10();
      }
    }
    else
    {
      for (i = v6 + 16; *(_BYTE *)i == 13; i += 16)
      {
        v7 = sub_10003F06C(*(_QWORD *)(i + 8));
        v9 = v7;
        if (*(_DWORD *)(*(_QWORD *)(a1 + 64) + 176))
        {
          v7 = sub_10003F41C(v7);
          if ((_DWORD)v7)
            sub_10003FC4C(a1, v9);
        }
        switch(v9)
        {
          case 16:
            v10 = *(int **)(a1 + 408);
            v11 = *v10 | 1;
            goto LABEL_13;
          case 17:
            v10 = *(int **)(a1 + 408);
            v11 = *v10 | 2;
LABEL_13:
            *v10 = v11;
            break;
          case 18:
            v7 = sub_1000151DC(*(_QWORD *)(i + 8));
            if ((v7 & 0x80000000) != 0)
            {
              if (dword_10008BA20)
              {
                v12 = ne_log_obj(v7);
                v7 = os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG);
                if ((_DWORD)v7)
                  sub_100059D70(&v25, v26, v12);
              }
              *(_DWORD *)(a1 + 100) = 1;
            }
            break;
          case 19:
            if (*(_DWORD *)(*(_QWORD *)(a1 + 64) + 208))
              *(_DWORD *)(a1 + 368) = 1;
            break;
          default:
            continue;
        }
      }
      if (*(_BYTE *)i)
      {
        if (dword_10008BA20)
        {
          v22 = ne_log_obj(v7);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
            sub_100059D10();
        }
      }
      else
      {
        if ((*(_BYTE *)(a1 + 96) & 1) != 0)
        {
          if (dword_10008BA20)
          {
            v17 = ne_log_obj(v7);
            if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
            {
              v18 = sub_10003EDD8(**(_DWORD **)(a1 + 88));
              *(_DWORD *)buf = 136315138;
              v29 = v18;
              _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Selected NAT-T version: %s\n", buf, 0xCu);
            }
          }
          sub_10004E490(a1);
        }
        v19 = sub_10000ABC8((unint64_t *)v27, (_QWORD *)a1);
        if ((v19 & 0x80000000) == 0)
        {
          v20 = *(_QWORD **)(a1 + 344);
          if (v20)
          {
            sub_10003F318(v20);
            *(_QWORD *)(a1 + 344) = 0;
          }
          sub_100003774(v2, 5186);
          sub_100048B0C(1, 1, a1, 0);
          v15 = 0;
          goto LABEL_52;
        }
        if (dword_10008BA20)
        {
          v23 = ne_log_obj(v19);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
            sub_100058FCC();
        }
      }
    }
  }
  else if (dword_10008BA20)
  {
    v16 = ne_log_obj(v4);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      sub_1000592B8();
  }
  v15 = 0xFFFFFFFFLL;
LABEL_52:
  sub_10003F318(v5);
LABEL_53:
  if (v27)
    sub_10003F318(v27);
  return v15;
}

uint64_t sub_10001623C(uint64_t a1, uint64_t a2)
{
  int *v2;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  unint64_t v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;
  uint64_t v16;
  NSObject *v18;
  NSObject *v19;

  v2 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) == 5186)
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)(*(_QWORD *)(a2 + 8) + 8);
    v5 = sub_1000297D4(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 64), (size_t **)(a1 + 152), (_QWORD *)(a1 + 136));
    if ((v5 & 0x80000000) != 0)
    {
      if (dword_10008BA20)
      {
        v13 = ne_log_obj(v5);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
          sub_100058C9C();
      }
    }
    else
    {
      v6 = sub_100006C70(*(_DWORD *)(*(_QWORD *)(a1 + 64) + 140));
      *(_QWORD *)(a1 + 176) = v6;
      if (v6)
      {
        v7 = sub_100016460(a1);
        *(_QWORD *)(a1 + 128) = v7;
        if (v7)
        {
          *(_DWORD *)(a1 + 124) = *(_DWORD *)(*(_QWORD *)(a1 + 64) + 200);
          v8 = sub_100024360(a1);
          if ((_DWORD)v8 == -1)
          {
            if (dword_10008BA20)
            {
              v18 = ne_log_obj(v8);
              if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
                sub_100058CF4();
            }
          }
          else
          {
            v9 = *(_QWORD **)(a1 + 128);
            if (*(_DWORD *)(a1 + 100) && *v9 >= 0x501uLL)
            {
              v10 = 0;
              LODWORD(v11) = *(_DWORD *)(a1 + 96);
            }
            else
            {
              v11 = *(unsigned int *)(a1 + 96);
              v10 = (v11 >> 3) & 4;
            }
            v16 = sub_100009B6C(*(unsigned __int8 **)(a1 + 48), *(unsigned __int8 **)(a1 + 56), (uint64_t)v9, a2, v10, (v11 >> 5) & 1);
            if ((_DWORD)v16 != -1)
            {
              sub_100003774(v2, 5219);
              return 0;
            }
            if (dword_10008BA20)
            {
              v19 = ne_log_obj(v16);
              if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
                sub_10005961C();
            }
          }
        }
        else if (dword_10008BA20)
        {
          v15 = ne_log_obj(0);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
            sub_100059DA4();
        }
      }
      else if (dword_10008BA20)
      {
        v14 = ne_log_obj(0);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
          sub_100058CC8();
      }
    }
  }
  else if (dword_10008BA20)
  {
    v12 = ne_log_obj(a1);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      sub_100058E84();
  }
  return 0xFFFFFFFFLL;
}

_QWORD *sub_100016460(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  char v4;
  _QWORD *v5;
  uint64_t **v6;
  uint64_t **v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  int v14;
  _QWORD *v15;
  int v16;
  uint64_t v17;
  NSObject *v18;
  _QWORD *v19;
  NSObject *v20;
  NSObject *v22;
  uint8_t v23[8];
  uint64_t **v24;

  if (*(_DWORD *)(a1 + 20) != 1
    || !*(_DWORD *)(*(_QWORD *)(a1 + 64) + 120)
    || !sub_10002CBE8(*(_DWORD *)(*(_QWORD *)(a1 + 72) + 48)))
  {
    v3 = 0;
    v4 = 1;
LABEL_7:
    v5 = sub_10002662C(0, *(_QWORD *)(a1 + 152), 4);
    v6 = (uint64_t **)sub_10002662C(v5, *(_QWORD *)(a1 + 176), 10);
    v7 = v6;
    v24 = v6;
    if ((v4 & 1) == 0)
    {
      v7 = (uint64_t **)sub_10002662C(v6, (uint64_t)v3, 7);
      v24 = v7;
    }
    if ((*(_BYTE *)(a1 + 96) & 1) == 0)
    {
      v8 = 0;
      v9 = 0;
      goto LABEL_30;
    }
    v10 = sub_10003F42C(a1, *(_QWORD *)(a1 + 48));
    if (v10)
    {
      v8 = (_QWORD *)v10;
      v11 = sub_10003F42C(a1, *(_QWORD *)(a1 + 56));
      if (v11)
      {
        v9 = (_QWORD *)v11;
        if (dword_10008BA20)
        {
          v12 = ne_log_obj(v11);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)v23 = 0;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Adding remote and local NAT-D payloads.\n", v23, 2u);
          }
        }
        v13 = *(_QWORD *)(a1 + 88);
        v14 = *(unsigned __int16 *)(v13 + 14);
        if (*(_DWORD *)v13 == 14)
        {
          v15 = sub_10002662C(v7, (uint64_t)v9, v14);
          v16 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 88) + 14);
          v17 = (uint64_t)v8;
        }
        else
        {
          v15 = sub_10002662C(v7, (uint64_t)v8, v14);
          v16 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 88) + 14);
          v17 = (uint64_t)v9;
        }
        v24 = (uint64_t **)sub_10002662C(v15, v17, v16);
LABEL_30:
        v19 = sub_100026684(&v24, a1);
        if (!v3)
        {
LABEL_32:
          if (v8)
            sub_10003F318(v8);
          if (v9)
            sub_10003F318(v9);
          return v19;
        }
LABEL_31:
        sub_10003F318(v3);
        goto LABEL_32;
      }
      if (dword_10008BA20)
      {
        v20 = ne_log_obj(0);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          sub_100059DD0((const sockaddr **)(a1 + 56));
      }
      v19 = 0;
    }
    else
    {
      if (dword_10008BA20)
      {
        v18 = ne_log_obj(0);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          sub_100059DD0((const sockaddr **)(a1 + 48));
      }
      v19 = 0;
      v8 = 0;
    }
    v9 = 0;
    if (!v3)
      goto LABEL_32;
    goto LABEL_31;
  }
  v2 = sub_10002C9DC(a1);
  if (v2)
  {
    v3 = v2;
    v4 = 0;
    goto LABEL_7;
  }
  if (dword_10008BA20)
  {
    v22 = ne_log_obj(0);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      sub_100059E3C();
  }
  return 0;
}

uint64_t sub_1000166E0(uint64_t a1, uint64_t a2)
{
  int *v3;
  uint64_t v4;
  _QWORD *v5;
  int v6;
  unsigned __int8 *i;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  NSObject *v13;
  const char *v14;
  int *v15;
  int v16;
  NSObject *v17;
  NSObject *v18;
  int v19;
  NSObject *v20;
  const char *v21;
  const char *v22;
  const char *v23;
  NSObject *v25;
  NSObject *v26;
  NSObject *v27;
  NSObject *v28;
  NSObject *v29;
  NSObject *v30;
  _QWORD *v31;
  _QWORD *v32;
  _QWORD *v33;
  void *v34;
  uint8_t buf[4];
  _BYTE v36[18];
  __int16 v37;
  const char *v38;

  v34 = 0;
  v3 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) == 5219)
  {
    v4 = (uint64_t)sub_1000232C8(a2);
    if (v4)
    {
      v5 = (_QWORD *)v4;
      v6 = 0;
      for (i = *(unsigned __int8 **)(v4 + 8); ; i += 16)
      {
        v8 = *i;
        if (v8 <= 0x13)
          break;
        if (v8 != 20 && v8 != 130)
        {
LABEL_58:
          if (dword_10008BA20)
          {
            v25 = ne_log_obj(v4);
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
              sub_100059D10();
          }
          goto LABEL_76;
        }
LABEL_10:
        if ((*(_BYTE *)(a1 + 96) & 1) != 0)
        {
          v9 = *(_QWORD *)(a1 + 88);
          if (v9)
          {
            if (*(unsigned __int16 *)(v9 + 14) == v8)
            {
              v34 = 0;
              v10 = sub_1000263B8((size_t **)&v34, *((_QWORD *)i + 1));
              if ((v10 & 0x80000000) != 0)
              {
                if (dword_10008BA20)
                {
                  v30 = ne_log_obj(v10);
                  if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
                    sub_1000597AC();
                }
                goto LABEL_76;
              }
              if (!v6)
                *(_DWORD *)(a1 + 96) |= 6u;
              v11 = sub_10003F610(a1, (uint64_t)v34, v6);
              if (dword_10008BA20)
              {
                v12 = v11;
                v13 = ne_log_obj(v11);
                if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 67109378;
                  v14 = "verified";
                  if (!v12)
                    v14 = "doesn't match";
                  *(_DWORD *)v36 = v6;
                  *(_WORD *)&v36[4] = 2080;
                  *(_QWORD *)&v36[6] = v14;
                  _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "NAT-D payload #%d %s\n", buf, 0x12u);
                }
              }
              ++v6;
              sub_10003F318(v34);
            }
          }
        }
LABEL_34:
        ;
      }
      switch(*i)
      {
        case 4u:
          v4 = sub_1000263B8((size_t **)(a1 + 160), *((_QWORD *)i + 1));
          if ((v4 & 0x80000000) == 0)
            goto LABEL_34;
          if (dword_10008BA20)
          {
            v26 = ne_log_obj(v4);
            if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
              sub_100059100();
          }
          break;
        case 5u:
        case 6u:
        case 8u:
        case 9u:
        case 0xBu:
        case 0xCu:
        case 0xEu:
          goto LABEL_58;
        case 7u:
          v4 = sub_10002C8BC(a1, *((_QWORD *)i + 1));
          if ((v4 & 0x80000000) == 0)
            goto LABEL_34;
          if (dword_10008BA20)
          {
            v27 = ne_log_obj(v4);
            if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
              sub_100059184();
          }
          break;
        case 0xAu:
          v4 = sub_1000263B8((size_t **)(a1 + 184), *((_QWORD *)i + 1));
          if ((v4 & 0x80000000) == 0)
            goto LABEL_34;
          if (dword_10008BA20)
          {
            v28 = ne_log_obj(v4);
            if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
              sub_10005912C();
          }
          break;
        case 0xDu:
          v4 = sub_10003F06C(*((_QWORD *)i + 1));
          if ((_DWORD)v4 == 19)
          {
            if (*(_DWORD *)(*(_QWORD *)(a1 + 64) + 208))
              *(_DWORD *)(a1 + 368) = 1;
          }
          else
          {
            if ((_DWORD)v4 == 17)
            {
              v15 = *(int **)(a1 + 408);
              v16 = *v15 | 2;
            }
            else
            {
              if ((_DWORD)v4 != 16)
                goto LABEL_34;
              v15 = *(int **)(a1 + 408);
              v16 = *v15 | 1;
            }
            *v15 = v16;
          }
          goto LABEL_34;
        case 0xFu:
          goto LABEL_10;
        default:
          if (*i)
            goto LABEL_58;
          v19 = *(_DWORD *)(a1 + 96);
          if ((v19 & 1) != 0)
          {
            if (dword_10008BA20)
            {
              v20 = ne_log_obj(v4);
              v4 = os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT);
              v19 = *(_DWORD *)(a1 + 96);
              if ((_DWORD)v4)
              {
                v21 = "detected:";
                v22 = "ME ";
                if ((v19 & 6) == 0)
                  v21 = "not detected";
                if ((v19 & 2) == 0)
                  v22 = (const char *)&unk_10007E079;
                *(_DWORD *)buf = 136315650;
                *(_QWORD *)v36 = v21;
                *(_WORD *)&v36[8] = 2080;
                *(_QWORD *)&v36[10] = v22;
                if ((v19 & 4) != 0)
                  v23 = "PEER";
                else
                  v23 = (const char *)&unk_10007E079;
                v37 = 2080;
                v38 = v23;
                _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "NAT %s %s%s\n", buf, 0x20u);
                v19 = *(_DWORD *)(a1 + 96);
              }
            }
            if ((v19 & 6) != 0)
              sub_10003FB84(a1);
          }
          if (*(_QWORD *)(a1 + 160) && *(_QWORD *)(a1 + 184))
          {
            sub_10002CACC(a1);
            sub_100003774(v3, 5188);
            sub_10003F318(v5);
            return 0;
          }
          if (dword_10008BA20)
          {
            v29 = ne_log_obj(v4);
            if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
              sub_100058FA0();
          }
          break;
      }
LABEL_76:
      sub_10003F318(v5);
    }
    else if (dword_10008BA20)
    {
      v18 = ne_log_obj(0);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        sub_100058EE4();
    }
  }
  else if (dword_10008BA20)
  {
    v17 = ne_log_obj(a1);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      sub_100058E84();
  }
  v31 = *(_QWORD **)(a1 + 160);
  if (v31)
  {
    sub_10003F318(v31);
    *(_QWORD *)(a1 + 160) = 0;
  }
  v32 = *(_QWORD **)(a1 + 184);
  if (v32)
  {
    sub_10003F318(v32);
    *(_QWORD *)(a1 + 184) = 0;
  }
  v33 = *(_QWORD **)(a1 + 320);
  if (v33)
  {
    sub_10003F318(v33);
    *(_QWORD *)(a1 + 320) = 0;
  }
  sub_10002BC70(*(_QWORD **)(a1 + 304));
  *(_QWORD *)(a1 + 304) = 0;
  return 0xFFFFFFFFLL;
}

uint64_t sub_100016C20(uint64_t a1, uint64_t a2)
{
  int *v2;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  unint64_t v16;
  NSObject *v17;
  NSObject *v18;
  NSObject *v19;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  NSObject *v25;
  uint64_t v26;
  NSObject *v28;
  NSObject *v29;

  v2 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) == 5188)
  {
    v5 = sub_1000295D8(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 64), *(_QWORD **)(a1 + 160), (_QWORD **)(a1 + 168), (_QWORD *)(a1 + 136));
    if ((v5 & 0x80000000) != 0)
    {
      if (dword_10008BA20)
      {
        v18 = ne_log_obj(v5);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          sub_100058FF8();
      }
    }
    else
    {
      v6 = sub_10002CDB4(a1);
      if ((v6 & 0x80000000) != 0)
      {
        if (dword_10008BA20)
        {
          v19 = ne_log_obj(v6);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
            sub_100059024();
        }
      }
      else
      {
        v7 = sub_10002D170(a1);
        if ((v7 & 0x80000000) != 0)
        {
          if (dword_10008BA20)
          {
            v20 = ne_log_obj(v7);
            if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
              sub_100059050();
          }
        }
        else
        {
          v8 = sub_10002D418((_QWORD *)a1);
          if ((v8 & 0x80000000) != 0)
          {
            if (dword_10008BA20)
            {
              v21 = ne_log_obj(v8);
              if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
                sub_10005907C();
            }
          }
          else
          {
            v9 = sub_10002D814(a1);
            if ((v9 & 0x80000000) != 0)
            {
              if (dword_10008BA20)
              {
                v22 = ne_log_obj(v9);
                if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
                  sub_1000590A8();
              }
            }
            else
            {
              v10 = sub_10000FFE8(a1);
              if ((v10 & 0x80000000) != 0)
              {
                if (dword_10008BA20)
                {
                  v23 = ne_log_obj(v10);
                  if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
                    sub_100058C18();
                }
              }
              else
              {
                v11 = sub_10002A470(a1, 1);
                *(_QWORD *)(a1 + 256) = v11;
                if (v11)
                {
                  *(_BYTE *)(a1 + 82) |= 1u;
                  v12 = sub_100016F88(a1);
                  *(_QWORD *)(a1 + 128) = v12;
                  if (v12)
                  {
                    *(_DWORD *)(a1 + 124) = *(_DWORD *)(*(_QWORD *)(a1 + 64) + 200);
                    v13 = sub_100024360(a1);
                    if ((_DWORD)v13 == -1)
                    {
                      if (dword_10008BA20)
                      {
                        v28 = ne_log_obj(v13);
                        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
                          sub_100058CF4();
                      }
                    }
                    else
                    {
                      v14 = *(_QWORD **)(a1 + 128);
                      if (*(_DWORD *)(a1 + 100) && *v14 >= 0x501uLL)
                      {
                        v15 = 0;
                        LODWORD(v16) = *(_DWORD *)(a1 + 96);
                      }
                      else
                      {
                        v16 = *(unsigned int *)(a1 + 96);
                        v15 = (v16 >> 3) & 4;
                      }
                      v26 = sub_100009B6C(*(unsigned __int8 **)(a1 + 48), *(unsigned __int8 **)(a1 + 56), (uint64_t)v14, a2, v15, (v16 >> 5) & 1);
                      if ((_DWORD)v26 != -1)
                      {
                        memcpy(*(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 328) + 8) + 8), *(const void **)(**(_QWORD **)(a1 + 328) + 8), ***(_QWORD ***)(a1 + 328));
                        sub_100003774(v2, 5221);
                        return 0;
                      }
                      if (dword_10008BA20)
                      {
                        v29 = ne_log_obj(v26);
                        if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
                          sub_10005961C();
                      }
                    }
                  }
                  else if (dword_10008BA20)
                  {
                    v25 = ne_log_obj(0);
                    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
                      sub_100059E94();
                  }
                }
                else if (dword_10008BA20)
                {
                  v24 = ne_log_obj(0);
                  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
                    sub_100059E68();
                }
              }
            }
          }
        }
      }
    }
  }
  else if (dword_10008BA20)
  {
    v17 = ne_log_obj(a1);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      sub_100058E84();
  }
  return 0xFFFFFFFFLL;
}

_QWORD *sub_100016F88(uint64_t a1)
{
  uint64_t v2;
  int v3;
  BOOL v4;
  NSObject *v5;
  _QWORD *v6;
  int v7;
  _QWORD *v8;
  uint64_t **v9;
  uint64_t **v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  NSObject *v14;
  BOOL v15;
  uint64_t v17;
  uint64_t v18;
  char v19;
  int v20;
  _QWORD *v21;
  uint64_t v22;
  int v23;
  NSObject *v24;
  NSObject *v25;
  NSObject *v26;
  _QWORD *v27;
  uint64_t **v28;
  NSObject *v29;
  uint64_t **v30;

  v2 = a1 + 72;
  v3 = *(_DWORD *)(*(_QWORD *)(a1 + 72) + 48);
  if (*(_QWORD *)(*(_QWORD *)(a1 + 64) + 272))
    v4 = v3 == 65001;
  else
    v4 = 0;
  if (v4)
    goto LABEL_22;
  if (v3 > 65004)
  {
    if ((v3 - 65007) < 4)
      goto LABEL_12;
    if ((v3 - 65005) < 2)
      goto LABEL_42;
    v7 = 65500;
LABEL_21:
    if (v3 != v7)
    {
LABEL_52:
      if (dword_10008BA20)
      {
        v25 = ne_log_obj(a1);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          sub_100059EEC();
      }
      return 0;
    }
    goto LABEL_22;
  }
  if (v3 > 64220)
  {
    if (v3 == 64221)
      goto LABEL_22;
    if (v3 == 64222)
      goto LABEL_42;
    v7 = 65002;
    goto LABEL_21;
  }
  if ((v3 - 4) < 2)
  {
LABEL_12:
    if (dword_10008BA20)
    {
      v5 = ne_log_obj(a1);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_100059F78();
    }
    return 0;
  }
  if (v3 == 1)
  {
LABEL_22:
    v8 = sub_10002662C(0, *(_QWORD *)(a1 + 312), 5);
    v9 = (uint64_t **)sub_10002662C(v8, *(_QWORD *)(a1 + 256), 8);
    v10 = v9;
    v11 = 0;
LABEL_23:
    v30 = v9;
    goto LABEL_24;
  }
  if (v3 != 3)
    goto LABEL_52;
LABEL_42:
  v17 = sub_10002B67C(a1);
  if ((v17 & 0x80000000) != 0)
  {
    if (dword_10008BA20)
    {
      v24 = ne_log_obj(v17);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        sub_1000596A0();
    }
    return 0;
  }
  v18 = sub_10002B990((_QWORD *)a1);
  if ((v18 & 0x80000000) != 0)
  {
    if (dword_10008BA20)
    {
      v26 = ne_log_obj(v18);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        sub_10005952C();
    }
    return 0;
  }
  if (!*(_DWORD *)(a1 + 20)
    && *(_DWORD *)(*(_QWORD *)(a1 + 64) + 120)
    && sub_10002CBE8(*(_DWORD *)(*(_QWORD *)v2 + 48)))
  {
    v27 = sub_10002C9DC(a1);
    if (!v27)
    {
      if (dword_10008BA20)
      {
        v29 = ne_log_obj(0);
        if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
          sub_100059F4C();
      }
      return 0;
    }
    v11 = v27;
    v19 = 0;
  }
  else
  {
    v11 = 0;
    v19 = 1;
  }
  if (*(_QWORD *)(a1 + 280))
  {
    v20 = *(_DWORD *)(*(_QWORD *)(a1 + 64) + 116);
    v21 = sub_10002662C(0, *(_QWORD *)(a1 + 312), 5);
    if (!v20)
      goto LABEL_64;
    v22 = *(_QWORD *)(*(_QWORD *)(a1 + 280) + 24);
    v23 = 6;
  }
  else
  {
    v22 = *(_QWORD *)(a1 + 312);
    v21 = 0;
    v23 = 5;
  }
  v21 = sub_10002662C(v21, v22, v23);
LABEL_64:
  v28 = (uint64_t **)sub_10002662C(v21, *(_QWORD *)(a1 + 264), 9);
  v10 = v28;
  v30 = v28;
  if ((v19 & 1) == 0)
  {
    v9 = (uint64_t **)sub_10002662C(v28, (uint64_t)v11, 7);
    v10 = v9;
    goto LABEL_23;
  }
LABEL_24:
  if (*(_DWORD *)(a1 + 20))
    v12 = 0;
  else
    v12 = sub_10002736C((unint64_t *)a1, v10);
  v6 = sub_100026684(&v30, a1);
  v13 = sub_10002E3DC(a1, (uint64_t)v6, *(_QWORD *)(*(_QWORD *)(a1 + 328) + 8), **(_QWORD **)(a1 + 328));
  if (v13)
  {
    sub_10003F318(v6);
    v6 = v13;
    if (!v11)
      goto LABEL_34;
    goto LABEL_33;
  }
  if (dword_10008BA20)
  {
    v14 = ne_log_obj(0);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      sub_100059EC0();
      if (!v11)
        goto LABEL_34;
      goto LABEL_33;
    }
  }
  if (v11)
LABEL_33:
    sub_10003F318(v11);
LABEL_34:
  if (v13)
    v15 = 1;
  else
    v15 = v6 == 0;
  if (!v15)
  {
    sub_10003F318(v6);
    v6 = 0;
  }
  if (v12)
    sub_10003F318(v12);
  return v6;
}

uint64_t sub_100017320(uint64_t a1, _QWORD *a2)
{
  int *v3;
  NSObject *v4;
  NSObject *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD *v13;
  int v14;
  uint64_t v15;
  NSObject *v16;
  NSObject *v17;
  uint64_t v18;
  NSObject *v19;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  NSObject *v23;
  char v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char v30;

  v3 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) != 5221)
  {
    if (dword_10008BA20)
    {
      v5 = ne_log_obj(a1);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_100058E84();
    }
    goto LABEL_9;
  }
  if ((*(_BYTE *)(a2[1] + 19) & 1) == 0)
  {
    if (dword_10008BA20)
    {
      v4 = ne_log_obj(a1);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_100059FD8();
    }
LABEL_9:
    v6 = 0xFFFFFFFFLL;
LABEL_10:
    v7 = *(_QWORD **)(a1 + 320);
    if (v7)
    {
      sub_10003F318(v7);
      *(_QWORD *)(a1 + 320) = 0;
    }
    sub_10002BC70(*(_QWORD **)(a1 + 288));
    *(_QWORD *)(a1 + 288) = 0;
    sub_10002BC70(*(_QWORD **)(a1 + 296));
    *(_QWORD *)(a1 + 296) = 0;
    v8 = *(_QWORD **)(a1 + 272);
    if (v8)
    {
      sub_10003F318(v8);
      *(_QWORD *)(a1 + 272) = 0;
    }
    return v6;
  }
  v10 = sub_10002E000(a1, a2, **(_QWORD **)(a1 + 328), *(_QWORD *)(*(_QWORD *)(a1 + 328) + 8));
  if (!v10)
  {
    if (dword_10008BA20)
    {
      v16 = ne_log_obj(0);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        sub_10005A004();
    }
    goto LABEL_9;
  }
  v11 = v10;
  v12 = (uint64_t)sub_1000232C8((uint64_t)v10);
  if (!v12)
  {
    if (dword_10008BA20)
    {
      v17 = ne_log_obj(0);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        sub_100058EE4();
    }
    sub_10003F318(v11);
    goto LABEL_9;
  }
  v13 = (_QWORD *)v12;
  v14 = 0;
  *(_QWORD *)(a1 + 352) = 0;
  v15 = *(_QWORD *)(v12 + 8);
  while (2)
  {
    switch(*(_BYTE *)v15)
    {
      case 0:
        if (v14)
          sub_10002BBF4((_QWORD *)a1);
        v18 = sub_10000F9F8(a1);
        if ((_DWORD)v18)
        {
          if (dword_10008BA20)
          {
            v19 = ne_log_obj(v18);
            if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
              sub_1000590D4();
          }
          goto LABEL_56;
        }
        v25 = sub_10002AC24(a1);
        v6 = v25;
        if ((_DWORD)v25 == -1)
        {
          v24 = 0;
        }
        else
        {
          if ((_DWORD)v25)
          {
            sub_10001B184(a1, v25, 0);
            goto LABEL_56;
          }
          if (dword_1000882C8 >= 7)
            sub_10003372C(7, *(_QWORD *)(*(_QWORD *)(a1 + 320) + 8), **(_QWORD **)(a1 + 320), "peer's ID:", v26, v27, v28, v29, v30);
          memcpy(*(void **)(**(_QWORD **)(a1 + 328) + 8), *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 328) + 8) + 8), **(_QWORD **)(*(_QWORD *)(a1 + 328) + 8));
          sub_100003774(v3, 5190);
          v6 = 0;
          v24 = 1;
        }
        goto LABEL_57;
      case 5:
        v12 = sub_1000263B8((size_t **)(a1 + 320), *(_QWORD *)(v15 + 8));
        if ((v12 & 0x80000000) == 0)
          goto LABEL_30;
        if (dword_10008BA20)
        {
          v21 = ne_log_obj(v12);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
            sub_100059158();
        }
        goto LABEL_56;
      case 6:
        v12 = sub_10002C614(a1, *(_QWORD *)(v15 + 8));
        if ((v12 & 0x80000000) == 0)
        {
          v14 = 1;
LABEL_30:
          v15 += 16;
          continue;
        }
        if (dword_10008BA20)
        {
          v22 = ne_log_obj(v12);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
            sub_100059754();
        }
LABEL_56:
        v24 = 0;
        v6 = 0xFFFFFFFFLL;
LABEL_57:
        sub_10003F318(v13);
        sub_10003F318(v11);
        if ((v24 & 1) == 0)
          goto LABEL_10;
        return v6;
      case 8:
        *(_QWORD *)(a1 + 352) = *(_QWORD *)(v15 + 8);
        goto LABEL_30;
      case 9:
        v12 = sub_1000263B8((size_t **)(a1 + 272), *(_QWORD *)(v15 + 8));
        if ((v12 & 0x80000000) == 0)
          goto LABEL_30;
        if (dword_10008BA20)
        {
          v23 = ne_log_obj(v12);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
            sub_100059780();
        }
        goto LABEL_56;
      case 0xB:
        sub_10001BBF4(*(_QWORD *)(v15 + 8), a1);
        goto LABEL_30;
      case 0xD:
        v12 = sub_10003F06C(*(_QWORD *)(v15 + 8));
        if ((_DWORD)v12 == 19 && *(_DWORD *)(*(_QWORD *)(a1 + 64) + 208))
          *(_DWORD *)(a1 + 368) = 1;
        goto LABEL_30;
      default:
        if (dword_10008BA20)
        {
          v20 = ne_log_obj(v12);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
            sub_100059D10();
        }
        goto LABEL_56;
    }
  }
}

uint64_t sub_100017728(uint64_t a1)
{
  int *v1;
  NSObject *v3;

  v1 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) == 5190)
  {
    memcpy(*(void **)(**(_QWORD **)(a1 + 328) + 8), *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 328) + 8) + 8), ***(_QWORD ***)(a1 + 328));
    sub_100003774(v1, 9216);
    return 0;
  }
  else
  {
    if (dword_10008BA20)
    {
      v3 = ne_log_obj(a1);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        sub_100058E84();
    }
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_1000177B4(uint64_t a1, uint64_t a2)
{
  int *v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t i;
  int v9;
  int *v10;
  int v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;
  NSObject *v16;
  __int128 *v17;
  uint64_t v18;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  _QWORD *v23;
  uint8_t v24;
  _BYTE v25[15];
  uint8_t buf[4];
  __int128 *v27;

  v3 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) == 5440)
  {
    v4 = sub_1000232C8(a2);
    if (v4)
    {
      v5 = v4;
      v6 = v4[1];
      if (*(_BYTE *)v6 == 1)
      {
        v7 = sub_1000263B8((size_t **)(a1 + 336), *(_QWORD *)(v6 + 8));
        if ((v7 & 0x80000000) != 0)
        {
          if (dword_10008BA20)
          {
            v20 = ne_log_obj(v7);
            if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
              sub_100058F10();
          }
        }
        else
        {
          for (i = v6 + 16; *(_BYTE *)i == 13; i += 16)
          {
            v7 = sub_10003F06C(*(_QWORD *)(i + 8));
            v9 = v7;
            if (*(_DWORD *)(*(_QWORD *)(a1 + 64) + 176))
            {
              v7 = sub_10003F41C(v7);
              if ((_DWORD)v7)
                sub_10003FC4C(a1, v9);
            }
            switch(v9)
            {
              case 16:
                v10 = *(int **)(a1 + 408);
                v11 = *v10 | 1;
                goto LABEL_13;
              case 17:
                v10 = *(int **)(a1 + 408);
                v11 = *v10 | 2;
LABEL_13:
                *v10 = v11;
                break;
              case 18:
                v7 = sub_1000151DC(*(_QWORD *)(i + 8));
                if ((v7 & 0x80000000) != 0)
                {
                  if (dword_10008BA20)
                  {
                    v12 = ne_log_obj(v7);
                    v7 = os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG);
                    if ((_DWORD)v7)
                      sub_100059D70(&v24, v25, v12);
                  }
                  *(_DWORD *)(a1 + 100) = 1;
                }
                break;
              case 19:
                if (*(_DWORD *)(*(_QWORD *)(a1 + 64) + 208))
                  *(_DWORD *)(a1 + 368) = 1;
                break;
              default:
                continue;
            }
          }
          if (*(_BYTE *)i)
          {
            if (dword_10008BA20)
            {
              v21 = ne_log_obj(v7);
              if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
                sub_100059D10();
            }
          }
          else
          {
            if ((*(_BYTE *)(a1 + 96) & 1) != 0)
            {
              if (dword_10008BA20)
              {
                v16 = ne_log_obj(v7);
                if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
                {
                  v17 = sub_10003EDD8(**(_DWORD **)(a1 + 88));
                  *(_DWORD *)buf = 136315138;
                  v27 = v17;
                  _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Selected NAT-T version: %s\n", buf, 0xCu);
                }
              }
              sub_10004E490(a1);
            }
            v18 = sub_10000ABC8(*(unint64_t **)(a1 + 336), (_QWORD *)a1);
            if ((v18 & 0x80000000) == 0)
            {
              sub_100003774(v3, 5441);
              sub_10003F318(v5);
              return 0;
            }
            if (dword_10008BA20)
            {
              v22 = ne_log_obj(v18);
              if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
                sub_100058FCC();
            }
          }
        }
      }
      else if (dword_10008BA20)
      {
        v15 = ne_log_obj(v4);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          sub_1000592B8();
      }
      sub_10003F318(v5);
    }
    else if (dword_10008BA20)
    {
      v14 = ne_log_obj(0);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        sub_100058EE4();
    }
  }
  else if (dword_10008BA20)
  {
    v13 = ne_log_obj(a1);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      sub_100058E84();
  }
  v23 = *(_QWORD **)(a1 + 336);
  if (v23)
  {
    sub_10003F318(v23);
    *(_QWORD *)(a1 + 336) = 0;
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100017B34(uint64_t a1, uint64_t a2)
{
  int *v2;
  uint64_t **v5;
  uint64_t **v6;
  int v7;
  _QWORD *v8;
  _QWORD *v9;
  NSObject *v10;
  uint64_t v11;
  NSObject *v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  void **v17;
  void **v18;
  NSObject *v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  NSObject *v25;
  NSObject *v26;
  NSObject *v27;
  NSObject *v29;
  uint8_t v30[8];
  uint64_t **v31;

  v2 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) != 5441)
  {
    if (dword_10008BA20)
    {
      v10 = ne_log_obj(a1);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_100058E84();
    }
    return 0xFFFFFFFFLL;
  }
  sub_100026198((_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56));
  v5 = (uint64_t **)sub_10002662C(0, *(_QWORD *)(a1 + 344), 1);
  v6 = v5;
  v31 = v5;
  v7 = **(_DWORD **)(a1 + 408);
  if ((v7 & 1) != 0)
  {
    if (dword_10008BA20)
    {
      v12 = ne_log_obj(v5);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v30 = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Adding xauth VID payload.\n", v30, 2u);
      }
    }
    v13 = sub_10003EFDC(16);
    if (v13)
    {
      v8 = v13;
      v6 = (uint64_t **)sub_10002662C(v6, (uint64_t)v13, 13);
      v31 = v6;
      if ((**(_DWORD **)(a1 + 408) & 2) == 0)
        goto LABEL_4;
      goto LABEL_14;
    }
    if (dword_10008BA20)
    {
      v26 = ne_log_obj(0);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        sub_100059674();
    }
    return 0xFFFFFFFFLL;
  }
  v8 = 0;
  if ((v7 & 2) == 0)
  {
LABEL_4:
    v9 = 0;
    goto LABEL_16;
  }
LABEL_14:
  v14 = sub_10003EFDC(17);
  if (!v14)
  {
    if (dword_10008BA20)
    {
      v29 = ne_log_obj(0);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        sub_100059648();
    }
    v18 = 0;
    v16 = 0;
    v9 = 0;
    v11 = 0xFFFFFFFFLL;
    if (!v8)
      goto LABEL_53;
    goto LABEL_52;
  }
  v9 = v14;
  v6 = (uint64_t **)sub_10002662C(v6, (uint64_t)v14, 13);
  v31 = v6;
LABEL_16:
  if ((*(_BYTE *)(a1 + 96) & 1) != 0)
  {
    v15 = sub_10003EFDC(**(unsigned int **)(a1 + 88));
    if (v15)
    {
      v6 = (uint64_t **)sub_10002662C(v6, (uint64_t)v15, 13);
      v31 = v6;
    }
  }
  else
  {
    v15 = 0;
  }
  if (*(_DWORD *)(*(_QWORD *)(a1 + 64) + 208))
  {
    v16 = sub_10003EFDC(19);
    if (v16)
    {
      v6 = (uint64_t **)sub_10002662C(v6, (uint64_t)v16, 13);
      v31 = v6;
    }
  }
  else
  {
    v16 = 0;
  }
  if (*(_DWORD *)(a1 + 100))
  {
    v17 = (void **)sub_10003EFDC(18);
    if (v17)
    {
      v17 = sub_100015718(v17, 0x80000000);
      if (v17)
      {
        v18 = v17;
        v31 = (uint64_t **)sub_10002662C(v6, (uint64_t)v17, 13);
        goto LABEL_32;
      }
    }
    if (dword_10008BA20)
    {
      v19 = ne_log_obj(v17);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        sub_1000596CC();
    }
  }
  v18 = 0;
LABEL_32:
  *(_QWORD *)(a1 + 128) = sub_100026684(&v31, a1);
  *(_DWORD *)(a1 + 124) = *(_DWORD *)(*(_QWORD *)(a1 + 64) + 200);
  v20 = sub_100024360(a1);
  if ((_DWORD)v20 == -1)
  {
    if (dword_10008BA20)
    {
      v25 = ne_log_obj(v20);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        sub_100058CF4();
    }
LABEL_49:
    v11 = 0xFFFFFFFFLL;
    if (!v15)
      goto LABEL_51;
    goto LABEL_50;
  }
  v21 = *(_QWORD **)(a1 + 128);
  if (*(_DWORD *)(a1 + 100) && *v21 >= 0x501uLL)
  {
    v22 = 0;
    LODWORD(v23) = *(_DWORD *)(a1 + 96);
  }
  else
  {
    v23 = *(unsigned int *)(a1 + 96);
    v22 = (v23 >> 3) & 4;
  }
  v24 = sub_100009B6C(*(unsigned __int8 **)(a1 + 48), *(unsigned __int8 **)(a1 + 56), (uint64_t)v21, a2, v22, (v23 >> 5) & 1);
  if ((_DWORD)v24 == -1)
  {
    if (dword_10008BA20)
    {
      v27 = ne_log_obj(v24);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        sub_10005961C();
    }
    goto LABEL_49;
  }
  sub_100003774(v2, 5474);
  sub_100048B0C(1, 0, a1, 0);
  v11 = 0;
  if (v15)
LABEL_50:
    sub_10003F318(v15);
LABEL_51:
  if (v8)
LABEL_52:
    sub_10003F318(v8);
LABEL_53:
  if (v9)
    sub_10003F318(v9);
  if (v16)
    sub_10003F318(v16);
  if (v18)
    sub_10003F318(v18);
  return v11;
}

uint64_t sub_100017F50(uint64_t a1, uint64_t a2)
{
  int *v3;
  uint64_t v4;
  int v5;
  unsigned __int8 *i;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  NSObject *v12;
  const char *v13;
  NSObject *v14;
  NSObject *v15;
  NSObject *v16;
  NSObject *v17;
  const char *v18;
  int v19;
  const char *v20;
  const char *v21;
  _QWORD *v23;
  NSObject *v24;
  NSObject *v25;
  NSObject *v26;
  NSObject *v27;
  NSObject *v28;
  _QWORD *v29;
  _QWORD *v30;
  _QWORD *v31;
  _QWORD *v32;
  void *v33;
  uint8_t buf[4];
  _BYTE v35[18];
  __int16 v36;
  const char *v37;

  v3 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) == 5474)
  {
    v4 = (uint64_t)sub_1000232C8(a2);
    if (v4)
    {
      v5 = 0;
      v32 = (_QWORD *)v4;
      for (i = *(unsigned __int8 **)(v4 + 8); ; i += 16)
      {
        v7 = *i;
        if (v7 <= 0x13)
          break;
        if (v7 != 20 && v7 != 130)
        {
LABEL_50:
          v23 = v32;
          if (dword_10008BA20)
          {
            v24 = ne_log_obj(v4);
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
              sub_100059D10();
          }
          goto LABEL_66;
        }
LABEL_10:
        if ((*(_BYTE *)(a1 + 96) & 1) != 0)
        {
          v8 = *(_QWORD *)(a1 + 88);
          if (v8)
          {
            if (*(unsigned __int16 *)(v8 + 14) == v7)
            {
              v33 = 0;
              v9 = sub_1000263B8((size_t **)&v33, *((_QWORD *)i + 1));
              if ((v9 & 0x80000000) != 0)
              {
                if (dword_10008BA20)
                {
                  v28 = ne_log_obj(v9);
                  if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
                    sub_1000597AC();
                }
                v23 = v32;
                goto LABEL_66;
              }
              if (!v5)
                *(_DWORD *)(a1 + 96) |= 6u;
              v10 = sub_10003F610(a1, (uint64_t)v33, v5);
              if (dword_10008BA20)
              {
                v11 = v10;
                v12 = ne_log_obj(v10);
                if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 67109378;
                  v13 = "verified";
                  if (!v11)
                    v13 = "doesn't match";
                  *(_DWORD *)v35 = v5;
                  *(_WORD *)&v35[4] = 2080;
                  *(_QWORD *)&v35[6] = v13;
                  _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "NAT-D payload #%d %s\n", buf, 0x12u);
                }
              }
              ++v5;
              sub_10003F318(v33);
            }
          }
        }
LABEL_28:
        ;
      }
      switch(*i)
      {
        case 4u:
          v4 = sub_1000263B8((size_t **)(a1 + 160), *((_QWORD *)i + 1));
          if ((v4 & 0x80000000) == 0)
            goto LABEL_28;
          v23 = v32;
          if (dword_10008BA20)
          {
            v25 = ne_log_obj(v4);
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
              sub_100059100();
          }
          break;
        case 5u:
        case 6u:
        case 8u:
        case 9u:
        case 0xBu:
        case 0xCu:
        case 0xEu:
          goto LABEL_50;
        case 7u:
          if (dword_10008BA20)
          {
            v14 = ne_log_obj(v4);
            v4 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
            if ((_DWORD)v4)
            {
              *(_WORD *)buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "CR received, ignore it. It should be in other exchange.\n", buf, 2u);
            }
          }
          goto LABEL_28;
        case 0xAu:
          v4 = sub_1000263B8((size_t **)(a1 + 184), *((_QWORD *)i + 1));
          if ((v4 & 0x80000000) == 0)
            goto LABEL_28;
          v23 = v32;
          if (dword_10008BA20)
          {
            v26 = ne_log_obj(v4);
            if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
              sub_10005912C();
          }
          break;
        case 0xDu:
          v4 = sub_10003F06C(*((_QWORD *)i + 1));
          goto LABEL_28;
        case 0xFu:
          goto LABEL_10;
        default:
          if (*i)
            goto LABEL_50;
          if ((*(_BYTE *)(a1 + 96) & 1) != 0)
          {
            if (dword_10008BA20)
            {
              v17 = ne_log_obj(v4);
              v4 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
              if ((_DWORD)v4)
              {
                v18 = "detected:";
                v19 = *(_DWORD *)(a1 + 96);
                v20 = "ME ";
                if ((v19 & 6) == 0)
                  v18 = "not detected";
                if ((v19 & 2) == 0)
                  v20 = (const char *)&unk_10007E079;
                *(_DWORD *)buf = 136315650;
                *(_QWORD *)v35 = v18;
                *(_WORD *)&v35[8] = 2080;
                *(_QWORD *)&v35[10] = v20;
                if ((v19 & 4) != 0)
                  v21 = "PEER";
                else
                  v21 = (const char *)&unk_10007E079;
                v36 = 2080;
                v37 = v21;
                _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "NAT %s %s%s\n", buf, 0x20u);
              }
            }
          }
          if (*(_QWORD *)(a1 + 160) && *(_QWORD *)(a1 + 184))
          {
            sub_100003774(v3, 5443);
            sub_10003F318(v32);
            return 0;
          }
          v23 = v32;
          if (dword_10008BA20)
          {
            v27 = ne_log_obj(v4);
            if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
              sub_100058FA0();
          }
          break;
      }
LABEL_66:
      sub_10003F318(v23);
    }
    else if (dword_10008BA20)
    {
      v16 = ne_log_obj(0);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        sub_100058EE4();
    }
  }
  else if (dword_10008BA20)
  {
    v15 = ne_log_obj(a1);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      sub_100058E84();
  }
  v29 = *(_QWORD **)(a1 + 160);
  if (v29)
  {
    sub_10003F318(v29);
    *(_QWORD *)(a1 + 160) = 0;
  }
  v30 = *(_QWORD **)(a1 + 184);
  if (v30)
  {
    sub_10003F318(v30);
    *(_QWORD *)(a1 + 184) = 0;
  }
  v31 = *(_QWORD **)(a1 + 320);
  if (v31)
  {
    sub_10003F318(v31);
    *(_QWORD *)(a1 + 320) = 0;
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_1000183FC(uint64_t a1, uint64_t a2)
{
  int *v2;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  unint64_t v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  NSObject *v23;
  NSObject *v24;
  NSObject *v25;
  NSObject *v26;
  NSObject *v27;
  NSObject *v28;
  NSObject *v29;

  v2 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) == 5443)
  {
    v5 = sub_1000297D4(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 64), (size_t **)(a1 + 152), (_QWORD *)(a1 + 136));
    if ((v5 & 0x80000000) != 0)
    {
      if (dword_10008BA20)
      {
        v13 = ne_log_obj(v5);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
          sub_100058C9C();
      }
    }
    else
    {
      v6 = sub_100006C70(*(_DWORD *)(*(_QWORD *)(a1 + 64) + 140));
      *(_QWORD *)(a1 + 176) = v6;
      if (v6)
      {
        v7 = sub_100016460(a1);
        *(_QWORD *)(a1 + 128) = v7;
        if (v7)
        {
          *(_DWORD *)(a1 + 124) = *(_DWORD *)(*(_QWORD *)(a1 + 64) + 200);
          v8 = sub_100024360(a1);
          if ((_DWORD)v8 == -1)
          {
            if (dword_10008BA20)
            {
              v23 = ne_log_obj(v8);
              if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
                sub_100058CF4();
            }
          }
          else
          {
            v9 = *(_QWORD **)(a1 + 128);
            if (*(_DWORD *)(a1 + 100) && *v9 >= 0x501uLL)
            {
              v10 = 0;
              LODWORD(v11) = *(_DWORD *)(a1 + 96);
            }
            else
            {
              v11 = *(unsigned int *)(a1 + 96);
              v10 = (v11 >> 3) & 4;
            }
            v16 = sub_100009B6C(*(unsigned __int8 **)(a1 + 48), *(unsigned __int8 **)(a1 + 56), (uint64_t)v9, a2, v10, (v11 >> 5) & 1);
            if ((_DWORD)v16 == -1)
            {
              if (dword_10008BA20)
              {
                v24 = ne_log_obj(v16);
                if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
                  sub_10005961C();
              }
            }
            else
            {
              v17 = sub_1000295D8(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 64), *(_QWORD **)(a1 + 160), (_QWORD **)(a1 + 168), (_QWORD *)(a1 + 136));
              if ((v17 & 0x80000000) != 0)
              {
                if (dword_10008BA20)
                {
                  v25 = ne_log_obj(v17);
                  if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
                    sub_100058FF8();
                }
              }
              else
              {
                v18 = sub_10002CDB4(a1);
                if ((v18 & 0x80000000) != 0)
                {
                  if (dword_10008BA20)
                  {
                    v26 = ne_log_obj(v18);
                    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
                      sub_100059024();
                  }
                }
                else
                {
                  v19 = sub_10002D170(a1);
                  if ((v19 & 0x80000000) != 0)
                  {
                    if (dword_10008BA20)
                    {
                      v27 = ne_log_obj(v19);
                      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
                        sub_100059050();
                    }
                  }
                  else
                  {
                    v20 = sub_10002D418((_QWORD *)a1);
                    if ((v20 & 0x80000000) != 0)
                    {
                      if (dword_10008BA20)
                      {
                        v28 = ne_log_obj(v20);
                        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
                          sub_10005907C();
                      }
                    }
                    else
                    {
                      v21 = sub_10002D814(a1);
                      if ((v21 & 0x80000000) == 0)
                      {
                        sub_100003774(v2, 5476);
                        return 0;
                      }
                      if (dword_10008BA20)
                      {
                        v29 = ne_log_obj(v21);
                        if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
                          sub_1000590A8();
                      }
                    }
                  }
                }
              }
            }
          }
        }
        else if (dword_10008BA20)
        {
          v15 = ne_log_obj(0);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
            sub_100059E94();
        }
      }
      else if (dword_10008BA20)
      {
        v14 = ne_log_obj(0);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
          sub_100058CC8();
      }
    }
  }
  else if (dword_10008BA20)
  {
    v12 = ne_log_obj(a1);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      sub_100058E84();
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100018754(uint64_t a1, _QWORD *a2)
{
  int *v3;
  NSObject *v4;
  NSObject *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD *v13;
  int v14;
  uint64_t v15;
  unint64_t **v16;
  NSObject *v17;
  NSObject *v18;
  int v19;
  BOOL v20;
  NSObject *v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  NSObject *v25;
  uint64_t v26;
  NSObject *v27;
  NSObject *v28;
  NSObject *v29;
  char v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char v35;

  v3 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) != 5476)
  {
    if (dword_10008BA20)
    {
      v5 = ne_log_obj(a1);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_100058E84();
    }
    goto LABEL_9;
  }
  if ((*(_BYTE *)(a2[1] + 19) & 1) == 0)
  {
    if (dword_10008BA20)
    {
      v4 = ne_log_obj(a1);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_10005A030();
    }
LABEL_9:
    v6 = 0xFFFFFFFFLL;
LABEL_10:
    v7 = *(_QWORD **)(a1 + 320);
    if (v7)
    {
      sub_10003F318(v7);
      *(_QWORD *)(a1 + 320) = 0;
    }
    sub_10002BC70(*(_QWORD **)(a1 + 288));
    *(_QWORD *)(a1 + 288) = 0;
    sub_10002BC70(*(_QWORD **)(a1 + 296));
    *(_QWORD *)(a1 + 296) = 0;
    v8 = *(_QWORD **)(a1 + 272);
    if (v8)
    {
      sub_10003F318(v8);
      *(_QWORD *)(a1 + 272) = 0;
    }
    sub_10002BC70(*(_QWORD **)(a1 + 304));
    *(_QWORD *)(a1 + 304) = 0;
    return v6;
  }
  v10 = sub_10002E000(a1, a2, **(_QWORD **)(a1 + 328), *(_QWORD *)(*(_QWORD *)(a1 + 328) + 8));
  if (!v10)
  {
    if (dword_10008BA20)
    {
      v17 = ne_log_obj(0);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        sub_10005A004();
    }
    goto LABEL_9;
  }
  v11 = v10;
  v12 = (uint64_t)sub_1000232C8((uint64_t)v10);
  if (!v12)
  {
    if (dword_10008BA20)
    {
      v18 = ne_log_obj(0);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        sub_100058EE4();
    }
    sub_10003F318(v11);
    goto LABEL_9;
  }
  v13 = (_QWORD *)v12;
  v14 = 0;
  *(_QWORD *)(a1 + 352) = 0;
  v15 = *(_QWORD *)(v12 + 8);
  v16 = (unint64_t **)(a1 + 320);
  while (2)
  {
    switch(*(_BYTE *)v15)
    {
      case 0:
        if (v14)
          v12 = (uint64_t)sub_10002BBF4((_QWORD *)a1);
        v19 = *(_DWORD *)(*(_QWORD *)(a1 + 72) + 48);
        if (*(_QWORD *)(*(_QWORD *)(a1 + 64) + 272))
          v20 = v19 == 65001;
        else
          v20 = 0;
        if (v20)
          goto LABEL_75;
        if (v19 > 64221)
        {
          switch(v19)
          {
            case 65002:
              goto LABEL_69;
            case 65003:
            case 65004:
            case 65005:
            case 65007:
            case 65009:
              goto LABEL_75;
            case 65006:
              goto LABEL_65;
            case 65008:
            case 65010:
              goto LABEL_70;
            default:
              if (v19 == 64222)
                goto LABEL_69;
              goto LABEL_75;
          }
        }
        if ((v19 - 4) < 2)
          goto LABEL_70;
        if (v19 == 1)
        {
LABEL_69:
          if (!*v16)
            goto LABEL_78;
LABEL_70:
          if (!*(_QWORD *)(a1 + 352))
            goto LABEL_78;
        }
        else
        {
          if (v19 != 3)
          {
LABEL_75:
            if (dword_10008BA20)
            {
              v28 = ne_log_obj(v12);
              if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
                sub_10005A05C();
            }
            goto LABEL_81;
          }
LABEL_65:
          if (!*v16 || !*(_QWORD *)(a1 + 272))
          {
LABEL_78:
            if (dword_10008BA20)
            {
              v29 = ne_log_obj(v12);
              if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
                sub_100058FA0();
            }
            goto LABEL_81;
          }
        }
        v26 = sub_10000F9F8(a1);
        if ((_DWORD)v26)
        {
          if (dword_10008BA20)
          {
            v27 = ne_log_obj(v26);
            if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
              sub_1000590D4();
          }
          goto LABEL_81;
        }
        v6 = sub_10002AC24(a1);
        if ((_DWORD)v6 == -1)
        {
          v30 = 0;
        }
        else
        {
          if ((_DWORD)v6)
          {
            sub_10001B184(a1, v6, 0);
            goto LABEL_81;
          }
          sub_10002CACC(a1);
          if (dword_1000882C8 >= 7)
            sub_10003372C(7, (*v16)[1], **v16, "peer's ID\n", v31, v32, v33, v34, v35);
          memcpy(*(void **)(**(_QWORD **)(a1 + 328) + 8), *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 328) + 8) + 8), **(_QWORD **)(*(_QWORD *)(a1 + 328) + 8));
          sub_100003774(v3, 5445);
          v6 = 0;
          v30 = 1;
        }
        goto LABEL_82;
      case 5:
        v12 = sub_1000263B8((size_t **)(a1 + 320), *(_QWORD *)(v15 + 8));
        if ((v12 & 0x80000000) == 0)
          goto LABEL_31;
        if (dword_10008BA20)
        {
          v22 = ne_log_obj(v12);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
            sub_100059158();
        }
        goto LABEL_81;
      case 6:
        v12 = sub_10002C614(a1, *(_QWORD *)(v15 + 8));
        if ((v12 & 0x80000000) == 0)
        {
          v14 = 1;
LABEL_31:
          v15 += 16;
          continue;
        }
        if (dword_10008BA20)
        {
          v23 = ne_log_obj(v12);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
            sub_100059754();
        }
LABEL_81:
        v30 = 0;
        v6 = 0xFFFFFFFFLL;
LABEL_82:
        sub_10003F318(v13);
        sub_10003F318(v11);
        if ((v30 & 1) == 0)
          goto LABEL_10;
        return v6;
      case 7:
        v12 = sub_10002C8BC(a1, *(_QWORD *)(v15 + 8));
        if ((v12 & 0x80000000) == 0)
          goto LABEL_31;
        if (dword_10008BA20)
        {
          v24 = ne_log_obj(v12);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
            sub_100059184();
        }
        goto LABEL_81;
      case 8:
        *(_QWORD *)(a1 + 352) = *(_QWORD *)(v15 + 8);
        goto LABEL_31;
      case 9:
        v12 = sub_1000263B8((size_t **)(a1 + 272), *(_QWORD *)(v15 + 8));
        if ((v12 & 0x80000000) == 0)
          goto LABEL_31;
        if (dword_10008BA20)
        {
          v25 = ne_log_obj(v12);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
            sub_100059780();
        }
        goto LABEL_81;
      case 0xB:
        sub_10001BBF4(*(_QWORD *)(v15 + 8), a1);
        goto LABEL_31;
      case 0xD:
        v12 = sub_10003F06C(*(_QWORD *)(v15 + 8));
        goto LABEL_31;
      default:
        if (dword_10008BA20)
        {
          v21 = ne_log_obj(v12);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
            sub_100059D10();
        }
        goto LABEL_81;
    }
  }
}

uint64_t sub_100018C9C(uint64_t a1, uint64_t a2)
{
  int *v2;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  size_t *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  unint64_t v12;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;
  NSObject *v16;
  uint64_t v17;
  NSObject *v19;
  NSObject *v20;

  v2 = (int *)(a1 + 16);
  if (*(_DWORD *)(a1 + 16) == 5445)
  {
    v5 = sub_10000FFE8(a1);
    if ((v5 & 0x80000000) != 0)
    {
      if (dword_10008BA20)
      {
        v14 = ne_log_obj(v5);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
          sub_100058C18();
      }
    }
    else
    {
      if (dword_10008BA20)
      {
        v6 = ne_log_obj(v5);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
          sub_100059724();
      }
      v7 = sub_10002A470(a1, 1);
      *(_QWORD *)(a1 + 256) = v7;
      if (v7)
      {
        *(_BYTE *)(a1 + 82) |= 1u;
        v8 = sub_100016F88(a1);
        *(_QWORD *)(a1 + 128) = v8;
        if (v8)
        {
          v9 = sub_1000240A4(a1, v8);
          if ((v9 & 0x80000000) != 0)
          {
            if (dword_10008BA20)
            {
              v19 = ne_log_obj(v9);
              if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
                sub_100058CF4();
            }
          }
          else
          {
            v10 = *(_QWORD **)(a1 + 128);
            if (*(_DWORD *)(a1 + 100) && *v10 >= 0x501uLL)
            {
              v11 = 0;
              LODWORD(v12) = *(_DWORD *)(a1 + 96);
            }
            else
            {
              v12 = *(unsigned int *)(a1 + 96);
              v11 = (v12 >> 3) & 4;
            }
            v17 = sub_100009B6C(*(unsigned __int8 **)(a1 + 48), *(unsigned __int8 **)(a1 + 56), (uint64_t)v10, a2, v11, (v12 >> 5) & 1);
            if ((_DWORD)v17 != -1)
            {
              memcpy(*(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 328) + 8) + 8), *(const void **)(**(_QWORD **)(a1 + 328) + 8), ***(_QWORD ***)(a1 + 328));
              sub_100003774(v2, 9216);
              return 0;
            }
            if (dword_10008BA20)
            {
              v20 = ne_log_obj(v17);
              if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
                sub_10005961C();
            }
          }
        }
        else if (dword_10008BA20)
        {
          v16 = ne_log_obj(0);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
            sub_100059DA4();
        }
      }
      else if (dword_10008BA20)
      {
        v15 = ne_log_obj(0);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          sub_100059E68();
      }
    }
  }
  else if (dword_10008BA20)
  {
    v13 = ne_log_obj(a1);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      sub_100058E84();
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100018ED4(_BOOL8 a1, _QWORD *a2)
{
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  char v6;
  int v7;
  unint64_t *v8;
  unint64_t *v9;
  NSObject *v10;
  _BOOL4 v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  int v18;
  uint64_t v19;
  NSObject *v20;
  unint64_t v21;
  unsigned __int8 *v22;
  int v23;
  int v24;
  int v25;
  int v26;
  NSObject *v27;
  NSObject *v28;
  int v29;
  int v30;
  int v31;
  NSObject *v32;
  NSObject *v33;
  uint64_t v34;
  size_t v35;
  uint64_t v36;
  NSObject *v37;
  uint64_t v38;
  unsigned int v39;
  int v40;
  NSObject *v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  NSObject *v45;
  char *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  int v52;
  unint64_t v53;
  char *v54;
  char *v55;
  NSObject *v56;
  unsigned int v57;
  int v58;
  int v59;
  NSObject *v60;
  NSObject *v61;
  NSObject *v62;
  int v63;
  NSObject *v64;
  NSObject *v65;
  NSObject *v66;
  NSObject *v67;
  const char *v68;
  NSObject *v69;
  NSObject *v70;
  const char *v71;
  NSObject *v72;
  _QWORD *v73;
  _QWORD *v74;
  uint64_t v75;
  NSObject *v76;
  NSObject *v77;
  NSObject *v78;
  NSObject *v79;
  const char *v80;
  NSObject *v81;
  int v82;
  NSObject *v83;
  int v84;
  NSObject *v85;
  const char *v86;
  uint32_t v87;
  NSObject *v88;
  NSObject *v89;
  NSObject *v90;
  unsigned int v91;
  int v92;
  NSObject *v93;
  int v94;
  unsigned int *v95;
  NSObject *v96;
  NSObject *v97;
  unsigned int v98;
  NSObject *v99;
  unint64_t v100;
  int *v101;
  uint64_t v102;
  int v103;
  int v104;
  NSObject *v105;
  unint64_t v106;
  char *v107;
  char *v108;
  NSObject *v109;
  char *v110;
  unsigned int v111;
  int v112;
  int v113;
  uint64_t v114;
  uint64_t v115;
  size_t v116;
  void *v117;
  NSObject *v118;
  NSObject *v119;
  char *v120;
  char *v121;
  int v122;
  int v123;
  uint64_t v124;
  NSObject *v125;
  char *v126;
  NSObject *v127;
  uint64_t v128;
  uint64_t v129;
  NSObject *v130;
  int v131;
  NSObject *v133;
  uint64_t v134;
  unint64_t *v136;
  NSObject *v137;
  NSObject *v138;
  unsigned __int16 *v139;
  size_t v140;
  NSObject *v141;
  NSObject *v142;
  NSObject *v143;
  _QWORD *v144;
  _QWORD *v145;
  uint64_t v146;
  _QWORD *v147;
  size_t v148;
  uint64_t v149;
  NSObject *v150;
  NSObject *v151;
  NSObject *v152;
  NSObject *v153;
  NSObject *v154;
  NSObject *v155;
  NSObject *v156;
  int v157;
  _QWORD *v158;
  unsigned __int8 *v159;
  int v160;
  char v161;
  char v162[15];
  char v163;
  char v164[15];
  char v165;
  char v166[15];
  char v167;
  char v168[15];
  char v169;
  char v170[11];
  int v171;
  char v172[16];
  uint8_t buf[4];
  _BYTE v174[20];
  _BYTE v175[6];
  _BYTE v176[10];
  __int16 v177;
  int v178;
  char v179[16];
  char v180[16];
  char v181[16];
  uint8_t v182[4];
  unsigned int v183[3];

  v3 = a1;
  if (dword_10008BA20)
  {
    v4 = ne_log_obj(a1);
    a1 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    if (a1)
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "receive Information.\n", buf, 2u);
    }
  }
  v5 = a2[1];
  v6 = *(_BYTE *)(v5 + 19);
  v7 = *(_DWORD *)(v5 + 20);
  if ((v6 & 1) == 0)
  {
    v8 = sub_10003F34C((uint64_t)a2);
    v9 = v8;
    if (*v8 < 0x20)
    {
LABEL_6:
      if (dword_10008BA20)
      {
        v10 = ne_log_obj(v8);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
          sub_10005A0BC();
      }
      goto LABEL_9;
    }
    v21 = v8[1];
    v24 = *(unsigned __int8 *)(v21 + 28);
    v22 = (unsigned __int8 *)(v21 + 28);
    v23 = v24;
    v25 = *(unsigned __int8 *)(v3 + 81);
    if (v25 == 4)
    {
      v26 = *(_DWORD *)(v3 + 16);
      if ((v26 & 0x2000) == 0)
      {
        v29 = *(_DWORD *)(v3 + 20);
        if (v26 == 5283 && !v29)
          goto LABEL_50;
        if (v26 == 5507 && v29 == 1)
          goto LABEL_50;
      }
    }
    else
    {
      if (v25 != 2)
        goto LABEL_251;
      v26 = *(_DWORD *)(v3 + 16);
    }
    if ((v26 & 0x2000) == 0)
    {
      v30 = *(_DWORD *)(v3 + 20);
      if (v30 == 1)
      {
        v31 = 5445;
      }
      else
      {
        if (v30)
          goto LABEL_251;
        if (v26 == 5190)
        {
LABEL_50:
          v159 = v22;
          v34 = (uint64_t)v8;
          goto LABEL_51;
        }
        v31 = 5221;
      }
      if (v26 == v31)
        goto LABEL_50;
    }
LABEL_251:
    v11 = !v23 && (v131 = *(_DWORD *)(v3 + 16), (v131 & 0x2000) == 0) && v131 == 5281 && *(_DWORD *)(v3 + 20) == 0;
    if (dword_10008BA20)
    {
      v133 = ne_log_obj(v8);
      if (os_log_type_enabled(v133, OS_LOG_TYPE_ERROR))
        sub_10005A0E8(v23, v3, v133);
    }
    v12 = 0;
    goto LABEL_264;
  }
  if (!*(_QWORD *)(v3 + 328))
  {
    if (dword_10008BA20)
    {
      v27 = ne_log_obj(a1);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        sub_10005A42C();
    }
    return 0xFFFFFFFFLL;
  }
  v13 = sub_10002DA88(v3, v7);
  if (!v13)
  {
    if (dword_10008BA20)
    {
      v28 = ne_log_obj(0);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        sub_10005A458();
    }
    return 0xFFFFFFFFLL;
  }
  v14 = v13;
  v9 = sub_10002E000(v3, a2, *v13, v13[1]);
  sub_10002DA18(v14);
  if (!v9)
  {
    if (dword_10008BA20)
    {
      v32 = ne_log_obj(v8);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
        sub_10005A484();
    }
    return 0xFFFFFFFFLL;
  }
  v15 = *v9;
  if (*v9 <= 0x1F)
    goto LABEL_6;
  v16 = v9[1];
  if (*(_BYTE *)(v16 + 16) != 8)
  {
    if (dword_10008BA20)
    {
      v33 = ne_log_obj(v8);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
        sub_10005A648();
    }
    goto LABEL_9;
  }
  v17 = v16 + 28;
  v18 = *(unsigned __int8 *)(v16 + 28);
  if ((*(_BYTE *)(v3 + 17) & 0x20) == 0 && (!*(_QWORD *)(v3 + 72) || !*(_QWORD *)(v3 + 208)))
  {
    if (dword_10008BA20)
    {
      v142 = ne_log_obj(v8);
      if (os_log_type_enabled(v142, OS_LOG_TYPE_ERROR))
        sub_10005A4B0();
    }
    goto LABEL_9;
  }
  v19 = bswap32(*(unsigned __int16 *)(v16 + 30)) >> 16;
  if (v15 < v19 + 32)
  {
    if (dword_10008BA20)
    {
      v20 = ne_log_obj(v8);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        sub_10005A4DC();
    }
    goto LABEL_9;
  }
  v139 = (unsigned __int16 *)(v17 + v19);
  v140 = bswap32(*(unsigned __int16 *)(v17 + v19 + 2)) >> 16;
  if (v15 - v19 - 28 < v140)
  {
    if (dword_10008BA20)
    {
      v141 = ne_log_obj(v140);
      if (os_log_type_enabled(v141, OS_LOG_TYPE_ERROR))
        sub_10005A508();
    }
    goto LABEL_9;
  }
  if (v140 <= 3)
  {
    if (dword_10008BA20)
    {
      v143 = ne_log_obj(v140);
      if (os_log_type_enabled(v143, OS_LOG_TYPE_ERROR))
        sub_10005A534();
    }
    goto LABEL_9;
  }
  v159 = (unsigned __int8 *)(v16 + 28);
  v144 = sub_10003F1F8(v140);
  if (!v144)
  {
    if (dword_10008BA20)
    {
      v153 = ne_log_obj(0);
      if (os_log_type_enabled(v153, OS_LOG_TYPE_ERROR))
        sub_10005A560();
    }
    goto LABEL_9;
  }
  v145 = v144;
  memcpy((void *)v144[1], v139, bswap32(v139[1]) >> 16);
  v146 = sub_10002A3A0(v3, *(_DWORD *)(v16 + 20), (uint64_t)v145);
  if (!v146)
  {
    if (dword_10008BA20)
    {
      v154 = ne_log_obj(0);
      if (os_log_type_enabled(v154, OS_LOG_TYPE_ERROR))
        sub_10005A58C();
    }
    goto LABEL_314;
  }
  v147 = (_QWORD *)v146;
  v148 = (bswap32(*(unsigned __int16 *)(v16 + 30)) >> 16) - 4;
  if (v148 != *(_QWORD *)v146)
  {
    if (dword_10008BA20)
    {
      v155 = ne_log_obj(v146);
      if (os_log_type_enabled(v155, OS_LOG_TYPE_ERROR))
        sub_10005A61C();
    }
    goto LABEL_313;
  }
  v149 = timingsafe_bcmp((const void *)(v16 + 32), *(const void **)(v146 + 8), v148);
  if ((_DWORD)v149)
  {
    if (dword_10008BA20)
    {
      v150 = ne_log_obj(v149);
      if (os_log_type_enabled(v150, OS_LOG_TYPE_ERROR))
        sub_10005A5F0();
    }
LABEL_313:
    sub_10003F318(v147);
LABEL_314:
    sub_10003F318(v145);
    goto LABEL_9;
  }
  if (dword_10008BA20)
  {
    v156 = ne_log_obj(v149);
    if (os_log_type_enabled(v156, OS_LOG_TYPE_DEBUG))
      sub_10005A5B8();
  }
  sub_10003F318(v147);
  sub_10003F318(v145);
  v34 = (uint64_t)v9;
  v23 = v18;
LABEL_51:
  v35 = (size_t)sub_1000232C8(v34);
  if (!v35)
  {
    if (dword_10008BA20)
    {
      v136 = (unint64_t *)v34;
      v137 = ne_log_obj(0);
      if (os_log_type_enabled(v137, OS_LOG_TYPE_ERROR))
        sub_100058EE4();
      v11 = 0;
      v12 = 0xFFFFFFFFLL;
      v9 = v136;
      goto LABEL_264;
    }
    v9 = (unint64_t *)v34;
LABEL_9:
    v11 = 0;
    v12 = 0xFFFFFFFFLL;
    goto LABEL_264;
  }
  v9 = (unint64_t *)v35;
  v157 = v23;
  v12 = 0;
  v160 = 0;
  v158 = (_QWORD *)v34;
  v36 = *(_QWORD *)(v35 + 8) + 8;
  while (2)
  {
    switch(*(_BYTE *)(v36 - 8))
    {
      case 8:
        goto LABEL_240;
      case 9:
        goto LABEL_98;
      case 0xA:
        if (dword_10008BA20)
        {
          v37 = ne_log_obj(v35);
          v35 = os_log_type_enabled(v37, OS_LOG_TYPE_ERROR);
          if ((_DWORD)v35)
            sub_10005A400(&v161, v162);
        }
        goto LABEL_240;
      case 0xB:
        v38 = *(_QWORD *)v36;
        v39 = *(unsigned __int16 *)(*(_QWORD *)v36 + 10);
        if (v39 == 3584)
        {
          v40 = *(_DWORD *)(v3 + 16);
          if ((v40 & 0x2000) == 0 && v40 == 5281 && !*(_DWORD *)(v3 + 20))
          {
            if (dword_10008BA20)
            {
              v41 = ne_log_obj(v35);
              v35 = os_log_type_enabled(v41, OS_LOG_TYPE_ERROR);
              if ((_DWORD)v35)
              {
                v120 = sub_10003DBA0(v157);
                v121 = sub_10003DB2C(14);
                v122 = *(_DWORD *)(v3 + 16);
                v123 = *(_DWORD *)(v3 + 20);
                *(_DWORD *)buf = 136315906;
                *(_QWORD *)v174 = v120;
                *(_WORD *)&v174[8] = 2080;
                *(_QWORD *)&v174[10] = v121;
                *(_WORD *)&v174[18] = 1024;
                *(_DWORD *)v175 = v122;
                *(_WORD *)&v175[4] = 1024;
                *(_DWORD *)v176 = v123;
                _os_log_error_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "%s message with %s notification receveid, status 0x%x, side %d\n", buf, 0x22u);
              }
            }
            v160 = 1;
            goto LABEL_240;
          }
        }
        v52 = __rev16(v39);
        if (v52 > 36135)
        {
          if (v52 > 40499)
          {
            if (v52 == 40500)
              goto LABEL_210;
            if (v52 == 40501)
            {
              if (*(_DWORD *)(v3 + 20))
              {
                if (!dword_10008BA20)
                  goto LABEL_210;
                v66 = ne_log_obj(v35);
                v35 = os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT);
                if (!(_DWORD)v35)
                  goto LABEL_210;
                *(_WORD *)buf = 0;
                v67 = v66;
                v68 = "LOAD-BALANCE notification ignored - we are not the initiator.\n";
              }
              else if ((v6 & 1) != 0)
              {
                if (*(_WORD *)(v38 + 2) == 0x2000)
                {
                  v94 = sub_10000A9C8(v3);
                  v95 = (unsigned int *)(v38 + 28);
                  v35 = sub_1000487BC(0x9E35u, 1u, v94, 4u, (const void *)(v38 + 28));
                  if (dword_10008BA20)
                  {
                    v96 = ne_log_obj(v35);
                    v35 = os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT);
                    if ((_DWORD)v35)
                    {
                      *(_WORD *)buf = 0;
                      _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_DEFAULT, "Received LOAD_BALANCE notification.\n", buf, 2u);
                    }
                  }
                  if (*(_DWORD *)(*(_QWORD *)(v3 + 48) + 4) != bswap32(*v95))
                  {
                    if (dword_10008BA20)
                    {
                      v97 = ne_log_obj(v35);
                      if (os_log_type_enabled(v97, OS_LOG_TYPE_DEFAULT))
                      {
                        v98 = bswap32(*v95);
                        *(_DWORD *)buf = 67109120;
                        *(_DWORD *)v174 = v98;
                        _os_log_impl((void *)&_mh_execute_header, v97, OS_LOG_TYPE_DEFAULT, "Deleting old Phase 1 because of LOAD_BALANCE notification - redirect address=%x.\n", buf, 8u);
                      }
                    }
                    if ((*(_BYTE *)(v3 + 17) & 0x20) != 0)
                      sub_10001A528(v3);
                    v35 = (size_t)sub_100022B8C(v3);
                  }
                  goto LABEL_210;
                }
                if (!dword_10008BA20
                  || (v105 = ne_log_obj(v35),
                      v35 = os_log_type_enabled(v105, OS_LOG_TYPE_DEFAULT),
                      !(_DWORD)v35))
                {
LABEL_210:
                  v106 = *(unsigned __int8 *)(v38 + 9);
                  if (*(_BYTE *)(v38 + 9))
                  {
                    if (v106 + 12 > bswap32(*(unsigned __int16 *)(v38 + 2)) >> 16)
                    {
                      if (dword_10008BA20)
                      {
                        v138 = ne_log_obj(v35);
                        if (os_log_type_enabled(v138, OS_LOG_TYPE_ERROR))
                          sub_10005A228();
                      }
                      goto LABEL_277;
                    }
                    v107 = sub_10003D3A0(v38 + 12, v106);
                    v108 = v107;
                    if (dword_10008BA20)
                    {
                      v109 = ne_log_obj(v107);
                      if (os_log_type_enabled(v109, OS_LOG_TYPE_DEFAULT))
                      {
                        v110 = sub_10003DB2C(v52);
                        v111 = bswap32(*(_DWORD *)(v38 + 4));
                        v112 = *(unsigned __int8 *)(v38 + 8);
                        v113 = *(unsigned __int8 *)(v38 + 9);
                        *(_DWORD *)buf = 67110402;
                        *(_DWORD *)v174 = v52;
                        *(_WORD *)&v174[4] = 2080;
                        *(_QWORD *)&v174[6] = v110;
                        *(_WORD *)&v174[14] = 1024;
                        *(_DWORD *)&v174[16] = v111;
                        *(_WORD *)v175 = 1024;
                        *(_DWORD *)&v175[2] = v112;
                        *(_WORD *)v176 = 2080;
                        *(_QWORD *)&v176[2] = v108;
                        v177 = 1024;
                        v178 = v113;
                        _os_log_impl((void *)&_mh_execute_header, v109, OS_LOG_TYPE_DEFAULT, "Notification message %d:%s, doi=%d proto_id=%d spi=%s(size=%d).\n", buf, 0x2Eu);
                      }
                    }
                    free(v108);
                  }
                  if ((unsigned __int16)(v52 - 1) <= 0x3FFEu)
                  {
                    v114 = (bswap32(*(unsigned __int16 *)(v38 + 2)) >> 16) - 12;
                    v115 = *(unsigned __int8 *)(v38 + 9);
                    v35 = v114 - v115;
                    if (v114 != v115)
                    {
                      v35 = (size_t)sub_10003F1F8(v35);
                      if (v35)
                      {
                        v116 = v35;
                        v117 = memcpy(*(void **)(v35 + 8), (const void *)(v115 + v38 + 12), *(_QWORD *)v35);
                        if (dword_10008BA20)
                        {
                          v118 = ne_log_obj(v117);
                          if (os_log_type_enabled(v118, OS_LOG_TYPE_ERROR))
                          {
                            v126 = sub_1000291E4(*(char **)(v116 + 8), *(_QWORD *)v116);
                            *(_DWORD *)buf = 136315138;
                            *(_QWORD *)v174 = v126;
                            _os_log_error_impl((void *)&_mh_execute_header, v118, OS_LOG_TYPE_ERROR, "Message: '%s'.\n", buf, 0xCu);
                          }
                        }
                        sub_10003F318((_QWORD *)v116);
                      }
                      else if (dword_10008BA20)
                      {
                        v119 = ne_log_obj(0);
                        v35 = os_log_type_enabled(v119, OS_LOG_TYPE_ERROR);
                        if ((_DWORD)v35)
                          sub_10005A1FC(&v163, v164);
                      }
                    }
                  }
                  goto LABEL_239;
                }
                *(_WORD *)buf = 0;
                v67 = v105;
                v68 = "isakmp_info_recv_lb Invalid length of payload\n";
              }
              else
              {
                if (!dword_10008BA20)
                  goto LABEL_210;
                v89 = ne_log_obj(v35);
                v35 = os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT);
                if (!(_DWORD)v35)
                  goto LABEL_210;
                *(_WORD *)buf = 0;
                v67 = v89;
                v68 = "LOAD-BALANCE notification ignored - not protected.\n";
              }
              _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, v68, buf, 2u);
              goto LABEL_210;
            }
LABEL_144:
            if ((unsigned __int16)(v52 - 1) > 0x3FFEu)
            {
              if (dword_10008BA20)
              {
                v81 = ne_log_obj(v35);
                v35 = os_log_type_enabled(v81, OS_LOG_TYPE_ERROR);
                if ((_DWORD)v35)
                  sub_10005A2CC((uint64_t)v179, v52);
              }
            }
            else
            {
              if (!v7)
              {
                if (dword_10008BA20)
                {
                  v152 = ne_log_obj(v35);
                  if (os_log_type_enabled(v152, OS_LOG_TYPE_ERROR))
                    sub_10005A1D0();
                }
                goto LABEL_277;
              }
              v35 = sub_100008AA0(v3, v7);
              if (v35)
              {
                if (dword_10008BA20)
                {
                  v77 = ne_log_obj(v35);
                  v35 = os_log_type_enabled(v77, OS_LOG_TYPE_ERROR);
                  if ((_DWORD)v35)
                    sub_10005A290((uint64_t)v180, v52);
                }
              }
              else if (dword_10008BA20)
              {
                v99 = ne_log_obj(0);
                v35 = os_log_type_enabled(v99, OS_LOG_TYPE_ERROR);
                if ((_DWORD)v35)
                  sub_10005A254((uint64_t)v181, v52);
              }
            }
            goto LABEL_210;
          }
          if (v52 != 36136)
          {
            if (v52 == 36137)
            {
              if ((v6 & 1) != 0)
              {
                if (dword_10008BA20)
                {
                  v62 = ne_log_obj(v35);
                  v35 = os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT);
                  if ((_DWORD)v35)
                  {
                    *(_WORD *)buf = 0;
                    _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "DPD R-U-There-Ack received\n", buf, 2u);
                  }
                }
                v63 = *(unsigned __int16 *)(v3 + 384);
                if (bswap32(*(_DWORD *)(v38 + 28)) == v63)
                {
                  if (*(_QWORD *)(v38 + 12) == *(_QWORD *)v3 && *(_QWORD *)(v38 + 20) == *(_QWORD *)(v3 + 8))
                  {
                    *(_BYTE *)(v3 + 386) = 0;
                    *(_WORD *)(v3 + 384) = v63 + 1;
                    *(_QWORD *)(v3 + 376) = time(0);
                    v128 = *(unsigned int *)(v3 + 388);
                    if ((_DWORD)v128)
                    {
                      sub_10003A6F0(v128);
                      *(_DWORD *)(v3 + 388) = 0;
                    }
                    v129 = sub_10001C3BC(v3, 0);
                    if (dword_10008BA20)
                    {
                      v130 = ne_log_obj(v129);
                      if (os_log_type_enabled(v130, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_WORD *)buf = 0;
                        _os_log_impl((void *)&_mh_execute_header, v130, OS_LOG_TYPE_DEFAULT, "received an R-U-THERE-ACK\n", buf, 2u);
                      }
                    }
                    v35 = sub_100048E70(1, v3);
                  }
                  else if (dword_10008BA20)
                  {
                    v64 = ne_log_obj(v35);
                    v35 = os_log_type_enabled(v64, OS_LOG_TYPE_ERROR);
                    if ((_DWORD)v35)
                      sub_10005A360(&v167, v168);
                  }
                }
                else if (dword_10008BA20)
                {
                  v90 = ne_log_obj(v35);
                  v35 = os_log_type_enabled(v90, OS_LOG_TYPE_ERROR);
                  if ((_DWORD)v35)
                  {
                    v91 = bswap32(*(_DWORD *)(v38 + 28));
                    v92 = *(unsigned __int16 *)(v3 + 384);
                    *(_DWORD *)buf = 67109376;
                    *(_DWORD *)v174 = v91;
                    *(_WORD *)&v174[4] = 1024;
                    *(_DWORD *)&v174[6] = v92;
                    v85 = v90;
                    v86 = "Wrong DPD sequence number (%d, %d expected).\n";
LABEL_204:
                    v87 = 14;
LABEL_205:
                    _os_log_error_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_ERROR, v86, buf, v87);
                  }
                }
                goto LABEL_239;
              }
              goto LABEL_210;
            }
            goto LABEL_144;
          }
          if ((v6 & 1) == 0)
            goto LABEL_210;
          if (dword_10008BA20)
          {
            v72 = ne_log_obj(v35);
            if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "DPD R-U-There received\n", buf, 2u);
            }
          }
          v73 = sub_10003F1F8(0x20uLL);
          if (v73)
          {
            v74 = v73;
            v75 = v73[1];
            *(_BYTE *)v75 = 0;
            *(_WORD *)(v75 + 2) = 0x2000;
            *(_QWORD *)(v75 + 4) = 0x298D100101000000;
            *(_QWORD *)(v75 + 12) = *(_QWORD *)(v38 + 12);
            *(_QWORD *)(v75 + 20) = *(_QWORD *)(v38 + 20);
            *(_DWORD *)(v75 + 28) = *(_DWORD *)(v38 + 28);
            v12 = sub_10001A5E8(v3, (uint64_t)v73, 11, 1);
            sub_10003F318(v74);
            if (dword_10008BA20)
            {
              v76 = ne_log_obj(v35);
              v35 = os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT);
              if ((_DWORD)v35)
              {
                *(_WORD *)buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "received a valid R-U-THERE, ACK sent\n", buf, 2u);
              }
            }
          }
          else
          {
            if (dword_10008BA20)
            {
              v93 = ne_log_obj(0);
              if (os_log_type_enabled(v93, OS_LOG_TYPE_ERROR))
                sub_10005A334(&v165, v166);
            }
            v35 = (size_t)__error();
            v12 = *(unsigned int *)v35;
          }
          if ((v12 & 0x80000000) != 0)
            goto LABEL_278;
LABEL_240:
          v36 += 16;
          continue;
        }
        if (v52 > 24576)
        {
          if (v52 == 24577)
            goto LABEL_210;
          if (v52 != 24578)
            goto LABEL_144;
          if ((v6 & 1) == 0)
            goto LABEL_210;
          sub_10001B88C(v3);
LABEL_239:
          v12 = 0;
          goto LABEL_240;
        }
        if (v52 == 0x4000)
          goto LABEL_210;
        if (v52 != 24576)
          goto LABEL_144;
        if ((v6 & 1) == 0)
          goto LABEL_210;
        v53 = *(unsigned __int8 *)(v38 + 9);
        if (v53 + 12 <= bswap32(*(unsigned __int16 *)(v38 + 2)) >> 16)
        {
          v54 = sub_10003D3A0(v38 + 12, v53);
          v55 = v54;
          if (dword_10008BA20)
          {
            v56 = ne_log_obj(v54);
            if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
            {
              v57 = bswap32(*(_DWORD *)(v38 + 4));
              v58 = *(unsigned __int8 *)(v38 + 8);
              v59 = *(unsigned __int8 *)(v38 + 9);
              *(_DWORD *)buf = 67109890;
              *(_DWORD *)v174 = v57;
              *(_WORD *)&v174[4] = 1024;
              *(_DWORD *)&v174[6] = v58;
              *(_WORD *)&v174[10] = 2080;
              *(_QWORD *)&v174[12] = v55;
              *(_WORD *)v175 = 1024;
              *(_DWORD *)&v175[2] = v59;
              _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "notification message ISAKMP-SA RESPONDER-LIFETIME, doi=%d proto_id=%d spi=%s(size=%d).\n", buf, 0x1Eu);
            }
          }
          free(v55);
          goto LABEL_239;
        }
        if (dword_10008BA20)
        {
          v151 = ne_log_obj(v35);
          if (os_log_type_enabled(v151, OS_LOG_TYPE_ERROR))
            sub_10005A308();
        }
LABEL_277:
        v12 = 0xFFFFFFFFLL;
LABEL_278:
        sub_10003F318(v158);
        v11 = v160;
LABEL_264:
        sub_10003F318(v9);
        if (v11)
        {
          v134 = *(_QWORD *)(v3 + 440);
          if (v134)
          {
            gettimeofday((timeval *)(v134 + 336), 0);
            if (!*(_QWORD *)(v134 + 296))
              *(_QWORD *)(v134 + 296) = off_100088528;
            sub_10004CDE8(v134);
          }
        }
        return v12;
      case 0xC:
        v42 = *(_QWORD *)v36;
        v171 = 0;
        v43 = dword_10008BA20;
        if (*(_DWORD *)(v42 + 4) == 0x1000000)
          goto LABEL_66;
        if (dword_10008BA20)
        {
          v61 = ne_log_obj(v35);
          v35 = os_log_type_enabled(v61, OS_LOG_TYPE_ERROR);
          if ((_DWORD)v35)
            sub_10005A3B8(v182, (unsigned int *)(v42 + 4), v183, v61);
        }
        if ((**(_BYTE **)(v3 + 408) & 2) == 0 || *(_DWORD *)(v42 + 4))
          goto LABEL_239;
        v43 = dword_10008BA20;
LABEL_66:
        v44 = bswap32(*(unsigned __int16 *)(v42 + 10)) >> 16;
        if ((bswap32(*(unsigned __int16 *)(v42 + 2)) >> 16) - 12 != *(unsigned __int8 *)(v42 + 9) * (_DWORD)v44)
        {
          if (v43)
          {
            v65 = ne_log_obj(v35);
            v35 = os_log_type_enabled(v65, OS_LOG_TYPE_ERROR);
            if ((_DWORD)v35)
              sub_10005A38C(&v169, v170);
          }
          goto LABEL_239;
        }
        if (v43)
        {
          v45 = ne_log_obj(v35);
          v35 = os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT);
          if ((_DWORD)v35)
          {
            v46 = sub_10003DCFC(*(unsigned __int8 *)(v42 + 8));
            *(_DWORD *)buf = 136315138;
            *(_QWORD *)v174 = v46;
            _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "delete payload for protocol %s\n", buf, 0xCu);
          }
        }
        v47 = *(_QWORD *)(v3 + 64);
        if (*(_DWORD *)(v47 + 240) | v6 & 1)
        {
          v48 = *(unsigned __int8 *)(v42 + 8);
          if ((v48 - 2) < 2)
          {
            if (*(_BYTE *)(v42 + 9) != 4)
            {
              if (dword_10008BA20)
              {
                v88 = ne_log_obj(v35);
                v35 = os_log_type_enabled(v88, OS_LOG_TYPE_ERROR);
                if ((_DWORD)v35)
                {
LABEL_203:
                  v103 = *(unsigned __int8 *)(v42 + 9);
                  v104 = *(unsigned __int8 *)(v42 + 8);
                  *(_DWORD *)buf = 67109376;
                  *(_DWORD *)v174 = v103;
                  *(_WORD *)&v174[4] = 1024;
                  *(_DWORD *)&v174[6] = v104;
                  v85 = v88;
                  v86 = "delete payload with strange spi size %d(proto_id:%d)\n";
                  goto LABEL_204;
                }
              }
              goto LABEL_239;
            }
            if (*(_DWORD *)(v47 + 180) && (*(_WORD *)(*(_QWORD *)(v3 + 440) + 264) & 8) != 0)
            {
              v35 = (size_t)sub_100008C2C(*(_QWORD *)(v3 + 56), *(_QWORD *)(v3 + 48), *(unsigned __int8 *)(v42 + 8), *(_DWORD *)(v42 + 12));
              if (v35)
              {
                *(_BYTE *)(v35 + 264) |= 4u;
                if (!dword_10008BA20)
                  goto LABEL_239;
                v78 = ne_log_obj(v35);
                v35 = os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT);
                if (!(_DWORD)v35)
                {
LABEL_235:
                  if (dword_10008BA20)
                  {
                    v125 = ne_log_obj(v35);
                    v35 = os_log_type_enabled(v125, OS_LOG_TYPE_DEFAULT);
                    if ((_DWORD)v35)
                    {
                      *(_WORD *)buf = 0;
                      v70 = v125;
                      v71 = "purged SAs.\n";
                      goto LABEL_238;
                    }
                  }
                  goto LABEL_239;
                }
                *(_WORD *)buf = 0;
                v79 = v78;
                v80 = "Ignoring SA delete from peer for L2TP server\n";
LABEL_244:
                _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_DEFAULT, v80, buf, 2u);
                goto LABEL_235;
              }
              v48 = *(unsigned __int8 *)(v42 + 8);
            }
            v100 = *(_QWORD *)(v3 + 48);
            v101 = (int *)(v42 + 12);
            v102 = v48;
          }
          else
          {
            if ((_DWORD)v48 != 4)
            {
              if ((_DWORD)v48 != 1)
              {
                if (dword_10008BA20)
                {
                  v83 = ne_log_obj(v35);
                  v35 = os_log_type_enabled(v83, OS_LOG_TYPE_ERROR);
                  if ((_DWORD)v35)
                  {
                    v84 = *(unsigned __int8 *)(v42 + 8);
                    *(_DWORD *)buf = 67109120;
                    *(_DWORD *)v174 = v84;
                    v85 = v83;
                    v86 = "deletion message received, invalid proto_id: %d\n";
                    v87 = 8;
                    goto LABEL_205;
                  }
                }
                goto LABEL_239;
              }
              if (*(_BYTE *)(v42 + 9) != 16)
              {
                if (dword_10008BA20)
                {
                  v88 = ne_log_obj(v35);
                  v35 = os_log_type_enabled(v88, OS_LOG_TYPE_ERROR);
                  if ((_DWORD)v35)
                    goto LABEL_203;
                }
                goto LABEL_239;
              }
              v35 = sub_100007EB0(*(_QWORD *)(v3 + 440), (_QWORD *)(v42 + 12));
              if (!v35)
                goto LABEL_235;
              v49 = v35;
              if (*(_DWORD *)(v35 + 116))
              {
                v50 = *(_QWORD *)(v35 + 440);
                if (v50)
                {
                  v51 = *(unsigned __int16 *)(v50 + 264);
                  if ((~v51 & 0x401) == 0 && ((v51 & 8) == 0 || !*(_DWORD *)(*(_QWORD *)(v35 + 64) + 180)))
                    sub_100024B1C(v35, 0);
                }
              }
              v35 = *(unsigned int *)(v49 + 120);
              if ((_DWORD)v35)
              {
                v35 = sub_10003A6F0(v35);
                *(_DWORD *)(v49 + 120) = 0;
              }
              if (*(_DWORD *)(v49 + 24)
                || (*(_BYTE *)(v49 + 432) & 1) != 0
                && (v124 = *(_QWORD *)(v49 + 440)) != 0
                && (*(_WORD *)(v124 + 264) & 0x400) != 0)
              {
                v35 = sub_10000838C(v49);
                if ((_DWORD)v35)
                  v35 = sub_10001AE80(v49, 1, 50002, 0);
              }
              if (!*(_DWORD *)(*(_QWORD *)(v49 + 64) + 180) || (*(_WORD *)(*(_QWORD *)(v49 + 440) + 264) & 8) == 0)
              {
                v35 = (size_t)sub_100022B8C(v49);
                goto LABEL_235;
              }
              if (!dword_10008BA20)
                goto LABEL_239;
              v127 = ne_log_obj(v35);
              v35 = os_log_type_enabled(v127, OS_LOG_TYPE_DEFAULT);
              if (!(_DWORD)v35)
                goto LABEL_235;
              *(_WORD *)buf = 0;
              v79 = v127;
              v80 = "Ignoring IKE delete from peer for L2TP server\n";
              goto LABEL_244;
            }
            v171 = 0;
            v82 = *(unsigned __int8 *)(v42 + 9);
            if (v82 == 4)
            {
              v171 = *(_DWORD *)(v42 + 12);
            }
            else
            {
              if (v82 != 2)
              {
                if (dword_10008BA20)
                {
                  v88 = ne_log_obj(v35);
                  v35 = os_log_type_enabled(v88, OS_LOG_TYPE_ERROR);
                  if ((_DWORD)v35)
                    goto LABEL_203;
                }
                goto LABEL_239;
              }
              HIWORD(v171) = *(_WORD *)(v42 + 12);
            }
            v100 = *(_QWORD *)(v3 + 48);
            v101 = &v171;
            v102 = 4;
          }
          sub_10001B534(v100, v102, v101, v44, 0, 0);
          goto LABEL_235;
        }
        if (dword_10008BA20)
        {
          v69 = ne_log_obj(v35);
          v35 = os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT);
          if ((_DWORD)v35)
          {
            *(_WORD *)buf = 0;
            v70 = v69;
            v71 = "Ignoring unencrypted delete payload (check the weak_phase1_check option)\n";
LABEL_238:
            _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, v71, buf, 2u);
            goto LABEL_239;
          }
        }
        goto LABEL_239;
      default:
        if (!*(_BYTE *)(v36 - 8))
          goto LABEL_278;
LABEL_98:
        if (dword_10008BA20)
        {
          v60 = ne_log_obj(v35);
          v35 = os_log_type_enabled(v60, OS_LOG_TYPE_ERROR);
          if ((_DWORD)v35)
            sub_10005A184((uint64_t)v172, v159);
        }
        goto LABEL_239;
    }
  }
}

uint64_t sub_10001A528(uint64_t a1)
{
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;

  if ((*(_BYTE *)(a1 + 17) & 0x20) == 0)
    return 0;
  v3 = sub_10003F1F8(0x1CuLL);
  if (v3)
  {
    v4 = v3;
    v5 = v3[1];
    *(_BYTE *)v5 = 0;
    *(_WORD *)(v5 + 2) = 7168;
    *(_QWORD *)(v5 + 4) = 0x100100101000000;
    *(_OWORD *)(v5 + 12) = *(_OWORD *)a1;
    v6 = sub_10001A5E8(a1, (uint64_t)v3, 12, 0);
    sub_10003F318(v4);
    return v6;
  }
  else
  {
    if (dword_10008BA20)
    {
      v7 = ne_log_obj(0);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_10005A674();
    }
    return *__error();
  }
}

uint64_t sub_10001A5E8(uint64_t a1, uint64_t a2, int a3, char a4)
{
  _BYTE *v8;
  uint64_t v9;
  void *v10;
  void *v11;
  int v12;
  int v14;
  uint64_t *v15;
  const void **v16;
  const void **v17;
  uint64_t v18;
  NSObject *v19;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  uint64_t v23;
  char v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  char v28;
  size_t v29;
  char *v30;
  NSObject *v31;
  NSObject *v32;
  NSObject *v33;
  uint64_t v34;
  size_t *v36;
  _QWORD *v37;
  uint64_t v38;
  NSObject *v39;
  _QWORD *v40;
  NSObject *v41;
  _QWORD *v42;
  NSObject *v43;
  int v44;
  char *v45;

  v8 = sub_100008D90(16, 1);
  if (!v8)
  {
    if (dword_10008BA20)
    {
      v19 = ne_log_obj(0);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        sub_10005A6A0();
    }
    return 0xFFFFFFFFLL;
  }
  v9 = (uint64_t)v8;
  v10 = sub_10003C6F8(*(unsigned __int8 **)(a1 + 48));
  *(_QWORD *)(v9 + 8) = v10;
  if (!v10)
  {
    if (dword_10008BA20)
    {
      v20 = ne_log_obj(0);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        sub_10005A6CC();
    }
    goto LABEL_43;
  }
  v11 = sub_10003C6F8(*(unsigned __int8 **)(a1 + 56));
  *(_QWORD *)v9 = v11;
  if (!v11)
  {
    if (dword_10008BA20)
    {
      v21 = ne_log_obj(0);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        sub_10005A6F8();
    }
    goto LABEL_43;
  }
  v12 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 48) + 1);
  if (v12 != 2 && v12 != 30)
  {
    if (dword_10008BA20)
    {
      v22 = ne_log_obj(v11);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        sub_10005A724(a1 + 48, v22, v23);
    }
LABEL_43:
    sub_100008F90(v9);
    return 0xFFFFFFFFLL;
  }
  *(_BYTE *)(v9 + 60) = 0;
  sub_100003774((int *)(v9 + 56), 63);
  v14 = sub_1000264E8(a1);
  *(_DWORD *)(v9 + 108) = v14;
  if (*(_QWORD *)(a1 + 208))
  {
    v15 = sub_10002DA88(a1, v14);
    *(_QWORD *)(v9 + 240) = v15;
    if (!v15)
    {
      if (dword_10008BA20)
      {
        v31 = ne_log_obj(0);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
          sub_1000590A8();
      }
      goto LABEL_43;
    }
    v16 = (const void **)sub_10002A3A0(a1, *(_DWORD *)(v9 + 108), a2);
    if (!v16)
    {
      if (dword_10008BA20)
      {
        v33 = ne_log_obj(0);
        if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
          sub_100059E68();
      }
      goto LABEL_43;
    }
    v17 = v16;
    v18 = *(int *)v16 + 32;
  }
  else
  {
    v17 = 0;
    v18 = 28;
  }
  v24 = v17 != 0;
  if ((a4 & 4) != 0)
    v24 = 4 * (v17 != 0);
  *(_BYTE *)(v9 + 105) = v24;
  sub_10004B4EC(a1, (_QWORD *)v9);
  v25 = v18 + *(_QWORD *)a2;
  v26 = sub_10003F1F8((int)v25);
  *(_QWORD *)(v9 + 80) = v26;
  if (!v26)
  {
    if (dword_10008BA20)
    {
      v32 = ne_log_obj(0);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
        sub_10005A794();
    }
    goto LABEL_67;
  }
  v27 = v26[1];
  *(_QWORD *)v27 = *(_QWORD *)a1;
  *(_QWORD *)(v27 + 8) = *(_QWORD *)(a1 + 8);
  if (v17)
    v28 = 8;
  else
    v28 = a3;
  *(_BYTE *)(v27 + 16) = v28;
  *(_BYTE *)(v27 + 17) = *(_BYTE *)(a1 + 80);
  *(_BYTE *)(v27 + 18) = 5;
  *(_BYTE *)(v27 + 19) = *(_BYTE *)(v9 + 105);
  *(_DWORD *)(v27 + 20) = *(_DWORD *)(v9 + 108);
  *(_DWORD *)(v27 + 24) = bswap32(v25);
  if (v17)
  {
    *(_BYTE *)(v27 + 28) = a3;
    v29 = (size_t)*v17;
    *(_WORD *)(v27 + 30) = bswap32(*v17 + 4) >> 16;
    memcpy((void *)(v27 + 32), v17[1], v29);
    v30 = (char *)*v17 + v27 + 32;
  }
  else
  {
    v30 = (char *)(v27 + 28);
  }
  memcpy(v30, *(const void **)(a2 + 8), *(_QWORD *)a2);
  v36 = *(size_t **)(v9 + 80);
  if ((*(_BYTE *)(v27 + 19) & 1) != 0)
  {
    v36 = sub_10002E3DC(*(_QWORD *)(v9 + 256), *(_QWORD *)(v9 + 80), *(_QWORD *)(*(_QWORD *)(v9 + 240) + 8), **(_QWORD **)(v9 + 240));
    v37 = *(_QWORD **)(v9 + 80);
    if (v37)
    {
      sub_10003F318(v37);
      *(_QWORD *)(v9 + 80) = 0;
    }
    if (!v36)
    {
      if (dword_10008BA20)
      {
        v43 = ne_log_obj(v37);
        if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
          sub_10005A7C0();
      }
      goto LABEL_67;
    }
    *(_QWORD *)(v9 + 80) = v36;
  }
  v38 = sub_1000240A4(*(_QWORD *)(v9 + 256), v36);
  if ((v38 & 0x80000000) == 0)
  {
    if (dword_10008BA20)
    {
      v39 = ne_log_obj(v38);
      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
      {
        v44 = 136315138;
        v45 = sub_10003DBA0(a3);
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "sendto Information %s.\n", (uint8_t *)&v44, 0xCu);
      }
    }
    v40 = *(_QWORD **)(v9 + 80);
    if (v40)
    {
      sub_10003F318(v40);
      v34 = 0;
      *(_QWORD *)(v9 + 80) = 0;
    }
    else
    {
      v34 = 0;
    }
    goto LABEL_68;
  }
  if (dword_10008BA20)
  {
    v41 = ne_log_obj(v38);
    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
      sub_100058CF4();
  }
  v42 = *(_QWORD **)(v9 + 80);
  if (v42)
  {
    sub_10003F318(v42);
    *(_QWORD *)(v9 + 80) = 0;
  }
LABEL_67:
  v34 = 0xFFFFFFFFLL;
LABEL_68:
  sub_10004A9EC((_QWORD *)v9);
  if (v17)
    sub_10003F318(v17);
  return v34;
}

uint64_t sub_10001AA88(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  signed int v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  size_t v8;
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  uint8_t v13[16];

  if ((*(_BYTE *)(a1 + 57) & 0x20) == 0)
    return 0;
  v2 = sub_10004B9DC(*(_QWORD *)(a1 + 272));
  if (!v2)
  {
    v2 = sub_100007FC4(*(_QWORD *)(a1 + 272), *(const sockaddr **)a1, *(const sockaddr **)(a1 + 8));
    if (!v2)
    {
      if (dword_10008BA20)
      {
        v11 = ne_log_obj(0);
        v9 = 0;
        if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          return v9;
        *(_WORD *)v13 = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "No ph1 handler found, could not send DELETE_SA\n", v13, 2u);
      }
      return 0;
    }
  }
  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 128) + 32);
  if (!v3)
    return 0;
  while (1)
  {
    v4 = *(_DWORD *)(v3 + 8) + 12;
    v5 = sub_10003F1F8(v4);
    if (!v5)
      break;
    v6 = v5;
    v7 = v5[1];
    *(_BYTE *)v7 = 0;
    *(_WORD *)(v7 + 2) = bswap32(v4) >> 16;
    *(_DWORD *)(v7 + 4) = 0x1000000;
    *(_BYTE *)(v7 + 8) = *(_DWORD *)v3;
    v8 = *(_QWORD *)(v3 + 8);
    *(_BYTE *)(v7 + 9) = v8;
    *(_WORD *)(v7 + 10) = 256;
    memcpy((void *)(v7 + 12), (const void *)(v3 - v8 + 28), v8);
    v9 = sub_10001A5E8(v2, v6, 12, 0);
    sub_10003F318(v6);
    v3 = *(_QWORD *)(v3 + 72);
    if (!v3)
      return v9;
  }
  if (dword_10008BA20)
  {
    v10 = ne_log_obj(0);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      sub_10005A674();
  }
  return *__error();
}

uint64_t sub_10001AC10(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3, unsigned int a4, uint64_t a5)
{
  uint64_t v10;
  _DWORD *v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  signed int v17;
  NSObject *v18;
  NSObject *v19;
  NSObject *v20;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  uint64_t v24;
  NSObject *v25;

  v10 = sub_10004ABA4((uint64_t)a3, (uint64_t)a2, 0, 0);
  v11 = sub_100038594((uint64_t)a2);
  if (v11)
  {
    v12 = (uint64_t)v11;
    v13 = sub_1000083E8(16);
    if (v13)
    {
      v14 = (uint64_t)v13;
      *v13 = *(_QWORD *)a1;
      sub_100026198(v13 + 1, (uint64_t)a2, (uint64_t)a3);
      sub_100003774((int *)(v14 + 16), 63);
      *(_QWORD *)(v14 + 64) = v12;
      sub_100038B74(v12);
      *(_DWORD *)(v14 + 20) = 0;
      *(_BYTE *)(v14 + 80) = *(_BYTE *)(a1 + 17);
      *(_BYTE *)(v14 + 82) = 0;
      *(_DWORD *)(v14 + 84) = 0;
      v15 = sub_1000448B4();
      *(_QWORD *)(v14 + 408) = v15;
      if (!v15)
        goto LABEL_27;
      *(_DWORD *)(v14 + 100) = 0;
      *(_QWORD *)(v14 + 104) = 0;
      v16 = sub_1000225F8(v14, v12, a2, a3);
      if ((v16 & 0x80000000) == 0)
      {
        if (a5)
          v17 = *(_DWORD *)a5 + 12;
        else
          v17 = 12;
        v22 = sub_10003F1F8(v17);
        if (v22)
        {
          v23 = v22;
          v24 = v22[1];
          *(_BYTE *)v24 = 0;
          *(_WORD *)(v24 + 2) = bswap32(v17) >> 16;
          *(_DWORD *)(v24 + 4) = 0x1000000;
          *(_WORD *)(v24 + 8) = 1;
          *(_WORD *)(v24 + 10) = bswap32(a4) >> 16;
          if (a5)
            memcpy((void *)(v24 + 12), *(const void **)(a5 + 8), *(_QWORD *)a5);
          sub_10001AE80(v14, 0, a4, (unsigned __int16 *)a5);
          if (sub_10004B29C(v10, v14))
            sub_10003B334();
          v21 = sub_10001A5E8(v14, (uint64_t)v23, 11, 0);
          sub_10003F318(v23);
          goto LABEL_28;
        }
        if (dword_10008BA20)
        {
          v25 = ne_log_obj(0);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
            sub_10005A794();
        }
LABEL_27:
        v21 = 0xFFFFFFFFLL;
LABEL_28:
        sub_10004AACC(v14);
        return v21;
      }
      if (dword_10008BA20)
      {
        v20 = ne_log_obj(v16);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          sub_10005A844();
      }
    }
    else if (dword_10008BA20)
    {
      v19 = ne_log_obj(0);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        sub_10005A818();
    }
  }
  else if (dword_10008BA20)
  {
    v18 = ne_log_obj(0);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      sub_10005A7EC();
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_10001AE80(uint64_t a1, int a2, int a3, unsigned __int16 *a4)
{
  uint64_t result;
  int v9;
  int v10;
  uint64_t v11;
  NSObject *v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  NSObject *v17;
  NSObject *v18;
  unsigned int v19;
  unsigned int v20;
  int v21;
  unsigned int v22;
  const void *v23;
  NSObject *v24;
  NSObject *v25;
  NSObject *v26;
  unsigned __int16 v27;
  uint8_t v28[16];
  uint8_t v29[16];
  uint8_t v30[16];
  uint8_t v31[16];
  uint8_t v32[16];
  uint8_t buf[16];

  result = sub_10000A9C8(a1);
  v9 = result;
  if (a2 == 1)
  {
    v10 = sub_10002B658(*(_QWORD *)(a1 + 280), 1);
    v11 = sub_10002B658(*(_QWORD *)(a1 + 280), 2);
    if (v10)
    {
      if (dword_10008BA20)
      {
        v12 = ne_log_obj(v11);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, ">>> Server reports client's certificate is pre-mature\n", buf, 2u);
        }
      }
      LOWORD(a3) = -15532;
    }
    else if ((_DWORD)v11)
    {
      if (dword_10008BA20)
      {
        v18 = ne_log_obj(v11);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)v32 = 0;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, ">>> Server reports client's certificate is expired\n", v32, 2u);
        }
      }
      LOWORD(a3) = -15531;
    }
    v19 = (unsigned __int16)a3;
    v20 = 1;
    v21 = v9;
    v22 = 0;
    v23 = 0;
  }
  else
  {
    if (a3 > 30)
      return result;
    v13 = sub_10002B658(*(_QWORD *)(a1 + 288), 1);
    v14 = sub_10002B658(*(_QWORD *)(a1 + 288), 2);
    v15 = sub_10002B658(*(_QWORD *)(a1 + 288), 3);
    v16 = sub_10002B658(*(_QWORD *)(a1 + 288), 4);
    if (v13)
    {
      if (dword_10008BA20)
      {
        v17 = ne_log_obj(v16);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)v31 = 0;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, ">>> Server's certificate is pre-mature\n", v31, 2u);
        }
      }
      LOWORD(a3) = -15530;
    }
    else if (v14)
    {
      if (dword_10008BA20)
      {
        v24 = ne_log_obj(v16);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)v30 = 0;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, ">>> Server's certificate is expired\n", v30, 2u);
        }
      }
      LOWORD(a3) = -15529;
    }
    else if (v15)
    {
      if (dword_10008BA20)
      {
        v25 = ne_log_obj(v16);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)v29 = 0;
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, ">>> Server's certificate subject name not valid\n", v29, 2u);
        }
      }
      LOWORD(a3) = -15528;
    }
    else if ((_DWORD)v16)
    {
      if (dword_10008BA20)
      {
        v26 = ne_log_obj(v16);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)v28 = 0;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, ">>> Server's certificate subject alternate name not valid\n", v28, 2u);
        }
      }
      LOWORD(a3) = -15527;
    }
    if (a4)
    {
      v27 = *a4;
      v23 = (const void *)*((_QWORD *)a4 + 1);
    }
    else
    {
      v27 = 0;
      v23 = 0;
    }
    v19 = (unsigned __int16)a3;
    v22 = v27;
    v20 = 0;
    v21 = v9;
  }
  return sub_1000487BC(v19, v20, v21, v22, v23);
}

uint64_t sub_10001B184(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v7;
  signed int v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v14;

  if (a2 == 24578 || a2 == 40501)
    v7 = 16;
  else
    v7 = 0;
  v8 = v7 | 0xC;
  if (a3)
    v8 += *(_DWORD *)a3;
  v9 = sub_10003F1F8(v8);
  if (v9)
  {
    v10 = v9;
    v11 = v9[1];
    *(_BYTE *)v11 = 0;
    *(_WORD *)(v11 + 2) = bswap32(v8) >> 16;
    *(_DWORD *)(v11 + 4) = bswap32(*(_DWORD *)(*(_QWORD *)(a1 + 64) + 24));
    *(_BYTE *)(v11 + 8) = 1;
    *(_BYTE *)(v11 + 9) = v7;
    *(_WORD *)(v11 + 10) = bswap32(a2) >> 16;
    if (a2 == 40501 || a2 == 24578)
      *(_OWORD *)(v11 + 12) = *(_OWORD *)a1;
    if (a3)
      memcpy((void *)(v11 + v7 + 12), *(const void **)(a3 + 8), *(_QWORD *)a3);
    sub_10001AE80(a1, 0, a2, (unsigned __int16 *)a3);
    v12 = sub_10001A5E8(a1, (uint64_t)v10, 11, *(_BYTE *)(a1 + 82));
    sub_10003F318(v10);
    return v12;
  }
  else
  {
    if (dword_10008BA20)
    {
      v14 = ne_log_obj(0);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        sub_10005A794();
    }
    return *__error();
  }
}

uint64_t sub_10001B2D4(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3;
  _DWORD *v7;
  signed int v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  char v14;
  uint64_t v15;
  NSObject *v17;

  v3 = *(_QWORD *)(a1 + 128);
  if (!v3)
    return 22;
  v7 = *(_DWORD **)(v3 + 32);
  v8 = v7[2] + 12;
  if (a3)
    v8 += *(_DWORD *)a3;
  v9 = *(_QWORD *)(a1 + 256);
  v10 = sub_10003F1F8(v8);
  if (v10)
  {
    v11 = v10;
    v12 = v10[1];
    *(_BYTE *)v12 = 0;
    *(_WORD *)(v12 + 2) = bswap32(v8) >> 16;
    *(_DWORD *)(v12 + 4) = 0x1000000;
    *(_BYTE *)(v12 + 8) = *v7;
    *(_BYTE *)(v12 + 9) = *((_QWORD *)v7 + 1);
    *(_WORD *)(v12 + 10) = bswap32(a2) >> 16;
    *(_DWORD *)(v12 + 12) = v7[6];
    v13 = v12 + 12;
    if (a3)
      memcpy((void *)(v13 + *((_QWORD *)v7 + 1)), *(const void **)(a3 + 8), *(_QWORD *)a3);
    v14 = *(_BYTE *)(a1 + 105) | 1;
    *(_BYTE *)(a1 + 105) = v14;
    v15 = sub_10001A5E8(v9, (uint64_t)v11, 11, v14);
    sub_10003F318(v11);
    return v15;
  }
  else
  {
    if (dword_10008BA20)
    {
      v17 = ne_log_obj(0);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        sub_10005A794();
    }
    return *__error();
  }
}

_QWORD *sub_10001B408(void **a1, _BYTE **a2, unsigned int a3, _DWORD *a4, uint64_t a5)
{
  signed int v9;
  void *v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;

  if (*a2)
    **a2 = 11;
  v9 = a4[2] + 12;
  if (a5)
    v9 += *(_DWORD *)a5;
  if (a1)
  {
    v10 = *a1;
    v11 = sub_10003F270(a1, (size_t)*a1 + v9);
    v12 = v11;
    v13 = (int)v10;
    if (v11)
    {
LABEL_7:
      v14 = v12[1] + v13;
      *(_BYTE *)v14 = 0;
      *(_WORD *)(v14 + 2) = bswap32(v9) >> 16;
      *(_DWORD *)(v14 + 4) = 0x1000000;
      *(_BYTE *)(v14 + 8) = *a4;
      *(_BYTE *)(v14 + 9) = *((_QWORD *)a4 + 1);
      *(_WORD *)(v14 + 10) = bswap32(a3) >> 16;
      *(_DWORD *)(v14 + 12) = a4[6];
      if (a5)
        memcpy((void *)(v14 + 12 + *((_QWORD *)a4 + 1)), *(const void **)(a5 + 8), *(_QWORD *)a5);
      *a2 = (_BYTE *)v14;
      return v12;
    }
  }
  else
  {
    v11 = sub_10003F1F8(v9);
    v12 = v11;
    v13 = 0;
    if (v11)
      goto LABEL_7;
  }
  if (dword_10008BA20)
  {
    v15 = ne_log_obj(v11);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      sub_10005A870();
  }
  return v12;
}

void sub_10001B534(unint64_t a1, uint64_t a2, int *a3, uint64_t a4, uint64_t a5, unint64_t *a6)
{
  unsigned int v11;
  void **v12;
  unint64_t v13;
  char *v14;
  BOOL v15;
  int v16;
  unint64_t v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  unsigned __int8 *v22;
  uint64_t v23;
  unsigned __int8 *v24;
  int *v25;
  _DWORD *v26;
  uint64_t *v27;
  uint64_t v28;
  unint64_t v29;
  NSObject *v30;
  char *v31;
  unsigned int v32;
  NSObject *v33;
  int *v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  void **v38;
  int v39;
  unint64_t *v40;
  int v41;
  unint64_t v42;
  uint8_t buf[4];
  char *v44;
  __int16 v45;
  unsigned int v46;
  _OWORD v47[2];
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;

  v59 = 0u;
  v60 = 0u;
  v57 = 0u;
  v58 = 0u;
  v55 = 0u;
  v56 = 0u;
  v53 = 0u;
  v54 = 0u;
  v51 = 0u;
  v52 = 0u;
  v49 = 0u;
  v50 = 0u;
  v48 = 0u;
  memset(v47, 0, sizeof(v47));
  v41 = a2;
  v11 = sub_10002EFA4(a2);
  v12 = sub_10002EA90(v11);
  if (v12)
  {
    v38 = v12;
    if ((uint64_t)*v12 < 1)
    {
      v42 = 0;
    }
    else
    {
      v34 = a3;
      v35 = a4;
      v42 = 0;
      v13 = (unint64_t)v12[1];
      v14 = (char *)*v12 + v13;
      v36 = a1;
      v37 = a5;
      if (a5)
        v15 = a6 == 0;
      else
        v15 = 1;
      v16 = !v15;
      v39 = v16;
      v40 = a6;
      do
      {
        v17 = *(unsigned __int16 *)(v13 + 4);
        if (v17 < 2)
          break;
        if (*(_BYTE *)(v13 + 1) == 10)
        {
          v18 = sub_100041CFC(v13, (uint64_t)v47);
          if ((_DWORD)v18 || (v18 = sub_100041DFC((uint64_t)v47), (_DWORD)v18))
          {
            if (dword_10008BA20)
            {
              v19 = ne_log_obj(v18);
              if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
                sub_10005A89C();
            }
          }
          else
          {
            v20 = *((_QWORD *)&v47[0] + 1);
            if (*((_QWORD *)&v47[0] + 1))
            {
              v21 = *((_QWORD *)&v48 + 1);
              if (*((_QWORD *)&v48 + 1))
              {
                if ((_QWORD)v49)
                {
                  if (*(unsigned __int8 *)(*((_QWORD *)&v47[0] + 1) + 9) - 1 <= 1)
                  {
                    v22 = (unsigned __int8 *)(v49 + 8);
                    if (!sub_10003B4E8(v36, v49 + 8))
                    {
                      v23 = v35;
                      if (v35)
                      {
                        v24 = (unsigned __int8 *)(v21 + 8);
                        v25 = v34;
                        do
                        {
                          if (*v25 == *(_DWORD *)(v20 + 4))
                          {
                            if (v39)
                            {
                              if (v42 >= *a6)
                                v26 = 0;
                              else
                                v26 = (_DWORD *)(v37 + 4 * v42);
                            }
                            else
                            {
                              v26 = 0;
                            }
                            v27 = sub_100008CCC((uint64_t)v24, (uint64_t)v22, v41, *v25, v26);
                            v28 = sub_100040B7C(*(_DWORD *)(qword_10008B848 + 32), *(_BYTE *)(v13 + 3), 0, v24, v22, *(_DWORD *)(v20 + 4));
                            if (v27)
                            {
                              sub_100026C5C(v27);
                              v28 = sub_10004A9EC(v27);
                              v29 = v42;
                              if (v26)
                                v29 = v42 + 1;
                              v42 = v29;
                            }
                            a6 = v40;
                            if (dword_10008BA20)
                            {
                              v30 = ne_log_obj(v28);
                              if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
                              {
                                v31 = sub_10003DCFC(v41);
                                v32 = bswap32(*v25);
                                *(_DWORD *)buf = 136315394;
                                v44 = v31;
                                v45 = 1024;
                                v46 = v32;
                                _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "Purged IPsec-SA proto_id=%s spi=%u.\n", buf, 0x12u);
                              }
                            }
                          }
                          ++v25;
                          --v23;
                        }
                        while (v23);
                      }
                    }
                  }
                }
              }
            }
          }
        }
        v13 += 8 * v17;
      }
      while (v13 < (unint64_t)v14);
    }
    if (a6)
      *a6 = v42;
    sub_10003F318(v38);
  }
  else if (dword_10008BA20)
  {
    v33 = ne_log_obj(0);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "pfkey_dump_sadb returned nothing.\n", buf, 2u);
    }
  }
}

void sub_10001B88C(uint64_t a1)
{
  void **v2;
  void **v3;
  unint64_t v4;
  char *v5;
  unint64_t v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  unsigned __int8 *v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  int v16;
  unsigned int v17;
  int v18;
  uint64_t *v19;
  uint64_t *v20;
  NSObject *v21;
  NSObject *log;
  unsigned __int8 *v23;
  uint8_t buf[4];
  unsigned int v25;
  uint8_t v26[16];
  _OWORD v27[2];
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;

  if (!dword_10008B858)
  {
    v39 = 0u;
    v40 = 0u;
    v37 = 0u;
    v38 = 0u;
    v35 = 0u;
    v36 = 0u;
    v33 = 0u;
    v34 = 0u;
    v31 = 0u;
    v32 = 0u;
    v29 = 0u;
    v30 = 0u;
    v28 = 0u;
    memset(v27, 0, sizeof(v27));
    v2 = sub_10002EA90(0);
    if (v2)
    {
      v3 = v2;
      if ((uint64_t)*v2 >= 1)
      {
        v4 = (unint64_t)v2[1];
        v5 = (char *)*v2 + v4;
        do
        {
          v6 = *(unsigned __int16 *)(v4 + 4);
          if (v6 < 2)
            break;
          if (*(_BYTE *)(v4 + 1) == 10)
          {
            v7 = sub_100041CFC(v4, (uint64_t)v27);
            if ((_DWORD)v7 || (v7 = sub_100041DFC((uint64_t)v27), (_DWORD)v7))
            {
              if (dword_10008BA20)
              {
                v8 = ne_log_obj(v7);
                if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
                  sub_10005A89C();
              }
            }
            else
            {
              v9 = *((_QWORD *)&v27[0] + 1);
              if (*((_QWORD *)&v27[0] + 1)
                && *((_QWORD *)&v28 + 1)
                && (_QWORD)v29
                && *(unsigned __int8 *)(*((_QWORD *)&v27[0] + 1) + 9) - 1 <= 1)
              {
                v10 = (unsigned __int8 *)(*((_QWORD *)&v28 + 1) + 8);
                v23 = (unsigned __int8 *)(v29 + 8);
                v11 = *(_QWORD *)(a1 + 56);
                v12 = *((_QWORD *)&v28 + 1) + 8;
                if ((*(_BYTE *)(a1 + 96) & 6) != 0)
                {
                  if (!sub_10003B5A0(v11, v12))
                  {
                    v13 = sub_10003B5A0(*(_QWORD *)(a1 + 48), (unint64_t)v23);
                    if (!(_DWORD)v13)
                      goto LABEL_28;
                  }
                  if (!sub_10003B5A0(*(_QWORD *)(a1 + 48), (unint64_t)v10))
                  {
                    v13 = sub_10003B5A0(*(_QWORD *)(a1 + 56), (unint64_t)v23);
                    if (!(_DWORD)v13)
                      goto LABEL_28;
                  }
                }
                else if (!sub_10003B380(v11, v12)
                       && (v13 = sub_10003B380(*(_QWORD *)(a1 + 48), (unint64_t)v23), !(_DWORD)v13)
                       || !sub_10003B380(*(_QWORD *)(a1 + 48), (unint64_t)v10)
                       && (v13 = sub_10003B380(*(_QWORD *)(a1 + 56), (unint64_t)v23), !(_DWORD)v13))
                {
LABEL_28:
                  v14 = 0;
                  v15 = byte_100085050;
                  while (1)
                  {
                    v16 = *v15;
                    v15 += 16;
                    if (v16 == *(unsigned __int8 *)(v4 + 3))
                      break;
                    if (++v14 == 3)
                      goto LABEL_12;
                  }
                  if ((_DWORD)v14 != 3)
                  {
                    if (dword_10008BA20)
                    {
                      log = ne_log_obj(v13);
                      if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
                      {
                        v17 = bswap32(*(_DWORD *)(v9 + 4));
                        *(_DWORD *)buf = 67109120;
                        v25 = v17;
                        _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, "purging spi=%u.\n", buf, 8u);
                      }
                    }
                    sub_100040B7C(*(_DWORD *)(qword_10008B848 + 32), *(_BYTE *)(v4 + 3), 0, v10, v23, *(_DWORD *)(v9 + 4));
                    v18 = sub_10002F014(*(unsigned __int8 *)(v4 + 3));
                    v19 = sub_100008C2C((uint64_t)v10, (uint64_t)v23, v18, *(_DWORD *)(v9 + 4));
                    if (v19)
                    {
                      v20 = v19;
                      sub_100026C5C(v19);
                      sub_10004A9EC(v20);
                    }
                  }
                }
              }
            }
          }
LABEL_12:
          v4 += 8 * v6;
        }
        while (v4 < (unint64_t)v5);
      }
      sub_10003F318(v3);
    }
    else if (dword_10008BA20)
    {
      v21 = ne_log_obj(0);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v26 = 0;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "pfkey_dump_sadb returned nothing.\n", v26, 2u);
      }
    }
  }
}

void sub_10001BBF4(_BOOL8 a1, uint64_t a2)
{
  uint64_t v3;
  NSObject *v4;
  unsigned __int16 *v5;
  unsigned int v6;
  signed int v7;
  NSObject *v8;
  const char *v9;
  NSObject *v10;
  char *v11;
  NSObject *v12;
  uint32_t v13;
  uint64_t v14;
  NSObject *v15;
  int v16;
  char *v17;

  v3 = a1;
  if (dword_10008BA20)
  {
    v4 = ne_log_obj(a1);
    a1 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    if (a1)
    {
      LOWORD(v16) = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Notify Message received\n", (uint8_t *)&v16, 2u);
    }
  }
  v6 = *(unsigned __int16 *)(v3 + 10);
  v5 = (unsigned __int16 *)(v3 + 10);
  v7 = bswap32(v6) >> 16;
  if (v7 <= 40499)
  {
    if ((v7 - 24576) >= 2 && v7 != 0x4000)
    {
      if (v7 == 24578)
      {
        if (dword_10008BA20)
        {
          v8 = ne_log_obj(a1);
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v16) = 0;
            v9 = "Ignore INITIAL-CONTACT notification, because it is only accepted after Phase 1.\n";
LABEL_23:
            v12 = v8;
            v13 = 2;
            goto LABEL_24;
          }
        }
        return;
      }
LABEL_17:
      v14 = sub_10001B184(a2, 1u, 0);
      if (dword_10008BA20)
      {
        v15 = ne_log_obj(v14);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          sub_10005A8D8(v5);
      }
      return;
    }
LABEL_14:
    if (dword_10008BA20)
    {
      v10 = ne_log_obj(a1);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        v11 = sub_10003DB2C(bswap32(*v5) >> 16);
        v16 = 136315138;
        v17 = v11;
        v9 = "Ignore %s notification.\n";
        v12 = v10;
        v13 = 12;
LABEL_24:
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v16, v13);
        return;
      }
    }
    return;
  }
  if (v7 == 40503)
    goto LABEL_14;
  if (v7 != 40501)
  {
    if (v7 != 40500)
      goto LABEL_17;
    goto LABEL_14;
  }
  if (dword_10008BA20)
  {
    v8 = ne_log_obj(a1);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v16) = 0;
      v9 = "Ignore LOAD-BALANCE notification, because it is only accepted after Phase 1.\n";
      goto LABEL_23;
    }
  }
}

void sub_10001BE0C(_BOOL8 a1, uint64_t a2)
{
  uint64_t v3;
  NSObject *v4;
  unsigned __int16 *v5;
  signed int v6;
  int v7;
  unint64_t v8;
  NSObject *v9;
  NSObject *v10;
  char *v11;
  const char *v12;
  NSObject *v13;
  uint32_t v14;
  NSObject *v15;
  uint64_t v16;
  NSObject *v17;
  char *v18;
  char *v19;
  NSObject *v20;
  unsigned int v21;
  int v22;
  int v23;
  int v24;
  _BYTE v25[10];
  __int16 v26;
  char *v27;
  __int16 v28;
  int v29;

  v3 = a1;
  if (dword_10008BA20)
  {
    v4 = ne_log_obj(a1);
    a1 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    if (a1)
    {
      LOWORD(v24) = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Phase 2 Notify Message received\n", (uint8_t *)&v24, 2u);
    }
  }
  v5 = (unsigned __int16 *)(v3 + 10);
  v6 = bswap32(*(unsigned __int16 *)(v3 + 10)) >> 16;
  v7 = 24577;
  if (v6 > 24577)
  {
    if (v6 > 40500)
    {
      if (v6 != 40501)
      {
        v7 = 40503;
LABEL_16:
        if (v6 != v7)
        {
          v16 = sub_10001B184(*(_QWORD *)(a2 + 256), 1u, 0);
          if (dword_10008BA20)
          {
            v17 = ne_log_obj(v16);
            if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
              sub_10005A8D8(v5);
          }
          return;
        }
        goto LABEL_17;
      }
      if (!dword_10008BA20)
        return;
      v15 = ne_log_obj(a1);
      if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        return;
      LOWORD(v24) = 0;
      v12 = "Ignore LOAD-BALANCE notification, because it is only accepted after Phase 1.\n";
    }
    else
    {
      if (v6 != 24578)
      {
        v7 = 40500;
        goto LABEL_16;
      }
      if (!dword_10008BA20)
        return;
      v15 = ne_log_obj(a1);
      if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        return;
      LOWORD(v24) = 0;
      v12 = "Ignore INITIAL-CONTACT notification, because it is only accepted after Phase 1.\n";
    }
    v13 = v15;
    v14 = 2;
    goto LABEL_27;
  }
  if (v6 != 0x4000)
  {
    if (v6 == 24576)
    {
      v8 = *(unsigned __int8 *)(v3 + 9);
      if (v8 + 12 <= bswap32(*(unsigned __int16 *)(v3 + 2)) >> 16)
      {
        v18 = sub_10003D3A0(v3 + 12, v8);
        v19 = v18;
        if (dword_10008BA20)
        {
          v20 = ne_log_obj(v18);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            v21 = bswap32(*(_DWORD *)(v3 + 4));
            v22 = *(unsigned __int8 *)(v3 + 8);
            v23 = *(unsigned __int8 *)(v3 + 9);
            v24 = 67109890;
            *(_DWORD *)v25 = v21;
            *(_WORD *)&v25[4] = 1024;
            *(_DWORD *)&v25[6] = v22;
            v26 = 2080;
            v27 = v19;
            v28 = 1024;
            v29 = v23;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "notification message IPSEC-SA RESPONDER-LIFETIME, doi=%d proto_id=%d spi=%s(size=%d).\n", (uint8_t *)&v24, 0x1Eu);
          }
        }
        free(v19);
      }
      else if (dword_10008BA20)
      {
        v9 = ne_log_obj(a1);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          sub_10005A944();
      }
      return;
    }
    goto LABEL_16;
  }
LABEL_17:
  if (dword_10008BA20)
  {
    v10 = ne_log_obj(a1);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      v11 = sub_10003DB2C(bswap32(*v5) >> 16);
      v24 = 136315138;
      *(_QWORD *)v25 = v11;
      v12 = "Ignore %s notification.\n";
      v13 = v10;
      v14 = 12;
LABEL_27:
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v12, (uint8_t *)&v24, v14);
    }
  }
}

void sub_10001C108(uint64_t a1)
{
  NSObject *v2;
  int v3;
  const char *v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  __int16 v10;
  int v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  int v15;
  NSObject *v16;
  uint32_t v17;
  int v18;
  uint64_t v19;
  NSObject *v20;
  NSObject *v21;
  int v22;
  int v23;

  if ((*(_BYTE *)(a1 + 17) & 0x20) != 0)
  {
    if (*(_DWORD *)(*(_QWORD *)(a1 + 64) + 220) <= (int)*(unsigned __int8 *)(a1 + 386))
    {
      v18 = sub_10000A9C8(a1);
      sub_1000487BC(0xC351u, 0, v18, 0, 0);
      sub_100026790(a1);
      if (dword_10008BA20)
      {
        v20 = ne_log_obj(v19);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v22) = 0;
          v4 = "DPD: remote seems to be dead\n";
          v16 = v20;
          v17 = 2;
          goto LABEL_19;
        }
      }
    }
    else
    {
      v5 = sub_10003F1F8(0x20uLL);
      if (v5)
      {
        v6 = v5;
        v7 = v5[1];
        *(_BYTE *)v7 = 0;
        *(_WORD *)(v7 + 2) = 0x2000;
        *(_QWORD *)(v7 + 4) = 0x288D100101000000;
        *(_QWORD *)(v7 + 12) = *(_QWORD *)a1;
        *(_QWORD *)(v7 + 20) = *(_QWORD *)(a1 + 8);
        v8 = *(unsigned __int16 *)(a1 + 384);
        if (!*(_WORD *)(a1 + 384))
        {
          v9 = time(0);
          srand(v9);
          v10 = rand();
          v8 = v10 & 0xFFF;
          *(_WORD *)(a1 + 384) = v10 & 0xFFF;
        }
        *(_DWORD *)(v7 + 28) = bswap32(v8);
        v11 = sub_10001A5E8(a1, (uint64_t)v6, 11, 0);
        sub_10003F318(v6);
        if (dword_10008BA20)
        {
          v13 = ne_log_obj(v12);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            v22 = 67109120;
            v23 = v11;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "DPD R-U-There sent (%d)\n", (uint8_t *)&v22, 8u);
          }
        }
        ++*(_BYTE *)(a1 + 386);
        v14 = sub_10001C3BC(a1, 1);
        if (dword_10008BA20)
        {
          v2 = ne_log_obj(v14);
          if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
          {
            v15 = *(_DWORD *)(*(_QWORD *)(a1 + 64) + 212);
            v22 = 67109120;
            v23 = v15;
            v4 = "rescheduling send_r_u (%d).\n";
            goto LABEL_15;
          }
        }
      }
      else if (dword_10008BA20)
      {
        v21 = ne_log_obj(0);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          sub_10005A674();
      }
    }
  }
  else if (dword_10008BA20)
  {
    v2 = ne_log_obj(a1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      v3 = *(_DWORD *)(a1 + 16);
      v22 = 67109120;
      v23 = v3;
      v4 = "DPD r-u send aborted, invalid Phase 1 status %d....\n";
LABEL_15:
      v16 = v2;
      v17 = 8;
LABEL_19:
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v4, (uint8_t *)&v22, v17);
    }
  }
}

uint64_t sub_10001C3BC(uint64_t a1, int a2)
{
  int *v3;
  uint64_t result;
  void (*v5)(uint64_t);
  unsigned int v6;

  if (!a1)
    return 1;
  v3 = *(int **)(a1 + 64);
  if (!v3)
    return 1;
  if (!*(_DWORD *)(a1 + 368))
    return 0;
  result = v3[54];
  if (!(_DWORD)result)
    return result;
  if (a2)
  {
    result = v3[53];
LABEL_12:
    v5 = sub_10001C108;
    goto LABEL_13;
  }
  if ((v3[56] - 1) > 1)
    goto LABEL_12;
  v5 = sub_10001C450;
LABEL_13:
  v6 = sub_10003A520(result, (uint64_t)v5, a1);
  result = 0;
  *(_DWORD *)(a1 + 388) = v6;
  return result;
}

void sub_10001C450(uint64_t a1)
{
  uint64_t v2;
  int v3;
  NSObject *v4;
  int v5;
  const char *v6;
  int v7;
  int v8;
  NSObject *v9;
  uint32_t v10;
  NSObject *v11;
  uint64_t v12;
  NSObject *v13;
  NSObject *v14;
  uint64_t v15;
  NSObject *v16;
  int v17;
  uint64_t v18;
  NSObject *v19;
  int v20;
  int v21;
  __int16 v22;
  int v23;

  if (!a1)
    return;
  v2 = *(_QWORD *)(a1 + 64);
  if (!v2)
    return;
  v3 = *(_DWORD *)(v2 + 224);
  if (v3 != 2)
  {
    if (v3 != 1)
    {
      if (dword_10008BA20)
      {
        v4 = ne_log_obj(a1);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          v8 = *(_DWORD *)(*(_QWORD *)(a1 + 64) + 224);
          v20 = 67109120;
          v21 = v8;
          v6 = "DPD monitoring aborted, invalid algorithm %d....\n";
          goto LABEL_16;
        }
      }
      return;
    }
    if ((*(_BYTE *)(a1 + 17) & 0x20) == 0)
    {
      if (dword_10008BA20)
      {
        v4 = ne_log_obj(a1);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
        {
          v5 = *(_DWORD *)(a1 + 16);
          v20 = 67109120;
          v21 = v5;
          v6 = "DPD monitoring (for ALGORITHM_INBOUND_DETECT) aborted, invalid Phase 1 status %d....\n";
LABEL_16:
          v9 = v4;
          v10 = 8;
LABEL_17:
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v6, (uint8_t *)&v20, v10);
          return;
        }
      }
      return;
    }
    if (dword_10008BA20)
    {
      v11 = ne_log_obj(a1);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v20) = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "DPD monitoring (for ALGORITHM_INBOUND_DETECT) ....\n", (uint8_t *)&v20, 2u);
      }
    }
    if (*(_BYTE *)(a1 + 387))
    {
      *(_BYTE *)(a1 + 387) = 0;
      v12 = sub_10001C3BC(a1, 0);
      if (dword_10008BA20)
      {
        v13 = ne_log_obj(v12);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v20) = 0;
          v6 = "ike packets received from peer... reschedule monitor.\n";
          v9 = v13;
          v10 = 2;
          goto LABEL_17;
        }
      }
      return;
    }
    if ((*(_WORD *)(*(_QWORD *)(a1 + 440) + 264) & 0x40) != 0)
    {
      v18 = sub_10001C3BC(a1, 0);
      if (dword_10008BA20)
      {
        v19 = ne_log_obj(v18);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v20) = 0;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "rescheduling DPD monitoring (for ALGORITHM_INBOUND_DETECT).\n", (uint8_t *)&v20, 2u);
        }
      }
    }
    else
    {
      sub_10001C108(a1);
    }
LABEL_34:
    *(_WORD *)(*(_QWORD *)(a1 + 440) + 264) &= ~0x40u;
    return;
  }
  if ((*(_BYTE *)(a1 + 17) & 0x20) != 0)
  {
    if (dword_10008BA20)
    {
      v14 = ne_log_obj(a1);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v20) = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "DPD monitoring (for ALGORITHM_BLACKHOLE_DETECT) ....\n", (uint8_t *)&v20, 2u);
      }
    }
    if ((*(_WORD *)(*(_QWORD *)(a1 + 440) + 264) & 0x140) == 0x100)
    {
      sub_10001C108(a1);
    }
    else
    {
      v15 = sub_10001C3BC(a1, 0);
      if (dword_10008BA20)
      {
        v16 = ne_log_obj(v15);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          v17 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 440) + 264);
          v20 = 67109376;
          v21 = v17 << 23 >> 31;
          v22 = 1024;
          v23 = v17 << 25 >> 31;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "rescheduling DPD monitoring (for ALGORITHM_BLACKHOLE_DETECT) i = %d, peer %d.\n", (uint8_t *)&v20, 0xEu);
        }
      }
    }
    *(_WORD *)(*(_QWORD *)(a1 + 440) + 264) &= ~0x100u;
    goto LABEL_34;
  }
  if (dword_10008BA20)
  {
    v4 = ne_log_obj(a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v7 = *(_DWORD *)(a1 + 16);
      v20 = 67109120;
      v21 = v7;
      v6 = "DPD monitoring (for ALGORITHM_BLACKHOLE_DETECT) aborted, invalid Phase 1 status %d....\n";
      goto LABEL_16;
    }
  }
}

void sub_10001C7DC(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  int v8;
  uint64_t v9;

  if (a1)
  {
    if ((*(_BYTE *)(a1 + 17) & 0x20) != 0)
    {
      if (*(_DWORD *)(a1 + 368))
      {
        v3 = *(_QWORD *)(a1 + 64);
        if (*(_DWORD *)(v3 + 216))
        {
          if (*(_DWORD *)(v3 + 224))
          {
            if (!*(_BYTE *)(a1 + 387))
            {
              v5 = *(unsigned int *)(a1 + 388);
              if ((_DWORD)v5)
              {
                sub_10003A6F0(v5);
                *(_DWORD *)(a1 + 388) = 0;
              }
              v6 = sub_10001C3BC(a1, 0);
              if (dword_10008BA20)
              {
                v7 = ne_log_obj(v6);
                if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
                {
                  v8 = 136315138;
                  v9 = a2;
                  _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%s... rescheduling send_r_u.\n", (uint8_t *)&v8, 0xCu);
                }
              }
            }
            ++*(_BYTE *)(a1 + 387);
          }
        }
      }
    }
  }
}

char *sub_10001C8EC(uint64_t a1, int a2)
{
  return sub_10003DB2C(a2);
}

char *sub_10001C900(unsigned __int16 *a1)
{
  return sub_10003DB2C(bswap32(*a1) >> 16);
}

uint64_t sub_10001C914(uint64_t result, float a2)
{
  _QWORD *v2;
  float *v3;

  *v3 = a2;
  *v2 = result;
  return result;
}

const char *sub_10001C920()
{
  return ipsec_strerror();
}

uint64_t sub_10001C930(uint64_t a1)
{
  int *v1;
  int v3;
  _QWORD *v4;
  uint64_t result;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  unsigned int v9;
  NSObject *v10;

  v1 = (int *)(a1 + 56);
  if (*(_DWORD *)(a1 + 56) != 6336)
  {
    if (dword_10008BA20)
    {
      v6 = ne_log_obj(a1);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        sub_100058E84();
    }
    return 0xFFFFFFFFLL;
  }
  v3 = sub_1000264E8(*(_QWORD *)(a1 + 256));
  *(_DWORD *)(a1 + 108) = v3;
  v4 = *(_QWORD **)(a1 + 240);
  if (v4)
  {
    sub_10002DA18(v4);
    v3 = *(_DWORD *)(a1 + 108);
  }
  result = (uint64_t)sub_10002DA88(*(_QWORD *)(a1 + 256), v3);
  *(_QWORD *)(a1 + 240) = result;
  if (result)
  {
    sub_100003774(v1, 6384);
    if (dword_10008B858)
      return 0;
    v7 = sub_10002F7B4(a1);
    if ((v7 & 0x80000000) == 0)
    {
      if (dword_10008BA20)
      {
        v8 = ne_log_obj(v7);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
          sub_10005A99C();
      }
      v9 = sub_10003A520(*(int *)(qword_10008B848 + 284), (uint64_t)sub_10002F66C, a1);
      result = 0;
      *(_DWORD *)(a1 + 64) = v9;
      return result;
    }
    if (dword_10008BA20)
    {
      v10 = ne_log_obj(v7);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_10005A970();
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t sub_10001CA7C(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  int *v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _BOOL4 v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  NSObject *v24;
  NSObject *v25;
  NSObject *v26;
  NSObject *v27;
  _QWORD *v28;
  _QWORD *v29;
  char *v30;
  int v31;
  int v32;
  char *v33;
  char *v34;
  char *v35;
  uint64_t *v36;
  uint64_t *v37;
  _QWORD *v38;
  uint64_t v39;
  uint64_t v40;
  NSObject *v41;
  NSObject *v42;
  NSObject *v43;
  NSObject *v44;
  NSObject *v45;
  NSObject *v47;
  NSObject *v48;
  void *v49;
  void *v50;

  v49 = 0;
  v50 = 0;
  if (a2)
  {
    if (dword_10008BA20)
    {
      v2 = ne_log_obj(a1);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_10005AAD0();
    }
LABEL_73:
    v40 = 0xFFFFFFFFLL;
    goto LABEL_74;
  }
  v4 = (int *)(a1 + 56);
  if (*(_DWORD *)(a1 + 56) != 6352)
  {
    if (dword_10008BA20)
    {
      v25 = ne_log_obj(a1);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        sub_100058E84();
    }
    goto LABEL_73;
  }
  v5 = sub_10000EF64((_QWORD *)a1, 0);
  if ((v5 & 0x80000000) != 0)
  {
    if (dword_10008BA20)
    {
      v26 = ne_log_obj(v5);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        sub_10005A9C8();
    }
    goto LABEL_73;
  }
  v6 = sub_100006C70(*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 256) + 64) + 140));
  *(_QWORD *)(a1 + 208) = v6;
  if (!v6)
  {
    if (dword_10008BA20)
    {
      v27 = ne_log_obj(0);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        sub_100058CC8();
    }
    goto LABEL_73;
  }
  v7 = *(_QWORD *)(a1 + 120);
  v8 = *(_DWORD *)(v7 + 20);
  if (v8)
  {
    v9 = sub_100029AD4(*(unsigned int *)(v7 + 20), a1 + 152);
    if ((v9 & 0x80000000) != 0)
    {
      if (dword_10008BA20)
      {
        v41 = ne_log_obj(v9);
        if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
          sub_10005AAA4();
      }
      goto LABEL_73;
    }
    v10 = sub_1000297D4(*(_QWORD *)(a1 + 152), (size_t **)(a1 + 168), (_QWORD *)(a1 + 144));
    if ((v10 & 0x80000000) != 0)
    {
      if (dword_10008BA20)
      {
        v43 = ne_log_obj(v10);
        if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
          sub_100058C9C();
      }
      goto LABEL_73;
    }
  }
  v11 = sub_10001080C(a1);
  if ((v11 & 0x80000000) != 0)
  {
    if (dword_10008BA20)
    {
      v42 = ne_log_obj(v11);
      if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
        sub_10005A9F4();
    }
    goto LABEL_73;
  }
  if (dword_1000882C8 >= 7)
  {
    sub_10003372C(7, *(_QWORD *)(*(_QWORD *)(a1 + 192) + 8), **(_QWORD **)(a1 + 192), "IDci:\n", v12, v13, v14, v15, (char)v49);
    if (dword_1000882C8 >= 7)
      sub_10003372C(7, *(_QWORD *)(*(_QWORD *)(a1 + 200) + 8), **(_QWORD **)(a1 + 200), "IDcr:\n", v16, v17, v18, v19, (char)v49);
  }
  v20 = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 192) + 8) + 1)
     || *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 200) + 8) + 1)
     || *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 256) + 64) + 160)
     || !sub_10000F5FC(*(_QWORD *)(a1 + 120));
  v21 = **(_QWORD **)(a1 + 224) + **(_QWORD **)(a1 + 208) + 8;
  if (v8)
    v21 = **(_QWORD **)(a1 + 168) + (int)v21 + 4;
  if (v20)
    LODWORD(v21) = v21 + **(_DWORD **)(a1 + 192) + **(_DWORD **)(a1 + 200) + 8;
  if (sub_10000F5BC(*(_QWORD *)(a1 + 120)) && (*(_BYTE *)(*(_QWORD *)(a1 + 256) + 96) & 6) != 0)
  {
    v22 = sub_10003F804(a1, &v50, &v49);
    v23 = v22;
    if ((_DWORD)v22)
    {
      if ((_DWORD)v22 == -1)
      {
        if (dword_10008BA20)
        {
          v24 = ne_log_obj(v22);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
            sub_10005AA78();
        }
        goto LABEL_73;
      }
      LODWORD(v21) = v21 + *(_DWORD *)v50 + *(_DWORD *)v49 + 8;
    }
  }
  else
  {
    v23 = 0;
  }
  v28 = sub_10003F1F8((int)v21);
  if (!v28)
  {
    if (dword_10008BA20)
    {
      v44 = ne_log_obj(0);
      if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
        sub_10005A794();
    }
    goto LABEL_73;
  }
  v29 = v28;
  v30 = sub_10002659C(v28[1], *(uint64_t **)(a1 + 224), 10);
  if (v20)
    v31 = 5;
  else
    v31 = v23;
  if (v8)
    v32 = 4;
  else
    v32 = v31;
  v33 = sub_10002659C((uint64_t)v30, *(uint64_t **)(a1 + 208), v32);
  if (v8)
    v33 = sub_10002659C((uint64_t)v33, *(uint64_t **)(a1 + 168), v31);
  if (v20)
  {
    v34 = sub_10002659C((uint64_t)v33, *(uint64_t **)(a1 + 192), 5);
    v33 = sub_10002659C((uint64_t)v34, *(uint64_t **)(a1 + 200), v23);
  }
  if (v23)
  {
    v35 = sub_10002659C((uint64_t)v33, (uint64_t *)v50, v23);
    sub_10002659C((uint64_t)v35, (uint64_t *)v49, 0);
  }
  v36 = (uint64_t *)sub_10002A3A0(*(_QWORD *)(a1 + 256), *(_DWORD *)(a1 + 108), (uint64_t)v29);
  if (!v36)
  {
    if (dword_10008BA20)
    {
      v45 = ne_log_obj(0);
      if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
        sub_10005AA20();
    }
    sub_10003F318(v29);
    goto LABEL_73;
  }
  v37 = v36;
  v38 = sub_10001CFE4(a1, (uint64_t)v29, v36);
  *(_QWORD *)(a1 + 80) = v38;
  if (!v38)
  {
    if (dword_10008BA20)
    {
      v47 = ne_log_obj(0);
      if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
        sub_10005AA4C();
    }
    goto LABEL_86;
  }
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 256) + 64) + 200);
  v39 = sub_1000248F8(a1);
  if ((_DWORD)v39 == -1)
  {
    if (dword_10008BA20)
    {
      v48 = ne_log_obj(v39);
      if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
        sub_100058CF4();
    }
LABEL_86:
    v40 = 0xFFFFFFFFLL;
    goto LABEL_87;
  }
  sub_100003774(v4, 6369);
  v40 = 0;
LABEL_87:
  sub_10003F318(v29);
  sub_10003F318(v37);
LABEL_74:
  if (v50)
    sub_10003F318(v50);
  if (v49)
    sub_10003F318(v49);
  return v40;
}

_QWORD *sub_10001CFE4(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  _QWORD *v10;
  _QWORD *v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;

  v6 = sub_10003F1F8(*(_DWORD *)a3 + *(_DWORD *)a2 + 32);
  if (!v6)
  {
    if (dword_10008BA20)
    {
      v12 = ne_log_obj(0);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        sub_10005A794();
    }
    return 0;
  }
  v7 = v6;
  *(_BYTE *)(a1 + 105) |= 1u;
  v8 = sub_100026584((uint64_t)v6, a1, 8);
  if (!v8)
  {
    if (dword_10008BA20)
    {
      v13 = ne_log_obj(0);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        sub_10005AAFC();
    }
    goto LABEL_14;
  }
  v9 = sub_10002659C(v8, a3, 1);
  memcpy(v9, *(const void **)(a2 + 8), *(_QWORD *)a2);
  v10 = sub_10002E3DC(*(_QWORD *)(a1 + 256), (uint64_t)v7, *(_QWORD *)(*(_QWORD *)(a1 + 240) + 8), **(_QWORD **)(a1 + 240));
  if (!v10)
  {
    if (dword_10008BA20)
    {
      v14 = ne_log_obj(0);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        sub_10005A7C0();
    }
LABEL_14:
    sub_10003F318(v7);
    return 0;
  }
  v11 = v10;
  sub_10003F318(v7);
  return v11;
}

uint64_t sub_10001D128(uint64_t a1, _QWORD *a2)
{
  int *v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  _BYTE *v16;
  unsigned __int8 *v17;
  int v18;
  uint64_t v19;
  NSObject *v21;
  int v22;
  unsigned int *v23;
  unsigned int v24;
  unsigned int v25;
  size_t v26;
  uint64_t v27;
  uint64_t v28;
  sockaddr *v29;
  sockaddr *v30;
  int v31;
  char *v32;
  unsigned int v33;
  sockaddr *v34;
  NSObject *v35;
  BOOL v36;
  char *v37;
  const sockaddr *v38;
  _QWORD *v39;
  unsigned __int8 *v40;
  uint64_t v41;
  const void *v42;
  NSObject *v43;
  int v44;
  _QWORD *v45;
  size_t *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  NSObject *v51;
  NSObject *v52;
  _QWORD *v53;
  unsigned int v54;
  size_t *v55;
  _QWORD *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  uint64_t v62;
  NSObject *v63;
  NSObject *v64;
  NSObject *v65;
  NSObject *v66;
  NSObject *v67;
  sockaddr *v68;
  void *v69;
  NSObject *v70;
  uint64_t v71;
  _QWORD *v72;
  int v73;
  uint64_t v74;
  NSObject *v75;
  sockaddr *v76;
  NSObject *v77;
  NSObject *v78;
  NSObject *v79;
  NSObject *v80;
  uint64_t v81;
  NSObject *v82;
  NSObject *v83;
  NSObject *v84;
  NSObject *v85;
  NSObject *v86;
  void *v87;
  size_t v88;
  NSObject *v89;
  NSObject *v90;
  NSObject *v91;
  int *v92;
  size_t **v93;
  uint64_t v94;
  void **v95;
  sockaddr *v96;
  sockaddr *v97;
  size_t **v98;
  int v99;
  uint8_t v100;
  char v101[15];
  _BYTE buf[14];
  size_t v103;
  char v104[4];
  int v105;
  char v106[16];

  v3 = (int *)(a1 + 56);
  if (*(_DWORD *)(a1 + 56) != 6369)
  {
    if (dword_10008BA20)
    {
      v6 = ne_log_obj(a1);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        sub_100058E84();
    }
    goto LABEL_9;
  }
  v4 = a2[1];
  if ((*(_BYTE *)(v4 + 19) & 1) == 0)
  {
    if (dword_10008BA20)
    {
      v5 = ne_log_obj(a1);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_10005AB28();
    }
LABEL_9:
    v7 = 0xFFFFFFFFLL;
LABEL_10:
    v8 = *(_QWORD **)(a1 + 232);
    if (v8)
    {
      sub_10003F318(v8);
      *(_QWORD *)(a1 + 232) = 0;
    }
    v9 = *(_QWORD **)(a1 + 216);
    if (v9)
    {
      sub_10003F318(v9);
      *(_QWORD *)(a1 + 216) = 0;
    }
    v10 = *(_QWORD **)(a1 + 176);
    if (v10)
    {
      sub_10003F318(v10);
      *(_QWORD *)(a1 + 176) = 0;
    }
    return v7;
  }
  v12 = sub_10002E000(*(_QWORD *)(a1 + 256), a2, **(_QWORD **)(a1 + 240), *(_QWORD *)(*(_QWORD *)(a1 + 240) + 8));
  if (!v12)
  {
    if (dword_10008BA20)
    {
      v63 = ne_log_obj(0);
      if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
        sub_10005A004();
    }
    goto LABEL_9;
  }
  v13 = v12;
  v14 = sub_1000232C8((uint64_t)v12);
  if (!v14)
  {
    if (dword_10008BA20)
    {
      v64 = ne_log_obj(0);
      if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
        sub_100058EE4();
    }
    sub_10003F318(v13);
    goto LABEL_9;
  }
  v15 = v14;
  v16 = (_BYTE *)v14[1];
  if (*v16 != 8)
  {
    if (dword_10008BA20)
    {
      v65 = ne_log_obj(v14);
      if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
        sub_10005AE28();
    }
    goto LABEL_115;
  }
  v18 = v16[16];
  v17 = v16 + 16;
  v19 = *((_QWORD *)v17 - 1);
  if (v18 != 1 && dword_10008BA20 != 0)
  {
    v21 = ne_log_obj(v14);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      v22 = *v17;
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)&buf[4] = v22;
      *(_WORD *)&buf[8] = 1024;
      *(_DWORD *)&buf[10] = 8;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "received invalid next payload type %d, expecting %d.\n", buf, 0xEu);
    }
  }
  v24 = *(_DWORD *)(v4 + 24);
  v23 = (unsigned int *)(v4 + 24);
  v25 = **(_DWORD **)(a1 + 208) + bswap32(v24);
  v26 = v25 - 28;
  if ((int)(v25 - 28) < 0)
  {
    if (dword_10008BA20)
    {
      v66 = ne_log_obj(v26);
      if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
        sub_10005AB54((uint64_t **)(a1 + 208), v23, v66);
    }
    goto LABEL_115;
  }
  v27 = (uint64_t)sub_10003F1F8(v26);
  if (!v27)
  {
    if (dword_10008BA20)
    {
      v67 = ne_log_obj(0);
      if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
        sub_10005ABE4();
    }
LABEL_115:
    v30 = 0;
    v29 = 0;
    v7 = 0xFFFFFFFFLL;
    goto LABEL_116;
  }
  v93 = (size_t **)(a1 + 208);
  v94 = v19;
  v95 = (void **)v27;
  v28 = *(_QWORD *)(v27 + 8);
  *(_QWORD *)(a1 + 232) = 0;
  v98 = (size_t **)(a1 + 232);
  if (!*v17)
  {
    v31 = 0;
    v30 = 0;
    v29 = 0;
LABEL_123:
    if (v94 && *v98 && *(_QWORD *)(a1 + 216))
    {
      v68 = v30;
      v69 = memcpy(v95[1], (const void *)(*v93)[1], **v93);
      if (dword_10008BA20)
      {
        v70 = ne_log_obj(v69);
        if (os_log_type_enabled(v70, OS_LOG_TYPE_DEBUG))
        {
          v87 = *v95;
          v88 = **v93 + v31;
          *(_DWORD *)buf = 134218240;
          *(_QWORD *)&buf[4] = v87;
          *(_WORD *)&buf[12] = 2048;
          v103 = v88;
          _os_log_debug_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEBUG, "HASH allocated:hbuf->l=%zu actual:tlen=%zu\n", buf, 0x16u);
        }
      }
      *v95 = (void *)(**(_QWORD **)(a1 + 208) + v31);
      v71 = sub_10002A3A0(*(_QWORD *)(a1 + 256), *(_DWORD *)(a1 + 108), (uint64_t)v95);
      if (v71)
      {
        v72 = (_QWORD *)v71;
        v73 = timingsafe_bcmp(*(const void **)(v71 + 8), (const void *)(v94 + 4), *(_QWORD *)v71);
        sub_10003F318(v72);
        if (v73)
        {
          if (dword_10008BA20)
          {
            v75 = ne_log_obj(v74);
            if (os_log_type_enabled(v75, OS_LOG_TYPE_DEBUG))
              sub_10005AC3C();
          }
          v7 = 23;
        }
        else
        {
          v81 = sub_10000D148(a1);
          v30 = v68;
          if ((v81 & 0x80000000) == 0)
          {
            sub_100003774(v3, 6338);
            v7 = 0;
            goto LABEL_164;
          }
          if (!dword_10008BA20)
          {
            v7 = 14;
            goto LABEL_164;
          }
          v85 = ne_log_obj(v81);
          if (os_log_type_enabled(v85, OS_LOG_TYPE_ERROR))
            sub_10005AC10();
          v7 = 14;
        }
      }
      else
      {
        if (dword_10008BA20)
        {
          v78 = ne_log_obj(0);
          if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
            sub_10005AA20();
        }
        v7 = 0xFFFFFFFFLL;
      }
      v30 = v68;
      goto LABEL_164;
    }
    if (dword_10008BA20)
    {
      v76 = v30;
      v77 = ne_log_obj(v27);
      if (os_log_type_enabled(v77, OS_LOG_TYPE_ERROR))
        sub_100058FA0();
LABEL_138:
      v7 = 0xFFFFFFFFLL;
      goto LABEL_139;
    }
LABEL_163:
    v7 = 0xFFFFFFFFLL;
    goto LABEL_164;
  }
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v99 = 0;
  v32 = (char *)(v28 + **(_QWORD **)(a1 + 208));
  v92 = &v105;
  while (2)
  {
    v27 = (uint64_t)memcpy(v32, *((const void **)v17 + 1), *((int *)v17 + 1));
    v33 = *v17;
    if (v33 > 0xF)
    {
      v36 = v33 == 16 || v33 == 21;
      if (v36 || v33 == 131)
      {
        *(_QWORD *)buf = 0;
        sub_1000263B8((size_t **)buf, *((_QWORD *)v17 + 1));
        v27 = *(_QWORD *)buf;
        if (*(_QWORD *)buf)
        {
          v37 = sub_10003FA50(*(uint64_t *)buf);
          if (v37)
          {
            v38 = (const sockaddr *)v37;
            if (v30)
            {
              if (v29)
              {
                free(v37);
              }
              else if (dword_10008BA20)
              {
                v52 = ne_log_obj(v37);
                if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG))
                  sub_10005ADEC((uint64_t)v104, v38);
                v29 = (sockaddr *)v38;
              }
              else
              {
                v29 = (sockaddr *)v37;
              }
            }
            else
            {
              if (dword_10008BA20)
              {
                v51 = ne_log_obj(v37);
                if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
                  sub_10005ADB0((uint64_t)v106, v38);
              }
              v30 = (sockaddr *)v38;
            }
          }
          sub_10003F318(*(_QWORD **)buf);
        }
        goto LABEL_97;
      }
LABEL_153:
      if (dword_10008BA20)
      {
        v76 = v30;
        v82 = ne_log_obj(v27);
        if (os_log_type_enabled(v82, OS_LOG_TYPE_ERROR))
          sub_100059D10();
        goto LABEL_138;
      }
      goto LABEL_163;
    }
    switch(*v17)
    {
      case 1u:
        v27 = a1 + 232;
        if (*v98)
        {
          if (dword_10008BA20)
          {
            v34 = v30;
            v35 = ne_log_obj(v98);
            v27 = os_log_type_enabled(v35, OS_LOG_TYPE_ERROR);
            if ((_DWORD)v27)
              sub_10005AC68(&v100, v101, v35);
            v30 = v34;
          }
          goto LABEL_97;
        }
        v27 = sub_1000263B8(v98, *((_QWORD *)v17 + 1));
        if ((v27 & 0x80000000) == 0)
          goto LABEL_97;
        if (!dword_10008BA20)
          goto LABEL_163;
        v76 = v30;
        v84 = ne_log_obj(v27);
        if (os_log_type_enabled(v84, OS_LOG_TYPE_ERROR))
          sub_100058F10();
        goto LABEL_138;
      case 4u:
        v27 = sub_1000263B8((size_t **)(a1 + 176), *((_QWORD *)v17 + 1));
        if ((v27 & 0x80000000) == 0)
          goto LABEL_97;
        if (!dword_10008BA20)
          goto LABEL_163;
        v76 = v30;
        v79 = ne_log_obj(v27);
        if (os_log_type_enabled(v79, OS_LOG_TYPE_ERROR))
          sub_100059100();
        goto LABEL_138;
      case 5u:
        v39 = *(_QWORD **)(a1 + 192);
        if (!v39 || !*(_QWORD *)(a1 + 200))
          goto LABEL_163;
        v96 = v29;
        if (v99)
          v39 = *(_QWORD **)(a1 + 200);
        v40 = (unsigned __int8 *)v39[1];
        v41 = *((_QWORD *)v17 + 1);
        v42 = (const void *)(v41 + 4);
        if (*v40 == *(unsigned __int8 *)(v41 + 4)
          && (!*(_BYTE *)(v41 + 5) || *(unsigned __int8 *)(v41 + 5) == v40[1])
          && (!*(_WORD *)(v41 + 6) || *(unsigned __int16 *)(v41 + 6) == *((unsigned __int16 *)v40 + 1)))
        {
          v27 = memcmp(v40 + 4, (const void *)(v41 + 8), *v39 - 4);
          if (!(_DWORD)v27)
            goto LABEL_80;
        }
        if ((*(_BYTE *)(*(_QWORD *)(a1 + 256) + 96) & 6) != 0)
        {
          v97 = v30;
          if (dword_10008BA20)
          {
            v43 = ne_log_obj(v27);
            v27 = os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT);
            if ((_DWORD)v27)
            {
              *(_WORD *)buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "mismatched ID was returned - ignored because nat traversal is being used.\n", buf, 2u);
            }
          }
          v44 = *(_DWORD *)(*(_QWORD *)(a1 + 256) + 96);
          if (v99)
          {
            v30 = v97;
            if ((v44 & 4) != 0)
            {
              v45 = *(_QWORD **)(a1 + 288);
              if (v45)
                sub_10003F318(v45);
              v46 = sub_10003F1F8((bswap32(*(unsigned __int16 *)(v41 + 2)) >> 16) - 4);
              *(_QWORD *)(a1 + 288) = v46;
              if (v46)
              {
                v27 = (uint64_t)memcpy((void *)v46[1], v42, *v46);
                if (dword_1000882C8 >= 7)
                  sub_10003372C(7, *(_QWORD *)(*(_QWORD *)(a1 + 288) + 8), **(_QWORD **)(a1 + 288), "peer's external nat address saved.\n", v47, v48, v49, v50, (char)v92);
                goto LABEL_80;
              }
              if (dword_10008BA20)
              {
                v86 = ne_log_obj(0);
                v29 = v96;
                if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR))
                  sub_10005AD84();
                goto LABEL_184;
              }
              v7 = 0xFFFFFFFFLL;
LABEL_186:
              v29 = v96;
              goto LABEL_164;
            }
          }
          else
          {
            v30 = v97;
            if ((v44 & 2) != 0)
            {
              v53 = *(_QWORD **)(qword_10008B848 + 296);
              if (v53)
                sub_10003F318(v53);
              v54 = *(unsigned __int16 *)(v41 + 2);
              if (v54 <= 3)
              {
                if (dword_10008BA20)
                {
                  v89 = ne_log_obj(v53);
                  if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR))
                    sub_10005ACC8();
                }
              }
              else
              {
                v55 = sub_10003F1F8(__rev16(v54) - 4);
                *(_QWORD *)(qword_10008B848 + 296) = v55;
                if (v55)
                {
                  memcpy((void *)v55[1], v42, *v55);
                  v56 = *(_QWORD **)(a1 + 280);
                  if (v56)
                    sub_10003F318(v56);
                  v27 = (uint64_t)sub_10003F34C(*(_QWORD *)(qword_10008B848 + 296));
                  *(_QWORD *)(a1 + 280) = v27;
                  v29 = v96;
                  if (v27)
                  {
                    if (dword_1000882C8 >= 7)
                      sub_10003372C(7, *(_QWORD *)(v27 + 8), *(_QWORD *)v27, "external nat address saved.\n", v57, v58, v59, v60, (char)v92);
                    v99 = 1;
                    goto LABEL_97;
                  }
                  if (dword_10008BA20)
                  {
                    v91 = ne_log_obj(0);
                    if (os_log_type_enabled(v91, OS_LOG_TYPE_ERROR))
                      sub_10005AD58();
                  }
LABEL_184:
                  v7 = 0xFFFFFFFFLL;
                  v30 = v97;
                  goto LABEL_164;
                }
                if (dword_10008BA20)
                {
                  v90 = ne_log_obj(0);
                  if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR))
                    sub_10005AD2C();
                }
              }
              v7 = 0xFFFFFFFFLL;
              v29 = v96;
              v30 = v97;
              goto LABEL_164;
            }
          }
LABEL_80:
          v99 = 1;
          v29 = v96;
LABEL_97:
          v61 = v17[16];
          v17 += 16;
          v62 = *((int *)v17 - 3);
          v32 += v62;
          v31 += v62;
          if (!v61)
            goto LABEL_123;
          continue;
        }
        if (!dword_10008BA20)
        {
          v7 = 13;
          goto LABEL_186;
        }
        v76 = v30;
        v83 = ne_log_obj(v27);
        v29 = v96;
        if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR))
          sub_10005AC9C();
        v7 = 13;
LABEL_139:
        v30 = v76;
LABEL_164:
        sub_10003F318(v95);
LABEL_116:
        sub_10003F318(v15);
        sub_10003F318(v13);
        if (v30)
          free(v30);
        if (v29)
          free(v29);
        if ((_DWORD)v7)
          goto LABEL_10;
        return v7;
      case 0xAu:
        v27 = sub_1000263B8((size_t **)(a1 + 216), *((_QWORD *)v17 + 1));
        if ((v27 & 0x80000000) == 0)
          goto LABEL_97;
        if (!dword_10008BA20)
          goto LABEL_163;
        v76 = v30;
        v80 = ne_log_obj(v27);
        if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR))
          sub_10005912C();
        goto LABEL_138;
      case 0xBu:
        sub_10001BE0C(*((_QWORD *)v17 + 1), a1);
        goto LABEL_97;
      default:
        goto LABEL_153;
    }
  }
}

uint64_t sub_10001DD08(uint64_t a1, uint64_t a2)
{
  int *v2;
  NSObject *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t *v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  size_t *v13;
  size_t *v14;
  uint64_t v15;
  uint64_t v16;
  NSObject *v17;
  NSObject *v18;
  NSObject *v19;
  NSObject *v20;
  uint64_t v21;
  NSObject *v23;
  NSObject *v24;
  NSObject *v25;
  uint64_t v26;
  unint64_t v27;
  unsigned __int8 *v28;
  unsigned __int8 *v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  NSObject *v35;
  uint64_t v36;
  NSObject *v37;
  uint64_t v38;
  NSObject *v39;
  NSObject *v40;
  NSObject *v41;
  NSObject *v42;
  NSObject *v43;
  NSObject *v44;

  v2 = (int *)(a1 + 56);
  if (*(_DWORD *)(a1 + 56) == 6338)
  {
    if (dword_10008BA20)
    {
      v5 = ne_log_obj(a1);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
        sub_10005AFEC();
    }
    v6 = sub_10003F1F8(**(_QWORD **)(a1 + 216) + **(_QWORD **)(a1 + 208));
    if (v6)
    {
      v7 = v6;
      memcpy((void *)v6[1], *(const void **)(*(_QWORD *)(a1 + 208) + 8), **(_QWORD **)(a1 + 208));
      memcpy((void *)(v7[1] + **(_QWORD **)(a1 + 208)), *(const void **)(*(_QWORD *)(a1 + 216) + 8), **(_QWORD **)(a1 + 216));
      v8 = (uint64_t *)sub_10002A2C0(*(_QWORD *)(a1 + 256), *(_DWORD *)(a1 + 108), (uint64_t)v7);
      sub_10003F318(v7);
      if (v8)
      {
        v10 = sub_10003F1F8(*(_DWORD *)v8 + 32);
        if (!v10)
        {
          if (dword_10008BA20)
          {
            v23 = ne_log_obj(0);
            if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
              sub_10005A794();
          }
          v21 = 0xFFFFFFFFLL;
          goto LABEL_74;
        }
        v11 = v10;
        v12 = sub_100026584((uint64_t)v10, a1, 8);
        if (!v12)
        {
          if (dword_10008BA20)
          {
            v24 = ne_log_obj(0);
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
              sub_10005AE8C();
          }
          goto LABEL_72;
        }
        sub_10002659C(v12, v8, 0);
        v13 = sub_10002E3DC(*(_QWORD *)(a1 + 256), (uint64_t)v11, *(_QWORD *)(*(_QWORD *)(a1 + 240) + 8), **(_QWORD **)(a1 + 240));
        *(_QWORD *)(a1 + 80) = v13;
        if (!v13)
        {
          if (dword_10008BA20)
          {
            v25 = ne_log_obj(0);
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
              sub_10005A7C0();
          }
          goto LABEL_72;
        }
        v14 = v13;
        v15 = *(_QWORD *)(a1 + 256);
        if ((*(_BYTE *)(a1 + 105) & 2) != 0)
        {
          *(_DWORD *)(a1 + 72) = *(_DWORD *)(*(_QWORD *)(v15 + 64) + 200);
          v26 = sub_1000248F8(a1);
          if ((_DWORD)v26 == -1)
          {
            if (dword_10008BA20)
            {
              v41 = ne_log_obj(v26);
              if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
                sub_10005AFC0();
            }
            goto LABEL_72;
          }
        }
        else
        {
          v16 = sub_1000240A4(v15, v14);
          if ((v16 & 0x80000000) != 0)
          {
            if (dword_10008BA20)
            {
              v17 = ne_log_obj(v16);
              if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
                sub_100058CF4();
            }
LABEL_72:
            v21 = 0xFFFFFFFFLL;
            goto LABEL_73;
          }
        }
        v27 = *(_QWORD *)(a1 + 256);
        v28 = *(unsigned __int8 **)(v27 + 48);
        v29 = *(unsigned __int8 **)(v27 + 56);
        v30 = *(_QWORD **)(a1 + 80);
        if (*(_DWORD *)(v27 + 100) && *v30 >= 0x501uLL)
        {
          v31 = 0;
          LODWORD(v27) = *(_DWORD *)(v27 + 96);
        }
        else
        {
          v27 = *(unsigned int *)(v27 + 96);
          v31 = (v27 >> 3) & 4;
        }
        v32 = sub_100009B6C(v28, v29, (uint64_t)v30, a2, v31, (v27 >> 5) & 1);
        if ((_DWORD)v32 == -1)
        {
          if (dword_10008BA20)
          {
            v40 = ne_log_obj(v32);
            if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
              sub_10005961C();
          }
          goto LABEL_72;
        }
        v33 = sub_100029D2C(a1, 0);
        if ((v33 & 0x80000000) != 0)
        {
          if (dword_10008BA20)
          {
            v42 = ne_log_obj(v33);
            if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
              sub_10005AEB8();
          }
          goto LABEL_72;
        }
        if ((*(_BYTE *)(a1 + 105) & 2) != 0)
        {
          sub_100003774(v2, 6371);
        }
        else
        {
          sub_100003774(v2, 6344);
          if (dword_10008BA20)
          {
            v35 = ne_log_obj(v34);
            if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
              sub_10005AF94();
          }
          v36 = sub_10002FBE0(a1);
          if ((v36 & 0x80000000) != 0)
          {
            if (dword_10008BA20)
            {
              v43 = ne_log_obj(v36);
              if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
                sub_10005AEE4();
            }
            goto LABEL_72;
          }
          if (dword_10008BA20)
          {
            v37 = ne_log_obj(v36);
            if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
              sub_10005AF68();
          }
          v38 = sub_10002FFB8(a1);
          if ((v38 & 0x80000000) != 0)
          {
            if (dword_10008BA20)
            {
              v44 = ne_log_obj(v38);
              if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
                sub_10005AF10();
            }
            goto LABEL_72;
          }
          if (dword_10008BA20)
          {
            v39 = ne_log_obj(v38);
            if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
              sub_10005AF3C();
          }
        }
        v21 = 0;
LABEL_73:
        sub_10003F318(v11);
LABEL_74:
        sub_10003F318(v8);
        return v21;
      }
      if (dword_10008BA20)
      {
        v20 = ne_log_obj(v9);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          sub_10005AA20();
      }
    }
    else if (dword_10008BA20)
    {
      v19 = ne_log_obj(0);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        sub_10005ABE4();
    }
  }
  else if (dword_10008BA20)
  {
    v18 = ne_log_obj(a1);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      sub_100058E84();
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_10001E178(uint64_t a1, _QWORD *a2)
{
  int *v2;
  NSObject *v3;
  NSObject *v4;
  uint64_t v5;
  _QWORD *v8;
  _QWORD *v9;
  void *v10;
  uint64_t v11;
  _QWORD *v12;
  unsigned __int8 *i;
  int v14;
  NSObject *v15;
  _QWORD *v16;
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  NSObject *v22;
  _QWORD *v23;
  NSObject *v24;
  NSObject *v25;
  NSObject *v26;
  NSObject *v27;
  NSObject *v28;
  uint64_t v29;
  NSObject *v30;
  uint64_t v31;
  NSObject *v32;
  uint64_t v33;
  NSObject *v34;
  NSObject *v35;
  NSObject *v36;
  _QWORD *v37;
  uint8_t buf[16];

  v2 = (int *)(a1 + 56);
  if (*(_DWORD *)(a1 + 56) != 6371)
  {
    if (dword_10008BA20)
    {
      v4 = ne_log_obj(a1);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_100058E84();
    }
    return 0xFFFFFFFFLL;
  }
  if ((*(_BYTE *)(a2[1] + 19) & 1) == 0)
  {
    if (dword_10008BA20)
    {
      v3 = ne_log_obj(a1);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        sub_10005AB28();
    }
    return 0xFFFFFFFFLL;
  }
  v8 = sub_10002E000(*(_QWORD *)(a1 + 256), a2, **(_QWORD **)(a1 + 240), *(_QWORD *)(*(_QWORD *)(a1 + 240) + 8));
  if (!v8)
  {
    if (dword_10008BA20)
    {
      v17 = ne_log_obj(0);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        sub_10005B018();
    }
    return 0xFFFFFFFFLL;
  }
  v9 = v8;
  v10 = sub_1000232C8((uint64_t)v8);
  if (!v10)
  {
    if (dword_10008BA20)
    {
      v24 = ne_log_obj(0);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        sub_10005B044();
    }
    sub_10003F318(v9);
    return 0xFFFFFFFFLL;
  }
  v11 = 0;
  v12 = 0;
  v37 = v10;
  for (i = (unsigned __int8 *)*((_QWORD *)v10 + 1); ; i += 16)
  {
    v14 = *i;
    if (v14 == 8)
    {
      v11 = *((_QWORD *)i + 1);
      continue;
    }
    if (v14 != 11)
      break;
    if (v12)
    {
      if (dword_10008BA20)
      {
        v15 = ne_log_obj(v10);
        v10 = (void *)os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
        if ((_DWORD)v10)
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Ignoring multiple notifications\n", buf, 2u);
        }
      }
    }
    else
    {
      sub_10001BE0C(*((_QWORD *)i + 1), a1);
      v16 = sub_10003F1F8(*((int *)i + 1));
      if (!v16)
      {
        if (dword_10008BA20)
        {
          v27 = ne_log_obj(0);
          v23 = v37;
          if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
            sub_10005B0C8();
          v12 = 0;
LABEL_52:
          v5 = 0xFFFFFFFFLL;
          goto LABEL_58;
        }
        v12 = 0;
LABEL_56:
        v5 = 0xFFFFFFFFLL;
LABEL_57:
        v23 = v37;
        goto LABEL_58;
      }
      v12 = v16;
      v10 = memcpy((void *)v16[1], *((const void **)i + 1), *v16);
    }
  }
  if (*i)
  {
    if (dword_10008BA20)
    {
      v25 = ne_log_obj(v10);
      v23 = v37;
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        sub_100059D10();
      goto LABEL_52;
    }
    goto LABEL_56;
  }
  if (!v11)
  {
    if (dword_10008BA20)
    {
      v26 = ne_log_obj(v10);
      v23 = v37;
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        sub_100058FA0();
      goto LABEL_52;
    }
    goto LABEL_56;
  }
  v18 = sub_10002A3A0(*(_QWORD *)(a1 + 256), *(_DWORD *)(a1 + 108), (uint64_t)v12);
  sub_10003F318(0);
  if (!v18)
  {
    if (dword_10008BA20)
    {
      v28 = ne_log_obj(v19);
      v23 = v37;
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        sub_10005B070();
      goto LABEL_52;
    }
    goto LABEL_56;
  }
  v20 = timingsafe_bcmp(*(const void **)(v18 + 8), (const void *)(v11 + 4), *(_QWORD *)v18);
  sub_10003F318((_QWORD *)v18);
  if (v20)
  {
    if (!dword_10008BA20)
    {
      v5 = 23;
      goto LABEL_57;
    }
    v22 = ne_log_obj(v21);
    v23 = v37;
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
      sub_10005B09C();
    v5 = 23;
  }
  else
  {
    sub_100003774(v2, 6344);
    *(_BYTE *)(a1 + 105) ^= 2u;
    if (dword_10008B858)
    {
      v5 = 0;
      goto LABEL_57;
    }
    if (dword_10008BA20)
    {
      v30 = ne_log_obj(v29);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
        sub_10005AF94();
    }
    v31 = sub_10002FBE0(a1);
    if ((v31 & 0x80000000) != 0)
    {
      if (dword_10008BA20)
      {
        v35 = ne_log_obj(v31);
        v23 = v37;
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
          sub_10005AEE4();
        goto LABEL_52;
      }
      goto LABEL_56;
    }
    if (dword_10008BA20)
    {
      v32 = ne_log_obj(v31);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
        sub_10005AF68();
    }
    v33 = sub_10002FFB8(a1);
    if ((v33 & 0x80000000) != 0)
    {
      v23 = v37;
      if (dword_10008BA20)
      {
        v36 = ne_log_obj(v33);
        if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
          sub_10005AF10();
      }
      goto LABEL_52;
    }
    v23 = v37;
    if (dword_10008BA20)
    {
      v34 = ne_log_obj(v33);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
        sub_10005AF3C();
    }
    v5 = 0;
  }
LABEL_58:
  sub_10003F318(v9);
  sub_10003F318(v23);
  if (v12)
    sub_10003F318(v12);
  return v5;
}

uint64_t sub_10001E61C(uint64_t a1, _QWORD *a2)
{
  int *v3;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  _BYTE *v19;
  unsigned __int8 *v20;
  int v21;
  uint64_t v22;
  NSObject *v23;
  NSObject *v24;
  NSObject *v25;
  sockaddr *v26;
  sockaddr *v27;
  NSObject *v28;
  int v29;
  unsigned int v30;
  size_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  int v38;
  int v39;
  void *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  BOOL v46;
  char *v47;
  const sockaddr *v48;
  NSObject *v49;
  int v50;
  uint64_t v51;
  NSObject *v52;
  NSObject *v53;
  unsigned int v54;
  uint64_t v55;
  _QWORD *v56;
  int v57;
  uint64_t v58;
  NSObject *v59;
  NSObject *v60;
  NSObject *v61;
  NSObject *v62;
  NSObject *v63;
  NSObject *v64;
  NSObject *v65;
  uint64_t v66;
  NSObject *v67;
  NSObject *v68;
  NSObject *v69;
  NSObject *v70;
  uint64_t v71;
  uint64_t v72;
  NSObject *v73;
  uint64_t v74;
  int v75;
  NSObject *v76;
  NSObject *v77;
  NSObject *v78;
  NSObject *v79;
  _BYTE *v80;
  uint64_t v81;
  _QWORD *v82;
  _QWORD *v83;
  unint64_t **v84;
  size_t **v85;
  size_t **v86;
  unint64_t **v87;
  const sockaddr *v88;
  NSObject *v89;
  const sockaddr *v90;
  NSObject *v91;
  void *v92;
  uint8_t v93;
  char v94[15];
  char v95[4];
  _BYTE v96[12];
  uint8_t buf[4];
  int v98;
  __int16 v99;
  int v100;

  v3 = (int *)(a1 + 56);
  if (*(_DWORD *)(a1 + 56) != 6592)
  {
    if (dword_10008BA20)
    {
      v8 = ne_log_obj(a1);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_100058E84();
    }
    goto LABEL_9;
  }
  v5 = a2[1];
  if ((*(_BYTE *)(v5 + 19) & 1) == 0)
  {
    if (dword_10008BA20)
    {
      v6 = ne_log_obj(a1);
      v7 = 16;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        sub_10005AB28();
    }
    else
    {
      v7 = 16;
    }
    goto LABEL_10;
  }
  v15 = sub_10002E000(*(_QWORD *)(a1 + 256), a2, **(_QWORD **)(a1 + 240), *(_QWORD *)(*(_QWORD *)(a1 + 240) + 8));
  if (!v15)
  {
    if (dword_10008BA20)
    {
      v23 = ne_log_obj(0);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        sub_10005B018();
    }
    goto LABEL_9;
  }
  v16 = v15;
  v17 = sub_1000232C8((uint64_t)v15);
  if (!v17)
  {
    if (dword_10008BA20)
    {
      v24 = ne_log_obj(0);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        sub_10005B044();
    }
    sub_10003F318(v16);
LABEL_9:
    v7 = 0xFFFFFFFFLL;
LABEL_10:
    v9 = *(_QWORD **)(a1 + 224);
    if (v9)
    {
      sub_10003F318(v9);
      *(_QWORD *)(a1 + 224) = 0;
    }
    v10 = *(_QWORD **)(a1 + 216);
    if (v10)
    {
      sub_10003F318(v10);
      *(_QWORD *)(a1 + 216) = 0;
    }
    v11 = *(_QWORD **)(a1 + 176);
    if (v11)
    {
      sub_10003F318(v11);
      *(_QWORD *)(a1 + 176) = 0;
    }
    v12 = *(_QWORD **)(a1 + 192);
    if (v12)
    {
      sub_10003F318(v12);
      *(_QWORD *)(a1 + 192) = 0;
    }
    v13 = *(_QWORD **)(a1 + 200);
    if (v13)
    {
      sub_10003F318(v13);
      *(_QWORD *)(a1 + 200) = 0;
    }
    return v7;
  }
  v18 = v17;
  v19 = (_BYTE *)v17[1];
  if (*v19 != 8)
  {
    if (dword_10008BA20)
    {
      v25 = ne_log_obj(v17);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        sub_10005AE28();
    }
    v26 = 0;
    v27 = 0;
    v7 = 15;
    goto LABEL_161;
  }
  v21 = v19[16];
  v20 = v19 + 16;
  v22 = *((_QWORD *)v20 - 1);
  if (v21 == 1)
  {
    v7 = 0xFFFFFFFFLL;
  }
  else
  {
    if (dword_10008BA20)
    {
      v28 = ne_log_obj(v17);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        v29 = *v20;
        *(_DWORD *)buf = 67109376;
        v98 = v29;
        v99 = 1024;
        v100 = 1;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "received invalid next payload type %d, expecting %d.\n", buf, 0xEu);
      }
    }
    v7 = 15;
  }
  v30 = bswap32(*(_DWORD *)(v5 + 24));
  v31 = v30 - 28;
  if ((int)(v30 - 28) < 0)
  {
    if (dword_10008BA20)
    {
      v52 = ne_log_obj(v31);
      if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
        sub_10005B0F4();
    }
    goto LABEL_95;
  }
  v32 = (uint64_t)sub_10003F1F8(v31);
  if (!v32)
  {
    if (dword_10008BA20)
    {
      v53 = ne_log_obj(0);
      if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
        sub_10005ABE4();
    }
LABEL_95:
    v26 = 0;
    v27 = 0;
    goto LABEL_161;
  }
  v81 = v22;
  v82 = v18;
  v37 = *(char **)(v32 + 8);
  *(_QWORD *)(a1 + 216) = 0;
  *(_QWORD *)(a1 + 224) = 0;
  v85 = (size_t **)(a1 + 216);
  v86 = (size_t **)(a1 + 224);
  *(_QWORD *)(a1 + 176) = 0;
  v83 = (_QWORD *)v32;
  *(_QWORD *)(a1 + 200) = 0;
  v84 = (unint64_t **)(a1 + 200);
  *(_QWORD *)(a1 + 192) = 0;
  v87 = (unint64_t **)(a1 + 192);
  if (!*v20)
  {
    v39 = 0;
    v88 = 0;
    v90 = 0;
LABEL_97:
    v18 = v82;
    if (!v81 || !*v86 || !*v85)
    {
      if (dword_10008BA20)
      {
        v60 = ne_log_obj(v32);
        v7 = 16;
        v27 = (sockaddr *)v90;
        if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
          sub_10005B158();
        goto LABEL_115;
      }
      v7 = 16;
      goto LABEL_159;
    }
    v54 = dword_1000882C8;
    if (*v84 && dword_1000882C8 >= 7)
    {
      sub_10003372C(7, (*v84)[1], **v84, "received IDci2:", v33, v34, v35, v36, (char)v80);
      v54 = dword_1000882C8;
    }
    if (*v87 && v54 >= 7)
      sub_10003372C(7, (*v87)[1], **v87, "received IDcr2:", v33, v34, v35, v36, (char)v80);
    *v83 = v39;
    v55 = sub_10002A3A0(*(_QWORD *)(a1 + 256), *(_DWORD *)(a1 + 108), (uint64_t)v83);
    if (!v55)
    {
      if (dword_10008BA20)
      {
        v61 = ne_log_obj(0);
        v27 = (sockaddr *)v90;
        if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
          sub_10005B070();
        goto LABEL_115;
      }
      goto LABEL_159;
    }
    v56 = (_QWORD *)v55;
    v57 = timingsafe_bcmp(*(const void **)(v55 + 8), (const void *)(v81 + 4), *(_QWORD *)v55);
    sub_10003F318(v56);
    if (v57)
    {
      if (dword_10008BA20)
      {
        v59 = ne_log_obj(v58);
        v27 = (sockaddr *)v90;
        if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
          sub_10005B28C();
        v7 = 23;
        goto LABEL_115;
      }
      v7 = 23;
      goto LABEL_159;
    }
    v66 = sub_10001F140((uint64_t *)a1);
    if ((_DWORD)v66)
    {
      if (dword_10008BA20)
      {
        v67 = ne_log_obj(v66);
        v27 = (sockaddr *)v90;
        if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
          sub_10005B260();
        v7 = 0xFFFFFFFFLL;
        goto LABEL_115;
      }
      goto LABEL_156;
    }
    v71 = sub_10001F544(a1);
    if ((_DWORD)v71)
    {
      v7 = v71;
      if ((_DWORD)v71 != -2)
      {
        if (dword_10008BA20)
        {
          v77 = ne_log_obj(v71);
          if (os_log_type_enabled(v77, OS_LOG_TYPE_ERROR))
            sub_10005B184();
        }
        goto LABEL_159;
      }
      v72 = sub_100037A3C(a1);
      if ((_DWORD)v72)
      {
        if (dword_10008BA20)
        {
          v73 = ne_log_obj(v72);
          if (os_log_type_enabled(v73, OS_LOG_TYPE_ERROR))
            sub_10005B234();
        }
LABEL_156:
        v7 = 0xFFFFFFFFLL;
        goto LABEL_159;
      }
    }
    v74 = sub_10000CB50(a1);
    if ((v74 & 0x80000000) != 0)
    {
      if (dword_10008BA20)
      {
        v78 = ne_log_obj(v74);
        if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
          sub_10005B1B0();
      }
      goto LABEL_183;
    }
    v75 = *(_DWORD *)(*(_QWORD *)(a1 + 128) + 20);
    if (*(_QWORD *)(a1 + 176))
    {
      if (!v75)
      {
        if (dword_10008BA20)
        {
          v76 = ne_log_obj(v74);
          if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
            sub_10005B208();
        }
LABEL_183:
        v7 = 14;
        goto LABEL_159;
      }
    }
    else if (v75)
    {
      if (dword_10008BA20)
      {
        v79 = ne_log_obj(v74);
        if (os_log_type_enabled(v79, OS_LOG_TYPE_ERROR))
          sub_10005B1DC();
      }
      goto LABEL_183;
    }
    sub_10004B1D0(a1);
    *(_QWORD *)(a1 + 88) = sub_10003F34C((uint64_t)a2);
    sub_100003774(v3, 6593);
    v7 = 0;
    goto LABEL_159;
  }
  v88 = 0;
  v90 = 0;
  v38 = 0;
  v39 = 0;
  v80 = v96;
  while (2)
  {
    v40 = memcpy(v37, *((const void **)v20 + 1), *((int *)v20 + 1));
    v45 = *v20;
    if (v45 != 5)
      v38 = 0;
    if (*v20 > 0xFu)
    {
      v46 = v45 == 16 || v45 == 21;
      if (v46 || v45 == 131)
      {
        v92 = 0;
        sub_1000263B8((size_t **)&v92, *((_QWORD *)v20 + 1));
        v32 = (uint64_t)v92;
        if (v92)
        {
          v47 = sub_10003FA50((uint64_t)v92);
          if (v47)
          {
            v48 = (const sockaddr *)v47;
            if (v90)
            {
              if (v88)
              {
                free(v47);
              }
              else
              {
                if (dword_10008BA20)
                {
                  v89 = ne_log_obj(v47);
                  if (os_log_type_enabled(v89, OS_LOG_TYPE_DEBUG))
                    sub_10005B490((uint64_t)v95, v48);
                }
                v88 = v48;
              }
            }
            else
            {
              if (dword_10008BA20)
              {
                v91 = ne_log_obj(v47);
                if (os_log_type_enabled(v91, OS_LOG_TYPE_DEBUG))
                  sub_10005B454((uint64_t)buf, v48);
              }
              v90 = v48;
            }
          }
          sub_10003F318(v92);
        }
        goto LABEL_87;
      }
LABEL_137:
      if (!dword_10008BA20)
      {
        v7 = 16;
        goto LABEL_158;
      }
      v68 = ne_log_obj(v40);
      v7 = 16;
      v18 = v82;
      v27 = (sockaddr *)v90;
      if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
        sub_10005B2B8();
      goto LABEL_115;
    }
    switch(*v20)
    {
      case 1u:
        if (*v86)
        {
          if (dword_10008BA20)
          {
            v62 = ne_log_obj(v86);
            v18 = v82;
            v27 = (sockaddr *)v90;
            if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
              sub_10005B344();
            goto LABEL_115;
          }
          goto LABEL_158;
        }
        v32 = sub_1000263B8(v86, *((_QWORD *)v20 + 1));
        if ((v32 & 0x80000000) != 0)
        {
          if (dword_10008BA20)
          {
            v65 = ne_log_obj(v32);
            v18 = v82;
            v27 = (sockaddr *)v90;
            if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
              sub_10005B318();
            goto LABEL_115;
          }
          goto LABEL_158;
        }
        goto LABEL_87;
      case 4u:
        v32 = sub_1000263B8((size_t **)(a1 + 176), *((_QWORD *)v20 + 1));
        if ((v32 & 0x80000000) == 0)
          goto LABEL_87;
        if (!dword_10008BA20)
          goto LABEL_158;
        v63 = ne_log_obj(v32);
        v18 = v82;
        v27 = (sockaddr *)v90;
        if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
          sub_10005B39C();
        goto LABEL_115;
      case 5u:
        if (!*v84)
        {
          v32 = sub_1000263B8(v84, *((_QWORD *)v20 + 1));
          if ((v32 & 0x80000000) == 0)
          {
            ++v38;
            goto LABEL_87;
          }
          if (!dword_10008BA20)
            goto LABEL_158;
          v70 = ne_log_obj(v32);
          v18 = v82;
          v27 = (sockaddr *)v90;
          if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR))
            sub_10005B3C8();
LABEL_115:
          v26 = (sockaddr *)v88;
          goto LABEL_160;
        }
        if (*v87)
        {
          if (dword_1000882C8 >= 3)
            sub_10003372C(3, (*v87)[1], **v87, "received too many ID payloads", v41, v42, v43, v44, (char)v96);
          v7 = 18;
          goto LABEL_158;
        }
        if (!v38)
        {
          if (dword_10008BA20)
          {
            v49 = ne_log_obj(v84);
            if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
              sub_10005B420(&v93, v94, v49);
          }
        }
        v32 = sub_1000263B8(v87, *((_QWORD *)v20 + 1));
        if ((v32 & 0x80000000) == 0)
        {
LABEL_87:
          v50 = v20[16];
          v20 += 16;
          v51 = *((int *)v20 - 3);
          v37 += v51;
          v39 += v51;
          if (!v50)
            goto LABEL_97;
          continue;
        }
        if (dword_10008BA20)
        {
          v69 = ne_log_obj(v32);
          v18 = v82;
          v27 = (sockaddr *)v90;
          if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
            sub_10005B3F4();
          goto LABEL_115;
        }
LABEL_158:
        v18 = v82;
LABEL_159:
        v26 = (sockaddr *)v88;
        v27 = (sockaddr *)v90;
LABEL_160:
        sub_10003F318(v83);
LABEL_161:
        sub_10003F318(v16);
        sub_10003F318(v18);
        if (v27)
          free(v27);
        if (v26)
          free(v26);
        if ((_DWORD)v7)
          goto LABEL_10;
        return v7;
      case 0xAu:
        v32 = sub_1000263B8(v85, *((_QWORD *)v20 + 1));
        if ((v32 & 0x80000000) == 0)
          goto LABEL_87;
        if (!dword_10008BA20)
          goto LABEL_158;
        v64 = ne_log_obj(v32);
        v18 = v82;
        v27 = (sockaddr *)v90;
        if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
          sub_10005B370();
        goto LABEL_115;
      case 0xBu:
        sub_10001BE0C(*((_QWORD *)v20 + 1), a1);
        goto LABEL_87;
      default:
        goto LABEL_137;
    }
  }
}

uint64_t sub_10001F140(uint64_t *a1)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  int v5;
  unsigned int v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  NSObject *v10;
  uint64_t v11;
  int v12;
  unsigned int v13;
  NSObject *v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  NSObject *v31;
  NSObject *v32;
  NSObject *v33;
  NSObject *v34;
  NSObject *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  NSObject *v39;
  NSObject *v40;
  NSObject *v42;

  v2 = a1[24];
  if (v2)
  {
    v3 = sub_10003F34C(v2);
  }
  else
  {
    v4 = *a1;
    v5 = *(unsigned __int8 *)(*a1 + 1);
    if (v5 == 2)
    {
      v6 = 32;
    }
    else
    {
      if (v5 != 30)
      {
        if (dword_10008BA20)
        {
          v14 = ne_log_obj(v4);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
            sub_100057F20();
        }
        return 0xFFFFFFFFLL;
      }
      v6 = 128;
    }
    v3 = sub_100010ADC(v4, v6, 255);
  }
  v7 = v3;
  if (!v3)
  {
    if (dword_10008BA20)
    {
      v10 = ne_log_obj(0);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_10005B4CC();
    }
    return 0xFFFFFFFFLL;
  }
  v8 = a1[25];
  if (v8)
  {
    v9 = sub_10003F34C(v8);
LABEL_22:
    v15 = v9;
    if (v9)
    {
      v16 = (_QWORD *)sub_100039CAC((uint64_t)v7, (uint64_t)v9, *(_QWORD *)(a1[32] + 320), 0);
      v17 = v16;
      a1[14] = (uint64_t)v16;
      v18 = a1 + 14;
      if (v16)
      {
        if (*v16)
          goto LABEL_65;
        v19 = a1[34];
        if (!v19 || (*(_WORD *)(v19 + 264) & 0x400) == 0)
          goto LABEL_65;
      }
      v20 = a1[32];
      if ((*(_BYTE *)(v20 + 96) & 2) != 0 && *(_QWORD *)(qword_10008B848 + 296))
      {
        v16 = (_QWORD *)sub_100039CAC((uint64_t)v7, (uint64_t)v15, *(_QWORD *)(v20 + 320), 1);
        *v18 = (uint64_t)v16;
      }
      if (v16 && dword_10008BA20)
      {
        v21 = ne_log_obj(v16);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
          sub_10005B644();
        v16 = (_QWORD *)*v18;
      }
      if (v16)
      {
        if (*v16)
          goto LABEL_65;
        v22 = a1[34];
        if (!v22 || (*(_WORD *)(v22 + 264) & 0x400) == 0)
          goto LABEL_65;
      }
      v23 = sub_10004E078((uint64_t)a1);
      v30 = (_QWORD *)a1[14];
      if (v30 && dword_10008BA20)
      {
        v31 = ne_log_obj(v23);
        v23 = os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG);
        if ((_DWORD)v23)
          sub_10005B618();
        v30 = (_QWORD *)*v18;
      }
      if (v30 && *v30)
        goto LABEL_65;
      if (a1[25])
      {
        if (dword_10008BA20)
        {
          v32 = ne_log_obj(v23);
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
            sub_10005B5EC();
        }
        v23 = sub_100039E8C(a1[25], *(_QWORD *)(a1[32] + 320), v24, v25, v26, v27, v28, v29);
        a1[14] = v23;
        if (v23)
        {
          if (dword_10008BA20)
          {
            v33 = ne_log_obj(v23);
            if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
              sub_10005B5C0();
          }
          goto LABEL_65;
        }
      }
      else if (v30)
      {
        goto LABEL_65;
      }
      if (!v17)
      {
        if (dword_10008BA20)
        {
          v42 = ne_log_obj(v23);
          if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
            sub_10005B260();
        }
        goto LABEL_70;
      }
      *v18 = (uint64_t)v17;
LABEL_65:
      v37 = sub_10003A2BC(*v18);
      v38 = *(_QWORD *)(*v18 + 16);
      if (!v38 || (v37 = sub_1000460D0(a1[32], (char **)(v38 + 8), 1), !(_DWORD)v37))
      {
        if (dword_10008BA20)
        {
          v40 = ne_log_obj(v37);
          if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
            sub_10005B524((uint64_t **)v18);
        }
        v36 = 0;
        goto LABEL_75;
      }
      if (dword_10008BA20)
      {
        v39 = ne_log_obj(v37);
        if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
          sub_10005B594();
      }
LABEL_70:
      v36 = 0xFFFFFFFFLL;
LABEL_75:
      sub_10003F318(v7);
      sub_10003F318(v15);
      return v36;
    }
    if (dword_10008BA20)
    {
      v34 = ne_log_obj(0);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        sub_10005B4F8();
    }
    goto LABEL_60;
  }
  v11 = a1[1];
  v12 = *(unsigned __int8 *)(v11 + 1);
  if (v12 == 2)
  {
    v13 = 32;
    goto LABEL_21;
  }
  if (v12 == 30)
  {
    v13 = 128;
LABEL_21:
    v9 = sub_100010ADC(v11, v13, 255);
    goto LABEL_22;
  }
  if (dword_10008BA20)
  {
    v35 = ne_log_obj(v11);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      sub_100057F20();
  }
LABEL_60:
  sub_10003F318(v7);
  return 0xFFFFFFFFLL;
}

uint64_t sub_10001F544(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;

  result = sub_1000208F0((unsigned __int8 *)a1, 0);
  if ((_DWORD)result == -2 || !(_DWORD)result)
    return result;
  if ((*(_BYTE *)(*(_QWORD *)(a1 + 256) + 96) & 2) == 0 || !*(_QWORD *)(qword_10008B848 + 296))
  {
    v3 = *(_QWORD *)(a1 + 272);
    if (!v3 || (*(_WORD *)(v3 + 264) & 0x400) == 0)
      return result;
    goto LABEL_10;
  }
  v3 = *(_QWORD *)(a1 + 272);
  if (v3)
  {
LABEL_10:
    if ((*(_WORD *)(v3 + 264) & 0x400) != 0)
      result = sub_10004E2C8(a1);
  }
  if ((_DWORD)result != -2)
  {
    if ((_DWORD)result)
      return sub_1000208F0((unsigned __int8 *)a1, 1);
  }
  return result;
}

uint64_t sub_10001F5E0(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  unsigned int v4;
  uint64_t result;
  NSObject *v6;
  NSObject *v7;

  if (*(_DWORD *)(a1 + 56) != 6593)
  {
    if (dword_10008BA20)
    {
      v6 = ne_log_obj(a1);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        sub_100058E84();
    }
    return 0xFFFFFFFFLL;
  }
  sub_100003774((int *)(a1 + 56), 6640);
  v2 = sub_10002F7B4(a1);
  if ((v2 & 0x80000000) != 0)
  {
    if (dword_10008BA20)
    {
      v7 = ne_log_obj(v2);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_10005B670();
    }
    return 0xFFFFFFFFLL;
  }
  if (dword_10008BA20)
  {
    v3 = ne_log_obj(v2);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
      sub_10005A99C();
  }
  v4 = sub_10003A520(*(int *)(qword_10008B848 + 284), (uint64_t)sub_10002F66C, a1);
  result = 0;
  *(_DWORD *)(a1 + 64) = v4;
  return result;
}

uint64_t sub_10001F6E4(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  int *v4;
  uint64_t v5;
  _QWORD *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _DWORD *v12;
  uint64_t v13;
  int v14;
  NSObject *v15;
  NSObject *v16;
  NSObject *v17;
  NSObject *v18;
  NSObject *v19;
  _QWORD *v20;
  uint64_t v21;
  char *v22;
  int v23;
  NSObject *v24;
  char *v25;
  char *v26;
  int v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  void **v40;
  void **v41;
  void **v42;
  void **v43;
  void **v44;
  uint64_t v45;
  _QWORD *v46;
  char *v47;
  _QWORD *v48;
  _QWORD *v49;
  uint64_t *v50;
  uint64_t v51;
  _QWORD *v52;
  uint64_t v53;
  unint64_t v54;
  unsigned __int8 *v55;
  unsigned __int8 *v56;
  _QWORD *v57;
  uint64_t v58;
  NSObject *v59;
  NSObject *v60;
  NSObject *v61;
  NSObject *v62;
  NSObject *v63;
  NSObject *v64;
  NSObject *v65;
  NSObject *v66;
  uint64_t v67;
  NSObject *v69;
  NSObject *v70;
  uint64_t v71;
  NSObject *v72;
  NSObject *v73;
  char v74;
  unsigned int v75;
  char *v76;
  void *v77;
  void *v78;

  v77 = 0;
  v78 = 0;
  v76 = 0;
  if (a2)
  {
    if (dword_10008BA20)
    {
      v2 = ne_log_obj(a1);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_10005B828();
    }
    goto LABEL_107;
  }
  v4 = (int *)(a1 + 56);
  if (*(_DWORD *)(a1 + 56) != 6608)
  {
    if (dword_10008BA20)
    {
      v16 = ne_log_obj(a1);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        sub_100058E84();
    }
    goto LABEL_107;
  }
  v5 = sub_10000D850(a1);
  if ((v5 & 0x80000000) != 0)
  {
    if (dword_10008BA20)
    {
      v17 = ne_log_obj(v5);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        sub_10005B69C();
    }
    goto LABEL_107;
  }
  v6 = sub_100006C70(*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 256) + 64) + 140));
  *(_QWORD *)(a1 + 208) = v6;
  if (!v6)
  {
    if (dword_10008BA20)
    {
      v18 = ne_log_obj(0);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        sub_100058CC8();
    }
    goto LABEL_107;
  }
  v7 = *(_DWORD *)(*(_QWORD *)(a1 + 128) + 20);
  v8 = *(_QWORD *)(a1 + 176);
  if (v8 && v7)
  {
    v9 = sub_100029AD4(*(unsigned int *)(*(_QWORD *)(a1 + 128) + 20), a1 + 152);
    if ((v9 & 0x80000000) != 0)
    {
      if (dword_10008BA20)
      {
        v59 = ne_log_obj(v9);
        if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
          sub_10005B6C8();
      }
      goto LABEL_107;
    }
    v10 = sub_1000297D4(*(_QWORD *)(a1 + 152), (size_t **)(a1 + 168), (_QWORD *)(a1 + 144));
    if ((v10 & 0x80000000) != 0)
    {
      if (dword_10008BA20)
      {
        v60 = ne_log_obj(v10);
        if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
          sub_10005B6F4();
      }
      goto LABEL_107;
    }
    v6 = *(_QWORD **)(a1 + 208);
    v8 = *(_QWORD *)(a1 + 176);
  }
  v11 = **(_QWORD **)(a1 + 232) + *v6 + 8;
  if (v8 && v7)
    v11 = **(_QWORD **)(a1 + 168) + (int)v11 + 4;
  v12 = *(_DWORD **)(a1 + 200);
  if (v12)
    LODWORD(v11) = *v12 + **(_DWORD **)(a1 + 192) + v11 + 8;
  v13 = sub_10000F5BC(*(_QWORD *)(a1 + 128));
  if ((_DWORD)v13 && (*(_BYTE *)(*(_QWORD *)(a1 + 256) + 96) & 6) != 0)
  {
    v13 = sub_10003F804(a1, &v78, &v77);
    v14 = v13;
    if ((_DWORD)v13)
    {
      if ((_DWORD)v13 == -1)
      {
        if (dword_10008BA20)
        {
          v15 = ne_log_obj(v13);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
            sub_10005B7FC();
        }
        goto LABEL_107;
      }
      LODWORD(v11) = v11 + *(_DWORD *)v78 + *(_DWORD *)v77 + 8;
    }
  }
  else
  {
    v14 = 0;
  }
  if (dword_10008BA20)
  {
    v19 = ne_log_obj(v13);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
      sub_10005B7D0();
  }
  sub_100036C54(7, *(_QWORD *)(a1 + 128));
  v20 = sub_10003F1F8((int)v11);
  if (!v20)
  {
    if (dword_10008BA20)
    {
      v24 = ne_log_obj(0);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        sub_10005A794();
    }
    goto LABEL_107;
  }
  v21 = (uint64_t)v20;
  v22 = sub_10002659C(v20[1], *(uint64_t **)(a1 + 232), 10);
  v76 = v22;
  if (*(_QWORD *)(a1 + 176) && v7)
  {
    v23 = 4;
  }
  else if (*(_QWORD *)(a1 + 200))
  {
    v23 = 5;
  }
  else
  {
    v23 = v14;
  }
  v25 = sub_10002659C((uint64_t)v22, *(uint64_t **)(a1 + 208), v23);
  v26 = v25;
  if (*(_QWORD *)(a1 + 176) && v7)
  {
    v76 = v25;
    if (*(_QWORD *)(a1 + 200))
      v27 = 5;
    else
      v27 = v14;
    v26 = sub_10002659C((uint64_t)v25, *(uint64_t **)(a1 + 168), v27);
  }
  v28 = *(uint64_t **)(a1 + 200);
  if (v28)
  {
    v33 = sub_10002659C((uint64_t)v26, v28, 5);
    if (dword_1000882C8 >= 7)
      sub_10003372C(7, *(_QWORD *)(*(_QWORD *)(a1 + 200) + 8), **(_QWORD **)(a1 + 200), "sending IDci2:", v29, v30, v31, v32, v74);
    v76 = v33;
    v26 = sub_10002659C((uint64_t)v33, *(uint64_t **)(a1 + 192), v14);
    if (dword_1000882C8 >= 7)
      sub_10003372C(7, *(_QWORD *)(*(_QWORD *)(a1 + 192) + 8), **(_QWORD **)(a1 + 192), "sending IDcr2:", v34, v35, v36, v37, v74);
  }
  v38 = *(_QWORD *)(a1 + 128);
  v39 = *(_DWORD *)(v38 + 24);
  if ((v39 & 1) == 0)
  {
    if ((v39 & 2) == 0)
      goto LABEL_72;
    v40 = 0;
    goto LABEL_65;
  }
  v75 = bswap32(*(_DWORD *)(v38 + 8));
  v41 = (void **)sub_1000260E0(0, 1, 1u);
  if (!v41)
  {
    if (dword_10008BA20)
    {
      v61 = ne_log_obj(0);
      if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
        sub_10005B74C();
    }
    goto LABEL_106;
  }
  v42 = (void **)sub_10002600C(v41, 2u, &v75, 4);
  if (!v42)
  {
    if (!dword_10008BA20)
      goto LABEL_106;
    v64 = ne_log_obj(0);
    if (!os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
      goto LABEL_106;
    goto LABEL_105;
  }
  v40 = v42;
  if ((*(_BYTE *)(v38 + 24) & 2) != 0)
  {
LABEL_65:
    v75 = bswap32(*(_DWORD *)(v38 + 16));
    v43 = (void **)sub_1000260E0(v40, 1, 2u);
    if (!v43)
    {
      if (dword_10008BA20)
      {
        v63 = ne_log_obj(0);
        if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
          sub_10005B74C();
      }
      goto LABEL_106;
    }
    v44 = (void **)sub_10002600C(v43, 2u, &v75, 4);
    if (v44)
    {
      v40 = v44;
      goto LABEL_68;
    }
    if (!dword_10008BA20 || (v66 = ne_log_obj(0), !os_log_type_enabled(v66, OS_LOG_TYPE_ERROR)))
    {
LABEL_106:
      sub_10003F318((_QWORD *)v21);
LABEL_107:
      v67 = 0xFFFFFFFFLL;
      goto LABEL_108;
    }
LABEL_105:
    sub_10005B778();
    goto LABEL_106;
  }
LABEL_68:
  v45 = *(_QWORD *)(v38 + 32);
  if (v45)
  {
    while (1)
    {
      v46 = sub_10001B408((void **)v21, &v76, 0x6000u, (_DWORD *)v45, (uint64_t)v40);
      if (!v46)
        break;
      v21 = (uint64_t)v46;
      v45 = *(_QWORD *)(v45 + 72);
      if (!v45)
        goto LABEL_71;
    }
    if (dword_10008BA20)
    {
      v69 = ne_log_obj(0);
      if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
        sub_10005B7A4();
    }
    v67 = 0xFFFFFFFFLL;
    goto LABEL_111;
  }
LABEL_71:
  sub_10003F318(v40);
LABEL_72:
  if (v14)
  {
    v47 = sub_10002659C((uint64_t)v26, (uint64_t *)v78, v14);
    sub_10002659C((uint64_t)v47, (uint64_t *)v77, 0);
  }
  v48 = sub_10003F1F8(*(_QWORD *)v21 + **(_QWORD **)(a1 + 216));
  if (!v48)
  {
    if (dword_10008BA20)
    {
      v62 = ne_log_obj(0);
      if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
        sub_10005ABE4();
    }
    goto LABEL_106;
  }
  v49 = v48;
  memcpy((void *)v48[1], *(const void **)(*(_QWORD *)(a1 + 216) + 8), **(_QWORD **)(a1 + 216));
  memcpy((void *)(v49[1] + **(_QWORD **)(a1 + 216)), *(const void **)(v21 + 8), *(_QWORD *)v21);
  v50 = (uint64_t *)sub_10002A3A0(*(_QWORD *)(a1 + 256), *(_DWORD *)(a1 + 108), (uint64_t)v49);
  sub_10003F318(v49);
  if (!v50)
  {
    if (dword_10008BA20)
    {
      v65 = ne_log_obj(v51);
      if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
        sub_10005AA20();
    }
    goto LABEL_106;
  }
  v52 = sub_10001CFE4(a1, v21, v50);
  *(_QWORD *)(a1 + 80) = v52;
  if (!v52)
  {
    if (dword_10008BA20)
    {
      v70 = ne_log_obj(0);
      if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR))
        sub_10005B720();
    }
    goto LABEL_129;
  }
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 256) + 64) + 200);
  v53 = sub_1000248F8(a1);
  if ((_DWORD)v53 == -1)
  {
    if (dword_10008BA20)
    {
      v72 = ne_log_obj(v53);
      if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
        sub_100058CF4();
    }
    goto LABEL_129;
  }
  v54 = *(_QWORD *)(a1 + 256);
  v55 = *(unsigned __int8 **)(v54 + 48);
  v56 = *(unsigned __int8 **)(v54 + 56);
  v57 = *(_QWORD **)(a1 + 80);
  if (*(_DWORD *)(v54 + 100) && *v57 >= 0x501uLL)
  {
    v58 = 0;
    LODWORD(v54) = *(_DWORD *)(v54 + 96);
  }
  else
  {
    v54 = *(unsigned int *)(v54 + 96);
    v58 = (v54 >> 3) & 4;
  }
  v71 = sub_100009B6C(v55, v56, (uint64_t)v57, *(_QWORD *)(a1 + 88), v58, (v54 >> 5) & 1);
  if ((_DWORD)v71 == -1)
  {
    if (dword_10008BA20)
    {
      v73 = ne_log_obj(v71);
      if (os_log_type_enabled(v73, OS_LOG_TYPE_ERROR))
        sub_10005961C();
    }
LABEL_129:
    v67 = 0xFFFFFFFFLL;
    goto LABEL_130;
  }
  sub_100003774(v4, 6626);
  v67 = 0;
LABEL_130:
  sub_10003F318((_QWORD *)v21);
  sub_10003F318(v50);
LABEL_108:
  if (v78)
    sub_10003F318(v78);
  v40 = (void **)v77;
  if (v77)
LABEL_111:
    sub_10003F318(v40);
  return v67;
}

uint64_t sub_10001FEC4(uint64_t a1, _QWORD *a2)
{
  int *v2;
  NSObject *v3;
  NSObject *v4;
  uint64_t v5;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned __int8 *i;
  int v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  NSObject *v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  NSObject *v25;
  NSObject *v26;
  NSObject *v27;
  int v28;

  v2 = (int *)(a1 + 56);
  if (*(_DWORD *)(a1 + 56) != 6626)
  {
    if (dword_10008BA20)
    {
      v4 = ne_log_obj(a1);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_100058E84();
    }
    return 0xFFFFFFFFLL;
  }
  if ((*(_BYTE *)(a2[1] + 19) & 1) == 0)
  {
    if (dword_10008BA20)
    {
      v3 = ne_log_obj(a1);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        sub_10005AB28();
    }
    return 0xFFFFFFFFLL;
  }
  v8 = sub_10002E000(*(_QWORD *)(a1 + 256), a2, **(_QWORD **)(a1 + 240), *(_QWORD *)(*(_QWORD *)(a1 + 240) + 8));
  if (!v8)
  {
    if (dword_10008BA20)
    {
      v22 = ne_log_obj(0);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        sub_10005B018();
    }
    return 0xFFFFFFFFLL;
  }
  v9 = v8;
  v10 = sub_1000232C8((uint64_t)v8);
  if (!v10)
  {
    if (dword_10008BA20)
    {
      v23 = ne_log_obj(0);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        sub_10005B044();
    }
    v5 = 0xFFFFFFFFLL;
    goto LABEL_49;
  }
  v11 = v10;
  v12 = 0;
  for (i = (unsigned __int8 *)v10[1]; ; i += 16)
  {
    v14 = *i;
    if (v14 != 8)
      break;
    v12 = *((_QWORD *)i + 1);
LABEL_18:
    ;
  }
  if (v14 == 11)
  {
    sub_10001BE0C(*((_QWORD *)i + 1), a1);
    goto LABEL_18;
  }
  if (*i)
  {
    if (dword_10008BA20)
    {
      v24 = ne_log_obj(v10);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        sub_100059D10();
    }
    goto LABEL_47;
  }
  if (!v12)
  {
    if (dword_10008BA20)
    {
      v25 = ne_log_obj(v10);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        sub_100058FA0();
    }
    goto LABEL_47;
  }
  v15 = sub_10003F1F8(**(_QWORD **)(a1 + 208) + **(_QWORD **)(a1 + 216));
  if (!v15)
  {
    if (dword_10008BA20)
    {
      v26 = ne_log_obj(0);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        sub_10005ABE4();
    }
    goto LABEL_47;
  }
  v16 = v15;
  memcpy((void *)v15[1], *(const void **)(*(_QWORD *)(a1 + 216) + 8), **(_QWORD **)(a1 + 216));
  memcpy((void *)(v16[1] + **(_QWORD **)(a1 + 216)), *(const void **)(*(_QWORD *)(a1 + 208) + 8), **(_QWORD **)(a1 + 208));
  v17 = sub_10002A2C0(*(_QWORD *)(a1 + 256), *(_DWORD *)(a1 + 108), (uint64_t)v16);
  sub_10003F318(v16);
  if (!v17)
  {
    if (dword_10008BA20)
    {
      v27 = ne_log_obj(v18);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        sub_10005B070();
    }
LABEL_47:
    v5 = 0xFFFFFFFFLL;
    goto LABEL_48;
  }
  v19 = timingsafe_bcmp(*(const void **)(v17 + 8), (const void *)(v12 + 4), *(_QWORD *)v17);
  sub_10003F318((_QWORD *)v17);
  if (v19)
  {
    if (dword_10008BA20)
    {
      v21 = ne_log_obj(v20);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        sub_10005B854();
    }
    v5 = 23;
  }
  else
  {
    if ((*(_BYTE *)(a1 + 105) & 2) != 0)
      v28 = 6595;
    else
      v28 = 6596;
    sub_100003774(v2, v28);
    v5 = 0;
  }
LABEL_48:
  sub_10003F318(v11);
LABEL_49:
  sub_10003F318(v9);
  return v5;
}

uint64_t sub_10002020C(uint64_t a1, uint64_t a2)
{
  int *v2;
  NSObject *v5;
  signed int v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t *v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  char *v16;
  size_t *v17;
  uint64_t v18;
  unint64_t v19;
  unsigned __int8 *v20;
  unsigned __int8 *v21;
  _QWORD *v22;
  uint64_t v23;
  NSObject *v24;
  NSObject *v25;
  uint64_t v26;
  NSObject *v27;
  NSObject *v28;
  NSObject *v29;
  NSObject *v30;
  uint64_t v31;
  NSObject *v32;
  NSObject *v33;

  v2 = (int *)(a1 + 56);
  if (*(_DWORD *)(a1 + 56) == 6595)
  {
    if (dword_10008BA20)
    {
      v5 = ne_log_obj(a1);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
        sub_10005B8AC();
    }
    v6 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 128) + 32) + 8) + 12;
    v7 = sub_10003F1F8(v6);
    if (v7)
    {
      v8 = (uint64_t)v7;
      v9 = v7[1];
      *(_BYTE *)v9 = 0;
      *(_WORD *)(v9 + 2) = bswap32(v6) >> 16;
      *(_DWORD *)(v9 + 4) = 0x1000000;
      v10 = *(_QWORD *)(*(_QWORD *)(a1 + 128) + 32);
      *(_BYTE *)(v9 + 8) = *(_DWORD *)v10;
      *(_BYTE *)(v9 + 9) = 8;
      *(_WORD *)(v9 + 10) = 64;
      memcpy((void *)(v9 + 12), (const void *)(v10 + 24), *(_QWORD *)(v10 + 8));
      v11 = (uint64_t *)sub_10002A3A0(*(_QWORD *)(a1 + 256), *(_DWORD *)(a1 + 108), v8);
      if (!v11)
      {
        if (dword_10008BA20)
        {
          v27 = ne_log_obj(0);
          if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
            sub_10005AA20();
        }
        v26 = 0xFFFFFFFFLL;
        goto LABEL_47;
      }
      v12 = v11;
      v13 = sub_10003F1F8(*(_DWORD *)v11 + *(_DWORD *)v8 + 32);
      if (!v13)
      {
        if (dword_10008BA20)
        {
          v28 = ne_log_obj(0);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
            sub_10005A794();
        }
        v26 = 0xFFFFFFFFLL;
        goto LABEL_46;
      }
      v14 = v13;
      v15 = sub_100026584((uint64_t)v13, a1, 8);
      if (v15)
      {
        v16 = sub_10002659C(v15, v12, 11);
        memcpy(v16, *(const void **)(v8 + 8), *(_QWORD *)v8);
        v17 = sub_10002E3DC(*(_QWORD *)(a1 + 256), (uint64_t)v14, *(_QWORD *)(*(_QWORD *)(a1 + 240) + 8), **(_QWORD **)(a1 + 240));
        *(_QWORD *)(a1 + 80) = v17;
        if (v17)
        {
          v18 = sub_1000240A4(*(_QWORD *)(a1 + 256), v17);
          if ((v18 & 0x80000000) != 0)
          {
            if (dword_10008BA20)
            {
              v32 = ne_log_obj(v18);
              if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
                sub_100058CF4();
            }
          }
          else
          {
            v19 = *(_QWORD *)(a1 + 256);
            v20 = *(unsigned __int8 **)(v19 + 48);
            v21 = *(unsigned __int8 **)(v19 + 56);
            v22 = *(_QWORD **)(a1 + 80);
            if (*(_DWORD *)(v19 + 100) && *v22 >= 0x501uLL)
            {
              v23 = 0;
              LODWORD(v19) = *(_DWORD *)(v19 + 96);
            }
            else
            {
              v19 = *(unsigned int *)(v19 + 96);
              v23 = (v19 >> 3) & 4;
            }
            v31 = sub_100009B6C(v20, v21, (uint64_t)v22, a2, v23, (v19 >> 5) & 1);
            if ((_DWORD)v31 != -1)
            {
              sub_100003774(v2, 6596);
              v26 = 0;
LABEL_45:
              sub_10003F318(v14);
LABEL_46:
              sub_10003F318(v12);
LABEL_47:
              sub_10003F318((_QWORD *)v8);
              return v26;
            }
            if (dword_10008BA20)
            {
              v33 = ne_log_obj(v31);
              if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
                sub_10005961C();
            }
          }
        }
        else if (dword_10008BA20)
        {
          v30 = ne_log_obj(0);
          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
            sub_10005A7C0();
        }
      }
      else if (dword_10008BA20)
      {
        v29 = ne_log_obj(0);
        if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
          sub_10005B880();
      }
      v26 = 0xFFFFFFFFLL;
      goto LABEL_45;
    }
    if (dword_10008BA20)
    {
      v25 = ne_log_obj(0);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        sub_10005B0C8();
    }
  }
  else if (dword_10008BA20)
  {
    v24 = ne_log_obj(a1);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      sub_100058E84();
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100020554(uint64_t a1)
{
  int *v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t result;
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  uint64_t v17;
  char v18;
  uint64_t v19;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;

  v1 = (int *)(a1 + 56);
  if (*(_DWORD *)(a1 + 56) != 6596)
  {
    if (dword_10008BA20)
    {
      v6 = ne_log_obj(a1);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        sub_100058E84();
    }
    return 0xFFFFFFFFLL;
  }
  v3 = sub_100029D2C(a1, 1);
  if ((v3 & 0x80000000) != 0)
  {
    if (dword_10008BA20)
    {
      v7 = ne_log_obj(v3);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_10005B8D8();
    }
    return 0xFFFFFFFFLL;
  }
  sub_100003774(v1, 6600);
  *(_BYTE *)(a1 + 105) ^= 2u;
  if (dword_10008B858)
    return 0;
  if (dword_10008BA20)
  {
    v8 = ne_log_obj(v4);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      sub_10005AF94();
  }
  v9 = sub_10002FBE0(a1);
  if ((v9 & 0x80000000) != 0)
  {
    if (dword_10008BA20)
    {
      v21 = ne_log_obj(v9);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        sub_10005AEE4();
    }
    return 0xFFFFFFFFLL;
  }
  if (dword_10008BA20)
  {
    v10 = ne_log_obj(v9);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      sub_10005AF68();
  }
  v11 = sub_10002FFB8(a1);
  if ((v11 & 0x80000000) != 0)
  {
    if (dword_10008BA20)
    {
      v22 = ne_log_obj(v11);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        sub_10005AF10();
    }
    return 0xFFFFFFFFLL;
  }
  if (dword_10008BA20)
  {
    v12 = ne_log_obj(v11);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      sub_10005AF3C();
  }
  if (!*(_QWORD *)(a1 + 136))
    return 0;
  v13 = *(_QWORD *)a1;
  v14 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a1 = v14;
  *(_QWORD *)(a1 + 8) = v13;
  v15 = sub_100030390(a1);
  if ((v15 & 0x80000000) != 0)
  {
    if (dword_10008BA20)
    {
      v23 = ne_log_obj(v15);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        sub_10005B904();
    }
    return 0xFFFFFFFFLL;
  }
  if (dword_10008BA20)
  {
    v16 = ne_log_obj(v15);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
      sub_10005B988();
  }
  v17 = *(_QWORD *)(a1 + 136);
  *(_QWORD *)a1 = v13;
  *(_QWORD *)(a1 + 8) = v14;
  *(_BYTE *)v17 = 2;
  v29 = *(_OWORD *)(v17 + 72);
  v30 = *(_OWORD *)(v17 + 88);
  v31 = *(_OWORD *)(v17 + 104);
  v32 = *(_OWORD *)(v17 + 120);
  v25 = *(_OWORD *)(v17 + 8);
  v26 = *(_OWORD *)(v17 + 24);
  v27 = *(_OWORD *)(v17 + 40);
  v28 = *(_OWORD *)(v17 + 56);
  *(_OWORD *)(v17 + 8) = *(_OWORD *)(v17 + 136);
  *(_OWORD *)(v17 + 24) = *(_OWORD *)(v17 + 152);
  *(_OWORD *)(v17 + 40) = *(_OWORD *)(v17 + 168);
  *(_OWORD *)(v17 + 120) = *(_OWORD *)(v17 + 248);
  *(_OWORD *)(v17 + 104) = *(_OWORD *)(v17 + 232);
  *(_OWORD *)(v17 + 88) = *(_OWORD *)(v17 + 216);
  *(_OWORD *)(v17 + 72) = *(_OWORD *)(v17 + 200);
  *(_OWORD *)(v17 + 56) = *(_OWORD *)(v17 + 184);
  *(_OWORD *)(v17 + 184) = v28;
  *(_OWORD *)(v17 + 168) = v27;
  *(_OWORD *)(v17 + 152) = v26;
  *(_OWORD *)(v17 + 136) = v25;
  *(_OWORD *)(v17 + 248) = v32;
  *(_OWORD *)(v17 + 232) = v31;
  *(_OWORD *)(v17 + 216) = v30;
  *(_OWORD *)(v17 + 200) = v29;
  v18 = *(_BYTE *)(v17 + 264);
  *(_BYTE *)(v17 + 264) = *(_BYTE *)(v17 + 265);
  *(_BYTE *)(v17 + 265) = v18;
  v19 = sub_100030390(a1);
  if ((v19 & 0x80000000) != 0)
  {
    if (dword_10008BA20)
    {
      v24 = ne_log_obj(v19);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        sub_10005B930();
    }
    return 0xFFFFFFFFLL;
  }
  if (dword_10008BA20)
  {
    v20 = ne_log_obj(v19);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      sub_10005B95C();
  }
  sub_100034F18(*(void **)(a1 + 136));
  free(*(void **)(a1 + 136));
  result = 0;
  *(_QWORD *)(a1 + 136) = 0;
  *(_DWORD *)(a1 + 248) = 1;
  return result;
}

uint64_t sub_1000208F0(unsigned __int8 *a1, int a2)
{
  unint64_t *v3;
  uint64_t v4;
  NSObject *v5;
  unsigned int v6;
  uint64_t result;
  int v8;
  int v9;
  int v10;
  NSObject *v11;
  NSObject *v12;
  uint64_t v13;
  NSObject *v14;
  unsigned int v15;
  int v16;
  unsigned __int8 *v17;
  NSObject *v18;
  NSObject *v19;
  NSObject *v20;
  _BOOL8 v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  NSObject *v25;
  const char *v26;
  unsigned __int8 *v27;
  int v28;
  char v29;
  uint64_t v30;
  uint64_t v31;
  NSObject *v32;
  NSObject *v33;
  NSObject *v34;
  uint64_t v35;
  NSObject *v36;
  NSObject *v37;
  NSObject *v38;
  NSObject *v39;
  int v40;
  char *v41;
  uint8_t buf[16];
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  _OWORD __src[17];

  v3 = (unint64_t *)a1;
  memset(__src, 0, sizeof(__src));
  v4 = *((_QWORD *)a1 + 24);
  if (*((_QWORD *)a1 + 25))
  {
    if (v4)
    {
LABEL_3:
      if (!a2 && (*((_QWORD *)a1 + 4) || *((_QWORD *)a1 + 5)))
      {
        if (dword_10008BA20)
        {
          v14 = ne_log_obj(a1);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
            sub_10005BD28();
        }
        return 0xFFFFFFFFLL;
      }
      if (dword_10008BA20)
      {
        v5 = ne_log_obj(a1);
        a1 = (unsigned __int8 *)os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG);
        if ((_DWORD)a1)
          sub_10005BCA4(a2, v5);
      }
      memset(__src, 0, sizeof(__src));
      LOBYTE(__src[0]) = 1;
      if (!a2
        && (a1 = (unsigned __int8 *)v3[24]) != 0
        && (v6 = **((unsigned __int8 **)a1 + 1), v6 <= 6)
        && ((1 << v6) & 0x72) != 0)
      {
        result = sub_100010E6C((unint64_t *)a1, (uint64_t)&__src[8] + 8, (_BYTE *)&__src[16] + 9, (__int16 *)&__src[16] + 5, *((unsigned __int8 *)v3 + 61));
        if ((_DWORD)result)
          return result;
        v8 = **(unsigned __int8 **)(v3[24] + 8);
        if (v8 == 5)
        {
          result = sub_100027280((uint64_t)&__src[8] + 8, *v3);
          if ((_DWORD)result)
            return result;
          v8 = **(unsigned __int8 **)(v3[24] + 8);
        }
        if (v8 == 5)
          v9 = 5;
        else
          v9 = 0;
        if (v8 == 1)
          v10 = 1;
        else
          v10 = v9;
      }
      else
      {
        if (dword_10008BA20)
        {
          v12 = ne_log_obj(a1);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
            sub_10005BC78();
        }
        v13 = __memcpy_chk((char *)&__src[8] + 8, *v3, *(unsigned __int8 *)*v3, 136);
        if (BYTE9(__src[8]) == 30)
        {
          v10 = 0;
          BYTE9(__src[16]) = 0x80;
          if (a2)
            goto LABEL_55;
        }
        else if (BYTE9(__src[8]) == 2)
        {
          v10 = 0;
          BYTE9(__src[16]) = 32;
          WORD5(__src[8]) = 0;
          if (a2)
            goto LABEL_55;
        }
        else
        {
          v10 = 0;
          BYTE9(__src[16]) = 0;
          if (a2)
            goto LABEL_55;
        }
      }
      v13 = v3[25];
      if (v13)
      {
        v15 = **(unsigned __int8 **)(v13 + 8);
        if (v15 <= 6 && ((1 << v15) & 0x72) != 0)
        {
          result = sub_100010E6C((unint64_t *)v13, (uint64_t)__src + 8, (_BYTE *)&__src[16] + 8, (__int16 *)&__src[16] + 5, *((unsigned __int8 *)v3 + 61));
          if ((_DWORD)result)
            return result;
          v16 = **(unsigned __int8 **)(v3[25] + 8);
          if (v16 == 5)
          {
            result = sub_100027280((uint64_t)__src + 8, v3[1]);
            if ((_DWORD)result)
              return result;
            v16 = **(unsigned __int8 **)(v3[25] + 8);
          }
          if (v10 == v16 && BYTE9(__src[8]) == BYTE9(__src[0]))
          {
            v17 = (unsigned __int8 *)sub_10003C6F8((unsigned __int8 *)&__src[8] + 8);
            v3[4] = (unint64_t)v17;
            if (!v17)
            {
              if (!dword_10008BA20)
                return 0xFFFFFFFFLL;
              v39 = ne_log_obj(0);
              if (!os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
                return 0xFFFFFFFFLL;
LABEL_113:
              sub_10005BA1C();
              return 0xFFFFFFFFLL;
            }
            result = (uint64_t)sub_10003C6F8((unsigned __int8 *)__src + 8);
            v3[5] = result;
            if (!result)
            {
              if (!dword_10008BA20)
                return 0xFFFFFFFFLL;
              v18 = ne_log_obj(0);
              if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
                return 0xFFFFFFFFLL;
              goto LABEL_113;
            }
          }
LABEL_63:
          if (dword_10008BA20)
          {
            v20 = ne_log_obj(result);
            v21 = os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG);
            if (v21)
              sub_10005BBC8((uint64_t)__src);
            if (dword_10008BA20)
            {
              v22 = ne_log_obj(v21);
              if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
                sub_10005BB44((uint64_t)__src);
            }
          }
          if (!WORD5(__src[16]))
            WORD5(__src[16]) = 255;
          v23 = sub_100034760((unsigned __int8 *)__src, v3);
          v24 = v23;
          if (v23)
          {
            if (*(_DWORD *)(v23 + 292) != 5)
            {
              v28 = 1;
              goto LABEL_85;
            }
            if (*(_DWORD *)(*(_QWORD *)(v3[32] + 64) + 164))
            {
              if (!dword_10008BA20)
                goto LABEL_82;
              v25 = ne_log_obj(v23);
              if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
                goto LABEL_82;
              *(_DWORD *)buf = 136315138;
              *(_QWORD *)&buf[4] = sub_1000352C0((unsigned __int8 *)__src);
              v26 = "Update the generated policy : %s\n";
LABEL_81:
              _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, v26, buf, 0xCu);
LABEL_82:
              v27 = (unsigned __int8 *)malloc_type_malloc(0x110uLL, 0x1000040DDC4BC7FuLL);
              v3[17] = (unint64_t)v27;
              if (!v27)
              {
                if (dword_10008BA20)
                {
                  v36 = ne_log_obj(0);
                  if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
                    sub_10005BA1C();
                }
                return 0xFFFFFFFFLL;
              }
              memcpy(v27, __src, 0x110uLL);
              v28 = 0;
LABEL_85:
              LOBYTE(__src[0]) = 2;
              v46 = *(_OWORD *)((char *)&__src[4] + 8);
              v47 = *(_OWORD *)((char *)&__src[5] + 8);
              v48 = *(_OWORD *)((char *)&__src[6] + 8);
              v49 = *(_OWORD *)((char *)&__src[7] + 8);
              *(_OWORD *)buf = *(_OWORD *)((char *)__src + 8);
              v43 = *(_OWORD *)((char *)&__src[1] + 8);
              v44 = *(_OWORD *)((char *)&__src[2] + 8);
              v45 = *(_OWORD *)((char *)&__src[3] + 8);
              *(_OWORD *)((char *)&__src[3] + 8) = *(_OWORD *)((char *)&__src[11] + 8);
              *(_OWORD *)((char *)&__src[2] + 8) = *(_OWORD *)((char *)&__src[10] + 8);
              *(_OWORD *)((char *)&__src[1] + 8) = *(_OWORD *)((char *)&__src[9] + 8);
              *(_OWORD *)((char *)&__src[7] + 8) = *(_OWORD *)((char *)&__src[15] + 8);
              *(_OWORD *)((char *)&__src[6] + 8) = *(_OWORD *)((char *)&__src[14] + 8);
              *(_OWORD *)((char *)&__src[5] + 8) = *(_OWORD *)((char *)&__src[13] + 8);
              *(_OWORD *)((char *)&__src[4] + 8) = *(_OWORD *)((char *)&__src[12] + 8);
              *(_OWORD *)((char *)__src + 8) = *(_OWORD *)((char *)&__src[8] + 8);
              *(_OWORD *)((char *)&__src[11] + 8) = v45;
              *(_OWORD *)((char *)&__src[10] + 8) = v44;
              *(_OWORD *)((char *)&__src[9] + 8) = v43;
              *(_OWORD *)((char *)&__src[8] + 8) = *(_OWORD *)buf;
              *(_OWORD *)((char *)&__src[15] + 8) = v49;
              *(_OWORD *)((char *)&__src[14] + 8) = v48;
              *(_OWORD *)((char *)&__src[13] + 8) = v47;
              *(_OWORD *)((char *)&__src[12] + 8) = v46;
              v29 = BYTE8(__src[16]);
              BYTE8(__src[16]) = BYTE9(__src[16]);
              BYTE9(__src[16]) = v29;
              v30 = sub_100034760((unsigned __int8 *)__src, v3);
              v31 = v30;
              if (v30)
              {
                if (!*((_DWORD *)v3 + 13))
                  *((_DWORD *)v3 + 13) = *(_DWORD *)(v30 + 288);
              }
              else
              {
                if (!dword_10008BA20)
                  goto LABEL_96;
                v33 = ne_log_obj(0);
                v30 = os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT);
                if ((_DWORD)v30)
                {
                  v40 = 136315138;
                  v41 = sub_1000352C0((unsigned __int8 *)__src);
                  _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "no outbound policy found: %s\n", (uint8_t *)&v40, 0xCu);
                }
              }
              if (dword_10008BA20)
              {
                v34 = ne_log_obj(v30);
                v30 = os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG);
                if ((_DWORD)v30)
                {
                  sub_10005BADC((unsigned __int8 *)__src);
                  if (v28)
                  {
LABEL_97:
                    if (*(_DWORD *)(v24 + 292) == 2)
                    {
                      v35 = sub_1000376F0((uint64_t)v3, v24, v31);
                      if ((v35 & 0x80000000) == 0)
                        return 0;
                      if (dword_10008BA20)
                      {
                        v38 = ne_log_obj(v35);
                        if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
                          sub_10005BA48();
                      }
                    }
                    else if (dword_10008BA20)
                    {
                      v37 = ne_log_obj(v30);
                      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
                        sub_10005BA74((unsigned __int8 *)__src);
                    }
                    return 0xFFFFFFFFLL;
                  }
                  return 4294967294;
                }
              }
LABEL_96:
              if (v28)
                goto LABEL_97;
              return 4294967294;
            }
          }
          else if (*(_DWORD *)(*(_QWORD *)(v3[32] + 64) + 164))
          {
            if (!dword_10008BA20)
              goto LABEL_82;
            v25 = ne_log_obj(0);
            if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
              goto LABEL_82;
            *(_DWORD *)buf = 136315138;
            *(_QWORD *)&buf[4] = sub_1000352C0((unsigned __int8 *)__src);
            v26 = "no policy found, try to generate the policy : %s\n";
            goto LABEL_81;
          }
          if (dword_10008BA20)
          {
            v32 = ne_log_obj(v23);
            if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
              sub_10005B9B4((unsigned __int8 *)__src);
          }
          return 0xFFFFFFFFLL;
        }
      }
LABEL_55:
      if (dword_10008BA20)
      {
        v19 = ne_log_obj(v13);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
          sub_10005BC4C();
      }
      result = __memcpy_chk((char *)__src + 8, v3[1], *(unsigned __int8 *)v3[1], 264);
      if (BYTE9(__src[0]) == 30)
      {
        BYTE8(__src[16]) = 0x80;
      }
      else if (BYTE9(__src[0]) == 2)
      {
        BYTE8(__src[16]) = 32;
        WORD5(__src[0]) = 0;
      }
      else
      {
        BYTE8(__src[16]) = 0;
      }
      goto LABEL_63;
    }
  }
  else if (!v4)
  {
    goto LABEL_3;
  }
  if (dword_10008BA20)
  {
    v11 = ne_log_obj(a1);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      sub_10005BD54();
  }
  return 18;
}

uint64_t *sub_1000210EC(uint64_t a1, const sockaddr *a2)
{
  return sub_10003C570(a2);
}

void sub_10002113C(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_debug_impl(a1, v9, OS_LOG_TYPE_DEBUG, a4, &a9, 0x18u);
}

char *sub_100021160(unsigned __int8 *a1)
{
  return sub_1000352C0(a1);
}

void sub_100021168(uint64_t a1)
{
  NSObject *v1;
  int v2;
  ssize_t v3;
  int *v4;
  NSObject *v5;
  ssize_t v6;
  NSObject *v7;
  BOOL v8;
  uint64_t v9;
  unsigned int v10;
  NSObject *v11;
  ssize_t v12;
  NSObject *v13;
  NSObject *v14;
  ssize_t v15;
  NSObject *v16;
  unint64_t *v17;
  unint64_t *v18;
  ssize_t v19;
  int *v20;
  NSObject *v21;
  NSObject *v22;
  ssize_t v23;
  NSObject *v24;
  NSObject *v25;
  size_t v26;
  unint64_t *v27;
  unint64_t *v28;
  void *v29;
  NSObject *v30;
  uint64_t v31;
  NSObject *v32;
  _BOOL8 v33;
  uint64_t *v34;
  NSObject *v35;
  uint64_t *v36;
  NSObject *v37;
  unint64_t *v38;
  NSObject *v39;
  NSObject *v40;
  NSObject *v41;
  char *v42;
  unsigned int v43;
  socklen_t v44;
  uint8_t buf[4];
  size_t v46;
  __int16 v47;
  char *v48;
  sockaddr v49[8];
  sockaddr v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  _DWORD v58[16];
  _OWORD v59[2];

  memset(v59, 0, 28);
  memset(v58, 0, sizeof(v58));
  v56 = 0u;
  v57 = 0u;
  v54 = 0u;
  v55 = 0u;
  v52 = 0u;
  v53 = 0u;
  v50 = (sockaddr)0;
  v51 = 0u;
  memset(v49, 0, sizeof(v49));
  v44 = 128;
  v43 = 128;
  if (xmmword_10008C6E0 == 0)
  {
    v2 = a1;
    while (1)
    {
      v3 = sub_10003BAE4(v2, (uint64_t)v58, 0x40uLL, 2, &v50, &v44, (uint64_t)v49, &v43);
      if ((v3 & 0x80000000) == 0)
        break;
      v4 = __error();
      if (*v4 != 4)
      {
        if (dword_10008BA20)
        {
          v5 = ne_log_obj(v4);
          if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
          {
LABEL_10:
            sub_10005BDAC();
            return;
          }
        }
        return;
      }
    }
    if ((_DWORD)v3 == 1 && LOBYTE(v58[0]) == 255)
    {
      v6 = recvfrom(v2, v58, 1uLL, 0, &v50, &v44);
      if (v6 != 1)
      {
        if (dword_10008BA20)
        {
          v7 = ne_log_obj(v6);
          if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
            sub_10005BE18();
        }
      }
    }
    else
    {
      if (v58[1])
        v8 = v58[0] == 0;
      else
        v8 = 0;
      if (v8)
        v9 = 4;
      else
        v9 = 0;
      v59[0] = *(_OWORD *)((unint64_t)v58 | v9);
      *(_OWORD *)((char *)v59 + 12) = *(_OWORD *)(((unint64_t)v58 | v9) + 0xC);
      if (v3 >= 0x1C && (v10 = bswap32(DWORD2(v59[1])), v10 > 0x1B))
      {
        if (v10 < 0x10000)
        {
          v17 = sub_10003F1F8(v10 + v9);
          if (v17)
          {
            v18 = v17;
            while (1)
            {
              v19 = sub_10003BAE4(v2, v18[1], *v18, 0, &v50, &v44, (uint64_t)v49, &v43);
              if ((v19 & 0x80000000) == 0)
                break;
              v20 = __error();
              if (*v20 != 4)
              {
                if (dword_10008BA20)
                {
                  v21 = ne_log_obj(v20);
                  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
                    sub_10005BDAC();
                }
LABEL_77:
                v38 = v18;
                goto LABEL_78;
              }
            }
            if ((int)v19 < (int)v9)
            {
              if (dword_10008BA20)
              {
                v25 = ne_log_obj(v19);
                if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
                  sub_10005BF98();
              }
              goto LABEL_77;
            }
            v26 = v19 - v9;
            v27 = sub_10003F1F8(v26);
            if (!v27)
            {
              if (dword_10008BA20)
              {
                v37 = ne_log_obj(0);
                if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
                  sub_10005C00C();
              }
              goto LABEL_77;
            }
            v28 = v27;
            v29 = memcpy((void *)v27[1], (const void *)(v18[1] + v9), *v27);
            if (v26 == *v28)
            {
              if (dword_10008BA20)
              {
                v30 = ne_log_obj(v29);
                v29 = (void *)os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG);
                if ((_DWORD)v29)
                {
                  v42 = sub_10003CB18("from %s to %s", &v50, v49);
                  *(_DWORD *)buf = 134218242;
                  v46 = v26;
                  v47 = 2080;
                  v48 = v42;
                  _os_log_debug_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEBUG, "%zd bytes message received %s\n", buf, 0x16u);
                }
              }
              if (v50.sa_family == 30 || v50.sa_family == 2)
              {
                if (*(_WORD *)v50.sa_data)
                {
                  v31 = sub_10000978C(&v50, (uint64_t)v49, (uint64_t)v28);
                  if ((_DWORD)v31)
                  {
                    if (dword_10008BA20)
                    {
                      v32 = ne_log_obj(v31);
                      v33 = os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT);
                      if (v33)
                      {
                        v34 = sub_10003C570(&v50);
                        *(_DWORD *)buf = 136315138;
                        v46 = (size_t)v34;
                        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "Received retransmitted packet from %s.\n", buf, 0xCu);
                      }
                      if (dword_10008BA20)
                      {
                        v35 = ne_log_obj(v33);
                        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
                        {
                          v36 = sub_10003C570(&v50);
                          *(_DWORD *)buf = 136315138;
                          v46 = (size_t)v36;
                          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "the packet is retransmitted by %s.\n", buf, 0xCu);
                        }
                      }
                    }
                  }
                  else
                  {
                    sub_100021828(v28, &v50, &v49[0].sa_len);
                  }
                }
                else if (dword_10008BA20)
                {
                  v41 = ne_log_obj(v29);
                  if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
                    sub_10005C0DC();
                }
              }
              else if (dword_10008BA20)
              {
                v40 = ne_log_obj(v29);
                if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
                  sub_10005C078();
              }
            }
            else if (dword_10008BA20)
            {
              v39 = ne_log_obj(v29);
              if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
                sub_10005C108();
            }
            sub_10003F318(v18);
            v38 = v28;
LABEL_78:
            sub_10003F318(v38);
          }
          else
          {
            if (dword_10008BA20)
            {
              v22 = ne_log_obj(0);
              if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
                sub_10005BF24();
            }
            v23 = recvfrom(v2, v59, 0x1CuLL, 0, &v50, &v44);
            if (v23 < 0)
            {
              if (dword_10008BA20)
              {
                v24 = ne_log_obj(v23);
                if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
                  goto LABEL_10;
              }
            }
          }
        }
        else
        {
          if (dword_10008BA20)
          {
            v14 = ne_log_obj(v3);
            if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
              sub_10005BEF8();
          }
          v15 = recvfrom(v2, v59, 0x1CuLL, 0, &v50, &v44);
          if (v15 < 0)
          {
            if (dword_10008BA20)
            {
              v16 = ne_log_obj(v15);
              if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
                goto LABEL_10;
            }
          }
        }
      }
      else
      {
        if (dword_10008BA20)
        {
          v11 = ne_log_obj(v3);
          if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
            sub_10005BE84();
        }
        v12 = recvfrom(v2, v59, 0x1CuLL, 0, &v50, &v44);
        if (v12 < 0)
        {
          if (dword_10008BA20)
          {
            v13 = ne_log_obj(v12);
            if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
              sub_10005BDAC();
          }
        }
      }
    }
  }
  else if (dword_10008BA20)
  {
    v1 = ne_log_obj(a1);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG))
      sub_10005BD80();
  }
}

void sub_100021828(_QWORD *a1, sockaddr *a2, unsigned __int8 *a3)
{
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  char *v6;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  void *v15;
  NSObject *v16;
  void *v17;
  NSObject *v18;
  NSObject *v19;
  char *v20;
  uint64_t *v21;
  char *v22;
  uint64_t *v23;
  char *v24;
  char *v25;
  int v26;
  unsigned __int8 *v27;
  NSObject *v28;
  NSObject *v29;
  NSObject *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  NSObject *v37;
  uint64_t v38;
  NSObject *v39;
  NSObject *v40;
  NSObject *v41;
  int v42;
  uint64_t *v43;
  int v44;
  uint64_t v45;
  NSObject *v46;
  uint64_t v47;
  uint64_t v48;
  NSObject *v49;
  uint64_t *v50;
  NSObject *v51;
  const char *v52;
  NSObject *v53;
  NSObject *v54;
  uint64_t v55;
  NSObject *v56;
  NSObject *v57;
  uint64_t v58;
  char v59;
  uint64_t v60;
  NSObject *v61;
  NSObject *v62;
  NSObject *v63;
  NSObject *log;
  uint8_t buf[4];
  _BYTE v66[24];

  v3 = a1[1];
  if (*(_QWORD *)v3 == qword_10008B840)
  {
    if (dword_10008BA20)
    {
      v29 = ne_log_obj(a1);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        sub_10005C184();
    }
    return;
  }
  v4 = *(unsigned __int8 *)(v3 + 17);
  if ((v4 & 0xF0) != 0x10)
  {
    if (dword_10008BA20)
    {
      v30 = ne_log_obj(a1);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        sub_10005C590(v4, v30, v31, v32, v33, v34, v35, v36);
    }
    return;
  }
  if ((_DWORD)v4 != 16)
    return;
  v6 = (char *)(v3 + 19);
  v5 = *(unsigned __int8 *)(v3 + 19);
  if (v5 >= 8)
  {
    if (dword_10008BA20)
    {
      v37 = ne_log_obj(a1);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
        sub_10005C52C();
    }
    return;
  }
  if ((v5 & 2) != 0 && !*(_DWORD *)(v3 + 20))
  {
    v38 = sub_10001AC10(a1[1], &a2->sa_len, a3, 8u, 0);
    if (dword_10008BA20)
    {
      v39 = ne_log_obj(v38);
      if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
        sub_10005C500();
    }
    return;
  }
  v10 = sub_10004ABA4((uint64_t)a3, (uint64_t)a2, 0, (_QWORD *)v3);
  if (!v10)
  {
    v10 = sub_10004ABA4((uint64_t)a3, (uint64_t)a2, 1, 0);
    if (!v10)
    {
      if (dword_10008BA20)
      {
        v11 = ne_log_obj(0);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "failed to allocate or find ike session.\n", buf, 2u);
        }
      }
      sub_10003B334();
    }
  }
  v12 = sub_100007EB0(v10, (_QWORD *)v3);
  v13 = v12;
  if (v12)
  {
    if (*(_QWORD *)(v3 + 8) == qword_10008B840 && !*(_DWORD *)(v12 + 20))
    {
      if (dword_10008BA20)
      {
        v51 = ne_log_obj(v12);
        if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          v52 = "Malformed cookie received or the initiator's cookies collide.\n";
LABEL_93:
          _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, v52, buf, 2u);
        }
      }
      return;
    }
    if ((*(_DWORD *)(v12 + 96) & 9) == 1)
    {
      v14 = (_QWORD *)(v12 + 48);
      if (sub_10003B5A0(*(_QWORD *)(v12 + 48), (unint64_t)a2)
        || sub_10003B5A0(*(_QWORD *)(v13 + 56), (unint64_t)a3))
      {
        free(*(void **)(v13 + 48));
        free(*(void **)(v13 + 56));
        *v14 = 0;
        *(_QWORD *)(v13 + 56) = 0;
        v15 = sub_10003C6F8(&a2->sa_len);
        *(_QWORD *)(v13 + 48) = v15;
        if (!v15)
        {
          if (dword_10008BA20)
          {
            v16 = ne_log_obj(0);
            if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
              sub_10005C4D4();
          }
          sub_10003B334();
        }
        v17 = sub_10003C6F8(a3);
        *(_QWORD *)(v13 + 56) = v17;
        if (!v17)
        {
          if (dword_10008BA20)
          {
            v18 = ne_log_obj(0);
            if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
              sub_10005C4D4();
          }
          sub_10003B334();
        }
        *(_DWORD *)(v13 + 96) |= 0x28u;
        if (dword_10008BA20)
        {
          v19 = ne_log_obj(v17);
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            v20 = sub_10003CB18("%s<->%s", *(const sockaddr **)(v13 + 48), *(sockaddr **)(v13 + 56));
            *(_DWORD *)buf = 136315138;
            *(_QWORD *)v66 = v20;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "NAT-T: ports changed to: %s\n", buf, 0xCu);
          }
        }
      }
    }
    if (!sub_10003B5A0(*(_QWORD *)(v13 + 48), (unint64_t)a2))
      goto LABEL_39;
    v21 = sub_10003C570(*(const sockaddr **)(v13 + 48));
    v22 = strdup((const char *)v21);
    v23 = sub_10003C570(a2);
    v24 = strdup((const char *)v23);
    if (v22)
    {
      v25 = v24;
      if (v24)
      {
        if (dword_10008BA20)
        {
          log = ne_log_obj(v24);
          if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315394;
            *(_QWORD *)v66 = v22;
            *(_WORD *)&v66[8] = 2080;
            *(_QWORD *)&v66[10] = v25;
            _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, "Remote address mismatched. db=%s, act=%s\n", buf, 0x16u);
          }
        }
        free(v22);
        free(v25);
LABEL_39:
        sub_10001C7DC(v13, (uint64_t)"IKE packet received from peer");
        goto LABEL_40;
      }
      if (dword_10008BA20)
      {
        v63 = ne_log_obj(0);
        if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
          goto LABEL_131;
      }
    }
    else if (dword_10008BA20)
    {
      v62 = ne_log_obj(v24);
      if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
LABEL_131:
        sub_10005C4A8();
    }
    exit(1);
  }
LABEL_40:
  v27 = (unsigned __int8 *)(v3 + 18);
  v26 = *(unsigned __int8 *)(v3 + 18);
  switch(*(_BYTE *)(v3 + 18))
  {
    case 2:
    case 4:
      if (*(_DWORD *)(v3 + 20))
      {
        if (dword_10008BA20)
        {
          v28 = ne_log_obj(v12);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
            sub_10005C2BC();
        }
        return;
      }
      if (v13)
        goto LABEL_82;
      v12 = sub_100007F3C(v10, (_QWORD *)v3);
      if (v12)
      {
        v13 = v12;
        v26 = *v27;
LABEL_82:
        if (*(unsigned __int8 *)(v13 + 81) == v26)
        {
          if (*(unsigned __int8 *)(v3 + 16) == 132)
            goto LABEL_101;
          sub_100003834(v13, a1);
        }
        else if (dword_10008BA20)
        {
          v54 = ne_log_obj(v12);
          if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
            sub_10005C220((unsigned __int8 *)(v13 + 81), (unsigned __int8 *)(v3 + 18), v54);
        }
      }
      else if (*(_QWORD *)(v3 + 8) == qword_10008B840)
      {
        sub_10002759C(v10, (uint64_t)a1, &a2->sa_len, a3, *v27);
      }
      else if (dword_10008BA20)
      {
        v51 = ne_log_obj(0);
        if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          v52 = "Malformed cookie received or the spi expired.\n";
          goto LABEL_93;
        }
      }
      return;
    case 3:
      goto LABEL_62;
    case 5:
      goto LABEL_56;
    case 6:
      if (v13)
      {
        if ((*(_BYTE *)(v13 + 17) & 0x20) != 0)
        {
          if (*(unsigned __int8 *)(v3 + 16) == 132)
            goto LABEL_101;
          sub_1000421F8(v13, a1);
        }
        else if (dword_10008BA20)
        {
          v41 = ne_log_obj(v12);
          if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
          {
            v42 = *v27;
            v43 = sub_10003C570(a2);
            sub_100023E84(v13, *(_DWORD *)(v13 + 84));
            *(_DWORD *)buf = 67109634;
            *(_DWORD *)v66 = v42;
            *(_WORD *)&v66[4] = 2080;
            *(_QWORD *)&v66[6] = v43;
            *(_WORD *)&v66[14] = 2080;
            *(_QWORD *)&v66[16] = &xmmword_100088748;
            _os_log_error_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "mode config %d from %s, but ISAKMP-SA %s isn't established.\n", buf, 0x1Cu);
          }
        }
      }
      else if (dword_10008BA20)
      {
        v53 = ne_log_obj(v12);
        if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
          sub_10005C438(v3 + 18, a2, v53);
      }
      return;
    default:
      if (v26 == 32)
      {
        v44 = *(_DWORD *)(v3 + 20);
        if (v13)
        {
          v45 = *(_QWORD *)(v13 + 408);
          if (v45)
          {
            v12 = *(_QWORD *)(v45 + 1176);
            if (v12)
            {
              sub_10002DA18((_QWORD *)v12);
              *(_QWORD *)(*(_QWORD *)(v13 + 408) + 1176) = 0;
            }
          }
          if (*(unsigned __int8 *)(v3 + 16) == 132)
          {
LABEL_101:
            sub_100027948(v13, a1, a2, (uint64_t)a3);
            return;
          }
          if ((*(_BYTE *)(v13 + 17) & 0x20) != 0)
          {
            v58 = sub_100008AA0(v13, v44);
            if (v58)
            {
              v59 = *v6;
              if ((*v6 & 2) != 0)
                *(_BYTE *)(v58 + 105) |= 2u;
              if ((v59 & 1) == 0 || (v60 = *(_QWORD *)(v58 + 256)) != 0 && *(_QWORD *)(v60 + 72))
              {
                sub_100003C48(v58, a1);
              }
              else if (dword_10008BA20)
              {
                v61 = ne_log_obj(v58);
                if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
                  sub_10005C40C();
              }
            }
            else
            {
              sub_100027B10(v13, a1);
            }
          }
          else if (dword_10008BA20)
          {
            v46 = ne_log_obj(v12);
            if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
              sub_10005C398(v13);
          }
        }
        else
        {
          v55 = sub_10001AC10(v3, &a2->sa_len, a3, 4u, 0);
          if (dword_10008BA20)
          {
            v56 = ne_log_obj(v55);
            if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
              sub_10005C314((unsigned int *)(v3 + 20), v3);
          }
        }
      }
      else if (v26 == 34)
      {
LABEL_56:
        if (v13)
          goto LABEL_57;
        v47 = sub_100007F3C(v10, (_QWORD *)v3);
        if (v47)
        {
          v13 = v47;
          v48 = sub_10003B5A0(*(_QWORD *)(v47 + 48), (unint64_t)a2);
          if ((_DWORD)v48)
          {
            if (dword_10008BA20)
            {
              v49 = ne_log_obj(v48);
              if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
              {
                v50 = sub_10003C570(*(const sockaddr **)(v13 + 48));
                *(_DWORD *)buf = 136315138;
                *(_QWORD *)v66 = v50;
                _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "Remote address mismatched. db=%s\n", buf, 0xCu);
              }
            }
          }
LABEL_57:
          if (*(unsigned __int8 *)(v3 + 16) != 132)
          {
            sub_100018ED4(v13, a1);
            return;
          }
          goto LABEL_101;
        }
        if (dword_10008BA20)
        {
          v57 = ne_log_obj(0);
          if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
            sub_10005C2E8();
        }
      }
      else
      {
LABEL_62:
        if (dword_10008BA20)
        {
          v40 = ne_log_obj(v12);
          if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
            sub_10005C1B0(v3 + 18, a2, v40);
        }
      }
      break;
  }
}

uint64_t sub_1000221FC(uint64_t a1, uint64_t a2, unsigned __int8 *a3, unsigned __int8 *a4, int a5, _OWORD *a6)
{
  uint64_t v11;
  NSObject *v12;
  _BYTE *v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  NSObject *v17;
  int v19;
  int v20;
  uint64_t v21;
  NSObject *v22;
  uint64_t *v23;
  char *v24;
  char *v25;
  NSObject *v26;
  uint64_t *v27;
  int v28;
  uint64_t v29;
  NSObject *v30;
  _BOOL8 v31;
  char *v32;
  NSObject *v33;
  NSObject *v34;
  int v35;
  char *v36;
  __int16 v37;
  uint64_t *v38;

  v11 = a1;
  if (!a1)
  {
    v11 = sub_10004ABA4((uint64_t)a4, (uint64_t)a3, 1, 0);
    if (!v11)
    {
      if (dword_10008BA20)
      {
        v12 = ne_log_obj(0);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v35) = 0;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "failed to allocate or find ike session.\n", (uint8_t *)&v35, 2u);
        }
      }
      sub_10003B334();
    }
  }
  v13 = sub_1000083E8(16);
  if (!v13)
    return 0xFFFFFFFFLL;
  v14 = (uint64_t)v13;
  *((_QWORD *)v13 + 8) = a2;
  sub_100038B74(a2);
  *(_DWORD *)(v14 + 20) = 0;
  *(_DWORD *)(v14 + 24) = a5;
  if (a6)
    *(_OWORD *)(v14 + 28) = *a6;
  *(_BYTE *)(v14 + 80) = 16;
  *(_DWORD *)(v14 + 84) = 0;
  *(_BYTE *)(v14 + 82) = 0;
  *(_DWORD *)(v14 + 400) = 0;
  v15 = sub_1000448B4();
  *(_QWORD *)(v14 + 408) = v15;
  if (!v15)
    goto LABEL_16;
  *(_DWORD *)(v14 + 100) = *(_DWORD *)(a2 + 148) == 2;
  *(_QWORD *)(v14 + 104) = 0;
  *(_QWORD *)(v14 + 72) = 0;
  if ((sub_1000225F8(v14, a2, a3, a4) & 0x80000000) != 0)
    return 0xFFFFFFFFLL;
  v16 = sub_10004B29C(v11, v14);
  if ((_DWORD)v16)
  {
    if (dword_10008BA20)
    {
      v17 = ne_log_obj(v16);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v35) = 0;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Failed to link ph1 to session\n", (uint8_t *)&v35, 2u);
      }
    }
LABEL_16:
    sub_10000849C(v14);
    return 0xFFFFFFFFLL;
  }
  if (a5 == 3 && (*(_BYTE *)(v14 + 432) & 1) == 0)
  {
    *(_WORD *)(*(_QWORD *)(v14 + 440) + 264) |= 1u;
    ++*(_DWORD *)(*(_QWORD *)(v14 + 440) + 364);
    *(_BYTE *)(v14 + 432) |= 1u;
  }
  v19 = **(unsigned __int8 **)(a2 + 16);
  *(_BYTE *)(v14 + 81) = v19;
  if (v19 == 2)
  {
    v20 = 5184;
  }
  else
  {
    if (v19 != 4)
      return 0xFFFFFFFFLL;
    v20 = 5248;
  }
  sub_100003774((int *)(v14 + 16), v20);
  if (dword_10008BA20)
  {
    v22 = ne_log_obj(v21);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
      sub_10005C5F4();
  }
  v23 = sub_10003C570(*(const sockaddr **)(v14 + 56));
  v24 = strdup((const char *)v23);
  if (!v24)
  {
    if (dword_10008BA20)
    {
      v34 = ne_log_obj(0);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        sub_10005C4A8();
    }
    exit(1);
  }
  v25 = v24;
  if (dword_10008BA20)
  {
    v26 = ne_log_obj(v24);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      v27 = sub_10003C570(*(const sockaddr **)(v14 + 48));
      v35 = 136315394;
      v36 = v25;
      v37 = 2080;
      v38 = v27;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "initiate new phase 1 negotiation: %s<=>%s\n", (uint8_t *)&v35, 0x16u);
    }
    v28 = dword_10008BA20;
    free(v25);
    if (v28)
    {
      v30 = ne_log_obj(v29);
      v31 = os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT);
      if (v31)
      {
        v32 = sub_10003DAB8(*(unsigned __int8 *)(v14 + 81));
        v35 = 136315138;
        v36 = v32;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "begin %s mode.\n", (uint8_t *)&v35, 0xCu);
      }
      if (dword_10008BA20)
      {
        v33 = ne_log_obj(v31);
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v35) = 0;
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "IPSec Phase 1 started (Initiated by me).\n", (uint8_t *)&v35, 2u);
        }
      }
    }
  }
  else
  {
    free(v24);
  }
  if (sub_100003AE4(v14, 0))
  {
    sub_10004AACC(v14);
    return 0xFFFFFFFFLL;
  }
  sub_100048B0C(1, 0, v14, 0);
  return 0;
}

uint64_t sub_1000225F8(uint64_t a1, uint64_t a2, unsigned __int8 *a3, unsigned __int8 *a4)
{
  unsigned __int8 *v7;
  int v8;
  __int16 *v9;
  int v10;
  unsigned __int8 *v11;
  NSObject *v12;
  __int16 v13;
  unint64_t v14;
  int v15;
  uint64_t v16;
  NSObject *v17;
  uint64_t result;
  NSObject *v19;
  uint8_t v20[16];

  v7 = (unsigned __int8 *)sub_10003C6F8(a3);
  *(_QWORD *)(a1 + 48) = v7;
  if (!v7)
    goto LABEL_27;
  v8 = v7[1];
  if (v8 != 30 && v8 != 2)
  {
    if (!dword_10008BA20)
      goto LABEL_27;
    v12 = ne_log_obj(v7);
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      goto LABEL_27;
LABEL_26:
    sub_10005C620();
    goto LABEL_27;
  }
  v10 = *((unsigned __int16 *)v7 + 1);
  v9 = (__int16 *)(v7 + 2);
  if (v10)
  {
    if (a4)
    {
LABEL_6:
      v11 = (unsigned __int8 *)sub_10003C6F8(a4);
      goto LABEL_14;
    }
  }
  else
  {
    v13 = *(_WORD *)(*(_QWORD *)a2 + 2);
    if (!v13)
      v13 = -3071;
    *v9 = v13;
    if (a4)
      goto LABEL_6;
  }
  v11 = (unsigned __int8 *)sub_10003B74C(*(const sockaddr **)(a1 + 48));
LABEL_14:
  v14 = (unint64_t)v11;
  *(_QWORD *)(a1 + 56) = v11;
  if (!v11)
  {
LABEL_27:
    sub_10000849C(a1);
    return 0xFFFFFFFFLL;
  }
  v15 = v11[1];
  if (v15 != 30 && v15 != 2)
  {
    if (!dword_10008BA20)
      goto LABEL_27;
    v19 = ne_log_obj(v11);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      goto LABEL_27;
    goto LABEL_26;
  }
  v16 = *((unsigned __int16 *)v11 + 1);
  if (!*(_WORD *)(v14 + 2))
  {
    v16 = sub_1000078AC(v14);
    *(_WORD *)(v14 + 2) = v16;
  }
  if ((_DWORD)v16 != bswap32(*(unsigned __int16 *)(qword_10008B848 + 18)) >> 16)
    return 0;
  if (dword_10008BA20)
  {
    v17 = ne_log_obj(v16);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v20 = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Marking ports as changed\n", v20, 2u);
    }
  }
  result = 0;
  *(_DWORD *)(a1 + 96) |= 0x20u;
  return result;
}

uint64_t sub_1000227C4(uint64_t a1)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  NSObject *v8;
  unsigned int v9;
  unint64_t v10;
  unint64_t v11;
  BOOL v12;
  _BOOL4 v13;
  int v14;
  unsigned int v15;
  unint64_t v16;
  unint64_t v17;
  _BOOL4 v18;
  int v19;
  uint64_t v20;
  NSObject *v21;
  int v22;
  BOOL v24;
  uint64_t v27;
  NSObject *v28;
  uint64_t v29;
  NSObject *v30;
  NSObject *v32;
  _DWORD v33[2];

  v2 = *(_DWORD *)(*(_QWORD *)(a1 + 64) + 168);
  if (*(_DWORD *)(a1 + 20) == 1
    && (v3 = *(_QWORD *)(a1 + 56), *(_BYTE *)(v3 + 1) == 2)
    && (v4 = *(_QWORD *)(qword_10008B848 + 72)) != 0)
  {
    if (*(_DWORD *)(v3 + 4) == *(_DWORD *)(v4 + 16))
    {
      v5 = sub_10003F1F8(4uLL);
      if (v5)
      {
        v6 = v5;
        *(_DWORD *)v5[1] = *(_DWORD *)(v4 + 20);
        v7 = sub_10001B184(a1, 0x9E35u, (uint64_t)v5);
        if (dword_10008BA20)
        {
          v8 = ne_log_obj(v7);
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
          {
            v9 = bswap32(*(_DWORD *)(v4 + 20));
            v33[0] = 67109120;
            v33[1] = v9;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "sent redirect notification - address = %x.\n", (uint8_t *)v33, 8u);
          }
        }
        sub_10003F318(v6);
        if (*(_WORD *)(v4 + 24))
        {
          sub_10004B64C(a1);
          sub_100022B8C(a1);
        }
      }
      else if (dword_10008BA20)
      {
        v32 = ne_log_obj(0);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
          sub_10005C6D8();
      }
    }
  }
  else
  {
    time((time_t *)(a1 + 360));
    *(_DWORD *)(a1 + 112) = sub_10003A520(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 16), (uint64_t)sub_100022D68, a1);
    if (*(_DWORD *)(*(_QWORD *)(a1 + 64) + 280))
    {
      if (*(_DWORD *)(a1 + 20))
      {
        v10 = bswap64(*(_QWORD *)(a1 + 8));
        v11 = bswap64(*(_QWORD *)a1);
        v12 = v10 >= v11;
        v13 = v10 > v11;
        v14 = !v12;
        v15 = v13 - v14;
        if (!v15)
          v15 = -1;
      }
      else
      {
        v16 = bswap64(*(_QWORD *)a1);
        v17 = bswap64(*(_QWORD *)(a1 + 8));
        v12 = v16 >= v17;
        v18 = v16 > v17;
        v19 = !v12;
        v15 = v18 - v19;
        if (v15 <= 1)
          v15 = 1;
      }
      v20 = sub_10004A794((int)v15 > 0, *(_DWORD *)(*(_QWORD *)(a1 + 72) + 16));
      if ((_DWORD)v20)
      {
        *(_DWORD *)(a1 + 116) = sub_10003A520(v20, (uint64_t)sub_100022D6C, a1);
      }
      else if (dword_10008BA20)
      {
        v21 = ne_log_obj(v20);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          sub_10005C6AC();
      }
    }
    if ((*(_BYTE *)(a1 + 432) & 1) == 0 && (**(_BYTE **)(a1 + 408) & 1) != 0)
    {
      v22 = *(_DWORD *)(*(_QWORD *)(a1 + 72) + 48);
      if (!*(_QWORD *)(*(_QWORD *)(a1 + 64) + 272) || v22 != 65001)
      {
        v24 = (v22 - 65002) > 8 || ((1 << (v22 + 22)) & 0x151) == 0;
        if (!v24 || v22 == 64222)
        {
          sub_100045A84(a1);
          v2 = 0;
        }
      }
    }
    if (*(_DWORD *)(a1 + 368) && *(_DWORD *)(*(_QWORD *)(a1 + 64) + 216))
      sub_10001C3BC(a1, 0);
    if ((*(_BYTE *)(a1 + 432) & 1) == 0 && !dword_10008B858 && v2 != 0 && !sub_1000095F0(*(_QWORD *)(a1 + 48)))
    {
      sub_10001B184(a1, 0x6002u, 0);
      v27 = sub_100009634(*(unsigned __int8 **)(a1 + 48));
      if ((_DWORD)v27 == -1)
      {
        if (dword_10008BA20)
        {
          v28 = ne_log_obj(v27);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
            sub_10005C680();
        }
      }
    }
    sub_100022D74(a1);
    if (dword_10008BA20)
    {
      v30 = ne_log_obj(v29);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
        sub_10005C5F4();
    }
    sub_10004C6F4(*(_QWORD *)(a1 + 440), a1);
    sub_100048B0C(0, 0, a1, 0);
    sub_100048E70(1, a1);
  }
  return 0;
}

_QWORD *sub_100022B8C(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  char *v5;
  uint64_t *v6;
  char *v7;
  char *v8;
  NSObject *v9;
  uint64_t (*v10)();
  _QWORD *result;
  NSObject *v12;
  NSObject *v13;
  int v14;
  char *v15;
  __int16 v16;
  char *v17;
  __int16 v18;
  __int128 *v19;

  v2 = *(unsigned int *)(a1 + 112);
  if ((_DWORD)v2)
  {
    sub_10003A6F0(v2);
    *(_DWORD *)(a1 + 112) = 0;
  }
  v3 = *(unsigned int *)(a1 + 388);
  if ((_DWORD)v3)
  {
    sub_10003A6F0(v3);
    *(_DWORD *)(a1 + 388) = 0;
  }
  if ((*(_BYTE *)(a1 + 17) & 0x40) == 0)
  {
    v4 = sub_10003C570(*(const sockaddr **)(a1 + 56));
    v5 = strdup((const char *)v4);
    v6 = sub_10003C570(*(const sockaddr **)(a1 + 48));
    v7 = strdup((const char *)v6);
    if (v5)
    {
      v8 = v7;
      if (v7)
      {
        if (dword_10008BA20)
        {
          v9 = ne_log_obj(v7);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            sub_100023E84(a1, 0);
            v14 = 136315650;
            v15 = v5;
            v16 = 2080;
            v17 = v8;
            v18 = 2080;
            v19 = &xmmword_100088748;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "ISAKMP-SA expired %s-%s spi:%s\n", (uint8_t *)&v14, 0x20u);
          }
        }
        free(v5);
        free(v8);
        sub_100003774((int *)(a1 + 16), 17408);
        sub_10004B64C(a1);
        goto LABEL_12;
      }
      if (dword_10008BA20)
      {
        v13 = ne_log_obj(0);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
          goto LABEL_21;
      }
    }
    else if (dword_10008BA20)
    {
      v12 = ne_log_obj(v7);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
LABEL_21:
        sub_10005C4A8();
    }
    exit(1);
  }
LABEL_12:
  if (*(_QWORD *)(a1 + 448))
    v10 = sub_100022D68;
  else
    v10 = sub_100024B18;
  result = sub_10003A520(1, (uint64_t)v10, a1);
  *(_DWORD *)(a1 + 112) = (_DWORD)result;
  return result;
}

void sub_100022D6C(uint64_t a1)
{
  sub_100024B1C(a1, 0);
}

void sub_100022D74(uint64_t a1)
{
  uint64_t *v2;
  char *v3;
  uint64_t *v4;
  char *v5;
  char *v6;
  NSObject *v7;
  _BOOL8 v8;
  NSObject *v9;
  int v10;
  uint64_t v11;
  NSObject *v12;
  const char *v13;
  NSObject *v14;
  NSObject *v15;
  int v16;
  __int128 *v17;
  __int16 v18;
  char *v19;
  __int16 v20;
  __int128 *v21;

  v2 = sub_10003C570(*(const sockaddr **)(a1 + 56));
  v3 = strdup((const char *)v2);
  v4 = sub_10003C570(*(const sockaddr **)(a1 + 48));
  v5 = strdup((const char *)v4);
  if (!v3)
  {
    if (dword_10008BA20)
    {
      v14 = ne_log_obj(v5);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        goto LABEL_22;
    }
    goto LABEL_23;
  }
  v6 = v5;
  if (!v5)
  {
    if (dword_10008BA20)
    {
      v15 = ne_log_obj(0);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
LABEL_22:
        sub_10005C4A8();
    }
LABEL_23:
    exit(1);
  }
  if (!dword_10008BA20)
    goto LABEL_15;
  v7 = ne_log_obj(v5);
  v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
  if (v8)
  {
    sub_100023E84(a1, 0);
    v16 = 136315138;
    v17 = &xmmword_100088748;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "ISAKMP-SA established spi:%s\n", (uint8_t *)&v16, 0xCu);
  }
  if (dword_10008BA20)
  {
    v9 = ne_log_obj(v8);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      sub_100023E84(a1, 0);
      v16 = 136315650;
      v17 = (__int128 *)v3;
      v18 = 2080;
      v19 = v6;
      v20 = 2080;
      v21 = &xmmword_100088748;
      _os_log_debug_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "ISAKMP-SA established %s-%s spi:%s\n", (uint8_t *)&v16, 0x20u);
    }
    v10 = dword_10008BA20;
    free(v3);
    free(v6);
    if (v10)
    {
      v12 = ne_log_obj(v11);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        if (*(_DWORD *)(a1 + 20))
          v13 = "peer";
        else
          v13 = "me";
        v16 = 136315138;
        v17 = (__int128 *)v13;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "IPSec Phase 1 established (Initiated by %s).\n", (uint8_t *)&v16, 0xCu);
      }
    }
  }
  else
  {
LABEL_15:
    free(v3);
    free(v6);
  }
}

_QWORD *sub_100022FCC(uint64_t a1, unsigned __int8 *a2, int a3)
{
  unsigned __int8 v5;
  NSObject *v6;
  void *v7;
  _QWORD *v8;
  unint64_t v9;
  char v10;
  int v11;
  unint64_t v12;
  NSObject *v13;
  char *v14;
  unsigned int v15;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  NSObject *v23;
  _QWORD *v24;
  NSObject *v26;
  uint8_t buf[4];
  int v28;
  __int16 v29;
  char *v30;

  v5 = a1;
  if (dword_10008BA20)
  {
    v6 = ne_log_obj(a1);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      sub_10005C75C();
  }
  v7 = sub_10003F1F8(0x50uLL);
  if (!v7)
  {
    if (dword_10008BA20)
    {
      v21 = ne_log_obj(0);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        sub_1000565B0();
    }
    return 0;
  }
  v8 = v7;
  v9 = *((_QWORD *)v7 + 1);
  if (a3 < 1 || (v10 = v5) == 0)
  {
LABEL_25:
    *(_BYTE *)v9 = 0;
    *(_DWORD *)(v9 + 4) = 0;
    *(_QWORD *)(v9 + 8) = 0;
    if (dword_10008BA20)
    {
      v20 = ne_log_obj(v7);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
        sub_10005C730();
    }
    return v8;
  }
  v11 = v5;
  v12 = v9 + *(_QWORD *)v7 - 16;
  while (1)
  {
    if (a3 <= 4)
    {
      if (dword_10008BA20)
      {
        v22 = ne_log_obj(v7);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
          sub_10005C704();
      }
      goto LABEL_37;
    }
    if (dword_10008BA20)
    {
      v13 = ne_log_obj(v7);
      v7 = (void *)os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
      if ((_DWORD)v7)
      {
        v14 = sub_10003DBA0(v11);
        *(_DWORD *)buf = 67109378;
        v28 = v11;
        v29 = 2080;
        v30 = v14;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "seen nptype=%u(%s)\n", buf, 0x12u);
      }
    }
    *(_BYTE *)v9 = v10;
    v15 = bswap32(*((unsigned __int16 *)a2 + 1)) >> 16;
    *(_DWORD *)(v9 + 4) = v15;
    if (v15 < 4 || a3 < v15)
    {
      if (dword_10008BA20)
      {
        v23 = ne_log_obj(v7);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "isakmp_parsewoh invalid length of payload (2)\n", buf, 2u);
        }
      }
LABEL_37:
      v24 = v8;
      goto LABEL_38;
    }
    *(_QWORD *)(v9 + 8) = a2;
    v9 += 16;
    if (v12 <= v9)
      break;
LABEL_20:
    v11 = *a2;
    a2 += v15;
    a3 -= v15;
    v19 = a3 < 1 || v11 == 0;
    v10 = v11;
    if (v19)
      goto LABEL_25;
  }
  v17 = v8[1];
  v7 = sub_10003F270((void **)v8, 2 * *v8);
  if (v7)
  {
    v8 = v7;
    v18 = *((_QWORD *)v7 + 1);
    v12 = v18 + *(_QWORD *)v7 - 16;
    v9 = v18 + 16 * (int)((v9 - v17) >> 4);
    v15 = bswap32(*((unsigned __int16 *)a2 + 1)) >> 16;
    goto LABEL_20;
  }
  if (dword_10008BA20)
  {
    v26 = ne_log_obj(0);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "failed to realloc buffer.\n", buf, 2u);
    }
  }
  v24 = 0;
LABEL_38:
  sub_10003F318(v24);
  return 0;
}

_QWORD *sub_1000232C8(uint64_t a1)
{
  return sub_100022FCC(*(unsigned __int8 *)(*(_QWORD *)(a1 + 8) + 16), (unsigned __int8 *)(*(_QWORD *)(a1 + 8) + 28), *(_DWORD *)a1 - 28);
}

uint64_t sub_1000232E4()
{
  _QWORD *v0;

  sub_10000976C();
  v0 = sub_100009EA0();
  if ((sub_100023318((uint64_t)v0) & 0x80000000) == 0)
    return 0;
  sub_100023FD8();
  sub_100006ED4();
  return 0xFFFFFFFFLL;
}

uint64_t sub_100023318(uint64_t a1)
{
  uint64_t *v1;
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t *v6;
  int v7;
  BOOL v8;
  NSObject *v9;
  NSObject *v10;
  const char *v11;
  NSObject *v13;
  sockaddr *v14;
  uint64_t v15;
  uint64_t v16;
  NSObject *v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  NSObject *v25;
  _BOOL4 v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  NSObject *v36;
  int v37;
  NSObject *v38;
  NSObject *v39;
  NSObject *v40;
  uint64_t *v41;
  int v42;
  NSObject *v43;
  NSObject *v44;
  int *v45;
  char *v46;
  NSObject *v47;
  NSObject *v48;
  NSObject *v49;
  int *v50;
  int v51;
  NSObject *v52;
  _OWORD *v53;
  __int128 v54;
  uint64_t v55;
  NSObject *v56;
  uint64_t *v57;
  NSObject *v58;
  NSObject *v59;
  NSObject *v60;
  char *v61;
  uint64_t *v62;
  _BOOL8 v63;
  NSObject *v64;
  _BOOL8 v65;
  NSObject *v66;
  NSObject *v68;
  NSObject *v69;
  NSObject *v70;
  uint64_t *v71;
  _QWORD v72[5];
  int v73;
  _QWORD handler[4];
  int v75;
  uint8_t v76;
  _BYTE v77[11];
  int v78;
  _BYTE v79[16];
  uint8_t v80[4];
  uint64_t *v81;
  __int16 v82;
  int v83;
  uint8_t buf[48];
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  uint8_t v100[4];
  int v101;

  v78 = 1;
  v1 = *(uint64_t **)(qword_10008B848 + 120);
  if (v1)
  {
    v2 = 0;
    v3 = 0;
    v4 = 0;
    while (1)
    {
      v6 = v1 + 1;
      v5 = v1[1];
      if (!v5)
        goto LABEL_107;
      if (*((_DWORD *)v1 + 4) != -1)
      {
        ++v2;
        if (*((_DWORD *)v1 + 8))
          ++v4;
        goto LABEL_107;
      }
      v7 = *(unsigned __int8 *)(v5 + 1);
      if (v7 != 30)
        break;
      if (!*(_DWORD *)(v5 + 8)
        && !*(_DWORD *)(v5 + 12)
        && !*(_DWORD *)(v5 + 16)
        && !*(_DWORD *)(v5 + 20)
        && dword_10008BA20 != 0)
      {
        v13 = ne_log_obj(a1);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          v10 = v13;
          v11 = "listening to wildcard address, broadcast IKE packet may kill you\n";
LABEL_16:
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v11, buf, 2u);
        }
      }
LABEL_26:
      v14 = (sockaddr *)*v6;
      if (*(_BYTE *)(*v6 + 1) == 30 && v14->sa_data[6] == 255)
      {
        if (dword_10008BA20)
        {
          v25 = ne_log_obj(v14);
          v26 = os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT);
          v14 = (sockaddr *)*v6;
          if (v26)
          {
            v27 = sub_10003C570(v14);
            *(_DWORD *)buf = 136315138;
            *(_QWORD *)&buf[4] = v27;
            _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Ignoring multicast address %s\n", buf, 0xCu);
            v14 = (sockaddr *)*v6;
          }
        }
        free(v14);
        *v6 = 0;
      }
      else
      {
        v15 = socket(*(unsigned __int8 *)(*v6 + 1), 2, 0);
        *((_DWORD *)v1 + 4) = v15;
        if ((v15 & 0x80000000) != 0)
        {
          if (dword_10008BA20)
          {
            v24 = ne_log_obj(v15);
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
              sub_10005C800();
          }
          goto LABEL_105;
        }
        v16 = fcntl(v15, 4, 4);
        if ((_DWORD)v16 == -1 && dword_10008BA20 != 0)
        {
          v18 = ne_log_obj(v16);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
            sub_10005CAA4(&v76, v77, v18);
        }
        v19 = *(unsigned __int8 *)(*v6 + 1);
        if (v19 == 30)
        {
          *(_DWORD *)v80 = 0;
          *(_DWORD *)v80 = if_nametoindex((const char *)v1[5]);
          if (*(_DWORD *)v80)
          {
            v28 = setsockopt(*((_DWORD *)v1 + 4), 41, 125, v80, 4u);
            if ((v28 & 0x80000000) != 0)
            {
              if (dword_10008BA20)
              {
                v49 = ne_log_obj(v28);
                if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
                  sub_10005CA64();
              }
              goto LABEL_105;
            }
          }
          v29 = setsockopt(*((_DWORD *)v1 + 4), 41, 61, &v78, 4u);
          if ((v29 & 0x80000000) != 0)
          {
            if (dword_10008BA20)
            {
              v44 = ne_log_obj(v29);
              if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
              {
                v45 = __error();
                v46 = strerror(*v45);
                *(_DWORD *)buf = 67109378;
                *(_DWORD *)&buf[4] = 61;
                *(_WORD *)&buf[8] = 2080;
                *(_QWORD *)&buf[10] = v46;
                _os_log_error_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "setsockopt IPV6_RECVDSTADDR (%d):%s\n", buf, 0x12u);
              }
            }
            goto LABEL_105;
          }
        }
        else if (v19 == 2)
        {
          *(_DWORD *)buf = 0;
          *(_DWORD *)buf = if_nametoindex((const char *)v1[5]);
          if (*(_DWORD *)buf)
          {
            v20 = setsockopt(*((_DWORD *)v1 + 4), 0, 25, buf, 4u);
            if ((v20 & 0x80000000) != 0)
            {
              if (dword_10008BA20)
              {
                v48 = ne_log_obj(v20);
                if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
                  sub_10005CA24();
              }
              goto LABEL_105;
            }
          }
          v21 = setsockopt(*((_DWORD *)v1 + 4), 0, 7, &v78, 4u);
          if ((v21 & 0x80000000) != 0)
          {
            if (dword_10008BA20)
            {
              v22 = ne_log_obj(v21);
              if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
                sub_10005C9E4();
            }
            goto LABEL_105;
          }
        }
        v30 = *(unsigned __int8 *)(*v6 + 1);
        if ((_DWORD)v30 == 30)
        {
          v31 = setsockopt(*((_DWORD *)v1 + 4), 41, 42, &v78, 4u);
          if ((v31 & 0x80000000) != 0)
          {
            if (dword_10008BA20)
            {
              v69 = ne_log_obj(v31);
              if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
                sub_10005C840();
            }
            return 0xFFFFFFFFLL;
          }
          v30 = *(unsigned __int8 *)(*v6 + 1);
        }
        if ((sub_10003B918(*((unsigned int *)v1 + 4), v30) & 0x80000000) != 0)
          goto LABEL_105;
        v32 = setsockopt(*((_DWORD *)v1 + 4), 0xFFFF, 4, &v78, 4u);
        if ((v32 & 0x80000000) != 0)
        {
          if (dword_10008BA20)
          {
            v43 = ne_log_obj(v32);
            if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
              sub_10005C8AC();
          }
          goto LABEL_105;
        }
        v33 = setsockopt(*((_DWORD *)v1 + 4), 0xFFFF, 512, &v78, 4u);
        if ((v33 & 0x80000000) != 0)
        {
          if (dword_10008BA20)
          {
            v47 = ne_log_obj(v33);
            if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
              sub_10005C8EC();
          }
          goto LABEL_105;
        }
        if (sub_10003D25C(*v6) == 500)
        {
          v34 = setsockopt(*((_DWORD *)v1 + 4), 0xFFFF, 4134, &v78, 4u);
          if ((v34 & 0x80000000) != 0)
          {
            if (dword_10008BA20)
            {
              v58 = ne_log_obj(v34);
              if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
                sub_10005C92C();
            }
            goto LABEL_105;
          }
        }
        if ((bind(*((_DWORD *)v1 + 4), (const sockaddr *)v1[1], *(unsigned __int8 *)v1[1]) & 0x80000000) == 0)
        {
          if (*((_DWORD *)v1 + 8))
            ++v4;
          v35 = *((_DWORD *)v1 + 4);
          v36 = v1[3];
          v37 = v35;
          if (v36)
          {
            dispatch_source_cancel(v36);
            v1[3] = 0;
            v37 = *((_DWORD *)v1 + 4);
          }
          v38 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, v37, 0, (dispatch_queue_t)&_dispatch_main_q);
          v1[3] = (uint64_t)v38;
          if (!v38)
          {
            if (dword_10008BA20)
            {
              v70 = ne_log_obj(0);
              if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR))
                sub_10005C9B8();
            }
            return 0xFFFFFFFFLL;
          }
          ++v2;
          handler[0] = _NSConcreteStackBlock;
          handler[1] = 0x40000000;
          handler[2] = sub_100023F68;
          handler[3] = &unk_100084F38;
          v75 = v35;
          dispatch_source_set_event_handler(v38, handler);
          v39 = v1[3];
          v72[0] = _NSConcreteStackBlock;
          v72[1] = 0x40000000;
          v72[2] = sub_100023F70;
          v72[3] = &unk_100084F58;
          v73 = v35;
          v72[4] = v39;
          dispatch_source_set_cancel_handler(v39, v72);
          dispatch_resume((dispatch_object_t)v1[3]);
          if (dword_10008BA20)
          {
            v40 = ne_log_obj(a1);
            a1 = os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT);
            if ((_DWORD)a1)
            {
              v41 = sub_10003C570((const sockaddr *)v1[1]);
              v42 = *((_DWORD *)v1 + 4);
              *(_DWORD *)buf = 136315394;
              *(_QWORD *)&buf[4] = v41;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v42;
              _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "%s used as isakmp port (fd=%d)\n", buf, 0x12u);
            }
          }
          goto LABEL_107;
        }
        v50 = __error();
        v51 = *v50;
        if (dword_10008BA20)
        {
          v52 = ne_log_obj(v50);
          if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
          {
            v71 = sub_10003C570((const sockaddr *)*v6);
            v61 = strerror(v51);
            *(_DWORD *)buf = 136315394;
            *(_QWORD *)&buf[4] = v71;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = v61;
            _os_log_error_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_ERROR, "failed to bind to address %s (%s).\n", buf, 0x16u);
          }
        }
        if (v51 != 49 || *(_BYTE *)(*v6 + 1) != 30)
          goto LABEL_104;
        v98 = 0u;
        v99 = 0u;
        v96 = 0u;
        v97 = 0u;
        v94 = 0u;
        v95 = 0u;
        v92 = 0u;
        v93 = 0u;
        v90 = 0u;
        v91 = 0u;
        v88 = 0u;
        v89 = 0u;
        v86 = 0u;
        v87 = 0u;
        v85 = 0u;
        memset(buf, 0, sizeof(buf));
        __strlcpy_chk(buf, v1[5], 16, 16);
        v53 = (_OWORD *)v1[1];
        v54 = *(_OWORD *)((char *)v53 + 12);
        *(_OWORD *)&buf[16] = *v53;
        *(_OWORD *)&buf[28] = v54;
        v55 = ioctl(*((_DWORD *)v1 + 4), 0xC1206949uLL, buf);
        if ((v55 & 0x80000000) != 0)
        {
          if (dword_10008BA20)
          {
            v59 = ne_log_obj(v55);
            if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
              sub_10005C96C((uint64_t)v79, (const sockaddr **)v1 + 1);
          }
LABEL_104:
          close(*((_DWORD *)v1 + 4));
          *((_DWORD *)v1 + 4) = -1;
LABEL_105:
          free((void *)v1[1]);
          v1[1] = 0;
          *((_DWORD *)v1 + 4) = -1;
          if (!*(_DWORD *)(qword_10008B848 + 112) && *(_DWORD *)(qword_10008B848 + 308))
            return 0xFFFFFFFFLL;
          goto LABEL_107;
        }
        if ((buf[16] & 0x1D) != 0)
        {
          if (dword_10008BA20)
          {
            v56 = ne_log_obj(v55);
            if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
            {
              v57 = sub_10003C570((const sockaddr *)*v6);
              *(_DWORD *)v80 = 136315394;
              v81 = v57;
              v82 = 1024;
              v83 = *(_DWORD *)&buf[16];
              _os_log_error_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_ERROR, "failed to bind to address %s: because of interface address error, flags %x.\n", v80, 0x12u);
            }
          }
          goto LABEL_104;
        }
        if (dword_10008BA20)
        {
          v60 = ne_log_obj(v55);
          if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
          {
            v62 = sub_10003C570((const sockaddr *)*v6);
            *(_DWORD *)v80 = 136315394;
            v81 = v62;
            v82 = 1024;
            v83 = *(_DWORD *)&buf[16];
            _os_log_error_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_ERROR, "failed to bind to address %s: because interface address is/was not ready (flags %x).\n", v80, 0x12u);
          }
        }
        a1 = close(*((_DWORD *)v1 + 4));
        *((_DWORD *)v1 + 4) = -1;
        v3 = 1;
      }
LABEL_107:
      v1 = (uint64_t *)*v1;
      if (!v1)
      {
        if (!v2)
          goto LABEL_125;
        v63 = sub_10003FD00();
        if (v63 && !v4 && dword_10008BA20)
        {
          v64 = ne_log_obj(v63);
          v65 = os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT);
          if (v65)
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "NAT-T is enabled in at least one remote{} section,\n", buf, 2u);
          }
          if (dword_10008BA20)
          {
            v66 = ne_log_obj(v65);
            if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "but no 'isakmp_natt' address was specified!\n", buf, 2u);
            }
          }
        }
        if (v3)
          sub_10003A520(5, (uint64_t)sub_1000079E0, 0);
        return 0;
      }
    }
    if (v7 != 2)
    {
      if (dword_10008BA20)
      {
        v23 = ne_log_obj(a1);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          sub_10005C7B4(v100, &v101, v23);
      }
      goto LABEL_105;
    }
    if (*(_DWORD *)(v5 + 4))
      v8 = 1;
    else
      v8 = dword_10008BA20 == 0;
    if (v8)
      goto LABEL_26;
    v9 = ne_log_obj(a1);
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      goto LABEL_26;
    *(_WORD *)buf = 0;
    v10 = v9;
    v11 = "listening to wildcard address,broadcast IKE packet may kill you\n";
    goto LABEL_16;
  }
LABEL_125:
  if (dword_10008BA20)
  {
    v68 = ne_log_obj(a1);
    if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
      sub_10005C788();
  }
  return 0xFFFFFFFFLL;
}

_QWORD *sub_100023E5C()
{
  sub_100023FD8();
  return sub_100006ED4();
}

void sub_100023E70()
{
  sub_100009E30();
  sub_1000096F0();
}

__int128 *sub_100023E84(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  int v5;
  uint64_t v6;

  v4 = 0;
  v5 = 0;
  xmmword_100088768 = 0u;
  unk_100088778 = 0u;
  xmmword_100088748 = 0u;
  unk_100088758 = 0u;
  do
  {
    snprintf((char *)&xmmword_100088748 + v5, 64 - v5, "%02x", *(unsigned __int8 *)(a1 + v4));
    v6 = v5 + 2;
    if (v4 == 7)
    {
      *((_BYTE *)&xmmword_100088748 + v6) = 58;
      LODWORD(v6) = v5 + 3;
    }
    ++v4;
    v5 = v6;
  }
  while (v4 != 16);
  if (a2)
    snprintf((char *)&xmmword_100088748 + (int)v6, 64 - (int)v6, ":%08x", bswap32(a2) >> 16);
  return &xmmword_100088748;
}

void sub_100023F68(uint64_t a1)
{
  sub_100021168(*(unsigned int *)(a1 + 32));
}

void sub_100023F70(uint64_t a1)
{
  close(*(_DWORD *)(a1 + 40));
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

void sub_100023F98()
{
  _QWORD *i;
  NSObject *v1;

  for (i = *(_QWORD **)(qword_10008B848 + 120); i; i = (_QWORD *)*i)
  {
    v1 = i[3];
    if (v1)
      dispatch_suspend(v1);
  }
}

void sub_100023FD8()
{
  uint64_t *i;
  NSObject *v1;

  for (i = *(uint64_t **)(qword_10008B848 + 120); i; i = (uint64_t *)*i)
  {
    if (i[1])
    {
      v1 = i[3];
      if (v1)
      {
        dispatch_source_cancel(v1);
        i[3] = 0;
        *((_DWORD *)i + 9) = 0;
        *((_DWORD *)i + 4) = -1;
      }
    }
  }
}

void sub_100024030()
{
  uint64_t *v0;
  _QWORD *v1;
  uint64_t *v2;
  NSObject *v3;
  uint64_t *v4;

  v1 = (_QWORD *)(qword_10008B848 + 120);
  v0 = *(uint64_t **)(qword_10008B848 + 120);
  if (v0)
  {
    do
    {
      v2 = (uint64_t *)*v0;
      if (*((_DWORD *)v0 + 9))
      {
        v1 = v0;
      }
      else
      {
        v3 = v0[3];
        v4 = (uint64_t *)*v0;
        if (v3)
        {
          dispatch_source_cancel(v3);
          v0[3] = 0;
          v4 = (uint64_t *)*v0;
        }
        *v1 = v4;
        sub_100006F18(v0);
      }
      v0 = v2;
    }
    while (v2);
  }
}

uint64_t sub_1000240A4(uint64_t a1, size_t *a2)
{
  size_t *v2;
  unsigned int v4;
  uint64_t v5;
  BOOL v6;
  size_t *v7;
  NSObject *v8;
  size_t *v10;
  _DWORD *v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  unint64_t v15;
  uint64_t v16;
  NSObject *v17;
  NSObject *v18;
  uint64_t v19;
  NSObject *v21;
  size_t v22;
  char *v23;
  int v24;
  size_t v25;
  __int16 v26;
  char *v27;

  v2 = a2;
  v4 = (*(_DWORD *)(a1 + 96) >> 3) & 4;
  if (*(_DWORD *)(a1 + 100) && *a2 > 0x500)
    v4 = 0;
  v5 = v4;
  if (v4)
    v6 = dword_10008BA20 == 0;
  else
    v6 = 1;
  if (v6)
  {
    if (!v4)
    {
      v7 = 0;
      goto LABEL_15;
    }
  }
  else
  {
    v8 = ne_log_obj(a1);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      sub_10005CB64();
  }
  v10 = sub_10003F1F8(*v2 + v5);
  if (!v10)
  {
    if (dword_10008BA20)
    {
      v18 = ne_log_obj(0);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        sub_10005CAE0();
    }
    return 0xFFFFFFFFLL;
  }
  v7 = v10;
  v11 = (_DWORD *)v10[1];
  *v11 = 0;
  memcpy((char *)v11 + v5, (const void *)v2[1], *v2);
  v2 = v7;
LABEL_15:
  v12 = sub_100007A38(*(unsigned __int8 **)(a1 + 56));
  if ((_DWORD)v12 == -1)
    goto LABEL_35;
  v13 = v12;
  if (dword_10008BA20)
  {
    v14 = ne_log_obj(v12);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      v22 = *v2;
      v23 = sub_10003CB18("from %s to %s", *(const sockaddr **)(a1 + 56), *(sockaddr **)(a1 + 48));
      v24 = 134218242;
      v25 = v22;
      v26 = 2080;
      v27 = v23;
      _os_log_debug_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "%zu bytes %s\n", (uint8_t *)&v24, 0x16u);
    }
  }
  v15 = *v2;
  if (!*(_DWORD *)(a1 + 100) || v15 < 0x501)
  {
    v19 = sub_10003BDE0(v13, (const void *)v2[1], v15, *(unsigned __int8 **)(a1 + 56), *(unsigned __int8 **)(a1 + 48), *(_DWORD *)(qword_10008B848 + 276));
    if ((_DWORD)v19 != -1)
      goto LABEL_30;
    if (dword_10008BA20)
    {
      v21 = ne_log_obj(v19);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        sub_10005CB38();
        if (!v7)
          return 0xFFFFFFFFLL;
        goto LABEL_36;
      }
    }
LABEL_35:
    if (!v7)
      return 0xFFFFFFFFLL;
LABEL_36:
    sub_10003F318(v7);
    return 0xFFFFFFFFLL;
  }
  v16 = sub_100014F98(a1, v2);
  if ((_DWORD)v16 == -1)
  {
    if (dword_10008BA20)
    {
      v17 = ne_log_obj(v16);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        sub_10005CB0C();
        if (!v7)
          return 0xFFFFFFFFLL;
        goto LABEL_36;
      }
    }
    goto LABEL_35;
  }
LABEL_30:
  if (v7)
    sub_10003F318(v7);
  return 0;
}

uint64_t sub_10002431C(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;

  result = sub_100024360();
  if ((result & 0x80000000) != 0)
  {
    v3 = *(unsigned int *)(a1 + 120);
    if ((_DWORD)v3)
    {
      sub_10003A6F0(v3);
      *(_DWORD *)(a1 + 120) = 0;
    }
    return sub_10004AACC(a1);
  }
  return result;
}

uint64_t sub_100024360(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t result;
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  int v11;
  __int128 *v12;

  if (!*(_QWORD *)(a1 + 128))
    return 0xFFFFFFFFLL;
  if (*(int *)(a1 + 124) > 0)
  {
    sub_10004EF9C(a1);
    v2 = sub_1000240A4(a1, *(size_t **)(a1 + 128));
    if ((v2 & 0x80000000) == 0)
    {
      if (dword_10008BA20)
      {
        v3 = ne_log_obj(v2);
        if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
        {
          sub_100023E84(a1, *(_DWORD *)(a1 + 84));
          v11 = 136315138;
          v12 = &xmmword_100088748;
          _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Resend Phase 1 packet %s\n", (uint8_t *)&v11, 0xCu);
        }
      }
      v4 = *(_DWORD *)(a1 + 124) - 1;
      *(_DWORD *)(a1 + 124) = v4;
      v5 = sub_100009778(*(_DWORD *)(*(_QWORD *)(a1 + 64) + 200) - v4, *(_DWORD *)(*(_QWORD *)(a1 + 64) + 204));
      v6 = sub_10003A520(v5, (uint64_t)sub_10002431C, a1);
      result = 0;
      *(_DWORD *)(a1 + 120) = v6;
      return result;
    }
    if (dword_10008BA20)
    {
      v10 = ne_log_obj(v2);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_10005CC04(a1);
    }
    return 0xFFFFFFFFLL;
  }
  if (dword_10008BA20)
  {
    v8 = ne_log_obj(a1);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      sub_10005CB90(a1);
  }
  if (*(_DWORD *)(a1 + 20))
    return 0xFFFFFFFFLL;
  if ((*(_BYTE *)(a1 + 432) & 1) == 0)
    return 0xFFFFFFFFLL;
  v9 = *(_QWORD *)(a1 + 440);
  if (!v9)
    return 0xFFFFFFFFLL;
  if ((*(_WORD *)(v9 + 264) & 0x400) == 0)
    return 0xFFFFFFFFLL;
  result = sub_100024514(a1);
  if ((_DWORD)result)
    return 0xFFFFFFFFLL;
  return result;
}

uint64_t sub_100024514(uint64_t a1)
{
  uint64_t result;
  int v3;
  BOOL v4;
  uint64_t *v5;
  char *v6;
  uint64_t *v7;
  uint64_t *v8;
  char *v9;
  char *v10;
  NSObject *v11;
  uint64_t v12;
  NSObject *v13;
  _BOOL4 v14;
  uint64_t v15;
  NSObject *v16;
  const char *v17;
  _DWORD *v18;
  _DWORD *v19;
  NSObject *v20;
  uint64_t v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  int v25;
  char *v26;
  __int16 v27;
  char *v28;
  __int16 v29;
  __int128 *v30;

  if (*(_DWORD *)(a1 + 112) || *(_DWORD *)(a1 + 116))
    return 0xFFFFFFFFLL;
  v3 = *(_DWORD *)(a1 + 16);
  v4 = v3 == 5281 || v3 == 5217;
  if (!v4
    || (*(_BYTE *)(a1 + 96) & 8) == 0
    || sub_10003D25C(*(_QWORD *)(a1 + 56)) != 4500
    && sub_10003D25C(*(_QWORD *)(a1 + 48)) != 4500
    || (*(_BYTE *)(a1 + 432) & 2) != 0)
  {
    return 0xFFFFFFFFLL;
  }
  v5 = sub_10003C570(*(const sockaddr **)(a1 + 56));
  v6 = strdup((const char *)v5);
  v7 = (uint64_t *)(a1 + 48);
  v8 = sub_10003C570(*(const sockaddr **)(a1 + 48));
  v9 = strdup((const char *)v8);
  if (!v6)
  {
    if (dword_10008BA20)
    {
      v23 = ne_log_obj(v9);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        goto LABEL_50;
    }
    goto LABEL_51;
  }
  v10 = v9;
  if (!v9)
  {
    if (dword_10008BA20)
    {
      v24 = ne_log_obj(0);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
LABEL_50:
        sub_10005C4A8();
    }
LABEL_51:
    exit(1);
  }
  if (dword_10008BA20)
  {
    v11 = ne_log_obj(v9);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      sub_100023E84(a1, 0);
      v25 = 136315650;
      v26 = v6;
      v27 = 2080;
      v28 = v10;
      v29 = 2080;
      v30 = &xmmword_100088748;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "ISAKMP-SA rekey failed... retrying %s-%s spi:%s\n", (uint8_t *)&v25, 0x20u);
    }
  }
  free(v6);
  free(v10);
  v12 = sub_10004E4C4(*(_QWORD *)(a1 + 440), 1);
  if (!(_DWORD)v12)
  {
    v15 = sub_10004BDEC(*(_QWORD *)(a1 + 440), a1);
    if ((_DWORD)v15)
    {
      if (!dword_10008BA20)
        return 0xFFFFFFFFLL;
      v16 = ne_log_obj(v15);
      if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        return 0xFFFFFFFFLL;
      LOWORD(v25) = 0;
      v17 = "request to retry ISAKMP-SA rekey was ignored due to another established ph1.\n";
    }
    else
    {
      if (sub_10003D25C(*(_QWORD *)(a1 + 56)) == 4500)
        sub_10003D350(*(_QWORD *)(a1 + 56), 0x1F4u);
      if (sub_10003D25C(*v7) == 4500)
        sub_10003D350(*v7, 0x1F4u);
      *(_DWORD *)(a1 + 96) &= ~8u;
      v18 = sub_100038594(*(_QWORD *)(a1 + 48));
      if (!v18)
      {
        if (dword_10008BA20)
        {
          v22 = ne_log_obj(0);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
            sub_10005CC78((const sockaddr **)v7);
        }
        return 0xFFFFFFFFLL;
      }
      v19 = v18;
      if (dword_10008BA20)
      {
        v20 = ne_log_obj(v18);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v25) = 0;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "begin Phase 1 rekey retry.\n", (uint8_t *)&v25, 2u);
        }
      }
      v21 = sub_1000221FC(*(_QWORD *)(a1 + 440), v19, *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), 0, a1 + 28);
      if ((v21 & 0x80000000) == 0)
      {
        result = 0;
        *(_BYTE *)(a1 + 432) |= 1u;
        return result;
      }
      if (!dword_10008BA20)
        return 0xFFFFFFFFLL;
      v16 = ne_log_obj(v21);
      if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        return 0xFFFFFFFFLL;
      LOWORD(v25) = 0;
      v17 = "Phase 1 rekey retry Failed.\n";
    }
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v17, (uint8_t *)&v25, 2u);
    return 0xFFFFFFFFLL;
  }
  if (!dword_10008BA20)
    return 0;
  v13 = ne_log_obj(v12);
  v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
  result = 0;
  if (v14)
  {
    LOWORD(v25) = 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "request for ISAKMP-SA rekey was ignored due to idleness.\n", (uint8_t *)&v25, 2u);
    return 0;
  }
  return result;
}

uint64_t sub_1000248C4(_QWORD *a1)
{
  uint64_t result;

  result = sub_1000248F8();
  if ((result & 0x80000000) != 0)
    return sub_10004A9EC(a1);
  return result;
}

uint64_t sub_1000248F8(uint64_t a1)
{
  uint64_t v1;
  uint64_t *v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t result;
  NSObject *v8;
  NSObject *v9;
  NSObject *v10;
  NSObject *v11;
  int v12;
  __int128 *v13;

  v1 = *(_QWORD *)(a1 + 256);
  if (!v1)
  {
    if (dword_10008BA20)
    {
      v8 = ne_log_obj(a1);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_10005CCE0();
    }
    return 0xFFFFFFFFLL;
  }
  v3 = (uint64_t *)(a1 + 256);
  if ((*(_BYTE *)(v1 + 17) & 0x40) != 0)
  {
    if (dword_10008BA20)
    {
      v9 = ne_log_obj(a1);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_10005CDF4(v3, a1);
    }
    return 0xFFFFFFFFLL;
  }
  if (*(int *)(a1 + 72) <= 0)
  {
    if (dword_10008BA20)
    {
      v10 = ne_log_obj(a1);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_10005CD0C(v3, a1);
    }
    return 0xFFFFFFFFLL;
  }
  sub_10004EEB4(a1);
  v4 = sub_1000240A4(*(_QWORD *)(a1 + 256), *(size_t **)(a1 + 80));
  if ((v4 & 0x80000000) != 0)
  {
    if (dword_10008BA20)
    {
      v11 = ne_log_obj(v4);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        sub_10005CD80(v3, a1);
    }
    return 0xFFFFFFFFLL;
  }
  if (dword_10008BA20)
  {
    v5 = ne_log_obj(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      sub_100023E84(*(_QWORD *)(a1 + 256), *(_DWORD *)(a1 + 108));
      v12 = 136315138;
      v13 = &xmmword_100088748;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Resend Phase 2 packet %s\n", (uint8_t *)&v12, 0xCu);
    }
  }
  --*(_DWORD *)(a1 + 72);
  v6 = sub_100009778(*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 256) + 64) + 200) - *(_DWORD *)(*(_QWORD *)(a1 + 256) + 124), *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 256) + 64) + 204));
  result = (uint64_t)sub_10003A520(v6, (uint64_t)sub_1000248C4, a1);
  *(_DWORD *)(a1 + 68) = result;
  if ((_DWORD)result)
  {
    sub_10001C7DC(*v3, (uint64_t)"Phase 2 packets sent to peer: retransmit timer armed");
    return 0;
  }
  return result;
}

void sub_100024B1C(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t *v5;
  char *v6;
  const sockaddr **v7;
  uint64_t *v8;
  char *v9;
  char *v10;
  NSObject *v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  NSObject *v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  NSObject *v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  int v25;
  char *v26;
  __int16 v27;
  char *v28;
  __int16 v29;
  __int128 *v30;

  v4 = *(unsigned int *)(a1 + 116);
  if ((_DWORD)v4)
  {
    sub_10003A6F0(v4);
    *(_DWORD *)(a1 + 116) = 0;
  }
  if (*(_DWORD *)(a1 + 112)
    || (v14 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 24)) != 0
    && (v15 = sub_10003A520(v14, (uint64_t)sub_100022D68, a1), (*(_DWORD *)(a1 + 112) = v15) != 0))
  {
    if ((*(_BYTE *)(a1 + 17) & 0x20) != 0 && (*(_BYTE *)(a1 + 432) & 2) == 0)
    {
      v5 = sub_10003C570(*(const sockaddr **)(a1 + 56));
      v6 = strdup((const char *)v5);
      v7 = (const sockaddr **)(a1 + 48);
      v8 = sub_10003C570(*(const sockaddr **)(a1 + 48));
      v9 = strdup((const char *)v8);
      if (v6)
      {
        v10 = v9;
        if (v9)
        {
          if (dword_10008BA20)
          {
            v11 = ne_log_obj(v9);
            if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
            {
              sub_100023E84(a1, 0);
              v25 = 136315650;
              v26 = v6;
              v27 = 2080;
              v28 = v10;
              v29 = 2080;
              v30 = &xmmword_100088748;
              _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "ISAKMP-SA rekey-timer expired %s-%s spi:%s\n", (uint8_t *)&v25, 0x20u);
            }
          }
          free(v6);
          free(v10);
          if (a2 || !sub_10004E4C4(*(_QWORD *)(a1 + 440), 1))
          {
            v12 = sub_10004BDEC(*(_QWORD *)(a1 + 440), a1);
            if ((_DWORD)v12)
            {
              if (dword_10008BA20)
              {
                v13 = ne_log_obj(v12);
                if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
                {
                  LOWORD(v25) = 0;
                  _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Request for ISAKMP-SA rekey was ignored due to another established ph1.\n", (uint8_t *)&v25, 2u);
                }
              }
            }
            else
            {
              v16 = sub_10004BE30(*(_QWORD *)(a1 + 440), a1);
              if ((_DWORD)v16)
              {
                if (dword_10008BA20)
                {
                  v17 = ne_log_obj(v16);
                  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
                    sub_10005CED0();
                }
                *(_DWORD *)(a1 + 116) = sub_10003A520(1, (uint64_t)sub_100022D6C, a1);
              }
              else
              {
                v18 = *(_QWORD *)(a1 + 64);
                if (v18 || (v16 = (uint64_t)sub_100038594((uint64_t)*v7), (v18 = v16) != 0))
                {
                  if (dword_10008BA20)
                  {
                    v19 = ne_log_obj(v16);
                    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
                    {
                      LOWORD(v25) = 0;
                      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Begin Phase 1 rekey.\n", (uint8_t *)&v25, 2u);
                    }
                  }
                  v20 = sub_1000221FC(*(_QWORD *)(a1 + 440), v18, *(unsigned __int8 **)(a1 + 48), *(unsigned __int8 **)(a1 + 56), 0, (_OWORD *)(a1 + 28));
                  if ((v20 & 0x80000000) != 0)
                  {
                    if (dword_10008BA20)
                    {
                      v21 = ne_log_obj(v20);
                      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
                      {
                        LOWORD(v25) = 0;
                        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Phase 1 rekey Failed.\n", (uint8_t *)&v25, 2u);
                      }
                    }
                  }
                  *(_BYTE *)(a1 + 432) |= 1u;
                }
                else if (dword_10008BA20)
                {
                  v22 = ne_log_obj(0);
                  if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
                    sub_10005CE68(v7);
                }
              }
            }
          }
          return;
        }
        if (dword_10008BA20)
        {
          v24 = ne_log_obj(0);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
            goto LABEL_45;
        }
      }
      else if (dword_10008BA20)
      {
        v23 = ne_log_obj(v9);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
LABEL_45:
          sub_10005C4A8();
      }
      exit(1);
    }
  }
}

_QWORD *sub_100024E9C(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *result;
  uint64_t *v6;
  char *v7;
  uint64_t *v8;
  char *v9;
  char *v10;
  NSObject *v11;
  _BOOL8 v12;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;
  int v16;
  __int128 *v17;
  __int16 v18;
  char *v19;
  __int16 v20;
  __int128 *v21;

  v2 = *(unsigned int *)(a1 + 112);
  if ((_DWORD)v2)
  {
    sub_10003A6F0(v2);
    *(_DWORD *)(a1 + 112) = 0;
  }
  v3 = *(unsigned int *)(a1 + 116);
  if ((_DWORD)v3)
  {
    sub_10003A6F0(v3);
    *(_DWORD *)(a1 + 116) = 0;
  }
  v4 = *(unsigned int *)(a1 + 388);
  if ((_DWORD)v4)
  {
    sub_10003A6F0(v4);
    *(_DWORD *)(a1 + 388) = 0;
  }
  if (*(_QWORD *)(a1 + 448))
  {
    result = sub_10003A520(1, (uint64_t)sub_100024B18, a1);
    *(_DWORD *)(a1 + 112) = (_DWORD)result;
    return result;
  }
  sub_10001A528(a1);
  v6 = sub_10003C570(*(const sockaddr **)(a1 + 56));
  v7 = strdup((const char *)v6);
  v8 = sub_10003C570(*(const sockaddr **)(a1 + 48));
  v9 = strdup((const char *)v8);
  if (!v7)
  {
    if (dword_10008BA20)
    {
      v14 = ne_log_obj(v9);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        goto LABEL_23;
    }
    goto LABEL_24;
  }
  v10 = v9;
  if (!v9)
  {
    if (dword_10008BA20)
    {
      v15 = ne_log_obj(0);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
LABEL_23:
        sub_10005C4A8();
    }
LABEL_24:
    exit(1);
  }
  if (dword_10008BA20)
  {
    v11 = ne_log_obj(v9);
    v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
    if (v12)
    {
      sub_100023E84(a1, 0);
      v16 = 136315138;
      v17 = &xmmword_100088748;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "ISAKMP-SA deleted spi:%s\n", (uint8_t *)&v16, 0xCu);
    }
    if (dword_10008BA20)
    {
      v13 = ne_log_obj(v12);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        sub_100023E84(a1, 0);
        v16 = 136315650;
        v17 = (__int128 *)v7;
        v18 = 2080;
        v19 = v10;
        v20 = 2080;
        v21 = &xmmword_100088748;
        _os_log_debug_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "ISAKMP-SA deleted %s-%s spi:%s\n", (uint8_t *)&v16, 0x20u);
      }
    }
  }
  free(v7);
  free(v10);
  return (_QWORD *)sub_10004AACC(a1);
}

_QWORD *sub_1000250DC(_QWORD *result)
{
  uint64_t v1;
  uint64_t v2;
  char *v3;
  char *v4;
  char *v5;
  char *v6;
  char *v7;
  NSObject *v8;
  uint64_t v9;
  unsigned int *i;
  int v11;
  char v12;
  NSObject *v13;
  NSObject *v14;
  int v15;
  char *v16;
  __int16 v17;
  char *v18;

  if ((*((_BYTE *)result + 57) & 0x40) != 0)
    return result;
  v1 = (uint64_t)result;
  v2 = *((unsigned int *)result + 16);
  if ((_DWORD)v2)
  {
    sub_10003A6F0(v2);
    *(_DWORD *)(v1 + 64) = 0;
  }
  v3 = sub_10003C8A0(*(const sockaddr **)v1);
  v4 = strdup(v3);
  v5 = sub_10003C8A0(*(const sockaddr **)(v1 + 8));
  v6 = strdup(v5);
  if (!v4)
  {
    if (dword_10008BA20)
    {
      v13 = ne_log_obj(v6);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        goto LABEL_24;
    }
    goto LABEL_25;
  }
  v7 = v6;
  if (!v6)
  {
    if (dword_10008BA20)
    {
      v14 = ne_log_obj(0);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
LABEL_24:
        sub_10005C4A8();
    }
LABEL_25:
    exit(1);
  }
  if (dword_10008BA20)
  {
    v8 = ne_log_obj(v6);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v15 = 136315394;
      v16 = v4;
      v17 = 2080;
      v18 = v7;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Phase 2 sa expired %s-%s\n", (uint8_t *)&v15, 0x16u);
    }
  }
  free(v4);
  free(v7);
  if ((*(_BYTE *)(v1 + 57) & 0x20) != 0)
  {
    v9 = *(_QWORD *)(v1 + 128);
    if (v9)
    {
      for (i = *(unsigned int **)(v9 + 32); i; i = (unsigned int *)*((_QWORD *)i + 9))
      {
        if (i[14])
        {
          v11 = *(_DWORD *)(qword_10008B848 + 32);
          v12 = sub_10002EFA4(*i);
          sub_100040B7C(v11, v12, 0, *(unsigned __int8 **)v1, *(unsigned __int8 **)(v1 + 8), i[7]);
        }
      }
    }
  }
  if (*(_BYTE *)(v1 + 61) == 16)
    sub_100003774((int *)(v1 + 56), 18432);
  result = sub_10003A520(1, (uint64_t)sub_1000252D4, v1);
  *(_DWORD *)(v1 + 64) = (_DWORD)result;
  return result;
}

uint64_t sub_1000252D8(uint64_t a1)
{
  uint64_t v2;
  char *v3;
  char *v4;
  char *v5;
  char *v6;
  char *v7;
  NSObject *v8;
  NSObject *v10;
  NSObject *v11;
  int v12;
  char *v13;
  __int16 v14;
  char *v15;

  v2 = *(unsigned int *)(a1 + 64);
  if ((_DWORD)v2)
  {
    sub_10003A6F0(v2);
    *(_DWORD *)(a1 + 64) = 0;
  }
  v3 = sub_10003C8A0(*(const sockaddr **)a1);
  v4 = strdup(v3);
  v5 = sub_10003C8A0(*(const sockaddr **)(a1 + 8));
  v6 = strdup(v5);
  if (!v4)
  {
    if (dword_10008BA20)
    {
      v10 = ne_log_obj(v6);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        goto LABEL_14;
    }
    goto LABEL_15;
  }
  v7 = v6;
  if (!v6)
  {
    if (dword_10008BA20)
    {
      v11 = ne_log_obj(0);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
LABEL_14:
        sub_10005C4A8();
    }
LABEL_15:
    exit(1);
  }
  if (dword_10008BA20)
  {
    v8 = ne_log_obj(v6);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v12 = 136315394;
      v13 = v4;
      v14 = 2080;
      v15 = v7;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Phase 2 sa deleted %s-%s\n", (uint8_t *)&v12, 0x16u);
    }
  }
  free(v4);
  free(v7);
  return sub_10004A9EC((_QWORD *)a1);
}

uint64_t sub_10002543C(uint64_t a1)
{
  NSObject *v2;
  const sockaddr **v3;
  _DWORD *v4;
  uint64_t v5;
  NSObject *v6;
  _BOOL4 v7;
  uint64_t result;
  char *v9;
  const char *v10;
  NSObject *v11;
  uint32_t v12;
  NSObject *v13;
  _BOOL8 v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  NSObject *v19;
  _BOOL4 v20;
  _QWORD *v21;
  NSObject *v22;
  char *v23;
  _BOOL8 v24;
  _BOOL4 v25;
  int v26;
  _BOOL4 v27;
  NSObject *v28;
  int v29;
  char *v30;

  if (dword_10008BA20)
  {
    v2 = ne_log_obj(a1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
      sub_10005CF64();
  }
  v3 = (const sockaddr **)(a1 + 8);
  v4 = sub_100038594(*(_QWORD *)(a1 + 8));
  if (!v4)
  {
    if (dword_10008BA20)
    {
      v13 = ne_log_obj(0);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        sub_10005CEFC(v3);
    }
    return 0xFFFFFFFFLL;
  }
  v5 = (uint64_t)v4;
  if (v4[36])
  {
    if (!dword_10008BA20)
      return 0;
    v6 = ne_log_obj(v4);
    v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (v7)
    {
      v9 = sub_10003C8A0(*v3);
      v29 = 136315138;
      v30 = v9;
      v10 = "Because of passive mode, ignore the acquire message for %s.\n";
      v11 = v6;
      v12 = 12;
LABEL_9:
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v10, (uint8_t *)&v29, v12);
      return 0;
    }
    return result;
  }
  v14 = sub_10004BF48(*(_QWORD *)(a1 + 272), a1);
  if (v14)
  {
    if (dword_10008BA20)
    {
      v15 = ne_log_obj(v14);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v29) = 0;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Request for establishing IPsec-SA was ignored due to another negoing ph2.\n", (uint8_t *)&v29, 2u);
      }
    }
    return 0xFFFFFFFFLL;
  }
  if ((*(_BYTE *)(a1 + 264) & 1) != 0)
    sub_10004D000((uint64_t *)a1);
  if (*(_BYTE *)(a1 + 61) != 16 || (v16 = sub_10004BBE8(a1)) == 0)
  {
    *(_DWORD *)(a1 + 96) = *(_DWORD *)(qword_10008B848 + 280);
    v21 = sub_10003A520(1, (uint64_t)sub_100025804, a1);
    if (dword_10008BA20)
    {
      v22 = ne_log_obj(v21);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        v23 = sub_10003C8A0(*v3);
        v29 = 136315138;
        v30 = v23;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "IPsec-SA request for %s queued due to no Phase 1 found.\n", (uint8_t *)&v29, 0xCu);
      }
    }
    v24 = sub_10004D81C(*(_QWORD *)(a1 + 272));
    if (v24)
    {
      if (!dword_10008BA20)
        return 0;
      v19 = ne_log_obj(v24);
      v25 = os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT);
      result = 0;
      if (!v25)
        return result;
      LOWORD(v29) = 0;
      v10 = "Request for Phase 1 was ignored due to another negotiating Phase 1.\n";
    }
    else
    {
      v26 = sub_1000221FC(*(_QWORD *)(a1 + 272), v5, *(unsigned __int8 **)(a1 + 8), *(unsigned __int8 **)a1, 0, (_OWORD *)(a1 + 16));
      result = 0;
      if ((v26 & 0x80000000) == 0)
        return result;
      if (!dword_10008BA20)
        return result;
      v19 = ne_log_obj(0);
      v27 = os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT);
      result = 0;
      if (!v27)
        return result;
      LOWORD(v29) = 0;
      v10 = "Request for Phase 1 failed. Will try later.\n";
    }
LABEL_39:
    v11 = v19;
    v12 = 2;
    goto LABEL_9;
  }
  v17 = v16;
  if ((*(_BYTE *)(v16 + 17) & 0x20) != 0)
  {
    if (dword_10008BA20)
    {
      v28 = ne_log_obj(v16);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v29) = 0;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Begin QUICK mode.\n", (uint8_t *)&v29, 2u);
      }
    }
    if (sub_100025808(v17, a1))
      return 0xFFFFFFFFLL;
    else
      return 0;
  }
  *(_DWORD *)(a1 + 96) = *(_DWORD *)(qword_10008B848 + 280);
  v18 = sub_10003A520(1, (uint64_t)sub_100025804, a1);
  if (!dword_10008BA20)
    return 0;
  v19 = ne_log_obj(v18);
  v20 = os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT);
  result = 0;
  if (v20)
  {
    LOWORD(v29) = 0;
    v10 = "Request for establishing IPsec-SA was queued due to no phase1 found.\n";
    goto LABEL_39;
  }
  return result;
}

uint64_t sub_100025808(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  _BOOL8 v7;
  NSObject *v8;
  uint64_t *v9;
  char *v10;
  char *v11;
  NSObject *v12;
  uint64_t *v13;
  uint64_t v14;
  NSObject *v15;
  NSObject *v17;
  int v18;
  char *v19;
  __int16 v20;
  uint64_t *v21;

  v4 = sub_100046728((_QWORD *)a1);
  if ((_DWORD)v4)
  {
    if (dword_10008BA20)
    {
      v5 = ne_log_obj(v4);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_10005CFBC();
    }
    return 0xFFFFFFFFLL;
  }
  if (dword_10008BA20)
  {
    v6 = ne_log_obj(v4);
    v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG);
    if (v7)
      sub_10005C5F4();
    if (dword_10008BA20)
    {
      v8 = ne_log_obj(v7);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        sub_10005CF90();
    }
  }
  v9 = sub_10003C570(*(const sockaddr **)a2);
  v10 = strdup((const char *)v9);
  if (!v10)
  {
    if (dword_10008BA20)
    {
      v17 = ne_log_obj(0);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        sub_10005C4A8();
    }
    exit(1);
  }
  v11 = v10;
  if (dword_10008BA20)
  {
    v12 = ne_log_obj(v10);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      v13 = sub_10003C570(*(const sockaddr **)(a2 + 8));
      v18 = 136315394;
      v19 = v11;
      v20 = 2080;
      v21 = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "initiate new phase 2 negotiation: %s<=>%s\n", (uint8_t *)&v18, 0x16u);
    }
  }
  free(v11);
  *(_BYTE *)(a2 + 264) &= ~2u;
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a1 + 28);
  sub_100003774((int *)(a2 + 56), 6336);
  if (dword_10008BA20)
  {
    v15 = ne_log_obj(v14);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v18) = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "IPSec Phase 2 started (Initiated by me).\n", (uint8_t *)&v18, 2u);
    }
  }
  if (sub_10001C930(a2))
    return 0xFFFFFFFFLL;
  sub_100048B0C(1, 0, 0, a2);
  return 0;
}

uint64_t sub_100025A2C(uint64_t a1)
{
  int *v2;
  int v3;
  NSObject *v4;

  if ((*(_BYTE *)(*(_QWORD *)(a1 + 256) + 17) & 0x40) != 0)
  {
    if (dword_10008BA20)
    {
      v4 = ne_log_obj(a1);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_10005CFE8();
    }
    return 0xFFFFFFFFLL;
  }
  v2 = (int *)(a1 + 56);
  if (*(_BYTE *)(a1 + 60))
    v3 = 6608;
  else
    v3 = 6352;
  sub_100003774(v2, v3);
  if (*(_BYTE *)(a1 + 60) != 1)
  {
    if (*(_BYTE *)(a1 + 60) || !sub_10001CA7C(a1, 0))
      return 0;
    return 0xFFFFFFFFLL;
  }
  if (sub_10001F6E4(a1, 0))
    return 0xFFFFFFFFLL;
  return 0;
}

void sub_100025AE0(uint64_t a1)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  NSObject *v7;
  NSObject *v8;
  int v9;
  int v10;
  NSObject *v11;
  _BOOL8 v12;
  NSObject *v13;
  NSObject *v14;
  _BOOL8 v15;
  NSObject *v16;
  _BOOL8 v17;
  NSObject *v18;
  _BOOL8 v19;
  NSObject *v20;
  _BOOL8 v21;
  NSObject *v22;
  _BOOL8 v23;
  NSObject *v24;
  uint64_t v25;
  unsigned int v26;
  uint64_t v27;
  unsigned int v28;
  _WORD *v29;
  NSObject *v30;
  _BOOL8 v31;
  NSObject *v32;
  _BOOL8 v33;
  NSObject *v34;
  _DWORD *v35;
  _OWORD *v36;
  NSObject *v37;
  const char *v38;
  _DWORD v39[2];
  __int16 v40;
  int v41;
  __int16 v42;
  int v43;

  if (*(_BYTE *)(a1 + 61) == 16 && *(_DWORD *)(a1 + 56) != 6336 || (*(_BYTE *)(a1 + 264) & 2) != 0)
  {
    if (dword_10008BA20)
    {
      v8 = ne_log_obj(a1);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        v9 = *(_DWORD *)(a1 + 56);
        v10 = *(unsigned __int8 *)(a1 + 264) << 30 >> 31;
        v39[0] = 67109632;
        v39[1] = v9;
        v40 = 1024;
        v41 = 6336;
        v42 = 1024;
        v43 = v10;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "CHKPH1THERE: ph2 handle has advanced too far (status %d, START %d, dying %d)... ignoring\n", (uint8_t *)v39, 0x14u);
      }
    }
  }
  else
  {
    v2 = *(_DWORD *)(a1 + 96);
    *(_DWORD *)(a1 + 96) = v2 - 1;
    if (v2 <= 0)
    {
      if (dword_10008BA20)
      {
        v11 = ne_log_obj(a1);
        v12 = os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
        if (v12)
          sub_10005D014(a1);
        if (dword_10008BA20)
        {
          v13 = ne_log_obj(v12);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v39[0]) = 0;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "delete Phase 2 handler.\n", (uint8_t *)v39, 2u);
          }
        }
      }
      sub_10002F6E8(a1);
LABEL_51:
      sub_10004A9EC((_QWORD *)a1);
      return;
    }
    v3 = sub_10004BBE8(a1);
    v4 = v3;
    if (!v3 || (*(_BYTE *)(v3 + 17) & 0x20) == 0)
    {
      v5 = sub_10004D81C(*(_QWORD *)(a1 + 272));
      if ((_DWORD)v5)
        goto LABEL_8;
      v35 = sub_100038594(*(_QWORD *)(a1 + 8));
      if (v35)
      {
        if (v4)
          v36 = (_OWORD *)(v4 + 28);
        else
          v36 = 0;
        v5 = sub_1000221FC(*(_QWORD *)(a1 + 272), (uint64_t)v35, *(unsigned __int8 **)(a1 + 8), *(unsigned __int8 **)a1, 0, v36);
        v6 = dword_10008BA20;
        if ((v5 & 0x80000000) == 0 || !dword_10008BA20)
          goto LABEL_9;
        v37 = ne_log_obj(v5);
        v5 = os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT);
        if (!(_DWORD)v5)
        {
LABEL_8:
          v6 = dword_10008BA20;
LABEL_9:
          if (v6)
          {
            v7 = ne_log_obj(v5);
            if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
            {
              LOWORD(v39[0]) = 0;
              _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "CHKPH1THERE: no established ph1 handler found\n", (uint8_t *)v39, 2u);
            }
          }
          goto LABEL_12;
        }
        LOWORD(v39[0]) = 0;
        v38 = "CHKPH1THERE: no established/negoing ph1 handler found... failed to initiate new one\n";
      }
      else
      {
        if (!dword_10008BA20)
        {
LABEL_12:
          sub_10003A520(1, (uint64_t)sub_100025804, a1);
          return;
        }
        v37 = ne_log_obj(0);
        v5 = os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT);
        if (!(_DWORD)v5)
          goto LABEL_8;
        LOWORD(v39[0]) = 0;
        v38 = "CHKPH1THERE: no remoteconf found... failed to initiate new one\n";
      }
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, v38, (uint8_t *)v39, 2u);
      goto LABEL_8;
    }
    if (dword_10008BA20)
    {
      v14 = ne_log_obj(v3);
      v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG);
      if (v15)
        sub_10005D30C();
      if (dword_10008BA20)
      {
        v16 = ne_log_obj(v15);
        v17 = os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG);
        if (v17)
          sub_10005D29C(v4);
        if (dword_10008BA20)
        {
          v18 = ne_log_obj(v17);
          v19 = os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG);
          if (v19)
            sub_10005D22C(v4);
          if (dword_10008BA20)
          {
            v20 = ne_log_obj(v19);
            v21 = os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG);
            if (v21)
              sub_10005D200();
            if (dword_10008BA20)
            {
              v22 = ne_log_obj(v21);
              v23 = os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG);
              if (v23)
                sub_10005D0FC((const sockaddr **)a1);
              if (dword_10008BA20)
              {
                v24 = ne_log_obj(v23);
                if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
                  sub_10005D190(a1);
              }
            }
          }
        }
      }
    }
    v25 = *(_QWORD *)a1;
    v26 = sub_10003D25C(*(_QWORD *)(v4 + 56));
    sub_10003D350(v25, v26);
    v27 = *(_QWORD *)(a1 + 8);
    v28 = sub_10003D25C(*(_QWORD *)(v4 + 48));
    v29 = sub_10003D350(v27, v28);
    if (dword_10008BA20)
    {
      v30 = ne_log_obj(v29);
      v31 = os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG);
      if (v31)
        sub_10005D164();
      if (dword_10008BA20)
      {
        v32 = ne_log_obj(v31);
        v33 = os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG);
        if (v33)
          sub_10005D0FC((const sockaddr **)a1);
        if (dword_10008BA20)
        {
          v34 = ne_log_obj(v33);
          if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
            sub_10005D094((const sockaddr **)(a1 + 8));
        }
      }
    }
    if (sub_100025808(v4, a1))
      goto LABEL_51;
  }
}

uint64_t sub_100025F98(_WORD *a1, unsigned int a2, void *__src, signed int a4)
{
  _WORD *v5;

  *a1 = bswap32(a2) >> 16;
  a1[1] = bswap32(a4) >> 16;
  v5 = a1 + 2;
  memcpy(a1 + 2, __src, a4);
  return (uint64_t)v5 + a4;
}

_WORD *sub_100025FE8(_WORD *a1, int a2, unsigned int a3)
{
  *a1 = bswap32(a2 | 0x8000) >> 16;
  a1[1] = bswap32(a3) >> 16;
  return a1 + 2;
}

_QWORD *sub_10002600C(void **a1, unsigned int a2, const void *a3, signed int a4)
{
  int v7;
  void *v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  _WORD *v12;
  NSObject *v13;

  v7 = a4 + 4;
  if (a1)
  {
    v8 = *a1;
    v9 = sub_10003F270(a1, (int)(v7 + *a1));
    v10 = v9;
    v11 = (int)v8;
    if (v9)
    {
LABEL_3:
      v12 = (_WORD *)(v10[1] + v11);
      *v12 = bswap32(a2) >> 16;
      v12[1] = bswap32(a4) >> 16;
      memcpy(v12 + 2, a3, a4);
      return v10;
    }
  }
  else
  {
    v9 = sub_10003F1F8(v7);
    v10 = v9;
    v11 = 0;
    if (v9)
      goto LABEL_3;
  }
  if (dword_10008BA20)
  {
    v13 = ne_log_obj(v9);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      sub_10005D338();
  }
  return v10;
}

_QWORD *sub_1000260E0(void **a1, int a2, unsigned int a3)
{
  void *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  _WORD *v9;
  NSObject *v10;

  if (a1)
  {
    v5 = *a1;
    v6 = sub_10003F270(a1, (int)(*a1 + 4));
    v7 = v6;
    v8 = (int)v5;
    if (v6)
    {
LABEL_3:
      v9 = (_WORD *)(v7[1] + v8);
      *v9 = bswap32(a2 | 0x8000) >> 16;
      v9[1] = bswap32(a3) >> 16;
      return v7;
    }
  }
  else
  {
    v6 = sub_10003F1F8(4uLL);
    v7 = v6;
    v8 = 0;
    if (v6)
      goto LABEL_3;
  }
  if (dword_10008BA20)
  {
    v10 = ne_log_obj(v6);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      sub_10005D338();
  }
  return v7;
}

uint64_t sub_100026198(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  int v3;
  _DWORD *v7;
  _DWORD *v8;
  NSObject *v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  char *v16;
  char *v17;
  NSObject *v18;
  NSObject *v20;
  NSObject *v21;

  v3 = *(unsigned __int8 *)(a2 + 1);
  if (v3 != *(unsigned __int8 *)(a3 + 1))
  {
    if (dword_10008BA20)
    {
      v9 = ne_log_obj(a1);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_10005D3FC();
    }
    return 0xFFFFFFFFLL;
  }
  if (v3 == 30)
  {
    v7 = (_DWORD *)(a2 + 8);
    v8 = (_DWORD *)(a3 + 8);
  }
  else
  {
    if (v3 != 2)
    {
      if (dword_10008BA20)
      {
        v20 = ne_log_obj(a1);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          sub_10005C078();
      }
      return 0xFFFFFFFFLL;
    }
    v7 = (_DWORD *)(a2 + 4);
    v8 = (_DWORD *)(a3 + 4);
  }
  v10 = sub_10003F1F8(*(_DWORD *)(qword_10008B848 + 304) + 20);
  if (!v10)
  {
    if (dword_10008BA20)
    {
      v21 = ne_log_obj(0);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        sub_10005D364();
    }
    return 0xFFFFFFFFLL;
  }
  v11 = v10;
  v12 = v10[1];
  *(_DWORD *)v12 = *v7;
  *(_WORD *)(v12 + 4) = *(_WORD *)(a2 + 2);
  *(_DWORD *)(v12 + 6) = *v8;
  *(_WORD *)(v12 + 10) = *(_WORD *)(a3 + 2);
  *(_QWORD *)(v12 + 12) = time(0);
  v13 = sub_100006C70(*(_DWORD *)(qword_10008B848 + 304));
  if (!v13)
  {
    sub_10003F318(v11);
    return 0xFFFFFFFFLL;
  }
  v14 = v13;
  memcpy((void *)(v12 + 20), (const void *)v13[1], *(int *)(qword_10008B848 + 304));
  sub_10003F318(v14);
  v15 = sub_100006B30((uint64_t)v11);
  *a1 = *(_QWORD *)v15[1];
  v16 = sub_10003D3A0((uint64_t)a1, 8uLL);
  v17 = v16;
  if (dword_10008BA20)
  {
    v18 = ne_log_obj(v16);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      sub_10005D390();
  }
  free(v17);
  sub_10003F318(v11);
  sub_10003F318(v15);
  return 0;
}

uint64_t sub_1000263B8(size_t **a1, uint64_t a2)
{
  NSObject *v2;
  uint64_t v4;
  NSObject *v5;
  size_t *v7;
  NSObject *v9;
  __int16 v10[8];

  if (*a1)
  {
    if (dword_10008BA20)
    {
      v2 = ne_log_obj(a1);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
        v10[0] = 0;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "ignore this payload, same payload type exist.\n", (uint8_t *)v10, 2u);
      }
    }
  }
  else
  {
    v4 = bswap32(*(unsigned __int16 *)(a2 + 2)) >> 16;
    if (v4 > 3)
    {
      v7 = sub_10003F1F8(v4 - 4);
      *a1 = v7;
      if (v7)
      {
        memcpy((void *)v7[1], (const void *)(a2 + 4), *v7);
        return 0;
      }
      if (dword_10008BA20)
      {
        v9 = ne_log_obj(0);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          sub_1000565B0();
      }
    }
    else if (dword_10008BA20)
    {
      v5 = ne_log_obj(a1);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_10005D478();
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_1000264E8(uint64_t a1)
{
  uint64_t v2;

  do
    v2 = sub_100006CC8();
  while (sub_100008AA0(a1, v2));
  return v2;
}

uint64_t sub_100026520(uint64_t a1, uint64_t a2, char a3)
{
  return sub_100026530(a1, a2, a3, *(_BYTE *)(a2 + 81), *(_BYTE *)(a2 + 82), *(_DWORD *)(a2 + 84));
}

uint64_t sub_100026530(uint64_t a1, uint64_t a2, char a3, char a4, char a5, int a6)
{
  uint64_t v7;
  unsigned int v8;

  if (*(_QWORD *)a1 < 0x1CuLL)
    return 0;
  v7 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)v7 = *(_QWORD *)a2;
  *(_QWORD *)(v7 + 8) = *(_QWORD *)(a2 + 8);
  *(_BYTE *)(v7 + 16) = a3;
  *(_BYTE *)(v7 + 17) = *(_BYTE *)(a2 + 80);
  *(_BYTE *)(v7 + 18) = a4;
  *(_BYTE *)(v7 + 19) = a5;
  v8 = bswap32(*(_DWORD *)a1);
  *(_DWORD *)(v7 + 20) = a6;
  *(_DWORD *)(v7 + 24) = v8;
  return *(_QWORD *)(a1 + 8) + 28;
}

uint64_t sub_100026584(uint64_t a1, uint64_t a2, char a3)
{
  return sub_100026530(a1, *(_QWORD *)(a2 + 256), a3, 32, *(_BYTE *)(a2 + 105), *(_DWORD *)(a2 + 108));
}

char *sub_10002659C(uint64_t a1, uint64_t *a2, int a3)
{
  NSObject *v6;
  const void *v7;
  size_t v8;
  char *v9;

  if (dword_10008BA20)
  {
    v6 = ne_log_obj(a1);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      sub_10005D4E4(a2, a3, v6);
  }
  *(_BYTE *)a1 = a3;
  v8 = *a2;
  v7 = (const void *)a2[1];
  *(_WORD *)(a1 + 2) = bswap32(*a2 + 4) >> 16;
  v9 = (char *)(a1 + 4);
  memcpy(v9, v7, v8);
  return &v9[*a2];
}

_QWORD *sub_10002662C(_QWORD *a1, uint64_t a2, int a3)
{
  _QWORD *result;

  result = malloc_type_malloc(0x20uLL, 0x102004055CCDE27uLL);
  if (a1)
    *a1 = result;
  *result = 0;
  result[1] = a1;
  result[2] = a2;
  *((_DWORD *)result + 6) = a3;
  return result;
}

_QWORD *sub_100026684(uint64_t ***a1, uint64_t a2)
{
  uint64_t **v4;
  uint64_t **v5;
  size_t v6;
  uint64_t **v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  char *v11;
  int v12;
  uint64_t *v13;
  NSObject *v14;

  v4 = *a1;
  do
  {
    v5 = v4;
    v4 = (uint64_t **)v4[1];
  }
  while (v4);
  v6 = 28;
  v7 = v5;
  do
  {
    v6 += *v7[2] + 4;
    v7 = (uint64_t **)*v7;
  }
  while (v7);
  v8 = sub_10003F1F8(v6);
  if (!v8)
  {
    if (dword_10008BA20)
    {
      v14 = ne_log_obj(0);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        sub_10005A794();
    }
    return 0;
  }
  v9 = v8;
  v10 = sub_100026530((uint64_t)v8, a2, *((_DWORD *)v5 + 6), *(_BYTE *)(a2 + 81), *(_BYTE *)(a2 + 82), *(_DWORD *)(a2 + 84));
  if (!v10)
  {
    sub_10003F318(v9);
    return 0;
  }
  v11 = (char *)v10;
  do
  {
    if (*v5)
      v12 = *((_DWORD *)*v5 + 6);
    else
      v12 = 0;
    v11 = sub_10002659C((uint64_t)v11, v5[2], v12);
    v13 = *v5;
    free(v5);
    v5 = (uint64_t **)v13;
  }
  while (v13);
  *a1 = 0;
  return v9;
}

void sub_100026790(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  void **v4;
  void **v5;
  unint64_t v6;
  char *v7;
  unint64_t v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  unsigned __int8 *v12;
  unint64_t v13;
  int v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t v17;
  NSObject *v18;
  unsigned int v19;
  NSObject *v20;
  const char *v21;
  uint32_t v22;
  _BOOL4 v23;
  unsigned int v24;
  unsigned __int8 *v25;
  uint64_t *v26;
  uint64_t v27;
  NSObject *v28;
  unsigned int v29;
  uint64_t v30;
  NSObject *v31;
  uint64_t v32;
  NSObject *v33;
  NSObject *log;
  uint8_t buf[4];
  _QWORD v36[3];
  _OWORD v37[2];
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;

  v49 = 0u;
  v50 = 0u;
  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  v38 = 0u;
  memset(v37, 0, sizeof(v37));
  if (dword_10008BA20)
  {
    v2 = ne_log_obj(a1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      sub_100023E84(a1, *(_DWORD *)(a1 + 84));
      *(_DWORD *)buf = 136315138;
      v36[0] = &xmmword_100088748;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "purging ISAKMP-SA spi=%s.\n", buf, 0xCu);
    }
  }
  sub_100003774((int *)(a1 + 16), 17408);
  v3 = sub_10004B64C(a1);
  v4 = sub_10002EA90(0);
  if (v4)
  {
    v5 = v4;
    if ((uint64_t)*v4 >= 1)
    {
      v6 = (unint64_t)v4[1];
      v7 = (char *)*v4 + v6;
      while (1)
      {
        v8 = *(unsigned __int16 *)(v6 + 4);
        if (v8 < 2)
          goto LABEL_41;
        if (*(_BYTE *)(v6 + 1) == 10)
        {
          v9 = sub_100041CFC(v6, (uint64_t)v37);
          if ((_DWORD)v9 || (v9 = sub_100041DFC((uint64_t)v37), (_DWORD)v9))
          {
            if (dword_10008BA20)
            {
              v10 = ne_log_obj(v9);
              if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
                sub_10005D568();
            }
            goto LABEL_14;
          }
          v11 = *((_QWORD *)&v37[0] + 1);
          if (*((_QWORD *)&v37[0] + 1)
            && *((_QWORD *)&v38 + 1)
            && (_QWORD)v39
            && *(unsigned __int8 *)(*((_QWORD *)&v37[0] + 1) + 9) <= 2u)
          {
            v12 = (unsigned __int8 *)(*((_QWORD *)&v38 + 1) + 8);
            v13 = v39 + 8;
            if (!sub_10003B5A0(*(_QWORD *)(a1 + 56), *((_QWORD *)&v38 + 1) + 8)
              && !sub_10003B5A0(*(_QWORD *)(a1 + 48), v13))
            {
              break;
            }
            if (!sub_10003B5A0(*(_QWORD *)(a1 + 56), v13)
              && !sub_10003B5A0(*(_QWORD *)(a1 + 48), (unint64_t)v12))
            {
              break;
            }
          }
        }
LABEL_14:
        v6 += 8 * v8;
        if (v6 >= (unint64_t)v7)
          goto LABEL_41;
      }
      v14 = sub_10002F014(*(unsigned __int8 *)(v6 + 3));
      v15 = sub_100008C2C((uint64_t)v12, v13, v14, *(_DWORD *)(v11 + 4));
      v16 = v15;
      if (v3)
      {
        if (v15)
        {
          v17 = v15[32];
          if (v17 && v17 != a1)
            goto LABEL_14;
          if ((*((_BYTE *)v15 + 57) & 0x60) != 0)
          {
            if (!dword_10008BA20)
              goto LABEL_14;
            v18 = ne_log_obj(v15);
            if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
              goto LABEL_14;
            v19 = bswap32(*(_DWORD *)(v11 + 4));
            sub_100023E84(v3, *(_DWORD *)(v3 + 84));
            *(_DWORD *)buf = 67109378;
            LODWORD(v36[0]) = v19;
            WORD2(v36[0]) = 2080;
            *(_QWORD *)((char *)v36 + 6) = &xmmword_100088748;
            v20 = v18;
            v21 = "keeping IPsec-SA spi=%u - found valid ISAKMP-SA spi=%s.\n";
            v22 = 18;
            goto LABEL_40;
          }
        }
        else if (dword_10008BA20)
        {
          log = ne_log_obj(0);
          v23 = os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT);
          v16 = 0;
          if (v23)
          {
            v24 = bswap32(*(_DWORD *)(v11 + 4));
            *(_DWORD *)buf = 67109120;
            LODWORD(v36[0]) = v24;
            _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, "Unknown IPsec-SA spi=%u, hmmmm?\n", buf, 8u);
            v16 = 0;
          }
        }
      }
      v25 = (unsigned __int8 *)v13;
      v26 = v16;
      v27 = sub_100040B7C(*(_DWORD *)(qword_10008B848 + 32), *(_BYTE *)(v6 + 3), 0, v12, v25, *(_DWORD *)(v11 + 4));
      if (v26)
      {
        sub_100026C5C(v26);
        v27 = sub_10004A9EC(v26);
      }
      if (!dword_10008BA20)
        goto LABEL_14;
      v28 = ne_log_obj(v27);
      if (!os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
        goto LABEL_14;
      v29 = bswap32(*(_DWORD *)(v11 + 4));
      *(_DWORD *)buf = 67109120;
      LODWORD(v36[0]) = v29;
      v20 = v28;
      v21 = "purged IPsec-SA spi=%u.\n";
      v22 = 8;
LABEL_40:
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, v21, buf, v22);
      goto LABEL_14;
    }
LABEL_41:
    sub_10003F318(v5);
    if (dword_10008BA20)
    {
      v31 = ne_log_obj(v30);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        sub_100023E84(a1, *(_DWORD *)(a1 + 84));
        *(_DWORD *)buf = 136315138;
        v36[0] = &xmmword_100088748;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "purged ISAKMP-SA spi=%s.\n", buf, 0xCu);
      }
    }
    v32 = *(unsigned int *)(a1 + 112);
    if ((_DWORD)v32)
    {
      sub_10003A6F0(v32);
      *(_DWORD *)(a1 + 112) = 0;
    }
    *(_DWORD *)(a1 + 112) = sub_10003A520(1, (uint64_t)sub_100024B18, a1);
  }
  else if (dword_10008BA20)
  {
    v33 = ne_log_obj(0);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "pfkey_dump_sadb returned nothing.\n", buf, 2u);
    }
  }
}

void sub_100026C5C(uint64_t *a1)
{
  __int128 v2;
  uint64_t v3;
  unsigned __int8 *v4;
  NSObject *v5;
  _BOOL4 v6;
  unsigned __int8 *v7;
  unsigned int v8;
  int v9;
  int v10;
  int v11;
  NSObject *v12;
  char v13;
  unsigned __int8 *v14;
  unsigned int v15;
  uint64_t v16;
  int v17;
  NSObject *v18;
  char v19;
  NSObject *v20;
  _BOOL8 v21;
  NSObject *v22;
  _BOOL8 v23;
  NSObject *v24;
  uint64_t v25;
  NSObject *v26;
  NSObject *v27;
  char v28;
  uint64_t v29;
  NSObject *v30;
  NSObject *v31;
  _DWORD v32[2];
  __int16 v33;
  int v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  _OWORD v43[17];

  if (a1 && *((_DWORD *)a1 + 62))
  {
    v2 = 0uLL;
    v42 = 0u;
    memset(v43, 0, sizeof(v43));
    v40 = 0u;
    v41 = 0u;
    v38 = 0u;
    v39 = 0u;
    v36 = 0u;
    v37 = 0u;
    v35 = 0u;
    v3 = *a1;
    v4 = (unsigned __int8 *)a1[1];
    if (dword_10008BA20)
    {
      v5 = ne_log_obj(a1);
      v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
      v2 = 0uLL;
      if (v6)
      {
        LOWORD(v32[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "generated policy, deleting it.\n", (uint8_t *)v32, 2u);
        v2 = 0uLL;
      }
    }
    v43[15] = v2;
    v43[16] = v2;
    v43[13] = v2;
    v43[14] = v2;
    v43[11] = v2;
    v43[12] = v2;
    v43[9] = v2;
    v43[10] = v2;
    v43[7] = v2;
    v43[8] = v2;
    v43[5] = v2;
    v43[6] = v2;
    v43[3] = v2;
    v43[4] = v2;
    v43[1] = v2;
    v43[2] = v2;
    v43[0] = v2;
    a1[17] = (uint64_t)v43;
    *a1 = (uint64_t)v4;
    a1[1] = v3;
    LOBYTE(v43[0]) = 1;
    v7 = (unsigned __int8 *)a1[24];
    if (v7 && (v8 = **((unsigned __int8 **)v7 + 1), v8 <= 6) && ((1 << v8) & 0x72) != 0)
    {
      if (sub_100010E6C((unint64_t *)v7, (uint64_t)&v43[8] + 8, (_BYTE *)&v43[16] + 9, (__int16 *)&v43[16] + 5, *((unsigned __int8 *)a1 + 61)))goto LABEL_72;
      v9 = **(unsigned __int8 **)(a1[24] + 8);
      if (v9 == 5)
      {
        if (sub_100027280((uint64_t)&v43[8] + 8, *a1))
          goto LABEL_72;
        v9 = **(unsigned __int8 **)(a1[24] + 8);
      }
      if (v9 == 5)
        v10 = 5;
      else
        v10 = 0;
      if (v9 == 1)
        v11 = 1;
      else
        v11 = v10;
    }
    else
    {
      if (dword_10008BA20)
      {
        v12 = ne_log_obj(v7);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v32[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Get a destination address of SP index from Phase 1 address due to no ID payloads found OR because ID type is not address.\n", (uint8_t *)v32, 2u);
        }
      }
      __memcpy_chk((char *)&v43[8] + 8, *a1, *(unsigned __int8 *)*a1, 136);
      if (BYTE9(v43[8]) == 30)
      {
        v11 = 0;
        v13 = 0x80;
      }
      else
      {
        if (BYTE9(v43[8]) != 2)
        {
          v11 = 0;
          BYTE9(v43[16]) = 0;
          goto LABEL_28;
        }
        v11 = 0;
        v13 = 32;
      }
      BYTE9(v43[16]) = v13;
    }
LABEL_28:
    v14 = (unsigned __int8 *)a1[25];
    if (v14)
    {
      v15 = **((unsigned __int8 **)v14 + 1);
      if (v15 <= 6 && ((1 << v15) & 0x72) != 0)
      {
        v16 = sub_100010E6C((unint64_t *)v14, (uint64_t)v43 + 8, (_BYTE *)&v43[16] + 8, (__int16 *)&v43[16] + 5, *((unsigned __int8 *)a1 + 61));
        if (!(_DWORD)v16)
        {
          v17 = **(unsigned __int8 **)(a1[25] + 8);
          if (v17 != 5)
          {
LABEL_35:
            if (v11 == v17 && BYTE9(v43[8]) == BYTE9(v43[0]))
            {
              a1[4] = (uint64_t)sub_10003C6F8((unsigned __int8 *)&v43[8] + 8);
              v16 = (uint64_t)sub_10003C6F8((unsigned __int8 *)v43 + 8);
              a1[5] = v16;
            }
            goto LABEL_47;
          }
          v16 = sub_100027280((uint64_t)v43 + 8, a1[1]);
          if (!(_DWORD)v16)
          {
            v17 = **(unsigned __int8 **)(a1[25] + 8);
            goto LABEL_35;
          }
        }
LABEL_72:
        a1[17] = 0;
        return;
      }
    }
    if (dword_10008BA20)
    {
      v18 = ne_log_obj(v14);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v32[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Get a source address of SP index from Phase 1 address due to no ID payloads found OR because ID type is not address.\n", (uint8_t *)v32, 2u);
      }
    }
    v16 = __memcpy_chk((char *)v43 + 8, a1[1], *(unsigned __int8 *)a1[1], 264);
    if (BYTE9(v43[0]) == 30)
    {
      v19 = 0x80;
    }
    else
    {
      if (BYTE9(v43[0]) != 2)
      {
        BYTE8(v43[16]) = 0;
        goto LABEL_47;
      }
      v19 = 32;
    }
    BYTE8(v43[16]) = v19;
LABEL_47:
    if (dword_10008BA20)
    {
      v20 = ne_log_obj(v16);
      v21 = os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT);
      if (v21)
      {
        v32[0] = 67109376;
        v32[1] = BYTE8(v43[16]);
        v33 = 1024;
        v34 = WORD5(v43[16]);
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "get src/dst address from ID payload prefixlen=%u ul_proto=%u\n", (uint8_t *)v32, 0xEu);
      }
      if (dword_10008BA20)
      {
        v22 = ne_log_obj(v21);
        v23 = os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG);
        if (v23)
          sub_10005D67C();
        if (dword_10008BA20)
        {
          v24 = ne_log_obj(v23);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
            sub_10005D600();
        }
      }
    }
    if (!WORD5(v43[16]))
      WORD5(v43[16]) = 255;
    v25 = sub_100030848((uint64_t)a1);
    if ((v25 & 0x80000000) != 0)
    {
      if (dword_10008BA20)
      {
        v27 = ne_log_obj(v25);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
          sub_10005D5D4();
      }
    }
    else if (dword_10008BA20)
    {
      v26 = ne_log_obj(v25);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v32[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "pfkey spddelete(inbound) sent.\n", (uint8_t *)v32, 2u);
      }
    }
    *a1 = v3;
    a1[1] = (uint64_t)v4;
    LOBYTE(v43[0]) = 2;
    v39 = *(_OWORD *)((char *)&v43[4] + 8);
    v40 = *(_OWORD *)((char *)&v43[5] + 8);
    v41 = *(_OWORD *)((char *)&v43[6] + 8);
    v42 = *(_OWORD *)((char *)&v43[7] + 8);
    v35 = *(_OWORD *)((char *)v43 + 8);
    v36 = *(_OWORD *)((char *)&v43[1] + 8);
    v37 = *(_OWORD *)((char *)&v43[2] + 8);
    v38 = *(_OWORD *)((char *)&v43[3] + 8);
    *(_OWORD *)((char *)&v43[3] + 8) = *(_OWORD *)((char *)&v43[11] + 8);
    *(_OWORD *)((char *)&v43[2] + 8) = *(_OWORD *)((char *)&v43[10] + 8);
    *(_OWORD *)((char *)&v43[1] + 8) = *(_OWORD *)((char *)&v43[9] + 8);
    *(_OWORD *)((char *)&v43[7] + 8) = *(_OWORD *)((char *)&v43[15] + 8);
    *(_OWORD *)((char *)&v43[6] + 8) = *(_OWORD *)((char *)&v43[14] + 8);
    *(_OWORD *)((char *)&v43[5] + 8) = *(_OWORD *)((char *)&v43[13] + 8);
    *(_OWORD *)((char *)&v43[4] + 8) = *(_OWORD *)((char *)&v43[12] + 8);
    *(_OWORD *)((char *)v43 + 8) = *(_OWORD *)((char *)&v43[8] + 8);
    *(_OWORD *)((char *)&v43[11] + 8) = v38;
    *(_OWORD *)((char *)&v43[10] + 8) = v37;
    *(_OWORD *)((char *)&v43[9] + 8) = v36;
    *(_OWORD *)((char *)&v43[8] + 8) = v35;
    *(_OWORD *)((char *)&v43[15] + 8) = v42;
    *(_OWORD *)((char *)&v43[14] + 8) = v41;
    *(_OWORD *)((char *)&v43[13] + 8) = v40;
    *(_OWORD *)((char *)&v43[12] + 8) = v39;
    v28 = BYTE8(v43[16]);
    BYTE8(v43[16]) = BYTE9(v43[16]);
    BYTE9(v43[16]) = v28;
    v29 = sub_100030848((uint64_t)a1);
    if ((v29 & 0x80000000) != 0)
    {
      if (dword_10008BA20)
      {
        v31 = ne_log_obj(v29);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
          sub_10005D5A8();
      }
    }
    else if (dword_10008BA20)
    {
      v30 = ne_log_obj(v29);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v32[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "pfkey spddelete(outbound) sent.\n", (uint8_t *)v32, 2u);
      }
    }
    goto LABEL_72;
  }
}

uint64_t sub_100027280(uint64_t a1, uint64_t a2)
{
  int v2;
  unsigned int v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;

  v2 = *(unsigned __int8 *)(a1 + 8);
  if (v2 == 255 || v2 == 254 && ((v3 = *(unsigned __int8 *)(a1 + 9), (v3 & 0xC0) == 0x80) || v3 >= 0xC0))
  {
    if (*(_BYTE *)(a2 + 1) == 30)
    {
      if (*(unsigned __int8 *)(a2 + 8) == 254 && (*(_BYTE *)(a2 + 9) & 0xC0) == 0x80)
      {
        v4 = 0;
        *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
        return v4;
      }
      if (dword_10008BA20)
      {
        v6 = ne_log_obj(a1);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
          sub_10005D6F8();
      }
    }
    else if (dword_10008BA20)
    {
      v5 = ne_log_obj(a1);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_10005D724();
    }
    return 0xFFFFFFFFLL;
  }
  return 0;
}

_QWORD *sub_10002736C(unint64_t *a1, _QWORD *a2)
{
  unint64_t *v2;
  NSObject *v4;
  int v5;
  int v6;
  unint64_t *v7;
  _QWORD *v8;
  unsigned int v10;
  _QWORD *v11;
  _QWORD *v12;
  NSObject *v13;
  uint64_t v14;
  NSObject *v15;
  NSObject *v16;
  _DWORD v17[2];
  __int16 v18;
  int v19;
  __int16 v20;
  _BOOL4 v21;

  v2 = a1;
  if ((a1[54] & 1) != 0 || !*(_DWORD *)(a1[8] + 168) || (a1 = sub_1000095F0(a1[6])) != 0)
  {
    if (dword_10008BA20)
    {
      v4 = ne_log_obj(a1);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        v5 = v2[54] & 1;
        v6 = *(_DWORD *)(v2[8] + 168);
        v7 = sub_1000095F0(v2[6]);
        v17[0] = 67109632;
        v17[1] = v5;
        v18 = 1024;
        v19 = v6;
        v20 = 1024;
        v21 = v7 != 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "failed to add initial-contact payload: rekey %d, ini-contact %d, contacted %d.\n", (uint8_t *)v17, 0x14u);
      }
    }
    return 0;
  }
  else
  {
    v10 = *(_DWORD *)(v2[8] + 24);
    v11 = sub_10003F1F8(0x18uLL);
    v8 = v11;
    if (v11)
    {
      *(_QWORD *)v11[1] = bswap32(v10) | 0x260100100000000;
      *(_OWORD *)(v11[1] + 8) = *(_OWORD *)v2;
      v12 = malloc_type_malloc(0x20uLL, 0x102004055CCDE27uLL);
      if (a2)
        *a2 = v12;
      *v12 = 0;
      v12[1] = a2;
      v12[2] = v8;
      *((_DWORD *)v12 + 6) = 11;
      if (dword_10008BA20)
      {
        v13 = ne_log_obj(v12);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v17[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "added initial-contact payload.\n", (uint8_t *)v17, 2u);
        }
      }
      v14 = sub_100009634((unsigned __int8 *)v2[6]);
      if ((_DWORD)v14 == -1)
      {
        if (dword_10008BA20)
        {
          v15 = ne_log_obj(v14);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
            sub_10005C680();
        }
      }
    }
    else if (dword_10008BA20)
    {
      v16 = ne_log_obj(0);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        sub_1000593E8();
    }
  }
  return v8;
}

void sub_10002759C(uint64_t a1, uint64_t a2, unsigned __int8 *a3, unsigned __int8 *a4, int a5)
{
  uint64_t v10;
  _DWORD *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned __int8 *v14;
  _QWORD *v15;
  uint64_t v16;
  int v17;
  int v18;
  NSObject *v19;
  NSObject *v20;
  void *v21;
  uint64_t v22;
  NSObject *v23;
  uint64_t *v24;
  char *v25;
  char *v26;
  NSObject *v27;
  uint64_t *v28;
  int v29;
  uint64_t v30;
  NSObject *v31;
  _BOOL8 v32;
  char *v33;
  NSObject *v34;
  NSObject *v35;
  int v36;
  char *v37;
  __int16 v38;
  uint64_t *v39;

  v10 = *(_QWORD *)(a2 + 8);
  v11 = sub_100038594((uint64_t)a3);
  if (!v11)
  {
    if (dword_10008BA20)
    {
      v19 = ne_log_obj(0);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        sub_10005D750();
    }
    return;
  }
  v12 = (uint64_t)v11;
  v13 = sub_100038C48((uint64_t)v11, a5);
  if (!v13)
  {
    if (dword_10008BA20)
    {
      v20 = ne_log_obj(0);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        sub_10005D77C(a5);
    }
    return;
  }
  v14 = (unsigned __int8 *)v13;
  v15 = sub_1000083E8(16);
  if (!v15)
    return;
  v16 = (uint64_t)v15;
  *v15 = *(_QWORD *)v10;
  v15[8] = v12;
  sub_100038B74(v12);
  *(_BYTE *)(v16 + 82) = 0;
  *(_QWORD *)(v16 + 20) = 1;
  v17 = *v14;
  *(_BYTE *)(v16 + 81) = v17;
  *(_BYTE *)(v16 + 80) = *(_BYTE *)(v10 + 17);
  *(_DWORD *)(v16 + 84) = 0;
  if (v17 == 2)
  {
    v18 = 5440;
  }
  else
  {
    if (v17 != 4)
    {
LABEL_19:
      sub_10000849C(v16);
      return;
    }
    v18 = 5504;
  }
  sub_100003774((int *)(v16 + 16), v18);
  v21 = sub_1000448B4();
  *(_QWORD *)(v16 + 408) = v21;
  if (!v21)
    goto LABEL_19;
  *(_DWORD *)(v16 + 100) = 0;
  *(_QWORD *)(v16 + 104) = 0;
  *(_QWORD *)(v16 + 72) = 0;
  if (sub_10003D25C((uint64_t)a4) == *(unsigned __int16 *)(qword_10008B848 + 18))
    *(_DWORD *)(v16 + 96) |= 8u;
  if ((sub_1000225F8(v16, v12, a3, a4) & 0x80000000) == 0)
  {
    v22 = sub_10004B29C(a1, v16);
    if ((_DWORD)v22)
      goto LABEL_19;
    if (dword_10008BA20)
    {
      v23 = ne_log_obj(v22);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
        sub_10005C5F4();
    }
    v24 = sub_10003C570(*(const sockaddr **)(v16 + 56));
    v25 = strdup((const char *)v24);
    if (!v25)
    {
      if (dword_10008BA20)
      {
        v35 = ne_log_obj(0);
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
          sub_10005C4A8();
      }
      exit(1);
    }
    v26 = v25;
    if (dword_10008BA20)
    {
      v27 = ne_log_obj(v25);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        v28 = sub_10003C570(*(const sockaddr **)(v16 + 48));
        v36 = 136315394;
        v37 = v26;
        v38 = 2080;
        v39 = v28;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "respond new phase 1 negotiation: %s<=>%s\n", (uint8_t *)&v36, 0x16u);
      }
      v29 = dword_10008BA20;
      free(v26);
      if (v29)
      {
        v31 = ne_log_obj(v30);
        v32 = os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT);
        if (v32)
        {
          v33 = sub_10003DAB8(a5);
          v36 = 136315138;
          v37 = v33;
          _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "begin %s mode.\n", (uint8_t *)&v36, 0xCu);
        }
        if (dword_10008BA20)
        {
          v34 = ne_log_obj(v32);
          if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v36) = 0;
            _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "IPSec Phase 1 started (Initiated by peer).\n", (uint8_t *)&v36, 2u);
          }
        }
      }
    }
    else
    {
      free(v25);
    }
    sub_100021828(a2, a3, a4);
  }
}

void sub_100027948(uint64_t a1, _QWORD *a2, const sockaddr *a3, uint64_t a4)
{
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  NSObject *v10;
  _BOOL8 v11;
  NSObject *v12;
  uint64_t *v13;
  NSObject *v14;
  int v15;
  uint64_t *v16;

  if (sub_100015210(a1, a2) == 1)
  {
    v7 = sub_100015534(a1);
    if (v7)
    {
      v8 = v7;
      v9 = sub_10000978C(a3, a4, (uint64_t)v7);
      if ((int)v9 < 1)
      {
        sub_100021828(v8, a3, a4);
        sub_10003F318(v8);
      }
      else
      {
        if (dword_10008BA20)
        {
          v10 = ne_log_obj(v9);
          v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
          if (v11)
          {
            v15 = 136315138;
            v16 = sub_10003C570(a3);
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Received (reassembled) retransmitted packet from %s.\n", (uint8_t *)&v15, 0xCu);
          }
          if (dword_10008BA20)
          {
            v12 = ne_log_obj(v11);
            if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
            {
              v13 = sub_10003C570(a3);
              v15 = 136315138;
              v16 = v13;
              _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "the reassembled packet is retransmitted by %s.\n", (uint8_t *)&v15, 0xCu);
            }
          }
        }
        sub_10003F318(v8);
      }
    }
    else if (dword_10008BA20)
    {
      v14 = ne_log_obj(0);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        sub_10005D7EC();
    }
  }
}

void sub_100027B10(uint64_t a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  _BYTE *v7;
  uint64_t v8;
  uint64_t *v9;
  unsigned __int8 *v10;
  int v11;
  unsigned __int8 *v13;
  int v14;
  uint64_t v15;
  NSObject *v16;
  uint64_t *v17;
  char *v18;
  char *v19;
  NSObject *v20;
  uint64_t *v21;
  int v22;
  uint64_t v23;
  NSObject *v24;
  NSObject *v25;
  NSObject *v26;
  NSObject *v27;
  NSObject *v28;
  int v29;
  char *v30;
  __int16 v31;
  uint64_t *v32;

  v4 = a2[1];
  v5 = sub_100046728((_QWORD *)a1);
  if ((_DWORD)v5)
  {
    if (dword_10008BA20)
    {
      v6 = ne_log_obj(v5);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        sub_10005D844();
    }
    return;
  }
  v7 = sub_100008D90(16, 0);
  if (v7)
  {
    v8 = (uint64_t)v7;
    *((_WORD *)v7 + 30) = 4097;
    sub_100003774((int *)v7 + 14, 6592);
    *(_BYTE *)(v8 + 105) = *(_BYTE *)(v4 + 19);
    *(_DWORD *)(v8 + 108) = *(_DWORD *)(v4 + 20);
    *(_DWORD *)(v8 + 100) = sub_100030D60();
    v9 = sub_10002DA88(a1, *(_DWORD *)(v8 + 108));
    *(_QWORD *)(v8 + 240) = v9;
    if (!v9)
      goto LABEL_38;
    v10 = (unsigned __int8 *)sub_10003C6F8(*(unsigned __int8 **)(a1 + 48));
    *(_QWORD *)(v8 + 8) = v10;
    if (!v10)
      goto LABEL_38;
    v11 = v10[1];
    if (v11 != 2 && v11 != 30)
    {
      if (!dword_10008BA20)
        goto LABEL_38;
      v26 = ne_log_obj(v10);
      if (!os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        goto LABEL_38;
      goto LABEL_37;
    }
    v13 = (unsigned __int8 *)sub_10003C6F8(*(unsigned __int8 **)(a1 + 56));
    *(_QWORD *)v8 = v13;
    if (!v13)
      goto LABEL_38;
    v14 = v13[1];
    if (v14 != 2 && v14 != 30)
    {
      if (!dword_10008BA20)
        goto LABEL_38;
      v27 = ne_log_obj(v13);
      if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        goto LABEL_38;
LABEL_37:
      sub_10005C620();
LABEL_38:
      sub_100008F90(v8);
      return;
    }
    v15 = sub_10004B4EC(a1, (_QWORD *)v8);
    if (!(_DWORD)v15)
    {
      *(_BYTE *)(v8 + 264) &= ~2u;
      *(_OWORD *)(v8 + 16) = *(_OWORD *)(a1 + 28);
      if (dword_10008BA20)
      {
        v16 = ne_log_obj(v15);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
          sub_10005C5F4();
      }
      v17 = sub_10003C570(*(const sockaddr **)v8);
      v18 = strdup((const char *)v17);
      if (!v18)
      {
        if (dword_10008BA20)
        {
          v28 = ne_log_obj(0);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
            sub_10005C4A8();
        }
        exit(1);
      }
      v19 = v18;
      if (dword_10008BA20)
      {
        v20 = ne_log_obj(v18);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          v21 = sub_10003C570(*(const sockaddr **)(v8 + 8));
          v29 = 136315394;
          v30 = v19;
          v31 = 2080;
          v32 = v21;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "respond new phase 2 negotiation: %s<=>%s\n", (uint8_t *)&v29, 0x16u);
        }
        v22 = dword_10008BA20;
        free(v19);
        if (v22)
        {
          v24 = ne_log_obj(v23);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(v29) = 0;
            _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "IPSec Phase 2 started (Initiated by peer).\n", (uint8_t *)&v29, 2u);
          }
        }
      }
      else
      {
        free(v18);
      }
      if (!sub_100003C48(v8, a2))
        sub_100048B0C(1, 1, 0, v8);
    }
  }
  else if (dword_10008BA20)
  {
    v25 = ne_log_obj(0);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      sub_10005D818();
  }
}

__int128 *sub_100027E98(uint64_t *a1, uint64_t a2)
{
  return sub_100023E84(*a1, *(_DWORD *)(a2 + 108));
}

void sub_100027EC8(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0x16u);
}

__int128 *sub_100027ED4(uint64_t a1)
{
  return sub_100023E84(a1, *(_DWORD *)(a1 + 84));
}

char *sub_100027EE0(const sockaddr **a1)
{
  return sub_10003C8A0(*a1);
}

uint64_t *sub_100027EEC(uint64_t a1, const sockaddr *a2)
{
  return sub_10003C570(a2);
}

void sub_100027F0C()
{
  _QWORD *v0;
  uint64_t v1;

  qword_10008B848 = (uint64_t)malloc_type_calloc(1uLL, 0x140uLL, 0x10B004027E15F99uLL);
  if (!qword_10008B848)
    sub_10005D870();
  sub_100027F78();
  v0 = (_QWORD *)qword_10008B848;
  *(_DWORD *)(qword_10008B848 + 28) = -1;
  *v0 = "/etc/racoon/racoon.conf";
  v1 = qword_10008B848;
  *(_QWORD *)(qword_10008B848 + 96) = 0;
  *(_QWORD *)(v1 + 104) = v1 + 96;
}

double sub_100027F78()
{
  uint64_t v0;
  double result;

  v0 = qword_10008B848;
  *(_QWORD *)(qword_10008B848 + 8) = 0;
  *(_DWORD *)(v0 + 112) = 1;
  *(_DWORD *)(v0 + 16) = 294912500;
  *(_DWORD *)(v0 + 24) = 2;
  *(_OWORD *)(v0 + 248) = xmmword_10006A090;
  *(_OWORD *)(v0 + 264) = xmmword_10006A0A0;
  *(_QWORD *)(v0 + 280) = 0x1E0000001ELL;
  *(_QWORD *)&result = 16;
  *(_QWORD *)(v0 + 304) = 16;
  *(_DWORD *)(v0 + 312) = 1;
  *(_DWORD *)(v0 + 288) = 20;
  *(_QWORD *)(v0 + 80) = *(_DWORD *)(v0 + 80) & 0xFFFFFFEE | 0x10;
  return result;
}

void sub_100027FF0()
{
  uint64_t v0;
  uint64_t i;
  void *v2;
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;

  sub_100027F78();
  sub_100006ED4();
  v0 = qword_10008B848;
  for (i = 136; i != 176; i += 8)
  {
    v2 = *(void **)(v0 + i);
    if (v2)
    {
      free(v2);
      *(_QWORD *)(qword_10008B848 + i) = 0;
      v0 = qword_10008B848;
    }
  }
  do
  {
    v3 = qword_10008B848;
    v4 = *(_QWORD **)(qword_10008B848 + i);
    if (v4)
    {
      sub_10003F318(v4);
      v3 = qword_10008B848;
    }
    *(_QWORD *)(v3 + i) = 0;
    i += 8;
  }
  while (i != 248);
  v5 = *(_QWORD **)(qword_10008B848 + 296);
  if (v5)
  {
    sub_10003F318(v5);
    *(_QWORD *)(qword_10008B848 + 296) = 0;
  }
}

void sub_10002807C()
{
  qword_10008B850 = qword_10008B848;
  qword_10008B848 = 0;
  sub_100027F0C();
}

void sub_100028094()
{
  sub_100027FF0();
  free((void *)qword_10008B848);
  qword_10008B848 = qword_10008B850;
  qword_10008B850 = 0;
}

size_t *sub_1000280CC(_QWORD *a1)
{
  NSObject *v2;
  char *v3;
  char *v4;
  size_t *v5;
  NSObject *v6;

  if (dword_10008BA20)
  {
    v2 = ne_log_obj(a1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
      sub_10005D8B4();
  }
  v3 = (char *)malloc_type_calloc(1uLL, *a1 - 3, 0x681A2B4uLL);
  if (v3)
  {
    v4 = v3;
    memcpy(v3, (const void *)(a1[1] + 4), *a1 - 4);
    v4[*a1 - 4] = 0;
    v5 = sub_1000281AC(v4, *(_DWORD *)a1 - 4);
    free(v4);
  }
  else
  {
    if (dword_10008BA20)
    {
      v6 = ne_log_obj(0);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        sub_10005D888();
    }
    return 0;
  }
  return v5;
}

size_t *sub_1000281AC(const char *a1, int a2)
{
  NSObject *v4;
  FILE *v5;
  NSObject *v6;
  size_t *v7;
  FILE *v8;
  size_t v9;
  char v10;
  char *v11;
  int v12;
  __darwin_ct_rune_t v13;
  __darwin_ct_rune_t v14;
  size_t v16;
  char *v18;
  size_t *v19;
  NSObject *v20;
  NSObject *v21;
  size_t i;
  char __s1[1024];

  i = 0;
  if (dword_10008BA20)
  {
    v4 = ne_log_obj(a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
      sub_10005D990();
  }
  v5 = (FILE *)sub_100039B38(*(const char **)(qword_10008B848 + 144), 1);
  if ((_DWORD)v5 || (v5 = fopen(*(const char **)(qword_10008B848 + 144), "r")) == 0)
  {
    if (dword_10008BA20)
    {
      v6 = ne_log_obj(v5);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        sub_10005D8E0(v6);
    }
    return 0;
  }
  v8 = v5;
  if (!fgets(__s1, 1024, v5))
    goto LABEL_31;
  v9 = a2;
  while (2)
  {
    v10 = __s1[0];
    if (!__s1[0] || __s1[0] == 35)
      goto LABEL_30;
    v11 = __s1;
    while ((v10 & 0x80) == 0)
    {
      if ((_DefaultRuneLocale.__runetype[v10] & 0x4000) != 0)
        goto LABEL_21;
LABEL_19:
      v12 = *++v11;
      v10 = v12;
      if (!v12)
        goto LABEL_30;
    }
    if (!__maskrune(v10, 0x4000uLL))
      goto LABEL_19;
LABEL_21:
    if (!*v11)
      goto LABEL_30;
    *v11 = 0;
    do
    {
      while (1)
      {
        v14 = *++v11;
        v13 = v14;
        if (v14 < 0)
          break;
        if ((_DefaultRuneLocale.__runetype[v13] & 0x4000) == 0)
          goto LABEL_27;
      }
    }
    while (__maskrune(v13, 0x4000uLL));
LABEL_27:
    if (!v13 || strncmp(__s1, a1, v9) || __s1[v9])
    {
LABEL_30:
      if (!fgets(__s1, 1024, v8))
        goto LABEL_31;
      continue;
    }
    break;
  }
  v16 = 0;
  for (i = 0; v11[v16] && v11[v16] != 10; i = v16)
    ++v16;
  v11[v16] = 0;
  if (strncmp(v11, "0x", 2uLL))
  {
    v18 = 0;
    goto LABEL_43;
  }
  v11 = sub_10003D478(v11 + 2, 16, &i);
  v18 = v11;
  if (!v11)
  {
    if (dword_10008BA20)
    {
      v21 = ne_log_obj(0);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        sub_10005D888();
    }
    goto LABEL_31;
  }
LABEL_43:
  v19 = sub_10003F1F8(i);
  if (!v19)
  {
    if (dword_10008BA20)
    {
      v20 = ne_log_obj(0);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        sub_10005D964();
    }
LABEL_31:
    v7 = 0;
    goto LABEL_32;
  }
  v7 = v19;
  memcpy((void *)v19[1], v11, *v19);
  if (v18)
    free(v18);
LABEL_32:
  fclose(v8);
  return v7;
}

size_t *sub_100028484(sockaddr *a1)
{
  NSObject *v2;
  int v3;
  char v5[32];
  char __s[1025];

  if (dword_10008BA20)
  {
    v2 = ne_log_obj(a1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
      sub_10005D9BC();
  }
  if (getnameinfo(a1, a1->sa_len, __s, 0x401u, v5, 0x20u, 10))
  {
    __strlcpy_chk(__s, "(invalid)", 1025, 1025);
    __strlcpy_chk(v5, "(invalid)", 32, 32);
  }
  v3 = strlen(__s);
  return sub_1000281AC(__s, v3);
}

void sub_100028574(char *__str, int a2, int a3, const char *a4)
{
  const char *v5;
  const char *v6;
  uint64_t v7;
  NSObject *v8;

  if (*a4 == 47)
  {
    v5 = (const char *)&unk_10007E079;
    v6 = (const char *)&unk_10007E079;
  }
  else
  {
    v6 = *(const char **)(qword_10008B848 + 8 * a3 + 136);
    v5 = "/";
  }
  v7 = snprintf(__str, a2, "%s%s%s", v6, v5, a4);
  if (dword_10008BA20)
  {
    v8 = ne_log_obj(v7);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      sub_10005D9E8((uint64_t)__str, v8);
  }
}

uint64_t sub_10002861C(unsigned int a1)
{
  if (a1 > 2)
    return 0xFFFFFFFFLL;
  else
    return dword_10006A0B8[a1];
}

uint64_t sub_10002863C(int a1)
{
  if (a1)
    return 0xFFFFFFFFLL;
  else
    return 1;
}

uint64_t start(int a1, char **a2)
{
  uint64_t v4;
  uint64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  NSObject *v9;
  _BOOL8 v10;
  NSObject *v11;
  _BOOL8 v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  NSObject *v19;
  uint64_t v20;
  NSObject *v21;
  uint64_t v22;
  NSObject *v23;
  NSObject *v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  NSObject *v29;
  NSObject *v30;
  NSObject *v31;
  char *__envp;
  _BYTE buf[24];
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  uint64_t v49;

  sub_10004F48C();
  sub_100034328();
  v4 = geteuid();
  if ((_DWORD)v4)
    sub_10005DC24(v4);
  umask(0x3Fu);
  v5 = umask(0x3Fu);
  if ((_DWORD)v5 != 63)
    sub_10005DC10(v5);
  sub_100027F0C();
  sub_100038C38();
  sub_10002928C();
  sub_10003EE24();
  v6 = strrchr(*a2, 47);
  qword_10008B9E8 = (uint64_t)v6;
  if (v6)
    v7 = v6 + 1;
  else
    v7 = *a2;
  qword_10008B9E8 = (uint64_t)v7;
  while (1)
  {
    while (1)
    {
      while (1)
      {
        while (1)
        {
          v8 = getopt(a1, a2, "dDLFp:P:a:f:l:vsZBCx46");
          if ((int)v8 <= 89)
            break;
          if ((int)v8 > 101)
          {
            switch((int)v8)
            {
              case 'p':
                *(_WORD *)(qword_10008B848 + 16) = atoi(optarg);
                continue;
              case 'q':
              case 'r':
              case 't':
              case 'u':
              case 'w':
                goto LABEL_80;
              case 's':
                *(_DWORD *)(qword_10008B848 + 80) &= ~0x10u;
                continue;
              case 'v':
                ++dword_100088284;
                continue;
              case 'x':
                byte_10008878C = 1;
                continue;
              default:
                if ((_DWORD)v8 == 102)
                {
                  *(_QWORD *)qword_10008B848 = optarg;
                }
                else
                {
                  if ((_DWORD)v8 != 108)
                    goto LABEL_80;
                  *(_QWORD *)(qword_10008B848 + 128) = optarg;
                }
                break;
            }
          }
          else
          {
            switch((_DWORD)v8)
            {
              case 'Z':
                puts("Local test mode.");
                dword_10008B858 = 1;
                break;
              case 'd':
                sub_100033E38(7);
                break;
              case 'a':
                fprintf(__stderrp, "%s: the option is disabled in the configuration\n", (const char *)qword_10008B9E8);
                goto LABEL_79;
              default:
LABEL_80:
                sub_100028EC8();
            }
          }
        }
        if ((int)v8 <= 66)
          break;
        switch((int)v8)
        {
          case 'C':
            ++dword_100088788;
            continue;
          case 'D':
            if (dword_10008B9F0)
              goto LABEL_78;
            dword_10008B860 = 1;
            continue;
          case 'E':
          case 'G':
          case 'H':
          case 'I':
          case 'J':
          case 'K':
            goto LABEL_80;
          case 'F':
            if (dword_10008B860)
            {
LABEL_78:
              fwrite("-D and -F are mutually exclusive\n", 0x21uLL, 1uLL, __stderrp);
              goto LABEL_79;
            }
            puts("Foreground mode.");
            dword_10008B9F0 = 1;
            break;
          case 'L':
            dword_10008B9F4 = 1;
            continue;
          default:
            if ((_DWORD)v8 != 80)
              goto LABEL_80;
            *(_WORD *)(qword_10008B848 + 18) = atoi(optarg);
            continue;
        }
      }
      if ((_DWORD)v8 != 52)
        break;
      *(_DWORD *)(qword_10008B848 + 24) = 2;
    }
    if ((_DWORD)v8 != 54)
      break;
    *(_DWORD *)(qword_10008B848 + 24) = 30;
  }
  if ((_DWORD)v8 != -1 || optind != a1)
    goto LABEL_80;
  if (dword_10008BA20)
  {
    v9 = ne_log_obj(v8);
    v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
    if (v10)
    {
      *(_DWORD *)buf = 67109632;
      *(_DWORD *)&buf[4] = getpid();
      *(_WORD *)&buf[8] = 1024;
      *(_DWORD *)&buf[10] = getppid();
      *(_WORD *)&buf[14] = 1024;
      *(_DWORD *)&buf[16] = dword_10008B860;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "racoon started: pid=%d  started by: %d, launchdlaunched %d\n", buf, 0x14u);
    }
    if (dword_10008BA20)
    {
      v11 = ne_log_obj(v10);
      v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
      if (v12)
      {
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = aRacoonIpsecToo_0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%s\n", buf, 0xCu);
      }
      if (dword_10008BA20)
      {
        v13 = ne_log_obj(v12);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          v14 = *(_QWORD *)qword_10008B848;
          *(_DWORD *)buf = 136315138;
          *(_QWORD *)&buf[4] = v14;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Reading configuration from \"%s\"\n", buf, 0xCu);
        }
      }
    }
  }
  v15 = sub_10002EC60();
  if ((v15 & 0x80000000) != 0)
    sub_10005DA5C(v15);
  word_10008878E = *(_WORD *)(qword_10008B848 + 16);
  v16 = sub_100052524(v15);
  if ((_DWORD)v16)
    sub_10005DBFC(v16);
  v17 = qword_10008B848;
  *(_WORD *)(qword_10008B848 + 16) = word_10008878E;
  if (!*(_QWORD *)(v17 + 128) && !byte_10008BA24)
    sub_100033D88(*(char **)(v17 + 168));
  *(_DWORD *)buf = 4500;
  result = sysctlbyname("net.inet.ipsec.esp_port", 0, 0, buf, 4uLL);
  if ((_DWORD)result)
    sub_10005DBD0();
  if (!(_DWORD)xmmword_10008BE38 || qword_10008BE90 || (result = sub_100044BE4(255), !(_DWORD)result))
  {
    if (dword_100088788)
      sub_100038D28();
    if (dword_10008B9F0)
    {
      close(0);
      goto LABEL_60;
    }
    if ((byte_10008878C & 1) != 0 || !dword_10008B860)
    {
      if (!byte_10008878C)
      {
        v49 = 0;
        v48 = 0u;
        v47 = 0u;
        v46 = 0u;
        v45 = 0u;
        v44 = 0u;
        v43 = 0u;
        v42 = 0u;
        v41 = 0u;
        v40 = 0u;
        v39 = 0u;
        v38 = 0u;
        v37 = 0u;
        v36 = 0u;
        v35 = 0u;
        v34 = 0u;
        *(_OWORD *)&buf[8] = 0u;
        __envp = 0;
        if (a1 < 33)
        {
          if (daemon(0, 0) < 0)
            sub_10005DAC8();
          v25 = setuid(0);
          if ((_DWORD)v25)
          {
            if (dword_10008BA20)
            {
              v30 = ne_log_obj(v25);
              if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
                sub_10005DBA4();
            }
          }
          else
          {
            v26 = setgid(0);
            if ((_DWORD)v26)
            {
              if (dword_10008BA20)
              {
                v31 = ne_log_obj(v26);
                if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
                  sub_10005DB78();
              }
            }
            else
            {
              *(_QWORD *)buf = "/usr/sbin/racoon";
              if (a1 >= 2)
                memcpy(&buf[8], a2 + 1, 8 * (a1 - 1));
              v27 = &buf[8 * a1];
              *v27 = "-x";
              v27[1] = 0;
              v28 = execve("/usr/sbin/racoon", (char *const *)buf, &__envp);
              if (dword_10008BA20)
              {
                v29 = ne_log_obj(v28);
                if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
                  sub_10005DAEC(v29);
              }
            }
          }
        }
        else if (dword_10008BA20)
        {
          v24 = ne_log_obj(result);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
            sub_10005DA9C();
        }
LABEL_79:
        exit(1);
      }
      v22 = atexit((void (*)(void))sub_100028DF4);
      if ((v22 & 0x80000000) != 0)
      {
        if (dword_10008BA20)
        {
          v23 = ne_log_obj(v22);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
LABEL_70:
            sub_10005DA70();
        }
      }
    }
    else
    {
      if (dword_10008BA20)
      {
        v19 = ne_log_obj(result);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "racoon launched by launchd.\n", buf, 2u);
        }
      }
      byte_10008878C = 1;
      v20 = atexit((void (*)(void))sub_100028DF4);
      if ((v20 & 0x80000000) != 0)
      {
        if (dword_10008BA20)
        {
          v21 = ne_log_obj(v20);
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
            goto LABEL_70;
        }
      }
    }
LABEL_60:
    sub_10004F73C();
    sub_10003A814();
  }
  return result;
}

uint64_t sub_100028DF4()
{
  uint64_t result;
  const char *v1;
  char v2[1024];

  result = getpid();
  if (dword_10008B85C == (_DWORD)result)
  {
    v1 = *(const char **)(qword_10008B848 + 160);
    if (v1)
    {
      if (*v1 != 47)
      {
        __strlcat_chk(v2, "/var/run/", 1024, 1024);
        __strlcat_chk(v2, *(_QWORD *)(qword_10008B848 + 160), 1024, 1024);
        return unlink(v2);
      }
    }
    else
    {
      v1 = "/var/run/racoon.pid";
    }
    __strlcpy_chk(v2, v1, 1024, 1024);
    return unlink(v2);
  }
  return result;
}

void sub_100028EC8()
{
  printf("usage: racoon [-BdDFvs%s] %s[-f (file)] [-l (file)] [-p (port)]\n", "46", (const char *)&unk_10007E079);
  puts("   -d: debug level, more -d will generate more debug message.");
  puts("   -D: started by LaunchD (implies daemon mode).");
  puts("   -C: dump parsed config file.");
  puts("   -L: include location in debug messages");
  puts("   -F: run in foreground, do not become daemon.");
  puts("   -v: be more verbose");
  puts("   -s: override enable auto exit");
  puts("   -4: IPv4 mode.");
  puts("   -6: IPv6 mode.");
  puts("   -f: pathname for configuration file.");
  puts("   -l: pathname for log file.");
  printf("   -p: port number for isakmp (default: %d).\n", 500);
  printf("   -P: port number for NAT-T (default: %d).\n", 4500);
  exit(1);
}

void sub_100028FA8(uint64_t a1, const char *a2)
{
  errx(1, a2);
}

uint64_t sub_100028FB0(uint64_t a1, uint64_t a2)
{
  uint64_t i;

  if (a2)
  {
    for (i = 0; i != a2; ++i)
    {
      if (i && (i & 0x1F) == 0)
        putchar(10);
      if ((i & 3) == 0)
        putchar(32);
      printf("%02x", *(unsigned __int8 *)(a1 + i));
    }
  }
  putchar(10);
  return 0;
}

const char *sub_10002903C(unsigned int a1, int a2)
{
  _BYTE *v2;
  int v5;
  uint64_t v6;

  if (a2 > 128)
    return "Failed to convert.";
  v2 = byte_100088790;
  __memset_chk(byte_100088790, 48, a2, 129);
  byte_100088790[a2] = 0;
  v5 = a2 - 1;
  if (a2 >= 1)
  {
    v6 = 0;
    do
    {
      if (((a1 >> v6) & 1) != 0)
        byte_100088790[v5] = 49;
      ++v6;
      --v5;
    }
    while (a2 != v6);
  }
  return v2;
}

char *sub_1000290CC(char *a1, uint64_t a2, uint64_t a3)
{
  strrchr(a1, 47);
  if (a3)
    snprintf(byte_100088811, 0x400uLL, "%s:%d:%s()");
  else
    snprintf(byte_100088811, 0x400uLL, "%s:%d");
  return byte_100088811;
}

uint64_t sub_100029154(const char *a1)
{
  stat v2;

  memset(&v2, 0, sizeof(v2));
  if (stat(a1, &v2))
    return 0xFFFFFFFFLL;
  else
    return LODWORD(v2.st_size);
}

double sub_100029198(uint64_t a1, uint64_t a2)
{
  int v2;
  int v3;
  uint64_t v4;

  v2 = *(_DWORD *)(a2 + 8);
  v3 = *(_DWORD *)(a1 + 8);
  if (v2 >= v3)
  {
    v4 = -*(_QWORD *)a1;
  }
  else
  {
    v2 += 1000000;
    v4 = ~*(_QWORD *)a1;
  }
  return (double)(v2 - v3) / 1000000.0 + (double)(*(_QWORD *)a2 + v4);
}

char *sub_1000291E4(char *a1, uint64_t a2)
{
  uint64_t v3;
  int v4;
  char *v5;
  __darwin_ct_rune_t v6;
  __darwin_ct_rune_t v7;

  if (a2)
  {
    v3 = a2;
    v4 = 0;
    v5 = a1;
    while (1)
    {
      v7 = *v5++;
      v6 = v7;
      if (v7 < 0)
      {
        if (__maskrune(v6, 0x800uLL))
          goto LABEL_10;
      }
      else if ((_DefaultRuneLocale.__runetype[v6] & 0x800) != 0)
      {
        goto LABEL_10;
      }
      if (!v4 || a1[v4 - 1] == 32)
        goto LABEL_11;
      LOBYTE(v6) = 32;
LABEL_10:
      a1[v4++] = v6;
LABEL_11:
      if (!--v3)
        goto LABEL_14;
    }
  }
  v4 = 0;
LABEL_14:
  a1[v4] = 0;
  return a1;
}

uint64_t sub_10002928C()
{
  uint64_t v1;
  void *v2;

  v1 = 0;
  v2 = 0;
  v2 = sub_10003D478("FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD129024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DDEF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245E485B576 625E7EC6 F44C42E9 A63A3620 FFFFFFFF FFFFFFFF", 16, &v1);
  *(_OWORD *)&qword_10008B990 = 0u;
  unk_10008B9A0 = 0u;
  qword_10008B9B0 = 0;
  qword_10008B988 = 0x100000001;
  qword_10008B990 = (uint64_t)sub_10003F34C((uint64_t)&v1);
  qword_10008B998 = 2;
  free(v2);
  v1 = 0;
  v2 = 0;
  v2 = sub_10003D478("FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD129024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DDEF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7EDEE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE65381FFFFFFFF FFFFFFFF", 16, &v1);
  *(_OWORD *)&qword_10008B870 = 0u;
  unk_10008B880 = 0u;
  qword_10008B890 = 0;
  qword_10008B868 = 0x100000002;
  qword_10008B870 = (uint64_t)sub_10003F34C((uint64_t)&v1);
  qword_10008B878 = 2;
  free(v2);
  v1 = 0;
  v2 = 0;
  v2 = sub_10003D478("FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD129024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DDEF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7EDEE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE45B3DC2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8 FD24CF5F83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D670C354E 4ABC9804 F1746C08 CA237327 FFFFFFFF FFFFFFFF", 16, &v1);
  *(_OWORD *)&qword_10008B8A0 = 0u;
  *(_OWORD *)algn_10008B8B0 = 0u;
  qword_10008B8C0 = 0;
  qword_10008B898 = 0x100000005;
  qword_10008B8A0 = (uint64_t)sub_10003F34C((uint64_t)&v1);
  qword_10008B8A8 = 2;
  free(v2);
  v1 = 0;
  v2 = 0;
  v2 = sub_10003D478("FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD129024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DDEF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7EDEE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE45B3DC2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8 FD24CF5F83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3BE39E772C 180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9DE2BCBF6 95581718 3995497C EA956AE5 15D22618 98FA051015728E5A 8AACAA68 FFFFFFFF FFFFFFFF", 16, &v1);
  *(_OWORD *)&qword_10008B8D0 = 0u;
  unk_10008B8E0 = 0u;
  qword_10008B8F0 = 0;
  qword_10008B8C8 = 0x10000000ELL;
  qword_10008B8D0 = (uint64_t)sub_10003F34C((uint64_t)&v1);
  qword_10008B8D8 = 2;
  free(v2);
  v1 = 0;
  v2 = 0;
  v2 = sub_10003D478("FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD129024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DDEF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7EDEE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE45B3DC2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8 FD24CF5F83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3BE39E772C 180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9DE2BCBF6 95581718 3995497C EA956AE5 15D22618 98FA051015728E5A 8AAAC42D AD33170D 04507A33 A85521AB DF1CBA64ECFB8504 58DBEF0A 8AEA7157 5D060C7D B3970F85 A6E1E4C7ABF5AE8C DB0933D7 1E8C94E0 4A25619D CEE3D226 1AD2EE6BF12FFA06 D98A0864 D8760273 3EC86A64 521F2B18 177B200CBBE11757 7A615D6C 770988C0 BAD946E2 08E24FA0 74E5AB3143DB5BFC E0FD108E 4B82D120 A93AD2CA FFFFFFFF FFFFFFFF", 16, &v1);
  *(_OWORD *)&qword_10008B900 = 0u;
  *(_OWORD *)algn_10008B910 = 0u;
  qword_10008B920 = 0;
  qword_10008B8F8 = 0x10000000FLL;
  qword_10008B900 = (uint64_t)sub_10003F34C((uint64_t)&v1);
  qword_10008B908 = 2;
  free(v2);
  v1 = 0;
  v2 = 0;
  v2 = sub_10003D478("FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD129024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DDEF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7EDEE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE45B3DC2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8 FD24CF5F83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3BE39E772C 180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9DE2BCBF6 95581718 3995497C EA956AE5 15D22618 98FA051015728E5A 8AAAC42D AD33170D 04507A33 A85521AB DF1CBA64ECFB8504 58DBEF0A 8AEA7157 5D060C7D B3970F85 A6E1E4C7ABF5AE8C DB0933D7 1E8C94E0 4A25619D CEE3D226 1AD2EE6BF12FFA06 D98A0864 D8760273 3EC86A64 521F2B18 177B200CBBE11757 7A615D6C 770988C0 BAD946E2 08E24FA0 74E5AB3143DB5BFC E0FD108E 4B82D120 A9210801 1A723C12 A787E6D788719A10 BDBA5B26 99C32718 6AF4E23C 1A946834 B6150BDA2583E9CA 2AD44CE8 DBBBC2DB 04DE8EF9 2E8EFC14 1FBECAA6287C5947 4E6BC05D 99B2964F A090C3A2 233BA186 515BE7ED1F612970 CEE2D7AF B81BDD76 2170481C D0069127 D5B05AA993B4EA98 8D8FDDC1 86FFB7DC 90A6C08F 4DF435C9 34063199FFFFFFFF FFFFFFFF", 16, &v1);
  *(_OWORD *)&qword_10008B930 = 0u;
  unk_10008B940 = 0u;
  qword_10008B950 = 0;
  qword_10008B928 = 0x100000010;
  qword_10008B930 = (uint64_t)sub_10003F34C((uint64_t)&v1);
  qword_10008B938 = 2;
  free(v2);
  v1 = 0;
  v2 = 0;
  v2 = sub_10003D478("FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD129024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DDEF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7EDEE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE45B3DC2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8 FD24CF5F83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3BE39E772C 180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9DE2BCBF6 95581718 3995497C EA956AE5 15D22618 98FA051015728E5A 8AAAC42D AD33170D 04507A33 A85521AB DF1CBA64ECFB8504 58DBEF0A 8AEA7157 5D060C7D B3970F85 A6E1E4C7ABF5AE8C DB0933D7 1E8C94E0 4A25619D CEE3D226 1AD2EE6BF12FFA06 D98A0864 D8760273 3EC86A64 521F2B18 177B200CBBE11757 7A615D6C 770988C0 BAD946E2 08E24FA0 74E5AB3143DB5BFC E0FD108E 4B82D120 A9210801 1A723C12 A787E6D788719A10 BDBA5B26 99C32718 6AF4E23C 1A946834 B6150BDA2583E9CA 2AD44CE8 DBBBC2DB 04DE8EF9 2E8EFC14 1FBECAA6287C5947 4E6BC05D 99B2964F A090C3A2 233BA186 515BE7ED1F612970 CEE2D7AF B81BDD76 2170481C D0069127 D5B05AA993B4EA98 8D8FDDC1 86FFB7DC 90A6C08F 4DF435C9 3402849236C3FAB4 D27C7026 C1D4DCB2 602646DE C9751E76 3DBA37BDF8FF9406 AD9E530E E5DB382F 413001AE B06A53ED 9027D831179727B0 865A8918 DA3EDBEB CF9B14ED 44CE6CBA CED4BB1BDB7F1447 E6CC254B 33205151 2BD7AF42 6FB8F401 378CD2BF5983CA01 C64B92EC F032EA15 D1721D03 F482D7CE 6E74FEF6D55E702F 46980C82 B5A84031 900B1C9E 59E7C97F BEC7E8F323A97A7E 36CC88BE 0F1D45B7 FF585AC5 4BD407B2 2B4154AACC8F6D7E BF48E1D8 14CC5ED2 0F8037E0 A79715EE F29BE32806A1D58B B7C5DA76 F550AA3D 8A1FBFF0 EB19CCB1 A313D55CDA56C9EC 2EF29632 387FE8D7 6E3C0468 043E8F66 3F4860EE12BF2D5B 0B7474D6 E694F91E 6DCC4024 FFFFFFFF FFFFFFFF", 16, &v1);
  *(_OWORD *)&qword_10008B960 = 0u;
  *(_OWORD *)algn_10008B970 = 0u;
  qword_10008B980 = 0;
  qword_10008B958 = 0x100000011;
  qword_10008B960 = (uint64_t)sub_10003F34C((uint64_t)&v1);
  qword_10008B968 = 2;
  free(v2);
  v1 = 0;
  v2 = 0;
  v2 = sub_10003D478("FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD129024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DDEF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7EDEE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE45B3DC2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8 FD24CF5F83655D23 DCA3AD96 1C62F356 208552BB 9ED52907 7096966D670C354E 4ABC9804 F1746C08 CA18217C 32905E46 2E36CE3BE39E772C 180E8603 9B2783A2 EC07A28F B5C55DF0 6F4C52C9DE2BCBF6 95581718 3995497C EA956AE5 15D22618 98FA051015728E5A 8AAAC42D AD33170D 04507A33 A85521AB DF1CBA64ECFB8504 58DBEF0A 8AEA7157 5D060C7D B3970F85 A6E1E4C7ABF5AE8C DB0933D7 1E8C94E0 4A25619D CEE3D226 1AD2EE6BF12FFA06 D98A0864 D8760273 3EC86A64 521F2B18 177B200CBBE11757 7A615D6C 770988C0 BAD946E2 08E24FA0 74E5AB3143DB5BFC E0FD108E 4B82D120 A9210801 1A723C12 A787E6D788719A10 BDBA5B26 99C32718 6AF4E23C 1A946834 B6150BDA2583E9CA 2AD44CE8 DBBBC2DB 04DE8EF9 2E8EFC14 1FBECAA6287C5947 4E6BC05D 99B2964F A090C3A2 233BA186 515BE7ED1F612970 CEE2D7AF B81BDD76 2170481C D0069127 D5B05AA993B4EA98 8D8FDDC1 86FFB7DC 90A6C08F 4DF435C9 3402849236C3FAB4 D27C7026 C1D4DCB2 602646DE C9751E76 3DBA37BDF8FF9406 AD9E530E E5DB382F 413001AE B06A53ED 9027D831179727B0 865A8918 DA3EDBEB CF9B14ED 44CE6CBA CED4BB1BDB7F1447 E6CC254B 33205151 2BD7AF42 6FB8F401 378CD2BF5983CA01 C64B92EC F032EA15 D1721D03 F482D7CE 6E74FEF6D55E702F 46980C82 B5A84031 900B1C9E 59E7C97F BEC7E8F323A97A7E 36CC88BE 0F1D45B7 FF585AC5 4BD407B2 2B4154AACC8F6D7E BF48E1D8 14CC5ED2 0F8037E0 A79715EE F29BE32806A1D58B B7C5DA76 F550AA3D 8A1FBFF0 EB19CCB1 A313D55CDA56C9EC 2EF29632 387FE8D7 6E3C0468 043E8F66 3F4860EE12BF2D5B 0B7474D6 E694F91E 6DBE1159 74A3926F 12FEE5E438777CB6 A932DF8C D8BEC4D0 73B931BA 3BC832B6 8D9DD300741FA7BF 8AFC47ED 2576F693 6BA42466 3AAB639C 5AE4F5683423B474 2BF1C978 238F16CB E39D652D E3FDB8BE FC848AD922222E04 A4037C07 13EB57A8 1A23F0C7 3473FC64 6CEA306B4BCBC886 2F8385DD FA9D4B7F A2C087E8 79683303 ED5BDD3A062B3CF5 B3A278A6 6D2A13F8 3F44F82D DF310EE0 74AB6A364597E899 A0255DC1 64F31CC5 0846851D F9AB4819 5DED7EA1B1D510BD 7EE74D73 FAF36BC3 1ECFA268 359046"
         "F4 EB879F924009438B 481C6CD7 889A002E D5EE382B C9190DA6 FC026E479558E447 5677E9AA 9E3050E2 765694DF C81F56E8 80"
         "B96E7160C980DD 98EDD3DF FFFFFFFF FFFFFFFF",
         16,
         &v1);
  *(_OWORD *)&qword_10008B9C0 = 0u;
  *(_OWORD *)algn_10008B9D0 = 0u;
  qword_10008B9E0 = 0;
  qword_10008B9B8 = 0x100000012;
  qword_10008B9C0 = (uint64_t)sub_10003F34C((uint64_t)&v1);
  qword_10008B9C8 = 2;
  free(v2);
  return 0;
}

void sub_10002957C(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;

  v2 = (_QWORD *)a1[1];
  if (v2)
  {
    sub_10003F318(v2);
    a1[1] = 0;
  }
  v3 = (_QWORD *)a1[3];
  if (v3)
  {
    sub_10003F318(v3);
    a1[3] = 0;
  }
  v4 = (_QWORD *)a1[4];
  if (v4)
  {
    sub_10003F318(v4);
    a1[4] = 0;
  }
  v5 = (_QWORD *)a1[5];
  if (v5)
    sub_10003F318(v5);
  free(a1);
}

uint64_t sub_1000295D8(_BOOL8 a1, _QWORD *a2, _QWORD **a3, _QWORD *a4)
{
  uint64_t v7;
  NSObject *v8;
  size_t v9;
  size_t *v10;
  size_t *v11;
  size_t v12;
  uint64_t v13;
  NSObject *v14;
  NSObject *v15;
  NSObject *v16;
  _QWORD *v18;
  void *v19;
  NSObject *v20;
  NSObject *v21;
  size_t __n;

  v7 = a1;
  __n = 0;
  if (dword_10008BA20)
  {
    v8 = ne_log_obj(a1);
    a1 = os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG);
    if (a1)
      sub_10005DD28();
  }
  if (*a2 != **(_QWORD **)(v7 + 8))
  {
    if (dword_10008BA20)
    {
      v15 = ne_log_obj(a1);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        sub_10005DCBC();
    }
    goto LABEL_16;
  }
  v9 = SecDHGetMaxKeyLength(*a4);
  v10 = sub_10003F1F8(v9);
  if (!v10)
  {
    if (dword_10008BA20)
    {
      v16 = ne_log_obj(0);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        sub_10005DC38();
    }
LABEL_16:
    v11 = 0;
LABEL_17:
    if (*a4)
    {
      SecDHDestroy();
      *a4 = 0;
    }
    sub_10003F318(*a3);
    sub_10003F318(v11);
    return 0xFFFFFFFFLL;
  }
  v11 = v10;
  v12 = v10[1];
  __n = *v10;
  v13 = SecDHComputeKey(*a4, a2[1], *a2, v12, &__n);
  if ((_DWORD)v13)
  {
    if (dword_10008BA20)
    {
      v14 = ne_log_obj(v13);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        sub_10005DC90();
    }
    goto LABEL_17;
  }
  v18 = sub_10003F1F8(v9);
  *a3 = v18;
  if (!v18)
  {
    if (dword_10008BA20)
    {
      v21 = ne_log_obj(0);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        sub_10005DC38();
    }
    goto LABEL_17;
  }
  v19 = memcpy((void *)(v18[1] + v9 - __n), (const void *)v11[1], __n);
  if (dword_10008BA20)
  {
    v20 = ne_log_obj(v19);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      sub_10005DC64();
  }
  if (*a4)
  {
    SecDHDestroy();
    *a4 = 0;
  }
  sub_10003F318(v11);
  return 0;
}

uint64_t sub_1000297D4(_BOOL8 a1, size_t **a2, _QWORD *a3)
{
  uint64_t v5;
  NSObject *v6;
  int v7;
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  size_t *v12;
  size_t v14;
  size_t v15;
  uint64_t v16;
  NSObject *v17;
  NSObject *v18;
  size_t *v19;
  size_t *v20;
  size_t *v21;
  size_t v22;
  size_t v23;
  NSObject *v24;
  _BOOL8 v25;
  NSObject *v26;
  size_t *v27;
  size_t *v28;
  NSObject *v29;
  NSObject *v30;
  size_t __n;

  v5 = a1;
  __n = 0;
  if (dword_10008BA20)
  {
    v6 = ne_log_obj(a1);
    a1 = os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG);
    if (a1)
      sub_10005DF24();
  }
  *a2 = 0;
  v7 = *(_DWORD *)(v5 + 4);
  if ((v7 - 2) >= 2)
  {
    if (v7 != 1)
    {
      if (dword_10008BA20)
      {
        v11 = ne_log_obj(a1);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          sub_10005DD54();
      }
      goto LABEL_16;
    }
    v9 = SecDHCreate(2, *(_QWORD *)(*(_QWORD *)(v5 + 8) + 8), **(_QWORD **)(v5 + 8), 0, 0, 0, a3);
    if ((_DWORD)v9)
    {
      if (dword_10008BA20)
      {
        v10 = ne_log_obj(v9);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
          sub_10005DE94();
      }
      goto LABEL_16;
    }
    v14 = SecDHGetMaxKeyLength(*a3);
    v12 = sub_10003F1F8(v14);
    v15 = v12[1];
    __n = *v12;
    v16 = SecDHGenerateKeypair(*a3, v15, &__n);
    if ((_DWORD)v16)
    {
      if (dword_10008BA20)
      {
        v17 = ne_log_obj(v16);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          sub_10005DE68();
      }
      goto LABEL_17;
    }
    if (dword_10008BA20)
    {
      v18 = ne_log_obj(v16);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        sub_10005DE3C();
    }
    v19 = sub_10003F1F8(v14);
    *a2 = v19;
    if (!v19)
    {
      if (dword_10008BA20)
      {
        v26 = ne_log_obj(0);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
          sub_10005DC38();
      }
      goto LABEL_17;
    }
    memcpy((void *)(v19[1] + v14 - __n), (const void *)v12[1], __n);
    v20 = *(size_t **)(v5 + 8);
    v21 = *a2;
    v22 = *v20;
    v23 = **a2;
    if (*v20 != v23)
    {
      if (*v20 < v23)
      {
        if (!dword_10008BA20)
          goto LABEL_17;
        v24 = ne_log_obj(v22);
        v25 = os_log_type_enabled(v24, OS_LOG_TYPE_ERROR);
        if (v25)
          sub_10005DDE4();
LABEL_42:
        if (dword_10008BA20)
        {
          v30 = ne_log_obj(v25);
          if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
            sub_10005DDB8();
        }
        goto LABEL_17;
      }
      v27 = sub_10003F1F8(v22);
      if (!v27)
      {
        if (!dword_10008BA20)
          goto LABEL_17;
        v29 = ne_log_obj(0);
        v25 = os_log_type_enabled(v29, OS_LOG_TYPE_ERROR);
        if (v25)
          sub_10005DE10();
        goto LABEL_42;
      }
      v28 = v27;
      memcpy((void *)(v27[1] + *v20 - *v21), (const void *)v21[1], *v21);
      sub_10003F318(*a2);
      *a2 = v28;
    }
    sub_10003F318(v12);
    return 0;
  }
  if (dword_10008BA20)
  {
    v8 = ne_log_obj(a1);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      sub_10005DEC0();
  }
LABEL_16:
  v12 = 0;
LABEL_17:
  if (*a3)
  {
    SecDHDestroy();
    *a3 = 0;
  }
  sub_10003F318(*a2);
  sub_10003F318(v12);
  return 0xFFFFFFFFLL;
}

uint64_t sub_100029AD4(uint64_t a1, uint64_t a2)
{
  char **v3;
  char **v4;
  _OWORD *v5;
  __int128 v6;
  __int128 v7;
  _QWORD *v8;
  uint64_t result;
  NSObject *v10;
  NSObject *v11;
  NSObject *v12;

  *(_QWORD *)a2 = 0;
  v3 = sub_100004638(a1);
  if (!v3)
  {
    if (dword_10008BA20)
    {
      v11 = ne_log_obj(0);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        sub_10005DF50();
    }
    return 0xFFFFFFFFLL;
  }
  v4 = v3;
  if (!*((_DWORD *)v3 + 1) || !v3[1] || !*((_DWORD *)v3 + 4))
  {
    if (dword_10008BA20)
    {
      v10 = ne_log_obj(v3);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_10005DFB0();
    }
    return 0xFFFFFFFFLL;
  }
  v5 = malloc_type_calloc(1uLL, 0x30uLL, 0x10200409D20112CuLL);
  *(_QWORD *)a2 = v5;
  if (v5)
  {
    v6 = *(_OWORD *)v4;
    v7 = *((_OWORD *)v4 + 2);
    v5[1] = *((_OWORD *)v4 + 1);
    v5[2] = v7;
    *v5 = v6;
    v8 = sub_10003F34C((uint64_t)v4[1]);
    result = 0;
    *(_QWORD *)(*(_QWORD *)a2 + 8) = v8;
    return result;
  }
  if (!dword_10008BA20)
    return 0;
  v12 = ne_log_obj(0);
  result = os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
  if ((_DWORD)result)
  {
    sub_10005DE10();
    return 0;
  }
  return result;
}

uint64_t sub_100029C14(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  NSObject *v4;

  v3 = *(_QWORD *)(a3 + 72);
  if (!v3 || *(_BYTE *)(a3 + 80) != 16 || (result = sub_1000040CC(*(unsigned int *)(v3 + 52), result, a2)) == 0)
  {
    if (dword_10008BA20)
    {
      v4 = ne_log_obj(result);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_10005E010();
    }
    return 0;
  }
  return result;
}

uint64_t sub_100029C9C(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  NSObject *v5;

  v2 = *(_QWORD *)(a2 + 72);
  if (v2 && *(_BYTE *)(a2 + 80) == 16)
    v3 = *(_DWORD *)(v2 + 52);
  else
    v3 = 1;
  v4 = sub_100004050(v3, a1);
  if (!v4)
  {
    if (dword_10008BA20)
    {
      v5 = ne_log_obj();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_10005E070();
    }
  }
  return v4;
}

uint64_t sub_100029D2C(uint64_t a1, int a2)
{
  _QWORD *v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t result;

  if (*(_DWORD *)(*(_QWORD *)(a1 + 128) + 20))
  {
    v4 = *(_QWORD **)(a1 + 176);
    if (v4)
    {
      if ((sub_1000295D8(*(_QWORD *)(a1 + 152), v4, (_QWORD **)(a1 + 184), (_QWORD *)(a1 + 144)) & 0x80000000) != 0)
        return 0xFFFFFFFFLL;
    }
  }
  if ((sub_100029DD4(a1, a2, 1) & 0x80000000) != 0)
    return 0xFFFFFFFFLL;
  v5 = sub_100029DD4(a1, a2, 0);
  if ((v5 & 0x80000000) != 0)
    return 0xFFFFFFFFLL;
  if (dword_10008BA20)
  {
    v6 = ne_log_obj(v5);
    result = os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG);
    if (!(_DWORD)result)
      return result;
    sub_10005E0D0();
  }
  return 0;
}

uint64_t sub_100029DD4(uint64_t a1, int a2, int a3)
{
  _QWORD *v6;
  uint64_t v7;
  int v8;
  size_t *v9;
  uint64_t v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  size_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  int v23;
  uint64_t v24;
  NSObject *v25;
  size_t v26;
  _QWORD *v27;
  uint64_t v28;
  int v29;
  unint64_t v30;
  void **v31;
  int v32;
  void **v33;
  void **v34;
  char *v35;
  void **v36;
  void **v37;
  uint64_t v38;
  uint64_t v39;
  NSObject *v40;
  NSObject *v41;
  NSObject *v42;
  _QWORD *i;
  _QWORD *v44;
  _QWORD *v45;
  NSObject *v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  int v51;
  uint8_t buf[4];
  int v53;
  __int16 v54;
  int v55;

  if (*(_DWORD *)(*(_QWORD *)(a1 + 128) + 20) && (v6 = *(_QWORD **)(a1 + 184)) != 0)
  {
    v7 = *v6 + 5;
    v8 = 1;
  }
  else
  {
    v8 = 0;
    LODWORD(v7) = 5;
  }
  v9 = sub_10003F1F8((int)v7 + **(_DWORD **)(a1 + 208) + **(_DWORD **)(a1 + 216));
  if (!v9)
  {
    if (dword_10008BA20)
    {
      v40 = ne_log_obj(0);
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
        sub_10005E0FC();
    }
LABEL_73:
    v31 = 0;
    goto LABEL_74;
  }
  v10 = *(_QWORD *)(*(_QWORD *)(a1 + 128) + 32);
  if (!v10)
  {
    v31 = 0;
    v38 = 0;
LABEL_81:
    sub_10003F318(v9);
    goto LABEL_82;
  }
  v11 = a2 == 0;
  if (a2)
    v12 = 216;
  else
    v12 = 208;
  if (v11)
    v13 = 216;
  else
    v13 = 208;
  v50 = v8;
  v51 = a3;
  v48 = v13;
  v49 = v12;
  while (2)
  {
    v14 = v9[1];
    if (v8)
    {
      memcpy((void *)v9[1], *(const void **)(*(_QWORD *)(a1 + 184) + 8), **(_QWORD **)(a1 + 184));
      v14 += **(_QWORD **)(a1 + 184);
    }
    *(_BYTE *)v14 = *(_DWORD *)v10;
    v15 = 24;
    if (a3 != 1)
      v15 = 28;
    *(_DWORD *)(v14 + 1) = *(_DWORD *)(v10 + v15);
    v16 = (char *)(v14 + 5);
    v17 = *(_QWORD *)(a1 + v12);
    memcpy(v16, *(const void **)(v17 + 8), *(_QWORD *)v17);
    memcpy(&v16[*(_QWORD *)v17], *(const void **)(*(_QWORD *)(a1 + v13) + 8), **(_QWORD **)(a1 + v13));
    v18 = sub_100029C14(*(_QWORD *)(*(_QWORD *)(a1 + 256) + 200), (uint64_t)v9, *(_QWORD *)(a1 + 256));
    if (!v18)
      goto LABEL_73;
    v19 = v18;
    if (*(_DWORD *)v10 == 2)
    {
      v24 = *(_QWORD *)(v10 + 64);
      if (v24)
      {
        v21 = 0;
        do
        {
          v18 = sub_10000449C(*(unsigned int *)(v24 + 4));
          if ((int)v18 > v21)
            v21 = v18;
          v24 = *(_QWORD *)(v24 + 16);
        }
        while (v24);
        v22 = 0;
        goto LABEL_36;
      }
    }
    else if (*(_DWORD *)v10 == 3)
    {
      v20 = *(_QWORD *)(v10 + 64);
      if (v20)
      {
        v21 = 0;
        v22 = 0;
        do
        {
          v23 = sub_1000043C4(*(unsigned int *)(v20 + 4), *(unsigned int *)(v20 + 8));
          if (v23 > v22)
            v22 = v23;
          v18 = sub_10000449C(*(unsigned int *)(v20 + 12));
          if ((int)v18 > v21)
            v21 = v18;
          v20 = *(_QWORD *)(v20 + 16);
        }
        while (v20);
        goto LABEL_36;
      }
    }
    v22 = 0;
    v21 = 0;
LABEL_36:
    if (dword_10008BA20)
    {
      v25 = ne_log_obj(v18);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 67109376;
        v53 = v22;
        v54 = 1024;
        v55 = v21;
        _os_log_debug_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEBUG, "encklen=%d authklen=%d\n", buf, 0xEu);
      }
    }
    v26 = *(_QWORD *)v19;
    v27 = sub_10003F1F8(*v9 + *(_QWORD *)v19);
    if (v27)
    {
      v28 = (uint64_t)v27;
      v29 = v21 + v22;
      if (v21 + v22 < 0 != __OFADD__(v21, v22))
        v29 = v21 + v22 + 7;
      v30 = ((uint64_t)v29 >> 3) / v26;
      if ((int)v30 <= 1)
        LODWORD(v30) = 1;
      v31 = (void **)v19;
      do
      {
        v32 = v30;
        memcpy(*(void **)(v28 + 8), *(const void **)(v19 + 8), *(_QWORD *)v19);
        memcpy((void *)(*(_QWORD *)(v28 + 8) + *(_QWORD *)v19), (const void *)v9[1], *v9);
        v33 = (void **)sub_100029C14(*(_QWORD *)(*(_QWORD *)(a1 + 256) + 200), v28, *(_QWORD *)(a1 + 256));
        if (!v33)
        {
          if (dword_10008BA20)
          {
            v41 = ne_log_obj(0);
            if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
              sub_10005E128();
          }
          if ((void **)v19 != v31)
            sub_10003F318((_QWORD *)v19);
          sub_10003F318(0);
          sub_10003F318((_QWORD *)v28);
          goto LABEL_74;
        }
        v34 = v33;
        v35 = (char *)*v31;
        v36 = sub_10003F270(v31, (size_t)*v31 + (_QWORD)*v33);
        if ((void **)v19 == v31)
          v19 = (uint64_t)v36;
        if (!v36)
        {
          if (dword_10008BA20 && (v42 = ne_log_obj(0), os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)))
          {
            sub_10005E0FC();
            if (v19)
LABEL_71:
              sub_10003F318((_QWORD *)v19);
          }
          else if (v19)
          {
            goto LABEL_71;
          }
          sub_10003F318(v34);
          sub_10003F318((_QWORD *)v28);
          goto LABEL_73;
        }
        v37 = v36;
        v31 = v36;
        memcpy(&v35[(_QWORD)v36[1]], v34[1], (size_t)*v34);
        if ((void **)v19 != v37)
          sub_10003F318((_QWORD *)v19);
        LODWORD(v30) = v32 - 1;
        v19 = (uint64_t)v34;
      }
      while (v32);
      if (v34 != v37)
        sub_10003F318(v34);
      sub_10003F318((_QWORD *)v28);
      v38 = 0;
      v8 = v50;
      a3 = v51;
      v39 = 40;
      if (v51 == 1)
        v39 = 32;
      *(_QWORD *)(v10 + v39) = v31;
      v10 = *(_QWORD *)(v10 + 72);
      v31 = 0;
      v13 = v48;
      v12 = v49;
      if (v10)
        continue;
      goto LABEL_81;
    }
    break;
  }
  if (dword_10008BA20)
  {
    v47 = ne_log_obj(0);
    if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
      sub_10005E0FC();
  }
  v31 = (void **)v19;
LABEL_74:
  for (i = *(_QWORD **)(*(_QWORD *)(a1 + 128) + 32); i; i = (_QWORD *)i[9])
  {
    v44 = (_QWORD *)i[4];
    if (v44)
    {
      sub_10003F318(v44);
      i[4] = 0;
    }
    v45 = (_QWORD *)i[5];
    if (v45)
    {
      sub_10003F318(v45);
      i[5] = 0;
    }
  }
  v38 = 0xFFFFFFFFLL;
  if (v9)
    goto LABEL_81;
LABEL_82:
  if (v31)
    sub_10003F318(v31);
  return v38;
}

uint64_t sub_10002A2C0(uint64_t a1, int a2, uint64_t a3)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  NSObject *v10;
  uint8_t v11[16];

  v6 = sub_10003F1F8(*(_DWORD *)a3 + 5);
  if (v6)
  {
    v7 = v6;
    *(_BYTE *)v6[1] = 0;
    *(_DWORD *)(v6[1] + 1) = a2;
    memcpy((void *)(v6[1] + 5), *(const void **)(a3 + 8), *(_QWORD *)a3);
    v8 = sub_100029C14(*(_QWORD *)(a1 + 208), (uint64_t)v7, a1);
    sub_10003F318(v7);
    return v8;
  }
  else
  {
    if (dword_10008BA20)
    {
      v10 = ne_log_obj(0);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v11 = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "failed to get hash buffer\n", v11, 2u);
      }
    }
    return 0;
  }
}

uint64_t sub_10002A3A0(uint64_t a1, int a2, uint64_t a3)
{
  _QWORD *v6;
  _QWORD *v7;
  _DWORD *v8;
  uint64_t v9;
  NSObject *v11;
  uint8_t v12[16];

  v6 = sub_10003F1F8(*(_DWORD *)a3 + 4);
  if (v6)
  {
    v7 = v6;
    v8 = (_DWORD *)v6[1];
    *v8 = a2;
    memcpy(v8 + 1, *(const void **)(a3 + 8), *(_QWORD *)a3);
    v9 = sub_100029C14(*(_QWORD *)(a1 + 208), (uint64_t)v7, a1);
    sub_10003F318(v7);
    return v9;
  }
  else
  {
    if (dword_10008BA20)
    {
      v11 = ne_log_obj(0);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v12 = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "failed to get hash buffer\n", v12, 2u);
      }
    }
    return 0;
  }
}

uint64_t sub_10002A470(uint64_t a1, int a2)
{
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  BOOL v7;
  _BOOL4 v8;
  _BOOL4 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  NSObject *v23;

  if (a2 == 1)
    v4 = 312;
  else
    v4 = 320;
  v5 = sub_10003F1F8(**(_DWORD **)(a1 + 152)
                   + **(_DWORD **)(a1 + 160)
                   + **(_DWORD **)(a1 + 336)
                   + **(_DWORD **)(a1 + v4) + 16);
  if (v5)
  {
    v6 = v5;
    v7 = a2 == 1;
    v8 = a2 == 1;
    v9 = a2 != 1;
    v10 = v5[1];
    if (v7)
      v11 = 152;
    else
      v11 = 160;
    v12 = *(_QWORD *)(a1 + v11);
    if (v7)
      v13 = 160;
    else
      v13 = 152;
    memcpy((void *)v5[1], *(const void **)(v12 + 8), *(_QWORD *)v12);
    v14 = (char *)(v10 + *(_QWORD *)v12);
    v15 = *(_QWORD *)(a1 + v13);
    memcpy(v14, *(const void **)(v15 + 8), *(_QWORD *)v15);
    v16 = &v14[*(_QWORD *)v15];
    if (*(_DWORD *)(a1 + 20))
      v17 = 8 * v8;
    else
      v17 = 8 * v9;
    *(_QWORD *)v16 = *(_QWORD *)(a1 + v17);
    if (*(_DWORD *)(a1 + 20))
      v18 = 8 * v9;
    else
      v18 = 8 * v8;
    *((_QWORD *)v16 + 1) = *(_QWORD *)(a1 + v18);
    v19 = v16 + 16;
    v20 = *(_QWORD *)(a1 + 336);
    memcpy(v16 + 16, *(const void **)(v20 + 8), *(_QWORD *)v20);
    memcpy((char *)v19 + *(_QWORD *)v20, *(const void **)(*(_QWORD *)(a1 + v4) + 8), **(_QWORD **)(a1 + v4));
    v21 = sub_100029C14(*(_QWORD *)(a1 + 192), (uint64_t)v6, a1);
    sub_10003F318(v6);
    return v21;
  }
  else
  {
    if (dword_10008BA20)
    {
      v23 = ne_log_obj(0);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        sub_10005E154();
    }
    return 0;
  }
}

uint64_t sub_10002A5F4(uint64_t a1, int a2)
{
  int v4;
  BOOL v5;
  int v6;
  NSObject *v7;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  char *v15;
  uint64_t v16;
  char *v17;
  _QWORD *v18;
  uint64_t v19;
  NSObject *v20;
  NSObject *v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  NSObject *v29;
  NSObject *v30;

  if (*(_BYTE *)(a1 + 81) != 1)
  {
    if (dword_10008BA20)
    {
      v7 = ne_log_obj(a1);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_10005E20C();
    }
    return 0;
  }
  v4 = *(_DWORD *)(*(_QWORD *)(a1 + 72) + 48);
  if (*(_QWORD *)(*(_QWORD *)(a1 + 64) + 272))
    v5 = v4 == 65001;
  else
    v5 = 0;
  if (v5)
    goto LABEL_21;
  if (v4 <= 64220)
  {
    if ((v4 - 4) >= 2 && v4 != 1)
    {
      if (v4 != 3)
      {
LABEL_57:
        if (dword_10008BA20)
        {
          v30 = ne_log_obj(a1);
          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
            sub_10005E1AC();
        }
        return 0;
      }
      goto LABEL_45;
    }
    goto LABEL_21;
  }
  if ((v4 - 65002) <= 8)
  {
    v6 = 1 << (v4 + 22);
    if ((v6 & 0x1E1) == 0)
    {
      if ((v6 & 0x18) != 0)
        goto LABEL_45;
      goto LABEL_10;
    }
LABEL_21:
    v9 = *(_QWORD *)(a1 + 192);
    if (!v9)
    {
      if (dword_10008BA20)
      {
        v20 = ne_log_obj(a1);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          sub_10005E180();
      }
      return 0;
    }
    v10 = 0;
    goto LABEL_23;
  }
LABEL_10:
  if ((v4 - 64221) >= 2)
  {
    if (v4 != 65500)
      goto LABEL_57;
    goto LABEL_21;
  }
LABEL_45:
  v23 = sub_10003F1F8(**(_DWORD **)(a1 + 184) + **(_DWORD **)(a1 + 176));
  if (!v23)
  {
    if (dword_10008BA20)
    {
      v29 = ne_log_obj(0);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        sub_10005E154();
    }
    return 0;
  }
  v14 = v23;
  v24 = v23[1];
  if (a2 == 1)
    v25 = 184;
  else
    v25 = 176;
  v26 = *(_QWORD *)(a1 + v25);
  if (a2 == 1)
    v27 = 176;
  else
    v27 = 184;
  memcpy((void *)v23[1], *(const void **)(v26 + 8), *(_QWORD *)v26);
  memcpy((void *)(v24 + *(_QWORD *)v26), *(const void **)(*(_QWORD *)(a1 + v27) + 8), **(_QWORD **)(a1 + v27));
  v28 = sub_100029C9C((uint64_t)v14, a1);
  if (!v28)
  {
    v19 = 0;
    goto LABEL_33;
  }
  v9 = v28;
  sub_10003F318(v14);
  v10 = (_QWORD *)v9;
LABEL_23:
  if (a2 == 1)
    v11 = 152;
  else
    v11 = 160;
  if (a2 == 1)
    v12 = 312;
  else
    v12 = 320;
  v13 = sub_10003F1F8(**(_DWORD **)(a1 + v11) + **(_DWORD **)(a1 + 336) + **(_DWORD **)(a1 + v12) + 16);
  v14 = v13;
  if (v13)
  {
    v15 = (char *)v13[1];
    v16 = *(_QWORD *)(a1 + v11);
    memcpy(v15, *(const void **)(v16 + 8), *(_QWORD *)v16);
    v17 = &v15[*(_QWORD *)v16];
    *(_QWORD *)v17 = *(_QWORD *)a1;
    *((_QWORD *)v17 + 1) = *(_QWORD *)(a1 + 8);
    v18 = v17 + 16;
    memcpy(v17 + 16, *(const void **)(*(_QWORD *)(a1 + 336) + 8), **(_QWORD **)(a1 + 336));
    memcpy((char *)v18 + **(_QWORD **)(a1 + 336), *(const void **)(*(_QWORD *)(a1 + v12) + 8), **(_QWORD **)(a1 + v12));
    v19 = sub_100029C14(v9, (uint64_t)v14, a1);
    if (!v10)
      goto LABEL_32;
    goto LABEL_31;
  }
  if (dword_10008BA20)
  {
    v22 = ne_log_obj(0);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      sub_10005E154();
  }
  v19 = 0;
  if (v10)
LABEL_31:
    sub_10003F318(v10);
LABEL_32:
  if (v14)
LABEL_33:
    sub_10003F318(v14);
  return v19;
}

uint64_t sub_10002A940(uint64_t a1, int a2)
{
  int v4;
  BOOL v5;
  NSObject *v7;
  NSObject *v8;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  char *v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  char *v26;
  _QWORD *v27;
  uint64_t v28;
  NSObject *v29;
  NSObject *v31;

  if (*(_BYTE *)(a1 + 81) != 1)
  {
    if (dword_10008BA20)
    {
      v8 = ne_log_obj(a1);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_10005E20C();
    }
    return 0;
  }
  v4 = *(_DWORD *)(*(_QWORD *)(a1 + 72) + 48);
  if (*(_QWORD *)(*(_QWORD *)(a1 + 64) + 272))
    v5 = v4 == 65001;
  else
    v5 = 0;
  if (!v5)
  {
    if (v4 > 65004)
    {
      if ((v4 - 65005) >= 2 && v4 != 65500)
        goto LABEL_11;
    }
    else if ((v4 - 64221) >= 2 && v4 != 3)
    {
LABEL_11:
      if (dword_10008BA20)
      {
        v7 = ne_log_obj(a1);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
          sub_10005E1AC();
      }
      return 0;
    }
  }
  v10 = sub_10003F1F8(**(_DWORD **)(a1 + 184) + **(_DWORD **)(a1 + 176));
  if (!v10)
  {
    if (dword_10008BA20)
    {
      v29 = ne_log_obj(0);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        sub_10005E154();
    }
    return 0;
  }
  v11 = v10;
  v12 = v10[1];
  if (a2 == 1)
    v13 = 184;
  else
    v13 = 176;
  v14 = *(_QWORD *)(a1 + v13);
  if (a2 == 1)
    v15 = 176;
  else
    v15 = 184;
  memcpy((void *)v10[1], *(const void **)(v14 + 8), *(_QWORD *)v14);
  memcpy((void *)(v12 + *(_QWORD *)v14), *(const void **)(*(_QWORD *)(a1 + v15) + 8), **(_QWORD **)(a1 + v15));
  v16 = (_QWORD *)sub_100029C9C((uint64_t)v11, a1);
  sub_10003F318(v11);
  if (!v16)
    return 0;
  if (a2 == 1)
    v17 = 160;
  else
    v17 = 152;
  if (a2 == 1)
    v18 = 152;
  else
    v18 = 160;
  if (a2 == 1)
    v19 = 320;
  else
    v19 = 312;
  v20 = sub_10003F1F8(**(_DWORD **)(a1 + v17)
                    + **(_DWORD **)(a1 + v18)
                    + **(_DWORD **)(a1 + 336)
                    + **(_DWORD **)(a1 + v19) + 16);
  if (v20)
  {
    v21 = v20;
    v22 = (char *)v20[1];
    v23 = *(_QWORD *)(a1 + v17);
    memcpy(v22, *(const void **)(v23 + 8), *(_QWORD *)v23);
    v24 = &v22[*(_QWORD *)v23];
    v25 = *(_QWORD *)(a1 + v18);
    memcpy(v24, *(const void **)(v25 + 8), *(_QWORD *)v25);
    v26 = &v24[*(_QWORD *)v25];
    *(_QWORD *)v26 = *(_QWORD *)a1;
    *((_QWORD *)v26 + 1) = *(_QWORD *)(a1 + 8);
    v27 = v26 + 16;
    memcpy(v26 + 16, *(const void **)(*(_QWORD *)(a1 + 336) + 8), **(_QWORD **)(a1 + 336));
    memcpy((char *)v27 + **(_QWORD **)(a1 + 336), *(const void **)(*(_QWORD *)(a1 + v19) + 8), **(_QWORD **)(a1 + v19));
    v28 = sub_100029C14((uint64_t)v16, (uint64_t)v21, a1);
    sub_10003F318(v21);
  }
  else
  {
    if (dword_10008BA20)
    {
      v31 = ne_log_obj(0);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
        sub_10005E154();
    }
    v28 = 0;
  }
  sub_10003F318(v16);
  return v28;
}

uint64_t sub_10002AC24(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  BOOL v7;
  NSObject *v8;
  NSObject *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  BOOL v14;
  NSObject *v15;
  NSObject *v16;
  int v17;
  NSObject *v18;
  NSObject *v19;
  uint64_t v20;
  int v21;
  int v22;
  BOOL v23;
  __CFString *v24;
  uint64_t v25;
  CFIndex *v26;
  CFIndex v27;
  int v28;
  in_addr v29;
  char *v30;
  CFStringRef v31;
  NSObject *v32;
  NSObject *v33;
  NSObject *v34;
  NSObject *v35;
  NSObject *v36;
  uint64_t v37;
  _QWORD *v38;
  int v39;
  uint64_t v40;
  NSObject *v41;
  NSObject *v42;
  NSObject *v43;
  NSObject *v44;
  NSObject *v45;
  uint64_t v46;
  int v47;
  NSObject *v48;
  NSObject *v49;
  int v50;
  uint64_t v51;
  NSObject *v52;
  _QWORD *v53;
  uint64_t v54;
  int v55;
  uint64_t v56;
  int v57;
  BOOL v58;
  NSObject *v59;
  uint64_t v60;
  int v61;
  NSObject *v62;
  uint64_t v63;
  NSObject *v64;
  NSObject *v65;
  NSObject *v67;
  NSObject *v68;
  NSObject *v69;
  uint64_t v70;
  CFTypeRef cf;

  v1 = a1;
  cf = 0;
  v2 = a1 + 64;
  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 272);
  v4 = a1 + 72;
  v5 = *(_DWORD *)(*(_QWORD *)(a1 + 72) + 48);
  v6 = 65001;
  if (v3)
    v7 = v5 == 65001;
  else
    v7 = 0;
  if (v7)
    goto LABEL_26;
  if (v5 > 65004)
  {
    if ((v5 - 65007) < 4)
    {
LABEL_12:
      if (*(_QWORD *)(a1 + 320) && *(_QWORD *)(a1 + 352))
      {
        if (dword_10008BA20)
        {
          v8 = ne_log_obj(a1);
          if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
            sub_10005E638(v4);
        }
        return 0xFFFFFFFFLL;
      }
      if (!dword_10008BA20)
        return 16;
      v9 = ne_log_obj(a1);
      v10 = 16;
      if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        return v10;
      goto LABEL_19;
    }
    if ((v5 - 65005) < 2)
      goto LABEL_51;
    v11 = 65500;
LABEL_25:
    v6 = *(_DWORD *)(*(_QWORD *)(a1 + 72) + 48);
    if (v5 != v11)
    {
LABEL_83:
      if (dword_10008BA20)
      {
        v34 = ne_log_obj(a1);
        if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
          sub_10005A05C();
      }
      return 0xFFFFFFFFLL;
    }
    goto LABEL_26;
  }
  if (v5 > 64220)
  {
    if (v5 == 64221)
      goto LABEL_51;
    if (v5 == 64222)
    {
      if ((**(_BYTE **)(a1 + 408) & 1) != 0)
      {
        if (dword_10008BA20)
        {
          v42 = ne_log_obj(a1);
          v10 = 0;
          if (!os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
            return v10;
          LOWORD(v70) = 0;
          _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "No SIG was passed, but hybrid auth is enabled\n", (uint8_t *)&v70, 2u);
        }
        return 0;
      }
      if (!dword_10008BA20)
        return 3;
      v33 = ne_log_obj(a1);
      if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
        return 3;
LABEL_81:
      sub_10005E238();
      return 3;
    }
    v11 = 65002;
    goto LABEL_25;
  }
  if ((v5 - 4) < 2)
    goto LABEL_12;
  v6 = *(_DWORD *)(*(_QWORD *)(a1 + 72) + 48);
  if (v5 == 1)
  {
LABEL_26:
    if (*(_QWORD *)(a1 + 320))
    {
      v12 = *(_QWORD *)(a1 + 352);
      if (v12)
      {
        v14 = v6 == 65001 && v3 != 0 || v6 == 65500;
        if (v14 && (**(_BYTE **)(a1 + 408) & 1) == 0)
        {
          if (!dword_10008BA20)
            return 3;
          v15 = ne_log_obj(a1);
          if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
            return 3;
          goto LABEL_81;
        }
        if (*(_BYTE *)(a1 + 80) != 16)
          return 0xFFFFFFFFLL;
        v17 = *(unsigned __int8 *)(a1 + 81);
        if (v17 == 1)
        {
          if (*(_DWORD *)(a1 + 20))
          {
            v37 = sub_10002A5F4(a1, 0);
LABEL_96:
            v38 = (_QWORD *)v37;
            if (!v37)
              return 0xFFFFFFFFLL;
            v39 = memcmp(*(const void **)(v37 + 8), (const void *)(v12 + 4), *(_QWORD *)v37);
            sub_10003F318(v38);
            if (!v39)
            {
              if (dword_10008BA20)
              {
                v43 = ne_log_obj(v40);
                if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
                  sub_10005E2C8();
              }
              return 0;
            }
            if (dword_10008BA20)
            {
              v41 = ne_log_obj(v40);
              if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
                sub_10005E2F4();
            }
            return 23;
          }
        }
        else if (v17 != 4 && v17 != 2)
        {
          if (dword_10008BA20)
          {
            v18 = ne_log_obj(a1);
            if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
              sub_10005E264();
          }
          return 7;
        }
        v37 = sub_10002A470(a1, 0);
        goto LABEL_96;
      }
    }
    if (!dword_10008BA20)
      return 16;
    v16 = ne_log_obj(a1);
    v10 = 16;
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      return v10;
LABEL_19:
    sub_100058FA0();
    return v10;
  }
  if (v5 != 3)
    goto LABEL_83;
LABEL_51:
  if (!*(_QWORD *)(a1 + 320))
  {
    if (dword_10008BA20)
    {
      v32 = ne_log_obj(a1);
      v10 = 16;
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
        sub_10005E320();
      return v10;
    }
    return 16;
  }
  if (!*(_QWORD *)(a1 + 272))
  {
    if (dword_10008BA20)
    {
      v35 = ne_log_obj(a1);
      v10 = 16;
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        sub_10005E34C();
      return v10;
    }
    return 16;
  }
  if (dword_10008BA20)
  {
    v19 = ne_log_obj(a1);
    a1 = os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG);
    if ((_DWORD)a1)
      sub_10005E60C();
  }
  if (*(_DWORD *)(*(_QWORD *)v2 + 108) != 1)
  {
    if (dword_10008BA20)
    {
      v36 = ne_log_obj(a1);
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
        sub_10005E5A4();
    }
    return 0xFFFFFFFFLL;
  }
  if (!*(_QWORD *)(v1 + 288))
  {
    if (dword_10008BA20)
    {
      v44 = ne_log_obj(a1);
      if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
        sub_10005E378();
    }
    return 0xFFFFFFFFLL;
  }
  if (!*(_DWORD *)(*(_QWORD *)v2 + 124))
    goto LABEL_124;
  a1 = sub_10002B514(v1);
  v10 = a1;
  if ((_DWORD)a1)
    return v10;
  v20 = *(_QWORD *)v2;
  if (!*(_DWORD *)(*(_QWORD *)v2 + 124) || *(_DWORD *)(v20 + 108) != 1)
  {
LABEL_124:
    if (dword_10008BA20)
    {
      v49 = ne_log_obj(a1);
      a1 = os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)a1)
        sub_10005E4F4();
    }
    if (*(_BYTE *)(v1 + 80) != 16)
      return 0xFFFFFFFFLL;
    v50 = *(unsigned __int8 *)(v1 + 81);
    if (v50 == 1)
    {
      if (*(_DWORD *)(v1 + 20))
        v51 = sub_10002A5F4(v1, 0);
      else
        v51 = sub_10002A940(v1, 0);
LABEL_138:
      v53 = (_QWORD *)v51;
      if (v51)
      {
        v54 = *(_QWORD *)v2;
        v55 = *(_DWORD *)(*(_QWORD *)v2 + 104);
        v56 = *(_QWORD *)(v54 + 272);
        v57 = *(_DWORD *)(*(_QWORD *)v4 + 48);
        v58 = v57 != 65001 || v56 == 0;
        if (v58 && v57 == 64221)
          v55 = **(unsigned __int8 **)(v1 + 288);
        if (v55 != 4)
        {
          if (dword_10008BA20)
          {
            v65 = ne_log_obj(v51);
            if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
              sub_10005E494();
          }
          sub_10003F318(v53);
          return 0xFFFFFFFFLL;
        }
        if (!cf)
        {
          if (dword_10008BA20)
          {
            v59 = ne_log_obj(v51);
            if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
              sub_10005E468();
          }
        }
        if (*(_BYTE *)(v1 + 80) == 16)
        {
          v60 = sub_100005930((__SecKey *)cf, (uint64_t)v53, *(_QWORD *)(v1 + 272), 0);
          v61 = v60;
          if ((_DWORD)v60)
          {
            if (dword_10008BA20)
            {
              v62 = ne_log_obj(v60);
              if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
                sub_10005E3FC(v61);
            }
          }
          CFRelease(cf);
          sub_10003F318(v53);
          if (v61)
          {
            if (dword_10008BA20)
            {
              v64 = ne_log_obj(v63);
              if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
                sub_10005E3A4();
            }
            return 25;
          }
        }
        else
        {
          CFRelease(cf);
          sub_10003F318(v53);
        }
        if (dword_10008BA20)
        {
          v67 = ne_log_obj(v63);
          if (os_log_type_enabled(v67, OS_LOG_TYPE_DEBUG))
            sub_10005E3D0();
        }
        return 0;
      }
      return 0xFFFFFFFFLL;
    }
    if (v50 == 4 || v50 == 2)
    {
      v51 = sub_10002A470(v1, 0);
      goto LABEL_138;
    }
    if (dword_10008BA20)
    {
      v52 = ne_log_obj(a1);
      if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
        sub_10005E264();
    }
    return 7;
  }
  v21 = *(_DWORD *)(v20 + 104);
  v22 = *(_DWORD *)(*(_QWORD *)v4 + 48);
  v23 = v22 != 65001 || *(_QWORD *)(v20 + 272) == 0;
  if (v23 && v22 == 64221)
    v21 = **(unsigned __int8 **)(v1 + 288);
  if (v21 != 4)
  {
    if (dword_10008BA20)
    {
      v45 = ne_log_obj(a1);
      if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
        sub_10005E494();
    }
    return 0xFFFFFFFFLL;
  }
  v24 = 0;
  v70 = 0;
  if (*(_DWORD *)(v20 + 132) != 1)
  {
LABEL_117:
    v46 = sub_10002B5B0(v1);
    a1 = sub_100004F48(v46, *(_QWORD *)(v1 + 288), v24, (SecKeyRef *)&cf);
    v47 = a1;
    if (v24)
      CFRelease(v24);
    if (v47)
    {
      if (dword_10008BA20)
      {
        v48 = ne_log_obj(a1);
        if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
          sub_10005E578();
      }
      return 22;
    }
    goto LABEL_124;
  }
  v25 = sub_100006E1C(*(_QWORD **)(v20 + 56), &v70);
  v26 = *(CFIndex **)(v25 + 8);
  v27 = v26[1];
  if (*(_DWORD *)v25 != 4)
  {
    v31 = CFStringCreateWithBytes(0, (const UInt8 *)v27, *v26, 0x8000100u, 0);
    goto LABEL_116;
  }
  v28 = *(unsigned __int8 *)(v27 + 1);
  if (v28 == 30)
    return 18;
  if (v28 == 2)
  {
    v29.s_addr = *(_DWORD *)(v27 + 4);
    v30 = inet_ntoa(v29);
    v31 = CFStringCreateWithCString(0, v30, 0x8000100u);
LABEL_116:
    v24 = (__CFString *)v31;
    if (v31)
      goto LABEL_117;
    if (dword_10008BA20)
    {
      v68 = ne_log_obj(0);
      if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
        sub_10005E54C();
    }
    return 18;
  }
  if (dword_10008BA20)
  {
    v69 = ne_log_obj(v25);
    if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
      sub_10005E520();
  }
  return 24;
}

uint64_t sub_10002B514(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  unsigned __int8 *v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  uint64_t result;
  NSObject *v9;

  v1 = *(_QWORD *)(a1 + 320);
  if (v1 && (v2 = *(_QWORD *)(a1 + 288)) != 0)
  {
    v3 = *(unsigned __int8 **)(v1 + 8);
    v6 = *v3;
    v4 = (uint64_t)(v3 + 4);
    v5 = v6;
    v7 = *(_DWORD *)v1 - 4;
    while (1)
    {
      result = sub_10002BC9C(v2 + 8, v5, v7, v4, (_DWORD *)(v2 + 32));
      if (!(_DWORD)result)
        break;
      v2 = *(_QWORD *)(v2 + 40);
      if (!v2)
        return 18;
    }
  }
  else
  {
    if (dword_10008BA20)
    {
      v9 = ne_log_obj(a1);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_10005E6AC();
    }
    return 18;
  }
  return result;
}

uint64_t sub_10002B5B0(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  unsigned __int8 *v3;
  int v4;
  NSObject *v5;

  v1 = *(_QWORD *)(a1 + 320);
  if (v1 && (v2 = *(_QWORD *)(a1 + 288)) != 0)
  {
    if (*(_QWORD *)(v2 + 40))
    {
      v3 = *(unsigned __int8 **)(v1 + 8);
      v4 = *(_DWORD *)v1 - 4;
      do
      {
        if (!sub_10002BC9C(v2 + 8, *v3, v4, (uint64_t)(v3 + 4), (_DWORD *)(v2 + 32)))
          break;
        v2 = *(_QWORD *)(v2 + 40);
      }
      while (v2);
    }
  }
  else
  {
    if (dword_10008BA20)
    {
      v5 = ne_log_obj(a1);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_10005E6AC();
    }
    return 0;
  }
  return v2;
}

uint64_t sub_10002B658(uint64_t result, int a2)
{
  if (result)
  {
    while (*(_DWORD *)(result + 32) != a2)
    {
      result = *(_QWORD *)(result + 40);
      if (!result)
        return result;
    }
    return 1;
  }
  return result;
}

uint64_t sub_10002B67C(uint64_t a1)
{
  uint64_t v1;
  NSObject *v4;
  uint64_t *v5;
  CFDataRef v6;
  size_t *v7;
  size_t *v8;
  NSObject *v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  NSObject *v16;
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  unsigned __int16 v21;
  int v22;
  NSObject *v23;
  NSObject *v24;
  NSObject *v25;
  _QWORD *v26;
  _QWORD *v27;
  CFDataRef v28;
  int v29;

  v1 = *(_QWORD *)(a1 + 64);
  if (*(_DWORD *)(v1 + 104) != 4)
  {
    if (dword_10008BA20)
    {
      v4 = ne_log_obj(a1);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_10005E868();
    }
    return 0xFFFFFFFFLL;
  }
  if (*(_QWORD *)(a1 + 280))
    return 0;
  v29 = 0;
  if (!*(_DWORD *)(v1 + 64))
  {
    if (dword_10008BA20)
    {
      v17 = ne_log_obj(a1);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        sub_10005E6D8();
    }
    goto LABEL_24;
  }
  v28 = 0;
  v5 = *(uint64_t **)(v1 + 72);
  if (!v5 || sub_10002BA7C(v5, &v28))
    return 0xFFFFFFFFLL;
  v6 = v28;
  v7 = sub_100005B10(v28, &v29);
  v8 = v7;
  if (dword_10008BA20)
  {
    v9 = ne_log_obj(v7);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      sub_10005E804();
  }
  CFRelease(v6);
  if (!v8)
  {
    if (dword_10008BA20)
    {
      v23 = ne_log_obj(v10);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        sub_10005E704(v23);
    }
    return 0xFFFFFFFFLL;
  }
  v11 = sub_10002D764();
  *(_QWORD *)(a1 + 280) = v11;
  if (!v11)
  {
    if (dword_10008BA20)
    {
      v24 = ne_log_obj(0);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        sub_10005E780();
    }
    goto LABEL_49;
  }
  v12 = sub_10003F1F8(*v8 + 1);
  *(_QWORD *)(*(_QWORD *)(a1 + 280) + 24) = v12;
  v13 = *(_QWORD *)(*(_QWORD *)(a1 + 280) + 24);
  if (!v13)
  {
    if (dword_10008BA20)
    {
      v25 = ne_log_obj(v12);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        sub_10005E7AC();
    }
    v26 = *(_QWORD **)(a1 + 280);
    if (v26)
    {
      do
      {
        v27 = (_QWORD *)v26[5];
        sub_10002D7E0(v26);
        v26 = v27;
      }
      while (v27);
    }
    *(_QWORD *)(a1 + 280) = 0;
LABEL_49:
    sub_10003F318(v8);
    return 0xFFFFFFFFLL;
  }
  v14 = memcpy((void *)(*(_QWORD *)(v13 + 8) + 1), (const void *)v8[1], *v8);
  **(_BYTE **)(*(_QWORD *)(*(_QWORD *)(a1 + 280) + 24) + 8) = *(_DWORD *)(*(_QWORD *)(a1 + 64) + 104);
  v15 = *(_QWORD *)(a1 + 280);
  *(_BYTE *)v15 = *(_DWORD *)(*(_QWORD *)(a1 + 64) + 104);
  *(_DWORD *)(v15 + 32) = v29;
  *(_QWORD *)(v15 + 16) = *(_QWORD *)(*(_QWORD *)(v15 + 24) + 8) + 1;
  *(_QWORD *)(*(_QWORD *)(a1 + 280) + 8) = **(_QWORD **)(*(_QWORD *)(a1 + 280) + 24) - 1;
  if (dword_10008BA20)
  {
    v16 = ne_log_obj(v14);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
      sub_10005E7D8();
  }
  sub_10003F318(v8);
LABEL_24:
  v18 = *(_QWORD *)(a1 + 280);
  if (!v18)
    return 0;
  v19 = *(_QWORD *)(a1 + 280);
  do
  {
    v20 = *(_DWORD *)(v19 + 32);
    if (v20 == 1)
      break;
    v19 = *(_QWORD *)(v19 + 40);
  }
  while (v19);
  do
  {
    if (*(_DWORD *)(v18 + 32) == 2)
    {
      if (v20 == 1)
        v21 = -15532;
      else
        v21 = -15531;
      goto LABEL_36;
    }
    v18 = *(_QWORD *)(v18 + 40);
  }
  while (v18);
  if (v20 != 1)
    return 0;
  v21 = -15532;
LABEL_36:
  v22 = sub_10000A9C8(a1);
  sub_1000487BC(v21, 0, v22, 0, 0);
  return 0xFFFFFFFFLL;
}

uint64_t sub_10002B990(_QWORD *a1)
{
  uint64_t v1;
  uint64_t *v3;
  CFDataRef v4;
  uint64_t v5;
  NSObject *v7;
  NSObject *v8;
  CFDataRef v9;

  v1 = a1[8];
  if (*(_DWORD *)(v1 + 104) == 4 && *(_DWORD *)(v1 + 64))
  {
    v9 = 0;
    v3 = *(uint64_t **)(v1 + 72);
    if (v3 && !sub_10002BA7C(v3, &v9))
    {
      v4 = v9;
      a1[33] = sub_100005950(v9, a1[32]);
      CFRelease(v4);
      if (a1[33])
        return 0;
      if (dword_10008BA20)
      {
        v8 = ne_log_obj(v5);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
          sub_10005E8D0();
      }
    }
  }
  else if (dword_10008BA20)
  {
    v7 = ne_log_obj(a1);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      sub_10005E868();
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_10002BA7C(uint64_t *a1, CFDataRef *a2)
{
  unsigned __int8 *v3;
  uint64_t v4;
  UInt8 *v5;
  UInt8 *v6;
  int v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  unsigned int v12;
  __uint32_t v13;
  uint64_t v14;

  v4 = *a1;
  v3 = (unsigned __int8 *)a1[1];
  v5 = (UInt8 *)malloc_type_malloc((int)*a1, 0x5EE5E58uLL);
  if (v5)
  {
    v6 = v5;
    if ((int)v4 < 1)
    {
      v10 = 0;
    }
    else
    {
      v7 = 0;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      do
      {
        v12 = *v3++;
        v11 = v12;
        if (v12 == 61)
        {
          ++v9;
        }
        else
        {
          if ((v11 & 0x80) != 0)
            v13 = __maskrune(v11, 0x4000uLL);
          else
            v13 = _DefaultRuneLocale.__runetype[v11] & 0x4000;
          if (!v13)
            v9 = 0;
        }
        if ((byte_10006A14A[v11] & 0x80000000) == 0)
        {
          ++v7;
          v8 = byte_10006A14A[v11] + (v8 << 6);
          if ((v7 & 3) == 0)
          {
            v6[v10] = BYTE2(v8);
            if (v9 > 1)
            {
              ++v10;
            }
            else
            {
              v14 = v10 + 2;
              v6[v10 + 1] = BYTE1(v8);
              if (v9 == 1)
              {
                v10 += 2;
              }
              else
              {
                v10 += 3;
                v6[v14] = v8;
              }
            }
          }
        }
        LODWORD(v4) = v4 - 1;
      }
      while ((_DWORD)v4);
    }
    *a2 = CFDataCreate(0, v6, v10);
    free(v6);
    if (*a2)
      return 0;
    else
      return 0xFFFFFFFFLL;
  }
  else
  {
    sub_100054D58((uint64_t)"memory error - could not allocate buffer for certificate reference conversion from base-64.");
    return 0xFFFFFFFFLL;
  }
}

_QWORD *sub_10002BBF4(_QWORD *result)
{
  _QWORD *v1;
  NSObject *v2;
  _QWORD *v3;

  if (*(_DWORD *)(result[8] + 124))
  {
    v1 = result;
    result = (_QWORD *)sub_10002B514((uint64_t)result);
    if ((_DWORD)result)
    {
      if (dword_10008BA20)
      {
        v2 = ne_log_obj(result);
        if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
          sub_10005E8FC();
      }
      result = (_QWORD *)v1[36];
      if (result)
      {
        do
        {
          v3 = (_QWORD *)result[5];
          sub_10002D7E0(result);
          result = v3;
        }
        while (v3);
      }
      v1[36] = 0;
    }
  }
  return result;
}

_QWORD *sub_10002BC70(_QWORD *result)
{
  _QWORD *v1;

  if (result)
  {
    do
    {
      v1 = (_QWORD *)result[5];
      sub_10002D7E0(result);
      result = v1;
    }
    while (v1);
  }
  return result;
}

uint64_t sub_10002BC9C(uint64_t a1, int a2, int a3, uint64_t a4, _DWORD *a5)
{
  unint64_t v8;
  SecCertificateRef v9;
  SecCertificateRef v10;
  const __CFArray *v11;
  const __CFArray *v12;
  CFIndex Count;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  CFIndex v18;
  CFIndex v19;
  _BOOL4 v21;
  BOOL v22;
  char v23;
  const __CFString *ValueAtIndex;
  char *v25;
  char *v26;
  int v27;
  unsigned int v28;
  unsigned int v29;
  _BOOL4 v30;
  int v31;
  int v32;
  int v33;
  char v34;
  unint64_t v35;
  unint64_t v36;
  NSObject *v37;
  _BOOL8 v38;
  NSObject *v39;
  SecCertificateRef v40;
  const __CFArray *v41;
  CFIndex v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  const __CFString *v48;
  CFIndex i;
  const __CFString *v50;
  NSObject *v51;
  _BOOL8 v52;
  NSObject *v53;
  SecCertificateRef v54;
  const __CFArray *v55;
  CFIndex v56;
  uint64_t v57;
  CFIndex j;
  const __CFString *v59;
  NSObject *v60;
  _BOOL8 v61;
  NSObject *v62;
  NSObject *v63;
  uint64_t v64;
  SecCertificateRef v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  int Length;
  const UInt8 *BytePtr;
  uint64_t v73;
  NSObject *v74;
  NSObject *v75;
  NSObject *v76;
  NSObject *v77;
  NSObject *v78;
  NSObject *v79;
  NSObject *v80;
  NSObject *v81;
  NSObject *v82;
  NSObject *v83;
  NSObject *v84;
  NSObject *v85;
  NSObject *v86;
  NSObject *v87;
  char v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  NSObject *v93;
  char v95;
  _BOOL4 v96;
  char v97;
  _BYTE v98[20];
  int v99;

  LODWORD(v8) = a3;
  switch(a2)
  {
    case 1:
    case 5:
      v9 = sub_100004A94(a1);
      if (!v9)
      {
        if (!dword_10008BA20)
          goto LABEL_113;
        v75 = ne_log_obj(0);
        if (!os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
          goto LABEL_113;
        sub_10005E994();
        if (a5)
          goto LABEL_114;
        return 20;
      }
      v10 = v9;
      v11 = (const __CFArray *)SecCertificateCopyIPAddresses();
      if (v11)
      {
        v12 = v11;
        Count = CFArrayGetCount(v11);
        if (Count < 1)
        {
LABEL_43:
          if (dword_10008BA20)
          {
            v37 = ne_log_obj(Count);
            v38 = os_log_type_enabled(v37, OS_LOG_TYPE_ERROR);
            if (v38)
              sub_10005EB20();
            if (dword_10008BA20)
            {
              v39 = ne_log_obj(v38);
              if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
                sub_10005EAB4(a2);
            }
          }
          if (dword_1000882C8 >= 3)
            sub_10003372C(3, a4, (int)v8, "ID:\n", v14, v15, v16, v17, v95);
          goto LABEL_80;
        }
        v18 = Count;
        v19 = 0;
        v21 = a2 == 1 && v8 > 3;
        v22 = a2 == 5 && v8 >= 0x10;
        v23 = !v22;
        v96 = v21;
        v97 = v23;
        while (1)
        {
          memset(v98, 0, sizeof(v98));
          v99 = 0;
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v12, v19);
          Count = CFStringGetLength(ValueAtIndex);
          if (!Count)
            goto LABEL_42;
          v25 = (char *)malloc_type_malloc(0x40uLL, 0x81734572uLL);
          if (!v25)
          {
            if (dword_10008BA20)
            {
              v83 = ne_log_obj(0);
              if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR))
                sub_10005EB4C();
            }
            v64 = 0xFFFFFFFFLL;
            goto LABEL_134;
          }
          v26 = v25;
          if (CFStringGetCString(ValueAtIndex, v25, 64, 0x8000100u) != 1)
          {
LABEL_29:
            free(v26);
            goto LABEL_42;
          }
          if (a2 == 1)
          {
            v27 = inet_pton(2, v26, v98);
            free(v26);
            if (!v27)
              goto LABEL_42;
            if (v96)
            {
              v28 = bswap32(*(_DWORD *)a4);
              v29 = bswap32(*(unsigned int *)v98);
              v22 = v28 >= v29;
              v30 = v28 > v29;
              v31 = !v22;
              v32 = v30 - v31;
              goto LABEL_41;
            }
            if ((v97 & 1) != 0)
              goto LABEL_42;
          }
          else
          {
            if (a2 != 5)
              goto LABEL_29;
            v33 = inet_pton(30, v26, &v98[4]);
            free(v26);
            v34 = v97;
            if (!v33)
              v34 = 1;
            if ((v34 & 1) != 0)
              goto LABEL_42;
          }
          v35 = bswap64(*(_QWORD *)a4);
          v36 = bswap64(*(unint64_t *)v98);
          if (v35 == v36
            && (v35 = bswap64(*(_QWORD *)(a4 + 8)), v36 = bswap64(*(unint64_t *)&v98[8]), v35 == v36))
          {
            v32 = 0;
          }
          else if (v35 < v36)
          {
            v32 = -1;
          }
          else
          {
            v32 = 1;
          }
LABEL_41:
          if (!v32)
          {
            v64 = 0;
LABEL_134:
            CFRelease(v12);
            CFRelease(v10);
            return v64;
          }
LABEL_42:
          if (v18 == ++v19)
            goto LABEL_43;
        }
      }
      if (!dword_10008BA20)
        goto LABEL_122;
      v76 = ne_log_obj(0);
      if (!os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
        goto LABEL_122;
      sub_100058064();
      if (a5)
        goto LABEL_123;
      goto LABEL_146;
    case 2:
      v40 = sub_100004A94(a1);
      if (!v40)
      {
        if (!dword_10008BA20)
          goto LABEL_113;
        v77 = ne_log_obj(0);
        if (!os_log_type_enabled(v77, OS_LOG_TYPE_ERROR))
          goto LABEL_113;
        sub_10005E994();
        if (a5)
          goto LABEL_114;
        return 20;
      }
      v10 = v40;
      v41 = (const __CFArray *)SecCertificateCopyDNSNames();
      if (!v41)
      {
        if (!dword_10008BA20)
          goto LABEL_122;
        v80 = ne_log_obj(0);
        if (!os_log_type_enabled(v80, OS_LOG_TYPE_ERROR))
          goto LABEL_122;
        sub_100058064();
        if (a5)
          goto LABEL_123;
        goto LABEL_146;
      }
      v12 = v41;
      v42 = CFArrayGetCount(v41);
      v8 = (int)v8;
      v43 = (uint64_t)CFStringCreateWithBytes(kCFAllocatorDefault, (const UInt8 *)a4, (int)v8, 0x8000100u, 0);
      if (!v43)
      {
        if (dword_10008BA20)
        {
          v84 = ne_log_obj(0);
          if (os_log_type_enabled(v84, OS_LOG_TYPE_ERROR))
            sub_10005EB78();
        }
        goto LABEL_139;
      }
      v48 = (const __CFString *)v43;
      if (v42 >= 1)
      {
        for (i = 0; i != v42; ++i)
        {
          v50 = (const __CFString *)CFArrayGetValueAtIndex(v12, i);
          v43 = CFStringCompare(v50, v48, 0);
          if (!v43)
            goto LABEL_135;
        }
      }
      if (dword_10008BA20)
      {
        v51 = ne_log_obj(v43);
        v52 = os_log_type_enabled(v51, OS_LOG_TYPE_ERROR);
        if (v52)
          sub_10005EB20();
        if (dword_10008BA20)
        {
          v53 = ne_log_obj(v52);
          if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
            sub_10005EBA4();
        }
      }
      goto LABEL_77;
    case 3:
      v54 = sub_100004A94(a1);
      if (!v54)
      {
        if (dword_10008BA20)
        {
          v78 = ne_log_obj(0);
          if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
          {
            sub_10005E994();
            if (a5)
              goto LABEL_114;
            return 20;
          }
        }
        goto LABEL_113;
      }
      v10 = v54;
      v55 = (const __CFArray *)SecCertificateCopyRFC822Names();
      if (!v55)
      {
        if (dword_10008BA20 && (v81 = ne_log_obj(0), os_log_type_enabled(v81, OS_LOG_TYPE_ERROR)))
        {
          sub_100058064();
          if (!a5)
          {
LABEL_146:
            CFRelease(v10);
            return 20;
          }
        }
        else
        {
LABEL_122:
          if (!a5)
            goto LABEL_146;
        }
LABEL_123:
        if (!*a5)
          *a5 = 4;
        goto LABEL_146;
      }
      v12 = v55;
      v56 = CFArrayGetCount(v55);
      v8 = (int)v8;
      v57 = (uint64_t)CFStringCreateWithBytes(kCFAllocatorDefault, (const UInt8 *)a4, (int)v8, 0x8000100u, 0);
      if (!v57)
      {
        if (dword_10008BA20 && (v85 = ne_log_obj(0), os_log_type_enabled(v85, OS_LOG_TYPE_ERROR)))
        {
          sub_10005EB78();
          if (a5)
          {
LABEL_143:
            if (!*a5)
              *a5 = 5;
          }
        }
        else if (a5)
        {
          goto LABEL_143;
        }
        CFRelease(v12);
        goto LABEL_146;
      }
      v48 = (const __CFString *)v57;
      if (v56 >= 1)
      {
        for (j = 0; j != v56; ++j)
        {
          v59 = (const __CFString *)CFArrayGetValueAtIndex(v12, j);
          v57 = CFStringCompare(v59, v48, 0);
          if (!v57)
          {
LABEL_135:
            CFRelease(v48);
            goto LABEL_139;
          }
        }
      }
      if (dword_10008BA20)
      {
        v60 = ne_log_obj(v57);
        v61 = os_log_type_enabled(v60, OS_LOG_TYPE_ERROR);
        if (v61)
          sub_10005EB20();
        if (dword_10008BA20)
        {
          v62 = ne_log_obj(v61);
          if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
            sub_10005EC14();
        }
      }
LABEL_77:
      if (dword_1000882C8 >= 3)
        sub_10003372C(3, a4, v8, "ID:\n", v44, v45, v46, v47, v95);
      CFRelease(v48);
LABEL_80:
      CFRelease(v12);
      CFRelease(v10);
      if (a5 && !*a5)
        *a5 = 4;
      return 18;
    case 9:
      v65 = sub_100004A94(a1);
      if (!v65)
      {
        if (dword_10008BA20)
        {
          v79 = ne_log_obj(0);
          if (os_log_type_enabled(v79, OS_LOG_TYPE_ERROR))
          {
            sub_10005E994();
            if (!a5)
              return 20;
            goto LABEL_114;
          }
        }
LABEL_113:
        if (!a5)
          return 20;
LABEL_114:
        if (!*a5)
          *a5 = 5;
        return 20;
      }
      v12 = v65;
      v66 = j__SecCertificateCopySubjectSequence();
      v10 = (SecCertificateRef)v66;
      if (v66)
      {
        Length = CFDataGetLength((CFDataRef)v66);
        BytePtr = CFDataGetBytePtr(v10);
        if (BytePtr)
        {
          v73 = (uint64_t)BytePtr;
          if (Length == (_DWORD)v8)
          {
            BytePtr = (const UInt8 *)memcmp((const void *)a4, BytePtr, (int)v8);
            if (!(_DWORD)BytePtr)
            {
LABEL_139:
              CFRelease(v12);
LABEL_169:
              CFRelease(v10);
              return 0;
            }
          }
          if (!dword_10008BA20)
            goto LABEL_155;
          v74 = ne_log_obj(BytePtr);
          v66 = os_log_type_enabled(v74, OS_LOG_TYPE_ERROR);
          if ((_DWORD)v66)
            sub_10005EA30();
LABEL_152:
          if (dword_10008BA20
            && (v87 = ne_log_obj(v66), v66 = os_log_type_enabled(v87, OS_LOG_TYPE_ERROR), (_DWORD)v66))
          {
            sub_10005EA30();
            if (v73)
              goto LABEL_155;
          }
          else if (v73)
          {
LABEL_155:
            if (dword_1000882C8 < 3)
              goto LABEL_165;
            v88 = sub_10003E21C(9);
            sub_10003372C(3, v73, Length, "subjectName (type %s):\n", v89, v90, v91, v92, v88);
LABEL_163:
            if (dword_1000882C8 >= 3)
              sub_10003372C(3, a4, (int)v8, "ID:\n", v67, v68, v69, v70, v95);
LABEL_165:
            if (a5 && !*a5)
              *a5 = 3;
            CFRelease(v12);
            if (!v10)
              return 0;
            goto LABEL_169;
          }
          if (dword_10008BA20)
          {
            v93 = ne_log_obj(v66);
            if (os_log_type_enabled(v93, OS_LOG_TYPE_ERROR))
              sub_10005E9C0();
          }
          goto LABEL_163;
        }
        if (!dword_10008BA20)
          goto LABEL_163;
        v86 = ne_log_obj(0);
        v66 = os_log_type_enabled(v86, OS_LOG_TYPE_ERROR);
        if ((_DWORD)v66)
          sub_10005EA88();
LABEL_151:
        v73 = 0;
        goto LABEL_152;
      }
      if (dword_10008BA20
        && (v82 = ne_log_obj(0), v66 = os_log_type_enabled(v82, OS_LOG_TYPE_ERROR), (_DWORD)v66))
      {
        sub_10005EA5C();
        if (a5)
        {
LABEL_128:
          if (!*a5)
          {
            Length = 0;
            v73 = 0;
            *a5 = 3;
            goto LABEL_152;
          }
        }
      }
      else if (a5)
      {
        goto LABEL_128;
      }
      Length = 0;
      goto LABEL_151;
    default:
      if (dword_10008BA20)
      {
        v63 = ne_log_obj(a1);
        if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
          sub_10005E928(a2);
      }
      return 18;
  }
}

uint64_t sub_10002C614(uint64_t a1, uint64_t a2)
{
  BOOL v4;
  NSObject *v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  NSObject *v12;
  NSObject *v13;
  uint8_t v14[16];

  if (*(_BYTE *)(a2 + 4) != 4)
  {
    if (dword_10008BA20)
    {
      v11 = ne_log_obj(a1);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        sub_10005ECDC();
    }
    return 0xFFFFFFFFLL;
  }
  if (*(_QWORD *)(a1 + 288))
    v4 = dword_10008BA20 == 0;
  else
    v4 = 1;
  if (!v4)
  {
    v5 = ne_log_obj(a1);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v14 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "preexisting CERT payload... chaining.\n", v14, 2u);
    }
  }
  result = (uint64_t)sub_10002C788(a2);
  if (!result)
  {
    if (dword_10008BA20)
    {
      v12 = ne_log_obj(0);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        sub_10005EC84();
    }
    return 0xFFFFFFFFLL;
  }
  if (*(_BYTE *)result == 4)
  {
    v7 = *(_QWORD *)(a1 + 288);
    if (v7)
    {
      v8 = *(_QWORD *)(a1 + 288);
      do
      {
        v9 = v8;
        v8 = *(_QWORD *)(v8 + 40);
      }
      while (v8);
      *(_QWORD *)(v9 + 40) = result;
    }
    else
    {
      v7 = result;
    }
    *(_QWORD *)(a1 + 288) = v7;
    if (!dword_10008BA20)
      return 0;
    v13 = ne_log_obj(result);
    result = os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG);
    if ((_DWORD)result)
    {
      sub_10005ECB0();
      return 0;
    }
  }
  else
  {
    do
    {
      v10 = *(_QWORD *)(result + 40);
      sub_10002D7E0((_QWORD *)result);
      result = v10;
    }
    while (v10);
  }
  return result;
}

_QWORD *sub_10002C788(uint64_t a1)
{
  NSObject *v1;
  _QWORD *v3;
  _QWORD *v4;
  size_t *v5;
  uint64_t v6;
  _BYTE *v7;
  NSObject *v8;
  NSObject *v10;
  _QWORD *v11;

  if (bswap32(*(unsigned __int16 *)(a1 + 2)) >> 16 <= 4)
  {
    if (dword_10008BA20)
    {
      v1 = ne_log_obj(a1);
      if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
        sub_10005ED3C();
    }
    return 0;
  }
  v3 = sub_10002D764();
  if (!v3)
  {
    if (dword_10008BA20)
    {
      v8 = ne_log_obj(0);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_10005EC84();
    }
    return 0;
  }
  v4 = v3;
  v5 = sub_10003F1F8((bswap32(*(unsigned __int16 *)(a1 + 2)) >> 16) - 4);
  v4[3] = v5;
  if (v5)
  {
    memcpy((void *)v5[1], (const void *)(a1 + 4), *v5);
    v6 = *(_QWORD *)v4[3];
    v7 = *(_BYTE **)(v4[3] + 8);
    *(_BYTE *)v4 = *v7;
    v4[1] = v6 - 1;
    v4[2] = v7 + 1;
  }
  else
  {
    if (dword_10008BA20)
    {
      v10 = ne_log_obj(0);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_10005ED68();
    }
    do
    {
      v11 = (_QWORD *)v4[5];
      sub_10002D7E0(v4);
      v4 = v11;
    }
    while (v11);
  }
  return v4;
}

uint64_t sub_10002C8BC(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  uint64_t result;
  NSObject *v13;

  if (*(_BYTE *)(a2 + 4) != 4)
  {
    if (dword_10008BA20)
    {
      v10 = ne_log_obj(a1);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_10005EDEC();
    }
    return 0xFFFFFFFFLL;
  }
  v4 = *(_QWORD **)(a1 + 304);
  if (v4)
  {
    do
    {
      v5 = (_QWORD *)v4[5];
      sub_10002D7E0(v4);
      v4 = v5;
    }
    while (v5);
    *(_QWORD *)(a1 + 304) = 0;
  }
  v6 = sub_10002C788(a2);
  if (!v6)
  {
    if (dword_10008BA20)
    {
      v11 = ne_log_obj(0);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        sub_10005ED94();
    }
    return 0xFFFFFFFFLL;
  }
  v7 = *(_QWORD **)(a1 + 304);
  if (v7)
  {
    v8 = *(_QWORD *)(a1 + 304);
    do
    {
      v9 = v8;
      v8 = *(_QWORD *)(v8 + 40);
    }
    while (v8);
    *(_QWORD *)(v9 + 40) = v6;
  }
  else
  {
    v7 = v6;
  }
  *(_QWORD *)(a1 + 304) = v7;
  if (dword_10008BA20)
  {
    v13 = ne_log_obj(v6);
    result = os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG);
    if (!(_DWORD)result)
      return result;
    sub_10005EDC0();
  }
  return 0;
}

_QWORD *sub_10002C9DC(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  NSObject *v8;
  NSObject *v9;
  NSObject *v10;

  v2 = sub_10003F1F8(1uLL);
  v3 = v2;
  if (v2)
  {
    v6 = *(_QWORD *)(a1 + 64);
    v5 = a1 + 64;
    v4 = v6;
    v7 = *(_DWORD *)(v6 + 104);
    if (v7)
    {
      *(_BYTE *)v2[1] = v7;
      if (dword_10008BA20)
      {
        v8 = ne_log_obj(v2);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
          sub_10005EEEC(v5);
      }
    }
    else
    {
      *(_BYTE *)v2[1] = *(_DWORD *)(v4 + 112);
      if (dword_10008BA20)
      {
        v10 = ne_log_obj(v2);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
          sub_10005EE78(v5);
      }
    }
  }
  else if (dword_10008BA20)
  {
    v9 = ne_log_obj(0);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      sub_10005EE4C();
  }
  return v3;
}

uint64_t sub_10002CACC(uint64_t a1)
{
  unsigned __int8 *v1;
  uint64_t v2;
  unsigned __int8 **v3;
  NSObject *v4;
  NSObject *v6;
  char *v7;
  int v8;
  char *v9;

  v1 = *(unsigned __int8 **)(a1 + 304);
  if (!v1)
    return 0;
  v2 = a1;
  v3 = (unsigned __int8 **)(a1 + 304);
  if (dword_10008BA20)
  {
    v4 = ne_log_obj(a1);
    a1 = os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG);
    v1 = *v3;
    if ((_DWORD)a1)
    {
      v7 = sub_10003DA44(*v1);
      v8 = 136315138;
      v9 = v7;
      _os_log_debug_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "peer transmitted CR: %s\n", (uint8_t *)&v8, 0xCu);
      v1 = *v3;
    }
  }
  if (*(_DWORD *)(*(_QWORD *)(v2 + 64) + 104) == *v1)
    return 0;
  if (dword_10008BA20)
  {
    v6 = ne_log_obj(a1);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      sub_10005EF60();
  }
  return 0xFFFFFFFFLL;
}

BOOL sub_10002CBE8(int a1)
{
  return (a1 - 65005) < 2 || a1 == 3 || a1 == 64221;
}

size_t *sub_10002CC0C(size_t *a1)
{
  size_t *v1;
  size_t v2;
  uint64_t v3;
  size_t *v4;
  NSObject *v5;
  const sockaddr **v6;
  sockaddr *v7;
  NSObject *v8;
  size_t *v9;
  NSObject *v10;
  NSObject *v11;
  uint8_t v13[16];

  v1 = a1;
  v2 = a1[8];
  v3 = *(_QWORD *)(v2 + 88);
  if (!v3)
  {
    if (*((_BYTE *)a1 + 81) != 2)
    {
      a1 = sub_1000280CC((_QWORD *)a1[40]);
      v4 = a1;
      if (a1)
        return v4;
      if (*(_DWORD *)(v1[8] + 136))
      {
        if (dword_10008BA20)
        {
          v10 = ne_log_obj(0);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
            sub_10005F038();
        }
        return 0;
      }
    }
LABEL_6:
    if (dword_10008BA20)
    {
      v5 = ne_log_obj(a1);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v13 = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "try to get pskey by the peer's address.\n", v13, 2u);
      }
    }
    v7 = (sockaddr *)v1[6];
    v6 = (const sockaddr **)(v1 + 6);
    v4 = sub_100028484(v7);
    if (!v4 && dword_10008BA20)
    {
      v8 = ne_log_obj(0);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_10005EFC8(v6);
      return 0;
    }
    return v4;
  }
  if (*(_DWORD *)(v2 + 80) == 1)
  {
    a1 = sub_1000281AC(*(const char **)(v3 + 8), *(_DWORD *)v3 - 1);
    v4 = a1;
    if (a1)
      return v4;
    goto LABEL_6;
  }
  v9 = sub_10003F1F8(*(_QWORD *)v3 - 1);
  if (!v9)
  {
    if (dword_10008BA20)
    {
      v11 = ne_log_obj(0);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        sub_10005DC38();
    }
    return 0;
  }
  v4 = v9;
  memcpy((void *)v9[1], *(const void **)(*(_QWORD *)(v1[8] + 88) + 8), *v9);
  return v4;
}

uint64_t sub_10002CDB4(uint64_t a1)
{
  uint64_t v2;
  int v3;
  BOOL v4;
  NSObject *v5;
  char *v6;
  int v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  size_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  NSObject *v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  NSObject *v29;
  NSObject *v30;
  NSObject *v32;
  int v33;
  char *v34;

  v2 = a1 + 72;
  v3 = *(_DWORD *)(*(_QWORD *)(a1 + 72) + 48);
  if (*(_QWORD *)(*(_QWORD *)(a1 + 64) + 272))
    v4 = v3 == 65001;
  else
    v4 = 0;
  if (v4)
    goto LABEL_31;
  if (v3 > 65004)
  {
    if ((v3 - 65007) < 4)
      goto LABEL_12;
    if ((v3 - 65005) < 2)
      goto LABEL_18;
    v7 = 65500;
LABEL_30:
    if (v3 != v7)
    {
LABEL_58:
      if (dword_10008BA20)
      {
        v32 = ne_log_obj(a1);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
          sub_10005F12C();
      }
      return 0xFFFFFFFFLL;
    }
    goto LABEL_31;
  }
  if (v3 <= 64220)
  {
    if ((v3 - 4) >= 2)
    {
      if (v3 != 1)
      {
        if (v3 != 3)
          goto LABEL_58;
        goto LABEL_18;
      }
LABEL_31:
      v16 = sub_10002CC0C((size_t *)a1);
      if (!v16)
      {
        if (dword_10008BA20)
        {
          v29 = ne_log_obj(0);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
            sub_10005F064(a1);
        }
        return 0xFFFFFFFFLL;
      }
      v21 = (uint64_t)v16;
      if (dword_10008BA20)
      {
        v22 = ne_log_obj(v16);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
          sub_10005F100();
      }
      if (dword_1000882C8 >= 7)
        sub_10003372C(7, *(_QWORD *)(v21 + 8), *(_QWORD *)v21, "psk: ", v17, v18, v19, v20, v33);
      v23 = sub_10003F1F8(**(_DWORD **)(a1 + 184) + **(_DWORD **)(a1 + 176));
      if (!v23)
      {
        if (dword_10008BA20)
        {
          v30 = ne_log_obj(0);
          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
            sub_10005F0D4();
        }
        sub_10003F318((_QWORD *)v21);
        return 0xFFFFFFFFLL;
      }
      v9 = v23;
      v24 = v23[1];
      if (*(_DWORD *)(a1 + 20))
        v25 = 184;
      else
        v25 = 176;
      v26 = *(_QWORD *)(a1 + v25);
      memcpy((void *)v23[1], *(const void **)(v26 + 8), *(_QWORD *)v26);
      if (*(_DWORD *)(a1 + 20))
        v27 = 176;
      else
        v27 = 184;
      memcpy((void *)(v24 + *(_QWORD *)v26), *(const void **)(*(_QWORD *)(a1 + v27) + 8), **(_QWORD **)(a1 + v27));
      v14 = sub_100029C14(v21, (uint64_t)v9, a1);
      *(_QWORD *)(a1 + 192) = v14;
      sub_10003F318((_QWORD *)v21);
      goto LABEL_45;
    }
LABEL_12:
    if (dword_10008BA20)
    {
      v5 = ne_log_obj(a1);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        v6 = sub_10003E3EC(*(_DWORD *)(*(_QWORD *)v2 + 48));
        v33 = 136315138;
        v34 = v6;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "not supported authentication method %s\n", (uint8_t *)&v33, 0xCu);
      }
    }
    return 0xFFFFFFFFLL;
  }
  if ((v3 - 64221) >= 2)
  {
    v7 = 65002;
    goto LABEL_30;
  }
LABEL_18:
  v8 = sub_10003F1F8(**(_DWORD **)(a1 + 184) + **(_DWORD **)(a1 + 176));
  if (!v8)
  {
    if (dword_10008BA20)
    {
      v15 = ne_log_obj(0);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        sub_10005F18C();
    }
    return 0xFFFFFFFFLL;
  }
  v9 = v8;
  v10 = v8[1];
  if (*(_DWORD *)(a1 + 20))
    v11 = 184;
  else
    v11 = 176;
  v12 = *(_QWORD *)(a1 + v11);
  memcpy((void *)v8[1], *(const void **)(v12 + 8), *(_QWORD *)v12);
  if (*(_DWORD *)(a1 + 20))
    v13 = 176;
  else
    v13 = 184;
  memcpy((void *)(v10 + *(_QWORD *)v12), *(const void **)(*(_QWORD *)(a1 + v13) + 8), **(_QWORD **)(a1 + v13));
  v14 = sub_100029C14((uint64_t)v9, *(_QWORD *)(a1 + 168), a1);
  *(_QWORD *)(a1 + 192) = v14;
LABEL_45:
  if (v14)
    v28 = 0;
  else
    v28 = 0xFFFFFFFFLL;
  sub_10003F318(v9);
  return v28;
}

uint64_t sub_10002D170(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  char *v4;
  char *v5;
  uint64_t v6;
  _QWORD *v7;
  char *v8;
  char *v9;
  char *v10;
  uint64_t v11;
  _QWORD *v12;
  char *v13;
  char *v14;
  char *v15;
  uint64_t v16;
  NSObject *v18;
  NSObject *v19;
  NSObject *v20;
  NSObject *v21;

  if (!*(_QWORD *)(a1 + 192))
  {
    if (dword_10008BA20)
    {
      v18 = ne_log_obj(a1);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        sub_10005F1B8();
    }
    return 0xFFFFFFFFLL;
  }
  v2 = sub_10003F1F8(**(_DWORD **)(a1 + 168) + 17);
  if (!v2)
  {
    if (!dword_10008BA20)
      return 0xFFFFFFFFLL;
    v19 = ne_log_obj(0);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      return 0xFFFFFFFFLL;
    goto LABEL_22;
  }
  v3 = v2;
  v4 = (char *)v2[1];
  memcpy(v4, *(const void **)(*(_QWORD *)(a1 + 168) + 8), **(_QWORD **)(a1 + 168));
  v5 = &v4[**(_QWORD **)(a1 + 168)];
  *(_QWORD *)v5 = *(_QWORD *)a1;
  *((_QWORD *)v5 + 1) = *(_QWORD *)(a1 + 8);
  v5[16] = 0;
  v6 = sub_100029C14(*(_QWORD *)(a1 + 192), (uint64_t)v3, a1);
  *(_QWORD *)(a1 + 200) = v6;
  if (v6)
  {
    sub_10003F318(v3);
    v7 = sub_10003F1F8(**(_DWORD **)(a1 + 168) + **(_DWORD **)(a1 + 200) + 17);
    if (!v7)
    {
      if (!dword_10008BA20)
        return 0xFFFFFFFFLL;
      v20 = ne_log_obj(0);
      if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        return 0xFFFFFFFFLL;
      goto LABEL_22;
    }
    v3 = v7;
    v8 = (char *)v7[1];
    memcpy(v8, *(const void **)(*(_QWORD *)(a1 + 200) + 8), **(_QWORD **)(a1 + 200));
    v9 = &v8[**(_QWORD **)(a1 + 200)];
    memcpy(v9, *(const void **)(*(_QWORD *)(a1 + 168) + 8), **(_QWORD **)(a1 + 168));
    v10 = &v9[**(_QWORD **)(a1 + 168)];
    *(_QWORD *)v10 = *(_QWORD *)a1;
    *((_QWORD *)v10 + 1) = *(_QWORD *)(a1 + 8);
    v10[16] = 1;
    v11 = sub_100029C14(*(_QWORD *)(a1 + 192), (uint64_t)v3, a1);
    *(_QWORD *)(a1 + 208) = v11;
    if (v11)
    {
      sub_10003F318(v3);
      v12 = sub_10003F1F8(**(_DWORD **)(a1 + 168) + **(_DWORD **)(a1 + 208) + 17);
      if (v12)
      {
        v3 = v12;
        v13 = (char *)v12[1];
        memcpy(v13, *(const void **)(*(_QWORD *)(a1 + 208) + 8), **(_QWORD **)(a1 + 208));
        v14 = &v13[**(_QWORD **)(a1 + 208)];
        memcpy(v14, *(const void **)(*(_QWORD *)(a1 + 168) + 8), **(_QWORD **)(a1 + 168));
        v15 = &v14[**(_QWORD **)(a1 + 168)];
        *(_QWORD *)v15 = *(_QWORD *)a1;
        *((_QWORD *)v15 + 1) = *(_QWORD *)(a1 + 8);
        v15[16] = 2;
        v16 = sub_100029C14(*(_QWORD *)(a1 + 192), (uint64_t)v3, a1);
        *(_QWORD *)(a1 + 224) = v16;
        if (v16)
        {
          sub_10003F318(v3);
          return 0;
        }
        goto LABEL_15;
      }
      if (!dword_10008BA20)
        return 0xFFFFFFFFLL;
      v21 = ne_log_obj(0);
      if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        return 0xFFFFFFFFLL;
LABEL_22:
      sub_10005F0D4();
      return 0xFFFFFFFFLL;
    }
  }
LABEL_15:
  sub_10003F318(v3);
  return 0xFFFFFFFFLL;
}

uint64_t sub_10002D418(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t **v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  NSObject *v10;
  size_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  char *v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  NSObject *v24;
  NSObject *v25;
  NSObject *v26;
  NSObject *v27;
  NSObject *v29;
  uint8_t buf[4];
  int v31;

  v2 = (uint64_t)(a1 + 9);
  v3 = sub_100004248(*(_DWORD *)(a1[9] + 40), *(unsigned int *)(a1[9] + 44));
  if ((_DWORD)v3 == -1)
  {
    if (dword_10008BA20)
    {
      v24 = ne_log_obj(v3);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        sub_10005F1E4(v2, v24);
    }
    return 0xFFFFFFFFLL;
  }
  v4 = sub_10003F1F8(v3 >> 3);
  a1[30] = v4;
  v5 = (uint64_t **)(a1 + 30);
  if (!v4)
  {
    if (!dword_10008BA20)
      return 0xFFFFFFFFLL;
    v25 = ne_log_obj(0);
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      return 0xFFFFFFFFLL;
    goto LABEL_27;
  }
  v6 = sub_100003FFC(*(_DWORD *)(*(_QWORD *)v2 + 52));
  if ((_DWORD)v6 == -1)
  {
    if (dword_10008BA20)
    {
      v26 = ne_log_obj(v6);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        sub_10005F294();
    }
    return 0xFFFFFFFFLL;
  }
  v7 = a1[28];
  v8 = a1[30];
  if (*(_QWORD *)v8 <= *(_QWORD *)v7)
  {
    memcpy(*(void **)(v8 + 8), *(const void **)(v7 + 8), *(_QWORD *)v8);
    return 0;
  }
  v9 = v6;
  if (dword_10008BA20)
  {
    v10 = ne_log_obj(v6);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      sub_10005F364();
  }
  v11 = v9 >> 3;
  v12 = sub_10003F1F8(v11);
  if (v12)
  {
    v13 = (uint64_t)v12;
    v14 = **v5;
    if (v14 >= 1)
    {
      v15 = (char *)(*v5)[1];
      v16 = &v15[v14];
      v17 = 1;
      while (1)
      {
        if (v15 == (char *)(*v5)[1])
        {
          **(_BYTE **)(v13 + 8) = 0;
          *(_QWORD *)v13 = 1;
        }
        v18 = sub_100029C14(a1[28], v13, (uint64_t)a1);
        if (!v18)
          break;
        v19 = v18;
        if (dword_10008BA20)
        {
          v20 = ne_log_obj(v18);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 67109120;
            v31 = v17;
            _os_log_debug_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEBUG, "compute intermediate encryption key K%d\n", buf, 8u);
          }
        }
        LODWORD(v21) = (_DWORD)v16 - (_DWORD)v15;
        if (*(_QWORD *)v19 < (unint64_t)(v16 - v15))
          v21 = *(_QWORD *)v19;
        v22 = (int)v21;
        v23 = memcpy(v15, *(const void **)(v19 + 8), (int)v21);
        *(_QWORD *)v13 = v11;
        if (*(_QWORD *)v19 != v11)
        {
          if (dword_10008BA20)
          {
            v29 = ne_log_obj(v23);
            if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
              sub_10005F2FC();
          }
          sub_10003F318((_QWORD *)v19);
          break;
        }
        v15 += v22;
        memcpy(*(void **)(v13 + 8), *(const void **)(v19 + 8), v11);
        sub_10003F318((_QWORD *)v19);
        ++v17;
        if (v15 >= v16)
          goto LABEL_35;
      }
      sub_10003F318((_QWORD *)v13);
      return 0xFFFFFFFFLL;
    }
LABEL_35:
    sub_10003F318((_QWORD *)v13);
    return 0;
  }
  if (dword_10008BA20)
  {
    v27 = ne_log_obj(0);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
LABEL_27:
      sub_10005F268();
  }
  return 0xFFFFFFFFLL;
}

_QWORD *sub_10002D764()
{
  _QWORD *v0;
  _QWORD *v1;
  NSObject *v2;

  v0 = malloc_type_calloc(1uLL, 0x30uLL, 0x1030040C42573BEuLL);
  v1 = v0;
  if (v0)
  {
    v0[3] = 0;
    v0[5] = 0;
  }
  else if (dword_10008BA20)
  {
    v2 = ne_log_obj(0);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_10005F3E4();
  }
  return v1;
}

void sub_10002D7E0(_QWORD *a1)
{
  _QWORD *v2;

  if (a1)
  {
    v2 = (_QWORD *)a1[3];
    if (v2)
      sub_10003F318(v2);
    free(a1);
  }
}

uint64_t sub_10002D814(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t result;
  NSObject *v16;
  NSObject *v17;
  NSObject *v18;
  NSObject *v19;

  v2 = sub_10003F1F8(**(_DWORD **)(a1 + 160) + **(_DWORD **)(a1 + 152));
  if (!v2)
  {
    if (dword_10008BA20)
    {
      v16 = ne_log_obj(0);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        sub_10005F410();
    }
    return 0xFFFFFFFFLL;
  }
  v3 = v2;
  v4 = v2[1];
  if (*(_DWORD *)(a1 + 20))
    v5 = 160;
  else
    v5 = 152;
  v6 = *(_QWORD *)(a1 + v5);
  memcpy((void *)v2[1], *(const void **)(v6 + 8), *(_QWORD *)v6);
  if (*(_DWORD *)(a1 + 20))
    v7 = 152;
  else
    v7 = 160;
  memcpy((void *)(v4 + *(_QWORD *)v6), *(const void **)(*(_QWORD *)(a1 + v7) + 8), **(_QWORD **)(a1 + v7));
  v8 = (uint64_t *)malloc_type_calloc(1uLL, 0x10uLL, 0x20040A4A59CD2uLL);
  if (!v8)
  {
    if (dword_10008BA20)
    {
      v17 = ne_log_obj(0);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        sub_10005F410();
    }
    sub_10003F318(v3);
    return 0xFFFFFFFFLL;
  }
  v9 = v8;
  v10 = sub_100029C9C((uint64_t)v3, a1);
  *v9 = v10;
  if (!v10)
  {
LABEL_28:
    sub_10003F318(v3);
    sub_10002DA18(v9);
    return 0xFFFFFFFFLL;
  }
  v11 = sub_100004288(*(_DWORD *)(*(_QWORD *)(a1 + 72) + 40));
  v12 = *v9;
  *(_QWORD *)*v9 = v11;
  if (v11 == -1)
  {
    if (dword_10008BA20)
    {
      v18 = ne_log_obj(v12);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        sub_10005F43C();
    }
    goto LABEL_28;
  }
  v13 = sub_10003F34C(v12);
  v9[1] = (uint64_t)v13;
  if (!v13)
  {
    if (dword_10008BA20)
    {
      v19 = ne_log_obj(0);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        sub_10005F49C();
    }
    goto LABEL_28;
  }
  sub_10003F318(v3);
  v14 = *(_QWORD **)(a1 + 328);
  if (v14)
    sub_10002DA18(v14);
  result = 0;
  *(_QWORD *)(a1 + 328) = v9;
  return result;
}

void sub_10002DA18(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  NSObject *v4;

  if (a1)
  {
    v2 = (_QWORD *)*a1;
    if (v2)
      sub_10003F318(v2);
    v3 = (_QWORD *)a1[1];
    if (v3)
      sub_10003F318(v3);
    free(a1);
    if (dword_10008BA20)
    {
      v4 = ne_log_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        sub_10005F510();
    }
  }
}

uint64_t *sub_10002DA88(uint64_t a1, int a2)
{
  _QWORD *v4;
  _QWORD *v5;
  char *v6;
  void *v7;
  NSObject *v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  _QWORD *v14;
  NSObject *v15;
  NSObject *v16;
  NSObject *v17;
  NSObject *v18;

  v4 = sub_10003F1F8(***(_DWORD ***)(a1 + 328) + 4);
  if (v4)
  {
    v5 = v4;
    v6 = (char *)v4[1];
    v7 = memcpy(v6, *(const void **)(**(_QWORD **)(a1 + 328) + 8), ***(_QWORD ***)(a1 + 328));
    *(_DWORD *)&v6[***(_QWORD ***)(a1 + 328)] = a2;
    if (dword_10008BA20)
    {
      v8 = ne_log_obj(v7);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        sub_10005F53C();
    }
    v9 = (uint64_t *)malloc_type_calloc(1uLL, 0x10uLL, 0x20040A4A59CD2uLL);
    if (v9)
    {
      v10 = v9;
      v11 = sub_100029C9C((uint64_t)v5, a1);
      *v10 = v11;
      if (v11)
      {
        v12 = sub_100004288(*(_DWORD *)(*(_QWORD *)(a1 + 72) + 40));
        v13 = *v10;
        *(_QWORD *)*v10 = v12;
        if (v12 == -1)
        {
          if (dword_10008BA20)
          {
            v18 = ne_log_obj(v13);
            if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
              sub_10005F43C();
          }
        }
        else
        {
          v14 = sub_10003F34C(v13);
          v10[1] = (uint64_t)v14;
          if (v14)
          {
LABEL_24:
            sub_10003F318(v5);
            return v10;
          }
          if (dword_10008BA20)
          {
            v15 = ne_log_obj(0);
            if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
              sub_10005F49C();
          }
        }
      }
      sub_10002DA18(v10);
    }
    else if (dword_10008BA20)
    {
      v17 = ne_log_obj(0);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        sub_10005F410();
    }
    v10 = 0;
    goto LABEL_24;
  }
  if (dword_10008BA20)
  {
    v16 = ((uint64_t (*)(void))ne_log_obj)();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      sub_10005F410();
  }
  return 0;
}

_QWORD *sub_10002DC5C(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  NSObject *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  size_t v16;
  _QWORD *v17;
  _QWORD *v18;
  uint64_t *v19;
  uint64_t *v20;
  _BOOL8 v21;
  NSObject *v22;
  unsigned __int8 v23;
  NSObject *v24;
  NSObject *v25;
  NSObject *v26;
  NSObject *v27;
  _QWORD *v28;
  NSObject *v29;
  NSObject *v30;
  NSObject *v31;
  _QWORD *v32;
  _OWORD *v33;
  __int128 *v34;
  __int128 v35;
  void *v36;
  NSObject *v37;
  NSObject *v38;
  char v40;

  if (dword_10008BA20)
  {
    v8 = ne_log_obj(a1);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      sub_10005F7BC();
  }
  v9 = sub_100004288(*(_DWORD *)(*(_QWORD *)(a1 + 72) + 40));
  if ((_DWORD)v9 == -1)
  {
    if (dword_10008BA20)
    {
      v26 = ne_log_obj(v9);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        sub_10005F43C();
    }
    return 0;
  }
  v10 = v9;
  bzero(*(void **)(a4 + 8), *(_QWORD *)a4);
  memcpy(*(void **)(a4 + 8), (const void *)(a2[1] + *a2 - v10), v10);
  if (dword_1000882C8 >= 7)
    sub_10003372C(7, *(_QWORD *)(a4 + 8), *(_QWORD *)a4, "IV was saved for next processing:\n", v11, v12, v13, v14, v40);
  v15 = a2[1];
  v16 = *(_DWORD *)a2 - 28;
  v17 = sub_10003F1F8(v16);
  if (!v17)
  {
    if (dword_10008BA20)
    {
      v29 = ne_log_obj(0);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        sub_10005F568();
    }
    return 0;
  }
  v18 = v17;
  memcpy((void *)v17[1], (const void *)(v15 + 28), v16);
  v19 = (uint64_t *)sub_1000042D4(*(_DWORD *)(*(_QWORD *)(a1 + 72) + 40), (uint64_t)v18, *(_QWORD *)(a1 + 240), a3);
  v20 = v19;
  if (v19 && v19[1] && *v19)
  {
    sub_10003F318(v18);
    if (dword_10008BA20)
    {
      v22 = ne_log_obj(v21);
      v21 = os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG);
      if (v21)
        sub_10005F790();
    }
    if (*(_DWORD *)(qword_10008B848 + 264))
      v23 = *(_BYTE *)(*v20 + v20[1] - 1) + 1;
    else
      v23 = *(_BYTE *)(*v20 + v20[1] - 1);
    if (dword_10008BA20)
    {
      v24 = ne_log_obj(v21);
      v21 = os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG);
      if (v21)
        sub_10005F72C();
    }
    if (*(_DWORD *)(qword_10008B848 + 260))
    {
      if (*v20 < (unint64_t)v23)
      {
        if (dword_10008BA20)
        {
          v25 = ne_log_obj(v21);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
            sub_10005F678(v23, v20, v25);
        }
        goto LABEL_50;
      }
      *v20 -= v23;
      if (dword_10008BA20)
      {
        v31 = ne_log_obj(v21);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
          sub_10005F700();
      }
    }
    else if (dword_10008BA20)
    {
      v30 = ne_log_obj(v21);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
        sub_10005F64C();
    }
    v32 = sub_10003F1F8(*(_DWORD *)v20 + 28);
    if (v32)
    {
      v28 = v32;
      v33 = (_OWORD *)v32[1];
      v34 = (__int128 *)a2[1];
      v35 = *v34;
      *(_OWORD *)((char *)v33 + 12) = *(__int128 *)((char *)v34 + 12);
      *v33 = v35;
      v36 = memcpy((void *)(v32[1] + 28), (const void *)v20[1], *v20);
      *(_DWORD *)(v28[1] + 24) = bswap32(*(_DWORD *)v28);
      if (dword_10008BA20)
      {
        v37 = ne_log_obj(v36);
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
          sub_10005F620();
      }
      goto LABEL_51;
    }
    if (dword_10008BA20)
    {
      v38 = ne_log_obj(0);
      if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
        sub_10005F5F4();
    }
LABEL_50:
    v28 = 0;
LABEL_51:
    sub_10003F318(v20);
    return v28;
  }
  if (dword_10008BA20)
  {
    v27 = ne_log_obj(v19);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      sub_10005F594();
  }
  sub_10003F318(v18);
  v28 = 0;
  if (v20)
    goto LABEL_51;
  return v28;
}

_QWORD *sub_10002E000(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  NSObject *v5;

  if (*(_BYTE *)(a1 + 80) == 16)
    return sub_10002DC5C(a1, a2, a3, a4);
  if (dword_10008BA20)
  {
    v5 = ne_log_obj(a1);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      sub_10005F7E8();
  }
  return 0;
}

_QWORD *sub_10002E064(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  NSObject *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  NSObject *v14;
  _QWORD *v15;
  uint64_t v16;
  const void *v17;
  _BYTE *v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  _QWORD *v27;
  _OWORD *v28;
  __int128 *v29;
  __int128 v30;
  void *v31;
  NSObject *v32;
  NSObject *v33;
  NSObject *v34;
  NSObject *v35;
  NSObject *v36;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;

  if (dword_10008BA20)
  {
    v8 = ne_log_obj(a1);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      sub_10005F92C();
  }
  v9 = sub_100004288(*(_DWORD *)(*(_QWORD *)(a1 + 72) + 40));
  if ((_DWORD)v9 == -1)
  {
    if (dword_10008BA20)
    {
      v33 = ne_log_obj(v9);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
        sub_10005F43C();
    }
    return 0;
  }
  v10 = v9;
  v40 = a3;
  v11 = *(_QWORD *)(a2 + 8);
  v38 = a2;
  v12 = *(_DWORD *)a2 - 28;
  v13 = v9 + 28 - *(_DWORD *)a2 + v12 / (int)v9 * v9;
  v39 = a4;
  if (*(_DWORD *)(qword_10008B848 + 252))
  {
    v9 = sub_100006CC8();
    v13 += v10 + v10 * (v9 % (*(_DWORD *)(qword_10008B848 + 256) + 1));
  }
  if (dword_10008BA20)
  {
    v14 = ne_log_obj(v9);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      sub_10005F8CC();
  }
  v15 = sub_10003F1F8((v13 + v12));
  if (!v15)
  {
    if (dword_10008BA20)
    {
      v34 = ne_log_obj(0);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        sub_10005F814();
    }
    return 0;
  }
  v16 = (uint64_t)v15;
  v17 = (const void *)(v11 + 28);
  if (v13 && *(_DWORD *)(qword_10008B848 + 248))
  {
    v18 = (_BYTE *)(v15[1] + v12);
    v19 = v13;
    do
    {
      *v18++ = sub_100006CC8();
      --v19;
    }
    while (v19);
  }
  memcpy(*(void **)(v16 + 8), v17, v12);
  *(_BYTE *)(*(_QWORD *)(v16 + 8) + (v13 + v12 - 1)) = v13 - (*(_DWORD *)(qword_10008B848 + 264) != 0);
  if (dword_1000882C8 >= 7)
    sub_10003372C(7, *(_QWORD *)(v16 + 8), *(_QWORD *)v16, "About to encrypt %d bytes", v20, v21, v22, v23, *(_QWORD *)v16);
  v24 = sub_100004330(*(_DWORD *)(*(_QWORD *)(a1 + 72) + 40), v16, *(_QWORD *)(a1 + 240), v40);
  if (!v24)
  {
    if (dword_10008BA20)
    {
      v35 = ne_log_obj(0);
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        sub_10005F840();
    }
    sub_10003F318((_QWORD *)v16);
    return 0;
  }
  v25 = v24;
  sub_10003F318((_QWORD *)v16);
  bzero(*(void **)(v39 + 8), *(_QWORD *)v39);
  memcpy(*(void **)(v39 + 8), (const void *)(*(_QWORD *)(v25 + 8) + *(_QWORD *)v25 - v10), v10);
  v26 = sub_10003F1F8(*(_DWORD *)v25 + 28);
  v27 = v26;
  if (v26)
  {
    v28 = (_OWORD *)v26[1];
    v29 = *(__int128 **)(v38 + 8);
    v30 = *v29;
    *(_OWORD *)((char *)v28 + 12) = *(__int128 *)((char *)v29 + 12);
    *v28 = v30;
    v31 = memcpy((void *)(v26[1] + 28), *(const void **)(v25 + 8), *(_QWORD *)v25);
    *(_DWORD *)(v27[1] + 24) = bswap32(*(_DWORD *)v27);
    if (dword_10008BA20)
    {
      v32 = ne_log_obj(v31);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
        sub_10005F8A0();
    }
  }
  else if (dword_10008BA20)
  {
    v36 = ne_log_obj(0);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
      sub_10005F814();
  }
  sub_10003F318((_QWORD *)v25);
  return v27;
}

_QWORD *sub_10002E3DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  NSObject *v5;

  if (*(_BYTE *)(a1 + 80) == 16)
    return sub_10002E064(a1, a2, a3, a4);
  if (dword_10008BA20)
  {
    v5 = ne_log_obj(a1);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      sub_10005F958();
  }
  return 0;
}

void sub_10002E468(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x16u);
}

uint64_t sub_10002E47C(uint64_t a1)
{
  void *v1;
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  int v10;
  int v11;
  NSObject *v12;
  NSObject *v13;
  char *v14;
  char *v15;
  const char *v16;
  NSObject *v17;
  uint32_t v18;
  unint64_t v19;
  NSObject *v20;
  NSObject *v21;
  char *v22;
  int v23;
  char *v24;
  __int16 v25;
  char *v26;
  _OWORD v27[15];

  v1 = (void *)a1;
  memset(v27, 0, sizeof(v27));
  v2 = sub_100041CFC(a1, (uint64_t)v27);
  if ((_DWORD)v2)
  {
    if (dword_10008BA20)
    {
      v3 = ne_log_obj(v2);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        sub_10005FAF8();
    }
    goto LABEL_9;
  }
  v4 = sub_100041DFC((uint64_t)v27);
  if (!(_DWORD)v4)
  {
    v1 = *(void **)&v27[0];
    v8 = (unsigned __int8 *)(*(_QWORD *)&v27[0] + 1);
    v9 = (unsigned __int8 *)(*(_QWORD *)&v27[0] + 2);
    v10 = *(unsigned __int8 *)(*(_QWORD *)&v27[0] + 2);
    if (*(_BYTE *)(*(_QWORD *)&v27[0] + 2))
    {
      if (dword_10008BA20)
      {
        v11 = *v8;
        v12 = ne_log_obj(v4);
        v13 = v12;
        if (v10 != 2 || v11 != 18)
        {
          if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
            sub_10005F9E4();
          goto LABEL_30;
        }
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          v14 = sub_10003E7D0(*v8);
          v15 = strerror(*v9);
          v23 = 136315394;
          v24 = v14;
          v25 = 2080;
          v26 = v15;
          v16 = "pfkey %s failed: %s\n";
          v17 = v13;
          v18 = 22;
LABEL_29:
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, v16, (uint8_t *)&v23, v18);
        }
      }
    }
    else
    {
      v19 = *v8;
      if (v19 >= 0x1B)
      {
        if (dword_10008BA20)
        {
          v20 = ne_log_obj(v4);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
            sub_10005F984();
        }
        goto LABEL_30;
      }
      if (((0x7521CA1uLL >> v19) & 1) == 0)
      {
        v6 = (qword_100084F78[v19](v27) >> 31);
        goto LABEL_10;
      }
      if (dword_10008BA20)
      {
        v21 = ne_log_obj(v4);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          v22 = sub_10003E7D0(*v8);
          v23 = 136315138;
          v24 = v22;
          v16 = "unsupported PF_KEY message %s\n";
          v17 = v21;
          v18 = 12;
          goto LABEL_29;
        }
      }
    }
LABEL_30:
    v6 = 0xFFFFFFFFLL;
    goto LABEL_10;
  }
  if (dword_10008BA20)
  {
    v5 = ne_log_obj(v4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      sub_10005FA90();
  }
LABEL_9:
  v6 = 0xFFFFFFFFLL;
  if (v1)
LABEL_10:
    free(v1);
  return v6;
}

void sub_10002E730(uint64_t a1)
{
  NSObject *v1;
  void *v2;
  NSObject *v3;
  NSObject *v4;
  uint8_t v5[8];
  unint64_t v6;

  if (xmmword_10008C6E0 == 0)
  {
    v6 = 0;
    v2 = sub_10002E84C(*(_DWORD *)(qword_10008B848 + 32), &v6);
    if (v2)
    {
      sub_10002E47C((uint64_t)v2);
    }
    else if ((v6 & 0x8000000000000000) != 0)
    {
      if (dword_10008BA20)
      {
        v4 = ne_log_obj(0);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
          sub_10005FB8C();
      }
    }
    else if (dword_10008BA20)
    {
      v3 = ne_log_obj(0);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v5 = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "recv short message from pfkey\n", v5, 2u);
      }
    }
  }
  else if (dword_10008BA20)
  {
    v1 = ne_log_obj(a1);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG))
      sub_10005FB60();
  }
}

void *sub_10002E84C(int a1, unint64_t *a2)
{
  void *v4;
  unint64_t v5;
  int *v6;
  NSObject *v7;
  socklen_t v10;
  size_t size;

  v10 = 4;
  LODWORD(size) = 0;
  if (getsockopt(a1, 0xFFFF, 4128, &size, &v10) < 0 || !(_DWORD)size)
    return 0;
  v4 = malloc_type_calloc(1uLL, (int)size, 0xD32FE939uLL);
  if (v4)
  {
    do
    {
      v5 = recv(a1, v4, (int)size, 0);
      *a2 = v5;
      if ((v5 & 0x8000000000000000) == 0)
        goto LABEL_10;
      v6 = __error();
    }
    while (*v6 == 4);
    if (dword_10008BA20)
    {
      v7 = ne_log_obj(v6);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_10005FC00();
    }
    v5 = *a2;
    if ((*a2 & 0x8000000000000000) != 0)
    {
LABEL_14:
      free(v4);
      return 0;
    }
LABEL_10:
    if (v5 < 0x10 || v5 != (int)size)
      goto LABEL_14;
  }
  return v4;
}

void sub_10002E940(uint64_t a1)
{
  NSObject *v1;
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  __int16 v6[8];

  if (xmmword_10008C6E0 == 0)
  {
    v2 = *(_QWORD **)(qword_10008B848 + 96);
    if (v2)
    {
      do
      {
        v3 = (_QWORD *)*v2;
        sub_10002E47C(v2[2]);
        v4 = (_QWORD *)*v2;
        v5 = (_QWORD *)v2[1];
        if (*v2)
        {
          v4[1] = v5;
          v5 = (_QWORD *)v2[1];
        }
        else
        {
          *(_QWORD *)(qword_10008B848 + 104) = v5;
        }
        *v5 = v4;
        free(v2);
        v2 = v3;
      }
      while (v3);
    }
  }
  else if (dword_10008BA20)
  {
    v1 = ne_log_obj(a1);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      v6[0] = 0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "ignoring (saved) pfkey messages until power-mgmt event is handled.\n", (uint8_t *)v6, 2u);
    }
  }
}

uint64_t sub_10002EA28(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t result;
  _QWORD *v5;

  v2 = malloc_type_calloc(0x18uLL, 1uLL, 0x54107A01uLL);
  if (!v2)
    return 0xFFFFFFFFLL;
  v3 = v2;
  result = 0;
  *v3 = 0;
  v5 = *(_QWORD **)(qword_10008B848 + 104);
  v3[1] = v5;
  v3[2] = a1;
  *v5 = v3;
  *(_QWORD *)(qword_10008B848 + 104) = v3;
  return result;
}

void **sub_10002EA90(unsigned int a1)
{
  pid_t v2;
  uint64_t v3;
  int v4;
  NSObject *v5;
  uint64_t v6;
  void **v7;
  _DWORD *v8;
  _DWORD *v9;
  char *v10;
  size_t v11;
  void **v12;
  NSObject *v13;
  NSObject *v14;
  NSObject *v16;
  unint64_t v17;

  v2 = getpid();
  v17 = 0;
  v3 = sub_100041BDC();
  if ((v3 & 0x80000000) != 0)
  {
    if (dword_10008BA20)
    {
      v13 = ne_log_obj(v3);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        sub_10005FC74();
    }
    return 0;
  }
  else
  {
    v4 = v3;
    if (dword_10008BA20)
    {
      v5 = ne_log_obj(v3);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
        sub_10005FD70();
    }
    v6 = sub_10004143C(v4, a1);
    if ((v6 & 0x80000000) != 0)
    {
      if (dword_10008BA20)
      {
        v14 = ne_log_obj(v6);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
          sub_10005FCDC();
      }
      v7 = 0;
    }
    else
    {
      v7 = 0;
LABEL_7:
      v8 = 0;
      while (1)
      {
        do
        {
          while (1)
          {
            if (v8)
              free(v8);
            v9 = sub_10002E84C(v4, &v17);
            v8 = v9;
            if (v9)
              break;
            if ((v17 & 0x8000000000000000) != 0)
              goto LABEL_30;
          }
          if (*((_BYTE *)v9 + 1) != 10)
          {
            sub_10002EA28((uint64_t)v9);
            goto LABEL_7;
          }
        }
        while (v9[3] != v2);
        v10 = v7 ? (char *)*v7 : 0;
        v11 = 8 * *((unsigned __int16 *)v9 + 2);
        v12 = sub_10003F270(v7, (size_t)&v10[v11]);
        v7 = v12;
        if (!v12)
          break;
        memcpy(&v10[(_QWORD)v12[1]], v8, v11);
        if (!v8[2])
          goto LABEL_35;
      }
      if (dword_10008BA20)
      {
        v16 = ne_log_obj(0);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          sub_10005FD44();
      }
LABEL_35:
      free(v8);
    }
LABEL_30:
    sub_100041CDC(v4);
  }
  return v7;
}

uint64_t sub_10002EC60()
{
  uint64_t v0;
  uint64_t v1;
  int v2;
  char **v3;
  NSObject *v4;
  NSObject *v5;
  char *v6;
  const char *v7;
  NSObject *v8;
  NSObject *v9;
  NSObject *v10;
  int v11;
  NSObject *v12;
  uint64_t v13;
  NSObject *v15;
  NSObject *v16;
  _QWORD handler[4];
  int v18;
  uint8_t buf[4];
  char *v20;
  __int16 v21;
  const char *v22;
  uint8_t v23[4];
  uint64_t v24;

  v0 = sub_100041BDC();
  *(_DWORD *)(qword_10008B848 + 32) = v0;
  if ((v0 & 0x80000000) != 0)
  {
    if (dword_10008BA20)
    {
      v9 = ne_log_obj(v0);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_10005FD9C();
    }
  }
  else
  {
    v1 = 0;
    v2 = 0;
    v3 = &off_100085058;
    do
    {
      if (dword_10008BA20)
      {
        v4 = ne_log_obj(v0);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
          sub_10005FEC4(v23, v1, &v24, v4);
      }
      v0 = sub_100040F34(*(_DWORD *)(qword_10008B848 + 32), *((unsigned __int8 *)v3 - 8));
      if ((v0 & 0x80000000) != 0 || (v0 = sub_1000410F4(*(_DWORD *)(qword_10008B848 + 32)), (v0 & 0x80000000) != 0))
      {
        if (dword_10008BA20)
        {
          v5 = ne_log_obj(v0);
          v0 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
          if ((_DWORD)v0)
          {
            v6 = *v3;
            v7 = ipsec_strerror();
            *(_DWORD *)buf = 136315394;
            v20 = v6;
            v21 = 2080;
            v22 = v7;
            _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "failed to register %s (%s)\n", buf, 0x16u);
          }
        }
        ++v2;
      }
      ++v1;
      v3 += 2;
    }
    while (v1 != 3);
    if (v2 == 3)
    {
      if (dword_10008BA20)
      {
        v8 = ne_log_obj(v0);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
          sub_10005FE04();
      }
      close(*(_DWORD *)(qword_10008B848 + 32));
    }
    else
    {
      sub_100035294();
      v10 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, *(int *)(qword_10008B848 + 32), 0, (dispatch_queue_t)&_dispatch_main_q);
      *(_QWORD *)(qword_10008B848 + 48) = v10;
      if (v10)
      {
        dispatch_source_set_event_handler_f(v10, (dispatch_function_t)sub_10002E730);
        v11 = *(_DWORD *)(qword_10008B848 + 32);
        v12 = *(NSObject **)(qword_10008B848 + 48);
        handler[0] = _NSConcreteStackBlock;
        handler[1] = 0x40000000;
        handler[2] = sub_10002EF68;
        handler[3] = &unk_100085080;
        v18 = v11;
        dispatch_source_set_cancel_handler(v12, handler);
        dispatch_resume(*(dispatch_object_t *)(qword_10008B848 + 48));
        v13 = sub_100041BD0(*(_DWORD *)(qword_10008B848 + 32));
        if ((v13 & 0x80000000) == 0)
          return 0;
        if (dword_10008BA20)
        {
          v16 = ne_log_obj(v13);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
            sub_10005FE5C();
        }
        dispatch_source_cancel(*(dispatch_source_t *)(qword_10008B848 + 48));
        *(_QWORD *)(qword_10008B848 + 48) = 0;
      }
      else if (dword_10008BA20)
      {
        v15 = ne_log_obj(0);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          sub_10005FE30();
      }
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_10002EF68(uint64_t a1)
{
  return sub_100041CDC(*(_DWORD *)(a1 + 32));
}

void sub_10002EF70()
{
  dispatch_source_cancel(*(dispatch_source_t *)(qword_10008B848 + 48));
  *(_QWORD *)(qword_10008B848 + 48) = 0;
}

uint64_t sub_10002EFA4(uint64_t a1)
{
  NSObject *v2;

  if ((a1 - 2) < 3)
    return dword_10006A1E8[(int)a1 - 2];
  if (dword_10008BA20)
  {
    v2 = ne_log_obj(a1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_10005FF14();
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_10002F014(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;

  v1 = a1;
  if ((_DWORD)a1 != 2)
  {
    if ((_DWORD)a1 == 9)
    {
      return 4;
    }
    else if ((_DWORD)a1 != 3)
    {
      if (dword_10008BA20)
      {
        v2 = ne_log_obj(a1);
        if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
          sub_10005FF74();
      }
      return 0xFFFFFFFFLL;
    }
  }
  return v1;
}

uint64_t sub_10002F08C(int a1)
{
  uint64_t result;
  NSObject *v3;

  result = 2;
  switch(a1)
  {
    case 1:
    case 3:
      return result;
    case 2:
    case 4:
      goto LABEL_4;
    default:
      if (a1 != 61443)
      {
        if (a1 == 61444)
        {
LABEL_4:
          result = 1;
        }
        else
        {
          if (dword_10008BA20)
          {
            v3 = ne_log_obj(2);
            if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
              sub_10005FFD4();
          }
          result = 0xFFFFFFFFLL;
        }
      }
      break;
  }
  return result;
}

uint64_t sub_10002F128(uint64_t a1)
{
  NSObject *v2;

  if (a1 < 3)
    return dword_10006A1F4[(int)a1];
  if (dword_10008BA20)
  {
    v2 = ne_log_obj(a1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_10005FFD4();
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_10002F194(uint64_t a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5, unsigned int *a6, _DWORD *a7, unsigned int *a8, _DWORD *a9)
{
  int v15;
  uint64_t v16;
  NSObject *v17;
  int v18;
  unsigned int v19;
  uint64_t result;
  NSObject *v21;
  int v22;
  NSObject *v23;
  NSObject *v24;
  int v25;
  uint64_t v26;
  NSObject *v27;

  *a9 = 0;
  if (a2 != 2)
  {
    if (a2 == 4)
    {
      v22 = sub_10002F608(a3);
      *a5 = v22;
      if (v22 != -1)
      {
        result = 0;
        *a6 = 0;
        *a9 = 128;
        *a7 = 0;
        *a8 = 0;
        if (*a5)
          return result;
        if (dword_10008BA20)
        {
          v23 = ne_log_obj(0);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
            sub_100060118();
        }
      }
    }
    else if (a2 == 3)
    {
      v15 = sub_10002F41C(a3);
      *a5 = v15;
      if (v15 != -1)
      {
        v16 = sub_1000043C4(a3, *a6);
        if ((_DWORD)v16 == -1 && dword_10008BA20)
        {
          v17 = ne_log_obj(v16);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
            sub_10006008C();
          *a6 = -1;
        }
        else
        {
          *a6 = v16;
          if ((_DWORD)v16 != -1)
          {
            *a6 = v16 >> 3;
            v25 = sub_10002F4F4(a4);
            *a7 = v25;
            if (v25 != -1)
            {
              v26 = sub_10002F5A4(a4);
              *a8 = v26;
              if ((_DWORD)v26 != -1)
              {
                *a8 = v26 >> 3;
                if (*a5)
                  return 0;
                if (dword_10008BA20)
                {
                  v27 = ne_log_obj(v26);
                  if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
                    sub_100060060();
                }
              }
            }
          }
        }
      }
    }
    else if (dword_10008BA20)
    {
      v24 = ne_log_obj(a1);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        sub_100060034();
    }
    goto LABEL_27;
  }
  v18 = sub_10002F4F4(a4);
  *a7 = v18;
  if (v18 == -1 || (v19 = sub_10002F5A4(a4), *a8 = v19, v19 == -1))
  {
LABEL_27:
    *__error() = 22;
    return 0xFFFFFFFFLL;
  }
  *a8 = v19 >> 3;
  if ((_DWORD)a3 == 1 && (_DWORD)a4 == 4)
  {
    *a7 = 3;
    *a9 |= 1u;
  }
  result = 0;
  *a5 = 0;
  *a6 = 0;
  if (!*a7)
  {
    if (dword_10008BA20)
    {
      v21 = ne_log_obj(0);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        sub_1000600EC();
    }
    goto LABEL_27;
  }
  return result;
}

uint64_t sub_10002F41C(int a1)
{
  int v1;
  uint64_t result;
  NSObject *v3;
  NSObject *v4;

  v1 = a1 - 1;
  result = 1;
  switch(v1)
  {
    case 0:
    case 1:
    case 8:
      return result;
    case 2:
      result = 2;
      break;
    case 4:
    case 7:
    case 9:
      if (dword_10008BA20)
      {
        v3 = ne_log_obj(1);
        if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
          sub_1000601A4();
      }
      goto LABEL_9;
    case 5:
      result = 5;
      break;
    case 6:
      result = 4;
      break;
    case 10:
      result = 3;
      break;
    case 11:
      result = 12;
      break;
    default:
      if (dword_10008BA20)
      {
        v4 = ne_log_obj(1);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
          sub_100060144();
      }
LABEL_9:
      result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t sub_10002F4F4(int a1)
{
  uint64_t result;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  result = 1;
  switch(a1)
  {
    case 1:
      return result;
    case 2:
      return 2;
    case 3:
      if (dword_10008BA20)
      {
        v3 = ne_log_obj(1);
        if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
          sub_100060204(v3, v4, v5, v6, v7, v8, v9, v10);
      }
      return 0xFFFFFFFFLL;
    case 4:
      return 0;
    case 5:
      return 6;
    case 6:
      return 7;
    case 7:
      return 8;
    default:
      if (a1 == 252)
        return result;
      if (a1 == 253)
        return 2;
      else
        return 0;
  }
}

uint64_t sub_10002F5A4(uint64_t result)
{
  NSObject *v1;

  if ((_DWORD)result)
  {
    result = sub_10000449C(result);
    if ((_DWORD)result == -1)
    {
      if (dword_10008BA20)
      {
        v1 = ne_log_obj(result);
        if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
          sub_100060270();
      }
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t sub_10002F608(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;

  v1 = a1;
  if ((a1 - 1) >= 3)
  {
    if (dword_10008BA20)
    {
      v2 = ne_log_obj(a1);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_100060144();
    }
    return 0xFFFFFFFFLL;
  }
  return v1;
}

uint64_t sub_10002F670(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;

  if (dword_10008BA20)
  {
    v2 = ne_log_obj(a1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1000602D0(a1);
  }
  v3 = *(unsigned int *)(a1 + 64);
  if ((_DWORD)v3)
  {
    sub_10003A6F0(v3);
    *(_DWORD *)(a1 + 64) = 0;
  }
  if (!*(_BYTE *)(a1 + 60))
    sub_10002F6E8(a1);
  return sub_10004A9EC((_QWORD *)a1);
}

uint64_t sub_10002F6E8(uint64_t a1)
{
  char *v2;
  void *v3;
  NSObject *v5;

  v2 = (char *)malloc_type_calloc(1uLL, 0x10uLL, 0x764284ADuLL);
  if (v2)
  {
    v3 = v2;
    *((_QWORD *)v2 + 1) = 0;
    *(_QWORD *)(v2 + 3) = 0;
    *(_WORD *)v2 = 1538;
    v2[2] = 2;
    v2[3] = *(_BYTE *)(a1 + 104);
    *((_WORD *)v2 + 2) = 2;
    *((_DWORD *)v2 + 2) = *(_DWORD *)(a1 + 100);
    *((_DWORD *)v2 + 3) = getpid();
    sub_1000405B4(*(_DWORD *)(qword_10008B848 + 32), v3, 0x10u);
    free(v3);
    return 0;
  }
  else
  {
    if (dword_10008BA20)
    {
      v5 = ne_log_obj(0);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_100060338();
    }
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_10002F7B4(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  sockaddr **v4;
  sockaddr **v5;
  unsigned int *v6;
  sockaddr *v7;
  sockaddr *v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v16;
  NSObject *v17;
  char *v18;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  int v23;
  uint8_t v24;
  _BYTE v25[15];
  uint8_t buf[4];
  char *v27;

  if (*(_BYTE *)(a1 + 60))
  {
    v2 = *(_QWORD *)(a1 + 128);
    v3 = *(_QWORD *)(a1 + 112);
    if (!v3 || !*(_QWORD *)(v3 + 40))
      goto LABEL_9;
LABEL_6:
    v4 = (sockaddr **)(a1 + 32);
    if (*(_QWORD *)(a1 + 32))
    {
      v5 = (sockaddr **)(a1 + 40);
      if (*(_QWORD *)(a1 + 40))
      {
        if (sub_10000F5FC(v2))
          goto LABEL_10;
      }
    }
    goto LABEL_9;
  }
  v2 = *(_QWORD *)(a1 + 120);
  if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 256) + 64) + 160))
    goto LABEL_6;
LABEL_9:
  v5 = (sockaddr **)(a1 + 8);
  v4 = (sockaddr **)a1;
LABEL_10:
  v6 = *(unsigned int **)(v2 + 32);
  if (!v6)
    return 0;
  v7 = *v5;
  v8 = *v4;
  while (1)
  {
    v9 = sub_10002EFA4(*v6);
    v10 = v9;
    if ((_DWORD)v9 != 9)
      break;
    v12 = 0xFFFF;
    v11 = 256;
LABEL_16:
    v13 = sub_10002F08C(v6[4]);
    if ((_DWORD)v13 == -1)
    {
      if (dword_10008BA20)
      {
        v20 = ne_log_obj(v13);
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          sub_100060364();
      }
      return 0xFFFFFFFFLL;
    }
    v14 = v13;
    if (dword_10008BA20)
    {
      v15 = ne_log_obj(v13);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
        sub_10006042C(&v24, v25, v15);
    }
    v16 = sub_100040148(*(_DWORD *)(qword_10008B848 + 32), v10, v14, &v7->sa_len, &v8->sa_len, v11, v12, v6[13], 0, v23, 0, 0, *(_DWORD *)(a1 + 100), 0);
    if ((v16 & 0x80000000) != 0)
    {
      if (dword_10008BA20)
      {
        v21 = ne_log_obj(v16);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          sub_1000603C4();
      }
      return 0xFFFFFFFFLL;
    }
    if (dword_10008BA20)
    {
      v17 = ne_log_obj(v16);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        v18 = sub_10002FA64(v7, v8, v10, 0, v14);
        *(_DWORD *)buf = 136315138;
        v27 = v18;
        _os_log_debug_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "pfkey GETSPI sent: %s\n", buf, 0xCu);
      }
    }
    v6 = (unsigned int *)*((_QWORD *)v6 + 9);
    if (!v6)
      return 0;
  }
  if ((_DWORD)v9 != -1)
  {
    v11 = 0;
    v12 = 0;
    goto LABEL_16;
  }
  if (dword_10008BA20)
  {
    v22 = ne_log_obj(v9);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      sub_100060468();
  }
  return 0xFFFFFFFFLL;
}

char *sub_10002FA64(const sockaddr *a1, const sockaddr *a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  int v9;
  int v10;
  int v11;
  int v12;
  char *v13;
  char *v14;
  const char *v15;
  unsigned int v16;
  char *result;
  char *v18;
  size_t v19;
  uint64_t *v20;
  int v21;
  int v22;
  char *v23;
  uint64_t *v24;
  int v25;
  uint64_t v26;

  v9 = sub_10002F014(a3);
  if (v9 == -1)
    return 0;
  v10 = v9;
  if ((_DWORD)a5)
  {
    v11 = sub_10002F128(a5);
    if (v11 == -1)
      return 0;
    v12 = v11;
    v13 = sub_10003DCFC(v10);
    v14 = sub_10003E0A4(v12);
    v15 = "/";
  }
  else
  {
    v13 = sub_10003DCFC(v9);
    v15 = (const char *)&unk_10007E079;
    v14 = (char *)&unk_10007E079;
  }
  v16 = snprintf(byte_100088C11, 0xFFuLL, "%s%s%s ", v13, v15, v14);
  if (v16 > 0xFE)
    return 0;
  v18 = &byte_100088C11[v16];
  v19 = 255 - v16;
  v20 = sub_10003C570(a1);
  v21 = snprintf(v18, v19, "%s->", (const char *)v20);
  result = 0;
  if ((v21 & 0x80000000) == 0)
  {
    v22 = v19 - v21;
    if ((int)v19 > v21)
    {
      v23 = &v18[v21];
      v24 = sub_10003C570(a2);
      v25 = snprintf(v23, v22, "%s ", (const char *)v24);
      result = 0;
      if ((v25 & 0x80000000) == 0 && v22 > v25)
      {
        if (a4)
        {
          v26 = bswap32(a4);
          snprintf(&v23[v25], v22 - v25, "spi=%lu(0x%lx)", v26, v26);
        }
        return byte_100088C11;
      }
    }
  }
  return result;
}

uint64_t sub_10002FBE0(uint64_t a1)
{
  BOOL v2;
  NSObject *v3;
  uint64_t v4;
  unsigned __int8 **v5;
  unsigned __int8 **v6;
  unsigned int *v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  char v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  unsigned int *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  __int16 v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  uint64_t v27;
  NSObject *v29;
  NSObject *v30;
  NSObject *v31;
  __int16 v32;
  int v33;
  unsigned int v34;
  int v35;
  unsigned int v36;
  int v37;
  uint8_t buf[4];
  int v39;
  __int16 v40;
  unsigned int v41;
  __int16 v42;
  int v43;
  __int16 v44;
  unsigned int v45;

  v37 = 0;
  v35 = 0;
  v33 = 0;
  if (*(_QWORD *)(a1 + 128))
    v2 = 1;
  else
    v2 = dword_10008BA20 == 0;
  if (!v2)
  {
    v3 = ne_log_obj(a1);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      sub_1000605F0();
  }
  if (*(_BYTE *)(a1 + 60))
  {
    v4 = *(_QWORD *)(a1 + 112);
    if (!v4 || !*(_QWORD *)(v4 + 40))
      goto LABEL_15;
LABEL_12:
    v5 = (unsigned __int8 **)(a1 + 32);
    if (*(_QWORD *)(a1 + 32))
    {
      v6 = (unsigned __int8 **)(a1 + 40);
      if (*(_QWORD *)(a1 + 40))
      {
        if (sub_10000F5FC(*(_QWORD *)(a1 + 128)))
          goto LABEL_16;
      }
    }
    goto LABEL_15;
  }
  if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 256) + 64) + 160))
    goto LABEL_12;
LABEL_15:
  v6 = (unsigned __int8 **)(a1 + 8);
  v5 = (unsigned __int8 **)a1;
LABEL_16:
  v7 = *(unsigned int **)(*(_QWORD *)(a1 + 128) + 32);
  if (!v7)
    return 0;
  v8 = *v6;
  v9 = *v5;
  v10 = 4;
  while (1)
  {
    v11 = sub_10002EFA4(*v7);
    v12 = v11;
    if ((_DWORD)v11 == 9)
    {
      v10 = 0;
    }
    else if ((_DWORD)v11 == -1)
    {
      if (dword_10008BA20)
      {
        v31 = ne_log_obj(v11);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
          sub_100060590();
      }
      return 0xFFFFFFFFLL;
    }
    v13 = sub_10002F08C(v7[4]);
    if ((_DWORD)v13 == -1)
      break;
    v14 = v13;
    v15 = (unsigned int *)*((_QWORD *)v7 + 8);
    v16 = v15[1];
    v36 = v15[2];
    v17 = v15[3];
    v34 = 0;
    v18 = sub_10002F194(v13, *v7, v16, v17, &v37, &v36, &v35, &v34, &v33);
    if ((v18 & 0x80000000) != 0)
      return 0xFFFFFFFFLL;
    if (dword_10008BA20)
    {
      v19 = ne_log_obj(v18);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 67109888;
        v39 = v37;
        v40 = 1024;
        v41 = v36;
        v42 = 1024;
        v43 = v35;
        v44 = 1024;
        v45 = v34;
        _os_log_debug_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "call pfkey_send_update: e_type %d, e_klen %d, a_type %d, a_klen %d\n", buf, 0x1Au);
      }
    }
    if (!v7[5])
    {
      v20 = 0;
      v22 = v33;
      goto LABEL_41;
    }
    v20 = sub_10003D25C(*(_QWORD *)(*(_QWORD *)(a1 + 256) + 48));
    v21 = v33;
    v22 = v33 | 2;
    v33 |= 2u;
    v23 = *(_QWORD *)(a1 + 256);
    v24 = *(_QWORD *)(v23 + 64);
    if (v14 == 1 && *(_DWORD *)(v24 + 180) == 1 && v9[1] == 2)
    {
      v22 = v21 | 0xA;
      v33 = v21 | 0xA;
      if ((*(_BYTE *)(v23 + 96) & 4) == 0)
        goto LABEL_41;
      v25 = 4106;
LABEL_36:
      v22 = v21 | v25;
      goto LABEL_40;
    }
    v26 = *(_DWORD *)(v23 + 96);
    if ((v26 & 2) == 0)
    {
      if ((v26 & 4) == 0)
        goto LABEL_41;
      v25 = 4098;
      goto LABEL_36;
    }
    if (*(_DWORD *)(v24 + 184) != 1)
      goto LABEL_41;
    v22 = v21 | 6;
LABEL_40:
    v33 = v22;
LABEL_41:
    v27 = sub_1000405F8(*(_DWORD *)(qword_10008B848 + 32), v12, v14, v8, v9, v7[6], v7[13], v10, *(char **)(*((_QWORD *)v7 + 4) + 8), v37, v36, v35, v34, v22, 0, 0, 0, *(_QWORD *)(*(_QWORD *)(a1 + 128) + 8), HIDWORD(*(_QWORD *)(*(_QWORD *)(a1 + 128) + 8)),
            0,
            0,
            *(_DWORD *)(a1 + 100),
            v20,
            v32,
            0);
    if ((v27 & 0x80000000) != 0)
    {
      if (dword_10008BA20)
      {
        v30 = ne_log_obj(v27);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
          sub_100060528();
      }
      return 0xFFFFFFFFLL;
    }
    v7 = (unsigned int *)*((_QWORD *)v7 + 9);
    if (!v7)
      return 0;
  }
  if (dword_10008BA20)
  {
    v29 = ne_log_obj(v13);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      sub_1000604C8();
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_10002FFB8(uint64_t a1)
{
  BOOL v2;
  NSObject *v3;
  uint64_t v4;
  unsigned __int8 **v5;
  unsigned __int8 **v6;
  unsigned int *v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  char v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  unsigned int *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  __int16 v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  uint64_t v27;
  NSObject *v29;
  NSObject *v30;
  NSObject *v31;
  __int16 v32;
  int v33;
  unsigned int v34;
  int v35;
  unsigned int v36;
  int v37;
  uint8_t buf[4];
  int v39;
  __int16 v40;
  unsigned int v41;
  __int16 v42;
  int v43;
  __int16 v44;
  unsigned int v45;

  v37 = 0;
  v35 = 0;
  v33 = 0;
  if (*(_QWORD *)(a1 + 128))
    v2 = 1;
  else
    v2 = dword_10008BA20 == 0;
  if (!v2)
  {
    v3 = ne_log_obj(a1);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      sub_100060684();
  }
  if (*(_BYTE *)(a1 + 60))
  {
    v4 = *(_QWORD *)(a1 + 112);
    if (!v4 || !*(_QWORD *)(v4 + 40))
      goto LABEL_15;
LABEL_12:
    v5 = (unsigned __int8 **)(a1 + 32);
    if (*(_QWORD *)(a1 + 32))
    {
      v6 = (unsigned __int8 **)(a1 + 40);
      if (*(_QWORD *)(a1 + 40))
      {
        if (sub_10000F5FC(*(_QWORD *)(a1 + 128)))
          goto LABEL_16;
      }
    }
    goto LABEL_15;
  }
  if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 256) + 64) + 160))
    goto LABEL_12;
LABEL_15:
  v6 = (unsigned __int8 **)(a1 + 8);
  v5 = (unsigned __int8 **)a1;
LABEL_16:
  v7 = *(unsigned int **)(*(_QWORD *)(a1 + 128) + 32);
  if (!v7)
    return 0;
  v8 = *v6;
  v9 = *v5;
  v10 = 4;
  while (1)
  {
    v11 = sub_10002EFA4(*v7);
    v12 = v11;
    if ((_DWORD)v11 == 9)
    {
      v10 = 0;
    }
    else if ((_DWORD)v11 == -1)
    {
      if (dword_10008BA20)
      {
        v31 = ne_log_obj(v11);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
          sub_100060468();
      }
      return 0xFFFFFFFFLL;
    }
    v13 = sub_10002F08C(v7[4]);
    if ((_DWORD)v13 == -1)
      break;
    v14 = v13;
    v15 = (unsigned int *)*((_QWORD *)v7 + 8);
    v16 = v15[1];
    v36 = v15[2];
    v17 = v15[3];
    v34 = 0;
    v18 = sub_10002F194(v13, *v7, v16, v17, &v37, &v36, &v35, &v34, &v33);
    if ((v18 & 0x80000000) != 0)
      return 0xFFFFFFFFLL;
    if (dword_10008BA20)
    {
      v19 = ne_log_obj(v18);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 67109888;
        v39 = v37;
        v40 = 1024;
        v41 = v36;
        v42 = 1024;
        v43 = v35;
        v44 = 1024;
        v45 = v34;
        _os_log_debug_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "call pfkey_send_add: e_type %d, e_klen %d, a_type %d, a_klen %d\n", buf, 0x1Au);
      }
    }
    if (!v7[5])
    {
      v20 = 0;
      v22 = v33;
      goto LABEL_41;
    }
    v20 = sub_10003D25C(*(_QWORD *)(*(_QWORD *)(a1 + 256) + 48));
    v21 = v33;
    v22 = v33 | 2;
    v33 |= 2u;
    v23 = *(_QWORD *)(a1 + 256);
    v24 = *(_QWORD *)(v23 + 64);
    if (v14 == 1 && *(_DWORD *)(v24 + 180) == 1 && v9[1] == 2)
    {
      v22 = v21 | 0xA;
      v33 = v21 | 0xA;
      if ((*(_BYTE *)(v23 + 96) & 4) == 0)
        goto LABEL_41;
      v25 = 4106;
LABEL_36:
      v22 = v21 | v25;
      goto LABEL_40;
    }
    v26 = *(_DWORD *)(v23 + 96);
    if ((v26 & 2) == 0)
    {
      if ((v26 & 4) == 0)
        goto LABEL_41;
      v25 = 4098;
      goto LABEL_36;
    }
    if (*(_DWORD *)(v24 + 184) != 1)
      goto LABEL_41;
    v22 = v21 | 6;
LABEL_40:
    v33 = v22;
LABEL_41:
    v27 = sub_100040B08(*(_DWORD *)(qword_10008B848 + 32), v12, v14, v9, v8, v7[7], v7[12], v10, *(char **)(*((_QWORD *)v7 + 5) + 8), v37, v36, v35, v34, v22, 0, 0, 0, *(_QWORD *)(*(_QWORD *)(a1 + 128) + 8), HIDWORD(*(_QWORD *)(*(_QWORD *)(a1 + 128) + 8)),
            0,
            0,
            *(_DWORD *)(a1 + 100),
            v20,
            v32,
            0);
    if ((v27 & 0x80000000) != 0)
    {
      if (dword_10008BA20)
      {
        v30 = ne_log_obj(v27);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
          sub_10006061C();
      }
      return 0xFFFFFFFFLL;
    }
    v7 = (unsigned int *)*((_QWORD *)v7 + 9);
    if (!v7)
      return 0;
  }
  if (dword_10008BA20)
  {
    v29 = ne_log_obj(v13);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      sub_100060364();
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100030390(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  unsigned __int8 *v6;
  unsigned int v7;
  unsigned __int8 *v8;
  unsigned int v9;
  __int16 v10;
  void *v11;
  ssize_t v12;
  NSObject *v13;
  NSObject *v14;
  int v15;
  uint64_t v16;

  v16 = 0;
  v15 = 0;
  v1 = *(_QWORD *)(a1 + 136);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 128) + 8);
  v3 = sub_1000304C0(&v16, &v15, 13, (const void **)a1);
  if (!(_DWORD)v3)
  {
    v6 = (unsigned __int8 *)(v1 + 8);
    v7 = *(unsigned __int8 *)(v1 + 264);
    v8 = (unsigned __int8 *)(v1 + 136);
    v9 = *(unsigned __int8 *)(v1 + 265);
    v10 = *(_WORD *)(v1 + 266);
    v11 = (void *)v16;
    v12 = sub_100041960(*(_DWORD *)(qword_10008B848 + 32), v6, v7, v8, v9, v10, v2, 0, (void *)v16, v15, 0);
    if ((v12 & 0x80000000) != 0)
    {
      if (dword_10008BA20)
      {
        v14 = ne_log_obj(v12);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          sub_1000606B0();
          if (!v11)
            return 0;
          goto LABEL_14;
        }
      }
    }
    else if (dword_10008BA20)
    {
      v13 = ne_log_obj(v12);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        sub_100060718();
        if (!v11)
          return 0;
        goto LABEL_14;
      }
    }
    if (!v11)
      return 0;
LABEL_14:
    free(v11);
    return 0;
  }
  if (dword_10008BA20)
  {
    v4 = ne_log_obj(v3);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      sub_100060744();
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_1000304C0(_QWORD *a1, int *a2, int a3, const void **a4)
{
  uint64_t v8;
  int v9;
  int v10;
  unsigned __int8 *v11;
  char *v12;
  _WORD *v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  __int16 v17;
  uint64_t v18;
  size_t v19;
  size_t v20;
  __int16 v21;
  uint64_t result;
  NSObject *v23;
  NSObject *v24;
  NSObject *v25;
  int *v26;

  if (a3 == 15 || (v8 = *((_QWORD *)a4[16] + 4)) == 0)
  {
    v9 = 16;
  }
  else
  {
    v9 = 16;
    do
    {
      if (*(_DWORD *)(v8 + 16) == 1)
        v10 = *(unsigned __int8 *)*a4 + *(unsigned __int8 *)a4[1] + 8;
      else
        v10 = 8;
      v9 += ((v10 - 1) | 7) + 1;
      v8 = *(_QWORD *)(v8 + 72);
    }
    while (v8);
  }
  v11 = (unsigned __int8 *)a4[17];
  v12 = (char *)malloc_type_malloc(v9, 0xA05AC79BuLL);
  if (v12)
  {
    v13 = v12;
    v26 = a2;
    *(_WORD *)v12 = v9 >> 3;
    *(_DWORD *)(v12 + 2) = 131090;
    v12[6] = *v11;
    *((_DWORD *)v12 + 2) = 0;
    if (a3 == 15 || (v14 = *((_QWORD *)a4[16] + 4)) == 0)
    {
LABEL_20:
      result = 0;
      *a1 = v13;
      *v26 = v9;
      return result;
    }
    v15 = v12 + 24;
    while (1)
    {
      v16 = sub_10000F8F0(*(_DWORD *)v14);
      if ((_DWORD)v16 == -1)
        break;
      v17 = v16;
      v18 = sub_10002F08C(*(_DWORD *)(v14 + 16));
      if ((_DWORD)v18 == -1)
      {
        if (dword_10008BA20)
        {
          v25 = ne_log_obj(v18);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
            sub_100060364();
        }
        goto LABEL_30;
      }
      v13[9] = v17;
      *((_BYTE *)v13 + 20) = v18;
      *((_BYTE *)v13 + 21) = 2;
      v13[11] = 0;
      if (*(_DWORD *)(v14 + 16) == 1)
      {
        v19 = *(unsigned __int8 *)*a4;
        v20 = *(unsigned __int8 *)a4[1];
        v21 = v19 + v20 + 8;
        memcpy(v13 + 12, *a4, v19);
        memcpy(&v15[v19], a4[1], v20);
      }
      else
      {
        v21 = 8;
      }
      v13[8] = ((v21 - 1) | 7) + 1;
      v14 = *(_QWORD *)(v14 + 72);
      if (!v14)
        goto LABEL_20;
    }
    if (dword_10008BA20)
    {
      v24 = ne_log_obj(v16);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        sub_100060468();
    }
LABEL_30:
    free(v13);
  }
  else if (dword_10008BA20)
  {
    v23 = ne_log_obj(0);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      sub_10005BA1C();
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100030718(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  unsigned __int8 *v6;
  unsigned int v7;
  unsigned __int8 *v8;
  unsigned int v9;
  __int16 v10;
  void *v11;
  ssize_t v12;
  NSObject *v13;
  NSObject *v14;
  int v15;
  uint64_t v16;

  v16 = 0;
  v15 = 0;
  v1 = *(_QWORD *)(a1 + 136);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 128) + 8);
  v3 = sub_1000304C0(&v16, &v15, 14, (const void **)a1);
  if (!(_DWORD)v3)
  {
    v6 = (unsigned __int8 *)(v1 + 8);
    v7 = *(unsigned __int8 *)(v1 + 264);
    v8 = (unsigned __int8 *)(v1 + 136);
    v9 = *(unsigned __int8 *)(v1 + 265);
    v10 = *(_WORD *)(v1 + 266);
    v11 = (void *)v16;
    v12 = sub_100041898(*(_DWORD *)(qword_10008B848 + 32), v6, v7, v8, v9, v10, v2, 0, (void *)v16, v15, 0);
    if ((v12 & 0x80000000) != 0)
    {
      if (dword_10008BA20)
      {
        v14 = ne_log_obj(v12);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          sub_100060770();
          if (!v11)
            return 0;
          goto LABEL_14;
        }
      }
    }
    else if (dword_10008BA20)
    {
      v13 = ne_log_obj(v12);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        sub_1000607D8();
        if (!v11)
          return 0;
        goto LABEL_14;
      }
    }
    if (!v11)
      return 0;
LABEL_14:
    free(v11);
    return 0;
  }
  if (dword_10008BA20)
  {
    v4 = ne_log_obj(v3);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      sub_100060744();
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100030848(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  unsigned __int8 *v5;
  unsigned int v6;
  unsigned __int8 *v7;
  unsigned int v8;
  __int16 v9;
  void *v10;
  ssize_t v11;
  NSObject *v12;
  NSObject *v13;
  int v14;
  void *__src;

  v1 = *(_QWORD *)(a1 + 136);
  __src = 0;
  v14 = 0;
  v2 = sub_1000304C0(&__src, &v14, 15, (const void **)a1);
  if (!(_DWORD)v2)
  {
    v5 = (unsigned __int8 *)(v1 + 8);
    v6 = *(unsigned __int8 *)(v1 + 264);
    v7 = (unsigned __int8 *)(v1 + 136);
    v8 = *(unsigned __int8 *)(v1 + 265);
    v9 = *(_WORD *)(v1 + 266);
    v10 = __src;
    v11 = sub_1000419C4(*(_DWORD *)(qword_10008B848 + 32), v5, v6, v7, v8, v9, __src, v14, 0);
    if ((v11 & 0x80000000) != 0)
    {
      if (dword_10008BA20)
      {
        v13 = ne_log_obj(v11);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        {
          sub_100060804();
          if (!v10)
            return 0;
          goto LABEL_14;
        }
      }
    }
    else if (dword_10008BA20)
    {
      v12 = ne_log_obj(v11);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        sub_10006086C();
        if (!v10)
          return 0;
        goto LABEL_14;
      }
    }
    if (!v10)
      return 0;
LABEL_14:
    free(v10);
    return 0;
  }
  if (dword_10008BA20)
  {
    v3 = ne_log_obj(v2);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      sub_100060744();
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_10003096C(uint64_t a1)
{
  const void *v2;
  uint64_t result;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  _QWORD v8[2];

  v7 = 0;
  if (a1)
  {
    *(_DWORD *)(a1 + 388) = 0;
    v2 = (const void *)(a1 + 400);
    *(_OWORD *)(a1 + 400) = 0u;
    *(_OWORD *)(a1 + 416) = 0u;
    *(_OWORD *)(a1 + 432) = 0u;
    *(_OWORD *)(a1 + 448) = 0u;
    *(_OWORD *)(a1 + 464) = 0u;
    *(_OWORD *)(a1 + 480) = 0u;
    *(_OWORD *)(a1 + 496) = 0u;
    *(_OWORD *)(a1 + 512) = 0u;
    *(_OWORD *)(a1 + 528) = 0u;
    *(_OWORD *)(a1 + 544) = 0u;
    *(_OWORD *)(a1 + 560) = 0u;
    *(_OWORD *)(a1 + 576) = 0u;
    *(_OWORD *)(a1 + 592) = 0u;
    *(_OWORD *)(a1 + 608) = 0u;
    *(_OWORD *)(a1 + 624) = 0u;
    *(_OWORD *)(a1 + 640) = 0u;
    *(_OWORD *)(a1 + 656) = 0u;
    *(_OWORD *)(a1 + 672) = 0u;
    *(_OWORD *)(a1 + 688) = 0u;
    *(_OWORD *)(a1 + 704) = 0u;
    result = sub_10004D11C(a1, 1, &v7, a1 + 400, 8);
    *(_DWORD *)(a1 + 388) = result;
    if (!(_DWORD)result)
      return result;
    v8[0] = a1;
    v8[1] = 0;
    if ((sub_100041F2C(*(_DWORD *)(qword_10008B848 + 32), v7, v8, 1u, 1, v2, result) & 0x80000000) == 0)
      return *(unsigned int *)(a1 + 388);
  }
  else if (dword_10008BA20)
  {
    v4 = ne_log_obj(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
      sub_100060898(v4, v5, v6);
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100030A84(uint64_t a1)
{
  const void *v2;
  uint64_t result;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  _QWORD v8[2];

  v7 = 0;
  if (a1)
  {
    *(_DWORD *)(a1 + 1040) = 0;
    v2 = (const void *)(a1 + 1048);
    *(_OWORD *)(a1 + 1048) = 0u;
    *(_OWORD *)(a1 + 1064) = 0u;
    *(_OWORD *)(a1 + 1080) = 0u;
    *(_OWORD *)(a1 + 1096) = 0u;
    *(_OWORD *)(a1 + 1112) = 0u;
    *(_OWORD *)(a1 + 1128) = 0u;
    *(_OWORD *)(a1 + 1144) = 0u;
    *(_OWORD *)(a1 + 1160) = 0u;
    *(_OWORD *)(a1 + 1176) = 0u;
    *(_OWORD *)(a1 + 1192) = 0u;
    *(_OWORD *)(a1 + 1208) = 0u;
    *(_OWORD *)(a1 + 1224) = 0u;
    *(_OWORD *)(a1 + 1240) = 0u;
    *(_OWORD *)(a1 + 1256) = 0u;
    *(_OWORD *)(a1 + 1272) = 0u;
    *(_OWORD *)(a1 + 1288) = 0u;
    *(_OWORD *)(a1 + 1304) = 0u;
    *(_OWORD *)(a1 + 1320) = 0u;
    *(_OWORD *)(a1 + 1336) = 0u;
    *(_OWORD *)(a1 + 1352) = 0u;
    result = sub_10004D11C(a1, 2, &v7, a1 + 1048, 8);
    *(_DWORD *)(a1 + 1040) = result;
    if (!(_DWORD)result)
      return result;
    v8[0] = a1;
    v8[1] = 0;
    if ((sub_100041F2C(*(_DWORD *)(qword_10008B848 + 32), v7, v8, 1u, 2, v2, result) & 0x80000000) == 0)
      return *(unsigned int *)(a1 + 1040);
  }
  else if (dword_10008BA20)
  {
    v4 = ne_log_obj(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
      sub_100060910(v4, v5, v6);
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100030B9C(unsigned int a1, int a2, unsigned int a3)
{
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  NSObject *v12;
  int v13;
  uint64_t v14;
  NSObject *v15;
  NSObject *v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v20;

  v20 = 0;
  v6 = sub_100004A34(a1);
  switch((_DWORD)v6)
  {
    case 3:
      v7 = 15;
      break;
    case 4:
      return 0;
    case 5:
      v7 = 14;
      break;
    default:
      if (dword_10008BA20)
      {
        v12 = ne_log_obj(v6);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          sub_100060988();
      }
      return 0xFFFFFFFFLL;
  }
  v8 = sub_100004A34(a1);
  v9 = sub_1000048CC(a1, a2);
  switch(v8)
  {
    case 3:
      v10 = sub_10002F41C(v9);
      break;
    case 4:
      v10 = sub_10002F608(v9);
      break;
    case 5:
      v10 = sub_10002F4F4(v9);
      break;
    default:
      if (dword_10008BA20)
      {
        v16 = ne_log_obj(v9);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          sub_1000609B4();
      }
      return 0xFFFFFFFFLL;
  }
  v13 = v10;
  if (v10 == -1)
    return 0xFFFFFFFFLL;
  if (!a3)
  {
    v17 = sub_10003FFD8(v7, v10, &v20);
    if (!(_DWORD)v17)
    {
      a3 = WORD1(v20);
      goto LABEL_18;
    }
    if (dword_10008BA20)
    {
      v18 = ne_log_obj(v17);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        sub_100060A14();
    }
    return 0xFFFFFFFFLL;
  }
LABEL_18:
  v14 = sub_10003FE7C(v7, v13, a3);
  v11 = v14;
  if ((_DWORD)v14)
  {
    if (dword_10008BA20)
    {
      v15 = ne_log_obj(v14);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        sub_100060A14();
    }
  }
  return v11;
}

uint64_t sub_100030D64(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  unsigned __int16 *v3;
  NSObject *v4;
  NSObject *v5;
  char *v7;
  char *v8;
  _OWORD *v9;
  unsigned int v10;
  char *v11;
  unsigned int v12;
  NSObject *v13;
  NSObject *v14;
  unsigned int v15;
  char *v16;
  int v17;
  unsigned __int16 *v18;
  unsigned int v19;
  int v20;
  uint64_t v22;
  int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned __int8 *v27;
  size_t v28;
  void *v29;
  uint64_t v30;
  size_t v31;
  NSObject *v32;
  NSObject *v33;
  NSObject *v34;
  NSObject *v35;
  NSObject *v36;
  NSObject *v37;
  NSObject *v38;
  NSObject *v39;
  NSObject *v40;
  uint8_t buf;
  _BYTE v42[15];

  v1 = a1[5];
  if (!v1 || (v2 = a1[6]) == 0 || (v3 = (unsigned __int16 *)a1[18]) == 0)
  {
    if (dword_10008BA20)
    {
      v5 = ne_log_obj(a1);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_100060A7C();
    }
    return 0xFFFFFFFFLL;
  }
  if (*v3 <= 1u)
  {
    if (!dword_10008BA20)
      return 0xFFFFFFFFLL;
    v4 = ne_log_obj(a1);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      return 0xFFFFFFFFLL;
    goto LABEL_7;
  }
  v7 = (char *)sub_100034EC4();
  if (!v7)
  {
    if (dword_10008BA20)
    {
      v13 = ne_log_obj(0);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        sub_100060AD4();
    }
    return 0xFFFFFFFFLL;
  }
  v8 = v7;
  v7[16] = *((_BYTE *)v3 + 6);
  v9 = v7 + 16;
  *((_DWORD *)v7 + 72) = *((_DWORD *)v3 + 2);
  v10 = v3[2];
  *((_DWORD *)v7 + 73) = v10;
  *((_QWORD *)v7 + 37) = 0;
  if (v10 > 5)
  {
    if (dword_10008BA20)
    {
      v14 = ne_log_obj(v7);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        sub_100060B00();
    }
    sub_100034EE0(v8);
    return 0xFFFFFFFFLL;
  }
  if (v10 == 2)
  {
    v15 = *v3;
    if (v15 >= 3)
    {
      v16 = v7 + 296;
      v17 = 8 * v15 - 16;
      v18 = v3 + 8;
      while (1)
      {
        if (v17 < 8 || (v19 = *v18, v17 < v19))
        {
          if (dword_10008BA20)
          {
            v32 = ne_log_obj(v7);
            if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
              sub_100060B2C();
          }
          return 0xFFFFFFFFLL;
        }
        if (v19 <= 7)
          break;
        v7 = (char *)sub_1000352A4();
        *(_QWORD *)v16 = v7;
        if (!v7)
        {
          if (dword_10008BA20)
          {
            v34 = ne_log_obj(0);
            if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
              sub_100060B58();
          }
          return 0xFFFFFFFFLL;
        }
        *(_QWORD *)v7 = 0;
        v20 = v18[1];
        if ((v20 - 50) > 0x3A || ((1 << (v20 - 50)) & 0x400000000000003) == 0)
        {
          if (dword_10008BA20)
          {
            v39 = ne_log_obj(v7);
            if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
              sub_100060B84();
          }
          return 0xFFFFFFFFLL;
        }
        v22 = *(_QWORD *)v16;
        *(_WORD *)(*(_QWORD *)v16 + 264) = v20;
        v23 = *((unsigned __int8 *)v18 + 4);
        if ((v23 - 1) >= 2)
        {
          if (dword_10008BA20)
          {
            v35 = ne_log_obj(v7);
            if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
              sub_100060CDC();
          }
          return 0xFFFFFFFFLL;
        }
        *(_BYTE *)(v22 + 266) = v23;
        v24 = *((unsigned __int8 *)v18 + 5);
        if (v24 >= 3)
        {
          if (v24 != 3)
          {
            if (dword_10008BA20)
            {
              v40 = ne_log_obj(v7);
              if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
                sub_100060BE8();
            }
            return 0xFFFFFFFFLL;
          }
          *(_DWORD *)(v22 + 268) = v18[3];
        }
        *(_DWORD *)(v22 + 272) = v24;
        v25 = *v18;
        if (v25 >= 9)
        {
          v26 = v25 - 8;
          if (v25 - 8 < 0x10
            || (v27 = (unsigned __int8 *)(v18 + 4), v28 = *((unsigned __int8 *)v18 + 8), v26 < v28))
          {
            if (dword_10008BA20)
            {
              v36 = ne_log_obj(v7);
              if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
                sub_100060C48();
            }
            return 0xFFFFFFFFLL;
          }
          v29 = memmove((void *)(v22 + 8), v18 + 4, v28);
          v30 = *v27;
          if (v26 - v30 < 0x10 || (v31 = v27[v30], (int)(v26 - v30) < (int)v31))
          {
            if (dword_10008BA20)
            {
              v38 = ne_log_obj(v29);
              if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
                sub_100060C74();
            }
            return 0xFFFFFFFFLL;
          }
          v7 = (char *)memmove((void *)(*(_QWORD *)v16 + 136), &v27[v30], v31);
          v22 = *(_QWORD *)v16;
          v25 = *v18;
        }
        *(_QWORD *)(v22 + 280) = v8;
        v17 -= v25;
        if (v17 < 0 && dword_10008BA20)
        {
          v37 = ne_log_obj(v7);
          if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
            sub_100060CA0(&buf, v42, v37);
          goto LABEL_15;
        }
        v16 = *(char **)v16;
        v18 = (unsigned __int16 *)((char *)v18 + *v18);
        if (v17 < 1)
          goto LABEL_15;
      }
      if (!dword_10008BA20)
        return 0xFFFFFFFFLL;
      v33 = ne_log_obj(v7);
      if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
        return 0xFFFFFFFFLL;
LABEL_7:
      sub_100060AA8();
      return 0xFFFFFFFFLL;
    }
  }
LABEL_15:
  v9[15] = 0u;
  v9[16] = 0u;
  v9[13] = 0u;
  v9[14] = 0u;
  v9[11] = 0u;
  v9[12] = 0u;
  v9[9] = 0u;
  v9[10] = 0u;
  v9[7] = 0u;
  v9[8] = 0u;
  v9[5] = 0u;
  v9[6] = 0u;
  v9[3] = 0u;
  v9[4] = 0u;
  v9[1] = 0u;
  v9[2] = 0u;
  *v9 = 0u;
  v8[16] = *((_BYTE *)v3 + 6);
  v12 = *(unsigned __int8 *)(v1 + 8);
  v11 = (char *)(v1 + 8);
  v8[280] = *(v11 - 3);
  v8[281] = *(_BYTE *)(v2 + 5);
  *((_WORD *)v8 + 141) = *(v11 - 4);
  memcpy(v8 + 24, v11, v12);
  memcpy(v8 + 152, (const void *)(v2 + 8), *(unsigned __int8 *)(v2 + 8));
  sub_1000351F8(v8);
  return 0;
}

uint64_t sub_10003122C(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _BYTE *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  NSObject *v18;
  NSObject *v19;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  uint64_t v26;
  NSObject *v27;
  NSObject *v28;
  unsigned int v29;
  const sockaddr *v30;
  const sockaddr *v31;
  uint8_t buf[4];
  char *v33;

  v1 = a1[1];
  if (!v1 || !a1[6])
  {
    if (dword_10008BA20)
    {
      v18 = ne_log_obj(a1);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        sub_100060D3C();
    }
    return 0xFFFFFFFFLL;
  }
  v2 = *a1;
  v3 = *(_DWORD *)(*a1 + 12);
  v4 = getpid();
  if (v3 != (_DWORD)v4)
  {
    if (dword_10008BA20)
    {
      v19 = ne_log_obj(v4);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
        sub_100060FF0();
    }
    return 0xFFFFFFFFLL;
  }
  v5 = sub_100008A60(*(_DWORD *)(v2 + 8));
  if (!v5)
  {
    if (dword_10008BA20)
    {
      v20 = ne_log_obj(0);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
        sub_100060D68(v2 + 8, v2);
    }
    return 0xFFFFFFFFLL;
  }
  v6 = v5;
  if ((*(_BYTE *)(v5 + 264) & 2) != 0)
  {
    if (dword_10008BA20)
    {
      v21 = ne_log_obj(v5);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        sub_100060F8C();
    }
    return 0xFFFFFFFFLL;
  }
  v7 = (_BYTE *)(v5 + 61);
  if (*(_BYTE *)(v5 + 61) != 16)
  {
    if (dword_10008BA20)
    {
      v22 = ne_log_obj(v5);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        sub_100060F2C();
    }
    return 0xFFFFFFFFLL;
  }
  if ((*(_DWORD *)(v5 + 56) | 0x100) != 0x19F0)
  {
    if (dword_10008BA20)
    {
      v24 = ne_log_obj(v5);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        sub_100060DD0();
    }
    return 0xFFFFFFFFLL;
  }
  if (!*(_QWORD *)(v5 + 256) && !sub_10004BBE8(v5))
  {
    if (dword_10008BA20)
    {
      v27 = ne_log_obj(0);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        sub_100060E30(v6);
    }
    goto LABEL_43;
  }
  v8 = sub_10002F014(*(unsigned __int8 *)(v2 + 3));
  v9 = 128;
  if (!*(_BYTE *)(v6 + 60))
    v9 = 120;
  v10 = *(_QWORD *)(*(_QWORD *)(v6 + v9) + 32);
  if (!v10)
    goto LABEL_40;
  v11 = v8;
  v12 = 1;
  v13 = 1;
  do
  {
    if (*(_DWORD *)v10 == v11 && !*(_DWORD *)(v10 + 24))
    {
      *(_DWORD *)(v10 + 24) = *(_DWORD *)(v1 + 4);
      v12 = dword_10008BA20;
      if (dword_10008BA20)
      {
        v14 = ne_log_obj(v8);
        v8 = os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG);
        if ((_DWORD)v8)
        {
          v30 = *(const sockaddr **)v6;
          v31 = *(const sockaddr **)(v6 + 8);
          v15 = *(unsigned __int8 *)(v2 + 3);
          v29 = *(_DWORD *)(v1 + 4);
          v16 = sub_10002F08C(*(_DWORD *)(v10 + 16));
          v17 = sub_10002FA64(v31, v30, v15, v29, v16);
          *(_DWORD *)buf = 136315138;
          v33 = v17;
          _os_log_debug_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "pfkey GETSPI succeeded: %s\n", buf, 0xCu);
        }
        v12 = 0;
      }
    }
    if (!*(_DWORD *)(v10 + 24))
      v13 = 0;
    v10 = *(_QWORD *)(v10 + 72);
  }
  while (v10);
  if (v12)
  {
LABEL_40:
    if (dword_10008BA20)
    {
      v23 = ne_log_obj(v8);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        sub_100060E98(v6);
    }
LABEL_43:
    sub_10004A9EC((_QWORD *)v6);
    return 0xFFFFFFFFLL;
  }
  if (v13)
  {
    if (*v7 == 16)
    {
      v26 = sub_100025A2C(v6);
      if ((v26 & 0x80000000) != 0)
      {
        if (dword_10008BA20)
        {
          v28 = ne_log_obj(v26);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
            sub_100060F00();
        }
        goto LABEL_43;
      }
    }
  }
  return 0;
}

uint64_t sub_100031624(uint64_t *a1)
{
  uint64_t result;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unsigned __int8 *v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  NSObject *v17;
  _BOOL8 v18;
  NSObject *v19;
  _BOOL8 v20;
  int v21;
  unsigned int v22;
  NSObject *v23;
  char *v24;
  char *v25;
  NSObject *v26;
  NSObject *v27;
  NSObject *v28;
  NSObject *v29;
  NSObject *v30;
  NSObject *v31;
  uint64_t v32;
  uint64_t v33;
  NSObject *v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  NSObject *v39;
  uint8_t buf[4];
  _BYTE v41[10];
  __int16 v42;
  int v43;

  if (dword_10008B858)
    return 0;
  v2 = *a1;
  if (!*a1 || (v3 = a1[1]) == 0 || !a1[5] || !a1[6])
  {
    if (dword_10008BA20)
    {
      v6 = ne_log_obj(a1);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        sub_10006105C();
    }
    return 0xFFFFFFFFLL;
  }
  v4 = a1[19];
  if (v4)
    v5 = *(unsigned __int8 *)(v4 + 4);
  else
    v5 = 0;
  v7 = *(_DWORD *)(v2 + 12);
  v8 = getpid();
  if (v7 != (_DWORD)v8)
  {
    if (dword_10008BA20)
    {
      v26 = ne_log_obj(v8);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
        sub_100060FF0();
    }
    return 0xFFFFFFFFLL;
  }
  v9 = sub_100008A60(*(_DWORD *)(v2 + 8));
  if (!v9)
  {
    if (dword_10008BA20)
    {
      v27 = ne_log_obj(0);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
        sub_100060D68(v2 + 8, v2);
    }
    return 0xFFFFFFFFLL;
  }
  v10 = v9;
  if ((*(_BYTE *)(v9 + 264) & 2) != 0)
  {
    if (dword_10008BA20)
    {
      v28 = ne_log_obj(v9);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        sub_100060F8C();
    }
    return 0xFFFFFFFFLL;
  }
  if ((*(_DWORD *)(v9 + 56) | 0x100) != 0x19C8)
  {
    if (dword_10008BA20)
    {
      v29 = ne_log_obj(v9);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        sub_100060DD0();
    }
    return 0xFFFFFFFFLL;
  }
  v11 = *(_QWORD *)(*(_QWORD *)(v9 + 128) + 32);
  if (v11)
  {
    v12 = 0;
    v13 = (unsigned __int8 *)(v2 + 3);
    do
    {
      v14 = sub_10002F014(*v13);
      if ((_DWORD)v14 == -1)
      {
        if (dword_10008BA20)
        {
          v30 = ne_log_obj(v14);
          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
            sub_100061088();
        }
        return 0xFFFFFFFFLL;
      }
      v15 = v14;
      v16 = sub_10002F128(v5);
      if ((_DWORD)v16 == -1)
      {
        if (dword_10008BA20)
        {
          v31 = ne_log_obj(v16);
          if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
            sub_1000610E8();
        }
        return 0xFFFFFFFFLL;
      }
      if (*(_DWORD *)v11 == v15 && *(_DWORD *)(v11 + 24) == *(_DWORD *)(v3 + 4))
      {
        *(_DWORD *)(v11 + 56) = 1;
        if (dword_10008BA20)
        {
          v17 = ne_log_obj(v16);
          v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG);
          if (v18)
          {
            v24 = sub_10002FA64(*(const sockaddr **)(v10 + 8), *(const sockaddr **)v10, *v13, *(_DWORD *)(v3 + 4), v5);
            *(_DWORD *)buf = 136315138;
            *(_QWORD *)v41 = v24;
            _os_log_debug_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "pfkey UPDATE succeeded: %s\n", buf, 0xCu);
          }
          if (dword_10008BA20)
          {
            v19 = ne_log_obj(v18);
            v20 = os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT);
            if (v20)
            {
              v21 = *v13;
              v22 = bswap32(*(_DWORD *)(v3 + 4));
              *(_DWORD *)buf = 67109632;
              *(_DWORD *)v41 = v21;
              *(_WORD *)&v41[4] = 1024;
              *(_DWORD *)&v41[6] = v22;
              v42 = 1024;
              v43 = v5;
              _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "IPsec-SA established (update): satype=%u spi=%#x mode=%u\n", buf, 0x14u);
            }
            if (dword_10008BA20)
            {
              v23 = ne_log_obj(v20);
              if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
              {
                v25 = sub_10002FA64(*(const sockaddr **)(v10 + 8), *(const sockaddr **)v10, *v13, *(_DWORD *)(v3 + 4), v5);
                *(_DWORD *)buf = 136315138;
                *(_QWORD *)v41 = v25;
                _os_log_debug_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEBUG, "IPsec-SA established (update): %s\n", buf, 0xCu);
              }
            }
          }
        }
      }
      if (!*(_DWORD *)(v11 + 56))
        v12 = 1;
      v11 = *(_QWORD *)(v11 + 72);
    }
    while (v11);
    if (v12)
      return 0;
  }
  v32 = *(unsigned int *)(v10 + 64);
  if ((_DWORD)v32)
  {
    sub_10003A6F0(v32);
    *(_DWORD *)(v10 + 64) = 0;
  }
  sub_100003774((int *)(v10 + 56), 10240);
  sub_10004C204(v10);
  if (dword_10008BA20)
  {
    v34 = ne_log_obj(v33);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      if (*(_BYTE *)(v10 + 60))
        v35 = "peer";
      else
        v35 = "me";
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)v41 = v35;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "IPSec Phase 2 established (Initiated by %s).\n", buf, 0xCu);
    }
  }
  v36 = *(_QWORD *)(v10 + 256);
  if (v36)
    ++*(_DWORD *)(v36 + 400);
  v37 = *(unsigned int *)(v10 + 68);
  if ((_DWORD)v37)
  {
    sub_10003A6F0(v37);
    *(_DWORD *)(v10 + 68) = 0;
  }
  sub_10004B9B4((_QWORD *)v10);
  v38 = sub_10003A520(*(_QWORD *)(*(_QWORD *)(v10 + 128) + 8), (uint64_t)sub_1000250D8, v10);
  *(_DWORD *)(v10 + 64) = (_DWORD)v38;
  if (!dword_10008BA20)
    return 0;
  v39 = ne_log_obj(v38);
  result = os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG);
  if ((_DWORD)result)
  {
    sub_10005C5F4();
    return 0;
  }
  return result;
}

uint64_t sub_100031B5C(uint64_t *a1)
{
  uint64_t result;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  _BOOL8 v12;
  int v13;
  unsigned int v14;
  NSObject *v15;
  uint64_t v16;
  NSObject *v17;
  NSObject *v18;
  NSObject *v19;
  char *v20;
  int v21;
  _BYTE v22[10];
  __int16 v23;
  int v24;

  if (dword_10008B858)
    return 0;
  v2 = *a1;
  if (!*a1 || (v3 = a1[1]) == 0 || !a1[5] || !a1[6])
  {
    if (dword_10008BA20)
    {
      v6 = ne_log_obj(a1);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        sub_100061148();
    }
    return 0xFFFFFFFFLL;
  }
  v4 = a1[19];
  if (v4)
    v5 = *(unsigned __int8 *)(v4 + 4);
  else
    v5 = 0;
  v7 = *(_DWORD *)(v2 + 12);
  v8 = getpid();
  if (v7 != (_DWORD)v8)
  {
    if (dword_10008BA20)
    {
      v18 = ne_log_obj(v8);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        sub_100060FF0();
    }
    return 0xFFFFFFFFLL;
  }
  v9 = sub_100008A60(*(_DWORD *)(v2 + 8));
  if (!v9)
  {
    if (dword_10008BA20)
    {
      v19 = ne_log_obj(0);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
        sub_100061174(v2 + 8, v2);
    }
    return 0xFFFFFFFFLL;
  }
  v10 = v9;
  if (dword_10008BA20)
  {
    v11 = ne_log_obj(v9);
    v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
    if (v12)
    {
      v13 = *(unsigned __int8 *)(v2 + 3);
      v14 = bswap32(*(_DWORD *)(v3 + 4));
      v21 = 67109632;
      *(_DWORD *)v22 = v13;
      *(_WORD *)&v22[4] = 1024;
      *(_DWORD *)&v22[6] = v14;
      v23 = 1024;
      v24 = v5;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "IPsec-SA established (add): satype=%u spi=%#x mode=%u\n", (uint8_t *)&v21, 0x14u);
    }
    if (dword_10008BA20)
    {
      v15 = ne_log_obj(v12);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
      {
        v20 = sub_10002FA64(*(const sockaddr **)v10, *(const sockaddr **)(v10 + 8), *(unsigned __int8 *)(v2 + 3), *(_DWORD *)(v3 + 4), v5);
        v21 = 136315138;
        *(_QWORD *)v22 = v20;
        _os_log_debug_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "IPsec-SA established (add): %s\n", (uint8_t *)&v21, 0xCu);
      }
    }
  }
  sub_10004CA44(*(_QWORD *)(v10 + 272), v10);
  v16 = sub_100048B0C(0, 0, 0, v10);
  if (!dword_10008BA20)
    return 0;
  v17 = ne_log_obj(v16);
  result = os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG);
  if ((_DWORD)result)
  {
    sub_10005C5F4();
    return 0;
  }
  return result;
}

uint64_t sub_100031DEC(uint64_t *a1)
{
  uint64_t result;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  NSObject *v8;
  NSObject *v9;
  unsigned __int8 *v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  const sockaddr *v14;
  const sockaddr *v15;
  NSObject *v16;
  _BOOL8 v17;
  NSObject *v18;
  _BOOL8 v19;
  NSObject *v20;
  const sockaddr **v21;
  const sockaddr **v22;
  NSObject *v23;
  char *v24;
  const char *v25;
  NSObject *v26;
  NSObject *v27;
  NSObject *v28;
  char *v29;
  int v30;
  char *v31;

  if (dword_10008B858)
    return 0;
  v2 = *a1;
  if (!*a1 || (v3 = a1[5]) == 0 || (v4 = a1[6]) == 0)
  {
    if (dword_10008BA20)
    {
      v9 = ne_log_obj(a1);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_1000611DC();
    }
    return 0xFFFFFFFFLL;
  }
  v5 = a1[1];
  v6 = *(_DWORD *)(v2 + 12);
  v7 = getpid();
  if (v6 == (_DWORD)v7)
  {
    if (dword_10008BA20)
    {
      v8 = ne_log_obj(v7);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        sub_100061208(v2);
    }
    return 0xFFFFFFFFLL;
  }
  v11 = *(unsigned __int8 *)(v2 + 3);
  v10 = (unsigned __int8 *)(v2 + 3);
  v12 = sub_10002F014(v11);
  if ((_DWORD)v12 == -1)
  {
    if (dword_10008BA20)
    {
      v27 = ne_log_obj(v12);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        sub_100061088();
    }
    return 0xFFFFFFFFLL;
  }
  v13 = v12;
  v14 = (const sockaddr *)(v3 + 8);
  v15 = (const sockaddr *)(v4 + 8);
  if (!dword_10008BA20)
    goto LABEL_24;
  v16 = ne_log_obj(v12);
  v17 = os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG);
  if (v17)
    sub_100061348();
  if (!dword_10008BA20)
    goto LABEL_24;
  v18 = ne_log_obj(v17);
  v19 = os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG);
  if (v19)
    sub_1000612DC(v14);
  if (!dword_10008BA20 || (v20 = ne_log_obj(v19), !os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG)))
  {
LABEL_24:
    if (v5)
      goto LABEL_25;
LABEL_37:
    sub_100009358((uint64_t)v14, (unint64_t)v15, v13);
    sub_1000094DC((uint64_t)v14, (unint64_t)v15);
    return 0;
  }
  sub_100061270(v15);
  if (!v5)
    goto LABEL_37;
LABEL_25:
  v21 = (const sockaddr **)sub_100008C2C((uint64_t)v14, (uint64_t)v15, v13, *(_DWORD *)(v5 + 4));
  if (v21)
  {
    if (dword_10008BA20)
    {
      v22 = v21;
      v23 = ne_log_obj(v21);
      result = os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
      if ((_DWORD)result)
      {
        v24 = sub_10002FA64(*v22, v22[1], *v10, *(_DWORD *)(v5 + 4), 0);
        v30 = 136315138;
        v31 = v24;
        v25 = "pfkey DELETE received: %s\n";
        v26 = v23;
LABEL_35:
        _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, v25, (uint8_t *)&v30, 0xCu);
        return 0;
      }
      return result;
    }
    return 0;
  }
  if (!dword_10008BA20)
    return 0;
  v28 = ne_log_obj(0);
  result = os_log_type_enabled(v28, OS_LOG_TYPE_ERROR);
  if ((_DWORD)result)
  {
    v29 = sub_10002FA64(v14, v15, *v10, *(_DWORD *)(v5 + 4), 0);
    v30 = 136315138;
    v31 = v29;
    v25 = "no iph2 found: %s\n";
    v26 = v28;
    goto LABEL_35;
  }
  return result;
}

uint64_t sub_1000320D0(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const sockaddr *v7;
  int v8;
  NSObject *v9;
  NSObject *v10;
  NSObject *v11;
  const sockaddr *v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t *v15;
  NSObject *v16;
  NSObject *v17;
  int *v18;
  int v19;
  const sockaddr *v20;
  uint64_t v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  NSObject *v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  uint64_t *v33;
  uint64_t v34;
  NSObject *v35;
  NSObject *v36;
  NSObject *v37;
  _DWORD *v38;
  _DWORD *v39;
  _BYTE *v40;
  uint64_t v41;
  NSObject *v42;
  void *v43;
  void *v44;
  NSObject *v45;
  size_t *v46;
  size_t *v47;
  size_t *v48;
  size_t *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  NSObject *v54;
  NSObject *v55;
  NSObject *v56;
  NSObject *v57;
  NSObject *v58;
  NSObject *v59;
  NSObject *v60;
  uint8_t v61[4];
  char *v62;
  _OWORD buf[17];

  if (dword_10008B858)
    return 0;
  v2 = a1;
  v3 = *a1;
  if (!*a1 || (v4 = a1[5]) == 0 || (v5 = a1[6]) == 0 || (v6 = a1[18]) == 0)
  {
    if (dword_10008BA20)
    {
      v10 = ne_log_obj(a1);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_1000613A8();
    }
    return 0xFFFFFFFFLL;
  }
  if (*(_WORD *)(v6 + 4) != 2)
  {
    if (!dword_10008BA20)
      return 0;
    v11 = ne_log_obj(a1);
    result = os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG);
    if ((_DWORD)result)
    {
      sub_100061820();
      return 0;
    }
    return result;
  }
  v7 = (const sockaddr *)(v5 + 8);
  v8 = *(unsigned __int8 *)(v5 + 9);
  if (v8 == 30)
  {
    if (*(unsigned __int8 *)(v5 + 16) == 255)
      goto LABEL_11;
  }
  else if (v8 == 2 && (*(_DWORD *)(v5 + 12) & 0xF0) == 0xE0)
  {
LABEL_11:
    if (!dword_10008BA20)
      return 0;
    v9 = ne_log_obj(a1);
    result = os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG);
    if ((_DWORD)result)
    {
      sub_1000617B8(v7);
      return 0;
    }
    return result;
  }
  v12 = (const sockaddr *)(v4 + 8);
  v13 = qword_10008B848 + 120;
  do
  {
    v13 = *(_QWORD *)v13;
    if (!v13)
    {
      if (!dword_10008BA20)
        return 0;
      v17 = ne_log_obj(a1);
      result = os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)result)
      {
        sub_1000613D4(v12);
        return 0;
      }
      return result;
    }
    v14 = sub_10003C570(*(const sockaddr **)(v13 + 8));
    if (dword_10008BA20)
    {
      v15 = v14;
      v16 = ne_log_obj(v14);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
      {
        LODWORD(buf[0]) = 136315138;
        *(_QWORD *)((char *)buf + 4) = v15;
        _os_log_debug_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "checking listen addrs: %s", (uint8_t *)buf, 0xCu);
      }
    }
    a1 = (_QWORD *)sub_10003B380(*(_QWORD *)(v13 + 8), (unint64_t)v12);
  }
  while ((_DWORD)a1);
  v19 = *(_DWORD *)(v6 + 8);
  v18 = (int *)(v6 + 8);
  v20 = v7;
  v21 = sub_100008AF8((unint64_t)v12, (unint64_t)v7, v19);
  if (v21)
  {
    if ((*(_BYTE *)(v21 + 57) & 0x20) == 0)
    {
      if (dword_10008BA20)
      {
        v22 = ne_log_obj(v21);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
          sub_10006178C();
      }
      return 0xFFFFFFFFLL;
    }
    v23 = *(_QWORD *)(v21 + 272);
  }
  else
  {
    v23 = 0;
  }
  v24 = sub_100034EA0(*v18);
  if (!v24)
  {
    if (dword_10008BA20)
    {
      v36 = ne_log_obj(0);
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
        sub_10006143C();
    }
    return 0xFFFFFFFFLL;
  }
  v25 = (uint64_t)v24;
  if (dword_10008BA20)
  {
    v26 = ne_log_obj(v24);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
      sub_100061724(v25);
  }
  memset(&buf[1], 0, 256);
  buf[0] = 0u;
  LOBYTE(buf[0]) = 1;
  *(_OWORD *)((char *)&buf[7] + 8) = *(_OWORD *)(v25 + 264);
  *(_OWORD *)((char *)&buf[6] + 8) = *(_OWORD *)(v25 + 248);
  *(_OWORD *)((char *)&buf[5] + 8) = *(_OWORD *)(v25 + 232);
  *(_OWORD *)((char *)&buf[3] + 8) = *(_OWORD *)(v25 + 200);
  *(_OWORD *)((char *)&buf[2] + 8) = *(_OWORD *)(v25 + 184);
  *(_OWORD *)((char *)&buf[1] + 8) = *(_OWORD *)(v25 + 168);
  *(_OWORD *)((char *)&buf[4] + 8) = *(_OWORD *)(v25 + 216);
  *(_OWORD *)((char *)buf + 8) = *(_OWORD *)(v25 + 152);
  v27 = *(_OWORD *)(v25 + 120);
  v28 = *(_OWORD *)(v25 + 104);
  v29 = *(_OWORD *)(v25 + 88);
  *(_OWORD *)((char *)&buf[15] + 8) = *(_OWORD *)(v25 + 136);
  *(_OWORD *)((char *)&buf[12] + 8) = v29;
  *(_OWORD *)((char *)&buf[13] + 8) = v28;
  *(_OWORD *)((char *)&buf[14] + 8) = v27;
  v30 = *(_OWORD *)(v25 + 24);
  v31 = *(_OWORD *)(v25 + 40);
  v32 = *(_OWORD *)(v25 + 56);
  *(_OWORD *)((char *)&buf[11] + 8) = *(_OWORD *)(v25 + 72);
  *(_OWORD *)((char *)&buf[10] + 8) = v32;
  *(_OWORD *)((char *)&buf[9] + 8) = v31;
  *(_OWORD *)((char *)&buf[8] + 8) = v30;
  BYTE8(buf[16]) = *(_BYTE *)(v25 + 281);
  BYTE9(buf[16]) = *(_BYTE *)(v25 + 280);
  WORD5(buf[16]) = *(_WORD *)(v25 + 282);
  v33 = sub_100034694((unsigned __int8 *)buf);
  v34 = (uint64_t)v33;
  if (v33)
  {
    if (dword_10008BA20)
    {
      v35 = ne_log_obj(v33);
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
        sub_1000616BC(v34);
    }
  }
  else if (dword_10008BA20)
  {
    v37 = ne_log_obj(0);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v61 = 136315138;
      v62 = sub_1000352C0((unsigned __int8 *)buf);
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "No in-bound policy found: %s\n", v61, 0xCu);
    }
  }
  v38 = sub_100038594((uint64_t)v20);
  if (!v38)
  {
    if (dword_10008BA20)
    {
      v55 = ne_log_obj(0);
      if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
        sub_10006149C(v20);
    }
    return 0xFFFFFFFFLL;
  }
  v39 = v38;
  v40 = sub_100008D90(v38[73], 0);
  if (!v40)
  {
    if (dword_10008BA20)
    {
      v56 = ne_log_obj(0);
      if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
        sub_100061504();
    }
    return 0xFFFFFFFFLL;
  }
  v41 = (uint64_t)v40;
  if (dword_10008BA20)
  {
    v42 = ne_log_obj(v40);
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
      sub_100061658();
  }
  *(_BYTE *)(v41 + 61) = v39[73];
  *(_BYTE *)(v41 + 60) = 0;
  *(_DWORD *)(v41 + 52) = *v18;
  *(_BYTE *)(v41 + 104) = *(_BYTE *)(v3 + 3);
  *(_DWORD *)(v41 + 100) = *(_DWORD *)(v3 + 8);
  sub_1000484FC((_OWORD *)(v41 + 16));
  v43 = sub_10003C6F8((unsigned __int8 *)(v2[5] + 8));
  *(_QWORD *)v41 = v43;
  if (!v43)
    goto LABEL_99;
  v44 = sub_10003C6F8((unsigned __int8 *)(v2[6] + 8));
  *(_QWORD *)(v41 + 8) = v44;
  if (!v44)
    goto LABEL_99;
  if (*(_BYTE *)(v41 + 61) == 16)
    sub_100003774((int *)(v41 + 56), 6336);
  if (dword_10008BA20)
  {
    v45 = ne_log_obj(v44);
    if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
      sub_1000615F0((unsigned __int8 *)(v25 + 16));
  }
  v46 = sub_100010ADC(v25 + 24, *(unsigned __int8 *)(v25 + 280), *(unsigned __int16 *)(v25 + 282));
  if (!v46)
  {
    if (dword_10008BA20)
    {
      v57 = ne_log_obj(0);
      if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
        sub_100061530((unsigned __int8 *)(v25 + 16));
    }
    goto LABEL_99;
  }
  v47 = v46;
  v48 = sub_100010ADC(v25 + 152, *(unsigned __int8 *)(v25 + 281), *(unsigned __int16 *)(v25 + 282));
  if (!v48)
  {
    if (dword_10008BA20)
    {
      v58 = ne_log_obj(0);
      if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
        sub_100061530((unsigned __int8 *)(v25 + 16));
    }
    sub_10003F318(v47);
    goto LABEL_99;
  }
  v49 = v48;
  *(_QWORD *)(v41 + 112) = sub_100039CAC((uint64_t)v47, (uint64_t)v48, 0, 0);
  sub_10003F318(v47);
  sub_10003F318(v49);
  v50 = *(_QWORD *)(v41 + 112);
  if (!v50)
  {
    if (dword_10008BA20)
    {
      v59 = ne_log_obj(0);
      if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
        sub_10005B260();
    }
    goto LABEL_99;
  }
  sub_10003A2BC(v50);
  v51 = sub_1000376F0(v41, v25, v34);
  if ((v51 & 0x80000000) != 0)
  {
    if (dword_10008BA20)
    {
      v60 = ne_log_obj(v51);
      if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
        sub_100061598();
    }
LABEL_99:
    sub_100008F90(v41);
    return 0xFFFFFFFFLL;
  }
  v52 = v23;
  if (!v23)
  {
    v52 = sub_10004ABA4(*(_QWORD *)v41, *(_QWORD *)(v41 + 8), 1, 0);
    if (!v52)
      sub_10003B334();
  }
  if (sub_10004B3B8(v52, v41))
    sub_10003B334();
  v53 = sub_10002543C(v41);
  if ((v53 & 0x80000000) != 0)
  {
    if (dword_10008BA20)
    {
      v54 = ne_log_obj(v53);
      if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
        sub_1000615C4();
    }
    sub_10004A9EC((_QWORD *)v41);
    return 0xFFFFFFFFLL;
  }
  return 0;
}

uint64_t sub_100032828(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  unsigned __int8 *v9;
  unsigned int v10;
  uint64_t v11;
  int v12;
  const sockaddr *v13;
  const sockaddr *v14;
  NSObject *v15;
  _BOOL8 v16;
  int v17;
  unsigned int v18;
  NSObject *v19;
  _QWORD *v20;
  uint64_t v21;
  NSObject *v22;
  _BOOL4 v23;
  int v24;
  const char *v25;
  NSObject *v26;
  NSObject *v27;
  char *v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  NSObject *v32;
  int v33;
  _BYTE v34[10];
  _DWORD v35[2];

  v1 = *a1;
  if (!*a1 || (v2 = a1[1]) == 0 || (v3 = a1[5]) == 0 || (v4 = a1[6]) == 0 || a1[3] && a1[4])
  {
    if (dword_10008BA20)
    {
      v5 = ne_log_obj(a1);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_10006184C();
    }
    return 0xFFFFFFFFLL;
  }
  v7 = a1[19];
  if (v7)
    v8 = *(unsigned __int8 *)(v7 + 4);
  else
    v8 = 0;
  v10 = *(unsigned __int8 *)(v1 + 3);
  v9 = (unsigned __int8 *)(v1 + 3);
  v11 = sub_10002F014(v10);
  if ((_DWORD)v11 == -1)
  {
    if (dword_10008BA20)
    {
      v26 = ne_log_obj(v11);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        sub_100061088();
    }
    return 0xFFFFFFFFLL;
  }
  v12 = v11;
  v13 = (const sockaddr *)(v3 + 8);
  v14 = (const sockaddr *)(v4 + 8);
  if (dword_10008BA20)
  {
    v15 = ne_log_obj(v11);
    v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
    if (v16)
    {
      v17 = *v9;
      v18 = bswap32(*(_DWORD *)(v2 + 4));
      v33 = 67109632;
      *(_DWORD *)v34 = v17;
      *(_WORD *)&v34[4] = 1024;
      *(_DWORD *)&v34[6] = v18;
      LOWORD(v35[0]) = 1024;
      *(_DWORD *)((char *)v35 + 2) = v8;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "IPsec-SA expired: satype=%u spi=%#x mode=%u\n", (uint8_t *)&v33, 0x14u);
    }
    if (dword_10008BA20)
    {
      v19 = ne_log_obj(v16);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
      {
        v30 = sub_10002FA64(v13, v14, *v9, *(_DWORD *)(v2 + 4), v8);
        v33 = 136315138;
        *(_QWORD *)v34 = v30;
        _os_log_debug_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, "IPsec-SA expired: %s\n", (uint8_t *)&v33, 0xCu);
      }
    }
  }
  v20 = sub_100008C2C((uint64_t)v13, (uint64_t)v14, v12, *(_DWORD *)(v2 + 4));
  if (!v20)
  {
    if (dword_10008BA20)
    {
      v27 = ne_log_obj(0);
      result = os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG);
      if (!(_DWORD)result)
        return result;
      v28 = sub_10002FA64(v13, v14, *v9, *(_DWORD *)(v2 + 4), v8);
      v33 = 136315138;
      *(_QWORD *)v34 = v28;
      _os_log_debug_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEBUG, "no such a SA found: %s\n", (uint8_t *)&v33, 0xCu);
    }
    return 0;
  }
  v21 = (uint64_t)v20;
  if ((v20[33] & 2) == 0 && (*((_BYTE *)v20 + 57) & 0x20) != 0)
  {
    v29 = *((unsigned int *)v20 + 16);
    if ((_DWORD)v29)
    {
      sub_10003A6F0(v29);
      *(_DWORD *)(v21 + 64) = 0;
    }
    sub_100003774((int *)(v21 + 56), 18432);
    if (*(_BYTE *)(v21 + 60)
      || sub_10004BEB0(*(_QWORD *)(v21 + 272), v21)
      || sub_10004E4C4(*(_QWORD *)(v21 + 272), 2))
    {
      sub_10004A9EC((_QWORD *)v21);
    }
    else
    {
      sub_100008E48(v21);
      v31 = sub_10002543C(v21);
      if ((v31 & 0x80000000) != 0)
      {
        if (dword_10008BA20)
        {
          v32 = ne_log_obj(v31);
          if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
            sub_100061878();
        }
        sub_10004A9EC((_QWORD *)v21);
        return 0xFFFFFFFFLL;
      }
    }
    return 0;
  }
  if (!dword_10008BA20)
    return 0;
  v22 = ne_log_obj(v20);
  v23 = os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT);
  result = 0;
  if (v23)
  {
    v24 = *(_DWORD *)(v21 + 56);
    if ((*(_BYTE *)(v21 + 264) & 2) != 0)
      v25 = "is dying";
    else
      v25 = "has not been established";
    v33 = 136315394;
    *(_QWORD *)v34 = v25;
    *(_WORD *)&v34[8] = 1024;
    v35[0] = v24;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "The expire message is received but the handler %s (status = 0x%x).\n", (uint8_t *)&v33, 0x12u);
    return 0;
  }
  return result;
}

uint64_t sub_100032BEC(_QWORD *a1)
{
  NSObject *v2;

  if (*a1)
  {
    sub_10000928C(0);
    sub_100008954(0);
    return 0;
  }
  else
  {
    if (dword_10008BA20)
    {
      v2 = ne_log_obj(a1);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_1000618A4();
    }
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_100032C58(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t *v7;
  uint64_t *v8;
  NSObject *v9;
  NSObject *v11;
  _OWORD v12[16];
  __int128 v13;

  if (*a1 && (v2 = a1[5]) != 0 && (v3 = a1[6]) != 0 && (v4 = a1[18]) != 0)
  {
    v13 = 0u;
    memset(v12, 0, sizeof(v12));
    LOBYTE(v12[0]) = *(_BYTE *)(v4 + 6);
    v6 = *(unsigned __int8 *)(v2 + 8);
    v5 = v2 + 8;
    BYTE8(v13) = *(_BYTE *)(v5 - 3);
    BYTE9(v13) = *(_BYTE *)(v3 + 5);
    WORD5(v13) = *(unsigned __int8 *)(v5 - 4);
    __memcpy_chk((char *)v12 + 8, v5, v6, 264);
    __memcpy_chk((char *)&v12[8] + 8, v3 + 8, *(unsigned __int8 *)(v3 + 8), 136);
    v7 = sub_100034694((unsigned __int8 *)v12);
    if (v7)
    {
      v8 = v7;
      sub_1000351D4(v7);
      sub_100034EE0(v8);
    }
    else if (dword_10008BA20)
    {
      v11 = ne_log_obj(0);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        sub_1000618FC((unsigned __int8 *)v12);
    }
    return ((int)sub_100030D64(a1) >> 31);
  }
  else
  {
    if (dword_10008BA20)
    {
      v9 = ne_log_obj(a1);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_1000618D0();
    }
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_100032DD8(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t *v7;
  uint64_t *v8;
  NSObject *v9;
  NSObject *v11;
  _OWORD v12[16];
  __int128 v13;

  if (*a1 && (v2 = a1[5]) != 0 && (v3 = a1[6]) != 0 && (v4 = a1[18]) != 0)
  {
    v13 = 0u;
    memset(v12, 0, sizeof(v12));
    LOBYTE(v12[0]) = *(_BYTE *)(v4 + 6);
    v6 = *(unsigned __int8 *)(v2 + 8);
    v5 = v2 + 8;
    BYTE8(v13) = *(_BYTE *)(v5 - 3);
    BYTE9(v13) = *(_BYTE *)(v3 + 5);
    WORD5(v13) = *(unsigned __int8 *)(v5 - 4);
    __memcpy_chk((char *)v12 + 8, v5, v6, 264);
    __memcpy_chk((char *)&v12[8] + 8, v3 + 8, *(unsigned __int8 *)(v3 + 8), 136);
    v7 = sub_100034694((unsigned __int8 *)v12);
    if (v7)
    {
      v8 = v7;
      if (dword_10008BA20)
      {
        v9 = ne_log_obj(v7);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          sub_100061990((unsigned __int8 *)v12);
      }
      sub_1000351D4(v8);
      sub_100034EE0(v8);
    }
    return ((int)sub_100030D64(a1) >> 31);
  }
  else
  {
    if (dword_10008BA20)
    {
      v11 = ne_log_obj(a1);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        sub_100061964();
    }
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_100032F58(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t *v6;
  uint64_t *v7;
  NSObject *v9;
  NSObject *v10;
  _OWORD v11[16];
  __int128 v12;

  if (*a1 && (v1 = a1[5]) != 0 && (v2 = a1[6]) != 0 && (v3 = a1[18]) != 0)
  {
    v12 = 0u;
    memset(v11, 0, sizeof(v11));
    LOBYTE(v11[0]) = *(_BYTE *)(v3 + 6);
    v5 = *(unsigned __int8 *)(v1 + 8);
    v4 = v1 + 8;
    BYTE8(v12) = *(_BYTE *)(v4 - 3);
    BYTE9(v12) = *(_BYTE *)(v2 + 5);
    WORD5(v12) = *(unsigned __int8 *)(v4 - 4);
    __memcpy_chk((char *)v11 + 8, v4, v5, 264);
    __memcpy_chk((char *)&v11[8] + 8, v2 + 8, *(unsigned __int8 *)(v2 + 8), 136);
    v6 = sub_100034694((unsigned __int8 *)v11);
    if (v6)
    {
      v7 = v6;
      sub_10000A210((_QWORD *)*(unsigned int *)(v3 + 8), 1);
      sub_1000351D4(v7);
      sub_100034EE0(v7);
      return 0;
    }
    if (dword_10008BA20)
    {
      v10 = ne_log_obj(0);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_10005B9B4((unsigned __int8 *)v11);
    }
  }
  else if (dword_10008BA20)
  {
    v9 = ne_log_obj(a1);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      sub_1000619F8();
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_1000330D8(_QWORD *a1)
{
  NSObject *v2;

  if (*a1)
    return 0;
  if (dword_10008BA20)
  {
    v2 = ne_log_obj(a1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_100061A24();
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100033134(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  BOOL v5;
  NSObject *v7;
  NSObject *v8;
  uint64_t v10;
  unsigned int v11;
  uint64_t *v12;
  uint64_t *v13;
  NSObject *v14;
  _OWORD v15[16];
  __int128 v16;

  if (!*a1)
  {
    if (!dword_10008BA20)
      return 0xFFFFFFFFLL;
    v8 = ne_log_obj(a1);
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      return 0xFFFFFFFFLL;
LABEL_15:
    sub_100061A50();
    return 0xFFFFFFFFLL;
  }
  v2 = a1[5];
  v3 = a1[6];
  v4 = a1[18];
  if (v2)
    v5 = v3 == 0;
  else
    v5 = 1;
  if (v5 || v4 == 0)
  {
    if (!dword_10008BA20)
      return 0xFFFFFFFFLL;
    v7 = ne_log_obj(a1);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      return 0xFFFFFFFFLL;
    goto LABEL_15;
  }
  v16 = 0u;
  memset(v15, 0, sizeof(v15));
  LOBYTE(v15[0]) = *(_BYTE *)(v4 + 6);
  v11 = *(unsigned __int8 *)(v2 + 8);
  v10 = v2 + 8;
  BYTE8(v16) = *(_BYTE *)(v10 - 3);
  BYTE9(v16) = *(_BYTE *)(v3 + 5);
  WORD5(v16) = *(unsigned __int8 *)(v10 - 4);
  __memcpy_chk((char *)v15 + 8, v10, v11, 264);
  __memcpy_chk((char *)&v15[8] + 8, v3 + 8, *(unsigned __int8 *)(v3 + 8), 136);
  v12 = sub_100034694((unsigned __int8 *)v15);
  if (v12)
  {
    v13 = v12;
    if (dword_10008BA20)
    {
      v14 = ne_log_obj(v12);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        sub_100061990((unsigned __int8 *)v15);
    }
    sub_1000351D4(v13);
    sub_100034EE0(v13);
  }
  return ((int)sub_100030D64(a1) >> 31);
}

uint64_t sub_1000332E4(_QWORD *a1)
{
  NSObject *v2;

  if (*a1)
  {
    sub_10000928C(0);
    sub_100008954(0);
    sub_100035220();
    return 0;
  }
  else
  {
    if (dword_10008BA20)
    {
      v2 = ne_log_obj(a1);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_100061A7C();
    }
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_100033354(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t *v6;
  uint64_t *v7;
  NSObject *v9;
  NSObject *v10;
  _OWORD v11[16];
  __int128 v12;

  if (*a1 && (v1 = a1[5]) != 0 && (v2 = a1[6]) != 0 && (v3 = a1[18]) != 0)
  {
    v12 = 0u;
    memset(v11, 0, sizeof(v11));
    LOBYTE(v11[0]) = *(_BYTE *)(v3 + 6);
    v5 = *(unsigned __int8 *)(v1 + 8);
    v4 = v1 + 8;
    BYTE8(v12) = *(_BYTE *)(v4 - 3);
    BYTE9(v12) = *(_BYTE *)(v2 + 5);
    WORD5(v12) = *(unsigned __int8 *)(v4 - 4);
    __memcpy_chk((char *)v11 + 8, v4, v5, 264);
    __memcpy_chk((char *)&v11[8] + 8, v2 + 8, *(unsigned __int8 *)(v2 + 8), 136);
    v6 = sub_100034694((unsigned __int8 *)v11);
    if (v6)
    {
      v7 = v6;
      sub_10000A210((_QWORD *)*(unsigned int *)(v3 + 8), 0);
      sub_1000351D4(v7);
      sub_100034EE0(v7);
      return 0;
    }
    if (dword_10008BA20)
    {
      v10 = ne_log_obj(0);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_10005B9B4((unsigned __int8 *)v11);
    }
  }
  else if (dword_10008BA20)
  {
    v9 = ne_log_obj(a1);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      sub_100061AA8();
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_1000334D4(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  NSObject *v9;
  NSObject *v10;
  NSObject *v11;
  NSObject *v12;

  v1 = *a1;
  if (*a1 && (v2 = a1[20]) != 0 && (v3 = a1[21]) != 0)
  {
    v4 = *(_DWORD *)(v1 + 12);
    v5 = getpid();
    if (v4 == (_DWORD)v5)
    {
      v6 = *(_QWORD *)(v2 + 8);
      if (v6)
      {
        v7 = *(_DWORD *)(v3 + 12);
        if (v7)
        {
          sub_10004D210(v6, *(_DWORD *)(v3 + 4), (_QWORD *)(v3 + 16), v7);
          return 0;
        }
        if (dword_10008BA20)
        {
          v12 = ne_log_obj(v6);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
            sub_100061B68(v1);
        }
      }
      else if (dword_10008BA20)
      {
        v11 = ne_log_obj(0);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
          sub_100061B00(v1);
      }
    }
    else if (dword_10008BA20)
    {
      v10 = ne_log_obj(v5);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        sub_100060FF0();
    }
  }
  else if (dword_10008BA20)
  {
    v9 = ne_log_obj(a1);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      sub_100061AD4();
  }
  return 0xFFFFFFFFLL;
}

void sub_100033620(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, a5, 0xCu);
}

void sub_10003362C(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_debug_impl(a1, v9, OS_LOG_TYPE_DEBUG, a4, &a9, 0x12u);
}

const char *sub_100033640()
{
  return ipsec_strerror();
}

char *sub_100033648(uint64_t a1)
{
  return sub_10003E7D0(*(unsigned __int8 *)(a1 + 1));
}

char *sub_10003366C(uint64_t a1, uint64_t a2)
{
  return sub_10003E7D0(*(unsigned __int8 *)(a2 + 1));
}

char *sub_10003367C(uint64_t a1)
{
  return sub_10003C8A0(*(const sockaddr **)(a1 + 8));
}

char *sub_100033694(const sockaddr *a1)
{
  return sub_10003C8A0(a1);
}

char *sub_10003369C(uint64_t a1)
{
  return sub_1000352C0((unsigned __int8 *)(a1 + 16));
}

void sub_1000336A8(__asl_object_s *a1, int a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  char *v10;
  char *v11;

  if ((a2 - 3) <= 4)
  {
    asl_set(a1, "Level", off_1000850A0[a2 - 3]);
    v10 = (char *)malloc_type_malloc(0x200uLL, 0x75F7A39CuLL);
    if (v10)
    {
      v11 = v10;
      *v10 = 0;
      vsnprintf(v10, 0x200uLL, a3, &a9);
      free(v11);
    }
  }
}

void sub_10003372C(int a1, uint64_t a2, unint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  size_t v13;
  _BYTE *v14;
  uint64_t v15;
  int v16;
  char v17;
  uint64_t v18;
  NSObject *v19;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  os_log_type_t v23;
  NSObject *v24;
  NSObject *v25;
  uint8_t buf[4];
  char *v27;
  __int16 v28;
  _BYTE *v29;
  char __str[512];

  v13 = (a3 >> 2) + 2 * a3 + (a3 >> 5) + 3;
  v14 = malloc_type_malloc(v13, 0xDE4BBEF8uLL);
  if (a3)
  {
    v15 = 0;
    v16 = 0;
    while ((v15 & 0x1F) != 0)
    {
      if ((v15 & 3) == 0)
      {
        v17 = 32;
LABEL_7:
        v14[v16++] = v17;
      }
      snprintf(&v14[v16], v13 - v16, "%02x", *(unsigned __int8 *)(a2 + v15));
      v16 += 2;
      if (a3 == ++v15)
        goto LABEL_11;
    }
    v17 = 10;
    goto LABEL_7;
  }
  v16 = 0;
LABEL_11:
  if (v13 - v16 >= 2)
    *(_WORD *)&v14[v16] = 10;
  __str[0] = 10;
  v18 = vsnprintf(__str, 0x200uLL, a4, &a9);
  if (dword_10008BA20)
  {
    if (a1 <= 2)
    {
      v19 = ne_log_obj(v18);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
        sub_100061BD0();
      goto LABEL_29;
    }
    if (a1 == 3)
    {
      v20 = ne_log_obj(v18);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        sub_100061C40();
      goto LABEL_29;
    }
    if (a1 <= 5)
    {
      v21 = ne_log_obj(v18);
      if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        goto LABEL_29;
      *(_DWORD *)buf = 136315394;
      v27 = __str;
      v28 = 2080;
      v29 = v14;
      v22 = v21;
      v23 = OS_LOG_TYPE_DEFAULT;
LABEL_26:
      _os_log_impl((void *)&_mh_execute_header, v22, v23, "%s %s", buf, 0x16u);
      goto LABEL_29;
    }
    v24 = ne_log_obj(v18);
    v25 = v24;
    if (a1 == 6)
    {
      if (!os_log_type_enabled(v24, OS_LOG_TYPE_INFO))
        goto LABEL_29;
      *(_DWORD *)buf = 136315394;
      v27 = __str;
      v28 = 2080;
      v29 = v14;
      v22 = v25;
      v23 = OS_LOG_TYPE_INFO;
      goto LABEL_26;
    }
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
      sub_100061CB0();
  }
LABEL_29:
  free(v14);
}

void sub_1000339CC(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, const char *a6, uint64_t a7, uint64_t a8, char a9)
{
  _QWORD *v15;
  _QWORD *v16;
  const char **v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  NSObject *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  NSObject *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  NSObject *v38;
  NSObject *v39;
  os_log_type_t v40;
  NSObject *v41;
  NSObject *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  const char *v49;
  char *v50[2];
  uint8_t buf[4];
  char *v52;

  if (a1)
  {
    v15 = malloc_type_calloc(1uLL, 0x58uLL, 0x10F0040C24C227BuLL);
    if (v15)
    {
      v16 = v15;
      *(_DWORD *)a1 = a3;
      v50[1] = &a9;
      v17 = (const char **)(a1 + 24);
      v18 = vasprintf((char **)(a1 + 24), a6, &a9);
      *(_DWORD *)(a1 + 32) = v18;
      *(_QWORD *)(a1 + 40) = a4;
      *(_QWORD *)(a1 + 48) = a5;
      v19 = *(_QWORD *)(a1 + 56);
      while (v19)
      {
        v20 = v19;
        v19 = *(_QWORD *)(v19 + 72);
        if (!v19)
        {
          *(_QWORD *)(v20 + 72) = v16;
          v16[10] = v20 + 72;
          break;
        }
      }
      if (a2 == 2)
      {
        v50[0] = 0;
        v21 = *(_QWORD *)(a1 + 56);
        if (v21)
        {
          do
          {
            if (*v17)
            {
              v22 = v50[0];
              if (v50[0])
              {
                v49 = *v17;
                v50[0] = 0;
                asprintf(v50, "%s\n\t\t-> %s", v22, v49);
                free(v22);
              }
              else
              {
                v18 = asprintf(v50, "%s", *v17);
              }
            }
            v21 = *(_QWORD *)(v21 + 72);
          }
          while (v21);
          if (v50[0] && dword_10008BA20 != 0)
          {
            if (a3 <= 2)
            {
              v24 = ne_log_obj(v18);
              if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT))
                sub_100061D20((uint64_t)v50, v24, v25, v26, v27, v28, v29, v30);
              return;
            }
            if (a3 == 3)
            {
              v31 = ne_log_obj(v18);
              if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
                sub_100061D88((uint64_t)v50, v31, v32, v33, v34, v35, v36, v37);
              return;
            }
            if (a3 <= 5)
            {
              v38 = ne_log_obj(v18);
              if (!os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
                return;
              *(_DWORD *)buf = 136315138;
              v52 = v50[0];
              v39 = v38;
              v40 = OS_LOG_TYPE_DEFAULT;
LABEL_30:
              _os_log_impl((void *)&_mh_execute_header, v39, v40, "%s", buf, 0xCu);
              return;
            }
            v41 = ne_log_obj(v18);
            v42 = v41;
            if (a3 == 6)
            {
              if (!os_log_type_enabled(v41, OS_LOG_TYPE_INFO))
                return;
              *(_DWORD *)buf = 136315138;
              v52 = v50[0];
              v39 = v42;
              v40 = OS_LOG_TYPE_INFO;
              goto LABEL_30;
            }
            if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
              sub_100061DF0((uint64_t)v50, v42, v43, v44, v45, v46, v47, v48);
          }
        }
      }
    }
  }
}

void sub_100033C54(const char *a1)
{
  const char *v2;
  char *v3;
  int v4;
  int *v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  if (a1)
    v2 = a1;
  else
    v2 = "bad file path";
  syslog(5, "%s: about to add racoon log file: %s\n", "plogsetfile", v2);
  if (qword_10008B9F8)
  {
    free((void *)qword_10008B9F8);
    if (dword_1000882CC != -1)
    {
      asl_remove_log_file((asl_object_t)qword_10008BA18, dword_1000882CC);
      asl_close_auxiliary_file(dword_1000882CC);
      dword_1000882CC = -1;
    }
  }
  v3 = strdup(a1);
  qword_10008B9F8 = (uint64_t)v3;
  if (!v3)
  {
    if (dword_10008BA20)
    {
      v6 = ne_log_obj(0);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        sub_100061E58(v6, v7, v8, v9, v10, v11, v12, v13);
    }
    exit(1);
  }
  v4 = open(v3, 777, 420);
  dword_1000882CC = v4;
  if (v4 < 0)
  {
    v5 = __error();
    syslog(5, "%s: failed to add racoon log file: %s. error %d\n", "plogsetfile", v2, *v5);
  }
  else
  {
    asl_add_log_file((asl_object_t)qword_10008BA18, v4);
  }
}

void sub_100033D88(char *__s2)
{
  void *v1;

  v1 = (void *)qword_10008B9F8;
  if ((unint64_t)__s2 | qword_10008B9F8)
  {
    if (__s2 && qword_10008B9F8)
    {
      if (!strcmp((const char *)qword_10008B9F8, __s2))
        return;
      if (dword_1000882CC == -1)
      {
LABEL_8:
        free(v1);
        qword_10008B9F8 = 0;
LABEL_9:
        if (__s2)
          sub_100033C54(__s2);
        return;
      }
      asl_remove_log_file((asl_object_t)qword_10008BA18, dword_1000882CC);
      close(dword_1000882CC);
      dword_1000882CC = -1;
      v1 = (void *)qword_10008B9F8;
    }
    if (!v1)
      goto LABEL_9;
    goto LABEL_8;
  }
}

uint64_t sub_100033E2C()
{
  return dword_1000882C8;
}

uint64_t sub_100033E38(int a1)
{
  unsigned int v1;
  int v2;

  if ((a1 - 1) >= 7)
  {
    v1 = dword_1000882C8;
  }
  else
  {
    dword_1000882C8 = a1;
    v1 = a1;
  }
  v2 = ~(-1 << (v1 + 1)) | ((v1 > 5) << 8);
  syslog(7, "%s: about to set racoon's log level %d, mask %x\n", "plogsetlevel", a1, v2);
  return asl_set_filter(0, v2);
}

uint64_t sub_100033EC0(uint64_t result)
{
  const char *v1;
  int v2;
  int v3;

  if (result)
  {
    v1 = (const char *)result;
    v2 = strncmp((const char *)result, "Emergency", 9uLL);
    if (!v2)
      return sub_100033E38(v2);
    if (!strncmp(v1, "Alert", 5uLL))
    {
      dword_1000882C8 = 1;
      syslog(7, "%s: about to set racoon's log level %d, mask %x\n", "plogsetlevel", 1, 3);
      v3 = 3;
    }
    else if (!strncmp(v1, "Critical", 8uLL))
    {
      dword_1000882C8 = 2;
      syslog(7, "%s: about to set racoon's log level %d, mask %x\n", "plogsetlevel", 2, 7);
      v3 = 7;
    }
    else if (!strncmp(v1, "Error", 5uLL))
    {
      dword_1000882C8 = 3;
      syslog(7, "%s: about to set racoon's log level %d, mask %x\n", "plogsetlevel", 3, 15);
      v3 = 15;
    }
    else if (!strncmp(v1, "Warning", 6uLL))
    {
      dword_1000882C8 = 4;
      syslog(7, "%s: about to set racoon's log level %d, mask %x\n", "plogsetlevel", 4, 31);
      v3 = 31;
    }
    else
    {
      if (strncmp(v1, "Notice", 6uLL))
      {
        if (!strncmp(v1, "Info", 4uLL))
        {
          v2 = 6;
        }
        else
        {
          result = strncmp(v1, "Debug", 5uLL);
          if ((_DWORD)result)
            return result;
          v2 = 7;
        }
        return sub_100033E38(v2);
      }
      dword_1000882C8 = 5;
      syslog(7, "%s: about to set racoon's log level %d, mask %x\n", "plogsetlevel", 5, 63);
      v3 = 63;
    }
    return asl_set_filter(0, v3);
  }
  return result;
}

void sub_1000340F8(const char *a1)
{
  size_t v2;
  uint64_t v3;
  NSObject *v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  if (a1)
  {
    v2 = strlen(a1);
    if ((int)v2 >= 3 && *a1 == 34 && (v3 = (v2 - 1), a1[v3] == 34))
    {
      a1[v3] = 0;
      sub_100033EC0((uint64_t)(a1 + 1));
    }
    else if (dword_10008BA20)
    {
      v4 = ne_log_obj(v2);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_100061EC0();
    }
  }
  else if (dword_10008BA20)
  {
    v5 = ne_log_obj(0);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      sub_100061E8C(v5, v6, v7, v8, v9, v10, v11, v12);
  }
}

void sub_1000341B0()
{
  const __CFDictionary *Value;
  const __CFDictionary *v1;
  CFTypeID v2;
  const __CFNumber *v3;
  const __CFNumber *v4;
  CFTypeID v5;
  const __CFString *v6;
  const __CFString *v7;
  CFTypeID v8;
  const __CFString *v9;
  const __CFString *v10;
  CFTypeID v11;
  int valuePtr;
  char buffer[16];

  valuePtr = 0;
  buffer[0] = 0;
  SCPreferencesSynchronize((SCPreferencesRef)qword_10008C710);
  Value = (const __CFDictionary *)SCPreferencesGetValue((SCPreferencesRef)qword_10008C710, CFSTR("Global"));
  if (Value)
  {
    v1 = Value;
    v2 = CFGetTypeID(Value);
    if (v2 == CFDictionaryGetTypeID())
    {
      v3 = (const __CFNumber *)CFDictionaryGetValue(v1, CFSTR("DebugLevel"));
      if (v3 && (v4 = v3, v5 = CFGetTypeID(v3), v5 == CFNumberGetTypeID()))
      {
        CFNumberGetValue(v4, kCFNumberSInt32Type, &valuePtr);
        sub_100033E38(valuePtr);
      }
      else
      {
        v6 = (const __CFString *)CFDictionaryGetValue(v1, CFSTR("DebugLevelString"));
        if (v6)
        {
          v7 = v6;
          v8 = CFGetTypeID(v6);
          if (v8 == CFStringGetTypeID())
          {
            CFStringGetCString(v7, buffer, 16, 0);
            sub_100033EC0((uint64_t)buffer);
          }
        }
      }
      v9 = (const __CFString *)CFDictionaryGetValue(v1, CFSTR("DebugLogfile"));
      if (v9)
      {
        v10 = v9;
        v11 = CFGetTypeID(v9);
        if (v11 == CFStringGetTypeID())
        {
          CFStringGetCString(v10, &byte_10008BA24, 1024, 0);
          sub_100033C54(&byte_10008BA24);
        }
      }
    }
  }
}

void sub_100034328()
{
  byte_10008BA24 = 0;
  qword_10008BA18 = 0;
  dword_1000882C8 = 5;
  syslog(7, "%s: about to set racoon's log level %d, mask %x\n", "plogsetlevel", 5, 63);
  asl_set_filter(0, 63);
  sub_1000341B0();
}

char *sub_10003438C(char *__s1, uint64_t a2, const char *a3)
{
  char *v6;
  char *v7;
  char *result;

  if (qword_10008BA00)
    free((void *)qword_10008BA00);
  if (__s1)
  {
    v6 = strdup(__s1);
    qword_10008BA00 = (uint64_t)v6;
    if (v6)
      free(v6);
    if (a2)
      goto LABEL_7;
  }
  else
  {
    qword_10008BA00 = 0;
    if (a2)
    {
LABEL_7:
      v7 = strdup(__s1);
      goto LABEL_10;
    }
  }
  v7 = 0;
LABEL_10:
  qword_10008BA08 = (uint64_t)v7;
  if (qword_10008BA10)
    free((void *)qword_10008BA10);
  if (a3)
    result = strdup(a3);
  else
    result = 0;
  qword_10008BA10 = (uint64_t)result;
  return result;
}

char *sub_10003442C(const __CFAllocator *a1, CFStringRef theString)
{
  CFIndex Length;
  CFIndex v5;
  char *v6;

  Length = CFStringGetLength(theString);
  v5 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
  v6 = (char *)CFAllocatorAllocate(a1, v5, 0);
  CFStringGetCString(theString, v6, v5, 0x8000100u);
  return v6;
}

void sub_10003449C(int a1, CFStringRef format, ...)
{
  const __CFString *v3;
  char *v4;
  char *v5;
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  os_log_type_t v10;
  NSObject *v11;
  NSObject *v12;
  uint8_t buf[4];
  char *v14;
  va_list va;

  va_start(va, format);
  v3 = CFStringCreateWithFormatAndArguments(kCFAllocatorDefault, 0, format, va);
  v4 = sub_10003442C(kCFAllocatorDefault, v3);
  v5 = v4;
  if (!dword_10008BA20)
    goto LABEL_17;
  if (a1 <= 2)
  {
    v6 = ne_log_obj(v4);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      sub_100061F20();
    goto LABEL_17;
  }
  if (a1 == 3)
  {
    v7 = ne_log_obj(v4);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      sub_100061F80();
    goto LABEL_17;
  }
  if (a1 <= 5)
  {
    v8 = ne_log_obj(v4);
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      goto LABEL_17;
    *(_DWORD *)buf = 136315138;
    v14 = v5;
    v9 = v8;
    v10 = OS_LOG_TYPE_DEFAULT;
LABEL_14:
    _os_log_impl((void *)&_mh_execute_header, v9, v10, "%s", buf, 0xCu);
    goto LABEL_17;
  }
  v11 = ne_log_obj(v4);
  v12 = v11;
  if (a1 == 6)
  {
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
      goto LABEL_17;
    *(_DWORD *)buf = 136315138;
    v14 = v5;
    v9 = v12;
    v10 = OS_LOG_TYPE_INFO;
    goto LABEL_14;
  }
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    sub_100061FE0();
LABEL_17:
  CFAllocatorDeallocate(kCFAllocatorDefault, v5);
  CFRelease(v3);
}

void sub_100034684(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, &a9, 0xCu);
}

uint64_t *sub_100034694(unsigned __int8 *a1)
{
  uint64_t *v2;

  v2 = &qword_100088D18;
  do
    v2 = (uint64_t *)*v2;
  while (v2 && sub_1000346D4(a1, (unsigned __int8 *)v2 + 16));
  return v2;
}

BOOL sub_1000346D4(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 != *a2
      || a1[264] != a2[264]
      || a1[265] != a2[265]
      || *((unsigned __int16 *)a1 + 133) != *((unsigned __int16 *)a2 + 133)
      || sub_10003B5A0((unint64_t)(a1 + 8), (unint64_t)(a2 + 8))
      || sub_10003B5A0((unint64_t)(a1 + 136), (unint64_t)(a2 + 136)) != 0;
}

uint64_t sub_100034760(unsigned __int8 *a1, unint64_t *a2)
{
  uint64_t v2;
  int v5;
  unint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  NSObject *v10;
  int v11;
  int v12;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;
  NSObject *v16;
  NSObject *v17;
  int v18;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  NSObject *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  _BYTE v36[16];
  _BYTE v37[16];
  _BYTE v38[16];
  _BYTE v39[16];
  uint8_t buf[4];
  const char *v41;
  __int16 v42;
  int v43;
  __int16 v44;
  int v45;

  v2 = qword_100088D18;
  if (!qword_100088D18)
    return v2;
  v5 = 0;
  v6 = a2 + 1;
  while (1)
  {
    v7 = sub_100034AD4(a1, (unsigned __int8 *)(v2 + 16));
    if ((_DWORD)v7)
      goto LABEL_36;
    if (*a1)
    {
      v8 = *(_QWORD *)(v2 + 296);
      if (v8)
        break;
    }
LABEL_34:
    if (!v5)
      return v2;
    v5 = 1;
LABEL_36:
    v2 = *(_QWORD *)v2;
    if (!v2)
      return v2;
  }
  while (1)
  {
    if (*(_BYTE *)(v8 + 266) != 2)
    {
      if (dword_10008BA20)
      {
        v10 = ne_log_obj(v7);
        v7 = os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG);
        if ((_DWORD)v7)
        {
          v11 = *a1;
          v12 = *(unsigned __int8 *)(v8 + 266);
          *(_DWORD *)buf = 136315650;
          v41 = "getsp_r";
          v42 = 1024;
          v43 = v11;
          v44 = 1024;
          v45 = v12;
          _os_log_debug_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "%s, skipping policy. dir %d, mode %d\n", buf, 0x18u);
        }
      }
      goto LABEL_33;
    }
    v9 = *a1;
    if (v9 == 2)
      break;
    if (v9 == 1)
    {
      v7 = sub_10003B380(*v6, v8 + 8);
      if (!(_DWORD)v7)
      {
        v7 = sub_10003B380(*a2, v8 + 136);
        if (!(_DWORD)v7)
        {
          if (dword_10008BA20)
          {
            v20 = ne_log_obj(v7);
            if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
              sub_100062150(v20, v21, v22, v23, v24, v25, v26, v27);
          }
          return v2;
        }
      }
    }
LABEL_17:
    if (dword_10008BA20)
    {
      v13 = ne_log_obj(v7);
      v7 = os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)v7)
      {
        v18 = *a1;
        *(_DWORD *)buf = 136315394;
        v41 = "getsp_r";
        v42 = 1024;
        v43 = v18;
        _os_log_debug_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "%s, policy outer addresses matched Phase 2 addresses: dir %d\n", buf, 0x12u);
      }
      if (dword_10008BA20)
      {
        v14 = ne_log_obj(v7);
        v7 = os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG);
        if ((_DWORD)v7)
          sub_100062114((uint64_t)v39, (const sockaddr **)a2);
        if (dword_10008BA20)
        {
          v15 = ne_log_obj(v7);
          v7 = os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG);
          if ((_DWORD)v7)
            sub_1000620C8((uint64_t)v38, (const sockaddr *)(v8 + 8));
          if (dword_10008BA20)
          {
            v16 = ne_log_obj(v7);
            v7 = os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG);
            if ((_DWORD)v7)
              sub_10006208C((uint64_t)v37, (const sockaddr **)v6);
            if (dword_10008BA20)
            {
              v17 = ne_log_obj(v7);
              v7 = os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG);
              if ((_DWORD)v7)
                sub_100062040((uint64_t)v36, v8);
            }
          }
        }
      }
    }
    v5 = 1;
LABEL_33:
    v8 = *(_QWORD *)v8;
    if (!v8)
      goto LABEL_34;
  }
  v7 = sub_10003B380(*a2, v8 + 8);
  if ((_DWORD)v7)
    goto LABEL_17;
  v7 = sub_10003B380(*v6, v8 + 136);
  if ((_DWORD)v7)
    goto LABEL_17;
  if (dword_10008BA20)
  {
    v28 = ne_log_obj(v7);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
      sub_1000621C0(v28, v29, v30, v31, v32, v33, v34, v35);
  }
  return v2;
}

BOOL sub_100034AD4(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v4;
  int v5;
  unsigned __int8 *v7;
  NSObject *v8;
  uint64_t v9;
  NSObject *v10;
  _BOOL8 v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v15;
  NSObject *v16;
  _BOOL8 v17;
  NSObject *v18;
  int v19;
  int v20;
  uint64_t *v21;
  int v22;
  uint64_t *v23;
  int v24;
  uint64_t *v25;
  NSObject *v26;
  int v27;
  unsigned __int8 *v28;
  __int16 v29;
  int v30;
  __int16 v31;
  uint64_t *v32;
  sockaddr v33[8];
  sockaddr v34[8];

  if (*a2 && *a1 != *a2)
    return 1;
  v4 = *((unsigned __int16 *)a1 + 133);
  if (v4 != 255)
  {
    v5 = *((unsigned __int16 *)a2 + 133);
    if (v5 != 255 && v4 != v5)
      return 1;
  }
  if (a1[9] != a2[9] || a1[137] != a2[137])
    return 1;
  v7 = a2 + 8;
  memset(v34, 0, sizeof(v34));
  memset(v33, 0, sizeof(v33));
  if (a1[8] > 0x80u || *v7 >= 0x81u)
  {
    if (dword_10008BA20)
    {
      v8 = ne_log_obj(a1);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_100062230(a1 + 8, v7, v8);
    }
    return 1;
  }
  sub_10003CE78((char *)v34, a1 + 8, a2[264]);
  sub_10003CE78((char *)v33, a2 + 8, a2[264]);
  if (dword_10008BA20)
  {
    v10 = ne_log_obj(v9);
    v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG);
    if (v11)
    {
      v19 = a2[264];
      v27 = 134218498;
      v28 = a1;
      v29 = 1024;
      v30 = v19;
      v31 = 2080;
      v32 = sub_10003C570(v34);
      _os_log_debug_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "%p masked with /%d: %s\n", (uint8_t *)&v27, 0x1Cu);
    }
    if (dword_10008BA20)
    {
      v12 = ne_log_obj(v11);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        v20 = a2[264];
        v21 = sub_10003C570(v33);
        v27 = 134218498;
        v28 = a2;
        v29 = 1024;
        v30 = v20;
        v31 = 2080;
        v32 = v21;
        _os_log_debug_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "%p masked with /%d: %s\n", (uint8_t *)&v27, 0x1Cu);
      }
    }
  }
  v13 = sub_10003B4E8((unint64_t)v34, (unint64_t)v33);
  if ((_DWORD)v13)
    return 1;
  if (a1[136] > 0x80u || a2[136] >= 0x81u)
  {
    if (dword_10008BA20)
    {
      v26 = ne_log_obj(v13);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        sub_1000622B8(v26);
    }
    exit(1);
  }
  sub_10003CE78((char *)v34, a1 + 136, a2[265]);
  sub_10003CE78((char *)v33, a2 + 136, a2[265]);
  if (dword_10008BA20)
  {
    v16 = ne_log_obj(v15);
    v17 = os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG);
    if (v17)
    {
      v22 = a2[265];
      v23 = sub_10003C570(v34);
      v27 = 134218498;
      v28 = a1;
      v29 = 1024;
      v30 = v22;
      v31 = 2080;
      v32 = v23;
      _os_log_debug_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "%p masked with /%d: %s\n", (uint8_t *)&v27, 0x1Cu);
    }
    if (dword_10008BA20)
    {
      v18 = ne_log_obj(v17);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        v24 = a2[265];
        v25 = sub_10003C570(v33);
        v27 = 134218498;
        v28 = a2;
        v29 = 1024;
        v30 = v24;
        v31 = 2080;
        v32 = v25;
        _os_log_debug_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEBUG, "%p masked with /%d: %s\n", (uint8_t *)&v27, 0x1Cu);
      }
    }
  }
  return sub_10003B4E8((unint64_t)v34, (unint64_t)v33) != 0;
}

uint64_t *sub_100034EA0(int a1)
{
  uint64_t *result;

  result = &qword_100088D18;
  do
    result = (uint64_t *)*result;
  while (result && *((_DWORD *)result + 72) != a1);
  return result;
}

void *sub_100034EC4()
{
  return malloc_type_calloc(1uLL, 0x130uLL, 0x10A004034AE4055uLL);
}

void sub_100034EE0(_QWORD *a1)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)a1[37];
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      free(v2);
      v2 = v3;
    }
    while (v3);
  }
  free(a1);
}

void sub_100034F18(void *__src)
{
  char v1;
  char v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  _QWORD __dst[34];

  memcpy(__dst, __src, sizeof(__dst));
  if (LOBYTE(__dst[0]) == 2)
  {
    v21 = *(_OWORD *)&__dst[25];
    v22 = *(_OWORD *)&__dst[27];
    v23 = *(_OWORD *)&__dst[29];
    v24 = *(_OWORD *)&__dst[31];
    v17 = *(_OWORD *)&__dst[17];
    v18 = *(_OWORD *)&__dst[19];
    v19 = *(_OWORD *)&__dst[21];
    v20 = *(_OWORD *)&__dst[23];
    v11 = *(_OWORD *)&__dst[5];
    v12 = *(_OWORD *)&__dst[7];
    v9 = *(_OWORD *)&__dst[1];
    v10 = *(_OWORD *)&__dst[3];
    v15 = *(_OWORD *)&__dst[13];
    v16 = *(_OWORD *)&__dst[15];
    v13 = *(_OWORD *)&__dst[9];
    v14 = *(_OWORD *)&__dst[11];
    v1 = BYTE1(__dst[33]);
    v2 = __dst[33];
  }
  else
  {
    if (LOBYTE(__dst[0]) != 1)
      return;
    v21 = *(_OWORD *)&__dst[9];
    v22 = *(_OWORD *)&__dst[11];
    v23 = *(_OWORD *)&__dst[13];
    v24 = *(_OWORD *)&__dst[15];
    v17 = *(_OWORD *)&__dst[1];
    v18 = *(_OWORD *)&__dst[3];
    v19 = *(_OWORD *)&__dst[5];
    v20 = *(_OWORD *)&__dst[7];
    v11 = *(_OWORD *)&__dst[21];
    v12 = *(_OWORD *)&__dst[23];
    v9 = *(_OWORD *)&__dst[17];
    v10 = *(_OWORD *)&__dst[19];
    v15 = *(_OWORD *)&__dst[29];
    v16 = *(_OWORD *)&__dst[31];
    v13 = *(_OWORD *)&__dst[25];
    v14 = *(_OWORD *)&__dst[27];
    v1 = __dst[33];
    v2 = BYTE1(__dst[33]);
  }
  *(_OWORD *)&__dst[9] = v21;
  *(_OWORD *)&__dst[11] = v22;
  *(_OWORD *)&__dst[13] = v23;
  *(_OWORD *)&__dst[15] = v24;
  *(_OWORD *)&__dst[1] = v17;
  *(_OWORD *)&__dst[3] = v18;
  *(_OWORD *)&__dst[5] = v19;
  *(_OWORD *)&__dst[7] = v20;
  *(_OWORD *)&__dst[23] = v12;
  *(_OWORD *)&__dst[21] = v11;
  *(_OWORD *)&__dst[19] = v10;
  *(_OWORD *)&__dst[17] = v9;
  *(_OWORD *)&__dst[31] = v16;
  *(_OWORD *)&__dst[29] = v15;
  *(_OWORD *)&__dst[27] = v14;
  *(_OWORD *)&__dst[25] = v13;
  LOBYTE(__dst[33]) = v1;
  LOBYTE(__dst[0]) = 1;
  v3 = &qword_100088D18;
  BYTE1(__dst[33]) = v2;
  while (1)
  {
    v3 = (uint64_t *)*v3;
    if (!v3)
      break;
    if (!sub_1000346D4((unsigned __int8 *)__dst, (unsigned __int8 *)v3 + 16))
    {
      v4 = *v3;
      v5 = (uint64_t *)v3[1];
      if (*v3)
      {
        *(_QWORD *)(v4 + 8) = v5;
        v5 = (uint64_t *)v3[1];
      }
      else
      {
        qword_100088D20 = v3[1];
      }
      *v5 = v4;
      sub_10003AEAC();
      sub_100034EE0(v3);
      break;
    }
  }
  *(_OWORD *)&__dst[9] = v13;
  *(_OWORD *)&__dst[11] = v14;
  *(_OWORD *)&__dst[13] = v15;
  *(_OWORD *)&__dst[15] = v16;
  *(_OWORD *)&__dst[1] = v9;
  *(_OWORD *)&__dst[3] = v10;
  *(_OWORD *)&__dst[5] = v11;
  *(_OWORD *)&__dst[7] = v12;
  *(_OWORD *)&__dst[21] = v19;
  *(_OWORD *)&__dst[23] = v20;
  *(_OWORD *)&__dst[17] = v17;
  *(_OWORD *)&__dst[19] = v18;
  *(_OWORD *)&__dst[29] = v23;
  *(_OWORD *)&__dst[31] = v24;
  *(_OWORD *)&__dst[25] = v21;
  *(_OWORD *)&__dst[27] = v22;
  LOBYTE(__dst[33]) = v2;
  BYTE1(__dst[33]) = v1;
  v6 = &qword_100088D18;
  LOBYTE(__dst[0]) = 2;
  while (1)
  {
    v6 = (uint64_t *)*v6;
    if (!v6)
      break;
    if (!sub_1000346D4((unsigned __int8 *)__dst, (unsigned __int8 *)v6 + 16))
    {
      v7 = *v6;
      v8 = (uint64_t *)v6[1];
      if (*v6)
      {
        *(_QWORD *)(v7 + 8) = v8;
        v8 = (uint64_t *)v6[1];
      }
      else
      {
        qword_100088D20 = v6[1];
      }
      *v8 = v7;
      sub_10003AEAC();
      sub_100034EE0(v6);
      return;
    }
  }
}

void sub_1000351D4(uint64_t *a1)
{
  uint64_t v1;
  _QWORD *v2;

  v1 = *a1;
  v2 = (_QWORD *)a1[1];
  if (*a1)
  {
    *(_QWORD *)(v1 + 8) = v2;
    v2 = (_QWORD *)a1[1];
  }
  else
  {
    qword_100088D20 = a1[1];
  }
  *v2 = v1;
  sub_10003AEAC();
}

void sub_1000351F8(_QWORD *a1)
{
  uint64_t *v1;

  v1 = (uint64_t *)qword_100088D18;
  *a1 = qword_100088D18;
  if (!v1)
    v1 = &qword_100088D18;
  v1[1] = (uint64_t)a1;
  qword_100088D18 = (uint64_t)a1;
  a1[1] = &qword_100088D18;
  sub_10003AEAC();
}

void sub_100035220()
{
  _QWORD *v0;
  _QWORD *v1;
  _QWORD *v2;

  v0 = (_QWORD *)qword_100088D18;
  if (qword_100088D18)
  {
    do
    {
      v2 = (_QWORD *)*v0;
      v1 = (_QWORD *)v0[1];
      if (*v0)
      {
        v2[1] = v1;
        v1 = (_QWORD *)v0[1];
      }
      else
      {
        qword_100088D20 = v0[1];
      }
      *v1 = v2;
      sub_10003AEAC();
      sub_100034EE0(v0);
      v0 = v2;
    }
    while (v2);
  }
}

BOOL sub_100035280()
{
  return qword_100088D18 != 0;
}

void sub_100035294()
{
  qword_100088D18 = 0;
  qword_100088D20 = (uint64_t)&qword_100088D18;
}

void *sub_1000352A4()
{
  return malloc_type_calloc(1uLL, 0x120uLL, 0x102004020B6CA89uLL);
}

char *sub_1000352C0(unsigned __int8 *a1)
{
  uint64_t *v2;
  const char *i;
  unsigned int v4;
  char *result;
  char *v6;
  size_t v7;
  uint64_t *v8;
  const char *j;
  int v10;
  size_t v11;
  char *v12;
  const char *v13;
  char *v14;

  v2 = sub_10003C570((const sockaddr *)(a1 + 8));
  for (i = (const char *)v2; *i; ++i)
  {
    if (*i == 91)
    {
      *i++ = 0;
      break;
    }
  }
  v4 = snprintf(byte_100088D28, 0xFFuLL, "%s/%d[%s ", (const char *)v2, a1[264], i);
  if (v4 > 0xFE)
    return 0;
  v6 = &byte_100088D28[v4];
  v7 = 255 - v4;
  v8 = sub_10003C570((const sockaddr *)(a1 + 136));
  for (j = (const char *)v8; *j; ++j)
  {
    if (*j == 91)
    {
      *j++ = 0;
      break;
    }
  }
  v10 = snprintf(v6, v7, "%s/%d[%s ", (const char *)v8, a1[265], j);
  result = 0;
  if ((v10 & 0x80000000) == 0 && (int)v7 > v10)
  {
    v11 = (int)v7 - v10;
    v12 = &v6[v10];
    v13 = sub_10003E940(*((unsigned __int16 *)a1 + 133));
    v14 = sub_10003E8B8(*a1);
    snprintf(v12, v11, "proto=%s dir=%s", v13, v14);
    return byte_100088D28;
  }
  return result;
}

uint64_t *sub_1000353F0(uint64_t a1, const sockaddr **a2)
{
  return sub_10003C570(*a2);
}

void *sub_100035404()
{
  return malloc_type_calloc(1uLL, 0x30uLL, 0x10200401AD049D5uLL);
}

void *sub_100035420()
{
  return malloc_type_calloc(1uLL, 0x50uLL, 0x1020040BE967AE7uLL);
}

uint64_t *sub_10003543C(uint64_t *result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *result;
  if (*result)
  {
    do
    {
      v3 = v2;
      v2 = *(_QWORD *)(v2 + 40);
    }
    while (v2);
    result = (uint64_t *)(v3 + 40);
  }
  *result = a2;
  return result;
}

_QWORD *sub_10003545C(uint64_t a1, uint64_t a2)
{
  _QWORD *result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v4 = *(_QWORD *)(a1 + 32);
  result = (_QWORD *)(a1 + 32);
  v3 = v4;
  while (v3)
  {
    v5 = v3;
    v3 = *(_QWORD *)(v3 + 72);
    if (!v3)
    {
      result = (_QWORD *)(v5 + 72);
      break;
    }
  }
  *result = a2;
  return result;
}

uint64_t sub_10003547C(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(a2 + 72) = *(_QWORD *)(result + 32);
  *(_QWORD *)(result + 32) = a2;
  return result;
}

void *sub_10003548C()
{
  return malloc_type_calloc(1uLL, 0x18uLL, 0x10200403ED2C137uLL);
}

_QWORD *sub_1000354A8(uint64_t a1, uint64_t a2)
{
  _QWORD *result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v4 = *(_QWORD *)(a1 + 64);
  result = (_QWORD *)(a1 + 64);
  v3 = v4;
  while (v3)
  {
    v5 = v3;
    v3 = *(_QWORD *)(v3 + 16);
    if (!v3)
    {
      result = (_QWORD *)(v5 + 16);
      break;
    }
  }
  *result = a2;
  return result;
}

uint64_t sub_1000354C8(_QWORD *a1, uint64_t a2)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t result;

  if (a1)
  {
    v2 = a1;
    v3 = *a1;
    if (*a1)
    {
      if (v3 == a2)
      {
LABEL_7:
        result = 0;
        *v2 = *(_QWORD *)(a2 + 16);
        *(_QWORD *)(a2 + 16) = 0;
        return result;
      }
      while (1)
      {
        v4 = v3;
        v3 = *(_QWORD *)(v3 + 16);
        if (!v3)
          break;
        if (v3 == a2)
        {
          v2 = (_QWORD *)(v4 + 16);
          goto LABEL_7;
        }
      }
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100035514(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  NSObject *v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  NSObject *v21;
  int v22;
  NSObject *v23;
  int v24;
  NSObject *v25;
  int v26;
  int v27;
  NSObject *v28;
  NSObject *v29;
  NSObject *v30;
  int *i;
  int v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  _BYTE *v37;
  _BOOL4 v38;
  _BOOL4 v39;
  uint64_t v40;
  uint64_t v41;
  NSObject *v42;
  uint64_t v43;
  int v44;
  int v45;
  NSObject *v46;
  char *v47;
  char *v48;
  unsigned int v49;
  int v50;
  int v51;
  NSObject *v52;
  char *v53;
  char *v54;
  unsigned int v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t *v58;
  uint64_t *v59;
  uint64_t *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t **v65;
  uint64_t v66;
  int *v67;
  NSObject *v69;
  NSObject *v70;
  NSObject *v71;
  NSObject *v72;
  NSObject *v73;
  NSObject *v74;
  _BYTE *v75;
  _BYTE *v76;
  uint8_t v77;
  _BYTE v78[7];
  uint8_t buf[4];
  _BYTE v80[10];
  int v81;
  __int16 v82;
  char *v83;
  __int16 v84;
  unsigned int v85;

  v8 = (uint64_t)malloc_type_calloc(1uLL, 0x30uLL, 0x10200401AD049D5uLL);
  if (!v8)
  {
    if (dword_10008BA20)
    {
      v11 = ne_log_obj(0);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        sub_1000622F8();
    }
    return 0;
  }
  v9 = v8;
  *(_DWORD *)v8 = *(_DWORD *)a2;
  switch(*(_DWORD *)(*(_QWORD *)(a1 + 64) + 172))
  {
    case 1:
      *(_QWORD *)(v8 + 8) = *(_QWORD *)(a2 + 8);
      *(_DWORD *)(v8 + 16) = *(_DWORD *)(a2 + 16);
      v10 = *(_DWORD *)(a2 + 20);
      goto LABEL_45;
    case 2:
      v12 = *(_QWORD *)(a2 + 8);
      if (v12 <= *(_QWORD *)(a3 + 8))
      {
        v22 = *(_DWORD *)(a2 + 16);
        if (v22 <= *(_DWORD *)(a3 + 16))
        {
          *(_QWORD *)(v8 + 8) = v12;
LABEL_39:
          *(_DWORD *)(v9 + 16) = v22;
          v10 = *(_DWORD *)(a3 + 20);
          if (!v10)
          {
            v10 = *(_DWORD *)(a2 + 20);
            goto LABEL_45;
          }
          if (*(_DWORD *)(a2 + 20) == v10)
            goto LABEL_45;
          if (dword_10008BA20)
          {
            v30 = ne_log_obj(v8);
            if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
              sub_100062604();
          }
        }
        else if (dword_10008BA20)
        {
          v23 = ne_log_obj(v8);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
            sub_1000625A4();
        }
      }
      else if (dword_10008BA20)
      {
        v13 = ne_log_obj(v8);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
          sub_100062544();
      }
      goto LABEL_141;
    case 3:
      v14 = *(_QWORD *)(a2 + 8);
      v15 = *(_QWORD *)(a3 + 8);
      if (v14 <= v15)
      {
        *(_QWORD *)(v8 + 8) = v14;
      }
      else
      {
        *(_QWORD *)(v8 + 8) = v15;
        *(_DWORD *)(v8 + 24) |= 1u;
        if (dword_10008BA20)
        {
          v16 = ne_log_obj(v8);
          v8 = os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT);
          if ((_DWORD)v8)
          {
            v17 = *(_QWORD *)(a3 + 8);
            v18 = *(_QWORD *)(a2 + 8);
            *(_DWORD *)buf = 67109376;
            *(_DWORD *)v80 = v17;
            *(_WORD *)&v80[4] = 1024;
            *(_DWORD *)&v80[6] = v18;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "use own lifetime: my:%d peer:%d\n", buf, 0xEu);
          }
        }
      }
      v24 = *(_DWORD *)(a3 + 16);
      if (*(_DWORD *)(a2 + 16) > v24)
      {
        *(_DWORD *)(v9 + 16) = v24;
        *(_DWORD *)(v9 + 24) |= 1u;
        if (dword_10008BA20)
        {
          v25 = ne_log_obj(v8);
          v8 = os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT);
          if ((_DWORD)v8)
          {
            v26 = *(_DWORD *)(a3 + 16);
            v27 = *(_DWORD *)(a2 + 16);
            *(_DWORD *)buf = 67109376;
            *(_DWORD *)v80 = v26;
            *(_WORD *)&v80[4] = 1024;
            *(_DWORD *)&v80[6] = v27;
            _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "use own lifebyte: my:%d peer:%d\n", buf, 0xEu);
          }
        }
      }
      v22 = *(_DWORD *)(a2 + 16);
      goto LABEL_39;
    case 4:
      v19 = *(_QWORD *)(a2 + 8);
      if (v19 != *(_QWORD *)(a3 + 8))
      {
        if (dword_10008BA20)
        {
          v28 = ne_log_obj(v8);
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
            sub_1000626C4();
        }
        goto LABEL_141;
      }
      v20 = *(_DWORD *)(a2 + 16);
      if (v20 != *(_DWORD *)(a3 + 16))
      {
        if (dword_10008BA20)
        {
          v29 = ne_log_obj(v8);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
            sub_100062664();
        }
        goto LABEL_141;
      }
      v10 = *(_DWORD *)(a2 + 20);
      if (v10 != *(_DWORD *)(a3 + 20))
      {
        if (dword_10008BA20)
        {
          v69 = ne_log_obj(v8);
          if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
            sub_100062604();
        }
        goto LABEL_141;
      }
      *(_QWORD *)(v8 + 8) = v19;
      *(_DWORD *)(v8 + 16) = v20;
LABEL_45:
      *(_DWORD *)(v9 + 20) = v10;
      i = *(int **)(a2 + 32);
      if (i)
      {
        v32 = 0;
        v33 = *(_QWORD *)(a2 + 32);
        do
        {
          ++v32;
          v33 = *(_QWORD *)(v33 + 72);
        }
        while (v33);
      }
      else
      {
        v32 = 0;
      }
      v34 = *(_QWORD *)(a3 + 32);
      if (v34)
      {
        v35 = 0;
        v36 = *(_QWORD *)(a3 + 32);
        do
        {
          ++v35;
          v36 = *(_QWORD *)(v36 + 72);
        }
        while (v36);
      }
      else
      {
        v35 = 0;
      }
      if (v32 != v35)
        goto LABEL_141;
      v37 = v78;
      if (!a4)
        goto LABEL_63;
LABEL_57:
      if (a4 != 1)
      {
        while (1)
        {
LABEL_68:
          v38 = i != 0;
          v39 = v34 != 0;
          if (!i || !v34)
            goto LABEL_129;
          if (*i != *(_DWORD *)v34)
          {
            if (dword_10008BA20)
            {
              v70 = ne_log_obj(v8);
              if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR))
                sub_1000624C0((int *)v34, i);
            }
            goto LABEL_141;
          }
          v40 = *((_QWORD *)i + 1);
          v41 = *(_QWORD *)(v34 + 8);
          if (v40 != v41)
          {
            if (*i != 4)
              goto LABEL_153;
            if (v40 == 2 && v41 == 4)
            {
              if (!dword_10008BA20)
                goto LABEL_83;
LABEL_80:
              v42 = ne_log_obj(v8);
              v8 = os_log_type_enabled(v42, OS_LOG_TYPE_ERROR);
              if ((_DWORD)v8)
                sub_10006242C(&v77, v37, v42);
              goto LABEL_83;
            }
            if (v41 != 2)
              goto LABEL_153;
            if (v40 == 4 && dword_10008BA20)
              goto LABEL_80;
            if (v40 != 4)
            {
LABEL_153:
              if (dword_10008BA20)
              {
                v72 = ne_log_obj(v8);
                if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
                  sub_100062460();
              }
              goto LABEL_141;
            }
          }
LABEL_83:
          if ((*(_BYTE *)(a1 + 96) & 6) == 0)
            goto LABEL_108;
          v43 = sub_10003F6F0(*(_DWORD *)(v34 + 16));
          if ((_DWORD)v43)
          {
            v44 = *(_DWORD *)(v34 + 16);
            v45 = 1;
            if (v44 > 61442)
            {
              if (v44 == 61443)
                goto LABEL_92;
              if (v44 == 61444)
                goto LABEL_91;
            }
            else
            {
              if (v44 != 3)
              {
                if (v44 != 4)
                  goto LABEL_93;
LABEL_91:
                v45 = 2;
              }
LABEL_92:
              *(_DWORD *)(v34 + 16) = v45;
              *(_DWORD *)(v34 + 20) = 1;
            }
LABEL_93:
            if (dword_10008BA20)
            {
              v46 = ne_log_obj(v43);
              if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
              {
                v75 = v37;
                v47 = sub_10003E0A4(v44);
                v48 = sub_10003E0A4(*(_DWORD *)(v34 + 16));
                v49 = *(_DWORD *)(v34 + 16);
                *(_DWORD *)buf = 136315906;
                *(_QWORD *)v80 = v47;
                v37 = v75;
                *(_WORD *)&v80[8] = 1024;
                v81 = v44;
                v82 = 2080;
                v83 = v48;
                v84 = 1024;
                v85 = v49;
                _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "Adjusting my encmode %s(%d)->%s(%d)\n", buf, 0x22u);
              }
            }
          }
          v8 = sub_10003F6F0(i[4]);
          if (!(_DWORD)v8)
            goto LABEL_108;
          v50 = i[4];
          v51 = 1;
          if (v50 <= 61442)
          {
            if (v50 != 3)
            {
              if (v50 != 4)
                goto LABEL_105;
LABEL_103:
              v51 = 2;
            }
LABEL_104:
            i[4] = v51;
            i[5] = 1;
            goto LABEL_105;
          }
          if (v50 == 61443)
            goto LABEL_104;
          if (v50 == 61444)
            goto LABEL_103;
LABEL_105:
          if (dword_10008BA20)
          {
            v52 = ne_log_obj(v8);
            v8 = os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT);
            if ((_DWORD)v8)
            {
              v76 = v37;
              v53 = sub_10003E0A4(v50);
              v54 = sub_10003E0A4(i[4]);
              v55 = i[4];
              *(_DWORD *)buf = 136315906;
              *(_QWORD *)v80 = v53;
              v37 = v76;
              *(_WORD *)&v80[8] = 1024;
              v81 = v50;
              v82 = 2080;
              v83 = v54;
              v84 = 1024;
              v85 = v55;
              _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "Adjusting peer's encmode %s(%d)->%s(%d)\n", buf, 0x22u);
            }
          }
LABEL_108:
          if (i[4] != *(_DWORD *)(v34 + 16))
          {
            if (dword_10008BA20)
            {
              v71 = ne_log_obj(v8);
              if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
                sub_1000623A8((int *)(v34 + 16), i + 4);
            }
            goto LABEL_141;
          }
          v56 = *((_QWORD *)i + 8);
          if (!v56)
            goto LABEL_141;
          while (1)
          {
            v57 = *(_QWORD *)(v34 + 64);
            if (v57)
              break;
LABEL_113:
            v56 = *(_QWORD *)(v56 + 16);
            if (!v56)
              goto LABEL_141;
          }
          while (sub_100035F84(*i, (unsigned int *)v56, (unsigned int *)v57))
          {
            v57 = *(_QWORD *)(v57 + 16);
            if (!v57)
              goto LABEL_113;
          }
          v58 = (uint64_t *)malloc_type_calloc(1uLL, 0x50uLL, 0x1020040BE967AE7uLL);
          if (!v58)
          {
            if (dword_10008BA20)
            {
              v73 = ne_log_obj(0);
              if (os_log_type_enabled(v73, OS_LOG_TYPE_ERROR))
                sub_100062350();
            }
            goto LABEL_141;
          }
          v59 = v58;
          *(_DWORD *)v58 = *i;
          v58[1] = *((_QWORD *)i + 1);
          *((_DWORD *)v58 + 4) = i[4];
          *((_DWORD *)v58 + 6) = *(_DWORD *)(v34 + 24);
          *((_DWORD *)v58 + 7) = i[6];
          v58[6] = *(_QWORD *)(v34 + 48);
          *((_DWORD *)v58 + 5) = *(_DWORD *)(v34 + 20) | i[5];
          v8 = (uint64_t)malloc_type_calloc(1uLL, 0x18uLL, 0x10200403ED2C137uLL);
          if (!v8)
          {
            if (dword_10008BA20)
            {
              v74 = ne_log_obj(0);
              if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
                sub_10006237C();
            }
            free(v59);
            goto LABEL_141;
          }
          *(_OWORD *)v8 = *(_OWORD *)v56;
          v60 = v59 + 8;
          v61 = v59[8];
          while (v61)
          {
            v62 = v61;
            v61 = *(_QWORD *)(v61 + 16);
            if (!v61)
            {
              v60 = (uint64_t *)(v62 + 16);
              break;
            }
          }
          *v60 = v8;
          v63 = *(_QWORD *)(v9 + 32);
          while (v63)
          {
            v64 = v63;
            v63 = *(_QWORD *)(v63 + 72);
            if (!v63)
            {
              v65 = (uint64_t **)(v64 + 72);
              goto LABEL_126;
            }
          }
          v65 = (uint64_t **)(v9 + 32);
LABEL_126:
          *v65 = v59;
          v34 = *(_QWORD *)(v34 + 72);
          i = (int *)*((_QWORD *)i + 9);
          if (a4)
            goto LABEL_57;
LABEL_63:
          if (!i)
            goto LABEL_128;
          v34 = *(_QWORD *)(a3 + 32);
          if (!v34)
            goto LABEL_128;
          while (*(_DWORD *)v34 != *i)
          {
            v34 = *(_QWORD *)(v34 + 72);
            if (!v34)
              goto LABEL_128;
          }
        }
      }
      if (v34)
      {
        for (i = *(int **)(a2 + 32); i; i = (int *)*((_QWORD *)i + 9))
        {
          if (*i == *(_DWORD *)v34)
            goto LABEL_68;
        }
      }
LABEL_128:
      v38 = i != 0;
      v39 = v34 != 0;
LABEL_129:
      if (v38)
        v66 = v34;
      else
        v66 = 0;
      if (v39)
        v67 = i;
      else
        v67 = 0;
      if (a4 != 1)
        v67 = i;
      if (a4)
        v66 = v34;
      else
        v67 = i;
      if ((unint64_t)v67 | v66)
      {
LABEL_141:
        sub_100036158((uint64_t *)v9);
        return 0;
      }
      return v9;
    default:
      if (dword_10008BA20)
      {
        v21 = ne_log_obj(v8);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          sub_100062324();
      }
      goto LABEL_141;
  }
}

uint64_t sub_100035F84(uint64_t a1, unsigned int *a2, unsigned int *a3)
{
  unsigned int *v5;
  NSObject *v7;
  _BOOL4 v8;
  uint64_t result;
  unsigned int v10;
  unsigned int v11;
  int v12;
  NSObject *v13;
  char *v14;
  char *v15;
  NSObject *v16;
  int v17;
  _BYTE v18[10];
  char *v19;

  if (a2[1] != a3[1])
  {
    if (dword_10008BA20)
    {
      v12 = a1;
      v13 = ne_log_obj(a1);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        v14 = sub_10003DF24(v12, a3[1]);
        v15 = sub_10003DF24(v12, a2[1]);
        v17 = 136315394;
        *(_QWORD *)v18 = v14;
        *(_WORD *)&v18[8] = 2080;
        v19 = v15;
        _os_log_debug_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "trns_id mismatched: my:%s peer:%s\n", (uint8_t *)&v17, 0x16u);
      }
    }
    return 1;
  }
  v5 = a2 + 3;
  if (a2[3] != a3[3])
  {
    if (dword_10008BA20)
    {
      v16 = ne_log_obj(a1);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        sub_100062724(a3 + 3, v5);
    }
    return 1;
  }
  if ((int)a2[2] > (int)a3[2] && dword_10008BA20 != 0)
  {
    v7 = ne_log_obj(a1);
    v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v8)
      return result;
    v10 = a3[2];
    v11 = a2[2];
    v17 = 67109376;
    *(_DWORD *)v18 = v10;
    *(_WORD *)&v18[4] = 1024;
    *(_DWORD *)&v18[6] = v11;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "less key length proposed, mine:%d peer:%d.  Use initiaotr's one.\n", (uint8_t *)&v17, 0xEu);
  }
  return 0;
}

void sub_100036158(uint64_t *a1)
{
  uint64_t *v1;
  uint64_t *v2;

  if (a1)
  {
    v1 = a1;
    do
    {
      v2 = (uint64_t *)v1[5];
      sub_100036A9C(v1[4]);
      free(v1);
      v1 = v2;
    }
    while (v2);
  }
}

uint64_t sub_100036190(uint64_t a1, uint64_t a2)
{
  NSObject *v5;
  int v6;
  int v7;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  int v13;
  int v14;
  int v16;
  int v17;
  __int16 v18;
  int v19;

  if (*(_DWORD *)(a1 + 20) != *(_DWORD *)(a2 + 20) && dword_10008BA20 != 0)
  {
    v5 = ne_log_obj();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(a1 + 20);
      v7 = *(_DWORD *)(a2 + 20);
      v16 = 67109376;
      v17 = v6;
      v18 = 1024;
      v19 = v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "pfs_group mismatch. mine:%d peer:%d\n", (uint8_t *)&v16, 0xEu);
    }
  }
  if (*(_QWORD *)(a1 + 8) > *(_QWORD *)(a2 + 8) && dword_10008BA20 != 0)
  {
    v9 = ne_log_obj();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      v10 = *(_QWORD *)(a1 + 8);
      v11 = *(_QWORD *)(a2 + 8);
      v16 = 67109376;
      v17 = v10;
      v18 = 1024;
      v19 = v11;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "less lifetime proposed. mine:%d peer:%d\n", (uint8_t *)&v16, 0xEu);
    }
  }
  if (*(_DWORD *)(a1 + 16) > *(_DWORD *)(a2 + 16))
  {
    if (dword_10008BA20)
    {
      v12 = ne_log_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        v13 = *(_DWORD *)(a1 + 16);
        v14 = *(_DWORD *)(a2 + 16);
        v16 = 67109376;
        v17 = v13;
        v18 = 1024;
        v19 = v14;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "less lifebyte proposed. mine:%d peer:%d\n", (uint8_t *)&v16, 0xEu);
      }
    }
  }
  return 0;
}

uint64_t sub_100036354(_DWORD *a1, _QWORD *a2, int a3)
{
  uint64_t v4;
  int v5;
  unsigned int *v6;
  uint64_t *v7;
  int v8;
  _DWORD *v9;
  _DWORD *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  int *v14;
  uint64_t *v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  NSObject *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  NSObject *v37;
  NSObject *v38;
  NSObject *v39;
  NSObject *v40;
  NSObject *v41;
  NSObject *v42;
  NSObject *v43;
  _QWORD *v44;
  _QWORD *v45;

  v4 = (uint64_t)a1;
  v5 = *a1;
  if (*a1 == 4)
  {
    v14 = (int *)a2[8];
    if (!v14)
    {
      if (dword_10008BA20)
      {
        v39 = ne_log_obj(a1);
        if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
          sub_100062894();
      }
      goto LABEL_66;
    }
    v15 = (uint64_t *)(a1 + 16);
    v16 = 1;
    while (1)
    {
      a1 = malloc_type_calloc(1uLL, 0x18uLL, 0x10200403ED2C137uLL);
      if (!a1)
        break;
      v17 = *v14;
      *a1 = v16;
      a1[1] = v17;
      a1[3] = 254;
      v18 = *v15;
      while (v18)
      {
        v19 = v18;
        v18 = *(_QWORD *)(v18 + 16);
        if (!v18)
        {
          v20 = (_QWORD *)(v19 + 16);
          goto LABEL_24;
        }
      }
      v20 = (_QWORD *)(v4 + 64);
LABEL_24:
      *v20 = a1;
      v14 = (int *)*((_QWORD *)v14 + 1);
      ++v16;
      if (!v14)
        goto LABEL_40;
    }
    if (!dword_10008BA20)
      goto LABEL_66;
    v41 = ne_log_obj(0);
    if (!os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
      goto LABEL_66;
LABEL_65:
    sub_10006237C();
    goto LABEL_66;
  }
  if (v5 != 3)
  {
    if (v5 != 2)
    {
      if (dword_10008BA20)
      {
        v30 = ne_log_obj(a1);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
          sub_1000627A8(v4, v30, v31, v32, v33, v34, v35, v36);
      }
      goto LABEL_66;
    }
    v6 = (unsigned int *)a2[7];
    if (!v6)
    {
      if (dword_10008BA20)
      {
        v38 = ne_log_obj(a1);
        if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
          sub_100062810();
      }
      goto LABEL_66;
    }
    v7 = (uint64_t *)(a1 + 16);
    v8 = 1;
    while (1)
    {
      if (*v6 != 254)
      {
        v9 = malloc_type_calloc(1uLL, 0x18uLL, 0x10200403ED2C137uLL);
        if (!v9)
        {
          if (dword_10008BA20)
          {
            v43 = ne_log_obj(0);
            if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
              goto LABEL_65;
          }
LABEL_66:
          v44 = *(_QWORD **)(v4 + 64);
          if (v44)
          {
            do
            {
              v45 = (_QWORD *)v44[2];
              free(v44);
              v44 = v45;
            }
            while (v45);
          }
          return 0xFFFFFFFFLL;
        }
        v10 = v9;
        *v9 = v8;
        a1 = (_DWORD *)sub_100011BCC(*v6);
        v10[1] = (_DWORD)a1;
        v10[3] = *v6;
        v11 = *v7;
        while (v11)
        {
          v12 = v11;
          v11 = *(_QWORD *)(v11 + 16);
          if (!v11)
          {
            v13 = (_QWORD *)(v12 + 16);
            goto LABEL_13;
          }
        }
        v13 = (_QWORD *)(v4 + 64);
LABEL_13:
        *v13 = v10;
        ++v8;
      }
      v6 = (unsigned int *)*((_QWORD *)v6 + 1);
      if (!v6)
        goto LABEL_40;
    }
  }
  v21 = (_QWORD *)a2[6];
  if (!v21)
  {
    if (dword_10008BA20)
    {
      v40 = ne_log_obj(a1);
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
        sub_100062868();
    }
    goto LABEL_66;
  }
  if (a3 == 16)
  {
    v22 = (uint64_t *)(a1 + 16);
    v23 = 1;
    while (1)
    {
      v24 = a2[7];
      if (v24)
        break;
      v25 = v23;
LABEL_39:
      v21 = (_QWORD *)v21[1];
      v23 = v25;
      if (!v21)
        goto LABEL_40;
    }
    while (1)
    {
      a1 = malloc_type_calloc(1uLL, 0x18uLL, 0x10200403ED2C137uLL);
      if (!a1)
        break;
      v25 = (v23 + 1);
      *a1 = v23;
      *(_QWORD *)(a1 + 1) = *v21;
      a1[3] = *(_DWORD *)v24;
      v26 = *v22;
      while (v26)
      {
        v27 = v26;
        v26 = *(_QWORD *)(v26 + 16);
        if (!v26)
        {
          v28 = (_QWORD *)(v27 + 16);
          goto LABEL_36;
        }
      }
      v28 = (_QWORD *)(v4 + 64);
LABEL_36:
      *v28 = a1;
      v24 = *(_QWORD *)(v24 + 8);
      LODWORD(v23) = v23 + 1;
      if (!v24)
        goto LABEL_39;
    }
    if (!dword_10008BA20)
      goto LABEL_66;
    v42 = ne_log_obj(0);
    if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
      goto LABEL_66;
    goto LABEL_65;
  }
LABEL_40:
  if (!*(_QWORD *)(v4 + 64))
  {
    if (dword_10008BA20)
    {
      v37 = ne_log_obj(a1);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
        sub_10006283C();
    }
    return 0xFFFFFFFFLL;
  }
  return 0;
}

_QWORD *sub_1000366F4(_QWORD *result)
{
  _QWORD *v1;

  if (result)
  {
    do
    {
      v1 = (_QWORD *)result[2];
      free(result);
      result = v1;
    }
    while (v1);
  }
  return result;
}

uint64_t *sub_100036720(uint64_t *a1)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  NSObject *v10;
  _DWORD *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  int v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v25;
  NSObject *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  char *v34;
  int v35;
  int v36;
  uint8_t buf[4];
  int v38;
  __int16 v39;
  char *v40;
  __int16 v41;
  int v42;
  __int16 v43;
  int v44;
  __int16 v45;
  int v46;
  __int16 v47;
  char *v48;

  if (a1)
  {
    v1 = a1;
    v2 = (uint64_t *)malloc_type_calloc(1uLL, 0x30uLL, 0x10200401AD049D5uLL);
    if (v2)
    {
      v3 = v2;
      *(_DWORD *)v2 = *(unsigned __int8 *)(*v1 + 4);
      v4 = v2 + 4;
      while (1)
      {
        v5 = malloc_type_calloc(1uLL, 0x50uLL, 0x1020040BE967AE7uLL);
        if (!v5)
        {
          if (dword_10008BA20)
          {
            v25 = ne_log_obj(0);
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
              sub_100062350();
          }
          goto LABEL_34;
        }
        v6 = v5;
        v7 = *(unsigned __int8 *)(*v1 + 6);
        if (v7 >= 5)
          break;
        *(_DWORD *)v5 = *(unsigned __int8 *)(*v1 + 5);
        v5[1] = v7;
        *((_DWORD *)v5 + 6) = 0;
        v8 = (uint64_t)memcpy((char *)v5 - *(unsigned __int8 *)(*v1 + 6) + 28, (const void *)(*v1 + 8), *(unsigned __int8 *)(*v1 + 6));
        v6[6] = 0;
        v9 = v1;
        do
        {
          if (dword_10008BA20)
          {
            v10 = ne_log_obj(v8);
            if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
            {
              v36 = *(unsigned __int8 *)(*v9 + 4);
              v34 = sub_10003DCFC(*(unsigned __int8 *)(*v9 + 5));
              v16 = v9[1];
              v17 = *(unsigned __int8 *)(*v9 + 6);
              v33 = *(unsigned __int8 *)(*v9 + 7);
              v35 = *(unsigned __int8 *)(v16 + 4);
              v18 = sub_10003DF24(*(unsigned __int8 *)(*v9 + 5), *(unsigned __int8 *)(v16 + 5));
              *(_DWORD *)buf = 67110402;
              v38 = v36;
              v39 = 2080;
              v40 = v34;
              v41 = 1024;
              v42 = v17;
              v43 = 1024;
              v44 = v33;
              v45 = 1024;
              v46 = v35;
              v47 = 2080;
              v48 = v18;
              _os_log_debug_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "prop#=%d prot-id=%s spi-size=%d #trns=%d trns#=%d trns-id=%s\n", buf, 0x2Eu);
            }
          }
          v11 = malloc_type_calloc(1uLL, 0x18uLL, 0x10200403ED2C137uLL);
          if (!v11)
          {
            if (dword_10008BA20)
            {
              v23 = ne_log_obj(0);
              if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
                sub_10006237C();
            }
            goto LABEL_33;
          }
          v12 = v11;
          v8 = sub_100011444(v9[1], (uint64_t)v3, v6, v11);
          if ((v8 & 0x80000000) != 0)
          {
            sub_100036158(v3);
            free(v12);
            free(v6);
            return 0;
          }
          v13 = v6[8];
          while (v13)
          {
            v14 = v13;
            v13 = *(_QWORD *)(v13 + 16);
            if (!v13)
            {
              v15 = (_QWORD *)(v14 + 16);
              goto LABEL_17;
            }
          }
          v15 = v6 + 8;
LABEL_17:
          *v15 = v12;
          v9 = (uint64_t *)v9[3];
        }
        while (v9);
        if (!*((_DWORD *)v6 + 4))
          *((_DWORD *)v6 + 4) = 2;
        v19 = *v4;
        while (v19)
        {
          v20 = v19;
          v19 = *(_QWORD *)(v19 + 72);
          if (!v19)
          {
            v21 = (_QWORD *)(v20 + 72);
            goto LABEL_25;
          }
        }
        v21 = v4;
LABEL_25:
        *v21 = v6;
        v1 = (uint64_t *)v1[2];
        if (!v1)
          return v3;
      }
      if (dword_10008BA20)
      {
        v26 = ne_log_obj(v5);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
          sub_1000628C0((uint64_t)v1, v26, v27, v28, v29, v30, v31, v32);
      }
LABEL_33:
      free(v6);
LABEL_34:
      sub_100036158(v3);
    }
    else if (dword_10008BA20)
    {
      v22 = ne_log_obj(0);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        sub_1000622F8();
    }
  }
  return 0;
}

void sub_100036A9C(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;

  if (a1)
  {
    v1 = a1;
    do
    {
      v2 = *(_QWORD **)(v1 + 64);
      v3 = *(_QWORD *)(v1 + 72);
      if (v2)
      {
        do
        {
          v4 = (_QWORD *)v2[2];
          free(v2);
          v2 = v4;
        }
        while (v4);
      }
      sub_10003F318(*(_QWORD **)(v1 + 32));
      sub_10003F318(*(_QWORD **)(v1 + 40));
      free((void *)v1);
      v1 = v3;
    }
    while (v3);
  }
}

void sub_100036AFC(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t i;
  NSObject *v5;
  NSObject *v6;
  NSObject *v7;
  uint8_t *v8;
  NSObject *v9;
  os_log_type_t v10;
  NSObject *v11;
  NSObject *v12;
  __int16 v13;
  __int16 v14;

  if (a2)
  {
    v3 = a2;
    do
    {
      for (i = *(_QWORD *)(v3 + 32); i; i = *(_QWORD *)(i + 72))
        sub_100036C90(a1, (int *)i);
      v3 = *(_QWORD *)(v3 + 40);
    }
    while (v3);
    return;
  }
  if (!dword_10008BA20)
    return;
  if ((int)a1 <= 2)
  {
    v5 = ne_log_obj(a1);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_FAULT))
      sub_10006292C();
    return;
  }
  if ((_DWORD)a1 == 3)
  {
    v6 = ne_log_obj(a1);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      sub_100062964();
    return;
  }
  if (a1 <= 5)
  {
    v7 = ne_log_obj(a1);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      return;
    v14 = 0;
    v8 = (uint8_t *)&v14;
    v9 = v7;
    v10 = OS_LOG_TYPE_DEFAULT;
    goto LABEL_20;
  }
  v11 = ne_log_obj(a1);
  v12 = v11;
  if ((_DWORD)a1 == 6)
  {
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
      return;
    v13 = 0;
    v8 = (uint8_t *)&v13;
    v9 = v12;
    v10 = OS_LOG_TYPE_INFO;
LABEL_20:
    _os_log_impl((void *)&_mh_execute_header, v9, v10, "(null)", v8, 2u);
    return;
  }
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    sub_100062990();
}

void sub_100036C54(uint64_t a1, uint64_t a2)
{
  uint64_t i;

  if (a2)
  {
    for (i = *(_QWORD *)(a2 + 32); i; i = *(_QWORD *)(i + 72))
      sub_100036C90(a1, (int *)i);
  }
}

void sub_100036C90(uint64_t a1, int *a2)
{
  NSObject *v4;
  NSObject *v5;
  NSObject *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  unsigned int v12;
  unsigned int v13;
  NSObject *v14;
  os_log_type_t v15;
  NSObject *v16;
  NSObject *v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t i;
  int v26;
  char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  __int16 v34;
  char *v35;
  __int16 v36;
  unsigned int v37;
  __int16 v38;
  unsigned int v39;

  if (!a2)
    return;
  if (dword_10008BA20)
  {
    if ((int)a1 <= 2)
    {
      v4 = ne_log_obj(a1);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
        sub_1000629BC();
      goto LABEL_18;
    }
    if ((_DWORD)a1 == 3)
    {
      v5 = ne_log_obj(a1);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_100062A3C();
      goto LABEL_18;
    }
    if (a1 <= 5)
    {
      v6 = ne_log_obj(a1);
      if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        goto LABEL_18;
      v7 = sub_10003DCFC(*a2);
      v8 = *((_QWORD *)a2 + 1);
      v9 = bswap32(a2[6]);
      v10 = bswap32(a2[7]);
      v11 = sub_10003E18C(4, a2[4]);
      v13 = a2[12];
      v12 = a2[13];
      v26 = 136316674;
      v27 = v7;
      v28 = 1024;
      v29 = v8;
      v30 = 2048;
      v31 = v9;
      v32 = 2048;
      v33 = v10;
      v34 = 2080;
      v35 = v11;
      v36 = 1024;
      v37 = v12;
      v38 = 1024;
      v39 = v13;
      v14 = v6;
      v15 = OS_LOG_TYPE_DEFAULT;
      goto LABEL_15;
    }
    v16 = ne_log_obj(a1);
    v17 = v16;
    if ((_DWORD)a1 != 6)
    {
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        sub_100062ABC();
      goto LABEL_18;
    }
    if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
    {
      v18 = sub_10003DCFC(*a2);
      v19 = *((_QWORD *)a2 + 1);
      v20 = bswap32(a2[6]);
      v21 = bswap32(a2[7]);
      v22 = sub_10003E18C(4, a2[4]);
      v24 = a2[12];
      v23 = a2[13];
      v26 = 136316674;
      v27 = v18;
      v28 = 1024;
      v29 = v19;
      v30 = 2048;
      v31 = v20;
      v32 = 2048;
      v33 = v21;
      v34 = 2080;
      v35 = v22;
      v36 = 1024;
      v37 = v23;
      v38 = 1024;
      v39 = v24;
      v14 = v17;
      v15 = OS_LOG_TYPE_INFO;
LABEL_15:
      _os_log_impl((void *)&_mh_execute_header, v14, v15, " (proto_id=%s spisize=%d spi=%08lx spi_p=%08lx encmode=%s reqid=%d:%d)\n", (uint8_t *)&v26, 0x3Cu);
    }
  }
LABEL_18:
  for (i = *((_QWORD *)a2 + 8); i; i = *(_QWORD *)(i + 16))
    sub_100036F14(a1, *a2, (unsigned int *)i);
}

void sub_100036F14(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  int v5;
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  NSObject *v10;
  NSObject *v11;
  NSObject *v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  NSObject *v20;
  char *v21;
  const char *v22;
  NSObject *v23;
  os_log_type_t v24;
  NSObject *v25;
  char *v26;
  unsigned int v27;
  char *v28;
  NSObject *v29;
  char *v30;
  char *v31;
  NSObject *v32;
  NSObject *v33;
  NSObject *v34;
  char *v35;
  uint32_t v36;
  NSObject *v37;
  NSObject *v38;
  char *v39;
  unsigned int v40;
  char *v41;
  NSObject *v42;
  NSObject *v43;
  char *v44;
  char *v45;
  NSObject *v46;
  NSObject *v47;
  int v48;
  char *v49;
  __int16 v50;
  _QWORD v51[3];

  if (!a3)
    return;
  v5 = a1;
  if ((_DWORD)a2 == 4)
  {
    if (!dword_10008BA20)
      return;
    if ((int)a1 <= 2)
    {
      v7 = ne_log_obj(a1);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
        sub_100062F70((uint64_t)a3);
      return;
    }
    if ((_DWORD)a1 == 3)
    {
      v10 = ne_log_obj(a1);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_100062FE4((uint64_t)a3);
      return;
    }
    if (a1 > 5)
    {
      v33 = ne_log_obj(a1);
      v34 = v33;
      if (v5 != 6)
      {
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
          sub_100063058((uint64_t)a3);
        return;
      }
      if (!os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
        return;
      v35 = sub_10003DF24(4, a3[1]);
      v48 = 136315138;
      v49 = v35;
      v22 = "  (trns_id=%s)\n";
      v23 = v34;
      v24 = OS_LOG_TYPE_INFO;
    }
    else
    {
      v20 = ne_log_obj(a1);
      if (!os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        return;
      v21 = sub_10003DF24(4, a3[1]);
      v48 = 136315138;
      v49 = v21;
      v22 = "  (trns_id=%s)\n";
      v23 = v20;
      v24 = OS_LOG_TYPE_DEFAULT;
    }
    v36 = 12;
LABEL_61:
    _os_log_impl((void *)&_mh_execute_header, v23, v24, v22, (uint8_t *)&v48, v36);
    return;
  }
  if ((_DWORD)a2 == 3)
  {
    if (!dword_10008BA20)
      return;
    if ((int)a1 <= 2)
    {
      v8 = ne_log_obj(a1);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
        sub_100062DF0();
      return;
    }
    if ((_DWORD)a1 == 3)
    {
      v11 = ne_log_obj(a1);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        sub_100062E70();
      return;
    }
    if (a1 > 5)
    {
      v37 = ne_log_obj(a1);
      v38 = v37;
      if (v5 != 6)
      {
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
          sub_100062EF0();
        return;
      }
      if (!os_log_type_enabled(v37, OS_LOG_TYPE_INFO))
        return;
      v39 = sub_10003DF24(3, a3[1]);
      v40 = a3[2];
      v41 = sub_10003E18C(5, a3[3]);
      v48 = 136315650;
      v49 = v39;
      v50 = 1024;
      LODWORD(v51[0]) = v40;
      WORD2(v51[0]) = 2080;
      *(_QWORD *)((char *)v51 + 6) = v41;
      v22 = "  (trns_id=%s encklen=%d authtype=%s)\n";
      v23 = v38;
      v24 = OS_LOG_TYPE_INFO;
    }
    else
    {
      v25 = ne_log_obj(a1);
      if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        return;
      v26 = sub_10003DF24(3, a3[1]);
      v27 = a3[2];
      v28 = sub_10003E18C(5, a3[3]);
      v48 = 136315650;
      v49 = v26;
      v50 = 1024;
      LODWORD(v51[0]) = v27;
      WORD2(v51[0]) = 2080;
      *(_QWORD *)((char *)v51 + 6) = v28;
      v22 = "  (trns_id=%s encklen=%d authtype=%s)\n";
      v23 = v25;
      v24 = OS_LOG_TYPE_DEFAULT;
    }
    v36 = 28;
    goto LABEL_61;
  }
  if ((_DWORD)a2 != 2)
  {
    if (!dword_10008BA20)
      return;
    if ((int)a1 <= 2)
    {
      v9 = ne_log_obj(a1);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT))
        sub_100062B3C(a2, v9);
      return;
    }
    if ((_DWORD)a1 == 3)
    {
      v13 = ne_log_obj(a1);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        sub_100062BAC(a2, v13, v14, v15, v16, v17, v18, v19);
      return;
    }
    if (a1 > 5)
    {
      v46 = ne_log_obj(a1);
      v47 = v46;
      if (v5 != 6)
      {
        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
          sub_100062C10(a2, v47);
        return;
      }
      if (!os_log_type_enabled(v46, OS_LOG_TYPE_INFO))
        return;
      v48 = 67109120;
      LODWORD(v49) = a2;
      v22 = "(unknown proto_id %d)\n";
      v23 = v47;
      v24 = OS_LOG_TYPE_INFO;
    }
    else
    {
      v32 = ne_log_obj(a1);
      if (!os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
        return;
      v48 = 67109120;
      LODWORD(v49) = a2;
      v22 = "(unknown proto_id %d)\n";
      v23 = v32;
      v24 = OS_LOG_TYPE_DEFAULT;
    }
    v36 = 8;
    goto LABEL_61;
  }
  if (!dword_10008BA20)
    return;
  if ((int)a1 <= 2)
  {
    v6 = ne_log_obj(a1);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      sub_100062C80();
    return;
  }
  if ((_DWORD)a1 == 3)
  {
    v12 = ne_log_obj(a1);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      sub_100062D00();
    return;
  }
  if (a1 <= 5)
  {
    v29 = ne_log_obj(a1);
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      return;
    v30 = sub_10003DF24(2, a3[1]);
    v31 = sub_10003E18C(5, a3[3]);
    v48 = 136315394;
    v49 = v30;
    v50 = 2080;
    v51[0] = v31;
    v22 = "  (trns_id=%s authtype=%s)\n";
    v23 = v29;
    v24 = OS_LOG_TYPE_DEFAULT;
LABEL_56:
    v36 = 22;
    goto LABEL_61;
  }
  v42 = ne_log_obj(a1);
  v43 = v42;
  if (v5 == 6)
  {
    if (!os_log_type_enabled(v42, OS_LOG_TYPE_INFO))
      return;
    v44 = sub_10003DF24(2, a3[1]);
    v45 = sub_10003E18C(5, a3[3]);
    v48 = 136315394;
    v49 = v44;
    v50 = 2080;
    v51[0] = v45;
    v22 = "  (trns_id=%s authtype=%s)\n";
    v23 = v43;
    v24 = OS_LOG_TYPE_INFO;
    goto LABEL_56;
  }
  if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
    sub_100062D78();
}

void sub_1000374C8(uint64_t a1, uint64_t a2, int a3)
{
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  os_log_type_t v12;
  NSObject *v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  _QWORD *v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  uint64_t v26;
  _QWORD v27[3];

  memset(v27, 32, 20);
  if (a3 <= 19)
    *((_BYTE *)v27 + a3) = 0;
  if (dword_10008BA20)
  {
    if ((int)a1 <= 2)
    {
      v6 = ne_log_obj(a1);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
        sub_1000630CC();
      goto LABEL_19;
    }
    if ((_DWORD)a1 == 3)
    {
      v7 = ne_log_obj(a1);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_100063140();
      goto LABEL_19;
    }
    if (a1 <= 5)
    {
      v8 = ne_log_obj(a1);
      if (!os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        goto LABEL_19;
      v9 = *(_QWORD *)(a2 + 16);
      v10 = *(_QWORD *)(a2 + 24);
      v19 = 136315906;
      v20 = v27;
      v21 = 2048;
      v22 = a2;
      v23 = 2048;
      v24 = v9;
      v25 = 2048;
      v26 = v10;
      v11 = v8;
      v12 = OS_LOG_TYPE_DEFAULT;
LABEL_16:
      _os_log_impl((void *)&_mh_execute_header, v11, v12, "%s%p: next=%p tnext=%p\n", (uint8_t *)&v19, 0x2Au);
      goto LABEL_19;
    }
    v13 = ne_log_obj(a1);
    v14 = v13;
    if ((_DWORD)a1 == 6)
    {
      if (!os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
        goto LABEL_19;
      v15 = *(_QWORD *)(a2 + 16);
      v16 = *(_QWORD *)(a2 + 24);
      v19 = 136315906;
      v20 = v27;
      v21 = 2048;
      v22 = a2;
      v23 = 2048;
      v24 = v15;
      v25 = 2048;
      v26 = v16;
      v11 = v14;
      v12 = OS_LOG_TYPE_INFO;
      goto LABEL_16;
    }
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      sub_1000631B4();
  }
LABEL_19:
  v17 = *(_QWORD *)(a2 + 16);
  if (v17)
    sub_1000374C8(a1, v17, (a3 + 1));
  v18 = *(_QWORD *)(a2 + 24);
  if (v18)
    sub_1000374C8(a1, v18, (a3 + 1));
}

void sub_1000376E8(uint64_t a1, uint64_t a2)
{
  sub_1000374C8(a1, a2, 1);
}

uint64_t sub_1000376F0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t *v13;
  _QWORD *v14;
  _QWORD *v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t *v22;
  _BOOL4 v23;
  _BOOL4 v24;
  int v25;
  int v26;
  BOOL v27;
  NSObject *v29;
  uint64_t i;
  NSObject *v32;
  NSObject *v33;
  __int16 v34[8];

  v6 = 1;
  v7 = (uint64_t)malloc_type_calloc(1uLL, 0x30uLL, 0x10200401AD049D5uLL);
  if (!v7)
  {
    if (dword_10008BA20)
    {
      v12 = ne_log_obj(0);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        sub_1000622F8();
    }
    return 0xFFFFFFFFLL;
  }
  v8 = (uint64_t *)v7;
  *(_DWORD *)v7 = 1;
  v9 = *(_QWORD *)(a1 + 112);
  *(_QWORD *)(v7 + 8) = *(_QWORD *)(v9 + 24);
  *(_QWORD *)(v7 + 16) = *(_QWORD *)(v9 + 32);
  if (!*(_DWORD *)(qword_10008B848 + 312))
  {
    v10 = (uint64_t *)(a2 + 296);
    do
    {
      v10 = (uint64_t *)*v10;
      if (!v10)
      {
        v6 = 1;
        goto LABEL_13;
      }
    }
    while (*((_BYTE *)v10 + 266) != 2);
    v7 = sub_10002F128(2);
    v6 = v7;
    v11 = *(_QWORD *)(a1 + 256);
    if (v11 && (*(_BYTE *)(v11 + 96) & 6) != 0)
      v6 = v7 + *(unsigned __int16 *)(*(_QWORD *)(v11 + 88) + 12);
  }
LABEL_13:
  v13 = *(uint64_t **)(a2 + 296);
  if (v13)
  {
    while (1)
    {
      v14 = malloc_type_calloc(1uLL, 0x50uLL, 0x1020040BE967AE7uLL);
      if (!v14)
        break;
      v15 = v14;
      v16 = sub_10000F8C4(*((unsigned __int16 *)v13 + 132));
      *(_DWORD *)v15 = v16;
      if (v16 == 4)
        v17 = 2;
      else
        v17 = 4;
      v15[1] = v17;
      if (*(_DWORD *)(qword_10008B848 + 312))
      {
        v18 = sub_10002F128(*((unsigned __int8 *)v13 + 266));
        v6 = v18;
        *((_DWORD *)v15 + 4) = v18;
        v19 = *(_QWORD *)(a1 + 256);
        if (v19 && (*(_BYTE *)(v19 + 96) & 6) != 0)
          *((_DWORD *)v15 + 4) = v18 + *(unsigned __int16 *)(*(_QWORD *)(v19 + 88) + 12);
      }
      else
      {
        *((_DWORD *)v15 + 4) = v6;
      }
      v20 = *((_DWORD *)v13 + 67);
      if (*(_BYTE *)(a1 + 60))
        *((_DWORD *)v15 + 13) = v20;
      else
        *((_DWORD *)v15 + 12) = v20;
      v7 = sub_100036354(v15, *(_QWORD **)(a1 + 112), *(unsigned __int8 *)(a1 + 61));
      if ((v7 & 0x80000000) != 0)
      {
        if (dword_10008BA20)
        {
          v33 = ne_log_obj(v7);
          if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
            sub_100063228();
        }
        free(v15);
        goto LABEL_56;
      }
      v15[9] = v8[4];
      v8[4] = (uint64_t)v15;
      v13 = (uint64_t *)*v13;
      if (!v13)
        goto LABEL_28;
    }
    if (dword_10008BA20)
    {
      v32 = ne_log_obj(0);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
        sub_100062350();
    }
LABEL_56:
    sub_100036158(v8);
    return 0xFFFFFFFFLL;
  }
LABEL_28:
  if (a3)
  {
    v21 = v8[4];
    v22 = *(uint64_t **)(a3 + 296);
    v23 = v22 != 0;
    v24 = v21 != 0;
    if (v22 && v21)
    {
      v25 = *(unsigned __int8 *)(a1 + 60);
      do
      {
        v26 = *((_DWORD *)v22 + 67);
        if (v25)
          *(_DWORD *)(v21 + 48) = v26;
        else
          *(_DWORD *)(v21 + 52) = v26;
        v21 = *(_QWORD *)(v21 + 72);
        v22 = (uint64_t *)*v22;
        v23 = v22 != 0;
        v24 = v21 != 0;
        if (v22)
          v27 = v21 == 0;
        else
          v27 = 1;
      }
      while (!v27);
    }
    if ((v24 || v23) && dword_10008BA20 != 0)
    {
      v29 = ne_log_obj(v7);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        v34[0] = 0;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "There is a difference between the in/out bound policies in SPD.\n", (uint8_t *)v34, 2u);
      }
    }
  }
  *(_QWORD *)(a1 + 120) = v8;
  sub_10004B1D0(a1);
  for (i = v8[4]; i; i = *(_QWORD *)(i + 72))
    sub_100036C90(7, (int *)i);
  return 0;
}

uint64_t sub_100037A3C(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  BOOL v8;
  NSObject *v9;
  uint64_t v10;
  _DWORD *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t **v18;
  NSObject *v19;
  NSObject *v20;
  NSObject *v22;
  uint64_t *v23;
  uint64_t i;
  NSObject *v25;
  uint8_t v26;
  _BYTE v27[7];
  uint64_t *v28;

  v28 = 0;
  if (*(_BYTE *)(a1 + 61) != 16)
    return 0xFFFFFFFFLL;
  v2 = sub_10000AE28(*(unint64_t **)(a1 + 224), 1u);
  if (v2)
  {
    v3 = 0;
    v4 = 0;
    while (1)
    {
      v5 = v2[v3];
      if (v5)
      {
        if (v4)
        {
          sub_100036158(v4);
          v5 = v2[v3];
        }
        v4 = sub_100036720((uint64_t *)v5);
        if (!v4)
          goto LABEL_41;
        v5 = (uint64_t)malloc_type_calloc(1uLL, 0x30uLL, 0x10200401AD049D5uLL);
        if (!v5)
        {
          if (dword_10008BA20)
          {
            v25 = ne_log_obj(0);
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
              sub_1000622F8();
          }
          goto LABEL_41;
        }
        v6 = (_QWORD *)v5;
        *(_DWORD *)v5 = 1;
        v7 = *(_QWORD *)(a1 + 112);
        *(_QWORD *)(v5 + 8) = *(_QWORD *)(v7 + 24);
        *(_QWORD *)(v5 + 16) = *(_QWORD *)(v7 + 32);
        if (v4[5])
          v8 = dword_10008BA20 == 0;
        else
          v8 = 1;
        if (!v8)
        {
          v9 = ne_log_obj(v5);
          v5 = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
          if ((_DWORD)v5)
            sub_100063280(&v26, v27, v9);
        }
        v10 = v4[4];
        if (v10)
        {
          while (1)
          {
            v11 = malloc_type_calloc(1uLL, 0x50uLL, 0x1020040BE967AE7uLL);
            if (!v11)
              break;
            v12 = v11;
            *v11 = *(_DWORD *)v10;
            *((_QWORD *)v11 + 1) = *(_QWORD *)(v10 + 8);
            v11[4] = *(_DWORD *)(v10 + 16);
            v11[6] = 0;
            v11[7] = *(_DWORD *)(v10 + 24);
            *((_QWORD *)v11 + 6) = 0;
            v5 = sub_100036354(v11, *(_QWORD **)(a1 + 112), *(unsigned __int8 *)(a1 + 61));
            if ((v5 & 0x80000000) != 0)
            {
              if (dword_10008BA20)
              {
                v20 = ne_log_obj(v5);
                if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
                  sub_100063228();
              }
              free(v12);
              goto LABEL_40;
            }
            v13 = v6[4];
            while (v13)
            {
              v14 = v13;
              v13 = *(_QWORD *)(v13 + 72);
              if (!v13)
              {
                v15 = (_QWORD *)(v14 + 72);
                goto LABEL_23;
              }
            }
            v15 = v6 + 4;
LABEL_23:
            *v15 = v12;
            v10 = *(_QWORD *)(v10 + 72);
            if (!v10)
              goto LABEL_24;
          }
          if (dword_10008BA20)
          {
            v19 = ne_log_obj(0);
            if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
              sub_100062350();
          }
LABEL_40:
          free(v6);
          goto LABEL_41;
        }
LABEL_24:
        v16 = v28;
        if (v28)
        {
          do
          {
            v17 = v16;
            v16 = (uint64_t *)v16[5];
          }
          while (v16);
          v18 = (uint64_t **)(v17 + 5);
        }
        else
        {
          v18 = &v28;
        }
        *v18 = v6;
      }
      if (++v3 == 256)
      {
        if (dword_10008BA20)
        {
          v22 = ne_log_obj(v5);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
            sub_100063254();
        }
        v23 = v28;
        if (v28)
        {
          for (i = v28[4]; i; i = *(_QWORD *)(i + 72))
            sub_100036C90(7, (int *)i);
        }
        *(_QWORD *)(a1 + 120) = v23;
        sub_10004B1D0(a1);
        if (v4)
        {
          sub_100036158(v4);
          v4 = 0;
        }
        goto LABEL_46;
      }
    }
  }
  v4 = 0;
LABEL_41:
  if (v28)
    sub_100036158(v28);
  if (v4)
    sub_100036158(v4);
  v4 = (uint64_t *)0xFFFFFFFFLL;
  if (v2)
LABEL_46:
    sub_10000B6A4(v2);
  return (uint64_t)v4;
}

uint64_t sub_100037D58(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 32);
  if (!v1)
    return 0;
  while (*(_DWORD *)(v1 + 16) != 1)
  {
    v1 = *(_QWORD *)(v1 + 72);
    if (!v1)
      return 0;
  }
  return 1;
}

__n128 sub_100037D84(__n128 *a1)
{
  _OWORD *v2;
  __n128 result;

  v2 = malloc_type_calloc(1uLL, 0x18uLL, 0x10200403ED2C137uLL);
  if (v2)
  {
    result = *a1;
    *v2 = *a1;
  }
  return result;
}

_OWORD *sub_100037DC8(_OWORD *result, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;

  if (a2)
  {
    v2 = a2;
    v3 = result + 4;
    do
    {
      result = malloc_type_calloc(1uLL, 0x18uLL, 0x10200403ED2C137uLL);
      if (!result)
        break;
      *result = *(_OWORD *)v2;
      v4 = *v3;
      while (v4)
      {
        v5 = v4;
        v4 = *(_QWORD *)(v4 + 16);
        if (!v4)
        {
          v6 = (_QWORD *)(v5 + 16);
          goto LABEL_9;
        }
      }
      v6 = v3;
LABEL_9:
      *v6 = result;
      v2 = *(_QWORD *)(v2 + 16);
    }
    while (v2);
  }
  return result;
}

_QWORD *sub_100037E40(_QWORD *result, uint64_t a2, int a3)
{
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;

  if (a2)
  {
    v4 = a2;
    v5 = result + 4;
    do
    {
      result = malloc_type_calloc(1uLL, 0x50uLL, 0x1020040BE967AE7uLL);
      if (!result)
        break;
      v6 = result;
      *(_DWORD *)result = *(_DWORD *)v4;
      result[1] = *(_QWORD *)(v4 + 8);
      result[2] = *(_QWORD *)(v4 + 16);
      if (!a3)
      {
        result[3] = *(_QWORD *)(v4 + 24);
        result[6] = *(_QWORD *)(v4 + 48);
      }
      result = sub_100037DC8(result, *(_QWORD *)(v4 + 64));
      v7 = *v5;
      while (v7)
      {
        v8 = v7;
        v7 = *(_QWORD *)(v7 + 72);
        if (!v7)
        {
          v9 = (_QWORD *)(v8 + 72);
          goto LABEL_11;
        }
      }
      v9 = v5;
LABEL_11:
      *v9 = v6;
      v4 = *(_QWORD *)(v4 + 72);
    }
    while (v4);
  }
  return result;
}

uint64_t sub_100037EF8(uint64_t result, int a2)
{
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;

  v9 = 0;
  if (result)
  {
    v3 = result;
    do
    {
      v4 = malloc_type_calloc(1uLL, 0x30uLL, 0x10200401AD049D5uLL);
      if (!v4)
        break;
      v5 = v4;
      *(_DWORD *)v4 = *(_DWORD *)v3;
      v4[1] = *(_QWORD *)(v3 + 8);
      v4[2] = *(_QWORD *)(v3 + 16);
      *((_DWORD *)v4 + 6) = *(_DWORD *)(v3 + 24);
      sub_100037E40(v4, *(_QWORD *)(v3 + 32), a2);
      v6 = v9;
      if (v9)
      {
        do
        {
          v7 = v6;
          v6 = *(_QWORD *)(v6 + 40);
        }
        while (v6);
        v8 = (uint64_t *)(v7 + 40);
      }
      else
      {
        v8 = &v9;
      }
      *v8 = (uint64_t)v5;
      v3 = *(_QWORD *)(v3 + 40);
    }
    while (v3);
    return v9;
  }
  return result;
}

char *sub_100038038()
{
  uint64_t v0;

  return sub_10003E18C(4, *(unsigned int *)(v0 + 16));
}

void sub_100038098(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x16u);
}

char *sub_1000380AC(uint64_t a1, uint64_t a2)
{
  return sub_10003E18C(5, a2);
}

char *sub_1000380B4(uint64_t a1)
{
  return sub_10003DF24(2, *(unsigned int *)(a1 + 4));
}

char *sub_1000380C4(uint64_t a1)
{
  return sub_10003DF24(4, *(unsigned int *)(a1 + 4));
}

char *sub_1000380E4(uint64_t a1)
{
  return sub_10003DF24(3, *(unsigned int *)(a1 + 4));
}

void sub_1000380F4(uint64_t a1@<X8>)
{
  uint64_t v1;

  *(_QWORD *)(v1 - 8) = a1;
}

void sub_100038114(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_debug_impl(a1, v9, OS_LOG_TYPE_DEBUG, a4, &a9, 0x16u);
}

char *sub_100038128@<X0>(int *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;

  *(_QWORD *)(v2 - 56) = a2;
  return sub_10003DCFC(*a1);
}

void sub_100038134(uint64_t a1@<X8>)
{
  uint64_t v1;

  *(_QWORD *)(v1 - 8) = a1;
}

_DWORD *sub_100038154(uint64_t a1, int a2)
{
  sockaddr *v3;
  int v4;
  unsigned __int8 *v5;
  int v7;
  _BOOL4 v8;
  const char *v9;
  const char *v10;
  char *v11;
  _DWORD *v12;
  _DWORD *v13;
  int v14;
  _DWORD *v15;
  _DWORD *v16;
  _DWORD *v17;
  int v18;
  unint64_t v19;
  int v20;
  BOOL v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  NSObject *v25;
  NSObject *v26;
  NSObject *v27;
  NSObject *v28;
  NSObject *v29;
  char v31[32];
  char v32[1025];
  char __str[1072];

  v3 = (sockaddr *)a1;
  v5 = (unsigned __int8 *)(a1 + 1);
  v4 = *(unsigned __int8 *)(a1 + 1);
  if (*(_BYTE *)(a1 + 1))
  {
    if (v4 != 30 && v4 != 2)
    {
      if (dword_10008BA20)
      {
        v23 = ne_log_obj(a1);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          sub_1000632B4(v5, v23);
      }
      return 0;
    }
    v7 = *(unsigned __int16 *)(a1 + 2);
    v8 = *(_WORD *)(a1 + 2) == 0;
    if (getnameinfo((const sockaddr *)a1, *(unsigned __int8 *)a1, v32, 0x401u, v31, 0x20u, 10))
    {
      __strlcpy_chk(v32, "(invalid)", 1025, 1025);
      __strlcpy_chk(v31, "(invalid)", 32, 32);
    }
    v9 = "[";
    v10 = (const char *)&unk_10007E079;
    if (v7)
    {
      v11 = v31;
    }
    else
    {
      v9 = (const char *)&unk_10007E079;
      v11 = (char *)&unk_10007E079;
    }
    if (v7)
      v10 = "]";
    a1 = snprintf(__str, 0x42BuLL, "%s%s%s%s", v32, v9, v11, v10);
  }
  else
  {
    strcpy(__str, "anonymous");
    v8 = 1;
  }
  v12 = (_DWORD *)qword_100088E28;
  if (!qword_100088E28)
  {
LABEL_73:
    if (dword_10008BA20)
    {
      v29 = ne_log_obj(a1);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
        sub_10006332C(v29);
    }
    return 0;
  }
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  do
  {
    if (!*v5 && !*(_BYTE *)(*(_QWORD *)v12 + 1))
    {
      if (!dword_10008BA20)
        return v12;
      v24 = ne_log_obj(a1);
      if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
        return v12;
      goto LABEL_53;
    }
    v18 = v12[2];
    v19 = *(_QWORD *)v12;
    if (v18)
    {
      if (v8)
      {
        a1 = sub_10003B408((unint64_t)v3, v19, v18);
        if ((_DWORD)a1)
          goto LABEL_40;
      }
      else
      {
        a1 = sub_10003B648((unint64_t)v3, v19, v18);
        if ((_DWORD)a1)
        {
          a1 = sub_10003B408((unint64_t)v3, *(_QWORD *)v12, v12[2]);
          if ((_DWORD)a1)
            goto LABEL_40;
          v20 = v12[2];
          v21 = v20 <= v14;
          if (v20 >= v14)
            v15 = v12;
          goto LABEL_34;
        }
      }
      v20 = v12[2];
      v21 = v20 <= v14;
      if (v20 >= v14)
        v16 = v12;
LABEL_34:
      if (!v21)
        v14 = v20;
      goto LABEL_40;
    }
    if (!v8)
    {
      a1 = sub_10003B5A0((unint64_t)v3, v19);
      if ((_DWORD)a1)
      {
        a1 = sub_10003B380((unint64_t)v3, *(_QWORD *)v12);
        if (!(_DWORD)a1)
          v17 = v12;
        goto LABEL_40;
      }
LABEL_54:
      if (!dword_10008BA20)
        return v12;
      v25 = ne_log_obj(a1);
      if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
        return v12;
LABEL_53:
      sub_10006336C();
      return v12;
    }
    a1 = sub_10003B380((unint64_t)v3, v19);
    if (!(_DWORD)a1)
      goto LABEL_54;
LABEL_40:
    if (!*(_BYTE *)(*(_QWORD *)v12 + 1))
      v13 = v12;
    v12 = (_DWORD *)*((_QWORD *)v12 + 38);
  }
  while (v12);
  if (v17)
  {
    if (dword_10008BA20)
    {
      v22 = ne_log_obj(a1);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
        sub_10006336C();
    }
    return v17;
  }
  if (v16)
  {
    if (dword_10008BA20)
    {
      v26 = ne_log_obj(a1);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
        sub_10006336C();
    }
    return v16;
  }
  if (v15)
  {
    if (dword_10008BA20)
    {
      v27 = ne_log_obj(a1);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
        sub_10006336C();
    }
    return v15;
  }
  if (!a2 || !v13)
    goto LABEL_73;
  if (dword_10008BA20)
  {
    v28 = ne_log_obj(a1);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
      sub_1000633CC();
  }
  return v13;
}

uint64_t sub_100038560(uint64_t result)
{
  _QWORD *v1;

  v1 = (_QWORD *)qword_100088E28;
  if (!qword_100088E28)
    return 1;
  if ((_DWORD)result)
  {
    while (!*(_BYTE *)(*v1 + 1))
    {
      v1 = (_QWORD *)v1[38];
      if (!v1)
        return 1;
    }
    return 0;
  }
  return result;
}

_DWORD *sub_100038594(uint64_t a1)
{
  _DWORD *result;
  __int128 v3;
  int v4;
  uint64_t v5;
  int v6;

  result = sub_100038154(a1, 1);
  if (!result)
  {
    if (*(_BYTE *)(a1 + 1) != 30)
      return 0;
    v6 = 0;
    v5 = 0;
    v4 = 528;
    v3 = 0uLL;
    if (!sub_1000484FC(&v3))
      return 0;
    nw_nat64_extract_v4(&v3, a1 + 8, &v5);
    result = (_DWORD *)sub_100038594(&v4);
    if (!result)
      return 0;
  }
  return result;
}

_DWORD *sub_100038640()
{
  _DWORD *v0;
  _DWORD *v1;

  v0 = malloc_type_calloc(1uLL, 0x140uLL, 0x10A004000D84CD7uLL);
  v1 = v0;
  if (v0)
  {
    v0[71] = 0;
    *((_QWORD *)v0 + 31) = 0;
    *((_QWORD *)v0 + 3) = 0x100000001;
    *((_QWORD *)v0 + 36) = 0x1000000001;
    v0[8] = 0;
    *((_QWORD *)v0 + 7) = sub_100006CF8();
    *(_OWORD *)(v1 + 34) = xmmword_10006A220;
    *(_OWORD *)(v1 + 26) = xmmword_10006A230;
    *((_QWORD *)v1 + 15) = 0x100000001;
    *(_OWORD *)(v1 + 38) = xmmword_10006A240;
    *((_QWORD *)v1 + 25) = *(_QWORD *)(qword_10008B848 + 268);
    *(_OWORD *)(v1 + 42) = xmmword_10006A250;
    v1[46] = 1;
    *((_QWORD *)v1 + 5) = 0;
    *((_QWORD *)v1 + 6) = 0;
    *((_OWORD *)v1 + 13) = xmmword_10006A260;
    *((_QWORD *)v1 + 28) = 1;
    v1[60] = 0;
    *((_QWORD *)v1 + 34) = 0;
    v1[70] = 1;
  }
  return v1;
}

_QWORD *sub_10003872C(const sockaddr *a1)
{
  _DWORD *v2;
  NSObject *v4;

  v2 = sub_100038154((uint64_t)a1, 0);
  if (v2)
    return sub_100038798((_QWORD **)v2);
  if (dword_10008BA20)
  {
    v4 = ne_log_obj(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      sub_10006342C(a1, v4);
  }
  return 0;
}

_QWORD *sub_100038798(_QWORD **a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;

  v2 = malloc_type_calloc(1uLL, 0x140uLL, 0x10A004000D84CD7uLL);
  v3 = v2;
  if (v2)
  {
    memcpy(v2, a1, 0x140uLL);
    *v3 = 0;
    v3[37] = 0;
    v3[9] = 0;
    v3[31] = 0;
    *(_QWORD *)((char *)v3 + 284) = &_mh_execute_header;
    v3[11] = 0;
    v3[12] = 0;
    v3[34] = 0;
    v3[5] = 0;
    v3[6] = 0;
    v4 = v3[2];
    if (v4)
      v3[2] = sub_100038904(v4);
    v5 = sub_100006CF8();
    v3[7] = v5;
    sub_100006DD0(a1[7], sub_100038840, (uint64_t)v5);
  }
  return v3;
}

uint64_t sub_100038840(uint64_t a1, uint64_t a2)
{
  void *v4;
  _DWORD *v5;

  v4 = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
  if (!v4)
    return -1;
  v5 = v4;
  *(_DWORD *)v4 = 4;
  if (sub_100010490((void ***)v4 + 1, *(_DWORD *)a1, *(_QWORD *)(a1 + 8)))
  {
    free(v5);
    return -1;
  }
  *v5 = *(_DWORD *)a1;
  sub_100006D80(a2, (uint64_t)v5);
  return 0;
}

_DWORD *sub_1000388CC()
{
  _DWORD *result;

  result = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
  if (result)
    *result = 4;
  return result;
}

_QWORD *sub_100038904(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;

  if (!a1)
    return 0;
  v2 = malloc_type_malloc(0x10uLL, 0x1020040D5A9D86FuLL);
  v3 = v2;
  if (v2)
  {
    *(_DWORD *)v2 = *(_DWORD *)a1;
    v2[1] = 0;
    if (*(_QWORD *)(a1 + 8))
      v2[1] = sub_100038904();
  }
  return v3;
}

void sub_10003896C(_QWORD *a1)
{
  _QWORD **v2;
  void *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  void *v13;
  void *v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;

  v2 = (_QWORD **)*a1;
  if (v2)
    free(v2);
  v3 = (void *)a1[37];
  if (v3)
    free(v3);
  if (a1[34])
    sub_1000472E4((_QWORD ***)a1 + 34);
  v4 = (_QWORD *)a1[2];
  if (v4)
  {
    sub_100038A7C(v4);
    a1[2] = 0;
  }
  v5 = (_QWORD *)a1[5];
  if (v5)
    sub_10003F318(v5);
  v6 = (_QWORD *)a1[7];
  if (v6)
    sub_100006E58(v6, (void (*)(_QWORD))sub_100038AA8);
  v7 = (_QWORD *)a1[24];
  if (v7)
    sub_10002957C(v7);
  v8 = (_QWORD *)a1[31];
  if (v8)
    sub_100038AD0(v8);
  v9 = (_QWORD *)a1[33];
  if (v9)
  {
    do
    {
      v10 = (_QWORD *)v9[2];
      v11 = (_QWORD *)v9[3];
      if (v10)
      {
        do
        {
          v12 = (_QWORD *)v10[12];
          v13 = (void *)v10[6];
          if (v13)
            free(v13);
          v14 = (void *)v10[7];
          if (v14)
            free(v14);
          free(v10);
          v10 = v12;
        }
        while (v12);
      }
      free(v9);
      v9 = v11;
    }
    while (v11);
  }
  v15 = (_QWORD *)a1[11];
  if (v15)
    sub_10003F318(v15);
  v16 = (_QWORD *)a1[9];
  if (v16)
    sub_10003F318(v16);
  v17 = (_QWORD *)a1[12];
  if (v17)
    sub_10003F318(v17);
  free(a1);
}

void sub_100038A7C(_QWORD *a1)
{
  if (a1[1])
    sub_100038A7C();
  free(a1);
}

void sub_100038AA8(_QWORD **a1)
{
  sub_10003F318(a1[1]);
  free(a1);
}

void sub_100038AD0(_QWORD *a1)
{
  _QWORD *v2;

  v2 = (_QWORD *)a1[8];
  if (v2)
    sub_10002957C(v2);
  if (a1[10])
    sub_100038AD0();
  free(a1);
}

uint64_t sub_100038B08(uint64_t result)
{
  uint64_t v1;
  uint64_t *v2;

  v1 = qword_100088E28;
  *(_QWORD *)(result + 304) = qword_100088E28;
  qword_100088E28 = result;
  if (v1)
    v2 = (uint64_t *)(v1 + 312);
  else
    v2 = &qword_100088E30;
  *v2 = result + 304;
  *(_QWORD *)(result + 312) = &qword_100088E28;
  *(_DWORD *)(result + 284) = 1;
  return result;
}

uint64_t sub_100038B44(uint64_t result)
{
  uint64_t v1;
  _QWORD *v2;

  if (*(_DWORD *)(result + 284))
  {
    v1 = *(_QWORD *)(result + 304);
    v2 = *(_QWORD **)(result + 312);
    if (v1)
    {
      *(_QWORD *)(v1 + 312) = v2;
      v2 = *(_QWORD **)(result + 312);
    }
    else
    {
      qword_100088E30 = *(_QWORD *)(result + 312);
    }
    *v2 = v1;
  }
  *(_DWORD *)(result + 284) = 0;
  return result;
}

uint64_t sub_100038B74(uint64_t result)
{
  ++*(_DWORD *)(result + 288);
  return result;
}

void sub_100038B84(_QWORD *a1)
{
  int v1;
  BOOL v2;
  uint64_t v3;
  _QWORD *v4;

  v1 = *((_DWORD *)a1 + 72);
  v2 = __OFSUB__(v1--, 1);
  *((_DWORD *)a1 + 72) = v1;
  if ((v1 < 0) ^ v2 | (v1 == 0))
  {
    if (*((_DWORD *)a1 + 71))
    {
      v3 = a1[38];
      v4 = (_QWORD *)a1[39];
      if (v3)
      {
        *(_QWORD *)(v3 + 312) = v4;
        v4 = (_QWORD *)a1[39];
      }
      else
      {
        qword_100088E30 = a1[39];
      }
      *v4 = v3;
    }
    *((_DWORD *)a1 + 71) = 0;
    sub_10003896C(a1);
  }
}

uint64_t sub_100038BC8()
{
  uint64_t result;
  uint64_t v1;
  uint64_t *v2;
  int v3;
  BOOL v4;

  result = qword_100088E28;
  if (qword_100088E28)
  {
    do
    {
      v1 = *(_QWORD *)(result + 304);
      if (*(_DWORD *)(result + 284))
      {
        v2 = *(uint64_t **)(result + 312);
        if (v1)
        {
          *(_QWORD *)(v1 + 312) = v2;
          v2 = *(uint64_t **)(result + 312);
        }
        else
        {
          qword_100088E30 = *(_QWORD *)(result + 312);
        }
        *v2 = v1;
      }
      *(_DWORD *)(result + 284) = 0;
      v3 = *(_DWORD *)(result + 288);
      v4 = __OFSUB__(v3--, 1);
      *(_DWORD *)(result + 288) = v3;
      if ((v3 < 0) ^ v4 | (v3 == 0))
        sub_10003896C((_QWORD *)result);
      result = v1;
    }
    while (v1);
  }
  return result;
}

void sub_100038C38()
{
  qword_100088E28 = 0;
  qword_100088E30 = (uint64_t)&qword_100088E28;
}

uint64_t sub_100038C48(uint64_t a1, int a2)
{
  uint64_t result;

  for (result = *(_QWORD *)(a1 + 16); result; result = *(_QWORD *)(result + 8))
  {
    if (*(_DWORD *)result == a2)
      break;
  }
  return result;
}

_DWORD *sub_100038C68()
{
  _DWORD *result;

  result = malloc_type_calloc(1uLL, 0x60uLL, 0x1020040CE8B1C45uLL);
  if (result)
  {
    result[14] = -1;
    *((_QWORD *)result + 10) = 0;
    *((_QWORD *)result + 11) = 0;
  }
  return result;
}

uint64_t sub_100038CA4(uint64_t result, uint64_t a2)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)(result + 88) = a2;
  v4 = *(_QWORD *)(a2 + 248);
  v2 = (_QWORD *)(a2 + 248);
  v3 = v4;
  if (v4)
  {
    do
    {
      v5 = v3;
      v3 = *(_QWORD *)(v3 + 80);
    }
    while (v3);
    v2 = (_QWORD *)(v5 + 80);
  }
  *v2 = result;
  return result;
}

uint64_t sub_100038CC8(uint64_t (*a1)(uint64_t, uint64_t), uint64_t a2)
{
  uint64_t v2;
  uint64_t result;

  v2 = **(_QWORD **)(qword_100088E30 + 8);
  if (!v2)
    return 0;
  while (1)
  {
    result = a1(v2, a2);
    if (result)
      break;
    v2 = **(_QWORD **)(*(_QWORD *)(v2 + 312) + 8);
    if (!v2)
      return 0;
  }
  return result;
}

void sub_100038D28()
{
  uint64_t v0;
  __int128 v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  const sockaddr *v5;
  uint64_t *v6;
  uint64_t v7;
  const sockaddr **v8;
  char *v9;
  size_t v10;
  uint64_t *v11;
  NSObject *v12;
  char *v13;
  const char *v14;
  const char *v15;
  NSObject *v16;
  _BOOL8 v17;
  NSObject *v18;
  const char *v19;
  char *v20;
  uint64_t v21;
  NSObject *v22;
  int v23;
  NSObject *v24;
  NSObject *v25;
  const char *v26;
  uint32_t v27;
  uint64_t v28;
  NSObject *v29;
  NSObject *v30;
  const char *v31;
  NSObject *v32;
  const char *v33;
  NSObject *v34;
  const char *v35;
  NSObject *v36;
  const char *v37;
  NSObject *v38;
  const char *v39;
  NSObject *v40;
  const char *v41;
  NSObject *v42;
  int v43;
  NSObject *v44;
  const char *v45;
  NSObject *v46;
  const char *v47;
  NSObject *v48;
  int v49;
  NSObject *v50;
  const char *v51;
  NSObject *v52;
  const char *v53;
  NSObject *v54;
  const char *v55;
  NSObject *v56;
  int v57;
  NSObject *v58;
  NSObject *v59;
  int v60;
  int v61;
  uint64_t *v62;
  NSObject *v63;
  NSObject *v64;
  uint64_t v65;
  NSObject *v66;
  uint64_t v67;
  NSObject *v68;
  const char *v69;
  NSObject *v70;
  const char *v71;
  NSObject *v72;
  const char *v73;
  NSObject *v74;
  const char *v75;
  NSObject *v76;
  const char *v77;
  NSObject *v78;
  NSObject *v79;
  _BOOL8 v80;
  NSObject *v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  uint8_t buf[4];
  _BYTE v87[10];
  __int16 v88;
  uint64_t *v89;
  char __str[1024];
  uint64_t v91;

  v0 = **(_QWORD **)(qword_100088E30 + 8);
  if (v0)
  {
    *((_QWORD *)&v1 + 1) = *(_QWORD *)"e_type ";
    strcpy((char *)&v82, "\texchange_type ");
    *(_QWORD *)&v1 = 136315138;
    v84 = v1;
    *(_QWORD *)&v1 = 67109634;
    v85 = v1;
    *(_QWORD *)&v1 = 134217984;
    v83 = v1;
    do
    {
      v2 = *(_QWORD *)(v0 + 16);
      v3 = *(_QWORD *)(v0 + 248);
      v4 = *(_DWORD *)(v0 + 8);
      v5 = *(const sockaddr **)v0;
      if (v4)
        v6 = sub_10003C784(v5, v4);
      else
        v6 = sub_10003C570(v5);
      v7 = snprintf(__str, 0x400uLL, "remote %s", (const char *)v6);
      v8 = *(const sockaddr ***)(v0 + 256);
      if (v8)
      {
        v9 = &__str[(int)v7];
        v10 = 1024 - (int)v7;
        v11 = sub_10003C570(*v8);
        v7 = snprintf(v9, v10, " inherit %s", (const char *)v11);
      }
      if (dword_10008BA20)
      {
        v12 = ne_log_obj(v7);
        v7 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
        if ((_DWORD)v7)
        {
          *(_DWORD *)buf = v84;
          *(_QWORD *)v87 = __str;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%s {\n", buf, 0xCu);
        }
      }
      *(_OWORD *)__str = v82;
      if (v2)
      {
        v13 = &__str[15];
        do
        {
          v14 = sub_10003EA48(*(_DWORD *)v2);
          if (*(_QWORD *)(v2 + 8))
            v15 = ", ";
          else
            v15 = ";\n";
          v7 = snprintf(v13, (char *)&v91 - v13, "%s%s", v14, v15);
          v13 += (int)v7;
          v2 = *(_QWORD *)(v2 + 8);
        }
        while (v2);
      }
      if (dword_10008BA20)
      {
        v16 = ne_log_obj(v7);
        v17 = os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT);
        if (v17)
        {
          *(_DWORD *)buf = v84;
          *(_QWORD *)v87 = __str;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%s", buf, 0xCu);
        }
        if (dword_10008BA20)
        {
          v18 = ne_log_obj(v17);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
          {
            v19 = sub_10003E9F0(*(_DWORD *)(v0 + 24));
            *(_DWORD *)buf = v84;
            *(_QWORD *)v87 = v19;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "\tdoi %s;\n", buf, 0xCu);
          }
        }
      }
      v20 = sub_10003EB38(*(_DWORD *)(v0 + 32));
      v21 = snprintf(__str, 0x400uLL, "\tmy_identifier %s", v20);
      if (*(_DWORD *)(v0 + 32) != 5)
      {
        v28 = *(_QWORD *)(v0 + 40);
        if (v28)
          v21 = snprintf(&__str[(int)v21], 1024 - (int)v21, " \"%s\"", *(const char **)(v28 + 8));
        if (dword_10008BA20)
        {
          v29 = ne_log_obj(v21);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = v84;
            *(_QWORD *)v87 = __str;
            _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "%s;\n", buf, 0xCu);
          }
        }
        v21 = sub_100006DD0(*(_QWORD **)(v0 + 56), (uint64_t (*)(_QWORD, uint64_t))sub_100039A30, 0);
        goto LABEL_38;
      }
      if (dword_10008BA20)
      {
        v22 = ne_log_obj(v21);
        v21 = os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT);
        if ((_DWORD)v21)
        {
          *(_DWORD *)buf = v84;
          *(_QWORD *)v87 = __str;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%s;\n", buf, 0xCu);
        }
      }
      v23 = *(_DWORD *)(v0 + 108);
      if (!v23)
        goto LABEL_38;
      if (v23 == 1)
      {
        if (dword_10008BA20)
        {
          v24 = ne_log_obj(v21);
          v21 = os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT);
          if ((_DWORD)v21)
          {
            *(_WORD *)buf = 0;
            v25 = v24;
            v26 = "\t/* peers certificate from payload */\n";
            v27 = 2;
            goto LABEL_84;
          }
          goto LABEL_38;
        }
      }
      else if (dword_10008BA20)
      {
        v56 = ne_log_obj(v21);
        v21 = os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT);
        if ((_DWORD)v21)
        {
          v57 = *(_DWORD *)(v0 + 108);
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)v87 = v57;
          v25 = v56;
          v26 = "\tpeers_certfile *UNKNOWN* (%d)\n";
          v27 = 8;
LABEL_84:
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, v26, buf, v27);
        }
LABEL_38:
        if (dword_10008BA20)
        {
          v30 = ne_log_obj(v21);
          v21 = os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT);
          if ((_DWORD)v21)
          {
            v31 = sub_10003EB98(*(_DWORD *)(v0 + 116));
            *(_DWORD *)buf = v84;
            *(_QWORD *)v87 = v31;
            _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "\tsend_cert %s;\n", buf, 0xCu);
          }
          if (dword_10008BA20)
          {
            v32 = ne_log_obj(v21);
            v21 = os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT);
            if ((_DWORD)v21)
            {
              v33 = sub_10003EB98(*(_DWORD *)(v0 + 120));
              *(_DWORD *)buf = v84;
              *(_QWORD *)v87 = v33;
              _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "\tsend_cr %s;\n", buf, 0xCu);
            }
            if (dword_10008BA20)
            {
              v34 = ne_log_obj(v21);
              v21 = os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT);
              if ((_DWORD)v21)
              {
                v35 = sub_10003EB98(*(_DWORD *)(v0 + 124));
                *(_DWORD *)buf = v84;
                *(_QWORD *)v87 = v35;
                _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "\tverify_cert %s;\n", buf, 0xCu);
              }
              if (dword_10008BA20)
              {
                v36 = ne_log_obj(v21);
                v21 = os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT);
                if ((_DWORD)v21)
                {
                  v37 = sub_10003EB98(*(_DWORD *)(v0 + 136));
                  *(_DWORD *)buf = v84;
                  *(_QWORD *)v87 = v37;
                  _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "\tverify_identifier %s;\n",
                    buf,
                    0xCu);
                }
                if (dword_10008BA20)
                {
                  v38 = ne_log_obj(v21);
                  v21 = os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT);
                  if ((_DWORD)v21)
                  {
                    v39 = "force";
                    if (*(_DWORD *)(v0 + 176) != 2)
                      v39 = sub_10003EB98(*(_DWORD *)(v0 + 176));
                    *(_DWORD *)buf = v84;
                    *(_QWORD *)v87 = v39;
                    _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "\tnat_traversal %s;\n",
                      buf,
                      0xCu);
                  }
                  if (dword_10008BA20)
                  {
                    v40 = ne_log_obj(v21);
                    v21 = os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT);
                    if ((_DWORD)v21)
                    {
                      v41 = sub_10003EB98(*(_DWORD *)(v0 + 180));
                      *(_DWORD *)buf = v84;
                      *(_QWORD *)v87 = v41;
                      _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "\tnatt_multiple_user %s;\n",
                        buf,
                        0xCu);
                    }
                    if (dword_10008BA20)
                    {
                      v42 = ne_log_obj(v21);
                      v21 = os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT);
                      if ((_DWORD)v21)
                      {
                        v43 = *(_DWORD *)(v0 + 140);
                        *(_DWORD *)buf = 67109120;
                        *(_DWORD *)v87 = v43;
                        _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "\tnonce_size %d;\n",
                          buf,
                          8u);
                      }
                      if (dword_10008BA20)
                      {
                        v44 = ne_log_obj(v21);
                        v21 = os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT);
                        if ((_DWORD)v21)
                        {
                          v45 = sub_10003EB98(*(_DWORD *)(v0 + 144));
                          *(_DWORD *)buf = v84;
                          *(_QWORD *)v87 = v45;
                          _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "\tpassive %s;\n",
                            buf,
                            0xCu);
                        }
                        if (dword_10008BA20)
                        {
                          v46 = ne_log_obj(v21);
                          v21 = os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT);
                          if ((_DWORD)v21)
                          {
                            v47 = "force";
                            if (*(_DWORD *)(v0 + 148) != 2)
                              v47 = sub_10003EB98(*(_DWORD *)(v0 + 148));
                            *(_DWORD *)buf = v84;
                            *(_QWORD *)v87 = v47;
                            _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "\tike_frag %s;\n",
                              buf,
                              0xCu);
                          }
                          if (dword_10008BA20)
                          {
                            v48 = ne_log_obj(v21);
                            v21 = os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT);
                            if ((_DWORD)v21)
                            {
                              v49 = *(_DWORD *)(v0 + 152);
                              *(_DWORD *)buf = 67109120;
                              *(_DWORD *)v87 = v49;
                              _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "\tesp_frag %d;\n",
                                buf,
                                8u);
                            }
                            if (dword_10008BA20)
                            {
                              v50 = ne_log_obj(v21);
                              v21 = os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT);
                              if ((_DWORD)v21)
                              {
                                v51 = sub_10003EB98(*(_DWORD *)(v0 + 168));
                                *(_DWORD *)buf = v84;
                                *(_QWORD *)v87 = v51;
                                _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "\tinitial_contact %s;\n",
                                  buf,
                                  0xCu);
                              }
                              if (dword_10008BA20)
                              {
                                v52 = ne_log_obj(v21);
                                v21 = os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT);
                                if ((_DWORD)v21)
                                {
                                  v53 = sub_10003EB98(*(_DWORD *)(v0 + 164));
                                  *(_DWORD *)buf = v84;
                                  *(_QWORD *)v87 = v53;
                                  _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "\tgenerate_policy %s;\n",
                                    buf,
                                    0xCu);
                                }
                                if (dword_10008BA20)
                                {
                                  v54 = ne_log_obj(v21);
                                  v21 = os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT);
                                  if ((_DWORD)v21)
                                  {
                                    v55 = sub_10003EB98(*(_DWORD *)(v0 + 160));
                                    *(_DWORD *)buf = v84;
                                    *(_QWORD *)v87 = v55;
                                    _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "\tsupport_proxy %s;\n",
                                      buf,
                                      0xCu);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      for (; v3; v3 = *(_QWORD *)(v3 + 80))
      {
        if (dword_10008BA20)
        {
          v58 = ne_log_obj(v21);
          v21 = os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT);
          if ((_DWORD)v21)
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "\n", buf, 2u);
          }
          if (dword_10008BA20)
          {
            v59 = ne_log_obj(v21);
            v21 = os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT);
            if ((_DWORD)v21)
            {
              v60 = *(_DWORD *)(v3 + 4);
              v61 = *(_DWORD *)(v3 + 8);
              v62 = sub_10003C570(**(const sockaddr ***)(v3 + 88));
              *(_DWORD *)buf = v85;
              *(_DWORD *)v87 = v60;
              *(_WORD *)&v87[4] = 1024;
              *(_DWORD *)&v87[6] = v61;
              v88 = 2080;
              v89 = v62;
              _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "\t/* prop_no=%d, trns_no=%d, rmconf=%s */\n", buf, 0x18u);
            }
            if (dword_10008BA20)
            {
              v63 = ne_log_obj(v21);
              v21 = os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT);
              if ((_DWORD)v21)
              {
                *(_WORD *)buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "\tproposal {\n", buf, 2u);
              }
              if (dword_10008BA20)
              {
                v64 = ne_log_obj(v21);
                v21 = os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT);
                if ((_DWORD)v21)
                {
                  v65 = *(_QWORD *)(v3 + 16);
                  *(_DWORD *)buf = v83;
                  *(_QWORD *)v87 = v65;
                  _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "\t\tlifetime time %lu sec;\n",
                    buf,
                    0xCu);
                }
                if (dword_10008BA20)
                {
                  v66 = ne_log_obj(v21);
                  v21 = os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT);
                  if ((_DWORD)v21)
                  {
                    v67 = *(_QWORD *)(v3 + 32);
                    *(_DWORD *)buf = v83;
                    *(_QWORD *)v87 = v67;
                    _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "\t\tlifetime bytes %zd;\n",
                      buf,
                      0xCu);
                  }
                  if (dword_10008BA20)
                  {
                    v68 = ne_log_obj(v21);
                    v21 = os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT);
                    if ((_DWORD)v21)
                    {
                      v69 = sub_100004654(*(unsigned int *)(v3 + 60));
                      *(_DWORD *)buf = v84;
                      *(_QWORD *)v87 = v69;
                      _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "\t\tdh_group %s;\n",
                        buf,
                        0xCu);
                    }
                    if (dword_10008BA20)
                    {
                      v70 = ne_log_obj(v21);
                      v21 = os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT);
                      if ((_DWORD)v21)
                      {
                        v71 = sub_1000042AC(*(_DWORD *)(v3 + 40));
                        *(_DWORD *)buf = v84;
                        *(_QWORD *)v87 = v71;
                        _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "\t\tencryption_algorithm %s;\n",
                          buf,
                          0xCu);
                      }
                      if (dword_10008BA20)
                      {
                        v72 = ne_log_obj(v21);
                        v21 = os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT);
                        if ((_DWORD)v21)
                        {
                          v73 = sub_100004028(*(_DWORD *)(v3 + 52));
                          *(_DWORD *)buf = v84;
                          *(_QWORD *)v87 = v73;
                          _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "\t\thash_algorithm %s;\n",
                            buf,
                            0xCu);
                        }
                        if (dword_10008BA20)
                        {
                          v74 = ne_log_obj(v21);
                          v21 = os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT);
                          if ((_DWORD)v21)
                          {
                            v75 = sub_100004028(*(_DWORD *)(v3 + 72));
                            *(_DWORD *)buf = v84;
                            *(_QWORD *)v87 = v75;
                            _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "\t\tprf_algorithm %s;\n",
                              buf,
                              0xCu);
                          }
                          if (dword_10008BA20)
                          {
                            v76 = ne_log_obj(v21);
                            v21 = os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT);
                            if ((_DWORD)v21)
                            {
                              v77 = sub_1000046B4(*(_DWORD *)(v3 + 48));
                              *(_DWORD *)buf = v84;
                              *(_QWORD *)v87 = v77;
                              _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "\t\tauthentication_method %s;\n",
                                buf,
                                0xCu);
                            }
                            if (dword_10008BA20)
                            {
                              v78 = ne_log_obj(v21);
                              v21 = os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT);
                              if ((_DWORD)v21)
                              {
                                *(_WORD *)buf = 0;
                                _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_DEFAULT, "\t}\n", buf, 2u);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (dword_10008BA20)
      {
        v79 = ne_log_obj(v21);
        v80 = os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT);
        if (v80)
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_DEFAULT, "}\n", buf, 2u);
        }
        if (dword_10008BA20)
        {
          v81 = ne_log_obj(v80);
          if (os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_DEFAULT, "\n", buf, 2u);
          }
        }
      }
      v0 = **(_QWORD **)(*(_QWORD *)(v0 + 312) + 8);
    }
    while (v0);
  }
}

_DWORD *sub_1000399A0(uint64_t a1)
{
  _DWORD *v2;
  _DWORD *v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;

  if (!a1)
    return 0;
  v2 = malloc_type_calloc(1uLL, 0x60uLL, 0x1020040CE8B1C45uLL);
  v3 = v2;
  if (v2)
  {
    v2[14] = -1;
    *((_QWORD *)v2 + 10) = 0;
    *((_QWORD *)v2 + 11) = 0;
    v4 = *(_OWORD *)(a1 + 32);
    v5 = *(_OWORD *)(a1 + 48);
    v6 = *(_OWORD *)(a1 + 64);
    *((_OWORD *)v2 + 5) = *(_OWORD *)(a1 + 80);
    v7 = *(_OWORD *)(a1 + 16);
    *(_OWORD *)v2 = *(_OWORD *)a1;
    *((_OWORD *)v2 + 1) = v7;
    *((_OWORD *)v2 + 3) = v5;
    *((_OWORD *)v2 + 4) = v6;
    *((_OWORD *)v2 + 2) = v4;
    *((_QWORD *)v2 + 10) = 0;
    if (*(_QWORD *)(a1 + 64))
      sub_100029AD4(*(unsigned int *)(a1 + 60), (uint64_t)(v2 + 16));
  }
  return v3;
}

uint64_t sub_100039A30(uint64_t a1)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  uint8_t buf[4];
  char *v8;
  char __str[1024];

  v2 = sub_10003EB38(*(_DWORD *)a1);
  v3 = snprintf(__str, 0x400uLL, "\tpeers_identifier %s", v2);
  v4 = *(_QWORD *)(a1 + 8);
  if (v4)
    v3 = snprintf(&__str[(int)v3], 1024 - (int)v3, " \"%s\"", *(const char **)(v4 + 8));
  if (dword_10008BA20)
  {
    v5 = ne_log_obj(v3);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      v8 = __str;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%s;\n", buf, 0xCu);
    }
  }
  return 0;
}

uint64_t sub_100039B38(const char *a1, int a2)
{
  uid_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  NSObject *v23;
  stat v24;

  memset(&v24, 0, sizeof(v24));
  v4 = getuid();
  v5 = geteuid();
  if (v4 != (_DWORD)v5)
  {
    if (dword_10008BA20)
    {
      v15 = ne_log_obj(v5);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        sub_100063600(v15);
    }
    return 0xFFFFFFFFLL;
  }
  if (stat(a1, &v24))
    return 0xFFFFFFFFLL;
  v6 = getuid();
  if (v24.st_uid != (_DWORD)v6)
  {
    if (dword_10008BA20)
    {
      v16 = ne_log_obj(v6);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        sub_10006359C((uint64_t)a1, v16, v17, v18, v19, v20, v21, v22);
    }
    return 0xFFFFFFFFLL;
  }
  if ((v24.st_mode & 0xF000) != 0x8000)
  {
    if (dword_10008BA20)
    {
      v23 = ne_log_obj(v6);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        sub_100063514((uint64_t)a1, &v24.st_mode, v23);
    }
    return 0xFFFFFFFFLL;
  }
  result = 0;
  if (a2 && (v24.st_mode & 0x3F) != 0)
  {
    if (dword_10008BA20)
    {
      v8 = ne_log_obj(0);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_1000634B0((uint64_t)a1, v8, v9, v10, v11, v12, v13, v14);
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t sub_100039CAC(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t *v15;
  const void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  NSObject *v23;
  uint64_t v24;
  uint64_t v25;
  char v27;

  v6 = a1;
  v7 = qword_10008B848;
  if (a4 && !*(_QWORD *)(qword_10008B848 + 296))
    return 0;
  if (a3)
    v8 = 1;
  else
    v8 = 2;
  v9 = qword_100088E38;
  while (!v9)
  {
LABEL_30:
    v22 = v8 == 1;
    v8 = 2;
    if (!v22)
      return 0;
  }
  v10 = 0;
  v11 = v9;
  while (1)
  {
    v12 = v10;
    v13 = *(_QWORD *)(v11 + 40);
    if (v13)
    {
      if (v8 == 2)
        goto LABEL_18;
      a1 = memcmp(*(const void **)(a3 + 8), *(const void **)(v13 + 8), *(_QWORD *)v13);
      if ((_DWORD)a1)
        goto LABEL_18;
    }
    else if (v8 == 1)
    {
      goto LABEL_18;
    }
    v14 = *(_QWORD *)v11;
    v10 = v11;
    if (*(_QWORD *)v11)
      break;
LABEL_19:
    v11 = *(_QWORD *)(v11 + 120);
    if (!v11)
    {
      v12 = v10;
      if (!v10)
        goto LABEL_30;
LABEL_32:
      if (dword_10008BA20)
      {
        v23 = ne_log_obj(a1);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
          sub_100063640(v23, v24, v25);
      }
      return v12;
    }
  }
  if (!v6)
  {
    if (v12)
      goto LABEL_32;
    v10 = 0;
    goto LABEL_19;
  }
  if (*(_QWORD *)v6 != *(_QWORD *)v14
    || (a1 = memcmp(*(const void **)(v6 + 8), *(const void **)(v14 + 8), *(_QWORD *)v6), (_DWORD)a1))
  {
LABEL_18:
    v10 = v12;
    goto LABEL_19;
  }
  if (!a4)
  {
    v21 = *(_QWORD *)(v11 + 8);
    if (*(_QWORD *)a2 == *(_QWORD *)v21)
    {
      a1 = memcmp(*(const void **)(a2 + 8), *(const void **)(v21 + 8), *(_QWORD *)a2);
      v10 = v12;
      if (!(_DWORD)a1)
        return v11;
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  v15 = *(unint64_t **)(v7 + 296);
  v16 = (const void *)v15[1];
  a1 = memcmp(v16, *(const void **)(*(_QWORD *)(v11 + 8) + 8), **(_QWORD **)(v11 + 8));
  v10 = v12;
  if ((_DWORD)a1)
    goto LABEL_19;
  if (dword_1000882C8 >= 7)
    sub_10003372C(7, (uint64_t)v16, *v15, "matched external nat address.\n", v17, v18, v19, v20, v27);
  return v11;
}

uint64_t sub_100039E8C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  uint64_t v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  char v22;
  uint8_t v23;
  char v24[15];

  v9 = a1;
  if (!dword_10008BA20
    || (v10 = ne_log_obj(a1), a1 = os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG), !(_DWORD)a1))
  {
    if (v9)
      goto LABEL_4;
    return 0;
  }
  sub_1000636A8(v10, v11, v12);
  if (!v9)
    return 0;
LABEL_4:
  if (dword_1000882C8 >= 7)
    sub_10003372C(7, *(_QWORD *)(v9 + 8), *(_QWORD *)v9, "getsainfo_by_dst_id - dst id:\n", a5, a6, a7, a8, v22);
  v13 = qword_100088E38;
  if (!qword_100088E38)
    return 0;
  v14 = 0;
  do
  {
    v15 = v14;
    if (*(_QWORD *)v13)
    {
      if (dword_1000882C8 >= 7)
      {
        sub_10003372C(7, *(_QWORD *)(*(_QWORD *)v13 + 8), **(_QWORD **)v13, "getsainfo_by_dst_id - sainfo id - src:\n", a5, a6, a7, a8, v22);
        if (dword_1000882C8 >= 7)
          sub_10003372C(7, *(_QWORD *)(*(_QWORD *)(v13 + 8) + 8), **(_QWORD **)(v13 + 8), "getsainfo_by_dst_id - sainfo id - dst:\n", a5, a6, a7, a8, v22);
      }
    }
    else if (dword_10008BA20)
    {
      v16 = ne_log_obj(a1);
      a1 = os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)a1)
        sub_100063674(&v23, v24, v16);
    }
    v17 = *(_QWORD *)(v13 + 40);
    if (!v17)
      goto LABEL_21;
    if (dword_1000882C8 >= 7)
      sub_10003372C(7, *(_QWORD *)(v17 + 8), *(_QWORD *)v17, "getsainfo_by_dst_id - sainfo id_i:\n", a5, a6, a7, a8, v22);
    if (!a2
      || (a1 = memcmp(*(const void **)(a2 + 8), *(const void **)(*(_QWORD *)(v13 + 40) + 8), **(_QWORD **)(v13 + 40)),
          (_DWORD)a1))
    {
      v14 = v15;
    }
    else
    {
LABEL_21:
      v14 = v13;
      if (*(_QWORD *)v13)
      {
        a1 = memcmp(*(const void **)(v9 + 8), *(const void **)(*(_QWORD *)(v13 + 8) + 8), **(_QWORD **)(v13 + 8));
        v14 = v15;
        if (!(_DWORD)a1)
          return v13;
      }
    }
    v13 = *(_QWORD *)(v13 + 120);
  }
  while (v13);
  if (v14)
  {
    if (dword_10008BA20)
    {
      v18 = ne_log_obj(a1);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        sub_100063640(v18, v19, v20);
    }
  }
  return v14;
}

double sub_10003A090()
{
  _QWORD *v0;
  double result;

  v0 = malloc_type_calloc(1uLL, 0x88uLL, 0x10A004085B85051uLL);
  if (v0)
  {
    v0[3] = 28800;
    *((_DWORD *)v0 + 8) = 0x7FFFFFFF;
    result = COERCE_DOUBLE(&_mh_execute_header);
    *(_QWORD *)((char *)v0 + 108) = &_mh_execute_header;
  }
  return result;
}

void sub_10003A0DC(_QWORD *a1)
{
  uint64_t i;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;

  for (i = 0; i != 7; ++i)
  {
    v3 = (_QWORD *)a1[i + 6];
    if (v3)
    {
      do
      {
        v4 = (_QWORD *)v3[1];
        free(v3);
        v3 = v4;
      }
      while (v4);
    }
  }
  if (*a1)
    sub_10003F318((_QWORD *)*a1);
  v5 = (_QWORD *)a1[1];
  if (v5)
    sub_10003F318(v5);
  v6 = (_QWORD *)a1[2];
  if (v6)
    sub_10003F318(v6);
  free(a1);
}

_QWORD *sub_10003A154(_QWORD *result)
{
  _QWORD *v1;

  if (result)
  {
    do
    {
      v1 = (_QWORD *)result[1];
      free(result);
      result = v1;
    }
    while (v1);
  }
  return result;
}

uint64_t sub_10003A180(uint64_t result)
{
  uint64_t v1;

  v1 = qword_100088E38;
  *(_QWORD *)(result + 120) = qword_100088E38;
  if (v1)
    *(_QWORD *)(v1 + 128) = result + 120;
  qword_100088E38 = result;
  *(_QWORD *)(result + 128) = &qword_100088E38;
  *(_DWORD *)(result + 108) = 1;
  return result;
}

uint64_t sub_10003A1B4(uint64_t result)
{
  uint64_t v1;

  if (*(_DWORD *)(result + 108))
  {
    v1 = *(_QWORD *)(result + 120);
    if (v1)
      *(_QWORD *)(v1 + 128) = *(_QWORD *)(result + 128);
    **(_QWORD **)(result + 128) = v1;
    *(_DWORD *)(result + 108) = 0;
  }
  return result;
}

void sub_10003A1DC()
{
  uint64_t v0;
  uint64_t v1;
  int v2;
  BOOL v3;

  v0 = qword_100088E38;
  while (v0)
  {
    v1 = v0;
    v0 = *(_QWORD *)(v0 + 120);
    if (!*(_DWORD *)(v1 + 104))
    {
      if (*(_DWORD *)(v1 + 108))
      {
        if (v0)
          *(_QWORD *)(v0 + 128) = *(_QWORD *)(v1 + 128);
        **(_QWORD **)(v1 + 128) = v0;
        *(_DWORD *)(v1 + 108) = 0;
      }
      v2 = *(_DWORD *)(v1 + 112);
      v3 = __OFSUB__(v2--, 1);
      *(_DWORD *)(v1 + 112) = v2;
      if ((v2 < 0) ^ v3 | (v2 == 0))
        sub_10003A0DC((_QWORD *)v1);
    }
  }
}

void sub_10003A248(int a1)
{
  uint64_t v1;
  uint64_t v3;
  int v4;
  BOOL v5;

  v1 = qword_100088E38;
  while (v1)
  {
    v3 = v1;
    v1 = *(_QWORD *)(v1 + 120);
    if (*(_DWORD *)(v3 + 104) == a1)
    {
      if (*(_DWORD *)(v3 + 108))
      {
        if (v1)
          *(_QWORD *)(v1 + 128) = *(_QWORD *)(v3 + 128);
        **(_QWORD **)(v3 + 128) = v1;
        *(_DWORD *)(v3 + 108) = 0;
      }
      v4 = *(_DWORD *)(v3 + 112);
      v5 = __OFSUB__(v4--, 1);
      *(_DWORD *)(v3 + 112) = v4;
      if ((v4 < 0) ^ v5 | (v4 == 0))
        sub_10003A0DC((_QWORD *)v3);
    }
  }
}

uint64_t sub_10003A2BC(uint64_t result)
{
  ++*(_DWORD *)(result + 112);
  return result;
}

void sub_10003A2CC(_QWORD *a1)
{
  int v1;
  BOOL v2;
  uint64_t v3;

  v1 = *((_DWORD *)a1 + 28);
  v2 = __OFSUB__(v1--, 1);
  *((_DWORD *)a1 + 28) = v1;
  if ((v1 < 0) ^ v2 | (v1 == 0))
  {
    if (*((_DWORD *)a1 + 27))
    {
      v3 = a1[15];
      if (v3)
        *(_QWORD *)(v3 + 128) = a1[16];
      *(_QWORD *)a1[16] = v3;
      *((_DWORD *)a1 + 27) = 0;
    }
    sub_10003A0DC(a1);
  }
}

void sub_10003A308()
{
  qword_100088E38 = 0;
}

void *sub_10003A314()
{
  return malloc_type_calloc(1uLL, 0x10uLL, 0x10200405730B0C9uLL);
}

uint64_t *sub_10003A330(uint64_t *result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *result;
  while (v2)
  {
    v3 = v2;
    v2 = *(_QWORD *)(v2 + 8);
    if (!v2)
    {
      result = (uint64_t *)(v3 + 8);
      break;
    }
  }
  *result = a2;
  return result;
}

uint64_t *sub_10003A350(uint64_t *a1)
{
  uint64_t v2;
  const char *v3;
  char *v4;
  uint64_t v5;
  char *v6;
  char *v7;
  size_t v8;
  size_t v9;
  uint64_t v10;
  char *v11;
  char *v12;
  size_t v13;

  v2 = *a1;
  if (v2)
  {
    v3 = sub_10001102C(v2);
    if (v3)
    {
      v4 = (char *)v3;
      snprintf((char *)&qword_100088E40, 0x100uLL, "%s", v3);
      free(v4);
    }
    v5 = a1[1];
    if (v5)
    {
      v6 = sub_10001102C(v5);
      if (v6)
      {
        v7 = v6;
        v8 = strlen((const char *)&qword_100088E40);
        snprintf((char *)&qword_100088E40 + v8, 256 - v8, " %s", v7);
        free(v7);
      }
    }
    else
    {
      v9 = strlen((const char *)&qword_100088E40);
      snprintf((char *)&qword_100088E40 + v9, 256 - v9, " anonymous");
    }
  }
  else
  {
    strcpy((char *)&qword_100088E40, "anonymous");
  }
  v10 = a1[5];
  if (v10)
  {
    v11 = sub_10001102C(v10);
    if (v11)
    {
      v12 = v11;
      v13 = strlen((const char *)&qword_100088E40);
      snprintf((char *)&qword_100088E40 + v13, 256 - v13, " from %s", v12);
      free(v12);
    }
  }
  return &qword_100088E40;
}

void sub_10003A490(_DWORD *a1)
{
  uint64_t v2;
  _QWORD *v3;
  void (*v4)(_QWORD);

  if (xmmword_10008C6E0 != 0)
    a1[8] = 1;
  v2 = *((_QWORD *)a1 + 5);
  v3 = (_QWORD *)*((_QWORD *)a1 + 6);
  if (v2)
  {
    *(_QWORD *)(v2 + 48) = v3;
    v3 = (_QWORD *)*((_QWORD *)a1 + 6);
  }
  else
  {
    qword_100088F48 = *((_QWORD *)a1 + 6);
  }
  *v3 = v2;
  if (!a1[8])
  {
    v4 = (void (*)(_QWORD))*((_QWORD *)a1 + 2);
    if (v4)
    {
      if (!dword_10008BE28)
        v4(*((_QWORD *)a1 + 3));
    }
  }
  free(a1);
}

_QWORD *sub_10003A520(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *result;
  _QWORD *v7;
  int v8;
  _QWORD *v9;
  dispatch_time_t v10;
  _QWORD v11[5];
  time_t v12;

  if (!dword_1000882D0)
    dword_1000882D0 = 1;
  result = malloc_type_malloc(0x38uLL, 0x10A0040F0AD93B6uLL);
  if (result)
  {
    v7 = result;
    v8 = dword_1000882D0++;
    *(_DWORD *)result = v8;
    *((_DWORD *)result + 8) = 0;
    result[2] = a2;
    result[3] = a3;
    v12 = 0;
    result[1] = time(&v12) + a1;
    v7[5] = 0;
    v9 = (_QWORD *)qword_100088F48;
    v7[6] = qword_100088F48;
    *v9 = v7;
    qword_100088F48 = (uint64_t)(v7 + 5);
    v10 = dispatch_time(0, 1000000000 * a1);
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000;
    v11[2] = sub_10003A654;
    v11[3] = &unk_1000850C8;
    v11[4] = v7;
    dispatch_after(v10, (dispatch_queue_t)&_dispatch_main_q, v11);
    return (_QWORD *)*(unsigned int *)v7;
  }
  return result;
}

time_t sub_10003A630()
{
  time_t v1;

  v1 = 0;
  return time(&v1);
}

void sub_10003A654(uint64_t a1)
{
  sub_10003A490(*(_DWORD **)(a1 + 32));
}

BOOL sub_10003A65C(int a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = 1;
  if (a1)
  {
    v2 = qword_100088F40;
    if (qword_100088F40)
    {
      while (*(_DWORD *)v2 != a1)
      {
        v2 = *(_QWORD *)(v2 + 40);
        if (!v2)
          return 1;
      }
      return *(_DWORD *)(v2 + 32) != 0;
    }
  }
  return v1;
}

uint64_t sub_10003A6A0(int a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = 0;
  if (a1)
  {
    v3 = qword_100088F40;
    if (qword_100088F40)
    {
      while (*(_DWORD *)v3 != a1)
      {
        v3 = *(_QWORD *)(v3 + 40);
        if (!v3)
          return 0;
      }
      if (*(_DWORD *)(v3 + 32))
        return 0;
      *a2 = *(_QWORD *)(v3 + 8);
      return 1;
    }
  }
  return v2;
}

uint64_t sub_10003A6F0(uint64_t result)
{
  uint64_t v1;

  if ((_DWORD)result)
  {
    v1 = qword_100088F40;
    if (qword_100088F40)
    {
      while (*(_DWORD *)v1 != (_DWORD)result)
      {
        v1 = *(_QWORD *)(v1 + 40);
        if (!v1)
          return result;
      }
      *(_DWORD *)(v1 + 32) = 1;
    }
  }
  return result;
}

void sub_10003A724()
{
  uint64_t i;

  for (i = qword_100088F40; i; i = *(_QWORD *)(i + 40))
    *(_DWORD *)(i + 32) = 1;
}

uint64_t sub_10003A744(uint64_t result)
{
  uint64_t i;

  for (i = qword_100088F40; i; i = *(_QWORD *)(i + 40))
  {
    if (*(_QWORD *)(i + 24) == result)
      *(_DWORD *)(i + 32) = 1;
  }
  return result;
}

void sub_10003A770()
{
  qword_100088F40 = 0;
  qword_100088F48 = (uint64_t)&qword_100088F40;
}

uint64_t sub_10003A780(unsigned int a1)
{
  unsigned __int8 v1;
  uint64_t v2;
  NSObject *v3;
  uint64_t v5;

  if (dword_10008B860)
  {
    v1 = a1;
    v5 = a1;
    v2 = vproc_swap_integer(0, 7, &v5, &qword_1000882D8);
    if (v2)
    {
      if (dword_10008BA20)
      {
        v3 = ne_log_obj(v2);
        if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
          sub_1000636DC(v1, v3);
      }
    }
  }
  return qword_1000882D8;
}

void sub_10003A814()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t Session;
  pid_t v3;
  const void *v4;
  __CFArray *Mutable;
  __CFDictionary *v6;
  _BOOL4 v7;
  __CFDictionary *v8;
  __CFDictionary *v9;
  __CFDictionary *v10;
  __CFDictionary *v11;
  _BOOL4 v12;
  __CFDictionary *v13;
  BOOL v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t i;
  const char *v24;
  FILE *v25;
  NSObject *v26;
  NSObject *v27;
  _BOOL8 v28;
  int *v29;
  char *v30;
  NSObject *v31;
  const char *v32;
  FILE *v33;
  int v34;
  uint64_t v35;
  NSObject *v36;
  int *v37;
  char *v38;
  uint8_t buf[4];
  sigaction *p_buffer;
  sigaction buffer;
  uint64_t v42;

  qword_10008BE30 = (uint64_t)&_dispatch_main_q;
  sub_10003A770();
  v0 = sub_10004F104();
  if ((v0 & 0x80000000) != 0)
  {
    if (!dword_10008BA20)
      goto LABEL_60;
    v31 = ne_log_obj(v0);
    if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      goto LABEL_60;
    LOWORD(buffer.__sigaction_u.__sa_handler) = 0;
    v32 = "failed to initialize power-mgmt.";
    goto LABEL_59;
  }
  if (*(_DWORD *)(qword_10008B848 + 112) == 1)
  {
    v1 = sub_100007CB8();
    if ((_DWORD)v1)
    {
      if (!dword_10008BA20)
        goto LABEL_60;
      v31 = ne_log_obj(v1);
      if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
        goto LABEL_60;
      LOWORD(buffer.__sigaction_u.__sa_handler) = 0;
      v32 = "failed to initialize route socket.\n";
      goto LABEL_59;
    }
  }
  Session = NEPolicyCreateSession(kCFAllocatorDefault, CFSTR("racoon"), 0, 0);
  qword_100088FE0 = Session;
  if (!Session)
    goto LABEL_23;
  v42 = 0;
  memset(&buffer, 0, 48);
  v3 = getpid();
  Session = proc_pidinfo(v3, 17, 1uLL, &buffer, 56);
  if ((_DWORD)Session != 56)
    goto LABEL_23;
  Session = (uint64_t)CFUUIDCreateFromUUIDBytes(kCFAllocatorDefault, (CFUUIDBytes)buffer);
  if (!Session)
    goto LABEL_23;
  v4 = (const void *)Session;
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (!Mutable)
    goto LABEL_11;
  v6 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v7 = v6 != 0;
  if (v6)
  {
    v8 = v6;
    CFDictionarySetValue(v6, CFSTR("ConditionType"), CFSTR("Application"));
    CFDictionarySetValue(v8, CFSTR("ApplicationUUID"), v4);
    CFArrayAppendValue(Mutable, v8);
    CFRelease(v8);
  }
  v9 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v9)
  {
    v10 = v9;
    CFDictionarySetValue(v9, CFSTR("ConditionType"), CFSTR("AllInterfaces"));
    CFArrayAppendValue(Mutable, v10);
    CFRelease(v10);
  }
  else
  {
LABEL_11:
    v7 = 0;
  }
  v11 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v11)
  {
    v13 = v11;
    CFDictionaryAddValue(v11, CFSTR("Result"), CFSTR("Pass"));
    v12 = v7 && NEPolicyAdd(qword_100088FE0, 0, Mutable, v13, 0) != 0;
    CFRelease(v13);
    if (!Mutable)
    {
LABEL_21:
      CFRelease(v4);
      if (v12)
      {
        Session = NEPolicyApply(qword_100088FE0);
        v14 = (_DWORD)Session != 0;
LABEL_24:
        if (!v14)
        {
          if (dword_10008BA20)
          {
            v15 = ne_log_obj(Session);
            if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
            {
              LOWORD(buffer.__sigaction_u.__sa_handler) = 0;
              _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "failed to initialize NEPolicy session.\n", (uint8_t *)&buffer, 2u);
            }
          }
        }
        v16 = sub_1000079FC();
        if ((_DWORD)v16)
        {
          if (!dword_10008BA20)
            goto LABEL_60;
          v31 = ne_log_obj(v16);
          if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
            goto LABEL_60;
          LOWORD(buffer.__sigaction_u.__sa_handler) = 0;
          v32 = "failed to initialize listening addresses.\n";
        }
        else
        {
          v17 = sub_1000232E4();
          if ((_DWORD)v17)
          {
            if (!dword_10008BA20)
              goto LABEL_60;
            v31 = ne_log_obj(v17);
            if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
              goto LABEL_60;
            LOWORD(buffer.__sigaction_u.__sa_handler) = 0;
            v32 = "failed to initialize isakmp";
          }
          else
          {
            v18 = sub_1000490E8();
            if ((_DWORD)v18)
            {
              if (dword_10008BA20)
              {
                v19 = ne_log_obj(v18);
                if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
                {
                  LOWORD(buffer.__sigaction_u.__sa_handler) = 0;
                  _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "failed to initialize vpn control port", (uint8_t *)&buffer, 2u);
                }
              }
            }
            v20 = 0;
            while (1)
            {
              v21 = dword_10006A280[v20];
              buffer.__sigaction_u.__sa_handler = (void (__cdecl *)(int))sub_10003B2C0;
              *(_QWORD *)&buffer.sa_mask = 0x4200000000;
              v22 = sigaction(v21, &buffer, 0);
              if ((v22 & 0x80000000) != 0)
                break;
              if (++v20 == 6)
              {
                for (i = 0; i != 33; ++i)
                  dword_100088F50[i] = 0;
                if (dword_10008B9F0)
                  goto LABEL_49;
                dword_10008B85C = getpid();
                v24 = *(const char **)(qword_10008B848 + 160);
                if (!v24)
                {
                  v24 = "/var/run/racoon.pid";
                  goto LABEL_43;
                }
                if (*v24 == 47)
                {
LABEL_43:
                  __strlcpy_chk(&buffer, v24, 1024, 1024);
                }
                else
                {
                  __strlcat_chk(&buffer, "/var/run/", 1024, 1024);
                  __strlcat_chk(&buffer, *(_QWORD *)(qword_10008B848 + 160), 1024, 1024);
                }
                v25 = fopen((const char *)&buffer, "w");
                if (v25)
                {
                  v33 = v25;
                  v34 = fileno(v25);
                  v35 = fchmod(v34, 0x1A4u);
                  if ((_DWORD)v35 != -1)
                  {
                    fprintf(v33, "%ld\n", dword_10008B85C);
                    fclose(v33);
                    goto LABEL_49;
                  }
                  if (dword_10008BA20)
                  {
                    v36 = ne_log_obj(v35);
                    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
                    {
                      v37 = __error();
                      v38 = strerror(*v37);
                      *(_DWORD *)buf = 136315138;
                      p_buffer = (sigaction *)v38;
                      _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "%s", buf, 0xCu);
                    }
                  }
                  fclose(v33);
                }
                else
                {
                  if (dword_10008BA20)
                  {
                    v26 = ne_log_obj(0);
                    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)buf = 136315138;
                      p_buffer = &buffer;
                      _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "cannot open %s", buf, 0xCu);
                    }
                  }
LABEL_49:
                  if (!qword_100088FD8)
                    qword_100088FD8 = os_transaction_create("IKEv1_Transaction");
                  if (!dword_10008BE28)
                    dispatch_main();
                }
LABEL_60:
                exit(1);
              }
            }
            if (!dword_10008BA20)
              goto LABEL_60;
            v27 = ne_log_obj(v22);
            v28 = os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
            if (v28)
            {
              v29 = __error();
              v30 = strerror(*v29);
              LODWORD(buffer.__sigaction_u.__sa_handler) = 136315138;
              *(void (__cdecl **)(int, __siginfo *, void *))((char *)&buffer.__sigaction_u.__sa_sigaction + 4) = (void (__cdecl *)(int, __siginfo *, void *))v30;
              _os_log_error_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "failed to set_signal (%s)\n", (uint8_t *)&buffer, 0xCu);
            }
            if (!dword_10008BA20)
              goto LABEL_60;
            v31 = ne_log_obj(v28);
            if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
              goto LABEL_60;
            LOWORD(buffer.__sigaction_u.__sa_handler) = 0;
            v32 = "failed to initialize signals.\n";
          }
        }
LABEL_59:
        _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, v32, (uint8_t *)&buffer, 2u);
        goto LABEL_60;
      }
LABEL_23:
      v14 = 0;
      goto LABEL_24;
    }
  }
  else
  {
    v12 = 0;
    if (!Mutable)
      goto LABEL_21;
  }
  CFRelease(Mutable);
  goto LABEL_21;
}

void sub_10003AEAC()
{
  int v0;
  _BOOL8 v1;
  uint64_t v2;
  unsigned int v3;
  _BOOL8 v4;
  uint64_t v5;

  v0 = *(_DWORD *)(qword_10008B848 + 80);
  if (*(_DWORD *)(qword_10008B848 + 88))
  {
    if (v0 != 17
      || sub_100049594()
      || sub_10004F714()
      || (v1 = sub_100035280())
      || !sub_100038560(v1))
    {
      v2 = *(unsigned int *)(qword_10008B848 + 88);
      if ((_DWORD)v2)
      {
        sub_10003A6F0(v2);
        v3 = 0;
LABEL_8:
        *(_DWORD *)(qword_10008B848 + 88) = v3;
      }
    }
  }
  else if (v0 == 17 && !sub_100049594() && !sub_10004F714())
  {
    v4 = sub_100035280();
    if (!v4)
    {
      if (sub_100038560(v4))
      {
        v5 = *(int *)(qword_10008B848 + 84);
        if (!(_DWORD)v5)
          sub_10003AF6C(v5);
        v3 = sub_10003A520(v5, (uint64_t)sub_10003AF6C, 0);
        goto LABEL_8;
      }
    }
  }
}

void sub_10003AF6C(uint64_t a1)
{
  NSObject *v1;
  uint8_t v2[16];

  if (dword_10008BA20)
  {
    v1 = ne_log_obj(a1);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v2 = 0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "performing auto exit\n", v2, 2u);
    }
  }
  sub_10003B214();
}

void sub_10003AFCC(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint8_t buf[4];
  int v22;

  v1 = 0;
  while (1)
  {
    if (!dword_100088F50[v1])
      goto LABEL_23;
    --dword_100088F50[v1];
    if ((int)v1 > 1)
    {
      if ((_DWORD)v1 != 30)
      {
        if ((_DWORD)v1 == 2 || (_DWORD)v1 == 15)
        {
          if (dword_10008BA20)
          {
            v12 = ne_log_obj(a1);
            if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 67109120;
              v22 = v1;
              _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "caught signal %d\n", buf, 8u);
            }
          }
LABEL_31:
          sub_10003B214();
        }
        goto LABEL_20;
      }
    }
    else if ((_DWORD)v1 != 1)
    {
      if (!(_DWORD)v1)
        return;
LABEL_20:
      if (dword_10008BA20)
      {
        v3 = ne_log_obj(a1);
        a1 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
        if ((_DWORD)a1)
        {
          *(_DWORD *)buf = 67109120;
          v22 = v1;
          _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "caught signal %d\n", buf, 8u);
        }
      }
      goto LABEL_23;
    }
    a1 = sub_100044DAC(0);
    if ((_DWORD)a1)
      break;
    if (!dword_10008BE28)
    {
      if (v1 == 1)
      {
        sub_10000928C(1);
        sub_100008954(1);
      }
      v2 = sub_100052680(v1);
      if ((_DWORD)v2)
      {
        if (dword_10008BA20)
        {
          v13 = ne_log_obj(v2);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
            sub_100063750(v13, v14, v15, v16, v17, v18, v19, v20);
        }
        exit(1);
      }
      if (!*(_QWORD *)(qword_10008B848 + 128) && !byte_10008BA24)
        sub_100033D88(*(char **)(qword_10008B848 + 168));
      a1 = sub_100038560(1);
      if ((_DWORD)a1)
        goto LABEL_31;
    }
LABEL_23:
    if (++v1 == 33)
      return;
  }
  if (dword_10008BA20)
  {
    v4 = ne_log_obj(a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      sub_100063780(v4, v5, v6, v7, v8, v9, v10, v11);
  }
}

void sub_10003B214()
{
  uint64_t v0;
  uint64_t v1;
  NSObject *v2;
  uint8_t v3[16];

  sub_10003A724();
  sub_10004F3B0();
  if (dword_10008BE28)
    sub_10000928C(0);
  sub_100008954(0);
  sub_100007C84();
  sub_100023E5C();
  sub_10002EF70();
  sub_1000494EC(v0);
  v1 = qword_100088FD8;
  if (qword_100088FD8)
  {
    os_release((void *)qword_100088FD8);
    qword_100088FD8 = 0;
  }
  if (dword_10008BA20)
  {
    v2 = ne_log_obj(v1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v3 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "racoon shutdown\n", v3, 2u);
    }
  }
  exit(0);
}

void sub_10003B2C0(int a1)
{
  ++dword_100088F50[a1];
  if (a1 == 15)
    dword_10008BE28 = 1;
  dword_10008BE2C = 1;
  dispatch_async((dispatch_queue_t)qword_10008BE30, &stru_100085108);
}

void sub_10003B308(id a1)
{
  if (dword_10008BE2C)
  {
    sub_10003AFCC((uint64_t)a1);
    dword_10008BE2C = 0;
  }
}

void sub_10003B334()
{
  sub_10003B214();
}

void sub_10003B340()
{
  uint64_t v0;
  NSObject *v1;
  NSObject *v2;

  v0 = qword_10008B848;
  v1 = *(NSObject **)(qword_10008B848 + 56);
  if (v1)
  {
    dispatch_suspend(v1);
    v0 = qword_10008B848;
  }
  v2 = *(NSObject **)(v0 + 40);
  if (v2)
    dispatch_suspend(v2);
  sub_100023F98();
}

uint64_t sub_10003B380(unint64_t a1, unint64_t a2)
{
  uint64_t v2;
  int v3;
  int v4;
  int v5;

  v2 = a1 | a2;
  if (a1 | a2)
  {
    v2 = 1;
    if (a1)
    {
      if (a2)
      {
        if (*(unsigned __int8 *)a1 == *(unsigned __int8 *)a2)
        {
          v3 = *(unsigned __int8 *)(a1 + 1);
          if (v3 == *(unsigned __int8 *)(a2 + 1))
          {
            if (v3 == 30)
            {
              if (*(_QWORD *)(a1 + 8) == *(_QWORD *)(a2 + 8) && *(_QWORD *)(a1 + 16) == *(_QWORD *)(a2 + 16))
              {
                v4 = *(_DWORD *)(a1 + 24);
                v5 = *(_DWORD *)(a2 + 24);
LABEL_15:
                if (v4 == v5)
                  return 0;
              }
            }
            else if (v3 == 2)
            {
              v4 = *(_DWORD *)(a1 + 4);
              v5 = *(_DWORD *)(a2 + 4);
              goto LABEL_15;
            }
          }
        }
        return 1;
      }
    }
  }
  return v2;
}

BOOL sub_10003B408(unint64_t a1, unint64_t a2, int a3)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  unsigned int v6;
  BOOL v7;

  v3 = a1 | a2;
  if (a1 | a2)
  {
    v3 = 1;
    if (a1)
    {
      if (a2)
      {
        if (*(unsigned __int8 *)a1 != *(unsigned __int8 *)a2)
          return 1;
        v4 = *(unsigned __int8 *)(a1 + 1);
        if (v4 != *(unsigned __int8 *)(a2 + 1))
          return 1;
        if (v4 != 2)
        {
          if (v4 == 30)
          {
            v5 = 0;
            while (1)
            {
              v6 = -1 << -(char)a3;
              if (!a3)
                v6 = 0;
              v7 = a3 < 32;
              if (a3 >= 32)
                a3 -= 32;
              else
                a3 = 0;
              if (!v7)
                v6 = -1;
              if (((*(_DWORD *)(a1 + 8 + v5) ^ *(_DWORD *)(a2 + 8 + v5)) & bswap32(v6)) != 0)
                break;
              v5 += 4;
              if (v5 == 16)
                return *(_DWORD *)(a1 + 24) != *(_DWORD *)(a2 + 24);
            }
          }
          return 1;
        }
        return ((*(_DWORD *)(a1 + 4) ^ *(_DWORD *)(a2 + 4)) & bswap32(-1 << -(char)a3)) != 0;
      }
    }
  }
  return v3;
}

uint64_t sub_10003B4E8(unint64_t a1, unint64_t a2)
{
  uint64_t v2;
  int v3;
  int v4;
  int v5;

  v2 = a1 | a2;
  if (a1 | a2)
  {
    v2 = 1;
    if (a1)
    {
      if (a2)
      {
        if (*(unsigned __int8 *)a1 == *(unsigned __int8 *)a2)
        {
          v3 = *(unsigned __int8 *)(a1 + 1);
          if (v3 == *(unsigned __int8 *)(a2 + 1))
          {
            if (v3 == 30)
            {
              if ((!*(_WORD *)(a1 + 2)
                 || !*(_WORD *)(a2 + 2)
                 || *(unsigned __int16 *)(a1 + 2) == *(unsigned __int16 *)(a2 + 2))
                && *(_QWORD *)(a1 + 8) == *(_QWORD *)(a2 + 8)
                && *(_QWORD *)(a1 + 16) == *(_QWORD *)(a2 + 16))
              {
                v4 = *(_DWORD *)(a1 + 24);
                v5 = *(_DWORD *)(a2 + 24);
LABEL_21:
                if (v4 == v5)
                  return 0;
              }
            }
            else if (v3 == 2
                   && (!*(_WORD *)(a1 + 2)
                    || !*(_WORD *)(a2 + 2)
                    || *(unsigned __int16 *)(a1 + 2) == *(unsigned __int16 *)(a2 + 2)))
            {
              v4 = *(_DWORD *)(a1 + 4);
              v5 = *(_DWORD *)(a2 + 4);
              goto LABEL_21;
            }
          }
        }
        return 1;
      }
    }
  }
  return v2;
}

uint64_t sub_10003B5A0(unint64_t a1, unint64_t a2)
{
  uint64_t v2;
  int v3;
  int v4;
  int v5;

  v2 = a1 | a2;
  if (a1 | a2)
  {
    v2 = 1;
    if (a1)
    {
      if (a2)
      {
        if (*(unsigned __int8 *)a1 == *(unsigned __int8 *)a2)
        {
          v3 = *(unsigned __int8 *)(a1 + 1);
          if (v3 == *(unsigned __int8 *)(a2 + 1))
          {
            if (v3 == 30)
            {
              if (*(unsigned __int16 *)(a1 + 2) == *(unsigned __int16 *)(a2 + 2)
                && *(_QWORD *)(a1 + 8) == *(_QWORD *)(a2 + 8)
                && *(_QWORD *)(a1 + 16) == *(_QWORD *)(a2 + 16))
              {
                v4 = *(_DWORD *)(a1 + 24);
                v5 = *(_DWORD *)(a2 + 24);
LABEL_17:
                if (v4 == v5)
                  return 0;
              }
            }
            else if (v3 == 2 && *(unsigned __int16 *)(a1 + 2) == *(unsigned __int16 *)(a2 + 2))
            {
              v4 = *(_DWORD *)(a1 + 4);
              v5 = *(_DWORD *)(a2 + 4);
              goto LABEL_17;
            }
          }
        }
        return 1;
      }
    }
  }
  return v2;
}

BOOL sub_10003B648(unint64_t a1, unint64_t a2, int a3)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  unsigned int v6;
  BOOL v7;

  v3 = a1 | a2;
  if (a1 | a2)
  {
    v3 = 1;
    if (a1)
    {
      if (a2)
      {
        if (*(unsigned __int8 *)a1 == *(unsigned __int8 *)a2)
        {
          v4 = *(unsigned __int8 *)(a1 + 1);
          if (v4 == *(unsigned __int8 *)(a2 + 1))
          {
            if (v4 == 30)
            {
              if (*(unsigned __int16 *)(a1 + 2) == *(unsigned __int16 *)(a2 + 2))
              {
                v5 = 0;
                while (1)
                {
                  v6 = -1 << -(char)a3;
                  if (!a3)
                    v6 = 0;
                  v7 = a3 < 32;
                  if (a3 >= 32)
                    a3 -= 32;
                  else
                    a3 = 0;
                  if (!v7)
                    v6 = -1;
                  if (((*(_DWORD *)(a1 + 8 + v5) ^ *(_DWORD *)(a2 + 8 + v5)) & bswap32(v6)) != 0)
                    break;
                  v5 += 4;
                  if (v5 == 16)
                    return *(_DWORD *)(a1 + 24) != *(_DWORD *)(a2 + 24);
                }
              }
            }
            else if (v4 == 2
                   && *(unsigned __int16 *)(a1 + 2) == *(unsigned __int16 *)(a2 + 2)
                   && ((*(_DWORD *)(a1 + 4) ^ *(_DWORD *)(a2 + 4)) & bswap32(-1 << -(char)a3)) == 0)
            {
              return 0;
            }
          }
        }
        return 1;
      }
    }
  }
  return v3;
}

sockaddr *sub_10003B74C(const sockaddr *a1)
{
  sockaddr *v2;
  sockaddr *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v15;
  socklen_t v16;

  v16 = 128;
  v2 = (sockaddr *)malloc_type_calloc(1uLL, 0x80uLL, 0x4F296885uLL);
  if (!v2)
  {
    if (dword_10008BA20)
    {
      v11 = ne_log_obj(0);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        sub_1000637B0();
    }
    return 0;
  }
  v3 = v2;
  v4 = socket(a1->sa_family, 2, 0);
  if ((v4 & 0x80000000) != 0)
  {
    if (dword_10008BA20)
    {
      v12 = ne_log_obj(v4);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        sub_1000637DC();
    }
    goto LABEL_22;
  }
  v5 = v4;
  v6 = fcntl(v4, 4, 4);
  if ((_DWORD)v6 == -1 && dword_10008BA20 != 0)
  {
    v8 = ne_log_obj(v6);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      sub_100063920();
  }
  sub_10003B918(v5, a1->sa_family);
  v9 = connect(v5, a1, a1->sa_len);
  if ((v9 & 0x80000000) != 0)
  {
    if (dword_10008BA20)
    {
      v13 = ne_log_obj(v9);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        sub_100063848();
    }
    close(v5);
LABEL_22:
    free(v3);
    return 0;
  }
  v10 = getsockname(v5, v3, &v16);
  if ((v10 & 0x80000000) != 0)
  {
    if (dword_10008BA20)
    {
      v15 = ne_log_obj(v10);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        sub_1000638B4();
    }
    close(v5);
    return 0;
  }
  close(v5);
  return v3;
}

uint64_t sub_10003B918(uint64_t a1, uint64_t a2)
{
  int v2;
  int v4;
  int v5;
  char *v6;
  char *v7;
  socklen_t policylen;
  uint64_t v9;
  char *v10;
  char *v11;
  socklen_t v12;
  uint64_t v13;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  NSObject *v25;

  v2 = a1;
  if ((_DWORD)a2 == 2)
  {
    v4 = 0;
    v5 = 21;
  }
  else
  {
    if ((_DWORD)a2 != 30)
    {
      if (dword_10008BA20)
      {
        v15 = ne_log_obj(a1);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          sub_10006394C(a2, v15, v16, v17, v18, v19, v20, v21);
      }
      return 0xFFFFFFFFLL;
    }
    v4 = 41;
    v5 = 28;
  }
  v6 = ipsec_set_policy("in bypass", 9);
  if (!v6)
  {
    if (!dword_10008BA20)
      return 0xFFFFFFFFLL;
    v22 = ne_log_obj(0);
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      return 0xFFFFFFFFLL;
LABEL_15:
    sub_1000639B0();
    return 0xFFFFFFFFLL;
  }
  v7 = v6;
  policylen = ipsec_get_policylen(v6);
  v9 = setsockopt(v2, v4, v5, v7, policylen);
  if ((v9 & 0x80000000) != 0)
  {
    if (!dword_10008BA20)
      return 0xFFFFFFFFLL;
    v23 = ne_log_obj(v9);
    if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      return 0xFFFFFFFFLL;
    goto LABEL_24;
  }
  free(v7);
  v10 = ipsec_set_policy("out bypass", 10);
  if (!v10)
  {
    if (!dword_10008BA20)
      return 0xFFFFFFFFLL;
    v24 = ne_log_obj(0);
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      return 0xFFFFFFFFLL;
    goto LABEL_15;
  }
  v11 = v10;
  v12 = ipsec_get_policylen(v10);
  v13 = setsockopt(v2, v4, v5, v11, v12);
  if ((v13 & 0x80000000) == 0)
  {
    free(v11);
    return 0;
  }
  if (dword_10008BA20)
  {
    v25 = ne_log_obj(v13);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
LABEL_24:
      sub_100063A1C();
  }
  return 0xFFFFFFFFLL;
}

ssize_t sub_10003BAE4(int a1, uint64_t a2, unint64_t a3, int a4, void *a5, socklen_t *a6, uint64_t a7, unsigned int *a8)
{
  uint64_t v16;
  ssize_t result;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int *v22;
  NSObject *v23;
  NSObject *v24;
  unsigned int v25;
  unsigned int *msg_control;
  int sa_family;
  unsigned int *v29;
  __int16 v30;
  unsigned int v32;
  unsigned int *v34;
  BOOL v35;
  char v36;
  msghdr v37;
  socklen_t v38[2];
  _OWORD v39[16];
  _QWORD v40[4];
  sockaddr v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;

  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  v43 = 0u;
  v44 = 0u;
  v41 = (sockaddr)0;
  v42 = 0u;
  memset(&v37.msg_namelen, 0, 24);
  *(_QWORD *)v38 = 128;
  v16 = getsockname(a1, &v41, v38);
  if ((v16 & 0x80000000) != 0)
  {
    if (dword_10008BA20)
    {
      v24 = ne_log_obj(v16);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        sub_1000638B4();
    }
    return 0xFFFFFFFFLL;
  }
  else
  {
    v37.msg_name = a5;
    v37.msg_namelen = *a6;
    v40[0] = a2;
    v40[1] = a3;
    v37.msg_iov = (iovec *)v40;
    v37.msg_iovlen = 1;
    memset(v39, 0, sizeof(v39));
    v37.msg_control = v39;
    *(_QWORD *)&v37.msg_controllen = 256;
    while (1)
    {
      result = recvmsg(a1, &v37, a4);
      *(_QWORD *)v38 = result;
      if ((result & 0x8000000000000000) == 0)
        break;
      v22 = __error();
      if (*v22 != 4)
      {
        if (dword_10008BA20)
        {
          v23 = ne_log_obj(v22);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
            sub_100063A88();
        }
        return 0xFFFFFFFFLL;
      }
    }
    if (result)
    {
      *a6 = v37.msg_namelen;
      v25 = *a8;
      *a8 = 0;
      msg_control = (unsigned int *)v37.msg_control;
      if (v37.msg_controllen >= 0xC && v37.msg_control != 0)
      {
        sa_family = v41.sa_family;
        v29 = (unsigned int *)((char *)v37.msg_control + v37.msg_controllen);
        v30 = *(_WORD *)v41.sa_data;
        do
        {
          if (sa_family == 2)
          {
            if (msg_control[1])
              goto LABEL_40;
            if (msg_control[2] != 7 || v25 < 0x10)
              goto LABEL_40;
            *a8 = 16;
            *(_QWORD *)a7 = 0;
            *(_QWORD *)(a7 + 8) = 0;
            *(_WORD *)a7 = 528;
            *(_DWORD *)(a7 + 4) = msg_control[3];
          }
          else
          {
            if (sa_family != 30 || msg_control[1] != 41)
              goto LABEL_40;
            if (msg_control[2] != 46 || v25 < 0x1C)
              goto LABEL_40;
            v32 = 0;
            *a8 = 28;
            *(_QWORD *)a7 = 0;
            *(_QWORD *)(a7 + 8) = 0;
            *(_DWORD *)(a7 + 24) = 0;
            *(_QWORD *)(a7 + 16) = 0;
            *(_WORD *)a7 = 7708;
            *(_OWORD *)(a7 + 8) = *(_OWORD *)(msg_control + 3);
            if (*(unsigned __int8 *)(a7 + 8) == 254)
            {
              if ((*(_BYTE *)(a7 + 9) & 0xC0) == 0x80)
                v32 = msg_control[7];
              else
                v32 = 0;
            }
            *(_DWORD *)(a7 + 24) = v32;
          }
          *(_WORD *)(a7 + 2) = v30;
          v25 = -1;
LABEL_40:
          v34 = (unsigned int *)((char *)msg_control + ((*msg_control + 3) & 0x1FFFFFFFCLL));
          if (v34 + 3 <= v29)
          {
            v35 = v34 == msg_control;
          }
          else
          {
            v34 = 0;
            v35 = 1;
          }
          msg_control = v34;
        }
        while (!v35);
      }
      if (dword_1000882C8 >= 7)
      {
        sub_10003372C(7, a2, a3, "@@@@@@ data from readmsg:\n", v18, v19, v20, v21, v36);
        return *(_QWORD *)v38;
      }
    }
  }
  return result;
}

uint64_t sub_10003BDE0(uint64_t a1, const void *a2, unint64_t a3, unsigned __int8 *a4, unsigned __int8 *a5, int a6)
{
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;
  int v16;
  int v17;
  NSObject *v18;
  NSObject *v19;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  NSObject *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  ssize_t v34;
  int v35;
  NSObject *v36;
  NSObject *v37;
  NSObject *v38;
  socklen_t v39;
  NSObject *v40;
  _BOOL8 v41;
  NSObject *v42;
  int v43;
  ssize_t v44;
  NSObject *v45;
  NSObject *v46;
  socklen_t v47;
  NSObject *v49;
  NSObject *v50;
  NSObject *v51;
  NSObject *v52;
  char v53;
  int v54;
  _BYTE v55[28];
  _BYTE v56[28];
  socklen_t v57;
  uint8_t v58[4];
  int v59;
  __int16 v60;
  socklen_t v61;
  __int16 v62;
  uint64_t *v63;
  uint8_t buf[8];
  _BYTE v65[20];
  int v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  _QWORD v81[4];
  msghdr v82;
  sockaddr __s1;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;

  v89 = 0u;
  v90 = 0u;
  v87 = 0u;
  v88 = 0u;
  v85 = 0u;
  v86 = 0u;
  __s1 = (sockaddr)0;
  v84 = 0u;
  v57 = 0;
  if (a4[1] != a5[1])
  {
    if (dword_10008BA20)
    {
      v18 = ne_log_obj(a1);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        sub_100063DE0();
    }
    return 0xFFFFFFFFLL;
  }
  LODWORD(v11) = a1;
  v57 = 128;
  v12 = getsockname(a1, &__s1, &v57);
  if ((v12 & 0x80000000) != 0)
  {
    if (dword_10008BA20)
    {
      v19 = ne_log_obj(v12);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        sub_1000638B4();
    }
    return 0xFFFFFFFFLL;
  }
  if (dword_10008BA20)
  {
    v13 = ne_log_obj(v12);
    v12 = os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG);
    if ((_DWORD)v12)
      sub_100063EF4(&__s1);
    if (dword_10008BA20)
    {
      v14 = ne_log_obj(v12);
      v12 = os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)v12)
        sub_100063E80((const sockaddr *)a4);
      if (dword_10008BA20)
      {
        v15 = ne_log_obj(v12);
        v12 = os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG);
        if ((_DWORD)v12)
          sub_100063E0C((const sockaddr *)a5);
      }
    }
  }
  v16 = a4[1];
  if (v16 != __s1.sa_family)
  {
    if (dword_10008BA20)
    {
      v20 = ne_log_obj(v12);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        sub_100063DE0();
    }
    return 0xFFFFFFFFLL;
  }
  if (v16 == 30)
  {
    *(_OWORD *)v56 = *(_OWORD *)a4;
    *(_OWORD *)&v56[12] = *(_OWORD *)(a4 + 12);
    *(_OWORD *)v55 = *(_OWORD *)a5;
    *(_OWORD *)&v55[12] = *(_OWORD *)(a5 + 12);
    if (v56[8] == 255 || v56[8] == 254 && (v56[9] & 0xC0) == 0x80)
      v17 = *(_DWORD *)&v56[24];
    else
      v17 = 0;
    *(_DWORD *)&v55[4] = 0;
    *(_DWORD *)&v56[4] = 0;
    *(_QWORD *)&v82.msg_namelen = 28;
    *(_QWORD *)&v82.msg_iovlen = 1;
    v82.msg_name = v55;
    v81[0] = a2;
    v81[1] = a3;
    v82.msg_iov = (iovec *)v81;
    v67 = 0u;
    v68 = 0u;
    v69 = 0u;
    v70 = 0u;
    v71 = 0u;
    v72 = 0u;
    v73 = 0u;
    v74 = 0u;
    v75 = 0u;
    v76 = 0u;
    v77 = 0u;
    v78 = 0u;
    v79 = 0u;
    v80 = 0u;
    v82.msg_control = buf;
    v82.msg_flags = 0;
    v82.msg_controllen = 32;
    *(_QWORD *)buf = 0x2900000020;
    *(_DWORD *)v65 = 46;
    *(_OWORD *)&v65[4] = *(_OWORD *)&v56[8];
    v66 = v17;
    if (dword_10008BA20)
    {
      v40 = ne_log_obj(v12);
      v41 = os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG);
      if (v41)
        sub_100063BC0((const sockaddr *)v56);
      if (dword_10008BA20)
      {
        v42 = ne_log_obj(v41);
        if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
          sub_100063B44((const sockaddr *)v55);
      }
    }
    if (a6 >= 1)
    {
      v43 = 0;
      while (1)
      {
        v44 = sendmsg(v11, &v82, 0);
        v57 = v44;
        if ((v44 & 0x80000000) != 0)
        {
          if (dword_10008BA20)
          {
            v45 = ne_log_obj(v44);
            if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
              sub_100063AF4();
          }
          v44 = (ssize_t)__error();
          if (*(_DWORD *)v44 != 65)
          {
            v44 = (ssize_t)__error();
            if (*(_DWORD *)v44 != 50)
            {
              v44 = (ssize_t)__error();
              if (*(_DWORD *)v44 != 51)
                return 0xFFFFFFFFLL;
            }
          }
          v57 = 0;
        }
        if (dword_10008BA20)
        {
          v46 = ne_log_obj(v44);
          if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
          {
            v47 = v57;
            sub_10003C570((const sockaddr *)a5);
            *(_DWORD *)v58 = 67109634;
            v59 = v43 + 1;
            v60 = 1024;
            v61 = v47;
            v62 = 2080;
            v63 = &qword_100088FE8;
            _os_log_debug_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEBUG, "%d times of %d bytes message will be sent to %s\n", v58, 0x18u);
          }
        }
        if (a6 == ++v43)
          return v57;
      }
    }
    return v57;
  }
  v25 = memcmp(&__s1, a4, *a4);
  if (!v25)
    goto LABEL_39;
  *(_DWORD *)buf = 1;
  v26 = socket(v16, 2, 0);
  if ((v26 & 0x80000000) != 0)
  {
    if (dword_10008BA20)
    {
      v49 = ne_log_obj(v26);
      if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
        sub_1000637DC();
    }
    return 0xFFFFFFFFLL;
  }
  v11 = v26;
  v53 = 4;
  v27 = fcntl(v26, 4);
  if ((_DWORD)v27 == -1)
  {
    if (dword_10008BA20)
    {
      v28 = ne_log_obj(v27);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        sub_100063DB4();
    }
  }
  v29 = setsockopt(v11, 0xFFFF, 512, buf, 4u);
  if ((v29 & 0x80000000) != 0)
  {
    if (dword_10008BA20)
    {
      v50 = ne_log_obj(v29);
      if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
        sub_100063CDC();
    }
    goto LABEL_97;
  }
  v30 = a4[1];
  if ((_DWORD)v30 == 30)
  {
    v31 = setsockopt(v11, 41, 42, buf, 4u);
    if ((v31 & 0x80000000) != 0)
    {
      if (dword_10008BA20)
      {
        v52 = ne_log_obj(v31);
        if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
          sub_10005C840();
      }
      goto LABEL_97;
    }
    v30 = a4[1];
  }
  if ((sub_10003B918(v11, v30) & 0x80000000) != 0)
    goto LABEL_97;
  v32 = bind(v11, (const sockaddr *)a4, *a4);
  if ((v32 & 0x80000000) != 0)
  {
    if (dword_10008BA20)
    {
      v51 = ne_log_obj(v32);
      if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
        sub_100063D48();
    }
LABEL_97:
    close(v11);
    return 0xFFFFFFFFLL;
  }
LABEL_39:
  if (dword_1000882C8 >= 7)
    sub_10003372C(7, (uint64_t)a2, a3, "@@@@@@ data being sent:\n", v21, v22, v23, v24, v53);
  if (a6 < 1)
  {
LABEL_81:
    if (v25)
      close(v11);
    return v57;
  }
  v33 = 0;
  v54 = v25;
  while (1)
  {
    v34 = sendto(v11, a2, a3, 0, (const sockaddr *)a5, *a5);
    v57 = v34;
    v35 = dword_10008BA20;
    if ((v34 & 0x80000000) != 0)
      break;
LABEL_54:
    if (v35)
    {
      v38 = ne_log_obj(v34);
      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
      {
        v39 = v57;
        sub_10003C570((const sockaddr *)a5);
        *(_DWORD *)buf = 67109634;
        *(_DWORD *)&buf[4] = v33 + 1;
        *(_WORD *)v65 = 1024;
        *(_DWORD *)&v65[2] = v39;
        v25 = v54;
        *(_WORD *)&v65[6] = 2080;
        *(_QWORD *)&v65[8] = &qword_100088FE8;
        _os_log_debug_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEBUG, "%d times of %d bytes message will be sent to %s\n", buf, 0x18u);
      }
    }
    if (a6 == ++v33)
      goto LABEL_81;
  }
  if (dword_10008BA20)
  {
    v36 = ne_log_obj(v34);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
      sub_100063C8C();
  }
  v34 = (ssize_t)__error();
  if (*(_DWORD *)v34 == 65
    || (v34 = (ssize_t)__error(), *(_DWORD *)v34 == 50)
    || (v34 = (ssize_t)__error(), *(_DWORD *)v34 == 51))
  {
    if (dword_10008BA20)
    {
      v37 = ne_log_obj(v34);
      v34 = os_log_type_enabled(v37, OS_LOG_TYPE_ERROR);
      if ((_DWORD)v34)
        sub_100063C3C();
    }
    v57 = 0;
    v35 = dword_10008BA20;
    goto LABEL_54;
  }
  if (v25)
    goto LABEL_97;
  return 0xFFFFFFFFLL;
}

uint64_t *sub_10003C570(const sockaddr *a1)
{
  char v2[32];
  char v3[1025];

  if (a1)
  {
    if (a1->sa_family)
    {
      if (getnameinfo(a1, a1->sa_len, v3, 0x401u, v2, 0x20u, 10))
      {
        __strlcpy_chk(v3, "(invalid)", 1025, 1025);
        __strlcpy_chk(v2, "(invalid)", 32, 32);
      }
      snprintf((char *)&qword_100088FE8, 0x42BuLL, "%s[%s]", v3, v2);
    }
    else
    {
      strcpy((char *)&qword_100088FE8, "anonymous");
    }
  }
  else
  {
    LOBYTE(qword_100088FE8) = 0;
  }
  return &qword_100088FE8;
}

_BYTE *sub_10003C67C(char a1)
{
  _BYTE *v2;
  _BYTE *v3;
  NSObject *v4;

  v2 = malloc_type_calloc(1uLL, 0x80uLL, 0x1000040AE2C30F4uLL);
  v3 = v2;
  if (v2)
  {
    *v2 = a1;
  }
  else if (dword_10008BA20)
  {
    v4 = ne_log_obj(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      sub_100063F68();
  }
  return v3;
}

void *sub_10003C6F8(unsigned __int8 *a1)
{
  void *v2;
  void *v3;
  NSObject *v4;

  v2 = malloc_type_calloc(1uLL, 0x80uLL, 0x1000040AE2C30F4uLL);
  v3 = v2;
  if (v2)
  {
    __memcpy_chk(v2, a1, *a1, 128);
  }
  else if (dword_10008BA20)
  {
    v4 = ne_log_obj(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      sub_100063F68();
  }
  return v3;
}

uint64_t *sub_10003C784(const sockaddr *a1, int a2)
{
  char v4[32];
  char v5[1025];

  if (a1)
  {
    if (a1->sa_family)
    {
      if (getnameinfo(a1, a1->sa_len, v5, 0x401u, v4, 0x20u, 10))
      {
        __strlcpy_chk(v5, "(invalid)", 1025, 1025);
        __strlcpy_chk(v4, "(invalid)", 32, 32);
      }
      snprintf((char *)&qword_100089413, 0x42BuLL, "%s/%d[%s]", v5, a2, v4);
    }
    else
    {
      strcpy((char *)&qword_100089413, "anonymous");
    }
  }
  else
  {
    LOBYTE(qword_100089413) = 0;
  }
  return &qword_100089413;
}

char *sub_10003C8A0(const sockaddr *a1)
{
  char v2[1025];

  if (a1)
  {
    if (getnameinfo(a1, a1->sa_len, v2, 0x401u, 0, 0, 10))
      __strlcpy_chk(v2, "(invalid)", 1025, 1025);
    snprintf(&byte_10008983E, 0x42BuLL, "%s", v2);
  }
  else
  {
    byte_10008983E = 0;
  }
  return &byte_10008983E;
}

int *sub_10003C95C(uint64_t a1)
{
  size_t v2;

  if (a1)
  {
    if (*(_OWORD *)a1 == 0)
    {
      dword_100089C6C = 7958113;
    }
    else
    {
      sub_10003C8A0((const sockaddr *)a1);
      snprintf((char *)&dword_100089C6C, 0x40BuLL, "%s", &byte_10008983E);
      v2 = strlen((const char *)&dword_100089C6C);
      snprintf((char *)&dword_100089C6C + v2, 1035 - v2, "/%ld", *(_QWORD *)(a1 + 128));
    }
  }
  else
  {
    LOBYTE(dword_100089C6C) = 0;
  }
  return &dword_100089C6C;
}

char *sub_10003CA1C(const char *a1, uint64_t a2, uint64_t a3)
{
  char *v5;
  char *v6;
  char *v7;
  NSObject *v9;
  NSObject *v10;

  sub_10003C95C(a2);
  v5 = strdup((const char *)dword_100089C6C);
  sub_10003C95C(a3);
  v6 = strdup((const char *)dword_100089C6C);
  if (!v5)
  {
    if (dword_10008BA20)
    {
      v9 = ne_log_obj(v6);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        goto LABEL_9;
    }
    goto LABEL_10;
  }
  v7 = v6;
  if (!v6)
  {
    if (dword_10008BA20)
    {
      v10 = ne_log_obj(0);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
LABEL_9:
        sub_10005C4A8();
    }
LABEL_10:
    exit(1);
  }
  snprintf(byte_10008A077, 0x8BAuLL, a1, v5, v6);
  free(v5);
  free(v7);
  return byte_10008A077;
}

char *sub_10003CB18(const char *a1, const sockaddr *a2, sockaddr *a3)
{
  sockaddr *v3;
  char *v5;
  const char *v6;
  const char *v7;
  NSObject *v9;
  NSObject *v10;

  v3 = a3;
  if (!a2)
  {
    v5 = 0;
    if (!a3)
      goto LABEL_7;
    goto LABEL_6;
  }
  sub_10003C570(a2);
  v5 = strdup((const char *)&qword_100088FE8);
  if (!v5)
  {
    if (dword_10008BA20)
    {
      v9 = ne_log_obj(0);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
LABEL_22:
        sub_10005C4A8();
    }
LABEL_23:
    exit(1);
  }
  if (v3)
  {
LABEL_6:
    sub_10003C570(v3);
    v3 = (sockaddr *)strdup((const char *)&qword_100088FE8);
    if (v3)
      goto LABEL_7;
    if (dword_10008BA20)
    {
      v10 = ne_log_obj(0);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        goto LABEL_22;
    }
    goto LABEL_23;
  }
LABEL_7:
  v6 = "[null]";
  if (v5)
    v7 = v5;
  else
    v7 = "[null]";
  if (v3)
    v6 = (const char *)v3;
  snprintf(byte_10008A931, 0x8BAuLL, a1, v7, v6);
  if (v5)
    free(v5);
  if (v3)
    free(v3);
  return byte_10008A931;
}

_BYTE *sub_10003CC48(const char *a1, const char *a2)
{
  const char *v2;
  uint64_t v4;
  int v5;
  NSObject *v6;
  const char *v7;
  const char *v8;
  BOOL v9;
  NSObject *v10;
  const char *v11;
  const char *v12;
  _BYTE *v13;
  _BYTE *v14;
  NSObject *v15;
  addrinfo *v17;
  addrinfo v18;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  const char *v26;

  v2 = a2;
  v17 = 0;
  memset(&v18, 0, sizeof(v18));
  v18.ai_socktype = 2;
  v18.ai_flags = 4;
  v4 = getaddrinfo(a1, a2, &v18, &v17);
  if ((_DWORD)v4)
  {
    if (dword_10008BA20)
    {
      v5 = v4;
      v6 = ne_log_obj(v4);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        if (v2)
          v7 = ",";
        else
          v7 = (const char *)&unk_10007E079;
        if (!v2)
          v2 = (const char *)&unk_10007E079;
        v8 = gai_strerror(v5);
        *(_DWORD *)buf = 136315906;
        v20 = a1;
        v21 = 2080;
        v22 = v7;
        v23 = 2080;
        v24 = v2;
        v25 = 2080;
        v26 = v8;
        _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "getaddrinfo(%s%s%s): %s\n", buf, 0x2Au);
      }
    }
    return 0;
  }
  if (v17->ai_next)
    v9 = dword_10008BA20 == 0;
  else
    v9 = 1;
  if (!v9)
  {
    v10 = ne_log_obj(v4);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      v11 = ",";
      v12 = (const char *)&unk_10007E079;
      *(_DWORD *)buf = 136315650;
      v20 = a1;
      if (!v2)
        v11 = (const char *)&unk_10007E079;
      v21 = 2080;
      if (v2)
        v12 = v2;
      v22 = v11;
      v23 = 2080;
      v24 = v12;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "getaddrinfo(%s%s%s): resolved to multiple address, taking the first one\n", buf, 0x20u);
    }
  }
  v13 = sub_10003C67C(128);
  if (!v13)
  {
    if (dword_10008BA20)
    {
      v15 = ne_log_obj(0);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        sub_1000560FC();
    }
    freeaddrinfo(v17);
    return 0;
  }
  v14 = v13;
  memcpy(v13, v17->ai_addr, v17->ai_addrlen);
  freeaddrinfo(v17);
  return v14;
}

void sub_10003CE78(char *a1, unsigned __int8 *a2, unint64_t a3)
{
  int v4;
  char *v5;
  unsigned int v6;
  unint64_t v7;
  NSObject *v8;
  NSObject *v9;

  v4 = a2[1];
  if (v4 == 30)
  {
    v5 = a1 + 8;
    v6 = 16;
  }
  else
  {
    if (v4 != 2)
    {
      if (dword_10008BA20)
      {
        v9 = ne_log_obj(a1);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          sub_100063FD4();
      }
LABEL_15:
      exit(1);
    }
    v5 = a1 + 4;
    v6 = 4;
  }
  if (8 * v6 < a3)
  {
    if (dword_10008BA20)
    {
      v8 = ne_log_obj(a1);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_100064038();
    }
    goto LABEL_15;
  }
  memcpy(a1, a2, *a2);
  v5[a3 >> 3] &= 0xFF00u >> (a3 & 7);
  v7 = (a3 >> 3) + 1;
  if (v7 < v6)
    bzero(&v5[v7], ~(a3 >> 3) + v6);
}

uint64_t sub_10003CFA8(unint64_t *__s1, sockaddr *a2)
{
  uint64_t result;
  int v5;
  int v6;
  int v7;
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;
  NSObject *v16;
  int v17;
  char *v18;
  __int16 v19;
  char *v20;
  __int16 v21;
  char *v22;
  sockaddr v23[8];

  memset(v23, 0, sizeof(v23));
  if (__s1 && a2)
  {
    result = memcmp(__s1, &unk_10006A2C8, 0x88uLL);
    if (!(_DWORD)result)
      return result;
    if (*((unsigned __int8 *)__s1 + 1) == a2->sa_family)
    {
      v5 = sub_10003D25C((uint64_t)__s1);
      v6 = sub_10003D25C((uint64_t)a2);
      v7 = 0;
      if (!v5 || !v6)
      {
LABEL_9:
        sub_10003CE78((char *)v23, &a2->sa_len, __s1[16]);
        if (dword_1000882C8 < 7)
          goto LABEL_17;
        sub_10003C95C((uint64_t)__s1);
        v8 = strdup((const char *)dword_100089C6C);
        sub_10003C8A0(a2);
        v9 = strdup(&byte_10008983E);
        sub_10003C8A0(v23);
        v10 = strdup(&byte_10008983E);
        if (v8)
        {
          if (v9)
          {
            v11 = v10;
            if (v10)
            {
              if (dword_10008BA20)
              {
                v12 = ne_log_obj(v10);
                if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
                {
                  v17 = 136315650;
                  v18 = v8;
                  v19 = 2080;
                  v20 = v9;
                  v21 = 2080;
                  v22 = v11;
                  _os_log_debug_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "naddr=%s, saddr=%s (masked=%s)\n", (uint8_t *)&v17, 0x20u);
                }
              }
              free(v8);
              free(v9);
              free(v11);
LABEL_17:
              if (!sub_10003B380((unint64_t)v23, (unint64_t)__s1))
                return (*((_DWORD *)__s1 + 32) + v7);
              return 0xFFFFFFFFLL;
            }
            if (dword_10008BA20)
            {
              v16 = ne_log_obj(0);
              if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
                goto LABEL_32;
            }
LABEL_33:
            exit(1);
          }
          if (!dword_10008BA20)
            goto LABEL_33;
          v15 = ne_log_obj(v10);
          if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
            goto LABEL_33;
        }
        else
        {
          if (!dword_10008BA20)
            goto LABEL_33;
          v14 = ne_log_obj(v10);
          if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
            goto LABEL_33;
        }
LABEL_32:
        sub_10005C4A8();
        goto LABEL_33;
      }
      if (v5 == v6)
      {
        v7 = 1;
        goto LABEL_9;
      }
    }
  }
  else if (dword_10008BA20)
  {
    v13 = ne_log_obj(__s1);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      sub_1000640BC();
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_10003D25C(uint64_t a1)
{
  int v1;
  unsigned int v2;
  NSObject *v4;

  if (!a1)
    return 0xFFFFLL;
  v1 = *(unsigned __int8 *)(a1 + 1);
  if (v1 == 30 || v1 == 2)
  {
    v2 = *(unsigned __int16 *)(a1 + 2);
  }
  else
  {
    if (dword_10008BA20)
    {
      v4 = ne_log_obj(a1);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_10006413C();
    }
    v2 = 0xFFFF;
  }
  return __rev16(v2);
}

uint64_t sub_10003D2DC(uint64_t result)
{
  int v1;
  NSObject *v2;

  if (result)
  {
    v1 = *(unsigned __int8 *)(result + 1);
    if (v1 == 30 || v1 == 2)
    {
      result += 2;
    }
    else
    {
      if (dword_10008BA20)
      {
        v2 = ne_log_obj(result);
        if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
          sub_10006413C();
      }
      return 0;
    }
  }
  return result;
}

_WORD *sub_10003D350(uint64_t a1, unsigned int a2)
{
  _WORD *result;

  result = (_WORD *)sub_10003D2DC(a1);
  if (result)
    *result = __rev16(a2);
  return result;
}

void sub_10003D37C(void *a1, NSObject *a2, os_log_type_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, a3, a4, a5, 0xCu);
}

uint64_t *sub_10003D384(const sockaddr *a1)
{
  return sub_10003C570(a1);
}

char *sub_10003D3A0(uint64_t a1, unint64_t a2)
{
  size_t v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v4 = (a2 >> 3) + 2 * a2 + 10;
  v5 = (char *)malloc_type_malloc(v4, 0xEB1664DCuLL);
  if (v5)
  {
    if (a2)
    {
      v6 = 0;
      v7 = 0;
      do
      {
        snprintf(&v5[v6], v4 - v6, "%02x", *(unsigned __int8 *)(a1 + v7));
        v8 = v6 + 2;
        if ((~(_BYTE)v7 & 7) == 0)
        {
          v5[v8] = 32;
          v8 = v6 + 3;
          v5[v6 + 3] = 0;
        }
        ++v7;
        v6 = v8;
      }
      while (a2 != v7);
    }
    else
    {
      v8 = 0;
    }
    v5[v8] = 0;
  }
  return v5;
}

_BYTE *sub_10003D478(_BYTE *a1, int a2, _QWORD *a3)
{
  int v3;
  unint64_t v7;
  uint64_t v8;
  __uint32_t v9;
  _BYTE *v10;
  _BYTE *v11;
  int v12;
  uint64_t v13;
  int v14;
  unsigned __int8 *v15;
  _BYTE *v16;
  char v17;
  int v18;
  char __str[3];

  LOBYTE(v3) = *a1;
  if (!*a1)
    return 0;
  v7 = 0;
  v8 = 1;
  do
  {
    if ((v3 & 0x80) != 0)
    {
      if (!__maskrune((char)v3, 0x4000uLL))
        return 0;
    }
    else
    {
      v9 = _DefaultRuneLocale.__runetype[(char)v3];
      if ((v9 & 0x10000) != 0)
      {
        ++v7;
      }
      else if ((v9 & 0x4000) == 0)
      {
        return 0;
      }
    }
    v3 = a1[v8++];
  }
  while (v3);
  v10 = 0;
  if (v7)
  {
    if ((v7 & 1) == 0)
    {
      v11 = malloc_type_malloc(v7 >> 1, 0x66E920C4uLL);
      v10 = v11;
      if (v11)
      {
        v12 = *a1;
        if (*a1)
        {
          v13 = 0;
          v14 = 0;
          v15 = a1 + 1;
          v16 = v11;
          do
          {
            if ((v12 & 0x80) == 0 && (_DefaultRuneLocale.__runetype[v12] & 0x10000) != 0)
            {
              if (v14)
              {
                __str[1] = v12;
                __str[2] = 0;
                v17 = strtol(__str, 0, a2);
                v14 = 0;
                *v16++ = v17;
                ++v13;
              }
              else
              {
                __str[0] = v12;
                v14 = 1;
              }
            }
            v18 = *v15++;
            v12 = v18;
          }
          while (v18);
        }
        else
        {
          v13 = 0;
        }
        *a3 = v13;
      }
    }
  }
  return v10;
}

char *sub_10003D5B4(int a1)
{
  snprintf(byte_10008B1EB, 0x14uLL, "%d", a1);
  return byte_10008B1EB;
}

const char *sub_10003D5F8(uint64_t a1, uint64_t a2, int a3)
{
  const char *result;

  if (a3 > 5506)
  {
    if (a3 <= 6591)
    {
      if (a3 <= 6343)
      {
        if (a3 > 6335)
        {
          if (a3 == 6336)
            return "IKEv1 quick I start";
          if (a3 == 6338)
            return "IKEv1 quick I msg2 rcvd";
        }
        else
        {
          if (a3 == 5507)
            return "IKEv1 agg R msg3 rcvd";
          if (a3 == 5538)
            return "IKEv1 agg R msg2 sent";
        }
      }
      else if (a3 <= 6368)
      {
        if (a3 == 6344)
          return "IKEv1 quick I addsa";
        if (a3 == 6352)
          return "IKEv1 quick I getspi done";
      }
      else
      {
        switch(a3)
        {
          case 6369:
            return "IKEv1 quick I msg1 sent";
          case 6371:
            return "IKEv1 quick I msg3 sent";
          case 6384:
            return "IKEv1 quick I getspi sent";
        }
      }
    }
    else
    {
      if (a3 <= 6625)
      {
        switch(a3)
        {
          case 6592:
            result = "IKEv1 quick R start";
            break;
          case 6593:
            result = "IKEv1 quick R msg1 rcvd";
            break;
          case 6594:
          case 6597:
          case 6598:
          case 6599:
            return "???";
          case 6595:
            result = "IKEv1 quick R msg3 rcvd";
            break;
          case 6596:
            result = "IKEv1 quick R commit";
            break;
          case 6600:
            result = "IKEv1 quick R addsa";
            break;
          default:
            if (a3 != 6608)
              return "???";
            result = "IKEv1 quick R getspi done";
            break;
        }
        return result;
      }
      if (a3 > 10239)
      {
        switch(a3)
        {
          case 18432:
            return "Phase 2 expired";
          case 17408:
            return "Phase 1 expired";
          case 10240:
            return "Phase 2 established";
        }
      }
      else
      {
        switch(a3)
        {
          case 6626:
            return "IKEv1 quick R msg2 sent";
          case 6640:
            return "IKEv1 quick R getspi sent";
          case 9216:
            return "Phase 1 Established";
        }
      }
    }
    return "???";
  }
  if (a3 > 5280)
  {
    if (a3 > 5473)
    {
      if (a3 > 5503)
      {
        if (a3 == 5504)
          return "IKEv1 agg R start";
        if (a3 == 5505)
          return "IKEv1 agg R msg1 rcvd";
      }
      else
      {
        if (a3 == 5474)
          return "IKEv1 ident R msg2 sent";
        if (a3 == 5476)
          return "IKEv1 ident R msg4 sent";
      }
      return "???";
    }
    switch(a3)
    {
      case 5440:
        return "IKEv1 ident R start";
      case 5441:
        return "IKEv1 ident R msg1 rcvd";
      case 5442:
      case 5444:
        return "???";
      case 5443:
        return "IKEv1 ident R msg3 rcvd";
      case 5445:
        return "IKEv1 ident R msg5 rcvd";
      default:
        if (a3 == 5281)
        {
          result = "IKEv1 agg I msg1 sent";
        }
        else
        {
          if (a3 != 5283)
            return "???";
          result = "IKEv1 agg I msg3 sent";
        }
        break;
    }
  }
  else
  {
    if (a3 > 5216)
    {
      if (a3 <= 5220)
      {
        if (a3 == 5217)
          return "IKEv1 ident I msg1 sent";
        if (a3 == 5219)
          return "IKEv1 ident I msg3 sent";
      }
      else
      {
        switch(a3)
        {
          case 5221:
            return "IKEv1 ident I msg5 sent";
          case 5248:
            return "IKEv1 agg I start";
          case 5250:
            return "IKEv1 agg I msg2 rcvd";
        }
      }
      return "???";
    }
    switch(a3)
    {
      case 5184:
        result = "IKEv1 ident I start";
        break;
      case 5185:
      case 5187:
      case 5189:
        return "???";
      case 5186:
        result = "IKEv1 ident I msg2 rcvd";
        break;
      case 5188:
        result = "IKEv1 ident I msg4 rcvd";
        break;
      case 5190:
        result = "IKEv1 ident I msg6 rcvd";
        break;
      default:
        if (a3 != 63)
          return "???";
        result = "IKEv1 info";
        break;
    }
  }
  return result;
}

char *sub_10003DA44(int a1)
{
  uint64_t v1;
  char *v2;

  v1 = 0;
  while (dword_100085128[v1] != a1)
  {
    v1 += 6;
    if (v1 == 66)
    {
      v2 = byte_10008B1EB;
      snprintf(byte_10008B1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_100085128[v1 + 2];
}

char *sub_10003DAB8(int a1)
{
  uint64_t v1;
  char *v2;

  v1 = 0;
  while (dword_100085230[v1] != a1)
  {
    v1 += 6;
    if (v1 == 60)
    {
      v2 = byte_10008B1EB;
      snprintf(byte_10008B1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_100085230[v1 + 2];
}

char *sub_10003DB2C(int a1)
{
  uint64_t v1;
  char *v2;

  v1 = 0;
  while (dword_100085320[v1] != a1)
  {
    v1 += 6;
    if (v1 == 216)
    {
      v2 = byte_10008B1EB;
      snprintf(byte_10008B1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_100085320[v1 + 2];
}

char *sub_10003DBA0(int a1)
{
  uint64_t v1;
  char *v2;

  v1 = 0;
  while (dword_100085680[v1] != a1)
  {
    v1 += 6;
    if (v1 == 126)
    {
      v2 = byte_10008B1EB;
      snprintf(byte_10008B1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_100085680[v1 + 2];
}

char *sub_10003DC14(int a1)
{
  uint64_t v1;
  char *v2;

  v1 = 0;
  while (dword_100085878[v1] != a1)
  {
    v1 += 6;
    if (v1 == 216)
    {
      v2 = byte_10008B1EB;
      snprintf(byte_10008B1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_100085878[v1 + 2];
}

char *sub_10003DC88(int a1)
{
  uint64_t v1;
  char *v2;

  v1 = 0;
  while (dword_100085BD8[v1] != a1)
  {
    v1 += 6;
    if (v1 == 24)
    {
      v2 = byte_10008B1EB;
      snprintf(byte_10008B1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_100085BD8[v1 + 2];
}

char *sub_10003DCFC(int a1)
{
  uint64_t v1;
  char *v2;

  v1 = 0;
  while (dword_100085C38[v1] != a1)
  {
    v1 += 6;
    if (v1 == 24)
    {
      v2 = byte_10008B1EB;
      snprintf(byte_10008B1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_100085C38[v1 + 2];
}

const char *sub_10003DD70(int a1)
{
  char *v1;

  if (a1 == 1)
    return "IKE";
  v1 = byte_10008B1EB;
  snprintf(byte_10008B1EB, 0x14uLL, "%d", a1);
  return v1;
}

char *sub_10003DDC8(int a1)
{
  uint64_t v1;
  char *v2;

  v1 = 0;
  while (dword_100085C98[v1] != a1)
  {
    v1 += 6;
    if (v1 == 36)
    {
      v2 = byte_10008B1EB;
      snprintf(byte_10008B1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_100085C98[v1 + 2];
}

char *sub_10003DE3C(int a1)
{
  uint64_t v1;
  char *v2;

  v1 = 0;
  while (dword_100085D28[v1] != a1)
  {
    v1 += 6;
    if (v1 == 78)
    {
      v2 = byte_10008B1EB;
      snprintf(byte_10008B1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_100085D28[v1 + 2];
}

char *sub_10003DEB0(int a1)
{
  uint64_t v1;
  char *v2;

  v1 = 0;
  while (dword_100085E60[v1] != a1)
  {
    v1 += 6;
    if (v1 == 18)
    {
      v2 = byte_10008B1EB;
      snprintf(byte_10008B1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_100085E60[v1 + 2];
}

char *sub_10003DF24(int a1, uint64_t a2)
{
  uint64_t v2;

  v2 = 0;
  while (dword_100085C38[v2] != a1)
  {
    v2 += 6;
    if (v2 == 24)
    {
      snprintf(byte_10008B1EB, 0x14uLL, "%d", a2);
      return byte_10008B1EB;
    }
  }
  return (char *)(*(uint64_t (**)(uint64_t))&dword_100085C38[v2 + 4])(a2);
}

char *sub_10003DFA8(int a1)
{
  uint64_t v1;
  char *v2;

  v1 = 0;
  while (dword_100085EA8[v1] != a1)
  {
    v1 += 6;
    if (v1 == 54)
    {
      v2 = byte_10008B1EB;
      snprintf(byte_10008B1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_100085EA8[v1 + 2];
}

char *sub_10003E01C(int a1)
{
  uint64_t v1;
  char i;
  char v3;
  char *v4;

  v1 = 0;
  for (i = 1; ; i = 0)
  {
    v3 = i;
    if (*((_DWORD *)&unk_100086790 + 6 * v1) == a1)
      break;
    v1 = 1;
    if ((v3 & 1) == 0)
    {
      v4 = byte_10008B1EB;
      snprintf(byte_10008B1EB, 0x14uLL, "%d", a1);
      return v4;
    }
  }
  return (char *)*((_QWORD *)&unk_100086790 + 3 * v1 + 1);
}

char *sub_10003E0A4(int a1)
{
  uint64_t v1;
  char *v2;

  v1 = 0;
  while (dword_100085F80[v1] != a1)
  {
    v1 += 6;
    if (v1 == 42)
    {
      v2 = byte_10008B1EB;
      snprintf(byte_10008B1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_100085F80[v1 + 2];
}

char *sub_10003E118(int a1)
{
  uint64_t v1;
  char *v2;

  v1 = 0;
  while (dword_100086028[v1] != a1)
  {
    v1 += 6;
    if (v1 == 42)
    {
      v2 = byte_10008B1EB;
      snprintf(byte_10008B1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_100086028[v1 + 2];
}

char *sub_10003E18C(int a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t (**i)();

  v2 = 0;
  for (i = &off_100085EB8; *((_DWORD *)i - 4) != a1 || ((0x1E6uLL >> v2) & 1) != 0; i += 3)
  {
    if (++v2 == 9)
    {
      snprintf(byte_10008B1EB, 0x14uLL, "%d", a2);
      return byte_10008B1EB;
    }
  }
  return (char *)((uint64_t (*)(uint64_t))*i)(a2);
}

char *sub_10003E21C(int a1)
{
  uint64_t v1;
  char *v2;

  v1 = 0;
  while (dword_1000860D0[v1] != a1)
  {
    v1 += 6;
    if (v1 == 66)
    {
      v2 = byte_10008B1EB;
      snprintf(byte_10008B1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_1000860D0[v1 + 2];
}

char *sub_10003E290(int a1)
{
  uint64_t v1;
  char *v2;

  v1 = 0;
  while (dword_1000861D8[v1] != a1)
  {
    v1 += 6;
    if (v1 == 108)
    {
      v2 = byte_10008B1EB;
      snprintf(byte_10008B1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_1000861D8[v1 + 2];
}

char *sub_10003E304(int a1)
{
  uint64_t v1;
  char *v2;

  v1 = 0;
  while (dword_100086388[v1] != a1)
  {
    v1 += 6;
    if (v1 == 42)
    {
      v2 = byte_10008B1EB;
      snprintf(byte_10008B1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_100086388[v1 + 2];
}

char *sub_10003E378(int a1)
{
  uint64_t v1;
  char *v2;

  v1 = 0;
  while (dword_100086430[v1] != a1)
  {
    v1 += 6;
    if (v1 == 48)
    {
      v2 = byte_10008B1EB;
      snprintf(byte_10008B1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_100086430[v1 + 2];
}

char *sub_10003E3EC(int a1)
{
  uint64_t v1;
  char *v2;

  v1 = 0;
  while (dword_1000864F0[v1] != a1)
  {
    v1 += 6;
    if (v1 == 90)
    {
      v2 = byte_10008B1EB;
      snprintf(byte_10008B1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_1000864F0[v1 + 2];
}

char *sub_10003E460(int a1)
{
  uint64_t v1;
  char *v2;

  v1 = 0;
  while (dword_100086658[v1] != a1)
  {
    v1 += 6;
    if (v1 == 60)
    {
      v2 = byte_10008B1EB;
      snprintf(byte_10008B1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_100086658[v1 + 2];
}

char *sub_10003E4D4(int a1)
{
  uint64_t v1;
  char *v2;

  v1 = 0;
  while (dword_100086748[v1] != a1)
  {
    v1 += 6;
    if (v1 == 18)
    {
      v2 = byte_10008B1EB;
      snprintf(byte_10008B1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_100086748[v1 + 2];
}

char *sub_10003E548(int a1)
{
  uint64_t v1;
  char i;
  char v3;
  char *v4;

  v1 = 0;
  for (i = 1; ; i = 0)
  {
    v3 = i;
    if (*((_DWORD *)&unk_100086790 + 6 * v1) == a1)
      break;
    v1 = 1;
    if ((v3 & 1) == 0)
    {
      v4 = byte_10008B1EB;
      snprintf(byte_10008B1EB, 0x14uLL, "%d", a1);
      return v4;
    }
  }
  return (char *)*((_QWORD *)&unk_100086790 + 3 * v1 + 1);
}

char *sub_10003E5D0(int a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t (**i)();

  v2 = 0;
  for (i = &off_1000861E8; *((_DWORD *)i - 4) != a1 || ((0x3FBE0uLL >> v2) & 1) != 0; i += 3)
  {
    if (++v2 == 18)
    {
      snprintf(byte_10008B1EB, 0x14uLL, "%d", a2);
      return byte_10008B1EB;
    }
  }
  return (char *)((uint64_t (*)(uint64_t))*i)(a2);
}

char *sub_10003E664(int a1)
{
  uint64_t v1;
  char *v2;

  v1 = 0;
  while (dword_1000867C0[v1] != a1)
  {
    v1 += 6;
    if (v1 == 18)
    {
      v2 = byte_10008B1EB;
      snprintf(byte_10008B1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_1000867C0[v1 + 2];
}

char *sub_10003E6D8(int a1)
{
  uint64_t v1;
  char *v2;

  v1 = 0;
  while (dword_100086808[v1] != a1)
  {
    v1 += 6;
    if (v1 == 42)
    {
      v2 = byte_10008B1EB;
      snprintf(byte_10008B1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_100086808[v1 + 2];
}

char *sub_10003E74C(int a1, uint64_t a2)
{
  uint64_t v2;

  v2 = 0;
  while (dword_100086808[v2] != a1)
  {
    v2 += 6;
    if (v2 == 42)
    {
      snprintf(byte_10008B1EB, 0x14uLL, "%d", a2);
      return byte_10008B1EB;
    }
  }
  return (char *)(*(uint64_t (**)(uint64_t))&dword_100086808[v2 + 4])(a2);
}

char *sub_10003E7D0(int a1)
{
  uint64_t v1;
  char *v2;

  v1 = 0;
  while (dword_1000868B0[v1] != a1)
  {
    v1 += 6;
    if (v1 == 138)
    {
      v2 = byte_10008B1EB;
      snprintf(byte_10008B1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_1000868B0[v1 + 2];
}

char *sub_10003E844(int a1)
{
  uint64_t v1;
  char *v2;

  v1 = 0;
  while (dword_100086AD8[v1] != a1)
  {
    v1 += 6;
    if (v1 == 48)
    {
      v2 = byte_10008B1EB;
      snprintf(byte_10008B1EB, 0x14uLL, "%d", a1);
      return v2;
    }
  }
  return *(char **)&dword_100086AD8[v1 + 2];
}

char *sub_10003E8B8(int a1)
{
  uint64_t v1;
  char i;
  char v3;
  char *v4;

  v1 = 0;
  for (i = 1; ; i = 0)
  {
    v3 = i;
    if (*((_DWORD *)&unk_100086B98 + 6 * v1) == a1)
      break;
    v1 = 1;
    if ((v3 & 1) == 0)
    {
      v4 = byte_10008B1EB;
      snprintf(byte_10008B1EB, 0x14uLL, "%d", a1);
      return v4;
    }
  }
  return (char *)*((_QWORD *)&unk_100086B98 + 3 * v1 + 1);
}

const char *sub_10003E940(int a1)
{
  char *v1;

  if (a1 <= 16)
  {
    if (a1 == 1)
      return "icmp";
    if (a1 == 6)
      return "tcp";
LABEL_12:
    v1 = byte_10008B1EB;
    snprintf(byte_10008B1EB, 0x14uLL, "%d", a1);
    return v1;
  }
  if (a1 == 17)
    return "udp";
  if (a1 == 58)
    return "icmpv6";
  if (a1 != 255)
    goto LABEL_12;
  return "any";
}

const char *sub_10003E9F0(int a1)
{
  char *v1;

  if (a1 == 1)
    return "ipsec_doi";
  v1 = byte_10008B1EB;
  snprintf(byte_10008B1EB, 0x14uLL, "%d", a1);
  return v1;
}

const char *sub_10003EA48(int a1)
{
  const char *v1;

  if (a1 > 31)
  {
    switch(a1)
    {
      case ' ':
        return "_quick";
      case '!':
        return "_newgrp";
      case '"':
        return "_ackinfo";
      default:
LABEL_14:
        v1 = byte_10008B1EB;
        snprintf(byte_10008B1EB, 0x14uLL, "%d", a1);
        break;
    }
  }
  else
  {
    v1 = "_none";
    switch(a1)
    {
      case 0:
        return v1;
      case 1:
        v1 = "base";
        break;
      case 2:
        v1 = "main";
        break;
      case 3:
        v1 = "_auth";
        break;
      case 4:
        v1 = "aggressive";
        break;
      case 5:
        v1 = "_info";
        break;
      default:
        goto LABEL_14;
    }
  }
  return v1;
}

char *sub_10003EB38(int a1)
{
  char *v1;

  if ((a1 - 1) < 5)
    return off_100086BC8[a1 - 1];
  v1 = byte_10008B1EB;
  snprintf(byte_10008B1EB, 0x14uLL, "%d", a1);
  return v1;
}

const char *sub_10003EB98(int a1)
{
  char *v1;

  if (!a1)
    return "off";
  if (a1 == 1)
    return "on";
  v1 = byte_10008B1EB;
  snprintf(byte_10008B1EB, 0x14uLL, "%d", a1);
  return v1;
}

_QWORD *sub_10003EC00(unsigned __int8 *a1)
{
  _QWORD *v2;
  char *v3;
  _QWORD *v4;
  BOOL v5;
  _QWORD *v6;

  v2 = malloc_type_malloc(*a1 + 24, 0xC6948EEEuLL);
  if (v2)
  {
    *(_DWORD *)v2 = dword_10008BE98 + time(0);
    memcpy(v2 + 3, a1, *a1);
    v3 = (char *)off_1000882E0;
    v2[1] = off_1000882E0;
    v4 = v3 + 16;
    v5 = v3 == 0;
    off_1000882E0 = v2;
    v6 = &off_1000882E8;
    if (!v5)
      v6 = v4;
    *v6 = v2 + 1;
    v2[2] = &off_1000882E0;
  }
  return v2;
}

uint64_t sub_10003EC98(unsigned __int8 *a1, int a2)
{
  time_t v4;
  _QWORD *v5;
  time_t v6;
  uint64_t v7;
  _QWORD *v8;
  _UNKNOWN **v9;
  uint64_t result;
  uint64_t v11;
  NSObject *v12;

  if (!dword_10008BE98)
    return 0;
  v4 = time(0);
  v5 = *(_QWORD **)off_1000882E8[1];
  if (!v5)
  {
LABEL_12:
    if (a2 && !sub_10003EC00(a1))
    {
      if (dword_10008BA20)
      {
        v12 = ne_log_obj(0);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          sub_1000641A0(v12);
      }
      return dword_10008BE98 + time(0);
    }
    return 0;
  }
  v6 = v4;
  while (1)
  {
    if (v6 > *(int *)v5)
    {
      v7 = v5[1];
      v8 = (_QWORD *)v5[2];
      if (v7)
      {
        *(_QWORD *)(v7 + 16) = v8;
        v8 = (_QWORD *)v5[2];
      }
      else
      {
        off_1000882E8 = (_UNKNOWN **)v5[2];
      }
      *v8 = v7;
      free(v5);
      v9 = off_1000882E8;
      goto LABEL_11;
    }
    if (!sub_10003B380((unint64_t)a1, (unint64_t)(v5 + 3)))
      break;
    v9 = (_UNKNOWN **)v5[2];
LABEL_11:
    v5 = *(_QWORD **)v9[1];
    if (!v5)
      goto LABEL_12;
  }
  result = *(unsigned int *)v5;
  if (a2)
  {
    v11 = (int)result - v6 + dword_10008BE98;
    if (v11 >= 10)
      LODWORD(v11) = 10;
    result = (v11 + v6);
    *(_DWORD *)v5 = result;
  }
  return result;
}

__int128 *sub_10003EDD8(int a1)
{
  uint64_t v2;

  if (a1 == 19)
    return &xmmword_10006A36C;
  v2 = 0;
  while (dword_1000882F0[v2] != a1)
  {
    v2 += 6;
    if (v2 == 120)
      return 0;
  }
  return *(__int128 **)&dword_1000882F0[v2 + 2];
}

double sub_10003EE24()
{
  uint64_t v0;
  int *v1;
  _QWORD *v2;
  NSObject *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  NSObject *v7;
  _QWORD *v8;
  double result;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint8_t v13;
  _BYTE v14[15];
  size_t v15;
  const char *v16;
  uint8_t v17;
  _BYTE v18[15];

  v0 = 0;
  v15 = 0;
  v16 = 0;
  do
  {
    v1 = &dword_1000882F0[v0];
    v16 = *(const char **)&dword_1000882F0[v0 + 2];
    v15 = strlen(v16);
    v2 = sub_100006C18((uint64_t)&v15);
    *(_QWORD *)&dword_1000882F0[v0 + 4] = v2;
    if (!v2)
    {
      if (dword_10008BA20)
      {
        v3 = ne_log_obj(0);
        if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
          sub_100064218(&v13, v14, v3);
      }
    }
    v4 = (_QWORD *)*((_QWORD *)v1 + 2);
    if (*v1 == 17)
    {
      *(_BYTE *)(v4[1] + 14) = 1;
      *(_BYTE *)(v4[1] + 15) = 0;
    }
    else if (*v1 == 16)
    {
      v5 = sub_10003F1F8(8uLL);
      if (v5)
      {
        v6 = v5;
        *(_QWORD *)v5[1] = *(_QWORD *)v4[1];
        sub_10003F318(v4);
        v4 = v6;
      }
      else
      {
        if (dword_10008BA20)
        {
          v7 = ne_log_obj(0);
          if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
            sub_100064218(&v17, v18, v7);
        }
        v4 = 0;
      }
    }
    *((_QWORD *)v1 + 2) = v4;
    v0 += 6;
  }
  while (v0 != 114);
  v8 = sub_10003F1F8(0x10uLL);
  qword_1000884C8 = (uint64_t)v8;
  if (!v8)
  {
    if (dword_10008BA20)
    {
      v10 = ne_log_obj(0);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_1000641E0(v10, v11, v12);
    }
    exit(1);
  }
  result = -1.61043727e48;
  *(_OWORD *)v8[1] = xmmword_10006A36C;
  return result;
}

_QWORD *sub_10003EFDC(uint64_t a1)
{
  uint64_t v1;
  int v2;
  NSObject *v3;

  v1 = 0;
  if ((_DWORD)a1 == -1)
    v2 = 0;
  else
    v2 = a1;
  do
  {
    if (dword_1000882F0[v1] == v2)
      return sub_10003F34C(*(_QWORD *)&dword_1000882F0[v1 + 4]);
    v1 += 6;
  }
  while (v1 != 120);
  if (dword_10008BA20)
  {
    v3 = ne_log_obj(a1);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      sub_10006424C(v2, v3);
  }
  return 0;
}

uint64_t sub_10003F06C(uint64_t a1)
{
  uint64_t v1;
  signed int v2;
  const char *v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v12;
  uint64_t v13;
  const char *v14;
  uint64_t v15;
  int v16;
  uint64_t v17;

  if (!a1)
    return 0xFFFFFFFFLL;
  v1 = 0;
  v2 = (bswap32(*(unsigned __int16 *)(a1 + 2)) >> 16) - 4;
  v3 = (const char *)(a1 + 4);
  do
  {
    v4 = *(_QWORD *)&dword_1000882F0[v1 + 4];
    v5 = *(_QWORD *)v4;
    v6 = strncmp(*(const char **)(v4 + 8), v3, *(_QWORD *)v4);
    if (!(_DWORD)v6)
    {
      if (v5 >= v2)
      {
        if (!dword_10008BA20)
          return dword_1000882F0[v1];
        v12 = ne_log_obj(v6);
        if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          return dword_1000882F0[v1];
        v15 = *(_QWORD *)&dword_1000882F0[v1 + 2];
        v16 = 136315138;
        v17 = v15;
        v14 = "received Vendor ID: %s\n";
      }
      else
      {
        if (!dword_10008BA20)
          return dword_1000882F0[v1];
        v12 = ne_log_obj(v6);
        if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          return dword_1000882F0[v1];
        v13 = *(_QWORD *)&dword_1000882F0[v1 + 2];
        v16 = 136315138;
        v17 = v13;
        v14 = "received broken Microsoft ID: %s\n";
      }
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, v14, (uint8_t *)&v16, 0xCu);
      return dword_1000882F0[v1];
    }
    v1 += 6;
  }
  while (v1 != 120);
  if (dword_1000882C8 >= 7)
    sub_10003372C(7, (uint64_t)v3, v2, "received unknown Vendor ID:\n", v7, v8, v9, v10, v16);
  return 0xFFFFFFFFLL;
}

_QWORD *sub_10003F1F8(size_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;

  v2 = malloc_type_malloc(0x10uLL, 0x1010040466105CCuLL);
  v3 = v2;
  if (v2)
  {
    *v2 = a1;
    if (a1)
    {
      v4 = malloc_type_calloc(1uLL, a1, 0x68A898BBuLL);
      v3[1] = v4;
      if (!v4)
      {
        free(v3);
        return 0;
      }
    }
    else
    {
      v2[1] = 0;
    }
  }
  return v3;
}

void **sub_10003F270(void **a1, size_t size)
{
  void **v3;
  char *v4;
  char *v5;

  if (!a1)
    return (void **)sub_10003F1F8(size);
  v3 = a1;
  if (!*a1)
  {
    sub_10003F318(a1);
    return (void **)sub_10003F1F8(size);
  }
  v4 = (char *)malloc_type_realloc(a1[1], size, 0xE23CD46AuLL);
  if (v4)
  {
    v5 = v4;
    if (size > (unint64_t)*v3)
      bzero((char *)*v3 + (_QWORD)v4, size - (_QWORD)*v3);
    *v3 = (void *)size;
    v3[1] = v5;
  }
  else
  {
    sub_10003F318(v3);
    return 0;
  }
  return v3;
}

void sub_10003F318(_QWORD *a1)
{
  void *v2;

  if (a1)
  {
    v2 = (void *)a1[1];
    if (v2)
      free(v2);
    free(a1);
  }
}

_QWORD *sub_10003F34C(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  NSObject *v4;

  if (a1)
  {
    v2 = sub_10003F1F8(*(_QWORD *)a1);
    v3 = v2;
    if (v2)
      memcpy((void *)v2[1], *(const void **)(a1 + 8), *(_QWORD *)a1);
  }
  else
  {
    if (dword_10008BA20)
    {
      v4 = ne_log_obj();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_1000642C0(v4);
    }
    return 0;
  }
  return v3;
}

_QWORD *sub_10003F3C4(const void *a1, size_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  if (!a1)
    return 0;
  v4 = sub_10003F1F8(a2);
  v5 = v4;
  if (v4)
    memcpy((void *)v4[1], a1, a2);
  return v5;
}

BOOL sub_10003F41C(int a1)
{
  return (a1 - 6) < 0xA;
}

uint64_t sub_10003F42C(_BOOL8 a1, uint64_t a2)
{
  _QWORD *v3;
  BOOL v4;
  NSObject *v5;
  uint64_t *v6;
  int v7;
  const char *v8;
  int v9;
  const void *v10;
  size_t v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  void *v16;
  NSObject *v17;
  uint64_t v18;
  int v20;
  uint64_t *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  const char *v25;

  v3 = (_QWORD *)a1;
  if (*(_QWORD *)(a1 + 72))
    v4 = dword_10008BA20 == 0;
  else
    v4 = 1;
  if (!v4)
  {
    v5 = ne_log_obj(a1);
    a1 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
    if (a1)
    {
      v6 = sub_10003C570((const sockaddr *)a2);
      v7 = *(_DWORD *)(v3[9] + 52);
      if (*(_DWORD *)(v3[8] + 176) == 2)
        v8 = "(NAT-T forced)";
      else
        v8 = (const char *)&unk_10007E079;
      v20 = 136315650;
      v21 = v6;
      v22 = 1024;
      v23 = v7;
      v24 = 2080;
      v25 = v8;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Hashing %s with algo #%d %s\n", (uint8_t *)&v20, 0x1Cu);
    }
  }
  v9 = *(unsigned __int8 *)(a2 + 1);
  if (v9 == 30)
  {
    v10 = (const void *)(a2 + 8);
    v11 = 16;
  }
  else
  {
    if (v9 != 2)
    {
      if (dword_10008BA20)
      {
        v17 = ne_log_obj(a1);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          sub_100064300();
      }
      return 0;
    }
    v10 = (const void *)(a2 + 4);
    v11 = 4;
  }
  v12 = sub_10003F1F8(v11 + 18);
  if (!v12)
    return 0;
  v13 = v12;
  v14 = (_QWORD *)v12[1];
  *v14 = *v3;
  v14[1] = v3[1];
  v15 = v14 + 2;
  v16 = v14 + 2;
  if (*(_DWORD *)(v3[8] + 176) == 2)
    bzero(v16, v11);
  else
    memcpy(v16, v10, v11);
  *(_WORD *)((char *)v15 + v11) = *(_WORD *)(a2 + 2);
  v18 = sub_100029C9C((uint64_t)v13, (uint64_t)v3);
  sub_10003F318(v13);
  return v18;
}

uint64_t sub_10003F610(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  int v6;
  uint64_t *v7;
  uint64_t *v8;
  int v9;
  int v10;
  BOOL v11;
  uint64_t *v12;
  int v13;
  uint64_t v14;
  uint64_t v15;

  if (*(_DWORD *)(*(_QWORD *)(a1 + 64) + 176) == 2)
    return 0;
  v6 = **(_DWORD **)(a1 + 88);
  v7 = (uint64_t *)(a1 + 48);
  if (a3)
    v8 = (uint64_t *)(a1 + 48);
  else
    v8 = (uint64_t *)(a1 + 56);
  if (a3)
    v9 = -5;
  else
    v9 = -3;
  if (a3)
  {
    v7 = (uint64_t *)(a1 + 56);
    v10 = -3;
  }
  else
  {
    v10 = -5;
  }
  v11 = v6 == 14;
  if (v6 == 14)
    v12 = v7;
  else
    v12 = v8;
  if (v11)
    v13 = v10;
  else
    v13 = v9;
  v14 = sub_10003F42C(a1, *v12);
  if (*(_QWORD *)a2 == *(_QWORD *)v14 && !memcmp(*(const void **)(a2 + 8), *(const void **)(v14 + 8), *(_QWORD *)a2))
  {
    *(_DWORD *)(a1 + 96) &= v13;
    v3 = 1;
  }
  else
  {
    v3 = 0;
  }
  v15 = *(_QWORD *)(a1 + 440);
  if (v15)
    *(_DWORD *)(v15 + 284) = *(_DWORD *)(a1 + 96);
  sub_10003F318((_QWORD *)v14);
  return v3;
}

uint64_t sub_10003F6F0(int a1)
{
  _BOOL4 v1;

  v1 = a1 == 61443 || a1 == 61444;
  return (a1 - 3) < 2 || v1;
}

uint64_t sub_10003F71C(uint64_t a1, int a2)
{
  int v4;
  uint64_t result;
  __int16 v6;
  __int16 v7;
  __int16 v8;
  __int16 v9;
  __int16 v10;
  NSObject *v11;

  if (!a1)
    return 0xFFFFFFFFLL;
  *(_DWORD *)a1 = a2;
  v4 = a2 - 6;
  if ((a2 - 6) >= 0xA)
  {
    if (dword_10008BA20)
    {
      v11 = ne_log_obj(a1);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        sub_100064360(a2, v11);
    }
    return 0xFFFFFFFFLL;
  }
  else
  {
    result = 0;
    v6 = word_10006A37C[v4];
    v7 = word_10006A390[v4];
    v8 = word_10006A3A4[v4];
    v9 = word_10006A3B8[v4];
    v10 = word_10006A3CC[v4];
    *(_WORD *)(a1 + 4) = *(_WORD *)(qword_10008B848 + 18);
    *(_WORD *)(a1 + 14) = v6;
    *(_WORD *)(a1 + 16) = v7;
    *(_WORD *)(a1 + 6) = v8;
    *(_WORD *)(a1 + 8) = v9;
    *(_WORD *)(a1 + 10) = 2;
    *(_WORD *)(a1 + 12) = v10;
  }
  return result;
}

uint64_t sub_10003F804(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  int v9;
  size_t v10;
  int v11;
  uint64_t v12;
  NSObject *v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  _BYTE *v18;
  int v19;
  void *v20;
  const void *v21;
  NSObject *v22;
  NSObject *v23;
  uint64_t v24;
  NSObject *v25;
  _BYTE *v27;
  int v28;
  void *v29;
  const void *v30;
  size_t __len;

  *a3 = 0;
  *a2 = 0;
  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 256) + 88);
  if (!v3)
    return 0;
  v4 = *(unsigned __int16 *)(v3 + 16);
  if (*(_WORD *)(v3 + 16))
  {
    v7 = *(unsigned __int8 **)(a1 + 8 * (*(_BYTE *)(a1 + 60) == 0));
    v8 = *(unsigned __int8 **)(a1 + 8 * (*(_BYTE *)(a1 + 60) != 0));
    v9 = v8[1];
    if (v9 == 2)
    {
      v10 = 4;
    }
    else
    {
      if (v9 != 30)
      {
        if (!dword_10008BA20)
          return 0xFFFFFFFFLL;
        v13 = ne_log_obj(a1);
        if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
          return 0xFFFFFFFFLL;
        goto LABEL_13;
      }
      v10 = 16;
    }
    v11 = v7[1];
    if (v11 == 2)
    {
      v12 = 4;
      goto LABEL_15;
    }
    if (v11 == 30)
    {
      v12 = 16;
LABEL_15:
      v14 = sub_10003F1F8(v10 + 4);
      if (v14)
      {
        v15 = v14;
        __len = v12;
        v16 = sub_10003F1F8(v12 + 4);
        if (v16)
        {
          v17 = v16;
          v18 = (_BYTE *)v15[1];
          v19 = v8[1];
          if (v19 == 30)
          {
            *v18 = 5;
            v20 = v18 + 4;
            v21 = v8 + 8;
          }
          else
          {
            if (v19 != 2)
              goto LABEL_33;
            *v18 = 1;
            v20 = v18 + 4;
            v21 = v8 + 4;
          }
          memmove(v20, v21, v10);
LABEL_33:
          v27 = (_BYTE *)v17[1];
          v28 = v7[1];
          if (v28 == 30)
          {
            *v27 = 5;
            v29 = v27 + 4;
            v30 = v7 + 8;
          }
          else
          {
            if (v28 != 2)
            {
LABEL_38:
              *a2 = v15;
              *a3 = v17;
              return v4;
            }
            *v27 = 1;
            v29 = v27 + 4;
            v30 = v7 + 4;
          }
          memmove(v29, v30, __len);
          goto LABEL_38;
        }
        sub_10003F318(v15);
        if (!dword_10008BA20)
          return 0xFFFFFFFFLL;
        v25 = ne_log_obj(v24);
        if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          return 0xFFFFFFFFLL;
      }
      else
      {
        if (!dword_10008BA20)
          return 0xFFFFFFFFLL;
        v23 = ne_log_obj(0);
        if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          return 0xFFFFFFFFLL;
      }
      sub_100064448();
      return 0xFFFFFFFFLL;
    }
    if (!dword_10008BA20)
      return 0xFFFFFFFFLL;
    v22 = ne_log_obj(a1);
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      return 0xFFFFFFFFLL;
LABEL_13:
    sub_1000643E8();
    return 0xFFFFFFFFLL;
  }
  return v4;
}

char *sub_10003FA50(uint64_t a1)
{
  int v2;
  char *result;
  NSObject *v4;
  NSObject *v5;
  NSObject *v6;

  v2 = **(unsigned __int8 **)(a1 + 8);
  if (v2 != 5)
  {
    if (v2 != 1)
    {
      if (dword_10008BA20)
      {
        v4 = ne_log_obj(a1);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
          sub_100064474();
      }
      return 0;
    }
    result = (char *)malloc_type_malloc(0x10uLL, 0x1000040451B5BE8uLL);
    if (result)
    {
      *(_DWORD *)result = 528;
      *((_DWORD *)result + 1) = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 4);
      return result;
    }
    if (!dword_10008BA20)
      return 0;
    v5 = ne_log_obj(0);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      return 0;
    goto LABEL_15;
  }
  result = (char *)malloc_type_malloc(0x1CuLL, 0x100004027586B93uLL);
  if (result)
  {
    *(_DWORD *)result = 7708;
    *(_OWORD *)(result + 8) = *(_OWORD *)(*(_QWORD *)(a1 + 8) + 4);
    return result;
  }
  if (dword_10008BA20)
  {
    v6 = ne_log_obj(0);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
LABEL_15:
      sub_1000644D4();
  }
  return 0;
}

void sub_10003FB84(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 96) & 6) != 0 && *(_WORD *)(*(_QWORD *)(a1 + 88) + 4))
  {
    if (*(unsigned __int16 *)sub_10003D2DC(*(_QWORD *)(a1 + 56)) == bswap32(*(unsigned __int16 *)(qword_10008B848 + 16)) >> 16)
      sub_10003D350(*(_QWORD *)(a1 + 56), *(unsigned __int16 *)(*(_QWORD *)(a1 + 88) + 4));
    if (*(unsigned __int16 *)sub_10003D2DC(*(_QWORD *)(a1 + 48)) == bswap32(*(unsigned __int16 *)(qword_10008B848 + 16)) >> 16)
      sub_10003D350(*(_QWORD *)(a1 + 48), *(unsigned __int16 *)(*(_QWORD *)(a1 + 88) + 4));
    *(_DWORD *)(a1 + 96) |= 0x28u;
    if (*(_BYTE *)(a1 + 80) == 16)
      sub_10004C0C0((uint64_t *)a1);
  }
}

void sub_10003FC4C(uint64_t a1, int a2)
{
  void *v4;
  int v5;
  int v6;
  int *v7;
  NSObject *v8;

  if (*(_QWORD *)(a1 + 88)
    || (v4 = malloc_type_calloc(1uLL, 0x14uLL, 0x1000040EF768F96uLL), (*(_QWORD *)(a1 + 88) = v4) != 0))
  {
    v5 = sub_10004E4AC(a1);
    if (v5)
      v6 = v5;
    else
      v6 = a2;
    v7 = *(int **)(a1 + 88);
    if (*v7 < v6 && !sub_10003F71C((uint64_t)v7, v6))
      *(_DWORD *)(a1 + 96) |= 1u;
  }
  else if (dword_10008BA20)
  {
    v8 = ne_log_obj(0);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      sub_100064500();
  }
}

BOOL sub_10003FD00()
{
  return sub_100038CC8((uint64_t (*)(uint64_t, uint64_t))sub_10003FD28, 0) != 0;
}

uint64_t sub_10003FD28(uint64_t result)
{
  if (!*(_DWORD *)(result + 176))
    return 0;
  return result;
}

_QWORD *sub_10003FD38(_QWORD *a1, _OWORD *a2)
{
  unint64_t v4;
  _QWORD *v5;
  int v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  unint64_t i;

  if (!a2)
    return 0;
  a2[4] = 0u;
  a2[5] = 0u;
  a2[2] = 0u;
  a2[3] = 0u;
  *a2 = 0u;
  a2[1] = 0u;
  v4 = (unint64_t)sub_10003EFDC(15);
  *(_QWORD *)a2 = v4;
  v5 = sub_10003EFDC(14);
  *((_QWORD *)a2 + (v4 != 0)) = v5;
  if (v4)
    v6 = 2;
  else
    v6 = 1;
  if (v5)
    LODWORD(v4) = v6;
  else
    LODWORD(v4) = v4 != 0;
  v7 = sub_10003EFDC(13);
  *((_QWORD *)a2 + v4) = v7;
  if (v7)
    LODWORD(v4) = v4 + 1;
  v8 = sub_10003EFDC(12);
  *((_QWORD *)a2 + v4) = v8;
  if (v8)
    LODWORD(v4) = v4 + 1;
  v9 = sub_10003EFDC(11);
  *((_QWORD *)a2 + v4) = v9;
  if (v9)
    LODWORD(v4) = v4 + 1;
  v10 = sub_10003EFDC(10);
  *((_QWORD *)a2 + v4) = v10;
  if (v10)
    LODWORD(v4) = v4 + 1;
  v11 = sub_10003EFDC(9);
  *((_QWORD *)a2 + v4) = v11;
  if (v11)
    LODWORD(v4) = v4 + 1;
  v12 = sub_10003EFDC(8);
  *((_QWORD *)a2 + v4) = v12;
  if (v12)
    LODWORD(v4) = v4 + 1;
  v13 = sub_10003EFDC(6);
  *((_QWORD *)a2 + v4) = v13;
  if (v13)
    LODWORD(v4) = v4 + 1;
  v14 = sub_10003EFDC(7);
  *((_QWORD *)a2 + v4) = v14;
  if (v14)
    v4 = (v4 + 1);
  else
    v4 = v4;
  if ((_DWORD)v4)
  {
    for (i = 0; i < v4; ++i)
      a1 = sub_10002662C(a1, *((_QWORD *)a2 + i), 13);
  }
  return a1;
}

uint64_t sub_10003FE7C(int a1, int a2, unsigned int a3)
{
  int v3;

  if (a1 == 14)
  {
    v3 = 2;
    return sub_10003FEB4(v3, a2, a3);
  }
  if (a1 == 15)
  {
    v3 = 3;
    return sub_10003FEB4(v3, a2, a3);
  }
  __ipsec_errcode = 2;
  return 0xFFFFFFFFLL;
}

uint64_t sub_10003FEB4(int a1, int a2, unsigned int a3)
{
  unsigned __int8 *v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t result;
  int v9;

  v4 = sub_10003FF3C(a1, a2);
  if (!v4)
    return 0xFFFFFFFFLL;
  v5 = *((unsigned __int16 *)v4 + 1);
  v6 = *((unsigned __int16 *)v4 + 2);
  if (v5 <= a3 && v6 >= a3)
  {
    v9 = 0;
    result = 0;
  }
  else
  {
    fprintf(__stderrp, "%d %d %d\n", a3, v5, v6);
    result = 0xFFFFFFFFLL;
    v9 = 14;
  }
  __ipsec_errcode = v9;
  return result;
}

unsigned __int8 *sub_10003FF3C(int a1, int a2)
{
  uint64_t v2;
  int v3;
  unsigned __int8 *result;
  unsigned __int16 *v5;
  unsigned int v6;
  int v7;

  v2 = 0;
  while (dword_10006A3F4[v2] != a1)
  {
    if (++v2 == 3)
      goto LABEL_6;
  }
  if (v2 == 0xFFFFFFFFLL)
  {
LABEL_6:
    v3 = 2;
LABEL_7:
    result = 0;
    __ipsec_errcode = v3;
    return result;
  }
  v5 = (unsigned __int16 *)qword_10008B200[v2];
  if (!v5)
  {
    v3 = 22;
    goto LABEL_7;
  }
  v6 = *v5;
  if (v6 < 0x10)
  {
LABEL_14:
    v3 = 1;
    goto LABEL_7;
  }
  result = (unsigned __int8 *)(v5 + 4);
  v7 = v6 + 8;
  while (*result != a2)
  {
    result += 8;
    v7 -= 8;
    if (v7 <= 23)
      goto LABEL_14;
  }
  return result;
}

uint64_t sub_10003FFD8(int a1, int a2, _QWORD *a3)
{
  int v5;
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  uint64_t v8;

  if (a3)
  {
    v5 = 2;
    if (a1 != 14)
    {
      if (a1 != 15)
      {
        v8 = 0xFFFFFFFFLL;
        goto LABEL_9;
      }
      v5 = 3;
    }
    v6 = sub_10003FF3C(v5, a2);
    if (!v6)
      return 0xFFFFFFFFLL;
    v7 = v6;
    v5 = 0;
    v8 = 0;
    *a3 = *(_QWORD *)v7;
  }
  else
  {
    v8 = 0xFFFFFFFFLL;
    v5 = 2;
  }
LABEL_9:
  __ipsec_errcode = v5;
  return v8;
}

uint64_t sub_10004005C(unsigned int a1, int a2)
{
  int v2;
  uint64_t result;

  __ipsec_errcode = 0;
  if ((a2 - 101) >= 0xFFFFFF9C)
    v2 = a2;
  else
    v2 = 100;
  switch(a1)
  {
    case 0u:
      result = 0;
      dword_1000884D0 = v2;
      break;
    case 1u:
      result = 0;
      dword_1000884D4 = v2;
      break;
    case 2u:
      result = 0;
      dword_1000884D8 = v2;
      break;
    case 3u:
      result = 0;
      dword_1000884DC = v2;
      break;
    default:
      *(_DWORD *)a1 = 2;
      result = 1;
      break;
  }
  return result;
}

uint64_t sub_1000400EC(int a1)
{
  uint64_t result;

  switch(a1)
  {
    case 0:
      result = dword_1000884D0;
      break;
    case 1:
      result = dword_1000884D4;
      break;
    case 2:
      result = dword_1000884D8;
      break;
    case 3:
      result = dword_1000884DC;
      break;
    default:
      result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t sub_100040148(int a1, char a2, char a3, unsigned __int8 *a4, unsigned __int8 *a5, unsigned int a6, unsigned int a7, int a8, int a9, int a10, unsigned int a11, int a12, int a13, char a14)
{
  int v16;
  char v23;
  int v24;
  int v25;
  int v26;
  BOOL v27;
  char v28;
  uint64_t v29;
  _QWORD *v30;
  _QWORD *v31;
  pid_t v32;
  unint64_t v33;
  char *v34;
  char *v35;
  ssize_t v36;
  int *v38;
  char *v39;
  char v40;
  char v41;

  if (!a4 || !a5)
  {
    v24 = 2;
    goto LABEL_38;
  }
  v16 = a4[1];
  if (v16 != a5[1])
  {
    v24 = 24;
    goto LABEL_38;
  }
  if (a6 > a7 || a6 - 1 <= 0xFE)
  {
    v24 = 18;
    goto LABEL_38;
  }
  if (v16 != 2)
  {
    if (v16 == 30)
    {
      v23 = 0x80;
      goto LABEL_13;
    }
    v24 = 15;
LABEL_38:
    __ipsec_errcode = v24;
    return 0xFFFFFFFFLL;
  }
  v23 = 32;
LABEL_13:
  v41 = v23;
  if (a9)
    v25 = 82;
  else
    v25 = 50;
  v26 = v25 + ((*a4 - 1) | 7) + ((*a5 - 1) | 7);
  v27 = a6 < 0x100 || a7 == -1;
  v28 = v27;
  v40 = v28;
  if (!v27)
    v26 += 16;
  v29 = v26;
  v30 = malloc_type_calloc(1uLL, v26, 0x87EE41D3uLL);
  if (!v30)
  {
    v38 = __error();
    v39 = strerror(*v38);
    __ipsec_set_strerror(v39);
    return 0xFFFFFFFFLL;
  }
  v31 = v30;
  v32 = getpid();
  if ((int)v29 <= 15)
    goto LABEL_36;
  *v31 = 0;
  v31[1] = 0;
  *(_WORD *)v31 = 258;
  *((_BYTE *)v31 + 2) = 0;
  *((_BYTE *)v31 + 3) = a2;
  *((_DWORD *)v31 + 1) = (unsigned __int16)(v29 >> 3);
  *((_DWORD *)v31 + 2) = a13;
  *((_DWORD *)v31 + 3) = v32;
  if (v29 <= 0x1F)
    goto LABEL_36;
  v33 = (unint64_t)v31 + v29;
  v31[2] = 0;
  v31[3] = 0;
  *((_DWORD *)v31 + 4) = 1245186;
  *((_BYTE *)v31 + 20) = a3;
  *((_DWORD *)v31 + 7) = a8;
  *((_BYTE *)v31 + 21) = a14;
  *((_WORD *)v31 + 11) |= 1u;
  v34 = sub_100040458((_WORD *)v31 + 16, (unint64_t)v31 + v29, 5, a4, v41, 255);
  if (!v34)
    goto LABEL_36;
  v35 = sub_100040458(v34, (unint64_t)v31 + v29, 6, a5, v41, 255);
  if (!v35)
    goto LABEL_36;
  if (a9)
  {
    if ((unint64_t)(v35 + 32) > v33)
      goto LABEL_36;
    *(_OWORD *)v35 = 0u;
    *((_OWORD *)v35 + 1) = 0u;
    *(_QWORD *)v35 = 196612;
    *((_QWORD *)v35 + 1) = 0;
    *((_QWORD *)v35 + 2) = a11;
    *((_QWORD *)v35 + 3) = 0;
    v35 += 32;
  }
  if ((v40 & 1) != 0)
    goto LABEL_35;
  if ((unint64_t)(v35 + 16) > v33)
  {
LABEL_36:
    free(v31);
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)v35 = 1048578;
  *((_DWORD *)v35 + 1) = a6;
  *((_DWORD *)v35 + 2) = a7;
  *((_DWORD *)v35 + 3) = 0;
  v35 += 16;
LABEL_35:
  if (v35 != (char *)v33)
    goto LABEL_36;
  v36 = sub_1000405B4(a1, v31, v29);
  free(v31);
  if ((v36 & 0x80000000) == 0)
  {
    __ipsec_errcode = 0;
    return v36;
  }
  return 0xFFFFFFFFLL;
}

unint64_t sub_100040414(uint64_t a1, unint64_t a2, char a3, int a4, char a5)
{
  unint64_t result;

  result = a1 + 16;
  if (result > a2)
    return 0;
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_DWORD *)a1 = 1245186;
  *(_BYTE *)(a1 + 4) = a3;
  *(_DWORD *)(a1 + 12) = a4;
  *(_BYTE *)(a1 + 5) = a5;
  *(_WORD *)(a1 + 6) = 1;
  return result;
}

char *sub_100040458(_WORD *a1, unint64_t a2, __int16 a3, unsigned __int8 *a4, char a5, char a6)
{
  int v6;
  uint64_t v7;
  char *v8;

  v6 = (*a4 - 1) | 7;
  v7 = (v6 + 9);
  v8 = (char *)a1 + v7;
  if ((unint64_t)a1 + v7 > a2)
    return 0;
  bzero(a1, (v6 + 9));
  *a1 = v7 >> 3;
  a1[1] = a3;
  *((_BYTE *)a1 + 4) = a6;
  *((_BYTE *)a1 + 5) = a5;
  a1[3] = 0;
  memcpy(a1 + 4, a4, *a4);
  return v8;
}

unint64_t sub_1000404F4(uint64_t a1, unint64_t a2, int a3, int a4, unsigned int a5, unsigned int a6, unsigned int a7)
{
  unint64_t result;
  unint64_t v9;

  result = a1 + 32;
  if (result > a2)
    return 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_WORD *)a1 = 4;
  *(_WORD *)(a1 + 2) = a3;
  if (a3 == 3)
  {
    *(_DWORD *)(a1 + 4) = a4;
    *(_QWORD *)(a1 + 8) = a5;
    *(_QWORD *)(a1 + 16) = a6;
    goto LABEL_8;
  }
  if (a3 == 4)
  {
    *(_DWORD *)(a1 + 4) = dword_1000884D0 * a4 / 0x64u;
    v9 = dword_1000884D8 * a6 / 0x64uLL;
    *(_QWORD *)(a1 + 8) = dword_1000884D4 * a5 / 0x64uLL;
    *(_QWORD *)(a1 + 16) = v9;
    a7 = dword_1000884DC * a7 / 0x64;
LABEL_8:
    *(_QWORD *)(a1 + 24) = a7;
  }
  return result;
}

ssize_t sub_1000405B4(int a1, const void *a2, unsigned int a3)
{
  ssize_t result;
  int *v4;
  char *v5;

  result = send(a1, a2, a3, 0);
  if ((result & 0x80000000) != 0)
  {
    v4 = __error();
    v5 = strerror(*v4);
    __ipsec_set_strerror(v5);
    return 0xFFFFFFFFLL;
  }
  else
  {
    __ipsec_errcode = 0;
  }
  return result;
}

uint64_t sub_1000405F8(int a1, int a2, char a3, unsigned __int8 *a4, unsigned __int8 *a5, int a6, int a7, char a8, char *a9, int a10, unsigned int a11, int a12, unsigned int a13, int a14, int a15, unsigned int a16, int a17, unsigned int a18, int a19, unsigned int a20,int a21,int a22,__int16 a23,__int16 a24,char a25)
{
  return sub_10004066C(a1, 2, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a18, a20,
           a22,
           a23,
           SHIWORD(a22),
           a25);
}

uint64_t sub_10004066C(int a1, char a2, int a3, char a4, unsigned __int8 *a5, unsigned __int8 *a6, int a7, int a8, char a9, char *a10, int a11, unsigned int a12, int a13, unsigned int a14, int a15, int a16, unsigned int a17, unsigned int a18, unsigned int a19, int a20,__int16 a21,__int16 a22,char a23)
{
  int v25;
  char v32;
  int v33;
  ifaddrs *v34;
  sockaddr *ifa_addr;
  int sa_family;
  uint64_t v37;
  uint64_t v38;
  int v40;
  uint64_t v41;
  int v43;
  int v44;
  size_t v45;
  pid_t v46;
  int *v47;
  char *v48;
  void *v49;
  unint64_t v50;
  _WORD *v51;
  char *v52;
  uint64_t v53;
  char *ifa_name;
  int v55;
  unint64_t v56;
  ssize_t v57;
  BOOL v58;
  char v59;
  char v60;
  _QWORD *v61;
  ifaddrs *v62;

  v62 = 0;
  if (!a5 || !a6)
  {
    v33 = 2;
    goto LABEL_37;
  }
  v25 = a5[1];
  if (v25 != a6[1])
  {
    v33 = 24;
    goto LABEL_37;
  }
  if (v25 != 2)
  {
    if (v25 == 30)
    {
      v32 = 0x80;
      goto LABEL_10;
    }
    v33 = 15;
LABEL_37:
    __ipsec_errcode = v33;
    return 0xFFFFFFFFLL;
  }
  v32 = 32;
LABEL_10:
  if (a3 == 2)
  {
    if (!a11)
    {
      if (a13)
        goto LABEL_14;
      goto LABEL_34;
    }
LABEL_36:
    v33 = 13;
    goto LABEL_37;
  }
  if (a3 == 9)
  {
    if (a11)
    {
      if (!a13)
        goto LABEL_14;
LABEL_34:
      v33 = 20;
      goto LABEL_37;
    }
    goto LABEL_36;
  }
  if (a3 != 3)
  {
    v33 = 10;
    goto LABEL_37;
  }
  if (!a11)
    goto LABEL_34;
LABEL_14:
  v60 = v32;
  if (getifaddrs(&v62) < 0)
    return 0xFFFFFFFFLL;
  v34 = v62;
  if (!v62)
  {
LABEL_27:
    v40 = 0;
    v59 = 1;
    goto LABEL_43;
  }
  while (1)
  {
    ifa_addr = v34->ifa_addr;
    if (!ifa_addr)
      goto LABEL_26;
    sa_family = ifa_addr->sa_family;
    if (sa_family != a5[1])
      goto LABEL_26;
    if (sa_family == 30)
      break;
    if (sa_family != 2 || *(_DWORD *)&ifa_addr->sa_data[2] == *((_DWORD *)a5 + 1))
      goto LABEL_40;
LABEL_26:
    v34 = v34->ifa_next;
    if (!v34)
      goto LABEL_27;
  }
  v38 = *(_QWORD *)&ifa_addr->sa_data[6];
  v37 = *(_QWORD *)&ifa_addr[1].sa_len;
  if (v38 != *((_QWORD *)a5 + 1) || v37 != *((_QWORD *)a5 + 2))
    goto LABEL_26;
LABEL_40:
  v59 = 0;
  if (v34->ifa_name)
    v40 = 80;
  else
    v40 = 0;
LABEL_43:
  v43 = ((a14 - 1) | 7) + 9;
  if (!a13)
    v43 = 0;
  v58 = a3 != 9 && a11 != 0;
  v44 = ((a12 - 1) | 7) + 147;
  if (!v58)
    v44 = 138;
  v45 = v44 + v43 + ((*a5 - 1) | 7) + ((*a6 - 1) | 7) + v40;
  v61 = malloc_type_calloc(1uLL, v45, 0xE0EAEB3DuLL);
  if (!v61)
  {
    v47 = __error();
    v48 = strerror(*v47);
    __ipsec_set_strerror(v48);
    v41 = 0xFFFFFFFFLL;
    v49 = 0;
LABEL_66:
    if (v62)
      freeifaddrs(v62);
    if (v49)
      free(v49);
    return v41;
  }
  v46 = getpid();
  if ((int)v45 > 15)
  {
    *v61 = 0;
    v61[1] = 0;
    *(_BYTE *)v61 = 2;
    *((_BYTE *)v61 + 1) = a2;
    *((_BYTE *)v61 + 2) = 0;
    *((_BYTE *)v61 + 3) = a3;
    v49 = v61;
    *((_DWORD *)v61 + 1) = (unsigned __int16)(v45 >> 3);
    *((_DWORD *)v61 + 2) = a20;
    *((_DWORD *)v61 + 3) = v46;
    if (v45 < 0x28)
      goto LABEL_65;
    v50 = (unint64_t)v61 + v45;
    v61[2] = 0;
    v61[3] = 0;
    v61[4] = 0;
    *((_DWORD *)v61 + 4) = 65539;
    *((_DWORD *)v61 + 5) = a7;
    *((_BYTE *)v61 + 24) = a9;
    *((_BYTE *)v61 + 25) = 0;
    *((_BYTE *)v61 + 26) = a13;
    *((_BYTE *)v61 + 27) = a11;
    *((_DWORD *)v61 + 7) = a15;
    *((_WORD *)v61 + 16) = a21;
    v51 = (_WORD *)sub_100040414((uint64_t)(v61 + 5), (unint64_t)v61 + v45, a4, a8, a23);
    if (!v51)
      goto LABEL_65;
    v52 = sub_100040458(v51, (unint64_t)v61 + v45, 5, a5, v60, 255);
    if (!v52)
      goto LABEL_65;
    v53 = (uint64_t)sub_100040458(v52, (unint64_t)v61 + v45, 6, a6, v60, 255);
    if (!v53)
      goto LABEL_65;
    if ((v59 & 1) != 0 || (ifa_name = v34->ifa_name) == 0)
    {
      v55 = a13;
    }
    else
    {
      v53 = sub_1000420C0(v53, (unint64_t)v61 + v45, 0, ifa_name, 0, 0);
      v55 = a13;
      if (!v53)
      {
LABEL_65:
        v41 = 0xFFFFFFFFLL;
        goto LABEL_66;
      }
    }
    if ((!v58 || (v53 = (uint64_t)sub_10004216C((_WORD *)v53, (unint64_t)v61 + v45, 9, a10, a12)) != 0)
      && (!v55 || (v53 = (uint64_t)sub_10004216C((_WORD *)v53, (unint64_t)v61 + v45, 8, &a10[a12], a14)) != 0)
      && v53 + 32 <= v50)
    {
      *(_OWORD *)v53 = 0u;
      *(_OWORD *)(v53 + 16) = 0u;
      *(_DWORD *)v53 = 196612;
      *(_DWORD *)(v53 + 4) = a16;
      *(_QWORD *)(v53 + 8) = a17;
      *(_QWORD *)(v53 + 16) = a18;
      *(_QWORD *)(v53 + 24) = a19;
      v56 = sub_1000404F4(v53 + 32, (unint64_t)v61 + v45, 4, a16, a17, a18, a19);
      v41 = 0xFFFFFFFFLL;
      if (v56)
      {
        if (v56 == v50)
        {
          v57 = sub_1000405B4(a1, v61, v45);
          if ((v57 & 0x80000000) == 0)
          {
            v41 = v57;
            __ipsec_errcode = 0;
          }
        }
      }
      goto LABEL_66;
    }
    goto LABEL_65;
  }
  free(v61);
  freeifaddrs(v62);
  return 0xFFFFFFFFLL;
}

uint64_t sub_100040B08(int a1, int a2, char a3, unsigned __int8 *a4, unsigned __int8 *a5, int a6, int a7, char a8, char *a9, int a10, unsigned int a11, int a12, unsigned int a13, int a14, int a15, unsigned int a16, int a17, unsigned int a18, int a19, unsigned int a20,int a21,int a22,__int16 a23,__int16 a24,char a25)
{
  return sub_10004066C(a1, 3, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a18, a20,
           a22,
           a23,
           SHIWORD(a22),
           a25);
}

uint64_t sub_100040B7C(int a1, char a2, uint64_t a3, unsigned __int8 *a4, unsigned __int8 *a5, int a6)
{
  return sub_100040B88(a1, 4, a2, a4, a5, a6);
}

uint64_t sub_100040B88(int a1, char a2, char a3, unsigned __int8 *a4, unsigned __int8 *a5, int a6)
{
  int v8;
  char v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  pid_t v19;
  char *v20;
  char *v21;
  ssize_t v23;
  int *v25;
  char *v26;

  if (!a4 || !a5)
  {
    v14 = 2;
    goto LABEL_20;
  }
  v8 = a4[1];
  if (v8 != a5[1])
  {
    v14 = 24;
    goto LABEL_20;
  }
  if (v8 != 2)
  {
    if (v8 == 30)
    {
      v13 = 0x80;
      goto LABEL_10;
    }
    v14 = 15;
LABEL_20:
    __ipsec_errcode = v14;
    return 0xFFFFFFFFLL;
  }
  v13 = 32;
LABEL_10:
  v15 = ((*a5 - 1) | 7) + ((*a4 - 1) | 7);
  v16 = v15 + 58;
  v17 = malloc_type_calloc(1uLL, v15 + 58, 0x9B366433uLL);
  if (v17)
  {
    v18 = v17;
    v19 = getpid();
    if ((int)v15 <= -43)
      goto LABEL_18;
    *v18 = 0;
    v18[1] = 0;
    *(_BYTE *)v18 = 2;
    *((_BYTE *)v18 + 1) = a2;
    *((_BYTE *)v18 + 2) = 0;
    *((_BYTE *)v18 + 3) = a3;
    *((_DWORD *)v18 + 1) = (unsigned __int16)(v16 >> 3);
    *((_DWORD *)v18 + 2) = 0;
    *((_DWORD *)v18 + 3) = v19;
    if ((int)v15 <= -19)
      goto LABEL_18;
    v18[2] = 0;
    v18[3] = 0;
    v18[4] = 0;
    *((_DWORD *)v18 + 4) = 65539;
    *((_DWORD *)v18 + 5) = a6;
    v18[3] = 0;
    *((_WORD *)v18 + 16) = 0;
    v20 = sub_100040458((_WORD *)v18 + 20, (unint64_t)v18 + v16, 5, a4, v13, 255);
    if (!v20)
      goto LABEL_18;
    v21 = sub_100040458(v20, (unint64_t)v18 + v16, 6, a5, v13, 255);
    if (v21 && v21 == (char *)v18 + v16)
    {
      v23 = sub_1000405B4(a1, v18, v16);
      free(v18);
      if ((v23 & 0x80000000) == 0)
      {
        __ipsec_errcode = 0;
        return v23;
      }
    }
    else
    {
LABEL_18:
      free(v18);
    }
  }
  else
  {
    v25 = __error();
    v26 = strerror(*v25);
    __ipsec_set_strerror(v26);
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100040D74(int a1, char a2, uint64_t a3, unsigned __int8 *a4, unsigned __int8 *a5)
{
  int v7;
  char v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  pid_t v16;
  char *v17;
  char *v18;
  ssize_t v20;
  int *v22;
  char *v23;

  if (!a4 || !a5)
  {
    v11 = 2;
    goto LABEL_19;
  }
  v7 = a4[1];
  if (v7 != a5[1])
  {
    v11 = 24;
    goto LABEL_19;
  }
  if (v7 != 2)
  {
    if (v7 == 30)
    {
      v10 = 0x80;
      goto LABEL_10;
    }
    v11 = 15;
LABEL_19:
    __ipsec_errcode = v11;
    return 0xFFFFFFFFLL;
  }
  v10 = 32;
LABEL_10:
  v12 = ((*a5 - 1) | 7) + ((*a4 - 1) | 7);
  v13 = v12 + 34;
  v14 = malloc_type_calloc(1uLL, v12 + 34, 0x1C648503uLL);
  if (v14)
  {
    v15 = v14;
    v16 = getpid();
    if ((int)v12 <= -19)
      goto LABEL_17;
    *v15 = 0;
    v15[1] = 0;
    *(_WORD *)v15 = 1026;
    *((_BYTE *)v15 + 2) = 0;
    *((_BYTE *)v15 + 3) = a2;
    *((_DWORD *)v15 + 1) = (unsigned __int16)(v13 >> 3);
    *((_DWORD *)v15 + 2) = 0;
    *((_DWORD *)v15 + 3) = v16;
    v17 = sub_100040458((_WORD *)v15 + 8, (unint64_t)v15 + v13, 5, a4, v10, 255);
    if (!v17)
      goto LABEL_17;
    v18 = sub_100040458(v17, (unint64_t)v15 + v13, 6, a5, v10, 255);
    if (v18 && v18 == (char *)v15 + v13)
    {
      v20 = sub_1000405B4(a1, v15, v13);
      free(v15);
      if ((v20 & 0x80000000) == 0)
      {
        __ipsec_errcode = 0;
        return v20;
      }
    }
    else
    {
LABEL_17:
      free(v15);
    }
  }
  else
  {
    v22 = __error();
    v23 = strerror(*v22);
    __ipsec_set_strerror(v23);
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100040F28(int a1, char a2, uint64_t a3, unsigned __int8 *a4, unsigned __int8 *a5, int a6)
{
  return sub_100040B88(a1, 5, a2, a4, a5, a6);
}

uint64_t sub_100040F34(int a1, unsigned int a2)
{
  uint64_t v4;
  void *v5;
  void *v7;

  v4 = 0;
  if (a2)
  {
    while (dword_10006A3F4[v4] != a2)
    {
      if (++v4 == 3)
        goto LABEL_10;
    }
    if (v4 == 0xFFFFFFFFLL)
    {
LABEL_10:
      __ipsec_errcode = 2;
      return 0xFFFFFFFFLL;
    }
    v7 = (void *)qword_10008B200[v4];
    if (v7)
    {
      free(v7);
      qword_10008B200[v4] = 0;
    }
  }
  else
  {
    do
    {
      v5 = *(void **)((char *)qword_10008B200 + v4);
      if (v5)
      {
        free(v5);
        *(uint64_t *)((char *)qword_10008B200 + v4) = 0;
      }
      v4 += 8;
    }
    while (v4 != 24);
  }
  return sub_100041004(a1, 7, a2);
}

uint64_t sub_100041004(int a1, int a2, unsigned int a3)
{
  char v3;
  char v4;
  char *v6;
  char *v7;
  pid_t v8;
  ssize_t v9;
  int *v10;
  char *v11;

  v3 = a3;
  v4 = a2;
  if (a2 == 11)
  {
    if (a3 >= 2)
    {
LABEL_3:
      __ipsec_errcode = 10;
      return 0xFFFFFFFFLL;
    }
  }
  else if (a3 > 9 || ((1 << a3) & 0x20D) == 0)
  {
    goto LABEL_3;
  }
  v6 = (char *)malloc_type_calloc(1uLL, 0x10uLL, 0x862A560uLL);
  if (!v6)
  {
    v10 = __error();
    v11 = strerror(*v10);
    __ipsec_set_strerror(v11);
    return 0xFFFFFFFFLL;
  }
  v7 = v6;
  v8 = getpid();
  *v7 = 2;
  v7[1] = v4;
  v7[2] = 0;
  v7[3] = v3;
  *(_QWORD *)(v7 + 4) = 2;
  *((_DWORD *)v7 + 3) = v8;
  v9 = sub_1000405B4(a1, v7, 0x10u);
  free(v7);
  if ((v9 & 0x80000000) != 0)
    return 0xFFFFFFFFLL;
  __ipsec_errcode = 0;
  return v9;
}

uint64_t sub_1000410F4(int a1)
{
  pid_t v2;
  unsigned __int16 *v3;
  unsigned __int16 *v4;
  unsigned __int16 v5;
  int v6;
  uint64_t result;

  v2 = getpid();
  v3 = sub_1000411A4(a1);
  if (!v3)
    return 0xFFFFFFFFLL;
  v4 = v3;
  while (*((_BYTE *)v4 + 1) != 7 || *((_DWORD *)v4 + 3) != v2)
  {
    free(v4);
    v4 = sub_1000411A4(a1);
    if (!v4)
      return 0xFFFFFFFFLL;
  }
  v5 = 8 * v4[2];
  v4[2] = v5;
  v6 = sub_1000412FC((uint64_t)v4, v5 & 0xFFF8);
  free(v4);
  if (v6)
    return 0xFFFFFFFFLL;
  result = 0;
  __ipsec_errcode = 0;
  return result;
}

unsigned __int16 *sub_1000411A4(int a1)
{
  unint64_t v2;
  int *v3;
  char *v4;
  unsigned __int16 *v5;
  size_t v6;
  ssize_t v7;
  int *v8;
  char *v9;
  int *v10;
  char *v11;
  _QWORD v13[2];

  v13[0] = 0;
  v13[1] = 0;
  while (1)
  {
    v2 = recv(a1, v13, 0x10uLL, 2);
    if ((v2 & 0x8000000000000000) == 0)
      break;
    if (*__error() != 4)
    {
      v3 = __error();
      v4 = strerror(*v3);
      __ipsec_set_strerror(v4);
      return 0;
    }
  }
  if (v2 <= 0xF)
  {
    recv(a1, v13, 0x10uLL, 0);
    v5 = 0;
    __ipsec_errcode = 30;
    return v5;
  }
  v6 = 8 * WORD2(v13[0]);
  v5 = (unsigned __int16 *)malloc_type_calloc(1uLL, v6, 0x87DF477uLL);
  if (!v5)
  {
    v10 = __error();
    v11 = strerror(*v10);
    __ipsec_set_strerror(v11);
    return v5;
  }
  while (1)
  {
    v7 = recv(a1, v5, v6, 0);
    if ((v7 & 0x8000000000000000) == 0)
      break;
    if (*__error() != 4)
    {
      v8 = __error();
      v9 = strerror(*v8);
      __ipsec_set_strerror(v9);
      goto LABEL_16;
    }
  }
  if (v7 == v6 && v6 == 8 * v5[2])
  {
    __ipsec_errcode = 0;
    return v5;
  }
  __ipsec_errcode = 26;
LABEL_16:
  free(v5);
  return 0;
}

uint64_t sub_1000412FC(uint64_t a1, unsigned int a2)
{
  unint64_t v2;
  unsigned __int16 *v3;
  int v4;
  uint64_t result;
  uint64_t v6;
  int v8;
  unsigned __int16 v9;
  uint64_t v10;
  void *v11;
  void *v12;
  int *v13;
  char *v14;

  if (*(unsigned __int16 *)(a1 + 4) == a2)
  {
    v2 = a1 + a2;
    v3 = (unsigned __int16 *)(a1 + 16);
    if (a2 >= 0x18)
    {
      do
      {
        v6 = *v3;
        if (!*v3 || v2 < (unint64_t)v3 + v6)
          break;
        v8 = v3[1];
        if ((v8 & 0xFFFE) != 0xE)
          goto LABEL_4;
        v9 = 8 * v6;
        *v3 = v9;
        if (v8 == 14)
        {
          v10 = 0;
        }
        else
        {
          if (v8 != 15)
            goto LABEL_4;
          v10 = 1;
        }
        v11 = (void *)qword_10008B200[v10];
        if (v11)
        {
          free(v11);
          v9 = *v3;
        }
        v12 = malloc_type_malloc(v9, 0xD3A308D4uLL);
        qword_10008B200[v10] = (uint64_t)v12;
        if (!v12)
        {
          v13 = __error();
          v14 = strerror(*v13);
          __ipsec_set_strerror(v14);
          return 0xFFFFFFFFLL;
        }
        memcpy(v12, v3, *v3);
        v3 = (unsigned __int16 *)((char *)v3 + *v3);
      }
      while ((unint64_t)v3 < v2 && v2 >= (unint64_t)(v3 + 4));
    }
    if (v3 == (unsigned __int16 *)v2)
    {
      result = 0;
      __ipsec_errcode = 0;
      return result;
    }
LABEL_4:
    v4 = 10;
  }
  else
  {
    v4 = 2;
  }
  __ipsec_errcode = v4;
  return 0xFFFFFFFFLL;
}

uint64_t sub_100041430(int a1, unsigned int a2)
{
  return sub_100041004(a1, 9, a2);
}

uint64_t sub_10004143C(int a1, unsigned int a2)
{
  return sub_100041004(a1, 10, a2);
}

uint64_t sub_100041448(int a1, int a2)
{
  return sub_100041004(a1, 11, a2 != 0);
}

ssize_t sub_100041458(int a1, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int a5, char a6, void *__src, int a8, int a9)
{
  return sub_1000414BC(a1, 14, a2, 0, a3, a4, 0, a5, a6, 0, 0, __src, a8, a9, 0, 0, 0, 0);
}

ssize_t sub_1000414BC(int a1, char a2, unsigned __int8 *a3, unsigned __int8 *a4, unsigned int a5, unsigned __int8 *a6, unsigned __int8 *a7, unsigned int a8, char a9, uint64_t a10, uint64_t a11, void *__src, int a13, int a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18)
{
  int v20;
  char v21;
  char v23;
  unsigned int v27;
  int v28;
  BOOL v29;
  int v30;
  int v31;
  ssize_t v32;
  int v34;
  int v35;
  size_t v36;
  char *v37;
  char *v38;
  pid_t v39;
  unsigned int v40;
  unint64_t v41;
  char *v42;
  unint64_t v43;
  char v44;
  __int16 v45;
  unsigned __int8 *v46;
  char v47;
  char v48;
  int *v49;
  char *v50;
  char *v51;
  char *v52;
  unsigned int v53;
  uint64_t v54;
  unsigned int v55;
  int v56;

  if (!a3 || !a6)
  {
    v28 = 2;
LABEL_22:
    __ipsec_errcode = v28;
    return 0xFFFFFFFFLL;
  }
  v20 = a3[1];
  if (v20 != a6[1])
  {
    v28 = 24;
    goto LABEL_22;
  }
  v21 = a8;
  v23 = a5;
  if (v20 == 2)
  {
    v27 = 32;
    goto LABEL_10;
  }
  if (v20 != 30)
  {
    v28 = 15;
    goto LABEL_22;
  }
  v27 = 128;
LABEL_10:
  if (v27 < a5 || v27 < a8)
  {
    v28 = 16;
    goto LABEL_22;
  }
  if (a15 | a16 | a17)
    v29 = 0;
  else
    v29 = a18 == 0;
  v30 = !v29;
  if (a4)
    v31 = ((*a4 - 1) | 7) + 9;
  else
    v31 = 0;
  if (a7)
    v34 = ((*a7 - 1) | 7) + 9;
  else
    v34 = 0;
  v56 = v30;
  if (v30)
    v35 = 80;
  else
    v35 = 0;
  v36 = a13 + ((2 * *a3 - 2) | 0xE) + v31 + v34 + v35 + 66;
  v37 = (char *)malloc_type_calloc(1uLL, v36, 0x4451789CuLL);
  if (!v37)
  {
    v49 = __error();
    v50 = strerror(*v49);
    __ipsec_set_strerror(v50);
    return 0xFFFFFFFFLL;
  }
  v38 = v37;
  v39 = getpid();
  if ((int)v36 <= 15)
    goto LABEL_49;
  v40 = v36;
  v41 = (unint64_t)&v38[v36];
  *(_QWORD *)v38 = 0;
  *((_QWORD *)v38 + 1) = 0;
  *v38 = 2;
  v38[1] = a2;
  *((_WORD *)v38 + 1) = 0;
  v55 = v40;
  *((_DWORD *)v38 + 1) = (unsigned __int16)(v40 >> 3);
  *((_DWORD *)v38 + 2) = a14;
  *((_DWORD *)v38 + 3) = v39;
  v42 = v38 + 16;
  v43 = v41;
  if (a4)
  {
    v44 = a9;
    v42 = sub_100040458(v42, v41, 23, a3, v23, a9);
    if (!v42)
      goto LABEL_49;
    v43 = v41;
    v45 = 24;
    v46 = a4;
    v47 = v23;
    v48 = a9;
  }
  else
  {
    v45 = 5;
    v46 = a3;
    v47 = v23;
    v44 = a9;
    v48 = a9;
  }
  v51 = sub_100040458(v42, v43, v45, v46, v47, v48);
  if (!v51)
    goto LABEL_49;
  if (a7)
  {
    v52 = sub_100040458(v51, v41, 25, a6, v21, v44);
    v53 = v55;
    if (!v52)
      goto LABEL_49;
    v54 = (uint64_t)sub_100040458(v52, v41, 26, a7, v21, v44);
    if (!v54)
      goto LABEL_49;
    goto LABEL_45;
  }
  v54 = (uint64_t)sub_100040458(v51, v41, 6, a6, v21, v44);
  v53 = v55;
  if (!v54)
  {
LABEL_49:
    free(v38);
    return 0xFFFFFFFFLL;
  }
LABEL_45:
  if (v56)
  {
    v54 = sub_1000420C0(v54, v41, (char *)a16, (char *)a17, (char *)a15, a18);
    if (!v54)
      goto LABEL_49;
  }
  if (v54 + 32 > v41)
    goto LABEL_49;
  *(_OWORD *)v54 = 0u;
  *(_OWORD *)(v54 + 16) = 0u;
  *(_QWORD *)v54 = 196612;
  *(_QWORD *)(v54 + 8) = 0;
  *(_QWORD *)(v54 + 16) = a10;
  *(_QWORD *)(v54 + 24) = a11;
  if (v54 + 32 + a13 != v41)
    goto LABEL_49;
  memcpy((void *)(v54 + 32), __src, a13);
  v32 = sub_1000405B4(a1, v38, v53);
  free(v38);
  if ((v32 & 0x80000000) == 0)
  {
    __ipsec_errcode = 0;
    return v32;
  }
  return 0xFFFFFFFFLL;
}

ssize_t sub_10004182C(int a1, unsigned __int8 *a2, unsigned __int8 *a3, unsigned int a4, unsigned __int8 *a5, unsigned __int8 *a6, unsigned int a7, char a8, void *__src, int a10, int a11, __int128 a12, uint64_t a13, int a14)
{
  return sub_1000414BC(a1, 14, a2, a3, a4, a5, a6, a7, a8, 0, 0, __src, a10, a11, a12, *((uint64_t *)&a12 + 1), a13, a14);
}

ssize_t sub_100041898(int a1, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int a5, char a6, uint64_t a7, uint64_t a8, void *a9, int a10, int a11)
{
  return sub_1000414BC(a1, 14, a2, 0, a3, a4, 0, a5, a6, a7, a8, a9, a10, a11, 0, 0, 0, 0);
}

ssize_t sub_1000418FC(int a1, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int a5, char a6, void *__src, int a8, int a9)
{
  return sub_1000414BC(a1, 13, a2, 0, a3, a4, 0, a5, a6, 0, 0, __src, a8, a9, 0, 0, 0, 0);
}

ssize_t sub_100041960(int a1, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int a5, char a6, uint64_t a7, uint64_t a8, void *a9, int a10, int a11)
{
  return sub_1000414BC(a1, 13, a2, 0, a3, a4, 0, a5, a6, a7, a8, a9, a10, a11, 0, 0, 0, 0);
}

ssize_t sub_1000419C4(int a1, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int a5, char a6, void *__src, int a8, int a9)
{
  if (a8 == 16)
    return sub_1000414BC(a1, 15, a2, 0, a3, a4, 0, a5, a6, 0, 0, __src, 16, a9, 0, 0, 0, 0);
  __ipsec_errcode = 2;
  return 0xFFFFFFFFLL;
}

uint64_t sub_100041A4C(int a1, int a2)
{
  return sub_100041A58(a1, 22, a2);
}

uint64_t sub_100041A58(int a1, char a2, int a3)
{
  char *v6;
  char *v7;
  pid_t v8;
  ssize_t v9;
  int *v10;
  char *v11;

  v6 = (char *)malloc_type_calloc(1uLL, 0x20uLL, 0x227B07EuLL);
  if (!v6)
  {
    v10 = __error();
    v11 = strerror(*v10);
    __ipsec_set_strerror(v11);
    return 0xFFFFFFFFLL;
  }
  v7 = v6;
  v8 = getpid();
  *v7 = 2;
  v7[1] = a2;
  *((_WORD *)v7 + 1) = 0;
  *(_QWORD *)(v7 + 4) = 4;
  *((_DWORD *)v7 + 3) = v8;
  *((_QWORD *)v7 + 2) = 1179650;
  *((_DWORD *)v7 + 6) = a3;
  *((_DWORD *)v7 + 7) = 0;
  v9 = sub_1000405B4(a1, v7, 0x20u);
  free(v7);
  if ((v9 & 0x80000000) != 0)
    return 0xFFFFFFFFLL;
  __ipsec_errcode = 0;
  return v9;
}

uint64_t sub_100041B18(int a1, int a2)
{
  return sub_100041A58(a1, 24, a2);
}

uint64_t sub_100041B24(int a1, int a2)
{
  return sub_100041A58(a1, 25, a2);
}

uint64_t sub_100041B30(int a1, int a2)
{
  return sub_100041A58(a1, 16, a2);
}

ssize_t sub_100041B3C(int a1, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int a5, char a6, void *__src, int a8, int a9)
{
  if (a8 == 16)
    return sub_1000414BC(a1, 20, a2, 0, a3, a4, 0, a5, a6, 0, 0, __src, 16, a9, 0, 0, 0, 0);
  __ipsec_errcode = 2;
  return 0xFFFFFFFFLL;
}

uint64_t sub_100041BC4(int a1)
{
  return sub_100041004(a1, 19, 0);
}

uint64_t sub_100041BD0(int a1)
{
  return sub_100041004(a1, 18, 0);
}

uint64_t sub_100041BDC()
{
  uint64_t v0;
  uint64_t v1;
  int v2;
  int *v3;
  char *v4;
  uint64_t v6;
  size_t v7;
  uint64_t v8;
  int v9;

  v7 = 8;
  v8 = 0;
  v6 = 2506752;
  v0 = socket(29, 3, 2);
  if ((v0 & 0x80000000) != 0)
  {
    v3 = __error();
    v4 = strerror(*v3);
    __ipsec_set_strerror(v4);
    return 0xFFFFFFFFLL;
  }
  else
  {
    v1 = v0;
    if (sysctlbyname("kern.ipc.maxsockbuf", &v8, &v7, &v6, 8uLL))
      v2 = 233016;
    else
      v2 = 2228224;
    v9 = v2;
    setsockopt(v1, 0xFFFF, 4097, &v9, 4u);
    setsockopt(v1, 0xFFFF, 4098, &v9, 4u);
    if (v9 == 2228224)
      sysctlbyname("kern.ipc.maxsockbuf", 0, 0, &v8, v7);
    __ipsec_errcode = 0;
  }
  return v1;
}

uint64_t sub_100041CDC(int a1)
{
  uint64_t result;

  result = close(a1);
  __ipsec_errcode = 0;
  return result;
}

uint64_t sub_100041CFC(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  int v4;
  unint64_t v5;
  unint64_t v6;
  unsigned __int16 *v7;
  unsigned __int16 *v8;
  uint64_t v10;

  result = 0xFFFFFFFFLL;
  v4 = 2;
  if (a1 && a2)
  {
    *(_QWORD *)(a2 + 232) = 0;
    *(_OWORD *)(a2 + 216) = 0u;
    *(_OWORD *)(a2 + 200) = 0u;
    *(_OWORD *)(a2 + 184) = 0u;
    *(_OWORD *)(a2 + 168) = 0u;
    *(_OWORD *)(a2 + 152) = 0u;
    *(_OWORD *)(a2 + 136) = 0u;
    *(_OWORD *)(a2 + 120) = 0u;
    *(_OWORD *)(a2 + 104) = 0u;
    *(_OWORD *)(a2 + 88) = 0u;
    *(_OWORD *)(a2 + 72) = 0u;
    *(_OWORD *)(a2 + 56) = 0u;
    *(_OWORD *)(a2 + 40) = 0u;
    *(_OWORD *)(a2 + 24) = 0u;
    *(_OWORD *)(a2 + 8) = 0u;
    v5 = *(unsigned __int16 *)(a1 + 4);
    v6 = a1 + 8 * v5;
    *(_QWORD *)a2 = a1;
    v7 = (unsigned __int16 *)(a1 + 16);
    if (v5 >= 3)
    {
      while (1)
      {
        v8 = &v7[4 * *v7];
        if (!*v7 || v6 < (unint64_t)v8)
          break;
        v10 = v7[1];
        if (*(_QWORD *)(a2 + 8 * v10))
        {
          result = 0xFFFFFFFFLL;
          v4 = 12;
          goto LABEL_11;
        }
        v4 = 12;
        if (v10 > 0x1A || ((1 << v10) & 0x7FDFFFE) == 0)
          goto LABEL_11;
        *(_QWORD *)(a2 + 8 * v10) = v7;
        if ((unint64_t)v8 < v6)
        {
          v7 = v8;
          if (v6 >= (unint64_t)(v8 + 2))
            continue;
        }
        goto LABEL_5;
      }
    }
    v8 = v7;
LABEL_5:
    if (v8 == (unsigned __int16 *)v6)
      v4 = 0;
    else
      v4 = 3;
    if (v8 == (unsigned __int16 *)v6)
      result = 0;
    else
      result = 0xFFFFFFFFLL;
  }
LABEL_11:
  __ipsec_errcode = v4;
  return result;
}

uint64_t sub_100041DFC(uint64_t a1)
{
  _BYTE *v2;
  unsigned int v3;
  uint64_t result;
  int v5;
  int v6;
  char v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;

  if (a1 && (v2 = *(_BYTE **)a1) != 0)
  {
    if (*v2 == 2)
    {
      v3 = v2[1];
      if (v3 <= 0x1A)
      {
        v6 = v2[3];
        result = 0xFFFFFFFFLL;
        v5 = 1;
        switch(v6)
        {
          case 0:
            v7 = v3 - 1;
            if ((v3 - 1) >= 8u)
              goto LABEL_17;
            v8 = 191;
            goto LABEL_14;
          case 1:
            if (v3 == 11)
              goto LABEL_17;
            goto LABEL_24;
          case 2:
          case 3:
          case 9:
            v7 = v3 - 14;
            if (v3 - 14 < 6)
            {
              v8 = 55;
LABEL_14:
              if (((v8 >> v7) & 1) != 0)
                goto LABEL_25;
            }
LABEL_17:
            v9 = *(_QWORD *)(a1 + 40);
            if (!v9)
              goto LABEL_23;
            v10 = *(_QWORD *)(a1 + 48);
            if (!v10)
              goto LABEL_23;
            if (*(unsigned __int8 *)(v9 + 4) == *(unsigned __int8 *)(v10 + 4))
            {
              v11 = *(unsigned __int8 *)(v9 + 9);
              if (v11 == *(unsigned __int8 *)(v10 + 9))
              {
                if (v11 == 30 || v11 == 2)
                {
LABEL_23:
                  v5 = 0;
                  result = 0;
                }
                else
                {
                  v5 = 15;
                }
              }
              else
              {
                v5 = 24;
              }
            }
            else
            {
              v5 = 23;
            }
            break;
          case 5:
          case 6:
          case 7:
          case 8:
            break;
          default:
LABEL_24:
            result = 0xFFFFFFFFLL;
LABEL_25:
            v5 = 10;
            break;
        }
      }
      else
      {
        result = 0xFFFFFFFFLL;
        v5 = 11;
      }
    }
    else
    {
      result = 0xFFFFFFFFLL;
      v5 = 4;
    }
  }
  else
  {
    result = 0xFFFFFFFFLL;
    v5 = 2;
  }
  __ipsec_errcode = v5;
  return result;
}

uint64_t sub_100041F2C(int a1, int a2, _QWORD *a3, unsigned int a4, int a5, const void *a6, int a7)
{
  ssize_t v7;
  int v15;
  size_t v16;
  _QWORD *v17;
  _QWORD *v18;
  pid_t v19;
  char *v20;
  uint64_t v21;
  int *v22;
  char *v23;

  v7 = 0xFFFFFFFFLL;
  if (a3 && a6 && a7)
  {
    v15 = 40 * a7;
    v16 = 40 * a7 + 56;
    v17 = malloc_type_calloc(1uLL, v16, 0x951258BBuLL);
    if (v17)
    {
      v18 = v17;
      v19 = getpid();
      if ((int)v16 <= 15)
        goto LABEL_11;
      *v18 = 0;
      v18[1] = 0;
      *(_DWORD *)v18 = 5890;
      *((_DWORD *)v18 + 1) = (unsigned __int16)(v16 >> 3);
      *((_DWORD *)v18 + 2) = a2;
      *((_DWORD *)v18 + 3) = v19;
      if (!a4 || v16 < 0x28)
        goto LABEL_11;
      v20 = (char *)(v18 + 5);
      v18[2] = 0;
      v18[3] = 0;
      v18[4] = 0;
      *((_DWORD *)v18 + 4) = 1310723;
      v18[3] = *a3;
      if (a4 >= 2)
        v18[4] = a3[1];
      v21 = (v15 + 16);
      if (&v20[v21] <= (char *)v18 + v16)
      {
        bzero(v20, (v15 + 16));
        *((_WORD *)v18 + 20) = v21 >> 3;
        *((_WORD *)v18 + 21) = 21;
        *((_DWORD *)v18 + 11) = a5;
        *((_DWORD *)v18 + 13) = a7;
        memmove(v18 + 7, a6, (40 * a7));
        v7 = sub_1000405B4(a1, v18, v16);
        free(v18);
        if ((v7 & 0x80000000) == 0)
        {
          __ipsec_errcode = 0;
          return v7;
        }
      }
      else
      {
LABEL_11:
        free(v18);
      }
    }
    else
    {
      v22 = __error();
      v23 = strerror(*v22);
      __ipsec_set_strerror(v23);
    }
    return 0xFFFFFFFFLL;
  }
  return v7;
}

uint64_t sub_1000420C0(uint64_t a1, unint64_t a2, char *__src, char *a4, char *a5, __int16 a6)
{
  uint64_t v6;

  v6 = a1 + 80;
  if (a1 + 80 > a2)
    return 0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_DWORD *)a1 = 1441802;
  if (__src)
    strncpy((char *)(a1 + 4), __src, 0x17uLL);
  if (a4)
    strncpy((char *)(a1 + 28), a4, 0x17uLL);
  if (a5)
    strncpy((char *)(a1 + 52), a5, 0x17uLL);
  *(_WORD *)(a1 + 76) = a6;
  return v6;
}

char *sub_10004216C(_WORD *a1, unint64_t a2, __int16 a3, const void *a4, unsigned int a5)
{
  int v5;
  uint64_t v6;
  char *v7;

  v5 = (a5 - 1) | 7;
  v6 = (v5 + 9);
  v7 = (char *)a1 + v6;
  if ((unint64_t)a1 + v6 > a2)
    return 0;
  bzero(a1, (v5 + 9));
  *a1 = v6 >> 3;
  a1[1] = a3;
  a1[2] = 8 * a5;
  a1[3] = 0;
  memcpy(a1 + 4, a4, a5);
  return v7;
}

void sub_1000421F8(uint64_t a1, _QWORD *a2)
{
  NSObject *v2;
  uint64_t v4;
  NSObject *v5;
  uint64_t v7;
  uint64_t *v8;
  int v9;
  uint64_t v10;
  _QWORD *v11;
  NSObject *v12;
  uint64_t v13;
  signed int v14;
  unsigned int v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  NSObject *v20;
  unsigned __int8 *v21;
  size_t v22;
  NSObject *v23;
  uint64_t v24;
  unsigned __int16 *v25;
  unsigned int v26;
  size_t v27;
  _QWORD *v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  NSObject *v33;
  unsigned int v34;
  uint64_t v35;
  NSObject *v37;
  const char *v38;
  NSObject *v39;
  uint32_t v40;
  NSObject *v41;
  unsigned int v42;
  NSObject *v43;
  NSObject *v44;
  _QWORD *v45;
  NSObject *v46;
  uint8_t buf[4];
  unsigned int v48;
  __int16 v49;
  int v50;

  if (*a2 <= 0x1BuLL)
  {
    if (dword_10008BA20)
    {
      v2 = ne_log_obj(a1);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_10006452C();
    }
    return;
  }
  v4 = a2[1];
  if ((*(_BYTE *)(v4 + 19) & 1) == 0)
  {
    if (dword_10008BA20)
    {
      v5 = ne_log_obj(a1);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_100064558();
    }
    return;
  }
  v7 = *(_QWORD *)(a1 + 408);
  v8 = *(uint64_t **)(v7 + 1176);
  if (v8)
  {
    v9 = *(_DWORD *)(v4 + 20);
    if (*(_DWORD *)(v7 + 1184) == v9)
      goto LABEL_14;
  }
  else
  {
    v9 = *(_DWORD *)(v4 + 20);
  }
  v8 = sub_1000426F4(a1, v9);
  *(_QWORD *)(*(_QWORD *)(a1 + 408) + 1176) = v8;
LABEL_14:
  v10 = (uint64_t)sub_10002E000(a1, a2, *v8, v8[1]);
  if (!v10)
  {
    if (dword_10008BA20)
    {
      v20 = ne_log_obj(0);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        sub_100064584();
    }
    return;
  }
  v11 = (_QWORD *)v10;
  if (dword_10008BA20)
  {
    v12 = ne_log_obj(v10);
    v10 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
    if ((_DWORD)v10)
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "MODE_CFG packet\n", buf, 2u);
    }
  }
  v13 = v11[1];
  v14 = *(_DWORD *)v11 - 28;
  v15 = *(unsigned __int8 *)(v13 + 16);
  if (v14 < 1 || v15 == 0)
  {
LABEL_23:
    v17 = sub_100008AA0(a1, *(_DWORD *)(v13 + 20));
    if (v17)
    {
      v18 = v17;
      v19 = *(unsigned int *)(v17 + 68);
      if ((_DWORD)v19)
      {
        sub_10003A6F0(v19);
        *(_DWORD *)(v18 + 68) = 0;
      }
      sub_10004A9EC((_QWORD *)v18);
    }
    goto LABEL_27;
  }
  v21 = (unsigned __int8 *)(v13 + 28);
  while (1)
  {
    if (v14 <= 3)
    {
      if (!dword_10008BA20)
        goto LABEL_27;
      v37 = ne_log_obj(v10);
      if (!os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
        goto LABEL_27;
      *(_WORD *)buf = 0;
      v38 = "Short payload header\n";
      goto LABEL_60;
    }
    v22 = v14;
    if (v14 < bswap32(*((unsigned __int16 *)v21 + 1)) >> 16)
    {
      if (!dword_10008BA20)
        goto LABEL_27;
      v37 = ne_log_obj(v10);
      if (!os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
        goto LABEL_27;
      *(_WORD *)buf = 0;
      v38 = "Short payload\n";
LABEL_60:
      v39 = v37;
      v40 = 2;
      goto LABEL_61;
    }
    if (dword_10008BA20)
    {
      v23 = ne_log_obj(v10);
      v10 = os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)v10)
      {
        *(_DWORD *)buf = 67109120;
        v48 = v15;
        _os_log_debug_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEBUG, "Seen payload %d\n", buf, 8u);
      }
    }
    if (v15 == 14)
    {
      v10 = sub_10004277C(a1, *(_DWORD *)(v13 + 20), (uint64_t)v21, (uint64_t)a2);
      goto LABEL_48;
    }
    if (v15 != 8)
    {
      if (dword_10008BA20)
      {
        v33 = ne_log_obj(v10);
        v10 = os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT);
        if ((_DWORD)v10)
        {
          *(_DWORD *)buf = 67109120;
          v48 = v15;
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "Unexpected next payload %d\n", buf, 8u);
        }
      }
      goto LABEL_48;
    }
    v24 = bswap32(*((unsigned __int16 *)v21 + 1)) >> 16;
    v25 = (unsigned __int16 *)&v21[v24];
    v26 = bswap32(*(unsigned __int16 *)&v21[v24 + 2]);
    v27 = HIWORD(v26);
    if (v24 + v27 > v22)
    {
      if (!dword_10008BA20)
        goto LABEL_27;
      v41 = ne_log_obj(v10);
      if (!os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
        goto LABEL_27;
      v42 = bswap32(v25[1]);
      *(_DWORD *)buf = 67109376;
      v48 = HIWORD(v42);
      v49 = 1024;
      v50 = v27;
      v38 = "Invalid Hash payload. len %d, overall-len %d\n";
      v39 = v41;
      v40 = 14;
LABEL_61:
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, v38, buf, v40);
      goto LABEL_27;
    }
    v28 = sub_10003F1F8(HIWORD(v26));
    if (!v28)
    {
      if (dword_10008BA20)
      {
        v43 = ne_log_obj(0);
        if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
          sub_100059870();
      }
      goto LABEL_27;
    }
    v29 = v28;
    memcpy((void *)v28[1], v25, v27);
    v30 = sub_10002A3A0(a1, *(_DWORD *)(v13 + 20), (uint64_t)v29);
    if (!v30)
      break;
    v31 = v30;
    v32 = timingsafe_bcmp(v21 + 4, *(const void **)(v31 + 8), *(_QWORD *)v31);
    if ((_DWORD)v32)
    {
      if (dword_10008BA20)
      {
        v46 = ne_log_obj(v32);
        if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
          sub_1000645DC();
      }
      sub_10003F318(v29);
      v45 = (_QWORD *)v31;
      goto LABEL_76;
    }
    sub_10003F318(v29);
    sub_10003F318((_QWORD *)v31);
LABEL_48:
    v34 = bswap32(*((unsigned __int16 *)v21 + 1));
    v35 = HIWORD(v34);
    v14 = v22 - HIWORD(v34);
    v15 = *v21;
    v21 += v35;
    if (v14 < 1 || v15 == 0)
      goto LABEL_23;
  }
  if (dword_10008BA20)
  {
    v44 = ne_log_obj(0);
    if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
      sub_1000645B0();
  }
  v45 = v29;
LABEL_76:
  sub_10003F318(v45);
LABEL_27:
  sub_10003F318(v11);
}

uint64_t *sub_1000426F4(uint64_t a1, int a2)
{
  uint64_t v2;
  _QWORD *v5;
  uint64_t *result;
  NSObject *v7;

  v2 = *(_QWORD *)(a1 + 408);
  if (v2)
  {
    v5 = *(_QWORD **)(v2 + 1176);
    if (v5)
      sub_10002DA18(v5);
    result = sub_10002DA88(a1, a2);
    *(_QWORD *)(v2 + 1176) = result;
    *(_DWORD *)(v2 + 1184) = a2;
  }
  else
  {
    if (dword_10008BA20)
    {
      v7 = ne_log_obj(a1);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_100064608();
    }
    return 0;
  }
  return result;
}

uint64_t sub_10004277C(_BOOL8 a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  int v8;
  NSObject *v9;
  uint64_t result;
  NSObject *v11;
  int v12;
  char *v13;

  v7 = a1;
  v8 = *(unsigned __int8 *)(a3 + 4);
  if (dword_10008BA20)
  {
    v9 = ne_log_obj(a1);
    a1 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
    if (a1)
    {
      v12 = 136315138;
      v13 = sub_10003DC88(v8);
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Configuration exchange type %s\n", (uint8_t *)&v12, 0xCu);
    }
  }
  switch(v8)
  {
    case 1:
      *(_DWORD *)(v7 + 84) = a2;
      result = sub_100042F28(v7, (unsigned __int16 *)a3, a4);
      break;
    case 2:
      result = sub_100042928(v7, (unsigned __int16 *)a3);
      break;
    case 3:
      *(_DWORD *)(v7 + 84) = a2;
      result = sub_100043734(v7, (unsigned __int16 *)a3, a4);
      break;
    case 4:
      sub_10002DA18(*(_QWORD **)(*(_QWORD *)(v7 + 408) + 1176));
      result = 0;
      *(_QWORD *)(*(_QWORD *)(v7 + 408) + 1176) = 0;
      break;
    default:
      if (dword_10008BA20)
      {
        v11 = ne_log_obj(a1);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          v12 = 67109120;
          LODWORD(v13) = v8;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Unepected configuration exchange type %d\n", (uint8_t *)&v12, 8u);
        }
      }
      result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t sub_100042928(uint64_t result, unsigned __int16 *a2)
{
  int *v2;
  int v3;
  uint64_t v5;
  unsigned __int16 *v6;
  unsigned int v7;
  unsigned __int16 *v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  NSObject *v13;
  int v14;
  NSObject *v15;
  NSObject *v16;
  char *v17;
  NSObject *v18;
  char *v19;
  uint64_t v20;
  void *v21;
  unsigned int v22;
  size_t v23;
  int *v24;
  int v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  unsigned int v32;
  NSObject *v33;
  _QWORD *v34;
  uint64_t v35;
  NSObject *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  size_t v44;
  _QWORD *v45;
  NSObject *v46;
  NSObject *v47;
  unsigned __int16 *v48;
  uint8_t buf[4];
  char *v50;
  __int16 v51;
  uint64_t v52;

  v2 = *(int **)(result + 408);
  v3 = *v2;
  if ((*v2 & 0x8000) != 0)
    return 0;
  v5 = result;
  v6 = a2 + 1;
  v7 = bswap32(a2[1]) >> 16;
  v8 = a2 + 4;
  if (v7 < 9)
  {
LABEL_54:
    *v2 = v3 | 0x8000;
    if (*(_DWORD *)(v5 + 24)
      || (*(_BYTE *)(v5 + 432) & 1) != 0 && (v43 = *(_QWORD *)(v5 + 440)) != 0 && (*(_WORD *)(v43 + 264) & 0x400) != 0)
    {
      v34 = (_QWORD *)*((_QWORD *)v2 + 149);
      if (v34)
        sub_10003F318(v34);
      v35 = bswap32(*v6) >> 16;
      if (v35 <= 7)
      {
        if (dword_10008BA20)
        {
          v36 = ne_log_obj(v34);
          if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
            sub_100064704((uint64_t)v6, v36, v37, v38, v39, v40, v41, v42);
        }
        return 0xFFFFFFFFLL;
      }
      v44 = v35 - 8;
      v45 = sub_10003F1F8(v35 - 8);
      *(_QWORD *)(*(_QWORD *)(v5 + 408) + 1192) = v45;
      if (!v45)
      {
        if (dword_10008BA20)
        {
          v47 = ne_log_obj(0);
          if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
            sub_100064774();
        }
        return 0xFFFFFFFFLL;
      }
      memcpy((void *)v45[1], v8, v44);
    }
    if ((*(_BYTE *)(v5 + 17) & 0x20) != 0)
      sub_100048B0C(0, 0, v5, 0);
    return 0;
  }
  v9 = v7 - 8;
  v48 = a2 + 4;
  while (1)
  {
    v10 = v9;
    if (v9 <= 3)
      break;
    v11 = (int)bswap32(*v8) >> 16;
    if (v11 < 0)
    {
      v14 = v11 & 0x7FFF;
      if (dword_10008BA20)
      {
        v15 = ne_log_obj(result);
        result = os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG);
        if ((_DWORD)result)
        {
          v31 = sub_10003DC14(v11 & 0x7FFF);
          v32 = bswap32(v8[1]) >> 16;
          *(_DWORD *)buf = 136315394;
          v50 = v31;
          v51 = 1024;
          LODWORD(v52) = v32;
          _os_log_debug_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "Short attribute %s = %d\n", buf, 0x12u);
        }
      }
      if (v14 == 28679)
      {
        sub_100045664(v5, v8);
      }
      else if (v14 == 16520)
      {
        result = sub_100045C1C(v5, v8, bswap32(a2[3]) >> 16);
        if ((_DWORD)result)
          return result;
      }
      else if (dword_10008BA20)
      {
        v18 = ne_log_obj(result);
        result = os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT);
        if ((_DWORD)result)
        {
          v19 = sub_10003DC14(v11 & 0x7FFF);
          *(_DWORD *)buf = 136315138;
          v50 = v19;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Ignored short attribute %s\n", buf, 0xCu);
        }
      }
      v9 = v10 - 4;
      v8 += 2;
      goto LABEL_34;
    }
    v12 = bswap32(v8[1]) >> 16;
    if (v12 + 4 > (unint64_t)v9)
    {
      if (dword_10008BA20)
      {
        v46 = ne_log_obj(result);
        if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
          sub_100064694((unsigned __int16)v11);
      }
      return 0xFFFFFFFFLL;
    }
    if (dword_10008BA20)
    {
      v13 = ne_log_obj(result);
      result = os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)result)
      {
        v26 = sub_10003DC14((unsigned __int16)v11);
        *(_DWORD *)buf = 136315394;
        v50 = v26;
        v51 = 2048;
        v52 = v12;
        _os_log_debug_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "Attribute %s, len %zu\n", buf, 0x16u);
      }
    }
    if ((unsigned __int16)v11 - 28672 > 0xB)
    {
LABEL_11:
      if ((unsigned __int16)v11 - 16520 >= 0xA)
      {
        switch((__int16)v11)
        {
          case 1:
            v27 = *(_QWORD *)(v5 + 408);
            if ((*(_BYTE *)v27 & 0x80) != 0)
              goto LABEL_23;
            sub_100043ABC((uint64_t)v8, (_DWORD *)(v27 + 40));
            v24 = *(int **)(v5 + 408);
            v25 = *v24 | 0x80;
            goto LABEL_50;
          case 2:
            v28 = *(_QWORD *)(v5 + 408);
            if ((*(_BYTE *)(v28 + 1) & 1) != 0)
              goto LABEL_23;
            sub_100043ABC((uint64_t)v8, (_DWORD *)(v28 + 44));
            v24 = *(int **)(v5 + 408);
            v25 = *v24 | 0x100;
            goto LABEL_50;
          case 3:
            v29 = *(_QWORD *)(v5 + 408);
            if ((*(_BYTE *)(v29 + 1) & 2) != 0)
              goto LABEL_23;
            sub_100043B1C((uint64_t)v8, (_DWORD *)(v29 + 4 * *(int *)(v29 + 60) + 48), (_DWORD *)(v29 + 60));
            v24 = *(int **)(v5 + 408);
            v25 = *v24 | 0x200;
            goto LABEL_50;
          case 4:
            v30 = *(_QWORD *)(v5 + 408);
            if ((*(_BYTE *)(v30 + 1) & 4) != 0)
              goto LABEL_23;
            sub_100043B1C((uint64_t)v8, (_DWORD *)(v30 + 4 * *(int *)(v30 + 80) + 64), (_DWORD *)(v30 + 80));
            v24 = *(int **)(v5 + 408);
            v25 = *v24 | 0x400;
            goto LABEL_50;
          case 5:
          case 13:
            if (!*(_DWORD *)(v5 + 24))
              goto LABEL_26;
            goto LABEL_23;
          case 7:
            goto LABEL_22;
          default:
LABEL_26:
            if (dword_10008BA20)
            {
              v16 = ne_log_obj(result);
              result = os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT);
              if ((_DWORD)result)
              {
                v17 = sub_10003DC14((unsigned __int16)v11);
                *(_DWORD *)buf = 136315138;
                v50 = v17;
                _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Ignored attribute %s\n", buf, 0xCu);
              }
            }
            goto LABEL_23;
        }
      }
      result = sub_100045C1C(v5, v8, bswap32(a2[3]) >> 16);
      if ((_DWORD)result)
        return result;
      goto LABEL_23;
    }
    if (((1 << v11) & 0xF7B) != 0)
    {
LABEL_22:
      sub_100045664(v5, v8);
    }
    else
    {
      if ((unsigned __int16)v11 != 28674)
        goto LABEL_11;
      v20 = *(_QWORD *)(v5 + 408);
      if ((*(_BYTE *)(v20 + 1) & 0x10) == 0)
      {
        v21 = (void *)(v20 + 84);
        v22 = bswap32(v8[1]) >> 16;
        if (v22 >= 0x400)
          v23 = 1024;
        else
          v23 = v22;
        result = (uint64_t)memcpy(v21, v8 + 2, v23);
        v24 = *(int **)(v5 + 408);
        v25 = *v24 | 0x1000;
LABEL_50:
        *v24 = v25;
      }
    }
LABEL_23:
    v8 = (unsigned __int16 *)((char *)v8 + v12 + 4);
    v9 = v10 - (v12 + 4);
LABEL_34:
    if (v9 <= 0)
    {
      v2 = *(int **)(v5 + 408);
      v3 = *v2;
      v8 = v48;
      goto LABEL_54;
    }
  }
  if (dword_10008BA20)
  {
    v33 = ne_log_obj(result);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
      sub_100064634();
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100042F28(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  unsigned int v6;
  unsigned __int16 *v7;
  int v8;
  uint64_t v9;
  size_t *v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  NSObject *v15;
  NSObject *v16;
  _QWORD *v17;
  _QWORD *v18;
  NSObject *v19;
  char *v20;
  unsigned int v21;
  NSObject *v22;
  NSObject *v23;
  char *v24;
  unsigned int v25;
  NSObject *v26;
  char *v27;
  char *v28;
  unsigned int v29;
  unsigned __int16 *v30;
  __int128 *v31;
  NSObject *v32;
  int *v33;
  int v34;
  NSObject *v35;
  uint64_t v36;
  int *v37;
  int v38;
  _DWORD *v39;
  NSObject *v40;
  _QWORD *v41;
  NSObject *v42;
  size_t v43;
  NSObject *v44;
  NSObject *v46;
  NSObject *v47;
  NSObject *v48;
  uint64_t v49;
  char v50;
  char v51[15];
  char v52;
  char v53[15];
  char v54;
  char v55[15];
  char v56;
  char v57[15];
  uint8_t buf[4];
  char *v59;
  __int16 v60;
  uint64_t v61;

  v6 = bswap32(a2[1]) >> 16;
  v7 = a2 + 4;
  v8 = v6 - 8;
  if (!*(_DWORD *)(a1 + 24) && !sub_10004DAAC(a1))
  {
    v11 = (uint64_t)sub_10003F1F8(8uLL);
    if (!v11)
    {
      if (dword_10008BA20)
      {
        v46 = ne_log_obj(0);
        if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
          sub_100059870();
      }
      return 0xFFFFFFFFLL;
    }
    v10 = (size_t *)v11;
    v49 = a3;
    **(_QWORD **)(v11 + 8) = 0;
    if (v6 < 9)
    {
LABEL_78:
      v43 = v10[1];
      *(_WORD *)(v43 + 2) = bswap32(*(unsigned __int16 *)v10) >> 16;
      *(_BYTE *)(v43 + 4) = 2;
      *(_WORD *)(v43 + 6) = a2[3];
      if (dword_10008BA20)
      {
        v44 = ne_log_obj(v11);
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "Sending MODE_CFG REPLY\n", buf, 2u);
        }
      }
      v9 = sub_100043C98(a1, (uint64_t)v10, 14, 1, 0, 0, v49);
      goto LABEL_82;
    }
    while (1)
    {
      v12 = v8;
      if (v8 <= 3)
      {
        if (dword_10008BA20)
        {
          v47 = ne_log_obj(v11);
          if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
            sub_1000647A0();
        }
LABEL_7:
        v9 = 0xFFFFFFFFLL;
LABEL_82:
        sub_10003F318(v10);
        return v9;
      }
      v13 = (int)bswap32(*v7) >> 16;
      if (v13 < 0)
      {
        if (dword_10008BA20)
        {
          v16 = ne_log_obj(v11);
          v11 = os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG);
          if ((_DWORD)v11)
          {
            v28 = sub_10003DC14(v13 & 0x7FFF);
            v29 = bswap32(v7[1]) >> 16;
            *(_DWORD *)buf = 136315394;
            v59 = v28;
            v60 = 1024;
            LODWORD(v61) = v29;
            _os_log_debug_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "Short attribute %s = %d\n", buf, 0x12u);
          }
        }
        if ((v13 & 0x7FFF) == 0x4088)
        {
          v11 = (uint64_t)sub_10004680C(a1, v7);
          if (v11)
          {
            v17 = (_QWORD *)v11;
            v10 = sub_100043BC0(v10, v11);
            sub_10003F318(v17);
          }
        }
        else if (dword_10008BA20)
        {
          v19 = ne_log_obj(v11);
          v11 = os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT);
          if ((_DWORD)v11)
          {
            v20 = sub_10003DC14(v13 & 0x7FFF);
            *(_DWORD *)buf = 136315138;
            v59 = v20;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Ignored short attribute %s\n", buf, 0xCu);
          }
        }
        v8 = v12 - 4;
        v7 += 2;
        goto LABEL_35;
      }
      v14 = bswap32(v7[1]) >> 16;
      if (v14 + 4 > (unint64_t)v8)
      {
        if (dword_10008BA20)
        {
          v48 = ne_log_obj(v11);
          if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
            sub_100064694((unsigned __int16)v13);
        }
        goto LABEL_7;
      }
      if (dword_10008BA20)
      {
        v15 = ne_log_obj(v11);
        v11 = os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG);
        if ((_DWORD)v11)
        {
          v27 = sub_10003DC14((unsigned __int16)v13);
          *(_DWORD *)buf = 136315394;
          v59 = v27;
          v60 = 2048;
          v61 = v14;
          _os_log_debug_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "Attribute %s, len %zu\n", buf, 0x16u);
        }
      }
      if ((unsigned __int16)v13 >= 0x7000u)
      {
        if ((unsigned __int16)v13 - 28672 >= 0xB)
          goto LABEL_44;
        v11 = (uint64_t)sub_1000450BC();
      }
      else if ((unsigned __int16)v13 <= 0x4087u)
      {
        if ((unsigned __int16)v13 - 1 < 4)
          goto LABEL_38;
        if ((unsigned __int16)v13 != 7)
        {
          if ((unsigned __int16)v13 != 13)
          {
LABEL_44:
            if (dword_10008BA20)
            {
              v23 = ne_log_obj(v11);
              v11 = os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT);
              if ((_DWORD)v11)
              {
                v24 = sub_10003DC14((unsigned __int16)v13);
                *(_DWORD *)buf = 136315138;
                v59 = v24;
                _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Ignored attribute %s\n", buf, 0xCu);
              }
            }
            goto LABEL_30;
          }
LABEL_38:
          v21 = *v7;
          v11 = sub_100046728((_QWORD *)a1);
          if ((_DWORD)v11)
          {
            if (dword_10008BA20)
            {
              v22 = ne_log_obj(v11);
              v11 = os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
              if ((_DWORD)v11)
                sub_100064858(&v56, v57);
            }
            goto LABEL_30;
          }
          v25 = bswap32(v21) >> 16;
          switch(v25)
          {
            case 1u:
              if (dword_10008BE84)
              {
                if (dword_10008BA20)
                {
                  v26 = ne_log_obj(v11);
                  if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
                    sub_10006482C(&v52, v53);
                }
              }
              else
              {
                v36 = sub_100044930(a1);
                if ((_DWORD)v36 == -1)
                {
                  if (dword_10008BA20)
                  {
                    v40 = ne_log_obj(v36);
                    if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
                      sub_100064800(&v54, v55);
                  }
                }
                else
                {
                  v37 = *(int **)(a1 + 408);
                  v38 = *v37;
                  v37[10] = bswap32(v37[1] + bswap32(xmmword_10008BE38));
                  *v37 = v38 | 0x20;
                }
              }
              v31 = (__int128 *)(*(_QWORD *)(a1 + 408) + 40);
              goto LABEL_73;
            case 2u:
              if (dword_10008BE84)
              {
                if (dword_10008BA20)
                {
                  v32 = ne_log_obj(v11);
                  if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
                    sub_10006482C(&v50, v51);
                }
              }
              else
              {
                v39 = *(_DWORD **)(a1 + 408);
                v39[11] = DWORD1(xmmword_10008BE38);
                *v39 |= 0x40u;
              }
              v31 = (__int128 *)(*(_QWORD *)(a1 + 408) + 44);
LABEL_73:
              v30 = v7;
              goto LABEL_74;
            case 3u:
              v33 = (int *)&xmmword_10008BE38 + 2;
              v34 = dword_10008BE4C;
              goto LABEL_61;
            case 4u:
              v33 = (int *)&unk_10008BE50;
              v34 = dword_10008BE60;
LABEL_61:
              v11 = (uint64_t)sub_100044F7C(v7, v33, v34);
              goto LABEL_28;
            default:
              if (v25 != 13)
              {
                if (dword_10008BA20)
                {
                  v35 = ne_log_obj(v11);
                  v11 = os_log_type_enabled(v35, OS_LOG_TYPE_ERROR);
                  if ((_DWORD)v11)
                  {
                    *(_DWORD *)buf = 67109120;
                    LODWORD(v59) = v25;
                    _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "Unexpected type %d\n", buf, 8u);
                  }
                }
                goto LABEL_30;
              }
              v30 = v7;
              v31 = &xmmword_10008BE38;
LABEL_74:
              v11 = (uint64_t)sub_100044EF0(v30, v31);
              break;
          }
          goto LABEL_28;
        }
        v11 = (uint64_t)sub_100044628(v11, v7, "racoon / IPsec-tools", 0x14uLL);
      }
      else
      {
        if ((unsigned __int16)v13 - 16520 >= 0xA)
          goto LABEL_44;
        v11 = (uint64_t)sub_10004680C(a1, v7);
      }
LABEL_28:
      v18 = (_QWORD *)v11;
      if (v11)
      {
        v10 = sub_100043BC0(v10, v11);
        sub_10003F318(v18);
      }
LABEL_30:
      v7 = (unsigned __int16 *)((char *)v7 + v14 + 4);
      v8 = v12 - (v14 + 4);
LABEL_35:
      if (v8 <= 0)
        goto LABEL_78;
    }
  }
  if (!*(_BYTE *)(a1 + 417))
  {
    *(_BYTE *)(a1 + 416) = *((_BYTE *)a2 + 6);
    if (sub_100048548(a1, v7, v8))
    {
      v10 = 0;
      goto LABEL_7;
    }
    *(_BYTE *)(a1 + 417) = 1;
    *(_QWORD *)(a1 + 424) = sub_10003F34C(a3);
    v41 = sub_10004DB18((_QWORD *)a1);
    if (dword_10008BA20)
    {
      v42 = ne_log_obj(v41);
      v9 = 0;
      if (!os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
        return v9;
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "IPSec Extended Authentication requested.\n", buf, 2u);
    }
  }
  return 0;
}

uint64_t sub_100043734(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  uint64_t v6;
  size_t *v7;
  unsigned int v8;
  int v9;
  unsigned __int16 *v10;
  unint64_t v11;
  unsigned int v12;
  NSObject *v13;
  _QWORD *v14;
  NSObject *v15;
  uint64_t v16;
  size_t v17;
  NSObject *v18;
  uint64_t v19;
  NSObject *v20;
  NSObject *v21;
  NSObject *v22;
  uint8_t buf[4];
  unsigned int v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  unint64_t v29;
  int v30;
  char *v31;
  int v32;
  char *v33;

  v6 = (uint64_t)sub_10003F1F8(8uLL);
  if (!v6)
  {
    if (dword_10008BA20)
    {
      v20 = ne_log_obj(0);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        sub_100059870();
    }
    return 0xFFFFFFFFLL;
  }
  v7 = (size_t *)v6;
  **(_QWORD **)(v6 + 8) = 0;
  v8 = bswap32(a2[1]) >> 16;
  if (v8 < 9)
  {
LABEL_20:
    v17 = v7[1];
    *(_WORD *)(v17 + 2) = bswap32(*(unsigned __int16 *)v7) >> 16;
    *(_BYTE *)(v17 + 4) = 4;
    *(_WORD *)(v17 + 6) = a2[3];
    if (dword_10008BA20)
    {
      v18 = ne_log_obj(v6);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Sending MODE_CFG ACK\n", buf, 2u);
      }
    }
    v19 = sub_100043C98(a1, (uint64_t)v7, 14, 1, 0, 0, a3);
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 408) + 1) & 8) != 0)
    {
      if ((*(_BYTE *)(a1 + 17) & 0x20) != 0)
        sub_10001A528(a1);
      sub_100022B8C(a1);
      sub_10003F318(v7);
    }
    else
    {
      sub_10003F318(v7);
      if ((*(_BYTE *)(a1 + 432) & 1) == 0 && *(_DWORD *)(*(_QWORD *)(a1 + 64) + 156) && !(_DWORD)v19)
        return sub_1000442AC(a1);
    }
    return v19;
  }
  v9 = v8 - 8;
  v10 = a2 + 4;
  while (1)
  {
    v11 = v9;
    if (v9 <= 3)
      break;
    v12 = bswap32(*v10) >> 16;
    if (dword_10008BA20)
    {
      v13 = ne_log_obj(v6);
      v6 = os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)v6)
        sub_100064934(&v32, v12, &v33);
    }
    if ((v12 & 0x7FFF) == 0x408F)
    {
      v6 = (uint64_t)sub_100046CD8(a1, v10);
      if (v6)
      {
        v14 = (_QWORD *)v6;
        v7 = sub_100043BC0(v7, v6);
        sub_10003F318(v14);
        if ((v12 & 0x8000) != 0)
          goto LABEL_18;
        goto LABEL_15;
      }
LABEL_14:
      if ((v12 & 0x8000) != 0)
        goto LABEL_18;
      goto LABEL_15;
    }
    if (!dword_10008BA20)
      goto LABEL_14;
    v15 = ne_log_obj(v6);
    v6 = os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG);
    if (!(_DWORD)v6)
      goto LABEL_14;
    sub_1000648E4(&v30, v12 & 0x7FFF, &v31);
    if ((v12 & 0x8000) != 0)
    {
LABEL_18:
      v9 = v11 - 4;
      v10 += 2;
      goto LABEL_19;
    }
LABEL_15:
    v16 = bswap32(v10[1]) >> 16;
    if (v16 + 4 > v11)
    {
      if (dword_10008BA20)
      {
        v22 = ne_log_obj(v6);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109632;
          v25 = v12;
          v26 = 2048;
          v27 = v16;
          v28 = 2048;
          v29 = v11 - 4;
          _os_log_error_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "isakmp_cfg_set packet too short for type %d, expected %zu actual %zu\n", buf, 0x1Cu);
        }
      }
      goto LABEL_40;
    }
    v9 = v11 - (v16 + 4);
    v10 = (unsigned __int16 *)((char *)v10 + v16 + 4);
LABEL_19:
    if (v9 <= 0)
      goto LABEL_20;
  }
  if (dword_10008BA20)
  {
    v21 = ne_log_obj(v6);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      sub_100064884();
  }
LABEL_40:
  sub_10003F318(v7);
  return 0xFFFFFFFFLL;
}

void sub_100043ABC(uint64_t a1, _DWORD *a2)
{
  NSObject *v2;

  if (*(_WORD *)(a1 + 2) == 1024)
  {
    *a2 = *(_DWORD *)(a1 + 4);
  }
  else if (dword_10008BA20)
  {
    v2 = ne_log_obj(a1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_100064984();
  }
}

void sub_100043B1C(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  NSObject *v3;
  NSObject *v4;

  if (*(_WORD *)(a1 + 2) == 1024)
  {
    if (*a3 == 3)
    {
      if (dword_10008BA20)
      {
        v3 = ne_log_obj(a1);
        if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
          sub_1000649B0();
      }
    }
    else
    {
      *a2 = *(_DWORD *)(a1 + 4);
      ++*a3;
    }
  }
  else if (dword_10008BA20)
  {
    v4 = ne_log_obj(a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      sub_100064984();
  }
}

size_t *sub_100043BC0(size_t *a1, uint64_t a2)
{
  size_t *v3;
  _QWORD *v4;
  _QWORD *v5;
  NSObject *v6;

  v3 = a1;
  v4 = sub_10003F1F8(*(_QWORD *)a2 + *a1);
  if (v4)
  {
    v5 = v4;
    memcpy((void *)v4[1], (const void *)v3[1], *v3);
    memcpy((void *)(v5[1] + *v3), *(const void **)(a2 + 8), *(_QWORD *)a2);
    sub_10003F318(v3);
    return v5;
  }
  else if (dword_10008BA20)
  {
    v6 = ne_log_obj(0);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      sub_100059870();
  }
  return v3;
}

_QWORD *sub_100043C64(int a1, _WORD *a2, char *__s)
{
  size_t v5;

  v5 = strlen(__s);
  return sub_100044628(v5, a2, __s, v5);
}

uint64_t sub_100043C98(uint64_t a1, uint64_t a2, int a3, char a4, int a5, int a6, uint64_t a7)
{
  unsigned __int8 **v8;
  uint64_t v15;
  _BYTE *v16;
  uint64_t v17;
  void *v18;
  void *v19;
  int v20;
  int v22;
  int v23;
  NSObject *v24;
  uint64_t v25;
  NSObject *v27;
  NSObject *v28;
  NSObject *v29;
  NSObject *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const void **v37;
  const void **v38;
  int v39;
  char v40;
  signed int v41;
  _QWORD *v42;
  uint64_t v43;
  char v44;
  size_t v45;
  char *v46;
  NSObject *v47;
  NSObject *v48;
  void *v49;
  NSObject *v50;
  _QWORD *v51;
  _QWORD *v52;
  uint64_t v53;
  NSObject *v54;
  uint64_t v55;
  _QWORD *v56;
  uint64_t v57;
  unint64_t v58;
  NSObject *v59;
  NSObject *v60;
  NSObject *v61;
  _QWORD *v62;
  int v63;
  NSObject *v64;
  NSObject *v65;
  char *v66;
  _QWORD *v67;
  int v68;
  char *v69;

  if ((*(_BYTE *)(a1 + 17) & 0x20) == 0
    || !*(_QWORD *)(a1 + 56)
    || (v8 = (unsigned __int8 **)(a1 + 48), !*(_QWORD *)(a1 + 48)))
  {
    if (dword_10008BA20)
    {
      v24 = ne_log_obj(a1);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        sub_1000649DC();
    }
    return 0xFFFFFFFFLL;
  }
  v15 = *(_QWORD *)(a1 + 408);
  v16 = sub_100008D90(16, 2);
  if (!v16)
  {
    if (dword_10008BA20)
    {
      v27 = ne_log_obj(0);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        sub_100064A08();
    }
    return 0xFFFFFFFFLL;
  }
  v17 = (uint64_t)v16;
  v18 = sub_10003C6F8(*v8);
  *(_QWORD *)(v17 + 8) = v18;
  if (!v18)
  {
    if (dword_10008BA20)
    {
      v28 = ne_log_obj(0);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        sub_100064A34();
    }
    goto LABEL_66;
  }
  v19 = sub_10003C6F8(*(unsigned __int8 **)(a1 + 56));
  *(_QWORD *)v17 = v19;
  if (!v19)
  {
    if (dword_10008BA20)
    {
      v29 = ne_log_obj(0);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        sub_100064A60();
    }
    goto LABEL_66;
  }
  v20 = (*v8)[1];
  if (v20 != 2 && v20 != 30)
  {
    if (dword_10008BA20)
    {
      v30 = ne_log_obj(v19);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        sub_100064A8C(a1 + 48, v30, v31, v32, v33, v34, v35, v36);
    }
LABEL_66:
    sub_100008F90(v17);
    return 0xFFFFFFFFLL;
  }
  *(_BYTE *)(v17 + 60) = 0;
  sub_100003774((int *)(v17 + 56), 63);
  if (a5)
  {
    v22 = sub_1000264E8(a1);
    *(_DWORD *)(v17 + 108) = v22;
    if (*(_QWORD *)(a1 + 208))
    {
      if (!sub_1000426F4(a1, v22))
      {
        if (dword_10008BA20)
        {
          v54 = ne_log_obj(0);
          if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
            sub_1000590A8();
        }
        goto LABEL_66;
      }
      v23 = *(_DWORD *)(v17 + 108);
      goto LABEL_34;
    }
LABEL_36:
    v38 = 0;
    v39 = 0;
    goto LABEL_37;
  }
  v23 = *(_DWORD *)(a1 + 84);
  *(_DWORD *)(v17 + 108) = v23;
  if (!*(_QWORD *)(a1 + 208))
    goto LABEL_36;
LABEL_34:
  v37 = (const void **)sub_10002A3A0(a1, v23, a2);
  if (!v37)
  {
    if (dword_10008BA20)
    {
      v48 = ne_log_obj(0);
      if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
        sub_100059E68();
    }
    goto LABEL_66;
  }
  v38 = v37;
  v39 = *(_DWORD *)v37 + 4;
LABEL_37:
  v40 = v38 != 0;
  if ((a4 & 4) != 0)
    v40 = 4 * (v38 != 0);
  *(_BYTE *)(v17 + 105) = v40;
  sub_10004B4EC(a1, (_QWORD *)v17);
  v41 = v39 + *(_DWORD *)a2 + 28;
  v42 = sub_10003F1F8(v41);
  *(_QWORD *)(v17 + 80) = v42;
  if (!v42)
  {
    if (dword_10008BA20)
    {
      v47 = ne_log_obj(0);
      if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
        sub_10005A794();
    }
    goto LABEL_83;
  }
  v43 = v42[1];
  *(_QWORD *)v43 = *(_QWORD *)a1;
  *(_QWORD *)(v43 + 8) = *(_QWORD *)(a1 + 8);
  if (v38)
    v44 = 8;
  else
    v44 = a3;
  *(_BYTE *)(v43 + 16) = v44;
  *(_BYTE *)(v43 + 17) = *(_BYTE *)(a1 + 80);
  *(_BYTE *)(v43 + 18) = 6;
  *(_BYTE *)(v43 + 19) = *(_BYTE *)(v17 + 105);
  *(_DWORD *)(v43 + 20) = *(_DWORD *)(v17 + 108);
  *(_DWORD *)(v43 + 24) = bswap32(v41);
  if (v38)
  {
    *(_BYTE *)(v43 + 28) = a3;
    v45 = (size_t)*v38;
    *(_WORD *)(v43 + 30) = bswap32(*v38 + 4) >> 16;
    memcpy((void *)(v43 + 32), v38[1], v45);
    v46 = (char *)*v38 + v43 + 32;
  }
  else
  {
    v46 = (char *)(v43 + 28);
  }
  v49 = memcpy(v46, *(const void **)(a2 + 8), *(_QWORD *)a2);
  if (dword_10008BA20)
  {
    v50 = ne_log_obj(v49);
    if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v68) = 0;
      _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "MODE_CFG packet to send\n", (uint8_t *)&v68, 2u);
    }
  }
  if ((*(_BYTE *)(v43 + 19) & 1) != 0)
  {
    v51 = sub_10002E3DC(a1, *(_QWORD *)(v17 + 80), *(_QWORD *)(*(_QWORD *)(v15 + 1176) + 8), **(_QWORD **)(v15 + 1176));
    v52 = *(_QWORD **)(v17 + 80);
    if (v52)
    {
      sub_10003F318(v52);
      *(_QWORD *)(v17 + 80) = 0;
    }
    if (!v51)
    {
      if (dword_10008BA20)
      {
        v60 = ne_log_obj(v52);
        if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
          sub_10005A7C0();
      }
      goto LABEL_83;
    }
    *(_QWORD *)(v17 + 80) = v51;
  }
  if (a6 >= 1)
  {
    *(_DWORD *)(v17 + 72) = a6;
    v53 = sub_1000248F8(v17);
    if ((v53 & 0x80000000) == 0)
    {
      v25 = 0;
      goto LABEL_85;
    }
    if (dword_10008BA20)
    {
      v59 = ne_log_obj(v53);
      if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
        sub_100064AF8();
    }
    goto LABEL_81;
  }
  v55 = sub_1000240A4(*(_QWORD *)(v17 + 256), *(size_t **)(v17 + 80));
  if ((v55 & 0x80000000) == 0)
  {
    if (a7)
    {
      v56 = *(_QWORD **)(v17 + 80);
      v57 = *(_QWORD *)(v17 + 256);
      if (*(_DWORD *)(v57 + 100) && *v56 > 0x500uLL)
        v58 = 0;
      else
        v58 = ((unint64_t)*(unsigned int *)(v57 + 96) >> 3) & 4;
      v55 = sub_100009B6C(*(unsigned __int8 **)(a1 + 48), *(unsigned __int8 **)(a1 + 56), (uint64_t)v56, a7, v58, (*(_DWORD *)(a1 + 96) >> 5) & 1);
      v63 = dword_10008BA20;
      if ((_DWORD)v55 != -1 || !dword_10008BA20)
        goto LABEL_93;
      v64 = ne_log_obj(v55);
      v55 = os_log_type_enabled(v64, OS_LOG_TYPE_ERROR);
      if ((_DWORD)v55)
        sub_10005961C();
    }
    v63 = dword_10008BA20;
LABEL_93:
    if (v63)
    {
      v65 = ne_log_obj(v55);
      if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
      {
        v66 = sub_10003DBA0(a3);
        v68 = 136315138;
        v69 = v66;
        _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_DEFAULT, "sendto mode config %s.\n", (uint8_t *)&v68, 0xCu);
      }
    }
    v67 = *(_QWORD **)(v17 + 80);
    if (v67)
    {
      sub_10003F318(v67);
      v25 = 0;
      *(_QWORD *)(v17 + 80) = 0;
    }
    else
    {
      v25 = 0;
    }
    goto LABEL_84;
  }
  if (dword_10008BA20)
  {
    v61 = ne_log_obj(v55);
    if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
      sub_100058CF4();
  }
LABEL_81:
  v62 = *(_QWORD **)(v17 + 80);
  if (v62)
  {
    sub_10003F318(v62);
    *(_QWORD *)(v17 + 80) = 0;
  }
LABEL_83:
  v25 = 0xFFFFFFFFLL;
LABEL_84:
  sub_10004A9EC((_QWORD *)v17);
LABEL_85:
  if (v38)
    sub_10003F318(v38);
  return v25;
}

uint64_t sub_1000442AC(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;
  size_t *v4;
  int v5;
  size_t v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _WORD *v13;
  const void *v14;
  size_t v15;
  _WORD *v16;
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;
  NSObject *v20;
  NSObject *v21;
  __int16 v23[8];
  uint8_t buf[16];

  if (*(_DWORD *)(a1 + 24)
    && (v2 = *(_QWORD *)(a1 + 48), *(_BYTE *)(v2 + 1) == 2)
    && (v3 = *(_QWORD **)(qword_10008B848 + 64)) != 0)
  {
    v4 = 0;
    v5 = *(_DWORD *)(v2 + 4);
    v6 = 72;
    do
    {
      v7 = v3 + 6;
      while (1)
      {
        v7 = (_QWORD *)*v7;
        if (!v7)
          break;
        if (*((_DWORD *)v7 + 4) == v5)
        {
          v4 = (size_t *)v7[7];
          if (v4)
            v6 += *v4;
          break;
        }
      }
      v3 = (_QWORD *)*v3;
    }
    while (v3);
  }
  else
  {
    v4 = 0;
    v6 = 72;
  }
  v8 = sub_10003F1F8(v6);
  if (v8)
  {
    v9 = v8;
    v10 = v8[1];
    *(_WORD *)(v10 + 2) = bswap32(v6) >> 16;
    *(_BYTE *)(v10 + 4) = 1;
    v11 = sub_100006CC8();
    v12 = 0;
    *(_WORD *)(v10 + 6) = bswap32(v11) >> 16;
    v13 = (_WORD *)(v10 + 8);
    do
    {
      if (v12 == 10 && v4)
      {
        *v13 = 1792;
        v15 = *v4;
        v14 = (const void *)v4[1];
        v13[1] = bswap32(*v4) >> 16;
        v16 = v13 + 2;
        v11 = (uint64_t)memcpy(v13 + 2, v14, v15);
        v13 = (_WORD *)((char *)v16 + *v4);
      }
      else
      {
        *(_DWORD *)v13 = bswap32((unsigned __int16)word_10006A428[v12]) >> 16;
        v13 += 2;
      }
      v12 += 2;
    }
    while (v12 != 32);
    if (dword_10008BA20)
    {
      v17 = ne_log_obj(v11);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Sending MODE_CFG REQUEST\n", buf, 2u);
      }
    }
    v18 = sub_100043C98(a1, (uint64_t)v9, 14, 1, 1, *(_DWORD *)(*(_QWORD *)(a1 + 64) + 200), 0);
    sub_10003F318(v9);
    if (dword_10008BA20)
    {
      v20 = ne_log_obj(v19);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        v23[0] = 0;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "IPSec Network Configuration requested.\n", (uint8_t *)v23, 2u);
      }
    }
  }
  else
  {
    if (dword_10008BA20)
    {
      v21 = ne_log_obj(0);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        sub_100059870();
    }
    return 0xFFFFFFFFLL;
  }
  return v18;
}

_QWORD *sub_100044500(uint64_t a1, unsigned __int16 *a2)
{
  size_t v3;
  _QWORD *v4;
  _QWORD *v5;
  NSObject *v6;

  if ((*a2 & 0x80) != 0)
    v3 = 4;
  else
    v3 = (bswap32(a2[1]) >> 16) + 4;
  v4 = sub_10003F1F8(v3);
  v5 = v4;
  if (v4)
  {
    memcpy((void *)v4[1], a2, (bswap32(a2[1]) >> 16) + 4);
  }
  else if (dword_10008BA20)
  {
    v6 = ne_log_obj(0);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      sub_100059870();
  }
  return v5;
}

_QWORD *sub_10004459C(uint64_t a1, _WORD *a2, unsigned int a3)
{
  _QWORD *v5;
  _QWORD *v6;
  _WORD *v7;
  NSObject *v8;

  v5 = sub_10003F1F8(4uLL);
  v6 = v5;
  if (v5)
  {
    v7 = (_WORD *)v5[1];
    *v7 = *a2 | 0x80;
    v7[1] = bswap32(a3) >> 16;
  }
  else if (dword_10008BA20)
  {
    v8 = ne_log_obj(0);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      sub_100059870();
  }
  return v6;
}

_QWORD *sub_100044628(uint64_t a1, _WORD *a2, const void *a3, size_t a4)
{
  _QWORD *v7;
  _QWORD *v8;
  _WORD *v9;
  NSObject *v10;

  v7 = sub_10003F1F8(a4 + 4);
  v8 = v7;
  if (v7)
  {
    v9 = (_WORD *)v7[1];
    *v9 = *a2;
    v9[1] = bswap32(a4) >> 16;
    memcpy(v9 + 2, a3, a4);
  }
  else if (dword_10008BA20)
  {
    v10 = ne_log_obj(0);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      sub_100059870();
  }
  return v8;
}

void sub_1000446C4(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD **v6;

  v1 = *(_QWORD *)(a1 + 408);
  if (v1)
  {
    if ((*(_BYTE *)v1 & 4) != 0)
    {
      sub_100044768(a1, *(unsigned int *)(v1 + 4));
      v1 = *(_QWORD *)(a1 + 408);
    }
    v3 = *(_QWORD **)(v1 + 1176);
    if (v3)
    {
      sub_10002DA18(v3);
      *(_QWORD *)(*(_QWORD *)(a1 + 408) + 1176) = 0;
      v1 = *(_QWORD *)(a1 + 408);
    }
    v4 = *(_QWORD **)(v1 + 1112);
    if (v4)
    {
      sub_1000458F0(v4, (_DWORD *)(v1 + 1120));
      v1 = *(_QWORD *)(a1 + 408);
    }
    v5 = *(_QWORD **)(v1 + 1128);
    if (v5)
    {
      sub_1000458F0(v5, (_DWORD *)(v1 + 1136));
      v1 = *(_QWORD *)(a1 + 408);
    }
    sub_1000470CC(v1 + 1144);
    v6 = *(_QWORD ***)(a1 + 408);
    if (v6[149])
    {
      sub_10003F318(v6[149]);
      v6 = *(_QWORD ***)(a1 + 408);
    }
    free(v6);
    *(_QWORD *)(a1 + 408) = 0;
  }
}

uint64_t sub_100044768(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  _BOOL4 v4;
  uint64_t result;
  NSObject *v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _DWORD v14[2];

  if (!qword_10008BE68)
  {
    if (dword_10008BA20)
    {
      v6 = ne_log_obj();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        sub_100064B24();
    }
    return 0xFFFFFFFFLL;
  }
  if (!*(_BYTE *)(qword_10008BE68 + a2))
  {
    if (dword_10008BA20)
    {
      v7 = ne_log_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_100064B50(a2, v7, v8, v9, v10, v11, v12, v13);
    }
    return 0xFFFFFFFFLL;
  }
  *(_BYTE *)(qword_10008BE68 + a2) = 0;
  **(_DWORD **)(a1 + 408) &= 4u;
  if (dword_10008BA20)
  {
    v3 = ne_log_obj();
    v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v4)
      return result;
    v14[0] = 67109120;
    v14[1] = a2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Released port %d\n", (uint8_t *)v14, 8u);
  }
  return 0;
}

void *sub_1000448B4()
{
  void *v0;
  void *v1;
  NSObject *v2;

  v0 = malloc_type_malloc(0x4B0uLL, 0x1030040F12D1F44uLL);
  v1 = v0;
  if (v0)
  {
    bzero(v0, 0x4B0uLL);
  }
  else if (dword_10008BA20)
  {
    v2 = ne_log_obj(0);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_100064BB4();
  }
  return v1;
}

uint64_t sub_100044930(uint64_t a1)
{
  uint64_t v1;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  NSObject *v6;
  NSObject *v7;
  NSObject *v9;
  _DWORD *v10;
  _DWORD v11[2];

  v1 = *(_QWORD *)(a1 + 408);
  if ((*(_BYTE *)v1 & 4) != 0)
    return *(unsigned int *)(v1 + 4);
  if (!qword_10008BE68)
  {
    if (dword_10008BA20)
    {
      v6 = ne_log_obj(a1);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        sub_100064B24();
    }
    return 0xFFFFFFFFLL;
  }
  if (!qword_10008BE90)
    goto LABEL_25;
  v3 = 0;
  v4 = 0;
  while (*(_BYTE *)(qword_10008BE68 + v3))
  {
    v3 = (v4 + 1);
    v4 = v3;
    v5 = v3;
    if (qword_10008BE90 <= v3)
      goto LABEL_13;
  }
  v5 = v4;
LABEL_13:
  if (qword_10008BE90 == v3)
  {
LABEL_25:
    if (dword_10008BA20)
    {
      v7 = ne_log_obj(a1);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_100064BE0();
    }
    return 0xFFFFFFFFLL;
  }
  *(_BYTE *)(qword_10008BE68 + v3) = 1;
  if (dword_10008BA20)
  {
    v9 = ne_log_obj(a1);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      v11[0] = 67109120;
      v11[1] = v5;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Using port %d\n", (uint8_t *)v11, 8u);
    }
  }
  v10 = *(_DWORD **)(a1 + 408);
  *v10 |= 4u;
  v10[1] = v5;
  return v5;
}

size_t sub_100044AC4(size_t result, int a2, uint64_t a3, int a4)
{
  _BYTE *v4;
  uint64_t v5;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  _DWORD v12[4];

  v4 = (_BYTE *)result;
  if (a4 == 1)
    v5 = 14;
  else
    v5 = 4;
  if (a2 >= 1)
  {
    v8 = a2;
    v9 = 0;
    memset(v12, 0, 14);
    do
    {
      result = __memcpy_chk(v12, a3, v5, 14);
      if (!v12[0])
        break;
      inet_ntop(2, v12, &v4[v9], 0x28u);
      result = strlen(&v4[v9]);
      v10 = v9 + result;
      if (a4 == 1)
      {
        v4[v10] = 47;
        v11 = v10 + 1;
        inet_ntop(2, &v12[1], &v4[v11], 0x28u);
        result = strlen(&v4[v11]);
        v10 = v11 + result;
      }
      a3 += v5;
      v4[v10] = 32;
      v9 = v10 + 1;
      --v8;
    }
    while (v8);
    if (v9 >= 1)
      v4 += (v9 - 1);
  }
  *v4 = 0;
  return result;
}

uint64_t sub_100044BE4(_BOOL8 a1)
{
  uint64_t result;
  int v2;
  size_t v3;
  NSObject *v4;
  int v5;
  NSObject *v6;
  char *v7;
  uint64_t v8;
  NSObject *v9;
  int v10;
  uint64_t v11;
  __int16 v12;
  int v13;

  if (qword_10008BE90 == a1)
    return 0;
  v2 = a1;
  v3 = a1;
  if (dword_10008BA20)
  {
    v4 = ne_log_obj(a1);
    a1 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    if (a1)
    {
      v10 = 134218240;
      v11 = qword_10008BE90;
      v12 = 1024;
      v13 = v2;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Resize address pool from %zu to %d\n", (uint8_t *)&v10, 0x12u);
    }
  }
  if (qword_10008BE68)
  {
    v5 = qword_10008BE90;
    if (qword_10008BE90 > v3)
    {
      while (--v5 >= v2)
      {
        if (*(_BYTE *)(qword_10008BE68 + v5))
        {
          v3 = v5;
          if (dword_10008BA20)
          {
            v6 = ne_log_obj(a1);
            if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
              sub_100064CC8(v2, v5, v6);
          }
          goto LABEL_14;
        }
      }
    }
  }
  v5 = v2;
LABEL_14:
  v7 = (char *)malloc_type_realloc((void *)qword_10008BE68, v3, 0x119301F2uLL);
  if (v7)
  {
    v8 = (uint64_t)v7;
    if (v3 > qword_10008BE90)
      bzero(&v7[qword_10008BE90], v3 - qword_10008BE90);
    result = 0;
    qword_10008BE68 = v8;
    qword_10008BE90 = v3;
  }
  else
  {
    if (dword_10008BA20)
    {
      v9 = ne_log_obj(0);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_100064C0C(v5, v9);
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t sub_100044DAC(int a1)
{
  void *v2;
  uint64_t v3;

  unk_10008BE54 = 0u;
  xmmword_10008BE38 = 0u;
  unk_10008BE48 = 0u;
  if (a1 != 1 && qword_10008BE68)
    free((void *)qword_10008BE68);
  qword_10008BE90 = 0;
  qword_10008BE68 = 0;
  *(_QWORD *)&dword_10008BE70 = 0;
  if (a1 != 1)
  {
    v2 = (void *)qword_10008BE78;
    if (qword_10008BE78)
    {
      if (dword_10008BE80 >= 1)
      {
        v3 = 0;
        do
          free(*(void **)(qword_10008BE78 + 8 * v3++));
        while (v3 < dword_10008BE80);
        v2 = (void *)qword_10008BE78;
      }
      free(v2);
    }
  }
  qword_10008BE78 = 0;
  *(_QWORD *)&dword_10008BE80 = 0;
  dword_10008BE88 = 0;
  dword_10008BE98 = 1;
  __strlcpy_chk(byte_10008BE9C, &unk_10007E079, 1025, 1025);
  __strlcpy_chk(&byte_10008BE9C[1025], "/etc/motd", 1025, 1025);
  if (a1 != 1 && qword_10008C6A0)
    sub_1000458F0((_QWORD *)qword_10008C6A0, &dword_10008C6A8);
  dword_10008C6BC = 0;
  dword_10008C6C0 = 0;
  qword_10008C6A0 = 0;
  *(_QWORD *)&dword_10008C6A8 = 0;
  if (a1 != 1 && qword_10008C6B0)
    free((void *)qword_10008C6B0);
  qword_10008C6B0 = 0;
  dword_10008C6B8 = 0;
  return 0;
}

_QWORD *sub_100044EF0(_WORD *a1, _DWORD *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  NSObject *v7;

  v4 = sub_10003F1F8(8uLL);
  v5 = v4;
  if (v4)
  {
    v6 = v4[1];
    *(_WORD *)v6 = *a1;
    *(_WORD *)(v6 + 2) = 1024;
    *(_DWORD *)(v6 + 4) = *a2;
  }
  else if (dword_10008BA20)
  {
    v7 = ne_log_obj(0);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      sub_100059870();
  }
  return v5;
}

size_t *sub_100044F7C(_WORD *a1, int *a2, int a3)
{
  size_t *v6;
  size_t *v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  int v12;
  NSObject *v13;
  NSObject *v14;

  v6 = sub_10003F1F8(0);
  if (!v6)
  {
    if (dword_10008BA20)
    {
      v13 = ne_log_obj(0);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        sub_100059870();
    }
    return 0;
  }
  v7 = v6;
  if (a3 >= 1)
  {
    v8 = a3;
    while (1)
    {
      v9 = sub_10003F1F8(8uLL);
      if (!v9)
        break;
      v10 = v9;
      v11 = v9[1];
      *(_WORD *)v11 = *a1;
      *(_WORD *)(v11 + 2) = 1024;
      v12 = *a2++;
      *(_DWORD *)(v11 + 4) = v12;
      v7 = sub_100043BC0(v7, (uint64_t)v9);
      sub_10003F318(v10);
      if (!--v8)
        return v7;
    }
    if (dword_10008BA20)
    {
      v14 = ne_log_obj(0);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        sub_100059870();
        if (!v7)
          return v7;
        goto LABEL_13;
      }
    }
    if (v7)
    {
LABEL_13:
      sub_10003F318(v7);
      return 0;
    }
  }
  return v7;
}

void sub_100045094(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x12u);
}

_QWORD *sub_1000450BC()
{
  uint64_t v0;
  _WORD *v1;
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _WORD *v11;
  unsigned int v12;
  int v13;
  int v14;
  uint64_t v15;
  int v16;
  ssize_t v17;
  int v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  NSObject *v28;
  _BOOL8 v29;
  NSObject *v30;
  unsigned int v31;
  int v32;
  int v33;
  NSObject *v34;
  NSObject *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char __s[65537];

  v0 = __chkstk_darwin();
  if ((**(_BYTE **)(v0 + 408) & 2) != 0)
  {
    v11 = v1;
    v12 = bswap32((unsigned __int16)*v1);
    v13 = HIWORD(v12);
    if ((v12 & 0x80000000) != 0)
    {
      if (dword_10008BA20)
      {
        v27 = HIWORD(v12) & 0x7FFF;
        v28 = ne_log_obj(v0);
        v29 = os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG);
        if (v29)
          sub_100064F50(v27, (uint64_t)v11, v28);
        if (dword_10008BA20)
        {
          v30 = ne_log_obj(v29);
          if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
            sub_100064EE4(v27);
        }
      }
    }
    else
    {
      v14 = v0;
      switch(v13)
      {
        case 28672:
          v15 = open(&byte_10008BE9C[1025], 0, 0);
          if ((_DWORD)v15 == -1)
          {
            if (dword_10008BA20)
            {
              v35 = ne_log_obj(v15);
              if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
                sub_100064DF4(v35, v36, v37, v38, v39, v40, v41, v42);
            }
          }
          else
          {
            v16 = v15;
            v17 = read(v15, __s, 0x10000uLL);
            v18 = v17;
            if ((_DWORD)v17 != -1)
            {
              close(v16);
              __s[v18] = 0;
              return sub_100043C64(v14, v11, __s);
            }
            if (dword_10008BA20)
            {
              v19 = ne_log_obj(v17);
              if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
                sub_100064E6C(v19, v20, v21, v22, v23, v24, v25, v26);
            }
            close(v16);
          }
          break;
        case 28673:
          v31 = dword_10008C6C0;
          return sub_10004459C(v0, v1, v31);
        case 28674:
          return sub_100043C64(v0, v1, byte_10008BE9C);
        case 28675:
          return sub_100044628(v0, v1, (const void *)qword_10008C6B0, dword_10008C6B8);
        case 28676:
          v32 = dword_10008C6AC;
          v33 = 28676;
          goto LABEL_28;
        case 28678:
          v32 = dword_10008C6AC;
          v33 = 28678;
LABEL_28:
          if (v32 != v33)
            return 0;
          return sub_1000454AC(v1, (uint64_t *)qword_10008C6A0, dword_10008C6A8);
        case 28679:
          v31 = dword_10008C6BC;
          return sub_10004459C(v0, v1, v31);
        case 28682:
          return sub_100044500(v0, v1);
        default:
          if (dword_10008BA20)
          {
            v34 = ne_log_obj(v0);
            if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
              sub_100064D88(v13);
          }
          return 0;
      }
    }
  }
  else if (dword_10008BA20)
  {
    v2 = ne_log_obj(v0);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_100064D58(v2, v3, v4, v5, v6, v7, v8, v9);
  }
  return 0;
}

_QWORD *sub_1000454AC(_WORD *a1, uint64_t *a2, int a3)
{
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  _WORD *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  NSObject *v14;
  NSObject *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint8_t buf[4];
  char *v25;
  __int16 v26;
  char *v27;
  char v28[40];
  char v29[40];

  v6 = 14 * a3;
  v7 = sub_10003F1F8(v6 + 4);
  v8 = v7;
  if (v7)
  {
    v9 = (_WORD *)v7[1];
    *v9 = *a1;
    v9[1] = bswap32(v6) >> 16;
    if (a3 >= 1)
    {
      v10 = v9 + 2;
      v11 = a3;
      do
      {
        v12 = *a2;
        *(_QWORD *)((char *)v10 + 6) = *(uint64_t *)((char *)a2 + 6);
        *v10 = v12;
        inet_ntop(2, a2, v29, 0x28u);
        v13 = inet_ntop(2, (char *)a2 + 4, v28, 0x28u);
        if (dword_10008BA20)
        {
          v14 = ne_log_obj(v13);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136315394;
            v25 = v29;
            v26 = 2080;
            v27 = v28;
            _os_log_debug_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "splitnet: %s/%s\n", buf, 0x16u);
          }
        }
        a2 = (uint64_t *)a2[2];
        v10 = (_QWORD *)((char *)v10 + 14);
        --v11;
      }
      while (v11);
    }
  }
  else if (dword_10008BA20)
  {
    v15 = ne_log_obj(0);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      sub_100064FE8(v15, v16, v17, v18, v19, v20, v21, v22);
  }
  return v8;
}

void sub_100045664(uint64_t a1, _WORD *a2)
{
  uint64_t *v2;
  unsigned int v3;
  unsigned __int16 *v5;
  unsigned int v6;
  NSObject *v7;
  int *v8;
  int v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  NSObject *v14;
  int v15;
  char *v16;

  v2 = (uint64_t *)(a2 + 2);
  v3 = bswap32(*a2 & 0xFF7F) >> 16;
  v5 = a2 + 1;
  v6 = __rev16((unsigned __int16)a2[1]);
  switch(v3)
  {
    case 0x7000u:
    case 0x7001u:
    case 0x7003u:
    case 0x7005u:
    case 0x7008u:
    case 0x7009u:
    case 0x700Au:
      if (!*(_DWORD *)(a1 + 24))
        goto LABEL_3;
      break;
    case 0x7004u:
      v8 = *(int **)(a1 + 408);
      v9 = *v8;
      if ((*v8 & 0x2000) == 0)
      {
        if (a2[1] && v6 >= 0xE)
        {
          v10 = (18725 * (v6 >> 1)) >> 17;
          do
          {
            sub_10004585C((uint64_t *)(*(_QWORD *)(a1 + 408) + 1112), v2, (_DWORD *)(*(_QWORD *)(a1 + 408) + 1120));
            v2 = (uint64_t *)((char *)v2 + 14);
            --v10;
          }
          while (v10);
          v8 = *(int **)(a1 + 408);
          v9 = *v8;
        }
        v11 = v9 | 0x2000;
        goto LABEL_20;
      }
      break;
    case 0x7006u:
      v8 = *(int **)(a1 + 408);
      v12 = *v8;
      if ((*v8 & 0x4000) == 0)
      {
        if (a2[1] && v6 >= 0xE)
        {
          v13 = (18725 * (v6 >> 1)) >> 17;
          do
          {
            sub_10004585C((uint64_t *)(*(_QWORD *)(a1 + 408) + 1128), v2, (_DWORD *)(*(_QWORD *)(a1 + 408) + 1136));
            v2 = (uint64_t *)((char *)v2 + 14);
            --v13;
          }
          while (v13);
          v8 = *(int **)(a1 + 408);
          v12 = *v8;
        }
        v11 = v12 | 0x4000;
LABEL_20:
        *v8 = v11;
      }
      break;
    case 0x7007u:
      *(_DWORD *)(*(_QWORD *)(a1 + 408) + 1140) = v6;
      if (dword_10008BA20)
      {
        v14 = ne_log_obj(a1);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
          sub_100065018(v5, v14);
      }
      break;
    default:
LABEL_3:
      if (dword_10008BA20)
      {
        v7 = ne_log_obj(a1);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          v15 = 136315138;
          v16 = sub_10003DC14(v3);
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Ignored attribute %s\n", (uint8_t *)&v15, 0xCu);
        }
      }
      break;
  }
}

uint64_t sub_10004585C(uint64_t *a1, uint64_t *a2, _DWORD *a3)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v6 = malloc_type_malloc(0x18uLL, 0x10200403A35BBDDuLL);
  if (!v6)
    return 0xFFFFFFFFLL;
  v7 = *a2;
  *(_QWORD *)((char *)v6 + 6) = *(uint64_t *)((char *)a2 + 6);
  *v6 = v7;
  v6[2] = 0;
  v8 = *a1;
  if (*a1)
  {
    do
    {
      v9 = v8;
      v8 = *(_QWORD *)(v8 + 16);
    }
    while (v8);
    a1 = (uint64_t *)(v9 + 16);
  }
  v10 = 0;
  *a1 = (uint64_t)v6;
  ++*a3;
  return v10;
}

_QWORD *sub_1000458F0(_QWORD *result, _DWORD *a2)
{
  _QWORD *v2;

  *a2 = 0;
  if (result)
  {
    do
    {
      v2 = (_QWORD *)result[2];
      free(result);
      result = v2;
    }
    while (v2);
  }
  return result;
}

_BYTE *sub_100045920(_QWORD *a1)
{
  _QWORD *v1;
  int v2;
  _QWORD *v3;
  int v4;
  _BYTE *v5;
  _BYTE *v6;
  int i;
  int v8;
  char v10[40];
  char __s[40];

  v1 = a1;
  v2 = 0;
  if (a1)
  {
    v3 = a1;
    do
    {
      inet_ntop(2, v3, __s, 0x28u);
      inet_ntop(2, (char *)v3 + 4, v10, 0x28u);
      v4 = strlen(__s);
      v2 += v4 + strlen(v10) + 2;
      v3 = (_QWORD *)v3[2];
    }
    while (v3);
  }
  v5 = malloc_type_malloc(v2, 0x1470EAEAuLL);
  v6 = v5;
  if (v5)
  {
    *v5 = 0;
    if (v1)
    {
      if (v2 >= 1)
      {
        for (i = 0; i < v2; i += v8)
        {
          inet_ntop(2, v1, __s, 0x28u);
          inet_ntop(2, (char *)v1 + 4, v10, 0x28u);
          v8 = snprintf(&v6[i], v2 - i, "%s/%s ", __s, v10);
          if (v8 < 0)
            break;
          v1 = (_QWORD *)v1[2];
          if (!v1)
            break;
        }
      }
    }
  }
  return v6;
}

char *sub_100045A7C(int a1)
{
  return sub_10003DC14(a1);
}

void sub_100045A84(uint64_t a1)
{
  NSObject *v1;
  _DWORD *v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  NSObject *v15;
  uint8_t v16[16];

  if ((*(_BYTE *)(a1 + 17) & 0x20) != 0)
  {
    v3 = (_DWORD *)(*(_QWORD *)(a1 + 408) + 1144);
    if (*v3)
    {
      if (dword_10008BA20)
      {
        v4 = ne_log_obj(a1);
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
          sub_1000650EC((uint64_t)v3, v4, v5, v6, v7, v8, v9, v10);
      }
    }
    else
    {
      if (dword_10008BA20)
      {
        v11 = ne_log_obj(a1);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)v16 = 0;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Sending Xauth request\n", v16, 2u);
        }
      }
      v12 = sub_10003F1F8(0x14uLL);
      if (v12)
      {
        v13 = v12;
        v14 = v12[1];
        *(_QWORD *)v14 = 0;
        *(_QWORD *)(v14 + 8) = 0;
        *(_DWORD *)(v14 + 16) = 0;
        *(_WORD *)(v14 + 2) = 5120;
        *(_BYTE *)(v14 + 4) = 1;
        *(_WORD *)(v14 + 6) = bswap32(sub_100006CC8()) >> 16;
        *(_QWORD *)(v14 + 8) = 0x8940000088C0;
        *(_DWORD *)(v14 + 16) = 35392;
        sub_100043C98(a1, (uint64_t)v13, 14, 1, 1, 0, 0);
        sub_10003F318(v13);
        *v3 = 1;
      }
      else if (dword_10008BA20)
      {
        v15 = ne_log_obj(0);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          sub_1000650C0();
      }
    }
  }
  else if (dword_10008BA20)
  {
    v1 = ne_log_obj(a1);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_100065094();
  }
}

uint64_t sub_100045C1C(uint64_t a1, _WORD *a2, unsigned int a3)
{
  uint64_t v3;
  NSObject *v4;
  unsigned int v8;
  NSObject *v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void **v18;
  size_t v19;
  void *v20;
  NSObject *v21;
  NSObject *v22;
  const char *v23;
  const char *v24;
  uint64_t v25;
  uint64_t v26;
  NSObject *v27;
  int v28;
  NSObject *v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  uint64_t v33;
  NSObject *v34;
  _DWORD *v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int v38;
  int v39;
  NSObject *v40;
  int v41;
  int v42;

  v3 = *(_QWORD *)(a1 + 408);
  if ((*(_BYTE *)v3 & 1) == 0)
  {
    if (dword_10008BA20)
    {
      v4 = ne_log_obj(a1);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_100065154();
    }
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)(v3 + 1144) != 1)
  {
    if (dword_10008BA20)
    {
      v10 = ne_log_obj(a1);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_1000652B0(v3 + 1144, v10, v11, v12, v13, v14, v15, v16);
    }
    return 0xFFFFFFFFLL;
  }
  v8 = bswap32(*a2 & 0xFF7F) >> 16;
  switch(v8)
  {
    case 0x408Au:
      v18 = (void **)(v3 + 1168);
LABEL_19:
      v19 = bswap32((unsigned __int16)a2[1]) >> 16;
      v20 = malloc_type_realloc(*v18, v19 + 1, 0xD8D5CB64uLL);
      *v18 = v20;
      if (!v20)
      {
        if (dword_10008BA20)
        {
          v22 = ne_log_obj(0);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
            sub_100065284();
        }
        return 0xFFFFFFFFLL;
      }
      memcpy(v20, a2 + 2, v19);
      *((_BYTE *)*v18 + v19) = 0;
      break;
    case 0x4089u:
      v18 = (void **)(v3 + 1160);
      goto LABEL_19;
    case 0x4088u:
      if (a2[1])
      {
        if (dword_10008BA20)
        {
          v9 = ne_log_obj(a1);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            v41 = 67109120;
            v42 = 34880;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Unexpected authentication type %d\n", (uint8_t *)&v41, 8u);
          }
        }
        return 0xFFFFFFFFLL;
      }
      *(_DWORD *)(v3 + 1152) = 0;
      break;
    default:
      if (dword_10008BA20)
      {
        v21 = ne_log_obj(a1);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          v41 = 67109120;
          v42 = v8;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "ignored Xauth attribute %d\n", (uint8_t *)&v41, 8u);
        }
      }
      break;
  }
  v23 = *(const char **)(v3 + 1160);
  if (!v23)
    return 0;
  v24 = *(const char **)(v3 + 1168);
  if (!v24)
    return 0;
  __strlcpy_chk(*(_QWORD *)(a1 + 408) + 8, v23, 32, 32);
  v25 = sub_100044930(a1);
  v26 = v25;
  if ((_DWORD)v25 == -1)
  {
    if (dword_10008BA20)
    {
      v29 = ne_log_obj(v25);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        sub_100065180();
    }
    v28 = -1;
    goto LABEL_50;
  }
  if (dword_10008BE70)
  {
    if (dword_10008BA20)
    {
      v27 = ne_log_obj(v25);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        sub_100065258();
    }
    v28 = -1;
  }
  else
  {
    v28 = sub_100046078(v23, v24);
    if (!v28 && dword_10008BE80)
      v28 = sub_1000460D0(a1, (char **)qword_10008BE78, dword_10008BE80);
  }
  v30 = (int)sub_10003EC98(*(unsigned __int8 **)(a1 + 48), v28);
  v31 = v30 - time(0);
  if (v31 < 1)
  {
LABEL_50:
    v36 = a1;
    v37 = v26;
    v38 = a3;
    v39 = v28;
    return sub_100046310(v36, v37, v38, v39);
  }
  v32 = sub_10003C8A0(*(const sockaddr **)(a1 + 48));
  if (dword_10008BA20)
  {
    v33 = (uint64_t)v32;
    v34 = ne_log_obj(v32);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
      sub_1000651D8(v33, v31, v34);
  }
  v35 = malloc_type_malloc(0x1CuLL, 0x100004027586B93uLL);
  if (v35)
  {
    *(_OWORD *)v35 = *(_OWORD *)a1;
    v35[4] = v26;
    v35[5] = a3;
    v35[6] = -1;
    sub_10003A520(v31, (uint64_t)sub_1000464F4, (uint64_t)v35);
    return 0;
  }
  if (dword_10008BA20)
  {
    v40 = ne_log_obj(0);
    if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
      sub_1000651AC();
  }
  v36 = a1;
  v37 = v26;
  v38 = a3;
  v39 = -1;
  return sub_100046310(v36, v37, v38, v39);
}

uint64_t sub_100046078(const char *a1, const char *a2)
{
  passwd *v3;
  const char *pw_passwd;
  char *v5;

  v3 = getpwnam(a1);
  if (!v3)
    return 0xFFFFFFFFLL;
  if (!v3->pw_uid)
    return 0xFFFFFFFFLL;
  pw_passwd = v3->pw_passwd;
  v5 = crypt(a2, pw_passwd);
  if (!v5)
    return 0xFFFFFFFFLL;
  if (!strcmp(v5, pw_passwd))
    return 0;
  return 0xFFFFFFFFLL;
}

uint64_t sub_1000460D0(uint64_t a1, char **a2, int a3)
{
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  NSObject *v7;
  NSObject *v8;
  char *v9;
  NSObject *v10;
  NSObject *v11;
  uint64_t result;
  NSObject *v13;
  _BOOL4 v14;
  char *v15;
  uint8_t v16;
  _BYTE v17[15];
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  char *v21;

  if (!*(_QWORD *)(a1 + 408))
  {
    if (dword_10008BA20)
    {
      v10 = ne_log_obj(a1);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_100065318();
    }
    return 0xFFFFFFFFLL;
  }
  if (a3 < 1)
    return 0xFFFFFFFFLL;
  v4 = a1;
  v5 = a3;
  while (1)
  {
    v6 = *(const char **)(*(_QWORD *)(v4 + 408) + 1160);
    if (!v6)
    {
      if (dword_10008BA20)
      {
        v11 = ne_log_obj(a1);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          sub_100065344();
      }
      return 0xFFFFFFFFLL;
    }
    if (!dword_10008BE74)
      break;
    if (dword_10008BA20)
    {
      v7 = ne_log_obj(a1);
      a1 = os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
      if ((_DWORD)a1)
        sub_100065370(&v16, v17, v7);
      goto LABEL_10;
    }
LABEL_13:
    ++a2;
    if (!--v5)
      return 0xFFFFFFFFLL;
  }
  a1 = sub_100046644(v6, *a2);
  if ((_DWORD)a1)
  {
LABEL_10:
    if (dword_10008BA20)
    {
      v8 = ne_log_obj(a1);
      a1 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
      if ((_DWORD)a1)
      {
        v9 = *a2;
        *(_DWORD *)buf = 136315394;
        v19 = v6;
        v20 = 2080;
        v21 = v9;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "user \"%s\" is not a member of group \"%s\"\n", buf, 0x16u);
      }
    }
    goto LABEL_13;
  }
  if (dword_10008BA20)
  {
    v13 = ne_log_obj(a1);
    v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v14)
      return result;
    v15 = *a2;
    *(_DWORD *)buf = 136315394;
    v19 = v6;
    v20 = 2080;
    v21 = v15;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "user \"%s\" is a member of group \"%s\"\n", buf, 0x16u);
  }
  return 0;
}

uint64_t sub_100046310(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;
  NSObject *v8;
  NSObject *v9;
  NSObject *v11;
  int v12;
  uint64_t v13;

  v4 = *(_QWORD *)(a1 + 408);
  v5 = *(_QWORD *)(v4 + 1160);
  if ((*(_BYTE *)(a1 + 432) & 2) != 0)
  {
    if (dword_10008BA20)
    {
      v9 = ne_log_obj(a1);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        v12 = 136315138;
        v13 = v5;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "dropped login for user \"%s\"\n", (uint8_t *)&v12, 0xCu);
      }
    }
    return 0xFFFFFFFFLL;
  }
  v7 = a1;
  if (a4)
  {
    if ((_DWORD)a2 != -1)
      a1 = sub_100044768(a1, a2);
    if (dword_10008BA20)
    {
      v8 = ne_log_obj(a1);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        v12 = 136315138;
        v13 = v5;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "login failed for user \"%s\"\n", (uint8_t *)&v12, 0xCu);
      }
    }
    sub_100046568(v7, 0, a3);
    *(_DWORD *)(v4 + 1144) = 0;
    if ((*(_BYTE *)(v7 + 17) & 0x20) != 0)
      sub_10001A528(v7);
    sub_100022B8C(v7);
    return 0xFFFFFFFFLL;
  }
  *(_DWORD *)(v4 + 1144) = 2;
  if (dword_10008BA20)
  {
    v11 = ne_log_obj(a1);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      v12 = 136315138;
      v13 = v5;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "login succeeded for user \"%s\"\n", (uint8_t *)&v12, 0xCu);
    }
  }
  sub_100046568(v7, 1u, a3);
  return 0;
}

void sub_1000464F4(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;

  v2 = sub_100007EB0(0, (_QWORD *)a1);
  if (v2)
  {
    sub_100046310(v2, *(unsigned int *)(a1 + 16), *(_DWORD *)(a1 + 20), *(_DWORD *)(a1 + 24));
  }
  else if (dword_10008BA20)
  {
    v3 = ne_log_obj(0);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      sub_1000653AC();
  }
  free((void *)a1);
}

void sub_100046568(uint64_t a1, unsigned int a2, unsigned int a3)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  NSObject *v9;

  v6 = sub_10003F1F8(0xCuLL);
  if (v6)
  {
    v7 = v6;
    v8 = v6[1];
    *(_QWORD *)v8 = 0;
    *(_DWORD *)(v8 + 8) = 0;
    *(_WORD *)(v8 + 2) = 3072;
    *(_BYTE *)(v8 + 4) = 3;
    *(_WORD *)(v8 + 6) = bswap32(a3) >> 16;
    *(_WORD *)(v8 + 8) = -28736;
    *(_WORD *)(v8 + 10) = bswap32(a2) >> 16;
    sub_100043C98(a1, (uint64_t)v6, 14, 1, 1, 0, 0);
    sub_10003F318(v7);
  }
  else if (dword_10008BA20)
  {
    v9 = ne_log_obj(0);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      sub_1000650C0();
  }
}

uint64_t sub_100046644(const char *a1, char *a2)
{
  group *v4;
  const char **i;
  uint64_t v6;
  NSObject *v7;
  _BOOL4 v8;
  uint64_t result;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint8_t v17[16];

  v4 = getgrnam(a2);
  if (v4)
  {
    for (i = (const char **)v4->gr_mem; *i; ++i)
    {
      v6 = strcmp(*i, a1);
      if (!(_DWORD)v6)
      {
        if (dword_10008BA20)
        {
          v7 = ne_log_obj(v6);
          v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
          result = 0;
          if (!v8)
            return result;
          *(_WORD *)v17 = 0;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "membership validated\n", v17, 2u);
        }
        return 0;
      }
    }
  }
  else if (dword_10008BA20)
  {
    v10 = ne_log_obj(0);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      sub_1000653D8((uint64_t)a2, v10, v11, v12, v13, v14, v15, v16);
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100046728(_QWORD *a1)
{
  int v1;
  BOOL v2;
  BOOL v3;
  uint64_t v5;
  NSObject *v6;
  NSObject *v8;

  v1 = *(_DWORD *)(a1[9] + 48);
  if (*(_QWORD *)(a1[8] + 272))
    v2 = v1 == 65001;
  else
    v2 = 0;
  if (v2)
    return 0;
  v3 = (v1 - 65002) > 8 || ((1 << (v1 + 22)) & 0x151) == 0;
  if (v3 && v1 != 64222)
    return 0;
  v5 = a1[51];
  if ((*(_BYTE *)v5 & 1) != 0)
  {
    if (*(_DWORD *)(v5 + 1144) == 2)
      return 0;
    if (dword_10008BA20)
    {
      v8 = ne_log_obj(a1);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_100065468();
    }
  }
  else if (dword_10008BA20)
  {
    v6 = ne_log_obj(a1);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      sub_10006543C();
  }
  return 0xFFFFFFFFLL;
}

_QWORD *sub_10004680C(uint64_t a1, unsigned __int16 *a2)
{
  NSObject *v2;
  _QWORD *v3;
  int v6;
  __int16 v7;
  unsigned int v8;
  uint64_t v10;
  _QWORD **v11;
  _QWORD *v12;
  size_t *v13;
  size_t *v14;
  size_t *v15;
  int v16;
  NSObject *v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  size_t *v21;
  size_t *v22;
  void *v23;
  NSObject *v24;
  char *v25;
  size_t *v26;
  NSObject *v27;
  uint64_t v28;
  NSObject *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  NSObject *v36;
  char v37;
  size_t *v38;
  _QWORD *v39;
  uint64_t v40;
  const void *v41;
  NSObject *v42;
  NSObject *v43;
  NSObject *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  char *v52;

  if ((**(_BYTE **)(a1 + 408) & 1) == 0)
  {
    if (dword_10008BA20)
    {
      v2 = ne_log_obj(a1);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_100065494();
    }
    return 0;
  }
  v6 = *a2;
  v7 = v6 & 0xFF7F;
  v8 = bswap32(v6 & 0xFFFFFF7F) >> 16;
  switch(v8)
  {
    case 0x4088u:
      if ((v6 & 0x80) != 0)
      {
        v28 = (uint64_t)(a2 + 1);
        if (!a2[1])
        {
          v20 = 0;
          v37 = 0;
          v15 = 0;
          v16 = 0;
          goto LABEL_45;
        }
        if (dword_10008BA20)
        {
          v29 = ne_log_obj(a1);
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
            sub_1000654EC(v28, v29, v30, v31, v32, v33, v34, v35);
        }
      }
      else if (dword_10008BA20)
      {
        v18 = ne_log_obj(a1);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          sub_1000654C0();
      }
      return 0;
    case 0x4089u:
      v19 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 272);
      if (v19 && *(_QWORD *)v19)
      {
        v15 = 0;
        v16 = 0;
        v20 = **(_QWORD **)v19 - 1;
        *(_DWORD *)(v19 + 16) |= 1u;
        goto LABEL_44;
      }
      if (dword_10008BA20)
      {
        v27 = ne_log_obj(a1);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
          sub_10006555C();
      }
      return 0;
    case 0x408Au:
    case 0x408Bu:
      v10 = a1 + 64;
      v11 = *(_QWORD ***)(*(_QWORD *)(a1 + 64) + 272);
      if (!v11)
        return 0;
      v12 = *v11;
      if (!v12)
        return 0;
      v13 = sub_10003F1F8(*v12 + 3);
      if (v13)
      {
        v14 = v13;
        *(_DWORD *)v13[1] = 0;
        memcpy((void *)(v13[1] + 4), *(const void **)(**(_QWORD **)(*(_QWORD *)v10 + 272) + 8), ***(_QWORD ***)(*(_QWORD *)v10 + 272) - 1);
        v15 = *(size_t **)(*(_QWORD *)(*(_QWORD *)v10 + 272) + 8);
        if (v15)
        {
          v16 = 0;
LABEL_43:
          sub_10003F318(v14);
          *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v10 + 272) + 16) |= 2u;
          v20 = *v15 - 1;
LABEL_44:
          v37 = 1;
LABEL_45:
          v39 = sub_10003F1F8(v20 + 4);
          v3 = v39;
          if (!v39)
          {
            if (dword_10008BA20)
            {
              v42 = ne_log_obj(0);
              if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
                sub_100059870();
            }
            goto LABEL_56;
          }
          v40 = v39[1];
          if ((v37 & 1) == 0)
          {
            *(_DWORD *)v40 = (unsigned __int16)__rev16(v8 | 0x8000);
            goto LABEL_56;
          }
          *(_WORD *)v40 = v7;
          *(_WORD *)(v40 + 2) = bswap32(v20) >> 16;
          if (v8 - 16522 >= 2)
          {
            if (v8 != 16521)
              goto LABEL_56;
            v41 = *(const void **)(**(_QWORD **)(*(_QWORD *)(a1 + 64) + 272) + 8);
          }
          else
          {
            v41 = (const void *)v15[1];
          }
          memcpy((void *)(v40 + 4), v41, v20);
LABEL_56:
          if (v16)
            sub_10003F318(v15);
          return v3;
        }
        v38 = sub_1000280CC(v14);
        if (v38)
        {
          v15 = v38;
          v16 = 1;
          goto LABEL_43;
        }
        if (dword_10008BA20)
        {
          v44 = ne_log_obj(0);
          if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
            sub_100065588(a1 + 64, v44, v45, v46, v47, v48, v49, v50);
        }
        v26 = v14;
LABEL_65:
        sub_10003F318(v26);
      }
      else
      {
        if (!dword_10008BA20)
          return 0;
        v36 = ne_log_obj(0);
        if (!os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
          return 0;
LABEL_39:
        sub_100059870();
      }
      return 0;
    case 0x408Cu:
      if ((v6 & 0x80) != 0 || !a2[1])
        return 0;
      v21 = sub_10003F1F8(__rev16(a2[1]));
      if (v21)
      {
        v22 = v21;
        v23 = memcpy((void *)v21[1], a2 + 2, *v21);
        if (dword_10008BA20)
        {
          v24 = ne_log_obj(v23);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
          {
            v25 = sub_1000291E4((char *)v22[1], *v22);
            v51 = 136315138;
            v52 = v25;
            _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "XAUTH Message: '%s'.\n", (uint8_t *)&v51, 0xCu);
          }
        }
        v26 = v22;
        goto LABEL_65;
      }
      if (!dword_10008BA20)
        return 0;
      v43 = ne_log_obj(0);
      if (!os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
        return 0;
      goto LABEL_39;
    default:
      if (dword_10008BA20)
      {
        v17 = ne_log_obj(a1);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          v51 = 136315138;
          v52 = sub_10003DC14(v8);
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Ignored attribute %s\n", (uint8_t *)&v51, 0xCu);
        }
      }
      return 0;
  }
}

_QWORD *sub_100046CD8(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t v2;
  NSObject *v3;
  int v5;
  unsigned int v6;
  int v8;
  BOOL v9;
  NSObject *v10;
  size_t *v11;
  size_t *v12;
  void *v13;
  NSObject *v14;
  char *v15;
  NSObject *v16;
  char *v17;
  NSObject *v19;
  const char *v20;
  NSObject *v21;
  int v22;
  uint64_t v23;
  _QWORD *result;
  NSObject *v25;
  NSObject *v26;
  NSObject *v27;
  int v28;
  char *v29;

  v2 = *(_QWORD *)(a1 + 408);
  if ((*(_BYTE *)v2 & 1) == 0)
  {
    if (dword_10008BA20)
    {
      v3 = ne_log_obj(a1);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        sub_1000655FC();
    }
    return 0;
  }
  v5 = *a2;
  v6 = bswap32(v5 & 0xFFFFFF7F) >> 16;
  if (v6 == 16524)
  {
    if ((v5 & 0x80) == 0 && a2[1])
    {
      v11 = sub_10003F1F8(__rev16(a2[1]));
      if (!v11)
      {
        if (dword_10008BA20)
        {
          v26 = ne_log_obj(0);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
            sub_100059870();
        }
        return 0;
      }
      v12 = v11;
      v13 = memcpy((void *)v11[1], a2 + 2, *v11);
      if (dword_10008BA20)
      {
        v14 = ne_log_obj(v13);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          v15 = sub_1000291E4((char *)v12[1], *v12);
          v28 = 136315138;
          v29 = v15;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "XAUTH Message: '%s'.\n", (uint8_t *)&v28, 0xCu);
        }
      }
      sub_10003F318(v12);
    }
    goto LABEL_23;
  }
  if (v6 != 16527)
  {
LABEL_23:
    if (dword_10008BA20)
    {
      v16 = ne_log_obj(a1);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        v17 = sub_10003DC14(v6);
        v28 = 136315138;
        v29 = v17;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Ignored attribute %s\n", (uint8_t *)&v28, 0xCu);
      }
    }
    return 0;
  }
  v8 = *(_DWORD *)(*(_QWORD *)(a1 + 72) + 48);
  if (*(_QWORD *)(*(_QWORD *)(a1 + 64) + 272))
    v9 = v8 == 65001;
  else
    v9 = 0;
  if (!v9)
  {
    switch(v8)
    {
      case 65002:
        if ((*(_BYTE *)(a1 + 432) & 1) != 0)
          goto LABEL_31;
        if (dword_10008BA20)
        {
          v10 = ne_log_obj(a1);
          if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
            sub_100065680();
        }
        return 0;
      case 65003:
      case 65004:
      case 65006:
      case 65008:
        goto LABEL_52;
      case 65005:
      case 65007:
      case 65009:
        goto LABEL_31;
      default:
        if (v8 == 64221 || v8 == 65500)
          goto LABEL_31;
LABEL_52:
        if (dword_10008BA20)
        {
          v27 = ne_log_obj(a1);
          if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
            sub_100065654();
        }
        break;
    }
    return 0;
  }
LABEL_31:
  if (a2[1] == 256)
  {
    if ((*(_BYTE *)(a1 + 432) & 1) != 0)
      *(_DWORD *)(v2 + 1144) = 2;
    if (!dword_10008BA20)
      goto LABEL_44;
    v19 = ne_log_obj(a1);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      goto LABEL_44;
    LOWORD(v28) = 0;
    v20 = "IPSec Extended Authentication Passed.\n";
  }
  else
  {
    if (dword_10008BA20)
    {
      v21 = ne_log_obj(a1);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        sub_100065628();
    }
    v22 = sub_10000A9C8(a1);
    v23 = sub_1000487BC(0x18u, 0, v22, 0, 0);
    **(_DWORD **)(a1 + 408) |= 0x800u;
    if (!dword_10008BA20)
      goto LABEL_44;
    v19 = ne_log_obj(v23);
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      goto LABEL_44;
    LOWORD(v28) = 0;
    v20 = "IPSec Extended Authentication Failed.\n";
  }
  _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, v20, (uint8_t *)&v28, 2u);
LABEL_44:
  result = sub_10003F1F8(4uLL);
  if (result)
  {
    *(_DWORD *)result[1] = 36800;
    return result;
  }
  if (dword_10008BA20)
  {
    v25 = ne_log_obj(0);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      sub_100059870();
  }
  return 0;
}

void sub_1000470CC(uint64_t a1)
{
  int v2;
  NSObject *v3;
  int v4;
  const char *v5;
  void *v6;
  void *v7;
  int v8;
  int v9;
  int v10;

  v2 = *(_DWORD *)(a1 + 8);
  if ((v2 - 1) >= 3)
  {
    if (v2)
    {
      if (dword_10008BA20)
      {
        v3 = ne_log_obj();
        if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
        {
          v8 = *(_DWORD *)(a1 + 8);
          v9 = 67109120;
          v10 = v8;
          v5 = "Unexpected authtype %d\n";
          goto LABEL_13;
        }
      }
    }
    else
    {
      v6 = *(void **)(a1 + 16);
      if (v6)
        free(v6);
      v7 = *(void **)(a1 + 24);
      if (v7)
        free(v7);
    }
  }
  else if (dword_10008BA20)
  {
    v3 = ne_log_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4 = *(_DWORD *)(a1 + 8);
      v9 = 67109120;
      v10 = v4;
      v5 = "Unsupported authtype %d\n";
LABEL_13:
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, v5, (uint8_t *)&v9, 8u);
    }
  }
}

uint64_t sub_100047214(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t result;
  _QWORD *v5;
  _QWORD *v6;
  NSObject *v7;

  v2 = *(_QWORD **)a1;
  if (*(_QWORD *)a1)
  {
    if (*v2)
    {
      sub_10003F318((_QWORD *)*v2);
      **(_QWORD **)a1 = 0;
      v2 = *(_QWORD **)a1;
    }
    v3 = (_QWORD *)v2[1];
    if (v3)
    {
      sub_10003F318(v3);
      *(_QWORD *)(*(_QWORD *)a1 + 8) = 0;
      v2 = *(_QWORD **)a1;
    }
    result = 0;
    goto LABEL_9;
  }
  v5 = malloc_type_malloc(0x18uLL, 0x1020040EDCEB4C7uLL);
  *(_QWORD *)a1 = v5;
  if (v5)
  {
    v6 = v5;
    result = 0;
    *v6 = 0;
    *(_QWORD *)(*(_QWORD *)a1 + 8) = 0;
    v2 = *(_QWORD **)a1;
LABEL_9:
    *((_DWORD *)v2 + 4) = 0;
    return result;
  }
  if (dword_10008BA20)
  {
    v7 = ne_log_obj(0);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      sub_1000656AC();
  }
  return 0xFFFFFFFFLL;
}

void sub_1000472E4(_QWORD ***a1)
{
  _QWORD **v2;

  v2 = *a1;
  if (v2)
  {
    if (*v2)
    {
      sub_10003F318(*v2);
      v2 = *a1;
    }
    if (v2[1])
    {
      sub_10003F318(v2[1]);
      v2 = *a1;
    }
    free(v2);
    *a1 = 0;
  }
}

void sub_100047338()
{
  void *v0;
  void *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  int v6;
  NSObject *v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  NSObject *v11;
  NSObject *v12;
  uint8_t v13[16];
  _QWORD v14[5];
  int v15;
  _QWORD handler[5];
  socklen_t v17;
  sockaddr v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;

  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v18 = (sockaddr)0;
  v19 = 0u;
  v17 = 128;
  dword_10008BA20 = 1;
  v0 = malloc_type_calloc(1uLL, 0x38uLL, 0x10B0040FCE79EF2uLL);
  if (v0)
  {
    v1 = v0;
    *((_QWORD *)v0 + 6) = 0;
    v2 = accept(*(_DWORD *)(qword_10008B848 + 28), &v18, &v17);
    *((_DWORD *)v1 + 4) = v2;
    if ((v2 & 0x80000000) != 0)
    {
      if (dword_10008BA20)
      {
        v11 = ne_log_obj(v2);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          sub_100065744();
      }
    }
    else
    {
      v3 = *(_QWORD *)(qword_10008B848 + 64);
      *(_QWORD *)v1 = v3;
      v4 = qword_10008B848;
      if (v3)
        *(_QWORD *)(*(_QWORD *)(qword_10008B848 + 64) + 8) = v1;
      *(_QWORD *)(v4 + 64) = v1;
      *((_QWORD *)v1 + 1) = v4 + 64;
      v5 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, v2, 0, (dispatch_queue_t)&_dispatch_main_q);
      *((_QWORD *)v1 + 3) = v5;
      if (v5)
      {
        handler[0] = _NSConcreteStackBlock;
        handler[1] = 0x40000000;
        handler[2] = sub_100047594;
        handler[3] = &unk_100086BF0;
        handler[4] = v1;
        dispatch_source_set_event_handler(v5, handler);
        v6 = *((_DWORD *)v1 + 4);
        v7 = *((_QWORD *)v1 + 3);
        v14[0] = _NSConcreteStackBlock;
        v14[1] = 0x40000000;
        v14[2] = sub_100048310;
        v14[3] = &unk_100086C10;
        v15 = v6;
        v14[4] = v7;
        dispatch_source_set_cancel_handler(v7, v14);
        dispatch_resume(*((dispatch_object_t *)v1 + 3));
        if (dword_10008BA20)
        {
          v9 = ne_log_obj(v8);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)v13 = 0;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "accepted connection on vpn control socket.\n", v13, 2u);
          }
        }
        sub_10003AEAC();
        return;
      }
      if (dword_10008BA20)
      {
        v12 = ne_log_obj(0);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          sub_1000657B0();
      }
    }
    free(v1);
    return;
  }
  if (dword_10008BA20)
  {
    v10 = ne_log_obj(0);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      sub_1000656D8();
  }
}

void sub_100047594(uint64_t a1)
{
  sub_10004759C(*(_QWORD *)(a1 + 32));
}

void sub_10004759C(uint64_t a1)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int *v7;
  NSObject *v8;
  int *v9;
  unint64_t v10;
  NSObject *v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  NSObject *v15;
  _BOOL4 v16;
  NSObject *v17;
  NSObject *v18;
  const char *v19;
  unsigned __int16 *v20;
  uint64_t v21;
  NSObject *v22;
  size_t v23;
  void *v24;
  NSObject *v25;
  NSObject *v26;
  NSObject *v27;
  NSObject *v28;
  NSObject *v29;
  NSObject *v30;
  NSObject *v31;
  NSObject *v32;
  NSObject *v33;
  NSObject *v34;
  NSObject *v35;
  NSObject *v36;
  _WORD *v37;
  NSObject *v38;
  NSObject *v39;
  _DWORD *v40;
  _DWORD *v41;
  int v42;
  uint64_t v43;
  _QWORD *v44;
  NSObject *v45;
  unsigned int v46;
  _QWORD *v47;
  _QWORD *v48;
  int v49;
  NSObject *v50;
  int v51;
  NSObject *v52;
  NSObject *v53;
  NSObject *v54;
  NSObject *v55;
  uint64_t v56;
  int v57;
  int v58;
  int v59;
  NSObject *v60;
  NSObject *v61;
  int v62;
  uint64_t *v63;
  uint64_t *v64;
  _QWORD *v65;
  _QWORD *v66;
  uint64_t v67;
  uint64_t v68;
  NSObject *v69;
  _QWORD *v70;
  _QWORD *v71;
  _QWORD *v72;
  _QWORD *v73;
  uint64_t v74;
  NSObject *v75;
  uint64_t v76;
  int v77;
  NSObject *v78;
  NSObject *v79;
  NSObject *v80;
  ssize_t v81;
  NSObject *v82;
  uint64_t v83;
  uint64_t v84;
  _DWORD v85[2];
  uint64_t v86;
  uint8_t buf[4];
  _BYTE v88[20];
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  uint64_t v95;

  v83 = 0;
  v84 = 0;
  if (*(_QWORD *)(a1 + 40))
  {
LABEL_2:
    while (1)
    {
      v2 = recv(*(_DWORD *)(a1 + 16), (void *)(*(_QWORD *)(a1 + 40) + *(unsigned int *)(a1 + 32)), *(unsigned int *)(a1 + 36), 0);
      if ((v2 & 0x8000000000000000) == 0)
        break;
      v7 = __error();
      if (*v7 != 4)
      {
        if (dword_10008BA20)
        {
          v8 = ne_log_obj(v7);
          if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
            goto LABEL_6;
        }
        return;
      }
    }
    v12 = v2;
    if (v2)
    {
      v13 = *(unsigned int *)(a1 + 36);
      v14 = (*(_DWORD *)(a1 + 32) + v2);
      *(_DWORD *)(a1 + 32) = v14;
      if (v2 < v13)
      {
        if (dword_10008BA20)
        {
          v15 = ne_log_obj(v2);
          v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
          LODWORD(v13) = *(_DWORD *)(a1 + 36);
          if (v16)
          {
            *(_DWORD *)buf = 134218240;
            *(_QWORD *)v88 = v12;
            *(_WORD *)&v88[8] = 1024;
            *(_DWORD *)&v88[10] = v13;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "received partial vpn_control command - len=%ld - expected %u\n", buf, 0x12u);
            LODWORD(v13) = *(_DWORD *)(a1 + 36);
          }
        }
        *(_DWORD *)(a1 + 36) = v13 - v12;
        return;
      }
      v20 = *(unsigned __int16 **)(a1 + 40);
      v21 = 0;
      switch(bswap32(*v20) >> 16)
      {
        case 1u:
          if (v14 <= 0x17)
          {
            if (dword_10008BA20)
            {
              v22 = ne_log_obj(0);
              if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
                sub_1000659C4();
            }
            goto LABEL_197;
          }
          v37 = v20 + 10;
          if ((unint64_t)(bswap32(v20[10]) >> 16) + 24 > v14)
          {
            if (dword_10008BA20)
            {
              v38 = ne_log_obj(0);
              if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
                sub_100065A24();
            }
            goto LABEL_197;
          }
          if (dword_10008BA20)
          {
            v69 = ne_log_obj(0);
            if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEFAULT, "received bind command on vpn control socket.\n", buf, 2u);
            }
          }
          v70 = malloc_type_calloc(1uLL, 0x40uLL, 0x10A0040D5FA6E92uLL);
          if (!v70)
          {
            if (dword_10008BA20)
            {
              v79 = ne_log_obj(0);
              if (os_log_type_enabled(v79, OS_LOG_TYPE_ERROR))
                sub_1000656D8();
            }
            goto LABEL_197;
          }
          v71 = v70;
          if (*v37)
          {
            v72 = sub_10003F1F8(__rev16((unsigned __int16)*v37));
            v71[7] = v72;
            if (!v72)
            {
              if (dword_10008BA20)
              {
                v80 = ne_log_obj(0);
                if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR))
                  sub_1000656D8();
              }
              free(v71);
              goto LABEL_197;
            }
            memcpy((void *)v72[1], v20 + 12, bswap32(v20[10]) >> 16);
          }
          *((_DWORD *)v71 + 4) = *((_DWORD *)v20 + 4);
          v73 = (_QWORD *)(a1 + 48);
          v74 = *(_QWORD *)(a1 + 48);
          *v71 = v74;
          if (v74)
            *(_QWORD *)(v74 + 8) = v71;
          LODWORD(v21) = 0;
          *v73 = v71;
          v71[1] = v73;
          *(_DWORD *)(qword_10008B848 + 80) |= 0x10u;
          goto LABEL_198;
        case 2u:
          if (v14 <= 0x13)
          {
            if (dword_10008BA20)
            {
              v26 = ne_log_obj(0);
              if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
                sub_100065A9C();
            }
            goto LABEL_197;
          }
          if (dword_10008BA20)
          {
            v39 = ne_log_obj(0);
            if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "received unbind command on vpn control socket.\n", buf, 2u);
            }
          }
          v40 = *(_DWORD **)(a1 + 48);
          if (!v40)
            goto LABEL_192;
          break;
        case 3u:
          if (v14 <= 0x1B)
          {
            if (dword_10008BA20)
            {
              v27 = ne_log_obj(0);
              if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
                sub_100065AFC();
            }
            goto LABEL_197;
          }
          if (dword_10008BA20)
          {
            v45 = ne_log_obj(0);
            if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
            {
              v46 = bswap32(*((_DWORD *)v20 + 5));
              *(_DWORD *)buf = 67109120;
              *(_DWORD *)v88 = v46;
              _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "received redirect command on vpn control socket - address = %x.\n", buf, 8u);
            }
          }
          v47 = *(_QWORD **)(qword_10008B848 + 72);
          while (v47)
          {
            v48 = v47;
            v47 = (_QWORD *)*v47;
            if (*((_DWORD *)v48 + 4) == *((_DWORD *)v20 + 4))
            {
              v49 = *((_DWORD *)v20 + 5);
              if (!v49)
              {
                if (v47)
                  v47[1] = v48[1];
                *(_QWORD *)v48[1] = v47;
                free(v48);
                goto LABEL_192;
              }
              LODWORD(v21) = 0;
              *((_DWORD *)v48 + 5) = v49;
              *((_WORD *)v48 + 12) = bswap32(v20[12]) >> 16;
              goto LABEL_198;
            }
          }
          v65 = malloc_type_malloc(0x20uLL, 0x10A00401099AC32uLL);
          if (!v65)
          {
            if (dword_10008BA20)
            {
              v78 = ne_log_obj(0);
              if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
                sub_100065B64();
            }
            goto LABEL_197;
          }
          v66 = v65;
          v65[2] = *((_QWORD *)v20 + 2);
          *((_WORD *)v65 + 12) = bswap32(v20[12]) >> 16;
          v67 = *(_QWORD *)(qword_10008B848 + 72);
          *v65 = v67;
          v68 = qword_10008B848;
          if (v67)
            *(_QWORD *)(*(_QWORD *)(qword_10008B848 + 72) + 8) = v65;
          LODWORD(v21) = 0;
          *(_QWORD *)(v68 + 72) = v66;
          v66[1] = v68 + 72;
          goto LABEL_198;
        case 4u:
          goto LABEL_198;
        case 0x11u:
          if (v14 <= 0x13)
          {
            if (dword_10008BA20)
            {
              v29 = ne_log_obj(0);
              if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
                sub_100065CC8();
            }
            goto LABEL_197;
          }
          if (dword_10008BE2C)
          {
            sub_10003AFCC(0);
            dword_10008BE2C = 0;
          }
          if (dword_10008BA20)
          {
            v50 = ne_log_obj(v21);
            if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "received connect command on vpn control socket.\n", buf, 2u);
            }
          }
          v21 = a1 + 48;
          while (1)
          {
            v21 = *(_QWORD *)v21;
            if (!v21)
              goto LABEL_198;
            if (*((_DWORD *)v20 + 4) == *(_DWORD *)(v21 + 16))
            {
              v51 = 1;
              goto LABEL_154;
            }
          }
        case 0x12u:
          if (v14 <= 0x13)
          {
            if (dword_10008BA20)
            {
              v30 = ne_log_obj(0);
              if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
                sub_100065D28();
            }
            goto LABEL_197;
          }
          if (dword_10008BA20)
          {
            v52 = ne_log_obj(0);
            if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "received disconnect command on vpn control socket.\n", buf, 2u);
            }
          }
          v21 = a1 + 48;
          while (1)
          {
            v21 = *(_QWORD *)v21;
            if (!v21)
              goto LABEL_198;
            if (*((_DWORD *)v20 + 4) == *(_DWORD *)(v21 + 16))
            {
              LODWORD(v21) = sub_1000499E0(v21, (uint64_t)off_1000884F0[0]);
              goto LABEL_198;
            }
          }
        case 0x13u:
          if (v14 <= 0x1F)
          {
            if (dword_10008BA20)
            {
              v31 = ne_log_obj(0);
              if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
                sub_100065D88();
            }
            goto LABEL_197;
          }
          if (dword_10008BA20)
          {
            v53 = ne_log_obj(0);
            if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "received start_ph2 command on vpn control socket.\n", buf, 2u);
            }
          }
          v21 = a1 + 48;
          while (1)
          {
            v21 = *(_QWORD *)v21;
            if (!v21)
              goto LABEL_198;
            if (*((_DWORD *)v20 + 4) == *(_DWORD *)(v21 + 16))
            {
              LODWORD(v21) = sub_100049AD4(v21, (uint64_t)v20, v14);
              goto LABEL_198;
            }
          }
        case 0x14u:
          if (v14 <= 0x13)
          {
            if (dword_10008BA20)
            {
              v32 = ne_log_obj(0);
              if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
                sub_100065B90();
            }
            goto LABEL_197;
          }
          if ((unint64_t)(bswap32(v20[7]) >> 16) + 16 > v14)
          {
            if (dword_10008BA20)
            {
              v54 = ne_log_obj(0);
              if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
                sub_100065BF0();
            }
            goto LABEL_197;
          }
          if (dword_10008BA20)
          {
            v75 = ne_log_obj(0);
            if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, "received xauth info command vpn control socket.\n", buf, 2u);
            }
          }
          v76 = a1 + 48;
          do
          {
            v76 = *(_QWORD *)v76;
            if (!v76)
              goto LABEL_192;
            v77 = *((_DWORD *)v20 + 4);
          }
          while (v77 != *(_DWORD *)(v76 + 16));
          LODWORD(v21) = sub_10004A464(v77, v20 + 10, (bswap32(v20[7]) >> 16) - 4);
          goto LABEL_198;
        case 0x15u:
          if (v14 <= 0x13)
          {
            if (dword_10008BA20)
            {
              v33 = ne_log_obj(0);
              if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
                sub_100065DE8();
            }
            goto LABEL_197;
          }
          if (dword_10008BA20)
          {
            v55 = ne_log_obj(0);
            if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "received start_dpd command on vpn control socket.\n", buf, 2u);
            }
          }
          v56 = a1 + 48;
          do
          {
            v56 = *(_QWORD *)v56;
            if (!v56)
              goto LABEL_192;
            v57 = *((_DWORD *)v20 + 4);
          }
          while (v57 != *(_DWORD *)(v56 + 16));
          v95 = 0;
          v94 = 0u;
          v93 = 0u;
          v92 = 0u;
          v91 = 0u;
          v90 = 0u;
          v89 = 0u;
          *(_OWORD *)&v88[4] = 0u;
          *(_DWORD *)buf = 528;
          *(_DWORD *)v88 = v57;
          LODWORD(v21) = sub_10000A320((unint64_t)buf);
          goto LABEL_198;
        case 0x16u:
          if (v14 <= 0x17)
          {
            if (dword_10008BA20)
            {
              v34 = ne_log_obj(0);
              if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
                sub_100065E48();
            }
            goto LABEL_197;
          }
          if (dword_1000882C8 >= 5)
            sub_10003372C(5, *(_QWORD *)(a1 + 40), (bswap32(v20[7]) >> 16) + 16, "received assert command on vpn control socket.\n", v3, v4, v5, v6, v83);
          *(_QWORD *)&v88[4] = 0;
          v58 = *((_DWORD *)v20 + 4);
          v59 = *((_DWORD *)v20 + 5);
          *(_DWORD *)buf = 528;
          *(_DWORD *)v88 = v58;
          v86 = 0;
          v85[0] = 528;
          v85[1] = v59;
          LODWORD(v21) = sub_10004A704((uint64_t)buf, (uint64_t)v85);
          goto LABEL_198;
        case 0x17u:
          if (v14 <= 0x13)
          {
            if (dword_10008BA20)
            {
              v35 = ne_log_obj(0);
              if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
                sub_100065EA8();
            }
            goto LABEL_197;
          }
          if (dword_10008BA20)
          {
            v60 = ne_log_obj(0);
            if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "received reconnect command on vpn control socket.\n", buf, 2u);
            }
          }
          v21 = a1 + 48;
          while (1)
          {
            v21 = *(_QWORD *)v21;
            if (!v21)
              break;
            if (*((_DWORD *)v20 + 4) == *(_DWORD *)(v21 + 16))
            {
              v51 = 3;
LABEL_154:
              LODWORD(v21) = sub_100049668(v21, v51);
              break;
            }
          }
LABEL_198:
          v20[7] = 0;
          v20[6] = bswap32(v21) >> 16;
          v81 = send(*(_DWORD *)(a1 + 16), v20, 0x10uLL, 0);
          if (v81 < 0)
          {
            if (dword_10008BA20)
            {
              v82 = ne_log_obj(v81);
              if (os_log_type_enabled(v82, OS_LOG_TYPE_ERROR))
                sub_1000658DC();
            }
          }
          free(*(void **)(a1 + 40));
          *(_QWORD *)(a1 + 32) = 0;
          *(_QWORD *)(a1 + 40) = 0;
          return;
        case 0x18u:
          if (v14 <= 0x1F)
          {
            if (dword_10008BA20)
            {
              v36 = ne_log_obj(0);
              if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
                sub_100065C68();
            }
            goto LABEL_197;
          }
          if (dword_10008BA20)
          {
            v61 = ne_log_obj(0);
            if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
            {
              v62 = *((_DWORD *)v20 + 4);
              *(_DWORD *)buf = 67109120;
              *(_DWORD *)v88 = v62;
              _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "received set v6 prefix of len %u command on vpn control socket, adding to all addresses.\n", buf, 8u);
            }
          }
          v63 = *(uint64_t **)(a1 + 48);
          if (v63)
          {
            LODWORD(v21) = 0;
            do
            {
              v64 = (uint64_t *)*v63;
              *(_OWORD *)((char *)v63 + 20) = *((_OWORD *)v20 + 1);
              v63 = v64;
            }
            while (v64);
          }
          else
          {
LABEL_192:
            LODWORD(v21) = 0;
          }
          goto LABEL_198;
        default:
          if (dword_10008BA20)
          {
            v28 = ne_log_obj(0);
            if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
              sub_100065948(v20, v28);
          }
LABEL_197:
          LODWORD(v21) = 0xFFFF;
          goto LABEL_198;
      }
      while (1)
      {
        v41 = *(_DWORD **)v40;
        v42 = *((_DWORD *)v20 + 4);
        if (v42 == -1)
          break;
        if (v42 == v40[4])
          goto LABEL_95;
LABEL_100:
        LODWORD(v21) = 0;
        v40 = v41;
        if (!v41)
          goto LABEL_198;
      }
      v42 = v40[4];
LABEL_95:
      sub_10003A248(v42);
      v43 = *(_QWORD *)v40;
      if (*(_QWORD *)v40)
        *(_QWORD *)(v43 + 8) = *((_QWORD *)v40 + 1);
      **((_QWORD **)v40 + 1) = v43;
      v44 = (_QWORD *)*((_QWORD *)v40 + 7);
      if (v44)
        sub_10003F318(v44);
      free(v40);
      goto LABEL_100;
    }
    if (dword_10008BA20)
    {
      v18 = ne_log_obj(0);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        v19 = "vpn_control socket closed by peer while reading packet\n";
LABEL_34:
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v19, buf, 2u);
        goto LABEL_35;
      }
    }
    goto LABEL_35;
  }
  do
  {
    v10 = recv(*(_DWORD *)(a1 + 16), &v83, 0x10uLL, 2);
    if ((v10 & 0x8000000000000000) == 0)
    {
      if (v10)
      {
        if (v10 > 0xF)
        {
          v23 = (bswap32(HIWORD(v84)) >> 16) + 16;
          *(_DWORD *)(a1 + 32) = 0;
          *(_DWORD *)(a1 + 36) = v23;
          v24 = malloc_type_malloc(v23, 0x9525C829uLL);
          *(_QWORD *)(a1 + 40) = v24;
          if (v24)
            goto LABEL_2;
          if (dword_10008BA20)
          {
            v25 = ne_log_obj(0);
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
              sub_1000658B0();
          }
        }
        else if (dword_10008BA20)
        {
          v11 = ne_log_obj(v10);
          if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
            sub_100065848();
        }
        return;
      }
      if (dword_10008BA20)
      {
        v18 = ne_log_obj(0);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          v19 = "vpn_control socket closed by peer.\n";
          goto LABEL_34;
        }
      }
LABEL_35:
      sub_100048338(a1, (uint64_t)off_1000884F8[0]);
      sub_1000483D0((uint64_t *)a1);
      return;
    }
    v9 = __error();
  }
  while (*v9 == 4);
  if (dword_10008BA20)
  {
    v17 = ne_log_obj(v9);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
LABEL_6:
      sub_1000657DC();
  }
}

void sub_100048310(uint64_t a1)
{
  close(*(_DWORD *)(a1 + 40));
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

_QWORD *sub_100048338(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  _QWORD *result;
  _QWORD *v6;
  uint8_t v7[16];

  if (dword_10008BA20)
  {
    v4 = ne_log_obj(a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v7 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "received disconnect all command.\n", v7, 2u);
    }
  }
  result = *(_QWORD **)(a1 + 48);
  if (result)
  {
    do
    {
      v6 = (_QWORD *)*result;
      sub_1000499E0((uint64_t)result, a2);
      result = v6;
    }
    while (v6);
  }
  return result;
}

uint64_t sub_1000483D0(uint64_t *a1)
{
  NSObject *v2;
  uint64_t v3;
  void *v4;
  _DWORD *v5;
  _DWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t result;
  __int16 v10[8];

  if (dword_10008BA20)
  {
    v2 = ne_log_obj(a1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      v10[0] = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "vpncontrol_close_comm.\n", (uint8_t *)v10, 2u);
    }
  }
  v3 = *a1;
  if (*a1)
    *(_QWORD *)(v3 + 8) = a1[1];
  *(_QWORD *)a1[1] = v3;
  if (*((_DWORD *)a1 + 4) != -1)
  {
    dispatch_source_cancel((dispatch_source_t)a1[3]);
    *((_DWORD *)a1 + 4) = -1;
  }
  v4 = (void *)a1[5];
  if (v4)
  {
    free(v4);
    a1[4] = 0;
    a1[5] = 0;
  }
  v5 = (_DWORD *)a1[6];
  if (v5)
  {
    do
    {
      v6 = *(_DWORD **)v5;
      sub_10003A248(v5[4]);
      v7 = *(_QWORD *)v5;
      if (*(_QWORD *)v5)
        *(_QWORD *)(v7 + 8) = *((_QWORD *)v5 + 1);
      **((_QWORD **)v5 + 1) = v7;
      v8 = (_QWORD *)*((_QWORD *)v5 + 7);
      if (v8)
        sub_10003F318(v8);
      free(v5);
      v5 = v6;
    }
    while (v6);
  }
  free(a1);
  result = sub_10003AEAC();
  dword_10008BA20 = *(_QWORD *)(qword_10008B848 + 64) != 0;
  return result;
}

uint64_t sub_1000484FC(_OWORD *a1)
{
  _QWORD *i;
  _QWORD *v2;

  for (i = *(_QWORD **)(qword_10008B848 + 64); i; i = (_QWORD *)*i)
  {
    v2 = i + 6;
    while (1)
    {
      v2 = (_QWORD *)*v2;
      if (!v2)
        break;
      if (*((_DWORD *)v2 + 5))
      {
        *a1 = *(_OWORD *)((char *)v2 + 20);
        return 1;
      }
    }
  }
  return 0;
}

uint64_t sub_100048548(uint64_t result, const void *a2, size_t a3)
{
  uint64_t v5;
  NSObject *v6;
  __int16 *v7;
  __int16 *v8;
  int v9;
  int v10;
  __int16 v11;
  ssize_t v12;
  uint64_t *i;
  uint64_t *v14;
  int v15;
  NSObject *v17;
  NSObject *v18;
  NSObject *v19;
  uint8_t buf[4];
  size_t v21;

  if (result)
  {
    v5 = result;
    if (dword_10008BA20)
    {
      v6 = ne_log_obj(result);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "sending vpn_control xauth need info status\n", buf, 2u);
      }
    }
    v7 = (__int16 *)malloc_type_malloc(a3 + 20, 0x2DD99451uLL);
    if (v7)
    {
      v8 = v7;
      v7[1] = 0;
      v9 = sub_10000A9C8(v5);
      if (v9)
      {
        v10 = v9;
        v8[6] = 0;
        *((_DWORD *)v8 + 1) = 0;
        *((_DWORD *)v8 + 2) = 0;
        v8[7] = bswap32(a3 + 4) >> 16;
        v11 = sub_10004DAAC(v5) ? 641 : 385;
        *v8 = v11;
        *((_DWORD *)v8 + 4) = sub_10000A9C8(v5);
        v12 = (ssize_t)memcpy(v8 + 10, a2, a3);
        for (i = *(uint64_t **)(qword_10008B848 + 64); i; i = (uint64_t *)*i)
        {
          v14 = i + 6;
          while (1)
          {
            v14 = (uint64_t *)*v14;
            if (!v14)
              break;
            v15 = *((_DWORD *)v14 + 4);
            if (v15 == -1 || v15 == v10)
            {
              if (dword_10008BA20)
              {
                v17 = ne_log_obj(v12);
                if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)buf = 134217984;
                  v21 = a3 + 20;
                  _os_log_debug_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "vpn control writing %zu bytes\n", buf, 0xCu);
                }
              }
              v12 = send(*((_DWORD *)i + 4), v8, a3 + 20, 0);
              if (v12 < 0 && dword_10008BA20)
              {
                v18 = ne_log_obj(v12);
                v12 = os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
                if ((_DWORD)v12)
                  sub_100065F34();
              }
              break;
            }
          }
        }
      }
      free(v8);
      return 0;
    }
    else
    {
      if (dword_10008BA20)
      {
        v19 = ne_log_obj(0);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          sub_100065F08();
      }
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t sub_1000487BC(unsigned int a1, unsigned int a2, int a3, unsigned int a4, const void *a5)
{
  size_t v10;
  size_t v11;
  char *v12;
  void *v13;
  NSObject *v14;
  uint64_t *i;
  uint64_t *v16;
  int v17;
  ssize_t v19;
  ssize_t v20;
  NSObject *v21;
  NSObject *v22;
  NSObject *v24;
  uint8_t buf[4];
  ssize_t v26;
  __int16 v27;
  size_t v28;

  v10 = a4;
  v11 = a4 + 24;
  v12 = (char *)malloc_type_malloc(v11, 0xFAE13350uLL);
  if (v12)
  {
    v13 = v12;
    *(_WORD *)v12 = 384;
    *(_QWORD *)(v12 + 2) = 0;
    *(_DWORD *)(v12 + 10) = 0;
    *((_WORD *)v12 + 7) = bswap32(a4 + 8) >> 16;
    *((_DWORD *)v12 + 4) = a3;
    *((_WORD *)v12 + 10) = __rev16(a1);
    *((_WORD *)v12 + 11) = __rev16(a2);
    if (a4)
      v12 = (char *)memcpy(v12 + 24, a5, v10);
    if (dword_10008BA20)
    {
      v14 = ne_log_obj(v12);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        sub_100065FF8(a1, a2, v14);
    }
    for (i = *(uint64_t **)(qword_10008B848 + 64); i; i = (uint64_t *)*i)
    {
      v16 = i + 6;
      while (1)
      {
        v16 = (uint64_t *)*v16;
        if (!v16)
          break;
        v17 = *((_DWORD *)v16 + 4);
        if (v17 == -1 || v17 == a3)
        {
          v19 = send(*((_DWORD *)i + 4), v13, v11, 0);
          if (v19 < 0)
          {
            if (dword_10008BA20)
            {
              v22 = ne_log_obj(v19);
              if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
                sub_100065FAC();
            }
          }
          else if (dword_10008BA20)
          {
            v20 = v19;
            v21 = ne_log_obj(v19);
            if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 134218240;
              v26 = v20;
              v27 = 2048;
              v28 = v11;
              _os_log_debug_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEBUG, "Sent %zd/%zu bytes\n", buf, 0x16u);
            }
          }
          break;
        }
      }
    }
    free(v13);
    return 0;
  }
  else
  {
    if (dword_10008BA20)
    {
      v24 = ne_log_obj(0);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        sub_100065F80();
    }
    return 0xFFFFFFFFLL;
  }
}

const char *sub_100048A1C(int a1)
{
  if (a1 > 32800)
  {
    if (a1 > 33024)
    {
      if (a1 == 33025)
        return "Need authentication info";
      if (a1 == 33026)
        return "Need re-authentication info";
    }
    else
    {
      if (a1 == 32801)
        return "Phase 2 started";
      if (a1 == 32802)
        return "Phase 2 established";
    }
  }
  else if (a1 > 32785)
  {
    if (a1 == 32786)
      return "Phase 1 started by peer";
    if (a1 == 32787)
      return "Phase 1 established";
  }
  else
  {
    if (a1 == 32769)
      return "IKE failed";
    if (a1 == 32785)
      return "Phase 1 started by us";
  }
  return (const char *)&unk_10007E079;
}

uint64_t sub_100048B0C(int a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  _WORD *v9;
  uint64_t v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  _WORD *v14;
  unsigned int v15;
  NSObject *v16;
  const char *v17;
  uint64_t *i;
  uint64_t *v19;
  int v20;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  uint64_t v25;
  NSObject *v26;
  uint64_t result;
  NSObject *v28;
  size_t v29;
  void *v30;
  uint8_t buf[4];
  size_t v32;

  v29 = 0;
  v30 = 0;
  if (a1 || !a3 || (v8 = *(_QWORD *)(a3 + 408)) == 0 || *(_DWORD *)(v8 + 1144) == 2)
  {
    v29 = 20;
    v9 = malloc_type_malloc(0x14uLL, 0x361CAED1uLL);
    v30 = v9;
    v9[1] = 0;
    if (!a3)
    {
      v14 = v9;
      v10 = sub_10000AAA8(a4);
      if ((_DWORD)v10)
      {
        v11 = v10;
        if (a1)
          v15 = -32735;
        else
          v15 = -32734;
        v13 = bswap32(v15) >> 16;
        goto LABEL_18;
      }
      if (dword_10008BA20)
      {
        v28 = ne_log_obj(v10);
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
          sub_100066094();
      }
LABEL_50:
      result = (uint64_t)v30;
      if (!v30)
        return result;
      free(v30);
      return 0;
    }
LABEL_6:
    v10 = sub_10000A9C8(a3);
    if ((_DWORD)v10)
    {
      v11 = v10;
      if (a2)
        v12 = -32750;
      else
        v12 = -32751;
      if (!a1)
        v12 = -32749;
      v13 = bswap32(v12) >> 16;
      v14 = v30;
LABEL_18:
      *v14 = v13;
      if (dword_10008BA20)
      {
        v16 = ne_log_obj(v10);
        v10 = os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT);
        v14 = v30;
        if ((_DWORD)v10)
        {
          v17 = sub_100048A1C(bswap32(*(unsigned __int16 *)v30) >> 16);
          *(_DWORD *)buf = 136315138;
          v32 = (size_t)v17;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, ">>>>> phase change status = %s\n", buf, 0xCu);
          v14 = v30;
        }
      }
      v14[6] = 0;
      *((_DWORD *)v14 + 1) = 0;
      *((_DWORD *)v14 + 2) = 0;
      v14[7] = bswap32((unsigned __int16)v29 - 16) >> 16;
      *((_DWORD *)v14 + 4) = v11;
      for (i = *(uint64_t **)(qword_10008B848 + 64); i; i = (uint64_t *)*i)
      {
        v19 = i + 6;
        while (1)
        {
          v19 = (uint64_t *)*v19;
          if (!v19)
            break;
          v20 = *((_DWORD *)v19 + 4);
          if (v20 == -1 || v20 == v11)
          {
            if (dword_10008BA20)
            {
              v22 = ne_log_obj(v10);
              if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 134217984;
                v32 = v29;
                _os_log_debug_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEBUG, "vpn control writing %zu bytes\n", buf, 0xCu);
              }
            }
            v10 = send(*((_DWORD *)i + 4), v30, v29, 0);
            if (v10 < 0 && dword_10008BA20)
            {
              v23 = ne_log_obj(v10);
              v10 = os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
              if ((_DWORD)v10)
                sub_1000660C0();
            }
            break;
          }
        }
      }
      goto LABEL_50;
    }
    if (dword_10008BA20)
    {
      v24 = ne_log_obj(v10);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        sub_10006610C();
    }
    goto LABEL_50;
  }
  v25 = sub_10004A2A0(a3, &v30, &v29);
  if ((_DWORD)v25 == 1)
    return 0;
  if (v30)
    goto LABEL_6;
  if (dword_10008BA20)
  {
    v26 = ne_log_obj(v25);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      sub_100065F08();
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100048E70(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t result;
  int v6;

  if (!a2)
    return 0;
  v3 = *(_QWORD *)(a2 + 440);
  if (!v3 || (*(_BYTE *)(v3 + 280) & 1) == 0)
    return 0;
  v6 = sub_10000A9C8(a2);
  result = sub_100048EE4(a1, v6);
  if ((_DWORD)result)
    return 0xFFFFFFFFLL;
  *(_BYTE *)(*(_QWORD *)(a2 + 440) + 280) &= ~1u;
  return result;
}

uint64_t sub_100048EE4(uint64_t a1, int a2)
{
  int v3;
  NSObject *v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t *v7;
  int v8;
  ssize_t v10;
  uint64_t result;
  NSObject *v12;
  _QWORD v13[2];
  int v14;
  int v15;
  uint8_t buf[4];
  int v17;
  __int16 v18;
  int v19;

  v13[1] = 0x800000000000000;
  v13[0] = 897;
  v14 = a2;
  v15 = (unsigned __int16)a1;
  if (dword_10008BA20)
  {
    v3 = a1;
    v4 = ne_log_obj(a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109376;
      v17 = v3;
      v18 = 1024;
      v19 = a2;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "sending vpn_control status (peer response) message - code=%d  addr=%x.\n", buf, 0xEu);
    }
  }
  v5 = *(uint64_t **)(qword_10008B848 + 64);
  if (!v5)
    return 0xFFFFFFFFLL;
  v6 = 0xFFFFFFFFLL;
  do
  {
    v7 = v5 + 6;
    while (1)
    {
      v7 = (uint64_t *)*v7;
      if (!v7)
        break;
      v8 = *((_DWORD *)v7 + 4);
      if (v8 == -1 || v8 == a2)
      {
        v10 = send(*((_DWORD *)v5 + 4), v13, 0x18uLL, 0);
        result = 0;
        if ((v10 & 0x8000000000000000) == 0)
          goto LABEL_18;
        if (dword_10008BA20)
        {
          v12 = ne_log_obj(0);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
            sub_100066138();
        }
        break;
      }
    }
    result = v6;
LABEL_18:
    v5 = (uint64_t *)*v5;
    v6 = result;
  }
  while (v5);
  return result;
}

uint64_t sub_100049074(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t result;
  int v6;

  if (!a2)
    return 0;
  v3 = *(_QWORD *)(a2 + 272);
  if (!v3 || (*(_BYTE *)(v3 + 280) & 1) == 0)
    return 0;
  v6 = sub_10000AAA8(a2);
  result = sub_100048EE4(a1, v6);
  if ((_DWORD)result)
    return 0xFFFFFFFFLL;
  *(_BYTE *)(*(_QWORD *)(a2 + 272) + 280) &= ~1u;
  return result;
}

uint64_t sub_1000490E8()
{
  uint64_t v0;
  int v1;
  NSObject *v2;
  uint64_t result;
  int v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  int v14;
  NSObject *v15;
  uint64_t v16;
  NSObject *v17;
  NSObject *v18;
  uint64_t v19;
  NSObject *v20;
  NSObject *v21;
  _QWORD handler[4];
  int v23;
  size_t cnt;
  _BYTE fds[24];

  if (!off_1000884E0)
  {
    result = 0;
    *(_DWORD *)(qword_10008B848 + 28) = -1;
    return result;
  }
  cnt = 0;
  *(_QWORD *)fds = 0;
  v0 = launch_activate_socket("Listeners", (int **)fds, &cnt);
  if ((_DWORD)v0)
  {
    if (dword_10008BA20)
    {
      v1 = v0;
      v2 = ne_log_obj(v0);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_1000664B0(v1);
    }
  }
  else if (*(_QWORD *)fds)
  {
    if (cnt)
      v4 = **(_DWORD **)fds;
    else
      v4 = 0;
    free(*(void **)fds);
    *(_DWORD *)(qword_10008B848 + 28) = v4;
    if (v4)
      goto LABEL_29;
    goto LABEL_11;
  }
  *(_DWORD *)(qword_10008B848 + 28) = 0;
LABEL_11:
  unk_10008B272 = 0u;
  xmmword_10008B258 = 0u;
  unk_10008B268 = 0u;
  xmmword_10008B238 = 0u;
  unk_10008B248 = 0u;
  xmmword_10008B218 = 0u;
  unk_10008B228 = 0u;
  BYTE1(xmmword_10008B218) = 1;
  snprintf((char *)&xmmword_10008B218 + 2, 0x68uLL, "%s", off_1000884E0);
  v5 = socket(1, 1, 0);
  *(_DWORD *)(qword_10008B848 + 28) = v5;
  if ((_DWORD)v5 == -1)
  {
    if (dword_10008BA20)
    {
      v10 = ne_log_obj(v5);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_100066184();
    }
    return 0xFFFFFFFFLL;
  }
  v6 = fcntl(v5, 4, 4);
  if ((_DWORD)v6 == -1)
  {
    if (dword_10008BA20)
    {
      v7 = ne_log_obj(v6);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_100066484();
    }
  }
  unlink((const char *)&xmmword_10008B218 + 2);
  v8 = bind(*(_DWORD *)(qword_10008B848 + 28), (const sockaddr *)&xmmword_10008B218, 0x6Au);
  if ((_DWORD)v8)
  {
    if (dword_10008BA20)
    {
      v9 = ne_log_obj(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_100066404(v9);
    }
LABEL_42:
    close(*(_DWORD *)(qword_10008B848 + 28));
    return 0xFFFFFFFFLL;
  }
  v11 = chown((const char *)&xmmword_10008B218 + 2, dword_10008C6C8, dword_10008C6CC);
  if ((_DWORD)v11)
  {
    if (dword_10008BA20)
    {
      v12 = ne_log_obj(v11);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        sub_100066344(v12);
    }
    goto LABEL_42;
  }
  v16 = chmod((const char *)&xmmword_10008B218 + 2, word_1000884E8);
  if ((_DWORD)v16)
  {
    if (dword_10008BA20)
    {
      v17 = ne_log_obj(v16);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        sub_10006629C(v17);
    }
    goto LABEL_42;
  }
  v19 = listen(*(_DWORD *)(qword_10008B848 + 28), 5);
  if ((_DWORD)v19)
  {
    if (dword_10008BA20)
    {
      v20 = ne_log_obj(v19);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        sub_10006621C(v20);
    }
    goto LABEL_42;
  }
  if (dword_10008BA20)
  {
    v21 = ne_log_obj(v19);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)fds = 136315138;
      *(_QWORD *)&fds[4] = (char *)&xmmword_10008B218 + 2;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "opened %s as racoon management.\n", fds, 0xCu);
    }
  }
LABEL_29:
  v13 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, *(int *)(qword_10008B848 + 28), 0, (dispatch_queue_t)&_dispatch_main_q);
  *(_QWORD *)(qword_10008B848 + 40) = v13;
  if (v13)
  {
    dispatch_source_set_event_handler_f(v13, (dispatch_function_t)sub_100047338);
    v14 = *(_DWORD *)(qword_10008B848 + 28);
    v15 = *(NSObject **)(qword_10008B848 + 40);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 0x40000000;
    handler[2] = sub_1000494E4;
    handler[3] = &unk_100086C30;
    v23 = v14;
    dispatch_source_set_cancel_handler(v15, handler);
    dispatch_resume(*(dispatch_object_t *)(qword_10008B848 + 40));
    return 0;
  }
  if (dword_10008BA20)
  {
    v18 = ne_log_obj(0);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      sub_1000661F0();
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_1000494E4(uint64_t a1)
{
  return close(*(_DWORD *)(a1 + 32));
}

uint64_t *sub_1000494EC(uint64_t a1)
{
  NSObject *v1;
  uint64_t v2;
  uint64_t *result;
  uint64_t v4;
  uint8_t v5[16];

  if (dword_10008BA20)
  {
    v1 = ne_log_obj(a1);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "vpncontrol_close.\n", v5, 2u);
    }
  }
  dispatch_source_cancel(*(dispatch_source_t *)(qword_10008B848 + 40));
  v2 = qword_10008B848;
  *(_QWORD *)(qword_10008B848 + 40) = 0;
  *(_DWORD *)(v2 + 28) = -1;
  result = *(uint64_t **)(v2 + 64);
  if (result)
  {
    do
    {
      v4 = *result;
      sub_1000483D0(result);
      result = (uint64_t *)v4;
    }
    while (v4);
  }
  return result;
}

BOOL sub_100049594()
{
  return *(_QWORD *)(qword_10008B848 + 64) != 0;
}

void sub_1000495B0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x16u);
}

uint64_t sub_100049668(uint64_t a1, int a2)
{
  _DWORD *v4;
  _DWORD *v5;
  uint64_t v6;
  _DWORD *v7;
  uint64_t v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  NSObject *v11;
  uint64_t v12;
  NSObject *v13;
  sockaddr *v14;
  _OWORD *v15;
  int v16;
  sockaddr *v17;
  int sa_family;
  unsigned int v19;
  _WORD *v20;
  NSObject *v21;
  _BOOL8 v22;
  NSObject *v23;
  char *v24;
  NSObject *v25;
  NSObject *v26;
  NSObject *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v35;
  char *v36;

  v4 = malloc_type_calloc(1uLL, 0x80uLL, 0x1000040AE2C30F4uLL);
  if (!v4)
    return 0xFFFFFFFFLL;
  v5 = v4;
  *v4 = 32768528;
  v6 = a1 + 16;
  v4[1] = *(_DWORD *)(a1 + 16);
  v7 = sub_100038594((uint64_t)v4);
  if (!v7)
  {
    if (dword_10008BA20)
    {
      v13 = ne_log_obj(0);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        sub_10006651C((const sockaddr *)v5);
    }
    goto LABEL_12;
  }
  v8 = (uint64_t)v7;
  v9 = (unsigned __int8 *)*((_QWORD *)v7 + 37);
  if (v9)
  {
    v10 = (unsigned __int8 *)sub_10003C6F8(v9);
    if (!v10)
    {
      if (dword_10008BA20)
      {
        v11 = ne_log_obj(0);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          sub_100066648();
      }
LABEL_12:
      v12 = 0xFFFFFFFFLL;
      v14 = (sockaddr *)v5;
LABEL_38:
      free(v14);
      return v12;
    }
  }
  else
  {
    v10 = (unsigned __int8 *)sub_10003B74C((const sockaddr *)v5);
    if (!v10)
    {
      if (dword_10008BA20)
      {
        v26 = ne_log_obj(0);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
          sub_100066588();
      }
      goto LABEL_12;
    }
  }
  v16 = *(_DWORD *)(a1 + 20);
  v15 = (_OWORD *)(a1 + 20);
  if (v16)
  {
    *((_OWORD *)v5 + 7) = 0u;
    *(_OWORD *)(v5 + 25) = 0u;
    *(_OWORD *)(v5 + 21) = 0u;
    *(_OWORD *)(v5 + 17) = 0u;
    *(_OWORD *)(v5 + 13) = 0u;
    *(_OWORD *)(v5 + 9) = 0u;
    *(_OWORD *)(v5 + 5) = 0u;
    *(_OWORD *)(v5 + 1) = 0u;
    *v5 = 32775708;
    nw_nat64_synthesize_v6(v15, v6, v5 + 2);
  }
  v17 = (sockaddr *)sub_10003C6F8((unsigned __int8 *)v5);
  v14 = v17;
  if (!v17)
  {
    if (dword_10008BA20)
    {
      v25 = ne_log_obj(0);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        sub_1000665B4();
    }
    goto LABEL_36;
  }
  sa_family = v17->sa_family;
  if (sa_family != 30 && sa_family != 2)
  {
    if (dword_10008BA20)
    {
      v27 = ne_log_obj(v17);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        sub_1000665E0((uint64_t)&v14->sa_family, v27, v28, v29, v30, v31, v32, v33);
    }
    goto LABEL_36;
  }
  *(_WORD *)v17->sa_data = *(_WORD *)(*(_QWORD *)v8 + 2);
  v19 = sub_1000078AC((unint64_t)v10);
  v20 = sub_10003D350((uint64_t)v10, __rev16(v19));
  if (!v20)
  {
LABEL_36:
    v12 = 0xFFFFFFFFLL;
    goto LABEL_37;
  }
  if (dword_10008BA20)
  {
    v21 = ne_log_obj(v20);
    v22 = os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT);
    if (v22)
    {
      v35 = 136315138;
      v36 = sub_10003C8A0(v14);
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "accept a request to establish IKE-SA: %s\n", (uint8_t *)&v35, 0xCu);
    }
    if (dword_10008BA20)
    {
      v23 = ne_log_obj(v22);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        v24 = sub_10003C8A0(v14);
        v35 = 136315138;
        v36 = v24;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "IPSec connecting to server %s\n", (uint8_t *)&v35, 0xCu);
      }
    }
  }
  v12 = ((int)sub_1000221FC(0, v8, &v14->sa_len, v10, a2, v15) >> 31);
LABEL_37:
  free(v5);
  free(v10);
  if (v14)
    goto LABEL_38;
  return v12;
}

uint64_t sub_1000499E0(uint64_t a1, uint64_t a2)
{
  int v3;
  NSObject *v4;
  int v6;
  char *v7;
  _DWORD v8[2];
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;

  v16 = 0;
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  v10 = 0u;
  v11 = 0u;
  v9 = 0u;
  v3 = *(_DWORD *)(a1 + 16);
  v8[0] = 528;
  v8[1] = v3;
  if (dword_10008BA20)
  {
    v4 = ne_log_obj(a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v6 = 136315138;
      v7 = sub_10003C8A0((const sockaddr *)v8);
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "IPSec disconnecting from server %s\n", (uint8_t *)&v6, 0xCu);
    }
  }
  sub_10004CD34((unint64_t)v8, 0, a2);
  if ((int)sub_10000A01C((unint64_t)v8) >= 1)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

uint64_t sub_100049AD4(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  unsigned int v11;
  unint64_t v12;
  NSObject *v13;
  NSObject *v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  size_t v19;
  _QWORD *v20;
  size_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  char v25;
  __int16 v26;
  uint64_t v27;
  int v28;
  char v29;
  int v30;
  NSObject *v31;
  int *v32;
  NSObject *v33;
  unsigned int v34;
  unsigned __int16 *v35;
  _DWORD *v36;
  _DWORD *v37;
  uint64_t v38;
  unsigned int v39;
  uint64_t v40;
  unsigned int v41;
  unsigned int v42;
  unsigned int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  _QWORD *v48;
  uint64_t result;
  NSObject *v50;
  NSObject *v51;
  uint64_t v52;
  int v53;
  uint64_t v54;
  NSObject *v55;
  NSObject *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  NSObject *v63;
  NSObject *v64;
  NSObject *v65;
  NSObject *v66;
  NSObject *v67;
  NSObject *v68;
  NSObject *v69;
  NSObject *v70;
  NSObject *v71;
  _QWORD *v72;
  _QWORD *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  int v77;
  uint64_t v78;
  uint64_t v79;
  _DWORD v80[2];
  uint64_t v81;
  uint8_t v82[4];
  _DWORD v83[3];
  uint8_t v84[4];
  int v85;

  v5 = a1;
  v81 = 0;
  v6 = *(_DWORD *)(a1 + 16);
  v80[0] = 528;
  v80[1] = v6;
  v7 = sub_100008330(0, (unint64_t)v80);
  if (v7)
  {
    v8 = v7;
    if ((*(_BYTE *)(v7 + 17) & 0x20) != 0)
    {
      v11 = __rev16(*(unsigned __int16 *)(a2 + 26));
      v12 = 24 * v11 + 32;
      if (v12 <= a3)
      {
        if (v12 + 8 * (bswap32(*(unsigned __int16 *)(a2 + 28)) >> 16) <= a3)
        {
          if (!*(_WORD *)(a2 + 26))
            return 0;
          v15 = 0;
          v16 = a2 + 32;
          v74 = v7;
          v75 = a2 + 32 + 24 * v11;
          v72 = (_QWORD *)(v7 + 64);
          v73 = (_QWORD *)(v7 + 72);
          v78 = v5;
          while (1)
          {
            sub_10003A090();
            if (!v17)
              break;
            v18 = v17;
            if (*(_DWORD *)(v16 + 4) == -1)
              v19 = 8;
            else
              v19 = 12;
            v20 = sub_10003F1F8(v19);
            *(_QWORD *)v18 = v20;
            if (!v20)
            {
              if (dword_10008BA20)
              {
                v65 = ne_log_obj(0);
                if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
LABEL_99:
                  sub_1000667C0();
              }
LABEL_91:
              sub_10003A2CC((_QWORD *)v18);
              goto LABEL_92;
            }
            if (*(_DWORD *)(v16 + 12) == -1)
              v21 = 8;
            else
              v21 = 12;
            v22 = (uint64_t)sub_10003F1F8(v21);
            *(_QWORD *)(v18 + 8) = v22;
            if (!v22)
            {
              if (dword_10008BA20)
              {
                v66 = ne_log_obj(0);
                if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
                  goto LABEL_99;
              }
              goto LABEL_91;
            }
            v23 = *(_QWORD *)(*(_QWORD *)v18 + 8);
            v24 = *(_DWORD *)(v16 + 4);
            if (v24 == -1)
            {
              v25 = 1;
            }
            else
            {
              *(_DWORD *)(v23 + 8) = v24;
              v25 = 4;
            }
            *(_BYTE *)v23 = v25;
            *(_DWORD *)(v23 + 4) = *(_DWORD *)v16;
            *(_WORD *)(v23 + 2) = *(_WORD *)(v16 + 16);
            v26 = *(_WORD *)(v16 + 20);
            *(_BYTE *)(v23 + 1) = v26;
            v27 = *(_QWORD *)(v22 + 8);
            v28 = *(_DWORD *)(v16 + 12);
            if (v28 == -1)
            {
              v29 = 1;
            }
            else
            {
              *(_DWORD *)(v27 + 8) = v28;
              v29 = 4;
            }
            *(_BYTE *)v27 = v29;
            *(_DWORD *)(v27 + 4) = *(_DWORD *)(v16 + 8);
            *(_WORD *)(v27 + 2) = *(_WORD *)(v16 + 18);
            *(_BYTE *)(v27 + 1) = v26;
            *(_DWORD *)(v18 + 104) = *(_DWORD *)(v5 + 16);
            *(_QWORD *)(v18 + 24) = bswap32(*(_DWORD *)(a2 + 20));
            v77 = v15;
            if (*(_WORD *)(a2 + 24))
            {
              v22 = sub_1000048CC(5, __rev16(*(unsigned __int16 *)(a2 + 24)));
              *(_DWORD *)(v18 + 36) = v22;
              if ((_DWORD)v22 == -1)
              {
                if (dword_10008BA20)
                {
                  v67 = ne_log_obj(v22);
                  if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
                    sub_100066B68();
                }
                goto LABEL_91;
              }
            }
            else
            {
              v30 = *(_DWORD *)(*(_QWORD *)(v8 + 408) + 1140);
              if (v30)
              {
                if (*(_BYTE *)(v8 + 81) == 4)
                {
                  if (dword_10008BA20)
                  {
                    v31 = ne_log_obj(v22);
                    v22 = os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG);
                    if ((_DWORD)v22)
                      sub_100066AE0(v84, (uint64_t)v72, &v85, v31);
                  }
                  v32 = (int *)(*v72 + 188);
                }
                else
                {
                  if (dword_10008BA20)
                  {
                    v33 = ne_log_obj(v22);
                    v22 = os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG);
                    if ((_DWORD)v22)
                      sub_100066B24(v82, (uint64_t)v73, v83, v33);
                  }
                  v32 = (int *)(*v73 + 60);
                }
                v30 = *v32;
              }
              *(_DWORD *)(v18 + 36) = v30;
            }
            v76 = v16;
            if (*(_WORD *)(a2 + 28))
            {
              v34 = 0;
              v35 = (unsigned __int16 *)v75;
              v79 = v18;
              while (1)
              {
                v36 = sub_10003A314();
                if (!v36)
                  break;
                v37 = v36;
                v38 = a2;
                v39 = *v35;
                v40 = __rev16(v39);
                v41 = v35[1];
                v42 = __rev16(v41);
                v43 = v35[2];
                v44 = sub_1000048CC(v40, v42);
                *v37 = v44;
                if ((_DWORD)v44 == -1)
                {
                  if (dword_10008BA20)
                  {
                    v51 = ne_log_obj(v44);
                    if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
                      sub_1000669B8();
                  }
                  free(v37);
                  v5 = v78;
                  goto LABEL_91;
                }
                v45 = sub_1000046F4(v40, v42);
                LODWORD(v46) = v45;
                if ((_DWORD)v45)
                {
                  if (v43)
                  {
                    v46 = __rev16(v43);
                    v47 = sub_100004724(v40, v42, v46);
                    if ((v47 & 0x80000000) != 0)
                    {
                      if (dword_10008BA20)
                      {
                        v56 = ne_log_obj(v47);
                        if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
                          sub_100066A7C(v46, v56, v57, v58, v59, v60, v61, v62);
                      }
LABEL_90:
                      free(v37);
                      v5 = v78;
                      v18 = v79;
                      goto LABEL_91;
                    }
                  }
                }
                else if (v43)
                {
                  if (dword_10008BA20)
                  {
                    v63 = ne_log_obj(v45);
                    if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
                      sub_100066A50();
                  }
                  goto LABEL_90;
                }
                v37[1] = v46;
                if ((v39 != 256 || v41 != 4608) && sub_100030B9C(v40, v42, v46))
                {
                  v52 = sub_100004A34(v40);
                  if ((_DWORD)v52 == 5)
                    v53 = 2;
                  else
                    v53 = v52;
                  if (dword_10008BA20)
                  {
                    v54 = *v37;
                    v55 = ne_log_obj(v52);
                    if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
                      sub_1000669E4(v53, v54);
                  }
                  goto LABEL_90;
                }
                v18 = v79;
                v22 = (uint64_t)sub_10003A330((uint64_t *)(v79 + 8 * v40 + 48), (uint64_t)v37);
                ++v34;
                a2 = v38;
                v35 += 4;
                if (v34 >= bswap32(*(unsigned __int16 *)(v38 + 28)) >> 16)
                  goto LABEL_62;
              }
              v5 = v78;
              if (dword_10008BA20)
              {
                v50 = ne_log_obj(0);
                if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
                  sub_10006698C();
              }
              goto LABEL_91;
            }
LABEL_62:
            if (!*(_QWORD *)(v18 + 48))
            {
              v5 = v78;
              if (dword_10008BA20)
              {
                v68 = ne_log_obj(v22);
                if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
                  sub_1000667EC((uint64_t *)v18);
              }
              goto LABEL_91;
            }
            v5 = v78;
            if (!*(_QWORD *)(v18 + 56))
            {
              if (dword_10008BA20)
              {
                v69 = ne_log_obj(v22);
                if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
                  sub_100066854((uint64_t *)v18);
              }
              goto LABEL_91;
            }
            if (!*(_QWORD *)(v18 + 64))
            {
              if (dword_10008BA20)
              {
                v70 = ne_log_obj(v22);
                if (os_log_type_enabled(v70, OS_LOG_TYPE_ERROR))
                  sub_1000668BC((uint64_t *)v18);
              }
              goto LABEL_91;
            }
            v48 = (_QWORD *)sub_100039CAC(*(_QWORD *)v18, *(_QWORD *)(v18 + 8), *(_QWORD *)(v18 + 40), 0);
            if (v48 && !*v48 && !*(_QWORD *)v18)
            {
              if (dword_10008BA20)
              {
                v71 = ne_log_obj(v48);
                if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
                  sub_100066924((uint64_t *)v18);
              }
              goto LABEL_91;
            }
            sub_10003A180(v18);
            result = 0;
            v15 = v77 + 1;
            v16 = v76 + 24;
            v8 = v74;
            if (v77 + 1 >= bswap32(*(unsigned __int16 *)(a2 + 26)) >> 16)
              return result;
          }
          if (dword_10008BA20)
          {
            v64 = ne_log_obj(0);
            if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
              sub_100066794();
          }
LABEL_92:
          sub_10003A248(*(_DWORD *)(v5 + 16));
        }
        else if (dword_10008BA20)
        {
          v14 = ne_log_obj(v7);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
            sub_100066730();
        }
      }
      else if (dword_10008BA20)
      {
        v13 = ne_log_obj(v7);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
          sub_1000666CC();
      }
    }
    else if (dword_10008BA20)
    {
      v9 = ne_log_obj(v7);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_1000666A0();
    }
  }
  else if (dword_10008BA20)
  {
    v10 = ne_log_obj(0);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      sub_100066674();
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_10004A2A0(uint64_t a1, _QWORD *a2, size_t *a3)
{
  uint64_t *v6;
  uint64_t *v7;
  size_t v8;
  _WORD *v9;
  _WORD *v10;
  uint64_t v11;
  unsigned __int16 v12;
  _QWORD *v13;
  size_t v14;
  void *v15;
  NSObject *v16;
  _BOOL4 v17;
  uint64_t result;
  NSObject *v19;
  NSObject *v20;
  uint8_t v21[16];

  *a2 = 0;
  if (!*(_QWORD *)(*(_QWORD *)(a1 + 408) + 1192))
    return 1;
  v6 = sub_100006F50(*(const sockaddr **)(a1 + 56), 0);
  if (!v6)
  {
    if (dword_10008BA20)
    {
      v19 = ne_log_obj(0);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        sub_100066B94();
    }
    return 0xFFFFFFFFLL;
  }
  v7 = v6;
  v8 = (unsigned __int16)(**(_WORD **)(*(_QWORD *)(a1 + 408) + 1192) + 44);
  v9 = malloc_type_calloc(1uLL, v8, 0x464777ADuLL);
  *a2 = v9;
  if (!v9)
  {
    if (dword_10008BA20)
    {
      v20 = ne_log_obj(0);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        sub_100066BC0();
    }
    return 0xFFFFFFFFLL;
  }
  v10 = v9;
  v9[1] = 256;
  v11 = *(_QWORD *)(a1 + 56);
  if (*(_BYTE *)(v11 + 1) == 2)
    *((_DWORD *)v9 + 5) = *(_DWORD *)(v11 + 4);
  *((_DWORD *)v9 + 6) = 0;
  v12 = strlen((const char *)v7[5]);
  *(_QWORD *)(v10 + 14) = 0;
  v13 = v10 + 14;
  v13[1] = 0;
  if (v12 >= 0xFu)
    v14 = 15;
  else
    v14 = v12;
  memcpy(v13, (const void *)v7[5], v14);
  v15 = memcpy(v13 + 2, *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 408) + 1192) + 8), **(_QWORD **)(*(_QWORD *)(a1 + 408) + 1192));
  *a3 = v8;
  if (dword_10008BA20)
  {
    v16 = ne_log_obj(v15);
    v17 = os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v17)
      return result;
    *(_WORD *)v21 = 0;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "IPSec Network Configuration established.\n", v21, 2u);
  }
  return 0;
}

uint64_t sub_10004A464(int a1, _WORD *a2, size_t a3)
{
  uint64_t v5;
  uint64_t v6;
  int i;
  _WORD *v8;
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  NSObject *v12;
  uint64_t v13;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  void *v18;
  NSObject *v19;
  _QWORD *v20;
  uint64_t v21;
  NSObject *v22;
  NSObject *v23;
  uint8_t v24[8];
  _DWORD v25[2];
  uint64_t v26;

  v26 = 0;
  v25[0] = 528;
  v25[1] = a1;
  v5 = sub_100008330(0, (unint64_t)v25);
  if (!v5)
  {
    if (dword_10008BA20)
    {
      v11 = ne_log_obj(0);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        sub_100066BEC();
    }
    return 0xFFFFFFFFLL;
  }
  v6 = v5;
  if (!*(_BYTE *)(v5 + 417))
  {
    if (dword_10008BA20)
    {
      v12 = ne_log_obj(v5);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        sub_100066C18();
    }
    return 0xFFFFFFFFLL;
  }
  i = a3;
  if ((int)a3 >= 1)
  {
    v8 = a2;
    for (i = a3; i > 0; i -= 4)
    {
      if ((*v8 & 0x80) == 0)
      {
        v9 = bswap32((unsigned __int16)v8[1]) >> 16;
        i -= v9;
        v8 = (_WORD *)((char *)v8 + v9);
      }
      v8 += 2;
    }
  }
  if (i)
  {
    if (dword_10008BA20)
    {
      v10 = ne_log_obj(v5);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_100066CA8();
    }
    return 0xFFFFFFFFLL;
  }
  v15 = sub_10003F1F8(a3 + 8);
  if (!v15)
  {
    if (dword_10008BA20)
    {
      v23 = ne_log_obj(0);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        sub_100066C44();
    }
    return 0xFFFFFFFFLL;
  }
  v16 = v15;
  *(_QWORD *)v15[1] = 0;
  v17 = v15[1];
  *(_WORD *)(v17 + 2) = bswap32(*(unsigned __int16 *)v15) >> 16;
  *(_BYTE *)(v17 + 4) = 2;
  *(_WORD *)(v17 + 6) = *(unsigned __int8 *)(v6 + 416);
  *(_BYTE *)(v6 + 417) = 0;
  v18 = memcpy((void *)(v17 + 8), a2, a3);
  if (dword_10008BA20)
  {
    v19 = ne_log_obj(v18);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
      sub_100066C70();
  }
  v13 = sub_100043C98(v6, (uint64_t)v16, 14, 1, 0, 0, *(_QWORD *)(v6 + 424));
  v20 = *(_QWORD **)(v6 + 424);
  if (v20)
  {
    sub_10003F318(v20);
    *(_QWORD *)(v6 + 424) = 0;
  }
  v21 = sub_10004DBD4(v6);
  if (dword_10008BA20)
  {
    v22 = ne_log_obj(v21);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v24 = 0;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "IPSec Extended Authentication sent.\n", v24, 2u);
    }
  }
  sub_10003F318(v16);
  return v13;
}

uint64_t sub_10004A704(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  NSObject *v3;

  result = sub_10004EE44(a1, a2);
  if ((_DWORD)result)
  {
    if (dword_10008BA20)
    {
      v3 = ne_log_obj(result);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        sub_100066CD4();
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t *sub_10004A770(uint64_t *a1)
{
  return sub_10003A350(a1);
}

void sub_10004A778(void *a1@<X0>, const char *a2@<X3>, uint8_t *a3@<X4>, NSObject *a4@<X8>)
{
  _os_log_debug_impl(a1, a4, OS_LOG_TYPE_DEBUG, a2, a3, 8u);
}

void sub_10004A788()
{
  qword_10008C6D0 = 0;
}

uint64_t sub_10004A794(int a1, unsigned int a2)
{
  unsigned int v2;
  int v3;
  BOOL v4;
  unsigned int v5;
  int v6;
  unsigned int v7;

  v2 = a2 / 0xA;
  if (a1)
    v3 = -1;
  else
    v3 = -2;
  v4 = __CFADD__(v3, a2);
  v5 = v3 + a2;
  if (!v4)
    v5 = 0;
  v6 = 8 * v2;
  v7 = 9 * v2;
  if (!a1)
    v7 = v6;
  if (a2 >= 0xA)
    return v7;
  else
    return v5;
}

uint64_t sub_10004A7D4(uint64_t result)
{
  uint64_t v1;
  NSObject *v2;
  int v3;
  uint64_t *v4;

  if (result)
  {
    v1 = result;
    if (dword_10008BA20)
    {
      v2 = ne_log_obj(result);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
        v3 = 136315138;
        v4 = sub_10003C570((const sockaddr *)(v1 + 128));
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "New IKE Session to %s.\n", (uint8_t *)&v3, 0xCu);
      }
    }
    return sub_10004A890((__int128 *)v1);
  }
  return result;
}

uint64_t sub_10004A890(__int128 *a1)
{
  void *v2;
  uint64_t v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;

  if (a1)
  {
    v2 = malloc_type_calloc(1uLL, 0x6C0uLL, 0x10B00402B0E598BuLL);
    v3 = (uint64_t)v2;
    if (v2)
    {
      bzero(v2, 0x6C0uLL);
      v4 = *a1;
      v5 = a1[1];
      v6 = a1[2];
      *(_OWORD *)(v3 + 56) = a1[3];
      *(_OWORD *)(v3 + 40) = v6;
      *(_OWORD *)(v3 + 24) = v5;
      *(_OWORD *)(v3 + 8) = v4;
      v7 = a1[4];
      v8 = a1[5];
      v9 = a1[6];
      *(_OWORD *)(v3 + 120) = a1[7];
      *(_OWORD *)(v3 + 104) = v9;
      *(_OWORD *)(v3 + 88) = v8;
      *(_OWORD *)(v3 + 72) = v7;
      v10 = a1[8];
      v11 = a1[9];
      v12 = a1[10];
      *(_OWORD *)(v3 + 184) = a1[11];
      *(_OWORD *)(v3 + 168) = v12;
      *(_OWORD *)(v3 + 152) = v11;
      *(_OWORD *)(v3 + 136) = v10;
      v13 = a1[12];
      v14 = a1[13];
      v15 = a1[14];
      *(_OWORD *)(v3 + 248) = a1[15];
      *(_OWORD *)(v3 + 232) = v15;
      *(_OWORD *)(v3 + 216) = v14;
      *(_OWORD *)(v3 + 200) = v13;
      *(_OWORD *)(v3 + 1696) = 0u;
      v16 = qword_10008C6D0;
      *(_QWORD *)(v3 + 1712) = qword_10008C6D0;
      if (v16)
        *(_QWORD *)(v16 + 1720) = v3 + 1712;
      qword_10008C6D0 = v3;
      *(_QWORD *)(v3 + 1720) = &qword_10008C6D0;
    }
  }
  else
  {
    if (dword_10008BA20)
    {
      v17 = ne_log_obj(0);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        sub_100066D00(v17, v18, v19, v20, v21, v22, v23, v24);
    }
    return 0;
  }
  return v3;
}

uint64_t sub_10004A9AC(uint64_t a1)
{
  _QWORD *i;
  uint64_t result;

  for (i = *(_QWORD **)(a1 + 1704); i; i = *(_QWORD **)(a1 + 1704))
    sub_10004A9EC(i);
  while (1)
  {
    result = *(_QWORD *)(a1 + 1696);
    if (!result)
      break;
    sub_10004AACC(result);
  }
  return result;
}

uint64_t sub_10004A9EC(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  if (a1 && a1[34])
  {
    sub_10003A744((uint64_t)a1);
    if (a1[32])
    {
      a1[32] = 0;
      v2 = a1[39];
      if (v2)
        *(_QWORD *)(v2 + 320) = a1[40];
      *(_QWORD *)a1[40] = v2;
    }
    v3 = a1[37];
    if (v3)
      *(_QWORD *)(v3 + 304) = a1[38];
    *(_QWORD *)a1[38] = v3;
    v4 = a1[34];
    a1[34] = 0;
    v5 = *(_DWORD *)(v4 + 360) - 1;
    *(_DWORD *)(v4 + 360) = v5;
    if (!(*(_DWORD *)(v4 + 352) | v5))
    {
      *(_BYTE *)(v4 + 280) |= 2u;
      sub_10004B884((unsigned int *)v4);
    }
    sub_100008F90(a1);
    return 0;
  }
  else
  {
    if (dword_10008BA20)
    {
      v7 = ne_log_obj(a1);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_100066D70(v7, v8, v9, v10, v11, v12, v13, v14);
    }
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_10004AACC(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  if (a1 && *(_QWORD *)(a1 + 440))
  {
    if (*(_BYTE *)(a1 + 80) == 16 && *(_QWORD *)(a1 + 448))
      sub_10004B64C(a1);
    sub_10003A744(a1);
    v2 = *(_QWORD *)(a1 + 440);
    v3 = *(_QWORD *)(a1 + 456);
    if (v3)
      *(_QWORD *)(v3 + 464) = *(_QWORD *)(a1 + 464);
    **(_QWORD **)(a1 + 464) = v3;
    *(_QWORD *)(a1 + 440) = 0;
    v4 = *(_DWORD *)(v2 + 352) - 1;
    *(_DWORD *)(v2 + 352) = v4;
    if (!v4 && !*(_DWORD *)(v2 + 360))
    {
      *(_BYTE *)(v2 + 280) |= 2u;
      sub_10004B884((unsigned int *)v2);
    }
    sub_10000849C(a1);
    return 0;
  }
  else
  {
    if (dword_10008BA20)
    {
      v6 = ne_log_obj(a1);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        sub_100066DE0(v6, v7, v8, v9, v10, v11, v12, v13);
    }
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_10004ABA4(uint64_t a1, uint64_t a2, int a3, _QWORD *a4)
{
  int v8;
  int v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  sockaddr v18;
  int v19;
  sockaddr v20;
  uint64_t v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  NSObject *v26;
  NSObject *v27;
  uint64_t *v28;
  int v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  NSObject *v33;
  NSObject *v34;
  NSObject *v36;
  NSObject *v37;
  NSObject *v38;
  uint8_t buf[4];
  uint64_t *v40;
  __int16 v41;
  int v42;
  __int16 v43;
  int v44;
  uint8_t v45[4];
  uint64_t *v46;
  _OWORD v47[8];
  _OWORD v48[8];
  _OWORD v49[8];
  _OWORD v50[8];
  _OWORD v51[8];
  _OWORD v52[8];
  sockaddr __s2[16];

  if (!a1 || !a2)
  {
    if (dword_10008BA20)
    {
      v10 = ne_log_obj(a1);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        sub_100067138(v10, v11, v12, v13, v14, v15, v16, v17);
    }
    return 0;
  }
  v8 = sub_10003D25C(a2);
  memset(__s2, 0, sizeof(__s2));
  memset(v51, 0, sizeof(v51));
  memset(v52, 0, sizeof(v52));
  memset(v50, 0, sizeof(v50));
  memset(v49, 0, sizeof(v49));
  memset(v47, 0, sizeof(v47));
  memset(v48, 0, sizeof(v48));
  v9 = *(unsigned __int8 *)(a1 + 1);
  if (v9 == 30)
  {
    __s2[0] = *(sockaddr *)a1;
    v18 = __s2[0];
    *(sockaddr *)&__s2[0].sa_data[10] = *(sockaddr *)(a1 + 12);
    v51[0] = v18;
    *(sockaddr *)((char *)v51 + 12) = *(sockaddr *)&__s2[0].sa_data[10];
    v49[0] = v18;
    *(sockaddr *)((char *)v49 + 12) = *(sockaddr *)&__s2[0].sa_data[10];
    v47[0] = v18;
    *(sockaddr *)((char *)v47 + 12) = *(sockaddr *)&__s2[0].sa_data[10];
  }
  else if (v9 == 2)
  {
    __s2[0] = *(sockaddr *)a1;
    v51[0] = __s2[0];
    v49[0] = __s2[0];
    v47[0] = __s2[0];
  }
  sub_10003D350((uint64_t)v51, 0x1F4u);
  sub_10003D350((uint64_t)v49, 0x1194u);
  sub_10003D350((uint64_t)v47, 0);
  v19 = *(unsigned __int8 *)(a2 + 1);
  if (v19 == 30)
  {
    __s2[8] = *(sockaddr *)a2;
    v20 = __s2[8];
    *(sockaddr *)&__s2[8].sa_data[10] = *(sockaddr *)(a2 + 12);
    v52[0] = v20;
    *(sockaddr *)((char *)v52 + 12) = *(sockaddr *)&__s2[8].sa_data[10];
    v50[0] = v20;
    *(sockaddr *)((char *)v50 + 12) = *(sockaddr *)&__s2[8].sa_data[10];
    v48[0] = v20;
    *(sockaddr *)((char *)v48 + 12) = *(sockaddr *)&__s2[8].sa_data[10];
  }
  else if (v19 == 2)
  {
    __s2[8] = *(sockaddr *)a2;
    v52[0] = __s2[8];
    v50[0] = __s2[8];
    v48[0] = __s2[8];
  }
  sub_10003D350((uint64_t)v52, 0x1F4u);
  sub_10003D350((uint64_t)v50, 0x1194u);
  v21 = (uint64_t)sub_10003D350((uint64_t)v48, 0);
  if (dword_10008BA20)
  {
    v22 = ne_log_obj(v21);
    v21 = os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG);
    if ((_DWORD)v21)
      sub_1000670D0((const sockaddr *)a2);
  }
  v23 = qword_10008C6D0;
  if (!qword_10008C6D0)
  {
LABEL_50:
    if (a3)
    {
      if (dword_10008BA20)
      {
        v34 = ne_log_obj(v21);
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
          sub_100066E50(__s2);
      }
      return sub_10004A890((__int128 *)__s2);
    }
    return 0;
  }
  v24 = 0;
  do
  {
    v25 = v24;
    if (dword_10008BA20)
    {
      v26 = ne_log_obj(v21);
      v21 = os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)v21)
        sub_100067068(v45, v23, &v46, v26);
    }
    if ((*(_BYTE *)(v23 + 280) & 2) != 0
      || (*(_WORD *)(v23 + 264) & 0x20) != 0
      || *(_QWORD *)(v23 + 336)
      || *(_DWORD *)(v23 + 344))
    {
      if (dword_10008BA20)
      {
        v27 = ne_log_obj(v21);
        v21 = os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG);
        if ((_DWORD)v21)
        {
          v28 = sub_10003C570((const sockaddr *)(v23 + 136));
          v29 = *(_DWORD *)(v23 + 352);
          v30 = *(_DWORD *)(v23 + 360);
          *(_DWORD *)buf = 136315650;
          v40 = v28;
          v41 = 1024;
          v42 = v29;
          v43 = 1024;
          v44 = v30;
          _os_log_debug_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEBUG, "still searching. skipping... session to %s is already stopped, active ph1 %d ph2 %d.\n", buf, 0x18u);
        }
      }
LABEL_29:
      v24 = v25;
      goto LABEL_30;
    }
    if (a4)
    {
      v21 = sub_100007EB0(v23, a4);
      if (!v21)
        goto LABEL_29;
    }
    v21 = memcmp((const void *)(v23 + 8), __s2, 0x100uLL);
    if (!(_DWORD)v21)
    {
      if (dword_10008BA20)
      {
        v36 = ne_log_obj(v21);
        if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
          sub_100066EC0((const sockaddr *)a2);
      }
      return v23;
    }
    if (v8 && v8 != 4500 && v8 != 500)
      goto LABEL_42;
    v31 = memcmp((const void *)(v23 + 8), v51, 0x100uLL);
    if (!(_DWORD)v31)
    {
      if (dword_10008BA20)
      {
        v37 = ne_log_obj(v31);
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
          sub_100066F98((const sockaddr *)a2);
      }
      return v23;
    }
    if ((*(_WORD *)(v23 + 264) & 2) != 0)
    {
      v32 = memcmp((const void *)(v23 + 8), v49, 0x100uLL);
      if (!(_DWORD)v32)
      {
        if (dword_10008BA20)
        {
          v38 = ne_log_obj(v32);
          if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
            sub_100067000((const sockaddr *)a2);
        }
        return v23;
      }
    }
    v21 = memcmp((const void *)(v23 + 8), v47, 0x100uLL);
    v24 = v23;
    if ((_DWORD)v21)
    {
LABEL_42:
      if (a4)
        v24 = v23;
      else
        v24 = v25;
    }
LABEL_30:
    v23 = *(_QWORD *)(v23 + 1712);
  }
  while (v23);
  if (!v24)
    goto LABEL_50;
  if (dword_10008BA20)
  {
    v33 = ne_log_obj(v21);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
      sub_100066F28(v24);
  }
  return v24;
}

uint64_t sub_10004B0F8(uint64_t result)
{
  _DWORD *v1;
  int v2;
  _DWORD *v3;
  int v4;
  int v5;
  int v6;
  unsigned int v7;
  int v8;
  int v9;

  if (result)
  {
    v1 = *(_DWORD **)(result + 64);
    if (v1)
    {
      v2 = v1[57];
      if (v2 || v1[54])
      {
        v3 = *(_DWORD **)(result + 440);
        if (!v3[93])
          v3[93] = v2;
        if (!v3[94])
          v3[94] = v1[58];
        if (!v3[92])
        {
          v4 = v1[54];
          if (v4 && (v1[56] - 1) <= 1)
          {
            if (v4 <= v2)
              v5 = v2;
            else
              v5 = v1[54];
            if (v4 >= v2)
              v6 = v2;
            else
              v6 = v4;
            if (v2)
            {
              v2 = v6;
            }
            else
            {
              v2 = v6;
              if ((v4 & 0x80000000) == 0)
              {
                v7 = v5 / 0x14u;
                if (v5 < 6)
                  v8 = 1;
                else
                  v8 = 3;
                if (v5 <= 59)
                  v7 = v8;
LABEL_33:
                v3[92] = v7;
                return result;
              }
            }
          }
          else if (!v2)
          {
            return result;
          }
          if (v2 < 6)
            v9 = 1;
          else
            v9 = 3;
          if (v2 <= 59)
            v7 = v9;
          else
            v7 = v2 / 0x14u;
          goto LABEL_33;
        }
      }
    }
  }
  return result;
}

uint64_t sub_10004B1D0(uint64_t result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  __int16 v6;

  if (result)
  {
    v1 = (_QWORD *)result;
    v2 = *(_QWORD *)(result + 272);
    if (v2)
    {
      if (!*(_DWORD *)(result + 48) && (*(_WORD *)(v2 + 264) & 4) == 0)
      {
        v3 = *(_QWORD *)(result + 128);
        if (v3)
        {
          result = sub_10000F5BC(v3);
          if ((_DWORD)result)
          {
            v4 = v1[16];
LABEL_11:
            result = sub_10000F5FC(v4);
            if (!(_DWORD)result)
              return result;
            *(_WORD *)(v1[34] + 264) &= ~4u;
            *(_WORD *)(v1[34] + 264) |= 8u;
            v5 = v1[34];
            v6 = *(_WORD *)(v5 + 264) & 0xFFEF;
            goto LABEL_14;
          }
        }
        else
        {
          result = v1[15];
          if (!result)
            return result;
          result = sub_10000F5BC(result);
          if ((_DWORD)result)
          {
            v4 = v1[15];
            goto LABEL_11;
          }
        }
        *(_WORD *)(v1[34] + 264) &= ~4u;
        *(_WORD *)(v1[34] + 264) &= ~8u;
        v5 = v1[34];
        v6 = *(_WORD *)(v5 + 264) | 0x10;
LABEL_14:
        *(_WORD *)(v5 + 264) = v6;
      }
    }
  }
  return result;
}

uint64_t sub_10004B29C(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  __int16 v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  if (a1 && a2)
  {
    gettimeofday((timeval *)(a1 + 304), 0);
    if (*(_DWORD *)(a2 + 24))
      *(_WORD *)(a1 + 264) = *(_WORD *)(a1 + 264) & 0xFFE3 | 4;
    *(_QWORD *)(a2 + 440) = a1;
    v4 = *(_QWORD *)(a1 + 1696);
    *(_QWORD *)(a2 + 456) = v4;
    if (v4)
      *(_QWORD *)(v4 + 464) = a2 + 456;
    *(_QWORD *)(a1 + 1696) = a2;
    *(_QWORD *)(a2 + 464) = a1 + 1696;
    ++*(_DWORD *)(a1 + 352);
    v5 = *(_DWORD *)(a1 + 356);
    if ((v5 || *(_DWORD *)(a2 + 20)) && !*(_DWORD *)(a2 + 24))
    {
      v6 = *(_WORD *)(a1 + 264);
      if (!v5)
      {
LABEL_20:
        *(_DWORD *)(a1 + 356) = v5 + 1;
        sub_10004B0F8(a2);
        return 0;
      }
    }
    else
    {
      v6 = *(_WORD *)(a1 + 264) | 0x400;
      *(_WORD *)(a1 + 264) = v6;
      if (!v5)
        goto LABEL_20;
    }
    if ((v6 & 1) != 0 && *(_BYTE *)(a2 + 80) == 16)
    {
      *(_BYTE *)(a2 + 432) |= 1u;
      v5 = *(_DWORD *)(a1 + 356);
    }
    goto LABEL_20;
  }
  if (dword_10008BA20)
  {
    v7 = ne_log_obj(a1);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      sub_1000671A8(v7, v8, v9, v10, v11, v12, v13, v14);
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_10004B3B8(uint64_t a1, uint64_t a2)
{
  BOOL v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  if (a2)
  {
    if (*(_QWORD *)(a2 + 272))
      v4 = dword_10008BA20 == 0;
    else
      v4 = 1;
    if (!v4)
    {
      v5 = ne_log_obj(a1);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        sub_100067288(v5, v6, v7, v8, v9, v10, v11, v12);
    }
    *(_QWORD *)(a2 + 272) = a1;
    v13 = *(_QWORD *)(a1 + 1704);
    *(_QWORD *)(a2 + 296) = v13;
    if (v13)
      *(_QWORD *)(v13 + 304) = a2 + 296;
    *(_QWORD *)(a1 + 1704) = a2;
    *(_QWORD *)(a2 + 304) = a1 + 1704;
    ++*(_DWORD *)(a1 + 360);
    v14 = *(_DWORD *)(a1 + 364);
    if (!v14 && !*(_BYTE *)(a2 + 60))
      *(_WORD *)(a1 + 264) |= 0x400u;
    if (!*(_DWORD *)(a2 + 48) && v14 && (*(_WORD *)(a1 + 264) & 1) != 0 && *(_BYTE *)(a2 + 61) == 16)
    {
      *(_BYTE *)(a2 + 264) |= 1u;
      v14 = *(_DWORD *)(a1 + 364);
    }
    *(_DWORD *)(a1 + 364) = v14 + 1;
    sub_10004B1D0(a2);
    return 0;
  }
  else
  {
    if (dword_10008BA20)
    {
      v16 = ne_log_obj(a1);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        sub_100067218(v16, v17, v18, v19, v20, v21, v22, v23);
    }
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_10004B4EC(uint64_t a1, _QWORD *a2)
{
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  if (!a2)
  {
    if (dword_10008BA20)
    {
      v13 = ne_log_obj(a1);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        sub_1000672F8(v13, v14, v15, v16, v17, v18, v19, v20);
    }
    return 0xFFFFFFFFLL;
  }
  if (!a2[32])
  {
    if (a2[34] || !sub_10004B3B8(*(_QWORD *)(a1 + 440), (uint64_t)a2))
    {
      sub_10004B5C4(a1, a2);
      return 0;
    }
    return 0xFFFFFFFFLL;
  }
  if (dword_10008BA20)
  {
    v4 = ne_log_obj(a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      sub_100067368(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  if (a2[32] == a1)
    return 0;
  else
    return 0xFFFFFFFFLL;
}

void sub_10004B5C4(uint64_t a1, _QWORD *a2)
{
  BOOL v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;

  if (a2[32])
    v4 = dword_10008BA20 == 0;
  else
    v4 = 1;
  if (!v4)
  {
    v5 = ne_log_obj(a1);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      sub_1000673D8(v5, v6, v7, v8, v9, v10, v11, v12);
  }
  a2[32] = a1;
  v13 = (_QWORD *)(a1 + 448);
  v14 = *(_QWORD *)(a1 + 448);
  a2[39] = v14;
  if (v14)
    *(_QWORD *)(v14 + 320) = a2 + 39;
  *v13 = a2;
  a2[40] = v13;
}

uint64_t sub_10004B64C(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  _QWORD *v5;
  _QWORD *v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  NSObject *v17;
  _QWORD *v18;
  _QWORD *v19;
  int v20;
  const char *v21;

  if (!a1)
  {
    if (dword_10008BA20)
    {
      v7 = ne_log_obj(0);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        sub_100067448(v7, v8, v9, v10, v11, v12, v13, v14);
    }
    return 0;
  }
  v2 = *(_QWORD *)(a1 + 440);
  if (!v2)
  {
    if (dword_10008BA20)
    {
      v15 = ne_log_obj(a1);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        v20 = 136315138;
        v21 = "ike_session_update_ph1_ph2tree";
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "invalid parent session in %s.\n", (uint8_t *)&v20, 0xCu);
      }
    }
    return 0;
  }
  v3 = *(_QWORD *)(v2 + 1696);
  if (!v3)
  {
LABEL_7:
    if (dword_10008BA20)
    {
      v4 = ne_log_obj(a1);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v20) = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "no ph1bind replacement found. NULL ph1.\n", (uint8_t *)&v20, 2u);
      }
    }
    v5 = *(_QWORD **)(a1 + 448);
    if (v5)
    {
      do
      {
        v6 = (_QWORD *)v5[39];
        if (v5[32])
        {
          v5[32] = 0;
          if (v6)
            v6[40] = v5[40];
          *(_QWORD *)v5[40] = v6;
        }
        v5 = v6;
      }
      while (v6);
    }
    return 0;
  }
  while ((*(_BYTE *)(v3 + 432) & 2) != 0 || (*(_BYTE *)(v3 + 17) & 0x20) == 0)
  {
    v3 = *(_QWORD *)(v3 + 456);
    if (!v3)
      goto LABEL_7;
  }
  if (v3 == a1)
  {
    if (dword_10008BA20)
    {
      v17 = ne_log_obj(a1);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v20) = 0;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "no ph1bind replacement found. same ph1.\n", (uint8_t *)&v20, 2u);
      }
    }
    v18 = *(_QWORD **)(a1 + 448);
    if (v18)
    {
      do
      {
        v19 = (_QWORD *)v18[39];
        if (v18[32])
        {
          v18[32] = 0;
          if (v19)
            v19[40] = v18[40];
          *(_QWORD *)v18[40] = v19;
        }
        v18 = v19;
      }
      while (v19);
    }
    return a1;
  }
  else
  {
    sub_10004BA50(a1, v3);
  }
  return v3;
}

void sub_10004B884(unsigned int *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  NSObject *v5;
  uint64_t v6;
  int v7;
  uint64_t *v8;

  if (a1)
  {
    v2 = a1[95];
    if ((_DWORD)v2)
    {
      sub_10003A6F0(v2);
      a1[95] = 0;
    }
    v3 = a1[96];
    if ((_DWORD)v3)
    {
      sub_10003A6F0(v3);
      a1[96] = 0;
    }
    v4 = a1[423];
    if ((_DWORD)v4)
    {
      v4 = sub_10003A6F0(v4);
      a1[423] = 0;
    }
    if ((*((_QWORD *)a1 + 38) || a1[78]) && !*((_QWORD *)a1 + 42) && !a1[86])
      v4 = gettimeofday((timeval *)a1 + 21, 0);
    if (dword_10008BA20)
    {
      v5 = ne_log_obj(v4);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        v7 = 136315138;
        v8 = sub_10003C570((const sockaddr *)(a1 + 34));
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Freeing IKE-Session to %s.\n", (uint8_t *)&v7, 0xCu);
      }
    }
    v6 = *((_QWORD *)a1 + 214);
    if (v6)
      *(_QWORD *)(v6 + 1720) = *((_QWORD *)a1 + 215);
    **((_QWORD **)a1 + 215) = v6;
    free(a1);
  }
}

_QWORD *sub_10004B9B4(_QWORD *result)
{
  uint64_t v1;

  if (result[32])
  {
    result[32] = 0;
    v1 = result[39];
    if (v1)
      *(_QWORD *)(v1 + 320) = result[40];
    *(_QWORD *)result[40] = v1;
  }
  return result;
}

uint64_t sub_10004B9DC(uint64_t a1)
{
  uint64_t result;
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (a1)
  {
    for (result = *(_QWORD *)(a1 + 1696); result; result = *(_QWORD *)(result + 456))
    {
      if ((*(_BYTE *)(result + 432) & 2) == 0 && (*(_BYTE *)(result + 17) & 0x20) != 0)
        break;
    }
  }
  else
  {
    if (dword_10008BA20)
    {
      v2 = ne_log_obj(0);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_1000674B8(v2, v3, v4, v5, v6, v7, v8, v9);
    }
    return 0;
  }
  return result;
}

void sub_10004BA50(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  NSObject *v22;
  NSObject *v24;
  uint8_t v25;
  _BYTE v26[15];
  uint8_t buf[4];
  uint64_t v28;

  if (a1 == a2)
  {
    if (dword_10008BA20)
    {
      v11 = ne_log_obj(a1);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        sub_100067528(v11, v12, v13, v14, v15, v16, v17, v18);
    }
  }
  else if (*(_QWORD *)(a1 + 440) == *(_QWORD *)(a2 + 440))
  {
    v19 = *(_QWORD *)(a1 + 448);
    while (v19)
    {
      v20 = v19;
      v19 = *(_QWORD *)(v19 + 312);
      if (*(_QWORD *)(v20 + 272) != *(_QWORD *)(a2 + 440) && dword_10008BA20 != 0)
      {
        v22 = ne_log_obj(a1);
        a1 = os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
        if ((_DWORD)a1)
          sub_1000675E4(&v25, v26, v22);
      }
      if (*(_QWORD *)(v20 + 256) == a2 && dword_10008BA20 != 0)
      {
        v24 = ne_log_obj(a1);
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          sub_100067598(buf, &v28, v24);
      }
      sub_10004BC8C(a2, v20);
    }
  }
  else if (dword_10008BA20)
  {
    v3 = ne_log_obj(a1);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      sub_100067620(v3, v4, v5, v6, v7, v8, v9, v10);
  }
}

uint64_t sub_10004BBE8(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;

  if (a1 && !*(_DWORD *)(a1 + 48))
  {
    v12 = sub_10004B9DC(*(_QWORD *)(a1 + 272));
    v10 = v12;
    if (v12)
    {
      v13 = *(_QWORD *)(a1 + 256);
      if (!v13 || v12 == v13)
      {
        if (!v13)
          sub_10004B5C4(v12, (_QWORD *)a1);
      }
      else
      {
        sub_10004BC8C(v12, a1);
      }
    }
  }
  else
  {
    if (dword_10008BA20)
    {
      v2 = ne_log_obj(a1);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_100067690(v2, v3, v4, v5, v6, v7, v8, v9);
    }
    return 0;
  }
  return v10;
}

void sub_10004BC8C(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t *v6;
  NSObject *v7;
  uint8_t v8[16];

  if (*(_QWORD *)(a2 + 256))
  {
    *(_QWORD *)(a2 + 256) = 0;
    v4 = *(_QWORD *)(a2 + 312);
    if (v4)
      *(_QWORD *)(v4 + 320) = *(_QWORD *)(a2 + 320);
    **(_QWORD **)(a2 + 320) = v4;
  }
  sub_10004B5C4(a1, (_QWORD *)a2);
  v5 = *(_QWORD **)(a2 + 240);
  if (v5)
  {
    sub_10002DA18(v5);
    if ((*(_BYTE *)(a1 + 17) & 0x20) != 0)
    {
      v6 = sub_10002DA88(a1, *(_DWORD *)(a2 + 108));
      *(_QWORD *)(a2 + 240) = v6;
      if (dword_10008BA20)
      {
        v7 = ne_log_obj(v6);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)v8 = 0;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Phase 1-2 binding changed... recalculated ivm.\n", v8, 2u);
        }
      }
    }
    else
    {
      *(_QWORD *)(a2 + 240) = 0;
    }
  }
}

uint64_t sub_10004BD5C(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;
  int v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (!a1)
  {
    if (dword_10008BA20)
    {
      v4 = ne_log_obj(0);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_100067700(v4, v5, v6, v7, v8, v9, v10, v11);
    }
    return 0;
  }
  v1 = *(_QWORD *)(a1 + 1696);
  if (!v1)
    return 0;
  result = 0;
  do
  {
    if ((*(_BYTE *)(v1 + 432) & 2) == 0)
    {
      v3 = *(_DWORD *)(v1 + 16);
      if ((v3 & 0x3000) != 0 && (!result || v3 > *(_DWORD *)(result + 16)))
        result = v1;
    }
    v1 = *(_QWORD *)(v1 + 456);
  }
  while (v1);
  return result;
}

uint64_t sub_10004BDEC(uint64_t result, uint64_t a2)
{
  uint64_t v2;

  if (result)
  {
    v2 = *(_QWORD *)(result + 1696);
    if (v2)
    {
      while (v2 == a2 || (*(_BYTE *)(v2 + 432) & 2) != 0 || (*(_BYTE *)(v2 + 17) & 0x20) == 0 || !*(_DWORD *)(v2 + 116))
      {
        v2 = *(_QWORD *)(v2 + 456);
        if (!v2)
          return 0;
      }
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL sub_10004BE30(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  NSObject *v3;
  _BOOL8 result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (!a1)
  {
    if (dword_10008BA20)
    {
      v3 = ne_log_obj(0);
      result = os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      sub_100067770(v3, v5, v6, v7, v8, v9, v10, v11);
    }
    return 0;
  }
  v2 = *(_QWORD *)(a1 + 1696);
  if (!v2)
    return 0;
  while (v2 == a2 || (*(_BYTE *)(v2 + 432) & 2) != 0 || (*(_BYTE *)(v2 + 17) & 0x10) == 0)
  {
    v2 = *(_QWORD *)(v2 + 456);
    if (!v2)
      return 0;
  }
  return 1;
}

BOOL sub_10004BEB0(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  NSObject *v3;
  _BOOL8 result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (!a1)
  {
    if (dword_10008BA20)
    {
      v3 = ne_log_obj(0);
      result = os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      sub_1000677E0(v3, v5, v6, v7, v8, v9, v10, v11);
    }
    return 0;
  }
  v2 = *(_QWORD *)(a1 + 1704);
  if (!v2)
    return 0;
  while (v2 == a2
       || *(_DWORD *)(v2 + 48)
       || (*(_BYTE *)(v2 + 264) & 2) != 0
       || *(_DWORD *)(a2 + 52) != *(_DWORD *)(v2 + 52)
       || (*(_BYTE *)(v2 + 57) & 0x20) == 0)
  {
    v2 = *(_QWORD *)(v2 + 296);
    if (!v2)
      return 0;
  }
  return 1;
}

BOOL sub_10004BF48(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  NSObject *v4;
  int v5;
  int v6;
  NSObject *v7;
  _BOOL8 result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;

  if (!a1)
  {
    if (dword_10008BA20)
    {
      v7 = ne_log_obj(0);
      result = os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      sub_100067850(v7, v9, v10, v11, v12, v13, v14, v15);
    }
    return 0;
  }
  v2 = *(_QWORD *)(a1 + 1704);
  if (!v2)
    return 0;
  while (1)
  {
    if (dword_10008BA20)
    {
      v4 = ne_log_obj(a1);
      a1 = os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)a1)
      {
        v5 = *(_DWORD *)(a2 + 52);
        v6 = *(_DWORD *)(v2 + 52);
        *(_DWORD *)buf = 136315650;
        v17 = "ike_session_has_other_negoing_ph2";
        v18 = 1024;
        v19 = v5;
        v20 = 1024;
        v21 = v6;
        _os_log_debug_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "%s: ph2 sub spid %d, db spid %d\n", buf, 0x18u);
      }
    }
    if (v2 != a2
      && !*(_DWORD *)(v2 + 48)
      && (*(_BYTE *)(v2 + 264) & 2) == 0
      && *(_DWORD *)(a2 + 52) == *(_DWORD *)(v2 + 52)
      && (*(_BYTE *)(v2 + 57) & 0x10) != 0)
    {
      break;
    }
    v2 = *(_QWORD *)(v2 + 296);
    if (!v2)
      return 0;
  }
  return 1;
}

void sub_10004C0C0(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t *i;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  NSObject *v12;
  int v13;
  const char *v14;

  v1 = a1[55];
  if (v1)
  {
    v3 = v1 + 8;
    v4 = v1 + 136;
    v5 = sub_10003D25C(a1[7]);
    sub_10003D350(v3, v5);
    v6 = sub_10003D25C(a1[6]);
    sub_10003D350(v4, v6);
    *(_WORD *)(a1[55] + 264) |= 2u;
    for (i = *(uint64_t **)(a1[55] + 1704); i; i = (uint64_t *)i[37])
    {
      v8 = *i;
      v9 = i[1];
      v10 = sub_10003D25C(a1[7]);
      sub_10003D350(v8, v10);
      v11 = sub_10003D25C(a1[6]);
      sub_10003D350(v9, v11);
    }
  }
  else if (dword_10008BA20)
  {
    v12 = ne_log_obj(a1);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      v13 = 136315138;
      v14 = "ike_session_ikev1_float_ports";
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "invalid parent session in %s.\n", (uint8_t *)&v13, 0xCu);
    }
  }
}

void sub_10004C204(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  int v14;
  int v15;
  const char *v16;
  __int16 v17;
  int v18;

  v2 = *(_QWORD *)(a1 + 272);
  if (!v2 || *(_DWORD *)(a1 + 48))
  {
    if (dword_10008BA20)
    {
      v3 = ne_log_obj(v2);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        sub_1000678C0(v3, v4, v5, v6, v7, v8, v9, v10);
    }
    return;
  }
  if (*(_DWORD *)(v2 + 1692))
  {
    sub_10003A6F0(*(unsigned int *)(v2 + 1692));
    v2 = *(_QWORD *)(a1 + 272);
    *(_DWORD *)(v2 + 1692) = 0;
  }
  if ((*(_WORD *)(v2 + 264) & 1) != 0)
  {
    if ((*(_BYTE *)(v2 + 280) & 4) == 0)
      goto LABEL_13;
  }
  else
  {
    gettimeofday((timeval *)(v2 + 320), 0);
    *(_WORD *)(*(_QWORD *)(a1 + 272) + 264) |= 1u;
    v2 = *(_QWORD *)(a1 + 272);
  }
  sub_10004C3B4((int *)v2);
LABEL_13:
  *(_BYTE *)(*(_QWORD *)(a1 + 272) + 280) &= ~4u;
  *(_QWORD *)(*(_QWORD *)(a1 + 272) + 296) = 0;
  sub_10004B1D0(a1);
  if (*(_BYTE *)(a1 + 61) == 16 && *(_QWORD *)(a1 + 256))
  {
    *(_QWORD *)(a1 + 256) = 0;
    v11 = *(_QWORD *)(a1 + 312);
    if (v11)
      *(_QWORD *)(v11 + 320) = *(_QWORD *)(a1 + 320);
    **(_QWORD **)(a1 + 320) = v11;
  }
  v12 = sub_100049074(1, a1);
  if (dword_10008BA20)
  {
    v13 = ne_log_obj(v12);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      v14 = *(_DWORD *)(a1 + 52);
      v15 = 136315394;
      v16 = "ike_session_ph2_established";
      v17 = 1024;
      v18 = v14;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%s: ph2 established, spid %d\n", (uint8_t *)&v15, 0x12u);
    }
  }
}

uint64_t sub_10004C3B4(int *a1)
{
  uint64_t v2;
  uint64_t result;

  v2 = a1[92];
  if ((_DWORD)v2)
    a1[95] = sub_10003A520(v2, (uint64_t)sub_10004E94C, (uint64_t)a1);
  result = a1[93];
  if ((_DWORD)result)
  {
    result = (uint64_t)sub_10003A520(result, (uint64_t)sub_10004EAF8, (uint64_t)a1);
    a1[96] = result;
  }
  return result;
}

_QWORD *sub_10004C408(uint64_t a1)
{
  int v2;
  _QWORD *result;

  v2 = *(_DWORD *)(a1 + 16);
  if ((v2 & 0x4000) != 0)
  {
    result = sub_10003A520(1, (uint64_t)sub_100024B18, a1);
    *(_DWORD *)(a1 + 112) = (_DWORD)result;
  }
  else
  {
    if ((v2 & 0x2000) != 0)
      sub_10001A528(a1);
    return sub_100022B8C(a1);
  }
  return result;
}

void sub_10004C464(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  char *v8;
  uint64_t *v9;
  char *v10;
  __int128 *v11;
  char *v12;
  char *v13;
  NSObject *v14;
  uint64_t v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  NSObject *v24;
  NSObject *v25;
  NSObject *v26;
  int v27;
  char *v28;
  __int16 v29;
  char *v30;
  __int16 v31;
  char *v32;
  __int16 v33;
  __int128 *v34;

  if (a1)
  {
    if (a2)
    {
      v4 = *(_QWORD *)(a1 + 440);
      if (v4)
      {
        if (a1 != a2 && v4 == *(_QWORD *)(a2 + 440))
        {
          if ((*(_WORD *)(v4 + 264) & 0x400) != 0 && *(_DWORD *)(a1 + 20) == 1)
            return;
          v5 = *(unsigned int *)(a2 + 112);
          if ((_DWORD)v5)
          {
            sub_10003A6F0(v5);
            *(_DWORD *)(a2 + 112) = 0;
          }
          v6 = *(unsigned int *)(a2 + 116);
          if ((_DWORD)v6)
          {
            sub_10003A6F0(v6);
            *(_DWORD *)(a2 + 116) = 0;
          }
          *(_BYTE *)(a2 + 432) |= 2u;
          v7 = sub_10003C570(*(const sockaddr **)(a2 + 56));
          v8 = strdup((const char *)v7);
          v9 = sub_10003C570(*(const sockaddr **)(a2 + 48));
          v10 = strdup((const char *)v9);
          v11 = sub_100023E84(a2, 0);
          v12 = strdup((const char *)v11);
          if (v8)
          {
            if (v10)
            {
              v13 = v12;
              if (v12)
              {
                if (dword_10008BA20)
                {
                  v14 = ne_log_obj(v12);
                  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
                  {
                    v27 = 136315906;
                    v28 = v8;
                    v29 = 2080;
                    v30 = v10;
                    v31 = 2080;
                    v32 = v13;
                    v33 = 2080;
                    v34 = sub_100023E84(a1, 0);
                    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "ISAKMP-SA %s-%s (spi:%s) needs to be deleted, replaced by (spi:%s)\n", (uint8_t *)&v27, 0x2Au);
                  }
                }
                free(v8);
                free(v10);
                free(v13);
                sub_10004BA50(a2, a1);
                if (*(_DWORD *)(a2 + 20))
                  v15 = 7;
                else
                  v15 = 5;
                *(_DWORD *)(a2 + 112) = sub_10003A520(v15, (uint64_t)sub_10004C460, a2);
                return;
              }
              if (dword_10008BA20)
              {
                v26 = ne_log_obj(0);
                if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
                  goto LABEL_34;
              }
LABEL_35:
              exit(1);
            }
            if (!dword_10008BA20)
              goto LABEL_35;
            v25 = ne_log_obj(v12);
            if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
              goto LABEL_35;
          }
          else
          {
            if (!dword_10008BA20)
              goto LABEL_35;
            v24 = ne_log_obj(v12);
            if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
              goto LABEL_35;
          }
LABEL_34:
          sub_10005C4A8();
          goto LABEL_35;
        }
      }
    }
  }
  if (dword_10008BA20)
  {
    v16 = ne_log_obj(a1);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      sub_100067930(v16, v17, v18, v19, v20, v21, v22, v23);
  }
}

void sub_10004C6F4(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  char *v16;
  uint64_t *v17;
  char *v18;
  char *v19;
  NSObject *v20;
  __int128 *v21;
  uint64_t v22;
  NSObject *v23;
  NSObject *v24;
  uint8_t buf[4];
  char *v26;
  __int16 v27;
  char *v28;
  __int16 v29;
  __int128 *v30;

  if (a1 && a2 && *(_QWORD *)(a2 + 440) == a1)
  {
    if ((*(_WORD *)(a1 + 264) & 0x400) == 0 || *(_DWORD *)(a2 + 20) != 1)
    {
      v11 = *(_QWORD *)(a1 + 1696);
      while (v11)
      {
        v12 = v11;
        v11 = *(_QWORD *)(v11 + 456);
        if (v12 != a2 && (*(_BYTE *)(v12 + 432) & 2) == 0)
        {
          v13 = *(unsigned int *)(v12 + 112);
          if ((_DWORD)v13)
          {
            sub_10003A6F0(v13);
            *(_DWORD *)(v12 + 112) = 0;
          }
          v14 = *(unsigned int *)(v12 + 116);
          if ((_DWORD)v14)
          {
            sub_10003A6F0(v14);
            *(_DWORD *)(v12 + 116) = 0;
          }
          *(_BYTE *)(v12 + 432) |= 2u;
          v15 = sub_10003C570(*(const sockaddr **)(v12 + 56));
          v16 = strdup((const char *)v15);
          v17 = sub_10003C570(*(const sockaddr **)(v12 + 48));
          v18 = strdup((const char *)v17);
          if (!v16)
          {
            if (dword_10008BA20)
            {
              v23 = ne_log_obj(v18);
              if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
LABEL_33:
                sub_10005C4A8();
            }
LABEL_34:
            exit(1);
          }
          v19 = v18;
          if (!v18)
          {
            if (dword_10008BA20)
            {
              v24 = ne_log_obj(0);
              if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
                goto LABEL_33;
            }
            goto LABEL_34;
          }
          if (dword_10008BA20)
          {
            v20 = ne_log_obj(v18);
            if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
            {
              v21 = sub_100023E84(v12, 0);
              *(_DWORD *)buf = 136315650;
              v26 = v16;
              v27 = 2080;
              v28 = v19;
              v29 = 2080;
              v30 = v21;
              _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "ISAKMP-SA needs to be deleted %s-%s spi:%s\n", buf, 0x20u);
            }
          }
          free(v16);
          free(v19);
          sub_10004BA50(v12, a2);
          if (*(_DWORD *)(v12 + 20))
            v22 = 7;
          else
            v22 = 5;
          *(_DWORD *)(v12 + 112) = sub_10003A520(v22, (uint64_t)sub_10004C460, v12);
        }
      }
    }
  }
  else if (dword_10008BA20)
  {
    v3 = ne_log_obj(a1);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      sub_1000679A0(v3, v4, v5, v6, v7, v8, v9, v10);
  }
}

uint64_t sub_10004C950(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  unsigned int *i;
  int v6;
  char v7;

  if (!*(_DWORD *)(result + 48))
  {
    v1 = result;
    if ((*(_BYTE *)(result + 57) & 0x40) == 0)
    {
      v2 = *(unsigned int *)(result + 64);
      if ((_DWORD)v2)
      {
        v2 = sub_10003A6F0(v2);
        *(_DWORD *)(v1 + 64) = 0;
      }
      if (dword_10008BA20)
      {
        v3 = ne_log_obj(v2);
        if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
          sub_100067A10((int *)(v1 + 56), v1, v3);
      }
      if ((*(_BYTE *)(v1 + 57) & 0x20) != 0)
      {
        sub_10001AA88(v1);
        v4 = *(_QWORD *)(v1 + 128);
        if (v4)
        {
          for (i = *(unsigned int **)(v4 + 32); i; i = (unsigned int *)*((_QWORD *)i + 9))
          {
            if (i[14])
            {
              v6 = *(_DWORD *)(qword_10008B848 + 32);
              v7 = sub_10002EFA4(*i);
              sub_100040B7C(v6, v7, 0, *(unsigned __int8 **)v1, *(unsigned __int8 **)(v1 + 8), i[7]);
            }
          }
        }
      }
      sub_100026C5C((uint64_t *)v1);
      return sub_10004A9EC((_QWORD *)v1);
    }
  }
  return result;
}

void sub_10004CA44(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char v13;
  uint64_t v14;
  NSObject *v15;
  char *v16;
  uint64_t v17;
  uint8_t buf[4];
  char *v19;

  if (a1 && a2 && *(_QWORD *)(a2 + 272) == a1 && !*(_DWORD *)(a2 + 48))
  {
    if ((*(_WORD *)(a1 + 264) & 0x400) == 0 || *(_BYTE *)(a2 + 60) != 1)
    {
      v11 = *(_QWORD *)(a1 + 1704);
      while (v11)
      {
        v12 = v11;
        v11 = *(_QWORD *)(v11 + 296);
        if (v12 != a2 && *(_DWORD *)(v12 + 52) == *(_DWORD *)(a2 + 52))
        {
          v13 = *(_BYTE *)(v12 + 264);
          if ((v13 & 2) == 0)
          {
            v14 = *(unsigned int *)(v12 + 64);
            if ((_DWORD)v14)
            {
              v14 = sub_10003A6F0(v14);
              *(_DWORD *)(v12 + 64) = 0;
              v13 = *(_BYTE *)(v12 + 264);
            }
            *(_BYTE *)(v12 + 264) = v13 | 2;
            if (dword_10008BA20)
            {
              v15 = ne_log_obj(v14);
              if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
              {
                v16 = sub_10002FA64(*(const sockaddr **)v12, *(const sockaddr **)(v12 + 8), *(unsigned __int8 *)(v12 + 104), *(_DWORD *)(v12 + 52), 0);
                *(_DWORD *)buf = 136315138;
                v19 = v16;
                _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "IPsec-SA needs to be deleted: %s\n", buf, 0xCu);
              }
            }
            if (*(_BYTE *)(v12 + 60))
              v17 = 5;
            else
              v17 = 3;
            *(_DWORD *)(v12 + 64) = sub_10003A520(v17, (uint64_t)sub_10004CA40, v12);
          }
        }
      }
    }
  }
  else if (dword_10008BA20)
  {
    v3 = ne_log_obj(a1);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      sub_100067AAC(v3, v4, v5, v6, v7, v8, v9, v10);
  }
}

void sub_10004CC10(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v13;
  const char *v14;

  if (a1)
  {
    if (*(_QWORD *)(a1 + 336) || *(_DWORD *)(a1 + 344))
    {
      if (dword_10008BA20)
      {
        v3 = ne_log_obj(a1);
        if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
        {
          v13 = 136315138;
          v14 = "ike_session_stopped_by_controller";
          _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "already stopped %s.\n", (uint8_t *)&v13, 0xCu);
        }
      }
    }
    else
    {
      *(_WORD *)(a1 + 264) |= 0x20u;
      gettimeofday((timeval *)(a1 + 336), 0);
      if (!*(_QWORD *)(a1 + 296))
        *(_QWORD *)(a1 + 296) = a2;
    }
  }
  else if (dword_10008BA20)
  {
    v4 = ne_log_obj(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      sub_100067B1C(v4, v5, v6, v7, v8, v9, v10, v11);
  }
}

void sub_10004CD34(unint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v7;
  unint64_t v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  if (a1)
  {
    v3 = qword_10008C6D0;
    while (v3)
    {
      while (1)
      {
        v7 = v3;
        v3 = *(_QWORD *)(v3 + 1712);
        v8 = v7 + 136;
        if (a2)
          break;
        if (sub_10003B380(v8, a1))
          goto LABEL_5;
LABEL_8:
        sub_10004CC10(v7, a3);
        if (!v3)
          return;
      }
      if (!sub_10003B5A0(v8, a1))
        goto LABEL_8;
LABEL_5:
      ;
    }
  }
  else if (dword_10008BA20)
  {
    v9 = ne_log_obj(0);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      sub_100067B8C(v9, v10, v11, v12, v13, v14, v15, v16);
  }
}

uint64_t sub_10004CDE8(uint64_t result)
{
  uint64_t i;
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint8_t v5[16];

  for (i = *(_QWORD *)(result + 1696); i; result = sub_10004AACC(v2))
  {
    v2 = i;
    i = *(_QWORD *)(i + 456);
    if (dword_10008BA20)
    {
      v3 = ne_log_obj(result);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v5 = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "deleteallph1 of given session: got a ph1 handler...\n", v5, 2u);
      }
    }
    v4 = sub_10000A9C8(v2);
    sub_1000487BC(0xEu, 1u, v4, 0, 0);
  }
  return result;
}

void sub_10004CEA8(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  uint64_t v5;
  NSObject *v6;
  char *v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint8_t buf[4];
  char *v17;

  if (a1 && (v1 = *(_QWORD *)(a1 + 440)) != 0)
  {
    v2 = *(_QWORD *)(v1 + 1704);
    if (v2)
    {
      do
      {
        v3 = *(_QWORD *)(v2 + 296);
        v4 = *(_BYTE *)(v2 + 264);
        if ((v4 & 2) == 0)
        {
          v5 = *(unsigned int *)(v2 + 64);
          if ((_DWORD)v5)
          {
            v5 = sub_10003A6F0(v5);
            *(_DWORD *)(v2 + 64) = 0;
            v4 = *(_BYTE *)(v2 + 264);
          }
          *(_BYTE *)(v2 + 264) = v4 | 2;
          if (dword_10008BA20)
          {
            v6 = ne_log_obj(v5);
            if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
            {
              v7 = sub_10002FA64(*(const sockaddr **)v2, *(const sockaddr **)(v2 + 8), *(unsigned __int8 *)(v2 + 104), *(_DWORD *)(v2 + 52), 0);
              *(_DWORD *)buf = 136315138;
              v17 = v7;
              _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "IPsec-SA needs to be purged: %s\n", buf, 0xCu);
            }
          }
          sub_10004C950(v2);
        }
        v2 = v3;
      }
      while (v3);
    }
  }
  else if (dword_10008BA20)
  {
    v8 = ne_log_obj(a1);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      sub_100067BFC(v8, v9, v10, v11, v12, v13, v14, v15);
  }
}

void sub_10004D000(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  unsigned int v7;
  NSObject *v8;
  int v9;
  const char *v10;

  v1 = a1[34];
  if (v1)
  {
    v3 = v1 + 136;
    v4 = *a1;
    v5 = sub_10003D25C(v1 + 8);
    sub_10003D350(v4, v5);
    v6 = a1[1];
    v7 = sub_10003D25C(v3);
    sub_10003D350(v6, v7);
  }
  else if (dword_10008BA20)
  {
    v8 = ne_log_obj(a1);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 136315138;
      v10 = "ike_session_update_ph2_ports";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "invalid parent session in %s.\n", (uint8_t *)&v9, 0xCu);
    }
  }
}

uint64_t sub_10004D11C(uint64_t a1, int a2, _DWORD *a3, uint64_t a4, uint64_t a5)
{
  NSObject *v9;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  if ((a2 - 1) > 1 || a1 == 0 || a3 == 0 || a4 == 0 || (_DWORD)a5 == 0)
  {
    if (dword_10008BA20)
    {
      v9 = ne_log_obj(a1);
      result = os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
      if (!(_DWORD)result)
        return result;
      sub_100067C6C(v9, v11, v12, v13, v14, v15, v16, v17);
    }
    return 0;
  }
  *a3 = 0;
  v18 = *(_QWORD *)(a1 + 1704);
  if (!v18)
    return 0;
  result = 0;
  while (1)
  {
    v19 = *(_QWORD *)(v18 + 128);
    if (v19)
    {
      v20 = *(_QWORD *)(v19 + 32);
      if (v20)
        break;
    }
LABEL_31:
    v18 = *(_QWORD *)(v18 + 296);
    if (!v18)
      return result;
  }
  while (1)
  {
    if (*(_DWORD *)(v20 + 56) && *(_DWORD *)v20 == 3)
    {
      if (!*a3)
        *a3 = *(_DWORD *)(v18 + 100);
      v21 = a2 == 1 ? 24 : 28;
      *(_DWORD *)(a4 + 40 * (int)result) = *(_DWORD *)(v20 + v21);
      result = (result + 1);
      if ((_DWORD)result == (_DWORD)a5)
        return a5;
    }
    v20 = *(_QWORD *)(v20 + 72);
    if (!v20)
      goto LABEL_31;
  }
}

void sub_10004D210(uint64_t a1, int a2, _QWORD *__src, unsigned int a4)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  _DWORD *v23;
  _QWORD *v24;
  int v25;
  int v26;
  _QWORD *v27;
  uint64_t v28;
  _DWORD *v29;
  _QWORD *v30;
  int v31;
  int v32;
  _QWORD *v33;
  NSObject *v34;
  size_t v35;
  time_t v36;
  __int16 v37;
  unsigned int v38;
  NSObject *v39;
  int v40;
  int v41;
  const char *v42;
  int v43;
  int v44;
  uint64_t v45;
  int v46;
  _QWORD *v47;
  _QWORD *v48;
  uint8_t buf[4];
  const char *v50;
  __int16 v51;
  int v52;
  __int16 v53;
  int v54;

  if ((a2 - 3) >= 0xFFFFFFFE && a1 != 0 && __src != 0)
  {
    v14 = a1;
    if ((*(_WORD *)(a1 + 264) & 0x21) != 1 || *(_QWORD *)(a1 + 336) || *(_DWORD *)(a1 + 344))
    {
      if (dword_10008BA20)
      {
        v15 = ne_log_obj(a1);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          v50 = "ike_session_update_traffic_idle_status";
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "dropping update on invalid session in %s.\n", buf, 0xCu);
        }
      }
      return;
    }
    if (a4)
    {
      v19 = 0;
      v20 = 0;
      v47 = (_QWORD *)(a1 + 736);
      v48 = (_QWORD *)(a1 + 1384);
      v21 = 1;
      while (1)
      {
        if (a2 == 1)
        {
          v22 = *(unsigned int *)(v14 + 392);
          if ((_DWORD)v22)
          {
            v23 = &__src[5 * v19];
            v26 = *v23;
            v24 = v23 + 4;
            v25 = v26;
            v27 = v47;
            do
            {
              if (v25 == *((_DWORD *)v27 - 4))
              {
                if (*v24 != *v27)
                  v21 = 0;
                v20 = 1;
              }
              v27 += 5;
              --v22;
            }
            while (v22);
          }
        }
        else
        {
          v28 = *(unsigned int *)(v14 + 1044);
          if ((_DWORD)v28)
          {
            v29 = &__src[5 * v19];
            v32 = *v29;
            v30 = v29 + 4;
            v31 = v32;
            v33 = v48;
            do
            {
              if (v31 == *((_DWORD *)v33 - 4))
              {
                if (*v30 != *v33)
                  v21 = 0;
                v20 = 1;
              }
              v33 += 5;
              --v28;
            }
            while (v28);
          }
        }
        if (v20 || !__src[5 * v19 + 2])
          goto LABEL_43;
        if (!dword_10008BA20)
          goto LABEL_42;
        v34 = ne_log_obj(a1);
        a1 = os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT);
        v21 = 0;
        if ((_DWORD)a1)
          break;
LABEL_43:
        if (++v19 == a4)
          goto LABEL_46;
      }
      *(_DWORD *)buf = 67109120;
      LODWORD(v50) = a2;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "new SA: dir %d....\n", buf, 8u);
LABEL_42:
      v21 = 0;
      goto LABEL_43;
    }
    v21 = 1;
LABEL_46:
    v35 = 40 * a4;
    if (a2 == 1)
    {
      *(_OWORD *)(v14 + 1008) = 0u;
      *(_OWORD *)(v14 + 1024) = 0u;
      *(_OWORD *)(v14 + 976) = 0u;
      *(_OWORD *)(v14 + 992) = 0u;
      *(_OWORD *)(v14 + 944) = 0u;
      *(_OWORD *)(v14 + 960) = 0u;
      *(_OWORD *)(v14 + 912) = 0u;
      *(_OWORD *)(v14 + 928) = 0u;
      *(_OWORD *)(v14 + 880) = 0u;
      *(_OWORD *)(v14 + 896) = 0u;
      *(_OWORD *)(v14 + 848) = 0u;
      *(_OWORD *)(v14 + 864) = 0u;
      *(_OWORD *)(v14 + 816) = 0u;
      *(_OWORD *)(v14 + 832) = 0u;
      *(_OWORD *)(v14 + 784) = 0u;
      *(_OWORD *)(v14 + 800) = 0u;
      *(_OWORD *)(v14 + 752) = 0u;
      *(_OWORD *)(v14 + 768) = 0u;
      *(_OWORD *)(v14 + 720) = 0u;
      *(_OWORD *)(v14 + 736) = 0u;
      v36 = (time_t)memmove((void *)(v14 + 720), __src, v35);
      *(_DWORD *)(v14 + 392) = a4;
      if (!v21)
      {
        v37 = 192;
LABEL_51:
        *(_WORD *)(v14 + 264) |= v37;
        v36 = time(0);
        *(_QWORD *)(v14 + 272) = v36;
      }
    }
    else
    {
      *(_OWORD *)(v14 + 1656) = 0u;
      *(_OWORD *)(v14 + 1672) = 0u;
      *(_OWORD *)(v14 + 1624) = 0u;
      *(_OWORD *)(v14 + 1640) = 0u;
      *(_OWORD *)(v14 + 1592) = 0u;
      *(_OWORD *)(v14 + 1608) = 0u;
      *(_OWORD *)(v14 + 1560) = 0u;
      *(_OWORD *)(v14 + 1576) = 0u;
      *(_OWORD *)(v14 + 1528) = 0u;
      *(_OWORD *)(v14 + 1544) = 0u;
      *(_OWORD *)(v14 + 1496) = 0u;
      *(_OWORD *)(v14 + 1512) = 0u;
      *(_OWORD *)(v14 + 1464) = 0u;
      *(_OWORD *)(v14 + 1480) = 0u;
      *(_OWORD *)(v14 + 1432) = 0u;
      *(_OWORD *)(v14 + 1448) = 0u;
      *(_OWORD *)(v14 + 1400) = 0u;
      *(_OWORD *)(v14 + 1416) = 0u;
      *(_OWORD *)(v14 + 1368) = 0u;
      *(_OWORD *)(v14 + 1384) = 0u;
      v36 = (time_t)memmove((void *)(v14 + 1368), __src, v35);
      *(_DWORD *)(v14 + 1044) = a4;
      if (!v21)
      {
        v37 = 768;
        goto LABEL_51;
      }
    }
    v38 = *(_DWORD *)(v14 + 376);
    if (v38 <= 1 && (*(_WORD *)(v14 + 264) & 0x80) != 0)
    {
      if (!dword_10008BA20)
        goto LABEL_63;
      v39 = ne_log_obj(v36);
      if (!os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
        goto LABEL_63;
      v43 = *(_DWORD *)(v14 + 376);
      v44 = *(_DWORD *)(v14 + 372);
      *(_DWORD *)buf = 136315650;
      v50 = "ike_session_monitor_idle";
      v51 = 1024;
      v52 = v43;
      v53 = 1024;
      v54 = v44;
      v42 = "%s: restart idle-timeout because peer sent data. monitoring dir %d. idle timer %d s\n";
    }
    else
    {
      if ((v38 | 2) != 2 || (*(_WORD *)(v14 + 264) & 0x200) == 0)
        return;
      if (!dword_10008BA20)
        goto LABEL_63;
      v39 = ne_log_obj(v36);
      if (!os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
        goto LABEL_63;
      v40 = *(_DWORD *)(v14 + 376);
      v41 = *(_DWORD *)(v14 + 372);
      *(_DWORD *)buf = 136315650;
      v50 = "ike_session_monitor_idle";
      v51 = 1024;
      v52 = v40;
      v53 = 1024;
      v54 = v41;
      v42 = "%s: restart idle-timeout because i sent data. monitoring dir %d. idle times %d s\n";
    }
    _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, v42, buf, 0x18u);
LABEL_63:
    v45 = *(unsigned int *)(v14 + 384);
    if ((_DWORD)v45)
    {
      sub_10003A6F0(v45);
      *(_DWORD *)(v14 + 384) = 0;
    }
    v46 = *(_DWORD *)(v14 + 372);
    if (v46)
      *(_DWORD *)(v14 + 384) = sub_10003A520(v46, (uint64_t)sub_10004EAF8, v14);
    *(_WORD *)(v14 + 264) &= 0xFD7Fu;
    return;
  }
  if (dword_10008BA20)
  {
    v6 = ne_log_obj(a1);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      sub_100067CDC(v6, v7, v8, v9, v10, v11, v12, v13);
  }
}

uint64_t sub_10004D698(uint64_t result, char *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  unsigned int v9;
  int v10;
  __int128 v11;

  if (result)
  {
    v3 = result;
    v11 = 0uLL;
    *(_BYTE *)(result + 280) |= 2u;
    sub_10004CC10(result, (uint64_t)a2);
    result = *(unsigned int *)(v3 + 384);
    if ((_DWORD)result)
    {
      result = sub_10003A6F0(result);
      *(_DWORD *)(v3 + 384) = 0;
    }
    v4 = *(_QWORD *)(v3 + 1704);
    if (v4)
    {
      do
      {
        v5 = *(_QWORD *)(v4 + 296);
        if ((*(_BYTE *)(v4 + 57) & 0x20) != 0)
          sub_10001AA88(v4);
        result = (uint64_t)sub_1000250DC((_QWORD *)v4);
        v4 = v5;
      }
      while (v5);
    }
    v6 = *(_QWORD *)(v3 + 1696);
    if (v6)
    {
      do
      {
        if (*(_DWORD *)(v6 + 28))
          v11 = *(_OWORD *)(v6 + 28);
        v7 = *(_QWORD *)(v6 + 456);
        if ((*(_BYTE *)(v6 + 17) & 0x20) != 0)
          sub_10001A528(v6);
        result = (uint64_t)sub_100022B8C(v6);
        v6 = v7;
      }
      while (v7);
    }
    if (a2 && (*(_WORD *)(v3 + 264) & 4) != 0 && off_1000884F0[0] != a2 && off_1000884F8[0] != a2)
    {
      if (*(_BYTE *)(v3 + 137) == 2)
      {
        v8 = *(_DWORD *)(v3 + 140);
      }
      else if ((_DWORD)v11)
      {
        v10 = 0;
        nw_nat64_extract_v4(&v11, v3 + 144, &v10);
        v8 = v10;
      }
      else
      {
        v8 = 0;
      }
      if (off_100088508[0] == a2)
        v9 = 50003;
      else
        v9 = 0xFFFF;
      return sub_1000487BC(v9, 0, v8, 0, 0);
    }
  }
  return result;
}

BOOL sub_10004D81C(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  _BOOL8 result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (!a1)
  {
    if (dword_10008BA20)
    {
      v2 = ne_log_obj(0);
      result = os_log_type_enabled(v2, OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      sub_100067D4C(v2, v4, v5, v6, v7, v8, v9, v10);
    }
    return 0;
  }
  v1 = *(_QWORD *)(a1 + 1696);
  if (!v1)
    return 0;
  while ((*(_BYTE *)(v1 + 432) & 2) != 0 || (*(_BYTE *)(v1 + 17) & 0x10) == 0)
  {
    v1 = *(_QWORD *)(v1 + 456);
    if (!v1)
      return 0;
  }
  return 1;
}

BOOL sub_10004D894(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  _BOOL8 result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (!a1)
  {
    if (dword_10008BA20)
    {
      v2 = ne_log_obj(0);
      result = os_log_type_enabled(v2, OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      sub_100067DBC(v2, v4, v5, v6, v7, v8, v9, v10);
    }
    return 0;
  }
  v1 = *(_QWORD *)(a1 + 1696);
  if (!v1)
    return 0;
  while ((*(_BYTE *)(v1 + 432) & 2) != 0 || (*(_BYTE *)(v1 + 17) & 0x20) == 0)
  {
    v1 = *(_QWORD *)(v1 + 456);
    if (!v1)
      return 0;
  }
  return 1;
}

BOOL sub_10004D90C(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  _BOOL8 result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (!a1)
  {
    if (dword_10008BA20)
    {
      v2 = ne_log_obj(0);
      result = os_log_type_enabled(v2, OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      sub_100067E2C(v2, v4, v5, v6, v7, v8, v9, v10);
    }
    return 0;
  }
  v1 = *(_QWORD *)(a1 + 1704);
  if (!v1)
    return 0;
  while ((*(_BYTE *)(v1 + 264) & 2) != 0 || (*(_BYTE *)(v1 + 57) & 0x10) == 0)
  {
    v1 = *(_QWORD *)(v1 + 296);
    if (!v1)
      return 0;
  }
  return 1;
}

BOOL sub_10004D984(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  _BOOL8 result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (!a1)
  {
    if (dword_10008BA20)
    {
      v2 = ne_log_obj(0);
      result = os_log_type_enabled(v2, OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      sub_100067E9C(v2, v4, v5, v6, v7, v8, v9, v10);
    }
    return 0;
  }
  v1 = *(_QWORD *)(a1 + 1704);
  if (!v1)
    return 0;
  while ((*(_BYTE *)(v1 + 264) & 2) != 0 || (*(_BYTE *)(v1 + 57) & 0x20) == 0)
  {
    v1 = *(_QWORD *)(v1 + 296);
    if (!v1)
      return 0;
  }
  return 1;
}

void sub_10004D9FC(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (a1 && (v1 = *(_QWORD *)(a1 + 272)) != 0)
  {
    v2 = *(_QWORD *)(v1 + 1696);
    if (v2)
    {
      do
      {
        v3 = *(_QWORD *)(v2 + 456);
        if ((*(_BYTE *)(v2 + 17) & 0x20) != 0)
          sub_10001A528(v2);
        sub_100022B8C(v2);
        v2 = v3;
      }
      while (v3);
    }
  }
  else if (dword_10008BA20)
  {
    v4 = ne_log_obj(a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      sub_100067F0C(v4, v5, v6, v7, v8, v9, v10, v11);
  }
}

BOOL sub_10004DA80(uint64_t a1)
{
  uint64_t v1;
  __int16 v2;
  _BOOL8 result;

  v1 = *(_QWORD *)(a1 + 272);
  result = 0;
  if (v1)
  {
    v2 = *(_WORD *)(v1 + 264);
    if ((v2 & 0x400) != 0 && (v2 & 4) != 0 && (*(_BYTE *)(a1 + 264) & 1) != 0)
      return 1;
  }
  return result;
}

BOOL sub_10004DAAC(uint64_t a1)
{
  uint64_t v1;
  __int16 v2;
  _BOOL8 result;

  v1 = *(_QWORD *)(a1 + 440);
  result = 0;
  if (v1)
  {
    v2 = *(_WORD *)(v1 + 264);
    if ((v2 & 0x400) != 0 && (v2 & 4) != 0 && (*(_BYTE *)(a1 + 432) & 1) != 0)
      return 1;
  }
  return result;
}

BOOL sub_10004DAD8(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 440);
  return v1 && (*(_WORD *)(v1 + 264) & 0x400) != 0;
}

BOOL sub_10004DAF8(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 272);
  return v1 && (*(_WORD *)(v1 + 264) & 0x400) != 0;
}

_QWORD *sub_10004DB18(_QWORD *result)
{
  uint64_t v1;
  _QWORD *v2;

  v1 = result[55];
  if (v1 && (~*(unsigned __int16 *)(v1 + 264) & 0x404) == 0 && !*(_DWORD *)(v1 + 1692))
  {
    v2 = result;
    result = sub_10003A520(300, (uint64_t)sub_10004DB6C, v1);
    *(_DWORD *)(v2[55] + 1692) = (_DWORD)result;
  }
  return result;
}

_QWORD *sub_10004DB6C(uint64_t a1)
{
  uint64_t v2;
  _QWORD *result;

  v2 = *(unsigned int *)(a1 + 1692);
  if ((_DWORD)v2)
  {
    sub_10003A6F0(v2);
    *(_DWORD *)(a1 + 1692) = 0;
  }
  if (!sub_10004D984(a1))
    return (_QWORD *)sub_10004D698(a1, off_100088510[0]);
  result = sub_10003A520(300, (uint64_t)sub_10004DB6C, a1);
  *(_DWORD *)(a1 + 1692) = (_DWORD)result;
  return result;
}

uint64_t sub_10004DBD4(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(result + 440);
  if (v1)
  {
    v2 = result;
    result = *(unsigned int *)(v1 + 1692);
    if ((_DWORD)result)
    {
      result = sub_10003A6F0(result);
      *(_DWORD *)(*(_QWORD *)(v2 + 440) + 1692) = 0;
    }
  }
  return result;
}

uint64_t sub_10004DC0C(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  size_t *v12;
  size_t *v13;
  size_t v14;
  uint64_t v15;
  uint64_t v16;
  size_t *v17;
  size_t *v18;
  size_t v19;
  uint64_t *v20;
  size_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;

  v4 = a1[24];
  if (v4)
  {
    v5 = a2[24];
    if (v5)
    {
      if (*(_QWORD *)v4 == *(_QWORD *)v5 && !memcmp(*(const void **)(v4 + 8), *(const void **)(v5 + 8), *(_QWORD *)v4))
      {
        v29 = a1[25];
        if (v29)
        {
          v30 = a2[25];
          if (v30)
          {
            if (*(_QWORD *)v29 == *(_QWORD *)v30
              && !memcmp(*(const void **)(v29 + 8), *(const void **)(v30 + 8), *(_QWORD *)v29))
            {
              return 0;
            }
          }
        }
      }
    }
  }
  v6 = a1[35];
  if (v6)
  {
    v7 = a2[35];
    if (v7)
    {
      if (*(_QWORD *)v6 == *(_QWORD *)v7 && !memcmp(*(const void **)(v6 + 8), *(const void **)(v7 + 8), *(_QWORD *)v6))
      {
        v31 = a1[36];
        if (v31)
        {
          v32 = a2[36];
          if (v32)
          {
            if (*(_QWORD *)v31 == *(_QWORD *)v32
              && !memcmp(*(const void **)(v31 + 8), *(const void **)(v32 + 8), *(_QWORD *)v31))
            {
              return 0;
            }
          }
        }
      }
    }
  }
  v8 = a2[35];
  if (v4)
  {
    if (v8)
    {
      if (*(_QWORD *)v4 == *(_QWORD *)v8 && !memcmp(*(const void **)(v4 + 8), *(const void **)(v8 + 8), *(_QWORD *)v4))
      {
        v33 = a1[25];
        if (v33)
        {
          v34 = a2[36];
          if (v34)
          {
            if (*(_QWORD *)v33 == *(_QWORD *)v34
              && !memcmp(*(const void **)(v33 + 8), *(const void **)(v34 + 8), *(_QWORD *)v33))
            {
              return 0;
            }
          }
        }
      }
      if (*(_QWORD *)v4 == *(_QWORD *)v8 && !memcmp(*(const void **)(v4 + 8), *(const void **)(v8 + 8), *(_QWORD *)v4))
      {
        v35 = a1[25];
        if (v35)
        {
          v36 = a2[25];
          if (v36)
          {
            if (*(_QWORD *)v35 == *(_QWORD *)v36
              && !memcmp(*(const void **)(v35 + 8), *(const void **)(v36 + 8), *(_QWORD *)v35))
            {
              return 0;
            }
          }
        }
      }
    }
    v9 = a2[24];
    if (v9)
    {
      if (*(_QWORD *)v4 == *(_QWORD *)v9 && !memcmp(*(const void **)(v4 + 8), *(const void **)(v9 + 8), *(_QWORD *)v4))
      {
        v37 = a1[25];
        if (v37)
        {
          v38 = a2[36];
          if (v38)
          {
            if (*(_QWORD *)v37 == *(_QWORD *)v38
              && !memcmp(*(const void **)(v37 + 8), *(const void **)(v38 + 8), *(_QWORD *)v37))
            {
              return 0;
            }
          }
        }
      }
    }
  }
  if (!v8 || !sub_10004E00C(v8))
  {
    v10 = a2[36];
    if (!v10 || !sub_10004E00C(v10))
      return 0xFFFFFFFFLL;
  }
  v11 = a1[24];
  if (v11)
  {
    v12 = sub_10003F34C(v11);
    v13 = v12;
    if (v12)
    {
      v14 = v12[1];
      if (*(_BYTE *)v14 == 1)
        *(_WORD *)(v14 + 2) = 0;
    }
  }
  else
  {
    v13 = 0;
  }
  v16 = a1[25];
  if (v16)
  {
    v17 = sub_10003F34C(v16);
    v18 = v17;
    if (v17)
    {
      v19 = v17[1];
      if (*(_BYTE *)v19 == 1)
        *(_WORD *)(v19 + 2) = 0;
    }
    if (!v13)
      goto LABEL_45;
LABEL_35:
    v20 = (uint64_t *)a2[35];
    if (v20)
    {
      v21 = *v13;
      v22 = *v20;
      if (*v13 == *v20)
      {
        v23 = memcmp((const void *)v13[1], (const void *)v20[1], *v13);
        if (v18)
        {
          if (!v23)
          {
            v24 = a2[36];
            if (v24)
            {
              if (*v18 == *(_QWORD *)v24 && !memcmp((const void *)v18[1], *(const void **)(v24 + 8), *v18))
                goto LABEL_85;
            }
          }
        }
      }
      v25 = (_QWORD *)a1[24];
      if (v25)
      {
        if (*v25 == v22 && !memcmp((const void *)v13[1], (const void *)v20[1], v21))
        {
          v41 = a1[25];
          if (v41)
          {
            v42 = a2[25];
            if (v42)
            {
              if (*(_QWORD *)v41 == *(_QWORD *)v42
                && !memcmp(*(const void **)(v41 + 8), *(const void **)(v42 + 8), *(_QWORD *)v41))
              {
                sub_10003F318(v13);
                v15 = 0;
                if (!v18)
                  return v15;
                goto LABEL_53;
              }
            }
          }
        }
      }
    }
    goto LABEL_45;
  }
  v18 = 0;
  if (v13)
    goto LABEL_35;
LABEL_45:
  if (v18)
  {
    v26 = a1[24];
    if (v26)
    {
      v27 = a2[24];
      if (v27)
      {
        if (*(_QWORD *)v26 == *(_QWORD *)v27
          && !memcmp(*(const void **)(v26 + 8), *(const void **)(v27 + 8), *(_QWORD *)v26))
        {
          v39 = (_QWORD *)a1[25];
          if (v39)
          {
            v40 = a2[36];
            if (v40)
            {
              if (*v39 == *(_QWORD *)v40 && !memcmp((const void *)v18[1], *(const void **)(v40 + 8), *v18))
              {
                if (!v13)
                {
LABEL_86:
                  v15 = 0;
LABEL_53:
                  sub_10003F318(v18);
                  return v15;
                }
LABEL_85:
                sub_10003F318(v13);
                goto LABEL_86;
              }
            }
          }
        }
      }
    }
  }
  if (v13)
    sub_10003F318(v13);
  v15 = 0xFFFFFFFFLL;
  if (v18)
    goto LABEL_53;
  return v15;
}

BOOL sub_10004E00C(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  _BOOL8 result;

  v1 = *(_QWORD *)(a1 + 8);
  if (*(_BYTE *)v1 == 1 && !*(_WORD *)(v1 + 2))
    return 1;
  if (dword_10008BA20)
  {
    v2 = ne_log_obj(a1);
    result = os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG);
    if (!result)
      return result;
    sub_100067F7C((unsigned __int8 *)v1, v2);
  }
  return 0;
}

uint64_t sub_10004E078(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  NSObject *v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t result;
  uint64_t v16;
  _QWORD *v17;
  uint8_t v18[4];
  uint64_t v19;

  v1 = *(_QWORD *)(a1 + 272);
  if (!v1)
    return 0xFFFFFFFFLL;
  if ((*(_WORD *)(v1 + 264) & 0x400) == 0)
    return 0xFFFFFFFFLL;
  v3 = *(_QWORD *)(a1 + 192);
  if (!v3)
    return 0xFFFFFFFFLL;
  v4 = *(_QWORD *)(a1 + 200);
  if (!v4)
    return 0xFFFFFFFFLL;
  v5 = sub_10004E28C(v3, v4);
  v6 = v5;
  if (dword_10008BA20)
  {
    v7 = ne_log_obj(v5);
    v5 = os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG);
    if ((_DWORD)v5)
      sub_100068138();
  }
  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 272) + 1704);
  if (!v8)
    return 0xFFFFFFFFLL;
  while (1)
  {
    if (v8 == a1 || (*(_BYTE *)(v8 + 264) & 2) != 0 || (*(_BYTE *)(v8 + 57) & 0x60) == 0 || !*(_QWORD *)(v8 + 112))
      goto LABEL_17;
    if (dword_10008BA20)
    {
      v9 = ne_log_obj(v5);
      v5 = os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)v5)
        break;
    }
    if (v6)
      goto LABEL_20;
LABEL_16:
    v5 = sub_10004DC0C((_QWORD *)a1, (_QWORD *)v8);
    if (!(_DWORD)v5)
      goto LABEL_20;
LABEL_17:
    v8 = *(_QWORD *)(v8 + 296);
    if (!v8)
      return 0xFFFFFFFFLL;
  }
  sub_1000680F4(v18, &v19, v9);
  if (!v6)
    goto LABEL_16;
LABEL_20:
  if (dword_10008BA20)
  {
    v10 = ne_log_obj(v5);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      sub_100068080(v10, v11, v12);
  }
  v13 = *(_QWORD *)(v8 + 112);
  *(_QWORD *)(a1 + 112) = v13;
  if (v13)
    v13 = sub_10003A2BC(v13);
  if (*(_DWORD *)(a1 + 52))
  {
    if (dword_10008BA20)
    {
      v14 = ne_log_obj(v13);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
        sub_100068010();
    }
  }
  else
  {
    *(_DWORD *)(a1 + 52) = *(_DWORD *)(v8 + 52);
  }
  v16 = *(_QWORD *)(v8 + 280);
  if (v16)
  {
    if (*(_QWORD *)(a1 + 280))
    {
      sub_10003F318(*(_QWORD **)(a1 + 280));
      v16 = *(_QWORD *)(v8 + 280);
    }
    *(_QWORD *)(a1 + 280) = sub_10003F34C(v16);
  }
  result = *(_QWORD *)(v8 + 288);
  if (result)
  {
    if (*(_QWORD *)(a1 + 288))
    {
      sub_10003F318(*(_QWORD **)(a1 + 288));
      result = *(_QWORD *)(v8 + 288);
    }
    v17 = sub_10003F34C(result);
    result = 0;
    *(_QWORD *)(a1 + 288) = v17;
  }
  return result;
}

BOOL sub_10004E28C(uint64_t a1, uint64_t a2)
{
  return sub_10004F070(a1) && sub_10004F070(a2);
}

uint64_t sub_10004E2C8(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  NSObject *v7;
  uint64_t v8;
  NSObject *v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  NSObject *v16;
  uint64_t result;
  uint8_t v18[4];
  uint64_t v19;

  v1 = *(_QWORD *)(a1 + 272);
  if (!v1)
    return 0xFFFFFFFFLL;
  if ((*(_WORD *)(v1 + 264) & 0x400) == 0)
    return 0xFFFFFFFFLL;
  v3 = *(_QWORD *)(a1 + 192);
  if (!v3)
    return 0xFFFFFFFFLL;
  v4 = *(_QWORD *)(a1 + 200);
  if (!v4)
    return 0xFFFFFFFFLL;
  v5 = sub_10004E28C(v3, v4);
  v6 = v5;
  if (dword_10008BA20)
  {
    v7 = ne_log_obj(v5);
    v5 = os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG);
    if ((_DWORD)v5)
      sub_1000682CC();
  }
  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 272) + 1704);
  if (!v8)
    return 0xFFFFFFFFLL;
  while (1)
  {
    if (v8 == a1 || (*(_BYTE *)(v8 + 264) & 2) != 0 || (*(_BYTE *)(v8 + 57) & 0x60) == 0 || !*(_QWORD *)(v8 + 128))
      goto LABEL_17;
    if (dword_10008BA20)
    {
      v9 = ne_log_obj(v5);
      v5 = os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)v5)
        break;
    }
    if (v6)
      goto LABEL_20;
LABEL_16:
    v5 = sub_10004DC0C((_QWORD *)a1, (_QWORD *)v8);
    if (!(_DWORD)v5)
      goto LABEL_20;
LABEL_17:
    v8 = *(_QWORD *)(v8 + 296);
    if (!v8)
      return 0xFFFFFFFFLL;
  }
  sub_100068288(v18, &v19, v9);
  if (!v6)
    goto LABEL_16;
LABEL_20:
  if (dword_10008BA20)
  {
    v10 = ne_log_obj(v5);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      sub_100068214(v10, v11, v12);
  }
  v13 = sub_100037EF8(*(_QWORD *)(v8 + 128), 1);
  v15 = *(_DWORD *)(a1 + 52);
  v14 = a1 + 52;
  *(_QWORD *)(v14 + 68) = v13;
  if (v15)
  {
    if (!dword_10008BA20)
      return 0;
    v16 = ne_log_obj(v13);
    result = os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG);
    if ((_DWORD)result)
    {
      sub_1000681A4();
      return 0;
    }
  }
  else
  {
    result = 0;
    *(_DWORD *)v14 = *(_DWORD *)(v8 + 52);
  }
  return result;
}

uint64_t sub_10004E490(uint64_t result)
{
  uint64_t v1;
  _DWORD *v2;

  v1 = *(_QWORD *)(result + 440);
  if (v1)
  {
    v2 = *(_DWORD **)(result + 88);
    if (v2)
      LODWORD(v2) = *v2;
    *(_DWORD *)(v1 + 288) = (_DWORD)v2;
  }
  return result;
}

uint64_t sub_10004E4AC(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 440);
  if (v1)
    return *(unsigned int *)(v1 + 288);
  else
    return 0;
}

uint64_t sub_10004E4C4(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  time_t v7;
  time_t v8;
  NSObject *v9;
  _DWORD v11[2];

  if (a1)
  {
    if ((*(_WORD *)(a1 + 264) & 0x10) != 0)
    {
      if (*(_QWORD *)(a1 + 272) && *(_DWORD *)(a1 + 368) && *(_DWORD *)(a1 + 372))
      {
        v7 = time(0) - *(_QWORD *)(a1 + 272);
        v8 = 2 * *(_DWORD *)(a1 + 368);
        if (v7 > v8)
        {
          if (dword_10008BA20)
          {
            v9 = ne_log_obj();
            if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
            {
              v11[0] = 67109120;
              v11[1] = a2;
              _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "btmm session is idle: drop ph%drekey.\n", (uint8_t *)v11, 8u);
            }
          }
        }
        if (v7 > v8)
          return 1;
      }
    }
    else if (a2 == 1)
    {
      v4 = *(_QWORD *)(a1 + 1704);
      if (v4)
      {
        v5 = *(_QWORD *)(a1 + 1704);
        while ((*(_BYTE *)(v5 + 264) & 2) != 0 || (*(_BYTE *)(v5 + 57) & 0x10) == 0)
        {
          v5 = *(_QWORD *)(v5 + 296);
          if (!v5)
          {
            while ((*(_BYTE *)(v4 + 264) & 2) != 0 || (*(_BYTE *)(v4 + 57) & 0x20) == 0)
            {
              v4 = *(_QWORD *)(v4 + 296);
              if (!v4)
                goto LABEL_12;
            }
            return 0;
          }
        }
        return 0;
      }
LABEL_12:
      if (dword_10008BA20)
      {
        v6 = ne_log_obj();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v11[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "vpn session is idle: drop ph1 rekey.\n", (uint8_t *)v11, 2u);
        }
      }
      return 1;
    }
  }
  return 0;
}

void sub_10004E66C(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  char v3;
  uint64_t v4;
  NSObject *v5;
  NSObject *v6;
  const char *v7;
  NSObject *v8;
  NSObject *v9;
  const char *v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint8_t v19[16];

  v1 = qword_10008C6D0;
  while (v1)
  {
    v2 = v1;
    v1 = *(_QWORD *)(v1 + 1712);
    v3 = *(_BYTE *)(v2 + 280);
    if ((v3 & 2) != 0)
    {
      if (!dword_10008BA20)
        continue;
      v8 = ne_log_obj(a1);
      a1 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
      if (!(_DWORD)a1)
        continue;
      *(_WORD *)v19 = 0;
      v9 = v8;
      v10 = "skipping sweep of dying session.\n";
      goto LABEL_24;
    }
    v4 = *(unsigned int *)(v2 + 1692);
    if ((_DWORD)v4)
    {
      v4 = sub_10003A6F0(v4);
      *(_DWORD *)(v2 + 1692) = 0;
      v3 = *(_BYTE *)(v2 + 280);
    }
    if ((v3 & 4) != 0)
    {
      v11 = *(unsigned int *)(v2 + 380);
      if ((_DWORD)v11)
      {
        sub_10003A6F0(v11);
        *(_DWORD *)(v2 + 380) = 0;
      }
      a1 = *(unsigned int *)(v2 + 384);
      if ((_DWORD)a1)
      {
        a1 = sub_10003A6F0(a1);
        *(_DWORD *)(v2 + 384) = 0;
      }
      if (!dword_10008BA20)
        continue;
      v12 = ne_log_obj(a1);
      a1 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
      if (!(_DWORD)a1)
        continue;
      *(_WORD *)v19 = 0;
      v9 = v12;
      v10 = "skipping sweep of asserted session.\n";
LABEL_24:
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v10, v19, 2u);
      continue;
    }
    if ((*(_WORD *)(v2 + 264) & 0x20) != 0 || *(_QWORD *)(v2 + 336) || *(_DWORD *)(v2 + 344))
    {
      if (!dword_10008BA20)
        goto LABEL_13;
      v5 = ne_log_obj(v4);
      if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        goto LABEL_13;
      *(_WORD *)v19 = 0;
      v6 = v5;
      v7 = "sweeping stopped session.\n";
    }
    else
    {
      v13 = *(_QWORD *)(v2 + 1696);
      if (v13)
      {
        while ((*(_BYTE *)(v13 + 432) & 2) != 0 || (*(_BYTE *)(v13 + 17) & 0x20) == 0)
        {
          v13 = *(_QWORD *)(v13 + 456);
          if (!v13)
            goto LABEL_31;
        }
        goto LABEL_38;
      }
LABEL_31:
      v14 = *(_QWORD *)(v2 + 1704);
      if (v14)
      {
        while ((*(_BYTE *)(v14 + 264) & 2) != 0 || (*(_BYTE *)(v14 + 57) & 0x20) == 0)
        {
          v14 = *(_QWORD *)(v14 + 296);
          if (!v14)
            goto LABEL_35;
        }
LABEL_38:
        v16 = *(_DWORD *)(v2 + 380);
        if (v16)
        {
          *(_QWORD *)v19 = 0;
          if (sub_10003A6A0(v16, v19))
          {
            if (*(uint64_t *)v19 <= qword_10008C6F0)
            {
              v17 = *(unsigned int *)(v2 + 380);
              if ((_DWORD)v17)
              {
                sub_10003A6F0(v17);
                *(_DWORD *)(v2 + 380) = 0;
              }
              if ((*(_BYTE *)(v2 + 280) & 2) == 0)
              {
                v18 = *(int *)(v2 + 368);
                if ((_DWORD)v18)
                  *(_DWORD *)(v2 + 380) = sub_10003A520(v18, (uint64_t)sub_10004E94C, v2);
              }
            }
          }
        }
        a1 = *(unsigned int *)(v2 + 384);
        if ((_DWORD)a1)
        {
          *(_QWORD *)v19 = 0;
          a1 = sub_10003A6A0(a1, v19);
          if ((_DWORD)a1)
          {
            if (*(uint64_t *)v19 <= qword_10008C6F0)
            {
              a1 = *(unsigned int *)(v2 + 384);
              if ((_DWORD)a1)
              {
                a1 = sub_10003A6F0(a1);
                *(_DWORD *)(v2 + 384) = 0;
              }
              if ((*(_BYTE *)(v2 + 280) & 2) == 0)
              {
                a1 = *(int *)(v2 + 372);
                if ((_DWORD)a1)
                {
                  a1 = (uint64_t)sub_10003A520(a1, (uint64_t)sub_10004EAF8, v2);
                  *(_DWORD *)(v2 + 384) = a1;
                }
              }
            }
          }
        }
        continue;
      }
LABEL_35:
      if (!dword_10008BA20)
        goto LABEL_13;
      v15 = ne_log_obj(v4);
      if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        goto LABEL_13;
      *(_WORD *)v19 = 0;
      v6 = v15;
      v7 = "session died while sleeping.\n";
    }
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v7, v19, 2u);
LABEL_13:
    a1 = sub_10004D698(v2, off_100088518[0]);
  }
}

void sub_10004E94C(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  NSObject *v14;
  int v15;
  const char *v16;

  if (a1 && (*(_WORD *)(a1 + 264) & 0x21) == 1 && !*(_QWORD *)(a1 + 336) && !*(_DWORD *)(a1 + 344))
  {
    v10 = *(unsigned int *)(a1 + 380);
    if ((_DWORD)v10)
    {
      sub_10003A6F0(v10);
      *(_DWORD *)(a1 + 380) = 0;
    }
    v11 = sub_10003096C(a1);
    if ((v11 & 0x80000000) != 0)
    {
      if (dword_10008BA20)
      {
        v12 = ne_log_obj(v11);
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          v15 = 136315138;
          v16 = "ike_session_traffic_cop";
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "pk_sendget_inbound_sastats failed in %s.\n", (uint8_t *)&v15, 0xCu);
        }
      }
    }
    v13 = sub_100030A84(a1);
    if ((v13 & 0x80000000) != 0)
    {
      if (dword_10008BA20)
      {
        v14 = ne_log_obj(v13);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          v15 = 136315138;
          v16 = "ike_session_traffic_cop";
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "pk_sendget_outbound_sastats failed in %s.\n", (uint8_t *)&v15, 0xCu);
        }
      }
    }
    *(_DWORD *)(a1 + 380) = sub_10003A520(*(int *)(a1 + 368), (uint64_t)sub_10004E94C, a1);
  }
  else if (dword_10008BA20)
  {
    v2 = ne_log_obj(a1);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_100068338(v2, v3, v4, v5, v6, v7, v8, v9);
  }
}

uint64_t sub_10004EAF8(uint64_t a1)
{
  return sub_10004D698(a1, off_100088508[0]);
}

uint64_t sub_10004EB04(uint64_t a1)
{
  int *v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int *i;
  NSObject *v9;
  int *v10;
  unsigned __int8 *v11;
  const sockaddr *v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  const sockaddr *v16;
  char *v17;
  int v18;
  char v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  NSObject *v25;
  __int128 *v26;
  _QWORD *v27;
  _QWORD *v28;
  uint64_t result;
  NSObject *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint8_t buf[4];
  void *v40;

  v1 = &dword_10008BA20;
  if (!a1 || (*(_BYTE *)(a1 + 280) & 2) != 0)
  {
    if (dword_10008BA20)
    {
      v30 = ne_log_obj(a1);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        sub_1000683A8(v30, v31, v32, v33, v34, v35, v36, v37);
    }
    return 0xFFFFFFFFLL;
  }
  else
  {
    v2 = *(_QWORD *)(a1 + 1704);
    while (v2)
    {
      v3 = v2;
      v2 = *(_QWORD *)(v2 + 296);
      v4 = *(_BYTE *)(v3 + 264);
      if ((v4 & 2) == 0)
      {
        v5 = *(_DWORD *)(v3 + 56);
        if ((v5 & 0x4000) == 0)
        {
          v6 = *(unsigned int *)(v3 + 64);
          if ((_DWORD)v6)
          {
            v6 = sub_10003A6F0(v6);
            *(_DWORD *)(v3 + 64) = 0;
            v4 = *(_BYTE *)(v3 + 264);
            v5 = *(_DWORD *)(v3 + 56);
          }
          *(_BYTE *)(v3 + 264) = v4 | 2;
          if ((v5 & 0x2000) != 0)
          {
            v7 = *(_QWORD *)(v3 + 128);
            if (v7)
            {
              for (i = *(unsigned int **)(v7 + 32); i; i = (unsigned int *)*((_QWORD *)i + 9))
              {
                if (i[14])
                {
                  if (*v1)
                  {
                    v9 = ne_log_obj(v6);
                    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
                    {
                      v10 = v1;
                      v11 = *(unsigned __int8 **)v3;
                      v12 = *(const sockaddr **)(v3 + 8);
                      v13 = *(unsigned __int8 *)(v3 + 104);
                      v14 = *(_DWORD *)(v3 + 52);
                      v15 = sub_10002F08C(i[4]);
                      v16 = (const sockaddr *)v11;
                      v1 = v10;
                      v17 = sub_10002FA64(v16, v12, v13, v14, v15);
                      *(_DWORD *)buf = 136315138;
                      v40 = v17;
                      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Assert: Phase 2 %s deleted\n", buf, 0xCu);
                    }
                  }
                  v18 = *(_DWORD *)(qword_10008B848 + 32);
                  v19 = sub_10002EFA4(*i);
                  v20 = sub_10002F08C(i[4]);
                  v6 = sub_100040B7C(v18, v19, v20, *(unsigned __int8 **)v3, *(unsigned __int8 **)(v3 + 8), i[7]);
                }
              }
            }
          }
          sub_100003774((int *)(v3 + 56), 18432);
          *(_DWORD *)(v3 + 64) = sub_10003A520(3, (uint64_t)sub_10004CA40, v3);
        }
      }
    }
    v21 = *(_QWORD *)(a1 + 1696);
    while (v21)
    {
      v22 = v21;
      v21 = *(_QWORD *)(v21 + 456);
      if ((*(_BYTE *)(v22 + 432) & 2) == 0 && (*(_BYTE *)(v22 + 17) & 0x40) == 0)
      {
        v23 = *(unsigned int *)(v22 + 112);
        if ((_DWORD)v23)
        {
          sub_10003A6F0(v23);
          *(_DWORD *)(v22 + 112) = 0;
        }
        v24 = *(unsigned int *)(v22 + 116);
        if ((_DWORD)v24)
        {
          v24 = sub_10003A6F0(v24);
          *(_DWORD *)(v22 + 116) = 0;
        }
        *(_BYTE *)(v22 + 432) |= 2u;
        if (*v1)
        {
          v25 = ne_log_obj(v24);
          if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
          {
            v26 = sub_100023E84(v22, 0);
            *(_DWORD *)buf = 136315138;
            v40 = v26;
            _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Assert: Phase 1 %s deleted\n", buf, 0xCu);
          }
        }
        v27 = *(_QWORD **)(v22 + 448);
        if (v27)
        {
          do
          {
            v28 = (_QWORD *)v27[39];
            if (v27[32])
            {
              v27[32] = 0;
              if (v28)
                v28[40] = v27[40];
              *(_QWORD *)v27[40] = v28;
            }
            v27 = v28;
          }
          while (v28);
        }
        sub_100003774((int *)(v22 + 16), 17408);
        *(_DWORD *)(v22 + 112) = sub_10003A520(5, (uint64_t)sub_10004C460, v22);
      }
    }
    result = 0;
    *(_BYTE *)(a1 + 280) |= 4u;
  }
  return result;
}

uint64_t sub_10004EE44(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (a1 && a2)
  {
    v2 = sub_10004ABA4(a1, a2, 0, 0);
    if (v2)
      return sub_10004EB04(v2);
  }
  else if (dword_10008BA20)
  {
    v4 = ne_log_obj(a1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      sub_100068418(v4, v5, v6, v7, v8, v9, v10, v11);
  }
  return 0xFFFFFFFFLL;
}

void sub_10004EEB4(uint64_t a1)
{
  uint64_t v2;
  int v3;
  _BOOL8 v4;
  uint64_t v5;
  NSObject *v6;
  uint8_t v7[16];

  if ((*(_BYTE *)(a1 + 264) & 3) == 1)
  {
    v2 = *(_QWORD *)(a1 + 256);
    if (v2)
    {
      v3 = *(_DWORD *)(v2 + 116);
      if (v3)
      {
        v4 = sub_10003A65C(v3);
        if (!v4 && !*(_BYTE *)(a1 + 60))
        {
          v5 = *(_QWORD *)(a1 + 272);
          if (v5)
          {
            if ((*(_WORD *)(v5 + 264) & 0x404) == 0x400
              && *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 256) + 64) + 200) - *(_DWORD *)(a1 + 72) == 3)
            {
              if (dword_10008BA20)
              {
                v6 = ne_log_obj(v4);
                if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)v7 = 0;
                  _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Many Phase 2 retransmits: try Phase 1 rekey and this Phase 2 to quit earlier.\n", v7, 2u);
                }
              }
              sub_100024B1C(*(_QWORD *)(a1 + 256), 1);
              *(_DWORD *)(a1 + 72) = 0;
            }
          }
        }
      }
    }
  }
}

void sub_10004EF9C(uint64_t a1)
{
  uint64_t v2;
  _BOOL8 v3;
  NSObject *v4;
  uint8_t v5[16];

  if ((*(_BYTE *)(a1 + 432) & 3) == 1
    && !*(_DWORD *)(a1 + 116)
    && (*(_BYTE *)(a1 + 17) & 0x10) != 0
    && !*(_DWORD *)(a1 + 20))
  {
    v2 = *(_QWORD *)(a1 + 440);
    if (v2)
    {
      if ((*(_WORD *)(v2 + 264) & 0x400) != 0)
      {
        v3 = sub_10004BE30(v2, a1);
        if (!v3 && *(_DWORD *)(*(_QWORD *)(a1 + 64) + 200) - *(_DWORD *)(a1 + 124) == 3)
        {
          if (dword_10008BA20)
          {
            v4 = ne_log_obj(v3);
            if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)v5 = 0;
              _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Many Phase 1 retransmits: try quit earlier.\n", v5, 2u);
            }
          }
          *(_DWORD *)(a1 + 124) = 0;
        }
      }
    }
  }
}

BOOL sub_10004F070(uint64_t a1)
{
  unsigned __int8 *v1;
  int v2;
  NSObject *v3;
  _BOOL8 result;

  v1 = *(unsigned __int8 **)(a1 + 8);
  v2 = *v1;
  if (v2 == 4)
  {
    if (*((_DWORD *)v1 + 2))
      goto LABEL_6;
  }
  else if (v2 != 1)
  {
    goto LABEL_6;
  }
  if (!*((_DWORD *)v1 + 1))
    return 1;
LABEL_6:
  if (dword_10008BA20)
  {
    v3 = ne_log_obj(a1);
    result = os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG);
    if (!result)
      return result;
    sub_100068488(v1, v3);
  }
  return 0;
}

uint64_t sub_10004F104()
{
  uint64_t v0;
  NSObject *v2;

  v0 = IORegisterForSystemPower(0, (IONotificationPortRef *)&qword_10008C708, (IOServiceInterestCallback)sub_10004F198, dword_10008C700);
  dword_10008C6FC = v0;
  if ((_DWORD)v0)
  {
    IONotificationPortSetDispatchQueue((IONotificationPortRef)qword_10008C708, (dispatch_queue_t)&_dispatch_main_q);
    return 0;
  }
  else
  {
    if (dword_10008BA20)
    {
      v2 = ne_log_obj(v0);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
        sub_100068528();
    }
    return 0xFFFFFFFFLL;
  }
}

void sub_10004F198(uint64_t a1, int a2, int a3, intptr_t notificationID)
{
  unint64_t v5;
  time_t v7;
  NSObject *v8;
  NSObject *v9;
  NSObject *v10;
  time_t v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;

  HIDWORD(v5) = a3;
  LODWORD(v5) = a3 + 536870288;
  switch((v5 >> 4))
  {
    case 0u:
      goto LABEL_5;
    case 1u:
      byte_10008B284 = 1;
      v7 = sub_10003A630();
      *(_QWORD *)&xmmword_10008C6E0 = v7;
      if (dword_10008BA20)
      {
        v8 = ne_log_obj(v7);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
          sub_1000685D0();
      }
LABEL_5:
      IOAllowPowerChange(dword_10008C6FC, notificationID);
      break;
    case 2u:
      if (dword_10008BA20)
      {
        v9 = ne_log_obj(a1);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
          sub_1000685FC();
      }
      byte_10008B284 = 0;
      *(_QWORD *)&xmmword_10008C6E0 = 0;
      break;
    case 9u:
      v11 = sub_10003A630();
      *((_QWORD *)&xmmword_10008C6E0 + 1) = v11;
      if ((_QWORD)xmmword_10008C6E0)
      {
        if (dword_10008BA20)
        {
          v12 = ne_log_obj(v11);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
            sub_1000686AC();
        }
      }
      else if (dword_10008BA20)
      {
        v15 = ne_log_obj(v11);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
          sub_100068680();
      }
      break;
    case 0xBu:
      if (byte_10008B284 == 1)
      {
        if (dword_10008BA20)
        {
          v13 = ne_log_obj(a1);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
            sub_100068628();
        }
        byte_10008B284 = 0;
      }
      else if (dword_10008BA20)
      {
        v14 = ne_log_obj(a1);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
          sub_100068654();
      }
      break;
    default:
      if (dword_10008BA20)
      {
        v10 = ne_log_obj(a1);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
          sub_100068560(a3, v10);
      }
      break;
  }
  dispatch_async_f((dispatch_queue_t)&_dispatch_main_q, &unk_10008C6F8, (dispatch_function_t)sub_10004F3D4);
}

void sub_10004F3B0()
{
  IODeregisterForSystemPower(dword_10008C700);
  IONotificationPortDestroy((IONotificationPortRef)qword_10008C708);
}

void sub_10004F3D4(uint64_t a1)
{
  BOOL v1;
  NSObject *v2;
  NSObject *v3;

  if ((_QWORD)xmmword_10008C6E0)
    v1 = *((_QWORD *)&xmmword_10008C6E0 + 1) == 0;
  else
    v1 = 1;
  if (v1)
  {
    if (!*((_QWORD *)&xmmword_10008C6E0 + 1))
      return;
    if (dword_10008BA20)
    {
      v2 = ne_log_obj(a1);
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
        sub_100068704();
    }
  }
  else
  {
    if (dword_10008BA20)
    {
      v3 = ne_log_obj(a1);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
        sub_1000686D8();
    }
    qword_10008C6F0 = sub_10003A630();
    sub_10000A50C(qword_10008C6F0);
    *(_QWORD *)&xmmword_10008C6E0 = 0;
  }
  *((_QWORD *)&xmmword_10008C6E0 + 1) = 0;
}

void sub_10004F48C()
{
  const __SCPreferences *v0;

  if (!qword_10008C710)
  {
    v0 = SCPreferencesCreate(0, CFSTR("racoon"), CFSTR("com.apple.ipsec.plist"));
    qword_10008C710 = (uint64_t)v0;
    if (v0)
    {
      if (SCPreferencesSetCallback(v0, (SCPreferencesCallBack)sub_10004F500, &stru_10008B288))
      {
        if (!SCPreferencesSetDispatchQueue((SCPreferencesRef)qword_10008C710, (dispatch_queue_t)&_dispatch_main_q))
          sub_100068730();
      }
    }
  }
}

void sub_10004F500(uint64_t a1, char a2)
{
  if ((a2 & 2) != 0)
    sub_1000341B0();
}

const __CFDictionary *sub_10004F50C(const __CFDictionary *result)
{
  const __CFDictionary *v1;
  int v2;
  int v3;
  const void *v4;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v6;
  int valuePtr;
  unsigned int v8;

  if (result)
  {
    v1 = result;
    valuePtr = 0;
    result = (const __CFDictionary *)CFDictionaryGetValue(result, CFSTR("IKEVersion"));
    if (result)
    {
      CFNumberGetValue(result, kCFNumberIntType, &valuePtr);
      if (valuePtr != 1)
        return 0;
      result = (const __CFDictionary *)CFDictionaryContainsKey(v1, CFSTR("ReparseConfFile"));
      if ((_DWORD)result)
      {
        result = (const __CFDictionary *)CFDictionaryGetValue(v1, CFSTR("ReparseConfFile"));
        if (result)
        {
          result = (const __CFDictionary *)CFBooleanGetValue(result);
          if ((_DWORD)result)
          {
            sub_100052680(30);
            *(_QWORD *)(qword_10008B848 + 80) = 17;
            if (!qword_10008B2B0)
              qword_10008B2B0 = (uint64_t)CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            v2 = dword_100088530;
            v3 = (dword_100088530 + 1) > 1 ? dword_100088530 + 1 : 1;
            dword_100088530 = v3;
            v8 = v2;
            result = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v8);
            if (result)
            {
              v4 = result;
              Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, 0);
              if (Mutable)
              {
                v6 = Mutable;
                CFDictionaryAddValue((CFMutableDictionaryRef)qword_10008B2B0, v4, Mutable);
                CFRelease(v6);
                CFRelease(v4);
                return (const __CFDictionary *)v8;
              }
              CFRelease(v4);
              return 0;
            }
          }
        }
      }
    }
  }
  return result;
}

CFNumberRef sub_10004F67C(int a1)
{
  CFNumberRef result;
  const void *v3;
  int valuePtr;

  result = 0;
  valuePtr = a1;
  if (a1)
  {
    if (qword_10008B2B0)
    {
      result = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
      if (result)
      {
        v3 = result;
        if (CFDictionaryContainsKey((CFDictionaryRef)qword_10008B2B0, result))
          CFDictionaryRemoveValue((CFMutableDictionaryRef)qword_10008B2B0, v3);
        CFRelease(v3);
        if (!qword_10008B2B0 || !CFDictionaryGetCount((CFDictionaryRef)qword_10008B2B0))
          sub_10003AEAC();
        return (CFNumberRef)1;
      }
    }
  }
  return result;
}

uint64_t sub_10004F714()
{
  uint64_t result;

  result = qword_10008B2B0;
  if (qword_10008B2B0)
    return CFDictionaryGetCount((CFDictionaryRef)qword_10008B2B0) != 0;
  return result;
}

void sub_10004F73C()
{
  _xpc_connection_s *mach_service;
  _QWORD handler[5];

  qword_10008C718 = 0;
  qword_10008C720 = (uint64_t)&qword_10008C718;
  if (qword_10008B2B8 != -1)
    dispatch_once(&qword_10008B2B8, &stru_100086C90);
  mach_service = xpc_connection_create_mach_service("com.apple.SecureNetworking.IPSec", (dispatch_queue_t)qword_10008B2C0, 1uLL);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 0x40000000;
  handler[2] = sub_10004F7EC;
  handler[3] = &unk_100086C50;
  handler[4] = mach_service;
  xpc_connection_set_event_handler(mach_service, handler);
  xpc_connection_resume(mach_service);
}

void sub_10004F7EC(uint64_t a1, xpc_object_t object)
{
  xpc_type_t type;
  int v5;
  NSObject *v6;
  NSObject *v7;
  const char *string;
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  uint64_t *v12;
  NSObject *v13;
  _QWORD handler[5];

  type = xpc_get_type(object);
  if (type == (xpc_type_t)&_xpc_type_connection)
  {
    if (qword_10008B2B8 != -1)
      dispatch_once(&qword_10008B2B8, &stru_100086C90);
    xpc_connection_set_target_queue((xpc_connection_t)object, (dispatch_queue_t)qword_10008B2C0);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 0x40000000;
    handler[2] = sub_10004FA80;
    handler[3] = &unk_100086CB0;
    handler[4] = object;
    xpc_connection_set_event_handler((xpc_connection_t)object, handler);
    xpc_connection_resume((xpc_connection_t)object);
  }
  else
  {
    v5 = (int)type;
    if (type == (xpc_type_t)&_xpc_type_error)
    {
      if (dword_10008BA20)
      {
        v7 = ne_log_obj(type);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
          sub_100068888();
      }
      string = xpc_dictionary_get_string(object, _xpc_error_key_description);
      v9 = (uint64_t)string;
      if (object == &_xpc_error_connection_invalid)
      {
        if (dword_10008BA20)
        {
          v11 = ne_log_obj(string);
          if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
            sub_100068748();
        }
        v12 = &qword_10008C718;
        do
          v12 = (uint64_t *)*v12;
        while (v12 && v12[2] != *(_QWORD *)(a1 + 32));
        sub_10004FA08((xpc_object_t *)v12);
        xpc_release(*(xpc_object_t *)(a1 + 32));
      }
      else if (object == &_xpc_error_connection_interrupted)
      {
        if (dword_10008BA20)
        {
          v13 = ne_log_obj(string);
          if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
            sub_1000687A8();
        }
      }
      else if (dword_10008BA20)
      {
        v10 = ne_log_obj(string);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
          sub_100068808((int)object, v9, v10);
      }
    }
    else if (dword_10008BA20)
    {
      v6 = ne_log_obj(type);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        sub_1000688B4(v5, v6);
    }
  }
}

void sub_10004FA08(xpc_object_t *a1)
{
  xpc_object_t v2;
  uint64_t *v3;

  if (a1)
  {
    xpc_release(a1[2]);
    v2 = *a1;
    v3 = &qword_10008C718;
    if (*a1)
      v3 = (uint64_t *)*a1;
    v3[1] = (uint64_t)a1[1];
    *(_QWORD *)a1[1] = v2;
    free(a1);
  }
}

void sub_10004FA58(id a1)
{
  qword_10008B2C0 = (uint64_t)dispatch_queue_create("com.apple.SecureNetworking.IPSec.server", 0);
}

void sub_10004FA80(uint64_t a1, xpc_object_t object)
{
  xpc_type_t type;
  NSObject *v5;
  int64_t int64;
  int64_t v7;
  int64_t v8;
  SecTaskRef v9;
  const void *v10;
  const __CFBoolean *v11;
  const __CFBoolean *v12;
  CFTypeID v13;
  CFTypeID TypeID;
  _BOOL4 v15;
  const char *string;
  NSObject *v17;
  uint64_t *v18;
  int64_t v19;
  int v20;
  uint64_t *v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  int v25;
  xpc_connection_t remote_connection;
  _xpc_connection_s *v27;
  xpc_object_t reply;
  void *v29;
  NSObject *v30;
  NSObject *v31;
  NSObject *v32;
  int v33;
  NSObject *v34;
  NSObject *v35;
  int64_t v36;
  xpc_connection_t v37;
  _xpc_connection_s *v38;
  xpc_object_t v39;
  void *v40;
  uint64_t *v41;
  NSObject *v42;
  const void *v43;
  NSObject *v44;
  xpc_connection_t v45;
  xpc_connection_t v46;
  int v47;
  _DWORD *v48;
  NSObject *v49;
  audit_token_t v50;
  audit_token_t *p_token;
  uint64_t *v52;
  const void *v53;
  uint64_t v54;
  uint64_t *v55;
  uint64_t v56;
  int v57;
  audit_token_t token;

  type = xpc_get_type(object);
  if (type != (xpc_type_t)&_xpc_type_dictionary)
  {
    if (type == (xpc_type_t)&_xpc_type_error)
    {
      string = xpc_dictionary_get_string(object, _xpc_error_key_description);
      if (dword_10008BA20)
      {
        v17 = ne_log_obj(string);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
          sub_100068B3C();
      }
      v18 = &qword_10008C718;
      do
        v18 = (uint64_t *)*v18;
      while (v18 && v18[2] != *(_QWORD *)(a1 + 32));
      sub_10004FA08((xpc_object_t *)v18);
    }
    else if (dword_10008BA20)
    {
      v5 = ne_log_obj(type);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
        sub_100068BA8();
    }
    return;
  }
  int64 = xpc_dictionary_get_int64(object, "ipsecopcode");
  v7 = xpc_dictionary_get_int64(object, "ipsecobjectref");
  v8 = v7;
  if (int64 == 5)
  {
    *(_QWORD *)token.val = 0;
    *(_QWORD *)&token.val[2] = &token;
    *(_QWORD *)&token.val[4] = 0x2000000000;
    LOBYTE(token.val[6]) = 0;
    v54 = 0;
    v55 = &v54;
    v56 = 0x2000000000;
    LOBYTE(v57) = 0;
    v19 = xpc_dictionary_get_int64(object, "ipsecikeid");
    v20 = v19;
    if ((_DWORD)v19)
    {
      *(_QWORD *)v50.val = _NSConcreteStackBlock;
      *(_QWORD *)&v50.val[2] = 0x40000000;
      *(_QWORD *)&v50.val[4] = sub_10005018C;
      *(_QWORD *)&v50.val[6] = &unk_100086D00;
      LODWORD(v53) = v19;
      p_token = &token;
      v52 = &v54;
      dispatch_sync((dispatch_queue_t)&_dispatch_main_q, &v50);
      v21 = &qword_10008C718;
      do
        v21 = (uint64_t *)*v21;
      while (v21 && *((_DWORD *)v21 + 8) != v20);
      sub_10004FA08((xpc_object_t *)v21);
    }
    else if (dword_10008BA20)
    {
      v24 = ne_log_obj(v19);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        sub_100068B10();
    }
    v25 = *(unsigned __int8 *)(*(_QWORD *)&token.val[2] + 24);
    remote_connection = xpc_dictionary_get_remote_connection(object);
    if (remote_connection)
    {
      v27 = remote_connection;
      reply = xpc_dictionary_create_reply(object);
      if (reply)
      {
        v29 = reply;
        xpc_dictionary_set_int64(reply, "ipsecobjectref", v8);
        xpc_dictionary_set_int64(v29, "ipsecopcode", 4101);
        xpc_dictionary_set_BOOL(v29, "reply", v25 != 0);
        xpc_connection_send_message(v27, v29);
        xpc_release(v29);
      }
      else if (dword_10008BA20)
      {
        v31 = ne_log_obj(0);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
          sub_100068AE4();
      }
    }
    else if (dword_10008BA20)
    {
      v30 = ne_log_obj(0);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        sub_100068AB8();
    }
    _Block_object_dispose(&v54, 8);
    _Block_object_dispose(&token, 8);
  }
  else
  {
    if (int64 == 1)
    {
      v54 = 0;
      v55 = &v54;
      v56 = 0x2000000000;
      v57 = 0;
      memset(&v50, 0, sizeof(v50));
      xpc_dictionary_get_audit_token(object, &v50);
      token = v50;
      v9 = SecTaskCreateWithAuditToken(0, &token);
      if (!v9)
      {
        if (dword_10008BA20)
        {
          v23 = ne_log_obj(0);
          v9 = (SecTaskRef)os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
          if ((_DWORD)v9)
            sub_1000689B0();
        }
        goto LABEL_53;
      }
      v10 = v9;
      v11 = (const __CFBoolean *)SecTaskCopyValueForEntitlement(v9, CFSTR("com.apple.private.SecureNetworking.ipsec_ike"), 0);
      if (v11)
      {
        v12 = v11;
        v13 = CFGetTypeID(v11);
        TypeID = CFBooleanGetTypeID();
        if (v13 == TypeID)
        {
          v15 = CFBooleanGetValue(v12) != 0;
        }
        else
        {
          if (dword_10008BA20)
          {
            v32 = ne_log_obj(TypeID);
            if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
              sub_100068A8C();
          }
          v15 = 0;
        }
        CFRelease(v12);
      }
      else
      {
        v15 = 0;
      }
      CFRelease(v10);
      v33 = dword_10008BA20;
      if (!v15 && dword_10008BA20)
      {
        v34 = ne_log_obj(v9);
        v9 = (SecTaskRef)os_log_type_enabled(v34, OS_LOG_TYPE_ERROR);
        if ((_DWORD)v9)
          sub_1000689DC();
LABEL_53:
        v33 = dword_10008BA20;
LABEL_54:
        if (v33)
        {
          v35 = ne_log_obj(v9);
          if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
            sub_100068984();
        }
        goto LABEL_57;
      }
      if (!v15)
        goto LABEL_54;
      if (!xpc_dictionary_get_value(object, "ipsecikedict"))
      {
        if (!dword_10008BA20)
        {
LABEL_57:
          v36 = *((int *)v55 + 6);
          _Block_object_dispose(&v54, 8);
          v37 = xpc_dictionary_get_remote_connection(object);
          if (v37)
          {
            v38 = v37;
            v39 = xpc_dictionary_create_reply(object);
            if (v39)
            {
              v40 = v39;
              xpc_dictionary_set_int64(v39, "ipsecikeid", v36);
              xpc_dictionary_set_int64(v40, "ipsecobjectref", v8);
              xpc_dictionary_set_int64(v40, "ipsecopcode", 4097);
              xpc_dictionary_set_BOOL(v40, "reply", (_DWORD)v36 != 0);
              xpc_connection_send_message(v38, v40);
              xpc_release(v40);
            }
          }
          return;
        }
        v49 = ne_log_obj(0);
        v9 = (SecTaskRef)os_log_type_enabled(v49, OS_LOG_TYPE_ERROR);
        if ((_DWORD)v9)
          sub_100068A08();
        goto LABEL_53;
      }
      v41 = (uint64_t *)_CFXPCCreateCFObjectFromXPCObject();
      if (!v41)
      {
        if (dword_10008BA20)
        {
          v42 = ne_log_obj(0);
          if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
            sub_100068A60();
        }
      }
      if (xpc_dictionary_get_value(object, "ipsecchilddict"))
      {
        v43 = (const void *)_CFXPCCreateCFObjectFromXPCObject();
        if (v43 || !dword_10008BA20)
          goto LABEL_73;
        v44 = ne_log_obj(0);
        if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
          sub_100068A34();
      }
      v43 = 0;
LABEL_73:
      *(_QWORD *)v50.val = _NSConcreteStackBlock;
      *(_QWORD *)&v50.val[2] = 0x40000000;
      *(_QWORD *)&v50.val[4] = sub_100050158;
      *(_QWORD *)&v50.val[6] = &unk_100086CD8;
      p_token = (audit_token_t *)&v54;
      v52 = v41;
      v53 = v43;
      dispatch_sync((dispatch_queue_t)&_dispatch_main_q, &v50);
      if (*((_DWORD *)v55 + 6))
      {
        v45 = xpc_dictionary_get_remote_connection(object);
        if (v45)
        {
          v46 = v45;
          v47 = *((_DWORD *)v55 + 6);
          v48 = malloc_type_malloc(0x28uLL, 0x10A0040954427F6uLL);
          v48[8] = v47;
          *((_QWORD *)v48 + 2) = v46;
          *((_QWORD *)v48 + 3) = v8;
          xpc_retain(v46);
          *(_QWORD *)v48 = 0;
          *((_QWORD *)v48 + 1) = qword_10008C720;
          *(_QWORD *)qword_10008C720 = v48;
          qword_10008C720 = (uint64_t)v48;
        }
      }
      if (v41)
        CFRelease(v41);
      if (v43)
        CFRelease(v43);
      goto LABEL_57;
    }
    if (dword_10008BA20)
    {
      v22 = ne_log_obj(v7);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        sub_100068924();
    }
  }
}

const __CFDictionary *sub_100050158(uint64_t a1)
{
  const __CFDictionary *result;

  result = sub_10004F50C(*(const __CFDictionary **)(a1 + 40));
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (_DWORD)result;
  return result;
}

CFNumberRef sub_10005018C(uint64_t a1)
{
  CFNumberRef result;

  result = sub_10004F67C(*(_DWORD *)(a1 + 48));
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = (_BYTE)result;
  return result;
}

uint64_t sub_1000501C8(uint64_t a1, uint64_t a2, uint64_t a3, __int16 *a4)
{
  int v4;
  char *v5;
  uint64_t v6;
  _BYTE *v7;
  char *v8;
  int *v9;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  void *v23;
  char *v24;
  uint64_t v25;
  int v26;
  void *v27;
  int v28;
  uint64_t v29;
  char *v30;
  __int128 *v31;
  int v32;
  unsigned int v33;
  uint64_t v34;
  const char *v35;
  uint64_t v36;
  const char *v37;
  unsigned int v38;
  unsigned int v39;
  _QWORD *v40;
  _QWORD *v41;
  void *v42;
  int v43;
  size_t v44;
  int v45;
  _BYTE *v46;
  int v47;
  uint64_t v48;
  uint64_t *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  char *v58;
  _QWORD *v59;
  uint64_t v60;
  _QWORD *v61;
  uint64_t v62;
  void *v63;
  int v64;
  unsigned int v65;
  _QWORD *v66;
  _QWORD *v67;
  int v68;
  _DWORD *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  _DWORD *v74;
  int v75;
  _QWORD *v76;
  _QWORD *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  int v81;
  void *v82;
  uint64_t v83;
  uint64_t v84;
  _QWORD *v85;
  _DWORD *v86;
  unsigned __int8 *v87;
  uint64_t v88;
  _DWORD *v89;
  _BYTE *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  unint64_t v101;
  uint64_t v102;
  uint64_t v103;
  void *v104;
  uint64_t v105;
  int v106;
  uint64_t v107;
  void *v108;
  int *v109;
  uint64_t v110;
  uint64_t v111;
  int v112;
  uint64_t v113;
  int v114;
  unsigned int v115;
  unsigned __int8 *v116;
  unsigned __int8 *v117;
  unsigned __int8 *v118;
  int v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t *v123;
  _QWORD *v124;
  _QWORD *v125;
  _QWORD *v126;
  NSObject *v127;
  NSObject *v128;
  NSObject *v129;
  unsigned int v130;
  unsigned int v131;
  uint64_t v132;
  int v133;
  NSObject *v134;
  uint64_t i;
  uint64_t v136;
  uint64_t v137;
  NSObject *v138;
  char *v139;
  const char *v140;
  char *v141;
  const char *v142;
  NSObject *v143;
  _DWORD *v144;
  uint64_t v145;
  int v146;
  int v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  const char *v152;
  uint64_t v153;
  NSObject *v154;
  int *v155;
  _QWORD *v156;
  uint64_t *v157;
  void *v158;
  NSObject *v159;
  int v160;
  uint64_t v161;
  int v162;
  NSObject *v163;
  NSObject *v165;
  NSObject *v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t *v169;
  int v170;
  int v171;
  int v172;
  uint64_t v173;
  unsigned int v174;
  int v175;
  unsigned int v176;
  unsigned int v177;
  _QWORD *v178;
  unsigned int v179;
  char *__src;
  uint8_t v181;
  char v182[15];
  char __str[14];
  const char *v184;
  __int16 v185;
  char *v186;
  __int16 v187;
  const char *v188;
  _BYTE v189[1600];
  _BYTE v190[400];
  _DWORD v191[7];
  char v192[10];

  v4 = 0;
  v5 = &byte_10008BE9C[356];
  dword_10008C738 = 0;
  __src = v189;
  dword_10008C728 = -2;
  v6 = 200;
  v7 = v190;
  v8 = v190;
  v9 = (int *)v189;
  while (1)
  {
    *(_WORD *)v8 = v4;
    if (&v7[2 * v6 - 2] <= v8)
    {
      if ((unint64_t)v6 >> 4 > 0x270
        || ((unint64_t)(2 * v6) >= 0x2710 ? (v6 = 10000) : (v6 *= 2),
            (v10 = (char *)malloc_type_malloc(10 * v6 + 7, 0xE0D4DFE4uLL)) == 0))
      {
        v151 = 2;
        v152 = "memory exhausted";
        goto LABEL_412;
      }
      v11 = v10;
      v12 = v5;
      v13 = (v8 - v7) >> 1;
      v14 = v13 + 1;
      memcpy(v10, v7, 2 * (v13 + 1));
      a1 = (uint64_t)memcpy(&v11[(2 * v6 + 7) & 0xFFFFFFFFFFFFFFF8], __src, 8 * (v13 + 1));
      if (v7 != v190)
        free(v7);
      if (v6 <= v14)
      {
        v151 = 1;
LABEL_414:
        if (v11 != v190)
          free(v11);
        return v151;
      }
      v8 = &v11[2 * v13];
      v9 = (int *)&v11[8 * v14 - 8 + ((2 * v6 + 7) & 0xFFFFFFFFFFFFFFF8)];
      v7 = v11;
      __src = &v11[(2 * v6 + 7) & 0xFFFFFFFFFFFFFFF8];
      v5 = v12;
    }
    v15 = word_10006A75A[v4];
    if (v15 == -454)
      goto LABEL_27;
    a1 = *((unsigned int *)v5 + 458);
    if ((_DWORD)a1 == -2)
    {
      a1 = sub_10005276C(a1, a2, a3, a4);
      *((_DWORD *)v5 + 458) = a1;
    }
    if ((int)a1 <= 0)
    {
      v16 = 0;
      *((_DWORD *)v5 + 458) = 0;
    }
    else
    {
      v16 = a1 > 0x1A6 ? 2 : byte_10006ABFA[a1];
    }
    v17 = (v16 + v15);
    if (v17 > 0x1DD || v16 != (__int16)word_10006ADA2[v17])
    {
LABEL_27:
      v18 = word_10006B51A[v4];
      if (!word_10006B51A[v4])
        goto LABEL_411;
      goto LABEL_28;
    }
    v4 = word_10006B15E[v17];
    if (v4 <= 0)
      break;
    if ((_DWORD)v17 == 46)
    {
      v151 = 0;
      goto LABEL_413;
    }
    if ((int)a1 >= 1)
      *((_DWORD *)v5 + 458) = -2;
    *((_QWORD *)v9 + 1) = qword_10008C730;
    v9 += 2;
LABEL_295:
    v8 += 2;
  }
  if (!word_10006B15E[v17])
  {
LABEL_411:
    ++dword_10008C738;
    v151 = 1;
    v152 = "syntax error";
LABEL_412:
    sub_100054D58((uint64_t)v152);
LABEL_413:
    v11 = v7;
    goto LABEL_414;
  }
  v18 = -v4;
LABEL_28:
  v19 = byte_10006B9BA[v18];
  v20 = *(_QWORD *)&v9[2 * (1 - v19)];
  switch(v18)
  {
    case 0xFu:
      v21 = *((_QWORD *)v9 - 1);
      if (v21 >= 5)
      {
        sub_100054394("invalid path type %d");
        return 0xFFFFFFFFLL;
      }
      v22 = qword_10008B848;
      v23 = *(void **)(qword_10008B848 + 8 * v21 + 136);
      if (v23)
      {
        free(v23);
        v22 = qword_10008B848;
        v21 = *((_QWORD *)v9 - 1);
      }
      v24 = strdup(*(const char **)(*(_QWORD *)v9 + 8));
      *(_QWORD *)(v22 + 8 * v21 + 136) = v24;
      if (*(_QWORD *)(qword_10008B848 + 8 * *((_QWORD *)v9 - 1) + 136))
      {
LABEL_110:
        sub_10003F318(*(_QWORD **)v9);
        v5 = byte_10008BE9C + 356;
        goto LABEL_291;
      }
      if (dword_10008BA20)
      {
        v165 = ne_log_obj(v24);
        if (os_log_type_enabled(v165, OS_LOG_TYPE_ERROR))
          goto LABEL_503;
      }
      goto LABEL_504;
    case 0x11u:
      *(_DWORD *)(qword_10008B848 + 312) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0x13u:
      sub_100028574(__str, 1024, 0, *(const char **)(*((_QWORD *)v9 - 1) + 8));
      sub_10003F318(*((_QWORD **)v9 - 1));
      a1 = sub_100054E08(__str);
      if ((_DWORD)a1)
        return 0xFFFFFFFFLL;
      goto LABEL_291;
    case 0x17u:
      --**(_QWORD **)v9;
      *(_QWORD *)(qword_10008B848 + 8 * *((_QWORD *)v9 - 1) + 176) = *(_QWORD *)v9;
      if (*(_QWORD *)(qword_10008B848 + 8 * *((_QWORD *)v9 - 1) + 176))
        goto LABEL_291;
      v155 = __error();
      strerror(*v155);
      sub_100054394("failed to set my ident: %s");
      return 0xFFFFFFFFLL;
    case 0x1Au:
      sub_1000340F8(*(const char **)(*(_QWORD *)v9 + 8));
      goto LABEL_289;
    case 0x1Bu:
      a1 = sub_100033E38(*v9);
      goto LABEL_291;
    case 0x1Fu:
      *(_DWORD *)(qword_10008B848 + 248) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0x21u:
      *(_DWORD *)(qword_10008B848 + 252) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0x23u:
      *(_DWORD *)(qword_10008B848 + 256) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0x25u:
      *(_DWORD *)(qword_10008B848 + 260) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0x27u:
      *(_DWORD *)(qword_10008B848 + 264) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0x2Cu:
      v25 = *(_QWORD *)v9;
      v26 = 0;
      goto LABEL_62;
    case 0x2Eu:
      v25 = *(_QWORD *)v9;
      v26 = 1;
LABEL_62:
      sub_100052434(v25, v26);
      goto LABEL_291;
    case 0x30u:
      sub_100054394("admin directive is obsoleted.");
      goto LABEL_291;
    case 0x32u:
    case 0x34u:
    case 0x36u:
      sub_100054320("admin port support not compiled in");
      goto LABEL_291;
    case 0x38u:
      *(_DWORD *)(qword_10008B848 + 308) = 1;
      goto LABEL_291;
    case 0x3Au:
      snprintf(__str, 0xAuLL, "%ld", *(_QWORD *)v9);
      v20 = (uint64_t)sub_10003CC48(*(const char **)(*((_QWORD *)v9 - 1) + 8), __str);
      sub_10003F318(*((_QWORD **)v9 - 1));
      if (!v20)
        return 0xFFFFFFFFLL;
      goto LABEL_291;
    case 0x3Bu:
      v27 = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
      if (!v27)
      {
        sub_100054394("failed to allocate remote index struct");
        v156 = (_QWORD *)*((_QWORD *)v9 - 2);
        goto LABEL_463;
      }
      v20 = (uint64_t)v27;
      snprintf(__str, 0xAuLL, "%ld", *(_QWORD *)v9);
      *(_QWORD *)(v20 + 8) = sub_10003CC48(*(const char **)(*((_QWORD *)v9 - 2) + 8), __str);
      sub_10003F318(*((_QWORD **)v9 - 2));
      if (*(_QWORD *)(v20 + 8))
      {
        *(_DWORD *)v20 = *((_QWORD *)v9 - 1);
        goto LABEL_291;
      }
      sub_100054394("failed to allocate sockaddr storage", v167);
      return 0xFFFFFFFFLL;
    case 0x3Cu:
      v20 = 500;
      goto LABEL_291;
    case 0x3Du:
    case 0xB5u:
    case 0xB7u:
    case 0xB9u:
    case 0xBAu:
    case 0xBDu:
    case 0x12Bu:
    case 0x12Cu:
      v20 = *(_QWORD *)v9;
      goto LABEL_291;
    case 0x41u:
      if (inet_pton(2, *(const char **)(*(_QWORD *)v9 + 8), &xmmword_10008BE38) != 1)
        sub_100054394("bad IPv4 network address.");
      goto LABEL_289;
    case 0x43u:
      if (inet_pton(2, *(const char **)(*(_QWORD *)v9 + 8), (char *)&xmmword_10008BE38 + 4) != 1)
        sub_100054394("bad IPv4 netmask address.");
      goto LABEL_289;
    case 0x47u:
      v28 = 28678;
      goto LABEL_77;
    case 0x49u:
      v28 = 28676;
LABEL_77:
      dword_10008C6AC = v28;
      goto LABEL_291;
    case 0x4Du:
      v29 = *(_QWORD *)(*(_QWORD *)v9 + 8);
      v30 = byte_10008BE9C;
      goto LABEL_90;
    case 0x4Fu:
      dword_10008BE70 = 0;
      goto LABEL_291;
    case 0x51u:
    case 0x61u:
    case 0x6Fu:
      sub_100054394("racoon not configured with --with-libradius");
      goto LABEL_291;
    case 0x53u:
    case 0x63u:
      sub_100054394("racoon not configured with --with-libpam");
      goto LABEL_291;
    case 0x55u:
    case 0x5Bu:
    case 0x71u:
      sub_100054394("racoon not configured with --with-libldap");
      goto LABEL_291;
    case 0x59u:
      dword_10008BE74 = 0;
      goto LABEL_291;
    case 0x5Du:
      dword_10008BE88 = 0;
      goto LABEL_291;
    case 0x5Fu:
      v31 = &xmmword_10008BE38;
      v32 = 4;
      goto LABEL_223;
    case 0x65u:
      a1 = sub_100044BE4(*v9);
      if ((_DWORD)a1)
        sub_100054394("cannot allocate memory for pool");
      goto LABEL_291;
    case 0x67u:
      v33 = *v9;
      dword_10008C6BC = *v9;
      goto LABEL_153;
    case 0x69u:
      dword_10008C6C0 = *(_QWORD *)v9;
      goto LABEL_291;
    case 0x6Bu:
      dword_10008BE98 = *(_QWORD *)v9;
      goto LABEL_291;
    case 0x6Du:
      dword_10008BE84 = 0;
      goto LABEL_291;
    case 0x73u:
      v29 = *(_QWORD *)(*(_QWORD *)v9 + 8);
      v30 = &byte_10008BE9C[1025];
LABEL_90:
      __strlcpy_chk(v30, v29, 1025, 1025);
      goto LABEL_289;
    case 0x77u:
      v34 = dword_10008BE4C;
      if (dword_10008BE4C > 2)
      {
        sub_100054394("No more than %d DNS");
        return 0xFFFFFFFFLL;
      }
      v35 = *(const char **)(*(_QWORD *)v9 + 8);
      ++dword_10008BE4C;
      if (inet_pton(2, v35, (char *)&xmmword_10008BE38 + 4 * v34 + 8) != 1)
        sub_100054394("bad IPv4 DNS address.");
      goto LABEL_289;
    case 0x7Au:
      v36 = dword_10008BE60;
      if (dword_10008BE60 > 3)
      {
        sub_100054394("No more than %d WINS");
        return 0xFFFFFFFFLL;
      }
      v37 = *(const char **)(*(_QWORD *)v9 + 8);
      ++dword_10008BE60;
      if (inet_pton(2, v37, (char *)&xmmword_10008BE38 + 4 * v36 + 24) != 1)
        sub_100054394("bad IPv4 WINS address.");
      goto LABEL_289;
    case 0x7Du:
      memset(__str, 0, sizeof(__str));
      if (inet_pton(2, *(const char **)(*((_QWORD *)v9 - 1) + 8), __str) != 1)
        sub_100054394("bad IPv4 SPLIT address.");
      v38 = bswap32(-1 << -(char)*(_QWORD *)v9);
      if (*(_QWORD *)v9)
        v39 = v38;
      else
        v39 = 0;
      *(_DWORD *)&__str[4] = v39;
      if (sub_10004585C(&qword_10008C6A0, (uint64_t *)__str, &dword_10008C6A8))
        sub_100054394("Unable to allocate split network");
      v40 = (_QWORD *)*((_QWORD *)v9 - 1);
      goto LABEL_290;
    case 0x80u:
      v41 = malloc_type_realloc((void *)qword_10008BE78, 8 * dword_10008BE80 + 8, 0x80040B8603338uLL);
      if (!v41)
        sub_100054394("unable to allocate auth group list");
      v42 = malloc_type_malloc(**(_QWORD **)v9 + 1, 0x2556D787uLL);
      if (!v42)
        sub_100054394("unable to allocate auth group name");
      memcpy(v42, *(const void **)(*(_QWORD *)v9 + 8), **(_QWORD **)v9);
      *((_BYTE *)v42 + **(_QWORD **)v9) = 0;
      v43 = dword_10008BE80 + 1;
      v41[dword_10008BE80] = v42;
      qword_10008BE78 = (uint64_t)v41;
      dword_10008BE80 = v43;
      goto LABEL_110;
    case 0x83u:
      v44 = **(_QWORD **)v9;
      if (dword_10008C6B8)
      {
        v45 = dword_10008C6B8 + v44 + 1;
        v46 = malloc_type_realloc((void *)qword_10008C6B0, v45, 0x7D912066uLL);
        qword_10008C6B0 = (uint64_t)v46;
        if (!v46)
        {
          sub_100054394("error allocating splitdns list buffer");
          v46 = (_BYTE *)qword_10008C6B0;
        }
        v46[dword_10008C6B8] = 44;
        memcpy((void *)(qword_10008C6B0 + dword_10008C6B8 + 1), *(const void **)(*(_QWORD *)v9 + 8), **(_QWORD **)v9);
      }
      else
      {
        v108 = malloc_type_malloc(v44, 0xED941381uLL);
        qword_10008C6B0 = (uint64_t)v108;
        if (!v108)
        {
          sub_100054394("error allocating splitdns list buffer");
          v108 = (void *)qword_10008C6B0;
        }
        memcpy(v108, *(const void **)(*(_QWORD *)v9 + 8), **(_QWORD **)v9);
        v45 = **(_DWORD **)v9;
      }
      dword_10008C6B8 = v45;
      goto LABEL_289;
    case 0x87u:
      *(_DWORD *)(qword_10008B848 + 268) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0x89u:
      *(_DWORD *)(qword_10008B848 + 272) = *v9 * *(v9 - 2);
      goto LABEL_291;
    case 0x8Bu:
      *(_DWORD *)(qword_10008B848 + 276) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0x8Du:
      *(_DWORD *)(qword_10008B848 + 280) = *v9 * *(v9 - 2);
      goto LABEL_291;
    case 0x8Fu:
      *(_DWORD *)(qword_10008B848 + 284) = *v9 * *(v9 - 2);
      goto LABEL_291;
    case 0x91u:
      v47 = *v9 * *(v9 - 2);
      v48 = qword_10008B848;
      *(_DWORD *)(qword_10008B848 + 80) |= 1u;
      *(_DWORD *)(v48 + 84) = v47;
      goto LABEL_291;
    case 0x93u:
      *(_DWORD *)(qword_10008B848 + 288) = *v9 * *(v9 - 2);
      goto LABEL_291;
    case 0x95u:
      sub_10003A090();
      qword_10008B2C8 = a1;
      if (a1)
        goto LABEL_291;
      sub_100054394("failed to allocate sainfo", v167);
      return 0xFFFFFFFFLL;
    case 0x96u:
      if (*(_QWORD *)(qword_10008B2C8 + 48))
      {
        if (*(_QWORD *)(qword_10008B2C8 + 56))
        {
          if (*(_QWORD *)(qword_10008B2C8 + 64))
          {
            v49 = (uint64_t *)sub_100039CAC(*(_QWORD *)qword_10008B2C8, *(_QWORD *)(qword_10008B2C8 + 8), *(_QWORD *)(qword_10008B2C8 + 40), 0);
            if (v49)
            {
              v50 = *v49;
              v51 = qword_10008B2C8;
              if (!v50 && !*(_QWORD *)qword_10008B2C8)
              {
                sub_10003A350((uint64_t *)qword_10008B2C8);
                sub_100054394("duplicated sainfo: %s");
                return 0xFFFFFFFFLL;
              }
            }
            else
            {
              v51 = qword_10008B2C8;
            }
            a1 = sub_10003A180(v51);
            goto LABEL_291;
          }
          sub_10003A350((uint64_t *)qword_10008B2C8);
          sub_100054394("no compression algorithm at %s");
        }
        else
        {
          sub_10003A350((uint64_t *)qword_10008B2C8);
          sub_100054394("no authentication algorithm at %s");
        }
      }
      else
      {
        sub_10003A350((uint64_t *)qword_10008B2C8);
        sub_100054394("no encryption algorithm at %s");
      }
      return 0xFFFFFFFFLL;
    case 0x98u:
      v52 = qword_10008B2C8;
      *(_QWORD *)qword_10008B2C8 = 0;
      *(_QWORD *)(v52 + 8) = 0;
      goto LABEL_291;
    case 0x99u:
      v53 = qword_10008B2C8;
      *(_QWORD *)qword_10008B2C8 = 0;
      *(_QWORD *)(v53 + 8) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0x9Au:
      v54 = qword_10008B2C8;
      *(_QWORD *)qword_10008B2C8 = *((_QWORD *)v9 - 1);
      *(_QWORD *)(v54 + 8) = 0;
      goto LABEL_291;
    case 0x9Bu:
      v55 = qword_10008B2C8;
      *(_QWORD *)qword_10008B2C8 = *((_QWORD *)v9 - 1);
      *(_QWORD *)(v55 + 8) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0x9Cu:
      if (*(_QWORD *)v9 == 1 || *(_QWORD *)v9 == 58)
      {
        v56 = *((_QWORD *)v9 - 1);
        if (v56)
        {
LABEL_433:
          sub_100054394("port number must be \"any\".", v167);
          return 0xFFFFFFFFLL;
        }
      }
      else
      {
        v56 = *((_QWORD *)v9 - 1);
      }
      snprintf(__str, 0xAuLL, "%lu", v56);
      v87 = sub_10003CC48(*(const char **)(*((_QWORD *)v9 - 3) + 8), __str);
      sub_10003F318(*((_QWORD **)v9 - 3));
      if (!v87)
        return 0xFFFFFFFFLL;
      v112 = v87[1];
      if (v112 == 30)
      {
        v113 = *(_QWORD *)v9;
        if (*(_QWORD *)v9 == 1)
        {
LABEL_470:
          sub_100054394("upper layer protocol mismatched.\n");
          goto LABEL_475;
        }
        v114 = 128;
      }
      else
      {
        if (v112 != 2)
        {
          sub_100054394("invalid family: %d");
LABEL_475:
          v158 = v87;
LABEL_483:
          free(v158);
          return 0xFFFFFFFFLL;
        }
        v113 = *(_QWORD *)v9;
        if (*(_QWORD *)v9 == 58)
          goto LABEL_470;
        v114 = 32;
      }
      if (*((_QWORD *)v9 - 2) == -1)
        v115 = v114;
      else
        v115 = *((_QWORD *)v9 - 2);
      v20 = (uint64_t)sub_100010ADC((uint64_t)v87, v115, v113);
      free(v87);
      if (!v20)
        return 0xFFFFFFFFLL;
      goto LABEL_291;
    case 0x9Du:
      if (*(_QWORD *)v9 == 1 || *(_QWORD *)v9 == 58)
      {
        v57 = *((_QWORD *)v9 - 1);
        if (v57)
          goto LABEL_433;
        v58 = v5;
      }
      else
      {
        v58 = v5;
        v57 = *((_QWORD *)v9 - 1);
      }
      snprintf(__str, 0xAuLL, "%lu", v57);
      v116 = sub_10003CC48(*(const char **)(*((_QWORD *)v9 - 4) + 8), __str);
      if (!v116)
        return 0xFFFFFFFFLL;
      v117 = v116;
      sub_10003F318(*((_QWORD **)v9 - 4));
      v118 = sub_10003CC48(*(const char **)(*((_QWORD *)v9 - 3) + 8), __str);
      if (!v118)
      {
        v158 = v117;
        goto LABEL_483;
      }
      v87 = v118;
      sub_10003F318(*((_QWORD **)v9 - 3));
      v119 = v117[1];
      if (v119 == 30)
      {
        v120 = *(_QWORD *)v9;
        if (*(_QWORD *)v9 == 1)
        {
LABEL_472:
          sub_100054394("upper layer protocol mismatched.\n");
          free(v117);
          goto LABEL_475;
        }
      }
      else
      {
        if (v119 != 2)
        {
          sub_100054394("invalid family: %d", v117[1]);
          v20 = 0;
LABEL_334:
          free(v117);
          free(v87);
          v5 = v58;
          if (v20)
            goto LABEL_291;
          return 0xFFFFFFFFLL;
        }
        v120 = *(_QWORD *)v9;
        if (*(_QWORD *)v9 == 58)
          goto LABEL_472;
      }
      v20 = (uint64_t)sub_100010CFC((uint64_t)v117, (uint64_t)v87, v120);
      goto LABEL_334;
    case 0x9Eu:
      if (*((_QWORD *)v9 - 1) == 5)
      {
        sub_100054394("id type forbidden: %d");
      }
      else
      {
        v59 = sub_10003F1F8(--**(_QWORD **)v9 + 4);
        if (v59)
        {
          v20 = (uint64_t)v59;
          v60 = v59[1];
          *(_BYTE *)v60 = sub_100011C3C(*(v9 - 2));
          *(_BYTE *)(v60 + 1) = 0;
          *(_WORD *)(v60 + 2) = 0;
          a1 = (uint64_t)memcpy((void *)(*(_QWORD *)(v20 + 8) + 4), *(const void **)(*(_QWORD *)v9 + 8), **(_QWORD **)v9);
          goto LABEL_291;
        }
LABEL_427:
        sub_100054394("failed to allocate identifier", v167);
      }
      return 0xFFFFFFFFLL;
    case 0x9Fu:
      *(_QWORD *)(qword_10008B2C8 + 40) = 0;
      goto LABEL_291;
    case 0xA0u:
      *(_QWORD *)__str = 0;
      if (sub_100010490((void ***)__str, *(v9 - 2), *(_QWORD *)v9))
        goto LABEL_423;
      v61 = sub_10003F1F8(**(_QWORD **)__str + 4);
      *(_QWORD *)(qword_10008B2C8 + 40) = v61;
      if (!v61)
        goto LABEL_427;
      v62 = v61[1];
      *(_BYTE *)v62 = sub_100011C3C(*(v9 - 2));
      *(_BYTE *)(v62 + 1) = 0;
      *(_WORD *)(v62 + 2) = 0;
      memcpy((void *)(*(_QWORD *)(*(_QWORD *)(qword_10008B2C8 + 40) + 8) + 4), *(const void **)(*(_QWORD *)__str + 8), **(_QWORD **)__str);
      v40 = *(_QWORD **)__str;
      goto LABEL_290;
    case 0xA1u:
      a1 = (uint64_t)sub_10003F34C(*(_QWORD *)v9);
      *(_QWORD *)(qword_10008B2C8 + 16) = a1;
      if (a1)
        goto LABEL_291;
      sub_100054394("failed to set sainfo xauth group.\n", v167);
      return 0xFFFFFFFFLL;
    case 0xA4u:
      v33 = *v9;
      *(_DWORD *)(qword_10008B2C8 + 36) = *v9;
LABEL_153:
      if (v33 <= 0x12 && ((1 << v33) & 0x7C026) != 0)
        goto LABEL_291;
      sub_100054394("Invalid PFS group specified", v167);
      return 0xFFFFFFFFLL;
    case 0xA6u:
      *(_QWORD *)(qword_10008B2C8 + 24) = *(_QWORD *)v9 * *((_QWORD *)v9 - 1);
      goto LABEL_291;
    case 0xA8u:
    case 0x133u:
      sub_100054394("byte lifetime support is deprecated", v167);
      return 0xFFFFFFFFLL;
    case 0xAAu:
      dword_10008B2D0 = *(_QWORD *)v9;
      goto LABEL_291;
    case 0xACu:
    case 0xAEu:
      sub_100054394("it's deprecated to specify a identifier in phase 2");
      goto LABEL_291;
    case 0xB0u:
    case 0xB1u:
      a1 = (uint64_t)sub_10003A330((uint64_t *)(qword_10008B2C8 + 8 * dword_10008B2D0 + 48), *(_QWORD *)v9);
      goto LABEL_291;
    case 0xB3u:
      v63 = sub_10003A314();
      if (!v63)
      {
        sub_100054394("failed to get algorithm allocation", v167);
        return 0xFFFFFFFFLL;
      }
      v20 = (uint64_t)v63;
      v64 = sub_1000048CC(dword_10008B2D0, *(v9 - 2));
      *(_DWORD *)v20 = v64;
      if (v64 == -1)
      {
        sub_100054394("algorithm mismatched", v167);
        goto LABEL_482;
      }
      v65 = sub_1000046F4(dword_10008B2D0, *(v9 - 2));
      a3 = *(_QWORD *)v9;
      if (v65)
      {
        if (a3)
        {
          if ((sub_100004724(dword_10008B2D0, *(v9 - 2), a3) & 0x80000000) != 0)
          {
            sub_100054394("invalid keylen %d");
            goto LABEL_482;
          }
          if (*(_QWORD *)v9)
            v65 = *(_QWORD *)v9;
        }
      }
      else if (a3)
      {
        sub_100054394("keylen not allowed");
        goto LABEL_482;
      }
      *(_DWORD *)(v20 + 4) = v65;
      a1 = dword_10008B2D0;
      a2 = *((_QWORD *)v9 - 1);
      if (dword_10008B2D0 == 1 && a2 == 18)
        goto LABEL_291;
      a1 = sub_100030B9C(dword_10008B2D0, a2, v65);
      if (!(_DWORD)a1)
        goto LABEL_291;
      v160 = sub_100004A34(dword_10008B2D0);
      v161 = sub_1000048CC(dword_10008B2D0, *(v9 - 2));
      if (v160 == 5)
        v162 = 2;
      else
        v162 = v160;
      sub_10003DF24(v162, v161);
      sub_100054394("algorithm %s not supported by the kernel (missing module?)");
LABEL_482:
      v158 = (void *)v20;
      goto LABEL_483;
    case 0xB4u:
      v20 = -1;
      goto LABEL_291;
    case 0xB6u:
    case 0xB8u:
    case 0xBCu:
    case 0x12Au:
    case 0x142u:
    case 0x145u:
      v20 = 0;
      goto LABEL_291;
    case 0xBBu:
      v20 = 255;
      goto LABEL_291;
    case 0xBEu:
      v66 = sub_10003872C(*(const sockaddr **)(*(_QWORD *)v9 + 8));
      if (!v66)
      {
        v157 = sub_10003C570(*(const sockaddr **)v9);
        sub_100054394("failed to get remoteconf for %s.", (const char *)v157);
        free(*(void **)(*((_QWORD *)v9 - 2) + 8));
        free(*((void **)v9 - 2));
LABEL_446:
        free(*(void **)(*(_QWORD *)v9 + 8));
        v158 = *(void **)v9;
        goto LABEL_483;
      }
      v67 = v66;
      *v66 = *(_QWORD *)(*((_QWORD *)v9 - 2) + 8);
      v68 = **((_DWORD **)v9 - 2);
      if (v68 == -1)
        v68 = 0;
      *((_DWORD *)v66 + 2) = v68;
      v69 = sub_100038154(*(_QWORD *)(*(_QWORD *)v9 + 8), 1);
      v67[31] = 0;
      v67[32] = v69;
      v67[33] = 0;
      qword_10008B2D8 = (uint64_t)v67;
      free(*((void **)v9 - 2));
      free(*(void **)(*(_QWORD *)v9 + 8));
      free(*(void **)v9);
      a1 = (uint64_t)sub_1000524D8();
      if (!a1)
        return 0xFFFFFFFFLL;
      v70 = qword_10008B2D8;
      v71 = *(_QWORD *)(qword_10008B2D8 + 256);
      if (!v71)
        return 0xFFFFFFFFLL;
      v72 = *(_QWORD *)(v71 + 248);
      if (!v72)
        return 0xFFFFFFFFLL;
      *(_QWORD *)a1 = *(_QWORD *)(v72 + 16);
      *(_DWORD *)(a1 + 8) = *(_QWORD *)(v72 + 32);
      v73 = *(_QWORD *)(v70 + 264);
      if (v73)
      {
        *(_QWORD *)(v73 + 32) = a1;
        v73 = *(_QWORD *)(v70 + 264);
      }
      *(_QWORD *)(a1 + 24) = v73;
      *(_QWORD *)(v70 + 264) = a1;
      goto LABEL_291;
    case 0xC0u:
      v74 = sub_100038640();
      if (!v74)
      {
        sub_100054394("failed to get new remoteconf.");
        goto LABEL_446;
      }
      *(_QWORD *)v74 = *(_QWORD *)(*(_QWORD *)v9 + 8);
      v75 = **(_DWORD **)v9;
      if (v75 == -1)
        v75 = 0;
      v74[2] = v75;
      qword_10008B2D8 = (uint64_t)v74;
      free(*(void **)v9);
      v76 = sub_1000524D8();
      if (!v76)
        return 0xFFFFFFFFLL;
      v77 = v76;
      a1 = sub_10000F634();
      *v77 = (int)a1;
      v78 = qword_10008B2D8;
      v79 = *(_QWORD *)(qword_10008B2D8 + 264);
      if (v79)
      {
        *(_QWORD *)(v79 + 32) = v77;
        v79 = *(_QWORD *)(v78 + 264);
      }
      v77[3] = v79;
      *(_QWORD *)(v78 + 264) = v77;
LABEL_291:
      v109 = &v9[-2 * v19];
      v8 -= 2 * v19;
      *((_QWORD *)v109 + 1) = v20;
      v9 = v109 + 2;
      v110 = word_10006BB50[v18] - 168;
      v111 = (*(__int16 *)v8 + word_10006BDE0[v110]);
      if (v111 <= 0x1DD && word_10006ADA2[v111] == *(unsigned __int16 *)v8)
        v4 = word_10006B15E[v111];
      else
        v4 = word_10006BF3C[v110];
      goto LABEL_295;
    case 0xC2u:
      v80 = qword_10008B2D8;
      if (!*(_QWORD *)(qword_10008B2D8 + 16))
      {
        sub_100054394("no exchange mode specified.\n", v167);
        return 0xFFFFFFFFLL;
      }
      v81 = *(_DWORD *)(qword_10008B2D8 + 32);
      if (v81 == 5)
      {
        v121 = *(_QWORD *)(qword_10008B2D8 + 40);
        if (*(_DWORD *)(qword_10008B2D8 + 64))
        {
          if (v121)
          {
            sub_100054320("Both CERT and ASN1 ID are set. Hope this is OK.\n");
            v80 = qword_10008B2D8;
          }
        }
        else if (!v121)
        {
          sub_100054394("ASN1 ID not specified and no CERT defined!\n", v167);
          return 0xFFFFFFFFLL;
        }
      }
      else if (!v81)
      {
        *(_DWORD *)(qword_10008B2D8 + 32) = 4;
      }
      if (*(_DWORD *)(v80 + 132) == 1)
      {
        *(_QWORD *)__str = 0;
        a1 = sub_100006E1C(*(_QWORD **)(v80 + 56), __str);
        if (!a1)
        {
          sub_100054394("peers_identifier required for specified certificate verification option.\n", v167);
          return 0xFFFFFFFFLL;
        }
        v80 = qword_10008B2D8;
      }
      v123 = *(uint64_t **)(v80 + 264);
      v124 = (_QWORD *)v123[2];
      if (!v124)
      {
        v124 = *(_QWORD **)(v80 + 256);
        if (v124)
        {
          v124 = (_QWORD *)v124[33];
          if (v124)
          {
            v124 = (_QWORD *)v124[2];
            v123[2] = (uint64_t)v124;
          }
        }
      }
      if (v123[3])
      {
        if (dword_10008BA20)
        {
          v159 = ne_log_obj(a1);
          if (os_log_type_enabled(v159, OS_LOG_TYPE_ERROR))
            sub_100068C6C();
        }
        return 0xFFFFFFFFLL;
      }
      v125 = v124;
      if (!v124)
      {
        sub_10003C570(*(const sockaddr **)v80);
        sub_100054394("no remote specification found: %s.\n");
        return 0xFFFFFFFFLL;
      }
      do
      {
        if (!*((_DWORD *)v125 + 19))
        {
          sub_100054394("encryption algorithm required.", v167);
          return 0xFFFFFFFFLL;
        }
        if (!*((_DWORD *)v125 + 20))
        {
          sub_100054394("hash algorithm required.", v167);
          return 0xFFFFFFFFLL;
        }
        if (!*((_DWORD *)v125 + 21))
        {
          sub_100054394("DH group required.", v167);
          return 0xFFFFFFFFLL;
        }
        if (!*((_DWORD *)v125 + 22))
        {
          sub_100054394("authentication method required.", v167);
          return 0xFFFFFFFFLL;
        }
        v125 = (_QWORD *)v125[12];
      }
      while (v125);
      v168 = v80;
      do
      {
        v126 = v124;
        v124 = (_QWORD *)v124[12];
      }
      while (v124);
      v178 = v126;
      v175 = 1;
      v169 = v123;
      break;
    case 0xC3u:
      v82 = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
      if (!v82)
      {
        sub_100054394("failed to allocate remote index struct", v167);
        return 0xFFFFFFFFLL;
      }
      v20 = (uint64_t)v82;
      a1 = (uint64_t)sub_10003C67C(128);
      *(_QWORD *)(v20 + 8) = a1;
      if (a1)
      {
        *(_BYTE *)(a1 + 1) = 0;
        *(_WORD *)(a1 + 2) = bswap32(*(unsigned __int16 *)v9) >> 16;
        *(_DWORD *)v20 = -1;
        goto LABEL_291;
      }
      sub_100054394("failed to allocate sockaddr storage", v167);
      goto LABEL_482;
    case 0xC4u:
      v20 = *(_QWORD *)v9;
      if (*(_QWORD *)v9)
        goto LABEL_291;
      sub_100054394("failed to allocate sockaddr_storage", v167);
      return 0xFFFFFFFFLL;
    case 0xC7u:
      *(_QWORD *)(qword_10008B2D8 + 16) = 0;
      goto LABEL_291;
    case 0xC9u:
      *(_DWORD *)(qword_10008B2D8 + 24) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0xCBu:
      *(_DWORD *)(qword_10008B2D8 + 28) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0xCDu:
      if (*(_QWORD *)v9 == 1)
      {
        *(_DWORD *)(qword_10008B2D8 + 292) = 16;
        goto LABEL_291;
      }
      sub_100054394("invalid IKE version specified.\n", v167);
      return 0xFFFFFFFFLL;
    case 0xD0u:
      *(_DWORD *)(qword_10008B2D8 + 124) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0xD2u:
      *(_DWORD *)(qword_10008B2D8 + 116) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0xD4u:
      *(_DWORD *)(qword_10008B2D8 + 120) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0xD6u:
      *(_DWORD *)(qword_10008B2D8 + 128) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0xD8u:
      v83 = qword_10008B2D8;
      *(_DWORD *)(qword_10008B2D8 + 128) = *((_QWORD *)v9 - 1);
      *(_DWORD *)(v83 + 132) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0xDAu:
      sub_100054394("Apple specific features not compiled in.", v167);
      return 0xFFFFFFFFLL;
    case 0xDCu:
      if (sub_100010490((void ***)(qword_10008B2D8 + 40), *(v9 - 2), *(_QWORD *)v9))
      {
        sub_100054394("failed to set identifer.\n");
LABEL_462:
        v156 = *(_QWORD **)v9;
LABEL_463:
        sub_10003F318(v156);
        return 0xFFFFFFFFLL;
      }
      sub_10003F318(*(_QWORD **)v9);
      v84 = *((_QWORD *)v9 - 1);
LABEL_206:
      *(_DWORD *)(qword_10008B2D8 + 32) = v84;
      goto LABEL_291;
    case 0xDEu:
      a1 = sub_100010498((void ***)(qword_10008B2D8 + 40), *(v9 - 4), *(_QWORD *)v9, *(v9 - 2));
      if ((_DWORD)a1)
        goto LABEL_423;
      v84 = *((_QWORD *)v9 - 2);
      goto LABEL_206;
    case 0xE0u:
      if (sub_100047214(qword_10008B2D8 + 272) == -1)
      {
        sub_100054394("failed to allocate xauth state\n", v167);
        return 0xFFFFFFFFLL;
      }
      v85 = sub_10003F34C(*(_QWORD *)v9);
      **(_QWORD **)(qword_10008B2D8 + 272) = v85;
      if (!v85)
      {
LABEL_423:
        sub_100054394("failed to set identifer.\n", v167);
        return 0xFFFFFFFFLL;
      }
LABEL_289:
      v40 = *(_QWORD **)v9;
LABEL_290:
      sub_10003F318(v40);
      goto LABEL_291;
    case 0xE2u:
      v86 = sub_1000388CC();
      if (!v86)
        goto LABEL_426;
      v87 = (unsigned __int8 *)v86;
      if (!sub_100010490((void ***)v86 + 1, *(v9 - 2), *(_QWORD *)v9))
      {
        sub_10003F318(*(_QWORD **)v9);
        v88 = *((_QWORD *)v9 - 1);
LABEL_216:
        *(_DWORD *)v87 = v88;
        a1 = (uint64_t)sub_100006D80(*(_QWORD *)(qword_10008B2D8 + 56), (uint64_t)v87);
        goto LABEL_291;
      }
      sub_100054394("failed to set identifer.\n");
      free(v87);
      goto LABEL_462;
    case 0xE4u:
      v89 = sub_1000388CC();
      if (!v89)
      {
LABEL_426:
        sub_100054394("failed to allocate idspec", v167);
        return 0xFFFFFFFFLL;
      }
      v87 = (unsigned __int8 *)v89;
      if (sub_100010498((void ***)v89 + 1, *(v9 - 4), *(_QWORD *)v9, *(v9 - 2)))
      {
        sub_100054394("failed to set identifer.\n", v167);
        goto LABEL_475;
      }
      v88 = *((_QWORD *)v9 - 2);
      goto LABEL_216;
    case 0xE6u:
      *(_DWORD *)(qword_10008B2D8 + 136) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0xE8u:
      v90 = sub_10003CC48(*(const char **)(*(_QWORD *)v9 + 8), 0);
      sub_10003F318(*(_QWORD **)v9);
      if (!v90)
        return 0xFFFFFFFFLL;
      *(_QWORD *)(qword_10008B2D8 + 296) = v90;
      goto LABEL_291;
    case 0xEAu:
      v91 = qword_10008B2D8;
      *(_DWORD *)(qword_10008B2D8 + 80) = *((_QWORD *)v9 - 1);
      *(_QWORD *)(v91 + 88) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0xECu:
      if (*(_QWORD *)v9 != 3)
      {
        sub_100054394("shared secret value missing.\n", v167);
        return 0xFFFFFFFFLL;
      }
      v31 = (__int128 *)qword_10008B2D8;
      v32 = 3;
LABEL_223:
      *((_DWORD *)v31 + 20) = v32;
      goto LABEL_291;
    case 0xEEu:
      *(_DWORD *)(qword_10008B2D8 + 140) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0xF0u:
      sub_100054394("dh_group cannot be defined here.", v167);
      return 0xFFFFFFFFLL;
    case 0xF2u:
      *(_DWORD *)(qword_10008B2D8 + 144) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0xF4u:
      *(_DWORD *)(qword_10008B2D8 + 148) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0xF6u:
      *(_DWORD *)(qword_10008B2D8 + 148) = 2;
      goto LABEL_291;
    case 0xF8u:
      sub_100054320("Your kernel does not support esp_frag");
      goto LABEL_291;
    case 0xFAu:
      *(_DWORD *)(qword_10008B2D8 + 156) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0xFCu:
      *(_DWORD *)(qword_10008B2D8 + 240) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0xFEu:
    case 0x100u:
      *(_DWORD *)(qword_10008B2D8 + 164) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0x102u:
      *(_DWORD *)(qword_10008B2D8 + 160) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0x104u:
      *(_DWORD *)(qword_10008B2D8 + 168) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0x106u:
    case 0x108u:
      *(_DWORD *)(qword_10008B2D8 + 176) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0x10Au:
      *(_DWORD *)(qword_10008B2D8 + 180) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0x10Cu:
      *(_DWORD *)(qword_10008B2D8 + 184) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0x10Eu:
      *(_DWORD *)(qword_10008B2D8 + 208) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0x110u:
      *(_DWORD *)(qword_10008B2D8 + 216) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0x112u:
      *(_DWORD *)(qword_10008B2D8 + 212) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0x114u:
      *(_DWORD *)(qword_10008B2D8 + 220) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0x116u:
      *(_DWORD *)(qword_10008B2D8 + 224) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0x118u:
      v92 = qword_10008B2D8;
      *(_DWORD *)(qword_10008B2D8 + 228) = *((_QWORD *)v9 - 2);
      *(_DWORD *)(v92 + 232) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0x11Au:
      **(_QWORD **)(qword_10008B2D8 + 264) = *(_QWORD *)v9 * *((_QWORD *)v9 - 1);
      goto LABEL_291;
    case 0x11Cu:
      *(_DWORD *)(qword_10008B2D8 + 172) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0x11Eu:
      sub_100054394("byte lifetime support is deprecated in Phase 1", v167);
      return 0xFFFFFFFFLL;
    case 0x120u:
      a1 = (uint64_t)malloc_type_calloc(1uLL, 0x78uLL, 0x1030040E6A3F341uLL);
      if (!a1)
      {
        sub_100054394("failed to allocate spproto", v167);
        return 0xFFFFFFFFLL;
      }
      *(_DWORD *)(a1 + 12) = 0;
      *(_DWORD *)(a1 + 40) = -1;
      v93 = qword_10008B2D8;
      *(_QWORD *)(a1 + 112) = *(_QWORD *)(qword_10008B2D8 + 264);
      v94 = *(_QWORD *)(*(_QWORD *)(v93 + 264) + 16);
      if (v94)
      {
        *(_QWORD *)(v94 + 104) = a1;
        v94 = *(_QWORD *)(*(_QWORD *)(v93 + 264) + 16);
      }
      *(_QWORD *)(a1 + 96) = v94;
      *(_QWORD *)(*(_QWORD *)(v93 + 264) + 16) = a1;
      goto LABEL_291;
    case 0x123u:
      a1 = (uint64_t)malloc_type_malloc(0x10uLL, 0x1020040D5A9D86FuLL);
      if (!a1)
      {
        sub_100054394("failed to allocate etypes", v167);
        return 0xFFFFFFFFLL;
      }
      *(_DWORD *)a1 = *(_QWORD *)v9;
      *(_QWORD *)(a1 + 8) = 0;
      v95 = *(_QWORD *)(qword_10008B2D8 + 16);
      if (v95)
      {
        do
        {
          v96 = v95;
          v95 = *(_QWORD *)(v95 + 8);
        }
        while (v95);
        *(_QWORD *)(v96 + 8) = a1;
      }
      else
      {
        *(_QWORD *)(qword_10008B2D8 + 16) = a1;
      }
      goto LABEL_291;
    case 0x124u:
      v97 = qword_10008B2D8;
      *(_DWORD *)(qword_10008B2D8 + 104) = *((_QWORD *)v9 - 1);
      *(_DWORD *)(v97 + 64) = 1;
      *(_QWORD *)(v97 + 72) = 0;
      goto LABEL_291;
    case 0x126u:
      v98 = qword_10008B2D8;
      *(_DWORD *)(qword_10008B2D8 + 104) = *((_QWORD *)v9 - 2);
      *(_DWORD *)(v98 + 64) = 1;
      *(_QWORD *)(v98 + 72) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0x128u:
      a1 = sub_1000048CC(5, *v9);
      if ((_DWORD)a1 == -1)
        goto LABEL_424;
      v99 = (int)a1;
      goto LABEL_259;
    case 0x129u:
      v100 = *(_QWORD *)v9;
      if (*(_QWORD *)v9 > 0x12uLL || ((0x3FC1uLL >> v100) & 1) != 0)
      {
LABEL_424:
        sub_100054394("must be DH group", v167);
      }
      else
      {
        v99 = dword_10006BB04[v100];
LABEL_259:
        v101 = v99 - 1;
        if (v101 < 0x12 && ((0x3E013u >> v101) & 1) != 0)
        {
          v20 = qword_10006C098[v101];
          goto LABEL_291;
        }
        sub_100054394("Invalid DH group specified", v167);
      }
      return 0xFFFFFFFFLL;
    case 0x12Fu:
      sub_100054394("strength directive is obsoleted.");
      goto LABEL_291;
    case 0x131u:
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(qword_10008B2D8 + 264) + 16) + 16) = *(_QWORD *)v9 * *((_QWORD *)v9 - 1);
      goto LABEL_291;
    case 0x135u:
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(qword_10008B2D8 + 264) + 16) + 84) = *(_QWORD *)v9;
      goto LABEL_291;
    case 0x137u:
      v102 = qword_10008B2D8;
      v103 = *(_QWORD *)(*(_QWORD *)(qword_10008B2D8 + 264) + 16);
      if (*(_DWORD *)(v103 + 40) != 2)
      {
        sub_100054394("wrong Vendor ID for gssapi_id", v167);
        return 0xFFFFFFFFLL;
      }
      v104 = *(void **)(v103 + 48);
      if (v104)
      {
        free(v104);
        v103 = *(_QWORD *)(*(_QWORD *)(v102 + 264) + 16);
      }
      a1 = (uint64_t)strdup(*(const char **)(*(_QWORD *)v9 + 8));
      *(_QWORD *)(v103 + 48) = a1;
      if (!a1)
      {
        if (dword_10008BA20)
        {
          v166 = ne_log_obj(0);
          if (os_log_type_enabled(v166, OS_LOG_TYPE_ERROR))
LABEL_503:
            sub_10005C4A8();
        }
LABEL_504:
        exit(1);
      }
      goto LABEL_291;
    case 0x139u:
      a1 = sub_1000048CC(*(v9 - 4), *(v9 - 2));
      if ((_DWORD)a1 == -1)
      {
        sub_100054394("algorithm mismatched 1", v167);
        return 0xFFFFFFFFLL;
      }
      v105 = *((_QWORD *)v9 - 2);
      if (v105 != 6)
      {
        if (v105 == 4)
        {
          *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(qword_10008B2D8 + 264) + 16) + 80) = a1;
          goto LABEL_291;
        }
        if (v105 != 3)
        {
          sub_100054394("algorithm mismatched 2", v167);
          return 0xFFFFFFFFLL;
        }
        *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(qword_10008B2D8 + 264) + 16) + 76) = a1;
        a1 = sub_1000046F4(*(v9 - 4), *(v9 - 2));
        v106 = a1;
        a3 = *(_QWORD *)v9;
        if ((_DWORD)a1)
        {
          if (a3)
          {
            a1 = sub_100004724(*(v9 - 4), *(v9 - 2), a3);
            v107 = *(_QWORD *)v9;
            if ((a1 & 0x80000000) != 0)
            {
              sub_100054394("invalid keylen %d");
              return 0xFFFFFFFFLL;
            }
            if (v107)
            {
              *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(qword_10008B2D8 + 264) + 16) + 12) = v107;
              goto LABEL_291;
            }
          }
        }
        else if (a3)
        {
          sub_100054394("keylen not allowed", v167);
          return 0xFFFFFFFFLL;
        }
        *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(qword_10008B2D8 + 264) + 16) + 12) = v106;
        goto LABEL_291;
      }
      v122 = *(_QWORD *)(*(_QWORD *)(qword_10008B2D8 + 264) + 16);
      *(_DWORD *)(v122 + 88) = a1;
      if (*((_QWORD *)v9 - 1) != 48)
        goto LABEL_291;
      if (*(_DWORD *)(v122 + 40) == -1)
      {
        *(_DWORD *)(v122 + 40) = 2;
        goto LABEL_291;
      }
      sub_100054394("Vendor ID mismatch for auth method", v167);
      return 0xFFFFFFFFLL;
    case 0x13Bu:
    case 0x13Eu:
    case 0x143u:
    case 0x146u:
      v20 = 1;
      goto LABEL_291;
    case 0x13Cu:
      v20 = 60;
      goto LABEL_291;
    case 0x13Du:
      v20 = 3600;
      goto LABEL_291;
    case 0x13Fu:
      v20 = 1024;
      goto LABEL_291;
    case 0x140u:
      v20 = 0x100000;
      goto LABEL_291;
    case 0x141u:
      v20 = 0x40000000;
      goto LABEL_291;
    case 0x144u:
    case 0x147u:
      v20 = 2;
      goto LABEL_291;
    default:
      goto LABEL_291;
  }
  do
  {
    if (dword_10008BA20)
    {
      v127 = ne_log_obj(a1);
      a1 = os_log_type_enabled(v127, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)a1)
      {
        v145 = v178[2];
        if (!v145)
          v145 = *v123;
        *(_DWORD *)__str = 134217984;
        *(_QWORD *)&__str[4] = v145;
        _os_log_debug_impl((void *)&_mh_execute_header, v127, OS_LOG_TYPE_DEBUG, "lifetime = %ld\n", (uint8_t *)__str, 0xCu);
      }
      if (dword_10008BA20)
      {
        v128 = ne_log_obj(a1);
        a1 = os_log_type_enabled(v128, OS_LOG_TYPE_DEBUG);
        if ((_DWORD)a1)
        {
          v146 = *((_DWORD *)v178 + 6);
          if (!v146)
            v146 = *((_DWORD *)v123 + 2);
          *(_DWORD *)__str = 67109120;
          *(_DWORD *)&__str[4] = v146;
          _os_log_debug_impl((void *)&_mh_execute_header, v128, OS_LOG_TYPE_DEBUG, "lifebyte = %d\n", (uint8_t *)__str, 8u);
        }
        if (dword_10008BA20)
        {
          v129 = ne_log_obj(a1);
          a1 = os_log_type_enabled(v129, OS_LOG_TYPE_DEBUG);
          if ((_DWORD)a1)
          {
            v147 = *((_DWORD *)v178 + 3);
            *(_DWORD *)__str = 67109120;
            *(_DWORD *)&__str[4] = v147;
            _os_log_debug_impl((void *)&_mh_execute_header, v129, OS_LOG_TYPE_DEBUG, "encklen=%d\n", (uint8_t *)__str, 8u);
          }
        }
      }
    }
    *(_DWORD *)((char *)v191 + 3) = 0;
    v130 = *((_DWORD *)v178 + 19);
    v131 = *((_DWORD *)v178 + 20);
    v191[0] = 0;
    v179 = v130;
    v191[3] = v130;
    v191[4] = v131;
    v174 = v131;
    v176 = *((_DWORD *)v178 + 21);
    v177 = *((_DWORD *)v178 + 22);
    v191[5] = v176;
    v191[6] = v177;
    v132 = v178[2];
    if (!v132)
      v132 = *v123;
    v173 = v132;
    v133 = *((_DWORD *)v178 + 6);
    if (!v133)
      v133 = *((_DWORD *)v123 + 2);
    v172 = v133;
    v170 = *((_DWORD *)v178 + 3);
    v171 = *((_DWORD *)v178 + 10);
    if (dword_10008BA20)
    {
      v134 = ne_log_obj(a1);
      if (os_log_type_enabled(v134, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__str = 67109376;
        *(_DWORD *)&__str[4] = 1;
        *(_WORD *)&__str[8] = 1024;
        *(_DWORD *)&__str[10] = v175;
        _os_log_debug_impl((void *)&_mh_execute_header, v134, OS_LOG_TYPE_DEBUG, "p:%d t:%d\n", (uint8_t *)__str, 0xEu);
      }
    }
    for (i = 3; i != 7; ++i)
    {
      v136 = v191[i];
      v137 = snprintf(v192, 0xAuLL, "%d", v191[i]);
      if (dword_10008BA20)
      {
        v138 = ne_log_obj(v137);
        v137 = os_log_type_enabled(v138, OS_LOG_TYPE_DEBUG);
        if ((_DWORD)v137)
        {
          v139 = sub_10003E74C(i, v136);
          v140 = "(";
          v141 = v192;
          if (v192[0] == 48)
            v141 = (char *)&unk_10007E079;
          if (!(_DWORD)v136)
            v140 = (const char *)&unk_10007E079;
          *(_DWORD *)__str = 136315906;
          *(_QWORD *)&__str[4] = v139;
          *(_WORD *)&__str[12] = 2080;
          v184 = v140;
          v185 = 2080;
          if ((_DWORD)v136)
            v142 = ")";
          else
            v142 = (const char *)&unk_10007E079;
          v186 = v141;
          v187 = 2080;
          v188 = v142;
          _os_log_debug_impl((void *)&_mh_execute_header, v138, OS_LOG_TYPE_DEBUG, "%s%s%s%s\n", (uint8_t *)__str, 0x2Au);
        }
      }
    }
    if (dword_10008BA20)
    {
      v143 = ne_log_obj(v137);
      if (os_log_type_enabled(v143, OS_LOG_TYPE_DEBUG))
        sub_100068C38(&v181, v182, v143);
    }
    v5 = byte_10008BE9C + 356;
    if (!v179 || !v177 || !v176)
    {
      sub_10003E74C(3, v179);
      sub_10003E74C(6, v177);
      sub_10003E74C(4, v174);
      sub_10003E74C(5, v176);
      sub_100054394("few definition of algorithm enc=%s ameth=%s hash=%s dhgroup=%s.\n");
LABEL_430:
      if (dword_10008BA20)
      {
        v154 = ne_log_obj(v153);
        if (os_log_type_enabled(v154, OS_LOG_TYPE_ERROR))
          sub_100068BE0();
      }
      return 0xFFFFFFFFLL;
    }
    v144 = sub_100038C68();
    v123 = v169;
    if (!v144)
    {
      sub_100054394("failed to allocate isakmp sa");
      goto LABEL_430;
    }
    v144[1] = 1;
    v144[2] = v175;
    *((_QWORD *)v144 + 2) = v173;
    *((_QWORD *)v144 + 4) = v172;
    v144[10] = v179;
    v144[11] = v170;
    v144[12] = v177;
    v144[13] = v174;
    v144[18] = v174;
    v144[14] = v171;
    v144[15] = v176;
    a1 = sub_100038CA4((uint64_t)v144, v168);
    ++v175;
    v178 = (_QWORD *)v178[13];
  }
  while (v178);
  if (!*(_QWORD *)(v168 + 248))
  {
    if (dword_10008BA20)
    {
      v163 = ne_log_obj(a1);
      if (os_log_type_enabled(v163, OS_LOG_TYPE_ERROR))
        sub_100068C0C();
    }
    return 0xFFFFFFFFLL;
  }
  if (!sub_100038C48(qword_10008B2D8, 4))
    goto LABEL_409;
  v148 = qword_10008B2D8;
  v149 = *(_QWORD *)(qword_10008B2D8 + 248);
  if (!v149)
  {
    *(_DWORD *)(qword_10008B2D8 + 188) = 0;
LABEL_494:
    sub_100054394("DH group must be set in the proposal.\n", v167);
    return 0xFFFFFFFFLL;
  }
  v150 = 0;
  do
  {
    if ((_DWORD)v150)
    {
      if ((_DWORD)v150 != *(_DWORD *)(v149 + 60))
      {
        sub_100054394("DH group must be equal in all proposals when aggressive mode is used.\n", v167);
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      v150 = *(unsigned int *)(v149 + 60);
    }
    v149 = *(_QWORD *)(v149 + 80);
  }
  while (v149);
  *(_DWORD *)(qword_10008B2D8 + 188) = v150;
  if (!(_DWORD)v150)
    goto LABEL_494;
  if ((sub_100029AD4(v150, v148 + 192) & 0x80000000) == 0)
  {
LABEL_409:
    a1 = sub_100038B08(qword_10008B2D8);
    goto LABEL_291;
  }
  sub_100054394("failed to set DH value.\n", v167);
  return 0xFFFFFFFFLL;
}

void sub_100052434(uint64_t a1, int a2)
{
  _QWORD *v4;
  _QWORD *v5;

  v4 = sub_100007750();
  if (v4)
  {
    v5 = v4;
    v4[1] = a1;
    if (a1)
    {
      *((_DWORD *)v4 + 4) = -1;
      *((_DWORD *)v4 + 8) = a2;
      *((_DWORD *)v4 + 9) = 1;
      sub_1000079D0(v4, (_QWORD *)(qword_10008B848 + 120));
      *(_DWORD *)(qword_10008B848 + 112) = 0;
    }
    else
    {
      sub_100054394("failed to copy sockaddr_storage ");
      sub_100006F18(v5);
    }
  }
  else
  {
    sub_100054394("failed to allocate myaddrs");
  }
}

void *sub_1000524D8()
{
  void *v0;

  v0 = malloc_type_calloc(1uLL, 0x28uLL, 0x102004081634310uLL);
  if (!v0)
    sub_100054394("failed to allocate proposal");
  return v0;
}

uint64_t sub_100052524(uint64_t a1)
{
  NSObject *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  __int16 *v5;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  NSObject *v17;
  uint64_t result;
  NSObject *v19;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  if (dword_10008BA20)
  {
    v1 = ne_log_obj(a1);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG))
      sub_100068E60();
  }
  sub_100054FD4();
  v2 = sub_100054E08(*(const char **)qword_10008B848);
  if ((_DWORD)v2)
  {
    if (dword_10008BA20)
    {
      v6 = ne_log_obj(v2);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        sub_100068DDC(v6);
    }
  }
  else
  {
    v7 = sub_1000501C8(v2, v3, v4, v5);
    if (!(_DWORD)v7)
    {
      if (dword_10008C754)
      {
        if (dword_10008BA20)
        {
          v20 = ne_log_obj(v7);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
            sub_100068CC8(v20, v21, v22, v23, v24, v25, v26, v27);
        }
        sub_100055010();
        exit(1);
      }
      sub_100055010();
      if (dword_10008BA20)
      {
        v17 = ne_log_obj(v16);
        result = os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG);
        if (!(_DWORD)result)
          return result;
        sub_100068C98();
      }
      return 0;
    }
    if (dword_10008C754)
    {
      if (dword_10008BA20)
      {
        v8 = ne_log_obj(v7);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
          sub_100068D68(v8, v9, v10, v11, v12, v13, v14, v15);
      }
    }
    else if (dword_10008BA20)
    {
      v19 = ne_log_obj(v7);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        sub_100068D3C();
    }
    sub_100055010();
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100052680(uint64_t a1)
{
  NSObject *v2;
  _BOOL8 v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _BOOL8 v18;
  uint64_t v19;
  uint64_t v20;

  if (a1 > 0x1F)
  {
    if (!dword_10008BA20)
      goto LABEL_11;
    v10 = ne_log_obj(a1);
    v3 = os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
    if (v3)
      sub_100068F7C();
  }
  else
  {
    if (!dword_10008BA20)
      goto LABEL_11;
    v2 = ne_log_obj(a1);
    v3 = os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG);
    if (v3)
      sub_100068F0C(a1, v2, v4, v5, v6, v7, v8, v9);
  }
  if (dword_10008BA20)
  {
    v11 = ne_log_obj(v3);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      sub_100068E90((_DWORD)a1 == 30, v11, v12, v13, v14, v15, v16, v17);
  }
LABEL_11:
  v18 = (_DWORD)a1 == 30;
  sub_10000928C(v18);
  sub_100008954(v18);
  sub_100038BC8();
  sub_10003A1DC();
  sub_10003AEAC();
  sub_10002807C();
  v20 = sub_100052524(v19);
  sub_100028094();
  return v20;
}

uint64_t sub_10005276C(uint64_t a1, uint64_t a2, uint64_t a3, __int16 *a4)
{
  char *v4;
  char *v5;
  char *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  unsigned __int8 *v12;
  char *v13;
  __int16 *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  _BYTE *v32;
  char *v33;
  int v34;
  int v35;
  char v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  unsigned int v40;
  uint64_t v41;
  int v42;
  char *v43;
  void *v44;
  int v45;
  uint64_t v46;
  void *v47;
  size_t v48;
  size_t v49;
  unint64_t v50;
  int v51;
  BOOL v52;
  size_t v53;
  size_t v54;
  size_t v55;
  int v56;
  int v57;
  char *v58;
  char *v59;
  unint64_t v60;
  char *v61;
  unsigned __int8 *v62;
  char *v63;
  size_t v64;
  void *v65;
  uint64_t v66;
  uint64_t v67;
  int v68;
  char *v69;
  __int16 *v70;
  char *v71;
  char *v72;
  char *v73;
  char *v74;
  uint64_t v75;
  uint64_t v76;
  int v77;
  int v78;
  char *v79;
  char *v80;
  char *v81;
  char *v82;
  void **v83;
  int v84;
  uint64_t v85;
  int *v86;
  glob_t *v87;
  unint64_t v88;
  unint64_t v89;
  uint64_t v90;
  int *v91;
  _DWORD *v92;
  unint64_t v93;
  unint64_t v94;
  const char *v95;
  uint64_t v96;
  char *v97;
  char *v98;
  __int16 *v99;
  char *v100;
  char *v101;
  size_t v102;
  char *v103;
  __int16 *v104;
  char *v105;
  int v106;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  int v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  const char *v116;
  size_t *v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  _QWORD *v123;
  _WORD *v124;
  void *v125;
  uint64_t v126;
  unsigned __int8 *v127;
  int v128;
  size_t *v129;
  size_t *v130;
  unsigned __int8 *v131;
  int v132;
  const char *v133;
  size_t __nitems;
  int v135;
  int v136;
  int v137;
  int v138;
  uint64_t v139;
  uint64_t v140;
  char *__endptr;

  v4 = &byte_10008A931[1743];
  v5 = &byte_10008A931[1743];
  v6 = &byte_10008BE9C[356];
  v7 = &byte_10008A931[1743];
  if ((byte_10008B2E0 & 1) == 0)
  {
    byte_10008B2E0 = 1;
    if (!dword_10008B2E4)
      dword_10008B2E4 = 1;
    if (!qword_10008C740)
      qword_10008C740 = (uint64_t)__stdinp;
    if (!qword_10008C748)
      qword_10008C748 = (uint64_t)__stdoutp;
    v8 = qword_10008B2E8;
    if (!qword_10008B2E8 || (v9 = qword_10008B2F0, (v10 = *(_QWORD *)(qword_10008B2E8 + 8 * qword_10008B2F0)) == 0))
    {
      sub_1000541E0();
      v10 = sub_10005429C((FILE *)qword_10008C740, 0x4000);
      v5 = &byte_10008A931[1743];
      v4 = &byte_10008A931[1743];
      v8 = qword_10008B2E8;
      v9 = qword_10008B2F0;
      *(_QWORD *)(qword_10008B2E8 + 8 * qword_10008B2F0) = v10;
    }
    qword_10008B320 = *(_QWORD *)(v10 + 32);
    qword_10008B308 = *(_QWORD *)(v10 + 16);
    qword_10008C760 = qword_10008B308;
    qword_10008C740 = **(_QWORD **)(v8 + 8 * v9);
    byte_10008B310 = *(_BYTE *)qword_10008B308;
  }
  if ((byte_10008B2F8 & 1) == 0)
  {
    dword_10008B2E4 = 3;
    byte_10008B2F8 = 1;
  }
  v11 = &byte_10008A931[1743];
  v12 = byte_10006C3AC;
  v13 = &byte_10008A931[1743];
  v14 = word_100070446;
  v15 = &byte_10008A931[1743];
  v16 = &byte_10008A931[1743];
  v17 = &byte_10008BE9C[356];
LABEL_15:
  *((_DWORD *)v11 + 191) = 0;
  v18 = *((_QWORD *)v5 + 97);
  if (v13[768] == 1)
  {
    *((_DWORD *)v11 + 191) = v18 - *((_DWORD *)v6 + 472);
    v13[768] = 0;
  }
  *(_BYTE *)v18 = v7[784];
  LODWORD(v19) = *((_DWORD *)v4 + 185);
  v20 = v18;
  do
  {
LABEL_18:
    v21 = v12[*(unsigned __int8 *)v18];
    if (word_10006C4AC[(int)v19])
    {
      *((_DWORD *)v16 + 197) = v19;
      *((_QWORD *)v15 + 99) = v18;
    }
    v22 = (int)v19;
    v23 = word_10006E5BE[(int)v19] + v21;
    if ((_DWORD)v19 != (__int16)word_10006D3BA[v23])
    {
      do
      {
        v22 = word_10006F4E4[v22];
        if (v22 >= 1927)
          v21 = *((unsigned __int8 *)&unk_10007040A + v21);
        v23 = word_10006E5BE[v22] + v21;
      }
      while (word_10006D3BA[v23] != (unsigned __int16)v22);
    }
    v19 = v14[v23];
    ++v18;
  }
  while (word_10006E5BE[v19] != 2246);
  while (2)
  {
    LOWORD(v24) = word_10006C4AC[(int)v19];
    if (!(_WORD)v24)
    {
      v18 = *((_QWORD *)v15 + 99);
      LOWORD(v24) = word_10006C4AC[*((int *)v16 + 197)];
    }
    v24 = (__int16)v24;
    v25 = v20 - *((int *)v11 + 191);
    *((_QWORD *)v6 + 236) = v25;
    *((_QWORD *)v17 + 235) = v18 - v25;
    v7[784] = *(_BYTE *)v18;
    *(_BYTE *)v18 = 0;
    *((_QWORD *)v5 + 97) = v18;
LABEL_28:
    switch(v24)
    {
      case 0:
        *(_BYTE *)v18 = v7[784];
        v18 = *((_QWORD *)v15 + 99);
        LODWORD(v19) = *((_DWORD *)v16 + 197);
        continue;
      case 1:
        *((_DWORD *)v4 + 185) = 7;
        return 258;
      case 2:
        qword_10008C730 = 0;
        return 259;
      case 3:
        v110 = 1;
        goto LABEL_149;
      case 4:
        v110 = 2;
        goto LABEL_149;
      case 5:
        v110 = 3;
        goto LABEL_149;
      case 6:
        v110 = 4;
LABEL_149:
        qword_10008C730 = v110;
        return 259;
      case 7:
      case 10:
      case 21:
      case 84:
        *((_DWORD *)v4 + 185) = 3;
        return 412;
      case 8:
        return 260;
      case 9:
        *((_DWORD *)v4 + 185) = 9;
        sub_100054320("it is obsoleted.  use \"my_identifier\" in each remote directives.", v15, v16, a4, __nitems);
        return 261;
      case 11:
        return 373;
      case 12:
        *((_DWORD *)v4 + 185) = 11;
        return 263;
      case 13:
        v108 = 3;
        goto LABEL_160;
      case 14:
        v108 = 4;
        goto LABEL_160;
      case 15:
        v108 = 5;
        goto LABEL_160;
      case 16:
        v108 = 6;
        goto LABEL_160;
      case 17:
      case 18:
        goto LABEL_128;
      case 19:
      case 20:
        sub_100054320("it is obsoleted.  use \"debug2\"", v15, v16, a4);
LABEL_128:
        v108 = 7;
LABEL_160:
        qword_10008C730 = v108;
        return 264;
      case 22:
        *((_DWORD *)v4 + 185) = 13;
        return 265;
      case 23:
      case 31:
      case 40:
      case 68:
      case 165:
        return 413;
      case 24:
        return 266;
      case 25:
        return 267;
      case 26:
        return 268;
      case 27:
        return 269;
      case 28:
        return 270;
      case 29:
      case 38:
      case 66:
      case 76:
      case 85:
      case 101:
        v106 = 3;
        goto LABEL_122;
      case 30:
        *((_DWORD *)v4 + 185) = 15;
        return 271;
      case 32:
        return 272;
      case 33:
        return 273;
      case 34:
        return 274;
      case 35:
        return 276;
      case 36:
        return 277;
      case 37:
        return 275;
      case 39:
        *((_DWORD *)v4 + 185) = 19;
        return 278;
      case 41:
        return 279;
      case 42:
        return 280;
      case 43:
        return 281;
      case 44:
        return 282;
      case 45:
        return 283;
      case 46:
        return 284;
      case 47:
        return 285;
      case 48:
        return 292;
      case 49:
        return 294;
      case 50:
        return 293;
      case 51:
        return 286;
      case 52:
        return 290;
      case 53:
        return 291;
      case 54:
        return 287;
      case 55:
        return 288;
      case 56:
        return 296;
      case 57:
        return 295;
      case 58:
        return 297;
      case 59:
        return 298;
      case 60:
        return 299;
      case 61:
        return 300;
      case 62:
        return 301;
      case 63:
        return 302;
      case 64:
        return 303;
      case 65:
      case 96:
        return 415;
      case 67:
        *((_DWORD *)v4 + 185) = 17;
        return 304;
      case 69:
        return 305;
      case 70:
        return 306;
      case 71:
        return 307;
      case 72:
        return 308;
      case 73:
        return 309;
      case 74:
        return 310;
      case 75:
        return 311;
      case 77:
        *((_DWORD *)v4 + 185) = 25;
        return 315;
      case 78:
      case 98:
        return 319;
      case 79:
        return 386;
      case 80:
        return 388;
      case 81:
        return 316;
      case 82:
        return 317;
      case 83:
        v111 = 27;
        goto LABEL_221;
      case 86:
        return 392;
      case 87:
        return 397;
      case 88:
      case 113:
        sub_100054320("it is obsoleted.  use \"my_identifier\".", v15, v16, a4, __nitems);
        return 261;
      case 89:
      case 114:
        return 336;
      case 90:
      case 149:
      case 167:
        return 393;
      case 91:
      case 150:
      case 168:
        return 394;
      case 92:
      case 151:
      case 169:
        return 395;
      case 93:
        qword_10008C730 = 0;
        return 312;
      case 94:
        v112 = 1;
        goto LABEL_283;
      case 95:
        v112 = 2;
        goto LABEL_283;
      case 97:
        *((_DWORD *)v4 + 185) = 29;
        return 318;
      case 99:
        return 320;
      case 100:
        v111 = 31;
LABEL_221:
        *((_DWORD *)v4 + 185) = v111;
        return 413;
      case 102:
        return 321;
      case 103:
      case 296:
      case 298:
        goto LABEL_15;
      case 104:
        v113 = 2;
        goto LABEL_226;
      case 105:
        v113 = 4;
LABEL_226:
        qword_10008C730 = v113;
        return 322;
      case 106:
        return 323;
      case 107:
        qword_10008C730 = 1;
        return 324;
      case 108:
        return 325;
      case 109:
        return 422;
      case 110:
        v114 = 1;
        goto LABEL_234;
      case 111:
        v114 = 2;
        goto LABEL_234;
      case 112:
        v114 = 4;
LABEL_234:
        qword_10008C730 = v114;
        return 326;
      case 115:
        return 382;
      case 116:
        return 337;
      case 117:
        return 338;
      case 118:
        return 339;
      case 119:
        return 327;
      case 120:
        return 330;
      case 121:
        qword_10008C730 = 4;
        return 348;
      case 122:
        v97 = "plainrsa not supported.";
        goto LABEL_116;
      case 123:
      case 269:
        v97 = "Apple specific features not compiled in.";
LABEL_116:
        v98 = v5;
        v99 = v14;
        v100 = v13;
        v101 = v15;
        sub_100054394(v97, __nitems);
        a4 = &jpt_1000529C8;
        v16 = byte_10008A931 + 1743;
        v15 = v101;
        v13 = v100;
        v14 = v99;
        v11 = byte_10008A931 + 1743;
        goto LABEL_120;
      case 124:
        return 340;
      case 125:
        return 343;
      case 126:
        return 344;
      case 127:
        return 329;
      case 128:
        return 347;
      case 129:
        return 331;
      case 130:
        return 332;
      case 131:
        return 333;
      case 132:
      case 173:
        return 351;
      case 133:
        return 350;
      case 134:
        return 362;
      case 135:
        sub_100054320("it is obsoleted.  use \"support_proxy\".", v15, v16, a4);
        return 364;
      case 136:
        return 364;
      case 137:
        return 354;
      case 138:
        return 355;
      case 139:
        qword_10008C730 = 2;
        return 357;
      case 140:
        return 358;
      case 141:
        return 359;
      case 142:
        return 360;
      case 143:
        v115 = 1;
        goto LABEL_263;
      case 144:
        v115 = 2;
        goto LABEL_263;
      case 145:
        v115 = 4;
        goto LABEL_263;
      case 146:
        v115 = 3;
LABEL_263:
        qword_10008C730 = v115;
        return 361;
      case 147:
        return 352;
      case 148:
        return 353;
      case 152:
        return 374;
      case 153:
        return 375;
      case 154:
        return 376;
      case 155:
        return 377;
      case 156:
        return 378;
      case 157:
        return 379;
      case 158:
        return 380;
      case 159:
        return 381;
      case 160:
        return 389;
      case 161:
        return 390;
      case 162:
        return 391;
      case 163:
        return 383;
      case 164:
        *((_DWORD *)v4 + 185) = 33;
        return 365;
      case 166:
        v106 = 31;
LABEL_122:
        *((_DWORD *)v4 + 185) = v106;
        return 414;
      case 170:
        v112 = 3;
        goto LABEL_283;
      case 171:
        v112 = 6;
        goto LABEL_283;
      case 172:
        v112 = 4;
LABEL_283:
        qword_10008C730 = v112;
        return 312;
      case 174:
      case 175:
        return 370;
      case 176:
        *((_DWORD *)v4 + 185) = 37;
        return 371;
      case 177:
        qword_10008C730 = 1;
        return 372;
      case 178:
        qword_10008C730 = 0;
        return 372;
      case 179:
        *((_DWORD *)v4 + 185) = 3;
        return 412;
      case 180:
        qword_10008C730 = 1;
        return 399;
      case 181:
        qword_10008C730 = 0;
        return 399;
      case 182:
        v116 = (const char *)(*((_QWORD *)v6 + 236) + 1);
        *((_QWORD *)v6 + 236) = v116;
        qword_10008C730 = atoi(v116);
        return 384;
      case 183:
        v131 = (unsigned __int8 *)(*((_QWORD *)v6 + 236) + 1);
        do
          v132 = *v131++;
        while (v132 != 93);
        *(v131 - 1) = 0;
        v133 = (const char *)(*((_QWORD *)v6 + 236) + 1);
        *((_QWORD *)v6 + 236) = v133;
        qword_10008C730 = atoi(v133);
        return 385;
      case 184:
        ++*((_QWORD *)v6 + 236);
        v117 = sub_10003F1F8(*((_QWORD *)v17 + 235) + 1);
        qword_10008C730 = (uint64_t)v117;
        if (!v117)
          goto LABEL_404;
        memcpy((void *)v117[1], *((const void **)v6 + 236), *v117);
        return 404;
      case 185:
        v118 = 50;
        goto LABEL_410;
      case 186:
        v118 = 51;
        goto LABEL_410;
      case 187:
        v118 = 108;
        goto LABEL_410;
      case 188:
        v118 = 1;
        goto LABEL_410;
      case 189:
        v118 = 58;
        goto LABEL_410;
      case 190:
        v118 = 6;
        goto LABEL_410;
      case 191:
        v118 = 17;
LABEL_410:
        qword_10008C730 = v118;
        return 387;
      case 192:
        v109 = 1;
        goto LABEL_352;
      case 193:
        v109 = 2;
        goto LABEL_352;
      case 194:
        v109 = 3;
        goto LABEL_352;
      case 195:
        v109 = 4;
        goto LABEL_352;
      case 196:
        v109 = 5;
        goto LABEL_352;
      case 197:
        v109 = 6;
        goto LABEL_352;
      case 198:
        v109 = 7;
        goto LABEL_352;
      case 199:
        v109 = 8;
        goto LABEL_352;
      case 200:
        v109 = 9;
        goto LABEL_352;
      case 201:
        v109 = 10;
        goto LABEL_352;
      case 202:
      case 203:
        v109 = 11;
        goto LABEL_352;
      case 204:
      case 205:
        v109 = 12;
        goto LABEL_352;
      case 206:
        v109 = 13;
        goto LABEL_352;
      case 207:
        v109 = 18;
        goto LABEL_352;
      case 208:
        v109 = 14;
        goto LABEL_352;
      case 209:
        v109 = 15;
        goto LABEL_352;
      case 210:
      case 211:
        v109 = 19;
        goto LABEL_352;
      case 212:
      case 213:
        v109 = 20;
        goto LABEL_352;
      case 214:
      case 215:
        v109 = 21;
        goto LABEL_352;
      case 216:
        v109 = 22;
        goto LABEL_352;
      case 217:
        v109 = 23;
        goto LABEL_352;
      case 218:
        v109 = 16;
        goto LABEL_352;
      case 219:
        v109 = 17;
        goto LABEL_352;
      case 220:
        v109 = 27;
        goto LABEL_352;
      case 221:
        v109 = 28;
        goto LABEL_352;
      case 222:
        v109 = 29;
        goto LABEL_352;
      case 223:
      case 224:
        v109 = 30;
        goto LABEL_352;
      case 225:
      case 226:
        v109 = 31;
        goto LABEL_352;
      case 227:
      case 228:
        v109 = 32;
        goto LABEL_352;
      case 229:
        v109 = 24;
        goto LABEL_352;
      case 230:
        v109 = 25;
        goto LABEL_352;
      case 231:
        v109 = 26;
        goto LABEL_352;
      case 232:
        v109 = 33;
        goto LABEL_352;
      case 233:
        v109 = 34;
        goto LABEL_352;
      case 234:
        v109 = 37;
        goto LABEL_352;
      case 235:
        v109 = 35;
        goto LABEL_352;
      case 236:
        v109 = 36;
        goto LABEL_352;
      case 237:
        v109 = 38;
        goto LABEL_352;
      case 238:
        v109 = 39;
        goto LABEL_352;
      case 239:
        v109 = 40;
        goto LABEL_352;
      case 240:
        v109 = 41;
        goto LABEL_352;
      case 241:
        v109 = 42;
        goto LABEL_352;
      case 242:
        v109 = 43;
        goto LABEL_352;
      case 243:
        v109 = 45;
        goto LABEL_352;
      case 244:
        v109 = 44;
        goto LABEL_352;
      case 245:
        v109 = 46;
        goto LABEL_352;
      case 246:
        v109 = 47;
        goto LABEL_352;
      case 247:
        v109 = 48;
        goto LABEL_352;
      case 248:
        v109 = 49;
        goto LABEL_352;
      case 249:
        v109 = 50;
        goto LABEL_352;
      case 250:
        v109 = 51;
        goto LABEL_352;
      case 251:
        v109 = 52;
        goto LABEL_352;
      case 252:
        v109 = 53;
        goto LABEL_352;
      case 253:
        v109 = 54;
        goto LABEL_352;
      case 254:
        v109 = 55;
        goto LABEL_352;
      case 255:
        v109 = 56;
        goto LABEL_352;
      case 256:
        v109 = 57;
        goto LABEL_352;
      case 257:
        v109 = 58;
LABEL_352:
        qword_10008C730 = v109;
        return 313;
      case 258:
        sub_100054320("it is obsoleted.", v15, v16, a4);
        return 262;
      case 259:
        v119 = 2;
        goto LABEL_363;
      case 260:
        v119 = 1;
        goto LABEL_363;
      case 261:
        v119 = 3;
        goto LABEL_363;
      case 262:
        v119 = 8;
        goto LABEL_363;
      case 263:
        v119 = 4;
        goto LABEL_363;
      case 264:
        v119 = 7;
        goto LABEL_363;
      case 265:
        goto LABEL_362;
      case 266:
        sub_100054320("certname will be obsoleted in near future.", v15, v16, a4);
LABEL_362:
        v119 = 5;
LABEL_363:
        qword_10008C730 = v119;
        return 334;
      case 267:
        qword_10008C730 = 0;
        return 341;
      case 268:
        v120 = 1;
        goto LABEL_367;
      case 270:
        v120 = 3;
LABEL_367:
        qword_10008C730 = v120;
        return 341;
      case 271:
        qword_10008C730 = 0;
        return 345;
      case 272:
        qword_10008C730 = 1;
        return 345;
      case 273:
        v121 = 2;
        goto LABEL_373;
      case 274:
        v121 = 1;
LABEL_373:
        qword_10008C730 = v121;
        return 346;
      case 275:
        v122 = 2;
        goto LABEL_376;
      case 276:
        v122 = 1;
LABEL_376:
        qword_10008C730 = v122;
        return 335;
      case 277:
        return 405;
      case 278:
        return 406;
      case 279:
        return 407;
      case 280:
        return 408;
      case 281:
        return 409;
      case 282:
        return 410;
      case 283:
        return 411;
      case 284:
        return 416;
      case 285:
        return 417;
      case 286:
        return 418;
      case 287:
        return 421;
      case 288:
        return 419;
      case 289:
        return 420;
      case 290:
        qword_10008C730 = 1;
        return 400;
      case 291:
        qword_10008C730 = 0;
        return 400;
      case 292:
        __endptr = 0;
        qword_10008C730 = strtol(*((const char **)v6 + 236), &__endptr, 10);
        return 398;
      case 293:
        v123 = sub_10003F1F8(*((_QWORD *)v17 + 235) + (*((_QWORD *)v17 + 235) & 1) + 1);
        qword_10008C730 = (uint64_t)v123;
        if (!v123)
          goto LABEL_404;
        v124 = (_WORD *)v123[1];
        *v124 = 30768;
        v125 = v124 + 1;
        v126 = *((_QWORD *)v17 + 235);
        if ((v126 & 1) != 0)
        {
          v125 = (char *)v124 + 3;
          *((_BYTE *)v124 + 2) = 48;
          v126 = *((_QWORD *)v17 + 235);
        }
        memcpy(v125, (const void *)(*((_QWORD *)v6 + 236) + 2), v126 - 1);
        return 401;
      case 294:
        v127 = (unsigned __int8 *)(*((_QWORD *)v6 + 236) + 1);
        do
          v128 = *v127++;
        while (v128 != 34);
        *(v127 - 1) = 0;
        v129 = sub_10003F1F8(*((_QWORD *)v17 + 235) - 1);
        qword_10008C730 = (uint64_t)v129;
        if (!v129)
          goto LABEL_404;
        memcpy((void *)v129[1], (const void *)(*((_QWORD *)v6 + 236) + 1), *v129);
        return 402;
      case 295:
        v130 = sub_10003F1F8(*((_QWORD *)v17 + 235) + 1);
        qword_10008C730 = (uint64_t)v130;
        if (v130)
        {
          memcpy((void *)v130[1], *((const void **)v6 + 236), *v130);
          return 403;
        }
        else
        {
LABEL_404:
          sub_100054394("vmalloc failed", __nitems);
          return 0xFFFFFFFFLL;
        }
      case 297:
        ++dword_10008B330[32 * (uint64_t)dword_10008B330[0] + 8];
        goto LABEL_15;
      case 299:
        return 412;
      case 300:
        v13[768] = 1;
        goto LABEL_15;
      case 301:
        v102 = *((_QWORD *)v17 + 235);
        v98 = v5;
        v103 = v11;
        v104 = v14;
        v105 = v13;
        fwrite(*((const void **)v6 + 236), v102, 1uLL, (FILE *)qword_10008C748);
        a4 = &jpt_1000529C8;
        v16 = byte_10008A931 + 1743;
        v15 = byte_10008A931 + 1743;
        v13 = v105;
        v14 = v104;
        v11 = v103;
LABEL_120:
        v12 = byte_10006C3AC;
        v5 = v98;
        v4 = byte_10008A931 + 1743;
        v17 = byte_10008BE9C + 356;
        goto LABEL_15;
      case 302:
        v139 = v20;
        v26 = *((_QWORD *)v6 + 236);
        *(_BYTE *)v18 = v7[784];
        v27 = qword_10008B2E8;
        v28 = qword_10008B2F0;
        v29 = *(_QWORD *)(qword_10008B2E8 + 8 * qword_10008B2F0);
        if (*(_DWORD *)(v29 + 64))
        {
          v30 = qword_10008B320;
        }
        else
        {
          v30 = *(_QWORD *)(v29 + 32);
          qword_10008B320 = v30;
          *(_QWORD *)v29 = qword_10008C740;
          v29 = *(_QWORD *)(v27 + 8 * v28);
          *(_DWORD *)(v29 + 64) = 1;
        }
        v31 = *((_QWORD *)v5 + 97);
        v32 = *(_BYTE **)(v29 + 8);
        if (v31 <= (unint64_t)&v32[v30])
        {
          v6 = &byte_10008BE9C[356];
          v18 = qword_10008C760 + ~(_DWORD)v26 + (int)v18;
          v72 = v5;
          *((_QWORD *)v5 + 97) = v18;
          v73 = v15;
          v74 = v16;
          LODWORD(v19) = sub_1000546A8();
          v16 = v74;
          v15 = v73;
          if (word_10006C4AC[(int)v19])
          {
            *((_DWORD *)v74 + 197) = v19;
            *((_QWORD *)v73 + 99) = v18;
          }
          v75 = (int)v19;
          v76 = word_10006E5BE[(int)v19] + 1;
          v4 = byte_10008A931 + 1743;
          v5 = v72;
          v7 = byte_10008A931 + 1743;
          v17 = byte_10008BE9C + 356;
          v11 = &byte_10008A931[1743];
          v12 = byte_10006C3AC;
          v14 = word_100070446;
          v13 = byte_10008A931 + 1743;
          a4 = &jpt_1000529C8;
          if ((_DWORD)v19 != (__int16)word_10006D3BA[v76])
          {
            do
            {
              v77 = (unsigned __int16)word_10006F4E4[v75];
              v75 = (__int16)v77;
              v76 = word_10006E5BE[(__int16)v77] + 1;
            }
            while (v77 != word_10006D3BA[v76]);
          }
          v78 = (unsigned __int16)word_100070446[v76];
          v20 = qword_10008C760 + dword_10008B2FC;
          if (word_100070446[v76] && v78 != 1926)
          {
            LODWORD(v19) = (__int16)v78;
            *((_QWORD *)v5 + 97) = ++v18;
            goto LABEL_18;
          }
          continue;
        }
        v135 = v26;
        if (v31 > (unint64_t)&v32[v30 + 1])
          sub_100054788("fatal flex scanner internal error--end of buffer missed");
        v33 = (char *)qword_10008C760;
        if (!*(_DWORD *)(v29 + 60))
        {
          v37 = *((int *)v11 + 191);
          v6 = byte_10008BE9C + 356;
          v4 = byte_10008A931 + 1743;
          if (v31 - (qword_10008C760 + v37) != 1)
            goto LABEL_92;
          goto LABEL_84;
        }
        v34 = ~(_DWORD)qword_10008C760 + v31;
        if (v34 >= 1)
        {
          v35 = ~(_DWORD)qword_10008C760 + v31;
          do
          {
            v36 = *v33++;
            *v32++ = v36;
            --v35;
          }
          while (v35);
          v29 = *(_QWORD *)(v27 + 8 * v28);
        }
        v140 = v34;
        if (*(_DWORD *)(v29 + 64) == 2)
        {
          qword_10008B320 = 0;
          goto LABEL_41;
        }
        v38 = ~v34;
        v39 = *(_DWORD *)(v29 + 24);
        v40 = v39 + v38;
        v136 = v34;
        if (!(v39 + (_DWORD)v38))
        {
          do
          {
            if (!*(_DWORD *)(v29 + 40))
            {
              *(_QWORD *)(v29 + 8) = 0;
LABEL_413:
              sub_100054788("fatal error - scanner input buffer overflow");
            }
            v41 = v38;
            v42 = v31;
            v43 = v5;
            v44 = *(void **)(v29 + 8);
            v45 = 2 * v39;
            *(_DWORD *)(v29 + 24) = v45;
            v46 = v29;
            v47 = malloc_type_realloc(v44, v45 + 2, 0xCDB0C269uLL);
            *(_QWORD *)(v46 + 8) = v47;
            if (!v47)
              goto LABEL_413;
            v31 = (unint64_t)v47 + v42 - (int)v44;
            v5 = v43;
            *((_QWORD *)v43 + 97) = v31;
            v29 = *(_QWORD *)(qword_10008B2E8 + 8 * qword_10008B2F0);
            v39 = *(_DWORD *)(v29 + 24);
            v38 = v41;
            v40 = v39 + v41;
          }
          while (!(v39 + (_DWORD)v41));
          v12 = byte_10006C3AC;
          v34 = v136;
        }
        if (v40 >= 0x2000)
          v48 = 0x2000;
        else
          v48 = v40;
        if (*(_DWORD *)(v29 + 44))
        {
          v49 = v48;
          v50 = 0;
          while (1)
          {
            v51 = getc((FILE *)qword_10008C740);
            v52 = v51 == -1 || v51 == 10;
            if (v52)
              break;
            *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(qword_10008B2E8 + 8 * qword_10008B2F0) + 8) + v140 + v50++) = v51;
            if (v49 == v50)
            {
              v50 = v49;
              break;
            }
          }
          if (v51 == -1)
          {
            v56 = ferror((FILE *)qword_10008C740);
            v11 = &byte_10008A931[1743];
            v13 = byte_10008A931 + 1743;
            v15 = byte_10008A931 + 1743;
            v16 = byte_10008A931 + 1743;
            a4 = &jpt_1000529C8;
            if (v56)
LABEL_416:
              sub_100054788("input in flex scanner failed");
          }
          else
          {
            if (v51 == 10)
              *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(qword_10008B2E8 + 8 * qword_10008B2F0) + 8) + v140 + v50++) = 10;
            v11 = byte_10008A931 + 1743;
            v13 = byte_10008A931 + 1743;
            v15 = byte_10008A931 + 1743;
            v16 = byte_10008A931 + 1743;
            a4 = &jpt_1000529C8;
          }
          qword_10008B320 = v50;
LABEL_72:
          v27 = qword_10008B2E8;
          v28 = qword_10008B2F0;
          v29 = *(_QWORD *)(qword_10008B2E8 + 8 * qword_10008B2F0);
          *(_QWORD *)(v29 + 32) = v50;
          if (v50)
          {
            v57 = 0;
            v34 = v136;
            v7 = byte_10008A931 + 1743;
            goto LABEL_78;
          }
          v34 = v136;
          v7 = byte_10008A931 + 1743;
        }
        else
        {
          *__error() = 0;
          v53 = fread((void *)(*(_QWORD *)(*(_QWORD *)(qword_10008B2E8 + 8 * qword_10008B2F0) + 8) + v34), 1uLL, v48, (FILE *)qword_10008C740);
          v54 = v48;
          v50 = (int)v53;
          qword_10008B320 = (int)v53;
          v11 = byte_10008A931 + 1743;
          v13 = byte_10008A931 + 1743;
          v15 = byte_10008A931 + 1743;
          v16 = byte_10008A931 + 1743;
          a4 = &jpt_1000529C8;
          if (v53 << 32)
            goto LABEL_72;
          __nitems = v54;
          while (ferror((FILE *)qword_10008C740))
          {
            if (*__error() != 4)
              goto LABEL_416;
            *__error() = 0;
            clearerr((FILE *)qword_10008C740);
            v55 = fread((void *)(*(_QWORD *)(*(_QWORD *)(qword_10008B2E8 + 8 * qword_10008B2F0) + 8) + v140), 1uLL, __nitems, (FILE *)qword_10008C740);
            v50 = (int)v55;
            qword_10008B320 = (int)v55;
            if (v55 << 32)
            {
              v11 = byte_10008A931 + 1743;
              v13 = byte_10008A931 + 1743;
              v15 = byte_10008A931 + 1743;
              v16 = byte_10008A931 + 1743;
              a4 = &jpt_1000529C8;
              goto LABEL_72;
            }
          }
          v27 = qword_10008B2E8;
          v28 = qword_10008B2F0;
          v29 = *(_QWORD *)(qword_10008B2E8 + 8 * qword_10008B2F0);
          v11 = byte_10008A931 + 1743;
          v13 = byte_10008A931 + 1743;
          v15 = byte_10008A931 + 1743;
          v16 = byte_10008A931 + 1743;
          a4 = &jpt_1000529C8;
          v34 = v136;
          v7 = byte_10008A931 + 1743;
LABEL_41:
          *(_QWORD *)(v29 + 32) = 0;
        }
        if (*((_DWORD *)v11 + 191) == v34)
        {
          v58 = v11;
          v137 = v34;
          v59 = v15;
          sub_1000547BC((FILE *)qword_10008C740);
          a4 = &jpt_1000529C8;
          v16 = byte_10008A931 + 1743;
          v15 = v59;
          v34 = v137;
          v13 = byte_10008A931 + 1743;
          v11 = v58;
          v50 = qword_10008B320;
          v27 = qword_10008B2E8;
          v28 = qword_10008B2F0;
          v29 = *(_QWORD *)(qword_10008B2E8 + 8 * qword_10008B2F0);
          v57 = 1;
        }
        else
        {
          v50 = 0;
          v57 = 2;
          *(_DWORD *)(v29 + 64) = 2;
        }
LABEL_78:
        v60 = v50 + v34;
        if (v60 <= *(int *)(v29 + 24))
        {
          v67 = *(_QWORD *)(v29 + 8);
          v4 = &byte_10008A931[1743];
          v5 = &byte_10008A931[1743];
        }
        else
        {
          v138 = v57;
          v61 = v13;
          v62 = v12;
          v63 = v11;
          v64 = v60 + (v50 >> 1);
          v65 = malloc_type_realloc(*(void **)(v29 + 8), v64, 0xCDB0C269uLL);
          v27 = qword_10008B2E8;
          v28 = qword_10008B2F0;
          *(_QWORD *)(*(_QWORD *)(qword_10008B2E8 + 8 * qword_10008B2F0) + 8) = v65;
          v66 = *(_QWORD *)(v27 + 8 * v28);
          v67 = *(_QWORD *)(v66 + 8);
          if (!v67)
            sub_100054788("out of dynamic memory in yy_get_next_buffer()");
          *(_DWORD *)(v66 + 24) = v64 - 2;
          v60 = qword_10008B320 + v140;
          v4 = byte_10008A931 + 1743;
          v5 = byte_10008A931 + 1743;
          v11 = v63;
          v12 = v62;
          v13 = v61;
          v15 = byte_10008A931 + 1743;
          v16 = byte_10008A931 + 1743;
          a4 = &jpt_1000529C8;
          v57 = v138;
        }
        qword_10008B320 = v60;
        *(_BYTE *)(v67 + v60) = 0;
        *(_BYTE *)(v60 + *(_QWORD *)(*(_QWORD *)(v27 + 8 * v28) + 8) + 1) = 0;
        v33 = *(char **)(*(_QWORD *)(v27 + 8 * v28) + 8);
        qword_10008C760 = (uint64_t)v33;
        if (v57 == 1)
        {
          v37 = *((int *)v11 + 191);
          v6 = byte_10008BE9C + 356;
          v14 = word_100070446;
LABEL_84:
          *((_QWORD *)v5 + 97) = &v33[v37];
          v68 = *((_DWORD *)v4 + 185);
          if (v68 >= 1)
            --v68;
          v24 = (v68 >> 1) + 303;
          v17 = byte_10008BE9C + 356;
          v20 = v139;
          goto LABEL_28;
        }
        if (v57)
        {
          v52 = v57 == 2;
          v6 = &byte_10008BE9C[356];
          v17 = byte_10008BE9C + 356;
          v14 = word_100070446;
          if (!v52)
            goto LABEL_15;
          v32 = *(_BYTE **)(*(_QWORD *)(qword_10008B2E8 + 8 * qword_10008B2F0) + 8);
          v30 = qword_10008B320;
          v37 = *((int *)v11 + 191);
LABEL_92:
          v18 = (uint64_t)&v32[v30];
          *((_QWORD *)v5 + 97) = &v32[v30];
          v69 = v11;
          v70 = v14;
          v71 = v15;
          LODWORD(v19) = sub_1000546A8();
          a4 = &jpt_1000529C8;
          v16 = byte_10008A931 + 1743;
          v15 = v71;
          v13 = byte_10008A931 + 1743;
          v14 = v70;
          v11 = v69;
          v12 = byte_10006C3AC;
          v5 = byte_10008A931 + 1743;
          v7 = byte_10008A931 + 1743;
          v4 = byte_10008A931 + 1743;
          v20 = *((_QWORD *)v6 + 236) + v37;
          v17 = byte_10008BE9C + 356;
          continue;
        }
        v18 = (uint64_t)&v33[~v135 + (int)v18];
        *((_QWORD *)v5 + 97) = v18;
        v79 = v5;
        v80 = v11;
        v81 = v13;
        v82 = v15;
        LODWORD(v19) = sub_1000546A8();
        a4 = &jpt_1000529C8;
        v16 = byte_10008A931 + 1743;
        v15 = v82;
        v13 = v81;
        v11 = v80;
        v12 = byte_10006C3AC;
        v5 = v79;
        v4 = byte_10008A931 + 1743;
        v6 = &byte_10008BE9C[356];
        v20 = qword_10008C760 + *((int *)v11 + 191);
        v17 = byte_10008BE9C + 356;
        v14 = word_100070446;
        goto LABEL_18;
      case 303:
      case 304:
      case 305:
      case 306:
      case 307:
      case 308:
      case 309:
      case 310:
      case 311:
      case 312:
      case 313:
      case 314:
      case 315:
      case 316:
      case 317:
      case 318:
      case 319:
      case 320:
      case 321:
        if (qword_10008B2E8)
          v83 = *(void ***)(qword_10008B2E8 + 8 * qword_10008B2F0);
        else
          v83 = 0;
        sub_100054408(v83);
        while (1)
        {
          v84 = dword_10008B330[0];
          v85 = --dword_10008B330[0];
          v86 = &dword_10008B330[32 * v85];
          v89 = *((_QWORD *)v86 + 5);
          v87 = (glob_t *)(v86 + 10);
          v88 = v89;
          if (!v89)
            break;
          v90 = *(_QWORD *)&dword_10008B330[32 * v85 + 18];
          if (!v90)
            break;
          v91 = &dword_10008B330[32 * v85];
          v94 = v91[32];
          v92 = v91 + 32;
          v93 = v94;
          if (v88 <= v94)
            break;
          v95 = *(const char **)(v90 + 8 * v93);
          *v92 = v93 + 1;
          dword_10008B330[0] = v84;
          if (!sub_100054470(v95))
          {
            v96 = sub_10005429C((FILE *)qword_10008C740, 0x4000);
            sub_1000545E8(v96);
            v4 = &byte_10008A931[1743];
            dword_10008B2E4 = 3;
            goto LABEL_113;
          }
        }
        globfree(v87);
        if (dword_10008B330[0])
        {
          sub_1000545E8(*(_QWORD *)&dword_10008B330[32 * (uint64_t)dword_10008B330[0] + 6]);
          v4 = byte_10008A931 + 1743;
LABEL_113:
          v5 = byte_10008A931 + 1743;
          v17 = byte_10008BE9C + 356;
          v11 = byte_10008A931 + 1743;
          v14 = word_100070446;
          v13 = byte_10008A931 + 1743;
          v15 = byte_10008A931 + 1743;
          v16 = byte_10008A931 + 1743;
          a4 = &jpt_1000529C8;
          goto LABEL_15;
        }
        return 0;
      default:
        sub_100054788("fatal flex scanner internal error--no action found");
    }
  }
}

_QWORD *sub_1000541E0()
{
  _QWORD *result;
  uint64_t v1;
  _OWORD *v2;

  result = (_QWORD *)qword_10008B2E8;
  if (qword_10008B2E8)
  {
    if (qword_10008B2F0 >= (unint64_t)(qword_10008B328 - 1))
    {
      v1 = qword_10008B328 + 8;
      result = malloc_type_realloc((void *)qword_10008B2E8, 8 * (qword_10008B328 + 8), 0xCDB0C269uLL);
      qword_10008B2E8 = (uint64_t)result;
      if (result)
      {
        v2 = &result[qword_10008B328];
        *v2 = 0u;
        v2[1] = 0u;
        v2[2] = 0u;
        v2[3] = 0u;
        qword_10008B328 = v1;
        return result;
      }
LABEL_8:
      sub_100054788("out of dynamic memory in yyensure_buffer_stack()");
    }
  }
  else
  {
    result = malloc_type_malloc(8uLL, 0xFA1A264CuLL);
    qword_10008B2E8 = (uint64_t)result;
    if (!result)
      goto LABEL_8;
    *result = 0;
    qword_10008B328 = 1;
    qword_10008B2F0 = 0;
  }
  return result;
}

uint64_t sub_10005429C(FILE *a1, int a2)
{
  _DWORD *v4;
  uint64_t v5;
  void *v6;

  v4 = malloc_type_malloc(0x48uLL, 0xFA1A264CuLL);
  if (!v4
    || (v5 = (uint64_t)v4, v4[6] = a2, v6 = malloc_type_malloc(a2 + 2, 0xFA1A264CuLL), (*(_QWORD *)(v5 + 8) = v6) == 0))
  {
    sub_100054788("out of dynamic memory in yy_create_buffer()");
  }
  *(_DWORD *)(v5 + 40) = 1;
  sub_100054868(v5, a1);
  return v5;
}

void sub_100054320(char *__format, ...)
{
  char __str[512];
  va_list va;

  va_start(va, __format);
  vsnprintf(__str, 0x200uLL, __format, va);
  sub_100054DB8((uint64_t)__str);
}

void sub_100054394(char *__format, ...)
{
  char __str[512];
  va_list va;

  va_start(va, __format);
  vsnprintf(__str, 0x200uLL, __format, va);
  sub_100054D58((uint64_t)__str);
}

void sub_100054408(void **a1)
{
  void **v2;

  if (a1)
  {
    if (qword_10008B2E8)
      v2 = *(void ***)(qword_10008B2E8 + 8 * qword_10008B2F0);
    else
      v2 = 0;
    if (v2 == a1)
      *(_QWORD *)(qword_10008B2E8 + 8 * qword_10008B2F0) = 0;
    if (*((_DWORD *)a1 + 10))
      free(a1[1]);
    free(a1);
  }
}

uint64_t sub_100054470(const char *a1)
{
  FILE *v2;
  uint64_t v3;
  int *v4;
  char *v5;
  NSObject *v6;
  uint64_t result;
  FILE *v8;
  int *v9;
  char *v10;
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v2 = fopen(a1, "r");
  qword_10008C740 = (uint64_t)v2;
  if (v2)
  {
    v3 = dword_10008B330[0];
    if (*(_QWORD *)&dword_10008B330[32 * (uint64_t)dword_10008B330[0] + 2])
    {
      fclose(*((FILE **)&unk_10008B338 + 16 * (uint64_t)dword_10008B330[0] + 1));
      v3 = dword_10008B330[0];
      free(*((void **)&unk_10008B338 + 16 * (uint64_t)dword_10008B330[0]));
      v2 = (FILE *)qword_10008C740;
    }
    v4 = &dword_10008B330[32 * v3];
    *((_QWORD *)v4 + 2) = v2;
    v5 = strdup(a1);
    *((_QWORD *)v4 + 1) = v5;
    if (!v5)
    {
      if (dword_10008BA20)
      {
        v13 = ne_log_obj(0);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
          sub_100061E58(v13, v14, v15, v16, v17, v18, v19, v20);
      }
      exit(1);
    }
    v4[8] = 1;
    if (!dword_10008BA20)
      return 0;
    v6 = ne_log_obj(v5);
    result = os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG);
    if ((_DWORD)result)
    {
      sub_100069044((uint64_t)a1, v6);
      return 0;
    }
  }
  else
  {
    v8 = __stderrp;
    v9 = __error();
    v10 = strerror(*v9);
    v11 = fprintf(v8, "failed to open file %s (%s)\n", a1, v10);
    if (dword_10008BA20)
    {
      v12 = ne_log_obj(v11);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        sub_100068FA8((uint64_t)a1, v12);
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

_QWORD *sub_1000545E8(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  result = sub_1000541E0();
  v3 = qword_10008B2E8;
  if (qword_10008B2E8)
  {
    v4 = qword_10008B2F0;
    v5 = *(_QWORD *)(qword_10008B2E8 + 8 * qword_10008B2F0);
    if (v5 == a1)
      return result;
    if (v5)
    {
      v6 = qword_10008B308;
      *(_BYTE *)qword_10008B308 = byte_10008B310;
      *(_QWORD *)(*(_QWORD *)(v3 + 8 * v4) + 16) = v6;
      *(_QWORD *)(*(_QWORD *)(v3 + 8 * v4) + 32) = qword_10008B320;
    }
  }
  else
  {
    if (!a1)
      return result;
    v4 = qword_10008B2F0;
  }
  *(_QWORD *)(v3 + 8 * v4) = a1;
  qword_10008B320 = *(_QWORD *)(a1 + 32);
  qword_10008B308 = *(_QWORD *)(a1 + 16);
  qword_10008C760 = qword_10008B308;
  qword_10008C740 = **(_QWORD **)(v3 + 8 * v4);
  byte_10008B310 = *(_BYTE *)qword_10008B308;
  return result;
}

uint64_t sub_1000546A8()
{
  uint64_t result;
  _BYTE *i;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  result = dword_10008B2E4;
  for (i = (_BYTE *)(qword_10008C760 + dword_10008B2FC); (unint64_t)i < qword_10008B308; ++i)
  {
    if (*i)
      v2 = byte_10006C3AC[*i];
    else
      v2 = &_mh_execute_header.magic + 1;
    if (word_10006C4AC[(int)result])
    {
      dword_10008B314 = result;
      qword_10008B318 = (uint64_t)i;
    }
    v3 = (int)result;
    v4 = word_10006E5BE[(int)result] + v2;
    if ((_DWORD)result != (__int16)word_10006D3BA[v4])
    {
      do
      {
        v3 = word_10006F4E4[v3];
        if (v3 >= 1927)
          v2 = *((unsigned __int8 *)&unk_10007040A + v2);
        v4 = word_10006E5BE[v3] + v2;
      }
      while (word_10006D3BA[v4] != (unsigned __int16)v3);
    }
    result = word_100070446[v4];
  }
  return result;
}

void sub_100054788(const char *a1)
{
  fprintf(__stderrp, "%s\n", a1);
  exit(2);
}

int *sub_1000547BC(FILE *a1)
{
  uint64_t v2;
  int *result;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;

  if (!qword_10008B2E8 || (v2 = *(_QWORD *)(qword_10008B2E8 + 8 * qword_10008B2F0)) == 0)
  {
    sub_1000541E0();
    v2 = sub_10005429C((FILE *)qword_10008C740, 0x4000);
    *(_QWORD *)(qword_10008B2E8 + 8 * qword_10008B2F0) = v2;
  }
  result = sub_100054868(v2, a1);
  v4 = *(_QWORD *)(qword_10008B2E8 + 8 * qword_10008B2F0);
  v5 = *(_QWORD *)(v4 + 32);
  qword_10008B308 = *(_QWORD *)(v4 + 16);
  qword_10008C760 = qword_10008B308;
  v6 = *(uint64_t **)(qword_10008B2E8 + 8 * qword_10008B2F0);
  qword_10008B320 = v5;
  qword_10008C740 = *v6;
  byte_10008B310 = *(_BYTE *)qword_10008B308;
  return result;
}

int *sub_100054868(uint64_t a1, FILE *a2)
{
  int v4;
  uint64_t v5;
  int v6;
  _BOOL4 v7;
  int *result;

  v4 = *__error();
  sub_100054914(a1);
  *(_QWORD *)a1 = a2;
  *(_DWORD *)(a1 + 60) = 1;
  v5 = qword_10008B2E8;
  if (qword_10008B2E8)
    v5 = *(_QWORD *)(qword_10008B2E8 + 8 * qword_10008B2F0);
  if (v5 != a1)
    *(_QWORD *)(a1 + 52) = 1;
  if (a2)
  {
    v6 = fileno(a2);
    v7 = isatty(v6) > 0;
  }
  else
  {
    v7 = 0;
  }
  *(_DWORD *)(a1 + 44) = v7;
  result = __error();
  *result = v4;
  return result;
}

void *sub_100054904(size_t a1)
{
  return malloc_type_malloc(a1, 0xFA1A264CuLL);
}

uint64_t sub_100054914(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;

  if (result)
  {
    *(_QWORD *)(result + 32) = 0;
    **(_BYTE **)(result + 8) = 0;
    *(_BYTE *)(*(_QWORD *)(result + 8) + 1) = 0;
    *(_QWORD *)(result + 16) = *(_QWORD *)(result + 8);
    *(_DWORD *)(result + 48) = 1;
    *(_DWORD *)(result + 64) = 0;
    if (qword_10008B2E8)
      v1 = *(_QWORD *)(qword_10008B2E8 + 8 * qword_10008B2F0);
    else
      v1 = 0;
    if (v1 == result)
    {
      v2 = *(_QWORD *)(qword_10008B2E8 + 8 * qword_10008B2F0);
      qword_10008B320 = *(_QWORD *)(v2 + 32);
      qword_10008B308 = *(_QWORD *)(v2 + 16);
      qword_10008C760 = qword_10008B308;
      qword_10008C740 = **(_QWORD **)(qword_10008B2E8 + 8 * qword_10008B2F0);
      byte_10008B310 = *(_BYTE *)qword_10008B308;
    }
  }
  return result;
}

_QWORD *sub_1000549B4(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;

  if (result)
  {
    v1 = result;
    result = sub_1000541E0();
    v2 = qword_10008B2E8;
    v3 = qword_10008B2F0;
    if (qword_10008B2E8)
    {
      if (*(_QWORD *)(qword_10008B2E8 + 8 * qword_10008B2F0))
      {
        v4 = qword_10008B308;
        *(_BYTE *)qword_10008B308 = byte_10008B310;
        *(_QWORD *)(*(_QWORD *)(v2 + 8 * v3) + 16) = v4;
        *(_QWORD *)(*(_QWORD *)(v2 + 8 * v3++) + 32) = qword_10008B320;
        qword_10008B2F0 = v3;
      }
    }
    *(_QWORD *)(v2 + 8 * v3) = v1;
    v5 = v1[4];
    qword_10008B308 = v1[2];
    qword_10008C760 = qword_10008B308;
    v6 = *(uint64_t **)(v2 + 8 * v3);
    qword_10008B320 = v5;
    qword_10008C740 = *v6;
    byte_10008B310 = *(_BYTE *)qword_10008B308;
  }
  return result;
}

void sub_100054A5C()
{
  void **v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  if (qword_10008B2E8)
  {
    v0 = *(void ***)(qword_10008B2E8 + 8 * qword_10008B2F0);
    if (v0)
    {
      sub_100054408(v0);
      v1 = qword_10008B2E8;
      v2 = qword_10008B2F0;
      *(_QWORD *)(qword_10008B2E8 + 8 * qword_10008B2F0) = 0;
      if (v2)
      {
        v3 = v2 - 1;
        qword_10008B2F0 = v3;
        v4 = *(_QWORD *)(v1 + 8 * v3);
        if (v4)
        {
          qword_10008B320 = *(_QWORD *)(v4 + 32);
          qword_10008B308 = *(_QWORD *)(v4 + 16);
          qword_10008C760 = qword_10008B308;
          qword_10008C740 = **(_QWORD **)(v1 + 8 * v3);
          byte_10008B310 = *(_BYTE *)qword_10008B308;
        }
      }
    }
  }
}

char *sub_100054AF0(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  char *v4;
  char *v6;

  v2 = a2 - 2;
  if (a2 < 2 || *(_BYTE *)(a1 + v2) || *(_BYTE *)(a2 + a1 - 1))
    return 0;
  v6 = (char *)malloc_type_malloc(0x48uLL, 0xFA1A264CuLL);
  if (!v6)
    sub_100054788("out of dynamic memory in yy_scan_buffer()");
  v4 = v6;
  *((_DWORD *)v6 + 6) = v2;
  *((_QWORD *)v6 + 1) = a1;
  *((_QWORD *)v6 + 2) = a1;
  *(_QWORD *)v6 = 0;
  *((_QWORD *)v6 + 4) = (int)v2;
  *((_QWORD *)v6 + 5) = 0;
  *((_DWORD *)v6 + 12) = 1;
  *(_QWORD *)(v6 + 60) = 0;
  sub_1000545E8((uint64_t)v6);
  return v4;
}

char *sub_100054B8C(char *a1)
{
  uint64_t v2;

  v2 = (int)strlen(a1);
  return sub_100054BB4(a1, v2);
}

char *sub_100054BB4(char *a1, uint64_t a2)
{
  unint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  uint64_t v7;
  char v8;
  char *result;

  v4 = a2 + 2;
  v5 = malloc_type_malloc(a2 + 2, 0xFA1A264CuLL);
  if (!v5)
    sub_100054788("out of dynamic memory in yy_scan_bytes()");
  if (a2)
  {
    v6 = v5;
    v7 = a2;
    do
    {
      v8 = *a1++;
      *v6++ = v8;
      --v7;
    }
    while (v7);
  }
  *(_WORD *)&v5[a2] = 0;
  result = sub_100054AF0((uint64_t)v5, v4);
  if (!result)
    sub_100054788("bad buffer in yy_scan_bytes()");
  *((_DWORD *)result + 10) = 1;
  return result;
}

uint64_t sub_100054C40()
{
  return dword_100088534;
}

uint64_t sub_100054C4C()
{
  return qword_10008C740;
}

uint64_t sub_100054C58()
{
  return qword_10008C748;
}

uint64_t sub_100054C64()
{
  return qword_10008C758;
}

uint64_t sub_100054C70()
{
  return qword_10008C760;
}

uint64_t sub_100054C7C(uint64_t result)
{
  dword_100088534 = result;
  return result;
}

uint64_t sub_100054C88(uint64_t result)
{
  qword_10008C740 = result;
  return result;
}

uint64_t sub_100054C94(uint64_t result)
{
  qword_10008C748 = result;
  return result;
}

uint64_t sub_100054CA0()
{
  return dword_10008C750;
}

uint64_t sub_100054CAC(uint64_t result)
{
  dword_10008C750 = result;
  return result;
}

uint64_t sub_100054CB8()
{
  _QWORD *i;

  for (i = (_QWORD *)qword_10008B2E8; qword_10008B2E8; i = (_QWORD *)qword_10008B2E8)
  {
    if (!i[qword_10008B2F0])
      break;
    sub_100054408((void **)i[qword_10008B2F0]);
    *(_QWORD *)(qword_10008B2E8 + 8 * qword_10008B2F0) = 0;
    sub_100054A5C();
  }
  free(i);
  qword_10008B2E8 = 0;
  qword_10008B2F0 = 0;
  qword_10008B328 = 0;
  qword_10008B308 = 0;
  byte_10008B2E0 = 0;
  dword_10008B2E4 = 0;
  qword_10008C740 = 0;
  qword_10008C748 = 0;
  return 0;
}

void *sub_100054D4C(void *a1, size_t a2)
{
  return malloc_type_realloc(a1, a2, 0xCDB0C269uLL);
}

void sub_100054D58(uint64_t a1)
{
  NSObject *v1;

  if (dword_10008BA20)
  {
    v1 = ne_log_obj(a1);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1000690B8();
  }
  ++dword_10008C754;
}

void sub_100054DB8(uint64_t a1)
{
  NSObject *v1;

  if (dword_10008BA20)
  {
    v1 = ne_log_obj(a1);
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
      sub_1000690B8();
  }
}

uint64_t sub_100054E08(const char *a1)
{
  NSObject *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t result;
  uint64_t v11;
  NSObject *v12;
  _BOOL4 v13;
  uint64_t v14;
  int *v15;
  _DWORD *v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  const char *v20;
  int *v21;
  int v22;
  uint64_t v23;
  int v24;
  const char *v25;

  if (dword_10008B330[0] < 10)
  {
    v11 = glob(a1, 2048, 0, (glob_t *)&dword_10008B330[32 * (uint64_t)dword_10008B330[0] + 10]);
    if ((_DWORD)v11
      || (v14 = dword_10008B330[0], v15 = &dword_10008B330[32 * (uint64_t)dword_10008B330[0]], !*((_QWORD *)v15 + 5)))
    {
      if (dword_10008BA20)
      {
        v12 = ne_log_obj(v11);
        v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
        result = 0;
        if (!v13)
          return result;
        v24 = 136315138;
        v25 = a1;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "glob found no matches for path \"%s\"\n", (uint8_t *)&v24, 0xCu);
      }
      return 0;
    }
    else
    {
      v15[32] = 0;
      v16 = v15 + 32;
      v17 = qword_10008B2E8;
      if (qword_10008B2E8)
        v17 = *(_QWORD *)(qword_10008B2E8 + 8 * qword_10008B2F0);
      v18 = 0;
      v19 = 0;
      *(_QWORD *)&dword_10008B330[32 * v14 + 6] = v17;
      LODWORD(v17) = v14 + 1;
      while (1)
      {
        v20 = *(const char **)(*(_QWORD *)&dword_10008B330[32 * v14 + 18] + 8 * v18);
        *v16 = v19 + 1;
        dword_10008B330[0] = v17;
        if (!sub_100054470(v20))
          break;
        v17 = dword_10008B330[0];
        v14 = --dword_10008B330[0];
        v21 = &dword_10008B330[32 * v17 - 32];
        v22 = v21[32];
        v16 = v21 + 32;
        v19 = v22;
        v18 = v22;
        if (*((_QWORD *)v16 - 11) <= (unint64_t)v22)
          return 0xFFFFFFFFLL;
      }
      v23 = sub_10005429C((FILE *)qword_10008C740, 0x4000);
      sub_1000545E8(v23);
      result = 0;
      dword_10008B2E4 = 3;
    }
  }
  else
  {
    if (dword_10008BA20)
    {
      v1 = ne_log_obj(a1);
      if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
        sub_100069124(v1, v2, v3, v4, v5, v6, v7, v8);
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

void sub_100054FD4()
{
  uint64_t v0;
  _OWORD *v1;

  v0 = &dword_100000008;
  do
  {
    v1 = (_OWORD *)((char *)&dword_10008B330 + v0);
    v1[6] = 0uLL;
    v1[7] = 0uLL;
    v1[4] = 0uLL;
    v1[5] = 0uLL;
    v1[2] = 0uLL;
    v1[3] = 0uLL;
    v0 += 128;
    *v1 = 0uLL;
    v1[1] = 0uLL;
  }
  while (v0 != 1288);
  dword_10008B330 = 0;
}

void sub_100055010()
{
  uint64_t i;
  int *v1;

  for (i = 0; i != 320; i += 32)
  {
    v1 = &dword_10008B330[i];
    if (*(_QWORD *)&dword_10008B330[i + 2])
    {
      fclose(*((FILE **)v1 + 2));
      free(*((void **)v1 + 1));
      *((_QWORD *)v1 + 1) = 0;
    }
  }
}

void sub_10005508C(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x1Cu);
}

void sub_1000550B8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Phase 1 negotiation failed.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000550E4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to process packet.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100055110()
{
  os_log_t v0;
  uint8_t v1[16];

  sub_100003F1C();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "===\n", v1, 2u);
  sub_100003F14();
}

void sub_100055148()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to pre-process packet.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100055174()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Phase 2 negotiation failed.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000551A0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "no buffer found as sendbuf\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000551CC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100004A6C(__stack_chk_guard);
  sub_100004A78();
  sub_100004A54((void *)&_mh_execute_header, v0, v1, "hash(%s)\n", v2, v3, v4, v5, v6);
  sub_100004A64();
}

void sub_10005522C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100004A6C(__stack_chk_guard);
  sub_100004A78();
  sub_100004A54((void *)&_mh_execute_header, v0, v1, "hmac(%s)\n", v2, v3, v4, v5, v6);
  sub_100004A64();
}

void sub_10005528C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100004A6C(__stack_chk_guard);
  sub_100004A78();
  sub_100004A54((void *)&_mh_execute_header, v0, v1, "encryption(%s)\n", v2, v3, v4, v5, v6);
  sub_100004A64();
}

void sub_1000552EC(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100004A84((void *)&_mh_execute_header, a2, a3, "unknown algorithm class %d\n", a5, a6, a7, a8, 0);
  sub_100003F14();
}

void sub_100055350(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100003F04((void *)&_mh_execute_header, a1, a3, "key length is not allowed", a5, a6, a7, a8, 0);
  sub_100003F14();
}

void sub_100055380(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100003F04((void *)&_mh_execute_header, a1, a3, "key length out of range\n", a5, a6, a7, a8, 0);
  sub_100003F14();
}

void sub_1000553B0(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100004A84((void *)&_mh_execute_header, a2, a3, "key length %d is not multiple of 8\n", a5, a6, a7, a8, 0);
  sub_100003F14();
}

void sub_100055414()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "unable to get a certifcate reference.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100055440()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "current time after valid time\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005546C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "current time before valid time\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100055498()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "CFAbsoluteTimeGetCurrent() failed", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000554C4()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100005D60();
  sub_100005D58(v0);
  sub_100005D34();
  sub_100005D20((void *)&_mh_execute_header, v1, v2, "check_x509cert error %d %s.\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_10005552C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "unable to create CFArray.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100055558()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100005D60();
  sub_100005D58(v0);
  sub_100005D34();
  sub_100005D20((void *)&_mh_execute_header, v1, v2, "EvaluateCert error %d %s.\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_1000555C0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "-----------------------------------------------------.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000555EC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "---------------Returned error strings: ---------------.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100055618(int *a1, NSObject *a2)
{
  int v2;
  _DWORD v3[2];

  v2 = *a1;
  v3[0] = 67109120;
  v3[1] = v2;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "eval result unknown: value = %d.\n", (uint8_t *)v3, 8u);
  sub_100003F14();
}

void sub_10005568C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "eval result = kSecTrustResultInvalid.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000556B8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "eval result = kSecTrustResultProceed.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000556E4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "eval result = kSecTrustResultDeny.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100055710()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "eval result = kSecTrustResultUnspecified.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005573C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "eval result = kSecTrustResultRecoverableTrustFailure.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100055768()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "eval result = kSecTrustResultFatalTrustFailure.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100055794()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "eval result = kSecTrustResultOtherError.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000557C0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Error evaluating certificate.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000557EC(int a1, NSObject *a2)
{
  int v2;
  const char *v3;
  __int16 v4;
  int v5;

  v2 = 136315394;
  v3 = "crypto_cssm_check_x509cert";
  v4 = 1024;
  v5 = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "%s: checking chain of %d certificates.\n", (uint8_t *)&v2, 0x12u);
}

void sub_100055874()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "unable to create dictionary for policy properties.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000558A0()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100005D60();
  sub_100005D58(v0);
  sub_100005D34();
  sub_100005D20((void *)&_mh_execute_header, v1, v2, "getsign error %d %s.\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_100055908()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100005D60();
  sub_100005D58(v0);
  sub_100005D34();
  sub_100005D20((void *)&_mh_execute_header, v1, v2, "get_x509cert error %d %s.\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_100055970()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "unable to allocate space for addr.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005599C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "unable to duplicate addr.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000559C8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "unable to duplicate ifname.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000559F4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "unable to allocate space for natt addr.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100055A20()
{
  char **v0;
  _DWORD *v1;
  int *v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;

  v2 = sub_100007E80();
  v3 = sub_100007E40(v2);
  *v1 = 136315138;
  *v0 = v3;
  sub_100007E5C((void *)&_mh_execute_header, v4, v5, "socket(SOCK_DGRAM) failed:%s\n");
  sub_100007E9C();
}

void sub_100055A64()
{
  char **v0;
  _DWORD *v1;
  int *v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;

  v2 = sub_100007E80();
  v3 = sub_100007E40(v2);
  *v1 = 136315138;
  *v0 = v3;
  sub_100007E5C((void *)&_mh_execute_header, v4, v5, "ioctl(SIOCGIFAFLAG_IN6) failed:%s\n");
  sub_100007E9C();
}

void sub_100055AA8(uint8_t *buf, _BYTE *a2, os_log_t log)
{
  *buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "failed to put IPv6 socket in non-blocking mode\n", buf, 2u);
}

void sub_100055AE4(NSObject *a1)
{
  int *v2;
  int v3;
  char *v4;

  v2 = sub_100007EA8();
  v3 = 136315138;
  v4 = sub_100007E40(v2);
  _os_log_error_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_ERROR, "getifaddrs failed: %s\n", (uint8_t *)&v3, 0xCu);
  sub_100005D4C();
}

void sub_100055B64()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to allocate buffer for myaddrs.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100055B90()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to allocate buffer for duplicate addr.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100055BBC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to allocate buffer for duplicate ifname.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100055BE8(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100007E70((void *)&_mh_execute_header, a2, a3, "%d addrs are configured successfully\n", a5, a6, a7, a8, 0);
  sub_100003F14();
}

void sub_100055C4C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "configuring default isakmp port.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100055C78(uint8_t *a1, uint64_t a2, _DWORD *a3, NSObject *a4)
{
  int v4;

  v4 = *(unsigned __int8 *)(*(_QWORD *)a2 + 1);
  *(_DWORD *)a1 = 67109120;
  *a3 = v4;
  sub_100007E90((void *)&_mh_execute_header, a4, (uint64_t)a3, "unsupported AF %d\n", a1);
}

void sub_100055CC0(uint64_t a1, NSObject *a2, uint64_t a3)
{
  int v3;
  _DWORD v4[2];

  v3 = *(unsigned __int8 *)(a1 + 1);
  v4[0] = 67109120;
  v4[1] = v3;
  sub_100007E90((void *)&_mh_execute_header, a2, a3, "no socket matches address family %d\n", (uint8_t *)v4);
  sub_100003F14();
}

void sub_100055D2C()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v0 = sub_100007EA8();
  sub_100007E40(v0);
  sub_100007E48((void *)&_mh_execute_header, v1, v2, "read(PF_ROUTE) failed: %s\n", v3, v4, v5, v6, 2u);
  sub_100005D4C();
}

void sub_100055D9C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "read(PF_ROUTE) short read\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100055DC8(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100007E70((void *)&_mh_execute_header, a2, a3, "caught rtm:%d, need update interface address list\n", a5, a6, a7, a8, 0);
  sub_100003F14();
}

void sub_100055E30()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v0 = sub_100007EA8();
  sub_100007E40(v0);
  sub_100007E48((void *)&_mh_execute_header, v1, v2, "socket(PF_ROUTE) failed: %s", v3, v4, v5, v6, 2u);
  sub_100005D4C();
}

void sub_100055EA0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "could not create pfroute socket source.", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100055ECC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "failed to put PF_ROUTE socket in non-blocking mode\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100055EF8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "no match\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100055F24()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "matched\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100055F50(_DWORD *a1, uint64_t a2, uint64_t **a3)
{
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v5 = sub_10003C570(*(const sockaddr **)(a2 + 48));
  *a1 = 136315138;
  *a3 = v5;
  sub_10000AB88((void *)&_mh_execute_header, v6, v7, "p->remote: %s\n");
  sub_100007E9C();
}

void sub_100055FA0(_DWORD *a1, uint64_t a2, uint64_t **a3)
{
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v5 = sub_10003C570(*(const sockaddr **)(a2 + 56));
  *a1 = 136315138;
  *a3 = v5;
  sub_10000AB88((void *)&_mh_execute_header, v6, v7, "p->local: %s\n");
  sub_100007E9C();
}

void sub_100055FF0(const sockaddr *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_10003C570(a1);
  sub_100007E48((void *)&_mh_execute_header, v1, v2, "remote: %s\n", v3, v4, v5, v6, 2u);
  sub_100005D4C();
}

void sub_100056060(const sockaddr *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_10003C570(a1);
  sub_100007E48((void *)&_mh_execute_header, v1, v2, "local: %s\n", v3, v4, v5, v6, 2u);
  sub_100005D4C();
}

void sub_1000560D0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "getph1byaddr: start\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000560FC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to allocate buffer.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100056128(uint64_t a1, NSObject *a2)
{
  int v2;
  uint64_t v3;

  v2 = 134217984;
  v3 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "already responded within the past %ld secs\n", (uint8_t *)&v2, 0xCu);
  sub_100004A64();
}

void sub_100056198()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "sendfromto failed\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000561C4(int *a1, uint64_t a2, os_log_t log)
{
  int v3;
  uint64_t v4;
  _DWORD v5[2];
  __int16 v6;
  uint64_t v7;
  __int16 v8;
  int v9;

  v3 = *a1;
  v4 = **(_QWORD **)(a2 + 24);
  v5[0] = 67109632;
  v5[1] = v3;
  v6 = 2048;
  v7 = v4;
  v8 = 1024;
  v9 = 1280;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "!!! skipped retransmitting frags: frag_flags %x, r->sendbuf->l %zu, max %d\n", (uint8_t *)v5, 0x18u);
  sub_100004A64();
}

void sub_100056260()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "!!! retransmitting frags\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005628C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to allocate extra buf for non-esp\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000562B8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "Adding NON-ESP marker\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000562E4()
{
  uint64_t v0;
  os_log_t v1;
  int v2;
  int v3;

  sub_10000ABB0();
  sub_10000AB9C((void *)&_mh_execute_header, v0, v1, "Failed to get IPv4 address for Phase 1 (family=%u, NAT64Prefix=%u)\n", v2, v3);
  sub_100004A64();
}

void sub_100056350()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Failed to extract IPv4 from Phase 1 IPv6 address.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005637C()
{
  uint64_t v0;
  os_log_t v1;
  int v2;
  int v3;

  sub_10000ABB0();
  sub_10000AB9C((void *)&_mh_execute_header, v0, v1, "Failed to get IPv4 address for Phase 2 (family=%u, NAT64Prefix=%u)\n", v2, v3);
  sub_100004A64();
}

void sub_1000563E8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Failed to extract IPv4 from Phase 2 IPv6 address.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100056414()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "no suitable proposal found.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100056440(uint64_t a1)
{
  void *v1;
  os_log_t v2;
  os_log_type_t v3;
  const char *v4;
  uint8_t *v5;

  sub_10003E3EC(*(_DWORD *)(*(_QWORD *)a1 + 48));
  sub_100012054();
  sub_100012060();
  _os_log_debug_impl(v1, v2, v3, v4, v5, 0xCu);
  sub_100005D4C();
}

void sub_1000564BC()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[16];

  sub_100003F1C();
  sub_100011FA0((void *)&_mh_execute_header, v0, v1, "an acceptable proposal found.\n", v2);
  sub_100003F14();
}

void sub_1000564EC()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_100004A6C(__stack_chk_guard);
  sub_100004A78();
  sub_100011FAC((void *)&_mh_execute_header, v0, v1, "Invalid SA length = %zu.\n", v2);
  sub_100004A64();
}

void sub_100056550()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid situation 0x%08x.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000565B0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get buffer.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000565DC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100012048();
  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "Invalid payload type=%u\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005663C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "no Proposal found.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100056668(int *a1, NSObject *a2, uint64_t a3)
{
  int v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  int v7;

  v3 = *a1;
  v4 = 134218240;
  v5 = 8;
  v6 = 1024;
  v7 = v3;
  sub_100011FE0((void *)&_mh_execute_header, a2, a3, "get_proppair invalid length of proposal, expected %lu actual %d\n", (uint8_t *)&v4);
  sub_100004A64();
}

void sub_1000566E4()
{
  uint64_t v0;
  NSObject *v1;
  uint8_t v2[8];
  __int16 v3;
  uint64_t v4;

  sub_100011FEC();
  v3 = 2048;
  v4 = v0;
  sub_100011FE0((void *)&_mh_execute_header, v1, (uint64_t)v1, "get_proppair invalid length of proposal spi size, expected %u actual %zu\n", v2);
  sub_100004A64();
}

void sub_100056764()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "situation 0x%08x unsupported yet.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000567C4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid value of DOI 0x%08x.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100056824(_BYTE *a1, _BYTE *a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_100011F90(a1, a2);
  sub_100011F78((void *)&_mh_execute_header, v2, (uint64_t)v2, "Unexpected proposal_check value\n", v3);
}

void sub_100056850(_BYTE *a1, _BYTE *a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_100011F90(a1, a2);
  sub_100011FA0((void *)&_mh_execute_header, v2, (uint64_t)v2, "Compared: DB:Peer\n", v3);
}

void sub_10005687C(uint64_t a1, uint64_t a2)
{
  void *v2;
  os_log_t v3;
  os_log_type_t v4;
  const char *v5;
  uint8_t *v6;

  sub_10003DF24(*(unsigned __int8 *)(a2 + 5), *(unsigned __int8 *)(a1 + 5));
  sub_100012060();
  _os_log_debug_impl(v2, v3, v4, v5, v6, 0x12u);
  sub_100005D4C();
}

void sub_100056910(uint64_t a1)
{
  void *v1;
  os_log_t v2;
  os_log_type_t v3;
  const char *v4;
  uint8_t *v5;

  sub_10003DCFC(*(unsigned __int8 *)(a1 + 5));
  sub_100012060();
  _os_log_debug_impl(v1, v2, v3, v4, v5, 0x1Eu);
}

void sub_1000569CC()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_100011FB8();
  sub_100011FE0((void *)&_mh_execute_header, v0, v1, "t2isakmpsa invalid length of isakmp data, expected %zu actual %d\n", v2);
  sub_100004A64();
}

void sub_100056A30()
{
  uint64_t v0;
  os_log_t v1;
  int v2;
  int v3;

  sub_100011FF8();
  sub_10000AB9C((void *)&_mh_execute_header, v0, v1, "t2isakmpsa: packet too short - attr length %u for type %d\n", v2, v3);
  sub_100004A64();
}

void sub_100056A9C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "keylen must not be specified for encryption algorithm %d\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100056B00()
{
  NSObject *v0;
  uint8_t v1[24];

  sub_100012010();
  sub_100011FE0((void *)&_mh_execute_header, v0, (uint64_t)v0, "invalid ISAKMP-SA attr - OAKLEY_ATTR_GRP_GEN_ONE, attr-len %d, overall-len %lu\n", v1);
  sub_100004A64();
}

void sub_100056B68()
{
  NSObject *v0;
  uint8_t v1[24];

  sub_100012010();
  sub_100011FE0((void *)&_mh_execute_header, v0, (uint64_t)v0, "invalid ISAKMP-SA attr - OAKLEY_ATTR_GRP_GEN_TWO, attr-len %d, overall-len %lu\n", v1);
  sub_100004A64();
}

void sub_100056BD0(_BYTE *a1, _BYTE *a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_100011F90(a1, a2);
  sub_100011F78((void *)&_mh_execute_header, v2, (uint64_t)v2, "life duration must follow ltype\n", v3);
}

void sub_100056BFC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid life type: %d\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100056C5C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "invalid life duration.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100056C88()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "keylen %d: not multiple of 8\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100056CE8()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_100004A6C(__stack_chk_guard);
  sub_100004A78();
  sub_100011FAC((void *)&_mh_execute_header, v0, v1, "length %zu of life duration isn't supported.\n", v2);
  sub_100004A64();
}

void sub_100056D4C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "no suitable policy found.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100056D78(_BYTE *a1, _BYTE *a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_100011F90(a1, a2);
  sub_100011F78((void *)&_mh_execute_header, v2, (uint64_t)v2, "not matched\n", v3);
}

void sub_100056DA4(_BYTE *a1, _BYTE *a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_100011F90(a1, a2);
  sub_100011F78((void *)&_mh_execute_header, v2, (uint64_t)v2, "failed to get buffer.\n", v3);
}

void sub_100056DD0(_BYTE *a1, _BYTE *a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_100011F90(a1, a2);
  sub_100011FA0((void *)&_mh_execute_header, v2, (uint64_t)v2, "matched\n", v3);
}

void sub_100056DFC(_BYTE *a1, _BYTE *a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_100011F90(a1, a2);
  sub_100011FA0((void *)&_mh_execute_header, v2, (uint64_t)v2, "my single bundle:\n", v3);
}

void sub_100056E28(_BYTE *a1, _BYTE *a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_100011F90(a1, a2);
  sub_100011FA0((void *)&_mh_execute_header, v2, (uint64_t)v2, "peer's single bundle:\n", v3);
}

void sub_100056E54()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[16];

  sub_100003F1C();
  sub_100011FA0((void *)&_mh_execute_header, v0, v1, "begin compare proposals.\n", v2);
  sub_100003F14();
}

void sub_100056E84()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get newsa.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100056EB0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get prop pair.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100056EDC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "some proposals received.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100056F08()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "no proposal received.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100056F34()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "proposal mismathed.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100056F60()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "#of protocols mismatched.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100056F8C()
{
  uint64_t v0;
  os_log_t v1;
  int v2;

  sub_100004A6C(__stack_chk_guard);
  LOWORD(v2) = 1024;
  HIWORD(v2) = *(unsigned __int8 *)(*(_QWORD *)v0 + 5);
  sub_10000AB9C((void *)&_mh_execute_header, v0, v1, "proto_id mismathed: my:%d peer:%d\n", 67109376, v2);
  sub_100004A64();
}

void sub_100057008()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "no suitable transform found.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100057034()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "multi transforms replyed.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100057060()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid SPI size=%d for IPSEC proposal.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000570C0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid SPI size=%d for IPCOMP proposal.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100057120()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get newsa.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005714C()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_100011FB8();
  sub_100011FE0((void *)&_mh_execute_header, v0, v1, "check_attr_isakmp invalid length of isakmp data, expected %zu actual %d\n", v2);
  sub_100004A64();
}

void sub_1000571B0(int a1, NSObject *a2, uint64_t a3)
{
  _DWORD v3[2];
  __int16 v4;
  int v5;

  v3[0] = 67109376;
  v3[1] = 0;
  v4 = 1024;
  v5 = a1;
  sub_100011FD4((void *)&_mh_execute_header, a2, a3, "invalid length %d for TLV attribute %d.\n", (uint8_t *)v3);
  sub_100004A64();
}

void sub_100057224()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid attribute type %d.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100057284()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalied encryption algorithm=%d.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000572E4()
{
  uint64_t v0;
  os_log_t v1;
  int v2;
  int v3;

  sub_100012070();
  HIWORD(v3) = v0;
  sub_10000AB9C((void *)&_mh_execute_header, v0, v1, "check_attr_isakmp: packet too short - attr length %u for type %d\n", v2, v3);
  sub_100004A64();
}

void sub_100057348()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalied hash algorithm=%d.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000573A8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid auth method %d.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100057408(int a1, NSObject *a2)
{
  uint64_t v3;
  uint8_t v4[24];

  sub_10003E3EC(a1);
  sub_100012054();
  sub_100011FAC((void *)&_mh_execute_header, a2, v3, "auth method %s isn't supported.\n", v4);
  sub_100005D4C();
}

void sub_10005747C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid DH group %d.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000574DC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "unsupported DH group type %d.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005753C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "attr type=%u isn't supported.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005759C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid life type %d.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000575FC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100004A84((void *)&_mh_execute_header, a1, a3, "attr type=%u isn't supported.\n", a5, a6, a7, a8, 0);
  sub_100003F14();
}

void sub_100057668()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "oakley attribute %d must be TV.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000576C8()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_100011FB8();
  sub_100011FE0((void *)&_mh_execute_header, v0, v1, "check_attr_ipsec invalid length of isakmp data, expected %zu actual %d\n", v2);
  sub_100004A64();
}

void sub_10005772C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "must be TV when ENC_MODE.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100057758()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid encryption mode=%u.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000577B8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "attr AUTH must be present for ESP NULL encryption.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000577E4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "attr AUTH must be present for AH.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100057810(_BYTE *a1, _BYTE *a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_100011F90(a1, a2);
  sub_100011FA0((void *)&_mh_execute_header, v2, (uint64_t)v2, "UDP encapsulation requested\n", v3);
}

void sub_10005783C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "must be TV when AUTH.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100057868()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid auth algorithm=%u.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000578C8(unsigned __int8 *a1, uint64_t a2, NSObject *a3)
{
  int v3;

  LOWORD(v3) = 1024;
  HIWORD(v3) = *a1;
  sub_10000AB9C((void *)&_mh_execute_header, a2, a3, "auth algorithm %u conflicts with transform %u.\n", 67109376, v3);
  sub_100004A64();
}

void sub_10005793C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "auth algorithm %u isn't supported.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005799C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "must be TV when LD_TYPE.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000579C8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "invalid length of LD\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000579F4()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_10001202C();
  sub_100011FD4((void *)&_mh_execute_header, v0, v1, "check_attr_ipsec: packet too short - attr length %u for type %d\n", v2);
  sub_100004A64();
}

void sub_100057A58(_BYTE *a1, _BYTE *a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_100011F90(a1, a2);
  sub_100011FA0((void *)&_mh_execute_header, v2, (uint64_t)v2, "life duration was in TLV.\n", v3);
}

void sub_100057A84()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "must be TV when GRP_DESC.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100057AB0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid group description=%u.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100057B10()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "must be TV when KEY_LENGTH.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100057B3C()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_100011FB8();
  sub_100011FE0((void *)&_mh_execute_header, v0, v1, "check_attr_ipcomp: invalid length of isakmp data, expected %zu actual %d\n", v2);
  sub_100004A64();
}

void sub_100057BA0()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_10001202C();
  sub_100011FD4((void *)&_mh_execute_header, v0, v1, "check_attr_ipcomp: packet too short - attr length %u for type %d\n", v2);
  sub_100004A64();
}

void sub_100057C04(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100004A84((void *)&_mh_execute_header, a1, a3, "invalid attr type=%u.\n", a5, a6, a7, a8, 0);
  sub_100003F14();
}

void sub_100057C70()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to allocate my sa buffer\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100057C9C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "no suitable proposal was created.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100057CC8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid protocol: %d\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100057D2C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "no authentication algorithm found but protocol is AH.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100057D58()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Invalid IKE version detected\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100057D84()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid ipsec protocol %d\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100057DE4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "invalid iph1 passed id_p == NULL\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100057E10()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_100004A6C(__stack_chk_guard);
  sub_100004A78();
  sub_100011FAC((void *)&_mh_execute_header, v0, v1, "invalid value passed as \"ident\" (len=%lu)\n", v2);
  sub_100004A64();
}

void sub_100057E78(unsigned __int8 *a1, NSObject *a2)
{
  uint64_t v3;
  uint8_t v4[24];

  sub_10003E21C(*a1);
  sub_100012054();
  sub_100011FAC((void *)&_mh_execute_header, a2, v3, "Expecting IP address type in main mode, but %s.\n", v4);
  sub_100005D4C();
}

void sub_100057EF0()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[16];

  sub_100003F1C();
  sub_100011FA0((void *)&_mh_execute_header, v0, v1, "No ID match.\n", v2);
  sub_100003F14();
}

void sub_100057F20()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid family: %d\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100057F88()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed get my ID\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100057FB4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "invalid address family.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100057FE0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get ID buffer.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005800C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get own CERT.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100058038()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get SecCertificateRef\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100058064()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get subjectName\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100058090()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_100004A78();
  sub_100011FAC((void *)&_mh_execute_header, v0, v1, "No %s\n", v2);
  sub_100004A64();
}

void sub_10005810C()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_100004A78();
  sub_100011FAC((void *)&_mh_execute_header, v0, v1, "Empty %s\n", v2);
  sub_100004A64();
}

void sub_100058188()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "unknown qualifier", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000581B4()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_100004A6C(__stack_chk_guard);
  sub_100004A78();
  sub_100011FAC((void *)&_mh_execute_header, v0, v1, "can not open %s\n", v2);
  sub_100004A64();
}

void sub_100058218()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "can not allocate memory", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100058244()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_100004A6C(__stack_chk_guard);
  sub_100004A78();
  sub_100011FAC((void *)&_mh_execute_header, v0, v1, "invalid ip address %s\n", v2);
  sub_100004A64();
}

void sub_1000582A8()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[16];

  sub_100003F1C();
  sub_100011FA0((void *)&_mh_execute_header, v0, v1, "Setting ID type ASN1DN from string not supported\n", v2);
  sub_100003F14();
}

void sub_1000582D8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "no policy found for spid:%u.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005833C(unsigned __int8 *a1, NSObject *a2)
{
  uint64_t v3;
  uint8_t v4[24];

  sub_1000352C0(a1);
  sub_100012054();
  sub_100011FAC((void *)&_mh_execute_header, a2, v3, "failed to get ID for %s\n", v4);
  sub_100005D4C();
}

void sub_1000583B0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100012048();
  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid family: %d.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100058410()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid prefix length: %d.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100058470()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Address family mismatch\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005849C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100012048();
  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "unsupported ID type %d\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000584FC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100012048();
  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "unknown ID type %d\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005855C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "unable to extract asn1dn from id\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100058588()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_100011FB8();
  sub_100011FE0((void *)&_mh_execute_header, v0, v1, "ipsecdoi_t2satrns invalid length of isakmp data, expected %zu actual %d\n", v2);
  sub_100004A64();
}

void sub_1000585EC()
{
  uint64_t v0;
  os_log_t v1;
  int v2;
  int v3;

  sub_100011FF8();
  sub_10000AB9C((void *)&_mh_execute_header, v0, v1, "ipsecdoi_t2satrns: packet too short - attr length %u for type %d\n", v2, v3);
  sub_100004A64();
}

void sub_100058658(uint64_t a1, int a2, os_log_t log)
{
  _DWORD v3[2];
  __int16 v4;
  int v5;
  __int16 v6;
  uint64_t v7;

  v3[0] = 67109632;
  v3[1] = 2;
  v4 = 1024;
  v5 = a2;
  v6 = 2048;
  v7 = a1 - 4;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "invalid IPsec attr(%d), attr-len %d, overall-len %lu\n", (uint8_t *)v3, 0x18u);
  sub_100004A64();
}

void sub_1000586EC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get LD buffer.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100058718()
{
  int v0;
  NSObject *v1;
  uint8_t v2[12];
  __int16 v3;
  int v4;

  sub_100004A6C(__stack_chk_guard);
  sub_100004A78();
  v3 = 1024;
  v4 = v0;
  sub_100011FE0((void *)&_mh_execute_header, v1, (uint64_t)v1, "lifetime mismatched in a proposal, prev:%ld curr:%u.\n", v2);
  sub_100004A64();
}

void sub_10005878C()
{
  uint64_t v0;
  os_log_t v1;
  int v2;
  int v3;

  sub_100011FF8();
  sub_10000AB9C((void *)&_mh_execute_header, v0, v1, "lifebyte mismatched in a proposal, prev:%d curr:%u.\n", v2, v3);
  sub_100004A64();
}

void sub_1000587F0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "pfs_group mismatched in a proposal.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005881C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "multiple encmode exist in a transform.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100058848()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "multiple authtype exist in a transform.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100058874()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "key length defined but not ESP", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000588A0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid authentication algorithm:%d\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100058900()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "Illegal protocol id=%u.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100058960()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid protocol id %d.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000589C0()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[10];
  int v3;

  sub_100012070();
  v3 = 1;
  sub_100011FD4((void *)&_mh_execute_header, v0, v1, "invalid transform-id=%u in proto_id=%u.\n", v2);
  sub_100004A64();
}

void sub_100058A2C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid transform-id=%u in AH.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100058A8C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100004A84((void *)&_mh_execute_header, a1, a3, "not support transform-id=%u in AH.\n", a5, a6, a7, a8, 0);
  sub_100003F14();
}

void sub_100058AF8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid transform-id=%u in ESP.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100058B58()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "not support transform-id=%u in ESP.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100058BB8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid transform-id=%u in IPCOMP.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100058C18()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to set ID", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100058C44()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to set proposal", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100058C70()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "configuration failure about DH group.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100058C9C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to generate DH", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100058CC8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to generate NONCE", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100058CF4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to send packet", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100058D20(uint64_t a1, NSObject *a2)
{
  uint8_t v3[24];

  sub_10003E3EC(*(_DWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 248) + 48));
  sub_100012054();
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "authmethod is %s\n", v3, 0xCu);
  sub_100005D4C();
}

void sub_100058DA8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get CR", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100058DD4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Frag vendorID construction failed\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100058E00()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Unity vendor ID generation failed\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100058E2C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Xauth vendor ID generation failed\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100058E58()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "msg has to be NULL in this function.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100058E84()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100014F60();
  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "status mismatched %d.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100058EE4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to parse msg", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100058F10()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to process SA payload", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100058F3C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "ignore the packet, received unexpecting payload type %d.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100058FA0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "few isakmp message received.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100058FCC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get valid proposal.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100058FF8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to compute DH", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100059024()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to generate SKEYID", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100059050()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to generate SKEYID-DAE", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005907C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to generate ENCKEY", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000590A8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to generate IV", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000590D4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "invalid ID payload.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100059100()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to process KE payload", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005912C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to process NONCE payload", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100059158()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to process ID payload", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100059184()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to process CR payload", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000591B0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to process CERT payload", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000591DC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to process SIG payload", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100059208(_BYTE *a1, _BYTE *a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_100011F90(a1, a2);
  sub_100011FA0((void *)&_mh_execute_header, v2, (uint64_t)v2, "remote supports DPD\n", v3);
}

void sub_100059234(_BYTE *a1, _BYTE *a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_100011F90(a1, a2);
  sub_100011FA0((void *)&_mh_execute_header, v2, (uint64_t)v2, "remote supports FRAGMENTATION\n", v3);
}

void sub_100059260()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to pre-process NATD payload", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005928C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to process NATD payload", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000592B8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100014F6C();
  sub_100014F88((void *)&_mh_execute_header, v0, v1, "received invalid next payload type %d, expecting %d.\n", v2, v3, v4, v5, v6);
}

void sub_100059320()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to generate HASH", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005934C(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10003C8A0(*(const sockaddr **)(a1 + 48));
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "couldn't find the Hybrid pskey for %s.\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_1000593BC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to create hash.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000593E8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to allocate notification payload.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100059414()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to encrypt packet", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100059440()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to add a response packet to the tree.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005946C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to add contacted list.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100059498(const sockaddr **a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100014F54(a1);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "NAT-D hashing failed for %s\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_100059500()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get mycert", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005952C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get sign", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100059558()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[16];

  sub_100003F1C();
  sub_100011FA0((void *)&_mh_execute_header, v0, v1, "generate HASH_I\n", v2);
  sub_100003F14();
}

void sub_100059588(uint8_t *a1, unsigned __int8 *a2, char **a3, NSObject *a4)
{
  char *v7;

  v7 = sub_10003DBA0(*a2);
  *(_DWORD *)a1 = 136315138;
  *a3 = v7;
  _os_log_debug_impl((void *)&_mh_execute_header, a4, OS_LOG_TYPE_DEBUG, "received payload of type %s\n", a1, 0xCu);
}

void sub_1000595F0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to generate GSS HASH", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005961C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to add a response packet to the tree.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100059648()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Cannot create Unity vendor ID\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100059674()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Cannot create Xauth vendor ID\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000596A0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get mycert", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000596CC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Frag vendorID construction failed\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000596F8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get CR.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100059724()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[16];

  sub_100003F1C();
  sub_100011FA0((void *)&_mh_execute_header, v0, v1, "generate HASH_R\n", v2);
  sub_100003F14();
}

void sub_100059754()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to process CERT payload", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100059780()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to process SIG payload", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000597AC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to process NATD payload", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000597D8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to decrypt msg", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100059804()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_100015A64();
  sub_100015A44((void *)&_mh_execute_header, v0, v1, "%s: processed %d fragments\n", v2, v3, v4, v5, 2u);
  sub_100004A64();
}

void sub_100059870()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Cannot allocate memory\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005989C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "%s: sendfromto failed\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_10005990C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "%s: vbuf allocation failed\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_10005997C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Message too short\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000599A8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Fragment too short\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000599D4(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A44((void *)&_mh_execute_header, a2, a3, "%s: processed fragment %d\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100059A50()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "No fragment to reassemble\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100059A7C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_100015A64();
  sub_100015A44((void *)&_mh_execute_header, v0, v1, "%s: processed %d fragments\n", v2, v3, v4, v5, 2u);
  sub_100004A64();
}

void sub_100059AE8(int a1, NSObject *a2)
{
  _DWORD v2[2];

  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Missing fragment #%d\n", (uint8_t *)v2, 8u);
  sub_100003F14();
}

void sub_100059B58()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_100015A64();
  sub_100015A44((void *)&_mh_execute_header, v0, v1, "%s: processed %d fragments\n", v2, v3, v4, v5, 2u);
  sub_100004A64();
}

void sub_100059BC4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "sendfromto failed\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100059BF0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "%s: vbuf allocation failed\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100059C60()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to set proposal", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100059C8C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Unity vendor ID generation failed\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100059CB8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Xauth vendor ID generation failed\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100059CE4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "msg has to be NULL in this function.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100059D10()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100012048();
  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "ignore the packet, received unexpecting payload type %d.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100059D70(uint8_t *a1, _BYTE *a2, NSObject *a3)
{
  *a1 = 0;
  *a2 = 0;
  sub_100011FA0((void *)&_mh_execute_header, a3, (uint64_t)a3, "remote supports FRAGMENTATION\n", a1);
}

void sub_100059DA4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to create send buffer", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100059DD0(const sockaddr **a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_100014F54(a1);
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "NAT-D hashing failed for %s\n", v3, v4, v5, v6, 2u);
  sub_100005D4C();
}

void sub_100059E3C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get cr buffer.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100059E68()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to generate HASH", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100059E94()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to allocate send buffer", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100059EC0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to encrypt", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100059EEC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100018EC4();
  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid authentication type %d\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100059F4C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get CR", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100059F78()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100018EC4();
  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "not supported authentication type %d\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100059FD8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "ignore the packet, expecting the packet encrypted.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005A004()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to decrypt", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005A030()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "reject the packet, expecting the packet encrypted.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005A05C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100018EC4();
  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid authmethod %d why ?\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005A0BC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "ignore information because the message is way too short\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005A0E8(int a1, uint64_t a2, NSObject *a3)
{
  char *v5;
  int v6;
  int v7;
  int v8;
  char *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  int v13;

  v5 = sub_10003DBA0(a1);
  v6 = *(_DWORD *)(a2 + 16);
  v7 = *(_DWORD *)(a2 + 20);
  v8 = 136315650;
  v9 = v5;
  v10 = 1024;
  v11 = v6;
  v12 = 1024;
  v13 = v7;
  _os_log_error_impl((void *)&_mh_execute_header, a3, OS_LOG_TYPE_ERROR, "%s message must be encrypted, status 0x%x, side %d\n", (uint8_t *)&v8, 0x18u);
  sub_100005D4C();
}

void sub_10005A184(uint64_t a1, unsigned __int8 *a2)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;

  v2 = sub_10003DBA0(*a2);
  sub_10001C914((uint64_t)v2, 4.8149e-34);
  sub_100007E5C((void *)&_mh_execute_header, v3, v4, "reject the packet, received unexpected payload type %s.\n");
  sub_100007E9C();
}

void sub_10005A1D0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Delete Phase 1 handle.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005A1FC(_BYTE *a1, _BYTE *a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_100011F90(a1, a2);
  sub_100011F78((void *)&_mh_execute_header, v2, (uint64_t)v2, "Cannot allocate memory\n", v3);
}

void sub_10005A228()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Invalid spi_size in notification payload.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005A254(uint64_t a1, int a2)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;

  v2 = sub_10001C8EC(a1, a2);
  sub_10001C914((uint64_t)v2, 4.8149e-34);
  sub_100007E5C((void *)&_mh_execute_header, v3, v4, "Fatal %s notify messsage, Phase 1 should be deleted.\n");
  sub_100007E9C();
}

void sub_10005A290(uint64_t a1, int a2)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;

  v2 = sub_10001C8EC(a1, a2);
  sub_10001C914((uint64_t)v2, 4.8149e-34);
  sub_100007E5C((void *)&_mh_execute_header, v3, v4, "Fatal %s notify messsage, Phase 2 should be deleted.\n");
  sub_100007E9C();
}

void sub_10005A2CC(uint64_t a1, int a2)
{
  char *v2;
  uint64_t v3;
  uint64_t v4;

  v2 = sub_10001C8EC(a1, a2);
  sub_10001C914((uint64_t)v2, 4.8149e-34);
  sub_100007E5C((void *)&_mh_execute_header, v3, v4, "Unhandled notify message %s, no Phase 2 handle found.\n");
  sub_100007E9C();
}

void sub_10005A308()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "invalid spi_size in notification payload.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005A334(_BYTE *a1, _BYTE *a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_100011F90(a1, a2);
  sub_100011F78((void *)&_mh_execute_header, v2, (uint64_t)v2, "failed to get buffer to send.\n", v3);
}

void sub_10005A360(_BYTE *a1, _BYTE *a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_100011F90(a1, a2);
  sub_100011F78((void *)&_mh_execute_header, v2, (uint64_t)v2, "Cookie mismatch in DPD ACK!.\n", v3);
}

void sub_10005A38C(_BYTE *a1, _BYTE *a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_100011F90(a1, a2);
  sub_100011F78((void *)&_mh_execute_header, v2, (uint64_t)v2, "deletion payload with invalid length.\n", v3);
}

void sub_10005A3B8(uint8_t *a1, unsigned int *a2, unsigned int *a3, NSObject *a4)
{
  unsigned int v4;

  v4 = bswap32(*a2);
  *(_DWORD *)a1 = 67109120;
  *a3 = v4;
  sub_100007E90((void *)&_mh_execute_header, a4, (uint64_t)a3, "delete payload with invalid doi:%d.\n", a1);
}

void sub_10005A400(_BYTE *a1, _BYTE *a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_100011F90(a1, a2);
  sub_100011F78((void *)&_mh_execute_header, v2, (uint64_t)v2, "ignore Acknowledged Informational\n", v3);
}

void sub_10005A42C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "iph1->ivm == NULL\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005A458()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to compute IV\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005A484()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to decrypt packet\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005A4B0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "ignore information because ISAKMP-SA has not been established yet.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005A4DC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "ignore information because the message is too short\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005A508()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "too long payload length (broken message?)\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005A534()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "too short payload length (broken message?)\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005A560()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "cannot allocate memory\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005A58C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "cannot compute hash\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005A5B8()
{
  os_log_t v0;
  uint8_t v1[16];

  sub_100003F1C();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "hash validated.\n", v1, 2u);
  sub_100003F14();
}

void sub_10005A5F0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "ignore information due to hash mismatch\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005A61C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "ignore information due to hash length mismatch\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005A648()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "ignore information because the message has no hash payload.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005A674()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get buffer for payload.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005A6A0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to allocate ph2", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005A6CC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to duplicate remote address", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005A6F8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to duplicate local address", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005A724(uint64_t a1, NSObject *a2, uint64_t a3)
{
  int v3;
  _DWORD v4[2];

  v3 = *(unsigned __int8 *)(*(_QWORD *)a1 + 1);
  v4[0] = 67109120;
  v4[1] = v3;
  sub_100007E90((void *)&_mh_execute_header, a2, a3, "invalid family: %d\n", (uint8_t *)v4);
  sub_100003F14();
}

void sub_10005A794()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get buffer to send.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005A7C0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to encrypt packet", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005A7EC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "no configuration found for peer address.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005A818()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to allocate ph1", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005A844()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to copy ph1 addresses", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005A870()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get a payload buffer.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005A89C()
{
  const char *v0;
  uint64_t v1;
  uint64_t v2;

  v0 = sub_10001C920();
  sub_10001C914((uint64_t)v0, 4.8149e-34);
  sub_100007E5C((void *)&_mh_execute_header, v1, v2, "pfkey_check (%s)\n");
  sub_100007E9C();
}

void sub_10005A8D8(unsigned __int16 *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_10001C900(a1);
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "Received unknown notification type %s.\n", v3, v4, v5, v6, 2u);
  sub_100005D4C();
}

void sub_10005A944()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "invalid spi_size in notification payload.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005A970()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to send getspi message", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005A99C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "pfkey getspi sent.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005A9C8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to set proposal", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005A9F4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get ID.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005AA20()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to compute HASH", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005AA4C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get send buffer", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005AA78()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to generate NAT-OA payload.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005AAA4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to set DH value.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005AAD0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "msg has to be NULL in this function.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005AAFC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to set ISAKMP header", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005AB28()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Packet wasn't encrypted.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005AB54(uint64_t **a1, unsigned int *a2, os_log_t log)
{
  uint64_t v3;
  unsigned int v4;
  int v5;
  uint64_t v6;
  __int16 v7;
  unsigned int v8;

  v3 = **a1;
  v4 = bswap32(*a2);
  v5 = 134218240;
  v6 = v3;
  v7 = 1024;
  v8 = v4;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "invalid length (%lu,%d) while getting hash buffer.\n", (uint8_t *)&v5, 0x12u);
  sub_100004A64();
}

void sub_10005ABE4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get hash buffer.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005AC10()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to validate SA proposal", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005AC3C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "HASH(2) mismatch.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005AC68(uint8_t *a1, _BYTE *a2, NSObject *a3)
{
  *a1 = 0;
  *a2 = 0;
  sub_100011F78((void *)&_mh_execute_header, a3, (uint64_t)a3, "Ignored, multiple SA isn't supported.\n", a1);
}

void sub_10005AC9C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "mismatched ID was returned.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005ACC8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid length (%d) while allocating external nat id.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005AD2C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "memory error while allocating external nat id.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005AD58()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "memory error while allocating ph2's external nat id.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005AD84()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "memory error while allocating peers ph2's external nat id.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005ADB0(uint64_t a1, const sockaddr *a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;

  v2 = sub_1000210EC(a1, a2);
  sub_10001C914((uint64_t)v2, 4.8149e-34);
  sub_10000AB88((void *)&_mh_execute_header, v3, v4, "initiaor rcvd NAT-OA i: %s\n");
  sub_100007E9C();
}

void sub_10005ADEC(uint64_t a1, const sockaddr *a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;

  v2 = sub_1000210EC(a1, a2);
  sub_10001C914((uint64_t)v2, 4.8149e-34);
  sub_10000AB88((void *)&_mh_execute_header, v3, v4, "initiator rcvd NAT-OA r: %s\n");
  sub_100007E9C();
}

void sub_10005AE28()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100021120();
  sub_100014F88((void *)&_mh_execute_header, v0, v1, "received invalid next payload type %d, expecting %d.\n", v2, v3, v4, v5, v6);
  sub_100004A64();
}

void sub_10005AE8C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to create ISAKMP header", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005AEB8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to compute KEYMAT", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005AEE4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "pfkey update failed.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005AF10()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "pfkey add failed.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005AF3C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "pfkey add sent.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005AF68()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "pfkey update sent.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005AF94()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "call pk_sendupdate\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005AFC0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to send packet, commit-bit", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005AFEC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "HASH(3) generate\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B018()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to decrypt packet\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B044()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to parse msg\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B070()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to compute HASH\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B09C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "HASH(4) mismatch.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B0C8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get notify buffer.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B0F4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100014F60();
  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid length (%d) while extracting hash.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B158()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "expected isakmp payloads missing.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B184()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get proposal for responder.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B1B0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to select proposal.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B1DC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "PFS is specified, but peer doesn't sends KE.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B208()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "no PFS is specified, but peer sends KE.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B234()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to generate a proposal template from client's proposal.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B260()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get sainfo.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B28C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "HASH(1) mismatch.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B2B8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100012048();
  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "ignore the packet, received unexpected payload type %d.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B318()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to process SA payload\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B344()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Multi SAs isn't supported.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B370()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to process NONCE payload\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B39C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to process KE payload\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B3C8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to process IDci2 payload\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B3F4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to process IDcr2 payload\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B420(uint8_t *a1, _BYTE *a2, NSObject *a3)
{
  *a1 = 0;
  *a2 = 0;
  sub_100011F78((void *)&_mh_execute_header, a3, (uint64_t)a3, "IDr2 payload is not immediatelly followed by IDi2. We allowed.\n", a1);
}

void sub_10005B454(uint64_t a1, const sockaddr *a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;

  v2 = sub_1000210EC(a1, a2);
  sub_10001C914((uint64_t)v2, 4.8149e-34);
  sub_10000AB88((void *)&_mh_execute_header, v3, v4, "responder rcvd NAT-OA i: %s\n");
  sub_100007E9C();
}

void sub_10005B490(uint64_t a1, const sockaddr *a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;

  v2 = sub_1000210EC(a1, a2);
  sub_10001C914((uint64_t)v2, 4.8149e-34);
  sub_10000AB88((void *)&_mh_execute_header, v3, v4, "responder rcvd NAT-OA r: %s\n");
  sub_100007E9C();
}

void sub_10005B4CC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to set ID for source.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B4F8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to set ID for destination.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B524(uint64_t **a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10003A350(*a1);
  sub_100012054();
  sub_100007E48((void *)&_mh_execute_header, v1, v2, "selected sainfo: %s\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_10005B594()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to group check", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B5C0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "get_sainfo_r case 3.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B5EC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "get_sainfo_r about to try dst id only.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B618()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "get_sainfo_r case 2.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B644()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "get_sainfo_r case 1.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B670()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to send getspi", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B69C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to update spi.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B6C8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to set DH value.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B6F4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to generate DH public", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B720()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get send buffer", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B74C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to add RESPONDER-LIFETIME notify (type) payload", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B778()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to add RESPONDER-LIFETIME notify (value) payload", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B7A4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "invalid RESPONDER-LIFETIME payload", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B7D0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "Approved SA\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B7FC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to create NATOA payloads", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B828()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "msg has to be NULL in this function.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B854()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "HASH(3) mismatch.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B880()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to set ISAKMP header", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B8AC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "HASH(4) generate\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B8D8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to compute KEYMAT", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B904()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "pfkey spdupdate2(inbound) failed.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B930()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "pfkey spdupdate2(outbound) failed.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B95C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "pfkey spdupdate2(outbound) sent.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B988()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "pfkey spdupdate2(inbound) sent.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005B9B4(unsigned __int8 *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100021160(a1);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "no policy found: %s\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_10005BA1C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "buffer allocation failed.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005BA48()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to create saprop.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005BA74(unsigned __int8 *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100021160(a1);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "policy found, but no IPsec required: %s\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_10005BADC(unsigned __int8 *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100021160(a1);
  sub_100012054();
  sub_100007E48((void *)&_mh_execute_header, v1, v2, "suitable SP found:%s\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_10005BB44(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10003C570((const sockaddr *)(a1 + 136));
  sub_100021100();
  sub_10002113C((void *)&_mh_execute_header, v1, v2, "get dst address from ID payload %s prefixlen=%u ul_proto=%u\n", v3, v4, v5, v6, v7);
  sub_100021150();
}

void sub_10005BBC8(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10003C570((const sockaddr *)(a1 + 8));
  sub_100021100();
  sub_10002113C((void *)&_mh_execute_header, v1, v2, "get a src address from ID payload %s prefixlen=%u ul_proto=%u\n", v3, v4, v5, v6, v7);
  sub_100021150();
}

void sub_10005BC4C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "Get a source address of SP index from Phase 1 address due to no ID payloads found OR because ID type is not address.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005BC78()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "Get a destination address of SP index from Phase 1 address due to no ID payloads found OR because ID type is not address.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005BCA4(int a1, NSObject *a2)
{
  int v2;
  const char *v3;
  __int16 v4;
  int v5;

  v2 = 136315394;
  v3 = "get_proposal_r_remote";
  v4 = 1024;
  v5 = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "%s: ignore_id %x.\n", (uint8_t *)&v2, 0x12u);
  sub_100004A64();
}

void sub_10005BD28()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Why do ID[src,dst] exist already.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005BD54()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Both IDs wasn't found in payload.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005BD80()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "ignoring isakmp port until power-mgmt event is handled.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005BDAC()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  v0 = sub_100007EA8();
  sub_100007E40(v0);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "failed to receive isakmp packet: %s\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_10005BE18()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  v0 = sub_100007EA8();
  sub_100007E40(v0);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "failed to receive keep alive packet: %s\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_10005BE84()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[12];
  __int16 v3;
  uint64_t v4;

  sub_100012054();
  v3 = 2048;
  v4 = 28;
  sub_100027EC8((void *)&_mh_execute_header, v0, v1, "packet shorter than isakmp header size (size: %zu, minimum expected: %zu)\n", v2);
  sub_100004A64();
}

void sub_10005BEF8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "the length in the isakmp header is too big.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005BF24()
{
  NSObject *v0;
  uint8_t v1[8];

  sub_100011FEC();
  sub_100007E90((void *)&_mh_execute_header, v0, (uint64_t)v0, "failed to allocate reading buffer (%u Bytes)\n", v1);
  sub_100003F14();
}

void sub_10005BF98()
{
  void *v0;
  os_log_t v1;
  os_log_type_t v2;
  const char *v3;
  uint8_t *v4;

  sub_100012054();
  sub_100027EB8();
  _os_log_error_impl(v0, v1, v2, v3, v4, 0x12u);
  sub_100004A64();
}

void sub_10005C00C()
{
  os_log_t v0;
  uint8_t v1[24];

  sub_100012054();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "failed to allocate reading buffer (%lu Bytes)\n", v1, 0xCu);
  sub_100004A64();
}

void sub_10005C078()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid family: %d\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005C0DC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "src port == 0 (valid as UDP but not with IKE)\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005C108()
{
  void *v0;
  os_log_t v1;
  os_log_type_t v2;
  const char *v3;
  uint8_t *v4;

  sub_100027EB8();
  _os_log_error_impl(v0, v1, v2, v3, v4, 0x16u);
  sub_100004A64();
}

void sub_10005C184()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "malformed cookie received.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005C1B0(uint64_t a1, const sockaddr *a2, NSObject *a3)
{
  uint64_t v4;
  uint8_t v5[24];

  sub_100027EEC(a1, a2);
  sub_100005D34();
  sub_100011FE0((void *)&_mh_execute_header, a3, v4, "Invalid exchange type %d from %s.\n", v5);
  sub_100005D4C();
}

void sub_10005C220(unsigned __int8 *a1, unsigned __int8 *a2, NSObject *a3)
{
  char *v5;
  char *v6;
  uint64_t v7;
  int v8;
  char *v9;
  __int16 v10;
  char *v11;

  v5 = sub_10003DAB8(*a1);
  v6 = sub_10003DAB8(*a2);
  v8 = 136315394;
  v9 = v5;
  v10 = 2080;
  v11 = v6;
  sub_100027EC8((void *)&_mh_execute_header, a3, v7, "Exchange type is mismatched: db=%s packet=%s, ignore it.\n", (uint8_t *)&v8);
  sub_100021150();
}

void sub_10005C2BC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Message id should be zero in Phase 1.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005C2E8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Unknown Informational exchange received.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005C314(unsigned int *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  sub_100023E84(a2, *a1);
  sub_100014F40((void *)&_mh_execute_header, v2, v3, "Can't start the quick mode, there is no ISAKMP-SA, %s\n", v4, v5, v6, v7, 2u);
  sub_100005D4C();
}

void sub_10005C398(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_100027ED4(a1);
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "can't start the quick mode, there is no valid ISAKMP-SA, %s\n", v3, v4, v5, v6, 2u);
  sub_100005D4C();
}

void sub_10005C40C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "can't start the quick mode, invalid linked ISAKMP-SA\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005C438(uint64_t a1, const sockaddr *a2, NSObject *a3)
{
  uint64_t v4;
  uint8_t v5[24];

  sub_100027EEC(a1, a2);
  sub_100005D34();
  sub_100011FE0((void *)&_mh_execute_header, a3, v4, "mode config %d from %s, but we have no ISAKMP-SA.\n", v5);
  sub_100005D4C();
}

void sub_10005C4A8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "strdup failed\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005C4D4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Phase 1 failed: dupsaddr failed.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005C500()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Commit bit on Phase 1 forbidden.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005C52C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid flag 0x%02x.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005C590(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100004A84((void *)&_mh_execute_header, a2, a3, "invalid major version %d.\n", a5, a6, a7, a8, 0);
  sub_100003F14();
}

void sub_10005C5F4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "===\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005C620()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100027EA8();
  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid family: %d\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005C680()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to add contacted list.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005C6AC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get rekey timer - lifetime is too small... probably.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005C6D8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to send redirect message - memory error.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005C704()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "isakmp_parsewoh invalid length of payload (1)\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005C730()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "succeed.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005C75C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "begin.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005C788()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "no address could be bound.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005C7B4(uint8_t *a1, _DWORD *a2, NSObject *a3)
{
  int v3;

  v3 = *(_DWORD *)(qword_10008B848 + 24);
  *(_DWORD *)a1 = 67109120;
  *a2 = v3;
  sub_100007E90((void *)&_mh_execute_header, a3, (uint64_t)a3, "unsupported address family %d\n", a1);
}

void sub_10005C800()
{
  int *v0;
  char *v1;
  uint64_t v2;
  uint64_t v3;

  v0 = sub_100007E80();
  v1 = sub_100007E40(v0);
  sub_10001C914((uint64_t)v1, 4.8149e-34);
  sub_100007E5C((void *)&_mh_execute_header, v2, v3, "socket (%s)\n");
  sub_100007E9C();
}

void sub_10005C840()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  v0 = sub_100007EA8();
  sub_100007E40(v0);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "setsockopt IPV6_USE_MIN_MTU (%s)\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_10005C8AC()
{
  int *v0;
  char *v1;
  uint64_t v2;
  uint64_t v3;

  v0 = sub_100007E80();
  v1 = sub_100007E40(v0);
  sub_10001C914((uint64_t)v1, 4.8149e-34);
  sub_100007E5C((void *)&_mh_execute_header, v2, v3, "setsockopt SO_REUSEADDR (%s)\n");
  sub_100007E9C();
}

void sub_10005C8EC()
{
  int *v0;
  char *v1;
  uint64_t v2;
  uint64_t v3;

  v0 = sub_100007E80();
  v1 = sub_100007E40(v0);
  sub_10001C914((uint64_t)v1, 4.8149e-34);
  sub_100007E5C((void *)&_mh_execute_header, v2, v3, "setsockopt SO_REUSEPORT (%s)\n");
  sub_100007E9C();
}

void sub_10005C92C()
{
  int *v0;
  char *v1;
  uint64_t v2;
  uint64_t v3;

  v0 = sub_100007E80();
  v1 = sub_100007E40(v0);
  sub_10001C914((uint64_t)v1, 4.8149e-34);
  sub_100007E5C((void *)&_mh_execute_header, v2, v3, "setsockopt (%s)\n");
  sub_100007E9C();
}

void sub_10005C96C(uint64_t a1, const sockaddr **a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;

  v2 = sub_10003C570(*a2);
  sub_10001C914((uint64_t)v2, 4.8149e-34);
  sub_100007E5C((void *)&_mh_execute_header, v3, v4, "failed to bind to address %s: can't read interface address flags.\n");
  sub_100007E9C();
}

void sub_10005C9B8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "could not create isakmp socket source.", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005C9E4()
{
  int *v0;
  char *v1;
  uint64_t v2;
  uint64_t v3;

  v0 = sub_100007E80();
  v1 = sub_100007E40(v0);
  sub_10001C914((uint64_t)v1, 4.8149e-34);
  sub_100007E5C((void *)&_mh_execute_header, v2, v3, "setsockopt IP_RECVDSTADDR (%s)\n");
  sub_100007E9C();
}

void sub_10005CA24()
{
  int *v0;
  char *v1;
  uint64_t v2;
  uint64_t v3;

  v0 = sub_100007E80();
  v1 = sub_100007E40(v0);
  sub_10001C914((uint64_t)v1, 4.8149e-34);
  sub_100007E5C((void *)&_mh_execute_header, v2, v3, "setsockopt IP_BOUND_IF (%s)\n");
  sub_100007E9C();
}

void sub_10005CA64()
{
  int *v0;
  char *v1;
  uint64_t v2;
  uint64_t v3;

  v0 = sub_100007E80();
  v1 = sub_100007E40(v0);
  sub_10001C914((uint64_t)v1, 4.8149e-34);
  sub_100007E5C((void *)&_mh_execute_header, v2, v3, "setsockopt IPV6_BOUND_IF (%s)\n");
  sub_100007E9C();
}

void sub_10005CAA4(uint8_t *buf, _BYTE *a2, os_log_t log)
{
  *buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "failed to put socket in non-blocking mode\n", buf, 2u);
}

void sub_10005CAE0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "vbuf allocation failed\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005CB0C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "isakmp_sendfrags failed\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005CB38()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "sendfromto failed\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005CB64()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "Adding NON-ESP marker\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005CB90(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_100027ED4(a1);
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "Phase 1 negotiation failed due to time up. %s\n", v3, v4, v5, v6, 2u);
  sub_100005D4C();
}

void sub_10005CC04(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_100027ED4(a1);
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "Phase 1 negotiation failed due to send error. %s\n", v3, v4, v5, v6, 2u);
  sub_100005D4C();
}

void sub_10005CC78(const sockaddr **a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100027EE0(a1);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "Phase 1 rekey retry failed: no configuration found for %s.\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_10005CCE0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Internal error - attempt to re-send Phase 2 with no Phase 1 bound.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005CD0C(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  sub_100027E98(a1, a2);
  sub_100014F40((void *)&_mh_execute_header, v2, v3, "Phase 2 negotiation failed due to time up. %s\n", v4, v5, v6, v7, 2u);
  sub_100005D4C();
}

void sub_10005CD80(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  sub_100027E98(a1, a2);
  sub_100014F40((void *)&_mh_execute_header, v2, v3, "Phase 2 negotiation failed due to send error. %s\n", v4, v5, v6, v7, 2u);
  sub_100005D4C();
}

void sub_10005CDF4(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  sub_100027E98(a1, a2);
  sub_100014F40((void *)&_mh_execute_header, v2, v3, "Phase 2 negotiation failed due to Phase 1 expired. %s\n", v4, v5, v6, v7, 2u);
  sub_100005D4C();
}

void sub_10005CE68(const sockaddr **a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100027EE0(a1);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "Phase1 rekey failed: no configuration found for %s.\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_10005CED0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "Reschedule Phase 1 rekey.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005CEFC(const sockaddr **a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100027EE0(a1);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "No configuration found for %s.\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_10005CF64()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "In post_acquire\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005CF90()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "begin QUICK mode.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005CFBC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Attempt to start phase 2 whereas Xauth failed\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005CFE8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "the negotiation is stopped, because there is no suitable ISAKMP-SA.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005D014(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10002FA64(*(const sockaddr **)(a1 + 8), *(const sockaddr **)a1, *(unsigned __int8 *)(a1 + 104), 0, 0);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "Phase 2 negotiation failed due to time up waiting for Phase 1. %s\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_10005D094(const sockaddr **a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100014F54(a1);
  sub_100012054();
  sub_100007E48((void *)&_mh_execute_header, v1, v2, "dst: %s\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_10005D0FC(const sockaddr **a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100014F54(a1);
  sub_100012054();
  sub_100007E48((void *)&_mh_execute_header, v1, v2, "src: %s\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_10005D164()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "After:\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005D190(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10003C570(*(const sockaddr **)(a1 + 8));
  sub_100012054();
  sub_100007E48((void *)&_mh_execute_header, v1, v2, "dst: %s\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_10005D200()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "before:\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005D22C(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10003C570(*(const sockaddr **)(a1 + 48));
  sub_100012054();
  sub_100007E48((void *)&_mh_execute_header, v1, v2, "iph1->remote: %s\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_10005D29C(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10003C570(*(const sockaddr **)(a1 + 56));
  sub_100012054();
  sub_100007E48((void *)&_mh_execute_header, v1, v2, "iph1->local: %s\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_10005D30C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "CHKPH1THERE: got a ph1 handler, setting ports.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005D338()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get a attribute buffer.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005D364()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get a cookie.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005D390()
{
  os_log_t v0;
  uint8_t v1[24];

  sub_100012054();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "new cookie:\n%s\n", v1, 0xCu);
  sub_100004A64();
}

void sub_10005D3FC()
{
  void *v0;
  os_log_t v1;
  os_log_type_t v2;
  const char *v3;
  uint8_t *v4;

  sub_100011FEC();
  sub_100027EB8();
  _os_log_error_impl(v0, v1, v2, v3, v4, 0xEu);
  sub_100004A64();
}

void sub_10005D478()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "ignore this payload, invalid payload len %d.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005D4E4(uint64_t *a1, int a2, os_log_t log)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  int v7;

  v3 = *a1;
  v4 = 134218240;
  v5 = v3;
  v6 = 1024;
  v7 = a2;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "add payload of len %zu, next type %d\n", (uint8_t *)&v4, 0x12u);
  sub_100004A64();
}

void sub_10005D568()
{
  const char *v0;
  uint64_t v1;
  uint64_t v2;

  sub_100027EFC();
  v0 = ipsec_strerror();
  sub_10001C914((uint64_t)v0, 4.8149e-34);
  sub_100007E5C((void *)&_mh_execute_header, v1, v2, "pfkey_check (%s)\n");
  sub_100007E9C();
}

void sub_10005D5A8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "pfkey spddelete(outbound) failed.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005D5D4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "pfkey spddelete(inbound) failed.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005D600()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100027EFC();
  sub_10003C570((const sockaddr *)(v0 + 136));
  sub_100021100();
  sub_10002113C((void *)&_mh_execute_header, v1, v2, "get dst address from ID payload %s prefixlen=%u ul_proto=%u\n", v3, v4, v5, v6, v7);
  sub_100021150();
}

void sub_10005D67C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100027EFC();
  sub_10003C570((const sockaddr *)(v0 + 8));
  sub_100021100();
  sub_10002113C((void *)&_mh_execute_header, v1, v2, "get a src address from ID payload %s prefixlen=%u ul_proto=%u\n", v3, v4, v5, v6, v7);
  sub_100021150();
}

void sub_10005D6F8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "scope ID is not supported except of lladdr.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005D724()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "can't get scope ID: family mismatch\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005D750()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "couldn't find configuration.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005D77C(unsigned __int8 a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10003DAB8(a1);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "not acceptable %s mode\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_10005D7EC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Packet reassembly failed\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005D818()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to allocate Phase 2 entry.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005D844()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Attempt to start Phase 2 whereas Xauth failed\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005D870()
{
  errx(1, "failed to allocate local conf.");
}

void sub_10005D888()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get psk buffer.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005D8B4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "Getting pre-shared key by name.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005D8E0(os_log_t log)
{
  uint64_t v1;
  int v2;
  uint64_t v3;

  v1 = *(_QWORD *)(qword_10008B848 + 144);
  v2 = 136315138;
  v3 = v1;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "failed to open pre_share_key file %s\n", (uint8_t *)&v2, 0xCu);
}

void sub_10005D964()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to allocate key buffer.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005D990()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "Getting pre-shared key from file.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005D9BC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "Getting pre-shared key by addr.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005D9E8(uint64_t a1, NSObject *a2)
{
  int v2;
  uint64_t v3;

  v2 = 136315138;
  v3 = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "filename: %s\n", (uint8_t *)&v2, 0xCu);
}

void sub_10005DA5C(uint64_t a1)
{
  sub_100028FA8(a1, "failed to initialize pfkey.\n");
}

void sub_10005DA70()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "cannot register pidfile cleanup", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005DA9C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "too many arguments.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005DAC8()
{
  int *v0;
  char *v1;

  v0 = __error();
  v1 = sub_100007E40(v0);
  sub_100028FA8((uint64_t)v1, "failed to be daemon. (%s)");
}

void sub_10005DAEC(NSObject *a1)
{
  int *v2;
  int v3;
  char *v4;

  v2 = __error();
  v3 = 136315138;
  v4 = sub_100007E40(v2);
  _os_log_error_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_ERROR, "failed to exec racoon. (%s)", (uint8_t *)&v3, 0xCu);
}

void sub_10005DB78()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "cannot set gid.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005DBA4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "cannot set uid.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005DBD0()
{
  int *v0;
  char *v1;

  v0 = __error();
  v1 = sub_100007E40(v0);
  sub_100028FA8((uint64_t)v1, "couldn't set net.inet.ipsec.esp_port to %d. (%s)");
}

void sub_10005DBFC(uint64_t a1)
{
  sub_100028FA8(a1, "failed to parse configuration file.");
}

void sub_10005DC10(uint64_t a1)
{
  sub_100028FA8(a1, "could not set umask");
}

void sub_10005DC24(uint64_t a1)
{
  sub_100028FA8(a1, "must be root to invoke this program.");
}

void sub_10005DC38()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "memory error.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005DC64()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "compute DH's shared.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005DC90()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to compute dh value.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005DCBC()
{
  uint64_t v0;
  os_log_t v1;
  uint64_t v2;
  uint64_t v3;

  sub_10002E450();
  sub_10002E468((void *)&_mh_execute_header, v0, v1, "remote public key length (%zu) != prime length (%zu)\n", v2, v3);
  sub_100004A64();
}

void sub_10005DD28()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "compute DH result.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005DD54()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid dh type %d.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005DDB8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "failed DH public key size check.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005DDE4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "invalid public information was generated.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005DE10()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get DH buffer.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005DE3C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "got DH key pair.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005DE68()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to generate dh key pair.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005DE94()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to create dh context.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005DEC0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "dh type %d isn't supported.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005DF24()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "generate DH key pair.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005DF50()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid DH parameter grp=%d.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005DFB0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "unsupported DH parameters grp=%d.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005E010()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid hmac algorithm %d.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005E070()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid hash algorithm %d.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005E0D0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "KEYMAT computed.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005E0FC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get keymat buffer.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005E128()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "oakley_prf memory overflow\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005E154()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get hash buffer\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005E180()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "no SKEYID found.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005E1AC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100018EC4();
  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "not supported authentication method %d\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005E20C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "invalid etype for this hash function\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005E238()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "No SIG was passed, hybrid auth is enabled, but peer is no Xauth compliant\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005E264()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid etype %d\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005E2C8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "HASH for PSK validated.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005E2F4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "HASH mismatched\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005E320()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "no ID payload was passed.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005E34C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "no SIG payload was passed.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005E378()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "no peer's CERT payload found.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005E3A4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Invalid SIG.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005E3D0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "SIG authenticated\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005E3FC(int a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100005760(a1);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "error verifying signature %s\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_10005E468()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "@@@@@@ publicKeyRef is NULL\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005E494()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "no supported certtype %d\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005E4F4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "CERT validated\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005E520()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "unknown address type for peers identifier.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005E54C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "missing hostname for peers identifier.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005E578()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "the peer's certificate is not verified.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005E5A4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid getcert_mothod: %d\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005E60C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "SIGN passed\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005E638(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10003E3EC(*(_DWORD *)(*(_QWORD *)a1 + 48));
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "not supported authmethod type %s\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_10005E6AC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "no ID nor CERT found.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005E6D8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "no CERT defined.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005E704(os_log_t log)
{
  int v1;
  const char *v2;

  v1 = 136315138;
  v2 = "my";
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "failed to get %s CERT.\n", (uint8_t *)&v1, 0xCu);
  sub_100004A64();
}

void sub_10005E780()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get cert buffer.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005E7AC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get cert buffer\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005E7D8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "created CERT payload\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005E804()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011FEC();
  sub_100007E70((void *)&_mh_execute_header, v0, v1, "done with chking cert status %d\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005E868()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "Unknown certtype #%d\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005E8D0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to sign.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005E8FC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "Discarding CERT: does not match ID:\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005E928(int a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10003E21C(a1);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "Impropper ID type passed: %s.\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_10005E994()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get SecCertificateRef\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005E9C0()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003E21C(9);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v0, v1, "subjectName (type %s):\n", v2, v3, v4, v5, v6);
  sub_100005D4C();
}

void sub_10005EA30()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "ID mismatched with certificate subjectName\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005EA5C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get certificate subjectName\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005EA88()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "no certificate subjectName found\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005EAB4(int a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10003E21C(a1);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "subjectAltName (expected type %s):\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_10005EB20()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "ID mismatched with subjectAltName.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005EB4C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "out of memory\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005EB78()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "memory error\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005EBA4()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003E21C(2);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v0, v1, "subjectAltName (expected type %s):\n", v2, v3, v4, v5, v6);
  sub_100005D4C();
}

void sub_10005EC14()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003E21C(3);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v0, v1, "subjectAltName (expected type %s):\n", v2, v3, v4, v5, v6);
  sub_100005D4C();
}

void sub_10005EC84()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Failed to get CERT buffer.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005ECB0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "CERT saved:\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005ECDC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "Invalid CERT type %d\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005ED3C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Len is too small !!.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005ED68()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Failed to copy CERT from packet.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005ED94()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Failed to get CR buffer.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005EDC0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "CR saved\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005EDEC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "Invalid CR type %d\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005EE4C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get cr buffer\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005EE78(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10003DA44(*(_DWORD *)(*(_QWORD *)a1 + 112));
  sub_100012054();
  sub_100007E48((void *)&_mh_execute_header, v1, v2, "create my CR: NONE, using %s instead\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_10005EEEC(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10003DA44(*(_DWORD *)(*(_QWORD *)a1 + 104));
  sub_100012054();
  sub_100007E48((void *)&_mh_execute_header, v1, v2, "create my CR: %s\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_10005EF60()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "such a cert type isn't supported: %d\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005EFC8(const sockaddr **a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10003C8A0(*a1);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "couldn't find the pskey by address %s.\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_10005F038()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "couldn't find pskey by peer's ID.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005F064(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10003C8A0(*(const sockaddr **)(a1 + 48));
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "couldn't find the pskey for %s.\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_10005F0D4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get skeyid buffer\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005F100()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "the psk found.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005F12C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100018EC4();
  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid authentication method %d\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005F18C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get nonce buffer\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005F1B8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "no SKEYID found.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005F1E4(uint64_t a1, NSObject *a2)
{
  int v2;
  int v3;
  _DWORD v4[2];
  __int16 v5;
  int v6;

  v3 = *(_DWORD *)(*(_QWORD *)a1 + 40);
  v2 = *(_DWORD *)(*(_QWORD *)a1 + 44);
  v4[0] = 67109376;
  v4[1] = v3;
  v5 = 1024;
  v6 = v2;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "invalid encryption algoritym %d, or invalid key length %d.\n", (uint8_t *)v4, 0xEu);
  sub_100004A64();
}

void sub_10005F268()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get key buffer\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005F294()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid hash type %d.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005F2FC()
{
  uint64_t v0;
  os_log_t v1;
  uint64_t v2;
  uint64_t v3;

  sub_10002E450();
  sub_10002E468((void *)&_mh_execute_header, v0, v1, "internal error: res->l=%zu buf->l=%zu\n", v2, v3);
  sub_100004A64();
}

void sub_10005F364()
{
  os_log_t v0;
  uint8_t v1[24];

  sub_10002E450();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "len(SKEYID_e) < len(Ka) (%zu < %zu), generating long key (Ka = K1 | K2 | ...)\n", v1, 0x16u);
  sub_100004A64();
}

void sub_10005F3E4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get cert's buffer\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005F410()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Failed to get IV buffer\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005F43C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10002E440();
  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "Invalid encryption algorithm %d.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005F49C()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  v0 = __error();
  strerror(*v0);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "vdup (%s)\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_10005F510()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "IV freed\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005F53C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "Compute IV for Phase 2\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005F568()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Failed to get buffer to decrypt.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005F594()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10002E440();
  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "Decryption %d failed.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005F5F4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get buffer to decrypt.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005F620()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "decrypted.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005F64C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "skip to trim padding.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005F678(unsigned __int8 a1, uint64_t *a2, os_log_t log)
{
  uint64_t v3;
  _DWORD v4[2];
  __int16 v5;
  uint64_t v6;

  v3 = *a2;
  v4[0] = 67109376;
  v4[1] = a1;
  v5 = 2048;
  v6 = v3;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "invalid padding len=%u, buflen=%zu.\n", (uint8_t *)v4, 0x12u);
  sub_100004A64();
}

void sub_10005F700()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "trimmed padding\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005F72C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011FEC();
  sub_100007E70((void *)&_mh_execute_header, v0, v1, "padding len=%u\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005F790()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "decrypted payload by IV:\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005F7BC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "Begin decryption.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005F7E8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Failed to decrypt invalid IKE version", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005F814()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Failed to get buffer to encrypt.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005F840()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10002E440();
  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "Encryption %d failed.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005F8A0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "Encrypted.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005F8CC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100007E70((void *)&_mh_execute_header, v0, v1, "pad length = %u\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005F92C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "Begin encryption.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005F958()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Failed to encrypt invalid IKE version", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005F984()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100012048();
  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "unknown PF_KEY message type=%u\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005F9E4()
{
  NSObject *v0;
  unsigned __int8 *v1;
  unsigned __int8 *v2;
  char *v3;
  char *v4;
  int v5;
  char *v6;
  __int16 v7;
  char *v8;

  sub_100033688();
  v3 = sub_10003E7D0(*v2);
  v4 = strerror(*v1);
  v5 = 136315394;
  v6 = v3;
  v7 = 2080;
  v8 = v4;
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "pfkey %s failed: %s\n", (uint8_t *)&v5, 0x16u);
}

void sub_10005FA90()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100033640();
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v0, v1, "libipsec failed pfkey check (%s)\n", v2, v3, v4, v5, v6);
  sub_100005D4C();
}

void sub_10005FAF8()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100033640();
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v0, v1, "libipsec failed pfkey align (%s)\n", v2, v3, v4, v5, v6);
  sub_100005D4C();
}

void sub_10005FB60()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "ignoring pfkey port until power-mgmt event is handled.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005FB8C()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  v0 = __error();
  strerror(*v0);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "failed to recv from pfkey (%s)\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_10005FC00()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  v0 = __error();
  strerror(*v0);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "failed to recv pfkey message: %s\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_10005FC74()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100033640();
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v0, v1, "libipsec failed pfkey open: %s\n", v2, v3, v4, v5, v6);
  sub_100005D4C();
}

void sub_10005FCDC()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100033640();
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v0, v1, "libipsec failed dump: %s\n", v2, v3, v4, v5, v6);
  sub_100005D4C();
}

void sub_10005FD44()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to reallocate buffer to dump.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005FD70()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "call pfkey_send_dump\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005FD9C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100033640();
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v0, v1, "libipsec failed pfkey open (%s)\n", v2, v3, v4, v5, v6);
  sub_100005D4C();
}

void sub_10005FE04()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to regist any protocol.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005FE30()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "could not create pfkey socket source.", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005FE5C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100033640();
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v0, v1, "libipsec sending spddump failed: %s\n", v2, v3, v4, v5, v6);
  sub_100005D4C();
}

void sub_10005FEC4(uint8_t *a1, uint64_t a2, _QWORD *a3, NSObject *a4)
{
  uint64_t v4;

  v4 = *(_QWORD *)&byte_100085050[16 * a2 + 8];
  *(_DWORD *)a1 = 136315138;
  *a3 = v4;
  sub_100033620((void *)&_mh_execute_header, a4, (uint64_t)a3, "call pfkey_send_register for %s\n", a1);
}

void sub_10005FF14()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "Invalid ipsec_doi proto: %u\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005FF74()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "Invalid pfkey proto: %u\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10005FFD4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "Invalid mode type: %u\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100060034()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "unknown IPsec protocol.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100060060()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "no ESP algorithm.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10006008C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid encryption algorithm %u.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000600EC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "no AH algorithm.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100060118()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "no IPCOMP algorithm.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100060144()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "Invalid transform id: %u\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000601A4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "Not supported transform: %u\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100060204(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100004A84((void *)&_mh_execute_header, a1, a3, "Not supported hash type: %u\n", a5, a6, a7, a8, 0);
  sub_100003F14();
}

void sub_100060270()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid hmac algorithm %u.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000602D0(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10003367C(a1);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "%s give up to get IPsec-SA due to time up to wait.\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_100060338()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get buffer to send acquire.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100060364()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100014F60();
  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid encmode %d\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000603C4()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100033640();
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v0, v1, "ipseclib failed send getspi (%s)\n", v2, v3, v4, v5, v6);
  sub_100005D4C();
}

void sub_10006042C(uint8_t *buf, _BYTE *a2, os_log_t log)
{
  *buf = 0;
  *a2 = 0;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "call pfkey_send_getspi\n", buf, 2u);
}

void sub_100060468()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100014F60();
  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid proto_id %d\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000604C8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100014F60();
  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "Invalid encmode %d\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100060528()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100033640();
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v0, v1, "libipsec failed send update (%s)\n", v2, v3, v4, v5, v6);
  sub_100005D4C();
}

void sub_100060590()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100014F60();
  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "Invalid proto_id %d\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000605F0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "No approved SAs found.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10006061C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100033640();
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v0, v1, "libipsec failed send add (%s)\n", v2, v3, v4, v5, v6);
  sub_100005D4C();
}

void sub_100060684()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "no approvaled SAs found.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000606B0()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100033640();
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v0, v1, "libipsec failed send spdupdate2 (%s)\n", v2, v3, v4, v5, v6);
  sub_100005D4C();
}

void sub_100060718()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "call pfkey_send_spdupdate2\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100060744()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "getting sadb policy failed.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100060770()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100033640();
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v0, v1, "libipsec failed send spdadd2 (%s)\n", v2, v3, v4, v5, v6);
  sub_100005D4C();
}

void sub_1000607D8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "call pfkey_send_spdadd2\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100060804()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100033640();
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v0, v1, "libipsec failed send spddelete (%s)\n", v2, v3, v4, v5, v6);
  sub_100005D4C();
}

void sub_10006086C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "call pfkey_send_spddelete\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100060898(NSObject *a1, uint64_t a2, uint64_t a3)
{
  int v3;
  const char *v4;

  v3 = 136315138;
  v4 = "pk_sendget_inbound_sastats";
  sub_100033620((void *)&_mh_execute_header, a1, a3, "invalid args in %s \n", (uint8_t *)&v3);
}

void sub_100060910(NSObject *a1, uint64_t a2, uint64_t a3)
{
  int v3;
  const char *v4;

  v3 = 136315138;
  v4 = "pk_sendget_outbound_sastats";
  sub_100033620((void *)&_mh_execute_header, a1, a3, "invalid args in %s \n", (uint8_t *)&v3);
}

void sub_100060988()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "invalid algorithm class.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000609B4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "Invalid ipsec_doi algclass: %u\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100060A14()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100033640();
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v0, v1, "%s.\n", v2, v3, v4, v5, v6);
  sub_100005D4C();
}

void sub_100060A7C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "inappropriate sadb spd management message passed.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100060AA8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "invalid msg length.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100060AD4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to allocate buffer\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100060B00()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "invalid policy type.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100060B2C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "invalid msg length for ipsec request.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100060B58()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get new ipsecreq.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100060B84()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid proto type: %u\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100060BE8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100012048();
  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid level: %u\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100060C48()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "invalid msg length for src ip address.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100060C74()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "invalid msg length for dst ip address.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100060CA0(uint8_t *buf, _BYTE *a2, os_log_t log)
{
  *buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "becoming tlen < 0\n", buf, 2u);
}

void sub_100060CDC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100012048();
  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid mode: %u\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100060D3C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Inappropriate sadb getspi message passed.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100060D68(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_10003366C(a1, a2);
  sub_100005D34();
  sub_10003362C((void *)&_mh_execute_header, v2, v3, "Seq %d of %s message not interesting.\n", v4, v5, v6, v7, v8);
  sub_100005D4C();
}

void sub_100060DD0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100014F60();
  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "Status mismatch (db:%d)\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100060E30(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10003367C(a1);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "Can't proceed with getspi for  %s. no suitable ISAKMP-SA found \n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_100060E98(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10003367C(a1);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "Get spi for unknown address %s\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_100060F00()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "IKEv1 post getspi failed.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100060F2C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100012048();
  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "Internal error: invalid IKE major version %d\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100060F8C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "Status mismatch Phase 2 dying (db:%d)\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100060FF0()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100033688();
  sub_100033648(v0);
  sub_100033654();
  sub_10003362C((void *)&_mh_execute_header, v1, v2, "%s message is not interesting because pid %d is not mine.\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_10006105C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "inappropriate sadb update message passed.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100061088()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100012048();
  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid proto_id %d\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000610E8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid encmode %d\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100061148()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "inappropriate sadb add message passed.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100061174(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_10003366C(a1, a2);
  sub_100005D34();
  sub_10003362C((void *)&_mh_execute_header, v2, v3, "seq %d of %s message not interesting.\n", v4, v5, v6, v7, v8);
  sub_100005D4C();
}

void sub_1000611DC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "inappropriate sadb delete message passed.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100061208(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100033648(a1);
  sub_100012054();
  sub_100007E48((void *)&_mh_execute_header, v1, v2, "%s message is not interesting because the message was originated by me.\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_100061270(const sockaddr *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10003C570(a1);
  sub_100012054();
  sub_100007E48((void *)&_mh_execute_header, v1, v2, "dst: %s\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_1000612DC(const sockaddr *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10003C570(a1);
  sub_100012054();
  sub_100007E48((void *)&_mh_execute_header, v1, v2, "src: %s\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_100061348()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011F84();
  sub_100007E70((void *)&_mh_execute_header, v0, v1, "SADB delete message: proto-id %d\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000613A8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "inappropriate sadb acquire message passed.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000613D4(const sockaddr *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100033694(a1);
  sub_100012054();
  sub_100007E48((void *)&_mh_execute_header, v1, v2, "ignore because do not listen on source address : %s.\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_10006143C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100014F60();
  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "no policy found: id:%d.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10006149C(const sockaddr *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100033694(a1);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "No configuration found for %s.\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_100061504()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Failed to allocate Phase 2 entry.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100061530(unsigned __int8 *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100021160(a1);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "failed to get ID for %s\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_100061598()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to create saprop.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000615C4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to begin ipsec sa negotiation.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000615F0(unsigned __int8 *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100021160(a1);
  sub_100012054();
  sub_100007E48((void *)&_mh_execute_header, v1, v2, "new acquire %s\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_100061658()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011FEC();
  sub_100007E70((void *)&_mh_execute_header, v0, v1, "Got new Phase 2 version %d\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000616BC(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10003369C(a1);
  sub_100012054();
  sub_100007E48((void *)&_mh_execute_header, v1, v2, "Suitable inbound SP found: %s.\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_100061724(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10003369C(a1);
  sub_100012054();
  sub_100007E48((void *)&_mh_execute_header, v1, v2, "suitable outbound SP found: %s.\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_10006178C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "ignore the acquire because ph2 found\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000617B8(const sockaddr *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100033694(a1);
  sub_100012054();
  sub_100007E48((void *)&_mh_execute_header, v1, v2, "ignore due to multicast address: %s.\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_100061820()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "ignore ACQUIRE message. type is not IPsec.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10006184C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "inappropriate sadb expire message passed.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100061878()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to begin ipsec sa re-negotiation.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000618A4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "inappropriate sadb flush message passed.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000618D0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "inappropriate sadb spdupdate message passed.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000618FC(unsigned __int8 *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100021160(a1);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "such policy does not already exist: \"%s\"\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_100061964()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "inappropriate sadb spdadd message passed.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100061990(unsigned __int8 *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100021160(a1);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "such policy already exists. anyway replace it: %s\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_1000619F8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "inappropriate sadb spddelete message passed.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100061A24()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "inappropriate sadb spdget message passed.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100061A50()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "inappropriate sadb spddump message passed.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100061A7C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "inappropriate sadb spdflush message passed.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100061AA8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "inappropriate sadb spdexpire message passed.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100061AD4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "inappropriate sadb getsastat response.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100061B00(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100033648(a1);
  sub_100012054();
  sub_100007E48((void *)&_mh_execute_header, v1, v2, "%s message is bad because session-id[0] is invalid.\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_100061B68(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100033648(a1);
  sub_100012054();
  sub_100007E48((void *)&_mh_execute_header, v1, v2, "%s message is bad because it has no sastats.\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_100061BD0()
{
  os_log_t v0;
  uint8_t v1[24];

  sub_10003466C();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "%s %s", v1, 0x16u);
  sub_100004A64();
}

void sub_100061C40()
{
  os_log_t v0;
  uint8_t v1[24];

  sub_10003466C();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%s %s", v1, 0x16u);
  sub_100004A64();
}

void sub_100061CB0()
{
  os_log_t v0;
  uint8_t v1[24];

  sub_10003466C();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "%s %s", v1, 0x16u);
  sub_100004A64();
}

void sub_100061D20(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100034684((void *)&_mh_execute_header, a2, a3, "%s", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100061D88(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a2, a3, "%s", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100061DF0(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100004A54((void *)&_mh_execute_header, a2, a3, "%s", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100061E58(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100003F04((void *)&_mh_execute_header, a1, a3, "strdup failed\n", a5, a6, a7, a8, 0);
}

void sub_100061E8C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100003F04((void *)&_mh_execute_header, a1, a3, "Null log level (quoted string)", a5, a6, a7, a8, 0);
}

void sub_100061EC0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100012054();
  sub_100015A54((void *)&_mh_execute_header, v0, v1, "Invalid log level (quoted string): %s", v2, v3, v4, v5, v6);
  sub_100004A64();
}

void sub_100061F20()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100012054();
  sub_100034684((void *)&_mh_execute_header, v0, v1, "%s", v2, v3, v4, v5, v6);
  sub_100004A64();
}

void sub_100061F80()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100012054();
  sub_100015A54((void *)&_mh_execute_header, v0, v1, "%s", v2, v3, v4, v5, v6);
  sub_100004A64();
}

void sub_100061FE0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100012054();
  sub_100004A54((void *)&_mh_execute_header, v0, v1, "%s", v2, v3, v4, v5, v6);
  sub_100004A64();
}

void sub_100062040(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;

  v2 = sub_10003C570((const sockaddr *)(a2 + 136));
  sub_10001C914((uint64_t)v2, 4.8149e-34);
  sub_10000AB88((void *)&_mh_execute_header, v3, v4, "dst2: %s\n");
  sub_100007E9C();
}

void sub_10006208C(uint64_t a1, const sockaddr **a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;

  v2 = sub_1000353F0(a1, a2);
  sub_10001C914((uint64_t)v2, 4.8149e-34);
  sub_10000AB88((void *)&_mh_execute_header, v3, v4, "dst1: %s\n");
  sub_100007E9C();
}

void sub_1000620C8(uint64_t a1, const sockaddr *a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;

  v2 = sub_10003C570(a2);
  sub_10001C914((uint64_t)v2, 4.8149e-34);
  sub_10000AB88((void *)&_mh_execute_header, v3, v4, "src2: %s\n");
  sub_100007E9C();
}

void sub_100062114(uint64_t a1, const sockaddr **a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;

  v2 = sub_1000353F0(a1, a2);
  sub_10001C914((uint64_t)v2, 4.8149e-34);
  sub_10000AB88((void *)&_mh_execute_header, v3, v4, "src1: %s\n");
  sub_100007E9C();
}

void sub_100062150(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100004A54((void *)&_mh_execute_header, a1, a3, "%s, inbound policy outer addresses matched Phase 2 addresses\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_1000621C0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100004A54((void *)&_mh_execute_header, a1, a3, "%s, outbound policy outer addresses matched Phase 2 addresses\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100062230(unsigned __int8 *a1, unsigned __int8 *a2, os_log_t log)
{
  int v3;
  int v4;
  _DWORD v5[2];
  __int16 v6;
  int v7;

  v3 = *a1;
  v4 = *a2;
  v5[0] = 67109376;
  v5[1] = v3;
  v6 = 1024;
  v7 = v4;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "unexpected error: src.ss_len:%d dst.ss_len:%d\n", (uint8_t *)v5, 0xEu);
  sub_100004A64();
}

void sub_1000622B8(os_log_t log)
{
  uint8_t v1[16];

  *(_WORD *)v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "unexpected error\n", v1, 2u);
}

void sub_1000622F8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to allocate saprop.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100062324()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "invalid pcheck_level why?.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100062350()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to allocate saproto.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10006237C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to allocate satrns.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000623A8(int *a1, int *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint8_t v9;

  sub_10003E0A4(*a1);
  sub_10003E0A4(*a2);
  sub_100037FF8();
  sub_100038098((void *)&_mh_execute_header, v3, v4, "encmode mismatched: my:%s peer:%s\n", v5, v6, v7, v8, v9);
  sub_100021150();
}

void sub_10006242C(uint8_t *a1, _BYTE *a2, NSObject *a3)
{
  *a1 = 0;
  *a2 = 0;
  sub_100011F78((void *)&_mh_execute_header, a3, (uint64_t)a3, "IPComp SPI size promoted from 16bit to 32bit\n", a1);
}

void sub_100062460()
{
  uint64_t v0;
  os_log_t v1;
  int v2;
  int v3;

  sub_100038134(__stack_chk_guard);
  sub_10000ABB0();
  sub_10000AB9C((void *)&_mh_execute_header, v0, v1, "spisize mismatched: my:%d peer:%d\n", v2, v3);
  sub_100004A64();
}

void sub_1000624C0(int *a1, int *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint8_t v9;

  sub_10003DCFC(*a1);
  sub_10003DCFC(*a2);
  sub_100037FF8();
  sub_100038098((void *)&_mh_execute_header, v3, v4, "proto_id mismatched: my:%s peer:%s\n", v5, v6, v7, v8, v9);
  sub_100021150();
}

void sub_100062544()
{
  uint64_t v0;
  os_log_t v1;
  int v2;
  int v3;

  sub_100038134(__stack_chk_guard);
  sub_10000ABB0();
  sub_10000AB9C((void *)&_mh_execute_header, v0, v1, "long lifetime proposed: my:%d peer:%d\n", v2, v3);
  sub_100004A64();
}

void sub_1000625A4()
{
  uint64_t v0;
  os_log_t v1;
  int v2;
  int v3;

  sub_1000380F4(__stack_chk_guard);
  sub_10000ABB0();
  sub_10000AB9C((void *)&_mh_execute_header, v0, v1, "long lifebyte proposed: my:%d peer:%d\n", v2, v3);
  sub_100004A64();
}

void sub_100062604()
{
  uint64_t v0;
  os_log_t v1;
  int v2;
  int v3;

  sub_1000380F4(__stack_chk_guard);
  sub_10000ABB0();
  sub_10000AB9C((void *)&_mh_execute_header, v0, v1, "pfs group mismatched: my:%d peer:%d\n", v2, v3);
  sub_100004A64();
}

void sub_100062664()
{
  uint64_t v0;
  os_log_t v1;
  int v2;
  int v3;

  sub_1000380F4(__stack_chk_guard);
  sub_10000ABB0();
  sub_10000AB9C((void *)&_mh_execute_header, v0, v1, "lifebyte mismatched: my:%d peer:%d\n", v2, v3);
  sub_100004A64();
}

void sub_1000626C4()
{
  uint64_t v0;
  os_log_t v1;
  int v2;
  int v3;

  sub_100038134(__stack_chk_guard);
  sub_10000ABB0();
  sub_10000AB9C((void *)&_mh_execute_header, v0, v1, "lifetime mismatched: my:%d peer:%d\n", v2, v3);
  sub_100004A64();
}

void sub_100062724(unsigned int *a1, unsigned int *a2)
{
  char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint8_t v10;

  v3 = sub_1000380AC((uint64_t)a1, *a1);
  sub_1000380AC((uint64_t)v3, *a2);
  sub_100037FF8();
  sub_100038114((void *)&_mh_execute_header, v4, v5, "authtype mismatched: my:%s peer:%s\n", v6, v7, v8, v9, v10);
  sub_100021150();
}

void sub_1000627A8(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100004A84((void *)&_mh_execute_header, a2, a3, "unknown proto_id (%d).\n", a5, a6, a7, a8, 0);
  sub_100003F14();
}

void sub_100062810()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "no auth algorithm found\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10006283C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "no algorithms found.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100062868()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "no encryption algorithm found\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100062894()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "no ipcomp algorithm found\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000628C0(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100004A84((void *)&_mh_execute_header, a2, a3, "invalid spi size %d.\n", a5, a6, a7, a8, 0);
  sub_100003F14();
}

void sub_10006292C()
{
  os_log_t v0;
  uint8_t v1[16];

  sub_100003F1C();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "(null)", v1, 2u);
  sub_100003F14();
}

void sub_100062964()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "(null)", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100062990()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "(null)", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000629BC()
{
  int *v0;
  void *v1;
  os_log_t v2;
  os_log_type_t v3;
  const char *v4;
  uint8_t *v5;

  sub_100005D60();
  sub_100038128(v0, __stack_chk_guard);
  sub_100038038();
  sub_100037FB0();
  sub_100038104();
  _os_log_fault_impl(v1, v2, v3, v4, v5, 0x3Cu);
  sub_10003807C();
}

void sub_100062A3C()
{
  int *v0;
  void *v1;
  os_log_t v2;
  os_log_type_t v3;
  const char *v4;
  uint8_t *v5;

  sub_100005D60();
  sub_100038128(v0, __stack_chk_guard);
  sub_100038038();
  sub_100037FB0();
  sub_100038144();
  _os_log_error_impl(v1, v2, v3, v4, v5, 0x3Cu);
  sub_10003807C();
}

void sub_100062ABC()
{
  int *v0;
  void *v1;
  os_log_t v2;
  os_log_type_t v3;
  const char *v4;
  uint8_t *v5;

  sub_100005D60();
  sub_100038128(v0, __stack_chk_guard);
  sub_100038038();
  sub_100037FB0();
  sub_100012060();
  _os_log_debug_impl(v1, v2, v3, v4, v5, 0x3Cu);
  sub_10003807C();
}

void sub_100062B3C(int a1, NSObject *a2)
{
  _DWORD v2[2];

  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "(unknown proto_id %d)\n", (uint8_t *)v2, 8u);
  sub_100003F14();
}

void sub_100062BAC(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100004A84((void *)&_mh_execute_header, a2, a3, "(unknown proto_id %d)\n", a5, a6, a7, a8, 0);
  sub_100003F14();
}

void sub_100062C10(int a1, NSObject *a2)
{
  _DWORD v2[2];

  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "(unknown proto_id %d)\n", (uint8_t *)v2, 8u);
  sub_100003F14();
}

void sub_100062C80()
{
  uint64_t v0;
  uint64_t v1;
  char *v2;
  void *v3;
  os_log_t v4;
  os_log_type_t v5;
  const char *v6;
  uint8_t *v7;

  sub_100005D60();
  v2 = sub_1000380B4(v1);
  sub_1000380AC((uint64_t)v2, *(unsigned int *)(v0 + 12));
  sub_100037FF8();
  sub_100038104();
  _os_log_fault_impl(v3, v4, v5, v6, v7, 0x16u);
  sub_100021150();
}

void sub_100062D00()
{
  uint64_t v0;
  uint64_t v1;
  char *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint8_t v9;

  sub_100005D60();
  v2 = sub_1000380B4(v1);
  sub_1000380AC((uint64_t)v2, *(unsigned int *)(v0 + 12));
  sub_100037FF8();
  sub_100038098((void *)&_mh_execute_header, v3, v4, "  (trns_id=%s authtype=%s)\n", v5, v6, v7, v8, v9);
  sub_100021150();
}

void sub_100062D78()
{
  uint64_t v0;
  uint64_t v1;
  char *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint8_t v9;

  sub_100005D60();
  v2 = sub_1000380B4(v1);
  sub_1000380AC((uint64_t)v2, *(unsigned int *)(v0 + 12));
  sub_100037FF8();
  sub_100038114((void *)&_mh_execute_header, v3, v4, "  (trns_id=%s authtype=%s)\n", v5, v6, v7, v8, v9);
  sub_100021150();
}

void sub_100062DF0()
{
  uint64_t v0;
  uint64_t v1;
  char *v2;
  void *v3;
  os_log_t v4;
  os_log_type_t v5;
  const char *v6;
  uint8_t *v7;

  sub_100005D60();
  v2 = sub_1000380E4(v1);
  sub_1000380AC((uint64_t)v2, *(unsigned int *)(v0 + 12));
  sub_100038058();
  sub_100038104();
  _os_log_fault_impl(v3, v4, v5, v6, v7, 0x1Cu);
  sub_1000380D4();
}

void sub_100062E70()
{
  uint64_t v0;
  uint64_t v1;
  char *v2;
  void *v3;
  os_log_t v4;
  os_log_type_t v5;
  const char *v6;
  uint8_t *v7;

  sub_100005D60();
  v2 = sub_1000380E4(v1);
  sub_1000380AC((uint64_t)v2, *(unsigned int *)(v0 + 12));
  sub_100038058();
  sub_100038144();
  _os_log_error_impl(v3, v4, v5, v6, v7, 0x1Cu);
  sub_1000380D4();
}

void sub_100062EF0()
{
  uint64_t v0;
  uint64_t v1;
  char *v2;
  void *v3;
  os_log_t v4;
  os_log_type_t v5;
  const char *v6;
  uint8_t *v7;

  sub_100005D60();
  v2 = sub_1000380E4(v1);
  sub_1000380AC((uint64_t)v2, *(unsigned int *)(v0 + 12));
  sub_100038058();
  sub_100012060();
  _os_log_debug_impl(v3, v4, v5, v6, v7, 0x1Cu);
  sub_1000380D4();
}

void sub_100062F70(uint64_t a1)
{
  void *v1;
  os_log_t v2;
  os_log_type_t v3;
  const char *v4;
  uint8_t *v5;

  sub_1000380C4(a1);
  sub_100038104();
  _os_log_fault_impl(v1, v2, v3, v4, v5, 0xCu);
  sub_100005D4C();
}

void sub_100062FE4(uint64_t a1)
{
  void *v1;
  os_log_t v2;
  os_log_type_t v3;
  const char *v4;
  uint8_t *v5;

  sub_1000380C4(a1);
  sub_100038144();
  _os_log_error_impl(v1, v2, v3, v4, v5, 0xCu);
  sub_100005D4C();
}

void sub_100063058(uint64_t a1)
{
  void *v1;
  os_log_t v2;
  os_log_type_t v3;
  const char *v4;
  uint8_t *v5;

  sub_1000380C4(a1);
  sub_100012060();
  _os_log_debug_impl(v1, v2, v3, v4, v5, 0xCu);
  sub_100005D4C();
}

void sub_1000630CC()
{
  os_log_t v0;
  uint8_t v1[56];

  sub_100038010();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "%s%p: next=%p tnext=%p\n", v1, 0x2Au);
  sub_100038090();
}

void sub_100063140()
{
  os_log_t v0;
  uint8_t v1[56];

  sub_100038010();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%s%p: next=%p tnext=%p\n", v1, 0x2Au);
  sub_100038090();
}

void sub_1000631B4()
{
  os_log_t v0;
  uint8_t v1[56];

  sub_100038010();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "%s%p: next=%p tnext=%p\n", v1, 0x2Au);
  sub_100038090();
}

void sub_100063228()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get algorithms.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100063254()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "make a proposal from peer's:\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100063280(uint8_t *a1, _BYTE *a2, NSObject *a3)
{
  *a1 = 0;
  *a2 = 0;
  sub_100011F78((void *)&_mh_execute_header, a3, (uint64_t)a3, "pp_peer is inconsistency, ignore it.\n", a1);
}

void sub_1000632B4(unsigned __int8 *a1, NSObject *a2)
{
  int v2;
  _DWORD v3[2];

  v2 = *a1;
  v3[0] = 67109120;
  v3[1] = v2;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "invalid ip address family: %d\n", (uint8_t *)v3, 8u);
}

void sub_10006332C(os_log_t log)
{
  uint8_t v1[16];

  *(_WORD *)v1 = 0;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "no remote configuration found.\n", v1, 2u);
}

void sub_10006336C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100012054();
  sub_100004A54((void *)&_mh_execute_header, v0, v1, "configuration found for %s.\n", v2, v3, v4, v5, v6);
  sub_100004A64();
}

void sub_1000633CC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100012054();
  sub_100004A54((void *)&_mh_execute_header, v0, v1, "anonymous configuration selected for %s.\n", v2, v3, v4, v5, v6);
  sub_100004A64();
}

void sub_10006342C(const sockaddr *a1, NSObject *a2)
{
  uint8_t v3[24];

  sub_10003C570(a1);
  sub_100012054();
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "Remote configuration for '%s' not found!\n", v3, 0xCu);
}

void sub_1000634B0(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a2, a3, "%s has weak file permission\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100063514(uint64_t a1, _WORD *a2, os_log_t log)
{
  int v3;
  int v4;
  uint64_t v5;
  __int16 v6;
  int v7;

  v3 = *a2 & 0xF000;
  v4 = 136315394;
  v5 = a1;
  v6 = 1024;
  v7 = v3;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "%s is an invalid file type 0x%x\n", (uint8_t *)&v4, 0x12u);
  sub_100004A64();
}

void sub_10006359C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a2, a3, "%s has invalid owner uid\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100063600(os_log_t log)
{
  uint8_t v1[16];

  *(_WORD *)v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "setuid'ed execution not allowed\n", v1, 2u);
}

void sub_100063640(NSObject *a1, uint64_t a2, uint64_t a3)
{
  uint8_t v3[16];

  *(_WORD *)v3 = 0;
  sub_100011FA0((void *)&_mh_execute_header, a1, a3, "anonymous sainfo selected.\n", v3);
  sub_100003F14();
}

void sub_100063674(uint8_t *a1, _BYTE *a2, NSObject *a3)
{
  *a1 = 0;
  *a2 = 0;
  sub_100011FA0((void *)&_mh_execute_header, a3, (uint64_t)a3, "getsainfo_by_dst_id - sainfo id = anonymous\n", a1);
}

void sub_1000636A8(NSObject *a1, uint64_t a2, uint64_t a3)
{
  uint8_t v3[16];

  *(_WORD *)v3 = 0;
  sub_100011FA0((void *)&_mh_execute_header, a1, a3, "getsainfo_by_dst_id - dst id:\n", v3);
  sub_100003F14();
}

void sub_1000636DC(unsigned __int8 a1, NSObject *a2)
{
  _DWORD v2[2];

  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "failed to swap launchd keepalive integer %d\n", (uint8_t *)v2, 8u);
  sub_100003F14();
}

void sub_100063750(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100003F04((void *)&_mh_execute_header, a1, a3, "configuration read failed\n", a5, a6, a7, a8, 0);
  sub_100003F14();
}

void sub_100063780(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100003F04((void *)&_mh_execute_header, a1, a3, "ISAKMP mode config structure reset failed, not reloading\n", a5, a6, a7, a8, 0);
  sub_100003F14();
}

void sub_1000637B0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get address buffer.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000637DC()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  v0 = sub_100007EA8();
  sub_100007E40(v0);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "socket (%s)\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_100063848()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  v0 = sub_100007EA8();
  sub_100007E40(v0);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "connect (%s)\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_1000638B4()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  v0 = sub_100007EA8();
  sub_100007E40(v0);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "getsockname (%s)\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_100063920()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to put localaddr socket in non-blocking mode\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10006394C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100004A84((void *)&_mh_execute_header, a2, a3, "unsupported address family %d\n", a5, a6, a7, a8, 0);
  sub_100003F14();
}

void sub_1000639B0()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  ipsec_strerror();
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v0, v1, "ipsec_set_policy (%s)\n", v2, v3, v4, v5, v6);
  sub_100005D4C();
}

void sub_100063A1C()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  v0 = sub_100007EA8();
  sub_100007E40(v0);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "setsockopt IP_IPSEC_POLICY (%s)\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_100063A88()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  v0 = sub_100007EA8();
  sub_100007E40(v0);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "recvmsg (%s)\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_100063AF4()
{
  NSObject *v0;
  char **v1;
  uint8_t *v2;
  int *v3;
  char *v4;

  v3 = sub_100007E80();
  v4 = sub_100007E40(v3);
  *(_DWORD *)v2 = 136315138;
  *v1 = v4;
  sub_10003D37C((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "sendmsg (%s)\n", v2);
  sub_100007E9C();
}

void sub_100063B44(const sockaddr *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_10003D384(a1);
  sub_10003D38C();
  sub_10003362C((void *)&_mh_execute_header, v1, v2, "dst6 %s %d\n", v3, v4, v5, v6, 2u);
  sub_100005D4C();
}

void sub_100063BC0(const sockaddr *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_10003D384(a1);
  sub_10003D38C();
  sub_10003362C((void *)&_mh_execute_header, v1, v2, "src6 %s %d\n", v3, v4, v5, v6, 2u);
  sub_100005D4C();
}

void sub_100063C3C()
{
  NSObject *v0;
  char **v1;
  uint8_t *v2;
  int *v3;
  char *v4;

  v3 = sub_100007E80();
  v4 = sub_100007E40(v3);
  *(_DWORD *)v2 = 136315138;
  *v1 = v4;
  sub_10003D37C((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "treating socket error (%s) like packet loss\n", v2);
  sub_100007E9C();
}

void sub_100063C8C()
{
  NSObject *v0;
  char **v1;
  uint8_t *v2;
  int *v3;
  char *v4;

  v3 = sub_100007E80();
  v4 = sub_100007E40(v3);
  *(_DWORD *)v2 = 136315138;
  *v1 = v4;
  sub_10003D37C((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "sendto (%s)\n", v2);
  sub_100007E9C();
}

void sub_100063CDC()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  v0 = sub_100007EA8();
  sub_100007E40(v0);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "setsockopt SO_REUSEPORT (%s)\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_100063D48()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  v0 = sub_100007EA8();
  sub_100007E40(v0);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "bind 1 (%s)\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_100063DB4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to put sendsock socket in non-blocking mode\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100063DE0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "address family mismatch\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100063E0C(const sockaddr *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_10003D384(a1);
  sub_100007E48((void *)&_mh_execute_header, v1, v2, "send packet to %s\n", v3, v4, v5, v6, 2u);
  sub_100005D4C();
}

void sub_100063E80(const sockaddr *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_10003D384(a1);
  sub_100007E48((void *)&_mh_execute_header, v1, v2, "send packet from %s\n", v3, v4, v5, v6, 2u);
  sub_100005D4C();
}

void sub_100063EF4(const sockaddr *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_10003D384(a1);
  sub_100007E48((void *)&_mh_execute_header, v1, v2, "sockname %s\n", v3, v4, v5, v6, 2u);
  sub_100005D4C();
}

void sub_100063F68()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  v0 = sub_100007EA8();
  sub_100007E40(v0);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "%s\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_100063FD4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid address family: %d\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100064038()
{
  uint64_t v0;
  os_log_t v1;
  uint8_t v2[8];
  __int16 v3;
  uint64_t v4;

  sub_100011FEC();
  v3 = 2048;
  v4 = v0;
  _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "unexpected inconsistency: %d %zu\n", v2, 0x12u);
}

void sub_1000640BC()
{
  uint64_t v0;
  os_log_t v1;
  uint8_t v2[12];
  __int16 v3;
  uint64_t v4;

  sub_100012054();
  v3 = 2048;
  v4 = v0;
  _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "Call with null args: naddr=%p, saddr=%p\n", v2, 0x16u);
}

void sub_10006413C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "unknown AF: %u\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000641A0(os_log_t log)
{
  uint8_t v1[16];

  *(_WORD *)v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Throttle insertion failed\n", v1, 2u);
}

void sub_1000641E0(NSObject *a1, uint64_t a2, uint64_t a3)
{
  uint8_t v3[16];

  *(_WORD *)v3 = 0;
  sub_100011F78((void *)&_mh_execute_header, a1, a3, "unable to get memory for VID hash\n", v3);
}

void sub_100064218(uint8_t *a1, _BYTE *a2, NSObject *a3)
{
  *a1 = 0;
  *a2 = 0;
  sub_100011F78((void *)&_mh_execute_header, a3, (uint64_t)a3, "unable to hash vendor ID string\n", a1);
}

void sub_10006424C(int a1, NSObject *a2)
{
  _DWORD v2[2];

  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "invalid vendor ID index: %d\n", (uint8_t *)v2, 8u);
}

void sub_1000642C0(os_log_t log)
{
  uint8_t v1[16];

  *(_WORD *)v1 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "vdup(NULL) called\n", v1, 2u);
}

void sub_100064300()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100012048();
  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "Unsupported address family #0x%x\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100064360(int a1, NSObject *a2)
{
  int v3;
  __int128 *v4;

  v3 = 136315138;
  v4 = sub_10003EDD8(a1);
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "unsupported NAT-T version: %s\n", (uint8_t *)&v3, 0xCu);
}

void sub_1000643E8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100012048();
  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid address family: %d\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100064448()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to get buffer for natoa payload.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100064474()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100012048();
  sub_100011FEC();
  sub_100004A84((void *)&_mh_execute_header, v0, v1, "invalid NAT-OA payload %d\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000644D4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "error allocating addr for NAT-OA payload\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100064500()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Allocating memory for natt_options failed!\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10006452C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Unexpected short packet\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100064558()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "User credentials sent in cleartext!\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100064584()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to decrypt message\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000645B0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Cannot compute hash\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000645DC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Hash verification failed\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100064608()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "isakmp_cfg_newiv called without mode config state\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100064634()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011FB8();
  sub_100045094((void *)&_mh_execute_header, v0, v1, "isakmp_cfg_reply invalid length of isakmp data, expected %zu actual %d\n", v2, v3, v4, v5, v6);
  sub_100004A64();
}

void sub_100064694(int a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10003DC14(a1);
  sub_1000450A4();
  sub_100038098((void *)&_mh_execute_header, v1, v2, "Short attribute %s len %zu\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_100064704(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100004A84((void *)&_mh_execute_header, a2, a3, "invalid cfg-attr-list, attr-len %d\n", a5, a6, a7, a8, 0);
  sub_100003F14();
}

void sub_100064774()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Cannot allocate memory for mode-cfg attribute list\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000647A0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011FB8();
  sub_100045094((void *)&_mh_execute_header, v0, v1, "isakmp_cfg_request invalid length of isakmp data, expected %zu actual %d\n", v2, v3, v4, v5, v6);
  sub_100004A64();
}

void sub_100064800(_BYTE *a1, _BYTE *a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_100011F90(a1, a2);
  sub_100011F78((void *)&_mh_execute_header, v2, (uint64_t)v2, "Port pool depleted\n", v3);
}

void sub_10006482C(_BYTE *a1, _BYTE *a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_100011F90(a1, a2);
  sub_100011F78((void *)&_mh_execute_header, v2, (uint64_t)v2, "Unexpected confsource\n", v3);
}

void sub_100064858(_BYTE *a1, _BYTE *a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_100011F90(a1, a2);
  sub_100011F78((void *)&_mh_execute_header, v2, (uint64_t)v2, "Attempt to start phase config whereas Xauth failed\n", v3);
}

void sub_100064884()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100011FB8();
  sub_100045094((void *)&_mh_execute_header, v0, v1, "isakmp_cfg_set invalid length of isakmp data, expected %zu actual %d\n", v2, v3, v4, v5, v6);
  sub_100004A64();
}

void sub_1000648E4(_DWORD *a1, int a2, char **a3)
{
  char *v5;
  uint64_t v6;
  uint64_t v7;

  v5 = sub_10003DC14(a2);
  *a1 = 136315138;
  *a3 = v5;
  sub_10000AB88((void *)&_mh_execute_header, v6, v7, "Unexpected SET attribute %s\n");
  sub_100007E9C();
}

void sub_100064934(_DWORD *a1, __int16 a2, char **a3)
{
  char *v5;
  uint64_t v6;
  uint64_t v7;

  v5 = sub_10003DC14(a2 & 0x7FFF);
  *a1 = 136315138;
  *a3 = v5;
  sub_10000AB88((void *)&_mh_execute_header, v6, v7, "Attribute %s\n");
  sub_100007E9C();
}

void sub_100064984()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Bad IPv4 address len\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000649B0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Too many addresses given\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000649DC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "ISAKMP mode config exchange with immature phase 1\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100064A08()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to allocate ph2", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100064A34()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to duplicate remote address", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100064A60()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to duplicate local address", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100064A8C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100004A84((void *)&_mh_execute_header, a2, a3, "invalid family: %d\n", a5, a6, a7, a8, 0);
  sub_100003F14();
}

void sub_100064AF8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to resend packet", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100064B24()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "isakmp_cfg_config.port_pool == NULL\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100064B50(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100004A84((void *)&_mh_execute_header, a2, a3, "Attempt to release an unallocated address (port %d)\n", a5, a6, a7, a8, 0);
  sub_100003F14();
}

void sub_100064BB4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Cannot allocate memory for mode config state\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100064BE0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "No more addresses available\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100064C0C(int a1, NSObject *a2)
{
  uint64_t v4;
  int *v5;
  char *v6;
  int v7;
  uint64_t v8;
  __int16 v9;
  int v10;
  __int16 v11;
  char *v12;

  v4 = qword_10008BE90;
  v5 = __error();
  v6 = strerror(*v5);
  v7 = 134218498;
  v8 = v4;
  v9 = 1024;
  v10 = a1;
  v11 = 2080;
  v12 = v6;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "resize pool from %zu to %d impossible: %s", (uint8_t *)&v7, 0x1Cu);
}

void sub_100064CC8(int a1, int a2, os_log_t log)
{
  int v3;
  uint64_t v4;
  __int16 v5;
  int v6;
  __int16 v7;
  int v8;

  v3 = 134218496;
  v4 = qword_10008BE90;
  v5 = 1024;
  v6 = a1;
  v7 = 1024;
  v8 = a2;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "resize pool from %zu to %d impossible port %d is in use\n", (uint8_t *)&v3, 0x18u);
  sub_100004A64();
}

void sub_100064D58(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100003F04((void *)&_mh_execute_header, a1, a3, "Unity mode config request but the peer did not declare itself as  unity compliant\n", a5, a6, a7, a8, 0);
  sub_100003F14();
}

void sub_100064D88(int a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_100045A7C(a1);
  sub_100007E48((void *)&_mh_execute_header, v1, v2, "Ignored attribute %s\n", v3, v4, v5, v6, 2u);
  sub_100005D4C();
}

void sub_100064DF4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "Cannot open \"%s\"\n", a5, a6, a7, a8, 2u);
}

void sub_100064E6C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "Cannot read \"%s\"\n", a5, a6, a7, a8, 2u);
}

void sub_100064EE4(int a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_100045A7C(a1);
  sub_100007E48((void *)&_mh_execute_header, v1, v2, "Ignored short attribute %s\n", v3, v4, v5, v6, 2u);
  sub_100005D4C();
}

void sub_100064F50(int a1, uint64_t a2, NSObject *a3)
{
  char *v5;
  unsigned int v6;
  int v7;
  char *v8;
  __int16 v9;
  unsigned int v10;

  v5 = sub_100045A7C(a1);
  v6 = bswap32(*(unsigned __int16 *)(a2 + 2)) >> 16;
  v7 = 136315394;
  v8 = v5;
  v9 = 1024;
  v10 = v6;
  _os_log_debug_impl((void *)&_mh_execute_header, a3, OS_LOG_TYPE_DEBUG, "Short attribute %s = %d\n", (uint8_t *)&v7, 0x12u);
  sub_100005D4C();
}

void sub_100064FE8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100003F04((void *)&_mh_execute_header, a1, a3, "Cannot allocate memory\n", a5, a6, a7, a8, 0);
  sub_100003F14();
}

void sub_100065018(unsigned __int16 *a1, NSObject *a2)
{
  unsigned int v2;
  _DWORD v3[2];

  v2 = bswap32(*a1) >> 16;
  v3[0] = 67109120;
  v3[1] = v2;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "unity_pfs = %x\n", (uint8_t *)v3, 8u);
  sub_100003F14();
}

void sub_100065094()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Xauth request while phase 1 is not completed\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000650C0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Cannot allocate buffer\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000650EC(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100004A84((void *)&_mh_execute_header, a2, a3, "Xauth request whith Xauth state %d\n", a5, a6, a7, a8, 0);
  sub_100003F14();
}

void sub_100065154()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Xauth reply but peer did not declare itself as Xauth capable\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100065180()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Port pool depleted\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000651AC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "malloc failed, bypass throttling\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000651D8(uint64_t a1, uint64_t a2, os_log_t log)
{
  int v3;
  uint64_t v4;
  __int16 v5;
  uint64_t v6;

  v3 = 136315394;
  v4 = a1;
  v5 = 2048;
  v6 = a2;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Throttling in action for %s: delay %lds\n", (uint8_t *)&v3, 0x16u);
  sub_100004A64();
}

void sub_100065258()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Unexpected authentication source\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100065284()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Cannot allocate memory for Xauth Data\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000652B0(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100004A84((void *)&_mh_execute_header, a2, a3, "Xauth reply while Xauth state is %d\n", a5, a6, a7, a8, 0);
  sub_100003F14();
}

void sub_100065318()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "xauth group specified but modecfg not found\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100065344()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "xauth group specified but xauth not found\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100065370(uint8_t *buf, _BYTE *a2, os_log_t log)
{
  *buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Unknown group auth source\n", buf, 2u);
}

void sub_1000653AC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Delayed Xauth reply: phase 1 no longer exists.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000653D8(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a2, a3, "the system group name '%s' is unknown\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_10006543C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Hybrid auth negotiated but peer did not announced as Xauth capable\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100065468()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Hybrid auth negotiated but peer did not succeed Xauth exchange\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100065494()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Xauth mode config request but peer did not declare itself as Xauth capable\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000654C0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Unexpected long XAUTH_TYPE attribute\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000654EC(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100004A84((void *)&_mh_execute_header, a2, a3, "Unsupported Xauth authentication %d\n", a5, a6, a7, a8, 0);
  sub_100003F14();
}

void sub_10006555C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Xauth performed with no login supplied\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100065588(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a2, a3, "No password was found for login %s\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_1000655FC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Xauth mode config set but peer did not declare itself as Xauth capable\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100065628()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Xauth authentication failed\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100065654()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Unexpected XAUTH_STATUS_OK\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100065680()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Unexpected XAUTH_STATUS_OK... not a Phase 1 rekey\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000656AC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "xauth_rmconf_used: malloc failed\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000656D8()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  v0 = sub_100007EA8();
  sub_100007E40(v0);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "memory error: %s\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_100065744()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  v0 = sub_100007EA8();
  sub_100007E40(v0);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "failed to accept vpn_control command: %s\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_1000657B0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "could not create comm socket source.", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000657DC()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  v0 = sub_100007EA8();
  sub_100007E40(v0);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "failed to recv vpn_control command: %s\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_100065848()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100049654();
  sub_1000495B0((void *)&_mh_execute_header, v0, v1, "invalid header length of vpn_control command - len=%ld - expected %ld\n", v2, v3, v4, v5, v6);
  sub_100004A64();
}

void sub_1000658B0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to alloc buffer for vpn_control command\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000658DC()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  v0 = sub_100007EA8();
  sub_100007E40(v0);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "failed to send vpn_control message: %s\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_100065948(unsigned __int16 *a1, NSObject *a2)
{
  unsigned int v2;
  _DWORD v3[2];

  v2 = bswap32(*a1) >> 16;
  v3[0] = 67109120;
  v3[1] = v2;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "invalid command: %d\n", (uint8_t *)v3, 8u);
  sub_100003F14();
}

void sub_1000659C4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000495DC();
  sub_1000495B0((void *)&_mh_execute_header, v0, v1, "invalid header length for vpnctl bind cmd - len=%ld - expected %ld\n", v2, v3, v4, v5, v6);
  sub_100004A64();
}

void sub_100065A24()
{
  NSObject *v0;
  uint8_t v1[24];

  sub_100049614();
  sub_100027EC8((void *)&_mh_execute_header, v0, (uint64_t)v0, "invalid length for vpnctl bind cmd - len=%ld - expected %ld\n", v1);
  sub_100004A64();
}

void sub_100065A9C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000495C0();
  sub_1000495B0((void *)&_mh_execute_header, v0, v1, "invalid header length for vpnctl unbind cmd - len=%ld - expected %ld\n", v2, v3, v4, v5, v6);
  sub_100004A64();
}

void sub_100065AFC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100049654();
  sub_1000495B0((void *)&_mh_execute_header, v0, v1, "invalid header length for vpnctl redirect cmd - len=%ld - expected %ld\n", v2, v3, v4, v5, v6);
  sub_100004A64();
}

void sub_100065B64()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "cannot allcoate memory for redirect address.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100065B90()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000495C0();
  sub_1000495B0((void *)&_mh_execute_header, v0, v1, "invalid header length for vpnctl xauth info cmd - len=%ld - expected %ld\n", v2, v3, v4, v5, v6);
  sub_100004A64();
}

void sub_100065BF0()
{
  NSObject *v0;
  uint8_t v1[24];

  sub_100049614();
  sub_100027EC8((void *)&_mh_execute_header, v0, (uint64_t)v0, "invalid length for vpnctl xauth info cmd - len=%ld - expected %ld\n", v1);
  sub_100004A64();
}

void sub_100065C68()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000495F8();
  sub_1000495B0((void *)&_mh_execute_header, v0, v1, "invalid header length for vpnctl nat64 prefix cmd - len=%ld - expected %ld\n", v2, v3, v4, v5, v6);
  sub_100004A64();
}

void sub_100065CC8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000495C0();
  sub_1000495B0((void *)&_mh_execute_header, v0, v1, "invalid header length for vpnctl connect cmd - len=%ld - expected %ld\n", v2, v3, v4, v5, v6);
  sub_100004A64();
}

void sub_100065D28()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000495C0();
  sub_1000495B0((void *)&_mh_execute_header, v0, v1, "invalid header length for vpnctl disconnect cmd - len=%ld - expected %ld\n", v2, v3, v4, v5, v6);
  sub_100004A64();
}

void sub_100065D88()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000495F8();
  sub_1000495B0((void *)&_mh_execute_header, v0, v1, "invalid header length for vpnctl start ph2 cmd - len=%ld - expected %ld\n", v2, v3, v4, v5, v6);
  sub_100004A64();
}

void sub_100065DE8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000495C0();
  sub_1000495B0((void *)&_mh_execute_header, v0, v1, "invalid header length for vpnctl start dpd cmd - len=%ld - expected %ld\n", v2, v3, v4, v5, v6);
  sub_100004A64();
}

void sub_100065E48()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000495DC();
  sub_1000495B0((void *)&_mh_execute_header, v0, v1, "invalid header length for vpnctl assert cmd - len=%ld - expected %ld\n", v2, v3, v4, v5, v6);
  sub_100004A64();
}

void sub_100065EA8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000495C0();
  sub_1000495B0((void *)&_mh_execute_header, v0, v1, "invalid header length for vpnctl reconnect cmd - len=%ld - expected %ld\n", v2, v3, v4, v5, v6);
  sub_100004A64();
}

void sub_100065F08()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "unable to allocate space for vpn control message.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100065F34()
{
  NSObject *v0;
  uint8_t *v1;
  int *v2;
  char *v3;

  v2 = sub_100007E80();
  v3 = sub_100007E40(v2);
  sub_10001C914((uint64_t)v3, 4.8149e-34);
  sub_10003D37C((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "failed to send vpn_control need authinfo status: %s\n", v1);
  sub_100007E9C();
}

void sub_100065F80()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "unable to allcate memory for vpn control status message.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100065FAC()
{
  NSObject *v0;
  uint8_t *v1;
  int *v2;
  char *v3;

  v2 = sub_100007E80();
  v3 = sub_100007E40(v2);
  sub_10001C914((uint64_t)v3, 4.8149e-34);
  sub_10003D37C((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "Unable to send vpn_control ike notify failed: %s\n", v1);
  sub_100007E9C();
}

void sub_100065FF8(unsigned __int16 a1, __int16 a2, os_log_t log)
{
  const char *v3;
  _DWORD v4[2];
  __int16 v5;
  const char *v6;

  v3 = "remote";
  if (!a2)
    v3 = "local";
  v4[0] = 67109378;
  v4[1] = a1;
  v5 = 2080;
  v6 = v3;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "sending vpn_control ike failed message - code=%d  from=%s.\n", (uint8_t *)v4, 0x12u);
  sub_100004A64();
}

void sub_100066094()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "bad address for ph2 status change.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000660C0()
{
  NSObject *v0;
  uint8_t *v1;
  int *v2;
  char *v3;

  v2 = sub_100007E80();
  v3 = sub_100007E40(v2);
  sub_10001C914((uint64_t)v3, 4.8149e-34);
  sub_10003D37C((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "failed to send vpn_control phase change status: %s\n", v1);
  sub_100007E9C();
}

void sub_10006610C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "bad address for ph1 status change.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100066138()
{
  NSObject *v0;
  uint8_t *v1;
  int *v2;
  char *v3;

  v2 = sub_100007E80();
  v3 = sub_100007E40(v2);
  sub_10001C914((uint64_t)v3, 4.8149e-34);
  sub_10003D37C((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "unable to send vpn_control status (peer response): %s\n", v1);
  sub_100007E9C();
}

void sub_100066184()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  v0 = sub_100007EA8();
  sub_100007E40(v0);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "socket: %s\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_1000661F0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "could not create vpncontrol socket source.", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_10006621C(NSObject *a1)
{
  int *v2;
  uint64_t v3;
  int v4[6];

  v2 = sub_100007EA8();
  sub_100007E40(v2);
  v4[0] = 136315394;
  sub_10004962C();
  sub_100027EC8((void *)&_mh_execute_header, a1, v3, "listen(sockname:%s): %s\n", (uint8_t *)v4);
  sub_100005D4C();
}

void sub_10006629C(NSObject *a1)
{
  int *v2;
  uint64_t v3;
  int v4[4];
  __int16 v5;
  uint64_t v6;

  v2 = __error();
  sub_100007E40(v2);
  v4[0] = 136315650;
  sub_100049640();
  v5 = 2080;
  v6 = v3;
  _os_log_error_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_ERROR, "chmod(%s, 0%03o): %s\n", (uint8_t *)v4, 0x1Cu);
}

void sub_100066344(NSObject *a1)
{
  int v2;
  int *v3;
  __int16 v4;
  uint64_t v5;
  int v6[4];
  __int16 v7;
  int v8;
  __int16 v9;
  uint64_t v10;

  v2 = dword_10008C6CC;
  v3 = __error();
  sub_100007E40(v3);
  v6[0] = 136315906;
  sub_100049640();
  v7 = v4;
  v8 = v2;
  v9 = 2080;
  v10 = v5;
  _os_log_error_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_ERROR, "chown(%s, %d, %d): %s\n", (uint8_t *)v6, 0x22u);
}

void sub_100066404(NSObject *a1)
{
  int *v2;
  uint64_t v3;
  int v4[6];

  v2 = sub_100007EA8();
  sub_100007E40(v2);
  v4[0] = 136315394;
  sub_10004962C();
  sub_100027EC8((void *)&_mh_execute_header, a1, v3, "bind(sockname:%s): %s\n", (uint8_t *)v4);
  sub_100005D4C();
}

void sub_100066484()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to put VPN-Control socket in non-blocking mode\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000664B0(int a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  strerror(a1);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "failed to launch_activate_socket with error %s.\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_10006651C(const sockaddr *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10003C8A0(a1);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "no configuration found for %s\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_100066588()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "cannot get local address\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000665B4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to duplicate address\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000665E0(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100004A84((void *)&_mh_execute_header, a2, a3, "invalid family: %d\n", a5, a6, a7, a8, 0);
  sub_100003F14();
}

void sub_100066648()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to duplicate local address\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100066674()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Cannot start Phase 2 - no Phase 1 found.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000666A0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Cannot start Phase 2 - Phase 1 not established.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000666CC()
{
  uint64_t v0;
  os_log_t v1;
  uint64_t v2;
  uint64_t v3;

  sub_10004A758();
  sub_10002E468((void *)&_mh_execute_header, v0, v1, "invalid length for vpn ph2 selector - len=%ld - expected %ld\n", v2, v3);
}

void sub_100066730()
{
  uint64_t v0;
  os_log_t v1;
  uint64_t v2;
  uint64_t v3;

  sub_10004A758();
  sub_10002E468((void *)&_mh_execute_header, v0, v1, "invalid length for vpn ph2 algo - len=%ld - expected %ld\n", v2, v3);
}

void sub_100066794()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Unable to allocate sainfo struct.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000667C0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Unable to allocate id struct.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000667EC(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10004A770(a1);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "No encryption algorithm at %s\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_100066854(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10004A770(a1);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "No authentication algorithm at %s\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_1000668BC(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10004A770(a1);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "No compression algorithm at %s\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_100066924(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10004A770(a1);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v1, v2, "Duplicated sainfo: %s\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_10006698C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Failed to allocate algorithm structure\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000669B8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Algorithm mismatched\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000669E4(int a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_10003DF24(a1, a2);
  sub_100012054();
  sub_100014F40((void *)&_mh_execute_header, v2, v3, "Algorithm %s not supported by the kernel (missing module?)\n", v4, v5, v6, v7, v8);
  sub_100005D4C();
}

void sub_100066A50()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "keylen not allowed\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100066A7C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100004A84((void *)&_mh_execute_header, a2, a3, "invalid keylen %d\n", a5, a6, a7, a8, 0);
  sub_100003F14();
}

void sub_100066AE0(uint8_t *a1, uint64_t a2, _DWORD *a3, NSObject *a4)
{
  int v4;

  v4 = *(_DWORD *)(*(_QWORD *)a2 + 188);
  *(_DWORD *)a1 = 67109120;
  *a3 = v4;
  sub_10004A778((void *)&_mh_execute_header, "Using dh group %d for aggressive mode\n", a1, a4);
}

void sub_100066B24(uint8_t *a1, uint64_t a2, _DWORD *a3, NSObject *a4)
{
  int v4;

  v4 = *(_DWORD *)(*(_QWORD *)a2 + 60);
  *(_DWORD *)a1 = 67109120;
  *a3 = v4;
  sub_10004A778((void *)&_mh_execute_header, "Using dh group %d for main mode\n", a1, a4);
}

void sub_100066B68()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Invalid dh group specified\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100066B94()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Unable to find address structure.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100066BC0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Failed to allocate space for message.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100066BEC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Cannot reply to xauth request - no ph1 found.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100066C18()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Received xauth reply data with no xauth reply pending \n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100066C44()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Cannot allocate memory for xauth reply\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100066C70()
{
  os_log_t v0;
  uint8_t v1[16];

  sub_100003F1C();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Sending MODE_CFG REPLY\n", v1, 2u);
  sub_100003F14();
}

void sub_100066CA8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Invalid auth info received from VPN Control socket.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100066CD4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Cannot assert - no matching session.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100066D00(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "Invalid parameters in %s.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100066D70(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "invalid parameters in %s.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100066DE0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "invalid parameters in %s.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100066E50(const sockaddr *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10003C570(a1 + 8);
  sub_100012054();
  sub_100007E48((void *)&_mh_execute_header, v1, v2, "New IKE-Session to %s.\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_100066EC0(const sockaddr *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10003D384(a1);
  sub_100012054();
  sub_100007E48((void *)&_mh_execute_header, v1, v2, "Pre-existing IKE-Session to %s. case 1.\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_100066F28(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10003C570((const sockaddr *)(a1 + 136));
  sub_100012054();
  sub_100007E48((void *)&_mh_execute_header, v1, v2, "Best-match IKE-Session to %s.\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_100066F98(const sockaddr *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10003D384(a1);
  sub_100012054();
  sub_100007E48((void *)&_mh_execute_header, v1, v2, "Pre-existing IKE-Session to %s. case 2.\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_100067000(const sockaddr *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10003D384(a1);
  sub_100012054();
  sub_100007E48((void *)&_mh_execute_header, v1, v2, "Pre-existing IKE-Session to %s. case 3.\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_100067068(uint8_t *a1, uint64_t a2, uint64_t **a3, NSObject *a4)
{
  uint64_t *v7;

  v7 = sub_10003C570((const sockaddr *)(a2 + 136));
  *(_DWORD *)a1 = 136315138;
  *a3 = v7;
  _os_log_debug_impl((void *)&_mh_execute_header, a4, OS_LOG_TYPE_DEBUG, "still search for IKE-Session. this %s.\n", a1, 0xCu);
}

void sub_1000670D0(const sockaddr *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10003D384(a1);
  sub_100012054();
  sub_100007E48((void *)&_mh_execute_header, v1, v2, "start search for IKE-Session. target %s.\n", v3, v4, v5, v6, v7);
  sub_100005D4C();
}

void sub_100067138(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "invalid parameters in %s.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_1000671A8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "invalid parameters in %s.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100067218(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "Invalid parameters in %s.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100067288(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "Phase 2 already linked to session %s.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_1000672F8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "Invalid parameters in %s.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100067368(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "Phase 2 already linked %s.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_1000673D8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "Phase 2 already bound %s.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100067448(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "invalid parameters in %s.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_1000674B8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "invalid parameters in %s.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100067528(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "invalid parameters in %s.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100067598(uint8_t *buf, _QWORD *a2, os_log_t log)
{
  *(_DWORD *)buf = 136315138;
  *a2 = "ike_session_rebind_all_ph12_to_new_ph1";
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Same Phase 2 in ph1bind replacement in %s.\n", buf, 0xCu);
}

void sub_1000675E4(uint8_t *buf, _BYTE *a2, os_log_t log)
{
  *buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Mismatched parent session in ph1bind replacement.\n", buf, 2u);
}

void sub_100067620(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "Invalid parent sessions in %s.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100067690(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "invalid parameters in %s.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100067700(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "invalid parameters in %s.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100067770(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "invalid parameters in %s.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_1000677E0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "invalid parameters in %s.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100067850(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "invalid parameters in %s.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_1000678C0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "invalid parameters in %s.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100067930(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "invalid parameters in %s.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_1000679A0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "invalid parameters in %s.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100067A10(int *a1, uint64_t a2, os_log_t log)
{
  int v3;
  int v4;
  int v5;
  _DWORD v6[2];
  __int16 v7;
  int v8;
  __int16 v9;
  int v10;

  v3 = *a1;
  v4 = *(_DWORD *)(a2 + 100);
  v5 = *(unsigned __int8 *)(a2 + 264) << 30 >> 31;
  v6[0] = 67109632;
  v6[1] = v3;
  v7 = 1024;
  v8 = v4;
  v9 = 1024;
  v10 = v5;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "about to cleanup ph2: status %d, seq %d dying %d\n", (uint8_t *)v6, 0x14u);
  sub_100004A64();
}

void sub_100067AAC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "invalid parameters in %s.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100067B1C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "invalid parameters in %s.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100067B8C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "invalid parameters in %s.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100067BFC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "invalid parameters in %s.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100067C6C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "invalid args in %s.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100067CDC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "invalid args in %s.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100067D4C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "invalid parameters in %s.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100067DBC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "invalid parameters in %s.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100067E2C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "invalid parameters in %s.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100067E9C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "invalid parameters in %s.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100067F0C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "invalid parameters in %s.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100067F7C(unsigned __int8 *a1, NSObject *a2)
{
  int v2;
  int v3;
  int v4;
  const char *v5;
  __int16 v6;
  int v7;
  __int16 v8;
  int v9;

  v2 = *a1;
  v3 = *((unsigned __int16 *)a1 + 1);
  v4 = 136315650;
  v5 = "ike_session_is_id_portany";
  v6 = 1024;
  v7 = v2;
  v8 = 1024;
  v9 = v3;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "not portany_ids in %s: type %d, port %x.\n", (uint8_t *)&v4, 0x18u);
  sub_100004A64();
}

void sub_100068010()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_10003D38C();
  sub_100015A44((void *)&_mh_execute_header, v0, v1, "%s: pre-assigned spid %d.\n", v2, v3, v4, v5, 2u);
  sub_100004A64();
}

void sub_100068080(NSObject *a1, uint64_t a2, uint64_t a3)
{
  int v3;
  const char *v4;

  v3 = 136315138;
  v4 = "ike_session_get_sainfo_r";
  sub_100033620((void *)&_mh_execute_header, a1, a3, "candidate ph2 matched in %s.\n", (uint8_t *)&v3);
  sub_100004A64();
}

void sub_1000680F4(uint8_t *a1, _QWORD *a2, NSObject *a3)
{
  *(_DWORD *)a1 = 136315138;
  *a2 = "ike_session_get_sainfo_r";
  sub_100033620((void *)&_mh_execute_header, a3, (uint64_t)a3, "candidate ph2 found in %s.\n", a1);
}

void sub_100068138()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10004F0F0();
  sub_100015A44((void *)&_mh_execute_header, v0, v1, "ipany_ids %d in %s.\n", v2, v3, v4, v5, v6);
  sub_100004A64();
}

void sub_1000681A4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_10003D38C();
  sub_100015A44((void *)&_mh_execute_header, v0, v1, "%s: pre-assigned spid %d.\n", v2, v3, v4, v5, 2u);
  sub_100004A64();
}

void sub_100068214(NSObject *a1, uint64_t a2, uint64_t a3)
{
  int v3;
  const char *v4;

  v3 = 136315138;
  v4 = "ike_session_get_proposal_r";
  sub_100033620((void *)&_mh_execute_header, a1, a3, "candidate ph2 matched in %s.\n", (uint8_t *)&v3);
  sub_100004A64();
}

void sub_100068288(uint8_t *a1, _QWORD *a2, NSObject *a3)
{
  *(_DWORD *)a1 = 136315138;
  *a2 = "ike_session_get_proposal_r";
  sub_100033620((void *)&_mh_execute_header, a3, (uint64_t)a3, "candidate ph2 found in %s.\n", a1);
}

void sub_1000682CC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10004F0F0();
  sub_100015A44((void *)&_mh_execute_header, v0, v1, "ipany_ids %d in %s.\n", v2, v3, v4, v5, v6);
  sub_100004A64();
}

void sub_100068338(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "invalid parameters in %s.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_1000683A8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "invalid parameters in %s.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100068418(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100015A54((void *)&_mh_execute_header, a1, a3, "invalid parameters in %s.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100068488(unsigned __int8 *a1, NSObject *a2)
{
  int v2;
  int v3;
  int v4;
  int v5;
  const char *v6;
  __int16 v7;
  int v8;
  __int16 v9;
  int v10;
  __int16 v11;
  int v12;

  v2 = *a1;
  v3 = *((_DWORD *)a1 + 1);
  v4 = *((_DWORD *)a1 + 2);
  v5 = 136315906;
  v6 = "ike_session_is_id_ipany";
  v7 = 1024;
  v8 = v2;
  v9 = 1024;
  v10 = v3;
  v11 = 1024;
  v12 = v4;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "not ipany_ids in %s: type %d, addr %x, mask %x.\n", (uint8_t *)&v5, 0x1Eu);
}

void sub_100068528()
{
  os_log_t v0;
  uint8_t v1[16];

  sub_100003F1C();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "IORegisterForSystemPower failed for power-mgmt thread\n", v1, 2u);
  sub_100003F14();
}

void sub_100068560(int a1, NSObject *a2)
{
  _DWORD v2[2];

  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "received power-mgmt event: %x\n", (uint8_t *)v2, 8u);
  sub_100003F14();
}

void sub_1000685D0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "received power-mgmt event: will sleep\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000685FC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "received power-mgmt event: will not sleep\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100068628()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "received power-mgmt event: will wake\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100068654()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "received power-mgmt event: will power-on\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100068680()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "received power-mgmt event: has powered-on\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000686AC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "received power-mgmt event: has woken\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000686D8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "handling power-mgmt event: sleep-wake\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100068704()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100005D10((void *)&_mh_execute_header, v0, v1, "handling power-mgmt event: power-on\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100068730()
{
  errx(1, "failed to initialize dispatch queue.\n");
}

void sub_100068748()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100012054();
  sub_100015A54((void *)&_mh_execute_header, v0, v1, "xpc connection invalid %s.\n", v2, v3, v4, v5, v6);
  sub_100004A64();
}

void sub_1000687A8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100012054();
  sub_100015A54((void *)&_mh_execute_header, v0, v1, "xpc connection interrupted %s.\n", v2, v3, v4, v5, v6);
  sub_100004A64();
}

void sub_100068808(int a1, uint64_t a2, os_log_t log)
{
  _DWORD v3[2];
  __int16 v4;
  uint64_t v5;

  v3[0] = 67109378;
  v3[1] = a1;
  v4 = 2080;
  v5 = a2;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "xpc connection error %d:%s.\n", (uint8_t *)v3, 0x12u);
  sub_100004A64();
}

void sub_100068888()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "load_XPC_Service received type == XPC_TYPE_ERROR\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000688B4(int a1, NSObject *a2)
{
  _DWORD v2[2];

  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "xpc connection unknown type %x.\n", (uint8_t *)v2, 8u);
  sub_100003F14();
}

void sub_100068924()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100012054();
  sub_100015A54((void *)&_mh_execute_header, v0, v1, "xpc connection unknown client opcode %lld\n", v2, v3, v4, v5, v6);
  sub_100004A64();
}

void sub_100068984()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "do_ipsecike_create error\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000689B0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "SecTaskCreateWithAuditToken() failed\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_1000689DC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Entitlement not valid\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100068A08()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "xpc_ike_dict == NULL\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100068A34()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "do_ipsecike_create child_dict == NULL\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100068A60()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "do_ipsecike_create ike_dict == NULL\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100068A8C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "Entitlement type not valid\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100068AB8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "send_xpc_reply xpc_dictionary_get_remote_connection failed\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100068AE4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "create_reply failed\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100068B10()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "do_ipsecike_stop: ikeid == kInternalIKESARefInvalid\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100068B3C()
{
  os_log_t v0;
  uint8_t v1[24];

  sub_100012054();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "xpc connection wrong XPC type %s.\n", v1, 0xCu);
  sub_100004A64();
}

void sub_100068BA8()
{
  os_log_t v0;
  uint8_t v1[16];

  sub_100003F1C();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "xpc connection unknown XPC type\n", v1, 2u);
  sub_100003F14();
}

void sub_100068BE0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "failed to expand isakmp proposal.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100068C0C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "no proposal found.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100068C38(uint8_t *a1, _BYTE *a2, NSObject *a3)
{
  *a1 = 0;
  *a2 = 0;
  sub_100011FA0((void *)&_mh_execute_header, a3, (uint64_t)a3, "\n", a1);
}

void sub_100068C6C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "multiple proposal definition.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100068C98()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[16];

  sub_100003F1C();
  sub_100011FA0((void *)&_mh_execute_header, v0, v1, "parse succeeded.\n", v2);
  sub_100003F14();
}

void sub_100068CC8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100004A84((void *)&_mh_execute_header, a1, a3, "parse error is nothing, but yyerrorcount is %d.\n", a5, a6, a7, a8, 0);
  sub_100003F14();
}

void sub_100068D3C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "fatal parse failure.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100068D68(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100004A84((void *)&_mh_execute_header, a1, a3, "fatal parse failure (%d errors)\n", a5, a6, a7, a8, 0);
  sub_100003F14();
}

void sub_100068DDC(os_log_t log)
{
  uint64_t v1;
  int v2;
  uint64_t v3;

  v1 = *(_QWORD *)qword_10008B848;
  v2 = 136315138;
  v3 = v1;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "could not read configuration file \"%s\"\n", (uint8_t *)&v2, 0xCu);
  sub_100004A64();
}

void sub_100068E60()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[16];

  sub_100003F1C();
  sub_100011FA0((void *)&_mh_execute_header, v0, v1, "===== parsing configuration\n", v2);
  sub_100003F14();
}

void sub_100068E90(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100004A54((void *)&_mh_execute_header, a2, a3, "==== %s sessions.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100068F0C(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100004A54((void *)&_mh_execute_header, a2, a3, "==== Got %s signal - re-parsing configuration.\n", a5, a6, a7, a8, 2u);
  sub_100004A64();
}

void sub_100068F7C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100003F1C();
  sub_100003F04((void *)&_mh_execute_header, v0, v1, "==== Got Unknown signal - re-parsing configuration.\n", v2, v3, v4, v5, v6);
  sub_100003F14();
}

void sub_100068FA8(uint64_t a1, NSObject *a2)
{
  int *v4;
  char *v5;
  int v6;
  uint64_t v7;
  __int16 v8;
  char *v9;

  v4 = __error();
  v5 = strerror(*v4);
  v6 = 136315394;
  v7 = a1;
  v8 = 2080;
  v9 = v5;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "failed to open file %s (%s)\n", (uint8_t *)&v6, 0x16u);
  sub_10005509C();
}

void sub_100069044(uint64_t a1, NSObject *a2)
{
  int v2;
  uint64_t v3;

  v2 = 136315138;
  v3 = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "reading configuration file %s\n", (uint8_t *)&v2, 0xCu);
}

void sub_1000690B8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000550A4();
  sub_100055068();
  sub_10005508C((void *)&_mh_execute_header, v0, v1, "%s:%d: %s\n", v2, v3, v4, v5, v6);
  sub_10005509C();
}

void sub_100069124(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100003F04((void *)&_mh_execute_header, a1, a3, "Includes nested too deeply", a5, a6, a7, a8, 0);
}
